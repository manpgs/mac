<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Vector(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Vector(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Vector(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Bit::Vector - Efficient bit vector, set of integers and &quot;big
    int&quot; math library</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<section class="Ss">
<h2 class="Ss">OVERLOADED OPERATORS</h2>
<p class="Pp">See <b>Bit::Vector::Overload</b>(3).</p>
</section>
<section class="Ss">
<h2 class="Ss">MORE STRING IMPORT/EXPORT</h2>
<p class="Pp">See <b>Bit::Vector::String</b>(3).</p>
</section>
<section class="Ss">
<h2 class="Ss">CLASS METHODS</h2>
<pre>
  Version
      $version = Bit::Vector-&gt;Version();

  Word_Bits
      $bits = Bit::Vector-&gt;Word_Bits();  #  bits in a machine word

  Long_Bits
      $bits = Bit::Vector-&gt;Long_Bits();  #  bits in an unsigned long

  new
      $vector = Bit::Vector-&gt;new($bits);  #  bit vector constructor

      @veclist = Bit::Vector-&gt;new($bits,$count);

  new_Hex
      $vector = Bit::Vector-&gt;new_Hex($bits,$string);

  new_Bin
      $vector = Bit::Vector-&gt;new_Bin($bits,$string);

  new_Dec
      $vector = Bit::Vector-&gt;new_Dec($bits,$string);

  new_Enum
      $vector = Bit::Vector-&gt;new_Enum($bits,$string);

  Concat_List
      $vector = Bit::Vector-&gt;Concat_List(@vectors);
</pre>
</section>
<section class="Ss">
<h2 class="Ss">OBJECT METHODS</h2>
<pre>
  new
      $vec2 = $vec1-&gt;new($bits);  #  alternative call of constructor

      @veclist = $vec-&gt;new($bits,$count);

  Shadow
      $vec2 = $vec1-&gt;Shadow();  #  new vector, same size but empty

  Clone
      $vec2 = $vec1-&gt;Clone();  #  new vector, exact duplicate

  Concat
      $vector = $vec1-&gt;Concat($vec2);

  Concat_List
      $vector = $vec1-&gt;Concat_List($vec2,$vec3,...);

  Size
      $bits = $vector-&gt;Size();

  Resize
      $vector-&gt;Resize($bits);
      $vector-&gt;Resize($vector-&gt;Size()+5);
      $vector-&gt;Resize($vector-&gt;Size()-5);

  Copy
      $vec2-&gt;Copy($vec1);

  Empty
      $vector-&gt;Empty();

  Fill
      $vector-&gt;Fill();

  Flip
      $vector-&gt;Flip();

  Primes
      $vector-&gt;Primes();  #  Sieve of Erathostenes

  Reverse
      $vec2-&gt;Reverse($vec1);

  Interval_Empty
      $vector-&gt;Interval_Empty($min,$max);

  Interval_Fill
      $vector-&gt;Interval_Fill($min,$max);

  Interval_Flip
      $vector-&gt;Interval_Flip($min,$max);

  Interval_Reverse
      $vector-&gt;Interval_Reverse($min,$max);

  Interval_Scan_inc
      if (($min,$max) = $vector-&gt;Interval_Scan_inc($start))

  Interval_Scan_dec
      if (($min,$max) = $vector-&gt;Interval_Scan_dec($start))

  Interval_Copy
      $vec2-&gt;Interval_Copy($vec1,$offset2,$offset1,$length);

  Interval_Substitute
      $vec2-&gt;Interval_Substitute($vec1,$off2,$len2,$off1,$len1);

  is_empty
      if ($vector-&gt;is_empty())

  is_full
      if ($vector-&gt;is_full())

  equal
      if ($vec1-&gt;equal($vec2))

  Lexicompare (unsigned)
      if ($vec1-&gt;Lexicompare($vec2) == 0)
      if ($vec1-&gt;Lexicompare($vec2) != 0)
      if ($vec1-&gt;Lexicompare($vec2) &lt;  0)
      if ($vec1-&gt;Lexicompare($vec2) &lt;= 0)
      if ($vec1-&gt;Lexicompare($vec2) &gt;  0)
      if ($vec1-&gt;Lexicompare($vec2) &gt;= 0)

  Compare (signed)
      if ($vec1-&gt;Compare($vec2) == 0)
      if ($vec1-&gt;Compare($vec2) != 0)
      if ($vec1-&gt;Compare($vec2) &lt;  0)
      if ($vec1-&gt;Compare($vec2) &lt;= 0)
      if ($vec1-&gt;Compare($vec2) &gt;  0)
      if ($vec1-&gt;Compare($vec2) &gt;= 0)

  to_Hex
      $string = $vector-&gt;to_Hex();

  from_Hex
      $vector-&gt;from_Hex($string);

  to_Bin
      $string = $vector-&gt;to_Bin();

  from_Bin
      $vector-&gt;from_Bin($string);

  to_Dec
      $string = $vector-&gt;to_Dec();

  from_Dec
      $vector-&gt;from_Dec($string);

  to_Enum
      $string = $vector-&gt;to_Enum();  #  e.g. &quot;2,3,5-7,11,13-19&quot;

  from_Enum
      $vector-&gt;from_Enum($string);

  Bit_Off
      $vector-&gt;Bit_Off($index);

  Bit_On
      $vector-&gt;Bit_On($index);

  bit_flip
      $bit = $vector-&gt;bit_flip($index);

  bit_test
  contains
      $bit = $vector-&gt;bit_test($index);
      $bit = $vector-&gt;contains($index);
      if ($vector-&gt;bit_test($index))
      if ($vector-&gt;contains($index))

  Bit_Copy
      $vector-&gt;Bit_Copy($index,$bit);

  LSB (least significant bit)
      $vector-&gt;LSB($bit);

  MSB (most significant bit)
      $vector-&gt;MSB($bit);

  lsb (least significant bit)
      $bit = $vector-&gt;lsb();

  msb (most significant bit)
      $bit = $vector-&gt;msb();

  rotate_left
      $carry = $vector-&gt;rotate_left();

  rotate_right
      $carry = $vector-&gt;rotate_right();

  shift_left
      $carry = $vector-&gt;shift_left($carry);

  shift_right
      $carry = $vector-&gt;shift_right($carry);

  Move_Left
      $vector-&gt;Move_Left($bits);  #  shift left &quot;$bits&quot; positions

  Move_Right
      $vector-&gt;Move_Right($bits);  #  shift right &quot;$bits&quot; positions

  Insert
      $vector-&gt;Insert($offset,$bits);

  Delete
      $vector-&gt;Delete($offset,$bits);

  increment
      $carry = $vector-&gt;increment();

  decrement
      $carry = $vector-&gt;decrement();

  inc
      $overflow = $vec2-&gt;inc($vec1);

  dec
      $overflow = $vec2-&gt;dec($vec1);

  add
      $carry = $vec3-&gt;add($vec1,$vec2,$carry);
      ($carry,$overflow) = $vec3-&gt;add($vec1,$vec2,$carry);

  subtract
      $carry = $vec3-&gt;subtract($vec1,$vec2,$carry);
      ($carry,$overflow) = $vec3-&gt;subtract($vec1,$vec2,$carry);

  Neg
  Negate
      $vec2-&gt;Neg($vec1);
      $vec2-&gt;Negate($vec1);

  Abs
  Absolute
      $vec2-&gt;Abs($vec1);
      $vec2-&gt;Absolute($vec1);

  Sign
      if ($vector-&gt;Sign() == 0)
      if ($vector-&gt;Sign() != 0)
      if ($vector-&gt;Sign() &lt;  0)
      if ($vector-&gt;Sign() &lt;= 0)
      if ($vector-&gt;Sign() &gt;  0)
      if ($vector-&gt;Sign() &gt;= 0)

  Multiply
      $vec3-&gt;Multiply($vec1,$vec2);

  Divide
      $quot-&gt;Divide($vec1,$vec2,$rest);

  GCD (Greatest Common Divisor)
      $vecgcd-&gt;GCD($veca,$vecb);
      $vecgcd-&gt;GCD($vecx,$vecy,$veca,$vecb);

  Power
      $vec3-&gt;Power($vec1,$vec2);

  Block_Store
      $vector-&gt;Block_Store($buffer);

  Block_Read
      $buffer = $vector-&gt;Block_Read();

  Word_Size
      $size = $vector-&gt;Word_Size();  #  number of words in &quot;$vector&quot;

  Word_Store
      $vector-&gt;Word_Store($offset,$word);

  Word_Read
      $word = $vector-&gt;Word_Read($offset);

  Word_List_Store
      $vector-&gt;Word_List_Store(@words);

  Word_List_Read
      @words = $vector-&gt;Word_List_Read();

  Word_Insert
      $vector-&gt;Word_Insert($offset,$count);

  Word_Delete
      $vector-&gt;Word_Delete($offset,$count);

  Chunk_Store
      $vector-&gt;Chunk_Store($chunksize,$offset,$chunk);

  Chunk_Read
      $chunk = $vector-&gt;Chunk_Read($chunksize,$offset);

  Chunk_List_Store
      $vector-&gt;Chunk_List_Store($chunksize,@chunks);

  Chunk_List_Read
      @chunks = $vector-&gt;Chunk_List_Read($chunksize);

  Index_List_Remove
      $vector-&gt;Index_List_Remove(@indices);

  Index_List_Store
      $vector-&gt;Index_List_Store(@indices);

  Index_List_Read
      @indices = $vector-&gt;Index_List_Read();

  Or
  Union
      $vec3-&gt;Or($vec1,$vec2);
      $set3-&gt;Union($set1,$set2);

  And
  Intersection
      $vec3-&gt;And($vec1,$vec2);
      $set3-&gt;Intersection($set1,$set2);

  AndNot
  Difference
      $vec3-&gt;AndNot($vec1,$vec2);
      $set3-&gt;Difference($set1,$set2);

  Xor
  ExclusiveOr
      $vec3-&gt;Xor($vec1,$vec2);
      $set3-&gt;ExclusiveOr($set1,$set2);

  Not
  Complement
      $vec2-&gt;Not($vec1);
      $set2-&gt;Complement($set1);

  subset
      if ($set1-&gt;subset($set2))  #  true if $set1 is subset of $set2

  Norm
      $norm = $set-&gt;Norm();
      $norm = $set-&gt;Norm2();
      $norm = $set-&gt;Norm3();

  Min
      $min = $set-&gt;Min();

  Max
      $max = $set-&gt;Max();

  Multiplication
      $matrix3-&gt;Multiplication($rows3,$cols3,
                      $matrix1,$rows1,$cols1,
                      $matrix2,$rows2,$cols2);

  Product
      $matrix3-&gt;Product($rows3,$cols3,
               $matrix1,$rows1,$cols1,
               $matrix2,$rows2,$cols2);

  Closure
      $matrix-&gt;Closure($rows,$cols);

  Transpose
      $matrix2-&gt;Transpose($rows2,$cols2,$matrix1,$rows1,$cols1);
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="IMPORTANT_NOTES"><a class="permalink" href="#IMPORTANT_NOTES">IMPORTANT
  NOTES</a></h1>
<ul class="Bl-bullet">
  <li>Method naming conventions
    <p class="Pp">Method names completely in lower case indicate a boolean
        return value.</p>
    <p class="Pp">(Except for the bit vector constructor method
        &quot;<span class="Li">&quot;new()&quot;</span>&quot;, of course.)</p>
  </li>
  <li>Boolean values
    <p class="Pp">Boolean values in this module are always a numeric zero
        (&quot;<span class="Li">0</span>&quot;) for &quot;false&quot; and a
        numeric one (&quot;<span class="Li">1</span>&quot;) for
        &quot;true&quot;.</p>
  </li>
  <li>Negative numbers
    <p class="Pp">All numeric input parameters passed to any of the methods in
        this module are regarded as being <b>UNSIGNED</b> (as opposed to the
        contents of the bit vectors themselves, which are usually considered to
        be <b>SIGNED</b>).</p>
    <p class="Pp">As a consequence, whenever you pass a negative number as an
        argument to some method of this module, it will be treated as a (usually
        very large) positive number due to its internal two's complement binary
        representation, usually resulting in an &quot;index out of range&quot;
        error message and program abortion.</p>
  </li>
  <li>Bit order
    <p class="Pp">Note that bit vectors are stored least order bit and least
        order word first internally.</p>
    <p class="Pp">I.e., bit #0 of any given bit vector corresponds to bit #0 of
        word #0 in the array of machine words representing the bit vector.</p>
    <p class="Pp">(Where word #0 comes first in memory, i.e., it is stored at
        the least memory address in the allocated block of memory holding the
        given bit vector.)</p>
    <p class="Pp">Note however that machine words can be stored least order byte
        first or last, depending on your system's implementation.</p>
    <p class="Pp">When you are exporting or importing a whole bit vector at once
        using the methods
        &quot;<span class="Li">&quot;Block_Read()&quot;</span>&quot; and
        &quot;<span class="Li">&quot;Block_Store()&quot;</span>&quot; (the only
        time in this module where this could make any difference), however, a
        conversion to and from &quot;least order byte first&quot; order is
        automatically supplied.</p>
    <p class="Pp">In other words, what
        &quot;<span class="Li">&quot;Block_Read()&quot;</span>&quot; provides
        and what &quot;<span class="Li">&quot;Block_Store()&quot;</span>&quot;
        expects is always in &quot;least order byte first&quot; order,
        regardless of the order in which words are stored internally on your
        machine.</p>
    <p class="Pp">This is to make sure that what you export on one machine using
        &quot;<span class="Li">&quot;Block_Read()&quot;</span>&quot; can always
        be read in correctly with
        &quot;<span class="Li">&quot;Block_Store()&quot;</span>&quot; on a
        different machine.</p>
    <p class="Pp">Note further that whenever bit vectors are converted to and
        from (binary or hexadecimal) strings, the <b>RIGHTMOST</b> bit is always
        the <b>LEAST SIGNIFICANT</b> one, and the <b>LEFTMOST</b> bit is always
        the <b>MOST SIGNIFICANT</b> bit.</p>
    <p class="Pp">This is because in our western culture, numbers are always
        represented in this way (least significant to most significant digits go
        from right to left).</p>
    <p class="Pp">Of course this requires an internal reversion of order, which
        the corresponding conversion methods perform automatically (without any
        additional overhead, it's just a matter of starting the internal loop at
        the bottom or the top end).</p>
  </li>
  <li>&quot;Word&quot; related methods
    <p class="Pp">Note that all methods whose names begin with
        &quot;<span class="Li">&quot;Word_&quot;</span>&quot; are
        <b>MACHINE-DEPENDENT</b>!</p>
    <p class="Pp">They depend on the size (number of bits) of an &quot;unsigned
        int&quot; (C type) on your machine.</p>
    <p class="Pp">Therefore, you should only use these methods if you are
        <b>ABSOLUTELY CERTAIN</b> that portability of your code is not an
      issue!</p>
    <p class="Pp">Note that you can use arbitrarily large chunks (i.e.,
        fragments of bit vectors) of up to 32 bits <b>IN A PORTABLE WAY</b>
        using the methods whose names begin with
        &quot;<span class="Li">&quot;Chunk_&quot;</span>&quot;.</p>
  </li>
  <li>Chunk sizes
    <p class="Pp">Note that legal chunk sizes for all methods whose names begin
        with &quot;<span class="Li">&quot;Chunk_&quot;</span>&quot; range from
        &quot;<span class="Li">1</span>&quot; to
        &quot;<span class="Li">&quot;Bit::Vector-&gt;Long_Bits();&quot;</span>&quot;
        bits (&quot;<span class="Li">0</span>&quot; is <b>NOT</b> allowed!).</p>
    <p class="Pp">In order to make your programs portable, however, you
        shouldn't use chunk sizes larger than 32 bits, since this is the minimum
        size of an &quot;unsigned long&quot; (C type) on all systems, as
        prescribed by ANSI&#x00A0;C.</p>
  </li>
  <li>Matching sizes
    <p class="Pp">In general, for methods involving several bit vectors at the
        same time, all bit vector arguments must have identical sizes (number of
        bits), or a fatal &quot;size mismatch&quot; error will occur.</p>
    <p class="Pp">Exceptions from this rule are the methods
        &quot;<span class="Li">&quot;Concat()&quot;</span>&quot;,
        &quot;<span class="Li">&quot;Concat_List()&quot;</span>&quot;,
        &quot;<span class="Li">&quot;Copy()&quot;</span>&quot;,
        &quot;<span class="Li">&quot;Interval_Copy()&quot;</span>&quot; and
        &quot;<span class="Li">&quot;Interval_Substitute()&quot;</span>&quot;,
        where no conditions at all are imposed on the size of their bit vector
        arguments.</p>
    <p class="Pp">In method
        &quot;<span class="Li">&quot;Multiply()&quot;</span>&quot;, all three
        bit vector arguments must in principle obey the rule of matching sizes,
        but the bit vector in which the result of the multiplication is to be
        stored may be larger than the two bit vector arguments containing the
        factors for the multiplication.</p>
    <p class="Pp">In method
        &quot;<span class="Li">&quot;Power()&quot;</span>&quot;, the bit vector
        for the result must be the same size or greater than the base of the
        exponentiation term. The exponent can be any size.</p>
  </li>
  <li>Index ranges
    <p class="Pp">All indices for any given bits must lie between
        &quot;<span class="Li">0</span>&quot; and
        &quot;<span class="Li">&quot;$vector-&gt;Size()-1&quot;</span>&quot;, or
        a fatal &quot;index out of range&quot; error will occur.</p>
  </li>
  <li>Object persistence
    <p class="Pp">Since version 6.5, &quot;Bit::Vector&quot; objects can be
        serialized and de-serialized automatically with &quot;Storable&quot;,
        out-of-the-box, without requiring any further user action for this to
        work.</p>
    <p class="Pp">This is also true for nested data structures (since version
        6.8).</p>
    <p class="Pp">See the <b>Storable</b>(3) documentation for more details.</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<section class="Ss">
<h2 class="Ss">OVERLOADED OPERATORS</h2>
<p class="Pp">See <b>Bit::Vector::Overload</b>(3).</p>
</section>
<section class="Ss">
<h2 class="Ss">MORE STRING IMPORT/EXPORT</h2>
<p class="Pp">See <b>Bit::Vector::String</b>(3).</p>
</section>
<section class="Ss">
<h2 class="Ss">CLASS METHODS</h2>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;$version = Bit::Vector-&gt;Version();&quot;</span>
    <p class="Pp">Returns the current version number of this module.</p>
  </li>
  <li><span class="Li">&quot;$bits = Bit::Vector-&gt;Word_Bits();&quot;</span>
    <p class="Pp">Returns the number of bits of an &quot;unsigned int&quot; (C
        type) on your machine.</p>
    <p class="Pp">(An &quot;unsigned int&quot; is also called a &quot;machine
        word&quot;, hence the name of this method.)</p>
  </li>
  <li><span class="Li">&quot;$bits = Bit::Vector-&gt;Long_Bits();&quot;</span>
    <p class="Pp">Returns the number of bits of an &quot;unsigned long&quot; (C
        type) on your machine.</p>
  </li>
  <li><span class="Li">&quot;$vector = Bit::Vector-&gt;new($bits);&quot;</span>
    <p class="Pp">This is the bit vector constructor method.</p>
    <p class="Pp">Call this method to create a new bit vector containing
        &quot;<span class="Li">$bits</span>&quot; bits (with indices ranging
        from &quot;<span class="Li">0</span>&quot; to
        &quot;<span class="Li">&quot;$bits-1&quot;</span>&quot;).</p>
    <p class="Pp">Note that - in contrast to previous versions - bit vectors of
        length zero (i.e., with <span class="Li">&quot;$bits = 0&quot;</span>)
        are permitted now.</p>
    <p class="Pp">The method returns a reference to the newly created bit
        vector.</p>
    <p class="Pp">A new bit vector is always initialized so that all bits are
        cleared (turned off).</p>
    <p class="Pp">An exception will be raised if the method is unable to
        allocate the necessary memory.</p>
    <p class="Pp">Note that if you specify a negative number for
        &quot;<span class="Li">$bits</span>&quot; it will be interpreted as a
        large positive number due to its internal two's complement binary
        representation.</p>
    <p class="Pp">In such a case, the bit vector constructor method will
        obediently attempt to create a bit vector of that size, probably
        resulting in an exception, as explained above.</p>
  </li>
  <li><span class="Li">&quot;@veclist =
      Bit::Vector-&gt;new($bits,$count);&quot;</span>
    <p class="Pp">You can also create more than one bit vector at a time if you
        specify the optional second parameter
        &quot;<span class="Li">$count</span>&quot;.</p>
    <p class="Pp">The method returns a list of
        &quot;<span class="Li">$count</span>&quot; bit vectors which all have
        the same number of bits &quot;<span class="Li">$bits</span>&quot; (and
        which are all initialized, i.e., all bits are cleared).</p>
    <p class="Pp">If &quot;<span class="Li">$count</span>&quot; is zero, an
        empty list is returned.</p>
    <p class="Pp">If &quot;<span class="Li">$bits</span>&quot; is zero, a list
        of null-sized bit vectors is returned.</p>
    <p class="Pp">Note again that if you specify a negative number for
        &quot;<span class="Li">$count</span>&quot; it will be interpreted as a
        large positive number due to its internal two's complement binary
        representation.</p>
    <p class="Pp">In such a case, the bit vector constructor method will
        obediently attempt to create that many bit vectors, probably resulting
        in an exception (&quot;out of memory&quot;).</p>
  </li>
  <li><span class="Li">&quot;$vector =
      Bit::Vector-&gt;new_Hex($bits,$string);&quot;</span>
    <p class="Pp">This method is an alternative constructor which allows you to
        create a new bit vector object (with
        &quot;<span class="Li">$bits</span>&quot; bits) and to initialize it all
        in one go.</p>
    <p class="Pp">The method internally first calls the bit vector constructor
        method &quot;<span class="Li">&quot;new()&quot;</span>&quot; and then
        passes the given string to the method
        &quot;<span class="Li">&quot;from_Hex()&quot;</span>&quot;.</p>
    <p class="Pp">However, this method is more efficient than performing these
        two steps separately: First because in this method, the memory area
        occupied by the new bit vector is not initialized to zeros (which is
        pointless in this case), and second because it saves you from the
        associated overhead of one additional method invocation.</p>
    <p class="Pp">An exception will be raised if the necessary memory cannot be
        allocated (see the description of the method
        &quot;<span class="Li">&quot;new()&quot;</span>&quot; immediately above
        for possible causes) or if the given string cannot be converted
        successfully (see the description of the method
        &quot;<span class="Li">&quot;from_Hex()&quot;</span>&quot; further below
        for details).</p>
    <p class="Pp">In the latter case, the memory occupied by the new bit vector
        is released first (i.e., &quot;free&quot;d) before the exception is
        actually raised.</p>
  </li>
  <li><span class="Li">&quot;$vector =
      Bit::Vector-&gt;new_Bin($bits,$string);&quot;</span>
    <p class="Pp">This method is an alternative constructor which allows you to
        create a new bit vector object (with
        &quot;<span class="Li">$bits</span>&quot; bits) and to initialize it all
        in one go.</p>
    <p class="Pp">The method internally first calls the bit vector constructor
        method &quot;<span class="Li">&quot;new()&quot;</span>&quot; and then
        passes the given string to the method
        &quot;<span class="Li">&quot;from_Bin()&quot;</span>&quot;.</p>
    <p class="Pp">However, this method is more efficient than performing these
        two steps separately: First because in this method, the memory area
        occupied by the new bit vector is not initialized to zeros (which is
        pointless in this case), and second because it saves you from the
        associated overhead of one additional method invocation.</p>
    <p class="Pp">An exception will be raised if the necessary memory cannot be
        allocated (see the description of the method
        &quot;<span class="Li">&quot;new()&quot;</span>&quot; above for possible
        causes) or if the given string cannot be converted successfully (see the
        description of the method
        &quot;<span class="Li">&quot;from_Bin()&quot;</span>&quot; further below
        for details).</p>
    <p class="Pp">In the latter case, the memory occupied by the new bit vector
        is released first (i.e., &quot;free&quot;d) before the exception is
        actually raised.</p>
  </li>
  <li><span class="Li">&quot;$vector =
      Bit::Vector-&gt;new_Dec($bits,$string);&quot;</span>
    <p class="Pp">This method is an alternative constructor which allows you to
        create a new bit vector object (with
        &quot;<span class="Li">$bits</span>&quot; bits) and to initialize it all
        in one go.</p>
    <p class="Pp">The method internally first calls the bit vector constructor
        method &quot;<span class="Li">&quot;new()&quot;</span>&quot; and then
        passes the given string to the method
        &quot;<span class="Li">&quot;from_Dec()&quot;</span>&quot;.</p>
    <p class="Pp">However, this method is more efficient than performing these
        two steps separately: First because in this method,
        &quot;<span class="Li">&quot;new()&quot;</span>&quot; does not
        initialize the memory area occupied by the new bit vector with zeros
        (which is pointless in this case, because
        &quot;<span class="Li">&quot;from_Dec()&quot;</span>&quot; will do it
        anyway), and second because it saves you from the associated overhead of
        one additional method invocation.</p>
    <p class="Pp">An exception will be raised if the necessary memory cannot be
        allocated (see the description of the method
        &quot;<span class="Li">&quot;new()&quot;</span>&quot; above for possible
        causes) or if the given string cannot be converted successfully (see the
        description of the method
        &quot;<span class="Li">&quot;from_Dec()&quot;</span>&quot; further below
        for details).</p>
    <p class="Pp">In the latter case, the memory occupied by the new bit vector
        is released first (i.e., &quot;free&quot;d) before the exception is
        actually raised.</p>
  </li>
  <li><span class="Li">&quot;$vector =
      Bit::Vector-&gt;new_Enum($bits,$string);&quot;</span>
    <p class="Pp">This method is an alternative constructor which allows you to
        create a new bit vector object (with
        &quot;<span class="Li">$bits</span>&quot; bits) and to initialize it all
        in one go.</p>
    <p class="Pp">The method internally first calls the bit vector constructor
        method &quot;<span class="Li">&quot;new()&quot;</span>&quot; and then
        passes the given string to the method
        &quot;<span class="Li">&quot;from_Enum()&quot;</span>&quot;.</p>
    <p class="Pp">However, this method is more efficient than performing these
        two steps separately: First because in this method,
        &quot;<span class="Li">&quot;new()&quot;</span>&quot; does not
        initialize the memory area occupied by the new bit vector with zeros
        (which is pointless in this case, because
        &quot;<span class="Li">&quot;from_Enum()&quot;</span>&quot; will do it
        anyway), and second because it saves you from the associated overhead of
        one additional method invocation.</p>
    <p class="Pp">An exception will be raised if the necessary memory cannot be
        allocated (see the description of the method
        &quot;<span class="Li">&quot;new()&quot;</span>&quot; above for possible
        causes) or if the given string cannot be converted successfully (see the
        description of the method
        &quot;<span class="Li">&quot;from_Enum()&quot;</span>&quot; further
        below for details).</p>
    <p class="Pp">In the latter case, the memory occupied by the new bit vector
        is released first (i.e., &quot;free&quot;d) before the exception is
        actually raised.</p>
  </li>
  <li><span class="Li">&quot;$vector =
      Bit::Vector-&gt;Concat_List(@vectors);&quot;</span>
    <p class="Pp">This method creates a new vector containing all bit vectors
        from the argument list in concatenated form.</p>
    <p class="Pp">The argument list may contain any number of arguments
        (including zero); the only condition is that all arguments must be bit
        vectors.</p>
    <p class="Pp">There is no condition concerning the length (in number of
        bits) of these arguments.</p>
    <p class="Pp">The vectors from the argument list are not changed in any
      way.</p>
    <p class="Pp">If the argument list is empty or if all arguments have length
        zero, the resulting bit vector will also have length zero.</p>
    <p class="Pp">Note that the <b>RIGHTMOST</b> bit vector from the argument
        list will become the <b>LEAST</b> significant part of the resulting bit
        vector, and the <b>LEFTMOST</b> bit vector from the argument list will
        become the <b>MOST</b> significant part of the resulting bit vector.</p>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss">OBJECT METHODS</h2>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;$vec2 = $vec1-&gt;new($bits);&quot;</span>
    <p class="Pp"><span class="Li">&quot;@veclist =
        $vec-&gt;new($bits);&quot;</span></p>
    <p class="Pp">This is an alternative way of calling the bit vector
        constructor method.</p>
    <p class="Pp">Vector &quot;<span class="Li">$vec1</span>&quot; (or
        &quot;<span class="Li">$vec</span>&quot;) is not affected by this, it
        just serves as an anchor for the method invocation mechanism.</p>
    <p class="Pp">In fact <b>ALL</b> class methods in this module can be called
        this way, even though this is probably considered to be
        &quot;politically incorrect&quot; by OO (&quot;object-orientation&quot;)
        aficionados. ;-)</p>
    <p class="Pp">So even if you are too lazy to type
        &quot;<span class="Li">&quot;Bit::Vector-&gt;&quot;</span>&quot; instead
        of &quot;<span class="Li">&quot;$vec1-&gt;&quot;</span>&quot; (and even
        though laziness is - allegedly - a programmer's virtue
        <span class="Li">&quot;:-)&quot;</span>), maybe it is better not to use
        this feature if you don't want to get booed at. ;-)</p>
  </li>
  <li><span class="Li">&quot;$vec2 = $vec1-&gt;Shadow();&quot;</span>
    <p class="Pp">Creates a <b>NEW</b> bit vector
        &quot;<span class="Li">$vec2</span>&quot; of the <b>SAME SIZE</b> as
        &quot;<span class="Li">$vec1</span>&quot; but which is <b>EMPTY</b>.</p>
    <p class="Pp">Just like a shadow that has the same shape as the object it
        originates from, but is flat and has no volume, i.e., contains
      nothing.</p>
  </li>
  <li><span class="Li">&quot;$vec2 = $vec1-&gt;Clone();&quot;</span>
    <p class="Pp">Creates a <b>NEW</b> bit vector
        &quot;<span class="Li">$vec2</span>&quot; of the <b>SAME SIZE</b> as
        &quot;<span class="Li">$vec1</span>&quot; which is an <b>EXACT COPY</b>
        of &quot;<span class="Li">$vec1</span>&quot;.</p>
  </li>
  <li><span class="Li">&quot;$vector = $vec1-&gt;Concat($vec2);&quot;</span>
    <p class="Pp">This method returns a new bit vector object which is the
        result of the concatenation of the contents of
        &quot;<span class="Li">$vec1</span>&quot; and
        &quot;<span class="Li">$vec2</span>&quot;.</p>
    <p class="Pp">Note that the contents of
        &quot;<span class="Li">$vec1</span>&quot; become the <b>MOST</b>
        significant part of the resulting bit vector, and
        &quot;<span class="Li">$vec2</span>&quot; the <b>LEAST</b> significant
        part.</p>
    <p class="Pp">If both bit vector arguments have length zero, the resulting
        bit vector will also have length zero.</p>
  </li>
  <li><span class="Li">&quot;$vector =
      $vec1-&gt;Concat_List($vec2,$vec3,...);&quot;</span>
    <p class="Pp">This is an alternative way of calling this (class) method as
        an object method.</p>
    <p class="Pp">The method returns a new bit vector object which is the result
        of the concatenation of the contents of <span class="Li">&quot;$vec1 .
        $vec2 . $vec3 . ...&quot;</span></p>
    <p class="Pp">See the section &quot;class methods&quot; above for a detailed
        description of this method.</p>
    <p class="Pp">Note that the argument list may be empty and that all
        arguments must be bit vectors if it isn't.</p>
  </li>
  <li><span class="Li">&quot;$bits = $vector-&gt;Size();&quot;</span>
    <p class="Pp">Returns the size (number of bits) the given vector was created
        with (or &quot;<span class="Li">&quot;Resize()&quot;</span>&quot;d
      to).</p>
  </li>
  <li><span class="Li">&quot;$vector-&gt;Resize($bits);&quot;</span>
    <p class="Pp">Changes the size of the given vector to the specified number
        of bits.</p>
    <p class="Pp">This method allows you to change the size of an existing bit
        vector, preserving as many bits from the old vector as will fit into the
        new one (i.e., all bits with indices smaller than the minimum of the
        sizes of both vectors, old and new).</p>
    <p class="Pp">If the number of machine words needed to store the new vector
        is smaller than or equal to the number of words needed to store the old
        vector, the memory allocated for the old vector is reused for the new
        one, and only the relevant book-keeping information is adjusted
        accordingly.</p>
    <p class="Pp">This means that even if the number of bits increases, new
        memory is not necessarily being allocated (i.e., if the old and the new
        number of bits fit into the same number of machine words).</p>
    <p class="Pp">If the number of machine words needed to store the new vector
        is greater than the number of words needed to store the old vector, new
        memory is allocated for the new vector, the old vector is copied to the
        new one, the remaining bits in the new vector are cleared (turned off)
        and the old vector is deleted, i.e., the memory that was allocated for
        it is released.</p>
    <p class="Pp">(An exception will be raised if the method is unable to
        allocate the necessary memory for the new vector.)</p>
    <p class="Pp">As a consequence, if you decrease the size of a given vector
        so that it will use fewer machine words, and increase it again later so
        that it will use more words than immediately before but still less than
        the original vector, new memory will be allocated anyway because the
        information about the size of the original vector is lost whenever you
        resize it.</p>
    <p class="Pp">Note also that if you specify a negative number for
        &quot;<span class="Li">$bits</span>&quot; it will be interpreted as a
        large positive number due to its internal two's complement binary
        representation.</p>
    <p class="Pp">In such a case, &quot;<b>Resize()</b>&quot; will obediently
        attempt to create a bit vector of that size, probably resulting in an
        exception, as explained above.</p>
    <p class="Pp">Finally, note that - in contrast to previous versions -
        resizing a bit vector to a size of zero bits (length zero) is now
        permitted.</p>
  </li>
  <li><span class="Li">&quot;$vec2-&gt;Copy($vec1);&quot;</span>
    <p class="Pp">Copies the contents of bit vector
        &quot;<span class="Li">$vec1</span>&quot; to bit vector
        &quot;<span class="Li">$vec2</span>&quot;.</p>
    <p class="Pp">The previous contents of bit vector
        &quot;<span class="Li">$vec2</span>&quot; get overwritten, i.e., are
        lost.</p>
    <p class="Pp">Both vectors must exist beforehand, i.e., this method does not
        <b>CREATE</b> any new bit vector object.</p>
    <p class="Pp">The two vectors may be of any size.</p>
    <p class="Pp">If the source bit vector is larger than the target, this
        method will copy as much of the least significant bits of the source
        vector as will fit into the target vector, thereby discarding any
        extraneous most significant bits.</p>
    <p class="Pp">BEWARE that this causes a brutal cutoff in the middle of your
        data, and it will also leave you with an almost unpredictable sign if
        subsequently the number in the target vector is going to be interpreted
        as a number! (You have been warned!)</p>
    <p class="Pp">If the target bit vector is larger than the source, this
        method fills up the remaining most significant bits in the target bit
        vector with either 0's or 1's, depending on the sign (= the most
        significant bit) of the source bit vector. This is also known as
        &quot;sign extension&quot;.</p>
    <p class="Pp">This makes it possible to copy numbers from a smaller bit
        vector into a larger one while preserving the number's absolute value as
        well as its sign (due to the two's complement binary representation of
        numbers).</p>
  </li>
  <li><span class="Li">&quot;$vector-&gt;Empty();&quot;</span>
    <p class="Pp">Clears all bits in the given vector.</p>
  </li>
  <li><span class="Li">&quot;$vector-&gt;Fill();&quot;</span>
    <p class="Pp">Sets all bits in the given vector.</p>
  </li>
  <li><span class="Li">&quot;$vector-&gt;Flip();&quot;</span>
    <p class="Pp">Flips (i.e., complements) all bits in the given vector.</p>
  </li>
  <li><span class="Li">&quot;$vector-&gt;Primes();&quot;</span>
    <p class="Pp">Clears the given bit vector and sets all bits whose indices
        are prime numbers.</p>
    <p class="Pp">This method uses the algorithm known as the &quot;Sieve of
        Erathostenes&quot; internally.</p>
  </li>
  <li><span class="Li">&quot;$vec2-&gt;Reverse($vec1);&quot;</span>
    <p class="Pp">This method copies the given vector
        &quot;<span class="Li">$vec1</span>&quot; to the vector
        &quot;<span class="Li">$vec2</span>&quot;, thereby reversing the order
        of all bits.</p>
    <p class="Pp">I.e., the least significant bit of
        &quot;<span class="Li">$vec1</span>&quot; becomes the most significant
        bit of &quot;<span class="Li">$vec2</span>&quot;, whereas the most
        significant bit of &quot;<span class="Li">$vec1</span>&quot; becomes the
        least significant bit of &quot;<span class="Li">$vec2</span>&quot;, and
        so forth for all bits in between.</p>
    <p class="Pp">Note that in-place processing is also possible, i.e.,
        &quot;<span class="Li">$vec1</span>&quot; and
        &quot;<span class="Li">$vec2</span>&quot; may be identical.</p>
    <p class="Pp">(Internally, this is the same as
        <span class="Li">&quot;$vec1-&gt;Interval_Reverse(0,$vec1-&gt;Size()-1);&quot;</span>.)</p>
  </li>
  <li><span class="Li">&quot;$vector-&gt;Interval_Empty($min,$max);&quot;</span>
    <p class="Pp">Clears all bits in the interval
        <span class="Li">&quot;[$min..$max]&quot;</span> (including both limits)
        in the given vector.</p>
    <p class="Pp">&quot;<span class="Li">$min</span>&quot; and
        &quot;<span class="Li">$max</span>&quot; may have the same value; this
        is the same as clearing a single bit with
        &quot;<span class="Li">&quot;Bit_Off()&quot;</span>&quot; (but less
        efficient).</p>
    <p class="Pp">Note that
        <span class="Li">&quot;$vector-&gt;Interval_Empty(0,$vector-&gt;Size()-1);&quot;</span>
        is the same as <span class="Li">&quot;$vector-&gt;Empty();&quot;</span>
        (but less efficient).</p>
  </li>
  <li><span class="Li">&quot;$vector-&gt;Interval_Fill($min,$max);&quot;</span>
    <p class="Pp">Sets all bits in the interval
        <span class="Li">&quot;[$min..$max]&quot;</span> (including both limits)
        in the given vector.</p>
    <p class="Pp">&quot;<span class="Li">$min</span>&quot; and
        &quot;<span class="Li">$max</span>&quot; may have the same value; this
        is the same as setting a single bit with
        &quot;<span class="Li">&quot;Bit_On()&quot;</span>&quot; (but less
        efficient).</p>
    <p class="Pp">Note that
        <span class="Li">&quot;$vector-&gt;Interval_Fill(0,$vector-&gt;Size()-1);&quot;</span>
        is the same as <span class="Li">&quot;$vector-&gt;Fill();&quot;</span>
        (but less efficient).</p>
  </li>
  <li><span class="Li">&quot;$vector-&gt;Interval_Flip($min,$max);&quot;</span>
    <p class="Pp">Flips (i.e., complements) all bits in the interval
        <span class="Li">&quot;[$min..$max]&quot;</span> (including both limits)
        in the given vector.</p>
    <p class="Pp">&quot;<span class="Li">$min</span>&quot; and
        &quot;<span class="Li">$max</span>&quot; may have the same value; this
        is the same as flipping a single bit with
        &quot;<span class="Li">&quot;bit_flip()&quot;</span>&quot; (but less
        efficient).</p>
    <p class="Pp">Note that
        <span class="Li">&quot;$vector-&gt;Interval_Flip(0,$vector-&gt;Size()-1);&quot;</span>
        is the same as <span class="Li">&quot;$vector-&gt;Flip();&quot;</span>
        and <span class="Li">&quot;$vector-&gt;Complement($vector);&quot;</span>
        (but less efficient).</p>
  </li>
  <li><span class="Li">&quot;$vector-&gt;Interval_Reverse($min,$max);&quot;</span>
    <p class="Pp">Reverses the order of all bits in the interval
        <span class="Li">&quot;[$min..$max]&quot;</span> (including both limits)
        in the given vector.</p>
    <p class="Pp">I.e., bits &quot;<span class="Li">$min</span>&quot; and
        &quot;<span class="Li">$max</span>&quot; swap places, and so forth for
        all bits in between.</p>
    <p class="Pp">&quot;<span class="Li">$min</span>&quot; and
        &quot;<span class="Li">$max</span>&quot; may have the same value; this
        has no effect whatsoever, though.</p>
  </li>
  <li><span class="Li">&quot;if (($min,$max) =
      $vector-&gt;Interval_Scan_inc($start))&quot;</span>
    <p class="Pp">Returns the minimum and maximum indices of the next contiguous
        block of set bits (i.e., bits in the &quot;on&quot; state).</p>
    <p class="Pp">The search starts at index
        &quot;<span class="Li">$start</span>&quot; (i.e.,
        <span class="Li">&quot;$min&quot; &gt;= &quot;$start&quot;</span>) and
        proceeds upwards (i.e., <span class="Li">&quot;$max&quot; &gt;=
        &quot;$min&quot;</span>), thus repeatedly increments the search pointer
        &quot;<span class="Li">$start</span>&quot; (internally).</p>
    <p class="Pp">Note though that the contents of the variable (or scalar
        literal value) &quot;<span class="Li">$start</span>&quot; is <b>NOT</b>
        altered. I.e., you have to set it to the desired value yourself prior to
        each call to
        &quot;<span class="Li">&quot;Interval_Scan_inc()&quot;</span>&quot; (see
        also the example given below).</p>
    <p class="Pp">Actually, the bit vector is not searched bit by bit, but one
        machine word at a time, in order to speed up execution (which means that
        this method is quite efficient).</p>
    <p class="Pp">An empty list is returned if no such block can be found.</p>
    <p class="Pp">Note that a single set bit (surrounded by cleared bits) is a
        valid block by this definition. In that case the return values for
        &quot;<span class="Li">$min</span>&quot; and
        &quot;<span class="Li">$max</span>&quot; are the same.</p>
    <p class="Pp">Typical use:</p>
    <p class="Pp"></p>
    <pre>
    $start = 0;
    while (($start &lt; $vector-&gt;Size()) &amp;&amp;
        (($min,$max) = $vector-&gt;Interval_Scan_inc($start)))
    {
        $start = $max + 2;

        # do something with $min and $max
    }
    </pre>
  </li>
  <li><span class="Li">&quot;if (($min,$max) =
      $vector-&gt;Interval_Scan_dec($start))&quot;</span>
    <p class="Pp">Returns the minimum and maximum indices of the next contiguous
        block of set bits (i.e., bits in the &quot;on&quot; state).</p>
    <p class="Pp">The search starts at index
        &quot;<span class="Li">$start</span>&quot; (i.e.,
        <span class="Li">&quot;$max&quot; &lt;= &quot;$start&quot;</span>) and
        proceeds downwards (i.e., <span class="Li">&quot;$min&quot; &lt;=
        &quot;$max&quot;</span>), thus repeatedly decrements the search pointer
        &quot;<span class="Li">$start</span>&quot; (internally).</p>
    <p class="Pp">Note though that the contents of the variable (or scalar
        literal value) &quot;<span class="Li">$start</span>&quot; is <b>NOT</b>
        altered. I.e., you have to set it to the desired value yourself prior to
        each call to
        &quot;<span class="Li">&quot;Interval_Scan_dec()&quot;</span>&quot; (see
        also the example given below).</p>
    <p class="Pp">Actually, the bit vector is not searched bit by bit, but one
        machine word at a time, in order to speed up execution (which means that
        this method is quite efficient).</p>
    <p class="Pp">An empty list is returned if no such block can be found.</p>
    <p class="Pp">Note that a single set bit (surrounded by cleared bits) is a
        valid block by this definition. In that case the return values for
        &quot;<span class="Li">$min</span>&quot; and
        &quot;<span class="Li">$max</span>&quot; are the same.</p>
    <p class="Pp">Typical use:</p>
    <p class="Pp"></p>
    <pre>
    $start = $vector-&gt;Size() - 1;
    while (($start &gt;= 0) &amp;&amp;
        (($min,$max) = $vector-&gt;Interval_Scan_dec($start)))
    {
        $start = $min - 2;

        # do something with $min and $max
    }
    </pre>
  </li>
  <li><span class="Li">&quot;$vec2-&gt;Interval_Copy($vec1,$offset2,$offset1,$length);&quot;</span>
    <p class="Pp">This method allows you to copy a stretch of contiguous bits
        (starting at any position &quot;<span class="Li">$offset1</span>&quot;
        you choose, with a length of &quot;<span class="Li">$length</span>&quot;
        bits) from a given &quot;source&quot; bit vector
        &quot;<span class="Li">$vec1</span>&quot; to another position
        &quot;<span class="Li">$offset2</span>&quot; in a &quot;target&quot; bit
        vector &quot;<span class="Li">$vec2</span>&quot;.</p>
    <p class="Pp">Note that the two bit vectors
        &quot;<span class="Li">$vec1</span>&quot; and
        &quot;<span class="Li">$vec2</span>&quot; do <b>NOT</b> need to have the
        same (matching) size!</p>
    <p class="Pp">Consequently, any of the two terms
        &quot;<span class="Li">&quot;$offset1 + $length&quot;</span>&quot; and
        &quot;<span class="Li">&quot;$offset2 + $length&quot;</span>&quot; (or
        both) may exceed the actual length of its corresponding bit vector
        (&quot;<span class="Li">&quot;$vec1-&gt;Size()&quot;</span>&quot; and
        &quot;<span class="Li">&quot;$vec2-&gt;Size()&quot;</span>&quot;,
        respectively).</p>
    <p class="Pp">In such a case, the
        &quot;<span class="Li">$length</span>&quot; parameter is automatically
        reduced internally so that both terms above are bounded by the number of
        bits of their corresponding bit vector.</p>
    <p class="Pp">This may even result in a length of zero, in which case
        nothing is copied at all.</p>
    <p class="Pp">(Of course the value of the
        &quot;<span class="Li">$length</span>&quot; parameter, supplied by you
        in the initial method call, may also be zero right from the start!)</p>
    <p class="Pp">Note also that &quot;<span class="Li">$offset1</span>&quot;
        and &quot;<span class="Li">$offset2</span>&quot; must lie within the
        range &quot;<span class="Li">0</span>&quot; and, respectively,
        &quot;<span class="Li">&quot;$vec1-&gt;Size()-1&quot;</span>&quot; or
        &quot;<span class="Li">&quot;$vec2-&gt;Size()-1&quot;</span>&quot;, or a
        fatal &quot;offset out of range&quot; error will occur.</p>
    <p class="Pp">Note further that &quot;<span class="Li">$vec1</span>&quot;
        and &quot;<span class="Li">$vec2</span>&quot; may be identical, i.e.,
        you may copy a stretch of contiguous bits from one part of a given bit
        vector to another part.</p>
    <p class="Pp">The source and the target interval may even overlap, in which
        case the copying is automatically performed in ascending or descending
        order (depending on the direction of the copy - downwards or upwards in
        the bit vector, respectively) to handle this situation correctly, i.e.,
        so that no bits are being overwritten before they have been copied
        themselves.</p>
  </li>
  <li><span class="Li">&quot;$vec2-&gt;Interval_Substitute($vec1,$off2,$len2,$off1,$len1);&quot;</span>
    <p class="Pp">This method is (roughly) the same for bit vectors (i.e.,
        arrays of booleans) as what the &quot;splice&quot; function in Perl is
        for lists (i.e., arrays of scalars).</p>
    <p class="Pp">(See &quot;splice&quot; in perlfunc for more details about
        this function.)</p>
    <p class="Pp">The method allows you to substitute a stretch of contiguous
        bits (defined by a position (offset)
        &quot;<span class="Li">$off1</span>&quot; and a length of
        &quot;<span class="Li">$len1</span>&quot; bits) from a given
        &quot;source&quot; bit vector &quot;<span class="Li">$vec1</span>&quot;
        for a different stretch of contiguous bits (defined by a position
        (offset) &quot;<span class="Li">$off2</span>&quot; and a length of
        &quot;<span class="Li">$len2</span>&quot; bits) in another,
        &quot;target&quot; bit vector
      &quot;<span class="Li">$vec2</span>&quot;.</p>
    <p class="Pp">Note that the two bit vectors
        &quot;<span class="Li">$vec1</span>&quot; and
        &quot;<span class="Li">$vec2</span>&quot; do <b>NOT</b> need to have the
        same (matching) size!</p>
    <p class="Pp">Note further that &quot;<span class="Li">$off1</span>&quot;
        and &quot;<span class="Li">$off2</span>&quot; must lie within the range
        &quot;<span class="Li">0</span>&quot; and, respectively,
        &quot;<span class="Li">&quot;$vec1-&gt;Size()&quot;</span>&quot; or
        &quot;<span class="Li">&quot;$vec2-&gt;Size()&quot;</span>&quot;, or a
        fatal &quot;offset out of range&quot; error will occur.</p>
    <p class="Pp">Alert readers will have noticed that these upper limits are
        <b>NOT</b>
        &quot;<span class="Li">&quot;$vec1-&gt;Size()-1&quot;</span>&quot; and
        &quot;<span class="Li">&quot;$vec2-&gt;Size()-1&quot;</span>&quot;, as
        they would be for any other method in this module, but that these
        offsets may actually point to one position <b>PAST THE END</b> of the
        corresponding bit vector.</p>
    <p class="Pp">This is necessary in order to make it possible to
        <b>APPEND</b> a given stretch of bits to the target bit vector instead
        of <b>REPLACING</b> something in it.</p>
    <p class="Pp">For reasons of symmetry and generality, the same applies to
        the offset in the source bit vector, even though such an offset (one
        position past the end of the bit vector) does not serve any practical
        purpose there (but does not cause any harm either).</p>
    <p class="Pp">(Actually this saves you from the need of testing for this
        special case, in certain circumstances.)</p>
    <p class="Pp">Note that whenever the term &quot;<span class="Li">&quot;$off1
        + $len1&quot;</span>&quot; exceeds the size
        &quot;<span class="Li">&quot;$vec1-&gt;Size()&quot;</span>&quot; of bit
        vector &quot;<span class="Li">$vec1</span>&quot; (or if
        &quot;<span class="Li">&quot;$off2 + $len2&quot;</span>&quot; exceeds
        &quot;<span class="Li">&quot;$vec2-&gt;Size()&quot;</span>&quot;), the
        corresponding length (&quot;<span class="Li">$len1</span>&quot; or
        &quot;<span class="Li">$len2</span>&quot;, respectively) is
        automatically reduced internally so that
        &quot;<span class="Li">&quot;$off1 + $len1 &lt;=
        $vec1-&gt;Size()&quot;</span>&quot; (and
        &quot;<span class="Li">&quot;$off2 + $len2 &lt;=
        $vec2-&gt;Size()&quot;</span>&quot;) holds.</p>
    <p class="Pp">(Note that this does <b>NOT</b> alter the intended result,
        even though this may seem counter-intuitive at first!)</p>
    <p class="Pp">This may even result in a length
        (&quot;<span class="Li">$len1</span>&quot; or
        &quot;<span class="Li">$len2</span>&quot;) of zero.</p>
    <p class="Pp">A length of zero for the interval in the <b>SOURCE</b> bit
        vector (&quot;<span class="Li">&quot;$len1 == 0&quot;</span>&quot;)
        means that the indicated stretch of bits in the target bit vector
        (starting at position &quot;<span class="Li">$off2</span>&quot;) is to
        be replaced by <b>NOTHING</b>, i.e., is to be <b>DELETED</b>.</p>
    <p class="Pp">A length of zero for the interval in the <b>TARGET</b> bit
        vector (&quot;<span class="Li">$len2</span> == 0&quot;) means that
        <b>NOTHING</b> is replaced, and that the stretch of bits from the source
        bit vector is simply <b>INSERTED</b> into the target bit vector at the
        indicated position (&quot;<span class="Li">$off2</span>&quot;).</p>
    <p class="Pp">If both length parameters are zero, nothing is done at
      all.</p>
    <p class="Pp">Note that in contrast to any other method in this module
        (especially
        &quot;<span class="Li">&quot;Interval_Copy()&quot;</span>&quot;,
        &quot;<span class="Li">&quot;Insert()&quot;</span>&quot; and
        &quot;<span class="Li">&quot;Delete()&quot;</span>&quot;), this method
        <b>IMPLICITLY</b> and <b>AUTOMATICALLY</b> adapts the length of the
        resulting bit vector as needed, as given by</p>
    <p class="Pp"></p>
    <pre>
        $size = $vec2-&gt;Size();   #  before
        $size += $len1 - $len2;  #  after
    </pre>
    <p class="Pp">(The only other method in this module that changes the size of
        a bit vector is the method
        &quot;<span class="Li">&quot;Resize()&quot;</span>&quot;.)</p>
    <p class="Pp">In other words, replacing a given interval of bits in the
        target bit vector with a longer or shorter stretch of bits from the
        source bit vector, or simply inserting
        (&quot;<span class="Li">&quot;$len2 == 0&quot;</span>&quot;) a stretch
        of bits into or deleting (&quot;<span class="Li">&quot;$len1 ==
        0&quot;</span>&quot;) an interval of bits from the target bit vector
        will automatically increase or decrease, respectively, the size of the
        target bit vector accordingly.</p>
    <p class="Pp">For the sake of generality, this may even result in a bit
        vector with a size of zero (containing no bits at all).</p>
    <p class="Pp">This is also the reason why bit vectors of length zero are
        permitted in this module in the first place, starting with version
      5.0.</p>
    <p class="Pp">Finally, note that &quot;<span class="Li">$vec1</span>&quot;
        and &quot;<span class="Li">$vec2</span>&quot; may be identical, i.e.,
        in-place processing is possible.</p>
    <p class="Pp">(If you think about that for a while or if you look at the
        code, you will see that this is far from trivial!)</p>
  </li>
  <li><span class="Li">&quot;if ($vector-&gt;is_empty())&quot;</span>
    <p class="Pp">Tests whether the given bit vector is empty, i.e., whether
        <b>ALL</b> of its bits are cleared (in the &quot;off&quot; state).</p>
    <p class="Pp">In &quot;big integer&quot; arithmetic, this is equivalent to
        testing whether the number stored in the bit vector is zero
        (&quot;<span class="Li">0</span>&quot;).</p>
    <p class="Pp">Returns &quot;true&quot;
        (&quot;<span class="Li">1</span>&quot;) if the bit vector is empty and
        &quot;false&quot; (&quot;<span class="Li">0</span>&quot;) otherwise.</p>
    <p class="Pp">Note that this method also returns &quot;true&quot;
        (&quot;<span class="Li">1</span>&quot;) if the given bit vector has a
        length of zero, i.e., if it contains no bits at all.</p>
  </li>
  <li><span class="Li">&quot;if ($vector-&gt;is_full())&quot;</span>
    <p class="Pp">Tests whether the given bit vector is full, i.e., whether
        <b>ALL</b> of its bits are set (in the &quot;on&quot; state).</p>
    <p class="Pp">In &quot;big integer&quot; arithmetic, this is equivalent to
        testing whether the number stored in the bit vector is minus one
        (&quot;-1&quot;).</p>
    <p class="Pp">Returns &quot;true&quot;
        (&quot;<span class="Li">1</span>&quot;) if the bit vector is full and
        &quot;false&quot; (&quot;<span class="Li">0</span>&quot;) otherwise.</p>
    <p class="Pp">If the given bit vector has a length of zero (i.e., if it
        contains no bits at all), this method returns &quot;false&quot;
        (&quot;<span class="Li">0</span>&quot;).</p>
  </li>
  <li><span class="Li">&quot;if ($vec1-&gt;equal($vec2))&quot;</span>
    <p class="Pp">Tests the two given bit vectors for equality.</p>
    <p class="Pp">Returns &quot;true&quot;
        (&quot;<span class="Li">1</span>&quot;) if the two bit vectors are exact
        copies of one another and &quot;false&quot;
        (&quot;<span class="Li">0</span>&quot;) otherwise.</p>
  </li>
  <li><span class="Li">&quot;$cmp = $vec1-&gt;Lexicompare($vec2);&quot;</span>
    <p class="Pp">Compares the two given bit vectors, which are regarded as
        <b>UNSIGNED</b> numbers in binary representation.</p>
    <p class="Pp">The method returns
        &quot;<span class="Li">&quot;-1&quot;</span>&quot; if the first bit
        vector is smaller than the second bit vector,
        &quot;<span class="Li">0</span>&quot; if the two bit vectors are exact
        copies of one another and &quot;<span class="Li">1</span>&quot; if the
        first bit vector is greater than the second bit vector.</p>
  </li>
  <li><span class="Li">&quot;$cmp = $vec1-&gt;Compare($vec2);&quot;</span>
    <p class="Pp">Compares the two given bit vectors, which are regarded as
        <b>SIGNED</b> numbers in binary representation.</p>
    <p class="Pp">The method returns
        &quot;<span class="Li">&quot;-1&quot;</span>&quot; if the first bit
        vector is smaller than the second bit vector,
        &quot;<span class="Li">0</span>&quot; if the two bit vectors are exact
        copies of one another and &quot;<span class="Li">1</span>&quot; if the
        first bit vector is greater than the second bit vector.</p>
  </li>
  <li><span class="Li">&quot;$string = $vector-&gt;to_Hex();&quot;</span>
    <p class="Pp">Returns a hexadecimal string representing the given bit
        vector.</p>
    <p class="Pp">Note that this representation is quite compact, in that it
        only needs at most twice the number of bytes needed to store the bit
        vector itself, internally.</p>
    <p class="Pp">Note also that since a hexadecimal digit is always worth four
        bits, the length of the resulting string is always a multiple of four
        bits, regardless of the true length (in bits) of the given bit
      vector.</p>
    <p class="Pp">Finally, note that the <b>LEAST</b> significant hexadecimal
        digit is located at the <b>RIGHT</b> end of the resulting string, and
        the <b>MOST</b> significant digit at the <b>LEFT</b> end.</p>
  </li>
  <li><span class="Li">&quot;$vector-&gt;from_Hex($string);&quot;</span>
    <p class="Pp">Allows to read in the contents of a bit vector from a
        hexadecimal string, such as returned by the method
        &quot;<span class="Li">&quot;to_Hex()&quot;</span>&quot; (see
      above).</p>
    <p class="Pp">Remember that the least significant bits are always to the
        right of a hexadecimal string, and the most significant bits to the
        left. Therefore, the string is actually read in from right to left while
        the bit vector is filled accordingly, 4 bits at a time, starting with
        the least significant bits and going upward to the most significant
        bits.</p>
    <p class="Pp">If the given string contains less hexadecimal digits than are
        needed to completely fill the given bit vector, the remaining (most
        significant) bits are all cleared.</p>
    <p class="Pp">This also means that, even if the given string does not
        contain enough digits to completely fill the given bit vector, the
        previous contents of the bit vector are erased completely.</p>
    <p class="Pp">If the given string is longer than it needs to fill the given
        bit vector, the superfluous characters are simply ignored.</p>
    <p class="Pp">(In fact they are ignored completely - they are not even
        checked for proper syntax. See also below for more about that.)</p>
    <p class="Pp">This behaviour is intentional so that you may read in the
        string representing one bit vector into another bit vector of different
        size, i.e., as much of it as will fit.</p>
    <p class="Pp">If during the process of reading the given string any
        character is encountered which is not a hexadecimal digit, a fatal
        syntax error ensues (&quot;input string syntax error&quot;).</p>
  </li>
  <li><span class="Li">&quot;$string = $vector-&gt;to_Bin();&quot;</span>
    <p class="Pp">Returns a binary string representing the given bit vector.</p>
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>
  $vector = Bit::Vector-&gt;new(8);
  $vector-&gt;Primes();
  $string = $vector-&gt;to_Bin();
  print &quot;'$string'\n&quot;;
    </pre>
    <p class="Pp">This prints:</p>
    <p class="Pp"></p>
    <pre>
  '10101100'
    </pre>
    <p class="Pp">(Bits #7, #5, #3 and #2 are set.)</p>
    <p class="Pp">Note that the <b>LEAST</b> significant bit is located at the
        <b>RIGHT</b> end of the resulting string, and the <b>MOST</b>
        significant bit at the <b>LEFT</b> end.</p>
  </li>
  <li><span class="Li">&quot;$vector-&gt;from_Bin($string);&quot;</span>
    <p class="Pp">This method allows you to read in the contents of a bit vector
        from a binary string, such as returned by the method
        &quot;<span class="Li">&quot;to_Bin()&quot;</span>&quot; (see
      above).</p>
    <p class="Pp">Note that this method assumes that the <b>LEAST</b>
        significant bit is located at the <b>RIGHT</b> end of the binary string,
        and the <b>MOST</b> significant bit at the <b>LEFT</b> end. Therefore,
        the string is actually read in from right to left while the bit vector
        is filled accordingly, one bit at a time, starting with the least
        significant bit and going upward to the most significant bit.</p>
    <p class="Pp">If the given string contains less binary digits
        (&quot;<span class="Li">0</span>&quot; and
        &quot;<span class="Li">1</span>&quot;) than are needed to completely
        fill the given bit vector, the remaining (most significant) bits are all
        cleared.</p>
    <p class="Pp">This also means that, even if the given string does not
        contain enough digits to completely fill the given bit vector, the
        previous contents of the bit vector are erased completely.</p>
    <p class="Pp">If the given string is longer than it needs to fill the given
        bit vector, the superfluous characters are simply ignored.</p>
    <p class="Pp">(In fact they are ignored completely - they are not even
        checked for proper syntax. See also below for more about that.)</p>
    <p class="Pp">This behaviour is intentional so that you may read in the
        string representing one bit vector into another bit vector of different
        size, i.e., as much of it as will fit.</p>
    <p class="Pp">If during the process of reading the given string any
        character is encountered which is not either
        &quot;<span class="Li">0</span>&quot; or
        &quot;<span class="Li">1</span>&quot;, a fatal syntax error ensues
        (&quot;input string syntax error&quot;).</p>
  </li>
  <li><span class="Li">&quot;$string = $vector-&gt;to_Dec();&quot;</span>
    <p class="Pp">This method returns a string representing the contents of the
        given bit vector converted to decimal (base
      <span class="Li">10</span>).</p>
    <p class="Pp">Note that this method assumes the given bit vector to be
        <b>SIGNED</b> (and to contain a number in two's complement binary
        representation).</p>
    <p class="Pp">Consequently, whenever the most significant bit of the given
        bit vector is set, the number stored in it is regarded as being
        <b>NEGATIVE</b>.</p>
    <p class="Pp">The resulting string can be fed into
        &quot;<span class="Li">&quot;from_Dec()&quot;</span>&quot; (see below)
        in order to copy the contents of this bit vector to another one (or to
        restore the contents of this one). This is not advisable, though, since
        this would be very inefficient (there are much more efficient methods
        for storing and copying bit vectors in this module).</p>
    <p class="Pp">Note that such conversion from binary to decimal is inherently
        slow since the bit vector has to be repeatedly divided by
        <span class="Li">10</span> with remainder until the quotient becomes
        <span class="Li">0</span> (each remainder in turn represents a single
        decimal digit of the resulting string).</p>
    <p class="Pp">This is also true for the implementation of this method in
        this module, even though a considerable effort has been made to speed it
        up: instead of repeatedly dividing by <span class="Li">10</span>, the
        bit vector is repeatedly divided by the largest power of
        <span class="Li">10</span> that will fit into a machine word. The
        remainder is then repeatedly divided by <span class="Li">10</span> using
        only machine word arithmetics, which is much faster than dividing the
        whole bit vector (&quot;divide and rule&quot; principle).</p>
    <p class="Pp">According to my own measurements, this resulted in an 8-fold
        speed increase over the straightforward approach.</p>
    <p class="Pp">Still, conversion to decimal should be used only where
        absolutely necessary.</p>
    <p class="Pp">Keep the resulting string stored in some variable if you need
        it again, instead of converting the bit vector all over again.</p>
    <p class="Pp">Beware that if you set the configuration for overloaded
        operators to &quot;output=decimal&quot;, this method will be called for
        every bit vector enclosed in double quotes!</p>
  </li>
  <li><span class="Li">&quot;$vector-&gt;from_Dec($string);&quot;</span>
    <p class="Pp">This method allows you to convert a given decimal number,
        which may be positive or negative, into two's complement binary
        representation, which is then stored in the given bit vector.</p>
    <p class="Pp">The decimal number should always be provided as a string, to
        avoid possible truncation (due to the limited precision of integers in
        Perl) or formatting (due to Perl's use of scientific notation for large
        numbers), which would lead to errors.</p>
    <p class="Pp">If the binary representation of the given decimal number is
        too big to fit into the given bit vector (if the given bit vector does
        not contain enough bits to hold it), a fatal &quot;numeric overflow
        error&quot; occurs.</p>
    <p class="Pp">If the input string contains other characters than decimal
        digits (<span class="Li">&quot;0-9&quot;</span>) and an optional leading
        sign (&quot;<span class="Li">&quot;+&quot;</span>&quot; or
        &quot;<span class="Li">&quot;-&quot;</span>&quot;), a fatal &quot;input
        string syntax error&quot; occurs.</p>
    <p class="Pp">Beware that large positive numbers which cause the most
        significant bit to be set (e.g. &quot;255&quot; in a bit vector with 8
        bits) will be printed as negative numbers when converted back to decimal
        using the method &quot;<b>to_Dec()</b>&quot; (e.g. &quot;-1&quot;, in
        our example), because numbers with the most significant bit set are
        considered to be negative in two's complement binary representation.</p>
    <p class="Pp">Note also that while it is possible to thusly enter negative
        numbers as large positive numbers (e.g. &quot;255&quot; for
        &quot;-1&quot; in a bit vector with 8 bits), the contrary isn't, i.e.,
        you cannot enter &quot;-255&quot; for &quot;+1&quot;, in our example. A
        fatal &quot;numeric overflow error&quot; will occur if you try to do
      so.</p>
    <p class="Pp">If possible program abortion is unwanted or intolerable, use
        &quot;<span class="Li">&quot;eval&quot;</span>&quot;, like this:</p>
    <p class="Pp"></p>
    <pre>
  eval { $vector-&gt;from_Dec(&quot;1152921504606846976&quot;); };
  if ($@)
  {
      # an error occurred
  }
    </pre>
    <p class="Pp">There are four possible error messages:</p>
    <p class="Pp"></p>
    <pre>
  if ($@ =~ /item is not a string/)

  if ($@ =~ /input string syntax error/)

  if ($@ =~ /numeric overflow error/)

  if ($@ =~ /unable to allocate memory/)
    </pre>
    <p class="Pp">Note that the conversion from decimal to binary is costly in
        terms of processing time, since a lot of multiplications have to be
        carried out (in principle, each decimal digit must be multiplied with
        the binary representation of the power of <span class="Li">10</span>
        corresponding to its position in the decimal number, i.e., 1, 10, 100,
        1000, 10000 and so on).</p>
    <p class="Pp">This is not as time consuming as the opposite conversion, from
        binary to decimal (where successive divisions have to be carried out,
        which are even more expensive than multiplications), but still
        noticeable.</p>
    <p class="Pp">Again (as in the case of
        &quot;<span class="Li">&quot;to_Dec()&quot;</span>&quot;), the
        implementation of this method in this module uses the principle of
        &quot;divide and rule&quot; in order to speed up the conversion, i.e.,
        as many decimal digits as possible are first accumulated (converted) in
        a machine word and only then stored in the given bit vector.</p>
    <p class="Pp">Even so, use this method only where absolutely necessary if
        speed is an important consideration in your application.</p>
    <p class="Pp">Beware that if you set the configuration for overloaded
        operators to &quot;input=decimal&quot;, this method will be called for
        every scalar operand you use!</p>
  </li>
  <li><span class="Li">&quot;$string = $vector-&gt;to_Enum();&quot;</span>
    <p class="Pp">Converts the given bit vector or set into an enumeration of
        single indices and ranges of indices (&quot;.newsrc&quot; style),
        representing the bits that are set
        (&quot;<span class="Li">1</span>&quot;) in the bit vector.</p>
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>
  $vector = Bit::Vector-&gt;new(20);
  $vector-&gt;Bit_On(2);
  $vector-&gt;Bit_On(3);
  $vector-&gt;Bit_On(11);
  $vector-&gt;Interval_Fill(5,7);
  $vector-&gt;Interval_Fill(13,19);
  print &quot;'&quot;, $vector-&gt;to_Enum(), &quot;'\n&quot;;
    </pre>
    <p class="Pp">which prints</p>
    <p class="Pp"></p>
    <pre>
  '2,3,5-7,11,13-19'
    </pre>
    <p class="Pp">If the given bit vector is empty, the resulting string will
        also be empty.</p>
    <p class="Pp">Note, by the way, that the above example can also be written a
        little handier, perhaps, as follows:</p>
    <p class="Pp"></p>
    <pre>
  Bit::Vector-&gt;Configuration(&quot;out=enum&quot;);
  $vector = Bit::Vector-&gt;new(20);
  $vector-&gt;Index_List_Store(2,3,5,6,7,11,13,14,15,16,17,18,19);
  print &quot;'$vector'\n&quot;;
    </pre>
  </li>
  <li><span class="Li">&quot;$vector-&gt;from_Enum($string);&quot;</span>
    <p class="Pp">This method first empties the given bit vector and then tries
        to set the bits and ranges of bits specified in the given string.</p>
    <p class="Pp">The string &quot;<span class="Li">$string</span>&quot; must
        only contain unsigned integers or ranges of integers (two unsigned
        integers separated by a dash &quot;-&quot;), separated by commas
        (&quot;,&quot;).</p>
    <p class="Pp">All other characters are disallowed (including white space!)
        and will lead to a fatal &quot;input string syntax error&quot;.</p>
    <p class="Pp">In each range, the first integer (the lower limit of the
        range) must always be less than or equal to the second integer (the
        upper limit), or a fatal &quot;minimum &gt; maximum index&quot; error
        occurs.</p>
    <p class="Pp">All integers must lie in the permitted range for the given bit
        vector, i.e., they must lie between
        &quot;<span class="Li">0</span>&quot; and
        &quot;<span class="Li">&quot;$vector-&gt;Size()-1&quot;</span>&quot;.</p>
    <p class="Pp">If this condition is not met, a fatal &quot;index out of
        range&quot; error occurs.</p>
    <p class="Pp">If possible program abortion is unwanted or intolerable, use
        &quot;<span class="Li">&quot;eval&quot;</span>&quot;, like this:</p>
    <p class="Pp"></p>
    <pre>
  eval { $vector-&gt;from_Enum(&quot;2,3,5-7,11,13-19&quot;); };
  if ($@)
  {
      # an error occurred
  }
    </pre>
    <p class="Pp">There are four possible error messages:</p>
    <p class="Pp"></p>
    <pre>
  if ($@ =~ /item is not a string/)

  if ($@ =~ /input string syntax error/)

  if ($@ =~ /index out of range/)

  if ($@ =~ /minimum &gt; maximum index/)
    </pre>
    <p class="Pp">Note that the order of the indices and ranges is irrelevant,
        i.e.,</p>
    <p class="Pp"></p>
    <pre>
  eval { $vector-&gt;from_Enum(&quot;11,5-7,3,13-19,2&quot;); };
    </pre>
    <p class="Pp">results in the same vector as in the example above.</p>
    <p class="Pp">Ranges and indices may also overlap.</p>
    <p class="Pp">This is because each (single) index in the string is passed to
        the method &quot;<span class="Li">&quot;Bit_On()&quot;</span>&quot;,
        internally, and each range to the method
        &quot;<span class="Li">&quot;Interval_Fill()&quot;</span>&quot;.</p>
    <p class="Pp">This means that the resulting bit vector is just the union of
        all the indices and ranges specified in the given string.</p>
  </li>
  <li><span class="Li">&quot;$vector-&gt;Bit_Off($index);&quot;</span>
    <p class="Pp">Clears the bit with index
        &quot;<span class="Li">$index</span>&quot; in the given vector.</p>
  </li>
  <li><span class="Li">&quot;$vector-&gt;Bit_On($index);&quot;</span>
    <p class="Pp">Sets the bit with index
        &quot;<span class="Li">$index</span>&quot; in the given vector.</p>
  </li>
  <li><span class="Li">&quot;$vector-&gt;bit_flip($index)&quot;</span>
    <p class="Pp">Flips (i.e., complements) the bit with index
        &quot;<span class="Li">$index</span>&quot; in the given vector.</p>
    <p class="Pp">Moreover, this method returns the <b>NEW</b> state of the bit
        in question, i.e., it returns &quot;<span class="Li">0</span>&quot; if
        the bit is cleared or &quot;<span class="Li">1</span>&quot; if the bit
        is set (<b>AFTER</b> flipping it).</p>
  </li>
  <li><span class="Li">&quot;if ($vector-&gt;bit_test($index))&quot;</span>
    <p class="Pp"><span class="Li">&quot;if
        ($vector-&gt;contains($index))&quot;</span></p>
    <p class="Pp">Returns the current state of the bit with index
        &quot;<span class="Li">$index</span>&quot; in the given vector, i.e.,
        returns &quot;<span class="Li">0</span>&quot; if it is cleared (in the
        &quot;off&quot; state) or &quot;<span class="Li">1</span>&quot; if it is
        set (in the &quot;on&quot; state).</p>
  </li>
  <li><span class="Li">&quot;$vector-&gt;Bit_Copy($index,$bit);&quot;</span>
    <p class="Pp">Sets the bit with index
        &quot;<span class="Li">$index</span>&quot; in the given vector either to
        &quot;<span class="Li">0</span>&quot; or
        &quot;<span class="Li">1</span>&quot; depending on the boolean value
        &quot;<span class="Li">$bit</span>&quot;.</p>
  </li>
  <li><span class="Li">&quot;$vector-&gt;LSB($bit);&quot;</span>
    <p class="Pp">Allows you to set the least significant bit in the given bit
        vector to the value given by the boolean parameter
        &quot;<span class="Li">$bit</span>&quot;.</p>
    <p class="Pp">This is a (faster) shortcut for
        &quot;<span class="Li">&quot;$vector-&gt;Bit_Copy(0,$bit);&quot;</span>&quot;.</p>
  </li>
  <li><span class="Li">&quot;$vector-&gt;MSB($bit);&quot;</span>
    <p class="Pp">Allows you to set the most significant bit in the given bit
        vector to the value given by the boolean parameter
        &quot;<span class="Li">$bit</span>&quot;.</p>
    <p class="Pp">This is a (faster) shortcut for
        &quot;<span class="Li">&quot;$vector-&gt;Bit_Copy($vector-&gt;Size()-1,$bit);&quot;</span>&quot;.</p>
  </li>
  <li><span class="Li">&quot;$bit = $vector-&gt;lsb();&quot;</span>
    <p class="Pp">Returns the least significant bit of the given bit vector.</p>
    <p class="Pp">This is a (faster) shortcut for
        &quot;<span class="Li">&quot;$bit =
        $vector-&gt;bit_test(0);&quot;</span>&quot;.</p>
  </li>
  <li><span class="Li">&quot;$bit = $vector-&gt;msb();&quot;</span>
    <p class="Pp">Returns the most significant bit of the given bit vector.</p>
    <p class="Pp">This is a (faster) shortcut for
        &quot;<span class="Li">&quot;$bit =
        $vector-&gt;bit_test($vector-&gt;Size()-1);&quot;</span>&quot;.</p>
  </li>
  <li><span class="Li">&quot;$carry_out =
      $vector-&gt;rotate_left();&quot;</span>
    <p class="Pp"></p>
    <pre>
  carry             MSB           vector:           LSB
   out:
  +---+            +---+---+---+---     ---+---+---+---+
  |   |  &lt;---+---  |   |   |   |    ...    |   |   |   |  &lt;---+
  +---+      |     +---+---+---+---     ---+---+---+---+      |
             |                                                |
             +------------------------------------------------+
    </pre>
    <p class="Pp">The least significant bit (LSB) is the bit with index
        &quot;<span class="Li">0</span>&quot;, the most significant bit (MSB) is
        the bit with index
        &quot;<span class="Li">&quot;$vector-&gt;Size()-1&quot;</span>&quot;.</p>
  </li>
  <li><span class="Li">&quot;$carry_out =
      $vector-&gt;rotate_right();&quot;</span>
    <p class="Pp"></p>
    <pre>
          MSB           vector:           LSB            carry
                                                          out:
         +---+---+---+---     ---+---+---+---+           +---+
  +---&gt;  |   |   |   |    ...    |   |   |   |  ---+---&gt; |   |
  |      +---+---+---+---     ---+---+---+---+     |     +---+
  |                                                |
  +------------------------------------------------+
    </pre>
    <p class="Pp">The least significant bit (LSB) is the bit with index
        &quot;<span class="Li">0</span>&quot;, the most significant bit (MSB) is
        the bit with index
        &quot;<span class="Li">&quot;$vector-&gt;Size()-1&quot;</span>&quot;.</p>
  </li>
  <li><span class="Li">&quot;$carry_out =
      $vector-&gt;shift_left($carry_in);&quot;</span>
    <p class="Pp"></p>
    <pre>
  carry         MSB           vector:           LSB         carry
   out:                                                      in:
  +---+        +---+---+---+---     ---+---+---+---+        +---+
  |   |  &lt;---  |   |   |   |    ...    |   |   |   |  &lt;---  |   |
  +---+        +---+---+---+---     ---+---+---+---+        +---+
    </pre>
    <p class="Pp">The least significant bit (LSB) is the bit with index
        &quot;<span class="Li">0</span>&quot;, the most significant bit (MSB) is
        the bit with index
        &quot;<span class="Li">&quot;$vector-&gt;Size()-1&quot;</span>&quot;.</p>
  </li>
  <li><span class="Li">&quot;$carry_out =
      $vector-&gt;shift_right($carry_in);&quot;</span>
    <p class="Pp"></p>
    <pre>
  carry         MSB           vector:           LSB         carry
   in:                                                       out:
  +---+        +---+---+---+---     ---+---+---+---+        +---+
  |   |  ---&gt;  |   |   |   |    ...    |   |   |   |  ---&gt;  |   |
  +---+        +---+---+---+---     ---+---+---+---+        +---+
    </pre>
    <p class="Pp">The least significant bit (LSB) is the bit with index
        &quot;<span class="Li">0</span>&quot;, the most significant bit (MSB) is
        the bit with index
        &quot;<span class="Li">&quot;$vector-&gt;Size()-1&quot;</span>&quot;.</p>
  </li>
  <li><span class="Li">&quot;$vector-&gt;Move_Left($bits);&quot;</span>
    <p class="Pp">Shifts the given bit vector left by
        &quot;<span class="Li">$bits</span>&quot; bits, i.e., inserts
        &quot;<span class="Li">$bits</span>&quot; new bits at the lower end
        (least significant bit) of the bit vector, moving all other bits up by
        &quot;<span class="Li">$bits</span>&quot; places, thereby losing the
        &quot;<span class="Li">$bits</span>&quot; most significant bits.</p>
    <p class="Pp">The inserted new bits are all cleared (set to the
        &quot;off&quot; state).</p>
    <p class="Pp">This method does nothing if
        &quot;<span class="Li">$bits</span>&quot; is equal to zero.</p>
    <p class="Pp">Beware that the whole bit vector is cleared <b>WITHOUT
        WARNING</b> if &quot;<span class="Li">$bits</span>&quot; is greater than
        or equal to the size of the given bit vector!</p>
    <p class="Pp">In fact this method is equivalent to</p>
    <p class="Pp"></p>
    <pre>
  for ( $i = 0; $i &lt; $bits; $i++ ) { $vector-&gt;shift_left(0); }
    </pre>
    <p class="Pp">except that it is much more efficient (for
        &quot;<span class="Li">$bits</span>&quot; greater than or equal to the
        number of bits in a machine word on your system) than this
        straightforward approach.</p>
  </li>
  <li><span class="Li">&quot;$vector-&gt;Move_Right($bits);&quot;</span>
    <p class="Pp">Shifts the given bit vector right by
        &quot;<span class="Li">$bits</span>&quot; bits, i.e., deletes the
        &quot;<span class="Li">$bits</span>&quot; least significant bits of the
        bit vector, moving all other bits down by
        &quot;<span class="Li">$bits</span>&quot; places, thereby creating
        &quot;<span class="Li">$bits</span>&quot; new bits at the upper end
        (most significant bit) of the bit vector.</p>
    <p class="Pp">These new bits are all cleared (set to the &quot;off&quot;
        state).</p>
    <p class="Pp">This method does nothing if
        &quot;<span class="Li">$bits</span>&quot; is equal to zero.</p>
    <p class="Pp">Beware that the whole bit vector is cleared <b>WITHOUT
        WARNING</b> if &quot;<span class="Li">$bits</span>&quot; is greater than
        or equal to the size of the given bit vector!</p>
    <p class="Pp">In fact this method is equivalent to</p>
    <p class="Pp"></p>
    <pre>
  for ( $i = 0; $i &lt; $bits; $i++ ) { $vector-&gt;shift_right(0); }
    </pre>
    <p class="Pp">except that it is much more efficient (for
        &quot;<span class="Li">$bits</span>&quot; greater than or equal to the
        number of bits in a machine word on your system) than this
        straightforward approach.</p>
  </li>
  <li><span class="Li">&quot;$vector-&gt;Insert($offset,$bits);&quot;</span>
    <p class="Pp">This method inserts &quot;<span class="Li">$bits</span>&quot;
        fresh new bits at position &quot;<span class="Li">$offset</span>&quot;
        in the given bit vector.</p>
    <p class="Pp">The &quot;<span class="Li">$bits</span>&quot; most significant
        bits are lost, and all bits starting with bit number
        &quot;<span class="Li">$offset</span>&quot; up to and including bit
        number
        &quot;<span class="Li">&quot;$vector-&gt;Size()-$bits-1&quot;</span>&quot;
        are moved up by &quot;<span class="Li">$bits</span>&quot; places.</p>
    <p class="Pp">The now vacant &quot;<span class="Li">$bits</span>&quot; bits
        starting at bit number &quot;<span class="Li">$offset</span>&quot; (up
        to and including bit number
        &quot;<span class="Li">&quot;$offset+$bits-1&quot;</span>&quot;) are
        then set to zero (cleared).</p>
    <p class="Pp">Note that this method does <b>NOT</b> increase the size of the
        given bit vector, i.e., the bit vector is <b>NOT</b> extended at its
        upper end to &quot;rescue&quot; the
        &quot;<span class="Li">$bits</span>&quot; uppermost (most significant)
        bits - instead, these bits are lost forever.</p>
    <p class="Pp">If you don't want this to happen, you have to increase the
        size of the given bit vector <b>EXPLICITLY</b> and <b>BEFORE</b> you
        perform the &quot;Insert&quot; operation, with a statement such as the
        following:</p>
    <p class="Pp"></p>
    <pre>
  $vector-&gt;Resize($vector-&gt;Size() + $bits);
    </pre>
    <p class="Pp">Or use the method
        &quot;<span class="Li">&quot;Interval_Substitute()&quot;</span>&quot;
        instead of &quot;<span class="Li">&quot;Insert()&quot;</span>&quot;,
        which performs automatic growing and shrinking of its target bit
      vector.</p>
    <p class="Pp">Note also that &quot;<span class="Li">$offset</span>&quot;
        must lie in the permitted range between
        &quot;<span class="Li">0</span>&quot; and
        &quot;<span class="Li">&quot;$vector-&gt;Size()-1&quot;</span>&quot;, or
        a fatal &quot;offset out of range&quot; error will occur.</p>
    <p class="Pp">If the term &quot;<span class="Li">&quot;$offset +
        $bits&quot;</span>&quot; exceeds
        &quot;<span class="Li">&quot;$vector-&gt;Size()-1&quot;</span>&quot;,
        all the bits starting with bit number
        &quot;<span class="Li">$offset</span>&quot; up to bit number
        &quot;<span class="Li">&quot;$vector-&gt;Size()-1&quot;</span>&quot; are
        simply cleared.</p>
  </li>
  <li><span class="Li">&quot;$vector-&gt;Delete($offset,$bits);&quot;</span>
    <p class="Pp">This method deletes, i.e., removes the bits starting at
        position &quot;<span class="Li">$offset</span>&quot; up to and including
        bit number
        &quot;<span class="Li">&quot;$offset+$bits-1&quot;</span>&quot; from the
        given bit vector.</p>
    <p class="Pp">The remaining uppermost bits (starting at position
        &quot;<span class="Li">&quot;$offset+$bits&quot;</span>&quot; up to and
        including bit number
        &quot;<span class="Li">&quot;$vector-&gt;Size()-1&quot;</span>&quot;)
        are moved down by &quot;<span class="Li">$bits</span>&quot; places.</p>
    <p class="Pp">The now vacant uppermost (most significant)
        &quot;<span class="Li">$bits</span>&quot; bits are then set to zero
        (cleared).</p>
    <p class="Pp">Note that this method does <b>NOT</b> decrease the size of the
        given bit vector, i.e., the bit vector is <b>NOT</b> clipped at its
        upper end to &quot;get rid of&quot; the vacant
        &quot;<span class="Li">$bits</span>&quot; uppermost bits.</p>
    <p class="Pp">If you don't want this, i.e., if you want the bit vector to
        shrink accordingly, you have to do so <b>EXPLICITLY</b> and <b>AFTER</b>
        the &quot;Delete&quot; operation, with a couple of statements such as
        these:</p>
    <p class="Pp"></p>
    <pre>
  $size = $vector-&gt;Size();
  if ($bits &gt; $size) { $bits = $size; }
  $vector-&gt;Resize($size - $bits);
    </pre>
    <p class="Pp">Or use the method
        &quot;<span class="Li">&quot;Interval_Substitute()&quot;</span>&quot;
        instead of &quot;<span class="Li">&quot;Delete()&quot;</span>&quot;,
        which performs automatic growing and shrinking of its target bit
      vector.</p>
    <p class="Pp">Note also that &quot;<span class="Li">$offset</span>&quot;
        must lie in the permitted range between
        &quot;<span class="Li">0</span>&quot; and
        &quot;<span class="Li">&quot;$vector-&gt;Size()-1&quot;</span>&quot;, or
        a fatal &quot;offset out of range&quot; error will occur.</p>
    <p class="Pp">If the term &quot;<span class="Li">&quot;$offset +
        $bits&quot;</span>&quot; exceeds
        &quot;<span class="Li">&quot;$vector-&gt;Size()-1&quot;</span>&quot;,
        all the bits starting with bit number
        &quot;<span class="Li">$offset</span>&quot; up to bit number
        &quot;<span class="Li">&quot;$vector-&gt;Size()-1&quot;</span>&quot; are
        simply cleared.</p>
  </li>
  <li><span class="Li">&quot;$carry = $vector-&gt;increment();&quot;</span>
    <p class="Pp">This method increments the given bit vector.</p>
    <p class="Pp">Note that this method regards bit vectors as being unsigned,
        i.e., the largest possible positive number is directly followed by the
        smallest possible (or greatest possible, speaking in absolute terms)
        negative number:</p>
    <p class="Pp"></p>
    <pre>
  before:  2 ^ (b-1) - 1    (= &quot;0111...1111&quot;)
  after:   2 ^ (b-1)        (= &quot;1000...0000&quot;)
    </pre>
    <p class="Pp">where &quot;<span class="Li">&quot;b&quot;</span>&quot; is the
        number of bits of the given bit vector.</p>
    <p class="Pp">The method returns &quot;false&quot;
        (&quot;<span class="Li">0</span>&quot;) in all cases except when a carry
        over occurs (in which case it returns &quot;true&quot;, i.e.,
        &quot;<span class="Li">1</span>&quot;), which happens when the number
        &quot;1111...1111&quot; is incremented, which gives
        &quot;0000...0000&quot; plus a carry over to the next higher (binary)
        digit.</p>
    <p class="Pp">This can be used for the terminating condition of a
        &quot;while&quot; loop, for instance, in order to cycle through all
        possible values the bit vector can assume.</p>
  </li>
  <li><span class="Li">&quot;$carry = $vector-&gt;decrement();&quot;</span>
    <p class="Pp">This method decrements the given bit vector.</p>
    <p class="Pp">Note that this method regards bit vectors as being unsigned,
        i.e., the smallest possible (or greatest possible, speaking in absolute
        terms) negative number is directly followed by the largest possible
        positive number:</p>
    <p class="Pp"></p>
    <pre>
  before:  2 ^ (b-1)        (= &quot;1000...0000&quot;)
  after:   2 ^ (b-1) - 1    (= &quot;0111...1111&quot;)
    </pre>
    <p class="Pp">where &quot;<span class="Li">&quot;b&quot;</span>&quot; is the
        number of bits of the given bit vector.</p>
    <p class="Pp">The method returns &quot;false&quot;
        (&quot;<span class="Li">0</span>&quot;) in all cases except when a carry
        over occurs (in which case it returns &quot;true&quot;, i.e.,
        &quot;<span class="Li">1</span>&quot;), which happens when the number
        &quot;0000...0000&quot; is decremented, which gives
        &quot;1111...1111&quot; minus a carry over to the next higher (binary)
        digit.</p>
    <p class="Pp">This can be used for the terminating condition of a
        &quot;while&quot; loop, for instance, in order to cycle through all
        possible values the bit vector can assume.</p>
  </li>
  <li><span class="Li">&quot;$overflow = $vec2-&gt;inc($vec1);&quot;</span>
    <p class="Pp">This method copies the contents of bit vector
        &quot;<span class="Li">$vec1</span>&quot; to bit vector
        &quot;<span class="Li">$vec2</span>&quot; and increments the copy (not
        the original).</p>
    <p class="Pp">If by incrementing the number its sign becomes invalid, the
        return value (&quot;overflow&quot; flag) will be true
        (&quot;<span class="Li">1</span>&quot;), or false
        (&quot;<span class="Li">0</span>&quot;) if not. (See the description of
        the method &quot;<b>add()</b>&quot; below for a more in-depth
        explanation of what &quot;overflow&quot; means).</p>
    <p class="Pp">Note that in-place operation is also possible, i.e.,
        &quot;<span class="Li">$vec1</span>&quot; and
        &quot;<span class="Li">$vec2</span>&quot; may be identical.</p>
  </li>
  <li><span class="Li">&quot;$overflow = $vec2-&gt;dec($vec1);&quot;</span>
    <p class="Pp">This method copies the contents of bit vector
        &quot;<span class="Li">$vec1</span>&quot; to bit vector
        &quot;<span class="Li">$vec2</span>&quot; and decrements the copy (not
        the original).</p>
    <p class="Pp">If by decrementing the number its sign becomes invalid, the
        return value (&quot;overflow&quot; flag) will be true
        (&quot;<span class="Li">1</span>&quot;), or false
        (&quot;<span class="Li">0</span>&quot;) if not. (See the description of
        the method &quot;<b>subtract()</b>&quot; below for a more in-depth
        explanation of what &quot;overflow&quot; means).</p>
    <p class="Pp">Note that in-place operation is also possible, i.e.,
        &quot;<span class="Li">$vec1</span>&quot; and
        &quot;<span class="Li">$vec2</span>&quot; may be identical.</p>
  </li>
  <li><span class="Li">&quot;$carry =
      $vec3-&gt;add($vec1,$vec2,$carry);&quot;</span>
    <p class="Pp"><span class="Li">&quot;($carry,$overflow) =
        $vec3-&gt;add($vec1,$vec2,$carry);&quot;</span></p>
    <p class="Pp">This method adds the two numbers contained in bit vector
        &quot;<span class="Li">$vec1</span>&quot; and
        &quot;<span class="Li">$vec2</span>&quot; with carry
        &quot;<span class="Li">$carry</span>&quot; and stores the result in bit
        vector &quot;<span class="Li">$vec3</span>&quot;.</p>
    <p class="Pp">I.e.,
      <br/>
       <span class="Li">$vec3</span> = <span class="Li">$vec1</span> +
        <span class="Li">$vec2</span> + <span class="Li">$carry</span></p>
    <p class="Pp">Note that the &quot;<span class="Li">$carry</span>&quot;
        parameter is a boolean value, i.e., only its least significant bit is
        taken into account. (Think of it as though
        &quot;<span class="Li">&quot;$carry &amp;= 1;&quot;</span>&quot; was
        always executed internally.)</p>
    <p class="Pp">In scalar context, the method returns a boolean value which
        indicates if a carry over (to the next higher bit position) has occured.
        In list context, the method returns the carry and the overflow flag (in
        this order).</p>
    <p class="Pp">The overflow flag is true
        (&quot;<span class="Li">1</span>&quot;) if the sign (i.e., the most
        significant bit) of the result is wrong. This can happen when adding two
        very large positive numbers or when adding two (by their absolute value)
        very large negative numbers. See also further below.</p>
    <p class="Pp">The carry in- and output is needed mainly for cascading, i.e.,
        to add numbers that are fragmented into several pieces.</p>
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>
  # initialize

  for ( $i = 0; $i &lt; $n; $i++ )
  {
      $a[$i] = Bit::Vector-&gt;new($bits);
      $b[$i] = Bit::Vector-&gt;new($bits);
      $c[$i] = Bit::Vector-&gt;new($bits);
  }

  # fill @a and @b

  # $a[  0 ] is low order part,
  # $a[$n-1] is high order part,
  # and same for @b

  # add

  $carry = 0;
  for ( $i = 0; $i &lt; $n; $i++ )
  {
      $carry = $c[$i]-&gt;add($a[$i],$b[$i],$carry);
  }
    </pre>
    <p class="Pp">Note that it makes no difference to this method whether the
        numbers in &quot;<span class="Li">$vec1</span>&quot; and
        &quot;<span class="Li">$vec2</span>&quot; are unsigned or signed (i.e.,
        in two's complement binary representation).</p>
    <p class="Pp">Note however that the return value (carry flag) is not
        meaningful when the numbers are <b>SIGNED</b>.</p>
    <p class="Pp">Moreover, when the numbers are signed, a special type of error
        can occur which is commonly called an &quot;overflow error&quot;.</p>
    <p class="Pp">An overflow error occurs when the sign of the result (its most
        significant bit) is flipped (i.e., falsified) by a carry over from the
        next-lower bit position (&quot;MSB-1&quot;).</p>
    <p class="Pp">In fact matters are a bit more complicated than that: the
        overflow flag is set to &quot;true&quot; whenever there is a carry over
        from bit position MSB-1 to the most significant bit (MSB) but no carry
        over from the MSB to the output carry flag, or vice-versa, i.e., when
        there is no carry over from bit position MSB-1 to the most significant
        bit (MSB) but a carry over to the output carry flag.</p>
    <p class="Pp">Thus the overflow flag is the result of an exclusive-or
        operation between incoming and outgoing carry over at the most
        significant bit position.</p>
  </li>
  <li><span class="Li">&quot;$carry =
      $vec3-&gt;subtract($vec1,$vec2,$carry);&quot;</span>
    <p class="Pp"><span class="Li">&quot;($carry,$overflow) =
        $vec3-&gt;subtract($vec1,$vec2,$carry);&quot;</span></p>
    <p class="Pp">This method subtracts the two numbers contained in bit vector
        &quot;<span class="Li">$vec1</span>&quot; and
        &quot;<span class="Li">$vec2</span>&quot; with carry
        &quot;<span class="Li">$carry</span>&quot; and stores the result in bit
        vector &quot;<span class="Li">$vec3</span>&quot;.</p>
    <p class="Pp">I.e.,
      <br/>
       <span class="Li">$vec3</span> = <span class="Li">$vec1</span> -
        <span class="Li">$vec2</span> - <span class="Li">$carry</span></p>
    <p class="Pp">Note that the &quot;<span class="Li">$carry</span>&quot;
        parameter is a boolean value, i.e., only its least significant bit is
        taken into account. (Think of it as though
        &quot;<span class="Li">&quot;$carry &amp;= 1;&quot;</span>&quot; was
        always executed internally.)</p>
    <p class="Pp">In scalar context, the method returns a boolean value which
        indicates if a carry over (to the next higher bit position) has occured.
        In list context, the method returns the carry and the overflow flag (in
        this order).</p>
    <p class="Pp">The overflow flag is true
        (&quot;<span class="Li">1</span>&quot;) if the sign (i.e., the most
        significant bit) of the result is wrong. This can happen when
        subtracting a very large negative number from a very large positive
        number or vice-versa. See also further below.</p>
    <p class="Pp">The carry in- and output is needed mainly for cascading, i.e.,
        to subtract numbers that are fragmented into several pieces.</p>
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>
  # initialize

  for ( $i = 0; $i &lt; $n; $i++ )
  {
      $a[$i] = Bit::Vector-&gt;new($bits);
      $b[$i] = Bit::Vector-&gt;new($bits);
      $c[$i] = Bit::Vector-&gt;new($bits);
  }

  # fill @a and @b

  # $a[  0 ] is low order part,
  # $a[$n-1] is high order part,
  # and same for @b

  # subtract

  $carry = 0;
  for ( $i = 0; $i &lt; $n; $i++ )
  {
      $carry = $c[$i]-&gt;subtract($a[$i],$b[$i],$carry);
  }
    </pre>
    <p class="Pp">Note that it makes no difference to this method whether the
        numbers in &quot;<span class="Li">$vec1</span>&quot; and
        &quot;<span class="Li">$vec2</span>&quot; are unsigned or signed (i.e.,
        in two's complement binary representation).</p>
    <p class="Pp">Note however that the return value (carry flag) is not
        meaningful when the numbers are <b>SIGNED</b>.</p>
    <p class="Pp">Moreover, when the numbers are signed, a special type of error
        can occur which is commonly called an &quot;overflow error&quot;.</p>
    <p class="Pp">An overflow error occurs when the sign of the result (its most
        significant bit) is flipped (i.e., falsified) by a carry over from the
        next-lower bit position (&quot;MSB-1&quot;).</p>
    <p class="Pp">In fact matters are a bit more complicated than that: the
        overflow flag is set to &quot;true&quot; whenever there is a carry over
        from bit position MSB-1 to the most significant bit (MSB) but no carry
        over from the MSB to the output carry flag, or vice-versa, i.e., when
        there is no carry over from bit position MSB-1 to the most significant
        bit (MSB) but a carry over to the output carry flag.</p>
    <p class="Pp">Thus the overflow flag is the result of an exclusive-or
        operation between incoming and outgoing carry over at the most
        significant bit position.</p>
  </li>
  <li><span class="Li">&quot;$vec2-&gt;Neg($vec1);&quot;</span>
    <p class="Pp"><span class="Li">&quot;$vec2-&gt;Negate($vec1);&quot;</span></p>
    <p class="Pp">This method calculates the two's complement of the number in
        bit vector &quot;<span class="Li">$vec1</span>&quot; and stores the
        result in bit vector &quot;<span class="Li">$vec2</span>&quot;.</p>
    <p class="Pp">Calculating the two's complement of a given number in binary
        representation consists of inverting all bits and incrementing the
        result by one.</p>
    <p class="Pp">This is the same as changing the sign of the given number from
        &quot;<span class="Li">&quot;+&quot;</span>&quot; to
        &quot;<span class="Li">&quot;-&quot;</span>&quot; or vice-versa. In
        other words, applying this method twice on a given number yields the
        original number again.</p>
    <p class="Pp">Note that in-place processing is also possible, i.e.,
        &quot;<span class="Li">$vec1</span>&quot; and
        &quot;<span class="Li">$vec2</span>&quot; may be identical.</p>
    <p class="Pp">Most importantly, beware that this method produces a
        counter-intuitive result if the number contained in bit vector
        &quot;<span class="Li">$vec1</span>&quot; is <span class="Li">&quot;2 ^
        (n-1)&quot;</span> (i.e., &quot;1000...0000&quot;), where
        &quot;<span class="Li">&quot;n&quot;</span>&quot; is the number of bits
        the given bit vector contains: The negated value of this number is the
        number itself!</p>
  </li>
  <li><span class="Li">&quot;$vec2-&gt;Abs($vec1);&quot;</span>
    <p class="Pp"><span class="Li">&quot;$vec2-&gt;Absolute($vec1);&quot;</span></p>
    <p class="Pp">Depending on the sign (i.e., the most significant bit) of the
        number in bit vector &quot;<span class="Li">$vec1</span>&quot;, the
        contents of bit vector &quot;<span class="Li">$vec1</span>&quot; are
        copied to bit vector &quot;<span class="Li">$vec2</span>&quot; either
        with the method &quot;<span class="Li">&quot;Copy()&quot;</span>&quot;
        (if the number in bit vector &quot;<span class="Li">$vec1</span>&quot;
        is positive), or with
        &quot;<span class="Li">&quot;Negate()&quot;</span>&quot; (if the number
        in bit vector &quot;<span class="Li">$vec1</span>&quot; is
      negative).</p>
    <p class="Pp">In other words, this method calculates the absolute value of
        the number in bit vector &quot;<span class="Li">$vec1</span>&quot; and
        stores the result in bit vector
        &quot;<span class="Li">$vec2</span>&quot;.</p>
    <p class="Pp">Note that in-place processing is also possible, i.e.,
        &quot;<span class="Li">$vec1</span>&quot; and
        &quot;<span class="Li">$vec2</span>&quot; may be identical.</p>
    <p class="Pp">Most importantly, beware that this method produces a
        counter-intuitive result if the number contained in bit vector
        &quot;<span class="Li">$vec1</span>&quot; is <span class="Li">&quot;2 ^
        (n-1)&quot;</span> (i.e., &quot;1000...0000&quot;), where
        &quot;<span class="Li">&quot;n&quot;</span>&quot; is the number of bits
        the given bit vector contains: The absolute value of this number is the
        number itself, even though this number is still negative by definition
        (the most significant bit is still set)!</p>
  </li>
  <li><span class="Li">&quot;$sign = $vector-&gt;Sign();&quot;</span>
    <p class="Pp">This method returns &quot;<span class="Li">0</span>&quot; if
        all bits in the given bit vector are cleared, i.e., if the given bit
        vector contains the number &quot;<span class="Li">0</span>&quot;, or if
        the given bit vector has a length of zero (contains no bits at all).</p>
    <p class="Pp">If not all bits are cleared, this method returns
        &quot;<span class="Li">&quot;-1&quot;</span>&quot; if the most
        significant bit is set (i.e., if the bit vector contains a negative
        number), or &quot;<span class="Li">1</span>&quot; otherwise (i.e., if
        the bit vector contains a positive number).</p>
  </li>
  <li><span class="Li">&quot;$vec3-&gt;Multiply($vec1,$vec2);&quot;</span>
    <p class="Pp">This method multiplies the two numbers contained in bit vector
        &quot;<span class="Li">$vec1</span>&quot; and
        &quot;<span class="Li">$vec2</span>&quot; and stores the result in bit
        vector &quot;<span class="Li">$vec3</span>&quot;.</p>
    <p class="Pp">Note that this method regards its arguments as
      <b>SIGNED</b>.</p>
    <p class="Pp">If you want to make sure that a large number can never be
        treated as being negative by mistake, make your bit vectors at least one
        bit longer than the largest number you wish to represent, right from the
        start, or proceed as follows:</p>
    <p class="Pp"></p>
    <pre>
    $msb1 = $vec1-&gt;msb();
    $msb2 = $vec2-&gt;msb();
    $vec1-&gt;Resize($vec1-&gt;Size()+1);
    $vec2-&gt;Resize($vec2-&gt;Size()+1);
    $vec3-&gt;Resize($vec3-&gt;Size()+1);
    $vec1-&gt;MSB($msb1);
    $vec2-&gt;MSB($msb2);
    $vec3-&gt;Multiply($vec1,$vec2);
    </pre>
    <p class="Pp">Note also that all three bit vector arguments must in
        principle obey the rule of matching sizes, but that the bit vector
        &quot;<span class="Li">$vec3</span>&quot; may be larger than the two
        factors &quot;<span class="Li">$vec1</span>&quot; and
        &quot;<span class="Li">$vec2</span>&quot;.</p>
    <p class="Pp">In fact multiplying two binary numbers with
        &quot;<span class="Li">&quot;n&quot;</span>&quot; bits may yield a
        result which is at most
        &quot;<span class="Li">&quot;2n&quot;</span>&quot; bits long.</p>
    <p class="Pp">Therefore, it is usually a good idea to let bit vector
        &quot;<span class="Li">$vec3</span>&quot; have twice the size of bit
        vector &quot;<span class="Li">$vec1</span>&quot; and
        &quot;<span class="Li">$vec2</span>&quot;, unless you are absolutely
        sure that the result will fit into a bit vector of the same size as the
        two factors.</p>
    <p class="Pp">If you are wrong, a fatal &quot;numeric overflow error&quot;
        will occur.</p>
    <p class="Pp">Finally, note that in-place processing is possible, i.e.,
        &quot;<span class="Li">$vec3</span>&quot; may be identical with
        &quot;<span class="Li">$vec1</span>&quot; or
        &quot;<span class="Li">$vec2</span>&quot;, or both.</p>
  </li>
  <li><span class="Li">&quot;$quot-&gt;Divide($vec1,$vec2,$rest);&quot;</span>
    <p class="Pp">This method divides the two numbers contained in bit vector
        &quot;<span class="Li">$vec1</span>&quot; and
        &quot;<span class="Li">$vec2</span>&quot; and stores the quotient in bit
        vector &quot;<span class="Li">$quot</span>&quot; and the remainder in
        bit vector &quot;<span class="Li">$rest</span>&quot;.</p>
    <p class="Pp">I.e.,
      <br/>
       <span class="Li">$quot</span> = <span class="Li">$vec1</span> /
        <span class="Li">$vec2</span>; # div
      <br/>
       <span class="Li">$rest</span> = <span class="Li">$vec1</span> %
        <span class="Li">$vec2</span>; # mod</p>
    <p class="Pp">Therefore, &quot;<span class="Li">$quot</span>&quot; and
        &quot;<span class="Li">$rest</span>&quot; must be two <b>DISTINCT</b>
        bit vectors, or a fatal &quot;result vector(s) must be distinct&quot;
        error will occur.</p>
    <p class="Pp">Note also that a fatal &quot;division by zero error&quot; will
        occur if &quot;<span class="Li">$vec2</span>&quot; is equal to zero.</p>
    <p class="Pp">Note further that this method regards its arguments as
        <b>SIGNED</b>.</p>
    <p class="Pp">If you want to make sure that a large number can never be
        treated as being negative by mistake, make your bit vectors at least one
        bit longer than the largest number you wish to represent, right from the
        start, or proceed as follows:</p>
    <p class="Pp"></p>
    <pre>
    $msb1 = $vec1-&gt;msb();
    $msb2 = $vec2-&gt;msb();
    $vec1-&gt;Resize($vec1-&gt;Size()+1);
    $vec2-&gt;Resize($vec2-&gt;Size()+1);
    $quot-&gt;Resize($quot-&gt;Size()+1);
    $rest-&gt;Resize($rest-&gt;Size()+1);
    $vec1-&gt;MSB($msb1);
    $vec2-&gt;MSB($msb2);
    $quot-&gt;Divide($vec1,$vec2,$rest);
    </pre>
    <p class="Pp">Finally, note that in-place processing is possible, i.e.,
        &quot;<span class="Li">$quot</span>&quot; may be identical with
        &quot;<span class="Li">$vec1</span>&quot; or
        &quot;<span class="Li">$vec2</span>&quot; or both, and
        &quot;<span class="Li">$rest</span>&quot; may also be identical with
        &quot;<span class="Li">$vec1</span>&quot; or
        &quot;<span class="Li">$vec2</span>&quot; or both, as long as
        &quot;<span class="Li">$quot</span>&quot; and
        &quot;<span class="Li">$rest</span>&quot; are distinct. (!)</p>
  </li>
  <li><span class="Li">&quot;$vecgcd-&gt;GCD($veca,$vecb);&quot;</span>
    <p class="Pp">This method calculates the &quot;Greatest Common Divisor&quot;
        of the two numbers contained in bit vector
        &quot;<span class="Li">$veca</span>&quot; and
        &quot;<span class="Li">$vecb</span>&quot; and stores the result in bit
        vector &quot;<span class="Li">$vecgcd</span>&quot;.</p>
    <p class="Pp">The method uses Euklid's algorithm internally:</p>
    <p class="Pp"></p>
    <pre>
    int GCD(int a, int b)
    {
        int t;

        while (b != 0)
        {
            t = a % b; /* = remainder of (a div b) */
            a = b;
            b = t;
        }
        return(a);
    }
    </pre>
    <p class="Pp">Note that <span class="Li">&quot;GCD(z,0) == GCD(0,z) ==
        z&quot;</span>.</p>
  </li>
  <li><span class="Li">&quot;$vecgcd-&gt;GCD($vecx,$vecy,$veca,$vecb);&quot;</span>
    <p class="Pp">This variant of the &quot;GCD&quot; method calculates the
        &quot;Greatest Common Divisor&quot; of the two numbers contained in bit
        vector &quot;<span class="Li">$veca</span>&quot; and
        &quot;<span class="Li">$vecb</span>&quot; and stores the result in bit
        vector &quot;<span class="Li">$vecgcd</span>&quot;.</p>
    <p class="Pp">Moreover, it determines the two factors which are necessary in
        order to represent the greatest common divisor as a linear combination
        of its two arguments, i.e., the two factors
        <span class="Li">&quot;x&quot;</span> and
        <span class="Li">&quot;y&quot;</span> so that
        <span class="Li">&quot;GCD(a,b) == x * a + y * b&quot;</span>, and
        stores them in bit vector &quot;<span class="Li">$vecx</span>&quot; and
        &quot;<span class="Li">$vecy</span>&quot;, respectively.</p>
    <p class="Pp">For example:</p>
    <p class="Pp"></p>
    <pre>
  a = 2322
  b =  654

  GCD( 2322, 654 ) == 6

  x =  20
  y = -71

  20 * 2322 - 71 * 654 == 6
    </pre>
    <p class="Pp">Please see http://www.cut-the-knot.org/blue/extension.shtml
        for an explanation of how this extension of Euklid's algorithm
      works.</p>
  </li>
  <li><span class="Li">&quot;$vec3-&gt;Power($vec1,$vec2);&quot;</span>
    <p class="Pp">This method calculates the exponentiation of base
        &quot;<span class="Li">$vec1</span>&quot; elevated to the
        &quot;<span class="Li">$vec2</span>&quot; power, i.e.,
        &quot;<span class="Li">&quot;$vec1 ** $vec2&quot;</span>&quot;, and
        stores the result in bit vector
        &quot;<span class="Li">$vec3</span>&quot;.</p>
    <p class="Pp">The method uses an efficient divide-and-conquer algorithm:</p>
    <p class="Pp">Suppose the exponent is (decimal) 13, for example. The binary
        representation of this exponent is &quot;1101&quot;.</p>
    <p class="Pp">This means we want to calculate</p>
    <p class="Pp"></p>
    <pre>
  $vec1 * $vec1 * $vec1 * $vec1 * $vec1 * $vec1 * $vec1 * $vec1 *
  $vec1 * $vec1 * $vec1 * $vec1 *
  $vec1
    </pre>
    <p class="Pp">That is, &quot;<span class="Li">$vec1</span>&quot; multiplied
        with itself 13 times. The grouping into lines above is no coincidence.
        The first line comprises 8 factors, the second contains 4, and the last
        line just one. This just happens to be the binary representation of 13.
        <span class="Li">&quot;;-)&quot;</span></p>
    <p class="Pp">We then calculate a series of squares (of squares of
        squares...) of the base, i.e.,</p>
    <p class="Pp"></p>
    <pre>
  $power[0] = $vec1;
  $power[1] = $vec1 * $vec1;
  $power[2] = $power[1] * $power[1];
  $power[3] = $power[2] * $power[2];
  etc.
    </pre>
    <p class="Pp">To calculate the power of our example, we simply initialize
        our result with 1 and consecutively multiply it with the items of the
        series of powers we just calculated, if the corresponding bit of the
        binary representation of the exponent is set:</p>
    <p class="Pp"></p>
    <pre>
  $result = 1;
  $result *= $power[0] if ($vec2 &amp; 1);
  $result *= $power[1] if ($vec2 &amp; 2);
  $result *= $power[2] if ($vec2 &amp; 4);
  $result *= $power[3] if ($vec2 &amp; 8);
  etc.
    </pre>
    <p class="Pp">The bit vector &quot;<span class="Li">$vec3</span>&quot; must
        be of the same size as the base
        &quot;<span class="Li">$vec1</span>&quot; or greater.
        &quot;<span class="Li">$vec3</span>&quot; and
        &quot;<span class="Li">$vec1</span>&quot; may be the same vector (i.e.,
        in-place calculation as in &quot;<span class="Li">&quot;$vec1 **=
        $vec2;&quot;</span>&quot; is possible), but
        &quot;<span class="Li">$vec3</span>&quot; and
        &quot;<span class="Li">$vec2</span>&quot; must be distinct. Finally, the
        exponent &quot;<span class="Li">$vec2</span>&quot; must be positive. A
        fatal error occurs if any of these conditions is not met.</p>
  </li>
  <li><span class="Li">&quot;$vector-&gt;Block_Store($buffer);&quot;</span>
    <p class="Pp">This method allows you to load the contents of a given bit
        vector in one go.</p>
    <p class="Pp">This is useful when you store the contents of a bit vector in
        a file, for instance (using method
        &quot;<span class="Li">&quot;Block_Read()&quot;</span>&quot;), and when
        you want to restore the previously saved bit vector.</p>
    <p class="Pp">For this, &quot;<span class="Li">$buffer</span>&quot;
        <b>MUST</b> be a string (<b>NO</b> automatic conversion from numeric to
        string is provided here as would normally in Perl!) containing the bit
        vector in &quot;low order byte first&quot; order.</p>
    <p class="Pp">If the given string is shorter than what is needed to
        completely fill the given bit vector, the remaining (most significant)
        bytes of the bit vector are filled with zeros, i.e., the previous
        contents of the bit vector are always erased completely.</p>
    <p class="Pp">If the given string is longer than what is needed to
        completely fill the given bit vector, the superfluous bytes are simply
        ignored.</p>
    <p class="Pp">See &quot;sysread&quot; in perlfunc for how to read in the
        contents of &quot;<span class="Li">$buffer</span>&quot; from a file
        prior to passing it to this method.</p>
  </li>
  <li><span class="Li">&quot;$buffer = $vector-&gt;Block_Read();&quot;</span>
    <p class="Pp">This method allows you to export the contents of a given bit
        vector in one block.</p>
    <p class="Pp">This is useful when you want to save the contents of a bit
        vector for later, for instance in a file.</p>
    <p class="Pp">The advantage of this method is that it allows you to do so in
        the compactest possible format, in binary.</p>
    <p class="Pp">The method returns a Perl string which contains an exact copy
        of the contents of the given bit vector in &quot;low order byte
        first&quot; order.</p>
    <p class="Pp">See &quot;syswrite&quot; in perlfunc for how to write the data
        from this string to a file.</p>
  </li>
  <li><span class="Li">&quot;$size = $vector-&gt;Word_Size();&quot;</span>
    <p class="Pp">Each bit vector is internally organized as an array of machine
        words.</p>
    <p class="Pp">The methods whose names begin with &quot;Word_&quot; allow you
        to access this internal array of machine words.</p>
    <p class="Pp">Note that because the size of a machine word may vary from
        system to system, these methods are inherently
      <b>MACHINE-DEPENDENT</b>!</p>
    <p class="Pp">Therefore, <b>DO NOT USE</b> these methods unless you are
        absolutely certain that portability of your code is not an issue!</p>
    <p class="Pp">You have been warned!</p>
    <p class="Pp">To be machine-independent, use the methods whose names begin
        with &quot;<span class="Li">&quot;Chunk_&quot;</span>&quot; instead,
        with chunk sizes no greater than 32 bits.</p>
    <p class="Pp">The method
        &quot;<span class="Li">&quot;Word_Size()&quot;</span>&quot; returns the
        number of machine words that the internal array of words of the given
        bit vector contains.</p>
    <p class="Pp">This is similar in function to the term
        &quot;<span class="Li">&quot;scalar(@array)&quot;</span>&quot; for a
        Perl array.</p>
  </li>
  <li><span class="Li">&quot;$vector-&gt;Word_Store($offset,$word);&quot;</span>
    <p class="Pp">This method allows you to store a given value
        &quot;<span class="Li">$word</span>&quot; at a given position
        &quot;<span class="Li">$offset</span>&quot; in the internal array of
        words of the given bit vector.</p>
    <p class="Pp">Note that &quot;<span class="Li">$offset</span>&quot; must lie
        in the permitted range between &quot;<span class="Li">0</span>&quot; and
        &quot;<span class="Li">&quot;$vector-&gt;Word_Size()-1&quot;</span>&quot;,
        or a fatal &quot;offset out of range&quot; error will occur.</p>
    <p class="Pp">This method is similar in function to the expression
        &quot;<span class="Li">&quot;$array[$offset] = $word;&quot;</span>&quot;
        for a Perl array.</p>
  </li>
  <li><span class="Li">&quot;$word =
      $vector-&gt;Word_Read($offset);&quot;</span>
    <p class="Pp">This method allows you to access the value of a given machine
        word at position &quot;<span class="Li">$offset</span>&quot; in the
        internal array of words of the given bit vector.</p>
    <p class="Pp">Note that &quot;<span class="Li">$offset</span>&quot; must lie
        in the permitted range between &quot;<span class="Li">0</span>&quot; and
        &quot;<span class="Li">&quot;$vector-&gt;Word_Size()-1&quot;</span>&quot;,
        or a fatal &quot;offset out of range&quot; error will occur.</p>
    <p class="Pp">This method is similar in function to the expression
        &quot;<span class="Li">&quot;$word = $array[$offset];&quot;</span>&quot;
        for a Perl array.</p>
  </li>
  <li><span class="Li">&quot;$vector-&gt;Word_List_Store(@words);&quot;</span>
    <p class="Pp">This method allows you to store a list of values
        &quot;<span class="Li">@words</span>&quot; in the internal array of
        machine words of the given bit vector.</p>
    <p class="Pp">Thereby the <b>LEFTMOST</b> value in the list
        (&quot;<span class="Li">$words[0]</span>&quot;) is stored in the
        <b>LEAST</b> significant word of the internal array of words (the one
        with offset &quot;<span class="Li">0</span>&quot;), the next value from
        the list (&quot;<span class="Li">$words[1]</span>&quot;) is stored in
        the word with offset &quot;<span class="Li">1</span>&quot;, and so on,
        as intuitively expected.</p>
    <p class="Pp">If the list &quot;<span class="Li">@words</span>&quot;
        contains fewer elements than the internal array of words of the given
        bit vector contains machine words, the remaining (most significant)
        words are filled with zeros.</p>
    <p class="Pp">If the list &quot;<span class="Li">@words</span>&quot;
        contains more elements than the internal array of words of the given bit
        vector contains machine words, the superfluous values are simply
        ignored.</p>
    <p class="Pp">This method is comparable in function to the expression
        &quot;<span class="Li">&quot;@array = @words;&quot;</span>&quot; for a
        Perl array.</p>
  </li>
  <li><span class="Li">&quot;@words = $vector-&gt;Word_List_Read();&quot;</span>
    <p class="Pp">This method allows you to retrieve the internal array of
        machine words of the given bit vector all at once.</p>
    <p class="Pp">Thereby the <b>LEFTMOST</b> value in the returned list
        (&quot;<span class="Li">$words[0]</span>&quot;) is the <b>LEAST</b>
        significant word from the given bit vector, and the <b>RIGHTMOST</b>
        value in the returned list
        (&quot;<span class="Li">$words[$#words]</span>&quot;) is the <b>MOST</b>
        significant word of the given bit vector.</p>
    <p class="Pp">This method is similar in function to the expression
        &quot;<span class="Li">&quot;@words = @array;&quot;</span>&quot; for a
        Perl array.</p>
  </li>
  <li><span class="Li">&quot;$vector-&gt;Word_Insert($offset,$count);&quot;</span>
    <p class="Pp">This method inserts &quot;<span class="Li">$count</span>&quot;
        empty new machine words at position
        &quot;<span class="Li">$offset</span>&quot; in the internal array of
        words of the given bit vector.</p>
    <p class="Pp">The &quot;<span class="Li">$count</span>&quot; most
        significant words are lost, and all words starting with word number
        &quot;<span class="Li">$offset</span>&quot; up to and including word
        number
        &quot;<span class="Li">&quot;$vector-&gt;Word_Size()-$count-1&quot;</span>&quot;
        are moved up by &quot;<span class="Li">$count</span>&quot; places.</p>
    <p class="Pp">The now vacant &quot;<span class="Li">$count</span>&quot;
        words starting at word number
        &quot;<span class="Li">$offset</span>&quot; (up to and including word
        number &quot;<span class="Li">&quot;$offset+$count-1&quot;</span>&quot;)
        are then set to zero (cleared).</p>
    <p class="Pp">Note that this method does <b>NOT</b> increase the size of the
        given bit vector, i.e., the bit vector is <b>NOT</b> extended at its
        upper end to &quot;rescue&quot; the
        &quot;<span class="Li">$count</span>&quot; uppermost (most significant)
        words - instead, these words are lost forever.</p>
    <p class="Pp">If you don't want this to happen, you have to increase the
        size of the given bit vector <b>EXPLICITLY</b> and <b>BEFORE</b> you
        perform the &quot;Insert&quot; operation, with a statement such as the
        following:</p>
    <p class="Pp"></p>
    <pre>
  $vector-&gt;Resize($vector-&gt;Size() + $count * Bit::Vector-&gt;Word_Bits());
    </pre>
    <p class="Pp">Note also that &quot;<span class="Li">$offset</span>&quot;
        must lie in the permitted range between
        &quot;<span class="Li">0</span>&quot; and
        &quot;<span class="Li">&quot;$vector-&gt;Word_Size()-1&quot;</span>&quot;,
        or a fatal &quot;offset out of range&quot; error will occur.</p>
    <p class="Pp">If the term &quot;<span class="Li">&quot;$offset +
        $count&quot;</span>&quot; exceeds
        &quot;<span class="Li">&quot;$vector-&gt;Word_Size()-1&quot;</span>&quot;,
        all the words starting with word number
        &quot;<span class="Li">$offset</span>&quot; up to word number
        &quot;<span class="Li">&quot;$vector-&gt;Word_Size()-1&quot;</span>&quot;
        are simply cleared.</p>
  </li>
  <li><span class="Li">&quot;$vector-&gt;Word_Delete($offset,$count);&quot;</span>
    <p class="Pp">This method deletes, i.e., removes the words starting at
        position &quot;<span class="Li">$offset</span>&quot; up to and including
        word number
        &quot;<span class="Li">&quot;$offset+$count-1&quot;</span>&quot; from
        the internal array of machine words of the given bit vector.</p>
    <p class="Pp">The remaining uppermost words (starting at position
        &quot;<span class="Li">&quot;$offset+$count&quot;</span>&quot; up to and
        including word number
        &quot;<span class="Li">&quot;$vector-&gt;Word_Size()-1&quot;</span>&quot;)
        are moved down by &quot;<span class="Li">$count</span>&quot; places.</p>
    <p class="Pp">The now vacant uppermost (most significant)
        &quot;<span class="Li">$count</span>&quot; words are then set to zero
        (cleared).</p>
    <p class="Pp">Note that this method does <b>NOT</b> decrease the size of the
        given bit vector, i.e., the bit vector is <b>NOT</b> clipped at its
        upper end to &quot;get rid of&quot; the vacant
        &quot;<span class="Li">$count</span>&quot; uppermost words.</p>
    <p class="Pp">If you don't want this, i.e., if you want the bit vector to
        shrink accordingly, you have to do so <b>EXPLICITLY</b> and <b>AFTER</b>
        the &quot;Delete&quot; operation, with a couple of statements such as
        these:</p>
    <p class="Pp"></p>
    <pre>
  $bits = $vector-&gt;Size();
  $count *= Bit::Vector-&gt;Word_Bits();
  if ($count &gt; $bits) { $count = $bits; }
  $vector-&gt;Resize($bits - $count);
    </pre>
    <p class="Pp">Note also that &quot;<span class="Li">$offset</span>&quot;
        must lie in the permitted range between
        &quot;<span class="Li">0</span>&quot; and
        &quot;<span class="Li">&quot;$vector-&gt;Word_Size()-1&quot;</span>&quot;,
        or a fatal &quot;offset out of range&quot; error will occur.</p>
    <p class="Pp">If the term &quot;<span class="Li">&quot;$offset +
        $count&quot;</span>&quot; exceeds
        &quot;<span class="Li">&quot;$vector-&gt;Word_Size()-1&quot;</span>&quot;,
        all the words starting with word number
        &quot;<span class="Li">$offset</span>&quot; up to word number
        &quot;<span class="Li">&quot;$vector-&gt;Word_Size()-1&quot;</span>&quot;
        are simply cleared.</p>
  </li>
  <li><span class="Li">&quot;$vector-&gt;Chunk_Store($chunksize,$offset,$chunk);&quot;</span>
    <p class="Pp">This method allows you to set more than one bit at a time with
        different values.</p>
    <p class="Pp">You can access chunks (i.e., ranges of contiguous bits)
        between one and at most
        &quot;<span class="Li">&quot;Bit::Vector-&gt;Long_Bits()&quot;</span>&quot;
        bits wide.</p>
    <p class="Pp">In order to be portable, though, you should never use chunk
        sizes larger than 32 bits.</p>
    <p class="Pp">If the given &quot;<span class="Li">$chunksize</span>&quot;
        does not lie between &quot;<span class="Li">1</span>&quot; and
        &quot;<span class="Li">&quot;Bit::Vector-&gt;Long_Bits()&quot;</span>&quot;,
        a fatal &quot;chunk size out of range&quot; error will occur.</p>
    <p class="Pp">The method copies the
        &quot;<span class="Li">$chunksize</span>&quot; least significant bits
        from the value &quot;<span class="Li">$chunk</span>&quot; to the given
        bit vector, starting at bit position
        &quot;<span class="Li">$offset</span>&quot; and proceeding upwards until
        bit number
        &quot;<span class="Li">&quot;$offset+$chunksize-1&quot;</span>&quot;.</p>
    <p class="Pp">(I.e., bit number &quot;<span class="Li">0</span>&quot; of
        &quot;<span class="Li">$chunk</span>&quot; becomes bit number
        &quot;<span class="Li">$offset</span>&quot; in the given bit vector, and
        bit number &quot;<span class="Li">&quot;$chunksize-1&quot;</span>&quot;
        becomes bit number
        &quot;<span class="Li">&quot;$offset+$chunksize-1&quot;</span>&quot;.)</p>
    <p class="Pp">If the term
        &quot;<span class="Li">&quot;$offset+$chunksize-1&quot;</span>&quot;
        exceeds
        &quot;<span class="Li">&quot;$vector-&gt;Size()-1&quot;</span>&quot;,
        the corresponding superfluous (most significant) bits from
        &quot;<span class="Li">$chunk</span>&quot; are simply ignored.</p>
    <p class="Pp">Note that &quot;<span class="Li">$offset</span>&quot; itself
        must lie in the permitted range between
        &quot;<span class="Li">0</span>&quot; and
        &quot;<span class="Li">&quot;$vector-&gt;Size()-1&quot;</span>&quot;, or
        a fatal &quot;offset out of range&quot; error will occur.</p>
    <p class="Pp">This method (as well as the other
        &quot;<span class="Li">&quot;Chunk_&quot;</span>&quot; methods) is
        useful, for example, when you are reading in data in chunks of, say, 8
        bits, which you need to access later, say, using 16 bits at a time (like
        audio CD wave files, for instance).</p>
  </li>
  <li><span class="Li">&quot;$chunk =
      $vector-&gt;Chunk_Read($chunksize,$offset);&quot;</span>
    <p class="Pp">This method allows you to read the values of more than one bit
        at a time.</p>
    <p class="Pp">You can read chunks (i.e., ranges of contiguous bits) between
        one and at most
        &quot;<span class="Li">&quot;Bit::Vector-&gt;Long_Bits()&quot;</span>&quot;
        bits wide.</p>
    <p class="Pp">In order to be portable, though, you should never use chunk
        sizes larger than 32 bits.</p>
    <p class="Pp">If the given &quot;<span class="Li">$chunksize</span>&quot;
        does not lie between &quot;<span class="Li">1</span>&quot; and
        &quot;<span class="Li">&quot;Bit::Vector-&gt;Long_Bits()&quot;</span>&quot;,
        a fatal &quot;chunk size out of range&quot; error will occur.</p>
    <p class="Pp">The method returns the
        &quot;<span class="Li">$chunksize</span>&quot; bits from the given bit
        vector starting at bit position
        &quot;<span class="Li">$offset</span>&quot; and proceeding upwards until
        bit number
        &quot;<span class="Li">&quot;$offset+$chunksize-1&quot;</span>&quot;.</p>
    <p class="Pp">(I.e., bit number &quot;<span class="Li">$offset</span>&quot;
        of the given bit vector becomes bit number
        &quot;<span class="Li">0</span>&quot; of the returned value, and bit
        number
        &quot;<span class="Li">&quot;$offset+$chunksize-1&quot;</span>&quot;
        becomes bit number
        &quot;<span class="Li">&quot;$chunksize-1&quot;</span>&quot;.)</p>
    <p class="Pp">If the term
        &quot;<span class="Li">&quot;$offset+$chunksize-1&quot;</span>&quot;
        exceeds
        &quot;<span class="Li">&quot;$vector-&gt;Size()-1&quot;</span>&quot;,
        the non-existent bits are simply not returned.</p>
    <p class="Pp">Note that &quot;<span class="Li">$offset</span>&quot; itself
        must lie in the permitted range between
        &quot;<span class="Li">0</span>&quot; and
        &quot;<span class="Li">&quot;$vector-&gt;Size()-1&quot;</span>&quot;, or
        a fatal &quot;offset out of range&quot; error will occur.</p>
  </li>
  <li><span class="Li">&quot;$vector-&gt;Chunk_List_Store($chunksize,@chunks);&quot;</span>
    <p class="Pp">This method allows you to fill the given bit vector with a
        list of data packets (&quot;chunks&quot;) of any size
        (&quot;<span class="Li">$chunksize</span>&quot;) you like (within
        certain limits).</p>
    <p class="Pp">In fact the given
        &quot;<span class="Li">$chunksize</span>&quot; must lie in the range
        between &quot;<span class="Li">1</span>&quot; and
        &quot;<span class="Li">&quot;Bit::Vector-&gt;Long_Bits()&quot;</span>&quot;,
        or a fatal &quot;chunk size out of range&quot; error will occur.</p>
    <p class="Pp">In order to be portable, though, you should never use chunk
        sizes larger than 32 bits.</p>
    <p class="Pp">The given bit vector is thereby filled in ascending order: The
        first chunk from the list (i.e.,
        &quot;<span class="Li">$chunks[0]</span>&quot;) fills the
        &quot;<span class="Li">$chunksize</span>&quot; least significant bits,
        the next chunk from the list
        (&quot;<span class="Li">$chunks[1]</span>&quot;) fills the bits number
        &quot;<span class="Li">$chunksize</span>&quot; to number
        &quot;<span class="Li">&quot;2*$chunksize-1&quot;</span>&quot;, the
        third chunk (&quot;<span class="Li">$chunks[2]</span>&quot;) fills the
        bits number
        &quot;<span class="Li">&quot;2*$chunksize&quot;</span>&quot;, to number
        &quot;<span class="Li">&quot;3*$chunksize-1&quot;</span>&quot;, and so
        on.</p>
    <p class="Pp">If there a less chunks in the list than are needed to fill the
        entire bit vector, the remaining (most significant) bits are cleared,
        i.e., the previous contents of the given bit vector are always erased
        completely.</p>
    <p class="Pp">If there are more chunks in the list than are needed to fill
        the entire bit vector, and/or if a chunk extends beyond
        &quot;<span class="Li">&quot;$vector-&gt;Size()-1&quot;</span>&quot;
        (which happens whenever
        &quot;<span class="Li">&quot;$vector-&gt;Size()&quot;</span>&quot; is
        not a multiple of &quot;<span class="Li">$chunksize</span>&quot;), the
        superfluous chunks and/or bits are simply ignored.</p>
    <p class="Pp">The method is useful, for example (and among many other
        applications), for the conversion of packet sizes in a data stream.</p>
    <p class="Pp">This method can also be used to store an octal string in a
        given bit vector:</p>
    <p class="Pp"></p>
    <pre>
  $vector-&gt;Chunk_List_Store(3, split(//, reverse $string));
    </pre>
    <p class="Pp">Note however that unlike the conversion methods
        &quot;<span class="Li">&quot;from_Hex()&quot;</span>&quot;,
        &quot;<span class="Li">&quot;from_Bin()&quot;</span>&quot;,
        &quot;<span class="Li">&quot;from_Dec()&quot;</span>&quot; and
        &quot;<span class="Li">&quot;from_Enum()&quot;</span>&quot;, this
        statement does not include any syntax checking, i.e., it may fail
        silently, without warning.</p>
    <p class="Pp">To perform syntax checking, add the following statements:</p>
    <p class="Pp"></p>
    <pre>
  if ($string =~ /^[0-7]+$/)
  {
      # okay, go ahead with conversion as shown above
  }
  else
  {
      # error, string contains other than octal characters
  }
    </pre>
    <p class="Pp">Another application is to store a repetitive pattern in a
        given bit vector:</p>
    <p class="Pp"></p>
    <pre>
  $pattern = 0xDEADBEEF;
  $length = 32;            # = length of $pattern in bits
  $size = $vector-&gt;Size();
  $factor = int($size / $length);
  if ($size % $length) { $factor++; }
  $vector-&gt;Chunk_List_Store($length, ($pattern) x $factor);
    </pre>
  </li>
  <li><span class="Li">&quot;@chunks =
      $vector-&gt;Chunk_List_Read($chunksize);&quot;</span>
    <p class="Pp">This method allows you to access the contents of the given bit
        vector in form of a list of data packets (&quot;chunks&quot;) of a size
        (&quot;<span class="Li">$chunksize</span>&quot;) of your choosing
        (within certain limits).</p>
    <p class="Pp">In fact the given
        &quot;<span class="Li">$chunksize</span>&quot; must lie in the range
        between &quot;<span class="Li">1</span>&quot; and
        &quot;<span class="Li">&quot;Bit::Vector-&gt;Long_Bits()&quot;</span>&quot;,
        or a fatal &quot;chunk size out of range&quot; error will occur.</p>
    <p class="Pp">In order to be portable, though, you should never use chunk
        sizes larger than 32 bits.</p>
    <p class="Pp">The given bit vector is thereby read in ascending order: The
        &quot;<span class="Li">$chunksize</span>&quot; least significant bits
        (bits number &quot;<span class="Li">0</span>&quot; to
        &quot;<span class="Li">&quot;$chunksize-1&quot;</span>&quot;) become the
        first chunk in the returned list (i.e.,
        &quot;<span class="Li">$chunks[0]</span>&quot;). The bits number
        &quot;<span class="Li">$chunksize</span>&quot; to
        &quot;<span class="Li">&quot;2*$chunksize-1&quot;</span>&quot; become
        the next chunk in the list
        (&quot;<span class="Li">$chunks[1]</span>&quot;), and so on.</p>
    <p class="Pp">If
        &quot;<span class="Li">&quot;$vector-&gt;Size()&quot;</span>&quot; is
        not a multiple of &quot;<span class="Li">$chunksize</span>&quot;, the
        last chunk in the list will contain fewer bits than
        &quot;<span class="Li">$chunksize</span>&quot;.</p>
    <p class="Pp"><b>BEWARE</b> that for large bit vectors and/or small values
        of &quot;<span class="Li">$chunksize</span>&quot;, the number of
        returned list elements can be extremely large! <b>BE CAREFUL!</b></p>
    <p class="Pp">You could blow up your application with lack of memory (each
        list element is a full-grown Perl scalar, internally, with an associated
        memory overhead for its administration!) or at least cause a noticeable,
        more or less long-lasting &quot;freeze&quot; of your application!</p>
    <p class="Pp">Possible applications:</p>
    <p class="Pp">The method is especially useful in the conversion of packet
        sizes in a data stream.</p>
    <p class="Pp">This method can also be used to convert a given bit vector to
        a string of octal numbers:</p>
    <p class="Pp"></p>
    <pre>
  $string = reverse join('', $vector-&gt;Chunk_List_Read(3));
    </pre>
  </li>
  <li><span class="Li">&quot;$vector-&gt;Index_List_Remove(@indices);&quot;</span>
    <p class="Pp">This method allows you to specify a list of indices of bits
        which should be turned off in the given bit vector.</p>
    <p class="Pp">In fact this method is a shortcut for</p>
    <p class="Pp"></p>
    <pre>
    foreach $index (@indices)
    {
        $vector-&gt;Bit_Off($index);
    }
    </pre>
    <p class="Pp">In contrast to all other import methods in this module, this
        method does <b>NOT</b> clear the given bit vector before processing its
        list of arguments.</p>
    <p class="Pp">Instead, this method allows you to accumulate the results of
        various consecutive calls.</p>
    <p class="Pp">(The same holds for the method
        &quot;<span class="Li">&quot;Index_List_Store()&quot;</span>&quot;. As a
        consequence, you can &quot;wipe out&quot; what you did using the method
        &quot;<span class="Li">&quot;Index_List_Remove()&quot;</span>&quot; by
        passing the identical argument list to the method
        &quot;<span class="Li">&quot;Index_List_Store()&quot;</span>&quot;.)</p>
  </li>
  <li><span class="Li">&quot;$vector-&gt;Index_List_Store(@indices);&quot;</span>
    <p class="Pp">This method allows you to specify a list of indices of bits
        which should be turned on in the given bit vector.</p>
    <p class="Pp">In fact this method is a shortcut for</p>
    <p class="Pp"></p>
    <pre>
    foreach $index (@indices)
    {
        $vector-&gt;Bit_On($index);
    }
    </pre>
    <p class="Pp">In contrast to all other import methods in this module, this
        method does <b>NOT</b> clear the given bit vector before processing its
        list of arguments.</p>
    <p class="Pp">Instead, this method allows you to accumulate the results of
        various consecutive calls.</p>
    <p class="Pp">(The same holds for the method
        &quot;<span class="Li">&quot;Index_List_Remove()&quot;</span>&quot;. As
        a consequence, you can &quot;wipe out&quot; what you did using the
        method
        &quot;<span class="Li">&quot;Index_List_Store()&quot;</span>&quot; by
        passing the identical argument list to the method
        &quot;<span class="Li">&quot;Index_List_Remove()&quot;</span>&quot;.)</p>
  </li>
  <li><span class="Li">&quot;@indices =
      $vector-&gt;Index_List_Read();&quot;</span>
    <p class="Pp">This method returns a list of Perl scalars.</p>
    <p class="Pp">The list contains one scalar for each set bit in the given bit
        vector.</p>
    <p class="Pp"><b>BEWARE</b> that for large bit vectors, this can result in a
        literally overwhelming number of list elements! <b>BE CAREFUL!</b> You
        could run out of memory or slow down your application considerably!</p>
    <p class="Pp">Each scalar contains the number of the index corresponding to
        the bit in question.</p>
    <p class="Pp">These indices are always returned in ascending order.</p>
    <p class="Pp">If the given bit vector is empty (contains only cleared bits)
        or if it has a length of zero (if it contains no bits at all), the
        method returns an empty list.</p>
    <p class="Pp">This method can be useful, for instance, to obtain a list of
        prime numbers:</p>
    <p class="Pp"></p>
    <pre>
    $limit = 1000; # or whatever
    $vector = Bit::Vector-&gt;new($limit+1);
    $vector-&gt;Primes();
    @primes = $vector-&gt;Index_List_Read();
    </pre>
  </li>
  <li><span class="Li">&quot;$vec3-&gt;Or($vec1,$vec2);&quot;</span>
    <p class="Pp"><span class="Li">&quot;$set3-&gt;Union($set1,$set2);&quot;</span></p>
    <p class="Pp">This method calculates the union of
        &quot;<span class="Li">$set1</span>&quot; and
        &quot;<span class="Li">$set2</span>&quot; and stores the result in
        &quot;<span class="Li">$set3</span>&quot;.</p>
    <p class="Pp">This is usually written as &quot;<span class="Li">&quot;$set3
        = $set1 u $set2&quot;</span>&quot; in set theory (where &quot;u&quot; is
        the &quot;cup&quot; operator).</p>
    <p class="Pp">(On systems where the &quot;cup&quot; character is unavailable
        this operator is often denoted by a plus sign &quot;+&quot;.)</p>
    <p class="Pp">In-place calculation is also possible, i.e.,
        &quot;<span class="Li">$set3</span>&quot; may be identical with
        &quot;<span class="Li">$set1</span>&quot; or
        &quot;<span class="Li">$set2</span>&quot; or both.</p>
  </li>
  <li><span class="Li">&quot;$vec3-&gt;And($vec1,$vec2);&quot;</span>
    <p class="Pp"><span class="Li">&quot;$set3-&gt;Intersection($set1,$set2);&quot;</span></p>
    <p class="Pp">This method calculates the intersection of
        &quot;<span class="Li">$set1</span>&quot; and
        &quot;<span class="Li">$set2</span>&quot; and stores the result in
        &quot;<span class="Li">$set3</span>&quot;.</p>
    <p class="Pp">This is usually written as &quot;<span class="Li">&quot;$set3
        = $set1 n $set2&quot;</span>&quot; in set theory (where &quot;n&quot; is
        the &quot;cap&quot; operator).</p>
    <p class="Pp">(On systems where the &quot;cap&quot; character is unavailable
        this operator is often denoted by an asterisk &quot;*&quot;.)</p>
    <p class="Pp">In-place calculation is also possible, i.e.,
        &quot;<span class="Li">$set3</span>&quot; may be identical with
        &quot;<span class="Li">$set1</span>&quot; or
        &quot;<span class="Li">$set2</span>&quot; or both.</p>
  </li>
  <li><span class="Li">&quot;$vec3-&gt;AndNot($vec1,$vec2);&quot;</span>
    <p class="Pp"><span class="Li">&quot;$set3-&gt;Difference($set1,$set2);&quot;</span></p>
    <p class="Pp">This method calculates the difference of
        &quot;<span class="Li">$set1</span>&quot; less
        &quot;<span class="Li">$set2</span>&quot; and stores the result in
        &quot;<span class="Li">$set3</span>&quot;.</p>
    <p class="Pp">This is usually written as &quot;<span class="Li">&quot;$set3
        = $set1 \ $set2&quot;</span>&quot; in set theory (where &quot;\&quot; is
        the &quot;less&quot; operator).</p>
    <p class="Pp">In-place calculation is also possible, i.e.,
        &quot;<span class="Li">$set3</span>&quot; may be identical with
        &quot;<span class="Li">$set1</span>&quot; or
        &quot;<span class="Li">$set2</span>&quot; or both.</p>
  </li>
  <li><span class="Li">&quot;$vec3-&gt;Xor($vec1,$vec2);&quot;</span>
    <p class="Pp"><span class="Li">&quot;$set3-&gt;ExclusiveOr($set1,$set2);&quot;</span></p>
    <p class="Pp">This method calculates the symmetric difference of
        &quot;<span class="Li">$set1</span>&quot; and
        &quot;<span class="Li">$set2</span>&quot; and stores the result in
        &quot;<span class="Li">$set3</span>&quot;.</p>
    <p class="Pp">This can be written as &quot;<span class="Li">&quot;$set3 =
        ($set1 u $set2) \ ($set1 n $set2)&quot;</span>&quot; in set theory (the
        union of the two sets less their intersection).</p>
    <p class="Pp">When sets are implemented as bit vectors then the above
        formula is equivalent to the exclusive-or between corresponding bits of
        the two bit vectors (hence the name of this method).</p>
    <p class="Pp">Note that this method is also much more efficient than
        evaluating the above formula explicitly since it uses a built-in machine
        language instruction internally.</p>
    <p class="Pp">In-place calculation is also possible, i.e.,
        &quot;<span class="Li">$set3</span>&quot; may be identical with
        &quot;<span class="Li">$set1</span>&quot; or
        &quot;<span class="Li">$set2</span>&quot; or both.</p>
  </li>
  <li><span class="Li">&quot;$vec2-&gt;Not($vec1);&quot;</span>
    <p class="Pp"><span class="Li">&quot;$set2-&gt;Complement($set1);&quot;</span></p>
    <p class="Pp">This method calculates the complement of
        &quot;<span class="Li">$set1</span>&quot; and stores the result in
        &quot;<span class="Li">$set2</span>&quot;.</p>
    <p class="Pp">In &quot;big integer&quot; arithmetic, this is equivalent to
        calculating the one's complement of the number stored in the bit vector
        &quot;<span class="Li">$set1</span>&quot; in binary representation.</p>
    <p class="Pp">In-place calculation is also possible, i.e.,
        &quot;<span class="Li">$set2</span>&quot; may be identical with
        &quot;<span class="Li">$set1</span>&quot;.</p>
  </li>
  <li><span class="Li">&quot;if ($set1-&gt;subset($set2))&quot;</span>
    <p class="Pp">Returns &quot;true&quot;
        (&quot;<span class="Li">1</span>&quot;) if
        &quot;<span class="Li">$set1</span>&quot; is a subset of
        &quot;<span class="Li">$set2</span>&quot; (i.e., completely contained in
        &quot;<span class="Li">$set2</span>&quot;) and &quot;false&quot;
        (&quot;<span class="Li">0</span>&quot;) otherwise.</p>
    <p class="Pp">This means that any bit which is set
        (&quot;<span class="Li">1</span>&quot;) in
        &quot;<span class="Li">$set1</span>&quot; must also be set in
        &quot;<span class="Li">$set2</span>&quot;, but
        &quot;<span class="Li">$set2</span>&quot; may contain set bits which are
        not set in &quot;<span class="Li">$set1</span>&quot;, in order for the
        condition of subset relationship to be true between these two sets.</p>
    <p class="Pp">Note that by definition, if two sets are identical, they are
        also subsets (and also supersets) of each other.</p>
  </li>
  <li><span class="Li">&quot;$norm = $set-&gt;Norm();&quot;</span>
    <p class="Pp">Returns the norm (number of bits which are set) of the given
        vector.</p>
    <p class="Pp">This is equivalent to the number of elements contained in the
        given set.</p>
    <p class="Pp">Uses a byte lookup table for calculating the number of set
        bits per byte, and thus needs a time for evaluation (and a number of
        loops) linearly proportional to the length of the given bit vector (in
        bytes).</p>
    <p class="Pp">This should be the fastest algorithm on average.</p>
  </li>
  <li><span class="Li">&quot;$norm = $set-&gt;Norm2();&quot;</span>
    <p class="Pp">Returns the norm (number of bits which are set) of the given
        vector.</p>
    <p class="Pp">This is equivalent to the number of elements contained in the
        given set.</p>
    <p class="Pp">This does the same as the method
        &quot;<span class="Li">&quot;Norm()&quot;</span>&quot; above, only with
        a different algorithm:</p>
    <p class="Pp">This method counts the number of set and cleared bits at the
        same time and will stop when either of them has been exhausted, thus
        needing at most half as many loops per machine word as the total number
        of bits in a machine word - in fact it will need a number of loops equal
        to the minimum of the number of set bits and the number of cleared
      bits.</p>
    <p class="Pp">This might be a faster algorithm than of the method
        &quot;<span class="Li">&quot;Norm()&quot;</span>&quot; above on some
        systems, depending on the system's architecture and the compiler and
        optimisation used, for bit vectors with sparse set bits and for bit
        vectors with sparse cleared bits (i.e., predominantly set bits).</p>
  </li>
  <li><span class="Li">&quot;$norm = $set-&gt;Norm3();&quot;</span>
    <p class="Pp">Returns the norm (number of bits which are set) of the given
        vector.</p>
    <p class="Pp">This is equivalent to the number of elements contained in the
        given set.</p>
    <p class="Pp">This does the same as the two methods
        &quot;<span class="Li">&quot;Norm()&quot;</span>&quot; and
        &quot;<span class="Li">&quot;Norm2()&quot;</span>&quot; above, however
        with a different algorithm.</p>
    <p class="Pp">In fact this is the implementation of the method
        &quot;<span class="Li">&quot;Norm()&quot;</span>&quot; used in previous
        versions of this module.</p>
    <p class="Pp">The method needs a number of loops per machine word equal to
        the number of set bits in that machine word.</p>
    <p class="Pp">Only for bit vectors with sparse set bits will this method be
        fast; it will depend on a system's architecture and compiler whether the
        method will be faster than any of the two methods above in such
      cases.</p>
    <p class="Pp">On average however, this is probably the slowest method of the
        three.</p>
  </li>
  <li><span class="Li">&quot;$min = $set-&gt;Min();&quot;</span>
    <p class="Pp">Returns the minimum of the given set, i.e., the minimum of all
        indices of all set bits in the given bit vector
        &quot;<span class="Li">$set</span>&quot;.</p>
    <p class="Pp">If the set is empty (no set bits), plus infinity (represented
        by the constant &quot;MAX_LONG&quot; on your system) is returned.</p>
    <p class="Pp">(This constant is usually
        2&#x00A0;^&#x00A0;(n-1)&#x00A0;-&#x00A0;1, where
        &quot;<span class="Li">&quot;n&quot;</span>&quot; is the number of bits
        of an unsigned long on your machine.)</p>
  </li>
  <li><span class="Li">&quot;$max = $set-&gt;Max();&quot;</span>
    <p class="Pp">Returns the maximum of the given set, i.e., the maximum of all
        indices of all set bits in the given bit vector
        &quot;<span class="Li">$set</span>&quot;.</p>
    <p class="Pp">If the set is empty (no set bits), minus infinity (represented
        by the constant &quot;MIN_LONG&quot; on your system) is returned.</p>
    <p class="Pp">(This constant is usually
        -(2&#x00A0;^&#x00A0;(n-1)&#x00A0;-&#x00A0;1) or
        -(2&#x00A0;^&#x00A0;(n-1)), where
        &quot;<span class="Li">&quot;n&quot;</span>&quot; is the number of bits
        of an unsigned long on your machine.)</p>
  </li>
  <li><span class="Li">&quot;$m3-&gt;Multiplication($r3,$c3,$m1,$r1,$c1,$m2,$r2,$c2);&quot;</span>
    <p class="Pp">This method multiplies two boolean matrices (stored as bit
        vectors) &quot;<span class="Li">$m1</span>&quot; and
        &quot;<span class="Li">$m2</span>&quot; and stores the result in matrix
        &quot;<span class="Li">$m3</span>&quot;.</p>
    <p class="Pp">The method uses the binary &quot;xor&quot; operation
        (&quot;<span class="Li">&quot;^&quot;</span>&quot;) as the boolean
        addition operator
      (&quot;<span class="Li">&quot;+&quot;</span>&quot;).</p>
    <p class="Pp">An exception is raised if the product of the number of rows
        and columns of any of the three matrices differs from the actual size of
        their underlying bit vector.</p>
    <p class="Pp">An exception is also raised if the numbers of rows and columns
        of the three matrices do not harmonize in the required manner:</p>
    <p class="Pp"></p>
    <pre>
  rows3 == rows1
  cols3 == cols2
  cols1 == rows2
    </pre>
    <p class="Pp">This method is used by the module
        &quot;Math::MatrixBool&quot;.</p>
    <p class="Pp">See <b>Math::MatrixBool</b>(3) for details.</p>
  </li>
  <li><span class="Li">&quot;$m3-&gt;Product($r3,$c3,$m1,$r1,$c1,$m2,$r2,$c2);&quot;</span>
    <p class="Pp">This method multiplies two boolean matrices (stored as bit
        vectors) &quot;<span class="Li">$m1</span>&quot; and
        &quot;<span class="Li">$m2</span>&quot; and stores the result in matrix
        &quot;<span class="Li">$m3</span>&quot;.</p>
    <p class="Pp">This special method uses the binary &quot;or&quot; operation
        (&quot;<span class="Li">&quot;|&quot;</span>&quot;) as the boolean
        addition operator
      (&quot;<span class="Li">&quot;+&quot;</span>&quot;).</p>
    <p class="Pp">An exception is raised if the product of the number of rows
        and columns of any of the three matrices differs from the actual size of
        their underlying bit vector.</p>
    <p class="Pp">An exception is also raised if the numbers of rows and columns
        of the three matrices do not harmonize in the required manner:</p>
    <p class="Pp"></p>
    <pre>
  rows3 == rows1
  cols3 == cols2
  cols1 == rows2
    </pre>
    <p class="Pp">This method is used by the module
        &quot;Math::MatrixBool&quot;.</p>
    <p class="Pp">See <b>Math::MatrixBool</b>(3) for details.</p>
  </li>
  <li><span class="Li">&quot;$matrix-&gt;Closure($rows,$cols);&quot;</span>
    <p class="Pp">This method calculates the reflexive transitive closure of the
        given boolean matrix (stored as a bit vector) using Kleene's
      algoritm.</p>
    <p class="Pp">(See <b>Math::Kleene</b>(3) for a brief introduction into the
        theory behind Kleene's algorithm.)</p>
    <p class="Pp">The reflexive transitive closure answers the question whether
        a path exists between any two vertices of a graph whose edges are given
        as a matrix:</p>
    <p class="Pp">If a (directed) edge exists going from vertex &quot;i&quot; to
        vertex &quot;j&quot;, then the element in the matrix with coordinates
        (i,j) is set to &quot;<span class="Li">1</span>&quot; (otherwise it
        remains set to &quot;<span class="Li">0</span>&quot;).</p>
    <p class="Pp">If the edges are undirected, the resulting matrix is
        symmetric, i.e., elements (i,j) and (j,i) always contain the same
      value.</p>
    <p class="Pp">The matrix representing the edges of the graph only answers
        the question whether an <b>EDGE</b> exists between any two vertices of
        the graph or not, whereas the reflexive transitive closure answers the
        question whether a <b>PATH</b> (a series of adjacent edges) exists
        between any two vertices of the graph!</p>
    <p class="Pp">Note that the contents of the given matrix are modified by
        this method, so make a copy of the initial matrix in time if you are
        going to need it again later.</p>
    <p class="Pp">An exception is raised if the given matrix is not quadratic,
        i.e., if the number of rows and columns of the given matrix is not
        identical.</p>
    <p class="Pp">An exception is also raised if the product of the number of
        rows and columns of the given matrix differs from the actual size of its
        underlying bit vector.</p>
    <p class="Pp">This method is used by the module
        &quot;Math::MatrixBool&quot;.</p>
    <p class="Pp">See <b>Math::MatrixBool</b>(3) for details.</p>
  </li>
  <li><span class="Li">&quot;$matrix2-&gt;Transpose($rows2,$cols2,$matrix1,$rows1,$cols1);&quot;</span>
    <p class="Pp">This method calculates the transpose of a boolean matrix
        &quot;<span class="Li">$matrix1</span>&quot; (stored as a bit vector)
        and stores the result in matrix
        &quot;<span class="Li">$matrix2</span>&quot;.</p>
    <p class="Pp">The transpose of a boolean matrix, representing the edges of a
        graph, can be used for finding the strongly connected components of that
        graph.</p>
    <p class="Pp">An exception is raised if the product of the number of rows
        and columns of any of the two matrices differs from the actual size of
        its underlying bit vector.</p>
    <p class="Pp">An exception is also raised if the following conditions are
        not met:</p>
    <p class="Pp"></p>
    <pre>
  rows2 == cols1
  cols2 == rows1
    </pre>
    <p class="Pp">Note that in-place processing
        (&quot;<span class="Li">$matrix1</span>&quot; and
        &quot;<span class="Li">$matrix2</span>&quot; are identical) is only
        possible if the matrix is quadratic. Otherwise, a fatal &quot;matrix is
        not quadratic&quot; error will occur.</p>
    <p class="Pp">This method is used by the module
        &quot;Math::MatrixBool&quot;.</p>
    <p class="Pp">See <b>Math::MatrixBool</b>(3) for details.</p>
  </li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>Bit::Vector::Overload</b>(3), <b>Bit::Vector::String</b>(3),
    <b>Storable</b>(3).</p>
<p class="Pp"><b>Set::IntRange</b>(3), <b>Math::MatrixBool</b>(3),
    <b>Math::MatrixReal</b>(3), <b>DFA::Kleene</b>(3), <b>Math::Kleene</b>(3),
    <b>Graph::Kruskal</b>(3).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">This man page documents &quot;Bit::Vector&quot; version 7.4.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<pre>
  Steffen Beyer
  mailto:STBEY@cpan.org
  http://www.engelschall.com/u/sb/download/
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 1995 - 2013 by Steffen Beyer. All rights
  reserved.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">This package is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself, i.e., under the terms of the
    &quot;Artistic License&quot; or the &quot;GNU General Public
  License&quot;.</p>
<p class="Pp">The C library at the core of this Perl module can additionally be
    redistributed and/or modified under the terms of the &quot;GNU Library
    General Public License&quot;.</p>
<p class="Pp">Please refer to the files &quot;Artistic.txt&quot;,
    &quot;GNU_GPL.txt&quot; and &quot;GNU_LGPL.txt&quot; in this distribution
    for details!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DISCLAIMER"><a class="permalink" href="#DISCLAIMER">DISCLAIMER</a></h1>
<p class="Pp">This package is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</p>
<p class="Pp">See the &quot;GNU General Public License&quot; for more
  details.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-09-03</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Type::Tiny::Manual::Libraries(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Type::Tiny::Manual::Libraries(3)</td>
    <td class="head-vol"><a href=".">User Contributed Perl Documentation</a></td>
    <td class="head-rtitle">Type::Tiny::Manual::Libraries(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Type::Tiny::Manual::Libraries - defining your own type
  libraries</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MANUAL"><a class="permalink" href="#MANUAL">MANUAL</a></h1>
<section class="Ss">
<h2 class="Ss" id="Defining_a_Type"><a class="permalink" href="#Defining_a_Type">Defining
  a Type</a></h2>
<p class="Pp">A type is an object and you can create a new one using the
    constructor:</p>
<p class="Pp"></p>
<pre>  use Type::Tiny;
  
  my $type = Type::Tiny-&gt;new(%args);
</pre>
<p class="Pp">A full list of the available arguments can be found in the
    Type::Tiny documentation, but the most important ones to begin with are:</p>
<dl class="Bl-tag">
  <dt>&quot;name&quot;</dt>
  <dd>The name of your new type. Type::Tiny uses a convention of UpperCamelCase
      names for type constraints. The type name may also begin with one or two
      leading underscores to indicate a type intended for internal use only.
      Types using non-ASCII characters may cause problems on older versions of
      Perl (pre-5.8).
    <p class="Pp">Although this is optional and types may be anonymous, a name
        is required for a type constraint to added to a type library.</p>
  </dd>
  <dt>&quot;constraint&quot;</dt>
  <dd>A code reference checking <span class="Li">$_</span> and returning a
      boolean. Alternatively, a string of Perl code may be provided.
    <p class="Pp">If you've been paying attention, you can probably guess that
        the string of Perl code may result in more efficient type checks.</p>
  </dd>
  <dt>&quot;parent&quot;</dt>
  <dd>An existing type constraint to inherit from. A value will need to pass the
      parent constraint before its own constraint would be called.
    <p class="Pp"></p>
    <pre>  my $Even = Type::Tiny-&gt;new(
    name       =&gt; 'EvenNumber',
    parent     =&gt; Types::Standard::Int,
    constraint =&gt; sub {
      # in this sub we don't need to check that $_ is an Int
      # because the parent will take care of that!
      
      $_ % 2 == 0
    },
  );
    </pre>
    <p class="Pp">Although the <span class="Li">&quot;parent&quot;</span> is
        optional, it makes sense whenever possible to inherit from an existing
        type constraint to benefit from any optimizations or XS implementations
        they may provide.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Defining_a_Library"><a class="permalink" href="#Defining_a_Library">Defining
  a Library</a></h2>
<p class="Pp">A library is a Perl module that exports type constraints as subs.
    Types::Standard, Types::Common::Numeric, and Types::Common::String are type
    libraries that are bundled with Type::Tiny.</p>
<p class="Pp">To create a type library, create a package that inherits from
    Type::Library.</p>
<p class="Pp"></p>
<pre>  package MyTypes {
    use Type::Library -base;
    
    ...; # your type definitions go here
  }
</pre>
<p class="Pp">The <span class="Li">&quot;-base&quot;</span> flag is just a
    shortcut for:</p>
<p class="Pp"></p>
<pre>  package MyTypes {
    use Type::Library;
    our @ISA = 'Type::Library';
  }
</pre>
<p class="Pp">You can add types like this:</p>
<p class="Pp"></p>
<pre>  package MyTypes {
    use Type::Library -base;
    
    my $Even = Type::Tiny-&gt;new(
      name       =&gt; 'EvenNumber',
      parent     =&gt; Types::Standard::Int,
      constraint =&gt; sub {
        # in this sub we don't need to check that $_ is an Int
        # because the parent will take care of that!
        
        $_ % 2 == 0
      },
    );
    
    __PACKAGE__-&gt;add_type($Even);
  }
</pre>
<p class="Pp">There is a shortcut for adding types if they're going to be
    blessed Type::Tiny objects and not, for example, a subclass of Type::Tiny.
    You can just pass <span class="Li">%args</span> directly to
    <span class="Li">&quot;add_type&quot;</span>.</p>
<p class="Pp"></p>
<pre>  package MyTypes {
    use Type::Library -base;
    
    __PACKAGE__-&gt;add_type(
      name       =&gt; 'EvenNumber',
      parent     =&gt; Types::Standard::Int,
      constraint =&gt; sub {
        # in this sub we don't need to check that $_ is an Int
        # because the parent will take care of that!
        
        $_ % 2 == 0
      },
    );
  }
</pre>
<p class="Pp">The <span class="Li">&quot;add_type&quot;</span> method returns
    the type it just added, so it can be stored in a variable.</p>
<p class="Pp"></p>
<pre>  my $Even = __PACKAGE__-&gt;add_type(...);
</pre>
<p class="Pp">This can be useful if you wish to use
    <span class="Li">$Even</span> as the parent type to some other type you're
    going to define later.</p>
<p class="Pp">Here's a bigger worked example:</p>
<p class="Pp"></p>
<pre>  package Example::Types {
    use Type::Library -base;
    use Types::Standard -types;
    use DateTime;
    
    # Type::Tiny::Class is a subclass of Type::Tiny for creating
    # InstanceOf-like types. It's kind of better though because
    # it does cool stuff like pass through $type-&gt;new(%args) to
    # the class's constructor.
    #
    my $dt = __PACKAGE__-&gt;add_type(
      Type::Tiny::Class-&gt;new(
        name    =&gt; 'Datetime',
        class   =&gt; 'DateTime',
      )
    );
   
    my $dth = __PACKAGE__-&gt;add_type(
      name    =&gt; 'DatetimeHash',
      parent  =&gt; Dict[
        year       =&gt; Int,
        month      =&gt; Optional[ Int ],
        day        =&gt; Optional[ Int ],
        hour       =&gt; Optional[ Int ],
        minute     =&gt; Optional[ Int ],
        second     =&gt; Optional[ Int ],
        nanosecond =&gt; Optional[ Int ],
        time_zone  =&gt; Optional[ Str ],
      ],
    );
   
    my $eph = __PACKAGE__-&gt;add_type(
      name    =&gt; 'EpochHash',
      parent  =&gt; Dict[ epoch =&gt; Int ],
    );
    
    # Can't just use &quot;plus_coercions&quot; method because that creates
    # a new anonymous child type to add the coercions to. We want
    # to add them to the type which exists in this library.
    #
    $dt-&gt;coercion-&gt;add_type_coercions(
      Int,    q{ DateTime-&gt;from_epoch(epoch =&gt; $_) },
      Undef,  q{ DateTime-&gt;now() },
      $dth,   q{ DateTime-&gt;new(%$_) },
      $eph,   q{ DateTime-&gt;from_epoch(%$_) },
    );
    
    __PACKAGE__-&gt;make_immutable;
  }
</pre>
<p class="Pp"><span class="Li">&quot;make_immutable&quot;</span> freezes to
    coercions of all the types in the package, so no outside code can tamper
    with the coercions, and allows Type::Tiny to make optimizations to the
    coercions, knowing they won't later be altered. You should always do this at
    the end.</p>
<p class="Pp">The library will export types <b>Datetime</b>,
    <b>DatetimeHash</b>, and <b>EpochHash</b>. The <b>Datetime</b> type will
    have coercions from <b>Int</b>, <b>Undef</b>, <b>DatetimeHash</b>, and
    <b>EpochHash</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Extending_Libraries"><a class="permalink" href="#Extending_Libraries">Extending
  Libraries</a></h2>
<p class="Pp">Type::Utils provides a helpful function
    <span class="Li">&quot;extends&quot;</span>.</p>
<p class="Pp"></p>
<pre>  package My::Types {
    use Type::Library -base;
    use Type::Utils qw( extends );
    
    BEGIN { extends(&quot;Types::Standard&quot;) };
    
    # define your own types here
  }
</pre>
<p class="Pp">The <span class="Li">&quot;extends&quot;</span> function (which
    you should usually use in a <span class="Li">&quot;BEGIN { }&quot;</span>
    block not only loads another type library, but it also adds all the types
    from it to your library.</p>
<p class="Pp">This means code using the above My::Types doesn't need to do:</p>
<p class="Pp"></p>
<pre>  use Types::Standard qw( Str );
  use My::Types qw( Something );
</pre>
<p class="Pp">It can just do:</p>
<p class="Pp"></p>
<pre>  use My::Types qw( Str Something );
</pre>
<p class="Pp">Because all the types from Types::Standard have been copied across
    into My::Types and are also available there.</p>
<p class="Pp"><span class="Li">&quot;extends&quot;</span> can be passed a list
    of libraries; you can inherit from multiple existing libraries. It can also
    recognize and import types from MooseX::Types, MouseX::Types, and
    Specio::Exporter libraries.</p>
<p class="Pp">Since Type::Library 1.012, there has been a shortcut for
    <span class="Li">&quot;extends&quot;</span>.</p>
<p class="Pp"></p>
<pre>  package My::Types {
    use Type::Library -extends =&gt; [ 'Types::Standard' ];
    
    # define your own types here
  }
</pre>
<p class="Pp">The <span class="Li">&quot;-extends&quot;</span> flag takes an
    arrayref of type libraries to extend. It automatically implies
    <span class="Li">&quot;-base&quot;</span> so you don't need to use both.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Custom_Error_Messages"><a class="permalink" href="#Custom_Error_Messages">Custom
  Error Messages</a></h2>
<p class="Pp">A type constraint can have custom error messages. It's pretty
    simple:</p>
<p class="Pp"></p>
<pre>  Type::Tiny-&gt;new(
    name       =&gt; 'EvenNumber',
    parent     =&gt; Types::Standard::Int,
    constraint =&gt; sub {
      # in this sub we don't need to check that $_ is an Int
      # because the parent will take care of that!
      
      $_ % 2 == 0
    },
    message   =&gt; sub {
      sprintf '%s is not an even number', Type::Tiny::_dd($_);
    },
  );
</pre>
<p class="Pp">The message coderef just takes a value in
    <span class="Li">$_</span> and returns a string. It may use
    <span class="Li">&quot;Type::Tiny::_dd()&quot;</span> as a way of
    pretty-printing a value. (Don't be put off by the underscore in the function
    name. <span class="Li">&quot;_dd()&quot;</span> is an officially supported
    part of Type::Tiny's API now.)</p>
<p class="Pp">You don't have to use <span class="Li">&quot;_dd()&quot;</span>.
    You can generate any error string you like. But
    <span class="Li">&quot;_dd()&quot;</span> will help you make undef and the
    empty string look different, and will pretty-print references, and so
  on.</p>
<p class="Pp">There's no need to supply an error message coderef unless you
    really want custom error messages. The default sub should be reasonable.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Inlining"><a class="permalink" href="#Inlining">Inlining</a></h2>
<p class="Pp">In Perl, sub calls are relatively expensive in terms of memory and
    CPU use. The <b>PositiveInt</b> type inherits from <b>Int</b> which inherits
    from <b>Num</b> which inherits from <b>Str</b> which inherits from
    <b>Defined</b> which inherits from <b>Item</b> which inherits from
    <b>Any</b>.</p>
<p class="Pp">So you might think that to check of <span class="Li">$value</span>
    is a <b>PositiveInt</b>, it needs to be checked all the way up the
    inheritance chain. But this is where one of Type::Tiny's big optimizations
    happens. Type::Tiny can glue together a bunch of checks with a stringy eval,
    and get a single coderef that can do all the checks in one go.</p>
<p class="Pp">This is why when Type::Tiny gives you a choice of using a coderef
    or a string of Perl code, you should usually choose the string of Perl code.
    A single coderef can &quot;break the chain&quot;.</p>
<p class="Pp">But these automatically generated strings of Perl code are not
    always as efficient as they could be. For example, imagine that
    <b>HashRef</b> is defined as:</p>
<p class="Pp"></p>
<pre>  my $Defined = Type::Tiny-&gt;new(
    name       =&gt; 'Defined',
    constraint =&gt; 'defined($_)',
  );
  my $Ref = Type::Tiny-&gt;new(
    name       =&gt; 'Ref',
    parent     =&gt; $Defined,
    constraint =&gt; 'ref($_)',
  );
  my $HashRef = Type::Tiny-&gt;new(
    name       =&gt; 'HashRef',
    parent     =&gt; $Ref,
    constraint =&gt; 'ref($_) eq &quot;HASH&quot;',
  );
</pre>
<p class="Pp">Then the combined check is:</p>
<p class="Pp"></p>
<pre>  defined($_) and ref($_) and ref($_) eq &quot;HASH&quot;
</pre>
<p class="Pp">Actually in practice it's even more complicated, because
    Type::Tiny needs to localize and set <span class="Li">$_</span> first.</p>
<p class="Pp">But in practice, the following should be a sufficient check:</p>
<p class="Pp"></p>
<pre>  ref($_) eq &quot;HASH&quot;
</pre>
<p class="Pp">It is possible for the <b>HashRef</b> type to have more control
    over the string of code generated.</p>
<p class="Pp"></p>
<pre>  my $HashRef = Type::Tiny-&gt;new(
    name       =&gt; 'HashRef',
    parent     =&gt; $Ref,
    constraint =&gt; 'ref($_) eq &quot;HASH&quot;',
    inlined    =&gt; sub {
      my $varname = pop;
      sprintf 'ref(%s) eq &quot;HASH&quot;', $varname;
    },
  );
</pre>
<p class="Pp">The inlined coderef gets passed the name of a variable to check.
    This could be <span class="Li">'$_'</span> or <span class="Li">'$var'</span>
    or <span class="Li">&quot;$some{deep}{thing}[0]&quot;</span>. Because it is
    passed the name of a variable to check, instead of always checking
    <span class="Li">$_</span>, this enables very efficient checking for
    parameterized types.</p>
<p class="Pp">Although in this case, the inlining coderef is just returning a
    string, technically it returns a list of strings. If there's multiple
    strings, Type::Tiny will join them together in a big &quot;&amp;&amp;&quot;
    statement.</p>
<p class="Pp">As a special case, if the first item in the returned list of
    strings is undef, then Type::Tiny will substitute the parent type
    constraint's inlined string in its place. So an inlieing coderef for even
    numbers might be:</p>
<p class="Pp"></p>
<pre>  Type::Tiny-&gt;new(
    name       =&gt; 'EvenNumber',
    parent     =&gt; Types::Standard::Int,
    constraint =&gt; sub { $_ % 2 == 0 },
    inlined    =&gt; sub {
      my $varname = pop;
      return (undef, &quot;$varname % 2 == 0&quot;);
    },
  );
</pre>
<p class="Pp">Even if you provide a coderef as a string, an inlining coderef has
    the potential to generate more efficient code, so you should consider
    providing one.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Pre-Declaring_Types"><a class="permalink" href="#Pre-Declaring_Types">Pre-Declaring
  Types</a></h2>
<pre>  use Type::Library -base,
    -declare =&gt; qw( Foo Bar Baz );
</pre>
<p class="Pp">This declares types <b>Foo</b>, <b>Bar</b>, and <b>Baz</b> at
    compile time so they can safely be used as barewords in your type
  library.</p>
<p class="Pp">This also allows recursively defined types to (mostly) work!</p>
<p class="Pp"></p>
<pre>  use Type::Library -base,
    -declare =&gt; qw( NumericArrayRef );
  use Types::Standard qw( Num ArrayRef );
  
  __PACKAGE__-&gt;add_type(
    name     =&gt; NumericArrayRef,
    parent   =&gt; ArrayRef-&gt;of( Num | NumericArrayRef ),
  );
</pre>
<p class="Pp">(Support for recursive type definitions added in Type::Library
    1.009_000.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Parameterizable_Types"><a class="permalink" href="#Parameterizable_Types">Parameterizable
  Types</a></h2>
<p class="Pp">This is probably the most &quot;meta&quot; concept that is going
    to be covered. Building your own type constraint that can be parameterized
    like <b>ArrayRef</b> or <b>HasMethods</b>.</p>
<p class="Pp">The type constraint we'll build will be <b>MultipleOf[$i]</b>
    which checks that an integer is a multiple of
  <span class="Li">$i</span>.</p>
<p class="Pp"></p>
<pre>  __PACKAGE__-&gt;add_type(
    name       =&gt; 'MultipleOf',
    parent     =&gt; Int,
    
    # This coderef gets passed the contents of the square brackets.
    constraint_generator =&gt; sub {
      my $i = assert_Int(shift);
      # needs to return a coderef to use as a constraint for the
      # parameterized type
      return sub { $_ % $i == 0 };
    },
    
    # optional but recommended
    inline_generator =&gt; sub {
      my $i = shift;
      return sub {
        my $varname = pop;
        return (undef, &quot;$varname % $i == 0&quot;);
      };
    },
    
    # probably the most complex bit
    coercion_generator =&gt; sub {
      my $i = $_[2];
      require Type::Coercion;
      return Type::Coercion-&gt;new(
        type_coercion_map =&gt; [
          Num, qq{ int($i * int(\$_/$i)) }
        ],
      );
    },
  );
</pre>
<p class="Pp">Now we can define an even number like this:</p>
<p class="Pp"></p>
<pre>  __PACKAGE__-&gt;add_type(
    name     =&gt; 'EvenNumber',
    parent   =&gt; __PACKAGE__-&gt;get_type('MultipleOf')-&gt;of(2),
    coercion =&gt; 1,  # inherit from parent
  );
</pre>
<p class="Pp">Note that it is possible for a type constraint to have a
    <span class="Li">&quot;constraint&quot;</span> <i>and</i> a
    <span class="Li">&quot;constraint_generator&quot;</span>.</p>
<p class="Pp"></p>
<pre>  BaseType          # uses the constraint
  BaseType[]        # constraint_generator with no arguments
  BaseType[$x]      # constraint_generator with an argument
</pre>
<p class="Pp">In the <b>MultipleOf</b> example above, <b>MultipleOf[]</b> with
    no number would throw an error because of
    <span class="Li">&quot;assert_Int(shift)&quot;</span> not finding an
    integer.</p>
<p class="Pp">But it is certainly possible for <b>BaseType[]</b> to be
    meaningful and distinct from
  <span class="Li">&quot;BaseType&quot;</span>.</p>
<p class="Pp">For example, <b>Tuple</b> is just the same as <b>ArrayRef</b> and
    accepts any arrayref as being valid. But <b>Tuple[]</b> will only accept
    arrayrefs with zero elements in them. (Just like <b>Tuple[Any,Any]</b> will
    only accept arrayrefs with two elements.)</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="NEXT_STEPS"><a class="permalink" href="#NEXT_STEPS">NEXT
  STEPS</a></h1>
<p class="Pp">After that last example, probably have a little lie down. Once
    you're recovered, here's your next step:</p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>Type::Tiny::Manual::UsingWithMoose
    <p class="Pp">How to use Type::Tiny with Moose, including the advantages of
        Type::Tiny over built-in type constraints, and Moose-specific
      features.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Toby Inkster &lt;tobyink@cpan.org&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENCE"><a class="permalink" href="#COPYRIGHT_AND_LICENCE">COPYRIGHT
  AND LICENCE</a></h1>
<p class="Pp">This software is copyright (c) 2013-2014, 2017-2020 by Toby
    Inkster.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DISCLAIMER_OF_WARRANTIES"><a class="permalink" href="#DISCLAIMER_OF_WARRANTIES">DISCLAIMER
  OF WARRANTIES</a></h1>
<p class="Pp">THIS PACKAGE IS PROVIDED &quot;AS IS&quot; AND WITHOUT ANY EXPRESS
    OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES
    OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-10-28</td>
    <td class="foot-os"><a href="..">perl v5.34.0</a></td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Memoize(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Memoize(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Memoize(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Memoize - Make functions faster by trading space for time</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
        # This is the documentation for Memoize 1.03
        use Memoize;
        memoize('slow_function');
        slow_function(arguments);    # Is faster than it was before
</pre>
<p class="Pp">This is normally all you need to know. However, many options are
    available:</p>
<p class="Pp"></p>
<pre>
        memoize(function, options...);
</pre>
<p class="Pp">Options include:</p>
<p class="Pp"></p>
<pre>
        NORMALIZER =&gt; function
        INSTALL =&gt; new_name

        SCALAR_CACHE =&gt; 'MEMORY'
        SCALAR_CACHE =&gt; ['HASH', \%cache_hash ]
        SCALAR_CACHE =&gt; 'FAULT'
        SCALAR_CACHE =&gt; 'MERGE'

        LIST_CACHE =&gt; 'MEMORY'
        LIST_CACHE =&gt; ['HASH', \%cache_hash ]
        LIST_CACHE =&gt; 'FAULT'
        LIST_CACHE =&gt; 'MERGE'
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">`Memoizing' a function makes it faster by trading space for time.
    It does this by caching the return values of the function in a table. If you
    call the function again with the same arguments,
    <span class="Li">&quot;memoize&quot;</span> jumps in and gives you the value
    out of the table, instead of letting the function compute the value all over
    again.</p>
<p class="Pp">Here is an extreme example. Consider the Fibonacci sequence,
    defined by the following function:</p>
<p class="Pp"></p>
<pre>
        # Compute Fibonacci numbers
        sub fib {
          my $n = shift;
          return $n if $n &lt; 2;
          fib($n-1) + fib($n-2);
        }
</pre>
<p class="Pp">This function is very slow. Why? To compute fib(14), it first
    wants to compute fib(13) and fib(12), and add the results. But to compute
    fib(13), it first has to compute fib(12) and fib(11), and then it comes back
    and computes fib(12) all over again even though the answer is the same. And
    both of the times that it wants to compute fib(12), it has to compute
    fib(11) from scratch, and then it has to do it again each time it wants to
    compute fib(13). This function does so much recomputing of old results that
    it takes a really long time to run---fib(14) makes 1,200 extra recursive
    calls to itself, to compute and recompute things that it already
  computed.</p>
<p class="Pp">This function is a good candidate for memoization. If you memoize
    the `fib' function above, it will compute fib(14) exactly once, the first
    time it needs to, and then save the result in a table. Then if you ask for
    fib(14) again, it gives you the result out of the table. While computing
    fib(14), instead of computing fib(12) twice, it does it once; the second
    time it needs the value it gets it from the table. It doesn't compute
    fib(11) four times; it computes it once, getting it from the table the next
    three times. Instead of making 1,200 recursive calls to `fib', it makes 15.
    This makes the function about 150 times faster.</p>
<p class="Pp">You could do the memoization yourself, by rewriting the function,
    like this:</p>
<p class="Pp"></p>
<pre>
        # Compute Fibonacci numbers, memoized version
        { my @fib;
          sub fib {
            my $n = shift;
            return $fib[$n] if defined $fib[$n];
            return $fib[$n] = $n if $n &lt; 2;
            $fib[$n] = fib($n-1) + fib($n-2);
          }
        }
</pre>
<p class="Pp">Or you could use this module, like this:</p>
<p class="Pp"></p>
<pre>
        use Memoize;
        memoize('fib');

        # Rest of the fib function just like the original version.
</pre>
<p class="Pp">This makes it easy to turn memoizing on and off.</p>
<p class="Pp">Here's an even simpler example: I wrote a simple ray tracer; the
    program would look in a certain direction, figure out what it was looking
    at, and then convert the `color' value (typically a string like `red') of
    that object to a red, green, and blue pixel value, like this:</p>
<p class="Pp"></p>
<pre>
    for ($direction = 0; $direction &lt; 300; $direction++) {
      # Figure out which object is in direction $direction
      $color = $object-&gt;{color};
      ($r, $g, $b) = @{&amp;ColorToRGB($color)};
      ...
    }
</pre>
<p class="Pp">Since there are relatively few objects in a picture, there are
    only a few colors, which get looked up over and over again. Memoizing
    <span class="Li">&quot;ColorToRGB&quot;</span> sped up the program by
    several percent.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DETAILS"><a class="permalink" href="#DETAILS">DETAILS</a></h1>
<p class="Pp">This module exports exactly one function,
    <span class="Li">&quot;memoize&quot;</span>. The rest of the functions in
    this package are None of Your Business.</p>
<p class="Pp">You should say</p>
<p class="Pp"></p>
<pre>
        memoize(function)
</pre>
<p class="Pp">where <span class="Li">&quot;function&quot;</span> is the name of
    the function you want to memoize, or a reference to it.
    <span class="Li">&quot;memoize&quot;</span> returns a reference to the new,
    memoized version of the function, or
    <span class="Li">&quot;undef&quot;</span> on a non-fatal error. At present,
    there are no non-fatal errors, but there might be some in the future.</p>
<p class="Pp">If <span class="Li">&quot;function&quot;</span> was the name of a
    function, then <span class="Li">&quot;memoize&quot;</span> hides the old
    version and installs the new memoized version under the old name, so that
    <span class="Li">&quot;&amp;function(...)&quot;</span> actually invokes the
    memoized version.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OPTIONS"><a class="permalink" href="#OPTIONS">OPTIONS</a></h1>
<p class="Pp">There are some optional options you can pass to
    <span class="Li">&quot;memoize&quot;</span> to change the way it behaves a
    little. To supply options, invoke
    <span class="Li">&quot;memoize&quot;</span> like this:</p>
<p class="Pp"></p>
<pre>
        memoize(function, NORMALIZER =&gt; function,
                          INSTALL =&gt; newname,
                          SCALAR_CACHE =&gt; option,
                          LIST_CACHE =&gt; option
                         );
</pre>
<p class="Pp">Each of these options is optional; you can include some, all, or
    none of them.</p>
<section class="Ss">
<h2 class="Ss">INSTALL</h2>
<p class="Pp">If you supply a function name with
    <span class="Li">&quot;INSTALL&quot;</span>, memoize will install the new,
    memoized version of the function under the name you give. For example,</p>
<p class="Pp"></p>
<pre>
        memoize('fib', INSTALL =&gt; 'fastfib')
</pre>
<p class="Pp">installs the memoized version of
    <span class="Li">&quot;fib&quot;</span> as
    <span class="Li">&quot;fastfib&quot;</span>; without the
    <span class="Li">&quot;INSTALL&quot;</span> option it would have replaced
    the old <span class="Li">&quot;fib&quot;</span> with the memoized
  version.</p>
<p class="Pp">To prevent <span class="Li">&quot;memoize&quot;</span> from
    installing the memoized version anywhere, use <span class="Li">&quot;INSTALL
    =&gt; undef&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss">NORMALIZER</h2>
<p class="Pp">Suppose your function looks like this:</p>
<p class="Pp"></p>
<pre>
        # Typical call: f('aha!', A =&gt; 11, B =&gt; 12);
        sub f {
          my $a = shift;
          my %hash = @_;
          $hash{B} ||= 2;  # B defaults to 2
          $hash{C} ||= 7;  # C defaults to 7

          # Do something with $a, %hash
        }
</pre>
<p class="Pp">Now, the following calls to your function are all completely
    equivalent:</p>
<p class="Pp"></p>
<pre>
        f(OUCH);
        f(OUCH, B =&gt; 2);
        f(OUCH, C =&gt; 7);
        f(OUCH, B =&gt; 2, C =&gt; 7);
        f(OUCH, C =&gt; 7, B =&gt; 2);
        (etc.)
</pre>
<p class="Pp">However, unless you tell
    <span class="Li">&quot;Memoize&quot;</span> that these calls are equivalent,
    it will not know that, and it will compute the values for these invocations
    of your function separately, and store them separately.</p>
<p class="Pp">To prevent this, supply a
    <span class="Li">&quot;NORMALIZER&quot;</span> function that turns the
    program arguments into a string in a way that equivalent arguments turn into
    the same string. A <span class="Li">&quot;NORMALIZER&quot;</span> function
    for <span class="Li">&quot;f&quot;</span> above might look like this:</p>
<p class="Pp"></p>
<pre>
        sub normalize_f {
          my $a = shift;
          my %hash = @_;
          $hash{B} ||= 2;
          $hash{C} ||= 7;

          join(',', $a, map ($_ =&gt; $hash{$_}) sort keys %hash);
        }
</pre>
<p class="Pp">Each of the argument lists above comes out of the
    <span class="Li">&quot;normalize_f&quot;</span> function looking exactly the
    same, like this:</p>
<p class="Pp"></p>
<pre>
        OUCH,B,2,C,7
</pre>
<p class="Pp">You would tell <span class="Li">&quot;Memoize&quot;</span> to use
    this normalizer this way:</p>
<p class="Pp"></p>
<pre>
        memoize('f', NORMALIZER =&gt; 'normalize_f');
</pre>
<p class="Pp"><span class="Li">&quot;memoize&quot;</span> knows that if the
    normalized version of the arguments is the same for two argument lists, then
    it can safely look up the value that it computed for one argument list and
    return it as the result of calling the function with the other argument
    list, even if the argument lists look different.</p>
<p class="Pp">The default normalizer just concatenates the arguments with
    character 28 in between. (In ASCII, this is called FS or control-\.) This
    always works correctly for functions with only one string argument, and also
    when the arguments never contain character 28. However, it can confuse
    certain argument lists:</p>
<p class="Pp"></p>
<pre>
        normalizer(&quot;a\034&quot;, &quot;b&quot;)
        normalizer(&quot;a&quot;, &quot;\034b&quot;)
        normalizer(&quot;a\034\034b&quot;)
</pre>
<p class="Pp">for example.</p>
<p class="Pp">Since hash keys are strings, the default normalizer will not
    distinguish between <span class="Li">&quot;undef&quot;</span> and the empty
    string. It also won't work when the function's arguments are references. For
    example, consider a function <span class="Li">&quot;g&quot;</span> which
    gets two arguments: A number, and a reference to an array of numbers:</p>
<p class="Pp"></p>
<pre>
        g(13, [1,2,3,4,5,6,7]);
</pre>
<p class="Pp">The default normalizer will turn this into something like
    <span class="Li">&quot;13\034ARRAY(0x436c1f)&quot;</span>. That would be all
    right, except that a subsequent array of numbers might be stored at a
    different location even though it contains the same data. If this happens,
    <span class="Li">&quot;Memoize&quot;</span> will think that the arguments
    are different, even though they are equivalent. In this case, a normalizer
    like this is appropriate:</p>
<p class="Pp"></p>
<pre>
        sub normalize { join ' ', $_[0], @{$_[1]} }
</pre>
<p class="Pp">For the example above, this produces the key &quot;13 1 2 3 4 5 6
    7&quot;.</p>
<p class="Pp">Another use for normalizers is when the function depends on data
    other than those in its arguments. Suppose you have a function which returns
    a value which depends on the current hour of the day:</p>
<p class="Pp"></p>
<pre>
        sub on_duty {
          my ($problem_type) = @_;
          my $hour = (localtime)[2];
          open my $fh, &quot;$DIR/$problem_type&quot; or die...;
          my $line;
          while ($hour-- &gt; 0)
            $line = &lt;$fh&gt;;
          } 
          return $line;
        }
</pre>
<p class="Pp">At 10:23, this function generates the 10th line of a data file; at
    3:45 PM it generates the 15th line instead. By default,
    <span class="Li">&quot;Memoize&quot;</span> will only see the
    <span class="Li">$problem_type</span> argument. To fix this, include the
    current hour in the normalizer:</p>
<p class="Pp"></p>
<pre>
        sub normalize { join ' ', (localtime)[2], @_ }
</pre>
<p class="Pp">The calling context of the function (scalar or list context) is
    propagated to the normalizer. This means that if the memoized function will
    treat its arguments differently in list context than it would in scalar
    context, you can have the normalizer function select its behavior based on
    the results of <span class="Li">&quot;wantarray&quot;</span>. Even if called
    in a list context, a normalizer should still return a single string.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_SCALAR_CACHE_,__LIST_CACHE_"><a class="permalink" href="#_SCALAR_CACHE_,__LIST_CACHE_">&quot;SCALAR_CACHE&quot;,
  &quot;LIST_CACHE&quot;</a></h2>
<p class="Pp">Normally, <span class="Li">&quot;Memoize&quot;</span> caches your
    function's return values into an ordinary Perl hash variable. However, you
    might like to have the values cached on the disk, so that they persist from
    one run of your program to the next, or you might like to associate some
    other interesting semantics with the cached values.</p>
<p class="Pp">There's a slight complication under the hood of
    <span class="Li">&quot;Memoize&quot;</span>: There are actually <i>two</i>
    caches, one for scalar values and one for list values. When your function is
    called in scalar context, its return value is cached in one hash, and when
    your function is called in list context, its value is cached in the other
    hash. You can control the caching behavior of both contexts independently
    with these options.</p>
<p class="Pp">The argument to <span class="Li">&quot;LIST_CACHE&quot;</span> or
    <span class="Li">&quot;SCALAR_CACHE&quot;</span> must either be one of the
    following four strings:</p>
<p class="Pp"></p>
<pre>
        MEMORY
        FAULT
        MERGE
        HASH
</pre>
<p class="Pp">or else it must be a reference to an array whose first element is
    one of these four strings, such as <span class="Li">&quot;[HASH,
    arguments...]&quot;</span>.</p>
<dl class="Bl-tag">
  <dt>&quot;MEMORY&quot;</dt>
  <dd><span class="Li">&quot;MEMORY&quot;</span> means that return values from
      the function will be cached in an ordinary Perl hash variable. The hash
      variable will not persist after the program exits. This is the
    default.</dd>
  <dt>&quot;HASH&quot;</dt>
  <dd><span class="Li">&quot;HASH&quot;</span> allows you to specify that a
      particular hash that you supply will be used as the cache. You can tie
      this hash beforehand to give it any behavior you want.
    <p class="Pp">A tied hash can have any semantics at all. It is typically
        tied to an on-disk database, so that cached values are stored in the
        database and retrieved from it again when needed, and the disk file
        typically persists after your program has exited. See
        <span class="Li">&quot;perltie&quot;</span> for more complete details
        about <span class="Li">&quot;tie&quot;</span>.</p>
    <p class="Pp">A typical example is:</p>
    <p class="Pp"></p>
    <pre>
        use DB_File;
        tie my %cache =&gt; 'DB_File', $filename, O_RDWR|O_CREAT, 0666;
        memoize 'function', SCALAR_CACHE =&gt; [HASH =&gt; \%cache];
    </pre>
    <p class="Pp">This has the effect of storing the cache in a
        <span class="Li">&quot;DB_File&quot;</span> database whose name is in
        <span class="Li">$filename</span>. The cache will persist after the
        program has exited. Next time the program runs, it will find the cache
        already populated from the previous run of the program. Or you can
        forcibly populate the cache by constructing a batch program that runs in
        the background and populates the cache file. Then when you come to run
        your real program the memoized function will be fast because all its
        results have been precomputed.</p>
    <p class="Pp">Another reason to use <span class="Li">&quot;HASH&quot;</span>
        is to provide your own hash variable. You can then inspect or modify the
        contents of the hash to gain finer control over the cache
      management.</p>
  </dd>
  <dt>&quot;TIE&quot;</dt>
  <dd>This option is no longer supported. It is still documented only to aid in
      the debugging of old programs that use it. Old programs should be
      converted to use the <span class="Li">&quot;HASH&quot;</span> option
      instead.
    <p class="Pp"></p>
    <pre>
        memoize ... ['TIE', PACKAGE, ARGS...]
    </pre>
    <p class="Pp">is merely a shortcut for</p>
    <p class="Pp"></p>
    <pre>
        require PACKAGE;
        { tie my %cache, PACKAGE, ARGS...;
          memoize ... [HASH =&gt; \%cache];
        }
    </pre>
  </dd>
  <dt>&quot;FAULT&quot;</dt>
  <dd><span class="Li">&quot;FAULT&quot;</span> means that you never expect to
      call the function in scalar (or list) context, and that if
      <span class="Li">&quot;Memoize&quot;</span> detects such a call, it should
      abort the program. The error message is one of
    <p class="Pp"></p>
    <pre>
        `foo' function called in forbidden list context at line ...
        `foo' function called in forbidden scalar context at line ...
    </pre>
  </dd>
  <dt>&quot;MERGE&quot;</dt>
  <dd><span class="Li">&quot;MERGE&quot;</span> normally means that the memoized
      function does not distinguish between list and sclar context, and that
      return values in both contexts should be stored together. Both
      <span class="Li">&quot;LIST_CACHE =&gt;</span>
      <span class="Li">MERGE&quot;</span> and
      <span class="Li">&quot;SCALAR_CACHE =&gt; MERGE&quot;</span> mean the same
      thing.
    <p class="Pp">Consider this function:</p>
    <p class="Pp"></p>
    <pre>
        sub complicated {
          # ... time-consuming calculation of $result
          return $result;
        }
    </pre>
    <p class="Pp">The <span class="Li">&quot;complicated&quot;</span> function
        will return the same numeric <span class="Li">$result</span> regardless
        of whether it is called in list or in scalar context.</p>
    <p class="Pp">Normally, the following code will result in two calls to
        <span class="Li">&quot;complicated&quot;</span>, even if
        <span class="Li">&quot;complicated&quot;</span> is memoized:</p>
    <p class="Pp"></p>
    <pre>
    $x = complicated(142);
    ($y) = complicated(142);
    $z = complicated(142);
    </pre>
    <p class="Pp">The first call will cache the result, say 37, in the scalar
        cache; the second will cach the list
        <span class="Li">&quot;(37)&quot;</span> in the list cache. The third
        call doesn't call the real
        <span class="Li">&quot;complicated&quot;</span> function; it gets the
        value 37 from the scalar cache.</p>
    <p class="Pp">Obviously, the second call to
        <span class="Li">&quot;complicated&quot;</span> is a waste of time, and
        storing its return value is a waste of space. Specifying
        <span class="Li">&quot;LIST_CACHE</span> <span class="Li">=&gt;
        MERGE&quot;</span> will make <span class="Li">&quot;memoize&quot;</span>
        use the same cache for scalar and list context return values, so that
        the second call uses the scalar cache that was populated by the first
        call. <span class="Li">&quot;complicated&quot;</span> ends up being
        called only once, and both subsequent calls return
        <span class="Li">3</span> from the cache, regardless of the calling
        context.</p>
  </dd>
</dl>
<p class="Pp"><i>List values in scalar context</i></p>
<p class="Pp">Consider this function:</p>
<p class="Pp"></p>
<pre>
    sub iota { return reverse (1..$_[0]) }
</pre>
<p class="Pp">This function normally returns a list. Suppose you memoize it and
    merge the caches:</p>
<p class="Pp"></p>
<pre>
    memoize 'iota', SCALAR_CACHE =&gt; 'MERGE';

    @i7 = iota(7);
    $i7 = iota(7);
</pre>
<p class="Pp">Here the first call caches the list (1,2,3,4,5,6,7). The second
    call does not really make sense. <span class="Li">&quot;Memoize&quot;</span>
    cannot guess what behavior <span class="Li">&quot;iota&quot;</span> should
    have in scalar context without actually calling it in scalar context.
    Normally <span class="Li">&quot;Memoize&quot;</span> <i>would</i> call
    <span class="Li">&quot;iota&quot;</span> in scalar context and cache the
    result, but the <span class="Li">&quot;SCALAR_CACHE =&gt;
    'MERGE'&quot;</span> option says not to do that, but to use the cache
    list-context value instead. But it cannot return a list of seven elements in
    a scalar context. In this case <span class="Li">$i7</span> will receive the
    <b>first element</b> of the cached list value, namely 7.</p>
<p class="Pp"><i>Merged disk caches</i></p>
<p class="Pp">Another use for <span class="Li">&quot;MERGE&quot;</span> is when
    you want both kinds of return values stored in the same disk file; this
    saves you from having to deal with two disk files instead of one. You can
    use a normalizer function to keep the two sets of return values separate.
    For example:</p>
<p class="Pp"></p>
<pre>
        tie my %cache =&gt; 'MLDBM', 'DB_File', $filename, ...;

        memoize 'myfunc',
          NORMALIZER =&gt; 'n',
          SCALAR_CACHE =&gt; [HASH =&gt; \%cache],
          LIST_CACHE =&gt; 'MERGE',
        ;

        sub n {
          my $context = wantarray() ? 'L' : 'S';
          # ... now compute the hash key from the arguments ...
          $hashkey = &quot;$context:$hashkey&quot;;
        }
</pre>
<p class="Pp">This normalizer function will store scalar context return values
    in the disk file under keys that begin with
    <span class="Li">&quot;S:&quot;</span>, and list context return values under
    keys that begin with <span class="Li">&quot;L:&quot;</span>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="OTHER_FACILITIES"><a class="permalink" href="#OTHER_FACILITIES">OTHER
  FACILITIES</a></h1>
<section class="Ss">
<h2 class="Ss" id="_unmemoize_"><a class="permalink" href="#_unmemoize_">&quot;unmemoize&quot;</a></h2>
<p class="Pp">There's an <span class="Li">&quot;unmemoize&quot;</span> function
    that you can import if you want to. Why would you want to? Here's an
    example: Suppose you have your cache tied to a DBM file, and you want to
    make sure that the cache is written out to disk if someone interrupts the
    program. If the program exits normally, this will happen anyway, but if
    someone types control-C or something then the program will terminate
    immediately without synchronizing the database. So what you can do instead
    is</p>
<p class="Pp"></p>
<pre>
    $SIG{INT} = sub { unmemoize 'function' };
</pre>
<p class="Pp"><span class="Li">&quot;unmemoize&quot;</span> accepts a reference
    to, or the name of a previously memoized function, and undoes whatever it
    did to provide the memoized version in the first place, including making the
    name refer to the unmemoized version if appropriate. It returns a reference
    to the unmemoized version of the function.</p>
<p class="Pp">If you ask it to unmemoize a function that was never memoized, it
    croaks.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_flush_cache_"><a class="permalink" href="#_flush_cache_">&quot;flush_cache&quot;</a></h2>
<p class="Pp"><span class="Li">&quot;flush_cache(function)&quot;</span> will
    flush out the caches, discarding <i>all</i> the cached data. The argument
    may be a function name or a reference to a function. For finer control over
    when data is discarded or expired, see the documentation for
    <span class="Li">&quot;Memoize::Expire&quot;</span>, included in this
    package.</p>
<p class="Pp">Note that if the cache is a tied hash,
    <span class="Li">&quot;flush_cache&quot;</span> will attempt to invoke the
    <span class="Li">&quot;CLEAR&quot;</span> method on the hash. If there is no
    <span class="Li">&quot;CLEAR&quot;</span> method, this will cause a run-time
    error.</p>
<p class="Pp">An alternative approach to cache flushing is to use the
    <span class="Li">&quot;HASH&quot;</span> option (see above) to request that
    <span class="Li">&quot;Memoize&quot;</span> use a particular hash variable
    as its cache. Then you can examine or modify the hash at any time in any way
    you desire. You may flush the cache by using <span class="Li">&quot;%hash =
    ()&quot;</span>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<p class="Pp">Memoization is not a cure-all:</p>
<ul class="Bl-bullet">
  <li>Do not memoize a function whose behavior depends on program state other
      than its own arguments, such as global variables, the time of day, or file
      input. These functions will not produce correct results when memoized. For
      a particularly easy example:
    <p class="Pp"></p>
    <pre>
        sub f {
          time;
        }
    </pre>
    <p class="Pp">This function takes no arguments, and as far as
        <span class="Li">&quot;Memoize&quot;</span> is concerned, it always
        returns the same result. <span class="Li">&quot;Memoize&quot;</span> is
        wrong, of course, and the memoized version of this function will call
        <span class="Li">&quot;time&quot;</span> once to get the current time,
        and it will return that same time every time you call it after that.</p>
  </li>
  <li>Do not memoize a function with side effects.
    <p class="Pp"></p>
    <pre>
        sub f {
          my ($a, $b) = @_;
          my $s = $a + $b;
          print &quot;$a + $b = $s.\n&quot;;
        }
    </pre>
    <p class="Pp">This function accepts two arguments, adds them, and prints
        their sum. Its return value is the numuber of characters it printed, but
        you probably didn't care about that. But
        <span class="Li">&quot;Memoize&quot;</span> doesn't understand that. If
        you memoize this function, you will get the result you expect the first
        time you ask it to print the sum of 2 and 3, but subsequent calls will
        return 1 (the return value of <span class="Li">&quot;print&quot;</span>)
        without actually printing anything.</p>
  </li>
  <li>Do not memoize a function that returns a data structure that is modified
      by its caller.
    <p class="Pp">Consider these functions:
        <span class="Li">&quot;getusers&quot;</span> returns a list of users
        somehow, and then <span class="Li">&quot;main&quot;</span> throws away
        the first user on the list and prints the rest:</p>
    <p class="Pp"></p>
    <pre>
        sub main {
          my $userlist = getusers();
          shift @$userlist;
          foreach $u (@$userlist) {
            print &quot;User $u\n&quot;;
          }
        }

        sub getusers {
          my @users;
          # Do something to get a list of users;
          \@users;  # Return reference to list.
        }
    </pre>
    <p class="Pp">If you memoize <span class="Li">&quot;getusers&quot;</span>
        here, it will work right exactly once. The reference to the users list
        will be stored in the memo table.
        <span class="Li">&quot;main&quot;</span> will discard the first element
        from the referenced list. The next time you invoke
        <span class="Li">&quot;main&quot;</span>,
        <span class="Li">&quot;Memoize&quot;</span> will not call
        <span class="Li">&quot;getusers&quot;</span>; it will just return the
        same reference to the same list it got last time. But this time the list
        has already had its head removed;
        <span class="Li">&quot;main&quot;</span> will erroneously remove another
        element from it. The list will get shorter and shorter every time you
        call <span class="Li">&quot;main&quot;</span>.</p>
    <p class="Pp">Similarly, this:</p>
    <p class="Pp"></p>
    <pre>
        $u1 = getusers();    
        $u2 = getusers();    
        pop @$u1;
    </pre>
    <p class="Pp">will modify <span class="Li">$u2</span> as well as
        <span class="Li">$u1</span>, because both variables are references to
        the same array. Had <span class="Li">&quot;getusers&quot;</span> not
        been memoized, <span class="Li">$u1</span> and
        <span class="Li">$u2</span> would have referred to different arrays.</p>
  </li>
  <li>Do not memoize a very simple function.
    <p class="Pp">Recently someone mentioned to me that the Memoize module made
        his program run slower instead of faster. It turned out that he was
        memoizing the following function:</p>
    <p class="Pp"></p>
    <pre>
    sub square {
      $_[0] * $_[0];
    }
    </pre>
    <p class="Pp">I pointed out that <span class="Li">&quot;Memoize&quot;</span>
        uses a hash, and that looking up a number in the hash is necessarily
        going to take a lot longer than a single multiplication. There really is
        no way to speed up the <span class="Li">&quot;square&quot;</span>
        function.</p>
    <p class="Pp">Memoization is not magical.</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="PERSISTENT_CACHE_SUPPORT"><a class="permalink" href="#PERSISTENT_CACHE_SUPPORT">PERSISTENT
  CACHE SUPPORT</a></h1>
<p class="Pp">You can tie the cache tables to any sort of tied hash that you
    want to, as long as it supports <span class="Li">&quot;TIEHASH&quot;</span>,
    <span class="Li">&quot;FETCH&quot;</span>,
    <span class="Li">&quot;STORE&quot;</span>, and
    <span class="Li">&quot;EXISTS&quot;</span>. For example,</p>
<p class="Pp"></p>
<pre>
        tie my %cache =&gt; 'GDBM_File', $filename, O_RDWR|O_CREAT, 0666;
        memoize 'function', SCALAR_CACHE =&gt; [HASH =&gt; \%cache];
</pre>
<p class="Pp">works just fine. For some storage methods, you need a little
  glue.</p>
<p class="Pp"><span class="Li">&quot;SDBM_File&quot;</span> doesn't supply an
    <span class="Li">&quot;EXISTS&quot;</span> method, so included in this
    package is a glue module called
    <span class="Li">&quot;Memoize::SDBM_File&quot;</span> which does provide
    one. Use this instead of plain <span class="Li">&quot;SDBM_File&quot;</span>
    to store your cache table on disk in an
    <span class="Li">&quot;SDBM_File&quot;</span> database:</p>
<p class="Pp"></p>
<pre>
        tie my %cache =&gt; 'Memoize::SDBM_File', $filename, O_RDWR|O_CREAT, 0666;
        memoize 'function', SCALAR_CACHE =&gt; [HASH =&gt; \%cache];
</pre>
<p class="Pp"><span class="Li">&quot;NDBM_File&quot;</span> has the same problem
    and the same solution. (Use <span class="Li">&quot;Memoize::NDBM_File
    instead of plain NDBM_File.&quot;</span>)</p>
<p class="Pp"><span class="Li">&quot;Storable&quot;</span> isn't a tied hash
    class at all. You can use it to store a hash to disk and retrieve it again,
    but you can't modify the hash while it's on the disk. So if you want to
    store your cache table in a <span class="Li">&quot;Storable&quot;</span>
    database, use <span class="Li">&quot;Memoize::Storable&quot;</span>, which
    puts a hashlike front-end onto <span class="Li">&quot;Storable&quot;</span>.
    The hash table is actually kept in memory, and is loaded from your
    <span class="Li">&quot;Storable&quot;</span> file at the time you memoize
    the function, and stored back at the time you unmemoize the function (or
    when your program exits):</p>
<p class="Pp"></p>
<pre>
        tie my %cache =&gt; 'Memoize::Storable', $filename;
        memoize 'function', SCALAR_CACHE =&gt; [HASH =&gt; \%cache];

        tie my %cache =&gt; 'Memoize::Storable', $filename, 'nstore';
        memoize 'function', SCALAR_CACHE =&gt; [HASH =&gt; \%cache];
</pre>
<p class="Pp">Include the `nstore' option to have the
    <span class="Li">&quot;Storable&quot;</span> database written in `network
    order'. (See Storable for more details about this.)</p>
<p class="Pp">The <span class="Li">&quot;flush_cache()&quot;</span> function
    will raise a run-time error unless the tied package provides a
    <span class="Li">&quot;CLEAR&quot;</span> method.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPIRATION_SUPPORT"><a class="permalink" href="#EXPIRATION_SUPPORT">EXPIRATION
  SUPPORT</a></h1>
<p class="Pp">See Memoize::Expire, which is a plug-in module that adds
    expiration functionality to Memoize. If you don't like the kinds of policies
    that Memoize::Expire implements, it is easy to write your own plug-in module
    to implement whatever policy you desire. Memoize comes with several
    examples. An expiration manager that implements a LRU policy is available on
    CPAN as Memoize::ExpireLRU.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">The test suite is much better, but always needs improvement.</p>
<p class="Pp">There is some problem with the way <span class="Li">&quot;goto
    &amp;f&quot;</span> works under threaded Perl, perhaps because of the
    lexical scoping of <span class="Li">@_</span>. This is a bug in Perl, and
    until it is resolved, memoized functions will see a slightly different
    <span class="Li">&quot;caller()&quot;</span> and will perform a little more
    slowly on threaded perls than unthreaded perls.</p>
<p class="Pp">Some versions of <span class="Li">&quot;DB_File&quot;</span> won't
    let you store data under a key of length 0. That means that if you have a
    function <span class="Li">&quot;f&quot;</span> which you memoized and the
    cache is in a <span class="Li">&quot;DB_File&quot;</span> database, then the
    value of <span class="Li">&quot;f()&quot;</span>
    (<span class="Li">&quot;f&quot;</span> called with no arguments) will not be
    memoized. If this is a big problem, you can supply a normalizer function
    that prepends <span class="Li">&quot;x&quot;</span> to every key.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MAILING_LIST"><a class="permalink" href="#MAILING_LIST">MAILING
  LIST</a></h1>
<p class="Pp">To join a very low-traffic mailing list for announcements about
    <span class="Li">&quot;Memoize&quot;</span>, send an empty note to
    <span class="Li">&quot;mjd-perl-memoize-request@plover.com&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Mark-Jason Dominus
    (<span class="Li">&quot;mjd-perl-memoize+@plover.com&quot;</span>), Plover
    Systems co.</p>
<p class="Pp">See the <span class="Li">&quot;Memoize.pm&quot;</span> Page at
    http://perl.plover.com/Memoize/ for news and upgrades. Near this page, at
    http://perl.plover.com/MiniMemoize/ there is an article about memoization
    and about the internals of Memoize that appeared in The Perl Journal, issue
    #13. (This article is also included in the Memoize distribution as
    `article.html'.)</p>
<p class="Pp">The author's book <i>Higher-Order Perl</i> (2005, ISBN 1558607013,
    published by Morgan Kaufmann) discusses memoization (and many other topics)
    in tremendous detail. It is available on-line for free. For more
    information, visit http://hop.perl.plover.com/ .</p>
<p class="Pp">To join a mailing list for announcements about
    <span class="Li">&quot;Memoize&quot;</span>, send an empty message to
    <span class="Li">&quot;mjd-perl-memoize-request@plover.com&quot;</span>.
    This mailing list is for announcements only and has extremely low
    traffic---fewer than two messages per year.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">Copyright 1998, 1999, 2000, 2001, 2012 by Mark Jason Dominus</p>
<p class="Pp">This library is free software; you may redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="THANK_YOU"><a class="permalink" href="#THANK_YOU">THANK
  YOU</a></h1>
<p class="Pp">Many thanks to Florian Ragwitz for administration and packaging
    assistance, to John Tromp for bug reports, to Jonathan Roy for bug reports
    and suggestions, to Michael Schwern for other bug reports and patches, to
    Mike Cariaso for helping me to figure out the Right Thing to Do About
    Expiration, to Joshua Gerth, Joshua Chamas, Jonathan Roy (again), Mark D.
    Anderson, and Andrew Johnson for more suggestions about expiration, to Brent
    Powers for the Memoize::ExpireLRU module, to Ariel Scolnicov for delightful
    messages about the Fibonacci function, to Dion Almaer for thought-provoking
    suggestions about the default normalizer, to Walt Mankowski and Kurt
    Starsinic for much help investigating problems under threaded Perl, to Alex
    Dudkevich for reporting the bug in prototyped functions and for checking my
    patch, to Tony Bass for many helpful suggestions, to Jonathan Roy (again)
    for finding a use for <span class="Li">&quot;unmemoize()&quot;</span>, to
    Philippe Verdret for enlightening discussion of
    <span class="Li">&quot;Hook::PrePostCall&quot;</span>, to Nat Torkington for
    advice I ignored, to Chris Nandor for portability advice, to Randal Schwartz
    for suggesting the '<span class="Li">&quot;flush_cache&quot;</span>
    function, and to Jenda Krynicky for being a light in the world.</p>
<p class="Pp">Special thanks to Jarkko Hietaniemi, the 5.8.0 pumpking, for
    including this module in the core and for his patient and helpful guidance
    during the integration process.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="POD_ERRORS"><a class="permalink" href="#POD_ERRORS">POD
  ERRORS</a></h1>
<p class="Pp">Hey! <b>The above document had some coding errors, which are
    explained below:</b></p>
<dl class="Bl-tag">
  <dt id="Around"><a class="permalink" href="#Around">Around line 751:</a></dt>
  <dd>You forgot a '=back' before '=head3'</dd>
  <dt id="Around~2"><a class="permalink" href="#Around~2">Around line
    800:</a></dt>
  <dd>=back without =over</dd>
</dl>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-31</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

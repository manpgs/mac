<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Encode(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Encode(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Encode(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Encode - character encodings in Perl</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use Encode qw(decode encode);
    $characters = decode('UTF-8', $octets,     Encode::FB_CROAK);
    $octets     = encode('UTF-8', $characters, Encode::FB_CROAK);
</pre>
<section class="Ss">
<h2 class="Ss" id="Table_of_Contents"><a class="permalink" href="#Table_of_Contents">Table
  of Contents</a></h2>
<p class="Pp">Encode consists of a collection of modules whose details are too
    extensive to fit in one document. This one itself explains the top-level
    APIs and general topics at a glance. For other topics and more details, see
    the documentation for these modules:</p>
<dl class="Bl-tag">
  <dt id="Encode::Alias"><a class="permalink" href="#Encode::Alias">Encode::Alias
    - Alias definitions to encodings</a></dt>
  <dd></dd>
  <dt id="Encode::Encoding"><a class="permalink" href="#Encode::Encoding">Encode::Encoding
    - Encode Implementation Base Class</a></dt>
  <dd></dd>
  <dt id="Encode::Supported"><a class="permalink" href="#Encode::Supported">Encode::Supported
    - List of Supported Encodings</a></dt>
  <dd></dd>
  <dt id="Encode::CN"><a class="permalink" href="#Encode::CN">Encode::CN -
    Simplified Chinese Encodings</a></dt>
  <dd></dd>
  <dt id="Encode::JP"><a class="permalink" href="#Encode::JP">Encode::JP -
    Japanese Encodings</a></dt>
  <dd></dd>
  <dt id="Encode::KR"><a class="permalink" href="#Encode::KR">Encode::KR -
    Korean Encodings</a></dt>
  <dd></dd>
  <dt id="Encode::TW"><a class="permalink" href="#Encode::TW">Encode::TW -
    Traditional Chinese Encodings</a></dt>
  <dd></dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The <span class="Li">&quot;Encode&quot;</span> module provides the
    interface between Perl strings and the rest of the system. Perl strings are
    sequences of <i>characters</i>.</p>
<p class="Pp">The repertoire of characters that Perl can represent is a superset
    of those defined by the Unicode Consortium. On most platforms the ordinal
    values of a character as returned by
    <span class="Li">&quot;ord(</span><span class="Li"><i>S</i></span><span class="Li">)&quot;</span>
    is the <i>Unicode</i> <i>codepoint</i> for that character. The exceptions
    are platforms where the legacy encoding is some variant of EBCDIC rather
    than a superset of ASCII; see perlebcdic.</p>
<p class="Pp">During recent history, data is moved around a computer in 8-bit
    chunks, often called &quot;bytes&quot; but also known as &quot;octets&quot;
    in standards documents. Perl is widely used to manipulate data of many
    types: not only strings of characters representing human or computer
    languages, but also &quot;binary&quot; data, being the machine's
    representation of numbers, pixels in an image, or just about anything.</p>
<p class="Pp">When Perl is processing &quot;binary data&quot;, the programmer
    wants Perl to process &quot;sequences of bytes&quot;. This is not a problem
    for Perl: because a byte has 256 possible values, it easily fits in Perl's
    much larger &quot;logical character&quot;.</p>
<p class="Pp">This document mostly explains the <i>how</i>. perlunitut and
    perlunifaq explain the <i>why</i>.</p>
<section class="Ss">
<h2 class="Ss">TERMINOLOGY</h2>
<p class="Pp"><i>character</i></p>
<p class="Pp">A character in the range 0 .. 2**32-1 (or more); what Perl's
    strings are made of.</p>
<p class="Pp"><i>byte</i></p>
<p class="Pp">A character in the range 0..255; a special case of a Perl
    character.</p>
<p class="Pp"><i>octet</i></p>
<p class="Pp">8 bits of data, with ordinal values 0..255; term for bytes passed
    to or from a non-Perl context, such as a disk file, standard I/O stream,
    database, command-line argument, environment variable, socket etc.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="THE_PERL_ENCODING_API"><a class="permalink" href="#THE_PERL_ENCODING_API">THE
  PERL ENCODING API</a></h1>
<section class="Ss">
<h2 class="Ss" id="Basic_methods"><a class="permalink" href="#Basic_methods">Basic
  methods</a></h2>
<p class="Pp"><i>encode</i></p>
<p class="Pp"></p>
<pre>  $octets  = encode(ENCODING, STRING[, CHECK])
</pre>
<p class="Pp">Encodes the scalar value <i>STRING</i> from Perl's internal form
    into <i>ENCODING</i> and returns a sequence of octets. <i>ENCODING</i> can
    be either a canonical name or an alias. For encoding names and aliases, see
    &quot;Defining Aliases&quot;. For CHECK, see &quot;Handling Malformed
    Data&quot;.</p>
<p class="Pp"><b>CAVEAT</b>: the input scalar <i>STRING</i> might be modified
    in-place depending on what is set in CHECK. See &quot;LEAVE_SRC&quot; if you
    want your inputs to be left unchanged.</p>
<p class="Pp">For example, to convert a string from Perl's internal format into
    ISO-8859-1, also known as Latin1:</p>
<p class="Pp"></p>
<pre>  $octets = encode(&quot;iso-8859-1&quot;, $string);
</pre>
<p class="Pp"><b>CAVEAT</b>: When you run <span class="Li">&quot;$octets =
    encode(&quot;UTF-8&quot;, $string)&quot;</span>, then
    <span class="Li">$octets</span> <i>might not be equal to</i>
    <span class="Li">$string</span>. Though both contain the same data, the UTF8
    flag for <span class="Li">$octets</span> is <i>always</i> off. When you
    encode anything, the UTF8 flag on the result is always off, even when it
    contains a completely valid UTF-8 string. See &quot;The UTF8 flag&quot;
    below.</p>
<p class="Pp">If the <span class="Li">$string</span> is
    <span class="Li">&quot;undef&quot;</span>, then
    <span class="Li">&quot;undef&quot;</span> is returned.</p>
<p class="Pp"><span class="Li">&quot;str2bytes&quot;</span> may be used as an
    alias for <span class="Li">&quot;encode&quot;</span>.</p>
<p class="Pp"><i>decode</i></p>
<p class="Pp"></p>
<pre>  $string = decode(ENCODING, OCTETS[, CHECK])
</pre>
<p class="Pp">This function returns the string that results from decoding the
    scalar value <i>OCTETS</i>, assumed to be a sequence of octets in
    <i>ENCODING</i>, into Perl's internal form. As with <b>encode()</b>,
    <i>ENCODING</i> can be either a canonical name or an alias. For encoding
    names and aliases, see &quot;Defining Aliases&quot;; for <i>CHECK</i>, see
    &quot;Handling Malformed Data&quot;.</p>
<p class="Pp"><b>CAVEAT</b>: the input scalar <i>OCTETS</i> might be modified
    in-place depending on what is set in CHECK. See &quot;LEAVE_SRC&quot; if you
    want your inputs to be left unchanged.</p>
<p class="Pp">For example, to convert ISO-8859-1 data into a string in Perl's
    internal format:</p>
<p class="Pp"></p>
<pre>  $string = decode(&quot;iso-8859-1&quot;, $octets);
</pre>
<p class="Pp"><b>CAVEAT</b>: When you run <span class="Li">&quot;$string =
    decode(&quot;UTF-8&quot;, $octets)&quot;</span>, then
    <span class="Li">$string</span> <i>might not be equal to</i>
    <span class="Li">$octets</span>. Though both contain the same data, the UTF8
    flag for <span class="Li">$string</span> is on. See &quot;The UTF8
    flag&quot; below.</p>
<p class="Pp">If the <span class="Li">$string</span> is
    <span class="Li">&quot;undef&quot;</span>, then
    <span class="Li">&quot;undef&quot;</span> is returned.</p>
<p class="Pp"><span class="Li">&quot;bytes2str&quot;</span> may be used as an
    alias for <span class="Li">&quot;decode&quot;</span>.</p>
<p class="Pp"><i>find_encoding</i></p>
<p class="Pp"></p>
<pre>  [$obj =] find_encoding(ENCODING)
</pre>
<p class="Pp">Returns the <i>encoding object</i> corresponding to
    <i>ENCODING</i>. Returns <span class="Li">&quot;undef&quot;</span> if no
    matching <i>ENCODING</i> is find. The returned object is what does the
    actual encoding or decoding.</p>
<p class="Pp"></p>
<pre>  $string = decode($name, $bytes);
</pre>
<p class="Pp">is in fact</p>
<p class="Pp"></p>
<pre>    $string = do {
        $obj = find_encoding($name);
        croak qq(encoding &quot;$name&quot; not found) unless ref $obj;
        $obj-&gt;decode($bytes);
    };
</pre>
<p class="Pp">with more error checking.</p>
<p class="Pp">You can therefore save time by reusing this object as follows;</p>
<p class="Pp"></p>
<pre>    my $enc = find_encoding(&quot;iso-8859-1&quot;);
    while(&lt;&gt;) {
        my $string = $enc-&gt;decode($_);
        ... # now do something with $string;
    }
</pre>
<p class="Pp">Besides &quot;decode&quot; and &quot;encode&quot;, other methods
    are available as well. For instance,
    <span class="Li">&quot;name()&quot;</span> returns the canonical name of the
    encoding object.</p>
<p class="Pp"></p>
<pre>  find_encoding(&quot;latin1&quot;)-&gt;name; # iso-8859-1
</pre>
<p class="Pp">See Encode::Encoding for details.</p>
<p class="Pp"><i>find_mime_encoding</i></p>
<p class="Pp"></p>
<pre>  [$obj =] find_mime_encoding(MIME_ENCODING)
</pre>
<p class="Pp">Returns the <i>encoding object</i> corresponding to
    <i>MIME_ENCODING</i>. Acts same as
    <span class="Li">&quot;find_encoding()&quot;</span> but
    <span class="Li">&quot;mime_name()&quot;</span> of returned object must
    match to <i>MIME_ENCODING</i>. So as opposite of
    <span class="Li">&quot;find_encoding()&quot;</span> canonical names and
    aliases are not used when searching for object.</p>
<p class="Pp"></p>
<pre>    find_mime_encoding(&quot;utf8&quot;); # returns undef because &quot;utf8&quot; is not valid I&lt;MIME_ENCODING&gt;
    find_mime_encoding(&quot;utf-8&quot;); # returns encode object &quot;utf-8-strict&quot;
    find_mime_encoding(&quot;UTF-8&quot;); # same as &quot;utf-8&quot; because I&lt;MIME_ENCODING&gt; is case insensitive
    find_mime_encoding(&quot;utf-8-strict&quot;); returns undef because &quot;utf-8-strict&quot; is not valid I&lt;MIME_ENCODING&gt;
</pre>
<p class="Pp"><i>from_to</i></p>
<p class="Pp"></p>
<pre>  [$length =] from_to($octets, FROM_ENC, TO_ENC [, CHECK])
</pre>
<p class="Pp">Converts <i>in-place</i> data between two encodings. The data in
    <span class="Li">$octets</span> must be encoded as octets and <i>not</i> as
    characters in Perl's internal format. For example, to convert ISO-8859-1
    data into Microsoft's CP1250 encoding:</p>
<p class="Pp"></p>
<pre>  from_to($octets, &quot;iso-8859-1&quot;, &quot;cp1250&quot;);
</pre>
<p class="Pp">and to convert it back:</p>
<p class="Pp"></p>
<pre>  from_to($octets, &quot;cp1250&quot;, &quot;iso-8859-1&quot;);
</pre>
<p class="Pp">Because the conversion happens in place, the data to be converted
    cannot be a string constant: it must be a scalar variable.</p>
<p class="Pp"><span class="Li">&quot;from_to()&quot;</span> returns the length
    of the converted string in octets on success, and
    <span class="Li">&quot;undef&quot;</span> on error.</p>
<p class="Pp"><b>CAVEAT</b>: The following operations may look the same, but are
    not:</p>
<p class="Pp"></p>
<pre>  from_to($data, &quot;iso-8859-1&quot;, &quot;UTF-8&quot;); #1
  $data = decode(&quot;iso-8859-1&quot;, $data);  #2
</pre>
<p class="Pp">Both #1 and #2 make <span class="Li">$data</span> consist of a
    completely valid UTF-8 string, but only #2 turns the UTF8 flag on. #1 is
    equivalent to:</p>
<p class="Pp"></p>
<pre>  $data = encode(&quot;UTF-8&quot;, decode(&quot;iso-8859-1&quot;, $data));
</pre>
<p class="Pp">See &quot;The UTF8 flag&quot; below.</p>
<p class="Pp">Also note that:</p>
<p class="Pp"></p>
<pre>  from_to($octets, $from, $to, $check);
</pre>
<p class="Pp">is equivalent to:</p>
<p class="Pp"></p>
<pre>  $octets = encode($to, decode($from, $octets), $check);
</pre>
<p class="Pp">Yes, it does <i>not</i> respect the <span class="Li">$check</span>
    during decoding. It is deliberately done that way. If you need minute
    control, use <span class="Li">&quot;decode&quot;</span> followed by
    <span class="Li">&quot;encode&quot;</span> as follows:</p>
<p class="Pp"></p>
<pre>  $octets = encode($to, decode($from, $octets, $check_from), $check_to);
</pre>
<p class="Pp"><i>encode_utf8</i></p>
<p class="Pp"></p>
<pre>  $octets = encode_utf8($string);
</pre>
<p class="Pp">Equivalent to <span class="Li">&quot;$octets =
    encode(&quot;utf8&quot;, $string)&quot;</span>. The characters in
    <span class="Li">$string</span> are encoded in Perl's internal format, and
    the result is returned as a sequence of octets. Because all possible
    characters in Perl have a (loose, not strict) utf8 representation, this
    function cannot fail.</p>
<p class="Pp"><b>WARNING</b>: do not use this function for data exchange as it
    can produce not strict utf8 <span class="Li">$octets</span>! For strictly
    valid UTF-8 output use <span class="Li">&quot;$octets =
    encode(&quot;UTF-8&quot;, $string)&quot;</span>.</p>
<p class="Pp"><i>decode_utf8</i></p>
<p class="Pp"></p>
<pre>  $string = decode_utf8($octets [, CHECK]);
</pre>
<p class="Pp">Equivalent to <span class="Li">&quot;$string =
    decode(&quot;utf8&quot;, $octets [, CHECK])&quot;</span>. The sequence of
    octets represented by <span class="Li">$octets</span> is decoded from
    (loose, not strict) utf8 into a sequence of logical characters. Because not
    all sequences of octets are valid not strict utf8, it is quite possible for
    this function to fail. For CHECK, see &quot;Handling Malformed
  Data&quot;.</p>
<p class="Pp"><b>WARNING</b>: do not use this function for data exchange as it
    can produce <span class="Li">$string</span> with not strict utf8
    representation! For strictly valid UTF-8 <span class="Li">$string</span>
    representation use <span class="Li">&quot;$string =
    decode(&quot;UTF-8&quot;, $octets [, CHECK])&quot;</span>.</p>
<p class="Pp"><b>CAVEAT</b>: the input
    <i></i><span class="Li"><i>$octets</i></span><i></i> might be modified
    in-place depending on what is set in CHECK. See &quot;LEAVE_SRC&quot; if you
    want your inputs to be left unchanged.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Listing_available_encodings"><a class="permalink" href="#Listing_available_encodings">Listing
  available encodings</a></h2>
<pre>  use Encode;
  @list = Encode-&gt;encodings();
</pre>
<p class="Pp">Returns a list of canonical names of available encodings that have
    already been loaded. To get a list of all available encodings including
    those that have not yet been loaded, say:</p>
<p class="Pp"></p>
<pre>  @all_encodings = Encode-&gt;encodings(&quot;:all&quot;);
</pre>
<p class="Pp">Or you can give the name of a specific module:</p>
<p class="Pp"></p>
<pre>  @with_jp = Encode-&gt;encodings(&quot;Encode::JP&quot;);
</pre>
<p class="Pp">When &quot;<span class="Li">&quot;::&quot;</span>&quot; is not in
    the name, &quot;<span class="Li">&quot;Encode::&quot;</span>&quot; is
    assumed.</p>
<p class="Pp"></p>
<pre>  @ebcdic = Encode-&gt;encodings(&quot;EBCDIC&quot;);
</pre>
<p class="Pp">To find out in detail which encodings are supported by this
    package, see Encode::Supported.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Defining_Aliases"><a class="permalink" href="#Defining_Aliases">Defining
  Aliases</a></h2>
<p class="Pp">To add a new alias to a given encoding, use:</p>
<p class="Pp"></p>
<pre>  use Encode;
  use Encode::Alias;
  define_alias(NEWNAME =&gt; ENCODING);
</pre>
<p class="Pp">After that, <i>NEWNAME</i> can be used as an alias for
    <i>ENCODING</i>. <i>ENCODING</i> may be either the name of an encoding or an
    <i>encoding object</i>.</p>
<p class="Pp">Before you do that, first make sure the alias is nonexistent using
    <span class="Li">&quot;resolve_alias()&quot;</span>, which returns the
    canonical name thereof. For example:</p>
<p class="Pp"></p>
<pre>  Encode::resolve_alias(&quot;latin1&quot;) eq &quot;iso-8859-1&quot; # true
  Encode::resolve_alias(&quot;iso-8859-12&quot;)   # false; nonexistent
  Encode::resolve_alias($name) eq $name  # true if $name is canonical
</pre>
<p class="Pp"><span class="Li">&quot;resolve_alias()&quot;</span> does not need
    <span class="Li">&quot;use Encode::Alias&quot;</span>; it can be imported
    via <span class="Li">&quot;use Encode qw(resolve_alias)&quot;</span>.</p>
<p class="Pp">See Encode::Alias for details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Finding_"><a class="permalink" href="#Finding_">Finding IANA
  Character Set Registry names</a></h2>
<p class="Pp">The canonical name of a given encoding does not necessarily agree
    with IANA Character Set Registry, commonly seen as
    <span class="Li">&quot;Content-Type:</span> <span class="Li">text/plain;
    charset=</span><span class="Li"><i>WHATEVER</i></span><span class="Li">&quot;</span>.
    For most cases, the canonical name works, but sometimes it does not, most
    notably with &quot;utf-8-strict&quot;.</p>
<p class="Pp">As of <span class="Li">&quot;Encode&quot;</span> version 2.21, a
    new method <span class="Li">&quot;mime_name()&quot;</span> is therefore
    added.</p>
<p class="Pp"></p>
<pre>  use Encode;
  my $enc = find_encoding(&quot;UTF-8&quot;);
  warn $enc-&gt;name;      # utf-8-strict
  warn $enc-&gt;mime_name; # UTF-8
</pre>
<p class="Pp">See also: Encode::Encoding</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Encoding_via_PerlIO"><a class="permalink" href="#Encoding_via_PerlIO">Encoding
  via PerlIO</a></h1>
<p class="Pp">If your perl supports <span class="Li">&quot;PerlIO&quot;</span>
    (which is the default), you can use a
    <span class="Li">&quot;PerlIO&quot;</span> layer to decode and encode
    directly via a filehandle. The following two examples are fully identical in
    functionality:</p>
<p class="Pp"></p>
<pre>  ### Version 1 via PerlIO
    open(INPUT,  &quot;&lt; :encoding(shiftjis)&quot;, $infile)
        || die &quot;Can't open &lt; $infile for reading: $!&quot;;
    open(OUTPUT, &quot;&gt; :encoding(euc-jp)&quot;,  $outfile)
        || die &quot;Can't open &gt; $output for writing: $!&quot;;
    while (&lt;INPUT&gt;) {   # auto decodes $_
        print OUTPUT;   # auto encodes $_
    }
    close(INPUT)   || die &quot;can't close $infile: $!&quot;;
    close(OUTPUT)  || die &quot;can't close $outfile: $!&quot;;
  ### Version 2 via from_to()
    open(INPUT,  &quot;&lt; :raw&quot;, $infile)
        || die &quot;Can't open &lt; $infile for reading: $!&quot;;
    open(OUTPUT, &quot;&gt; :raw&quot;,  $outfile)
        || die &quot;Can't open &gt; $output for writing: $!&quot;;
    while (&lt;INPUT&gt;) {
        from_to($_, &quot;shiftjis&quot;, &quot;euc-jp&quot;, 1);  # switch encoding
        print OUTPUT;   # emit raw (but properly encoded) data
    }
    close(INPUT)   || die &quot;can't close $infile: $!&quot;;
    close(OUTPUT)  || die &quot;can't close $outfile: $!&quot;;
</pre>
<p class="Pp">In the first version above, you let the appropriate encoding layer
    handle the conversion. In the second, you explicitly translate from one
    encoding to the other.</p>
<p class="Pp">Unfortunately, it may be that encodings are not
    <span class="Li">&quot;PerlIO&quot;</span>-savvy. You can check to see
    whether your encoding is supported by
    <span class="Li">&quot;PerlIO&quot;</span> by invoking the
    <span class="Li">&quot;perlio_ok&quot;</span> method on it:</p>
<p class="Pp"></p>
<pre>  Encode::perlio_ok(&quot;hz&quot;);             # false
  find_encoding(&quot;euc-cn&quot;)-&gt;perlio_ok;  # true wherever PerlIO is available
  use Encode qw(perlio_ok);            # imported upon request
  perlio_ok(&quot;euc-jp&quot;)
</pre>
<p class="Pp">Fortunately, all encodings that come with
    <span class="Li">&quot;Encode&quot;</span> core are
    <span class="Li">&quot;PerlIO&quot;</span>-savvy except for
    <span class="Li">&quot;hz&quot;</span> and
    <span class="Li">&quot;ISO-2022-kr&quot;</span>. For the gory details, see
    Encode::Encoding and Encode::PerlIO.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Handling_Malformed_Data"><a class="permalink" href="#Handling_Malformed_Data">Handling
  Malformed Data</a></h1>
<p class="Pp">The optional <i>CHECK</i> argument tells
    <span class="Li">&quot;Encode&quot;</span> what to do when encountering
    malformed data. Without <i>CHECK</i>,
    <span class="Li">&quot;Encode::FB_DEFAULT&quot;</span> (== 0) is
  assumed.</p>
<p class="Pp">As of version 2.12, <span class="Li">&quot;Encode&quot;</span>
    supports coderef values for <span class="Li">&quot;CHECK&quot;</span>; see
    below.</p>
<p class="Pp"><b>NOTE:</b> Not all encodings support this feature. Some
    encodings ignore the <i>CHECK</i> argument. For example, Encode::Unicode
    ignores <i>CHECK</i> and it always croaks on error.</p>
<section class="Ss">
<h2 class="Ss" id="List_of_"><a class="permalink" href="#List_of_">List of
  <i>CHECK</i> values</a></h2>
<p class="Pp"><i>FB_DEFAULT</i></p>
<p class="Pp"></p>
<pre>  I&lt;CHECK&gt; = Encode::FB_DEFAULT ( == 0)
</pre>
<p class="Pp">If <i>CHECK</i> is 0, encoding and decoding replace any malformed
    character with a <i>substitution character</i>. When you encode,
    <i>SUBCHAR</i> is used. When you decode, the Unicode REPLACEMENT CHARACTER,
    code point U+FFFD, is used. If the data is supposed to be UTF-8, an optional
    lexical warning of warning category <span class="Li">&quot;utf8&quot;</span>
    is given.</p>
<p class="Pp"><i>FB_CROAK</i></p>
<p class="Pp"></p>
<pre>  I&lt;CHECK&gt; = Encode::FB_CROAK ( == 1)
</pre>
<p class="Pp">If <i>CHECK</i> is 1, methods immediately die with an error
    message. Therefore, when <i>CHECK</i> is 1, you should trap exceptions with
    <span class="Li">&quot;eval{}&quot;</span>, unless you really want to let it
    <span class="Li">&quot;die&quot;</span>.</p>
<p class="Pp"><i>FB_QUIET</i></p>
<p class="Pp"></p>
<pre>  I&lt;CHECK&gt; = Encode::FB_QUIET
</pre>
<p class="Pp">If <i>CHECK</i> is set to
    <span class="Li">&quot;Encode::FB_QUIET&quot;</span>, encoding and decoding
    immediately return the portion of the data that has been processed so far
    when an error occurs. The data argument is overwritten with everything after
    that point; that is, the unprocessed portion of the data. This is handy when
    you have to call <span class="Li">&quot;decode&quot;</span> repeatedly in
    the case where your source data may contain partial multi-byte character
    sequences, (that is, you are reading with a fixed-width buffer). Here's some
    sample code to do exactly that:</p>
<p class="Pp"></p>
<pre>    my($buffer, $string) = (&quot;&quot;, &quot;&quot;);
    while (read($fh, $buffer, 256, length($buffer))) {
        $string .= decode($encoding, $buffer, Encode::FB_QUIET);
        # $buffer now contains the unprocessed partial character
    }
</pre>
<p class="Pp"><i>FB_WARN</i></p>
<p class="Pp"></p>
<pre>  I&lt;CHECK&gt; = Encode::FB_WARN
</pre>
<p class="Pp">This is the same as <span class="Li">&quot;FB_QUIET&quot;</span>
    above, except that instead of being silent on errors, it issues a warning.
    This is handy for when you are debugging.</p>
<p class="Pp"><b>CAVEAT</b>: All warnings from Encode module are reported,
    independently of pragma warnings settings. If you want to follow settings of
    lexical warnings configured by pragma warnings then append also check value
    <span class="Li">&quot;ENCODE::ONLY_PRAGMA_WARNINGS&quot;</span>. This value
    is available since Encode version 2.99.</p>
<p class="Pp"><i>FB_PERLQQ FB_HTMLCREF FB_XMLCREF</i></p>
<dl class="Bl-tag">
  <dt id="perlqq"><a class="permalink" href="#perlqq">perlqq mode (<i>CHECK</i>
    = Encode::FB_PERLQQ)</a></dt>
  <dd></dd>
  <dt id="HTML"><a class="permalink" href="#HTML">HTML charref mode
    (<i>CHECK</i> = Encode::FB_HTMLCREF)</a></dt>
  <dd></dd>
  <dt id="XML"><a class="permalink" href="#XML">XML charref mode (<i>CHECK</i> =
    Encode::FB_XMLCREF)</a></dt>
  <dd></dd>
</dl>
<p class="Pp">For encodings that are implemented by the
    <span class="Li">&quot;Encode::XS&quot;</span> module,
    <span class="Li">&quot;CHECK&quot;</span>
    <span class="Li">&quot;==&quot;</span>
    <span class="Li">&quot;Encode::FB_PERLQQ&quot;</span> puts
    <span class="Li">&quot;encode&quot;</span> and
    <span class="Li">&quot;decode&quot;</span> into
    <span class="Li">&quot;perlqq&quot;</span> fallback mode.</p>
<p class="Pp">When you decode,
    <span class="Li">&quot;\x</span><span class="Li"><i>HH</i></span><span class="Li">&quot;</span>
    is inserted for a malformed character, where <i>HH</i> is the hex
    representation of the octet that could not be decoded to utf8. When you
    encode,
    <span class="Li">&quot;\x{</span><span class="Li"><i>HHHH</i></span><span class="Li">}&quot;</span>
    will be inserted, where <i>HHHH</i> is the Unicode code point (in any number
    of hex digits) of the character that cannot be found in the character
    repertoire of the encoding.</p>
<p class="Pp">The HTML/XML character reference modes are about the same. In
    place of
    <span class="Li">&quot;\x{</span><span class="Li"><i>HHHH</i></span><span class="Li">}&quot;</span>,
    HTML uses
    <span class="Li">&quot;&amp;#</span><span class="Li"><i>NNN</i></span><span class="Li">;&quot;</span>
    where <i>NNN</i> is a decimal number, and XML uses
    <span class="Li">&quot;&amp;#x</span><span class="Li"><i>HHHH</i></span><span class="Li">;&quot;</span>
    where <i>HHHH</i> is the hexadecimal number.</p>
<p class="Pp">In <span class="Li">&quot;Encode&quot;</span> 2.10 or later,
    <span class="Li">&quot;LEAVE_SRC&quot;</span> is also implied.</p>
<p class="Pp"><i>The bitmask</i></p>
<p class="Pp">These modes are all actually set via a bitmask. Here is how the
    <span class="Li">&quot;FB_</span><span class="Li"><i>XXX</i></span><span class="Li">&quot;</span>
    constants are laid out. You can import the
    <span class="Li">&quot;FB_</span><span class="Li"><i>XXX</i></span><span class="Li">&quot;</span>
    constants via <span class="Li">&quot;use Encode qw(:fallbacks)&quot;</span>,
    and you can import the generic bitmask constants via
    <span class="Li">&quot;use Encode qw(:fallback_all)&quot;</span>.</p>
<p class="Pp"></p>
<pre>                     FB_DEFAULT FB_CROAK FB_QUIET FB_WARN  FB_PERLQQ
 DIE_ON_ERR    0x0001             X
 WARN_ON_ERR   0x0002                               X
 RETURN_ON_ERR 0x0004                      X        X
 LEAVE_SRC     0x0008                                        X
 PERLQQ        0x0100                                        X
 HTMLCREF      0x0200
 XMLCREF       0x0400
</pre>
<p class="Pp"><i>LEAVE_SRC</i></p>
<p class="Pp"></p>
<pre>  Encode::LEAVE_SRC
</pre>
<p class="Pp">If the <span class="Li">&quot;Encode::LEAVE_SRC&quot;</span> bit
    is <i>not</i> set but <i>CHECK</i> is set, then the source string to
    <b>encode()</b> or <b>decode()</b> will be overwritten in place. If you're
    not interested in this, then bitwise-OR it with the bitmask.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="coderef_for_"><a class="permalink" href="#coderef_for_">coderef
  for CHECK</a></h2>
<p class="Pp">As of <span class="Li">&quot;Encode&quot;</span> 2.12,
    <span class="Li">&quot;CHECK&quot;</span> can also be a code reference which
    takes the ordinal value of the unmapped character as an argument and returns
    octets that represent the fallback character. For instance:</p>
<p class="Pp"></p>
<pre>  $ascii = encode(&quot;ascii&quot;, $utf8, sub{ sprintf &quot;&lt;U+%04X&gt;&quot;, shift });
</pre>
<p class="Pp">Acts like <span class="Li">&quot;FB_PERLQQ&quot;</span> but
    U+<i>XXXX</i> is used instead of
    <span class="Li">&quot;\x{</span><span class="Li"><i>XXXX</i></span><span class="Li">}&quot;</span>.</p>
<p class="Pp">Fallback for <span class="Li">&quot;decode&quot;</span> must
    return decoded string (sequence of characters) and takes a list of ordinal
    values as its arguments. So for example if you wish to decode octets as
    UTF-8, and use ISO-8859-15 as a fallback for bytes that are not valid UTF-8,
    you could write</p>
<p class="Pp"></p>
<pre>    $str = decode 'UTF-8', $octets, sub {
        my $tmp = join '', map chr, @_;
        return decode 'ISO-8859-15', $tmp;
    };
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Defining_Encodings"><a class="permalink" href="#Defining_Encodings">Defining
  Encodings</a></h1>
<p class="Pp">To define a new encoding, use:</p>
<p class="Pp"></p>
<pre>    use Encode qw(define_encoding);
    define_encoding($object, CANONICAL_NAME [, alias...]);
</pre>
<p class="Pp"><i>CANONICAL_NAME</i> will be associated with
    <i></i><span class="Li"><i>$object</i></span><i></i>. The object should
    provide the interface described in Encode::Encoding. If more than two
    arguments are provided, additional arguments are considered aliases for
    <i></i><span class="Li"><i>$object</i></span><i></i>.</p>
<p class="Pp">See Encode::Encoding for details.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="The_UTF8_flag"><a class="permalink" href="#The_UTF8_flag">The
  UTF8 flag</a></h1>
<p class="Pp">Before the introduction of Unicode support in Perl, The
    <span class="Li">&quot;eq&quot;</span> operator just compared the strings
    represented by two scalars. Beginning with Perl 5.8,
    <span class="Li">&quot;eq&quot;</span> compares two strings with
    simultaneous consideration of <i>the UTF8 flag</i>. To explain why we made
    it so, I quote from page 402 of <i>Programming Perl, 3rd ed.</i></p>
<dl class="Bl-tag">
  <dt id="Goal"><a class="permalink" href="#Goal">Goal #1:</a></dt>
  <dd>Old byte-oriented programs should not spontaneously break on the old
      byte-oriented data they used to work on.</dd>
  <dt id="Goal~2"><a class="permalink" href="#Goal~2">Goal #2:</a></dt>
  <dd>Old byte-oriented programs should magically start working on the new
      character-oriented data when appropriate.</dd>
  <dt id="Goal~3"><a class="permalink" href="#Goal~3">Goal #3:</a></dt>
  <dd>Programs should run just as fast in the new character-oriented mode as in
      the old byte-oriented mode.</dd>
  <dt id="Goal~4"><a class="permalink" href="#Goal~4">Goal #4:</a></dt>
  <dd>Perl should remain one language, rather than forking into a byte-oriented
      Perl and a character-oriented Perl.</dd>
</dl>
<p class="Pp">When <i>Programming Perl, 3rd ed.</i> was written, not even Perl
    5.6.0 had been born yet, many features documented in the book remained
    unimplemented for a long time. Perl 5.8 corrected much of this, and the
    introduction of the UTF8 flag is one of them. You can think of there being
    two fundamentally different kinds of strings and string-operations in Perl:
    one a byte-oriented mode for when the internal UTF8 flag is off, and the
    other a character-oriented mode for when the internal UTF8 flag is on.</p>
<p class="Pp">This UTF8 flag is not visible in Perl scripts, exactly for the
    same reason you cannot (or rather, you <i>don't have to</i>) see whether a
    scalar contains a string, an integer, or a floating-point number. But you
    can still peek and poke these if you will. See the next section.</p>
<section class="Ss">
<h2 class="Ss" id="Messing_with_Perl's_Internals"><a class="permalink" href="#Messing_with_Perl's_Internals">Messing
  with Perl's Internals</a></h2>
<p class="Pp">The following API uses parts of Perl's internals in the current
    implementation. As such, they are efficient but may change in a future
    release.</p>
<p class="Pp"><i>is_utf8</i></p>
<p class="Pp"></p>
<pre>  is_utf8(STRING [, CHECK])
</pre>
<p class="Pp">[INTERNAL] Tests whether the UTF8 flag is turned on in the
    <i>STRING</i>. If <i>CHECK</i> is true, also checks whether <i>STRING</i>
    contains well-formed UTF-8. Returns true if successful, false otherwise.</p>
<p class="Pp">Typically only necessary for debugging and testing. Don't use this
    flag as a marker to distinguish character and binary data, that should be
    decided for each variable when you write your code.</p>
<p class="Pp"><b>CAVEAT</b>: If <i>STRING</i> has UTF8 flag set, it does
    <b>NOT</b> mean that <i>STRING</i> is UTF-8 encoded and vice-versa.</p>
<p class="Pp">As of Perl 5.8.1, utf8 also has the
    <span class="Li">&quot;utf8::is_utf8&quot;</span> function.</p>
<p class="Pp"><i>_utf8_on</i></p>
<p class="Pp"></p>
<pre>  _utf8_on(STRING)
</pre>
<p class="Pp">[INTERNAL] Turns the <i>STRING</i>'s internal UTF8 flag <b>on</b>.
    The <i>STRING</i> is <i>not</i> checked for containing only well-formed
    UTF-8. Do not use this unless you <i>know with absolute certainty</i> that
    the STRING holds only well-formed UTF-8. Returns the previous state of the
    UTF8 flag (so please don't treat the return value as indicating success or
    failure), or <span class="Li">&quot;undef&quot;</span> if <i>STRING</i> is
    not a string.</p>
<p class="Pp"><b>NOTE</b>: For security reasons, this function does not work on
    tainted values.</p>
<p class="Pp"><i>_utf8_off</i></p>
<p class="Pp"></p>
<pre>  _utf8_off(STRING)
</pre>
<p class="Pp">[INTERNAL] Turns the <i>STRING</i>'s internal UTF8 flag
    <b>off</b>. Do not use frivolously. Returns the previous state of the UTF8
    flag, or <span class="Li">&quot;undef&quot;</span> if <i>STRING</i> is not a
    string. Do not treat the return value as indicative of success or failure,
    because that isn't what it means: it is only the previous setting.</p>
<p class="Pp"><b>NOTE</b>: For security reasons, this function does not work on
    tainted values.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="UTF"><a class="permalink" href="#UTF">UTF-8 vs. utf8 vs.
  UTF8</a></h1>
<pre>  ....We now view strings not as sequences of bytes, but as sequences
  of numbers in the range 0 .. 2**32-1 (or in the case of 64-bit
  computers, 0 .. 2**64-1) -- Programming Perl, 3rd ed.
</pre>
<p class="Pp">That has historically been Perl's notion of UTF-8, as that is how
    UTF-8 was first conceived by Ken Thompson when he invented it. However,
    thanks to later revisions to the applicable standards, official UTF-8 is now
    rather stricter than that. For example, its range is much narrower (0 ..
    0x10_FFFF to cover only 21 bits instead of 32 or 64 bits) and some sequences
    are not allowed, like those used in surrogate pairs, the 31 non-character
    code points 0xFDD0 .. 0xFDEF, the last two code points in <i>any</i> plane
    (0x<i>XX</i>_FFFE and 0x<i>XX</i>_FFFF), all non-shortest encodings,
  etc.</p>
<p class="Pp">The former default in which Perl would always use a loose
    interpretation of UTF-8 has now been overruled:</p>
<p class="Pp"></p>
<pre>  From: Larry Wall &lt;larry@wall.org&gt;
  Date: December 04, 2004 11:51:58 JST
  To: perl-unicode@perl.org
  Subject: Re: Make Encode.pm support the real UTF-8
  Message-Id: &lt;20041204025158.GA28754@wall.org&gt;
  On Fri, Dec 03, 2004 at 10:12:12PM +0000, Tim Bunce wrote:
  : I've no problem with 'utf8' being perl's unrestricted uft8 encoding,
  : but &quot;UTF-8&quot; is the name of the standard and should give the
  : corresponding behaviour.
  For what it's worth, that's how I've always kept them straight in my
  head.
  Also for what it's worth, Perl 6 will mostly default to strict but
  make it easy to switch back to lax.
  Larry
</pre>
<p class="Pp">Got that? As of Perl 5.8.7, <b>&quot;UTF-8&quot;</b> means UTF-8
    in its current sense, which is conservative and strict and
    security-conscious, whereas <b>&quot;utf8&quot;</b> means UTF-8 in its
    former sense, which was liberal and loose and lax.
    <span class="Li">&quot;Encode&quot;</span> version 2.10 or later thus groks
    this subtle but critically important distinction between
    <span class="Li">&quot;UTF-8&quot;</span> and
    <span class="Li">&quot;utf8&quot;</span>.</p>
<p class="Pp"></p>
<pre>  encode(&quot;utf8&quot;,  &quot;\x{FFFF_FFFF}&quot;, 1); # okay
  encode(&quot;UTF-8&quot;, &quot;\x{FFFF_FFFF}&quot;, 1); # croaks
</pre>
<p class="Pp">In the <span class="Li">&quot;Encode&quot;</span> module,
    <span class="Li">&quot;UTF-8&quot;</span> is actually a canonical name for
    <span class="Li">&quot;utf-8-strict&quot;</span>. That hyphen between the
    <span class="Li">&quot;UTF&quot;</span> and the
    <span class="Li">&quot;8&quot;</span> is critical; without it,
    <span class="Li">&quot;Encode&quot;</span> goes &quot;liberal&quot; and
    (perhaps overly-)permissive:</p>
<p class="Pp"></p>
<pre>  find_encoding(&quot;UTF-8&quot;)-&gt;name # is 'utf-8-strict'
  find_encoding(&quot;utf-8&quot;)-&gt;name # ditto. names are case insensitive
  find_encoding(&quot;utf_8&quot;)-&gt;name # ditto. &quot;_&quot; are treated as &quot;-&quot;
  find_encoding(&quot;UTF8&quot;)-&gt;name  # is 'utf8'.
</pre>
<p class="Pp">Perl's internal UTF8 flag is called &quot;UTF8&quot;, without a
    hyphen. It indicates whether a string is internally encoded as
    &quot;utf8&quot;, also without a hyphen.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Encode::Encoding, Encode::Supported, Encode::PerlIO, encoding,
    perlebcdic, &quot;open&quot; in perlfunc, perlunicode, perluniintro,
    perlunifaq, perlunitut utf8, the Perl Unicode Mailing List
    &lt;http://lists.perl.org/list/perl-unicode.html&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MAINTAINER"><a class="permalink" href="#MAINTAINER">MAINTAINER</a></h1>
<p class="Pp">This project was originated by the late Nick Ing-Simmons and later
    maintained by Dan Kogai <i>&lt;dankogai@cpan.org&gt;</i>. See AUTHORS for a
    full list of people involved. For any questions, send mail to
    <i>&lt;perl-unicode@perl.org&gt;</i> so that we can all share.</p>
<p class="Pp">While Dan Kogai retains the copyright as a maintainer, credit
    should go to all those involved. See AUTHORS for a list of those who
    submitted code to the project.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 2002-2014 Dan Kogai
  <i>&lt;dankogai@cpan.org&gt;</i>.</p>
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2021-01-20</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>HTTP::Response(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">HTTP::Response(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">HTTP::Response(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">HTTP::Response - HTTP style response message</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 6.22</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">Response objects are returned by the <b>request()</b> method of
    the <span class="Li">&quot;LWP::UserAgent&quot;</span>:</p>
<p class="Pp"></p>
<pre>    # ...
    $response = $ua-&gt;request($request);
    if ($response-&gt;is_success) {
        print $response-&gt;decoded_content;
    }
    else {
        print STDERR $response-&gt;status_line, &quot;\n&quot;;
    }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The <span class="Li">&quot;HTTP::Response&quot;</span> class
    encapsulates HTTP style responses. A response consists of a response line,
    some headers, and a content body. Note that the LWP library uses HTTP style
    responses even for non-HTTP protocol schemes. Instances of this class are
    usually created and returned by the <b>request()</b> method of an
    <span class="Li">&quot;LWP::UserAgent&quot;</span> object.</p>
<p class="Pp"><span class="Li">&quot;HTTP::Response&quot;</span> is a subclass
    of <span class="Li">&quot;HTTP::Message&quot;</span> and therefore inherits
    its methods. The following additional methods are available:</p>
<dl class="Bl-tag">
  <dt>$r = HTTP::Response-&gt;new( $code )</dt>
  <dd></dd>
  <dt>$r = HTTP::Response-&gt;new( $code, $msg )</dt>
  <dd></dd>
  <dt>$r = HTTP::Response-&gt;new( $code, $msg, $header )</dt>
  <dd></dd>
  <dt>$r = HTTP::Response-&gt;new( $code, $msg, $header, $content )</dt>
  <dd>Constructs a new <span class="Li">&quot;HTTP::Response&quot;</span> object
      describing a response with response code <span class="Li">$code</span> and
      optional message <span class="Li">$msg</span>. The optional
      <span class="Li">$header</span> argument should be a reference to an
      <span class="Li">&quot;HTTP::Headers&quot;</span> object or a plain array
      reference of key/value pairs. The optional
      <span class="Li">$content</span> argument should be a string of bytes. The
      meanings of these arguments are described below.</dd>
  <dt>$r = HTTP::Response-&gt;parse( $str )</dt>
  <dd>This constructs a new response object by parsing the given string.</dd>
  <dt>$r-&gt;code</dt>
  <dd></dd>
  <dt>$r-&gt;code( $code )</dt>
  <dd>This is used to get/set the code attribute. The code is a 3 digit number
      that encode the overall outcome of an HTTP response. The
      <span class="Li">&quot;HTTP::Status&quot;</span> module provide constants
      that provide mnemonic names for the code attribute.</dd>
  <dt>$r-&gt;message</dt>
  <dd></dd>
  <dt>$r-&gt;message( $message )</dt>
  <dd>This is used to get/set the message attribute. The message is a short
      human readable single line string that explains the response code.</dd>
  <dt>$r-&gt;header( $field )</dt>
  <dd></dd>
  <dt>$r-&gt;header( $field =&gt; $value )</dt>
  <dd>This is used to get/set header values and it is inherited from
      <span class="Li">&quot;HTTP::Headers&quot;</span> via
      <span class="Li">&quot;HTTP::Message&quot;</span>. See HTTP::Headers for
      details and other similar methods that can be used to access the
    headers.</dd>
  <dt>$r-&gt;content</dt>
  <dd></dd>
  <dt>$r-&gt;content( $bytes )</dt>
  <dd>This is used to get/set the raw content and it is inherited from the
      <span class="Li">&quot;HTTP::Message&quot;</span> base class. See
      HTTP::Message for details and other methods that can be used to access the
      content.</dd>
  <dt>$r-&gt;decoded_content( %options )</dt>
  <dd>This will return the content after any
      <span class="Li">&quot;Content-Encoding&quot;</span> and charsets have
      been decoded. See HTTP::Message for details.</dd>
  <dt>$r-&gt;request</dt>
  <dd></dd>
  <dt>$r-&gt;request( $request )</dt>
  <dd>This is used to get/set the request attribute. The request attribute is a
      reference to the request that caused this response. It does not have to be
      the same request passed to the
      <span class="Li">$ua</span>-&gt;<b>request()</b> method, because there
      might have been redirects and authorization retries in between.</dd>
  <dt>$r-&gt;previous</dt>
  <dd></dd>
  <dt>$r-&gt;previous( $response )</dt>
  <dd>This is used to get/set the previous attribute. The previous attribute is
      used to link together chains of responses. You get chains of responses if
      the first response is redirect or unauthorized. The value is
      <span class="Li">&quot;undef&quot;</span> if this is the first response in
      a chain.
    <p class="Pp">Note that the method <span class="Li">$r</span>-&gt;redirects
        is provided as a more convenient way to access the response chain.</p>
  </dd>
  <dt>$r-&gt;status_line</dt>
  <dd>Returns the string &quot;&lt;code&gt; &lt;message&gt;&quot;. If the
      message attribute is not set then the official name of &lt;code&gt; (see
      HTTP::Status) is substituted.</dd>
  <dt>$r-&gt;base</dt>
  <dd>Returns the base URI for this response. The return value will be a
      reference to a URI object.
    <p class="Pp">The base URI is obtained from one the following sources (in
        priority order):</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>Embedded in the document content, for instance &lt;BASE
      HREF=&quot;...&quot;&gt; in HTML documents.</dd>
  <dt>2.</dt>
  <dd>A &quot;Content-Base:&quot; or a &quot;Content-Location:&quot; header in
      the response.
    <p class="Pp">For backwards compatibility with older HTTP implementations we
        will also look for the &quot;Base:&quot; header.</p>
  </dd>
  <dt>3.</dt>
  <dd>The URI used to request this response. This might not be the original URI
      that was passed to <span class="Li">$ua</span>-&gt;<b>request()</b>
      method, because we might have received some redirect responses first.</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">If none of these sources provide an absolute URI, undef is
    returned.</p>
<p class="Pp">When the LWP protocol modules produce the HTTP::Response object,
    then any base URI embedded in the document (step 1) will already have
    initialized the &quot;Content-Base:&quot; header. (See
    &quot;parse_head&quot; in LWP::UserAgent). This means that this method only
    performs the last 2 steps (the content is not always available either).</p>
</div>
<dl class="Bl-tag">
  <dt>$r-&gt;filename</dt>
  <dd>Returns a filename for this response. Note that doing sanity checks on the
      returned filename (eg. removing characters that cannot be used on the
      target filesystem where the filename would be used, and laundering it for
      security purposes) are the caller's responsibility; the only related thing
      done by this method is that it makes a simple attempt to return a plain
      filename with no preceding path segments.
    <p class="Pp">The filename is obtained from one the following sources (in
        priority order):</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>A &quot;Content-Disposition:&quot; header in the response. Proper decoding
      of RFC 2047 encoded filenames requires the
      <span class="Li">&quot;MIME::QuotedPrint&quot;</span> (for &quot;Q&quot;
      encoding), <span class="Li">&quot;MIME::Base64&quot;</span> (for
      &quot;B&quot; encoding), and <span class="Li">&quot;Encode&quot;</span>
      modules.</dd>
  <dt>2.</dt>
  <dd>A &quot;Content-Location:&quot; header in the response.</dd>
  <dt>3.</dt>
  <dd>The URI used to request this response. This might not be the original URI
      that was passed to <span class="Li">$ua</span>-&gt;<b>request()</b>
      method, because we might have received some redirect responses first.</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">If a filename cannot be derived from any of these sources, undef
    is returned.</p>
</div>
<dl class="Bl-tag">
  <dt>$r-&gt;as_string</dt>
  <dd></dd>
  <dt>$r-&gt;as_string( $eol )</dt>
  <dd>Returns a textual representation of the response.</dd>
  <dt>$r-&gt;is_info</dt>
  <dd></dd>
  <dt>$r-&gt;is_success</dt>
  <dd></dd>
  <dt>$r-&gt;is_redirect</dt>
  <dd></dd>
  <dt>$r-&gt;is_error</dt>
  <dd></dd>
  <dt>$r-&gt;is_client_error</dt>
  <dd></dd>
  <dt>$r-&gt;is_server_error</dt>
  <dd>These methods indicate if the response was informational, successful, a
      redirection, or an error. See HTTP::Status for the meaning of these.</dd>
  <dt>$r-&gt;error_as_HTML</dt>
  <dd>Returns a string containing a complete HTML document indicating what error
      occurred. This method should only be called when
      <span class="Li">$r</span>-&gt;is_error is TRUE.</dd>
  <dt>$r-&gt;redirects</dt>
  <dd>Returns the list of redirect responses that lead up to this response by
      following the <span class="Li">$r</span>-&gt;previous chain. The list
      order is oldest first.
    <p class="Pp">In scalar context return the number of redirect responses
        leading up to this one.</p>
  </dd>
  <dt>$r-&gt;current_age</dt>
  <dd>Calculates the &quot;current age&quot; of the response as specified by RFC
      2616 section 13.2.3. The age of a response is the time since it was sent
      by the origin server. The returned value is a number representing the age
      in seconds.</dd>
  <dt>$r-&gt;freshness_lifetime( %opt )</dt>
  <dd>Calculates the &quot;freshness lifetime&quot; of the response as specified
      by RFC 2616 section 13.2.4. The &quot;freshness lifetime&quot; is the
      length of time between the generation of a response and its expiration
      time. The returned value is the number of seconds until expiry.
    <p class="Pp">If the response does not contain an &quot;Expires&quot; or a
        &quot;Cache-Control&quot; header, then this function will apply some
        simple heuristic based on the &quot;Last-Modified&quot; header to
        determine a suitable lifetime. The following options might be passed to
        control the heuristics:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="heuristic_expiry"><a class="permalink" href="#heuristic_expiry">heuristic_expiry
    =&gt; $bool</a></dt>
  <dd>If passed as a FALSE value, don't apply heuristics and just return
      <span class="Li">&quot;undef&quot;</span> when &quot;Expires&quot; or
      &quot;Cache-Control&quot; is lacking.</dd>
  <dt id="h_lastmod_fraction"><a class="permalink" href="#h_lastmod_fraction">h_lastmod_fraction
    =&gt; $num</a></dt>
  <dd>This number represent the fraction of the difference since the
      &quot;Last-Modified&quot; timestamp to make the expiry time. The default
      is <span class="Li">0.10</span>, the suggested typical setting of 10% in
      RFC 2616.</dd>
  <dt id="h_min"><a class="permalink" href="#h_min">h_min =&gt; $sec</a></dt>
  <dd>This is the lower limit of the heuristic expiry age to use. The default is
      <span class="Li">60</span> (1 minute).</dd>
  <dt id="h_max"><a class="permalink" href="#h_max">h_max =&gt; $sec</a></dt>
  <dd>This is the upper limit of the heuristic expiry age to use. The default is
      <span class="Li">86400</span> (24 hours).</dd>
  <dt id="h_default"><a class="permalink" href="#h_default">h_default =&gt;
    $sec</a></dt>
  <dd>This is the expiry age to use when nothing else applies. The default is
      <span class="Li">3600</span> (1 hour) or &quot;h_min&quot; if
    greater.</dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>$r-&gt;is_fresh( %opt )</dt>
  <dd>Returns TRUE if the response is fresh, based on the values of
      <b>freshness_lifetime()</b> and <b>current_age()</b>. If the response is
      no longer fresh, then it has to be re-fetched or re-validated by the
      origin server.
    <p class="Pp">Options might be passed to control expiry heuristics, see the
        description of <b>freshness_lifetime()</b>.</p>
  </dd>
  <dt>$r-&gt;fresh_until( %opt )</dt>
  <dd>Returns the time (seconds since epoch) when this entity is no longer
      fresh.
    <p class="Pp">Options might be passed to control expiry heuristics, see the
        description of <b>freshness_lifetime()</b>.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">HTTP::Headers, HTTP::Message, HTTP::Status, HTTP::Request</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Gisle Aas &lt;gisle@activestate.com&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 1994-2017 by Gisle Aas.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-02-24</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Class::Tiny(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Class::Tiny(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Class::Tiny(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Class::Tiny - Minimalist class construction</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 1.006</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">In <i>Person.pm</i>:</p>
<p class="Pp"></p>
<pre>  package Person;
  use Class::Tiny qw( name );
  1;
</pre>
<p class="Pp">In <i>Employee.pm</i>:</p>
<p class="Pp"></p>
<pre>  package Employee;
  use parent 'Person';
  use Class::Tiny qw( ssn ), {
    timestamp =&gt; sub { time }   # attribute with default
  };
  1;
</pre>
<p class="Pp">In <i>example.pl</i>:</p>
<p class="Pp"></p>
<pre>  use Employee;
  my $obj = Employee-&gt;new( name =&gt; &quot;Larry&quot;, ssn =&gt; &quot;111-22-3333&quot; );
  # unknown attributes are ignored
  my $obj = Employee-&gt;new( name =&gt; &quot;Larry&quot;, OS =&gt; &quot;Linux&quot; );
  # $obj-&gt;{OS} does not exist
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module offers a minimalist class construction kit in around
    120 lines of code. Here is a list of features:</p>
<ul class="Bl-bullet">
  <li>defines attributes via import arguments</li>
  <li>generates read-write accessors</li>
  <li>supports lazy attribute defaults</li>
  <li>supports custom accessors</li>
  <li>superclass provides a standard <span class="Li">&quot;new&quot;</span>
      constructor</li>
  <li><span class="Li">&quot;new&quot;</span> takes a hash reference or list of
      key/value pairs</li>
  <li><span class="Li">&quot;new&quot;</span> supports providing
      <span class="Li">&quot;BUILDARGS&quot;</span> to customize constructor
      options</li>
  <li><span class="Li">&quot;new&quot;</span> calls
      <span class="Li">&quot;BUILD&quot;</span> for each class from parent to
      child</li>
  <li>superclass provides a <span class="Li">&quot;DESTROY&quot;</span>
    method</li>
  <li><span class="Li">&quot;DESTROY&quot;</span> calls
      <span class="Li">&quot;DEMOLISH&quot;</span> for each class from child to
      parent</li>
</ul>
<p class="Pp">Multiple-inheritance is possible, with superclass order determined
    via mro::get_linear_isa.</p>
<p class="Pp">It uses no non-core modules for any recent Perl. On Perls older
    than v5.10 it requires MRO::Compat. On Perls older than v5.14, it requires
    Devel::GlobalDestruction.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="USAGE"><a class="permalink" href="#USAGE">USAGE</a></h1>
<section class="Ss">
<h2 class="Ss" id="Defining_attributes"><a class="permalink" href="#Defining_attributes">Defining
  attributes</a></h2>
<p class="Pp">Define attributes as a list of import arguments:</p>
<p class="Pp"></p>
<pre>    package Foo::Bar;
    use Class::Tiny qw(
        name
        id
        height
        weight
    );
</pre>
<p class="Pp">For each attribute, a read-write accessor is created unless a
    subroutine of that name already exists:</p>
<p class="Pp"></p>
<pre>    $obj-&gt;name;               # getter
    $obj-&gt;name( &quot;John Doe&quot; ); # setter
</pre>
<p class="Pp">Attribute names must be valid subroutine identifiers or an
    exception will be thrown.</p>
<p class="Pp">You can specify lazy defaults by defining attributes with a hash
    reference. Keys define attribute names and values are constants or code
    references that will be evaluated when the attribute is first accessed if no
    value has been set. The object is passed as an argument to a code
  reference.</p>
<p class="Pp"></p>
<pre>    package Foo::WithDefaults;
    use Class::Tiny qw/name id/, {
        title     =&gt; 'Peon',
        skills    =&gt; sub { [] },
        hire_date =&gt; sub { $_[0]-&gt;_build_hire_date },
    };
</pre>
<p class="Pp">When subclassing, if multiple accessors of the same name exist in
    different classes, any default (or lack of default) is determined by
    standard method resolution order.</p>
<p class="Pp">To make your own custom accessors, just pre-declare the method
    name before loading Class::Tiny:</p>
<p class="Pp"></p>
<pre>    package Foo::Bar;
    use subs 'id';
    use Class::Tiny qw( name id );
    sub id { ... }
</pre>
<p class="Pp">Even if you pre-declare a method name, you must include it in the
    attribute list for Class::Tiny to register it as a valid attribute.</p>
<p class="Pp">If you set a default for a custom accessor, your accessor will
    need to retrieve the default and do something with it:</p>
<p class="Pp"></p>
<pre>    package Foo::Bar;
    use subs 'id';
    use Class::Tiny qw( name ), { id =&gt; sub { int(rand(2*31)) } };
    sub id {
        my $self = shift;
        if (@_) {
            return $self-&gt;{id} = shift;
        }
        elsif ( exists $self-&gt;{id} ) {
            return $self-&gt;{id};
        }
        else {
            my $defaults =
                Class::Tiny-&gt;get_all_attribute_defaults_for( ref $self );
            return $self-&gt;{id} = $defaults-&gt;{id}-&gt;();
        }
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Class::Tiny::Object_is_your_base_class"><a class="permalink" href="#Class::Tiny::Object_is_your_base_class">Class::Tiny::Object
  is your base class</a></h2>
<p class="Pp">If your class <b>does not</b> already inherit from some class,
    then Class::Tiny::Object will be added to your <span class="Li">@ISA</span>
    to provide <span class="Li">&quot;new&quot;</span> and
    <span class="Li">&quot;DESTROY&quot;</span>.</p>
<p class="Pp">If your class <b>does</b> inherit from something, then no
    additional inheritance is set up. If the parent subclasses
    Class::Tiny::Object, then all is well. If not, then you'll get accessors set
    up but no constructor or destructor. Don't do that unless you really have a
    special need for it.</p>
<p class="Pp">Define subclasses as normal. It's best to define them with base,
    parent or superclass before defining attributes with Class::Tiny so the
    <span class="Li">@ISA</span> array is already populated at compile-time:</p>
<p class="Pp"></p>
<pre>    package Foo::Bar::More;
    use parent 'Foo::Bar';
    use Class::Tiny qw( shoe_size );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Object_construction"><a class="permalink" href="#Object_construction">Object
  construction</a></h2>
<p class="Pp">If your class inherits from Class::Tiny::Object (as it should if
    you followed the advice above), it provides the
    <span class="Li">&quot;new&quot;</span> constructor for you.</p>
<p class="Pp">Objects can be created with attributes given as a hash reference
    or as a list of key/value pairs:</p>
<p class="Pp"></p>
<pre>    $obj = Foo::Bar-&gt;new( name =&gt; &quot;David&quot; );
    $obj = Foo::Bar-&gt;new( { name =&gt; &quot;David&quot; } );
</pre>
<p class="Pp">If a reference is passed as a single argument, it must be able to
    be dereferenced as a hash or an exception is thrown.</p>
<p class="Pp">Unknown attributes in the constructor arguments will be ignored.
    Prior to version 1.000, unknown attributes were an error, but this made it
    harder for people to cleanly subclass Class::Tiny classes so this feature
    was removed.</p>
<p class="Pp">You can define a <span class="Li">&quot;BUILDARGS&quot;</span>
    method to change how arguments to new are handled. It will receive the
    constructor arguments as they were provided and must return a hash reference
    of key/value pairs (or else throw an exception).</p>
<p class="Pp"></p>
<pre>    sub BUILDARGS {
       my $class = shift;
       my $name = shift || &quot;John Doe&quot;;
       return { name =&gt; $name };
     };
     Foo::Bar-&gt;new( &quot;David&quot; );
     Foo::Bar-&gt;new(); # &quot;John Doe&quot;
</pre>
<p class="Pp">Unknown attributes returned from
    <span class="Li">&quot;BUILDARGS&quot;</span> will be ignored.</p>
</section>
<section class="Ss">
<h2 class="Ss">BUILD</h2>
<p class="Pp">If your class or any superclass defines a
    <span class="Li">&quot;BUILD&quot;</span> method, it will be called by the
    constructor from the furthest parent class down to the child class after the
    object has been created.</p>
<p class="Pp">It is passed the constructor arguments as a hash reference. The
    return value is ignored. Use <span class="Li">&quot;BUILD&quot;</span> for
    validation, checking required attributes or setting default values that
    depend on other attributes.</p>
<p class="Pp"></p>
<pre>    sub BUILD {
        my ($self, $args) = @_;
        for my $req ( qw/name age/ ) {
            croak &quot;$req attribute required&quot; unless defined $self-&gt;$req;
        }
        croak &quot;Age must be non-negative&quot; if $self-&gt;age &lt; 0;
        $self-&gt;msg( &quot;Hello &quot; . $self-&gt;name );
    }
</pre>
<p class="Pp">The argument reference is a copy, so deleting elements won't
    affect data in the original (but changes will be passed to other BUILD
    methods in <span class="Li">@ISA</span>).</p>
</section>
<section class="Ss">
<h2 class="Ss">DEMOLISH</h2>
<p class="Pp">Class::Tiny provides a <span class="Li">&quot;DESTROY&quot;</span>
    method. If your class or any superclass defines a
    <span class="Li">&quot;DEMOLISH&quot;</span> method, they will be called
    from the child class to the furthest parent class during object destruction.
    It is provided a single boolean argument indicating whether Perl is in
    global destruction. Return values and errors are ignored.</p>
<p class="Pp"></p>
<pre>    sub DEMOLISH {
        my ($self, $global_destruct) = @_;
        $self-&gt;cleanup();
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Introspection_and_internals"><a class="permalink" href="#Introspection_and_internals">Introspection
  and internals</a></h2>
<p class="Pp">You can retrieve an unsorted list of valid attributes known to
    Class::Tiny for a class and its superclasses with the
    <span class="Li">&quot;get_all_attributes_for&quot;</span> class method.</p>
<p class="Pp"></p>
<pre>    my @attrs = Class::Tiny-&gt;get_all_attributes_for(&quot;Employee&quot;);
    # returns qw/name ssn timestamp/
</pre>
<p class="Pp">Likewise, a hash reference of all valid attributes and default
    values (or code references) may be retrieved with the
    <span class="Li">&quot;get_all_attribute_defaults_for&quot;</span> class
    method. Any attributes without a default will be
    <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp"></p>
<pre>    my $def = Class::Tiny-&gt;get_all_attribute_defaults_for(&quot;Employee&quot;);
    # returns {
    #   name =&gt; undef,
    #   ssn =&gt; undef
    #   timestamp =&gt; $coderef
    # }
</pre>
<p class="Pp">The <span class="Li">&quot;import&quot;</span> method uses two
    class methods, <span class="Li">&quot;prepare_class&quot;</span> and
    <span class="Li">&quot;create_attributes&quot;</span> to set up the
    <span class="Li">@ISA</span> array and attributes. Anyone attempting to
    extend Class::Tiny itself should use these instead of mocking up a call to
    <span class="Li">&quot;import&quot;</span>.</p>
<p class="Pp">When the first object is created, linearized
    <span class="Li">@ISA</span>, the valid attribute list and various
    subroutine references are cached for speed. Ensure that all inheritance and
    methods are in place before creating objects. (You don't want to be changing
    that once you create objects anyway, right?)</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="RATIONALE"><a class="permalink" href="#RATIONALE">RATIONALE</a></h1>
<section class="Ss">
<h2 class="Ss" id="Why_this_instead_of_Object::Tiny_or_Class::Accessor_or_something_else?"><a class="permalink" href="#Why_this_instead_of_Object::Tiny_or_Class::Accessor_or_something_else?">Why
  this instead of Object::Tiny or Class::Accessor or something else?</a></h2>
<p class="Pp">I wanted something so simple that it could potentially be used by
    core Perl modules I help maintain (or hope to write), most of which either
    use Class::Struct or roll-their-own OO framework each time.</p>
<p class="Pp">Object::Tiny and Object::Tiny::RW were close to what I wanted, but
    lacking some features I deemed necessary, and their maintainers have an even
    more strict philosophy against feature creep than I have.</p>
<p class="Pp">I also considered Class::Accessor, which has been around a long
    time and is heavily used, but it, too, lacked features I wanted and did
    things in ways I considered poor design.</p>
<p class="Pp">I looked for something else on CPAN, but after checking a dozen
    class creators I realized I could implement exactly what I wanted faster
    than I could search CPAN for something merely sufficient.</p>
<p class="Pp">In general, compared to most things on CPAN (other than
    Object::Tiny), Class::Tiny is smaller in implementation and simpler in
  API.</p>
<p class="Pp">Specifically, here is how Class::Tiny (&quot;C::T&quot;) compares
    to Object::Tiny (&quot;O::T&quot;) and Class::Accessor
  (&quot;C::A&quot;):</p>
<p class="Pp"></p>
<pre> FEATURE                            C::T    O::T      C::A
 --------------------------------------------------------------
 attributes defined via import      yes     yes       no
 read/write accessors               yes     no        yes
 lazy attribute defaults            yes     no        no
 provides new                       yes     yes       yes
 provides DESTROY                   yes     no        no
 new takes either hashref or list   yes     no (list) no (hash)
 Moo(se)-like BUILD/DEMOLISH        yes     no        no
 Moo(se)-like BUILDARGS             yes     no        no
 no extraneous methods via @ISA     yes     yes       no
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Why_this_instead_of_Moose_or_Moo?"><a class="permalink" href="#Why_this_instead_of_Moose_or_Moo?">Why
  this instead of Moose or Moo?</a></h2>
<p class="Pp">Moose and Moo are both excellent OO frameworks. Moose offers a
    powerful meta-object protocol (MOP), but is slow to start up and has about
    30 non-core dependencies including XS modules. Moo is faster to start up and
    has about 10 pure Perl dependencies but provides no true MOP, relying
    instead on its ability to transparently upgrade Moo to Moose when Moose's
    full feature set is required.</p>
<p class="Pp">By contrast, Class::Tiny has no MOP and has <b>zero</b> non-core
    dependencies for Perls in the support window. It has far less code, less
    complexity and no learning curve. If you don't need or can't afford what Moo
    or Moose offer, this is intended to be a reasonable fallback.</p>
<p class="Pp">That said, Class::Tiny offers Moose-like conventions for things
    like <span class="Li">&quot;BUILD&quot;</span> and
    <span class="Li">&quot;DEMOLISH&quot;</span> for some minimal
    interoperability and an easier upgrade path.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
<section class="Ss">
<h2 class="Ss" id="Bugs_/_Feature_Requests"><a class="permalink" href="#Bugs_/_Feature_Requests">Bugs
  / Feature Requests</a></h2>
<p class="Pp">Please report any bugs or feature requests through the issue
    tracker at &lt;https://github.com/dagolden/Class-Tiny/issues&gt;. You will
    be notified automatically of any progress on your issue.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Source_Code"><a class="permalink" href="#Source_Code">Source
  Code</a></h2>
<p class="Pp">This is open source software. The code repository is available for
    public review and contribution under the terms of the license.</p>
<p class="Pp">&lt;https://github.com/dagolden/Class-Tiny&gt;</p>
<p class="Pp"></p>
<pre>  git clone https://github.com/dagolden/Class-Tiny.git
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">David Golden &lt;dagolden@cpan.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<ul class="Bl-bullet">
  <li>Dagfinn Ilmari Manns&#x00E5;ker &lt;ilmari@ilmari.org&gt;</li>
  <li>David Golden &lt;xdg@xdg.me&gt;</li>
  <li>Gelu Lupas &lt;gelu@devnull.ro&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Olivier Mengu&#x00E9; &lt;dolmen@cpan.org&gt;</li>
  <li>Toby Inkster &lt;tobyink@cpan.org&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is Copyright (c) 2013 by David Golden.</p>
<p class="Pp">This is free software, licensed under:</p>
<p class="Pp"></p>
<pre>  The Apache License, Version 2.0, January 2004
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2016-09-10</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

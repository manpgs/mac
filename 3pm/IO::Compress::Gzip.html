<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>IO::Compress::Gzip(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">IO::Compress::Gzip(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">IO::Compress::Gzip(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">IO::Compress::Gzip - Write RFC 1952 files/buffers</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
    use IO::Compress::Gzip qw(gzip $GzipError) ;

    my $status = gzip $input =&gt; $output [,OPTS]
        or die &quot;gzip failed: $GzipError\n&quot;;

    my $z = new IO::Compress::Gzip $output [,OPTS]
        or die &quot;gzip failed: $GzipError\n&quot;;

    $z-&gt;print($string);
    $z-&gt;printf($format, $string);
    $z-&gt;write($string);
    $z-&gt;syswrite($string [, $length, $offset]);
    $z-&gt;flush();
    $z-&gt;tell();
    $z-&gt;eof();
    $z-&gt;seek($position, $whence);
    $z-&gt;binmode();
    $z-&gt;fileno();
    $z-&gt;opened();
    $z-&gt;autoflush();
    $z-&gt;input_line_number();
    $z-&gt;newStream( [OPTS] );

    $z-&gt;deflateParams();

    $z-&gt;close() ;

    $GzipError ;

    # IO::File mode

    print $z $string;
    printf $z $format, $string;
    tell $z
    eof $z
    seek $z, $position, $whence
    binmode $z
    fileno $z
    close $z ;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module provides a Perl interface that allows writing
    compressed data to files or buffer as defined in RFC 1952.</p>
<p class="Pp">All the gzip headers defined in RFC 1952 can be created using this
    module.</p>
<p class="Pp">For reading RFC 1952 files/buffers, see the companion module
    IO::Uncompress::Gunzip.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Functional_Interface"><a class="permalink" href="#Functional_Interface">Functional
  Interface</a></h1>
<p class="Pp">A top-level function, <span class="Li">&quot;gzip&quot;</span>, is
    provided to carry out &quot;one-shot&quot; compression between buffers
    and/or files. For finer control over the compression process, see the
    &quot;OO Interface&quot; section.</p>
<p class="Pp"></p>
<pre>
    use IO::Compress::Gzip qw(gzip $GzipError) ;

    gzip $input_filename_or_reference =&gt; $output_filename_or_reference [,OPTS]
        or die &quot;gzip failed: $GzipError\n&quot;;
</pre>
<p class="Pp">The functional interface needs Perl5.005 or better.</p>
<section class="Ss">
<h2 class="Ss" id="gzip_$input_filename_or_reference_=__$output_filename_or_reference__,_"><a class="permalink" href="#gzip_$input_filename_or_reference_=__$output_filename_or_reference__,_">gzip
  $input_filename_or_reference =&gt; $output_filename_or_reference [,
  OPTS]</a></h2>
<p class="Pp"><span class="Li">&quot;gzip&quot;</span> expects at least two
    parameters, <span class="Li">$input_filename_or_reference</span> and
    <span class="Li">$output_filename_or_reference</span>.</p>
<p class="Pp"><i>The </i><i>$input_filename_or_reference</i><i>
  parameter</i></p>
<p class="Pp">The parameter,
    <span class="Li">$input_filename_or_reference</span>, is used to define the
    source of the uncompressed data.</p>
<p class="Pp">It can take one of the following forms:</p>
<dl class="Bl-tag">
  <dt id="A"><a class="permalink" href="#A">A filename</a></dt>
  <dd>If the &lt;$input_filename_or_reference&gt; parameter is a simple scalar,
      it is assumed to be a filename. This file will be opened for reading and
      the input data will be read from it.</dd>
  <dt id="A~2"><a class="permalink" href="#A~2">A filehandle</a></dt>
  <dd>If the <span class="Li">$input_filename_or_reference</span> parameter is a
      filehandle, the input data will be read from it. The string '-' can be
      used as an alias for standard input.</dd>
  <dt id="A~3"><a class="permalink" href="#A~3">A scalar reference</a></dt>
  <dd>If <span class="Li">$input_filename_or_reference</span> is a scalar
      reference, the input data will be read from
      <span class="Li">$$input_filename_or_reference</span>.</dd>
  <dt id="An"><a class="permalink" href="#An">An array reference</a></dt>
  <dd>If <span class="Li">$input_filename_or_reference</span> is an array
      reference, each element in the array must be a filename.
    <p class="Pp">The input data will be read from each file in turn.</p>
    <p class="Pp">The complete array will be walked to ensure that it only
        contains valid filenames before any data is compressed.</p>
  </dd>
  <dt id="An~2"><a class="permalink" href="#An~2">An Input FileGlob
    string</a></dt>
  <dd>If <span class="Li">$input_filename_or_reference</span> is a string that
      is delimited by the characters &quot;&lt;&quot; and &quot;&gt;&quot;
      <span class="Li">&quot;gzip&quot;</span> will assume that it is an
      <i>input fileglob string</i>. The input is the list of files that match
      the fileglob.
    <p class="Pp">See File::GlobMapper for more details.</p>
  </dd>
</dl>
<p class="Pp">If the <span class="Li">$input_filename_or_reference</span>
    parameter is any other type, <span class="Li">&quot;undef&quot;</span> will
    be returned.</p>
<p class="Pp">In addition, if
    <span class="Li">$input_filename_or_reference</span> is a simple filename,
    the default values for the <span class="Li">&quot;Name&quot;</span> and
    <span class="Li">&quot;Time&quot;</span> options will be sourced from that
    file.</p>
<p class="Pp">If you do not want to use these defaults they can be overridden by
    explicitly setting the <span class="Li">&quot;Name&quot;</span> and
    <span class="Li">&quot;Time&quot;</span> options or by setting the
    <span class="Li">&quot;Minimal&quot;</span> parameter.</p>
<p class="Pp"><i>The </i><i>$output_filename_or_reference</i><i>
  parameter</i></p>
<p class="Pp">The parameter
    <span class="Li">$output_filename_or_reference</span> is used to control the
    destination of the compressed data. This parameter can take one of these
    forms.</p>
<dl class="Bl-tag">
  <dt id="A~4"><a class="permalink" href="#A~4">A filename</a></dt>
  <dd>If the <span class="Li">$output_filename_or_reference</span> parameter is
      a simple scalar, it is assumed to be a filename. This file will be opened
      for writing and the compressed data will be written to it.</dd>
  <dt id="A~5"><a class="permalink" href="#A~5">A filehandle</a></dt>
  <dd>If the <span class="Li">$output_filename_or_reference</span> parameter is
      a filehandle, the compressed data will be written to it. The string '-'
      can be used as an alias for standard output.</dd>
  <dt id="A~6"><a class="permalink" href="#A~6">A scalar reference</a></dt>
  <dd>If <span class="Li">$output_filename_or_reference</span> is a scalar
      reference, the compressed data will be stored in
      <span class="Li">$$output_filename_or_reference</span>.</dd>
  <dt id="An~3"><a class="permalink" href="#An~3">An Array Reference</a></dt>
  <dd>If <span class="Li">$output_filename_or_reference</span> is an array
      reference, the compressed data will be pushed onto the array.</dd>
  <dt id="An~4"><a class="permalink" href="#An~4">An Output FileGlob</a></dt>
  <dd>If <span class="Li">$output_filename_or_reference</span> is a string that
      is delimited by the characters &quot;&lt;&quot; and &quot;&gt;&quot;
      <span class="Li">&quot;gzip&quot;</span> will assume that it is an
      <i>output fileglob string</i>. The output is the list of files that match
      the fileglob.
    <p class="Pp">When <span class="Li">$output_filename_or_reference</span> is
        an fileglob string, <span class="Li">$input_filename_or_reference</span>
        must also be a fileglob string. Anything else is an error.</p>
    <p class="Pp">See File::GlobMapper for more details.</p>
  </dd>
</dl>
<p class="Pp">If the <span class="Li">$output_filename_or_reference</span>
    parameter is any other type, <span class="Li">&quot;undef&quot;</span> will
    be returned.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Notes"><a class="permalink" href="#Notes">Notes</a></h2>
<p class="Pp">When <span class="Li">$input_filename_or_reference</span> maps to
    multiple files/buffers and
    <span class="Li">$output_filename_or_reference</span> is a single
    file/buffer the input files/buffers will be stored in
    <span class="Li">$output_filename_or_reference</span> as a concatenated
    series of compressed data streams.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Optional_Parameters"><a class="permalink" href="#Optional_Parameters">Optional
  Parameters</a></h2>
<p class="Pp">Unless specified below, the optional parameters for
    <span class="Li">&quot;gzip&quot;</span>,
    <span class="Li">&quot;OPTS&quot;</span>, are the same as those used with
    the OO interface defined in the &quot;Constructor Options&quot; section
    below.</p>
<dl class="Bl-tag">
  <dt>&quot;AutoClose =&gt; 0|1&quot;</dt>
  <dd>This option applies to any input or output data streams to
      <span class="Li">&quot;gzip&quot;</span> that are filehandles.
    <p class="Pp">If <span class="Li">&quot;AutoClose&quot;</span> is specified,
        and the value is true, it will result in all input and/or output
        filehandles being closed once <span class="Li">&quot;gzip&quot;</span>
        has completed.</p>
    <p class="Pp">This parameter defaults to 0.</p>
  </dd>
  <dt>&quot;BinModeIn =&gt; 0|1&quot;</dt>
  <dd>This option is now a no-op. All files will be read in binmode.</dd>
  <dt>&quot;Append =&gt; 0|1&quot;</dt>
  <dd>The behaviour of this option is dependent on the type of output data
      stream.</dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>A Buffer
    <p class="Pp">If <span class="Li">&quot;Append&quot;</span> is enabled, all
        compressed data will be append to the end of the output buffer.
        Otherwise the output buffer will be cleared before any compressed data
        is written to it.</p>
  </li>
  <li>A Filename
    <p class="Pp">If <span class="Li">&quot;Append&quot;</span> is enabled, the
        file will be opened in append mode. Otherwise the contents of the file,
        if any, will be truncated before any compressed data is written to
      it.</p>
  </li>
  <li>A Filehandle
    <p class="Pp">If <span class="Li">&quot;Append&quot;</span> is enabled, the
        filehandle will be positioned to the end of the file via a call to
        <span class="Li">&quot;seek&quot;</span> before any compressed data is
        written to it. Otherwise the file pointer will not be moved.</p>
  </li>
</ul>
</div>
<div class="Bd-indent">
<p class="Pp">When <span class="Li">&quot;Append&quot;</span> is specified, and
    set to true, it will <i>append</i> all compressed data to the output data
    stream.</p>
<p class="Pp">So when the output is a filehandle it will carry out a seek to the
    eof before writing any compressed data. If the output is a filename, it will
    be opened for appending. If the output is a buffer, all compressed data will
    be appended to the existing buffer.</p>
<p class="Pp">Conversely when <span class="Li">&quot;Append&quot;</span> is not
    specified, or it is present and is set to false, it will operate as
  follows.</p>
<p class="Pp">When the output is a filename, it will truncate the contents of
    the file before writing any compressed data. If the output is a filehandle
    its position will not be changed. If the output is a buffer, it will be
    wiped before any compressed data is output.</p>
<p class="Pp">Defaults to 0.</p>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Examples"><a class="permalink" href="#Examples">Examples</a></h2>
<p class="Pp">To read the contents of the file
    <span class="Li">&quot;file1.txt&quot;</span> and write the compressed data
    to the file <span class="Li">&quot;file1.txt.gz&quot;</span>.</p>
<p class="Pp"></p>
<pre>
    use strict ;
    use warnings ;
    use IO::Compress::Gzip qw(gzip $GzipError) ;

    my $input = &quot;file1.txt&quot;;
    gzip $input =&gt; &quot;$input.gz&quot;
        or die &quot;gzip failed: $GzipError\n&quot;;
</pre>
<p class="Pp">To read from an existing Perl filehandle,
    <span class="Li">$input</span>, and write the compressed data to a buffer,
    <span class="Li">$buffer</span>.</p>
<p class="Pp"></p>
<pre>
    use strict ;
    use warnings ;
    use IO::Compress::Gzip qw(gzip $GzipError) ;
    use IO::File ;

    my $input = new IO::File &quot;&lt;file1.txt&quot;
        or die &quot;Cannot open 'file1.txt': $!\n&quot; ;
    my $buffer ;
    gzip $input =&gt; \$buffer
        or die &quot;gzip failed: $GzipError\n&quot;;
</pre>
<p class="Pp">To compress all files in the directory &quot;/my/home&quot; that
    match &quot;*.txt&quot; and store the compressed data in the same
  directory</p>
<p class="Pp"></p>
<pre>
    use strict ;
    use warnings ;
    use IO::Compress::Gzip qw(gzip $GzipError) ;

    gzip '&lt;/my/home/*.txt&gt;' =&gt; '&lt;*.gz&gt;'
        or die &quot;gzip failed: $GzipError\n&quot;;
</pre>
<p class="Pp">and if you want to compress each file one at a time, this will do
    the trick</p>
<p class="Pp"></p>
<pre>
    use strict ;
    use warnings ;
    use IO::Compress::Gzip qw(gzip $GzipError) ;

    for my $input ( glob &quot;/my/home/*.txt&quot; )
    {
        my $output = &quot;$input.gz&quot; ;
        gzip $input =&gt; $output
            or die &quot;Error compressing '$input': $GzipError\n&quot;;
    }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="OO_Interface"><a class="permalink" href="#OO_Interface">OO
  Interface</a></h1>
<section class="Ss">
<h2 class="Ss" id="Constructor"><a class="permalink" href="#Constructor">Constructor</a></h2>
<p class="Pp">The format of the constructor for
    <span class="Li">&quot;IO::Compress::Gzip&quot;</span> is shown below</p>
<p class="Pp"></p>
<pre>
    my $z = new IO::Compress::Gzip $output [,OPTS]
        or die &quot;IO::Compress::Gzip failed: $GzipError\n&quot;;
</pre>
<p class="Pp">It returns an
    <span class="Li">&quot;IO::Compress::Gzip&quot;</span> object on success and
    undef on failure. The variable <span class="Li">$GzipError</span> will
    contain an error message on failure.</p>
<p class="Pp">If you are running Perl 5.005 or better the object,
    <span class="Li">$z</span>, returned from IO::Compress::Gzip can be used
    exactly like an IO::File filehandle. This means that all normal output file
    operations can be carried out with <span class="Li">$z</span>. For example,
    to write to a compressed file/buffer you can use either of these forms</p>
<p class="Pp"></p>
<pre>
    $z-&gt;print(&quot;hello world\n&quot;);
    print $z &quot;hello world\n&quot;;
</pre>
<p class="Pp">The mandatory parameter <span class="Li">$output</span> is used to
    control the destination of the compressed data. This parameter can take one
    of these forms.</p>
<dl class="Bl-tag">
  <dt id="A~7"><a class="permalink" href="#A~7">A filename</a></dt>
  <dd>If the <span class="Li">$output</span> parameter is a simple scalar, it is
      assumed to be a filename. This file will be opened for writing and the
      compressed data will be written to it.</dd>
  <dt id="A~8"><a class="permalink" href="#A~8">A filehandle</a></dt>
  <dd>If the <span class="Li">$output</span> parameter is a filehandle, the
      compressed data will be written to it. The string '-' can be used as an
      alias for standard output.</dd>
  <dt id="A~9"><a class="permalink" href="#A~9">A scalar reference</a></dt>
  <dd>If <span class="Li">$output</span> is a scalar reference, the compressed
      data will be stored in <span class="Li">$$output</span>.</dd>
</dl>
<p class="Pp">If the <span class="Li">$output</span> parameter is any other
    type, <span class="Li">&quot;IO::Compress::Gzip&quot;</span>::new will
    return undef.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Constructor_Options"><a class="permalink" href="#Constructor_Options">Constructor
  Options</a></h2>
<p class="Pp"><span class="Li">&quot;OPTS&quot;</span> is any combination of the
    following options:</p>
<dl class="Bl-tag">
  <dt>&quot;AutoClose =&gt; 0|1&quot;</dt>
  <dd>This option is only valid when the <span class="Li">$output</span>
      parameter is a filehandle. If specified, and the value is true, it will
      result in the <span class="Li">$output</span> being closed once either the
      <span class="Li">&quot;close&quot;</span> method is called or the
      <span class="Li">&quot;IO::Compress::Gzip&quot;</span> object is
      destroyed.
    <p class="Pp">This parameter defaults to 0.</p>
  </dd>
  <dt>&quot;Append =&gt; 0|1&quot;</dt>
  <dd>Opens <span class="Li">$output</span> in append mode.
    <p class="Pp">The behaviour of this option is dependent on the type of
        <span class="Li">$output</span>.</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>A Buffer
    <p class="Pp">If <span class="Li">$output</span> is a buffer and
        <span class="Li">&quot;Append&quot;</span> is enabled, all compressed
        data will be append to the end of <span class="Li">$output</span>.
        Otherwise <span class="Li">$output</span> will be cleared before any
        data is written to it.</p>
  </li>
  <li>A Filename
    <p class="Pp">If <span class="Li">$output</span> is a filename and
        <span class="Li">&quot;Append&quot;</span> is enabled, the file will be
        opened in append mode. Otherwise the contents of the file, if any, will
        be truncated before any compressed data is written to it.</p>
  </li>
  <li>A Filehandle
    <p class="Pp">If <span class="Li">$output</span> is a filehandle, the file
        pointer will be positioned to the end of the file via a call to
        <span class="Li">&quot;seek&quot;</span> before any compressed data is
        written to it. Otherwise the file pointer will not be moved.</p>
  </li>
</ul>
</div>
<div class="Bd-indent">
<p class="Pp">This parameter defaults to 0.</p>
</div>
<dl class="Bl-tag">
  <dt>&quot;Merge =&gt; 0|1&quot;</dt>
  <dd>This option is used to compress input data and append it to an existing
      compressed data stream in <span class="Li">$output</span>. The end result
      is a single compressed data stream stored in
      <span class="Li">$output</span>.
    <p class="Pp">It is a fatal error to attempt to use this option when
        <span class="Li">$output</span> is not an RFC 1952 data stream.</p>
    <p class="Pp">There are a number of other limitations with the
        <span class="Li">&quot;Merge&quot;</span> option:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>This module needs to have been built with zlib 1.2.1 or better to work. A
      fatal error will be thrown if <span class="Li">&quot;Merge&quot;</span> is
      used with an older version of zlib.</dd>
  <dt>2.</dt>
  <dd>If <span class="Li">$output</span> is a file or a filehandle, it must be
      seekable.</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">This parameter defaults to 0.</p>
</div>
<dl class="Bl-tag">
  <dt id="Level"><a class="permalink" href="#Level">-Level</a></dt>
  <dd>Defines the compression level used by zlib. The value should either be a
      number between 0 and 9 (0 means no compression and 9 is maximum
      compression), or one of the symbolic constants defined below.
    <p class="Pp"></p>
    <pre>
   Z_NO_COMPRESSION
   Z_BEST_SPEED
   Z_BEST_COMPRESSION
   Z_DEFAULT_COMPRESSION
    </pre>
    <p class="Pp">The default is Z_DEFAULT_COMPRESSION.</p>
    <p class="Pp">Note, these constants are not imported by
        <span class="Li">&quot;IO::Compress::Gzip&quot;</span> by default.</p>
    <p class="Pp"></p>
    <pre>
    use IO::Compress::Gzip qw(:strategy);
    use IO::Compress::Gzip qw(:constants);
    use IO::Compress::Gzip qw(:all);
    </pre>
  </dd>
  <dt id="Strategy"><a class="permalink" href="#Strategy">-Strategy</a></dt>
  <dd>Defines the strategy used to tune the compression. Use one of the symbolic
      constants defined below.
    <p class="Pp"></p>
    <pre>
   Z_FILTERED
   Z_HUFFMAN_ONLY
   Z_RLE
   Z_FIXED
   Z_DEFAULT_STRATEGY
    </pre>
    <p class="Pp">The default is Z_DEFAULT_STRATEGY.</p>
  </dd>
  <dt>&quot;Minimal =&gt; 0|1&quot;</dt>
  <dd>If specified, this option will force the creation of the smallest possible
      compliant gzip header (which is exactly 10 bytes long) as defined in RFC
      1952.
    <p class="Pp">See the section titled &quot;Compliance&quot; in RFC 1952 for
        a definition of the values used for the fields in the gzip header.</p>
    <p class="Pp">All other parameters that control the content of the gzip
        header will be ignored if this parameter is set to 1.</p>
    <p class="Pp">This parameter defaults to 0.</p>
  </dd>
  <dt>&quot;Comment =&gt; $comment&quot;</dt>
  <dd>Stores the contents of <span class="Li">$comment</span> in the COMMENT
      field in the gzip header. By default, no comment field is written to the
      gzip file.
    <p class="Pp">If the <span class="Li">&quot;-Strict&quot;</span> option is
        enabled, the comment can only consist of ISO 8859-1 characters plus line
        feed.</p>
    <p class="Pp">If the <span class="Li">&quot;-Strict&quot;</span> option is
        disabled, the comment field can contain any character except NULL. If
        any null characters are present, the field will be truncated at the
        first NULL.</p>
  </dd>
  <dt>&quot;Name =&gt; $string&quot;</dt>
  <dd>Stores the contents of <span class="Li">$string</span> in the gzip NAME
      header field. If <span class="Li">&quot;Name&quot;</span> is not
      specified, no gzip NAME field will be created.
    <p class="Pp">If the <span class="Li">&quot;-Strict&quot;</span> option is
        enabled, <span class="Li">$string</span> can only consist of ISO 8859-1
        characters.</p>
    <p class="Pp">If <span class="Li">&quot;-Strict&quot;</span> is disabled,
        then <span class="Li">$string</span> can contain any character except
        NULL. If any null characters are present, the field will be truncated at
        the first NULL.</p>
  </dd>
  <dt>&quot;Time =&gt; $number&quot;</dt>
  <dd>Sets the MTIME field in the gzip header to
      <span class="Li">$number</span>.
    <p class="Pp">This field defaults to the time the
        <span class="Li">&quot;IO::Compress::Gzip&quot;</span> object was
        created if this option is not specified.</p>
  </dd>
  <dt>&quot;TextFlag =&gt; 0|1&quot;</dt>
  <dd>This parameter controls the setting of the FLG.FTEXT bit in the gzip
      header. It is used to signal that the data stored in the gzip file/buffer
      is probably text.
    <p class="Pp">The default is 0.</p>
  </dd>
  <dt>&quot;HeaderCRC =&gt; 0|1&quot;</dt>
  <dd>When true this parameter will set the FLG.FHCRC bit to 1 in the gzip
      header and set the CRC16 header field to the CRC of the complete gzip
      header except the CRC16 field itself.
    <p class="Pp"><b>Note</b> that gzip files created with the
        <span class="Li">&quot;HeaderCRC&quot;</span> flag set to 1 cannot be
        read by most, if not all, of the standard gunzip utilities, most notably
        gzip version 1.2.4. You should therefore avoid using this option if you
        want to maximize the portability of your gzip files.</p>
    <p class="Pp">This parameter defaults to 0.</p>
  </dd>
  <dt>&quot;OS_Code =&gt; $value&quot;</dt>
  <dd>Stores <span class="Li">$value</span> in the gzip OS header field. A
      number between 0 and 255 is valid.
    <p class="Pp">If not specified, this parameter defaults to the OS code of
        the Operating System this module was built on. The value 3 is used as a
        catch-all for all Unix variants and unknown Operating Systems.</p>
  </dd>
  <dt>&quot;ExtraField =&gt; $data&quot;</dt>
  <dd>This parameter allows additional metadata to be stored in the ExtraField
      in the gzip header. An RFC 1952 compliant ExtraField consists of zero or
      more subfields. Each subfield consists of a two byte header followed by
      the subfield data.
    <p class="Pp">The list of subfields can be supplied in any of the following
        formats</p>
    <p class="Pp"></p>
    <pre>
    -ExtraField =&gt; [$id1, $data1,
                    $id2, $data2,
                     ...
                   ]
    -ExtraField =&gt; [ [$id1 =&gt; $data1],
                     [$id2 =&gt; $data2],
                     ...
                   ]
    -ExtraField =&gt; { $id1 =&gt; $data1,
                     $id2 =&gt; $data2,
                     ...
                   }
    </pre>
    <p class="Pp">Where <span class="Li">$id1</span>,
        <span class="Li">$id2</span> are two byte subfield ID's. The second byte
        of the ID cannot be 0, unless the
        <span class="Li">&quot;Strict&quot;</span> option has been disabled.</p>
    <p class="Pp">If you use the hash syntax, you have no control over the order
        in which the ExtraSubFields are stored, plus you cannot have SubFields
        with duplicate ID.</p>
    <p class="Pp">Alternatively the list of subfields can by supplied as a
        scalar, thus</p>
    <p class="Pp"></p>
    <pre>
    -ExtraField =&gt; $rawdata
    </pre>
    <p class="Pp">If you use the raw format, and the
        <span class="Li">&quot;Strict&quot;</span> option is enabled,
        <span class="Li">&quot;IO::Compress::Gzip&quot;</span> will check that
        <span class="Li">$rawdata</span> consists of zero or more conformant
        sub-fields. When <span class="Li">&quot;Strict&quot;</span> is disabled,
        <span class="Li">$rawdata</span> can consist of any arbitrary byte
        stream.</p>
    <p class="Pp">The maximum size of the Extra Field 65535 bytes.</p>
  </dd>
  <dt>&quot;ExtraFlags =&gt; $value&quot;</dt>
  <dd>Sets the XFL byte in the gzip header to <span class="Li">$value</span>.
    <p class="Pp">If this option is not present, the value stored in XFL field
        will be determined by the setting of the
        <span class="Li">&quot;Level&quot;</span> option.</p>
    <p class="Pp">If <span class="Li">&quot;Level =&gt;
        Z_BEST_SPEED&quot;</span> has been specified then XFL is set to 2. If
        <span class="Li">&quot;Level =&gt; Z_BEST_COMPRESSION&quot;</span> has
        been specified then XFL is set to 4. Otherwise XFL is set to 0.</p>
  </dd>
  <dt>&quot;Strict =&gt; 0|1&quot;</dt>
  <dd><span class="Li">&quot;Strict&quot;</span> will optionally police the
      values supplied with other options to ensure they are compliant with
      RFC1952.
    <p class="Pp">This option is enabled by default.</p>
    <p class="Pp">If <span class="Li">&quot;Strict&quot;</span> is enabled the
        following behaviour will be policed:</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>The value supplied with the <span class="Li">&quot;Name&quot;</span>
      option can only contain ISO 8859-1 characters.</li>
  <li>The value supplied with the <span class="Li">&quot;Comment&quot;</span>
      option can only contain ISO 8859-1 characters plus line-feed.</li>
  <li>The values supplied with the <span class="Li">&quot;-Name&quot;</span> and
      <span class="Li">&quot;-Comment&quot;</span> options cannot contain
      multiple embedded nulls.</li>
  <li>If an <span class="Li">&quot;ExtraField&quot;</span> option is specified
      and it is a simple scalar, it must conform to the sub-field structure as
      defined in RFC 1952.</li>
  <li>If an <span class="Li">&quot;ExtraField&quot;</span> option is specified
      the second byte of the ID will be checked in each subfield to ensure that
      it does not contain the reserved value 0x00.</li>
</ul>
</div>
<div class="Bd-indent">
<p class="Pp">When <span class="Li">&quot;Strict&quot;</span> is disabled the
    following behaviour will be policed:</p>
<ul class="Bl-bullet">
  <li>The value supplied with <span class="Li">&quot;-Name&quot;</span> option
      can contain any character except NULL.</li>
  <li>The value supplied with <span class="Li">&quot;-Comment&quot;</span>
      option can contain any character except NULL.</li>
  <li>The values supplied with the <span class="Li">&quot;-Name&quot;</span> and
      <span class="Li">&quot;-Comment&quot;</span> options can contain multiple
      embedded nulls. The string written to the gzip header will consist of the
      characters up to, but not including, the first embedded NULL.</li>
  <li>If an <span class="Li">&quot;ExtraField&quot;</span> option is specified
      and it is a simple scalar, the structure will not be checked. The only
      error is if the length is too big.</li>
  <li>The ID header in an <span class="Li">&quot;ExtraField&quot;</span>
      sub-field can consist of any two bytes.</li>
</ul>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Ss">
<h2 class="Ss" id="Examples~2"><a class="permalink" href="#Examples~2">Examples</a></h2>
<p class="Pp">TODO</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Methods"><a class="permalink" href="#Methods">Methods</a></h1>
<section class="Ss">
<h2 class="Ss" id="print"><a class="permalink" href="#print">print</a></h2>
<p class="Pp">Usage is</p>
<p class="Pp"></p>
<pre>
    $z-&gt;print($data)
    print $z $data
</pre>
<p class="Pp">Compresses and outputs the contents of the
    <span class="Li">$data</span> parameter. This has the same behaviour as the
    <span class="Li">&quot;print&quot;</span> built-in.</p>
<p class="Pp">Returns true if successful.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="printf"><a class="permalink" href="#printf">printf</a></h2>
<p class="Pp">Usage is</p>
<p class="Pp"></p>
<pre>
    $z-&gt;printf($format, $data)
    printf $z $format, $data
</pre>
<p class="Pp">Compresses and outputs the contents of the
    <span class="Li">$data</span> parameter.</p>
<p class="Pp">Returns true if successful.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="syswrite"><a class="permalink" href="#syswrite">syswrite</a></h2>
<p class="Pp">Usage is</p>
<p class="Pp"></p>
<pre>
    $z-&gt;syswrite $data
    $z-&gt;syswrite $data, $length
    $z-&gt;syswrite $data, $length, $offset
</pre>
<p class="Pp">Compresses and outputs the contents of the
    <span class="Li">$data</span> parameter.</p>
<p class="Pp">Returns the number of uncompressed bytes written, or
    <span class="Li">&quot;undef&quot;</span> if unsuccessful.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="write"><a class="permalink" href="#write">write</a></h2>
<p class="Pp">Usage is</p>
<p class="Pp"></p>
<pre>
    $z-&gt;write $data
    $z-&gt;write $data, $length
    $z-&gt;write $data, $length, $offset
</pre>
<p class="Pp">Compresses and outputs the contents of the
    <span class="Li">$data</span> parameter.</p>
<p class="Pp">Returns the number of uncompressed bytes written, or
    <span class="Li">&quot;undef&quot;</span> if unsuccessful.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="flush"><a class="permalink" href="#flush">flush</a></h2>
<p class="Pp">Usage is</p>
<p class="Pp"></p>
<pre>
    $z-&gt;flush;
    $z-&gt;flush($flush_type);
</pre>
<p class="Pp">Flushes any pending compressed data to the output file/buffer.</p>
<p class="Pp">This method takes an optional parameter,
    <span class="Li">$flush_type</span>, that controls how the flushing will be
    carried out. By default the <span class="Li">$flush_type</span> used is
    <span class="Li">&quot;Z_FINISH&quot;</span>. Other valid values for
    <span class="Li">$flush_type</span> are
    <span class="Li">&quot;Z_NO_FLUSH&quot;</span>,
    <span class="Li">&quot;Z_SYNC_FLUSH&quot;</span>,
    <span class="Li">&quot;Z_FULL_FLUSH&quot;</span> and
    <span class="Li">&quot;Z_BLOCK&quot;</span>. It is strongly recommended that
    you only set the <span class="Li">&quot;flush_type&quot;</span> parameter if
    you fully understand the implications of what it does - overuse of
    <span class="Li">&quot;flush&quot;</span> can seriously degrade the level of
    compression achieved. See the <span class="Li">&quot;zlib&quot;</span>
    documentation for details.</p>
<p class="Pp">Returns true on success.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="tell"><a class="permalink" href="#tell">tell</a></h2>
<p class="Pp">Usage is</p>
<p class="Pp"></p>
<pre>
    $z-&gt;tell()
    tell $z
</pre>
<p class="Pp">Returns the uncompressed file offset.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="eof"><a class="permalink" href="#eof">eof</a></h2>
<p class="Pp">Usage is</p>
<p class="Pp"></p>
<pre>
    $z-&gt;eof();
    eof($z);
</pre>
<p class="Pp">Returns true if the <span class="Li">&quot;close&quot;</span>
    method has been called.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="seek"><a class="permalink" href="#seek">seek</a></h2>
<pre>
    $z-&gt;seek($position, $whence);
    seek($z, $position, $whence);
</pre>
<p class="Pp">Provides a sub-set of the <span class="Li">&quot;seek&quot;</span>
    functionality, with the restriction that it is only legal to seek forward in
    the output file/buffer. It is a fatal error to attempt to seek backward.</p>
<p class="Pp">Empty parts of the file/buffer will have NULL (0x00) bytes written
    to them.</p>
<p class="Pp">The <span class="Li">$whence</span> parameter takes one the usual
    values, namely SEEK_SET, SEEK_CUR or SEEK_END.</p>
<p class="Pp">Returns 1 on success, 0 on failure.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="binmode"><a class="permalink" href="#binmode">binmode</a></h2>
<p class="Pp">Usage is</p>
<p class="Pp"></p>
<pre>
    $z-&gt;binmode
    binmode $z ;
</pre>
<p class="Pp">This is a noop provided for completeness.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="opened"><a class="permalink" href="#opened">opened</a></h2>
<pre>
    $z-&gt;opened()
</pre>
<p class="Pp">Returns true if the object currently refers to a opened
    file/buffer.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="autoflush"><a class="permalink" href="#autoflush">autoflush</a></h2>
<pre>
    my $prev = $z-&gt;autoflush()
    my $prev = $z-&gt;autoflush(EXPR)
</pre>
<p class="Pp">If the <span class="Li">$z</span> object is associated with a file
    or a filehandle, this method returns the current autoflush setting for the
    underlying filehandle. If <span class="Li">&quot;EXPR&quot;</span> is
    present, and is non-zero, it will enable flushing after every write/print
    operation.</p>
<p class="Pp">If <span class="Li">$z</span> is associated with a buffer, this
    method has no effect and always returns
    <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp"><b>Note</b> that the special variable <span class="Li">$|</span>
    <b>cannot</b> be used to set or retrieve the autoflush setting.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="input_line_number"><a class="permalink" href="#input_line_number">input_line_number</a></h2>
<pre>
    $z-&gt;input_line_number()
    $z-&gt;input_line_number(EXPR)
</pre>
<p class="Pp">This method always returns
    <span class="Li">&quot;undef&quot;</span> when compressing.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="fileno"><a class="permalink" href="#fileno">fileno</a></h2>
<pre>
    $z-&gt;fileno()
    fileno($z)
</pre>
<p class="Pp">If the <span class="Li">$z</span> object is associated with a file
    or a filehandle, <span class="Li">&quot;fileno&quot;</span> will return the
    underlying file descriptor. Once the
    <span class="Li">&quot;close&quot;</span> method is called
    <span class="Li">&quot;fileno&quot;</span> will return
    <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp">If the <span class="Li">$z</span> object is associated with a
    buffer, this method will return
  <span class="Li">&quot;undef&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="close"><a class="permalink" href="#close">close</a></h2>
<pre>
    $z-&gt;close() ;
    close $z ;
</pre>
<p class="Pp">Flushes any pending compressed data and then closes the output
    file/buffer.</p>
<p class="Pp">For most versions of Perl this method will be automatically
    invoked if the IO::Compress::Gzip object is destroyed (either explicitly or
    by the variable with the reference to the object going out of scope). The
    exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In these
    cases, the <span class="Li">&quot;close&quot;</span> method will be called
    automatically, but not until global destruction of all live objects when the
    program is terminating.</p>
<p class="Pp">Therefore, if you want your scripts to be able to run on all
    versions of Perl, you should call <span class="Li">&quot;close&quot;</span>
    explicitly and not rely on automatic closing.</p>
<p class="Pp">Returns true on success, otherwise 0.</p>
<p class="Pp">If the <span class="Li">&quot;AutoClose&quot;</span> option has
    been enabled when the IO::Compress::Gzip object was created, and the object
    is associated with a file, the underlying file will also be closed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="newStream(_"><a class="permalink" href="#newStream(_">newStream([OPTS])</a></h2>
<p class="Pp">Usage is</p>
<p class="Pp"></p>
<pre>
    $z-&gt;newStream( [OPTS] )
</pre>
<p class="Pp">Closes the current compressed data stream and starts a new
  one.</p>
<p class="Pp">OPTS consists of any of the options that are available when
    creating the <span class="Li">$z</span> object.</p>
<p class="Pp">See the &quot;Constructor Options&quot; section for more
  details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="deflateParams"><a class="permalink" href="#deflateParams">deflateParams</a></h2>
<p class="Pp">Usage is</p>
<p class="Pp"></p>
<pre>
    $z-&gt;deflateParams
</pre>
<p class="Pp">TODO</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Importing"><a class="permalink" href="#Importing">Importing</a></h1>
<p class="Pp">A number of symbolic constants are required by some methods in
    <span class="Li">&quot;IO::Compress::Gzip&quot;</span>. None are imported by
    default.</p>
<dl class="Bl-tag">
  <dt>:all</dt>
  <dd>Imports <span class="Li">&quot;gzip&quot;</span>,
      <span class="Li">$GzipError</span> and all symbolic constants that can be
      used by <span class="Li">&quot;IO::Compress::Gzip&quot;</span>. Same as
      doing this
    <p class="Pp"></p>
    <pre>
    use IO::Compress::Gzip qw(gzip $GzipError :constants) ;
    </pre>
  </dd>
  <dt>:constants</dt>
  <dd>Import all symbolic constants. Same as doing this
    <p class="Pp"></p>
    <pre>
    use IO::Compress::Gzip qw(:flush :level :strategy) ;
    </pre>
  </dd>
  <dt>:flush</dt>
  <dd>These symbolic constants are used by the
      <span class="Li">&quot;flush&quot;</span> method.
    <p class="Pp"></p>
    <pre>
    Z_NO_FLUSH
    Z_PARTIAL_FLUSH
    Z_SYNC_FLUSH
    Z_FULL_FLUSH
    Z_FINISH
    Z_BLOCK
    </pre>
  </dd>
  <dt>:level</dt>
  <dd>These symbolic constants are used by the
      <span class="Li">&quot;Level&quot;</span> option in the constructor.
    <p class="Pp"></p>
    <pre>
    Z_NO_COMPRESSION
    Z_BEST_SPEED
    Z_BEST_COMPRESSION
    Z_DEFAULT_COMPRESSION
    </pre>
  </dd>
  <dt>:strategy</dt>
  <dd>These symbolic constants are used by the
      <span class="Li">&quot;Strategy&quot;</span> option in the constructor.
    <p class="Pp"></p>
    <pre>
    Z_FILTERED
    Z_HUFFMAN_ONLY
    Z_RLE
    Z_FIXED
    Z_DEFAULT_STRATEGY
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Apache::GZip_Revisited"><a class="permalink" href="#Apache::GZip_Revisited">Apache::GZip
  Revisited</a></h2>
<p class="Pp">See IO::Compress::FAQ</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Working_with_Net::FTP"><a class="permalink" href="#Working_with_Net::FTP">Working
  with Net::FTP</a></h2>
<p class="Pp">See IO::Compress::FAQ</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Compress::Zlib, IO::Uncompress::Gunzip, IO::Compress::Deflate,
    IO::Uncompress::Inflate, IO::Compress::RawDeflate,
    IO::Uncompress::RawInflate, IO::Compress::Bzip2, IO::Uncompress::Bunzip2,
    IO::Compress::Lzma, IO::Uncompress::UnLzma, IO::Compress::Xz,
    IO::Uncompress::UnXz, IO::Compress::Lzip, IO::Uncompress::UnLzip,
    IO::Compress::Lzop, IO::Uncompress::UnLzop, IO::Compress::Lzf,
    IO::Uncompress::UnLzf, IO::Compress::Zstd, IO::Uncompress::UnZstd,
    IO::Uncompress::AnyInflate, IO::Uncompress::AnyUncompress</p>
<p class="Pp">IO::Compress::FAQ</p>
<p class="Pp">File::GlobMapper, Archive::Zip, Archive::Tar, IO::Zlib</p>
<p class="Pp">For RFC 1950, 1951 and 1952 see
    &lt;http://www.faqs.org/rfcs/rfc1950.html&gt;,
    &lt;http://www.faqs.org/rfcs/rfc1951.html&gt; and
    &lt;http://www.faqs.org/rfcs/rfc1952.html&gt;</p>
<p class="Pp">The <i>zlib</i> compression library was written by Jean-loup
    Gailly <span class="Li">&quot;gzip@prep.ai.mit.edu&quot;</span> and Mark
    Adler <span class="Li">&quot;madler@alumni.caltech.edu&quot;</span>.</p>
<p class="Pp">The primary site for the <i>zlib</i> compression library is
    &lt;http://www.zlib.org&gt;.</p>
<p class="Pp">The primary site for gzip is &lt;http://www.gzip.org&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">This module was written by Paul Marquess,
    <span class="Li">&quot;pmqs@cpan.org&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MODIFICATION_HISTORY"><a class="permalink" href="#MODIFICATION_HISTORY">MODIFICATION
  HISTORY</a></h1>
<p class="Pp">See the Changes file.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">Copyright (c) 2005-2019 Paul Marquess. All rights reserved.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

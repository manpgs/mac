<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>LWP::UserAgent(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">LWP::UserAgent(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">LWP::UserAgent(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">LWP::UserAgent - Web user agent class</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
 require LWP::UserAgent;
 
 my $ua = LWP::UserAgent-&gt;new;
 $ua-&gt;timeout(10);
 $ua-&gt;env_proxy;
 
 my $response = $ua-&gt;get('http://search.cpan.org/');
 
 if ($response-&gt;is_success) {
     print $response-&gt;decoded_content;  # or whatever
 }
 else {
     die $response-&gt;status_line;
 }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The <span class="Li">&quot;LWP::UserAgent&quot;</span> is a class
    implementing a web user agent.
    <span class="Li">&quot;LWP::UserAgent&quot;</span> objects can be used to
    dispatch web requests.</p>
<p class="Pp">In normal use the application creates an
    <span class="Li">&quot;LWP::UserAgent&quot;</span> object, and then
    configures it with values for timeouts, proxies, name, etc. It then creates
    an instance of <span class="Li">&quot;HTTP::Request&quot;</span> for the
    request that needs to be performed. This request is then passed to one of
    the request method the UserAgent, which dispatches it using the relevant
    protocol, and returns a <span class="Li">&quot;HTTP::Response&quot;</span>
    object. There are convenience methods for sending the most common request
    types: <i>get()</i>, <i>head()</i>, <i>post()</i>, <i>put()</i> and
    <i>delete()</i>. When using these methods then the creation of the request
    object is hidden as shown in the synopsis above.</p>
<p class="Pp">The basic approach of the library is to use HTTP style
    communication for all protocol schemes. This means that you will construct
    <span class="Li">&quot;HTTP::Request&quot;</span> objects and receive
    <span class="Li">&quot;HTTP::Response&quot;</span> objects even for non-HTTP
    resources like <i>gopher</i> and <i>ftp</i>. In order to achieve even more
    similarity to HTTP style communications, gopher menus and file directories
    are converted to HTML documents.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONSTRUCTOR_METHODS"><a class="permalink" href="#CONSTRUCTOR_METHODS">CONSTRUCTOR
  METHODS</a></h1>
<p class="Pp">The following constructor methods are available:</p>
<dl class="Bl-tag">
  <dt>$ua = LWP::UserAgent-&gt;new( %options )</dt>
  <dd>This method constructs a new
      <span class="Li">&quot;LWP::UserAgent&quot;</span> object and returns it.
      Key/value pair arguments may be provided to set up the initial state. The
      following options correspond to attribute methods described below:
    <p class="Pp"></p>
    <pre>
   KEY                     DEFAULT
   -----------             --------------------
   agent                   &quot;libwww-perl/#.###&quot;
   from                    undef
   conn_cache              undef
   cookie_jar              undef
   default_headers         HTTP::Headers-&gt;new
   local_address           undef
   ssl_opts                { verify_hostname =&gt; 1 }
   max_size                undef
   max_redirect            7
   parse_head              1
   protocols_allowed       undef
   protocols_forbidden     undef
   requests_redirectable   ['GET', 'HEAD']
   timeout                 180
    </pre>
    <p class="Pp">The following additional options are also accepted: If the
        <span class="Li">&quot;env_proxy&quot;</span> option is passed in with a
        TRUE value, then proxy settings are read from environment variables (see
        <i>env_proxy()</i> method below). If
        <span class="Li">&quot;env_proxy&quot;</span> isn't provided the
        <span class="Li">&quot;PERL_LWP_ENV_PROXY&quot;</span> environment
        variable controls if <i>env_proxy()</i> is called during initialization.
        If the <span class="Li">&quot;keep_alive&quot;</span> option is passed
        in, then a <span class="Li">&quot;LWP::ConnCache&quot;</span> is set up
        (see <i>conn_cache()</i> method below). The
        <span class="Li">&quot;keep_alive&quot;</span> value is passed on as the
        <span class="Li">&quot;total_capacity&quot;</span> for the connection
        cache.</p>
  </dd>
  <dt>$ua-&gt;clone</dt>
  <dd>Returns a copy of the LWP::UserAgent object.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="ATTRIBUTES"><a class="permalink" href="#ATTRIBUTES">ATTRIBUTES</a></h1>
<p class="Pp">The settings of the configuration attributes modify the behaviour
    of the <span class="Li">&quot;LWP::UserAgent&quot;</span> when it dispatches
    requests. Most of these can also be initialized by options passed to the
    constructor method.</p>
<p class="Pp">The following attribute methods are provided. The attribute value
    is left unchanged if no argument is given. The return value from each method
    is the old attribute value.</p>
<dl class="Bl-tag">
  <dt>$ua-&gt;agent</dt>
  <dd></dd>
  <dt>$ua-&gt;agent( $product_id )</dt>
  <dd>Get/set the product token that is used to identify the user agent on the
      network. The agent value is sent as the &quot;User-Agent&quot; header in
      the requests. The default is the string returned by the <i>_agent()</i>
      method (see below).
    <p class="Pp">If the <span class="Li">$product_id</span> ends with space
        then the <i>_agent()</i> string is appended to it.</p>
    <p class="Pp">The user agent string should be one or more simple product
        identifiers with an optional version number separated by the
        &quot;/&quot; character. Examples are:</p>
    <p class="Pp"></p>
    <pre>
  $ua-&gt;agent('Checkbot/0.4 ' . $ua-&gt;_agent);
  $ua-&gt;agent('Checkbot/0.4 ');    # same as above
  $ua-&gt;agent('Mozilla/5.0');
  $ua-&gt;agent(&quot;&quot;);                 # don't identify
    </pre>
  </dd>
  <dt>$ua-&gt;_agent</dt>
  <dd>Returns the default agent identifier. This is a string of the form
      &quot;libwww-perl/#.###&quot;, where &quot;#.###&quot; is substituted with
      the version number of this library.</dd>
  <dt>$ua-&gt;from</dt>
  <dd></dd>
  <dt>$ua-&gt;from( $email_address )</dt>
  <dd>Get/set the e-mail address for the human user who controls the requesting
      user agent. The address should be machine-usable, as defined in RFC 822.
      The <span class="Li">&quot;from&quot;</span> value is send as the
      &quot;From&quot; header in the requests. Example:
    <p class="Pp"></p>
    <pre>
  $ua-&gt;from('gaas@cpan.org');
    </pre>
    <p class="Pp">The default is to not send a &quot;From&quot; header. See the
        <i>default_headers()</i> method for the more general interface that
        allow any header to be defaulted.</p>
  </dd>
  <dt>$ua-&gt;cookie_jar</dt>
  <dd></dd>
  <dt>$ua-&gt;cookie_jar( $cookie_jar_obj )</dt>
  <dd>Get/set the cookie jar object to use. The only requirement is that the
      cookie jar object must implement the extract_cookies($request) and
      add_cookie_header($response) methods. These methods will then be invoked
      by the user agent as requests are sent and responses are received.
      Normally this will be a <span class="Li">&quot;HTTP::Cookies&quot;</span>
      object or some subclass.
    <p class="Pp">The default is to have no cookie_jar, i.e. never automatically
        add &quot;Cookie&quot; headers to the requests.</p>
    <p class="Pp">Shortcut: If a reference to a plain hash is passed in as the
        <span class="Li">$cookie_jar_object</span>, then it is replaced with an
        instance of <span class="Li">&quot;HTTP::Cookies&quot;</span> that is
        initialized based on the hash. This form also automatically loads the
        <span class="Li">&quot;HTTP::Cookies&quot;</span> module. It means
      that:</p>
    <p class="Pp"></p>
    <pre>
  $ua-&gt;cookie_jar({ file =&gt; &quot;$ENV{HOME}/.cookies.txt&quot; });
    </pre>
    <p class="Pp">is really just a shortcut for:</p>
    <p class="Pp"></p>
    <pre>
  require HTTP::Cookies;
  $ua-&gt;cookie_jar(HTTP::Cookies-&gt;new(file =&gt; &quot;$ENV{HOME}/.cookies.txt&quot;));
    </pre>
  </dd>
  <dt>$ua-&gt;default_headers</dt>
  <dd></dd>
  <dt>$ua-&gt;default_headers( $headers_obj )</dt>
  <dd>Get/set the headers object that will provide default header values for any
      requests sent. By default this will be an empty
      <span class="Li">&quot;HTTP::Headers&quot;</span> object.</dd>
  <dt>$ua-&gt;default_header( $field )</dt>
  <dd></dd>
  <dt>$ua-&gt;default_header( $field =&gt; $value )</dt>
  <dd>This is just a short-cut for
      <span class="Li">$ua</span>-&gt;default_headers-&gt;header(
      <span class="Li">$field</span> =&gt; <span class="Li">$value</span> ).
      Example:
    <p class="Pp"></p>
    <pre>
  $ua-&gt;default_header('Accept-Encoding' =&gt; scalar HTTP::Message::decodable());
  $ua-&gt;default_header('Accept-Language' =&gt; &quot;no, en&quot;);
    </pre>
  </dd>
  <dt>$ua-&gt;conn_cache</dt>
  <dd></dd>
  <dt>$ua-&gt;conn_cache( $cache_obj )</dt>
  <dd>Get/set the <span class="Li">&quot;LWP::ConnCache&quot;</span> object to
      use. See LWP::ConnCache for details.</dd>
  <dt>$ua-&gt;credentials( $netloc, $realm )</dt>
  <dd></dd>
  <dt>$ua-&gt;credentials( $netloc, $realm, $uname, $pass )</dt>
  <dd>Get/set the user name and password to be used for a realm.
    <p class="Pp">The <span class="Li">$netloc</span> is a string of the form
        &quot;&lt;host&gt;:&lt;port&gt;&quot;. The username and password will
        only be passed to this server. Example:</p>
    <p class="Pp"></p>
    <pre>
  $ua-&gt;credentials(&quot;www.example.com:80&quot;, &quot;Some Realm&quot;, &quot;foo&quot;, &quot;secret&quot;);
    </pre>
  </dd>
  <dt>$ua-&gt;local_address</dt>
  <dd></dd>
  <dt>$ua-&gt;local_address( $address )</dt>
  <dd>Get/set the local interface to bind to for network connections. The
      interface can be specified as a hostname or an IP address. This value is
      passed as the <span class="Li">&quot;LocalAddr&quot;</span> argument to
      IO::Socket::INET.</dd>
  <dt>$ua-&gt;max_size</dt>
  <dd></dd>
  <dt>$ua-&gt;max_size( $bytes )</dt>
  <dd>Get/set the size limit for response content. The default is
      <span class="Li">&quot;undef&quot;</span>, which means that there is no
      limit. If the returned response content is only partial, because the size
      limit was exceeded, then a &quot;Client-Aborted&quot; header will be added
      to the response. The content might end up longer than
      <span class="Li">&quot;max_size&quot;</span> as we abort once appending a
      chunk of data makes the length exceed the limit. The
      &quot;Content-Length&quot; header, if present, will indicate the length of
      the full content and will normally not be the same as
      <span class="Li">&quot;length($res-&gt;content)&quot;</span>.</dd>
  <dt>$ua-&gt;max_redirect</dt>
  <dd></dd>
  <dt>$ua-&gt;max_redirect( $n )</dt>
  <dd>This reads or sets the object's limit of how many times it will obey
      redirection responses in a given request cycle.
    <p class="Pp">By default, the value is 7. This means that if you call
        <i>request()</i> method and the response is a redirect elsewhere which
        is in turn a redirect, and so on seven times, then LWP gives up after
        that seventh request.</p>
  </dd>
  <dt>$ua-&gt;parse_head</dt>
  <dd></dd>
  <dt>$ua-&gt;parse_head( $boolean )</dt>
  <dd>Get/set a value indicating whether we should initialize response headers
      from the &lt;head&gt; section of HTML documents. The default is TRUE. Do
      not turn this off, unless you know what you are doing.</dd>
  <dt>$ua-&gt;protocols_allowed</dt>
  <dd></dd>
  <dt>$ua-&gt;protocols_allowed( \@protocols )</dt>
  <dd>This reads (or sets) this user agent's list of protocols that the request
      methods will exclusively allow. The protocol names are case insensitive.
    <p class="Pp">For example: <span class="Li">&quot;$ua-&gt;protocols_allowed(
        [ 'http', 'https'] );&quot;</span> means that this user agent will
        <i>allow only</i> those protocols, and attempts to use this user agent
        to access URLs with any other schemes (like &quot;ftp://...&quot;) will
        result in a 500 error.</p>
    <p class="Pp">To delete the list, call:
        <span class="Li">&quot;$ua-&gt;protocols_allowed(undef)&quot;</span></p>
    <p class="Pp">By default, an object has neither a
        <span class="Li">&quot;protocols_allowed&quot;</span> list, nor a
        <span class="Li">&quot;protocols_forbidden&quot;</span> list.</p>
    <p class="Pp">Note that having a
        <span class="Li">&quot;protocols_allowed&quot;</span> list causes any
        <span class="Li">&quot;protocols_forbidden&quot;</span> list to be
        ignored.</p>
  </dd>
  <dt>$ua-&gt;protocols_forbidden</dt>
  <dd></dd>
  <dt>$ua-&gt;protocols_forbidden( \@protocols )</dt>
  <dd>This reads (or sets) this user agent's list of protocols that the request
      method will <i>not</i> allow. The protocol names are case insensitive.
    <p class="Pp">For example:
        <span class="Li">&quot;$ua-&gt;protocols_forbidden( [ 'file', 'mailto']
        );&quot;</span> means that this user agent will <i>not</i> allow those
        protocols, and attempts to use this user agent to access URLs with those
        schemes will result in a 500 error.</p>
    <p class="Pp">To delete the list, call:
        <span class="Li">&quot;$ua-&gt;protocols_forbidden(undef)&quot;</span></p>
  </dd>
  <dt>$ua-&gt;requests_redirectable</dt>
  <dd></dd>
  <dt>$ua-&gt;requests_redirectable( \@requests )</dt>
  <dd>This reads or sets the object's list of request names that
      <span class="Li">&quot;$ua-&gt;redirect_ok(...)&quot;</span> will allow
      redirection for. By default, this is <span class="Li">&quot;['GET',
      'HEAD']&quot;</span>, as per RFC 2616. To change to include 'POST',
      consider:
    <p class="Pp"></p>
    <pre>
   push @{ $ua-&gt;requests_redirectable }, 'POST';
    </pre>
  </dd>
  <dt>$ua-&gt;show_progress</dt>
  <dd></dd>
  <dt>$ua-&gt;show_progress( $boolean )</dt>
  <dd>Get/set a value indicating whether a progress bar should be displayed on
      on the terminal as requests are processed. The default is FALSE.</dd>
  <dt>$ua-&gt;timeout</dt>
  <dd></dd>
  <dt>$ua-&gt;timeout( $secs )</dt>
  <dd>Get/set the timeout value in seconds. The default <i>timeout()</i> value
      is 180 seconds, i.e. 3 minutes.
    <p class="Pp">The requests is aborted if no activity on the connection to
        the server is observed for <span class="Li">&quot;timeout&quot;</span>
        seconds. This means that the time it takes for the complete transaction
        and the <i>request()</i> method to actually return might be longer.</p>
  </dd>
  <dt>$ua-&gt;ssl_opts</dt>
  <dd></dd>
  <dt>$ua-&gt;ssl_opts( $key )</dt>
  <dd></dd>
  <dt>$ua-&gt;ssl_opts( $key =&gt; $value )</dt>
  <dd>Get/set the options for SSL connections. Without argument return the list
      of options keys currently set. With a single argument return the current
      value for the given option. With 2 arguments set the option value and
      return the old. Setting an option to the value
      <span class="Li">&quot;undef&quot;</span> removes this option.
    <p class="Pp">The options that LWP relates to are:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>&quot;verify_hostname&quot; =&gt; $bool</dt>
  <dd>When TRUE LWP will for secure protocol schemes ensure it connects to
      servers that have a valid certificate matching the expected hostname. If
      FALSE no checks are made and you can't be sure that you communicate with
      the expected peer. The no checks behaviour was the default for
      libwww-perl-5.837 and earlier releases.
    <p class="Pp">This option is initialized from the
        PERL_LWP_SSL_VERIFY_HOSTNAME environment variable. If this environment
        variable isn't set; then
        <span class="Li">&quot;verify_hostname&quot;</span> defaults to 1.</p>
  </dd>
  <dt>&quot;SSL_ca_file&quot; =&gt; $path</dt>
  <dd>The path to a file containing Certificate Authority certificates. A
      default setting for this option is provided by checking the environment
      variables <span class="Li">&quot;PERL_LWP_SSL_CA_FILE&quot;</span> and
      <span class="Li">&quot;HTTPS_CA_FILE&quot;</span> in order.</dd>
  <dt>&quot;SSL_ca_path&quot; =&gt; $path</dt>
  <dd>The path to a directory containing files containing Certificate Authority
      certificates. A default setting for this option is provided by checking
      the environment variables
      <span class="Li">&quot;PERL_LWP_SSL_CA_PATH&quot;</span> and
      <span class="Li">&quot;HTTPS_CA_DIR&quot;</span> in order.</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">Other options can be set and are processed directly by the SSL
    Socket implementation in use. See IO::Socket::SSL or Net::SSL for
  details.</p>
<p class="Pp">The libwww-perl core no longer bundles protocol plugins for SSL.
    You will need to install LWP::Protocol::https separately to enable support
    for processing https-URLs.</p>
</div>
<section class="Ss">
<h2 class="Ss" id="Proxy_attributes"><a class="permalink" href="#Proxy_attributes">Proxy
  attributes</a></h2>
<p class="Pp">The following methods set up when requests should be passed via a
    proxy server.</p>
<dl class="Bl-tag">
  <dt>$ua-&gt;proxy(\@schemes, $proxy_url)</dt>
  <dd></dd>
  <dt>$ua-&gt;proxy($scheme, $proxy_url)</dt>
  <dd>Set/retrieve proxy URL for a scheme:
    <p class="Pp"></p>
    <pre>
 $ua-&gt;proxy(['http', 'ftp'], 'http://proxy.sn.no:8001/');
 $ua-&gt;proxy('gopher', 'http://proxy.sn.no:8001/');
    </pre>
    <p class="Pp">The first form specifies that the URL is to be used for
        proxying of access methods listed in the list in the first method
        argument, i.e. 'http' and 'ftp'.</p>
    <p class="Pp">The second form shows a shorthand form for specifying proxy
        URL for a single access scheme.</p>
  </dd>
  <dt>$ua-&gt;no_proxy( $domain, ... )</dt>
  <dd>Do not proxy requests to the given domains. Calling no_proxy without any
      domains clears the list of domains. Eg:
    <p class="Pp"></p>
    <pre>
 $ua-&gt;no_proxy('localhost', 'example.com');
    </pre>
  </dd>
  <dt>$ua-&gt;env_proxy</dt>
  <dd>Load proxy settings from *_proxy environment variables. You might specify
      proxies like this (sh-syntax):
    <p class="Pp"></p>
    <pre>
  gopher_proxy=http://proxy.my.place/
  wais_proxy=http://proxy.my.place/
  no_proxy=&quot;localhost,example.com&quot;
  export gopher_proxy wais_proxy no_proxy
    </pre>
    <p class="Pp">csh or tcsh users should use the
        <span class="Li">&quot;setenv&quot;</span> command to define these
        environment variables.</p>
    <p class="Pp">On systems with case insensitive environment variables there
        exists a name clash between the CGI environment variables and the
        <span class="Li">&quot;HTTP_PROXY&quot;</span> environment variable
        normally picked up by <i>env_proxy()</i>. Because of this
        <span class="Li">&quot;HTTP_PROXY&quot;</span> is not honored for CGI
        scripts. The <span class="Li">&quot;CGI_HTTP_PROXY&quot;</span>
        environment variable can be used instead.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Handlers"><a class="permalink" href="#Handlers">Handlers</a></h2>
<p class="Pp">Handlers are code that injected at various phases during the
    processing of requests. The following methods are provided to manage the
    active handlers:</p>
<dl class="Bl-tag">
  <dt>$ua-&gt;add_handler( $phase =&gt; \&amp;cb, %matchspec )</dt>
  <dd>Add handler to be invoked in the given processing phase. For how to
      specify <span class="Li">%matchspec</span> see &quot;Matching&quot; in
      HTTP::Config.
    <p class="Pp">The possible values <span class="Li">$phase</span> and the
        corresponding callback signatures are:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="request_preprepare"><a class="permalink" href="#request_preprepare">request_preprepare
    =&gt; sub { my($request, $ua, $h) = @_; ... }</a></dt>
  <dd>The handler is called before the
      <span class="Li">&quot;request_prepare&quot;</span> and other standard
      initialization of of the request. This can be used to set up headers and
      attributes that the <span class="Li">&quot;request_prepare&quot;</span>
      handler depends on. Proxy initialization should take place here; but in
      general don't register handlers for this phase.</dd>
  <dt id="request_prepare"><a class="permalink" href="#request_prepare">request_prepare
    =&gt; sub { my($request, $ua, $h) = @_; ... }</a></dt>
  <dd>The handler is called before the request is sent and can modify the
      request any way it see fit. This can for instance be used to add certain
      headers to specific requests.
    <p class="Pp">The method can assign a new request object to
        <span class="Li">$_</span>[0] to replace the request that is sent
      fully.</p>
    <p class="Pp">The return value from the callback is ignored. If an exception
        is raised it will abort the request and make the request method return a
        &quot;400 Bad request&quot; response.</p>
  </dd>
  <dt id="request_send"><a class="permalink" href="#request_send">request_send
    =&gt; sub { my($request, $ua, $h) = @_; ... }</a></dt>
  <dd>This handler gets a chance of handling requests before they're sent to the
      protocol handlers. It should return an HTTP::Response object if it wishes
      to terminate the processing; otherwise it should return nothing.
    <p class="Pp">The <span class="Li">&quot;response_header&quot;</span> and
        <span class="Li">&quot;response_data&quot;</span> handlers will not be
        invoked for this response, but the
        <span class="Li">&quot;response_done&quot;</span> will be.</p>
  </dd>
  <dt id="response_header"><a class="permalink" href="#response_header">response_header
    =&gt; sub { my($response, $ua, $h) = @_; ... }</a></dt>
  <dd>This handler is called right after the response headers have been
      received, but before any content data. The handler might set up handlers
      for data and might croak to abort the request.
    <p class="Pp">The handler might set the
        <span class="Li">$response</span>-&gt;{default_add_content} value to
        control if any received data should be added to the response object
        directly. This will initially be false if the
        <span class="Li">$ua</span>-&gt;<i>request()</i> method was called with
        a <span class="Li">$content_file</span> or
        <span class="Li">$content_cb</span> argument; otherwise true.</p>
  </dd>
  <dt id="response_data"><a class="permalink" href="#response_data">response_data
    =&gt; sub { my($response, $ua, $h, $data) = @_; ... }</a></dt>
  <dd>This handler is called for each chunk of data received for the response.
      The handler might croak to abort the request.
    <p class="Pp">This handler needs to return a TRUE value to be called again
        for subsequent chunks for the same request.</p>
  </dd>
  <dt id="response_done"><a class="permalink" href="#response_done">response_done
    =&gt; sub { my($response, $ua, $h) = @_; ... }</a></dt>
  <dd>The handler is called after the response has been fully received, but
      before any redirect handling is attempted. The handler can be used to
      extract information or modify the response.</dd>
  <dt id="response_redirect"><a class="permalink" href="#response_redirect">response_redirect
    =&gt; sub { my($response, $ua, $h) = @_; ... }</a></dt>
  <dd>The handler is called in <span class="Li">$ua</span>-&gt;request after
      <span class="Li">&quot;response_done&quot;</span>. If the handler returns
      an HTTP::Request object we'll start over with processing this request
      instead.</dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>$ua-&gt;remove_handler( undef, %matchspec )</dt>
  <dd></dd>
  <dt>$ua-&gt;remove_handler( $phase, %matchspec )</dt>
  <dd>Remove handlers that match the given <span class="Li">%matchspec</span>.
      If <span class="Li">$phase</span> is not provided remove handlers from all
      phases.
    <p class="Pp">Be careful as calling this function with
        <span class="Li">%matchspec</span> that is not not specific enough can
        remove handlers not owned by you. It's probably better to use the
        <i>set_my_handler()</i> method instead.</p>
    <p class="Pp">The removed handlers are returned.</p>
  </dd>
  <dt>$ua-&gt;set_my_handler( $phase, $cb, %matchspec )</dt>
  <dd>Set handlers private to the executing subroutine. Works by defaulting an
      <span class="Li">&quot;owner&quot;</span> field to the
      <span class="Li">%matchspec</span> that holds the name of the called
      subroutine. You might pass an explicit
      <span class="Li">&quot;owner&quot;</span> to override this.
    <p class="Pp">If <span class="Li">$cb</span> is passed as
        <span class="Li">&quot;undef&quot;</span>, remove the handler.</p>
  </dd>
  <dt>$ua-&gt;get_my_handler( $phase, %matchspec )</dt>
  <dd></dd>
  <dt>$ua-&gt;get_my_handler( $phase, %matchspec, $init )</dt>
  <dd>Will retrieve the matching handler as hash ref.
    <p class="Pp">If <span class="Li">$init</span> is passed passed as a TRUE
        value, create and add the handler if it's not found. If
        <span class="Li">$init</span> is a subroutine reference, then it's
        called with the created handler hash as argument. This sub might
        populate the hash with extra fields; especially the callback. If
        <span class="Li">$init</span> is a hash reference, merge the hashes.</p>
  </dd>
  <dt>$ua-&gt;handlers( $phase, $request )</dt>
  <dd></dd>
  <dt>$ua-&gt;handlers( $phase, $response )</dt>
  <dd>Returns the handlers that apply to the given request or response at the
      given processing phase.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="REQUEST_METHODS"><a class="permalink" href="#REQUEST_METHODS">REQUEST
  METHODS</a></h1>
<p class="Pp">The methods described in this section are used to dispatch
    requests via the user agent. The following request methods are provided:</p>
<dl class="Bl-tag">
  <dt>$ua-&gt;get( $url )</dt>
  <dd></dd>
  <dt>$ua-&gt;get( $url , $field_name =&gt; $value, ... )</dt>
  <dd>This method will dispatch a <span class="Li">&quot;GET&quot;</span>
      request on the given <span class="Li">$url</span>. Further arguments can
      be given to initialize the headers of the request. These are given as
      separate name/value pairs. The return value is a response object. See
      HTTP::Response for a description of the interface it provides.
    <p class="Pp">There will still be a response object returned when LWP can't
        connect to the server specified in the URL or when other failures in
        protocol handlers occur. These internal responses use the standard HTTP
        status codes, so the responses can't be differentiated by testing the
        response status code alone. Error responses that LWP generates
        internally will have the &quot;Client-Warning&quot; header set to the
        value &quot;Internal response&quot;. If you need to differentiate these
        internal responses from responses that a remote server actually
        generates, you need to test this header value.</p>
    <p class="Pp">Fields names that start with &quot;:&quot; are special. These
        will not initialize headers of the request but will determine how the
        response content is treated. The following special field names are
        recognized:</p>
    <p class="Pp"></p>
    <pre>
    :content_file   =&gt; $filename
    :content_cb     =&gt; \&amp;callback
    :read_size_hint =&gt; $bytes
    </pre>
    <p class="Pp">If a <span class="Li">$filename</span> is provided with the
        <span class="Li">&quot;:content_file&quot;</span> option, then the
        response content will be saved here instead of in the response object.
        If a callback is provided with the
        <span class="Li">&quot;:content_cb&quot;</span> option then this
        function will be called for each chunk of the response content as it is
        received from the server. If neither of these options are given, then
        the response content will accumulate in the response object itself. This
        might not be suitable for very large response bodies. Only one of
        <span class="Li">&quot;:content_file&quot;</span> or
        <span class="Li">&quot;:content_cb&quot;</span> can be specified. The
        content of unsuccessful responses will always accumulate in the response
        object itself, regardless of the
        <span class="Li">&quot;:content_file&quot;</span> or
        <span class="Li">&quot;:content_cb&quot;</span> options passed in.</p>
    <p class="Pp">The <span class="Li">&quot;:read_size_hint&quot;</span> option
        is passed to the protocol module which will try to read data from the
        server in chunks of this size. A smaller value for the
        <span class="Li">&quot;:read_size_hint&quot;</span> will result in a
        higher number of callback invocations.</p>
    <p class="Pp">The callback function is called with 3 arguments: a chunk of
        data, a reference to the response object, and a reference to the
        protocol object. The callback can abort the request by invoking
        <i>die()</i>. The exception message will show up as the
        &quot;X-Died&quot; header field in the response returned by the
        <i>get()</i> function.</p>
  </dd>
  <dt>$ua-&gt;head( $url )</dt>
  <dd></dd>
  <dt>$ua-&gt;head( $url , $field_name =&gt; $value, ... )</dt>
  <dd>This method will dispatch a <span class="Li">&quot;HEAD&quot;</span>
      request on the given <span class="Li">$url</span>. Otherwise it works like
      the <i>get()</i> method described above.</dd>
  <dt>$ua-&gt;post( $url, \%form )</dt>
  <dd></dd>
  <dt>$ua-&gt;post( $url, \@form )</dt>
  <dd></dd>
  <dt>$ua-&gt;post( $url, \%form, $field_name =&gt; $value, ... )</dt>
  <dd></dd>
  <dt>$ua-&gt;post( $url, $field_name =&gt; $value,... Content =&gt; \%form
    )</dt>
  <dd></dd>
  <dt>$ua-&gt;post( $url, $field_name =&gt; $value,... Content =&gt; \@form
    )</dt>
  <dd></dd>
  <dt>$ua-&gt;post( $url, $field_name =&gt; $value,... Content =&gt; $content
    )</dt>
  <dd>This method will dispatch a <span class="Li">&quot;POST&quot;</span>
      request on the given <span class="Li">$url</span>, with
      <span class="Li">%form</span> or <span class="Li">@form</span> providing
      the key/value pairs for the fill-in form content. Additional headers and
      content options are the same as for the <i>get()</i> method.
    <p class="Pp">This method will use the <i>POST()</i> function from
        <span class="Li">&quot;HTTP::Request::Common&quot;</span> to build the
        request. See HTTP::Request::Common for a details on how to pass form
        content and other advanced features.</p>
  </dd>
  <dt>$ua-&gt;put( $url, \%form )</dt>
  <dd></dd>
  <dt>$ua-&gt;put( $url, \@form )</dt>
  <dd></dd>
  <dt>$ua-&gt;put( $url, \%form, $field_name =&gt; $value, ... )</dt>
  <dd></dd>
  <dt>$ua-&gt;put( $url, $field_name =&gt; $value,... Content =&gt; \%form
    )</dt>
  <dd></dd>
  <dt>$ua-&gt;put( $url, $field_name =&gt; $value,... Content =&gt; \@form
    )</dt>
  <dd></dd>
  <dt>$ua-&gt;put( $url, $field_name =&gt; $value,... Content =&gt; $content
    )</dt>
  <dd>This method will dispatch a <span class="Li">&quot;PUT&quot;</span>
      request on the given <span class="Li">$url</span>, with
      <span class="Li">%form</span> or <span class="Li">@form</span> providing
      the key/value pairs for the fill-in form content. Additional headers and
      content options are the same as for the <i>get()</i> method.
    <p class="Pp">This method will use the <i>PUT()</i> function from
        <span class="Li">&quot;HTTP::Request::Common&quot;</span> to build the
        request. See HTTP::Request::Common for a details on how to pass form
        content and other advanced features.</p>
  </dd>
  <dt>$ua-&gt;delete( $url )</dt>
  <dd></dd>
  <dt>$ua-&gt;delete( $url, $field_name =&gt; $value, ... )</dt>
  <dd>This method will dispatch a <span class="Li">&quot;DELETE&quot;</span>
      request on the given <span class="Li">$url</span>. Additional headers and
      content options are the same as for the <i>get()</i> method.
    <p class="Pp">This method will use the <i>DELETE()</i> function from
        <span class="Li">&quot;HTTP::Request::Common&quot;</span> to build the
        request. See HTTP::Request::Common for a details on how to pass form
        content and other advanced features.</p>
  </dd>
  <dt>$ua-&gt;mirror( $url, $filename )</dt>
  <dd>This method will get the document identified by
      <span class="Li">$url</span> and store it in file called
      <span class="Li">$filename</span>. If the file already exists, then the
      request will contain an &quot;If-Modified-Since&quot; header matching the
      modification time of the file. If the document on the server has not
      changed since this time, then nothing happens. If the document has been
      updated, it will be downloaded again. The modification time of the file
      will be forced to match that of the server.
    <p class="Pp">The return value is the the response object.</p>
  </dd>
  <dt>$ua-&gt;request( $request )</dt>
  <dd></dd>
  <dt>$ua-&gt;request( $request, $content_file )</dt>
  <dd></dd>
  <dt>$ua-&gt;request( $request, $content_cb )</dt>
  <dd></dd>
  <dt>$ua-&gt;request( $request, $content_cb, $read_size_hint )</dt>
  <dd>This method will dispatch the given <span class="Li">$request</span>
      object. Normally this will be an instance of the
      <span class="Li">&quot;HTTP::Request&quot;</span> class, but any object
      with a similar interface will do. The return value is a response object.
      See HTTP::Request and HTTP::Response for a description of the interface
      provided by these classes.
    <p class="Pp">The <i>request()</i> method will process redirects and
        authentication responses transparently. This means that it may actually
        send several simple requests via the <i>simple_request()</i> method
        described below.</p>
    <p class="Pp">The request methods described above; <i>get()</i>,
        <i>head()</i>, <i>post()</i> and <i>mirror()</i>, will all dispatch the
        request they build via this method. They are convenience methods that
        simply hides the creation of the request object for you.</p>
    <p class="Pp">The <span class="Li">$content_file</span>,
        <span class="Li">$content_cb</span> and
        <span class="Li">$read_size_hint</span> all correspond to options
        described with the <i>get()</i> method above.</p>
    <p class="Pp">You are allowed to use a CODE reference as
        <span class="Li">&quot;content&quot;</span> in the request object passed
        in. The <span class="Li">&quot;content&quot;</span> function should
        return the content when called. The content can be returned in chunks.
        The content function will be invoked repeatedly until it return an empty
        string to signal that there is no more content.</p>
  </dd>
  <dt>$ua-&gt;simple_request( $request )</dt>
  <dd></dd>
  <dt>$ua-&gt;simple_request( $request, $content_file )</dt>
  <dd></dd>
  <dt>$ua-&gt;simple_request( $request, $content_cb )</dt>
  <dd></dd>
  <dt>$ua-&gt;simple_request( $request, $content_cb, $read_size_hint )</dt>
  <dd>This method dispatches a single request and returns the response received.
      Arguments are the same as for <i>request()</i> described above.
    <p class="Pp">The difference from <i>request()</i> is that
        <i>simple_request()</i> will not try to handle redirects or
        authentication responses. The <i>request()</i> method will in fact
        invoke this method for each simple request it sends.</p>
  </dd>
  <dt>$ua-&gt;is_online</dt>
  <dd>Tries to determine if you have access to the Internet. Returns TRUE if the
      built-in heuristics determine that the user agent is able to access the
      Internet (over HTTP). See also LWP::Online.</dd>
  <dt>$ua-&gt;is_protocol_supported( $scheme )</dt>
  <dd>You can use this method to test whether this user agent object supports
      the specified <span class="Li">&quot;scheme&quot;</span>. (The
      <span class="Li">&quot;scheme&quot;</span> might be a string (like 'http'
      or 'ftp') or it might be an URI object reference.)
    <p class="Pp">Whether a scheme is supported, is determined by the user
        agent's <span class="Li">&quot;protocols_allowed&quot;</span> or
        <span class="Li">&quot;protocols_forbidden&quot;</span> lists (if any),
        and by the capabilities of LWP. I.e., this will return TRUE only if LWP
        supports this protocol <i>and</i> it's permitted for this particular
        object.</p>
  </dd>
</dl>
<section class="Ss">
<h2 class="Ss" id="Callback_methods"><a class="permalink" href="#Callback_methods">Callback
  methods</a></h2>
<p class="Pp">The following methods will be invoked as requests are processed.
    These methods are documented here because subclasses of
    <span class="Li">&quot;LWP::UserAgent&quot;</span> might want to override
    their behaviour.</p>
<dl class="Bl-tag">
  <dt>$ua-&gt;prepare_request( $request )</dt>
  <dd>This method is invoked by <i>simple_request()</i>. Its task is to modify
      the given <span class="Li">$request</span> object by setting up various
      headers based on the attributes of the user agent. The return value should
      normally be the <span class="Li">$request</span> object passed in. If a
      different request object is returned it will be the one actually
      processed.
    <p class="Pp">The headers affected by the base implementation are;
        &quot;User-Agent&quot;, &quot;From&quot;, &quot;Range&quot; and
        &quot;Cookie&quot;.</p>
  </dd>
  <dt>$ua-&gt;redirect_ok( $prospective_request, $response )</dt>
  <dd>This method is called by <i>request()</i> before it tries to follow a
      redirection to the request in <span class="Li">$response</span>. This
      should return a TRUE value if this redirection is permissible. The
      <span class="Li">$prospective_request</span> will be the request to be
      sent if this method returns TRUE.
    <p class="Pp">The base implementation will return FALSE unless the method is
        in the object's
        <span class="Li">&quot;requests_redirectable&quot;</span> list, FALSE if
        the proposed redirection is to a &quot;file://...&quot; URL, and TRUE
        otherwise.</p>
  </dd>
  <dt>$ua-&gt;get_basic_credentials( $realm, $uri, $isproxy )</dt>
  <dd>This is called by <i>request()</i> to retrieve credentials for documents
      protected by Basic or Digest Authentication. The arguments passed in is
      the <span class="Li">$realm</span> provided by the server, the
      <span class="Li">$uri</span> requested and a boolean flag to indicate if
      this is authentication against a proxy server.
    <p class="Pp">The method should return a username and password. It should
        return an empty list to abort the authentication resolution attempt.
        Subclasses can override this method to prompt the user for the
        information. An example of this can be found in
        <span class="Li">&quot;lwp-request&quot;</span> program distributed with
        this library.</p>
    <p class="Pp">The base implementation simply checks a set of pre-stored
        member variables, set up with the <i>credentials()</i> method.</p>
  </dd>
  <dt>$ua-&gt;progress( $status, $request_or_response )</dt>
  <dd>This is called frequently as the response is received regardless of how
      the content is processed. The method is called with
      <span class="Li">$status</span> &quot;begin&quot; at the start of
      processing the request and with <span class="Li">$state</span>
      &quot;end&quot; before the request method returns. In between these
      <span class="Li">$status</span> will be the fraction of the response
      currently received or the string &quot;tick&quot; if the fraction can't be
      calculated.
    <p class="Pp">When <span class="Li">$status</span> is &quot;begin&quot; the
        second argument is the request object, otherwise it is the response
        object.</p>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">See LWP for a complete overview of libwww-perl5. See lwpcook and
    the scripts <i>lwp-request</i> and <i>lwp-download</i> for examples of
    usage.</p>
<p class="Pp">See HTTP::Request and HTTP::Response for a description of the
    message objects dispatched and received. See HTTP::Request::Common and
    HTML::Form for other ways to build request objects.</p>
<p class="Pp">See WWW::Mechanize and WWW::Search for examples of more
    specialized user agents based on
    <span class="Li">&quot;LWP::UserAgent&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 1995-2009 Gisle Aas.</p>
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-03-11</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

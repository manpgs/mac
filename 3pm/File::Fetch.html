<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>File::Fetch(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">File::Fetch(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">File::Fetch(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">File::Fetch - A generic file fetching mechanism</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use File::Fetch;
    ### build a File::Fetch object ###
    my $ff = File::Fetch-&gt;new(uri =&gt; 'http://some.where.com/dir/a.txt');
    ### fetch the uri to cwd() ###
    my $where = $ff-&gt;fetch() or die $ff-&gt;error;
    ### fetch the uri to /tmp ###
    my $where = $ff-&gt;fetch( to =&gt; '/tmp' );
    ### parsed bits from the uri ###
    $ff-&gt;uri;
    $ff-&gt;scheme;
    $ff-&gt;host;
    $ff-&gt;path;
    $ff-&gt;file;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">File::Fetch is a generic file fetching mechanism.</p>
<p class="Pp">It allows you to fetch any file pointed to by a
    <span class="Li">&quot;ftp&quot;</span>,
    <span class="Li">&quot;http&quot;</span>,
    <span class="Li">&quot;file&quot;</span>,
    <span class="Li">&quot;git&quot;</span> or
    <span class="Li">&quot;rsync&quot;</span> uri by a number of different
    means.</p>
<p class="Pp">See the <span class="Li">&quot;HOW IT WORKS&quot;</span> section
    further down for details.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACCESSORS"><a class="permalink" href="#ACCESSORS">ACCESSORS</a></h1>
<p class="Pp">A <span class="Li">&quot;File::Fetch&quot;</span> object has the
    following accessors</p>
<dl class="Bl-tag">
  <dt>$ff-&gt;uri</dt>
  <dd>The uri you passed to the constructor</dd>
  <dt>$ff-&gt;scheme</dt>
  <dd>The scheme from the uri (like 'file', 'http', etc)</dd>
  <dt>$ff-&gt;host</dt>
  <dd>The hostname in the uri. Will be empty if host was originally 'localhost'
      for a 'file://' url.</dd>
  <dt>$ff-&gt;vol</dt>
  <dd>On operating systems with the concept of a volume the second element of a
      file:// is considered to the be volume specification for the file. Thus on
      Win32 this routine returns the volume, on other operating systems this
      returns nothing.
    <p class="Pp">On Windows this value may be empty if the uri is to a network
        share, in which case the 'share' property will be defined. Additionally,
        volume specifications that use '|' as ':' will be converted on read to
        use ':'.</p>
    <p class="Pp">On VMS, which has a volume concept, this field will be empty
        because VMS file specifications are converted to absolute UNIX format
        and the volume information is transparently included.</p>
  </dd>
  <dt>$ff-&gt;share</dt>
  <dd>On systems with the concept of a network share (currently only Windows)
      returns the sharename from a file://// url. On other operating systems
      returns empty.</dd>
  <dt>$ff-&gt;path</dt>
  <dd>The path from the uri, will be at least a single '/'.</dd>
  <dt>$ff-&gt;file</dt>
  <dd>The name of the remote file. For the local file name, the result of
      <span class="Li">$ff</span>-&gt;output_file will be used.</dd>
  <dt>$ff-&gt;file_default</dt>
  <dd>The name of the default local file, that
      <span class="Li">$ff</span>-&gt;output_file falls back to if it would
      otherwise return no filename. For example when fetching a URI like
      http://www.abc.net.au/ the contents retrieved may be from a remote file
      called 'index.html'. The default value of this attribute is literally
      'file_default'.</dd>
  <dt>$ff-&gt;output_file</dt>
  <dd>The name of the output file. This is the same as
      <span class="Li">$ff</span>-&gt;file, but any query parameters are
      stripped off. For example:
    <p class="Pp"></p>
    <pre>    http://example.com/index.html?x=y
    </pre>
    <p class="Pp">would make the output file be
        <span class="Li">&quot;index.html&quot;</span> rather than
        <span class="Li">&quot;index.html?x=y&quot;</span>.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="$ff_=_File::Fetch"><a class="permalink" href="#$ff_=_File::Fetch">$ff
  = File::Fetch-&gt;new( uri =&gt; 'http://some.where.com/dir/file.txt'
  );</a></h2>
<p class="Pp">Parses the uri and creates a corresponding File::Fetch::Item
    object, that is ready to be <span class="Li">&quot;fetch&quot;</span>ed and
    returns it.</p>
<p class="Pp">Returns false on failure.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$where_=_$ff"><a class="permalink" href="#$where_=_$ff">$where
  = $ff-&gt;fetch( [to =&gt; /my/output/dir/ | \$scalar] )</a></h2>
<p class="Pp">Fetches the file you requested and returns the full path to the
    file.</p>
<p class="Pp">By default it writes to <span class="Li">&quot;cwd()&quot;</span>,
    but you can override that by specifying the
    <span class="Li">&quot;to&quot;</span> argument:</p>
<p class="Pp"></p>
<pre>    ### file fetch to /tmp, full path to the file in $where
    $where = $ff-&gt;fetch( to =&gt; '/tmp' );
    ### file slurped into $scalar, full path to the file in $where
    ### file is downloaded to a temp directory and cleaned up at exit time
    $where = $ff-&gt;fetch( to =&gt; \$scalar );
</pre>
<p class="Pp">Returns the full path to the downloaded file on success, and false
    on failure.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$ff"><a class="permalink" href="#$ff">$ff-&gt;error([BOOL])</a></h2>
<p class="Pp">Returns the last encountered error as string. Pass it a true value
    to get the <span class="Li">&quot;Carp::longmess()&quot;</span> output
    instead.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="HOW_IT_WORKS"><a class="permalink" href="#HOW_IT_WORKS">HOW
  IT WORKS</a></h1>
<p class="Pp">File::Fetch is able to fetch a variety of uris, by using several
    external programs and modules.</p>
<p class="Pp">Below is a mapping of what utilities will be used in what order
    for what schemes, if available:</p>
<p class="Pp"></p>
<pre>    file    =&gt; LWP, lftp, file
    http    =&gt; LWP, HTTP::Tiny, wget, curl, lftp, fetch, HTTP::Lite, lynx, iosock
    ftp     =&gt; LWP, Net::FTP, wget, curl, lftp, fetch, ncftp, ftp
    rsync   =&gt; rsync
    git     =&gt; git
</pre>
<p class="Pp">If you'd like to disable the use of one or more of these utilities
    and/or modules, see the <span class="Li">$BLACKLIST</span> variable further
    down.</p>
<p class="Pp">If a utility or module isn't available, it will be marked in a
    cache (see the <span class="Li">$METHOD_FAIL</span> variable further down),
    so it will not be tried again. The <span class="Li">&quot;fetch&quot;</span>
    method will only fail when all options are exhausted, and it was not able to
    retrieve the file.</p>
<p class="Pp">The <span class="Li">&quot;fetch&quot;</span> utility is available
    on FreeBSD. NetBSD and Dragonfly BSD may also have it from
    <span class="Li">&quot;pkgsrc&quot;</span>. We only check for
    <span class="Li">&quot;fetch&quot;</span> on those three platforms.</p>
<p class="Pp"><span class="Li">&quot;iosock&quot;</span> is a very limited
    IO::Socket::INET based mechanism for retrieving
    <span class="Li">&quot;http&quot;</span> schemed urls. It doesn't follow
    redirects for instance.</p>
<p class="Pp"><span class="Li">&quot;git&quot;</span> only supports
    <span class="Li">&quot;git://&quot;</span> style urls.</p>
<p class="Pp">A special note about fetching files from an ftp uri:</p>
<p class="Pp">By default, all ftp connections are done in passive mode. To
    change that, see the <span class="Li">$FTP_PASSIVE</span> variable further
    down.</p>
<p class="Pp">Furthermore, ftp uris only support anonymous connections, so no
    named user/password pair can be passed along.</p>
<p class="Pp"><span class="Li">&quot;/bin/ftp&quot;</span> is blacklisted by
    default; see the <span class="Li">$BLACKLIST</span> variable further
  down.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="GLOBAL_VARIABLES"><a class="permalink" href="#GLOBAL_VARIABLES">GLOBAL
  VARIABLES</a></h1>
<p class="Pp">The behaviour of File::Fetch can be altered by changing the
    following global variables:</p>
<section class="Ss">
<h2 class="Ss" id="$File::Fetch::FROM_EMAIL"><a class="permalink" href="#$File::Fetch::FROM_EMAIL">$File::Fetch::FROM_EMAIL</a></h2>
<p class="Pp">This is the email address that will be sent as your anonymous ftp
    password.</p>
<p class="Pp">Default is
    <span class="Li">&quot;File-Fetch@example.com&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$File::Fetch::USER_AGENT"><a class="permalink" href="#$File::Fetch::USER_AGENT">$File::Fetch::USER_AGENT</a></h2>
<p class="Pp">This is the useragent as <span class="Li">&quot;LWP&quot;</span>
    will report it.</p>
<p class="Pp">Default is
    <span class="Li">&quot;File::Fetch/$VERSION&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$File::Fetch::FTP_PASSIVE"><a class="permalink" href="#$File::Fetch::FTP_PASSIVE">$File::Fetch::FTP_PASSIVE</a></h2>
<p class="Pp">This variable controls whether the environment variable
    <span class="Li">&quot;FTP_PASSIVE&quot;</span> and any passive switches to
    commandline tools will be set to true.</p>
<p class="Pp">Default value is 1.</p>
<p class="Pp">Note: When <span class="Li">$FTP_PASSIVE</span> is true,
    <span class="Li">&quot;ncftp&quot;</span> will not be used to fetch files,
    since passive mode can only be set interactively for this binary</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$File::Fetch::TIMEOUT"><a class="permalink" href="#$File::Fetch::TIMEOUT">$File::Fetch::TIMEOUT</a></h2>
<p class="Pp">When set, controls the network timeout (counted in seconds).</p>
<p class="Pp">Default value is 0.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$File::Fetch::WARN"><a class="permalink" href="#$File::Fetch::WARN">$File::Fetch::WARN</a></h2>
<p class="Pp">This variable controls whether errors encountered internally by
    <span class="Li">&quot;File::Fetch&quot;</span> should be
    <span class="Li">&quot;carp&quot;</span>'d or not.</p>
<p class="Pp">Set to false to silence warnings. Inspect the output of the
    <span class="Li">&quot;error()&quot;</span> method manually to see what went
    wrong.</p>
<p class="Pp">Defaults to <span class="Li">&quot;true&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$File::Fetch::DEBUG"><a class="permalink" href="#$File::Fetch::DEBUG">$File::Fetch::DEBUG</a></h2>
<p class="Pp">This enables debugging output when calling commandline utilities
    to fetch files. This also enables
    <span class="Li">&quot;Carp::longmess&quot;</span> errors, instead of the
    regular <span class="Li">&quot;carp&quot;</span> errors.</p>
<p class="Pp">Good for tracking down why things don't work with your particular
    setup.</p>
<p class="Pp">Default is 0.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$File::Fetch::BLACKLIST"><a class="permalink" href="#$File::Fetch::BLACKLIST">$File::Fetch::BLACKLIST</a></h2>
<p class="Pp">This is an array ref holding blacklisted modules/utilities for
    fetching files with.</p>
<p class="Pp">To disallow the use of, for example,
    <span class="Li">&quot;LWP&quot;</span> and
    <span class="Li">&quot;Net::FTP&quot;</span>, you could set
    <span class="Li">$File::Fetch::BLACKLIST</span> to:</p>
<p class="Pp"></p>
<pre>    $File::Fetch::BLACKLIST = [qw|lwp netftp|]
</pre>
<p class="Pp">The default blacklist is [qw|ftp|], as
    <span class="Li">&quot;/bin/ftp&quot;</span> is rather unreliable.</p>
<p class="Pp">See the note on <span class="Li">&quot;MAPPING&quot;</span>
  below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$File::Fetch::METHOD_FAIL"><a class="permalink" href="#$File::Fetch::METHOD_FAIL">$File::Fetch::METHOD_FAIL</a></h2>
<p class="Pp">This is a hashref registering what modules/utilities were known to
    fail for fetching files (mostly because they weren't installed).</p>
<p class="Pp">You can reset this cache by assigning an empty hashref to it, or
    individually remove keys.</p>
<p class="Pp">See the note on <span class="Li">&quot;MAPPING&quot;</span>
  below.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="MAPPING"><a class="permalink" href="#MAPPING">MAPPING</a></h1>
<p class="Pp">Here's a quick mapping for the utilities/modules, and their names
    for the <span class="Li">$BLACKLIST</span>,
    <span class="Li">$METHOD_FAIL</span> and other internal functions.</p>
<p class="Pp"></p>
<pre>    LWP         =&gt; lwp
    HTTP::Lite  =&gt; httplite
    HTTP::Tiny  =&gt; httptiny
    Net::FTP    =&gt; netftp
    wget        =&gt; wget
    lynx        =&gt; lynx
    ncftp       =&gt; ncftp
    ftp         =&gt; ftp
    curl        =&gt; curl
    rsync       =&gt; rsync
    lftp        =&gt; lftp
    fetch       =&gt; fetch
    IO::Socket  =&gt; iosock
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="FREQUENTLY_ASKED_QUESTIONS"><a class="permalink" href="#FREQUENTLY_ASKED_QUESTIONS">FREQUENTLY
  ASKED QUESTIONS</a></h1>
<section class="Ss">
<h2 class="Ss" id="So_how_do_I_use_a_proxy_with_File::Fetch?"><a class="permalink" href="#So_how_do_I_use_a_proxy_with_File::Fetch?">So
  how do I use a proxy with File::Fetch?</a></h2>
<p class="Pp"><span class="Li">&quot;File::Fetch&quot;</span> currently only
    supports proxies with LWP::UserAgent. You will need to set your environment
    variables accordingly. For example, to use an ftp proxy:</p>
<p class="Pp"></p>
<pre>    $ENV{ftp_proxy} = 'foo.com';
</pre>
<p class="Pp">Refer to the LWP::UserAgent manpage for more details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="I_used_'lynx'_to_fetch_a_file,_but_its_contents_is_all_wrong!"><a class="permalink" href="#I_used_'lynx'_to_fetch_a_file,_but_its_contents_is_all_wrong!">I
  used 'lynx' to fetch a file, but its contents is all wrong!</a></h2>
<p class="Pp"><span class="Li">&quot;lynx&quot;</span> can only fetch remote
    files by dumping its contents to <span class="Li">&quot;STDOUT&quot;</span>,
    which we in turn capture. If that content is a 'custom' error file (like,
    say, a <span class="Li">&quot;404 handler&quot;</span>), you will get that
    contents instead.</p>
<p class="Pp">Sadly, <span class="Li">&quot;lynx&quot;</span> doesn't support
    any options to return a different exit code on
    non-<span class="Li">&quot;200 OK&quot;</span> status, giving us no way to
    tell the difference between a 'successful' fetch and a custom error
  page.</p>
<p class="Pp">Therefor, we recommend to only use
    <span class="Li">&quot;lynx&quot;</span> as a last resort. This is why it is
    at the back of our list of methods to try as well.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Files_I'm_trying_to_fetch_have_reserved_characters_or_non-ASCII_characters_in_them._What_do_I_do?"><a class="permalink" href="#Files_I'm_trying_to_fetch_have_reserved_characters_or_non-ASCII_characters_in_them._What_do_I_do?">Files
  I'm trying to fetch have reserved characters or non-ASCII characters in them.
  What do I do?</a></h2>
<p class="Pp"><span class="Li">&quot;File::Fetch&quot;</span> is relatively
    smart about things. When trying to write a file to disk, it removes the
    <span class="Li">&quot;query parameters&quot;</span> (see the
    <span class="Li">&quot;output_file&quot;</span> method for details) from the
    file name before creating it. In most cases this suffices.</p>
<p class="Pp">If you have any other characters you need to escape, please
    install the <span class="Li">&quot;URI::Escape&quot;</span> module from
    CPAN, and pre-encode your URI before passing it to
    <span class="Li">&quot;File::Fetch&quot;</span>. You can read about the
    details of URIs and URI encoding here:</p>
<p class="Pp"></p>
<pre>  http://www.faqs.org/rfcs/rfc2396.html
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TODO"><a class="permalink" href="#TODO">TODO</a></h1>
<dl class="Bl-tag">
  <dt id="Implement"><a class="permalink" href="#Implement">Implement
    $PREFER_BIN</a></dt>
  <dd>To indicate to rather use commandline tools than modules</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="BUG_REPORTS"><a class="permalink" href="#BUG_REPORTS">BUG
  REPORTS</a></h1>
<p class="Pp">Please report bugs or other issues to
    &lt;bug-file-fetch@rt.cpan.org&lt;gt&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">This module by Jos Boumans &lt;kane@cpan.org&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">This library is free software; you may redistribute and/or modify
    it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os">perl v5.34.1</td>
  </tr>
</table>
</body>
</html>

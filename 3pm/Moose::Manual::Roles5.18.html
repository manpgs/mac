<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Moose::Manual::Roles(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Moose::Manual::Roles(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Moose::Manual::Roles(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Moose::Manual::Roles - Roles, an alternative to deep hierarchies
    and base classes</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 2.1202</p>
</section>
<section class="Sh">
<h1 class="Sh" id="WHAT_IS_A_ROLE?"><a class="permalink" href="#WHAT_IS_A_ROLE?">WHAT
  IS A ROLE?</a></h1>
<p class="Pp">A role encapsulates some piece of behavior or state that can be
    shared between classes. It is something that classes <i>do</i>. It is
    important to understand that <i>roles are not classes</i>. You cannot
    inherit from a role, and a role cannot be instantiated. We sometimes say
    that roles are <i>consumed</i>, either by classes or other roles.</p>
<p class="Pp">Instead, a role is <i>composed</i> into a class. In practical
    terms, this means that all of the methods, method modifiers, and attributes
    defined in a role are added directly to (we sometimes say &quot;flattened
    into&quot;) the class that consumes the role. These attributes and methods
    then appear as if they were defined in the class itself. A subclass of the
    consuming class will inherit all of these methods and attributes.</p>
<p class="Pp">Moose roles are similar to mixins or interfaces in other
    languages.</p>
<p class="Pp">Besides defining their own methods and attributes, roles can also
    require that the consuming class define certain methods of its own. You
    could have a role that consisted only of a list of required methods, in
    which case the role would be very much like a Java interface.</p>
<p class="Pp">Note that attribute accessors also count as methods for the
    purposes of satisfying the requirements of a role.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="A_SIMPLE_ROLE"><a class="permalink" href="#A_SIMPLE_ROLE">A
  SIMPLE ROLE</a></h1>
<p class="Pp">Creating a role looks a lot like creating a Moose class:</p>
<p class="Pp"></p>
<pre>
  package Breakable;

  use Moose::Role;

  has 'is_broken' =&gt; (
      is  =&gt; 'rw',
      isa =&gt; 'Bool',
  );

  sub break {
      my $self = shift;

      print &quot;I broke\n&quot;;

      $self-&gt;is_broken(1);
  }
</pre>
<p class="Pp">Except for our use of Moose::Role, this looks just like a class
    definition with Moose. However, this is not a class, and it cannot be
    instantiated.</p>
<p class="Pp">Instead, its attributes and methods will be composed into classes
    which use the role:</p>
<p class="Pp"></p>
<pre>
  package Car;

  use Moose;

  with 'Breakable';

  has 'engine' =&gt; (
      is  =&gt; 'ro',
      isa =&gt; 'Engine',
  );
</pre>
<p class="Pp">The <span class="Li">&quot;with&quot;</span> function composes
    roles into a class. Once that is done, the
    <span class="Li">&quot;Car&quot;</span> class has an
    <span class="Li">&quot;is_broken&quot;</span> attribute and a
    <span class="Li">&quot;break&quot;</span> method. The
    <span class="Li">&quot;Car&quot;</span> class also
    <span class="Li">&quot;does('Breakable')&quot;</span>:</p>
<p class="Pp"></p>
<pre>
  my $car = Car-&gt;new( engine =&gt; Engine-&gt;new );

  print $car-&gt;is_broken ? 'Busted' : 'Still working';
  $car-&gt;break;
  print $car-&gt;is_broken ? 'Busted' : 'Still working';

  $car-&gt;does('Breakable'); # true
</pre>
<p class="Pp">This prints:</p>
<p class="Pp"></p>
<pre>
  Still working
  I broke
  Busted
</pre>
<p class="Pp">We could use this same role in a
    <span class="Li">&quot;Bone&quot;</span> class:</p>
<p class="Pp"></p>
<pre>
  package Bone;

  use Moose;

  with 'Breakable';

  has 'marrow' =&gt; (
      is  =&gt; 'ro',
      isa =&gt; 'Marrow',
  );
</pre>
<p class="Pp">See also Moose::Cookbook::Roles::Comparable_CodeReuse for an
    example.</p>
<p class="Pp">It's possible to compose existing roles into new roles. For
    example, we can have a <span class="Li">&quot;HandleWithCare&quot;</span>
    class which applies both the <span class="Li">&quot;Breakable&quot;</span>
    and <span class="Li">&quot;Package&quot;</span> roles to any class which
    consumes it:</p>
<p class="Pp"></p>
<pre>
  package HandleWithCare;

  use Moose::Role;

  with 'Breakable', 'Package';
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="REQUIRED_METHODS"><a class="permalink" href="#REQUIRED_METHODS">REQUIRED
  METHODS</a></h1>
<p class="Pp">As mentioned previously, a role can require that consuming classes
    provide one or more methods. Using our
    <span class="Li">&quot;Breakable&quot;</span> example, let's make it require
    that consuming classes implement their own
    <span class="Li">&quot;break&quot;</span> methods:</p>
<p class="Pp"></p>
<pre>
  package Breakable;

  use Moose::Role;

  requires 'break';

  has 'is_broken' =&gt; (
      is  =&gt; 'rw',
      isa =&gt; 'Bool',
  );

  after 'break' =&gt; sub {
      my $self = shift;

      $self-&gt;is_broken(1);
  };
</pre>
<p class="Pp">If we try to consume this role in a class that does not have a
    <span class="Li">&quot;break&quot;</span> method, we will get an
  exception.</p>
<p class="Pp">You can see that we added a method modifier on
    <span class="Li">&quot;break&quot;</span>. We want classes that consume this
    role to implement their own logic for breaking, but we make sure that the
    <span class="Li">&quot;is_broken&quot;</span> attribute is always set to
    true when <span class="Li">&quot;break&quot;</span> is called.</p>
<p class="Pp"></p>
<pre>
  package Car

  use Moose;

  with 'Breakable';

  has 'engine' =&gt; (
      is  =&gt; 'ro',
      isa =&gt; 'Engine',
  );

  sub break {
      my $self = shift;

      if ( $self-&gt;is_moving ) {
          $self-&gt;stop;
      }
  }
</pre>
<section class="Ss">
<h2 class="Ss" id="Roles_Versus_Abstract_Base_Classes"><a class="permalink" href="#Roles_Versus_Abstract_Base_Classes">Roles
  Versus Abstract Base Classes</a></h2>
<p class="Pp">If you are familiar with the concept of abstract base classes in
    other languages, you may be tempted to use roles in the same way.</p>
<p class="Pp">You <i>can</i> define an &quot;interface-only&quot; role, one that
    contains <i>just</i> a list of required methods.</p>
<p class="Pp">However, any class which consumes this role must implement all of
    the required methods, either directly or through inheritance from a parent.
    You cannot delay the method requirement check so that they can be
    implemented by future subclasses.</p>
<p class="Pp">Because the role defines the required methods directly, adding a
    base class to the mix would not achieve anything. We recommend that you
    simply consume the interface role in each class which implements that
    interface.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Required_Attributes"><a class="permalink" href="#Required_Attributes">Required
  Attributes</a></h2>
<p class="Pp">As mentioned before, a role's required method may also be
    satisfied by an attribute accessor. However, the call to
    <span class="Li">&quot;has&quot;</span> which defines an attribute happens
    at runtime. This means that you must define the attribute <i>before</i>
    consuming the role, or else the role will not see the generated
  accessor.</p>
<p class="Pp"></p>
<pre>
  package Breakable;

  use Moose::Role;

  requires 'stress';

  package Car;

  use Moose;

  has 'stress' =&gt; (
      is  =&gt; 'rw',
      isa =&gt; 'Int',
  );

  with 'Breakable';
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="USING_METHOD_MODIFIERS"><a class="permalink" href="#USING_METHOD_MODIFIERS">USING
  METHOD MODIFIERS</a></h1>
<p class="Pp">Method modifiers and roles are a very powerful combination. Often,
    a role will combine method modifiers and required methods. We already saw
    one example with our <span class="Li">&quot;Breakable&quot;</span>
  example.</p>
<p class="Pp">Method modifiers increase the complexity of roles, because they
    make the role application order relevant. If a class uses multiple roles,
    each of which modify the same method, those modifiers will be applied in the
    same order as the roles are used:</p>
<p class="Pp"></p>
<pre>
  package MovieCar;

  use Moose;

  extends 'Car';

  with 'Breakable', 'ExplodesOnBreakage';
</pre>
<p class="Pp">Assuming that the new
    <span class="Li">&quot;ExplodesOnBreakage&quot;</span> role <i>also</i> has
    an <span class="Li">&quot;after&quot;</span> modifier on
    <span class="Li">&quot;break&quot;</span>, the
    <span class="Li">&quot;after&quot;</span> modifiers will run one after the
    other. The modifier from <span class="Li">&quot;Breakable&quot;</span> will
    run first, then the one from
    <span class="Li">&quot;ExplodesOnBreakage&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHOD_CONFLICTS"><a class="permalink" href="#METHOD_CONFLICTS">METHOD
  CONFLICTS</a></h1>
<p class="Pp">If a class composes multiple roles, and those roles have methods
    of the same name, we will have a conflict. In that case, the composing class
    is required to provide its <i>own</i> method of the same name.</p>
<p class="Pp"></p>
<pre>
  package Breakdancer;

  use Moose::Role;

  sub break {

  }
</pre>
<p class="Pp">If we compose both <span class="Li">&quot;Breakable&quot;</span>
    and <span class="Li">&quot;Breakdancer&quot;</span> in a class, we must
    provide our own <span class="Li">&quot;break&quot;</span> method:</p>
<p class="Pp"></p>
<pre>
  package FragileDancer;

  use Moose;

  with 'Breakable', 'Breakdancer';

  sub break { ... }
</pre>
<p class="Pp">A role can be a collection of other roles:</p>
<p class="Pp"></p>
<pre>
  package Break::Bundle;

  use Moose::Role;

  with ('Breakable', 'Breakdancer');
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="METHOD_EXCLUSION_AND_ALIASING"><a class="permalink" href="#METHOD_EXCLUSION_AND_ALIASING">METHOD
  EXCLUSION AND ALIASING</a></h1>
<p class="Pp">If we want our <span class="Li">&quot;FragileDancer&quot;</span>
    class to be able to call the methods from both its roles, we can alias the
    methods:</p>
<p class="Pp"></p>
<pre>
  package FragileDancer;

  use Moose;

  with 'Breakable'   =&gt; { -alias =&gt; { break =&gt; 'break_bone' } },
       'Breakdancer' =&gt; { -alias =&gt; { break =&gt; 'break_dance' } };
</pre>
<p class="Pp">However, aliasing a method simply makes a <i>copy</i> of the
    method with the new name. We also need to exclude the original name:</p>
<p class="Pp"></p>
<pre>
  with 'Breakable' =&gt; {
      -alias    =&gt; { break =&gt; 'break_bone' },
      -excludes =&gt; 'break',
      },
      'Breakdancer' =&gt; {
      -alias    =&gt; { break =&gt; 'break_dance' },
      -excludes =&gt; 'break',
      };
</pre>
<p class="Pp">The excludes parameter prevents the
    <span class="Li">&quot;break&quot;</span> method from being composed into
    the <span class="Li">&quot;FragileDancer&quot;</span> class, so we don't
    have a conflict. This means that
    <span class="Li">&quot;FragileDancer&quot;</span> does not need to implement
    its own <span class="Li">&quot;break&quot;</span> method.</p>
<p class="Pp">This is useful, but it's worth noting that this breaks the
    contract implicit in consuming a role. Our
    <span class="Li">&quot;FragileDancer&quot;</span> class does both the
    <span class="Li">&quot;Breakable&quot;</span> and
    <span class="Li">&quot;BreakDancer&quot;</span>, but does not provide a
    <span class="Li">&quot;break&quot;</span> method. If some API expects an
    object that does one of those roles, it probably expects it to implement
    that method.</p>
<p class="Pp">In some use cases we might alias and exclude methods from roles,
    but then provide a method of the same name in the class itself.</p>
<p class="Pp">Also see Moose::Cookbook::Roles::Restartable_AdvancedComposition
    for an example.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ROLE_EXCLUSION"><a class="permalink" href="#ROLE_EXCLUSION">ROLE
  EXCLUSION</a></h1>
<p class="Pp">A role can say that it cannot be combined with some other role.
    This should be used with great caution, since it limits the re-usability of
    the role.</p>
<p class="Pp"></p>
<pre>
  package Breakable;

  use Moose::Role;

  excludes 'BreakDancer';
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="ADDING_A_ROLE_TO_AN_OBJECT_INSTANCE"><a class="permalink" href="#ADDING_A_ROLE_TO_AN_OBJECT_INSTANCE">ADDING
  A ROLE TO AN OBJECT INSTANCE</a></h1>
<p class="Pp">You may want to add a role to an object instance, rather than to a
    class. For example, you may want to add debug tracing to one instance of an
    object while debugging a particular bug. Another use case might be to
    dynamically change objects based on a user's configuration, as a plugin
    system.</p>
<p class="Pp">The best way to do this is to use the
    <span class="Li">&quot;apply_all_roles()&quot;</span> function from
    Moose::Util:</p>
<p class="Pp"></p>
<pre>
  use Moose::Util qw( apply_all_roles );

  my $car = Car-&gt;new;
  apply_all_roles( $car, 'Breakable' );
</pre>
<p class="Pp">This function can apply more than one role at a time, and will do
    so using the normal Moose role combination system. We recommend using this
    function to apply roles to an object. This is what Moose uses internally
    when you call <span class="Li">&quot;with&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Stevan Little &lt;stevan.little@iinteractive.com&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
  <li>Shawn M Moore &lt;code@sartak.org&gt;</li>
  <li>XXXX XXX'XX (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Florian Ragwitz &lt;rafl@debian.org&gt;</li>
  <li>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</li>
  <li>Chris Prather &lt;chris@prather.org&gt;</li>
  <li>Matt S Trout &lt;mst@shadowcat.co.uk&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2006 by Infinity Interactive,
  Inc..</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-19</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

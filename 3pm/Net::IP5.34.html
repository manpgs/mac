<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>IP(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">IP(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">IP(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
Net::IP - Perl extension for manipulating IPv4/IPv6 addresses
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  use Net::IP;
  
  my $ip = new Net::IP ('193.0.1/24') or die (Net::IP::Error());
  print (&quot;IP  : &quot;.$ip-&gt;ip().&quot;\n&quot;);
  print (&quot;Sho : &quot;.$ip-&gt;short().&quot;\n&quot;);
  print (&quot;Bin : &quot;.$ip-&gt;binip().&quot;\n&quot;);
  print (&quot;Int : &quot;.$ip-&gt;intip().&quot;\n&quot;);
  print (&quot;Mask: &quot;.$ip-&gt;mask().&quot;\n&quot;);
  print (&quot;Last: &quot;.$ip-&gt;last_ip().&quot;\n&quot;);
  print (&quot;Len : &quot;.$ip-&gt;prefixlen().&quot;\n&quot;);
  print (&quot;Size: &quot;.$ip-&gt;size().&quot;\n&quot;);
  print (&quot;Type: &quot;.$ip-&gt;iptype().&quot;\n&quot;);
  print (&quot;Rev:  &quot;.$ip-&gt;reverse_ip().&quot;\n&quot;);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module provides functions to deal with <b>IPv4/IPv6</b>
    addresses. The module can be used as a class, allowing the user to
    instantiate IP objects, which can be single IP addresses, prefixes, or
    ranges of addresses. There is also a procedural way of accessing most of the
    functions. Most subroutines can take either <b>IPv4</b> or <b>IPv6</b>
    addresses transparently.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OBJECT-ORIENTED_INTERFACE"><a class="permalink" href="#OBJECT-ORIENTED_INTERFACE">OBJECT-ORIENTED
  INTERFACE</a></h1>
<section class="Ss">
<h2 class="Ss" id="Object_Creation"><a class="permalink" href="#Object_Creation">Object
  Creation</a></h2>
<p class="Pp">A Net::IP object can be created from a single IP address:</p>
<p class="Pp"></p>
<pre>  $ip = new Net::IP ('193.0.1.46') || die ...
</pre>
<p class="Pp">Or from a Classless Prefix (a /24 prefix is equivalent to a C
    class):</p>
<p class="Pp"></p>
<pre>  $ip = new Net::IP ('195.114.80/24') || die ...
</pre>
<p class="Pp">Or from a range of addresses:</p>
<p class="Pp"></p>
<pre>  $ip = new Net::IP ('20.34.101.207 - 201.3.9.99') || die ...
</pre>
<p class="Pp">Or from a address plus a number:</p>
<p class="Pp"></p>
<pre>  $ip = new Net::IP ('20.34.10.0 + 255') || die ...
</pre>
<p class="Pp">The <b>new()</b> function accepts IPv4 and IPv6 addresses:</p>
<p class="Pp"></p>
<pre>  $ip = new Net::IP ('dead:beef::/32') || die ...
</pre>
<p class="Pp">Optionnaly, the function can be passed the version of the IP.
    Otherwise, it tries to guess what the version is (see
    <b></b><b>_is_ipv4()</b><b></b> and <b></b><b>_is_ipv6()</b><b></b>).</p>
<p class="Pp"></p>
<pre>  $ip = new Net::IP ('195/8',4); # Class A
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="OBJECT_METHODS"><a class="permalink" href="#OBJECT_METHODS">OBJECT
  METHODS</a></h1>
<p class="Pp">Most of these methods are front-ends for the real functions, which
    use a procedural interface. Most functions return undef on failure, and a
    true value on success. A detailed description of the procedural interface is
    provided below.</p>
<section class="Ss">
<h2 class="Ss" id="set"><a class="permalink" href="#set">set</a></h2>
<p class="Pp">Set an IP address in an existing IP object. This method has the
    same functionality as the <b>new()</b> method, except that it reuses an
    existing object to store the new IP.</p>
<p class="Pp"><span class="Li">&quot;$ip-&gt;set('130.23.1/24',4);&quot;</span></p>
<p class="Pp">Like <b>new()</b>, <b>set()</b> takes two arguments - a string
    used to build an IP address, prefix, or range, and optionally, the IP
    version of the considered address.</p>
<p class="Pp">It returns an IP object on success, and undef on failure.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="error"><a class="permalink" href="#error">error</a></h2>
<p class="Pp">Return the current object error string. The error string is set
    whenever one of the methods produces an error. Also, a global, class-wide
    <b></b><b>Error()</b><b></b> function is avaliable.</p>
<p class="Pp"><span class="Li">&quot;warn ($ip-&gt;error());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="errno"><a class="permalink" href="#errno">errno</a></h2>
<p class="Pp">Return the current object error number. The error number is set
    whenever one of the methods produces an error. Also, a global
    <b></b><span class="Li"><b>$ERRNO</b></span><b></b> variable is set when an
    error is produced.</p>
<p class="Pp"><span class="Li">&quot;warn ($ip-&gt;errno());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip"><a class="permalink" href="#ip">ip</a></h2>
<p class="Pp">Return the IP address (or first IP of the prefix or range) in quad
    format, as a string.</p>
<p class="Pp"><span class="Li">&quot;print ($ip-&gt;ip());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="binip"><a class="permalink" href="#binip">binip</a></h2>
<p class="Pp">Return the IP address as a binary string of 0s and 1s.</p>
<p class="Pp"><span class="Li">&quot;print ($ip-&gt;binip());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="prefixlen"><a class="permalink" href="#prefixlen">prefixlen</a></h2>
<p class="Pp">Return the length in bits of the current prefix.</p>
<p class="Pp"><span class="Li">&quot;print
  ($ip-&gt;prefixlen());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="version"><a class="permalink" href="#version">version</a></h2>
<p class="Pp">Return the version of the current IP object (4 or 6).</p>
<p class="Pp"><span class="Li">&quot;print ($ip-&gt;version());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="size"><a class="permalink" href="#size">size</a></h2>
<p class="Pp">Return the number of IP addresses in the current prefix or range.
    Use of this function requires Math::BigInt.</p>
<p class="Pp"><span class="Li">&quot;print ($ip-&gt;size());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="binmask"><a class="permalink" href="#binmask">binmask</a></h2>
<p class="Pp">Return the binary mask of the current prefix, if applicable.</p>
<p class="Pp"><span class="Li">&quot;print ($ip-&gt;binmask());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="mask"><a class="permalink" href="#mask">mask</a></h2>
<p class="Pp">Return the mask in quad format of the current prefix.</p>
<p class="Pp"><span class="Li">&quot;print ($ip-&gt;mask());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="prefix"><a class="permalink" href="#prefix">prefix</a></h2>
<p class="Pp">Return the full prefix (ip+prefix length) in quad (standard)
    format.</p>
<p class="Pp"><span class="Li">&quot;print ($ip-&gt;prefix());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="print"><a class="permalink" href="#print">print</a></h2>
<p class="Pp">Print the IP object (IP/Prefix or First - Last)</p>
<p class="Pp"><span class="Li">&quot;print ($ip-&gt;print());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="intip"><a class="permalink" href="#intip">intip</a></h2>
<p class="Pp">Convert the IP in integer format and return it as a Math::BigInt
    object.</p>
<p class="Pp"><span class="Li">&quot;print ($ip-&gt;intip());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="hexip"><a class="permalink" href="#hexip">hexip</a></h2>
<p class="Pp">Return the IP in hex format</p>
<p class="Pp"><span class="Li">&quot;print ($ip-&gt;hexip());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="hexmask"><a class="permalink" href="#hexmask">hexmask</a></h2>
<p class="Pp">Return the mask in hex format</p>
<p class="Pp"><span class="Li">&quot;print ($ip-&gt;hexmask());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="short"><a class="permalink" href="#short">short</a></h2>
<p class="Pp">Return the IP in short format: 	IPv4 addresses: 194.5/16 	IPv6
    addresses: ab32:f000::</p>
<p class="Pp"><span class="Li">&quot;print ($ip-&gt;short());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="iptype"><a class="permalink" href="#iptype">iptype</a></h2>
<p class="Pp">Return the IP Type - this describes the type of an IP (Public,
    Private, Reserved, etc.) See procedural interface ip_iptype for more
    details.</p>
<p class="Pp"><span class="Li">&quot;print ($ip-&gt;iptype());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="reverse_ip"><a class="permalink" href="#reverse_ip">reverse_ip</a></h2>
<p class="Pp">Return the reverse IP for a given IP address (in.addr.
  format).</p>
<p class="Pp"><span class="Li">&quot;print
  ($ip-&gt;reserve_ip());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="last_ip"><a class="permalink" href="#last_ip">last_ip</a></h2>
<p class="Pp">Return the last IP of a prefix/range in quad format.</p>
<p class="Pp"><span class="Li">&quot;print ($ip-&gt;last_ip());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="last_bin"><a class="permalink" href="#last_bin">last_bin</a></h2>
<p class="Pp">Return the last IP of a prefix/range in binary format.</p>
<p class="Pp"><span class="Li">&quot;print
  ($ip-&gt;last_bin());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="last_int"><a class="permalink" href="#last_int">last_int</a></h2>
<p class="Pp">Return the last IP of a prefix/range in integer format.</p>
<p class="Pp"><span class="Li">&quot;print
  ($ip-&gt;last_int());&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="find_prefixes"><a class="permalink" href="#find_prefixes">find_prefixes</a></h2>
<p class="Pp">This function finds all the prefixes that can be found between the
    two addresses of a range. The function returns a list of prefixes.</p>
<p class="Pp"><span class="Li">&quot;@list =
    $ip-&gt;find_prefixes($other_ip));&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="bincomp"><a class="permalink" href="#bincomp">bincomp</a></h2>
<p class="Pp">Binary comparaison of two IP objects. The function takes an
    operation and an IP object as arguments. It returns a boolean value.</p>
<p class="Pp">The operation can be one of: lt: less than (smaller than) le:
    smaller or equal to gt: greater than ge: greater or equal to</p>
<p class="Pp"><span class="Li">&quot;if ($ip-&gt;bincomp('lt',$ip2)
    {...}&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="binadd"><a class="permalink" href="#binadd">binadd</a></h2>
<p class="Pp">Binary addition of two IP objects. The value returned is an IP
    object.</p>
<p class="Pp"><span class="Li">&quot;my $sum =
    $ip-&gt;binadd($ip2);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="aggregate"><a class="permalink" href="#aggregate">aggregate</a></h2>
<p class="Pp">Aggregate 2 IPs - Append one range/prefix of IPs to another. The
    last address of the first range must be the one immediately preceding the
    first address of the second range. A new IP object is returned.</p>
<p class="Pp"><span class="Li">&quot;my $total =
    $ip-&gt;aggregate($ip2);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="overlaps"><a class="permalink" href="#overlaps">overlaps</a></h2>
<p class="Pp">Check if two IP ranges/prefixes overlap each other. The value
    returned by the function should be one of:
    	<span class="Li">$IP_PARTIAL_OVERLAP</span> (ranges overlap)
    	<span class="Li">$IP_NO_OVERLAP</span> (no overlap)
    	<span class="Li">$IP_A_IN_B_OVERLAP</span> (range2 contains range1)
    	<span class="Li">$IP_B_IN_A_OVERLAP</span> (range1 contains range2)
    	<span class="Li">$IP_IDENTICAL</span> (ranges are identical) 	undef
    (problem)</p>
<p class="Pp"><span class="Li">&quot;if
    ($ip-&gt;overlaps($ip2)==$IP_A_IN_B_OVERLAP) {...};&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="looping"><a class="permalink" href="#looping">looping</a></h2>
<p class="Pp">The <span class="Li">&quot;+&quot;</span> operator is overloaded
    in order to allow looping though a whole range of IP addresses:</p>
<p class="Pp"></p>
<pre>  my $ip = new Net::IP ('195.45.6.7 - 195.45.6.19') || die;
  # Loop
  do {
      print $ip-&gt;ip(), &quot;\n&quot;;
  } while (++$ip);
</pre>
<p class="Pp">The ++ operator returns undef when the last address of the range
    is reached.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="auth"><a class="permalink" href="#auth">auth</a></h2>
<p class="Pp">Return IP authority information from the IP::Authority module</p>
<p class="Pp"><span class="Li">&quot;$auth = ip-&quot;</span>auth ();&gt;</p>
<p class="Pp">Note: IPv4 only</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="PROCEDURAL_INTERFACE"><a class="permalink" href="#PROCEDURAL_INTERFACE">PROCEDURAL
  INTERFACE</a></h1>
<p class="Pp">These functions do the real work in the module. Like the OO
    methods, most of these return undef on failure. In order to access error
    codes and strings, instead of using
    <span class="Li">$ip</span>-&gt;<b>error()</b> and
    <span class="Li">$ip</span>-&gt;<b>errno()</b>, use the global functions
    <span class="Li">&quot;Error()&quot;</span> and
    <span class="Li">&quot;Errno()&quot;</span>.</p>
<p class="Pp">The functions of the procedural interface are not exported by
    default. In order to import these functions, you need to modify the use
    statement for the module:</p>
<p class="Pp"><span class="Li">&quot;use Net::IP qw(:PROC);&quot;</span></p>
<section class="Ss">
<h2 class="Ss" id="Error"><a class="permalink" href="#Error">Error</a></h2>
<p class="Pp">Returns the error string corresponding to the last error generated
    in the module. This is also useful for the OO interface, as if the
    <b>new()</b> function fails, we cannot call
    <span class="Li">$ip</span>-&gt;<b>error()</b> and so we have to use
    <b>Error()</b>.</p>
<p class="Pp">warn <b>Error()</b>;</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Errno"><a class="permalink" href="#Errno">Errno</a></h2>
<p class="Pp">Returns a numeric error code corresponding to the error string
    returned by Error.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_iptobin"><a class="permalink" href="#ip_iptobin">ip_iptobin</a></h2>
<p class="Pp">Transform an IP address into a bit string.</p>
<p class="Pp"></p>
<pre>    Params  : IP address, IP version
    Returns : binary IP string on success, undef otherwise
</pre>
<p class="Pp"><span class="Li">&quot;$binip = ip_iptobin
  ($ip,6);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_bintoip"><a class="permalink" href="#ip_bintoip">ip_bintoip</a></h2>
<p class="Pp">Transform a bit string into an IP address</p>
<p class="Pp"></p>
<pre>    Params  : binary IP, IP version
    Returns : IP address on success, undef otherwise
</pre>
<p class="Pp"><span class="Li">&quot;$ip = ip_bintoip
  ($binip,6);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_bintoint"><a class="permalink" href="#ip_bintoint">ip_bintoint</a></h2>
<p class="Pp">Transform a bit string into a BigInt.</p>
<p class="Pp"></p>
<pre>    Params  : binary IP
    Returns : BigInt
</pre>
<p class="Pp"><span class="Li">&quot;$bigint = new Math::BigInt
    (ip_bintoint($binip));&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_inttobin"><a class="permalink" href="#ip_inttobin">ip_inttobin</a></h2>
<p class="Pp">Transform a BigInt into a bit string. <i>Warning</i>: sets
    warnings (<span class="Li">&quot;-w&quot;</span>) off. This is necessary
    because Math::BigInt is not compliant.</p>
<p class="Pp"></p>
<pre>    Params  : BigInt, IP version
    Returns : binary IP
</pre>
<p class="Pp"><span class="Li">&quot;$binip = ip_inttobin
    ($bigint);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_get_version"><a class="permalink" href="#ip_get_version">ip_get_version</a></h2>
<p class="Pp">Try to guess the IP version of an IP address.</p>
<p class="Pp"></p>
<pre>    Params  : IP address
    Returns : 4, 6, undef(unable to determine)
</pre>
<p class="Pp"><span class="Li">&quot;$version = ip_get_version
    ($ip)&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_is_ipv4"><a class="permalink" href="#ip_is_ipv4">ip_is_ipv4</a></h2>
<p class="Pp">Check if an IP address is of type 4.</p>
<p class="Pp"></p>
<pre>    Params  : IP address
    Returns : 1 (yes) or 0 (no)
</pre>
<p class="Pp"><span class="Li">&quot;ip_is_ipv4($ip) and print &quot;$ip is
    IPv4&quot;;&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_is_ipv6"><a class="permalink" href="#ip_is_ipv6">ip_is_ipv6</a></h2>
<p class="Pp">Check if an IP address is of type 6.</p>
<p class="Pp"></p>
<pre>    Params            : IP address
    Returns           : 1 (yes) or 0 (no)
</pre>
<p class="Pp"><span class="Li">&quot;ip_is_ipv6($ip) and print &quot;$ip is
    IPv6&quot;;&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_expand_address"><a class="permalink" href="#ip_expand_address">ip_expand_address</a></h2>
<p class="Pp">Expand an IP address from compact notation.</p>
<p class="Pp"></p>
<pre>    Params  : IP address, IP version
    Returns : expanded IP address or undef on failure
</pre>
<p class="Pp"><span class="Li">&quot;$ip = ip_expand_address
    ($ip,4);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_get_mask"><a class="permalink" href="#ip_get_mask">ip_get_mask</a></h2>
<p class="Pp">Get IP mask from prefix length.</p>
<p class="Pp"></p>
<pre>    Params  : Prefix length, IP version
    Returns : Binary Mask
</pre>
<p class="Pp"><span class="Li">&quot;$mask = ip_get_mask
  ($len,6);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_last_address_bin"><a class="permalink" href="#ip_last_address_bin">ip_last_address_bin</a></h2>
<p class="Pp">Return the last binary address of a prefix.</p>
<p class="Pp"></p>
<pre>    Params  : First binary IP, prefix length, IP version
    Returns : Binary IP
</pre>
<p class="Pp"><span class="Li">&quot;$lastbin = ip_last_address_bin
    ($ip,$len,6);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_splitprefix"><a class="permalink" href="#ip_splitprefix">ip_splitprefix</a></h2>
<p class="Pp">Split a prefix into IP and prefix length. If it was passed a
    simple IP, it just returns it.</p>
<p class="Pp"></p>
<pre>    Params  : Prefix
    Returns : IP, optionnaly length of prefix
</pre>
<p class="Pp"><span class="Li">&quot;($ip,$len) = ip_splitprefix
    ($prefix)&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_prefix_to_range"><a class="permalink" href="#ip_prefix_to_range">ip_prefix_to_range</a></h2>
<p class="Pp">Get a range of IPs from a prefix.</p>
<p class="Pp"></p>
<pre>    Params  : Prefix, IP version
    Returns : First IP, last IP
</pre>
<p class="Pp"><span class="Li">&quot;($ip1,$ip2) = ip_prefix_to_range
    ($prefix,6);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_bincomp"><a class="permalink" href="#ip_bincomp">ip_bincomp</a></h2>
<p class="Pp">Compare binary Ips with &lt;, &gt;, &lt;=, &gt;=.
  <br/>
   Operators are lt(&lt;), le(&lt;=), gt(&gt;), and ge(&gt;=)</p>
<p class="Pp"></p>
<pre>    Params  : First binary IP, operator, Last binary IP
    Returns : 1 (yes), 0 (no), or undef (problem)
</pre>
<p class="Pp"><span class="Li">&quot;ip_bincomp ($ip1,'lt',$ip2) == 1 or do
    {}&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_binadd"><a class="permalink" href="#ip_binadd">ip_binadd</a></h2>
<p class="Pp">Add two binary IPs.</p>
<p class="Pp"></p>
<pre>    Params  : First binary IP, Last binary IP
    Returns : Binary sum or undef (problem)
</pre>
<p class="Pp"><span class="Li">&quot;$binip = ip_binadd
    ($bin1,$bin2);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_get_prefix_length"><a class="permalink" href="#ip_get_prefix_length">ip_get_prefix_length</a></h2>
<p class="Pp">Get the prefix length for a given range of 2 IPs.</p>
<p class="Pp"></p>
<pre>    Params  : First binary IP, Last binary IP
    Returns : Length of prefix or undef (problem)
</pre>
<p class="Pp"><span class="Li">&quot;$len = ip_get_prefix_length
    ($ip1,$ip2);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_range_to_prefix"><a class="permalink" href="#ip_range_to_prefix">ip_range_to_prefix</a></h2>
<p class="Pp">Return all prefixes between two IPs.</p>
<p class="Pp"></p>
<pre>    Params  : First IP (binary format), Last IP (binary format), IP version
    Returns : List of Prefixes or undef (problem)
</pre>
<p class="Pp">The prefixes returned have the form q.q.q.q/nn.</p>
<p class="Pp"><span class="Li">&quot;@prefix = ip_range_to_prefix
    ($ip1,$ip2,6);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_compress_v4_prefix"><a class="permalink" href="#ip_compress_v4_prefix">ip_compress_v4_prefix</a></h2>
<p class="Pp">Compress an IPv4 Prefix.</p>
<p class="Pp"></p>
<pre>    Params  : IP, Prefix length
    Returns : Compressed Prefix
</pre>
<p class="Pp"><span class="Li">&quot;$ip = ip_compress_v4_prefix ($ip,
    $len);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_compress_address"><a class="permalink" href="#ip_compress_address">ip_compress_address</a></h2>
<p class="Pp">Compress an IPv6 address. Just returns the IP if it is an
  IPv4.</p>
<p class="Pp"></p>
<pre>    Params  : IP, IP version
    Returns : Compressed IP or undef (problem)
</pre>
<p class="Pp"><span class="Li">&quot;$ip = ip_compress_adress ($ip,
    $version);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_is_overlap"><a class="permalink" href="#ip_is_overlap">ip_is_overlap</a></h2>
<p class="Pp">Check if two ranges of IPs overlap.</p>
<p class="Pp"></p>
<pre>    Params  : Four binary IPs (begin of range 1,end1,begin2,end2), IP version
        $IP_PARTIAL_OVERLAP (ranges overlap) 
        $IP_NO_OVERLAP      (no overlap)
        $IP_A_IN_B_OVERLAP  (range2 contains range1)
        $IP_B_IN_A_OVERLAP  (range1 contains range2)
        $IP_IDENTICAL       (ranges are identical)
        undef               (problem)
</pre>
<p class="Pp"><span class="Li">&quot;(ip_is_overlap($rb1,$re1,$rb2,$re2,4) eq
    $IP_A_IN_B_OVERLAP) and do {};&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_get_embedded_ipv4"><a class="permalink" href="#ip_get_embedded_ipv4">ip_get_embedded_ipv4</a></h2>
<p class="Pp">Get an IPv4 embedded in an IPv6 address</p>
<p class="Pp"></p>
<pre>    Params  : IPv6
    Returns : IPv4 string or undef (not found)
</pre>
<p class="Pp"><span class="Li">&quot;$ip4 =
  ip_get_embedded($ip6);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_check_mask"><a class="permalink" href="#ip_check_mask">ip_check_mask</a></h2>
<p class="Pp">Check the validity of a binary IP mask</p>
<p class="Pp"></p>
<pre>    Params  : Mask
    Returns : 1 or undef (invalid)
</pre>
<p class="Pp"><span class="Li">&quot;ip_check_mask($binmask) or do
    {};&quot;</span></p>
<p class="Pp">Checks if mask has only 1s followed by 0s.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_aggregate"><a class="permalink" href="#ip_aggregate">ip_aggregate</a></h2>
<p class="Pp">Aggregate 2 ranges of binary IPs</p>
<p class="Pp"></p>
<pre>    Params  : 1st range (1st IP, Last IP), last range (1st IP, last IP), IP version
    Returns : prefix or undef (invalid)
</pre>
<p class="Pp"><span class="Li">&quot;$prefix = ip_aggregate
    ($bip1,$eip1,$bip2,$eip2) || die ...&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_iptypev4"><a class="permalink" href="#ip_iptypev4">ip_iptypev4</a></h2>
<p class="Pp">Return the type of an IPv4 address.</p>
<p class="Pp"></p>
<pre>    Params:  binary IP
    Returns: type as of the following table or undef (invalid ip)
</pre>
<p class="Pp">See RFC 5735 and RFC 6598</p>
<p class="Pp">Address&#x00A0;Block&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Present&#x00A0;Use&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reference
    -------------------------------------------------------------------
    0.0.0.0/8&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&quot;This&quot;&#x00A0;Network&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;1122&#x00A0;PRIVATE
    10.0.0.0/8&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Private-Use&#x00A0;Networks&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;1918&#x00A0;PRIVATE
    100.64.0.0/10&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;CGN&#x00A0;Shared&#x00A0;Address&#x00A0;Space&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;6598&#x00A0;SHARED
    127.0.0.0/8&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Loopback&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;1122&#x00A0;LOOPBACK
    169.254.0.0/16&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Link&#x00A0;Local&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;3927&#x00A0;LINK-LOCAL
    172.16.0.0/12&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Private-Use&#x00A0;Networks&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;1918&#x00A0;PRIVATE
    192.0.0.0/24&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;IETF&#x00A0;Protocol&#x00A0;Assignments&#x00A0;&#x00A0;RFC&#x00A0;5736&#x00A0;RESERVED
    192.0.2.0/24&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;TEST-NET-1&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;5737&#x00A0;TEST-NET
    192.88.99.0/24&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;6to4&#x00A0;Relay&#x00A0;Anycast&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;3068&#x00A0;6TO4-RELAY
    192.168.0.0/16&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Private-Use&#x00A0;Networks&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;1918&#x00A0;PRIVATE
    198.18.0.0/15&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Network&#x00A0;Interconnect
    &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Device&#x00A0;Benchmark&#x00A0;Testing&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;2544&#x00A0;RESERVED
    198.51.100.0/24&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;TEST-NET-2&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;5737&#x00A0;TEST-NET
    203.0.113.0/24&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;TEST-NET-3&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;5737&#x00A0;TEST-NET
    224.0.0.0/4&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Multicast&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;3171&#x00A0;MULTICAST
    240.0.0.0/4&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;for&#x00A0;Future&#x00A0;Use&#x00A0;&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;1112&#x00A0;RESERVED
    255.255.255.255/32&#x00A0;&#x00A0;Limited&#x00A0;Broadcast&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;919&#x00A0;&#x00A0;BROADCAST
    &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;RFC&#x00A0;922</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_iptypev6"><a class="permalink" href="#ip_iptypev6">ip_iptypev6</a></h2>
<p class="Pp">Return the type of an IPv6 address.</p>
<p class="Pp"></p>
<pre>    Params:  binary ip
    Returns: type as of the following table or undef (invalid)
</pre>
<p class="Pp">See IANA Internet Protocol Version 6 Address Space
    &lt;http://www.iana.org/assignments/ipv6-address-space/ipv6-address-space.txt&gt;
    and IANA IPv6 Special Purpose Address Registry
    &lt;http://www.iana.org/assignments/iana-ipv6-special-registry/iana-ipv6-special-registry.txt&gt;</p>
<p class="Pp">Prefix&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Allocation&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reference
    -------------------------------------------------------------
    0000::/8&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;RESERVED
    0100::/8&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;RESERVED
    0200::/7&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4048]&#x00A0;RESERVED
    0400::/6&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;RESERVED
    0800::/5&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;RESERVED
    1000::/4&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;RESERVED
    2000::/3&#x00A0;&#x00A0;&#x00A0;&#x00A0;Global&#x00A0;Unicast&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;GLOBAL-UNICAST
    4000::/3&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;RESERVED
    6000::/3&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;RESERVED
    8000::/3&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;RESERVED
    A000::/3&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;RESERVED
    C000::/3&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;RESERVED
    E000::/4&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;RESERVED
    F000::/5&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;RESERVED
    F800::/6&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;RESERVED
    FC00::/7&#x00A0;&#x00A0;&#x00A0;&#x00A0;Unique&#x00A0;Local&#x00A0;Unicast&#x00A0;[RFC4193]&#x00A0;UNIQUE-LOCAL-UNICAST
    FE00::/9&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;RESERVED
    FE80::/10&#x00A0;&#x00A0;&#x00A0;Link&#x00A0;Local&#x00A0;Unicast&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;LINK-LOCAL-UNICAST
    FEC0::/10&#x00A0;&#x00A0;&#x00A0;Reserved&#x00A0;by&#x00A0;IETF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC3879]&#x00A0;RESERVED
    FF00::/8&#x00A0;&#x00A0;&#x00A0;&#x00A0;Multicast&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;MULTICAST</p>
<p class="Pp">Prefix&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Assignment&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Reference
    ---------------------------------------------------------------------
    ::1/128&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Loopback&#x00A0;Address&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;UNSPECIFIED
    ::/128&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Unspecified&#x00A0;Address&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;LOOPBACK
    ::FFFF:0:0/96&#x00A0;&#x00A0;&#x00A0;IPv4-mapped&#x00A0;Address&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;IPV4MAP
    0100::/64&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Discard-Only&#x00A0;Prefix&#x00A0;&#x00A0;&#x00A0;[RFC6666]&#x00A0;DISCARD
    2001:0000::/32&#x00A0;&#x00A0;TEREDO&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4380]&#x00A0;TEREDO
    2001:0002::/48&#x00A0;&#x00A0;BMWG&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC5180]&#x00A0;BMWG
    2001:db8::/32&#x00A0;&#x00A0;&#x00A0;Documentation&#x00A0;Prefix&#x00A0;&#x00A0;[RFC3849]&#x00A0;DOCUMENTATION
    2001:10::/28&#x00A0;&#x00A0;&#x00A0;&#x00A0;ORCHID&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4843]&#x00A0;ORCHID
    2002::/16&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;6to4&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC3056]&#x00A0;6TO4
    FC00::/7&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Unique-Local&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4193]&#x00A0;UNIQUE-LOCAL-UNICAST
    FE80::/10&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Linked-Scoped&#x00A0;Unicast&#x00A0;[RFC4291]&#x00A0;LINK-LOCAL-UNICAST
    FF00::/8&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Multicast&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;[RFC4291]&#x00A0;MULTICAST</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_iptype"><a class="permalink" href="#ip_iptype">ip_iptype</a></h2>
<p class="Pp">Return the type of an IP (Public, Private, Reserved)</p>
<p class="Pp"></p>
<pre>    Params  : Binary IP to test, IP version (defaults to 6)
    Returns : type (see ip_iptypev4 and ip_iptypev6 for details) or undef (invalid)
</pre>
<p class="Pp"><span class="Li">&quot;$type = ip_iptype ($ip);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_check_prefix"><a class="permalink" href="#ip_check_prefix">ip_check_prefix</a></h2>
<p class="Pp">Check the validity of a prefix</p>
<p class="Pp"></p>
<pre>    Params  : binary IP, length of prefix, IP version
    Returns : 1 or undef (invalid)
</pre>
<p class="Pp">Checks if the variant part of a prefix only has 0s, and the length
    is correct.</p>
<p class="Pp"><span class="Li">&quot;ip_check_prefix ($ip,$len,$ipv) or do
    {};&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_reverse"><a class="permalink" href="#ip_reverse">ip_reverse</a></h2>
<p class="Pp">Get a reverse name from a prefix</p>
<p class="Pp"></p>
<pre>    Params  : IP, length of prefix, IP version
    Returns : Reverse name or undef (error)
</pre>
<p class="Pp"><span class="Li">&quot;$reverse = ip_reverse
  ($ip);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_normalize"><a class="permalink" href="#ip_normalize">ip_normalize</a></h2>
<p class="Pp">Normalize data to a range/prefix of IP addresses</p>
<p class="Pp"></p>
<pre>    Params  : Data String (Single IP, Range, Prefix)
    Returns : ip1, ip2 (if range/prefix) or undef (error)
</pre>
<p class="Pp"><span class="Li">&quot;($ip1,$ip2) = ip_normalize
    ($data);&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="ip_auth"><a class="permalink" href="#ip_auth">ip_auth</a></h2>
<p class="Pp">Return IP authority information from the IP::Authority module</p>
<p class="Pp"></p>
<pre>    Params  : IP, version
    Returns : Auth info (RI for RIPE, AR for ARIN, etc)
</pre>
<p class="Pp"><span class="Li">&quot;$auth = ip_auth ($ip,4);&quot;</span></p>
<p class="Pp">Note: IPv4 only</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">The Math::BigInt library is needed for functions that use
    integers. These are ip_inttobin, ip_bintoint, and the size method. In a next
    version, Math::BigInt will become optionnal.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp">Manuel Valente &lt;manuel.valente@gmail.com&gt;.</p>
<p class="Pp">Original IPv4 code by Monica Cortes Sack
  &lt;mcortes@ripe.net&gt;.</p>
<p class="Pp">Original IPv6 code by Lee Wilmot &lt;lee@ripe.net&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BASED_ON"><a class="permalink" href="#BASED_ON">BASED
  ON</a></h1>
<p class="Pp">ipv4pack.pm, iplib.pm, iplibncc.pm.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>perl</b>(1), IP::Authority</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2012-11-28</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

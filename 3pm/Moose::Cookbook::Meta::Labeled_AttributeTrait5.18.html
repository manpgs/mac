<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Moose::Cookbook::Meta::Labeled_AttributeTrait(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Moose::Cookbook::Meta::Labeled_AttributeTrait(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Moose::Cookbook::Meta::Labeled_AttributeTrait(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Moose::Cookbook::Meta::Labeled_AttributeTrait - Labels implemented
    via attribute traits</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 2.1202</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
  package MyApp::Meta::Attribute::Trait::Labeled;
  use Moose::Role;
  Moose::Util::meta_attribute_alias('Labeled');

  has label =&gt; (
      is        =&gt; 'rw',
      isa       =&gt; 'Str',
      predicate =&gt; 'has_label',
  );

  package MyApp::Website;
  use Moose;

  has url =&gt; (
      traits =&gt; [qw/Labeled/],
      is     =&gt; 'rw',
      isa    =&gt; 'Str',
      label  =&gt; &quot;The site's URL&quot;,
  );

  has name =&gt; (
      is  =&gt; 'rw',
      isa =&gt; 'Str',
  );

  sub dump {
      my $self = shift;

      my $meta = $self-&gt;meta;

      my $dump = '';

      for my $attribute ( map { $meta-&gt;get_attribute($_) }
          sort $meta-&gt;get_attribute_list ) {

          if (   $attribute-&gt;does('MyApp::Meta::Attribute::Trait::Labeled')
              &amp;&amp; $attribute-&gt;has_label ) {
              $dump .= $attribute-&gt;label;
          }
          else {
              $dump .= $attribute-&gt;name;
          }

          my $reader = $attribute-&gt;get_read_method;
          $dump .= &quot;: &quot; . $self-&gt;$reader . &quot;\n&quot;;
      }

      return $dump;
  }

  package main;

  my $app = MyApp::Website-&gt;new( url =&gt; &quot;http://google.com&quot;, name =&gt; &quot;Google&quot; );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SUMMARY"><a class="permalink" href="#SUMMARY">SUMMARY</a></h1>
<p class="Pp">In this recipe, we begin to delve into the wonder of
    meta-programming. Some readers may scoff and claim that this is the arena of
    only the most twisted Moose developers. Absolutely not! Any sufficiently
    twisted developer can benefit greatly from going more meta.</p>
<p class="Pp">Our goal is to allow each attribute to have a human-readable
    &quot;label&quot; attached to it. Such labels would be used when showing
    data to an end user. In this recipe we label the
    <span class="Li">&quot;url&quot;</span> attribute with &quot;The site's
    URL&quot; and create a simple method showing how to use that label.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="META-ATTRIBUTE_OBJECTS"><a class="permalink" href="#META-ATTRIBUTE_OBJECTS">META-ATTRIBUTE
  OBJECTS</a></h1>
<p class="Pp">All the attributes of a Moose-based object are actually objects
    themselves. These objects have methods and attributes. Let's look at a
    concrete example.</p>
<p class="Pp"></p>
<pre>
  has 'x' =&gt; ( isa =&gt; 'Int', is =&gt; 'ro' );
  has 'y' =&gt; ( isa =&gt; 'Int', is =&gt; 'rw' );
</pre>
<p class="Pp">Internally, the metaclass for
    <span class="Li">&quot;Point&quot;</span> has two Moose::Meta::Attribute
    objects. There are several methods for getting meta-attributes out of a
    metaclass, one of which is
    <span class="Li">&quot;get_attribute_list&quot;</span>. This method is
    called on the metaclass object.</p>
<p class="Pp">The <span class="Li">&quot;get_attribute_list&quot;</span> method
    returns a list of attribute names. You can then use
    <span class="Li">&quot;get_attribute&quot;</span> to get the
    Moose::Meta::Attribute object itself.</p>
<p class="Pp">Once you have this meta-attribute object, you can call methods on
    it like this:</p>
<p class="Pp"></p>
<pre>
  print $point-&gt;meta-&gt;get_attribute('x')-&gt;type_constraint;
     =&gt; Int
</pre>
<p class="Pp">To add a label to our attributes there are two steps. First, we
    need a new attribute metaclass trait that can store a label for an
    attribute. Second, we need to apply that trait to our attributes.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="TRAITS"><a class="permalink" href="#TRAITS">TRAITS</a></h1>
<p class="Pp">Roles that apply to metaclasses have a special name: traits. Don't
    let the change in nomenclature fool you, <b>traits are just roles</b>.</p>
<p class="Pp">&quot;has&quot; in Moose allows you to pass a
    <span class="Li">&quot;traits&quot;</span> parameter for an attribute. This
    parameter takes a list of trait names which are composed into an anonymous
    metaclass, and that anonymous metaclass is used for the attribute.</p>
<p class="Pp">Yes, we still have lots of metaclasses in the background, but
    they're managed by Moose for you.</p>
<p class="Pp">Traits can do anything roles can do. They can add or refine
    attributes, wrap methods, provide more methods, define an interface, etc.
    The only difference is that you're now changing the attribute metaclass
    instead of a user-level class.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DISSECTION"><a class="permalink" href="#DISSECTION">DISSECTION</a></h1>
<p class="Pp">We start by creating a package for our trait.</p>
<p class="Pp"></p>
<pre>
  package MyApp::Meta::Attribute::Trait::Labeled;
  use Moose::Role;

  has label =&gt; (
      is        =&gt; 'rw',
      isa       =&gt; 'Str',
      predicate =&gt; 'has_label',
  );
</pre>
<p class="Pp">You can see that a trait is just a Moose::Role. In this case, our
    role contains a single attribute, <span class="Li">&quot;label&quot;</span>.
    Any attribute which does this trait will now have a label.</p>
<p class="Pp">We also register our trait with Moose:</p>
<p class="Pp"></p>
<pre>
  Moose::Util::meta_attribute_alias('Labeled');
</pre>
<p class="Pp">This allows Moose to find our trait by the short name
    <span class="Li">&quot;Labeled&quot;</span> when passed to the
    <span class="Li">&quot;traits&quot;</span> attribute option, rather than
    requiring the full package name to be specified.</p>
<p class="Pp">Finally, we pass our trait when defining an attribute:</p>
<p class="Pp"></p>
<pre>
  has url =&gt; (
      traits =&gt; [qw/Labeled/],
      is     =&gt; 'rw',
      isa    =&gt; 'Str',
      label  =&gt; &quot;The site's URL&quot;,
  );
</pre>
<p class="Pp">The <span class="Li">&quot;traits&quot;</span> parameter contains
    a list of trait names. Moose will build an anonymous attribute metaclass
    from these traits and use it for this attribute.</p>
<p class="Pp">The reason that we can pass the name
    <span class="Li">&quot;Labeled&quot;</span>, instead of
    <span class="Li">&quot;MyApp::Meta::Attribute::Trait::Labeled&quot;</span>,
    is because of the
    <span class="Li">&quot;register_implementation&quot;</span> code we touched
    on previously.</p>
<p class="Pp">When you pass a metaclass to
    <span class="Li">&quot;has&quot;</span>, it will take the name you provide
    and prefix it with
    <span class="Li">&quot;Moose::Meta::Attribute::Custom::Trait::&quot;</span>.
    Then it calls <span class="Li">&quot;register_implementation&quot;</span> in
    the package. In this case, that means Moose ends up calling
    <span class="Li">&quot;Moose::Meta::Attribute::Custom::Trait::Labeled::register_implementation&quot;</span>.</p>
<p class="Pp">If this function exists, it should return the <i>real</i> trait's
    package name. This is exactly what our code does, returning
    <span class="Li">&quot;MyApp::Meta::Attribute::Trait::Labeled&quot;</span>.
    This is a little convoluted, and if you don't like it, you can always use
    the fully-qualified name.</p>
<p class="Pp">We can access this meta-attribute and its label like this:</p>
<p class="Pp"></p>
<pre>
  $website-&gt;meta-&gt;get_attribute('url')-&gt;label()

  MyApp::Website-&gt;meta-&gt;get_attribute('url')-&gt;label()
</pre>
<p class="Pp">We also have a regular attribute,
    <span class="Li">&quot;name&quot;</span>:</p>
<p class="Pp"></p>
<pre>
  has name =&gt; (
      is  =&gt; 'rw',
      isa =&gt; 'Str',
  );
</pre>
<p class="Pp">Finally, we have a <span class="Li">&quot;dump&quot;</span>
    method, which creates a human-readable representation of a
    <span class="Li">&quot;MyApp::Website&quot;</span> object. It will use an
    attribute's label if it has one.</p>
<p class="Pp"></p>
<pre>
  sub dump {
      my $self = shift;

      my $meta = $self-&gt;meta;

      my $dump = '';

      for my $attribute ( map { $meta-&gt;get_attribute($_) }
          sort $meta-&gt;get_attribute_list ) {

          if (   $attribute-&gt;does('MyApp::Meta::Attribute::Trait::Labeled')
              &amp;&amp; $attribute-&gt;has_label ) {
              $dump .= $attribute-&gt;label;
          }
</pre>
<p class="Pp">This is a bit of defensive code. We cannot depend on every
    meta-attribute having a label. Even if we define one for every attribute in
    our class, a subclass may neglect to do so. Or a superclass could add an
    attribute without a label.</p>
<p class="Pp">We also check that the attribute has a label using the predicate
    we defined. We could instead make the label
    <span class="Li">&quot;required&quot;</span>. If we have a label, we use it,
    otherwise we use the attribute name:</p>
<p class="Pp"></p>
<pre>
          else {
              $dump .= $attribute-&gt;name;
          }

          my $reader = $attribute-&gt;get_read_method;
          $dump .= &quot;: &quot; . $self-&gt;$reader . &quot;\n&quot;;
      }

      return $dump;
  }
</pre>
<p class="Pp">The <span class="Li">&quot;get_read_method&quot;</span> is part of
    the Moose::Meta::Attribute API. It returns the name of a method that can
    read the attribute's value, <i>when</i> <i>called on the real object</i>
    (don't call this on the meta-attribute).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONCLUSION"><a class="permalink" href="#CONCLUSION">CONCLUSION</a></h1>
<p class="Pp">You might wonder why you'd bother with all this. You could just
    hardcode &quot;The Site's URL&quot; in the
    <span class="Li">&quot;dump&quot;</span> method. But we want to avoid
    repetition. If you need the label once, you may need it elsewhere, maybe in
    the <span class="Li">&quot;as_form&quot;</span> method you write next.</p>
<p class="Pp">Associating a label with an attribute just makes sense! The label
    is a piece of information <i>about</i> the attribute.</p>
<p class="Pp">It's also important to realize that this was a trivial example.
    You can make much more powerful metaclasses that <i>do</i> things, as
    opposed to just storing some more information. For example, you could
    implement a metaclass that expires attributes after a certain amount of
    time:</p>
<p class="Pp"></p>
<pre>
   has site_cache =&gt; (
       traits        =&gt; ['TimedExpiry'],
       expires_after =&gt; { hours =&gt; 1 },
       refresh_with  =&gt; sub { get( $_[0]-&gt;url ) },
       isa           =&gt; 'Str',
       is            =&gt; 'ro',
   );
</pre>
<p class="Pp">The sky's the limit!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Stevan Little &lt;stevan.little@iinteractive.com&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
  <li>Shawn M Moore &lt;code@sartak.org&gt;</li>
  <li>XXXX XXX'XX (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Florian Ragwitz &lt;rafl@debian.org&gt;</li>
  <li>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</li>
  <li>Chris Prather &lt;chris@prather.org&gt;</li>
  <li>Matt S Trout &lt;mst@shadowcat.co.uk&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2006 by Infinity Interactive,
  Inc..</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-19</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

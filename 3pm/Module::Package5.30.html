<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Module::Package(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Module::Package(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Module::Package(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">In your <span class="Li">&quot;Makefile.PL&quot;</span>:</p>
<p class="Pp"></p>
<pre>    use inc::Module::Package;
</pre>
<p class="Pp">or one of these invocations:</p>
<p class="Pp"></p>
<pre>    # These two are functionally the same as above:
    use inc::Module::Package ':basic';
    use inc::Module::Package 'Plugin:basic';
    # With Module::Package::Catalyst plugin options
    use inc::Module::Package 'Catalyst';
    # With Module::Package::Catalyst::common inline plugin class
    use inc::Module::Package 'Catalyst:common';
    # Pass options to the Module::Package::Ingy::modern constructor
    use inc::Module::Package 'Ingy:modern',
        option1 =&gt; 'value1',
        option2 =&gt; 'value2';
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module is a dropin replacement for Module::Install. It does
    everything Module::Install does, but just a bit better.</p>
<p class="Pp">Actually this module is simply a wrapper around Module::Install.
    It attempts to drastically reduce what goes in a Makefile.PL, while at the
    same time, fixing many of the problems that people have had with
    Module::Install (and other module frameworks) over the years.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PROPAGANDA"><a class="permalink" href="#PROPAGANDA">PROPAGANDA</a></h1>
<p class="Pp">Module::Install took Makefile.PL authoring from a black art to a
    small set of powerful and reusable instructions. It allowed packaging gurus
    to take their fancy tricks and make them into one liners for the rest of
  us.</p>
<p class="Pp">As the number of plugins has grown over the years, using
    Module::Install has itself become a bit of a black art. It's become hard to
    know all the latest tricks, put them in the correct order, and make sure you
    always use the correct sets for your various Perl modules.</p>
<p class="Pp">Added to this is the fact that there are a few problems in
    Module::Install design and general usage that are hard to fix and deploy
    with certainty that it will work in all cases.</p>
<p class="Pp">This is where Module::Package steps in. Module::Package is the
    next logical step in Makefile.PL authoring. It allows gurus to create well
    tested sets of Module::Install directives, and lets the rest of us use
    Makefile.PLs that are one line long. For example:</p>
<p class="Pp"></p>
<pre>    use inc::Module::Package 'Catalyst:widget';
</pre>
<p class="Pp">could be the one line Makefile.PL for a Catalyst widget (whatever
    that is) module distribution. Assuming someone creates a module called
    Module::Package::Catalyst, with an inline class called
    Module::Package::Catalyst::widget that inherited from
    Module::Package::Plugin.</p>
<p class="Pp">Module::Package is pragmatic. Even though you can do everything in
    one line, you are still able to make any Module::Install calls as usual.
    Also you can pass parameters to the Module::Package plugin.</p>
<p class="Pp"></p>
<pre>    use inc::Module::Package 'Catalyst:widget',
        deps_list =&gt; 0,
        some_cataylst_thing =&gt; '...';
    # All Module::Install plugins still work!
    requires 'Some::Module' =&gt; 3.14;
</pre>
<p class="Pp">This allows Module::Package::Catalyst to be configurable, even on
    the properties like <span class="Li">&quot;deps_list&quot;</span> that are
    inherited from Module::Package::Plugin.</p>
<p class="Pp">The point here is that with Module::Package, module packaging just
    got a whole lot more powerful and simple. A rare combination!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FEATURES"><a class="permalink" href="#FEATURES">FEATURES</a></h1>
<p class="Pp">Module::Package has many advantages over vanilla
  Module::Install.</p>
<section class="Ss">
<h2 class="Ss" id="Smaller_Makefile.PL_Files"><a class="permalink" href="#Smaller_Makefile.PL_Files">Smaller
  Makefile.PL Files</a></h2>
<p class="Pp">In the majority of cases you can reduce your Makefile.PL to a
    single command. The core Module::Package invokes the Module::Install plugins
    that it thinks you want. You can also name the Module::Package plugin that
    does exactly the plugins you want.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Reduces_Module::Install_Bloat"><a class="permalink" href="#Reduces_Module::Install_Bloat">Reduces
  Module::Install Bloat</a></h2>
<p class="Pp">Somewhere Module::Install development went awry, and allowed
    modules that only have useful code for an author, to be bundled into a
    distribution. Over time, this has created a lot of wasted space on CPAN
    mirrors. Module::Package fixes this.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Collaborator_Plugin_Discovery"><a class="permalink" href="#Collaborator_Plugin_Discovery">Collaborator
  Plugin Discovery</a></h2>
<p class="Pp">An increasing problem with Module::Install is that when people
    check out your module source from a repository, they don't know which
    Module::Install plugin modules you have used. That's because the Makefile.PL
    only requires the function names, not the module names that they come
  from.</p>
<p class="Pp">Many people have realized this problem, and worked around it in
    various suboptimal ways. Module::Package manages this problem for you.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Feature_Grouping_and_Reuse"><a class="permalink" href="#Feature_Grouping_and_Reuse">Feature
  Grouping and Reuse</a></h2>
<p class="Pp">Module::Install has lots of plugins. Although it is possible with
    plain Module::Install, nobody seems to make plugins that group other
    plugins. This also might introduce subtle problems of using groups with
    other groups.</p>
<p class="Pp">Module::Package has object oriented plugins whose main purpose is
    to create these groups. They inherit base functionality, subclass it to
    their design goals and can define options for the user to tweak how they
    will operate.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="USAGE"><a class="permalink" href="#USAGE">USAGE</a></h1>
<p class="Pp">The basic anatomy of a Makefile.PL call to Module::Package is:</p>
<p class="Pp"></p>
<pre>    use inc::Module::Package 'PluginName:flavor &lt;version&gt;',
        $option1 =&gt; $value1;
</pre>
<p class="Pp">The <span class="Li">&quot;inc::Module::Package&quot;</span> part
    uses the Module::Install <span class="Li">&quot;inc&quot;</span>
    bootstrapping trick.</p>
<p class="Pp"><span class="Li">&quot;PluginName:flavor&quot;</span> (note the
    single ':') resolves to the inline class
    <span class="Li">&quot;Module::Package::PluginName::flavor&quot;</span>,
    within the module
    <span class="Li">&quot;Module::Package::PluginName&quot;</span>.
    Module::Package::PluginName::flavor must be a subclass of
    Module::Package::Plugin.</p>
<p class="Pp">An optional version can be used after the plugin name.</p>
<p class="Pp">Optional key/value pairs can follow the Plugin specification. They
    are used to pass information to the plugin. See Plugin docs for more
    details.</p>
<p class="Pp">If <span class="Li">&quot;:flavor&quot;</span> is omitted, the
    class Module::Package::PluginName is used. The idea is that you can create a
    single module with many different plugin styles.</p>
<p class="Pp">If <span class="Li">&quot;PluginName&quot;</span> is omitted, then
    <span class="Li">&quot;:flavor&quot;</span> is used against
    Module::Package::Plugin. These are a set of common plugin classes that you
    can use.</p>
<p class="Pp">If <span class="Li">&quot;PluginName:flavor&quot;</span> is
    omitted altogether, it is the same as saying 'Plugin:basic'. Note that you
    need to specify the ':basic' plugin if you want to also pass it options.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="STATUS"><a class="permalink" href="#STATUS">STATUS</a></h1>
<p class="Pp">This is still an early release. We are still shaking out the bugs.
    You might want to hold off for a bit longer before using Module::Package for
    important modules.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2011-10-06</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

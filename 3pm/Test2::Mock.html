<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Test2::Mock(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Test2::Mock(3)</td>
    <td class="head-vol"><a href=".">User Contributed Perl Documentation</a></td>
    <td class="head-rtitle">Test2::Mock(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Test2::Mock - Module for managing mocked classes and
  instances.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module lets you add and override methods for any package
    temporarily. When the instance is destroyed it will restore the package to
    its original state.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use Test2::Mock;
    use MyClass;
    my $mock = Test2::Mock-&gt;new(
        track =&gt; $BOOL, # enable call tracking if desired
        class =&gt; 'MyClass',
        override =&gt; [
            name =&gt; sub { 'fred' },
            ...
        ],
        add =&gt; [
            is_mocked =&gt; sub { 1 }
            ...
        ],
        ...
    );
    # Unmock the 'name' sub
    $mock-&gt;restore('name');
    ...
    $mock = undef; # Will remove all the mocking
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="CONSTRUCTION"><a class="permalink" href="#CONSTRUCTION">CONSTRUCTION</a></h1>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<dl class="Bl-tag">
  <dt>$mock = Test2::Mock-&gt;new(class =&gt; $CLASS, ...)</dt>
  <dd>This will create a new instance of Test2::Mock that manages mocking for
      the specified <span class="Li">$CLASS</span>.
    <p class="Pp">Any <span class="Li">&quot;Test2::Mock&quot;</span> method can
        be used as a constructor argument, each should be followed by an
        arrayref of arguments to be used within the method. For instance the
        <span class="Li">&quot;add()&quot;</span> method:</p>
    <p class="Pp"></p>
    <pre>    my $mock = Test2::Mock-&gt;new(
        class =&gt; 'AClass',
        add =&gt; [foo =&gt; sub { 'foo' }],
    );
    </pre>
    <p class="Pp">is identical to this:</p>
    <p class="Pp"></p>
    <pre>    my $mock = Test2::Mock-&gt;new(
        class =&gt; 'AClass',
    );
    $mock-&gt;add(foo =&gt; sub { 'foo' });
    </pre>
  </dd>
  <dt>$mock-&gt;track($bool)</dt>
  <dd>Turn tracking on or off. Any sub added/overridden/set when tracking is on
      will log every call in a hash retrievable via
      <span class="Li">&quot;$mock-&gt;tracking&quot;</span>. Changing the
      tracking toggle will not affect subs already altered, but will affect any
      additional alterations.</dd>
  <dt>$hashref = $mock-&gt;sub_tracking</dt>
  <dd>The tracking data looks like this:
    <p class="Pp"></p>
    <pre>    {
        sub_name =&gt; [
            {sub_name =&gt; $sub_name, sub_ref =&gt; $mock_subref, args =&gt; [... copy of @_ from the call ... ]},
            ...,
            ...,
        ],
    }
    </pre>
    <p class="Pp">Unlike call_tracking, this lists all calls by sub, so you can
        choose to only look at the sub specific calls.</p>
    <p class="Pp"><b>Please note:</b> The hashref items with the subname and
        args are shared with call_tracking, modifying one modifies the other, so
        copy first!</p>
  </dd>
  <dt>$arrayref = $mock-&gt;call_tracking</dt>
  <dd>The tracking data looks like this:
    <p class="Pp"></p>
    <pre>    [
        {sub_name =&gt; $sub_name, sub_ref =&gt; $mock_subref, args =&gt; [... copy of @_ from the call ... ]},
        ...,
        ...,
    ]
    </pre>
    <p class="Pp">Unlike sub_tracking this lists all calls to any mocked sub, in
        the order they were called. To filter by sub use sub_tracking.</p>
    <p class="Pp"><b>Please note:</b> The hashref items with the subname and
        args are shared with sub_tracking, modifying one modifies the other, so
        copy first!</p>
  </dd>
  <dt>$mock-&gt;<b>clear_sub_tracking()</b></dt>
  <dd></dd>
  <dt>$mock-&gt;clear_sub_tracking(\@subnames)</dt>
  <dd>Clear tracking data. With no arguments ALL tracking data is cleared. When
      arguments are provided then only those specific keys will be cleared.</dd>
  <dt>$mock-&gt;<b>clear_call_tracking()</b></dt>
  <dd>Clear all items from call_tracking.</dd>
  <dt>$mock-&gt;add('symbol' =&gt; ..., 'symbol2' =&gt; ...)</dt>
  <dd></dd>
  <dt>$mock-&gt;override('symbol1' =&gt; ..., 'symbol2' =&gt; ...)</dt>
  <dd></dd>
  <dt>$mock-&gt;set('symbol1' =&gt; ..., 'symbol2' =&gt; ...)</dt>
  <dd><span class="Li">&quot;add()&quot;</span> and
      <span class="Li">&quot;override()&quot;</span> are the primary ways to
      add/modify methods for a class. Both accept the exact same type of
      arguments. The difference is that
      <span class="Li">&quot;override&quot;</span> will fail unless the symbol
      you are overriding already exists, <span class="Li">&quot;add&quot;</span>
      on the other hand will fail if the symbol does already exist.
    <p class="Pp"><span class="Li">&quot;set()&quot;</span> was more recently
        added for cases where you may not know if the sub already exists. These
        cases are rare, and set should be avoided (think of it like 'no
        strict'). However there are valid use cases, so it was added.</p>
    <p class="Pp"><b>Note:</b> Think of override as a push operation. If you
        call override on the same symbol multiple times it will track that. You
        can use <span class="Li">&quot;restore()&quot;</span> as a pop operation
        to go back to the previous mock.
        <span class="Li">&quot;reset&quot;</span> can be used to remove all the
        mocking for a symbol.</p>
    <p class="Pp">Arguments must be a symbol name, with optional sigil, followed
        by a new specification of the symbol. If no sigil is specified then
        '&amp;' (sub) is assumed. A simple example of overriding a sub:</p>
    <p class="Pp"></p>
    <pre>    $mock-&gt;override(foo =&gt; sub { 'overridden foo' });
    my $val = $class-&gt;foo; # Runs our override
    # $val is now set to 'overridden foo'
    </pre>
    <p class="Pp">You can also simply provide a value and it will be wrapped in
        a sub for you:</p>
    <p class="Pp"></p>
    <pre>    $mock-&gt;override( foo =&gt; 'foo' );
    </pre>
    <p class="Pp">The example above will generate a sub that always returns the
        string 'foo'.</p>
    <p class="Pp">There are three *special* values that can be used to generate
        accessors:</p>
    <p class="Pp"></p>
    <pre>    $mock-&gt;add(
        name =&gt; 'rw',   # Generates a read/write accessor
        age  =&gt; 'ro',   # Generates a read only accessor
        size =&gt; 'wo',   # Generates a write only accessor
    );
    </pre>
    <p class="Pp">If you want to have a sub that actually returns one of the
        three special strings, or that returns a coderef, you can use a hashref
        as the spec:</p>
    <p class="Pp"></p>
    <pre>    my $ref = sub { 'my sub' };
    $mock-&gt;add(
        rw_string =&gt; { val =&gt; 'rw' },
        ro_string =&gt; { val =&gt; 'ro' },
        wo_string =&gt; { val =&gt; 'wo' },
        coderef   =&gt; { val =&gt; $ref }, # the coderef method returns $ref each time
    );
    </pre>
    <p class="Pp">You can also override/add other symbol types, such as
      hash:</p>
    <p class="Pp"></p>
    <pre>    package Foo;
    ...
    $mock-&gt;add('%foo' =&gt; {a =&gt; 1});
    print $Foo::foo{a}; # prints '1'
    </pre>
    <p class="Pp">You can also tell mock to deduce the symbol type for the
        add/override from the reference, rules are similar to glob
      assignments:</p>
    <p class="Pp"></p>
    <pre>    $mock-&gt;add(
        -foo =&gt; sub { 'foo' },     # Adds the &amp;foo sub to the package
        -foo =&gt; { foo =&gt; 1 },      # Adds the %foo hash to the package
        -foo =&gt; [ 'f', 'o', 'o' ], # Adds the @foo array to the package
        -foo =&gt; \&quot;foo&quot;,            # Adds the $foo scalar to the package
    );
    </pre>
  </dd>
  <dt>$mock-&gt;restore($SYMBOL)</dt>
  <dd>Restore the symbol to what it was before the last override. If the symbol
      was recently added this will remove it. If the symbol has been overridden
      multiple times this will ONLY restore it to the previous state. Think of
      <span class="Li">&quot;override&quot;</span> as a push operation, and
      <span class="Li">&quot;restore&quot;</span> as the pop operation.</dd>
  <dt>$mock-&gt;reset($SYMBOL)</dt>
  <dd>Remove all mocking of the symbol and restore the original symbol. If the
      symbol was initially added then it will be completely removed.</dd>
  <dt>$mock-&gt;orig($SYMBOL)</dt>
  <dd>This will return the original symbol, before any mocking. For symbols that
      were added this will return undef.</dd>
  <dt>$mock-&gt;current($SYMBOL)</dt>
  <dd>This will return the current symbol.</dd>
  <dt>$mock-&gt;reset_all</dt>
  <dd>Remove all added symbols, and restore all overridden symbols to their
      originals.</dd>
  <dt>$mock-&gt;add_constructor($NAME =&gt; $TYPE)</dt>
  <dd></dd>
  <dt>$mock-&gt;override_constructor($NAME =&gt; $TYPE)</dt>
  <dd>This can be used to inject constructors. The first argument should be the
      name of the constructor. The second argument specifies the constructor
      type.
    <p class="Pp">The <span class="Li">&quot;hash&quot;</span> type is the most
        common, all arguments are used to create a new hash that is blessed.</p>
    <p class="Pp"></p>
    <pre>    hash =&gt; sub  {
        my ($class, %params) = @_;
        return bless \%params, $class;
    };
    </pre>
    <p class="Pp">The <span class="Li">&quot;array&quot;</span> type is similar
        to the hash type, but accepts a list instead of key/value pairs:</p>
    <p class="Pp"></p>
    <pre>    array =&gt; sub {
        my ($class, @params) = @_;
        return bless \@params, $class;
    };
    </pre>
    <p class="Pp">The <span class="Li">&quot;ref&quot;</span> type takes a
        reference and blesses it. This will modify your original input
      argument.</p>
    <p class="Pp"></p>
    <pre>    ref =&gt; sub {
        my ($class, $params) = @_;
        return bless $params, $class;
    };
    </pre>
    <p class="Pp">The <span class="Li">&quot;ref_copy&quot;</span> type will
        copy your reference and bless the copy:</p>
    <p class="Pp"></p>
    <pre>    ref_copy =&gt; sub {
        my ($class, $params) = @_;
        my $type = reftype($params);
        return bless {%$params}, $class
            if $type eq 'HASH';
        return bless [@$params], $class
            if $type eq 'ARRAY';
        croak &quot;Not sure how to construct a '$class' from '$params'&quot;;
    };
    </pre>
  </dd>
  <dt>$mock-&gt;before($NAME, sub { ... })</dt>
  <dd>This will replace the original sub <span class="Li">$NAME</span> with a
      new sub that calls your custom code just before calling the original
      method. The return from your custom sub is ignored. Your sub and the
      original both get the unmodified arguments.</dd>
  <dt>$mock-&gt;after($NAME, sub { ... })</dt>
  <dd>This is similar to before, except your callback runs after the original
      code. The return from your callback is ignored.</dd>
  <dt>$mock-&gt;around($NAME, sub { ... })</dt>
  <dd>This gives you the chance to wrap the original sub:
    <p class="Pp"></p>
    <pre>    $mock-&gt;around(foo =&gt; sub {
        my $orig = shift;
        my $self = shift;
        my (@args) = @_;
        ...
        $self-&gt;$orig(@args);
        ...
        return ...;
    });
    </pre>
    <p class="Pp">The original sub is passed in as the first argument, even
        before <span class="Li">$self</span>. You are responsible for making
        sure your wrapper sub returns the correct thing.</p>
  </dd>
  <dt>$mock-&gt;autoload</dt>
  <dd>This will inject an <span class="Li">&quot;AUTOLOAD&quot;</span> sub into
      the class. This autoload will automatically generate read-write accessors
      for any sub called that does not already exist.</dd>
  <dt>$mock-&gt;block_load</dt>
  <dd>This will prevent the real class from loading until the mock is destroyed.
      This will fail if the class is already loaded. This will let you mock a
      class completely without loading the original module.</dd>
  <dt>$pm_file = $mock-&gt;file</dt>
  <dd>This returns the relative path to the file for the module. This
      corresponds to the <span class="Li">%INC</span> entry.</dd>
  <dt>$bool = $mock-&gt;purge_on_destroy($bool)</dt>
  <dd>When true, this will cause the package stash to be completely obliterated
      when the mock object falls out of scope or is otherwise destroyed. You do
      not normally want this.</dd>
  <dt>$stash = $mock-&gt;stash</dt>
  <dd>This returns the stash for the class being mocked. This is the equivalent
      of:
    <p class="Pp"></p>
    <pre>    my $stash = \%{&quot;${class}\::&quot;};
    </pre>
    <p class="Pp">This saves you from needing to turn off strict.</p>
  </dd>
  <dt>$class = $mock-&gt;class</dt>
  <dd>The class being mocked by this instance.</dd>
  <dt>$p = $mock-&gt;parent</dt>
  <dd>If you mock a class twice the first instance is the parent, the second is
      the child. This prevents the parent from being destroyed before the child,
      which would lead to a very unpleasant situation.</dd>
  <dt>$c = $mock-&gt;child</dt>
  <dd>Returns the child mock, if any.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SOURCE"><a class="permalink" href="#SOURCE">SOURCE</a></h1>
<p class="Pp">The source code repository for Test2-Suite can be found at
    &lt;https://github.com/Test-More/Test2-Suite/&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MAINTAINERS"><a class="permalink" href="#MAINTAINERS">MAINTAINERS</a></h1>
<dl class="Bl-tag">
  <dt id="Chad"><a class="permalink" href="#Chad">Chad Granum
    &lt;exodist@cpan.org&gt;</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<dl class="Bl-tag">
  <dt id="Chad~2"><a class="permalink" href="#Chad~2">Chad Granum
    &lt;exodist@cpan.org&gt;</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 2018 Chad Granum &lt;exodist@cpan.org&gt;.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">See &lt;https://dev.perl.org/licenses/&gt;</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-10-22</td>
    <td class="foot-os"><a href="..">perl v5.34.0</a></td>
  </tr>
</table>
</body>
</html>

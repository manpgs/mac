<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Benchmark(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Benchmark(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Benchmark(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Benchmark - benchmark running times of Perl code</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
    use Benchmark qw(:all) ;

    timethis ($count, &quot;code&quot;);

    # Use Perl code in strings...
    timethese($count, {
        'Name1' =&gt; '...code1...',
        'Name2' =&gt; '...code2...',
    });

    # ... or use subroutine references.
    timethese($count, {
        'Name1' =&gt; sub { ...code1... },
        'Name2' =&gt; sub { ...code2... },
    });

    # cmpthese can be used both ways as well
    cmpthese($count, {
        'Name1' =&gt; '...code1...',
        'Name2' =&gt; '...code2...',
    });

    cmpthese($count, {
        'Name1' =&gt; sub { ...code1... },
        'Name2' =&gt; sub { ...code2... },
    });

    # ...or in two stages
    $results = timethese($count,
        {
            'Name1' =&gt; sub { ...code1... },
            'Name2' =&gt; sub { ...code2... },
        },
        'none'
    );
    cmpthese( $results ) ;

    $t = timeit($count, '...other code...')
    print &quot;$count loops of other code took:&quot;,timestr($t),&quot;\n&quot;;

    $t = countit($time, '...other code...')
    $count = $t-&gt;iters ;
    print &quot;$count loops of other code took:&quot;,timestr($t),&quot;\n&quot;;

    # enable hires wallclock timing if possible
    use Benchmark ':hireswallclock';
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The Benchmark module encapsulates a number of routines to help you
    figure out how long it takes to execute some code.</p>
<p class="Pp">timethis - run a chunk of code several times</p>
<p class="Pp">timethese - run several chunks of code several times</p>
<p class="Pp">cmpthese - print results of timethese as a comparison chart</p>
<p class="Pp">timeit - run a chunk of code and see how long it goes</p>
<p class="Pp">countit - see how many times a chunk of code runs in a given
  time</p>
<section class="Ss">
<h2 class="Ss" id="Methods"><a class="permalink" href="#Methods">Methods</a></h2>
<dl class="Bl-tag">
  <dt id="new"><a class="permalink" href="#new">new</a></dt>
  <dd>Returns the current time. Example:
    <p class="Pp"></p>
    <pre>
    use Benchmark;
    $t0 = Benchmark-&gt;new;
    # ... your code here ...
    $t1 = Benchmark-&gt;new;
    $td = timediff($t1, $t0);
    print &quot;the code took:&quot;,timestr($td),&quot;\n&quot;;
    </pre>
  </dd>
  <dt id="debug"><a class="permalink" href="#debug">debug</a></dt>
  <dd>Enables or disable debugging by setting the
      <span class="Li">$Benchmark::Debug</span> flag:
    <p class="Pp"></p>
    <pre>
    Benchmark-&gt;debug(1);
    $t = timeit(10, ' 5 ** $Global ');
    Benchmark-&gt;debug(0);
    </pre>
  </dd>
  <dt id="iters"><a class="permalink" href="#iters">iters</a></dt>
  <dd>Returns the number of iterations.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Standard_Exports"><a class="permalink" href="#Standard_Exports">Standard
  Exports</a></h2>
<p class="Pp">The following routines will be exported into your namespace if you
    use the Benchmark module:</p>
<dl class="Bl-tag">
  <dt id="timeit("><a class="permalink" href="#timeit(">timeit(COUNT,
    CODE)</a></dt>
  <dd>Arguments: COUNT is the number of times to run the loop, and CODE is the
      code to run. CODE may be either a code reference or a string to be eval'd;
      either way it will be run in the caller's package.
    <p class="Pp">Returns: a Benchmark object.</p>
  </dd>
  <dt id="timethis"><a class="permalink" href="#timethis">timethis ( COUNT,
    CODE, [ TITLE, [ STYLE ]] )</a></dt>
  <dd>Time COUNT iterations of CODE. CODE may be a string to eval or a code
      reference; either way the CODE will run in the caller's package. Results
      will be printed to STDOUT as TITLE followed by the times. TITLE defaults
      to &quot;timethis COUNT&quot; if none is provided. STYLE determines the
      format of the output, as described for <b>timestr()</b> below.
    <p class="Pp">The COUNT can be zero or negative: this means the <i>minimum
        number of</i> <i>CPU seconds</i> to run. A zero signifies the default of
        3 seconds. For example to run at least for 10 seconds:</p>
    <p class="Pp"></p>
    <pre>
        timethis(-10, $code)
    </pre>
    <p class="Pp">or to run two pieces of code tests for at least 3 seconds:</p>
    <p class="Pp"></p>
    <pre>
        timethese(0, { test1 =&gt; '...', test2 =&gt; '...'})
    </pre>
    <p class="Pp">CPU seconds is, in UNIX terms, the user time plus the system
        time of the process itself, as opposed to the real (wallclock) time and
        the time spent by the child processes. Less than 0.1 seconds is not
        accepted (-0.01 as the count, for example, will cause a fatal runtime
        exception).</p>
    <p class="Pp">Note that the CPU seconds is the <b>minimum</b> time: CPU
        scheduling and other operating system factors may complicate the attempt
        so that a little bit more time is spent. The benchmark output will,
        however, also tell the number of <span class="Li">$code</span>
        runs/second, which should be a more interesting number than the actually
        spent seconds.</p>
    <p class="Pp">Returns a Benchmark object.</p>
  </dd>
  <dt id="timethese"><a class="permalink" href="#timethese">timethese ( COUNT,
    CODEHASHREF, [ STYLE ] )</a></dt>
  <dd>The CODEHASHREF is a reference to a hash containing names as keys and
      either a string to eval or a code reference for each value. For each (KEY,
      VALUE) pair in the CODEHASHREF, this routine will call
    <p class="Pp"></p>
    <pre>
        timethis(COUNT, VALUE, KEY, STYLE)
    </pre>
    <p class="Pp">The routines are called in string comparison order of KEY.</p>
    <p class="Pp">The COUNT can be zero or negative, see <b>timethis()</b>.</p>
    <p class="Pp">Returns a hash reference of Benchmark objects, keyed by
      name.</p>
  </dd>
  <dt id="timediff"><a class="permalink" href="#timediff">timediff ( T1, T2
    )</a></dt>
  <dd>Returns the difference between two Benchmark times as a Benchmark object
      suitable for passing to <b>timestr()</b>.</dd>
  <dt id="timestr"><a class="permalink" href="#timestr">timestr ( TIMEDIFF, [
    STYLE, [ FORMAT ] ] )</a></dt>
  <dd>Returns a string that formats the times in the TIMEDIFF object in the
      requested STYLE. TIMEDIFF is expected to be a Benchmark object similar to
      that returned by <b>timediff()</b>.
    <p class="Pp">STYLE can be any of 'all', 'none', 'noc', 'nop' or 'auto'.
        'all' shows each of the 5 times available ('wallclock' time, user time,
        system time, user time of children, and system time of children). 'noc'
        shows all except the two children times. 'nop' shows only wallclock and
        the two children times. 'auto' (the default) will act as 'all' unless
        the children times are both zero, in which case it acts as 'noc'. 'none'
        prevents output.</p>
    <p class="Pp">FORMAT is the <b>printf</b>(3)-style format specifier (without
        the leading '%') to use to print the times. It defaults to '5.2f'.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Optional_Exports"><a class="permalink" href="#Optional_Exports">Optional
  Exports</a></h2>
<p class="Pp">The following routines will be exported into your namespace if you
    specifically ask that they be imported:</p>
<dl class="Bl-tag">
  <dt id="clearcache"><a class="permalink" href="#clearcache">clearcache ( COUNT
    )</a></dt>
  <dd>Clear the cached time for COUNT rounds of the null loop.</dd>
  <dt id="clearallcache"><a class="permalink" href="#clearallcache">clearallcache
    ( )</a></dt>
  <dd>Clear all cached times.</dd>
  <dt id="cmpthese"><a class="permalink" href="#cmpthese">cmpthese ( COUNT,
    CODEHASHREF, [ STYLE ] )</a></dt>
  <dd></dd>
  <dt id="cmpthese~2"><a class="permalink" href="#cmpthese~2">cmpthese (
    RESULTSHASHREF, [ STYLE ] )</a></dt>
  <dd>Optionally calls <b>timethese()</b>, then outputs comparison chart. This:
    <p class="Pp"></p>
    <pre>
    cmpthese( -1, { a =&gt; &quot;++\$i&quot;, b =&gt; &quot;\$i *= 2&quot; } ) ;
    </pre>
    <p class="Pp">outputs a chart like:</p>
    <p class="Pp"></p>
    <pre>
           Rate    b    a
    b 2831802/s   -- -61%
    a 7208959/s 155%   --
    </pre>
    <p class="Pp">This chart is sorted from slowest to fastest, and shows the
        percent speed difference between each pair of tests.</p>
    <p class="Pp"><span class="Li">&quot;cmpthese&quot;</span> can also be
        passed the data structure that <b>timethese()</b> returns:</p>
    <p class="Pp"></p>
    <pre>
    $results = timethese( -1,
        { a =&gt; &quot;++\$i&quot;, b =&gt; &quot;\$i *= 2&quot; } ) ;
    cmpthese( $results );
    </pre>
    <p class="Pp">in case you want to see both sets of results. If the first
        argument is an unblessed hash reference, that is RESULTSHASHREF;
        otherwise that is COUNT.</p>
    <p class="Pp">Returns a reference to an ARRAY of rows, each row is an ARRAY
        of cells from the above chart, including labels. This:</p>
    <p class="Pp"></p>
    <pre>
    my $rows = cmpthese( -1,
        { a =&gt; '++$i', b =&gt; '$i *= 2' }, &quot;none&quot; );
    </pre>
    <p class="Pp">returns a data structure like:</p>
    <p class="Pp"></p>
    <pre>
    [
        [ '',       'Rate',   'b',    'a' ],
        [ 'b', '2885232/s',  '--', '-59%' ],
        [ 'a', '7099126/s', '146%',  '--' ],
    ]
    </pre>
    <p class="Pp"><b>NOTE</b>: This result value differs from previous versions,
        which returned the <span class="Li">&quot;timethese()&quot;</span>
        result structure. If you want that, just use the two statement
        <span class="Li">&quot;timethese&quot;</span>...<span class="Li">&quot;cmpthese&quot;</span>
        idiom shown above.</p>
    <p class="Pp">Incidentally, note the variance in the result values between
        the two examples; this is typical of benchmarking. If this were a real
        benchmark, you would probably want to run a lot more iterations.</p>
  </dd>
  <dt id="countit("><a class="permalink" href="#countit(">countit(TIME,
    CODE)</a></dt>
  <dd>Arguments: TIME is the minimum length of time to run CODE for, and CODE is
      the code to run. CODE may be either a code reference or a string to be
      eval'd; either way it will be run in the caller's package.
    <p class="Pp">TIME is <i>not</i> negative. <b>countit()</b> will run the
        loop many times to calculate the speed of CODE before running it for
        TIME. The actual time run for will usually be greater than TIME due to
        system clock resolution, so it's best to look at the number of
        iterations divided by the times that you are concerned with, not just
        the iterations.</p>
    <p class="Pp">Returns: a Benchmark object.</p>
  </dd>
  <dt id="disablecache"><a class="permalink" href="#disablecache">disablecache (
    )</a></dt>
  <dd>Disable caching of timings for the null loop. This will force Benchmark to
      recalculate these timings for each new piece of code timed.</dd>
  <dt id="enablecache"><a class="permalink" href="#enablecache">enablecache (
    )</a></dt>
  <dd>Enable caching of timings for the null loop. The time taken for COUNT
      rounds of the null loop will be calculated only once for each different
      COUNT used.</dd>
  <dt id="timesum"><a class="permalink" href="#timesum">timesum ( T1, T2
    )</a></dt>
  <dd>Returns the sum of two Benchmark times as a Benchmark object suitable for
      passing to <b>timestr()</b>.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id=":hireswallclock"><a class="permalink" href="#:hireswallclock">:hireswallclock</a></h2>
<p class="Pp">If the Time::HiRes module has been installed, you can specify the
    special tag <span class="Li">&quot;:hireswallclock&quot;</span> for
    Benchmark (if Time::HiRes is not available, the tag will be silently
    ignored). This tag will cause the wallclock time to be measured in
    microseconds, instead of integer seconds. Note though that the speed
    computations are still conducted in CPU time, not wallclock time.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Benchmark_Object"><a class="permalink" href="#Benchmark_Object">Benchmark
  Object</a></h1>
<p class="Pp">Many of the functions in this module return a Benchmark object, or
    in the case of <span class="Li">&quot;timethese()&quot;</span>, a reference
    to a hash, the values of which are Benchmark objects. This is useful if you
    want to store or further process results from Benchmark functions.</p>
<p class="Pp">Internally the Benchmark object holds timing values, described in
    &quot;NOTES&quot; below. The following methods can be used to access
  them:</p>
<dl class="Bl-tag">
  <dt id="cpu_p"><a class="permalink" href="#cpu_p">cpu_p</a></dt>
  <dd>Total CPU (User + System) of the main (parent) process.</dd>
  <dt id="cpu_c"><a class="permalink" href="#cpu_c">cpu_c</a></dt>
  <dd>Total CPU (User + System) of any children processes.</dd>
  <dt id="cpu_a"><a class="permalink" href="#cpu_a">cpu_a</a></dt>
  <dd>Total CPU of parent and any children processes.</dd>
  <dt id="real"><a class="permalink" href="#real">real</a></dt>
  <dd>Real elapsed time &quot;wallclock seconds&quot;.</dd>
  <dt id="iters~2"><a class="permalink" href="#iters~2">iters</a></dt>
  <dd>Number of iterations run.</dd>
</dl>
<p class="Pp">The following illustrates use of the Benchmark object:</p>
<p class="Pp"></p>
<pre>
    $result = timethis(100000, sub { ... });
    print &quot;total CPU = &quot;, $result-&gt;cpu_a, &quot;\n&quot;;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<p class="Pp">The data is stored as a list of values from the time and times
    functions:</p>
<p class="Pp"></p>
<pre>
      ($real, $user, $system, $children_user, $children_system, $iters)
</pre>
<p class="Pp">in seconds for the whole loop (not divided by the number of
    rounds).</p>
<p class="Pp">The timing is done using <b>time</b>(3) and <b>times</b>(3).</p>
<p class="Pp">Code is executed in the caller's package.</p>
<p class="Pp">The time of the null loop (a loop with the same number of rounds
    but empty loop body) is subtracted from the time of the real loop.</p>
<p class="Pp">The null loop times can be cached, the key being the number of
    rounds. The caching can be controlled using calls like these:</p>
<p class="Pp"></p>
<pre>
    clearcache($key);
    clearallcache();

    disablecache();
    enablecache();
</pre>
<p class="Pp">Caching is off by default, as it can (usually slightly) decrease
    accuracy and does not usually noticeably affect runtimes.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">For example,</p>
<p class="Pp"></p>
<pre>
    use Benchmark qw( cmpthese ) ;
    $x = 3;
    cmpthese( -5, {
        a =&gt; sub{$x*$x},
        b =&gt; sub{$x**2},
    } );
</pre>
<p class="Pp">outputs something like this:</p>
<p class="Pp"></p>
<pre>
   Benchmark: running a, b, each for at least 5 CPU seconds...
          Rate    b    a
   b 1559428/s   -- -62%
   a 4152037/s 166%   --
</pre>
<p class="Pp">while</p>
<p class="Pp"></p>
<pre>
    use Benchmark qw( timethese cmpthese ) ;
    $x = 3;
    $r = timethese( -5, {
        a =&gt; sub{$x*$x},
        b =&gt; sub{$x**2},
    } );
    cmpthese $r;
</pre>
<p class="Pp">outputs something like this:</p>
<p class="Pp"></p>
<pre>
    Benchmark: running a, b, each for at least 5 CPU seconds...
             a: 10 wallclock secs ( 5.14 usr +  0.13 sys =  5.27 CPU) @ 3835055.60/s (n=20210743)
             b:  5 wallclock secs ( 5.41 usr +  0.00 sys =  5.41 CPU) @ 1574944.92/s (n=8520452)
           Rate    b    a
    b 1574945/s   -- -59%
    a 3835056/s 144%   --
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="INHERITANCE"><a class="permalink" href="#INHERITANCE">INHERITANCE</a></h1>
<p class="Pp">Benchmark inherits from no other class, except of course from
    Exporter.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<p class="Pp">Comparing eval'd strings with code references will give you
    inaccurate results: a code reference will show a slightly slower execution
    time than the equivalent eval'd string.</p>
<p class="Pp">The real time timing is done using <b>time</b>(2) and the
    granularity is therefore only one second.</p>
<p class="Pp">Short tests may produce negative figures because perl can appear
    to take longer to execute the empty loop than a short test; try:</p>
<p class="Pp"></p>
<pre>
    timethis(100,'1');
</pre>
<p class="Pp">The system time of the null loop might be slightly more than the
    system time of the loop with the actual code and therefore the difference
    might end up being &lt; 0.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Devel::NYTProf - a Perl code profiler</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp">Jarkko Hietaniemi &lt;<i>jhi@iki.fi</i>&gt;, Tim Bunce
    &lt;<i>Tim.Bunce@ig.co.uk</i>&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MODIFICATION_HISTORY"><a class="permalink" href="#MODIFICATION_HISTORY">MODIFICATION
  HISTORY</a></h1>
<p class="Pp">September 8th, 1994; by Tim Bunce.</p>
<p class="Pp">March 28th, 1997; by Hugo van der Sanden: added support for code
    references and the already documented 'debug' method; revamped
    documentation.</p>
<p class="Pp">April 04-07th, 1997: by Jarkko Hietaniemi, added the
    run-for-some-time functionality.</p>
<p class="Pp">September, 1999; by Barrie Slaymaker: math fixes and accuracy and
    efficiency tweaks. Added <b>cmpthese()</b>. A result is now returned from
    <b>timethese()</b>. Exposed <b>countit()</b> (was <b>runfor()</b>).</p>
<p class="Pp">December, 2001; by Nicholas Clark: make <b>timestr()</b> recognise
    the style 'none' and return an empty string. If cmpthese is calling
    timethese, make it pass the style in. (so that 'none' will suppress output).
    Make sub new dump its debugging output to STDERR, to be consistent with
    everything else. All bugs found while writing a regression test.</p>
<p class="Pp">September, 2002; by Jarkko Hietaniemi: add ':hireswallclock'
    special tag.</p>
<p class="Pp">February, 2004; by Chia-liang Kao: make cmpthese and timestr use
    time statistics for children instead of parent when the style is 'nop'.</p>
<p class="Pp">November, 2007; by Christophe Grosjean: make cmpthese and timestr
    compute time consistently with style argument, default is 'all' not 'noc'
    any more.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

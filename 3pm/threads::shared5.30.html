<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>threads::shared(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">threads::shared(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">threads::shared(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">threads::shared - Perl extension for sharing data structures
    between threads</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">This document describes threads::shared version 1.60</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
  use threads;
  use threads::shared;

  my $var :shared;
  my %hsh :shared;
  my @ary :shared;

  my ($scalar, @array, %hash);
  share($scalar);
  share(@array);
  share(%hash);

  $var = $scalar_value;
  $var = $shared_ref_value;
  $var = shared_clone($non_shared_ref_value);
  $var = shared_clone({'foo' =&gt; [qw/foo bar baz/]});

  $hsh{'foo'} = $scalar_value;
  $hsh{'bar'} = $shared_ref_value;
  $hsh{'baz'} = shared_clone($non_shared_ref_value);
  $hsh{'quz'} = shared_clone([1..3]);

  $ary[0] = $scalar_value;
  $ary[1] = $shared_ref_value;
  $ary[2] = shared_clone($non_shared_ref_value);
  $ary[3] = shared_clone([ {}, [] ]);

  { lock(%hash); ...  }

  cond_wait($scalar);
  cond_timedwait($scalar, time() + 30);
  cond_broadcast(@array);
  cond_signal(%hash);

  my $lockvar :shared;
  # condition var != lock var
  cond_wait($var, $lockvar);
  cond_timedwait($var, time()+30, $lockvar);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">By default, variables are private to each thread, and each newly
    created thread gets a private copy of each existing variable. This module
    allows you to share variables across different threads (and pseudo-forks on
    Win32). It is used together with the threads module.</p>
<p class="Pp">This module supports the sharing of the following data types only:
    scalars and scalar refs, arrays and array refs, and hashes and hash
  refs.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORT"><a class="permalink" href="#EXPORT">EXPORT</a></h1>
<p class="Pp">The following functions are exported by this module:
    <span class="Li">&quot;share&quot;</span>,
    <span class="Li">&quot;shared_clone&quot;</span>,
    <span class="Li">&quot;is_shared&quot;</span>,
    <span class="Li">&quot;cond_wait&quot;</span>,
    <span class="Li">&quot;cond_timedwait&quot;</span>,
    <span class="Li">&quot;cond_signal&quot;</span> and
    <span class="Li">&quot;cond_broadcast&quot;</span></p>
<p class="Pp">Note that if this module is imported when threads has not yet been
    loaded, then these functions all become no-ops. This makes it possible to
    write modules that will work in both threaded and non-threaded
  environments.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTIONS"><a class="permalink" href="#FUNCTIONS">FUNCTIONS</a></h1>
<dl class="Bl-tag">
  <dt id="share"><a class="permalink" href="#share">share VARIABLE</a></dt>
  <dd><span class="Li">&quot;share&quot;</span> takes a variable and marks it as
      shared:
    <p class="Pp"></p>
    <pre>
  my ($scalar, @array, %hash);
  share($scalar);
  share(@array);
  share(%hash);
    </pre>
    <p class="Pp"><span class="Li">&quot;share&quot;</span> will return the
        shared rvalue, but always as a reference.</p>
    <p class="Pp">Variables can also be marked as shared at compile time by
        using the <span class="Li">&quot;:shared&quot;</span> attribute:</p>
    <p class="Pp"></p>
    <pre>
  my ($var, %hash, @array) :shared;
    </pre>
    <p class="Pp">Shared variables can only store scalars, refs of shared
        variables, or refs of shared data (discussed in next section):</p>
    <p class="Pp"></p>
    <pre>
  my ($var, %hash, @array) :shared;
  my $bork;

  # Storing scalars
  $var = 1;
  $hash{'foo'} = 'bar';
  $array[0] = 1.5;

  # Storing shared refs
  $var = \%hash;
  $hash{'ary'} = \@array;
  $array[1] = \$var;

  # The following are errors:
  #   $var = \$bork;                    # ref of non-shared variable
  #   $hash{'bork'} = [];               # non-shared array ref
  #   push(@array, { 'x' =&gt; 1 });       # non-shared hash ref
    </pre>
  </dd>
  <dt id="shared_clone"><a class="permalink" href="#shared_clone">shared_clone
    REF</a></dt>
  <dd><span class="Li">&quot;shared_clone&quot;</span> takes a reference, and
      returns a shared version of its argument, performing a deep copy on any
      non-shared elements. Any shared elements in the argument are used as is
      (i.e., they are not cloned).
    <p class="Pp"></p>
    <pre>
  my $cpy = shared_clone({'foo' =&gt; [qw/foo bar baz/]});
    </pre>
    <p class="Pp">Object status (i.e., the class an object is blessed into) is
        also cloned.</p>
    <p class="Pp"></p>
    <pre>
  my $obj = {'foo' =&gt; [qw/foo bar baz/]};
  bless($obj, 'Foo');
  my $cpy = shared_clone($obj);
  print(ref($cpy), &quot;\n&quot;);         # Outputs 'Foo'
    </pre>
    <p class="Pp">For cloning empty array or hash refs, the following may also
        be used:</p>
    <p class="Pp"></p>
    <pre>
  $var = &amp;share([]);   # Same as $var = shared_clone([]);
  $var = &amp;share({});   # Same as $var = shared_clone({});
    </pre>
    <p class="Pp">Not all Perl data types can be cloned (e.g., globs, code
        refs). By default, <span class="Li">&quot;shared_clone&quot;</span> will
        croak if it encounters such items. To change this behaviour to a
        warning, then set the following:</p>
    <p class="Pp"></p>
    <pre>
  $threads::shared::clone_warn = 1;
    </pre>
    <p class="Pp">In this case, <span class="Li">&quot;undef&quot;</span> will
        be substituted for the item to be cloned. If set to zero:</p>
    <p class="Pp"></p>
    <pre>
  $threads::shared::clone_warn = 0;
    </pre>
    <p class="Pp">then the <span class="Li">&quot;undef&quot;</span>
        substitution will be performed silently.</p>
  </dd>
  <dt id="is_shared"><a class="permalink" href="#is_shared">is_shared
    VARIABLE</a></dt>
  <dd><span class="Li">&quot;is_shared&quot;</span> checks if the specified
      variable is shared or not. If shared, returns the variable's internal ID
      (similar to <span class="Li">&quot;refaddr()&quot;</span> (see
      Scalar::Util). Otherwise, returns
      <span class="Li">&quot;undef&quot;</span>.
    <p class="Pp"></p>
    <pre>
  if (is_shared($var)) {
      print(&quot;\$var is shared\n&quot;);
  } else {
      print(&quot;\$var is not shared\n&quot;);
  }
    </pre>
    <p class="Pp">When used on an element of an array or hash,
        <span class="Li">&quot;is_shared&quot;</span> checks if the specified
        element belongs to a shared array or hash. (It does not check the
        contents of that element.)</p>
    <p class="Pp"></p>
    <pre>
  my %hash :shared;
  if (is_shared(%hash)) {
      print(&quot;\%hash is shared\n&quot;);
  }

  $hash{'elem'} = 1;
  if (is_shared($hash{'elem'})) {
      print(&quot;\$hash{'elem'} is in a shared hash\n&quot;);
  }
    </pre>
  </dd>
  <dt id="lock"><a class="permalink" href="#lock">lock VARIABLE</a></dt>
  <dd><span class="Li">&quot;lock&quot;</span> places a <b>advisory</b> lock on
      a variable until the lock goes out of scope. If the variable is locked by
      another thread, the <span class="Li">&quot;lock&quot;</span> call will
      block until it's available. Multiple calls to
      <span class="Li">&quot;lock&quot;</span> by the same thread from within
      dynamically nested scopes are safe -- the variable will remain locked
      until the outermost lock on the variable goes out of scope.
    <p class="Pp"><span class="Li">&quot;lock&quot;</span> follows references
        exactly <i>one</i> level:</p>
    <p class="Pp"></p>
    <pre>
  my %hash :shared;
  my $ref = \%hash;
  lock($ref);           # This is equivalent to lock(%hash)
    </pre>
    <p class="Pp">Note that you cannot explicitly unlock a variable; you can
        only wait for the lock to go out of scope. This is most easily
        accomplished by locking the variable inside a block.</p>
    <p class="Pp"></p>
    <pre>
  my $var :shared;
  {
      lock($var);
      # $var is locked from here to the end of the block
      ...
  }
  # $var is now unlocked
    </pre>
    <p class="Pp">As locks are advisory, they do not prevent data access or
        modification by another thread that does not itself attempt to obtain a
        lock on the variable.</p>
    <p class="Pp">You cannot lock the individual elements of a container
        variable:</p>
    <p class="Pp"></p>
    <pre>
  my %hash :shared;
  $hash{'foo'} = 'bar';
  #lock($hash{'foo'});          # Error
  lock(%hash);                  # Works
    </pre>
    <p class="Pp">If you need more fine-grained control over shared variable
        access, see Thread::Semaphore.</p>
  </dd>
  <dt id="cond_wait"><a class="permalink" href="#cond_wait">cond_wait
    VARIABLE</a></dt>
  <dd></dd>
  <dt id="cond_wait~2"><a class="permalink" href="#cond_wait~2">cond_wait
    CONDVAR, LOCKVAR</a></dt>
  <dd>The <span class="Li">&quot;cond_wait&quot;</span> function takes a
      <b>locked</b> variable as a parameter, unlocks the variable, and blocks
      until another thread does a
      <span class="Li">&quot;cond_signal&quot;</span> or
      <span class="Li">&quot;cond_broadcast&quot;</span> for that same locked
      variable. The variable that <span class="Li">&quot;cond_wait&quot;</span>
      blocked on is re-locked after the
      <span class="Li">&quot;cond_wait&quot;</span> is satisfied. If there are
      multiple threads <span class="Li">&quot;cond_wait&quot;</span>ing on the
      same variable, all but one will re-block waiting to reacquire the lock on
      the variable. (So if you're only using
      <span class="Li">&quot;cond_wait&quot;</span> for synchronization, give up
      the lock as soon as possible). The two actions of unlocking the variable
      and entering the blocked wait state are atomic, the two actions of exiting
      from the blocked wait state and re-locking the variable are not.
    <p class="Pp">In its second form,
        <span class="Li">&quot;cond_wait&quot;</span> takes a shared,
        <b>unlocked</b> variable followed by a shared, <b>locked</b> variable.
        The second variable is unlocked and thread execution suspended until
        another thread signals the first variable.</p>
    <p class="Pp">It is important to note that the variable can be notified even
        if no thread <span class="Li">&quot;cond_signal&quot;</span> or
        <span class="Li">&quot;cond_broadcast&quot;</span> on the variable. It
        is therefore important to check the value of the variable and go back to
        waiting if the requirement is not fulfilled. For example, to pause until
        a shared counter drops to zero:</p>
    <p class="Pp"></p>
    <pre>
  { lock($counter); cond_wait($counter) until $counter == 0; }
    </pre>
  </dd>
  <dt id="cond_timedwait"><a class="permalink" href="#cond_timedwait">cond_timedwait
    VARIABLE, ABS_TIMEOUT</a></dt>
  <dd></dd>
  <dt id="cond_timedwait~2"><a class="permalink" href="#cond_timedwait~2">cond_timedwait
    CONDVAR, ABS_TIMEOUT, LOCKVAR</a></dt>
  <dd>In its two-argument form,
      <span class="Li">&quot;cond_timedwait&quot;</span> takes a <b>locked</b>
      variable and an absolute timeout in <i>epoch</i> seconds (see
      <b>time()</b> in perlfunc for more) as parameters, unlocks the variable,
      and blocks until the timeout is reached or another thread signals the
      variable. A false value is returned if the timeout is reached, and a true
      value otherwise. In either case, the variable is re-locked upon return.
    <p class="Pp">Like <span class="Li">&quot;cond_wait&quot;</span>, this
        function may take a shared, <b>locked</b> variable as an additional
        parameter; in this case the first parameter is an <b>unlocked</b>
        condition variable protected by a distinct lock variable.</p>
    <p class="Pp">Again like <span class="Li">&quot;cond_wait&quot;</span>,
        waking up and reacquiring the lock are not atomic, and you should always
        check your desired condition after this function returns. Since the
        timeout is an absolute value, however, it does not have to be
        recalculated with each pass:</p>
    <p class="Pp"></p>
    <pre>
  lock($var);
  my $abs = time() + 15;
  until ($ok = desired_condition($var)) {
      last if !cond_timedwait($var, $abs);
  }
  # we got it if $ok, otherwise we timed out!
    </pre>
  </dd>
  <dt id="cond_signal"><a class="permalink" href="#cond_signal">cond_signal
    VARIABLE</a></dt>
  <dd>The <span class="Li">&quot;cond_signal&quot;</span> function takes a
      <b>locked</b> variable as a parameter and unblocks one thread that's
      <span class="Li">&quot;cond_wait&quot;</span>ing on that variable. If more
      than one thread is blocked in a
      <span class="Li">&quot;cond_wait&quot;</span> on that variable, only one
      (and which one is indeterminate) will be unblocked.
    <p class="Pp">If there are no threads blocked in a
        <span class="Li">&quot;cond_wait&quot;</span> on the variable, the
        signal is discarded. By always locking before signaling, you can (with
        care), avoid signaling before another thread has entered
        <b>cond_wait()</b>.</p>
    <p class="Pp"><span class="Li">&quot;cond_signal&quot;</span> will normally
        generate a warning if you attempt to use it on an unlocked variable. On
        the rare occasions where doing this may be sensible, you can suppress
        the warning with:</p>
    <p class="Pp"></p>
    <pre>
  { no warnings 'threads'; cond_signal($foo); }
    </pre>
  </dd>
  <dt id="cond_broadcast"><a class="permalink" href="#cond_broadcast">cond_broadcast
    VARIABLE</a></dt>
  <dd>The <span class="Li">&quot;cond_broadcast&quot;</span> function works
      similarly to <span class="Li">&quot;cond_signal&quot;</span>.
      <span class="Li">&quot;cond_broadcast&quot;</span>, though, will unblock
      <b>all</b> the threads that are blocked in a
      <span class="Li">&quot;cond_wait&quot;</span> on the locked variable,
      rather than only one.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="OBJECTS"><a class="permalink" href="#OBJECTS">OBJECTS</a></h1>
<p class="Pp">threads::shared exports a version of <b>bless()</b> that works on
    shared objects such that <i>blessings</i> propagate across threads.</p>
<p class="Pp"></p>
<pre>
  # Create a shared 'Foo' object
  my $foo :shared = shared_clone({});
  bless($foo, 'Foo');

  # Create a shared 'Bar' object
  my $bar :shared = shared_clone({});
  bless($bar, 'Bar');

  # Put 'bar' inside 'foo'
  $foo-&gt;{'bar'} = $bar;

  # Rebless the objects via a thread
  threads-&gt;create(sub {
      # Rebless the outer object
      bless($foo, 'Yin');

      # Cannot directly rebless the inner object
      #bless($foo-&gt;{'bar'}, 'Yang');

      # Retrieve and rebless the inner object
      my $obj = $foo-&gt;{'bar'};
      bless($obj, 'Yang');
      $foo-&gt;{'bar'} = $obj;

  })-&gt;join();

  print(ref($foo),          &quot;\n&quot;);    # Prints 'Yin'
  print(ref($foo-&gt;{'bar'}), &quot;\n&quot;);    # Prints 'Yang'
  print(ref($bar),          &quot;\n&quot;);    # Also prints 'Yang'
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<p class="Pp">threads::shared is designed to disable itself silently if threads
    are not available. This allows you to write modules and packages that can be
    used in both threaded and non-threaded applications.</p>
<p class="Pp">If you want access to threads, you must <span class="Li">&quot;use
    threads&quot;</span> before you <span class="Li">&quot;use
    threads::shared&quot;</span>. threads will emit a warning if you use it
    after threads::shared.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="WARNINGS"><a class="permalink" href="#WARNINGS">WARNINGS</a></h1>
<dl class="Bl-tag">
  <dt id="cond_broadcast()"><a class="permalink" href="#cond_broadcast()"><b>cond_broadcast()</b>
    called on unlocked variable</a></dt>
  <dd></dd>
  <dt id="cond_signal()"><a class="permalink" href="#cond_signal()"><b>cond_signal()</b>
    called on unlocked variable</a></dt>
  <dd>See &quot;cond_signal VARIABLE&quot;, above.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS_AND_LIMITATIONS"><a class="permalink" href="#BUGS_AND_LIMITATIONS">BUGS
  AND LIMITATIONS</a></h1>
<p class="Pp">When <span class="Li">&quot;share&quot;</span> is used on arrays,
    hashes, array refs or hash refs, any data they contain will be lost.</p>
<p class="Pp"></p>
<pre>
  my @arr = qw(foo bar baz);
  share(@arr);
  # @arr is now empty (i.e., == ());

  # Create a 'foo' object
  my $foo = { 'data' =&gt; 99 };
  bless($foo, 'foo');

  # Share the object
  share($foo);        # Contents are now wiped out
  print(&quot;ERROR: \$foo is empty\n&quot;)
      if (! exists($foo-&gt;{'data'}));
</pre>
<p class="Pp">Therefore, populate such variables <b>after</b> declaring them as
    shared. (Scalar and scalar refs are not affected by this problem.)</p>
<p class="Pp">Blessing a shared item after it has been nested in another shared
    item does not propagate the blessing to the shared reference:</p>
<p class="Pp"></p>
<pre>
  my $foo = &amp;share({});
  my $bar = &amp;share({});
  $bar-&gt;{foo} = $foo;
  bless($foo, 'baz');   # $foo is now of class 'baz',
                        # but $bar-&gt;{foo} is unblessed.
</pre>
<p class="Pp">Therefore, you should bless objects before sharing them.</p>
<p class="Pp">It is often not wise to share an object unless the class itself
    has been written to support sharing. For example, a shared object's
    destructor may get called multiple times, once for each thread's scope exit,
    or may not get called at all if it is embedded inside another shared object.
    Another issue is that the contents of hash-based objects will be lost due to
    the above mentioned limitation. See <i>examples/class.pl</i> (in the CPAN
    distribution of this module) for how to create a class that supports object
    sharing.</p>
<p class="Pp">Destructors may not be called on objects if those objects still
    exist at global destruction time. If the destructors must be called, make
    sure there are no circular references and that nothing is referencing the
    objects before the program ends.</p>
<p class="Pp">Does not support <span class="Li">&quot;splice&quot;</span> on
    arrays. Does not support explicitly changing array lengths via $#array --
    use <span class="Li">&quot;push&quot;</span> and
    <span class="Li">&quot;pop&quot;</span> instead.</p>
<p class="Pp">Taking references to the elements of shared arrays and hashes does
    not autovivify the elements, and neither does slicing a shared array/hash
    over non-existent indices/keys autovivify the elements.</p>
<p class="Pp"><span class="Li">&quot;share()&quot;</span> allows you to
    <span class="Li">&quot;share($hashref-&gt;{key})&quot;</span> and
    <span class="Li">&quot;share($arrayref-&gt;[idx])&quot;</span> without
    giving any error message. But the
    <span class="Li">&quot;$hashref-&gt;{key}&quot;</span> or
    <span class="Li">&quot;$arrayref-&gt;[idx]&quot;</span> is <b>not</b>
    shared, causing the error &quot;lock can only be used on shared values&quot;
    to occur when you attempt to
    <span class="Li">&quot;lock($hashref-&gt;{key})&quot;</span> or
    <span class="Li">&quot;lock($arrayref-&gt;[idx])&quot;</span> in another
    thread.</p>
<p class="Pp">Using <span class="Li">&quot;refaddr()&quot;</span> is unreliable
    for testing whether or not two shared references are equivalent (e.g., when
    testing for circular references). Use <b>is_shared()</b>, instead:</p>
<p class="Pp"></p>
<pre>
    use threads;
    use threads::shared;
    use Scalar::Util qw(refaddr);

    # If ref is shared, use threads::shared's internal ID.
    # Otherwise, use refaddr().
    my $addr1 = is_shared($ref1) || refaddr($ref1);
    my $addr2 = is_shared($ref2) || refaddr($ref2);

    if ($addr1 == $addr2) {
        # The refs are equivalent
    }
</pre>
<p class="Pp"><b>each()</b> does not work properly on shared references embedded
    in shared structures. For example:</p>
<p class="Pp"></p>
<pre>
    my %foo :shared;
    $foo{'bar'} = shared_clone({'a'=&gt;'x', 'b'=&gt;'y', 'c'=&gt;'z'});

    while (my ($key, $val) = each(%{$foo{'bar'}})) {
        ...
    }
</pre>
<p class="Pp">Either of the following will work instead:</p>
<p class="Pp"></p>
<pre>
    my $ref = $foo{'bar'};
    while (my ($key, $val) = each(%{$ref})) {
        ...
    }

    foreach my $key (keys(%{$foo{'bar'}})) {
        my $val = $foo{'bar'}{$key};
        ...
    }
</pre>
<p class="Pp">This module supports dual-valued variables created using
    <span class="Li">&quot;dualvar()&quot;</span> from Scalar::Util. However,
    while <span class="Li">$!</span> acts like a dualvar, it is implemented as a
    tied SV. To propagate its value, use the follow construct, if needed:</p>
<p class="Pp"></p>
<pre>
    my $errno :shared = dualvar($!,$!);
</pre>
<p class="Pp">View existing bug reports at, and submit any new bugs, problems,
    patches, etc. to:
    &lt;http://rt.cpan.org/Public/Dist/Display.html?Name=threads-shared&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">threads::shared on MetaCPAN:
    &lt;https://metacpan.org/release/threads-shared&gt;</p>
<p class="Pp">Code repository for CPAN distribution:
    &lt;https://github.com/Dual-Life/threads-shared&gt;</p>
<p class="Pp">threads, perlthrtut</p>
<p class="Pp">&lt;http://www.perl.com/pub/a/2002/06/11/threads.html&gt; and
    &lt;http://www.perl.com/pub/a/2002/09/04/threads.html&gt;</p>
<p class="Pp">Perl threads mailing list:
    &lt;http://lists.perl.org/list/ithreads.html&gt;</p>
<p class="Pp">Sample code in the <i>examples</i> directory of this distribution
    on CPAN.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Artur Bergman &lt;sky AT crucially DOT net&gt;</p>
<p class="Pp">Documentation borrowed from the old Thread.pm.</p>
<p class="Pp">CPAN version produced by Jerry D. Hedden &lt;jdhedden AT cpan DOT
    org&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">threads::shared is released under the same license as Perl.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

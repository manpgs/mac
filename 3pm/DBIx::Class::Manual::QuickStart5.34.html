<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>DBIx::Class::Manual::QuickStart(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBIx::Class::Manual::QuickStart(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBIx::Class::Manual::QuickStart(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">DBIx::Class::Manual::QuickStart - up and running with DBIC in 10
    minutes</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This document shows the minimum amount of code to make you a
    productive DBIC user. It requires you to be familiar with just the basics of
    database programming (what database tables, rows and columns are) and the
    basics of Perl object-oriented programming (calling methods on an object
    instance). It also helps if you already know a bit of SQL and how to connect
    to a database through DBI.</p>
<p class="Pp">Follow along with the example database shipping with this
    distribution, see directory <i>examples/Schema</i>. This database is also
    used through-out the rest of the documentation.</p>
<section class="Ss">
<h2 class="Ss" id="Preparation"><a class="permalink" href="#Preparation">Preparation</a></h2>
<p class="Pp">First, install DBIx::Class like you do with any other CPAN
    distribution. See &lt;http://www.cpan.org/modules/INSTALL.html&gt; and
    perlmodinstall.</p>
<p class="Pp">Then open the distribution in your shell and change to the
    subdirectory mentioned earlier, the next command will download and unpack
    it:</p>
<p class="Pp"></p>
<pre>    $ perl -mCPAN -e'CPAN::Shell-&gt;look(&quot;DBIx::Class&quot;)'
    DBIx-Class$ cd examples/Schema
</pre>
<p class="Pp">Inspect the database:</p>
<p class="Pp"></p>
<pre>    DBIx-Class/examples/Schema$ sqlite3 db/example.db .dump
</pre>
<p class="Pp">You can also use a GUI database browser such as SQLite Manager
    &lt;https://addons.mozilla.org/firefox/addon/sqlite-manager&gt;.</p>
<p class="Pp">Have a look at the schema classes files in the subdirectory
    <i>MyApp</i>. The <span class="Li">&quot;MyApp::Schema&quot;</span> class is
    the entry point for loading the other classes and interacting with the
    database through DBIC and the <span class="Li">&quot;Result&quot;</span>
    classes correspond to the tables in the database.
    DBIx::Class::Manual::Example shows how to write all that Perl code. That is
    almost never necessary, though. Instead use dbicdump (part of the
    distribution DBIx::Class::Schema::Loader) to automatically create schema
    classes files from an existing database. The chapter &quot;Resetting the
    database&quot; below shows an example invocation.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Connecting_to_the_database"><a class="permalink" href="#Connecting_to_the_database">Connecting
  to the database</a></h2>
<p class="Pp">A schema object represents the database.</p>
<p class="Pp"></p>
<pre>    use MyApp::Schema qw();
    my $schema = MyApp::Schema-&gt;connect('dbi:SQLite:db/example.db');
</pre>
<p class="Pp">The first four arguments are the same as for &quot;connect&quot;
    in DBI.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Working_with_data"><a class="permalink" href="#Working_with_data">Working
  with data</a></h2>
<p class="Pp">Almost all actions go through a resultset object.</p>
<p class="Pp"><i>Adding data</i></p>
<p class="Pp">Via intermediate result objects:</p>
<p class="Pp"></p>
<pre>    my $artist_ma = $schema-&gt;resultset('Artist')-&gt;create({
        name =&gt; 'Massive Attack',
    });
    my $cd_mezz = $artist_ma-&gt;create_related(cds =&gt; {
        title =&gt; 'Mezzanine',
    });
    for ('Angel', 'Teardrop') {
        $cd_mezz-&gt;create_related(tracks =&gt; {
            title =&gt; $_
        });
    }
</pre>
<p class="Pp">Via relation accessors:</p>
<p class="Pp"></p>
<pre>    $schema-&gt;resultset('Artist')-&gt;create({
        name =&gt; 'Metallica',
        cds =&gt; [
            {
                title =&gt; q{Kill 'Em All},
                tracks =&gt; [
                    { title =&gt; 'Jump in the Fire' },
                    { title =&gt; 'Whiplash' },
                ],
            },
            {
                title =&gt; 'ReLoad',
                tracks =&gt; [
                    { title =&gt; 'The Memory Remains' },
                    { title =&gt; 'The Unforgiven II' },
                    { title =&gt; 'Fuel' },
                ],
            },
        ],
    });
</pre>
<p class="Pp">Columns that are not named are filled with default values. The
    value <span class="Li">&quot;undef&quot;</span> acts as a
    <span class="Li">&quot;NULL&quot;</span> in the database.</p>
<p class="Pp">See the chapter &quot;Introspecting the schema classes&quot; below
    to find out where the non-obvious source name strings such as
    <span class="Li">&quot;Artist&quot;</span> and accessors such as
    <span class="Li">&quot;cds&quot;</span> and
    <span class="Li">&quot;tracks&quot;</span> come from.</p>
<p class="Pp">Set the environment variable
    <span class="Li">&quot;DBI_TRACE='1|SQL'&quot;</span> to see the generated
    queries.</p>
<p class="Pp"><i>Retrieving data</i></p>
<p class="Pp">Set up a condition.</p>
<p class="Pp"></p>
<pre>    my $artists_starting_with_m = $schema-&gt;resultset('Artist')-&gt;search(
        {
            name =&gt; { like =&gt; 'M%' }
        }
    );
</pre>
<p class="Pp">Iterate over result objects of class
    <span class="Li">&quot;MyApp::Schema::Result::Artist&quot;</span>. Result
    objects represent a row and automatically get accessors for their column
    names.</p>
<p class="Pp"></p>
<pre>    for my $artist ($artists_starting_with_m-&gt;all) {
        say $artist-&gt;name;
    }
</pre>
<p class="Pp"><i>Changing data</i></p>
<p class="Pp">Change the release year of all CDs titled <i>ReLoad</i>.</p>
<p class="Pp"></p>
<pre>    $schema-&gt;resultset('Cd')-&gt;search(
        {
            title =&gt; 'ReLoad',
        }
    )-&gt;update_all(
        {
            year =&gt; 1997,
        }
    );
</pre>
<p class="Pp"><i>Removing data</i></p>
<p class="Pp">Removes all tracks titled <i>Fuel</i> regardless of which CD the
    belong to.</p>
<p class="Pp"></p>
<pre>    $schema-&gt;resultset('Track')-&gt;search(
        {
            title =&gt; 'Fuel',
        }
    )-&gt;delete_all;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Introspecting_the_schema_classes"><a class="permalink" href="#Introspecting_the_schema_classes">Introspecting
  the schema classes</a></h2>
<p class="Pp">This is useful for getting a feel for the naming of things in a
    REPL or during explorative programming.</p>
<p class="Pp">From the root to the details:</p>
<p class="Pp"></p>
<pre>    $schema-&gt;sources;                       # returns qw(Cd Track Artist)
    $schema-&gt;source('Cd')-&gt;columns;         # returns qw(cdid artist title year)
    $schema-&gt;source('Cd')-&gt;relationships;   # returns qw(artist tracks)
</pre>
<p class="Pp">From a detail to the root:</p>
<p class="Pp"></p>
<pre>    $some_result-&gt;result_source;            # returns appropriate source
    $some_resultset-&gt;result_source;
    $some_resultsource-&gt;schema;             # returns appropriate schema
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Resetting_the_database"><a class="permalink" href="#Resetting_the_database">Resetting
  the database</a></h2>
<pre>    # delete database file
    DBIx-Class/examples/Schema$ rm -f db/example.db
    # create database and set up tables from definition
    DBIx-Class/examples/Schema$ sqlite3 db/example.db &lt; db/example.sql
    # fill them with data
    DBIx-Class/examples/Schema$ perl ./insertdb.pl
    # delete the schema classes files
    DBIx-Class/examples/Schema$ rm -rf MyApp
    # recreate schema classes files from database file
    DBIx-Class/examples/Schema$ dbicdump \
        -o dump_directory=. MyApp::Schema dbi:SQLite:db/example.db
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Where_to_go_next"><a class="permalink" href="#Where_to_go_next">Where
  to go next</a></h2>
<p class="Pp">If you want to exercise what you learned with a more complicated
    schema, load Northwind &lt;http://code.google.com/p/northwindextended/&gt;
    into your database.</p>
<p class="Pp">If you want to transfer your existing SQL knowledge, read
    DBIx::Class::Manual::SQLHackers.</p>
<p class="Pp">Continue with DBIx::Class::Tutorial and &quot;WHERE TO START
    READING&quot; in DBIx::Class.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="FURTHER_QUESTIONS?"><a class="permalink" href="#FURTHER_QUESTIONS?">FURTHER
  QUESTIONS?</a></h1>
<p class="Pp">Check the list of additional DBIC resources.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This module is free software copyright by the DBIx::Class (DBIC)
    authors. You can redistribute it and/or modify it under the same terms as
    the DBIx::Class library.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-12-08</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

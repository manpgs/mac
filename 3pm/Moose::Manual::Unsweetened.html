<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Moose::Manual::Unsweetened(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Moose::Manual::Unsweetened(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Moose::Manual::Unsweetened(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Moose::Manual::Unsweetened - Moose idioms in plain old Perl 5
    without the sugar</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 2.2012</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">If you're trying to figure out just what the heck Moose does, and
    how it saves you time, you might find it helpful to see what Moose is
    <i>really</i> doing for you. This document shows you the translation from
    Moose sugar back to plain old Perl 5.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CLASSES_AND_ATTRIBUTES"><a class="permalink" href="#CLASSES_AND_ATTRIBUTES">CLASSES
  AND ATTRIBUTES</a></h1>
<p class="Pp">First, we define two very small classes the Moose way.</p>
<p class="Pp"></p>
<pre>
  package Person;

  use DateTime;
  use DateTime::Format::Natural;
  use Moose;
  use Moose::Util::TypeConstraints;

  has name =&gt; (
      is       =&gt; 'rw',
      isa      =&gt; 'Str',
      required =&gt; 1,
  );

  # Moose doesn't know about non-Moose-based classes.
  class_type 'DateTime';

  my $en_parser = DateTime::Format::Natural-&gt;new(
      lang      =&gt; 'en',
      time_zone =&gt; 'UTC',
  );

  coerce 'DateTime'
      =&gt; from 'Str'
      =&gt; via { $en_parser-&gt;parse_datetime($_) };

  has birth_date =&gt; (
      is      =&gt; 'rw',
      isa     =&gt; 'DateTime',
      coerce  =&gt; 1,
      handles =&gt; { birth_year =&gt; 'year' },
  );

  enum 'ShirtSize' =&gt; [qw( s m l xl xxl )];

  has shirt_size =&gt; (
      is      =&gt; 'rw',
      isa     =&gt; 'ShirtSize',
      default =&gt; 'l',
  );
</pre>
<p class="Pp">This is a fairly simple class with three attributes. We also
    define an enum type to validate t-shirt sizes because we don't want to end
    up with something like &quot;blue&quot; for the shirt size!</p>
<p class="Pp"></p>
<pre>
  package User;

  use Email::Valid;
  use Moose;
  use Moose::Util::TypeConstraints;

  extends 'Person';

  subtype 'Email'
      =&gt; as 'Str'
      =&gt; where { Email::Valid-&gt;address($_) }
      =&gt; message { &quot;$_ is not a valid email address&quot; };

  has email_address =&gt; (
      is       =&gt; 'rw',
      isa      =&gt; 'Email',
      required =&gt; 1,
  );
</pre>
<p class="Pp">This class subclasses Person to add a single attribute, email
    address.</p>
<p class="Pp">Now we will show what these classes would look like in plain old
    Perl 5. For the sake of argument, we won't use any base classes or any
    helpers like <span class="Li">&quot;Class::Accessor&quot;</span>.</p>
<p class="Pp"></p>
<pre>
  package Person;

  use strict;
  use warnings;

  use Carp qw( confess );
  use DateTime;
  use DateTime::Format::Natural;

  sub new {
      my $class = shift;
      my %p = ref $_[0] ? %{ $_[0] } : @_;

      exists $p{name}
          or confess 'name is a required attribute';
      $class-&gt;_validate_name( $p{name} );

      exists $p{birth_date}
          or confess 'birth_date is a required attribute';

      $p{birth_date} = $class-&gt;_coerce_birth_date( $p{birth_date} );
      $class-&gt;_validate_birth_date( $p{birth_date} );

      $p{shirt_size} = 'l'
          unless exists $p{shirt_size};

      $class-&gt;_validate_shirt_size( $p{shirt_size} );

      return bless \%p, $class;
  }

  sub _validate_name {
      shift;
      my $name = shift;

      local $Carp::CarpLevel = $Carp::CarpLevel + 1;

      defined $name
          or confess 'name must be a string';
  }

  {
      my $en_parser = DateTime::Format::Natural-&gt;new(
          lang      =&gt; 'en',
          time_zone =&gt; 'UTC',
      );

      sub _coerce_birth_date {
          shift;
          my $date = shift;

          return $date unless defined $date &amp;&amp; ! ref $date;

          my $dt = $en_parser-&gt;parse_datetime($date);

          return $dt ? $dt : undef;
      }
  }

  sub _validate_birth_date {
      shift;
      my $birth_date = shift;

      local $Carp::CarpLevel = $Carp::CarpLevel + 1;

      $birth_date-&gt;isa('DateTime')
          or confess 'birth_date must be a DateTime object';
  }

  sub _validate_shirt_size {
      shift;
      my $shirt_size = shift;

      local $Carp::CarpLevel = $Carp::CarpLevel + 1;

      defined $shirt_size
          or confess 'shirt_size cannot be undef';

      my %sizes = map { $_ =&gt; 1 } qw( s m l xl xxl );

      $sizes{$shirt_size}
          or confess &quot;$shirt_size is not a valid shirt size (s, m, l, xl, xxl)&quot;;
  }

  sub name {
      my $self = shift;

      if (@_) {
          $self-&gt;_validate_name( $_[0] );
          $self-&gt;{name} = $_[0];
      }

      return $self-&gt;{name};
  }

  sub birth_date {
      my $self = shift;

      if (@_) {
          my $date = $self-&gt;_coerce_birth_date( $_[0] );
          $self-&gt;_validate_birth_date( $date );

          $self-&gt;{birth_date} = $date;
      }

      return $self-&gt;{birth_date};
  }

  sub birth_year {
      my $self = shift;

      return $self-&gt;birth_date-&gt;year;
  }

  sub shirt_size {
      my $self = shift;

      if (@_) {
          $self-&gt;_validate_shirt_size( $_[0] );
          $self-&gt;{shirt_size} = $_[0];
      }

      return $self-&gt;{shirt_size};
  }
</pre>
<p class="Pp">Wow, that was a mouthful! One thing to note is just how much space
    the data validation code consumes. As a result, it's pretty common for Perl
    5 programmers to just not bother. Unfortunately, not validating arguments
    leads to surprises down the line (&quot;why is birth_date an email
    address?&quot;).</p>
<p class="Pp">Also, did you spot the (intentional) bug?</p>
<p class="Pp">It's in the
    <span class="Li">&quot;_validate_birth_date()&quot;</span> method. We should
    check that the value in <span class="Li">$birth_date</span> is actually
    defined and an object before we go and call
    <span class="Li">&quot;isa()&quot;</span> on it! Leaving out those checks
    means our data validation code could actually cause our program to die.
    Oops.</p>
<p class="Pp">Note that if we add a superclass to Person we'll have to change
    the constructor to account for that.</p>
<p class="Pp">(As an aside, getting all the little details of what Moose does
    for you just right in this example was really not easy, which emphasizes the
    point of the example. Moose saves you a lot of work!)</p>
<p class="Pp">Now let's see User:</p>
<p class="Pp"></p>
<pre>
  package User;

  use strict;
  use warnings;

  use Carp qw( confess );
  use Email::Valid;
  use Scalar::Util qw( blessed );

  use parent 'Person';

  sub new {
      my $class = shift;
      my %p = ref $_[0] ? %{ $_[0] } : @_;

      exists $p{email_address}
          or confess 'email_address is a required attribute';
      $class-&gt;_validate_email_address( $p{email_address} );

      my $self = $class-&gt;SUPER::new(%p);

      $self-&gt;{email_address} = $p{email_address};

      return $self;
  }

  sub _validate_email_address {
      shift;
      my $email_address = shift;

      local $Carp::CarpLevel = $Carp::CarpLevel + 1;

      defined $email_address
          or confess 'email_address must be a string';

      Email::Valid-&gt;address($email_address)
          or confess &quot;$email_address is not a valid email address&quot;;
  }

  sub email_address {
      my $self = shift;

      if (@_) {
          $self-&gt;_validate_email_address( $_[0] );
          $self-&gt;{email_address} = $_[0];
      }

      return $self-&gt;{email_address};
  }
</pre>
<p class="Pp">That one was shorter, but it only has one attribute.</p>
<p class="Pp">Between the two classes, we have a whole lot of code that doesn't
    do much. We could probably simplify this by defining some sort of
    &quot;attribute and validation&quot; hash, like this:</p>
<p class="Pp"></p>
<pre>
  package Person;

  my %Attr = (
      name =&gt; {
          required =&gt; 1,
          validate =&gt; sub { defined $_ },
      },
      birth_date =&gt; {
          required =&gt; 1,
          validate =&gt; sub { blessed $_ &amp;&amp; $_-&gt;isa('DateTime') },
      },
      shirt_size =&gt; {
          required =&gt; 1,
          validate =&gt; sub { defined $_ &amp;&amp; $_ =~ /^(?:s|m|l|xl|xxl)$/i },
      }
  );
</pre>
<p class="Pp">Then we could define a base class that would accept such a
    definition and do the right thing. Keep that sort of thing up and we're well
    on our way to writing a half-assed version of Moose!</p>
<p class="Pp">Of course, there are CPAN modules that do some of what Moose does,
    like <span class="Li">&quot;Class::Accessor&quot;</span>,
    <span class="Li">&quot;Class::Meta&quot;</span>, and so on. But none of them
    put together all of Moose's features along with a layer of declarative
    sugar, nor are these other modules designed for extensibility in the same
    way as Moose. With Moose, it's easy to write a MooseX module to replace or
    extend a piece of built-in functionality.</p>
<p class="Pp">Moose is a complete OO package in and of itself, and is part of a
    rich ecosystem of extensions. It also has an enthusiastic community of users
    and is being actively maintained and developed.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Stevan Little &lt;stevan.little@iinteractive.com&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
  <li>Shawn M Moore &lt;code@sartak.org&gt;</li>
  <li>&#x05D9;&#x05D5;&#x05D1;&#x05DC; &#x05E7;&#x05D5;&#x05D2;'&#x05DE;&#x05DF;
      (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Florian Ragwitz &lt;rafl@debian.org&gt;</li>
  <li>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</li>
  <li>Chris Prather &lt;chris@prather.org&gt;</li>
  <li>Matt S Trout &lt;mst@shadowcat.co.uk&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2006 by Infinity Interactive,
  Inc.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-11-22</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

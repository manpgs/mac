<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Net::DNS::Resolver(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Net::DNS::Resolver(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Net::DNS::Resolver(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Net::DNS::Resolver - DNS resolver class</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
  use Net::DNS;

  my $res = Net::DNS::Resolver-&gt;new;

  # Perform a lookup, using the searchlist if appropriate.
  my $answer = $res-&gt;search('example.com');

  # Perform a lookup, without the searchlist
  my $answer = $res-&gt;query('example.com', 'MX');

  # Perform a lookup, without pre or post-processing
  my $answer = $res-&gt;send('example.com', 'MX', 'CH');

  # Send a prebuilt packet
  my $packet = Net::DNS::Packet-&gt;new(...);
  my $answer = $res-&gt;send($packet);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Instances of the
    <span class="Li">&quot;Net::DNS::Resolver&quot;</span> class represent
    resolver objects. A program can have multiple resolver objects, each
    maintaining its own state information such as the nameservers to be queried,
    whether recursion is desired, etc.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
<pre>
  # Use the system defaults
  my $res = Net::DNS::Resolver-&gt;new;

  # Use my own configuration file
  my $res = Net::DNS::Resolver-&gt;new(config_file =&gt; '/my/dns.conf');

  # Set options in the constructor
  my $res = Net::DNS::Resolver-&gt;new(
        nameservers =&gt; [qw(10.1.1.128 10.1.2.128)],
        recurse     =&gt; 0,
        debug       =&gt; 1,
  );
</pre>
<p class="Pp">Returns a resolver object. If given no arguments,
    <span class="Li">&quot;new()&quot;</span> returns an object configured to
    your system's defaults. On UNIX systems the defaults are read from the
    following files, in the order indicated:</p>
<p class="Pp"></p>
<pre>
    /etc/resolv.conf
    $HOME/.resolv.conf
    ./.resolv.conf
</pre>
<p class="Pp">The following keywords are recognized in resolver configuration
    files:</p>
<dl class="Bl-tag">
  <dt id="domain"><a class="permalink" href="#domain">domain</a></dt>
  <dd>The default domain.</dd>
  <dt id="search"><a class="permalink" href="#search">search</a></dt>
  <dd>A space-separated list of domains to put in the search list.</dd>
  <dt id="nameserver"><a class="permalink" href="#nameserver">nameserver</a></dt>
  <dd>A space-separated list of nameservers to query.</dd>
</dl>
<p class="Pp">Files except for <i>/etc/resolv.conf</i> must be owned by the
    effective userid running the program or they won't be read. In addition,
    several environment variables can also contain configuration information;
    see &quot;ENVIRONMENT&quot;.</p>
<p class="Pp">On Windows systems, an attempt is made to determine the system
    defaults using the registry. This is still a work in progress; systems with
    many dynamically configured network interfaces may confuse Net::DNS.</p>
<p class="Pp">You can include a configuration file of your own when creating a
    resolver object:</p>
<p class="Pp"></p>
<pre>
 # Use my own configuration file
 my $res = Net::DNS::Resolver-&gt;new(config_file =&gt; '/my/dns.conf');
</pre>
<p class="Pp">This is supported on both UNIX and Windows. Values pulled from a
    custom configuration file override the the system's defaults, but can still
    be overridden by the other arguments to <b>new()</b>.</p>
<p class="Pp">Explicit arguments to new override both the system's defaults and
    the values of the custom configuration file, if any. The following arguments
    to <b>new()</b> are supported:</p>
<dl class="Bl-tag">
  <dt id="nameservers"><a class="permalink" href="#nameservers">nameservers</a></dt>
  <dd>An array reference of nameservers to query.</dd>
  <dt id="searchlist"><a class="permalink" href="#searchlist">searchlist</a></dt>
  <dd>An array reference of domains.</dd>
  <dt id="recurse"><a class="permalink" href="#recurse">recurse</a></dt>
  <dd></dd>
  <dt id="debug"><a class="permalink" href="#debug">debug</a></dt>
  <dd></dd>
  <dt id="domain~2"><a class="permalink" href="#domain~2">domain</a></dt>
  <dd></dd>
  <dt id="port"><a class="permalink" href="#port">port</a></dt>
  <dd></dd>
  <dt id="srcaddr"><a class="permalink" href="#srcaddr">srcaddr</a></dt>
  <dd></dd>
  <dt id="srcport"><a class="permalink" href="#srcport">srcport</a></dt>
  <dd></dd>
  <dt id="tcp_timeout"><a class="permalink" href="#tcp_timeout">tcp_timeout</a></dt>
  <dd></dd>
  <dt id="udp_timeout"><a class="permalink" href="#udp_timeout">udp_timeout</a></dt>
  <dd></dd>
  <dt id="retrans"><a class="permalink" href="#retrans">retrans</a></dt>
  <dd></dd>
  <dt id="retry"><a class="permalink" href="#retry">retry</a></dt>
  <dd></dd>
  <dt id="usevc"><a class="permalink" href="#usevc">usevc</a></dt>
  <dd></dd>
  <dt id="stayopen"><a class="permalink" href="#stayopen">stayopen</a></dt>
  <dd></dd>
  <dt id="igntc"><a class="permalink" href="#igntc">igntc</a></dt>
  <dd></dd>
  <dt id="defnames"><a class="permalink" href="#defnames">defnames</a></dt>
  <dd></dd>
  <dt id="dnsrch"><a class="permalink" href="#dnsrch">dnsrch</a></dt>
  <dd></dd>
  <dt id="persistent_tcp"><a class="permalink" href="#persistent_tcp">persistent_tcp</a></dt>
  <dd></dd>
  <dt id="persistent_udp"><a class="permalink" href="#persistent_udp">persistent_udp</a></dt>
  <dd></dd>
  <dt id="dnssec"><a class="permalink" href="#dnssec">dnssec</a></dt>
  <dd></dd>
</dl>
<p class="Pp">For more information on any of these options, please consult the
    method of the same name.</p>
</section>
<section class="Ss">
<h2 class="Ss">search</h2>
<pre>
    $packet = $res-&gt;search('mailhost');
    $packet = $res-&gt;search('mailhost.example.com');
    $packet = $res-&gt;search('192.168.1.1');
    $packet = $res-&gt;search('example.com', 'MX');
    $packet = $res-&gt;search('user.passwd.example.com', 'TXT', 'HS');
</pre>
<p class="Pp">Performs a DNS query for the given name, applying the searchlist
    if appropriate. The search algorithm is as follows:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>If the name contains at least one dot, try it as is.</dd>
  <dt>2.</dt>
  <dd>If the name doesn't end in a dot then append each item in the search list
      to the name. This is only done if <b>dnsrch</b> is true.</dd>
  <dt>3.</dt>
  <dd>If the name doesn't contain any dots, try it as is.</dd>
</dl>
<p class="Pp">The record type and class can be omitted; they default to A and
    IN. If the name looks like an IP address (4 dot-separated numbers), then an
    appropriate PTR query will be performed.</p>
<p class="Pp">Returns a &quot;Net::DNS::Packet&quot; object, or
    &quot;undef&quot; if no answers were found. If you need to examine the
    response packet whether it contains any answers or not, use the
    <b>send()</b> method instead.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="query"><a class="permalink" href="#query">query</a></h2>
<pre>
    $packet = $res-&gt;query('mailhost');
    $packet = $res-&gt;query('mailhost.example.com');
    $packet = $res-&gt;query('192.168.1.1');
    $packet = $res-&gt;query('example.com', 'MX');
    $packet = $res-&gt;query('user.passwd.example.com', 'TXT', 'HS');
</pre>
<p class="Pp">Performs a DNS query for the given name; the search list is not
    applied. If the name doesn't contain any dots and <b>defnames</b> is true
    then the default domain will be appended.</p>
<p class="Pp">The record type and class can be omitted; they default to A and
    IN. If the name looks like an IP address (IPv4 or IPv6), then an appropriate
    PTR query will be performed.</p>
<p class="Pp">Returns a &quot;Net::DNS::Packet&quot; object, or
    &quot;undef&quot; if no answers were found. If you need to examine the
    response packet whether it contains any answers or not, use the
    <b>send()</b> method instead.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="send"><a class="permalink" href="#send">send</a></h2>
<pre>
    $packet = $res-&gt;send($packet_object);
    $packet = $res-&gt;send('mailhost.example.com');
    $packet = $res-&gt;send('example.com', 'MX');
    $packet = $res-&gt;send('user.passwd.example.com', 'TXT', 'HS');
</pre>
<p class="Pp">Performs a DNS query for the given name. Neither the searchlist
    nor the default domain will be appended.</p>
<p class="Pp">The argument list can be either a
    <span class="Li">&quot;Net::DNS::Packet&quot;</span> object or a list of
    strings. The record type and class can be omitted; they default to A and IN.
    If the name looks like an IP address (Ipv4 or IPv6), then an appropriate PTR
    query will be performed.</p>
<p class="Pp">Returns a <span class="Li">&quot;Net::DNS::Packet&quot;</span>
    object whether there were any answers or not. Use
    <span class="Li">&quot;$packet-&gt;header-&gt;ancount&quot;</span> or
    <span class="Li">&quot;$packet-&gt;answer&quot;</span> to find out if there
    were any records in the answer section. Returns
    <span class="Li">&quot;undef&quot;</span> if there was an error.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="axfr"><a class="permalink" href="#axfr">axfr</a></h2>
<pre>
    @zone = $res-&gt;axfr;
    @zone = $res-&gt;axfr('example.com');
    @zone = $res-&gt;axfr('passwd.example.com', 'HS');
</pre>
<p class="Pp">Performs a zone transfer from the first nameserver listed in
    <span class="Li">&quot;nameservers&quot;</span>. If the zone is omitted, it
    defaults to the first zone listed in the resolver's search list. If the
    class is omitted, it defaults to IN.</p>
<p class="Pp">Returns a list of <span class="Li">&quot;Net::DNS::RR&quot;</span>
    objects, or <span class="Li">&quot;undef&quot;</span> if the zone transfer
    failed.</p>
<p class="Pp">The redundant SOA record that terminates the zone transfer is not
    returned to the caller.</p>
<p class="Pp">See also &quot;axfr_start&quot; and &quot;axfr_next&quot;.</p>
<p class="Pp">Here's an example that uses a timeout:</p>
<p class="Pp"></p>
<pre>
    $res-&gt;tcp_timeout(10);
    my @zone = $res-&gt;axfr('example.com');

    if (@zone) {
        foreach my $rr (@zone) {
            $rr-&gt;print;
        }
    } else {
        print 'Zone transfer failed: ', $res-&gt;errorstring, &quot;\n&quot;;
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="axfr_start"><a class="permalink" href="#axfr_start">axfr_start</a></h2>
<pre>
    $res-&gt;axfr_start;
    $res-&gt;axfr_start('example.com');
    $res-&gt;axfr_start('example.com', 'HS');
</pre>
<p class="Pp">Starts a zone transfer from the first nameserver listed in
    <span class="Li">&quot;nameservers&quot;</span>. If the zone is omitted, it
    defaults to the first zone listed in the resolver's search list. If the
    class is omitted, it defaults to IN.</p>
<p class="Pp"><b>IMPORTANT</b>:</p>
<p class="Pp">This method currently returns the
    <span class="Li">&quot;IO::Socket::INET&quot;</span> object that will be
    used for reading, or <span class="Li">&quot;undef&quot;</span> on error. DO
    NOT DEPEND ON <span class="Li">&quot;axfr_start()&quot;</span> returning a
    socket object. THIS MIGHT CHANGE in future releases.</p>
<p class="Pp">Use <span class="Li">&quot;axfr_next&quot;</span> to read the zone
    records one at a time.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="axfr_next"><a class="permalink" href="#axfr_next">axfr_next</a></h2>
<pre>
    $res-&gt;axfr_start('example.com');

    while (my $rr = $res-&gt;axfr_next) {
            $rr-&gt;print;
    }
</pre>
<p class="Pp">Reads records from a zone transfer one at a time.</p>
<p class="Pp">Returns <span class="Li">&quot;undef&quot;</span> at the end of
    the zone transfer. The redundant SOA record that terminates the zone
    transfer is not returned.</p>
<p class="Pp">See also &quot;axfr&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss">nameservers</h2>
<pre>
    @nameservers = $res-&gt;nameservers;
    $res-&gt;nameservers('192.168.1.1', '192.168.2.2', '192.168.3.3');
</pre>
<p class="Pp">Gets or sets the nameservers to be queried.</p>
<p class="Pp">Also see the IPv6 transport notes below</p>
</section>
<section class="Ss">
<h2 class="Ss" id="empty_nameservers"><a class="permalink" href="#empty_nameservers">empty_nameservers</a></h2>
<pre>
    $res-&gt;empty_nameservers();
</pre>
<p class="Pp">Empties the list of nameservers.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="print"><a class="permalink" href="#print">print</a></h2>
<pre>
    $res-&gt;print;
</pre>
<p class="Pp">Prints the resolver state on the standard output.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="string"><a class="permalink" href="#string">string</a></h2>
<pre>
    print $res-&gt;string;
</pre>
<p class="Pp">Returns a string representation of the resolver state.</p>
</section>
<section class="Ss">
<h2 class="Ss">searchlist</h2>
<pre>
    @searchlist = $res-&gt;searchlist;
    $res-&gt;searchlist('example.com', 'a.example.com', 'b.example.com');
</pre>
<p class="Pp">Gets or sets the resolver search list.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="empty_searchlist"><a class="permalink" href="#empty_searchlist">empty_searchlist</a></h2>
<pre>
    $res-&gt;empty_searchlist();
</pre>
<p class="Pp">Empties the searchlist.</p>
</section>
<section class="Ss">
<h2 class="Ss">port</h2>
<pre>
    print 'sending queries to port ', $res-&gt;port, &quot;\n&quot;;
    $res-&gt;port(9732);
</pre>
<p class="Pp">Gets or sets the port to which we send queries. This can be useful
    for testing a nameserver running on a non-standard port. The default is port
    53.</p>
</section>
<section class="Ss">
<h2 class="Ss">srcport</h2>
<pre>
    print 'sending queries from port ', $res-&gt;srcport, &quot;\n&quot;;
    $res-&gt;srcport(5353);
</pre>
<p class="Pp">Gets or sets the port from which we send queries. The default is
    0, meaning any port.</p>
</section>
<section class="Ss">
<h2 class="Ss">srcaddr</h2>
<pre>
    print 'sending queries from address ', $res-&gt;srcaddr, &quot;\n&quot;;
    $res-&gt;srcaddr('192.168.1.1');
</pre>
<p class="Pp">Gets or sets the source address from which we send queries.
    Convenient for forcing queries out a specific interfaces on a multi-homed
    host. The default is 0.0.0.0, meaning any local address.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="bgsend"><a class="permalink" href="#bgsend">bgsend</a></h2>
<pre>
    $socket = $res-&gt;bgsend($packet_object) || die &quot; $res-&gt;errorstring&quot;;

    $socket = $res-&gt;bgsend('mailhost.example.com');
    $socket = $res-&gt;bgsend('example.com', 'MX');
    $socket = $res-&gt;bgsend('user.passwd.example.com', 'TXT', 'HS');
</pre>
<p class="Pp">Performs a background DNS query for the given name, i.e., sends a
    query packet to the first nameserver listed in
    <span class="Li">&quot;$res-&gt;nameservers&quot;</span> and returns
    immediately without waiting for a response. The program can then perform
    other tasks while waiting for a response from the nameserver.</p>
<p class="Pp">The argument list can be either a
    <span class="Li">&quot;Net::DNS::Packet&quot;</span> object or a list of
    strings. The record type and class can be omitted; they default to A and IN.
    If the name looks like an IP address (4 dot-separated numbers), then an
    appropriate PTR query will be performed.</p>
<p class="Pp">Returns an <span class="Li">&quot;IO::Socket::INET&quot;</span>
    object or <span class="Li">&quot;undef&quot;</span> on error in which case
    the reason for failure can be found through a call to the errorstring
    method.</p>
<p class="Pp">The program must determine when the socket is ready for reading
    and call <span class="Li">&quot;$res-&gt;bgread&quot;</span> to get the
    response packet. You can use
    <span class="Li">&quot;$res-&gt;bgisready&quot;</span> or
    <span class="Li">&quot;IO::Select&quot;</span> to find out if the socket is
    ready before reading it.</p>
<p class="Pp">bgsend does not support persistent sockets.</p>
<p class="Pp"><b>BEWARE</b>: bgsend does not support the usevc option (TCP) and
    operates on UDP only; Answers may not fit in an UDP packet and might be
    truncated. Truncated packets will <b>not</b> be retried over TCP
    automatically and should be handled by the caller.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="bgread"><a class="permalink" href="#bgread">bgread</a></h2>
<pre>
    $packet = $res-&gt;bgread($socket);
    if ($packet-&gt;header-&gt;tc) { 
        # Retry over TCP (blocking).
    }
    undef $socket;
</pre>
<p class="Pp">Reads the answer from a background query (see &quot;bgsend&quot;).
    The argument is an <span class="Li">&quot;IO::Socket&quot;</span> object
    returned by <span class="Li">&quot;bgsend&quot;</span>.</p>
<p class="Pp">Returns a <span class="Li">&quot;Net::DNS::Packet&quot;</span>
    object or <span class="Li">&quot;undef&quot;</span> on error.</p>
<p class="Pp">The programmer should close or destroy the socket object after
    reading it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="bgisready"><a class="permalink" href="#bgisready">bgisready</a></h2>
<pre>
    $socket = $res-&gt;bgsend('foo.example.com');
    until ($res-&gt;bgisready($socket)) {
        # do some other processing
    }
    $packet = $res-&gt;bgread($socket);
    if ($packet-&gt;header-&gt;tc) { 
        # Retry over TCP (blocking).
    }
    $socket = undef;
</pre>
<p class="Pp">Determines whether a socket is ready for reading. The argument is
    an <span class="Li">&quot;IO::Socket&quot;</span> object returned by
    <span class="Li">&quot;$res-&gt;bgsend&quot;</span>.</p>
<p class="Pp">Returns true if the socket is ready, false if not.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="tsig"><a class="permalink" href="#tsig">tsig</a></h2>
<pre>
    my $tsig = $res-&gt;tsig;

    $res-&gt;tsig(Net::DNS::RR-&gt;new(&quot;$key_name TSIG $key&quot;));

    $tsig = Net::DNS::RR-&gt;new(&quot;$key_name TSIG $key&quot;);
    $tsig-&gt;fudge(60);
    $res-&gt;tsig($tsig);

    $res-&gt;tsig($key_name, $key);

    $res-&gt;tsig(0);
</pre>
<p class="Pp">Get or set the TSIG record used to automatically sign outgoing
    queries and updates. Call with an argument of 0 or '' to turn off automatic
    signing.</p>
<p class="Pp">The default resolver behavior is not to sign any packets. You must
    call this method to set the key if you'd like the resolver to sign packets
    automatically.</p>
<p class="Pp">You can also sign packets manually -- see the
    <span class="Li">&quot;Net::DNS::Packet&quot;</span> and
    <span class="Li">&quot;Net::DNS::Update&quot;</span> manual pages for
    examples. TSIG records in manually-signed packets take precedence over those
    that the resolver would add automatically.</p>
</section>
<section class="Ss">
<h2 class="Ss">retrans</h2>
<pre>
    print 'retrans interval: ', $res-&gt;retrans, &quot;\n&quot;;
    $res-&gt;retrans(3);
</pre>
<p class="Pp">Get or set the retransmission interval. The default is 5.</p>
</section>
<section class="Ss">
<h2 class="Ss">retry</h2>
<pre>
    print 'number of tries: ', $res-&gt;retry, &quot;\n&quot;;
    $res-&gt;retry(2);
</pre>
<p class="Pp">Get or set the number of times to try the query. The default is
  4.</p>
</section>
<section class="Ss">
<h2 class="Ss">recurse</h2>
<pre>
    print 'recursion flag: ', $res-&gt;recurse, &quot;\n&quot;;
    $res-&gt;recurse(0);
</pre>
<p class="Pp">Get or set the recursion flag. If this is true, nameservers will
    be requested to perform a recursive query. The default is true.</p>
</section>
<section class="Ss">
<h2 class="Ss">defnames</h2>
<pre>
    print 'defnames flag: ', $res-&gt;defnames, &quot;\n&quot;;
    $res-&gt;defnames(0);
</pre>
<p class="Pp">Get or set the defnames flag. If this is true, calls to
    <b>query</b> will append the default domain to names that contain no dots.
    The default is true.</p>
</section>
<section class="Ss">
<h2 class="Ss">dnsrch</h2>
<pre>
    print 'dnsrch flag: ', $res-&gt;dnsrch, &quot;\n&quot;;
    $res-&gt;dnsrch(0);
</pre>
<p class="Pp">Get or set the dnsrch flag. If this is true, calls to
    <b>search</b> will apply the search list. The default is true.</p>
</section>
<section class="Ss">
<h2 class="Ss">debug</h2>
<pre>
    print 'debug flag: ', $res-&gt;debug, &quot;\n&quot;;
    $res-&gt;debug(1);
</pre>
<p class="Pp">Get or set the debug flag. If set, calls to <b>search</b>,
    <b>query</b>, and <b>send</b> will print debugging information on the
    standard output. The default is false.</p>
</section>
<section class="Ss">
<h2 class="Ss">usevc</h2>
<pre>
    print 'usevc flag: ', $res-&gt;usevc, &quot;\n&quot;;
    $res-&gt;usevc(1);
</pre>
<p class="Pp">Get or set the usevc flag. If true, then queries will be performed
    using virtual circuits (TCP) instead of datagrams (UDP). The default is
    false.</p>
</section>
<section class="Ss">
<h2 class="Ss">tcp_timeout</h2>
<pre>
    print 'TCP timeout: ', $res-&gt;tcp_timeout, &quot;\n&quot;;
    $res-&gt;tcp_timeout(10);
</pre>
<p class="Pp">Get or set the TCP timeout in seconds. A timeout of
    <span class="Li">&quot;undef&quot;</span> means indefinite. The default is
    120 seconds (2 minutes).</p>
</section>
<section class="Ss">
<h2 class="Ss">udp_timeout</h2>
<pre>
    print 'UDP timeout: ', $res-&gt;udp_timeout, &quot;\n&quot;;
    $res-&gt;udp_timeout(10);
</pre>
<p class="Pp">Get or set the UDP timeout in seconds. A timeout of
    <span class="Li">&quot;undef&quot;</span> means the retry and retrans
    settings will be just utilized to perform the retries until they are
    exhausted. The default is <span class="Li">&quot;undef&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss">persistent_tcp</h2>
<pre>
    print 'Persistent TCP flag: ', $res-&gt;persistent_tcp, &quot;\n&quot;;
    $res-&gt;persistent_tcp(1);
</pre>
<p class="Pp">Get or set the persistent TCP setting. If set to true, Net::DNS
    will keep a TCP socket open for each host:port to which it connects. This is
    useful if you're using TCP and need to make a lot of queries or updates to
    the same nameserver.</p>
<p class="Pp">This option defaults to false unless you're running under a
    SOCKSified Perl, in which case it defaults to true.</p>
</section>
<section class="Ss">
<h2 class="Ss">persistent_udp</h2>
<pre>
    print 'Persistent UDP flag: ', $res-&gt;persistent_udp, &quot;\n&quot;;
    $res-&gt;persistent_udp(1);
</pre>
<p class="Pp">Get or set the persistent UDP setting. If set to true, Net::DNS
    will keep a single UDP socket open for all queries. This is useful if you're
    using UDP and need to make a lot of queries or updates.</p>
</section>
<section class="Ss">
<h2 class="Ss">igntc</h2>
<pre>
    print 'igntc flag: ', $res-&gt;igntc, &quot;\n&quot;;
    $res-&gt;igntc(1);
</pre>
<p class="Pp">Get or set the igntc flag. If true, truncated packets will be
    ignored. If false, truncated packets will cause the query to be retried
    using TCP. The default is false.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="errorstring"><a class="permalink" href="#errorstring">errorstring</a></h2>
<pre>
    print 'query status: ', $res-&gt;errorstring, &quot;\n&quot;;
</pre>
<p class="Pp">Returns a string containing the status of the most recent
  query.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="answerfrom"><a class="permalink" href="#answerfrom">answerfrom</a></h2>
<pre>
    print 'last answer was from: ', $res-&gt;answerfrom, &quot;\n&quot;;
</pre>
<p class="Pp">Returns the IP address from which we received the last answer in
    response to a query.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="answersize"><a class="permalink" href="#answersize">answersize</a></h2>
<pre>
    print 'size of last answer: ', $res-&gt;answersize, &quot;\n&quot;;
</pre>
<p class="Pp">Returns the size in bytes of the last answer we received in
    response to a query.</p>
</section>
<section class="Ss">
<h2 class="Ss">dnssec</h2>
<pre>
    print &quot;dnssec flag: &quot;, $res-&gt;dnssec, &quot;\n&quot;;
    $res-&gt;dnssec(0);
</pre>
<p class="Pp">Enabled DNSSEC this will set the checking disabled flag in the
    query header and add EDNS0 data as in RFC2671 and RFC3225</p>
<p class="Pp">When set to true the answer and additional section of queries from
    secured zones will contain DNSKEY, NSEC and RRSIG records.</p>
<p class="Pp">Setting calling the dnssec method with a non-zero value will set
    the UDP packet size to the default value of 2048. If that is too small or
    too big for your environment you should call the <b>udppacketsize()</b>
    method immediately after.</p>
<p class="Pp"></p>
<pre>
   $res-&gt;dnssec(1);    # turns on DNSSEC and sets udp packetsize to 2048
   $res-&gt;udppacketsize(1028);   # lowers the UDP pakcet size
</pre>
<p class="Pp">The method will Croak::croak with the message &quot;You called the
    <b>Net::DNS::Resolver::dnssec()</b> method but do not have Net::DNS::SEC
    installed at ...&quot; if you call it without Net::DNS::SEC being in your
    <span class="Li">@INC</span> path.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="cdflag"><a class="permalink" href="#cdflag">cdflag</a></h2>
<pre>
    print &quot;checking disabled flag: &quot;, $res-&gt;dnssec, &quot;\n&quot;;
    $res-&gt;dnssec(1);
    $res-&gt;cdflag(1);
</pre>
<p class="Pp">Sets or gets the CD bit for a dnssec query. This bit is always
    zero for non dnssec queries. When the dnssec is enabled the flag defaults to
    0 can be set to 1.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="adflag"><a class="permalink" href="#adflag">adflag</a></h2>
<pre>
    print &quot;checking disabled flag: &quot;, $res-&gt;dnssec, &quot;\n&quot;;
    $res-&gt;dnssec(1);
    $res-&gt;adflag(1);
</pre>
<p class="Pp">Sets or gets the AD bit for a dnssec query. This bit is always
    zero for non dnssec queries. When the dnssec is enabled the flag defaults to
    1.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="udppacketsize"><a class="permalink" href="#udppacketsize">udppacketsize</a></h2>
<pre>
    print &quot;udppacketsize: &quot;, $res-&gt;udppacketsize, &quot;\n&quot;;
    $res-&gt;udppacketsize(2048);
</pre>
<p class="Pp">udppacketsize will set or get the packet size. If set to a value
    greater than <b>Net::DNS::PACKETSZ()</b> an EDNS extension will be added
    indicating support for MTU path recovery.</p>
<p class="Pp">Default udppacketsize is <b>Net::DNS::PACKETSZ()</b> (512)</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CUSTOMIZING"><a class="permalink" href="#CUSTOMIZING">CUSTOMIZING</a></h1>
<p class="Pp">Net::DNS::Resolver is actually an empty subclass. At compile time
    a super class is chosen based on the current platform. A side benefit of
    this allows for easy modification of the methods in Net::DNS::Resolver. You
    simply add a method to the namespace!</p>
<p class="Pp">For example, if we wanted to cache lookups:</p>
<p class="Pp"></p>
<pre>
 package Net::DNS::Resolver;

 my %cache;

 sub search {
        my ($self, @args) = @_;

        return $cache{@args} ||= $self-&gt;SUPER::search(@args);
 }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="IPv6_transport"><a class="permalink" href="#IPv6_transport">IPv6
  transport</a></h1>
<p class="Pp">The Net::DNS::Resolver library will use IPv6 transport if the
    appropriate libraries (Socket6 and IO::Socket::INET6) are available and the
    address the server tries to connect to is an IPv6 address.</p>
<p class="Pp">The <b>print()</b> will method will report if IPv6 transport is
    available.</p>
<p class="Pp">You can use the <b>force_v4()</b> method with a non-zero argument
    to force IPv4 transport.</p>
<p class="Pp">The <b>nameserver()</b> method has IPv6 dependend behavior. If
    IPv6 is not available or IPv4 transport has been forced the
    <b>nameserver()</b> method will only return IPv4 addresses.</p>
<p class="Pp">For example</p>
<p class="Pp"></p>
<pre>
    $res-&gt;nameservers('192.168.1.1', '192.168.2.2', '2001:610:240:0:53:0:0:3');
    $res-&gt;force_v4(1);
    print join (&quot; &quot;,$res-&gt;nameserver());
</pre>
<p class="Pp">Will print: 192.168.1.1 192.168.2.2</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ENVIRONMENT"><a class="permalink" href="#ENVIRONMENT">ENVIRONMENT</a></h1>
<p class="Pp">The following environment variables can also be used to configure
    the resolver:</p>
<section class="Ss">
<h2 class="Ss">RES_NAMESERVERS</h2>
<pre>
    # Bourne Shell
    RES_NAMESERVERS=&quot;192.168.1.1 192.168.2.2 192.168.3.3&quot;
    export RES_NAMESERVERS

    # C Shell
    setenv RES_NAMESERVERS &quot;192.168.1.1 192.168.2.2 192.168.3.3&quot;
</pre>
<p class="Pp">A space-separated list of nameservers to query.</p>
</section>
<section class="Ss">
<h2 class="Ss">RES_SEARCHLIST</h2>
<pre>
    # Bourne Shell
    RES_SEARCHLIST=&quot;example.com sub1.example.com sub2.example.com&quot;
    export RES_SEARCHLIST

    # C Shell
    setenv RES_SEARCHLIST &quot;example.com sub1.example.com sub2.example.com&quot;
</pre>
<p class="Pp">A space-separated list of domains to put in the search list.</p>
</section>
<section class="Ss">
<h2 class="Ss">LOCALDOMAIN</h2>
<pre>
    # Bourne Shell
    LOCALDOMAIN=example.com
    export LOCALDOMAIN

    # C Shell
    setenv LOCALDOMAIN example.com
</pre>
<p class="Pp">The default domain.</p>
</section>
<section class="Ss">
<h2 class="Ss">RES_OPTIONS</h2>
<pre>
    # Bourne Shell
    RES_OPTIONS=&quot;retrans:3 retry:2 debug&quot;
    export RES_OPTIONS

    # C Shell
    setenv RES_OPTIONS &quot;retrans:3 retry:2 debug&quot;
</pre>
<p class="Pp">A space-separated list of resolver options to set. Options that
    take values are specified as <i>option</i>:<i>value</i>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">Error reporting and handling needs to be improved.</p>
<p class="Pp">The current implementation supports TSIG only on outgoing packets.
    No validation of server replies is performed.</p>
<p class="Pp">bgsend does not honor the usevc flag and only uses UDP for
    transport.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 1997-2002 Michael Fuhr.</p>
<p class="Pp">Portions Copyright (c) 2002-2004 Chris Reinhardt. Portions
    Copyright (c) 2005 Olaf M. Kolkman, NLnet Labs.</p>
<p class="Pp">All rights reserved. This program is free software; you may
    redistribute it and/or modify it under the same terms as Perl itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">perl, Net::DNS, Net::DNS::Packet, Net::DNS::Update,
    Net::DNS::Header, Net::DNS::Question, Net::DNS::RR, <b>resolver</b>(5), RFC
    1035, RFC 1034 Section 4.3.5</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-16</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Net::DNS::Nameserver(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Net::DNS::Nameserver(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Net::DNS::Nameserver(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Net::DNS::Nameserver - DNS server class</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
    use Net::DNS::Nameserver;

    $nameserver = new Net::DNS::Nameserver(
        LocalAddr        =&gt; ['::1' , '127.0.0.1' ],
        LocalPort        =&gt; &quot;5353&quot;,
        ReplyHandler =&gt; \&amp;reply_handler,
        Verbose          =&gt; 1,
        Truncate         =&gt; 0
    );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Instances of the
    <span class="Li">&quot;Net::DNS::Nameserver&quot;</span> class represent DNS
    server objects. See &quot;EXAMPLE&quot; for an example.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
<pre>
    my $ns = new Net::DNS::Nameserver(
        LocalAddr       =&gt; &quot;10.1.2.3&quot;,
        LocalPort       =&gt; &quot;5353&quot;,
        ReplyHandler    =&gt; \&amp;reply_handler,
        Verbose         =&gt; 1
        );



    my $ns = new Net::DNS::Nameserver(
        LocalAddr       =&gt; ['::1' , '127.0.0.1' ],
        LocalPort       =&gt; &quot;5353&quot;,
        ReplyHandler    =&gt; \&amp;reply_handler,
        Verbose         =&gt; 1,
        Truncate        =&gt; 0
        );
</pre>
<p class="Pp">Returns a Net::DNS::Nameserver object, or undef if the object
    could not be created.</p>
<p class="Pp">Attributes are:</p>
<p class="Pp"></p>
<pre>
    LocalAddr           IP address on which to listen.  Defaults to INADDR_ANY.
    LocalPort           Port on which to listen.        Defaults to 53.
    ReplyHandler        Reference to reply-handling
                        subroutine                      Required.
    NotifyHandler       Reference to reply-handling
                        subroutine for queries with
                        opcode NOTIFY (RFC1996)
    Verbose             Print info about received
                        queries.                        Defaults to 0 (off).
    Truncate            Truncates UDP packets that
                        are too big for the reply       Defaults to 1 (on)
    IdleTimeout         TCP clients are disconnected
                        if they are idle longer than
                        this duration.                  Defaults to 120 (secs)
</pre>
<p class="Pp">The LocalAddr attribute may alternatively be specified as a list
    of IP addresses to listen to.</p>
<p class="Pp">If IO::Socket::INET6 and Socket6 are available on the system you
    can also list IPv6 addresses and the default is '0' (listen on all
    interfaces on IPv6 and IPv4);</p>
<p class="Pp">The ReplyHandler subroutine is passed the query name, query class,
    query type and optionally an argument containing the peerhost, the incoming
    query, and the name of the incoming socket (sockethost). It must either
    return the response code and references to the answer, authority, and
    additional sections of the response, or undef to leave the query unanswered.
    Common response codes are:</p>
<p class="Pp"></p>
<pre>
    NOERROR     No error
    FORMERR     Format error
    SERVFAIL    Server failure
    NXDOMAIN    Non-existent domain (name doesn't exist)
    NOTIMP      Not implemented
    REFUSED     Query refused
</pre>
<p class="Pp">For advanced usage it may also contain a headermask containing an
    hashref with the settings for the <span class="Li">&quot;aa&quot;</span>,
    <span class="Li">&quot;ra&quot;</span>, and
    <span class="Li">&quot;ad&quot;</span> header bits. The argument is of the
    form <span class="Li">&quot;{ ad =&gt; 1, aa =&gt; 0, ra =&gt; 1
    }&quot;</span>.</p>
<p class="Pp">See RFC 1035 and the IANA dns-parameters file for more
    information:</p>
<p class="Pp"></p>
<pre>
  ftp://ftp.rfc-editor.org/in-notes/rfc1035.txt
  http://www.isi.edu/in-notes/iana/assignments/dns-parameters
</pre>
<p class="Pp">The nameserver will listen for both UDP and TCP connections. On
    Unix-like systems, the program will probably have to run as root to listen
    on the default port, 53.	A non-privileged user should be able to listen on
    ports 1024 and higher.</p>
<p class="Pp">Packet Truncation is new functionality available in VERSION &gt;
    830. Only UDP replies are truncated. The size limit is determined by the
    advertised EDNS0 size in the query, otherwise 512 is used.</p>
<p class="Pp">If you want to do packet truncation yourself you should set
    Truncate to 0 and truncate the reply packet in the code of the
  ReplyHandler.</p>
<p class="Pp">See &quot;EXAMPLE&quot; for an example.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="main_loop"><a class="permalink" href="#main_loop">main_loop</a></h2>
<pre>
    $ns-&gt;main_loop;
</pre>
<p class="Pp">Start accepting queries. Calling main_loop never returns.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="loop_once"><a class="permalink" href="#loop_once">loop_once</a></h2>
<pre>
    $ns-&gt;loop_once( [TIMEOUT_IN_SECONDS] );
</pre>
<p class="Pp">Start accepting queries, but returns. If called without a
    parameter, the call will not return until a request has been received (and
    replied to). If called with a number, that number specifies how many seconds
    (even fractional) to maximum wait before returning. If called with 0 it will
    return immediately unless there's something to do.</p>
<p class="Pp">Handling a request and replying obviously depends on the speed of
    ReplyHandler. Assuming ReplyHandler is super fast, loop_once should spend
    just a fraction of a second, if called with a timeout value of 0 seconds.
    One exception is when an AXFR has requested a huge amount of data that the
    OS is not ready to receive in full. In that case, it will keep running
    through a loop (while servicing new requests) until the reply has been
  sent.</p>
<p class="Pp">In case loop_once accepted a TCP connection it will immediatly
    check if there is data to be read from the socket. If not it will return and
    you will have to call <b>loop_once()</b> again to check if there is any data
    waiting on the socket to be processed. In most cases you will have to count
    on calling &quot;loop_once&quot; twice.</p>
<p class="Pp">A code fragment like:</p>
<p class="Pp"></p>
<pre>
    $ns-&gt;loop_once(10);
    while( $ns-&gt;get_open_tcp() ){
        $ns-&gt;loop_once(0);
    }
</pre>
<p class="Pp">Would wait for 10 seconds for the initial connection and would
    then process all TCP sockets until none is left.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="get_open_tcp"><a class="permalink" href="#get_open_tcp">get_open_tcp</a></h2>
<p class="Pp">In scalar context returns the number of TCP connections for which
    state is maintained. In array context it returns IO::Socket objects, these
    could be useful for troubleshooting but be careful using them.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLE"><a class="permalink" href="#EXAMPLE">EXAMPLE</a></h1>
<p class="Pp">The following example will listen on port 5353 and respond to all
    queries for A records with the IP address 10.1.2.3.	 All other queries will
    be answered with NXDOMAIN.	 Authority and additional sections are left
    empty. The <span class="Li">$peerhost</span> variable catches the IP address
    of the peer host, so that additional filtering on its basis may be
  applied.</p>
<p class="Pp"></p>
<pre>
    #!/usr/bin/perl

    use strict;
    use warnings;
    use Net::DNS::Nameserver;

    sub reply_handler {
        my ($qname, $qclass, $qtype, $peerhost,$query,$conn) = @_;
        my ($rcode, @ans, @auth, @add);

        print &quot;Received query from $peerhost to &quot;. $conn-&gt;{sockhost}. &quot;\n&quot;;
        $query-&gt;print;

        if ($qtype eq &quot;A&quot; &amp;&amp; $qname eq &quot;foo.example.com&quot; ) {
                my ($ttl, $rdata) = (3600, &quot;10.1.2.3&quot;);
                my $rr = new Net::DNS::RR(&quot;$qname $ttl $qclass $qtype $rdata&quot;);
                push @ans, $rr;
                $rcode = &quot;NOERROR&quot;;
        }elsif( $qname eq &quot;foo.example.com&quot; ) {
                $rcode = &quot;NOERROR&quot;;

        }else{
                $rcode = &quot;NXDOMAIN&quot;;
        }

        # mark the answer as authoritive (by setting the 'aa' flag
        return ($rcode, \@ans, \@auth, \@add, { aa =&gt; 1 });
    }

    my $ns = new Net::DNS::Nameserver(
        LocalPort    =&gt; 5353,
        ReplyHandler =&gt; \&amp;reply_handler,
        Verbose      =&gt; 1
        ) || die &quot;couldn't create nameserver object\n&quot;;

    $ns-&gt;main_loop;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">Limitations in perl 5.8.6 makes it impossible to guarantee that
    replies to UDP queries from Net::DNS::Nameserver are sent from the
    IP-address they were received on. This is a problem for machines with
    multiple IP-addresses and causes violation of RFC2181 section 4. Thus a UDP
    socket created listening to INADDR_ANY (all available IP-addresses) will
    reply not necessarily with the source address being the one to which the
    request was sent, but rather with the address that the operating system
    chooses. This is also often called &quot;the closest address&quot;. This
    should really only be a problem on a server which has more than one
    IP-address (besides localhost - any experience with IPv6 complications here,
    would be nice). If this is a problem for you, a work-around would be to not
    listen to INADDR_ANY but to specify each address that you want this module
    to listen on. A separate set of sockets will then be created for each
    IP-address.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (c)1997-2002 Michael Fuhr.</p>
<p class="Pp">Portions Copyright (c)2002-2004 Chris Reinhardt.</p>
<p class="Pp">Portions Copyright (c)2005-2009 O.M, Kolkman, RIPE NCC.</p>
<p class="Pp">Portions Copyright (c)2005 Robert Martin-Legene.</p>
<p class="Pp">All rights reserved.</p>
<p class="Pp">This program is free software; you may redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">perl, Net::DNS, Net::DNS::Resolver, Net::DNS::Packet,
    Net::DNS::Update, Net::DNS::Header, Net::DNS::Question, Net::DNS::RR, RFC
    1035</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-16</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>HTML::Element(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">HTML::Element(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">HTML::Element(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">HTML::Element - Class for objects that represent HTML elements</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">This document describes version 5.07 of HTML::Element, released
    August 31, 2017 as part of HTML-Tree.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use HTML::Element;
    $a = HTML::Element-&gt;new('a', href =&gt; 'http://www.perl.com/');
    $a-&gt;push_content(&quot;The Perl Homepage&quot;);
    $tag = $a-&gt;tag;
    print &quot;$tag starts out as:&quot;,  $a-&gt;starttag, &quot;\n&quot;;
    print &quot;$tag ends as:&quot;,  $a-&gt;endtag, &quot;\n&quot;;
    print &quot;$tag\'s href attribute is: &quot;, $a-&gt;attr('href'), &quot;\n&quot;;
    $links_r = $a-&gt;extract_links();
    print &quot;Hey, I found &quot;, scalar(@$links_r), &quot; links.\n&quot;;
    print &quot;And that, as HTML, is: &quot;, $a-&gt;as_HTML, &quot;\n&quot;;
    $a = $a-&gt;delete;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">(This class is part of the HTML::Tree dist.)</p>
<p class="Pp">Objects of the HTML::Element class can be used to represent
    elements of HTML document trees. These objects have attributes, notably
    attributes that designates each element's parent and content. The content is
    an array of text segments and other HTML::Element objects. A tree with
    HTML::Element objects as nodes can represent the syntax tree for a HTML
    document.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="HOW_WE_REPRESENT_TREES"><a class="permalink" href="#HOW_WE_REPRESENT_TREES">HOW
  WE REPRESENT TREES</a></h1>
<p class="Pp">Consider this HTML document:</p>
<p class="Pp"></p>
<pre>  &lt;html lang='en-US'&gt;
    &lt;head&gt;
      &lt;title&gt;Stuff&lt;/title&gt;
      &lt;meta name='author' content='Jojo'&gt;
    &lt;/head&gt;
    &lt;body&gt;
     &lt;h1&gt;I like potatoes!&lt;/h1&gt;
    &lt;/body&gt;
  &lt;/html&gt;
</pre>
<p class="Pp">Building a syntax tree out of it makes a tree-structure in memory
    that could be diagrammed as:</p>
<p class="Pp"></p>
<pre>                     html (lang='en-US')
                      / \
                    /     \
                  /         \
                head        body
               /\               \
             /    \               \
           /        \               \
         title     meta              h1
          |       (name='author',     |
       &quot;Stuff&quot;    content='Jojo')    &quot;I like potatoes&quot;
</pre>
<p class="Pp">This is the traditional way to diagram a tree, with the
    &quot;root&quot; at the top, and it's this kind of diagram that people have
    in mind when they say, for example, that &quot;the meta element is under the
    head element instead of under the body element&quot;. (The same is also said
    with &quot;inside&quot; instead of &quot;under&quot; -- the use of
    &quot;inside&quot; makes more sense when you're looking at the HTML
  source.)</p>
<p class="Pp">Another way to represent the above tree is with indenting:</p>
<p class="Pp"></p>
<pre>  html (attributes: lang='en-US')
    head
      title
        &quot;Stuff&quot;
      meta (attributes: name='author' content='Jojo')
    body
      h1
        &quot;I like potatoes&quot;
</pre>
<p class="Pp">Incidentally, diagramming with indenting works much better for
    very large trees, and is easier for a program to generate. The
    <span class="Li">&quot;$tree-&gt;dump&quot;</span> method uses indentation
    just that way.</p>
<p class="Pp">However you diagram the tree, it's stored the same in memory --
    it's a network of objects, each of which has attributes like so:</p>
<p class="Pp"></p>
<pre>  element #1:  _tag: 'html'
               _parent: none
               _content: [element #2, element #5]
               lang: 'en-US'
  element #2:  _tag: 'head'
               _parent: element #1
               _content: [element #3, element #4]
  element #3:  _tag: 'title'
               _parent: element #2
               _content: [text segment &quot;Stuff&quot;]
  element #4   _tag: 'meta'
               _parent: element #2
               _content: none
               name: author
               content: Jojo
  element #5   _tag: 'body'
               _parent: element #1
               _content: [element #6]
  element #6   _tag: 'h1'
               _parent: element #5
               _content: [text segment &quot;I like potatoes&quot;]
</pre>
<p class="Pp">The &quot;treeness&quot; of the tree-structure that these elements
    comprise is not an aspect of any particular object, but is emergent from the
    relatedness attributes (_parent and _content) of these element-objects and
    from how you use them to get from element to element.</p>
<p class="Pp">While you could access the content of a tree by writing code that
    says &quot;access the 'src' attribute of the root's <i>first</i> child's
    <i>seventh</i> child's <i>third</i> child&quot;, you're more likely to have
    to scan the contents of a tree, looking for whatever nodes, or kinds of
    nodes, you want to do something with. The most straightforward way to look
    over a tree is to &quot;traverse&quot; it; an HTML::Element method
    (<span class="Li">&quot;$h-&gt;traverse&quot;</span>) is provided for this
    purpose; and several other HTML::Element methods are based on it.</p>
<p class="Pp">(For everything you ever wanted to know about trees, and then
    some, see Niklaus Wirth's <i>Algorithms + Data Structures = Programs</i> or
    Donald Knuth's <i>The Art of Computer Programming, Volume 1</i>.)</p>
<section class="Ss">
<h2 class="Ss" id="Weak_References"><a class="permalink" href="#Weak_References">Weak
  References</a></h2>
<p class="Pp">TL;DR summary:
    <span class="Li">&quot;use&#x00A0;HTML::TreeBuilder&#x00A0;5&#x00A0;-weak;&quot;</span>
    and forget about the <span class="Li">&quot;delete&quot;</span> method
    (except for pruning a node from a tree).</p>
<p class="Pp">Because HTML::Element stores a reference to the parent element,
    Perl's reference-count garbage collection doesn't work properly with
    HTML::Element trees. Starting with version 5.00, HTML::Element uses weak
    references (if available) to prevent that problem. Weak references were
    introduced in Perl 5.6.0, but you also need a version of Scalar::Util that
    provides the <span class="Li">&quot;weaken&quot;</span> function.</p>
<p class="Pp">Weak references are enabled by default. If you want to be certain
    they're in use, you can say
    <span class="Li">&quot;use&#x00A0;HTML::Element&#x00A0;5&#x00A0;-weak;&quot;</span>.
    You must include the version number; previous versions of HTML::Element
    ignored the import list entirely.</p>
<p class="Pp">To disable weak references, you can say
    <span class="Li">&quot;use&#x00A0;HTML::Element&#x00A0;-noweak;&quot;</span>.
    This is a global setting. <b>This feature is deprecated</b> and is provided
    only as a quick fix for broken code. If your code does not work properly
    with weak references, you should fix it immediately, as weak references may
    become mandatory in a future version. Generally, all you need to do is keep
    a reference to the root of the tree until you're done working with it.</p>
<p class="Pp">Because HTML::TreeBuilder is a subclass of HTML::Element, you can
    also import <span class="Li">&quot;-weak&quot;</span> or
    <span class="Li">&quot;-noweak&quot;</span> from HTML::TreeBuilder: e.g.
    <span class="Li">&quot;use&#x00A0;HTML::TreeBuilder:&#x00A0;5&#x00A0;-weak;&quot;</span>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BASIC_METHODS"><a class="permalink" href="#BASIC_METHODS">BASIC
  METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
<pre>  $h = HTML::Element-&gt;new('tag', 'attrname' =&gt; 'value', ... );
</pre>
<p class="Pp">This constructor method returns a new HTML::Element object. The
    tag name is a required argument; it will be forced to lowercase. Optionally,
    you can specify other initial attributes at object creation time.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="attr"><a class="permalink" href="#attr">attr</a></h2>
<pre>  $value = $h-&gt;attr('attr');
  $old_value = $h-&gt;attr('attr', $new_value);
</pre>
<p class="Pp">Returns (optionally sets) the value of the given attribute of
    <span class="Li">$h</span>. The attribute name (but not the value, if
    provided) is forced to lowercase. If trying to read the value of an
    attribute not present for this element, the return value is undef. If
    setting a new value, the old value of that attribute is returned.</p>
<p class="Pp">If methods are provided for accessing an attribute (like
    <span class="Li">&quot;$h-&gt;tag&quot;</span> for &quot;_tag&quot;,
    <span class="Li">&quot;$h-&gt;content_list&quot;</span>, etc. below), use
    those instead of calling attr
    <span class="Li">&quot;$h-&gt;attr&quot;</span>, whether for reading or
    setting.</p>
<p class="Pp">Note that setting an attribute to
    <span class="Li">&quot;undef&quot;</span> (as opposed to &quot;&quot;, the
    empty string) actually deletes the attribute.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="tag"><a class="permalink" href="#tag">tag</a></h2>
<pre>  $tagname = $h-&gt;tag();
  $h-&gt;tag('tagname');
</pre>
<p class="Pp">Returns (optionally sets) the tag name (also known as the generic
    identifier) for the element <span class="Li">$h</span>. In setting, the tag
    name is always converted to lower case.</p>
<p class="Pp">There are four kinds of &quot;pseudo-elements&quot; that show up
    as HTML::Element objects:</p>
<dl class="Bl-tag">
  <dt id="Comment"><a class="permalink" href="#Comment">Comment
    pseudo-elements</a></dt>
  <dd>These are element objects with a
      <span class="Li">&quot;$h-&gt;tag&quot;</span> value of
      &quot;~comment&quot;, and the content of the comment is stored in the
      &quot;text&quot; attribute
      (<span class="Li">&quot;$h-&gt;attr(&quot;text&quot;)&quot;</span>). For
      example, parsing this code with HTML::TreeBuilder...
    <p class="Pp"></p>
    <pre>  &lt;!-- I like Pie.
     Pie is good
  --&gt;
    </pre>
    <p class="Pp">produces an HTML::Element object with these attributes:</p>
    <p class="Pp"></p>
    <pre>  &quot;_tag&quot;,
  &quot;~comment&quot;,
  &quot;text&quot;,
  &quot; I like Pie.\n     Pie is good\n  &quot;
    </pre>
  </dd>
  <dt id="Declaration"><a class="permalink" href="#Declaration">Declaration
    pseudo-elements</a></dt>
  <dd>Declarations (rarely encountered) are represented as HTML::Element objects
      with a tag name of &quot;~declaration&quot;, and content in the
      &quot;text&quot; attribute. For example, this:
    <p class="Pp"></p>
    <pre>  &lt;!DOCTYPE foo&gt;
    </pre>
    <p class="Pp">produces an element whose attributes include:</p>
    <p class="Pp"></p>
    <pre>  &quot;_tag&quot;, &quot;~declaration&quot;, &quot;text&quot;, &quot;DOCTYPE foo&quot;
    </pre>
  </dd>
  <dt id="Processing"><a class="permalink" href="#Processing">Processing
    instruction pseudo-elements</a></dt>
  <dd>PIs (rarely encountered) are represented as HTML::Element objects with a
      tag name of &quot;~pi&quot;, and content in the &quot;text&quot;
      attribute. For example, this:
    <p class="Pp"></p>
    <pre>  &lt;?stuff foo?&gt;
    </pre>
    <p class="Pp">produces an element whose attributes include:</p>
    <p class="Pp"></p>
    <pre>  &quot;_tag&quot;, &quot;~pi&quot;, &quot;text&quot;, &quot;stuff foo?&quot;
    </pre>
    <p class="Pp">(assuming a recent version of HTML::Parser)</p>
  </dd>
  <dt>~literal pseudo-elements</dt>
  <dd>These objects are not currently produced by HTML::TreeBuilder, but can be
      used to represent a &quot;super-literal&quot; -- i.e., a literal you want
      to be immune from escaping. (Yes, I just made that term up.)
    <p class="Pp">That is, this is useful if you want to insert code into a tree
        that you plan to dump out with
        <span class="Li">&quot;as_HTML&quot;</span>, where you want, for some
        reason, to suppress <span class="Li">&quot;as_HTML&quot;</span>'s normal
        behavior of amp-quoting text segments.</p>
    <p class="Pp">For example, this:</p>
    <p class="Pp"></p>
    <pre>  my $literal = HTML::Element-&gt;new('~literal',
    'text' =&gt; 'x &lt; 4 &amp; y &gt; 7'
  );
  my $span = HTML::Element-&gt;new('span');
  $span-&gt;push_content($literal);
  print $span-&gt;as_HTML;
    </pre>
    <p class="Pp">prints this:</p>
    <p class="Pp"></p>
    <pre>  &lt;span&gt;x &lt; 4 &amp; y &gt; 7&lt;/span&gt;
    </pre>
    <p class="Pp">Whereas this:</p>
    <p class="Pp"></p>
    <pre>  my $span = HTML::Element-&gt;new('span');
  $span-&gt;push_content('x &lt; 4 &amp; y &gt; 7');
    # normal text segment
  print $span-&gt;as_HTML;
    </pre>
    <p class="Pp">prints this:</p>
    <p class="Pp"></p>
    <pre>  &lt;span&gt;x &amp;lt; 4 &amp;amp; y &amp;gt; 7&lt;/span&gt;
    </pre>
    <p class="Pp">Unless you're inserting lots of pre-cooked code into existing
        trees, and dumping them out again, it's not likely that you'll find
        <span class="Li">&quot;~literal&quot;</span> pseudo-elements useful.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="parent"><a class="permalink" href="#parent">parent</a></h2>
<pre>  $parent = $h-&gt;parent();
  $h-&gt;parent($new_parent);
</pre>
<p class="Pp">Returns (optionally sets) the parent (aka &quot;container&quot;)
    for this element. The parent should either be undef, or should be another
    element.</p>
<p class="Pp">You <b>should not</b> use this to directly set the parent of an
    element. Instead use any of the other methods under
    &quot;Structure-Modifying Methods&quot;, below.</p>
<p class="Pp">Note that <span class="Li">&quot;not($h-&gt;parent)&quot;</span>
    is a simple test for whether <span class="Li">$h</span> is the root of its
    subtree.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="content_list"><a class="permalink" href="#content_list">content_list</a></h2>
<pre>  @content = $h-&gt;content_list();
  $num_children = $h-&gt;content_list();
</pre>
<p class="Pp">Returns a list of the child nodes of this element -- i.e., what
    nodes (elements or text segments) are inside/under this element. (Note that
    this may be an empty list.)</p>
<p class="Pp">In a scalar context, this returns the count of the items, as you
    may expect.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="content"><a class="permalink" href="#content">content</a></h2>
<pre>  $content_array_ref = $h-&gt;content(); # may return undef
</pre>
<p class="Pp">This somewhat deprecated method returns the content of this
    element; but unlike content_list, this returns either undef (which you
    should understand to mean no content), or a <i>reference to the array</i> of
    content items, each of which is either a text segment (a string, i.e., a
    defined non-reference scalar value), or an HTML::Element object. Note that
    even if an arrayref is returned, it may be a reference to an empty
  array.</p>
<p class="Pp">While older code should feel free to continue to use
    <span class="Li">&quot;$h-&gt;content&quot;</span>, new code should use
    <span class="Li">&quot;$h-&gt;content_list&quot;</span> in almost all
    conceivable cases. It is my experience that in most cases this leads to
    simpler code anyway, since it means one can say:</p>
<p class="Pp"></p>
<pre>    @children = $h-&gt;content_list;
</pre>
<p class="Pp">instead of the inelegant:</p>
<p class="Pp"></p>
<pre>    @children = @{$h-&gt;content || []};
</pre>
<p class="Pp">If you do use <span class="Li">&quot;$h-&gt;content&quot;</span>
    (or <span class="Li">&quot;$h-&gt;content_array_ref&quot;</span>), you
    should not use the reference returned by it (assuming it returned a
    reference, and not undef) to directly set or change the content of an
    element or text segment! Instead use content_refs_list or any of the other
    methods under &quot;Structure-Modifying Methods&quot;, below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="content_array_ref"><a class="permalink" href="#content_array_ref">content_array_ref</a></h2>
<pre>  $content_array_ref = $h-&gt;content_array_ref(); # never undef
</pre>
<p class="Pp">This is like <span class="Li">&quot;content&quot;</span> (with all
    its caveats and deprecations) except that it is guaranteed to return an
    array reference. That is, if the given node has no
    <span class="Li">&quot;_content&quot;</span> attribute, the
    <span class="Li">&quot;content&quot;</span> method would return that undef,
    but <span class="Li">&quot;content_array_ref&quot;</span> would set the
    given node's <span class="Li">&quot;_content&quot;</span> value to
    <span class="Li">&quot;[]&quot;</span> (a reference to a new, empty array),
    and return that.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="content_refs_list"><a class="permalink" href="#content_refs_list">content_refs_list</a></h2>
<pre>  @content_refs = $h-&gt;content_refs_list;
</pre>
<p class="Pp">This returns a list of scalar references to each element of
    <span class="Li">$h</span>'s content list. This is useful in case you want
    to in-place edit any large text segments without having to get a copy of the
    current value of that segment value, modify that copy, then use the
    <span class="Li">&quot;splice_content&quot;</span> to replace the old with
    the new. Instead, here you can in-place edit:</p>
<p class="Pp"></p>
<pre>    foreach my $item_r ($h-&gt;content_refs_list) {
        next if ref $$item_r;
        $$item_r =~ s/honour/honor/g;
    }
</pre>
<p class="Pp">You <i>could</i> currently achieve the same affect with:</p>
<p class="Pp"></p>
<pre>    foreach my $item (@{ $h-&gt;content_array_ref }) {
        # deprecated!
        next if ref $item;
        $item =~ s/honour/honor/g;
    }
</pre>
<p class="Pp">...except that using the return value of
    <span class="Li">&quot;$h-&gt;content&quot;</span> or
    <span class="Li">&quot;$h-&gt;content_array_ref&quot;</span> to do that is
    deprecated, and just might stop working in the future.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="implicit"><a class="permalink" href="#implicit">implicit</a></h2>
<pre>  $is_implicit = $h-&gt;implicit();
  $h-&gt;implicit($make_implicit);
</pre>
<p class="Pp">Returns (optionally sets) the &quot;_implicit&quot; attribute.
    This attribute is a flag that's used for indicating that the element was not
    originally present in the source, but was added to the parse tree (by
    HTML::TreeBuilder, for example) in order to conform to the rules of HTML
    structure.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="pos"><a class="permalink" href="#pos">pos</a></h2>
<pre>  $pos = $h-&gt;pos();
  $h-&gt;pos($element);
</pre>
<p class="Pp">Returns (and optionally sets) the &quot;_pos&quot; (for
    &quot;current <i>pos</i>ition&quot;) pointer of <span class="Li">$h</span>.
    This attribute is a pointer used during some parsing operations, whose value
    is whatever HTML::Element element at or under <span class="Li">$h</span> is
    currently &quot;open&quot;, where
    <span class="Li">&quot;$h-&gt;insert_element(NEW)&quot;</span> will actually
    insert a new element.</p>
<p class="Pp">(This has nothing to do with the Perl function called
    <span class="Li">&quot;pos&quot;</span>, for controlling where regular
    expression matching starts.)</p>
<p class="Pp">If you set
    <span class="Li">&quot;$h-&gt;pos($element)&quot;</span>, be sure that
    <span class="Li">$element</span> is either <span class="Li">$h</span>, or an
    element under <span class="Li">$h</span>.</p>
<p class="Pp">If you've been modifying the tree under <span class="Li">$h</span>
    and are no longer sure <span class="Li">&quot;$h-&gt;pos&quot;</span> is
    valid, you can enforce validity with:</p>
<p class="Pp"></p>
<pre>    $h-&gt;pos(undef) unless $h-&gt;pos-&gt;is_inside($h);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="all_attr"><a class="permalink" href="#all_attr">all_attr</a></h2>
<pre>  %attr = $h-&gt;all_attr();
</pre>
<p class="Pp">Returns all this element's attributes and values, as key-value
    pairs. This will include any &quot;internal&quot; attributes (i.e., ones not
    present in the original element, and which will not be represented if/when
    you call <span class="Li">&quot;$h-&gt;as_HTML&quot;</span>). Internal
    attributes are distinguished by the fact that the first character of their
    key (not value! key!) is an underscore (&quot;_&quot;).</p>
<p class="Pp">Example output of
    <span class="Li">&quot;$h-&gt;all_attr()&quot;</span> :
    <span class="Li">&quot;'_parent',
    &quot;</span><i>[object_value]</i><span class="Li">&quot; , '_tag', 'em',
    'lang', 'en-US',</span> <span class="Li">'_content',
    &quot;</span><i>[array-ref value]</i>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="all_attr_names"><a class="permalink" href="#all_attr_names">all_attr_names</a></h2>
<pre>  @names = $h-&gt;all_attr_names();
  $num_attrs = $h-&gt;all_attr_names();
</pre>
<p class="Pp">Like <span class="Li">&quot;all_attr&quot;</span>, but only
    returns the names of the attributes. In scalar context, returns the number
    of attributes.</p>
<p class="Pp">Example output of
    <span class="Li">&quot;$h-&gt;all_attr_names()&quot;</span> :
    <span class="Li">&quot;'_parent', '_tag', 'lang', '_content',
  &quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="all_external_attr"><a class="permalink" href="#all_external_attr">all_external_attr</a></h2>
<pre>  %attr = $h-&gt;all_external_attr();
</pre>
<p class="Pp">Like <span class="Li">&quot;all_attr&quot;</span>, except that
    internal attributes are not present.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="all_external_attr_names"><a class="permalink" href="#all_external_attr_names">all_external_attr_names</a></h2>
<pre>  @names = $h-&gt;all_external_attr_names();
  $num_attrs = $h-&gt;all_external_attr_names();
</pre>
<p class="Pp">Like <span class="Li">&quot;all_attr_names&quot;</span>, except
    that internal attributes' names are not present (or counted).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="id"><a class="permalink" href="#id">id</a></h2>
<pre>  $id = $h-&gt;id();
  $h-&gt;id($string);
</pre>
<p class="Pp">Returns (optionally sets to <span class="Li">$string</span>) the
    &quot;id&quot; attribute.
    <span class="Li">&quot;$h-&gt;id(undef)&quot;</span> deletes the
    &quot;id&quot; attribute.</p>
<p class="Pp"><span class="Li">&quot;$h-&gt;id(...)&quot;</span> is basically
    equivalent to <span class="Li">&quot;$h-&gt;attr('id', ...)&quot;</span>,
    except that when setting the attribute, this method returns the new value,
    not the old value.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="idf"><a class="permalink" href="#idf">idf</a></h2>
<pre>  $id = $h-&gt;idf();
  $h-&gt;idf($string);
</pre>
<p class="Pp">Just like the <span class="Li">&quot;id&quot;</span> method,
    except that if you call <span class="Li">&quot;$h-&gt;idf()&quot;</span> and
    no &quot;id&quot; attribute is defined for this element, then it's set to a
    likely-to-be-unique value, and returned. (The &quot;f&quot; is for
    &quot;force&quot;.)</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="STRUCTURE-MODIFYING_METHODS"><a class="permalink" href="#STRUCTURE-MODIFYING_METHODS">STRUCTURE-MODIFYING
  METHODS</a></h1>
<p class="Pp">These methods are provided for modifying the content of trees by
    adding or changing nodes as parents or children of other nodes.</p>
<section class="Ss">
<h2 class="Ss" id="push_content"><a class="permalink" href="#push_content">push_content</a></h2>
<pre>  $h-&gt;push_content($element_or_text, ...);
</pre>
<p class="Pp">Adds the specified items to the <i>end</i> of the content list of
    the element <span class="Li">$h</span>. The items of content to be added
    should each be either a text segment (a string), an HTML::Element object, or
    an arrayref. Arrayrefs are fed thru
    <span class="Li">&quot;$h-&gt;new_from_lol(that_arrayref)&quot;</span> to
    convert them into elements, before being added to the content list of
    <span class="Li">$h</span>. This means you can say things concise things
    like:</p>
<p class="Pp"></p>
<pre>  $body-&gt;push_content(
    ['br'],
    ['ul',
      map ['li', $_], qw(Peaches Apples Pears Mangos)
    ]
  );
</pre>
<p class="Pp">See the &quot;new_from_lol&quot; method's documentation, far
    below, for more explanation.</p>
<p class="Pp">Returns <span class="Li">$h</span> (the element itself).</p>
<p class="Pp">The push_content method will try to consolidate adjacent text
    segments while adding to the content list. That's to say, if
    <span class="Li">$h</span>'s
    <span class="Li">&quot;content_list&quot;</span> is</p>
<p class="Pp"></p>
<pre>  ('foo bar ', $some_node, 'baz!')
</pre>
<p class="Pp">and you call</p>
<p class="Pp"></p>
<pre>   $h-&gt;push_content('quack?');
</pre>
<p class="Pp">then the resulting content list will be this:</p>
<p class="Pp"></p>
<pre>  ('foo bar ', $some_node, 'baz!quack?')
</pre>
<p class="Pp">and not this:</p>
<p class="Pp"></p>
<pre>  ('foo bar ', $some_node, 'baz!', 'quack?')
</pre>
<p class="Pp">If that latter is what you want, you'll have to override the
    feature of consolidating text by using splice_content, as in:</p>
<p class="Pp"></p>
<pre>  $h-&gt;splice_content(scalar($h-&gt;content_list),0,'quack?');
</pre>
<p class="Pp">Similarly, if you wanted to add 'Skronk' to the beginning of the
    content list, calling this:</p>
<p class="Pp"></p>
<pre>   $h-&gt;unshift_content('Skronk');
</pre>
<p class="Pp">then the resulting content list will be this:</p>
<p class="Pp"></p>
<pre>  ('Skronkfoo bar ', $some_node, 'baz!')
</pre>
<p class="Pp">and not this:</p>
<p class="Pp"></p>
<pre>  ('Skronk', 'foo bar ', $some_node, 'baz!')
</pre>
<p class="Pp">What you'd to do get the latter is:</p>
<p class="Pp"></p>
<pre>  $h-&gt;splice_content(0,0,'Skronk');
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="unshift_content"><a class="permalink" href="#unshift_content">unshift_content</a></h2>
<pre>  $h-&gt;unshift_content($element_or_text, ...)
</pre>
<p class="Pp">Just like <span class="Li">&quot;push_content&quot;</span>, but
    adds to the <i>beginning</i> of the <span class="Li">$h</span> element's
    content list.</p>
<p class="Pp">The items of content to be added should each be either a text
    segment (a string), an HTML::Element object, or an arrayref (which is fed
    thru <span class="Li">&quot;new_from_lol&quot;</span>).</p>
<p class="Pp">The unshift_content method will try to consolidate adjacent text
    segments while adding to the content list. See above for a discussion of
    this.</p>
<p class="Pp">Returns <span class="Li">$h</span> (the element itself).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="splice_content"><a class="permalink" href="#splice_content">splice_content</a></h2>
<pre>  @removed = $h-&gt;splice_content($offset, $length,
                                $element_or_text, ...);
</pre>
<p class="Pp">Detaches the elements from <span class="Li">$h</span>'s list of
    content-nodes, starting at <span class="Li">$offset</span> and continuing
    for <span class="Li">$length</span> items, replacing them with the elements
    of the following list, if any. Returns the elements (if any) removed from
    the content-list. If <span class="Li">$offset</span> is negative, then it
    starts that far from the end of the array, just like Perl's normal
    <span class="Li">&quot;splice&quot;</span> function. If
    <span class="Li">$length</span> and the following list is omitted, removes
    everything from <span class="Li">$offset</span> onward.</p>
<p class="Pp">The items of content to be added (if any) should each be either a
    text segment (a string), an arrayref (which is fed thru
    &quot;new_from_lol&quot;), or an HTML::Element object that's not already a
    child of <span class="Li">$h</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="detach"><a class="permalink" href="#detach">detach</a></h2>
<pre>  $old_parent = $h-&gt;detach();
</pre>
<p class="Pp">This unlinks <span class="Li">$h</span> from its parent, by
    setting its 'parent' attribute to undef, and by removing it from the content
    list of its parent (if it had one). The return value is the parent that was
    detached from (or undef, if <span class="Li">$h</span> had no parent to
    start with). Note that neither <span class="Li">$h</span> nor its parent are
    explicitly destroyed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="detach_content"><a class="permalink" href="#detach_content">detach_content</a></h2>
<pre>  @old_content = $h-&gt;detach_content();
</pre>
<p class="Pp">This unlinks all of <span class="Li">$h</span>'s children from
    <span class="Li">$h</span>, and returns them. Note that these are not
    explicitly destroyed; for that, you can just use
    <span class="Li">&quot;$h-&gt;delete_content&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="replace_with"><a class="permalink" href="#replace_with">replace_with</a></h2>
<pre>  $h-&gt;replace_with( $element_or_text, ... )
</pre>
<p class="Pp">This replaces <span class="Li">$h</span> in its parent's content
    list with the nodes specified. The element <span class="Li">$h</span> (which
    by then may have no parent) is returned. This causes a fatal error if
    <span class="Li">$h</span> has no parent. The list of nodes to insert may
    contain <span class="Li">$h</span>, but at most once. Aside from that
    possible exception, the nodes to insert should not already be children of
    <span class="Li">$h</span>'s parent.</p>
<p class="Pp">Also, note that this method does not destroy
    <span class="Li">$h</span> if weak references are turned off -- use
    <span class="Li">&quot;$h-&gt;replace_with(...)-&gt;delete&quot;</span> if
    you need that.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="preinsert"><a class="permalink" href="#preinsert">preinsert</a></h2>
<pre>  $h-&gt;preinsert($element_or_text...);
</pre>
<p class="Pp">Inserts the given nodes right BEFORE <span class="Li">$h</span> in
    <span class="Li">$h</span>'s parent's content list. This causes a fatal
    error if <span class="Li">$h</span> has no parent. None of the given nodes
    should be <span class="Li">$h</span> or other children of
    <span class="Li">$h</span>. Returns <span class="Li">$h</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="postinsert"><a class="permalink" href="#postinsert">postinsert</a></h2>
<pre>  $h-&gt;postinsert($element_or_text...)
</pre>
<p class="Pp">Inserts the given nodes right AFTER <span class="Li">$h</span> in
    <span class="Li">$h</span>'s parent's content list. This causes a fatal
    error if <span class="Li">$h</span> has no parent. None of the given nodes
    should be <span class="Li">$h</span> or other children of
    <span class="Li">$h</span>. Returns <span class="Li">$h</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="replace_with_content"><a class="permalink" href="#replace_with_content">replace_with_content</a></h2>
<pre>  $h-&gt;replace_with_content();
</pre>
<p class="Pp">This replaces <span class="Li">$h</span> in its parent's content
    list with its own content. The element <span class="Li">$h</span> (which by
    then has no parent or content of its own) is returned. This causes a fatal
    error if <span class="Li">$h</span> has no parent. Also, note that this does
    not destroy <span class="Li">$h</span> if weak references are turned off --
    use
    <span class="Li">&quot;$h-&gt;replace_with_content-&gt;delete&quot;</span>
    if you need that.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="delete_content"><a class="permalink" href="#delete_content">delete_content</a></h2>
<pre>  $h-&gt;delete_content();
  $h-&gt;destroy_content(); # alias
</pre>
<p class="Pp">Clears the content of <span class="Li">$h</span>, calling
    <span class="Li">&quot;$h-&gt;delete&quot;</span> for each content element.
    Compare with <span class="Li">&quot;$h-&gt;detach_content&quot;</span>.</p>
<p class="Pp">Returns <span class="Li">$h</span>.</p>
<p class="Pp"><span class="Li">&quot;destroy_content&quot;</span> is an alias
    for this method.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="delete"><a class="permalink" href="#delete">delete</a></h2>
<pre>  $h-&gt;delete();
  $h-&gt;destroy(); # alias
</pre>
<p class="Pp">Detaches this element from its parent (if it has one) and
    explicitly destroys the element and all its descendants. The return value is
    the empty list (or <span class="Li">&quot;undef&quot;</span> in scalar
    context).</p>
<p class="Pp">Before version 5.00 of HTML::Element, you had to call
    <span class="Li">&quot;delete&quot;</span> when you were finished with the
    tree, or your program would leak memory. This is no longer necessary if weak
    references are enabled, see &quot;Weak References&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="destroy"><a class="permalink" href="#destroy">destroy</a></h2>
<p class="Pp">An alias for &quot;delete&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="destroy_content"><a class="permalink" href="#destroy_content">destroy_content</a></h2>
<p class="Pp">An alias for &quot;delete_content&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="clone"><a class="permalink" href="#clone">clone</a></h2>
<pre>  $copy = $h-&gt;clone();
</pre>
<p class="Pp">Returns a copy of the element (whose children are clones
    (recursively) of the original's children, if any).</p>
<p class="Pp">The returned element is parentless. Any '_pos' attributes present
    in the source element/tree will be absent in the copy. For that and other
    reasons, the clone of an HTML::TreeBuilder object that's in mid-parse (i.e,
    the head of a tree that HTML::TreeBuilder is elaborating) cannot (currently)
    be used to continue the parse.</p>
<p class="Pp">You are free to clone HTML::TreeBuilder trees, just as long as: 1)
    they're done being parsed, or 2) you don't expect to resume parsing into the
    clone. (You can continue parsing into the original; it is never
  affected.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="clone_list"><a class="permalink" href="#clone_list">clone_list</a></h2>
<pre>  @copies = HTML::Element-&gt;clone_list(...nodes...);
</pre>
<p class="Pp">Returns a list consisting of a copy of each node given. Text
    segments are simply copied; elements are cloned by calling
    <span class="Li">&quot;$it-&gt;clone&quot;</span> on each of them.</p>
<p class="Pp">Note that this must be called as a class method, not as an
    instance method. <span class="Li">&quot;clone_list&quot;</span> will croak
    if called as an instance method. You can also call it like so:</p>
<p class="Pp"></p>
<pre>    ref($h)-&gt;clone_list(...nodes...)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="normalize_content"><a class="permalink" href="#normalize_content">normalize_content</a></h2>
<pre>  $h-&gt;normalize_content
</pre>
<p class="Pp">Normalizes the content of <span class="Li">$h</span> -- i.e.,
    concatenates any adjacent text nodes. (Any undefined text segments are
    turned into empty-strings.) Note that this does not recurse into
    <span class="Li">$h</span>'s descendants.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="delete_ignorable_whitespace"><a class="permalink" href="#delete_ignorable_whitespace">delete_ignorable_whitespace</a></h2>
<pre>  $h-&gt;delete_ignorable_whitespace()
</pre>
<p class="Pp">This traverses under <span class="Li">$h</span> and deletes any
    text segments that are ignorable whitespace. You should not use this if
    <span class="Li">$h</span> is under a
    <span class="Li">&quot;&lt;pre&gt;&quot;</span> element.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="insert_element"><a class="permalink" href="#insert_element">insert_element</a></h2>
<pre>  $h-&gt;insert_element($element, $implicit);
</pre>
<p class="Pp">Inserts (via push_content) a new element under the element at
    <span class="Li">&quot;$h-&gt;pos()&quot;</span>. Then updates
    <span class="Li">&quot;$h-&gt;pos()&quot;</span> to point to the inserted
    element, unless <span class="Li">$element</span> is a prototypically empty
    element like <span class="Li">&quot;&lt;br&gt;&quot;</span>,
    <span class="Li">&quot;&lt;hr&gt;&quot;</span>,
    <span class="Li">&quot;&lt;img&gt;&quot;</span>, etc. The new
    <span class="Li">&quot;$h-&gt;pos()&quot;</span> is returned. This method is
    useful only if your particular tree task involves setting
    <span class="Li">&quot;$h-&gt;pos()&quot;</span>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DUMPING_METHODS"><a class="permalink" href="#DUMPING_METHODS">DUMPING
  METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="dump"><a class="permalink" href="#dump">dump</a></h2>
<pre>  $h-&gt;dump()
  $h-&gt;dump(*FH)  ; # or *FH{IO} or $fh_obj
</pre>
<p class="Pp">Prints the element and all its children to STDOUT (or to a
    specified filehandle), in a format useful only for debugging. The structure
    of the document is shown by indentation (no end tags).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="as_HTML"><a class="permalink" href="#as_HTML">as_HTML</a></h2>
<pre>  $s = $h-&gt;as_HTML();
  $s = $h-&gt;as_HTML($entities);
  $s = $h-&gt;as_HTML($entities, $indent_char);
  $s = $h-&gt;as_HTML($entities, $indent_char, \%optional_end_tags);
</pre>
<p class="Pp">Returns a string representing in HTML the element and its
    descendants. The optional argument <span class="Li">$entities</span>
    specifies a string of the entities to encode. For compatibility with
    previous versions, specify <span class="Li">'&lt;&gt;&amp;'</span> here. If
    omitted or undef, <i>all</i> unsafe characters are encoded as HTML entities.
    See HTML::Entities for details. If passed an empty string, no entities are
    encoded.</p>
<p class="Pp">If <span class="Li">$indent_char</span> is specified and defined,
    the HTML to be output is intented, using the string you specify (which you
    probably should set to &quot;\t&quot;, or some number of spaces, if you
    specify it).</p>
<p class="Pp">If <span class="Li">&quot;\%optional_end_tags&quot;</span> is
    specified and defined, it should be a reference to a hash that holds a true
    value for every tag name whose end tag is optional. Defaults to
    <span class="Li">&quot;\%HTML::Element::optionalEndTag&quot;</span>, which
    is an alias to <span class="Li">%HTML::Tagset::optionalEndTag</span>, which,
    at time of writing, contains true values for <span class="Li">&quot;p, li,
    dt, dd&quot;</span>. A useful value to pass is an empty hashref,
    <span class="Li">&quot;{}&quot;</span>, which means that no end-tags are
    optional for this dump. Otherwise, possibly consider copying
    <span class="Li">%HTML::Tagset::optionalEndTag</span> to a hash of your own,
    adding or deleting values as you like, and passing a reference to that
  hash.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="as_text"><a class="permalink" href="#as_text">as_text</a></h2>
<pre>  $s = $h-&gt;as_text();
  $s = $h-&gt;as_text(skip_dels =&gt; 1);
</pre>
<p class="Pp">Returns a string consisting of only the text parts of the
    element's descendants. Any whitespace inside the element is included
    unchanged, but whitespace not in the tree is never added. But remember that
    whitespace may be ignored or compacted by HTML::TreeBuilder during parsing
    (depending on the value of the
    <span class="Li">&quot;ignore_ignorable_whitespace&quot;</span> and
    <span class="Li">&quot;no_space_compacting&quot;</span> attributes). Also,
    since whitespace is never added during parsing,</p>
<p class="Pp"></p>
<pre>  HTML::TreeBuilder-&gt;new_from_content(&quot;&lt;p&gt;a&lt;/p&gt;&lt;p&gt;b&lt;/p&gt;&quot;)
                   -&gt;as_text;
</pre>
<p class="Pp">returns <span class="Li">&quot;ab&quot;</span>, not
    <span class="Li">&quot;a b&quot;</span> or
    <span class="Li">&quot;a\nb&quot;</span>.</p>
<p class="Pp">Text under <span class="Li">&quot;&lt;script&gt;&quot;</span> or
    <span class="Li">&quot;&lt;style&gt;&quot;</span> elements is never included
    in what's returned. If <span class="Li">&quot;skip_dels&quot;</span> is
    true, then text content under
    <span class="Li">&quot;&lt;del&gt;&quot;</span> nodes is not included in
    what's returned.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="as_trimmed_text"><a class="permalink" href="#as_trimmed_text">as_trimmed_text</a></h2>
<pre>  $s = $h-&gt;as_trimmed_text(...);
  $s = $h-&gt;as_trimmed_text(extra_chars =&gt; '\xA0'); # remove &amp;nbsp;
  $s = $h-&gt;as_text_trimmed(...); # alias
</pre>
<p class="Pp">This is just like <span class="Li">&quot;as_text(...)&quot;</span>
    except that leading and trailing whitespace is deleted, and any internal
    whitespace is collapsed.</p>
<p class="Pp">This will not remove non-breaking spaces, Unicode spaces, or any
    other non-ASCII whitespace unless you supply the extra characters as a
    string argument (e.g.
    <span class="Li">&quot;$h-&gt;as_trimmed_text(extra_chars =&gt;
    '\xA0')&quot;</span>). <span class="Li">&quot;extra_chars&quot;</span> may
    be any string that can appear inside a character class, including ranges
    like <span class="Li">&quot;a-z&quot;</span>, POSIX character classes like
    <span class="Li">&quot;[:alpha:]&quot;</span>, and character class escapes
    like <span class="Li">&quot;\p{Zs}&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="as_XML"><a class="permalink" href="#as_XML">as_XML</a></h2>
<pre>  $s = $h-&gt;as_XML()
</pre>
<p class="Pp">Returns a string representing in XML the element and its
    descendants.</p>
<p class="Pp">The XML is not indented.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="as_Lisp_form"><a class="permalink" href="#as_Lisp_form">as_Lisp_form</a></h2>
<pre>  $s = $h-&gt;as_Lisp_form();
</pre>
<p class="Pp">Returns a string representing the element and its descendants as a
    Lisp form. Unsafe characters are encoded as octal escapes.</p>
<p class="Pp">The Lisp form is indented, and contains external
    (&quot;href&quot;, etc.) as well as internal attributes (&quot;_tag&quot;,
    &quot;_content&quot;, &quot;_implicit&quot;, etc.), except for
    &quot;_parent&quot;, which is omitted.</p>
<p class="Pp">Current example output for a given element:</p>
<p class="Pp"></p>
<pre>  (&quot;_tag&quot; &quot;img&quot; &quot;border&quot; &quot;0&quot; &quot;src&quot; &quot;pie.png&quot; &quot;usemap&quot; &quot;#main.map&quot;)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="format"><a class="permalink" href="#format">format</a></h2>
<pre>  $s = $h-&gt;format; # use HTML::FormatText
  $s = $h-&gt;format($formatter);
</pre>
<p class="Pp">Formats text output. Defaults to HTML::FormatText.</p>
<p class="Pp">Takes a second argument that is a reference to a formatter.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="starttag"><a class="permalink" href="#starttag">starttag</a></h2>
<pre>  $start = $h-&gt;starttag();
  $start = $h-&gt;starttag($entities);
</pre>
<p class="Pp">Returns a string representing the complete start tag for the
    element. I.e., leading &quot;&lt;&quot;, tag name, attributes, and trailing
    &quot;&gt;&quot;. All values are surrounded with double-quotes, and
    appropriate characters are encoded. If <span class="Li">$entities</span> is
    omitted or undef, <i>all</i> unsafe characters are encoded as HTML entities.
    See HTML::Entities for details. If you specify some value for
    <span class="Li">$entities</span>, remember to include the double-quote
    character in it. (Previous versions of this module would basically behave as
    if <span class="Li">'&amp;&quot;&gt;'</span> were specified for
    <span class="Li">$entities</span>.) If <span class="Li">$entities</span> is
    an empty string, no entity is escaped.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="starttag_XML"><a class="permalink" href="#starttag_XML">starttag_XML</a></h2>
<pre>  $start = $h-&gt;starttag_XML();
</pre>
<p class="Pp">Returns a string representing the complete start tag for the
    element.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="endtag"><a class="permalink" href="#endtag">endtag</a></h2>
<pre>  $end = $h-&gt;endtag();
</pre>
<p class="Pp">Returns a string representing the complete end tag for this
    element. I.e., &quot;&lt;/&quot;, tag name, and &quot;&gt;&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="endtag_XML"><a class="permalink" href="#endtag_XML">endtag_XML</a></h2>
<pre>  $end = $h-&gt;endtag_XML();
</pre>
<p class="Pp">Returns a string representing the complete end tag for this
    element. I.e., &quot;&lt;/&quot;, tag name, and &quot;&gt;&quot;.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SECONDARY_STRUCTURAL_METHODS"><a class="permalink" href="#SECONDARY_STRUCTURAL_METHODS">SECONDARY
  STRUCTURAL METHODS</a></h1>
<p class="Pp">These methods all involve some structural aspect of the tree;
    either they report some aspect of the tree's structure, or they involve
    traversal down the tree, or walking up the tree.</p>
<section class="Ss">
<h2 class="Ss" id="is_inside"><a class="permalink" href="#is_inside">is_inside</a></h2>
<pre>  $inside = $h-&gt;is_inside('tag', $element, ...);
</pre>
<p class="Pp">Returns true if the <span class="Li">$h</span> element is, or is
    contained anywhere inside an element that is any of the ones listed, or
    whose tag name is any of the tag names listed. You can use any mix of
    elements and tag names.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="is_empty"><a class="permalink" href="#is_empty">is_empty</a></h2>
<pre>  $empty = $h-&gt;is_empty();
</pre>
<p class="Pp">Returns true if <span class="Li">$h</span> has no content, i.e.,
    has no elements or text segments under it. In other words, this returns true
    if <span class="Li">$h</span> is a leaf node, AKA a terminal node. Do not
    confuse this sense of &quot;empty&quot; with another sense that it can have
    in SGML/HTML/XML terminology, which means that the element in question is of
    the type (like HTML's <span class="Li">&quot;&lt;hr&gt;&quot;</span>,
    <span class="Li">&quot;&lt;br&gt;&quot;</span>,
    <span class="Li">&quot;&lt;img&gt;&quot;</span>, etc.) that <i>can't</i>
    have any content.</p>
<p class="Pp">That is, a particular
    <span class="Li">&quot;&lt;p&gt;&quot;</span> element may happen to have no
    content, so <span class="Li">$that_p_element</span>-&gt;is_empty will be
    true -- even though the prototypical
    <span class="Li">&quot;&lt;p&gt;&quot;</span> element isn't
    &quot;empty&quot; (not in the way that the prototypical
    <span class="Li">&quot;&lt;hr&gt;&quot;</span> element is).</p>
<p class="Pp">If you think this might make for potentially confusing code,
    consider simply using the clearer exact equivalent:
    <span class="Li">&quot;not($h-&gt;content_list)&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="pindex"><a class="permalink" href="#pindex">pindex</a></h2>
<pre>  $index = $h-&gt;pindex();
</pre>
<p class="Pp">Return the index of the element in its parent's contents array,
    such that <span class="Li">$h</span> would equal</p>
<p class="Pp"></p>
<pre>  $h-&gt;parent-&gt;content-&gt;[$h-&gt;pindex]
  # or
  ($h-&gt;parent-&gt;content_list)[$h-&gt;pindex]
</pre>
<p class="Pp">assuming <span class="Li">$h</span> isn't root. If the element
    <span class="Li">$h</span> is root, then
    <span class="Li">&quot;$h-&gt;pindex&quot;</span> returns
    <span class="Li">&quot;undef&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="left"><a class="permalink" href="#left">left</a></h2>
<pre>  $element = $h-&gt;left();
  @elements = $h-&gt;left();
</pre>
<p class="Pp">In scalar context: returns the node that's the immediate left
    sibling of <span class="Li">$h</span>. If <span class="Li">$h</span> is the
    leftmost (or only) child of its parent (or has no parent), then this returns
    undef.</p>
<p class="Pp">In list context: returns all the nodes that're the left siblings
    of <span class="Li">$h</span> (starting with the leftmost). If
    <span class="Li">$h</span> is the leftmost (or only) child of its parent (or
    has no parent), then this returns an empty list.</p>
<p class="Pp">(See also
    <span class="Li">&quot;$h-&gt;preinsert(LIST)&quot;</span>.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="right"><a class="permalink" href="#right">right</a></h2>
<pre>  $element = $h-&gt;right();
  @elements = $h-&gt;right();
</pre>
<p class="Pp">In scalar context: returns the node that's the immediate right
    sibling of <span class="Li">$h</span>. If <span class="Li">$h</span> is the
    rightmost (or only) child of its parent (or has no parent), then this
    returns <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp">In list context: returns all the nodes that're the right siblings
    of <span class="Li">$h</span>, starting with the leftmost. If
    <span class="Li">$h</span> is the rightmost (or only) child of its parent
    (or has no parent), then this returns an empty list.</p>
<p class="Pp">(See also
    <span class="Li">&quot;$h-&gt;postinsert(LIST)&quot;</span>.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="address"><a class="permalink" href="#address">address</a></h2>
<pre>  $address = $h-&gt;address();
  $element_or_text = $h-&gt;address($address);
</pre>
<p class="Pp">The first form (with no parameter) returns a string representing
    the location of <span class="Li">$h</span> in the tree it is a member of.
    The address consists of numbers joined by a '.', starting with '0', and
    followed by the pindexes of the nodes in the tree that are ancestors of
    <span class="Li">$h</span>, starting from the top.</p>
<p class="Pp">So if the way to get to a node starting at the root is to go to
    child 2 of the root, then child 10 of that, and then child 0 of that, and
    then you're there -- then that node's address is &quot;0.2.10.0&quot;.</p>
<p class="Pp">As a bit of a special case, the address of the root is simply
    &quot;0&quot;.</p>
<p class="Pp">I forsee this being used mainly for debugging, but you may find
    your own uses for it.</p>
<p class="Pp"></p>
<pre>  $element_or_text = $h-&gt;address($address);
</pre>
<p class="Pp">This form returns the node (whether element or text-segment) at
    the given address in the tree that <span class="Li">$h</span> is a part of.
    (That is, the address is resolved starting from
    <span class="Li">&quot;$h-&gt;root&quot;</span>.)</p>
<p class="Pp">If there is no node at the given address, this returns
    <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp">You can specify &quot;relative addressing&quot; (i.e., that
    indexing is supposed to start from <span class="Li">$h</span> and not from
    <span class="Li">&quot;$h-&gt;root&quot;</span>) by having the address start
    with a period -- e.g.,
    <span class="Li">&quot;$h-&gt;address(&quot;.3.2&quot;)&quot;</span> will
    look at child 3 of <span class="Li">$h</span>, and child 2 of that.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="depth"><a class="permalink" href="#depth">depth</a></h2>
<pre>  $depth = $h-&gt;depth();
</pre>
<p class="Pp">Returns a number expressing <span class="Li">$h</span>'s depth
    within its tree, i.e., how many steps away it is from the root. If
    <span class="Li">$h</span> has no parent (i.e., is root), its depth is
  0.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="root"><a class="permalink" href="#root">root</a></h2>
<pre>  $root = $h-&gt;root();
</pre>
<p class="Pp">Returns the element that's the top of <span class="Li">$h</span>'s
    tree. If <span class="Li">$h</span> is root, this just returns
    <span class="Li">$h</span>. (If you want to test whether
    <span class="Li">$h</span> <i>is</i> the root, instead of asking what its
    root is, just test
  <span class="Li">&quot;not($h-&gt;parent)&quot;</span>.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="lineage"><a class="permalink" href="#lineage">lineage</a></h2>
<pre>  @lineage = $h-&gt;lineage();
</pre>
<p class="Pp">Returns the list of <span class="Li">$h</span>'s ancestors,
    starting with its parent, and then that parent's parent, and so on, up to
    the root. If <span class="Li">$h</span> is root, this returns an empty
  list.</p>
<p class="Pp">If you simply want a count of the number of elements in
    <span class="Li">$h</span>'s lineage, use
    <span class="Li">&quot;$h-&gt;depth&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="lineage_tag_names"><a class="permalink" href="#lineage_tag_names">lineage_tag_names</a></h2>
<pre>  @names = $h-&gt;lineage_tag_names();
</pre>
<p class="Pp">Returns the list of the tag names of <span class="Li">$h</span>'s
    ancestors, starting with its parent, and that parent's parent, and so on, up
    to the root. If <span class="Li">$h</span> is root, this returns an empty
    list. Example output: <span class="Li">&quot;('em', 'td', 'tr', 'table',
    'body', 'html')&quot;</span></p>
<p class="Pp">Equivalent to:</p>
<p class="Pp"></p>
<pre>  map { $_-&gt;tag } $h-&gt;lineage;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="descendants"><a class="permalink" href="#descendants">descendants</a></h2>
<pre>  @descendants = $h-&gt;descendants();
</pre>
<p class="Pp">In list context, returns the list of all
    <span class="Li">$h</span>'s descendant elements, listed in pre-order (i.e.,
    an element appears before its content-elements). Text segments DO NOT appear
    in the list. In scalar context, returns a count of all such elements.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="descendents"><a class="permalink" href="#descendents">descendents</a></h2>
<p class="Pp">This is just an alias to the
    <span class="Li">&quot;descendants&quot;</span> method, for people who can't
    spell.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="find_by_tag_name"><a class="permalink" href="#find_by_tag_name">find_by_tag_name</a></h2>
<pre>  @elements = $h-&gt;find_by_tag_name('tag', ...);
  $first_match = $h-&gt;find_by_tag_name('tag', ...);
</pre>
<p class="Pp">In list context, returns a list of elements at or under
    <span class="Li">$h</span> that have any of the specified tag names. In
    scalar context, returns the first (in pre-order traversal of the tree) such
    element found, or undef if none.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="find"><a class="permalink" href="#find">find</a></h2>
<p class="Pp">This is just an alias to
    <span class="Li">&quot;find_by_tag_name&quot;</span>. (There was once going
    to be a whole find_* family of methods, but then
    <span class="Li">&quot;look_down&quot;</span> filled that niche, so there
    turned out not to be much reason for the verboseness of the name
    &quot;find_by_tag_name&quot;.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="find_by_attribute"><a class="permalink" href="#find_by_attribute">find_by_attribute</a></h2>
<pre>  @elements = $h-&gt;find_by_attribute('attribute', 'value');
  $first_match = $h-&gt;find_by_attribute('attribute', 'value');
</pre>
<p class="Pp">In a list context, returns a list of elements at or under
    <span class="Li">$h</span> that have the specified attribute, and have the
    given value for that attribute. In a scalar context, returns the first (in
    pre-order traversal of the tree) such element found, or undef if none.</p>
<p class="Pp">This method is <b>deprecated</b> in favor of the more expressive
    <span class="Li">&quot;look_down&quot;</span> method, which new code should
    use instead.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="look_down"><a class="permalink" href="#look_down">look_down</a></h2>
<pre>  @elements = $h-&gt;look_down( ...criteria... );
  $first_match = $h-&gt;look_down( ...criteria... );
</pre>
<p class="Pp">This starts at <span class="Li">$h</span> and looks thru its
    element descendants (in pre-order), looking for elements matching the
    criteria you specify. In list context, returns all elements that match all
    the given criteria; in scalar context, returns the first such element (or
    undef, if nothing matched).</p>
<p class="Pp">There are three kinds of criteria you can specify:</p>
<dl class="Bl-tag">
  <dt>(attr_name, attr_value)</dt>
  <dd>This means you're looking for an element with that value for that
      attribute. Example: <span class="Li">&quot;alt&quot;,
      &quot;pix!&quot;</span>. Consider that you can search on internal
      attribute values too: <span class="Li">&quot;_tag&quot;,
      &quot;p&quot;</span>.</dd>
  <dt>(attr_name, qr/.../)</dt>
  <dd>This means you're looking for an element whose value for that attribute
      matches the specified Regexp object.</dd>
  <dt id="a"><a class="permalink" href="#a">a coderef</a></dt>
  <dd>This means you're looking for elements where coderef-&gt;(each_element)
      returns true. Example:
    <p class="Pp"></p>
    <pre>  my @wide_pix_images = $h-&gt;look_down(
    _tag =&gt; &quot;img&quot;,
    alt  =&gt; &quot;pix!&quot;,
    sub { $_[0]-&gt;attr('width') &gt; 350 }
  );
    </pre>
  </dd>
</dl>
<p class="Pp">Note that <span class="Li">&quot;(attr_name,
    attr_value)&quot;</span> and <span class="Li">&quot;(attr_name,
    qr/.../)&quot;</span> criteria are almost always faster than coderef
    criteria, so should presumably be put before them in your list of criteria.
    That is, in the example above, the sub ref is called only for elements that
    have already passed the criteria of having a &quot;_tag&quot; attribute with
    value &quot;img&quot;, and an &quot;alt&quot; attribute with value
    &quot;pix!&quot;. If the coderef were first, it would be called on every
    element, and <i>then</i> what elements pass that criterion (i.e., elements
    for which the coderef returned true) would be checked for their
    &quot;_tag&quot; and &quot;alt&quot; attributes.</p>
<p class="Pp">Note that comparison of string attribute-values against the string
    value in <span class="Li">&quot;(attr_name, attr_value)&quot;</span> is
    case-INsensitive! A criterion of <span class="Li">&quot;('align',
    'right')&quot;</span> <i>will</i> match an element whose &quot;align&quot;
    value is &quot;RIGHT&quot;, or &quot;right&quot; or &quot;rIGhT&quot;,
  etc.</p>
<p class="Pp">Note also that <span class="Li">&quot;look_down&quot;</span>
    considers &quot;&quot; (empty-string) and undef to be different things, in
    attribute values. So this:</p>
<p class="Pp"></p>
<pre>  $h-&gt;look_down(&quot;alt&quot;, &quot;&quot;)
</pre>
<p class="Pp">will find elements <i>with</i> an &quot;alt&quot; attribute, but
    where the value for the &quot;alt&quot; attribute is &quot;&quot;. But
  this:</p>
<p class="Pp"></p>
<pre>  $h-&gt;look_down(&quot;alt&quot;, undef)
</pre>
<p class="Pp">is the same as:</p>
<p class="Pp"></p>
<pre>  $h-&gt;look_down(sub { !defined($_[0]-&gt;attr('alt')) } )
</pre>
<p class="Pp">That is, it finds elements that do not have an &quot;alt&quot;
    attribute at all (or that do have an &quot;alt&quot; attribute, but with a
    value of undef -- which is not normally possible).</p>
<p class="Pp">Note that when you give several criteria, this is taken to mean
    you're looking for elements that match <i>all</i> your criterion, not just
    <i>any</i> of them. In other words, there is an implicit &quot;and&quot;,
    not an &quot;or&quot;. So if you wanted to express that you wanted to find
    elements with a &quot;name&quot; attribute with the value &quot;foo&quot;
    <i>or</i> with an &quot;id&quot; attribute with the value &quot;baz&quot;,
    you'd have to do it like:</p>
<p class="Pp"></p>
<pre>  @them = $h-&gt;look_down(
    sub {
      # the lcs are to fold case
      lc($_[0]-&gt;attr('name')) eq 'foo'
      or lc($_[0]-&gt;attr('id')) eq 'baz'
    }
  );
</pre>
<p class="Pp">Coderef criteria are more expressive than
    <span class="Li">&quot;(attr_name, attr_value)&quot;</span> and
    <span class="Li">&quot;(attr_name, qr/.../)&quot;</span> criteria, and all
    <span class="Li">&quot;(attr_name, attr_value)&quot;</span> and
    <span class="Li">&quot;(attr_name, qr/.../)&quot;</span> criteria could be
    expressed in terms of coderefs. However, <span class="Li">&quot;(attr_name,
    attr_value)&quot;</span> and <span class="Li">&quot;(attr_name,
    qr/.../)&quot;</span> criteria are a convenient shorthand. (In fact,
    <span class="Li">&quot;look_down&quot;</span> itself is basically
    &quot;shorthand&quot; too, since anything you can do with
    <span class="Li">&quot;look_down&quot;</span> you could do by traversing the
    tree, either with the <span class="Li">&quot;traverse&quot;</span> method or
    with a routine of your own. However,
    <span class="Li">&quot;look_down&quot;</span> often makes for very concise
    and clear code.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="look_up"><a class="permalink" href="#look_up">look_up</a></h2>
<pre>  @elements = $h-&gt;look_up( ...criteria... );
  $first_match = $h-&gt;look_up( ...criteria... );
</pre>
<p class="Pp">This is identical to
    <span class="Li">&quot;$h-&gt;look_down&quot;</span>, except that whereas
    <span class="Li">&quot;$h-&gt;look_down&quot;</span> basically scans over
    the list:</p>
<p class="Pp"></p>
<pre>   ($h, $h-&gt;descendants)
</pre>
<p class="Pp"><span class="Li">&quot;$h-&gt;look_up&quot;</span> instead scans
    over the list</p>
<p class="Pp"></p>
<pre>   ($h, $h-&gt;lineage)
</pre>
<p class="Pp">So, for example, this returns all ancestors of
    <span class="Li">$h</span> (possibly including <span class="Li">$h</span>
    itself) that are <span class="Li">&quot;&lt;td&gt;&quot;</span> elements
    with an &quot;align&quot; attribute with a value of &quot;right&quot; (or
    &quot;RIGHT&quot;, etc.):</p>
<p class="Pp"></p>
<pre>   $h-&gt;look_up(&quot;_tag&quot;, &quot;td&quot;, &quot;align&quot;, &quot;right&quot;);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="traverse"><a class="permalink" href="#traverse">traverse</a></h2>
<pre>  $h-&gt;traverse(...options...)
</pre>
<p class="Pp">Lengthy discussion of HTML::Element's unnecessary and confusing
    <span class="Li">&quot;traverse&quot;</span> method has been moved to a
    separate file: HTML::Element::traverse</p>
</section>
<section class="Ss">
<h2 class="Ss" id="attr_get_i"><a class="permalink" href="#attr_get_i">attr_get_i</a></h2>
<pre>  @values = $h-&gt;attr_get_i('attribute');
  $first_value = $h-&gt;attr_get_i('attribute');
</pre>
<p class="Pp">In list context, returns a list consisting of the values of the
    given attribute for <span class="Li">$h</span> and for all its ancestors
    starting from <span class="Li">$h</span> and working its way up. Nodes with
    no such attribute are skipped. (&quot;attr_get_i&quot; stands for
    &quot;attribute get, with inheritance&quot;.) In scalar context, returns the
    first such value, or undef if none.</p>
<p class="Pp">Consider a document consisting of:</p>
<p class="Pp"></p>
<pre>   &lt;html lang='i-klingon'&gt;
     &lt;head&gt;&lt;title&gt;Pati Pata&lt;/title&gt;&lt;/head&gt;
     &lt;body&gt;
       &lt;h1 lang='la'&gt;Stuff&lt;/h1&gt;
       &lt;p lang='es-MX' align='center'&gt;
         Foo bar baz &lt;cite&gt;Quux&lt;/cite&gt;.
       &lt;/p&gt;
       &lt;p&gt;Hooboy.&lt;/p&gt;
     &lt;/body&gt;
   &lt;/html&gt;
</pre>
<p class="Pp">If <span class="Li">$h</span> is the
    <span class="Li">&quot;&lt;cite&gt;&quot;</span> element,
    <span class="Li">&quot;$h-&gt;attr_get_i(&quot;lang&quot;)&quot;</span> in
    list context will return the list <span class="Li">&quot;('es-MX',
    'i-klingon')&quot;</span>. In scalar context, it will return the value
    <span class="Li">'es-MX'</span>.</p>
<p class="Pp">If you call with multiple attribute names...</p>
<p class="Pp"></p>
<pre>  @values = $h-&gt;attr_get_i('a1', 'a2', 'a3');
  $first_value = $h-&gt;attr_get_i('a1', 'a2', 'a3');
</pre>
<p class="Pp">...in list context, this will return a list consisting of the
    values of these attributes which exist in <span class="Li">$h</span> and its
    ancestors. In scalar context, this returns the first value (i.e., the value
    of the first existing attribute from the first element that has any of the
    attributes listed). So, in the above example,</p>
<p class="Pp"></p>
<pre>  $h-&gt;attr_get_i('lang', 'align');
</pre>
<p class="Pp">will return:</p>
<p class="Pp"></p>
<pre>   ('es-MX', 'center', 'i-klingon') # in list context
  or
   'es-MX' # in scalar context.
</pre>
<p class="Pp">But note that this:</p>
<p class="Pp"></p>
<pre> $h-&gt;attr_get_i('align', 'lang');
</pre>
<p class="Pp">will return:</p>
<p class="Pp"></p>
<pre>   ('center', 'es-MX', 'i-klingon') # in list context
  or
   'center' # in scalar context.
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="tagname_map"><a class="permalink" href="#tagname_map">tagname_map</a></h2>
<pre>  $hash_ref = $h-&gt;tagname_map();
</pre>
<p class="Pp">Scans across <span class="Li">$h</span> and all its descendants,
    and makes a hash (a reference to which is returned) where each entry
    consists of a key that's a tag name, and a value that's a reference to a
    list to all elements that have that tag name. I.e., this method returns:</p>
<p class="Pp"></p>
<pre>   {
     # Across $h and all descendants...
     'a'   =&gt; [ ...list of all &lt;a&gt;   elements... ],
     'em'  =&gt; [ ...list of all &lt;em&gt;  elements... ],
     'img' =&gt; [ ...list of all &lt;img&gt; elements... ],
   }
</pre>
<p class="Pp">(There are entries in the hash for only those tagnames that occur
    at/under <span class="Li">$h</span> -- so if there's no
    <span class="Li">&quot;&lt;img&gt;&quot;</span> elements, there'll be no
    &quot;img&quot; entry in the returned hashref.)</p>
<p class="Pp">Example usage:</p>
<p class="Pp"></p>
<pre>    my $map_r = $h-&gt;tagname_map();
    my @heading_tags = sort grep m/^h\d$/s, keys %$map_r;
    if(@heading_tags) {
      print &quot;Heading levels used: @heading_tags\n&quot;;
    } else {
      print &quot;No headings.\n&quot;
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="extract_links"><a class="permalink" href="#extract_links">extract_links</a></h2>
<pre>  $links_array_ref = $h-&gt;extract_links();
  $links_array_ref = $h-&gt;extract_links(@wantedTypes);
</pre>
<p class="Pp">Returns links found by traversing the element and all of its
    children and looking for attributes (like &quot;href&quot; in an
    <span class="Li">&quot;&lt;a&gt;&quot;</span> element, or &quot;src&quot; in
    an <span class="Li">&quot;&lt;img&gt;&quot;</span> element) whose values
    represent links. The return value is a <i>reference</i> to an array. Each
    element of the array is reference to an array with <i>four</i> items: the
    link-value, the element that has the attribute with that link-value, and the
    name of that attribute, and the tagname of that element. (Example:
    <span class="Li">&quot;['http://www.suck.com/',&quot;</span>
    <i></i><span class="Li"><i>$elem_obj</i></span><i></i>
    <span class="Li">&quot;, 'href', 'a']&quot;</span>.) You may or may not end
    up using the element itself -- for some purposes, you may use only the link
    value.</p>
<p class="Pp">You might specify that you want to extract links from just some
    kinds of elements (instead of the default, which is to extract links from
    <i>all</i> the kinds of elements known to have attributes whose values
    represent links). For instance, if you want to extract links from only
    <span class="Li">&quot;&lt;a&gt;&quot;</span> and
    <span class="Li">&quot;&lt;img&gt;&quot;</span> elements, you could code it
    like this:</p>
<p class="Pp"></p>
<pre>  for (@{  $e-&gt;extract_links('a', 'img')  }) {
      my($link, $element, $attr, $tag) = @$_;
      print
        &quot;Hey, there's a $tag that links to &quot;,
        $link, &quot;, in its $attr attribute, at &quot;,
        $element-&gt;address(), &quot;.\n&quot;;
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="simplify_pres"><a class="permalink" href="#simplify_pres">simplify_pres</a></h2>
<pre>  $h-&gt;simplify_pres();
</pre>
<p class="Pp">In text bits under PRE elements that are at/under
    <span class="Li">$h</span>, this routine nativizes all newlines, and expands
    all tabs.</p>
<p class="Pp">That is, if you read a file with lines delimited by
    <span class="Li">&quot;\cm\cj&quot;</span>'s, the text under PRE areas will
    have <span class="Li">&quot;\cm\cj&quot;</span>'s instead of
    <span class="Li">&quot;\n&quot;</span>'s. Calling
    <span class="Li">&quot;$h-&gt;simplify_pres&quot;</span> on such a tree will
    turn <span class="Li">&quot;\cm\cj&quot;</span>'s into
    <span class="Li">&quot;\n&quot;</span>'s.</p>
<p class="Pp">Tabs are expanded to however many spaces it takes to get to the
    next 8th column -- the usual way of expanding them.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="same_as"><a class="permalink" href="#same_as">same_as</a></h2>
<pre>  $equal = $h-&gt;same_as($i)
</pre>
<p class="Pp">Returns true if <span class="Li">$h</span> and
    <span class="Li">$i</span> are both elements representing the same tree of
    elements, each with the same tag name, with the same explicit attributes
    (i.e., not counting attributes whose names start with &quot;_&quot;), and
    with the same content (textual, comments, etc.).</p>
<p class="Pp">Sameness of descendant elements is tested, recursively, with
    <span class="Li">&quot;$child1-&gt;same_as($child_2)&quot;</span>, and
    sameness of text segments is tested with <span class="Li">&quot;$segment1 eq
    $segment2&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="new_from_lol"><a class="permalink" href="#new_from_lol">new_from_lol</a></h2>
<pre>  $h = HTML::Element-&gt;new_from_lol($array_ref);
  @elements = HTML::Element-&gt;new_from_lol($array_ref, ...);
</pre>
<p class="Pp">Resursively constructs a tree of nodes, based on the (non-cyclic)
    data structure represented by each <span class="Li">$array_ref</span>, where
    that is a reference to an array of arrays (of arrays (of arrays
  (etc.))).</p>
<p class="Pp">In each arrayref in that structure, different kinds of values are
    treated as follows:</p>
<ul class="Bl-bullet">
  <li>Arrayrefs
    <p class="Pp">Arrayrefs are considered to designate a sub-tree representing
        children for the node constructed from the current arrayref.</p>
  </li>
  <li>Hashrefs
    <p class="Pp">Hashrefs are considered to contain attribute-value pairs to
        add to the element to be constructed from the current arrayref</p>
  </li>
  <li>Text segments
    <p class="Pp">Text segments at the start of any arrayref will be considered
        to specify the name of the element to be constructed from the current
        arrayref; all other text segments will be considered to specify text
        segments as children for the current arrayref.</p>
  </li>
  <li>Elements
    <p class="Pp">Existing element objects are either inserted into the treelet
        constructed, or clones of them are. That is, when the lol-tree is being
        traversed and elements constructed based what's in it, if an existing
        element object is found, if it has no parent, then it is added directly
        to the treelet constructed; but if it has a parent, then
        <span class="Li">&quot;$that_node-&gt;clone&quot;</span> is added to the
        treelet at the appropriate place.</p>
  </li>
</ul>
<p class="Pp">An example will hopefully make this more obvious:</p>
<p class="Pp"></p>
<pre>  my $h = HTML::Element-&gt;new_from_lol(
    ['html',
      ['head',
        [ 'title', 'I like stuff!' ],
      ],
      ['body',
        {'lang', 'en-JP', _implicit =&gt; 1},
        'stuff',
        ['p', 'um, p &lt; 4!', {'class' =&gt; 'par123'}],
        ['div', {foo =&gt; 'bar'}, '123'],
      ]
    ]
  );
  $h-&gt;dump;
</pre>
<p class="Pp">Will print this:</p>
<p class="Pp"></p>
<pre>  &lt;html&gt; @0
    &lt;head&gt; @0.0
      &lt;title&gt; @0.0.0
        &quot;I like stuff!&quot;
    &lt;body lang=&quot;en-JP&quot;&gt; @0.1 (IMPLICIT)
      &quot;stuff&quot;
      &lt;p class=&quot;par123&quot;&gt; @0.1.1
        &quot;um, p &lt; 4!&quot;
      &lt;div foo=&quot;bar&quot;&gt; @0.1.2
        &quot;123&quot;
</pre>
<p class="Pp">And printing <span class="Li">$h</span>-&gt;as_HTML will give
    something like:</p>
<p class="Pp"></p>
<pre>  &lt;html&gt;&lt;head&gt;&lt;title&gt;I like stuff!&lt;/title&gt;&lt;/head&gt;
  &lt;body lang=&quot;en-JP&quot;&gt;stuff&lt;p class=&quot;par123&quot;&gt;um, p &amp;lt; 4!
  &lt;div foo=&quot;bar&quot;&gt;123&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;
</pre>
<p class="Pp">You can even do fancy things with
    <span class="Li">&quot;map&quot;</span>:</p>
<p class="Pp"></p>
<pre>  $body-&gt;push_content(
    # push_content implicitly calls new_from_lol on arrayrefs...
    ['br'],
    ['blockquote',
      ['h2', 'Pictures!'],
      map ['p', $_],
      $body2-&gt;look_down(&quot;_tag&quot;, &quot;img&quot;),
        # images, to be copied from that other tree.
    ],
    # and more stuff:
    ['ul',
      map ['li', ['a', {'href'=&gt;&quot;$_.png&quot;}, $_ ] ],
      qw(Peaches Apples Pears Mangos)
    ],
  );
</pre>
<p class="Pp">In scalar context, you must supply exactly one arrayref. In list
    context, you can pass a list of arrayrefs, and new_from_lol will return a
    list of elements, one for each arrayref.</p>
<p class="Pp"></p>
<pre>  @elements = HTML::Element-&gt;new_from_lol(
    ['hr'],
    ['p', 'And there, on the door, was a hook!'],
  );
   # constructs two elements.
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="objectify_text"><a class="permalink" href="#objectify_text">objectify_text</a></h2>
<pre>  $h-&gt;objectify_text();
</pre>
<p class="Pp">This turns any text nodes under <span class="Li">$h</span> from
    mere text segments (strings) into real objects, pseudo-elements with a
    tag-name of &quot;~text&quot;, and the actual text content in an attribute
    called &quot;text&quot;. (For a discussion of pseudo-elements, see the
    &quot;tag&quot; method, far above.) This method is provided because, for
    some purposes, it is convenient or necessary to be able, for a given text
    node, to ask what element is its parent; and clearly this is not possible if
    a node is just a text string.</p>
<p class="Pp">Note that these &quot;~text&quot; objects are not recognized as
    text nodes by methods like &quot;as_text&quot;. Presumably you will want to
    call <span class="Li">&quot;$h-&gt;objectify_text&quot;</span>, perform
    whatever task that you needed that for, and then call
    <span class="Li">&quot;$h-&gt;deobjectify_text&quot;</span> before calling
    anything like <span class="Li">&quot;$h-&gt;as_text&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="deobjectify_text"><a class="permalink" href="#deobjectify_text">deobjectify_text</a></h2>
<pre>  $h-&gt;deobjectify_text();
</pre>
<p class="Pp">This undoes the effect of
    <span class="Li">&quot;$h-&gt;objectify_text&quot;</span>. That is, it takes
    any &quot;~text&quot; pseudo-elements in the tree at/under
    <span class="Li">$h</span>, and deletes each one, replacing each with the
    content of its &quot;text&quot; attribute.</p>
<p class="Pp">Note that if <span class="Li">$h</span> itself is a
    &quot;~text&quot; pseudo-element, it will be destroyed -- a condition you
    may need to treat specially in your calling code (since it means you can't
    very well do anything with <span class="Li">$h</span> after that). So that
    you can detect that condition, if <span class="Li">$h</span> is itself a
    &quot;~text&quot; pseudo-element, then this method returns the value of the
    &quot;text&quot; attribute, which should be a defined value; in all other
    cases, it returns undef.</p>
<p class="Pp">(This method assumes that no &quot;~text&quot; pseudo-element has
    any children.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="number_lists"><a class="permalink" href="#number_lists">number_lists</a></h2>
<pre>  $h-&gt;number_lists();
</pre>
<p class="Pp">For every UL, OL, DIR, and MENU element at/under
    <span class="Li">$h</span>, this sets a &quot;_bullet&quot; attribute for
    every child LI element. For LI children of an OL, the &quot;_bullet&quot;
    attribute's value will be something like &quot;4.&quot;, &quot;d.&quot;,
    &quot;D.&quot;, &quot;IV.&quot;, or &quot;iv.&quot;, depending on the OL
    element's &quot;type&quot; attribute. LI children of a UL, DIR, or MENU get
    their &quot;_bullet&quot; attribute set to &quot;*&quot;. There should be no
    other LIs (i.e., except as children of OL, UL, DIR, or MENU elements), and
    if there are, they are unaffected.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="has_insane_linkage"><a class="permalink" href="#has_insane_linkage">has_insane_linkage</a></h2>
<pre>  $h-&gt;has_insane_linkage
</pre>
<p class="Pp">This method is for testing whether this element or the elements
    under it have linkage attributes (_parent and _content) whose values are
    deeply aberrant: if there are undefs in a content list; if an element
    appears in the content lists of more than one element; if the _parent
    attribute of an element doesn't match its actual parent; or if an element
    appears as its own descendant (i.e., if there is a cyclicity in the
  tree).</p>
<p class="Pp">This returns empty list (or false, in scalar context) if the
    subtree's linkage methods are sane; otherwise it returns two items (or true,
    in scalar context): the element where the error occurred, and a string
    describing the error.</p>
<p class="Pp">This method is provided is mainly for debugging and
    troubleshooting -- it should be <i>quite impossible</i> for any document
    constructed via HTML::TreeBuilder to parse into a non-sane tree (since it's
    not the content of the tree per se that's in question, but whether the tree
    in memory was properly constructed); and it <i>should</i> be impossible for
    you to produce an insane tree just thru reasonable use of normal documented
    structure-modifying methods. But if you're constructing your own trees, and
    your program is going into infinite loops as during calls to
    <b>traverse()</b> or any of the secondary structural methods, as part of
    debugging, consider calling
    <span class="Li">&quot;has_insane_linkage&quot;</span> on the tree.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="element_class"><a class="permalink" href="#element_class">element_class</a></h2>
<pre>  $classname = $h-&gt;element_class();
</pre>
<p class="Pp">This method returns the class which will be used for new elements.
    It defaults to HTML::Element, but can be overridden by subclassing or
    esoteric means best left to those will will read the source and then not
    complain when those esoteric means change. (Just subclass.)</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CLASS_METHODS"><a class="permalink" href="#CLASS_METHODS">CLASS
  METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Use_Weak_Refs"><a class="permalink" href="#Use_Weak_Refs">Use_Weak_Refs</a></h2>
<pre>  $enabled = HTML::Element-&gt;Use_Weak_Refs;
  HTML::Element-&gt;Use_Weak_Refs( $enabled );
</pre>
<p class="Pp">This method allows you to check whether weak reference support is
    enabled, and to enable or disable it. For details, see &quot;Weak
    References&quot;. <span class="Li">$enabled</span> is true if weak
    references are enabled.</p>
<p class="Pp">You should not switch this in the middle of your program, and you
    probably shouldn't use it at all. Existing trees are not affected by this
    method (until you start modifying nodes in them).</p>
<p class="Pp">Throws an exception if you attempt to enable weak references and
    your Perl or Scalar::Util does not support them.</p>
<p class="Pp">Disabling weak reference support is deprecated.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SUBROUTINES"><a class="permalink" href="#SUBROUTINES">SUBROUTINES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Version"><a class="permalink" href="#Version">Version</a></h2>
<p class="Pp">This subroutine is deprecated. Please use the standard VERSION
    method (e.g. <span class="Li">&quot;HTML::Element-&gt;VERSION&quot;</span>)
    instead.</p>
</section>
<section class="Ss">
<h2 class="Ss">ABORT OK PRUNE PRUNE_SOFTLY PRUNE_UP</h2>
<p class="Pp">Constants for signalling back to the traverser</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">* If you want to free the memory associated with a tree built of
    HTML::Element nodes, and you have disabled weak references, then you will
    have to delete it explicitly using the &quot;delete&quot; method. See
    &quot;Weak References&quot;.</p>
<p class="Pp">* There's almost nothing to stop you from making a
    &quot;tree&quot; with cyclicities (loops) in it, which could, for example,
    make the traverse method go into an infinite loop. So don't make
    cyclicities! (If all you're doing is parsing HTML files, and looking at the
    resulting trees, this will never be a problem for you.)</p>
<p class="Pp">* There's no way to represent comments or processing directives in
    a tree with HTML::Elements. Not yet, at least.</p>
<p class="Pp">* There's (currently) nothing to stop you from using an undefined
    value as a text segment. If you're running under <span class="Li">&quot;perl
    -w&quot;</span>, however, this may make HTML::Element's code produce a slew
    of warnings.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES_ON_SUBCLASSING"><a class="permalink" href="#NOTES_ON_SUBCLASSING">NOTES
  ON SUBCLASSING</a></h1>
<p class="Pp">You are welcome to derive subclasses from HTML::Element, but you
    should be aware that the code in HTML::Element makes certain assumptions
    about elements (and I'm using &quot;element&quot; to mean ONLY an object of
    class HTML::Element, or of a subclass of HTML::Element):</p>
<p class="Pp">* The value of an element's _parent attribute must either be undef
    or otherwise false, or must be an element.</p>
<p class="Pp">* The value of an element's _content attribute must either be
    undef or otherwise false, or a reference to an (unblessed) array. The array
    may be empty; but if it has items, they must ALL be either mere strings
    (text segments), or elements.</p>
<p class="Pp">* The value of an element's _tag attribute should, at least, be a
    string of printable characters.</p>
<p class="Pp">Moreover, bear these rules in mind:</p>
<p class="Pp">* Do not break encapsulation on objects. That is, access their
    contents only thru <span class="Li">$obj</span>-&gt;attr or more specific
    methods.</p>
<p class="Pp">* You should think twice before completely overriding any of the
    methods that HTML::Element provides. (Overriding with a method that calls
    the superclass method is not so bad, though.)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">HTML::Tree; HTML::TreeBuilder; HTML::AsSubs; HTML::Tagset; and,
    for the morbidly curious, HTML::Element::traverse.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGEMENTS"><a class="permalink" href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></h1>
<p class="Pp">Thanks to Mark-Jason Dominus for a POD suggestion.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Current maintainers:</p>
<ul class="Bl-bullet">
  <li>Christopher J. Madsen
      <span class="Li">&quot;&lt;perl&#x00A0;AT&#x00A0;cjmweb.net&gt;&quot;</span></li>
  <li>Jeff Fearn
      <span class="Li">&quot;&lt;jfearn&#x00A0;AT&#x00A0;cpan.org&gt;&quot;</span></li>
</ul>
<p class="Pp">Original HTML-Tree author:</p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>Gisle Aas</dd>
</dl>
<p class="Pp">Former maintainers:</p>
<ul class="Bl-bullet">
  <li>Sean M. Burke</li>
  <li>Andy Lester</li>
  <li>Pete Krawczyk
      <span class="Li">&quot;&lt;petek&#x00A0;AT&#x00A0;cpan.org&gt;&quot;</span></li>
</ul>
<p class="Pp">You can follow or contribute to HTML-Tree's development at
    &lt;https://github.com/kentfredric/HTML-Tree&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">Copyright 1995-1998 Gisle Aas, 1999-2004 Sean M. Burke, 2005 Andy
    Lester, 2006 Pete Krawczyk, 2010 Jeff Fearn, 2012 Christopher J. Madsen.</p>
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">The programs in this library are distributed in the hope that they
    will be useful, but without any warranty; without even the implied warranty
    of merchantability or fitness for a particular purpose.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2024-11-10</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

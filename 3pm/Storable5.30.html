<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Storable(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Storable(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Storable(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Storable - persistence for Perl data structures</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre> use Storable;
 store \%table, 'file';
 $hashref = retrieve('file');
 use Storable qw(nstore store_fd nstore_fd freeze thaw dclone);
 # Network order
 nstore \%table, 'file';
 $hashref = retrieve('file');   # There is NO nretrieve()
 # Storing to and retrieving from an already opened file
 store_fd \@array, \*STDOUT;
 nstore_fd \%table, \*STDOUT;
 $aryref = fd_retrieve(\*SOCKET);
 $hashref = fd_retrieve(\*SOCKET);
 # Serializing to memory
 $serialized = freeze \%table;
 %table_clone = %{ thaw($serialized) };
 # Deep (recursive) cloning
 $cloneref = dclone($ref);
 # Advisory locking
 use Storable qw(lock_store lock_nstore lock_retrieve)
 lock_store \%table, 'file';
 lock_nstore \%table, 'file';
 $hashref = lock_retrieve('file');
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The Storable package brings persistence to your Perl data
    structures containing SCALAR, ARRAY, HASH or REF objects, i.e. anything that
    can be conveniently stored to disk and retrieved at a later time.</p>
<p class="Pp">It can be used in the regular procedural way by calling
    <span class="Li">&quot;store&quot;</span> with a reference to the object to
    be stored, along with the file name where the image should be written.</p>
<p class="Pp">The routine returns <span class="Li">&quot;undef&quot;</span> for
    I/O problems or other internal error, a true value otherwise. Serious errors
    are propagated as a <span class="Li">&quot;die&quot;</span> exception.</p>
<p class="Pp">To retrieve data stored to disk, use
    <span class="Li">&quot;retrieve&quot;</span> with a file name. The objects
    stored into that file are recreated into memory for you, and a
    <i>reference</i> to the root object is returned. In case an I/O error occurs
    while reading, <span class="Li">&quot;undef&quot;</span> is returned
    instead. Other serious errors are propagated via
    <span class="Li">&quot;die&quot;</span>.</p>
<p class="Pp">Since storage is performed recursively, you might want to stuff
    references to objects that share a lot of common data into a single array or
    hash table, and then store that object. That way, when you retrieve back the
    whole thing, the objects will continue to share what they originally
  shared.</p>
<p class="Pp">At the cost of a slight header overhead, you may store to an
    already opened file descriptor using the
    <span class="Li">&quot;store_fd&quot;</span> routine, and retrieve from a
    file via <span class="Li">&quot;fd_retrieve&quot;</span>. Those names aren't
    imported by default, so you will have to do that explicitly if you need
    those routines. The file descriptor you supply must be already opened, for
    read if you're going to retrieve and for write if you wish to store.</p>
<p class="Pp"></p>
<pre>        store_fd(\%table, *STDOUT) || die &quot;can't store to stdout\n&quot;;
        $hashref = fd_retrieve(*STDIN);
</pre>
<p class="Pp">You can also store data in network order to allow easy sharing
    across multiple platforms, or when storing on a socket known to be remotely
    connected. The routines to call have an initial
    <span class="Li">&quot;n&quot;</span> prefix for <i>network</i>, as in
    <span class="Li">&quot;nstore&quot;</span> and
    <span class="Li">&quot;nstore_fd&quot;</span>. At retrieval time, your data
    will be correctly restored so you don't have to know whether you're
    restoring from native or network ordered data. Double values are stored
    stringified to ensure portability as well, at the slight risk of loosing
    some precision in the last decimals.</p>
<p class="Pp">When using <span class="Li">&quot;fd_retrieve&quot;</span>,
    objects are retrieved in sequence, one object (i.e. one recursive tree) per
    associated <span class="Li">&quot;store_fd&quot;</span>.</p>
<p class="Pp">If you're more from the object-oriented camp, you can inherit from
    Storable and directly store your objects by invoking
    <span class="Li">&quot;store&quot;</span> as a method. The fact that the
    root of the to-be-stored tree is a blessed reference (i.e. an object) is
    special-cased so that the retrieve does not provide a reference to that
    object but rather the blessed object reference itself. (Otherwise, you'd get
    a reference to that blessed object).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MEMORY_STORE"><a class="permalink" href="#MEMORY_STORE">MEMORY
  STORE</a></h1>
<p class="Pp">The Storable engine can also store data into a Perl scalar
    instead, to later retrieve them. This is mainly used to freeze a complex
    structure in some safe compact memory place (where it can possibly be sent
    to another process via some IPC, since freezing the structure also
    serializes it in effect). Later on, and maybe somewhere else, you can thaw
    the Perl scalar out and recreate the original complex structure in
  memory.</p>
<p class="Pp">Surprisingly, the routines to be called are named
    <span class="Li">&quot;freeze&quot;</span> and
    <span class="Li">&quot;thaw&quot;</span>. If you wish to send out the frozen
    scalar to another machine, use <span class="Li">&quot;nfreeze&quot;</span>
    instead to get a portable image.</p>
<p class="Pp">Note that freezing an object structure and immediately thawing it
    actually achieves a deep cloning of that structure:</p>
<p class="Pp"></p>
<pre>    dclone(.) = thaw(freeze(.))
</pre>
<p class="Pp">Storable provides you with a
    <span class="Li">&quot;dclone&quot;</span> interface which does not create
    that intermediary scalar but instead freezes the structure in some internal
    memory space and then immediately thaws it out.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ADVISORY_LOCKING"><a class="permalink" href="#ADVISORY_LOCKING">ADVISORY
  LOCKING</a></h1>
<p class="Pp">The <span class="Li">&quot;lock_store&quot;</span> and
    <span class="Li">&quot;lock_nstore&quot;</span> routine are equivalent to
    <span class="Li">&quot;store&quot;</span> and
    <span class="Li">&quot;nstore&quot;</span>, except that they get an
    exclusive lock on the file before writing. Likewise,
    <span class="Li">&quot;lock_retrieve&quot;</span> does the same as
    <span class="Li">&quot;retrieve&quot;</span>, but also gets a shared lock on
    the file before reading.</p>
<p class="Pp">As with any advisory locking scheme, the protection only works if
    you systematically use <span class="Li">&quot;lock_store&quot;</span> and
    <span class="Li">&quot;lock_retrieve&quot;</span>. If one side of your
    application uses <span class="Li">&quot;store&quot;</span> whilst the other
    uses <span class="Li">&quot;lock_retrieve&quot;</span>, you will get no
    protection at all.</p>
<p class="Pp">The internal advisory locking is implemented using Perl's
    <b>flock()</b> routine. If your system does not support any form of
    <b>flock()</b>, or if you share your files across NFS, you might wish to use
    other forms of locking by using modules such as LockFile::Simple which lock
    a file using a filesystem entry, instead of locking the file descriptor.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SPEED"><a class="permalink" href="#SPEED">SPEED</a></h1>
<p class="Pp">The heart of Storable is written in C for decent speed. Extra
    low-level optimizations have been made when manipulating perl internals, to
    sacrifice encapsulation for the benefit of greater speed.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CANONICAL_REPRESENTATION"><a class="permalink" href="#CANONICAL_REPRESENTATION">CANONICAL
  REPRESENTATION</a></h1>
<p class="Pp">Normally, Storable stores elements of hashes in the order they are
    stored internally by Perl, i.e. pseudo-randomly. If you set
    <span class="Li">$Storable::canonical</span> to some
    <span class="Li">&quot;TRUE&quot;</span> value, Storable will store hashes
    with the elements sorted by their key. This allows you to compare data
    structures by comparing their frozen representations (or even the compressed
    frozen representations), which can be useful for creating lookup tables for
    complicated queries.</p>
<p class="Pp">Canonical order does not imply network order; those are two
    orthogonal settings.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CODE_REFERENCES"><a class="permalink" href="#CODE_REFERENCES">CODE
  REFERENCES</a></h1>
<p class="Pp">Since Storable version 2.05, CODE references may be serialized
    with the help of B::Deparse. To enable this feature, set
    <span class="Li">$Storable::Deparse</span> to a true value. To enable
    deserialization, <span class="Li">$Storable::Eval</span> should be set to a
    true value. Be aware that deserialization is done through
    <span class="Li">&quot;eval&quot;</span>, which is dangerous if the Storable
    file contains malicious data. You can set
    <span class="Li">$Storable::Eval</span> to a subroutine reference which
    would be used instead of <span class="Li">&quot;eval&quot;</span>. See below
    for an example using a Safe compartment for deserialization of CODE
    references.</p>
<p class="Pp">If <span class="Li">$Storable::Deparse</span> and/or
    <span class="Li">$Storable::Eval</span> are set to false values, then the
    value of <span class="Li">$Storable::forgive_me</span> (see below) is
    respected while serializing and deserializing.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FORWARD_COMPATIBILITY"><a class="permalink" href="#FORWARD_COMPATIBILITY">FORWARD
  COMPATIBILITY</a></h1>
<p class="Pp">This release of Storable can be used on a newer version of Perl to
    serialize data which is not supported by earlier Perls. By default, Storable
    will attempt to do the right thing, by
    <span class="Li">&quot;croak()&quot;</span>ing if it encounters data that it
    cannot deserialize. However, the defaults can be changed as follows:</p>
<dl class="Bl-tag">
  <dt id="utf8"><a class="permalink" href="#utf8">utf8 data</a></dt>
  <dd>Perl 5.6 added support for Unicode characters with code points &gt; 255,
      and Perl 5.8 has full support for Unicode characters in hash keys. Perl
      internally encodes strings with these characters using utf8, and Storable
      serializes them as utf8. By default, if an older version of Perl
      encounters a utf8 value it cannot represent, it will
      <span class="Li">&quot;croak()&quot;</span>. To change this behaviour so
      that Storable deserializes utf8 encoded values as the string of bytes
      (effectively dropping the <i>is_utf8</i> flag) set
      <span class="Li">$Storable::drop_utf8</span> to some
      <span class="Li">&quot;TRUE&quot;</span> value. This is a form of data
      loss, because with <span class="Li">$drop_utf8</span> true, it becomes
      impossible to tell whether the original data was the Unicode string, or a
      series of bytes that happen to be valid utf8.</dd>
  <dt id="restricted"><a class="permalink" href="#restricted">restricted
    hashes</a></dt>
  <dd>Perl 5.8 adds support for restricted hashes, which have keys restricted to
      a given set, and can have values locked to be read only. By default, when
      Storable encounters a restricted hash on a perl that doesn't support them,
      it will deserialize it as a normal hash, silently discarding any
      placeholder keys and leaving the keys and all values unlocked. To make
      Storable <span class="Li">&quot;croak()&quot;</span> instead, set
      <span class="Li">$Storable::downgrade_restricted</span> to a
      <span class="Li">&quot;FALSE&quot;</span> value. To restore the default
      set it back to some <span class="Li">&quot;TRUE&quot;</span> value.
    <p class="Pp">The cperl PERL_PERTURB_KEYS_TOP hash strategy has a known
        problem with restricted hashes.</p>
  </dd>
  <dt id="huge"><a class="permalink" href="#huge">huge objects</a></dt>
  <dd>On 64bit systems some data structures may exceed the 2G (i.e. I32_MAX)
      limit. On 32bit systems also strings between I32 and U32 (2G-4G). Since
      Storable 3.00 (not in perl5 core) we are able to store and retrieve these
      objects, even if perl5 itself is not able to handle them. These are
      strings longer then 4G, arrays with more then 2G elements and hashes with
      more then 2G elements. cperl forbids hashes with more than 2G elements,
      but this fail in cperl then. perl5 itself at least until 5.26 allows it,
      but cannot iterate over them. Note that creating those objects might cause
      out of memory exceptions by the operating system before perl has a chance
      to abort.</dd>
  <dt id="files"><a class="permalink" href="#files">files from future versions
    of Storable</a></dt>
  <dd>Earlier versions of Storable would immediately croak if they encountered a
      file with a higher internal version number than the reading Storable knew
      about. Internal version numbers are increased each time new data types
      (such as restricted hashes) are added to the vocabulary of the file
      format. This meant that a newer Storable module had no way of writing a
      file readable by an older Storable, even if the writer didn't store newer
      data types.
    <p class="Pp">This version of Storable will defer croaking until it
        encounters a data type in the file that it does not recognize. This
        means that it will continue to read files generated by newer Storable
        modules which are careful in what they write out, making it easier to
        upgrade Storable modules in a mixed environment.</p>
    <p class="Pp">The old behaviour of immediate croaking can be re-instated by
        setting <span class="Li">$Storable::accept_future_minor</span> to some
        <span class="Li">&quot;FALSE&quot;</span> value.</p>
  </dd>
</dl>
<p class="Pp">All these variables have no effect on a newer Perl which supports
    the relevant feature.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ERROR_REPORTING"><a class="permalink" href="#ERROR_REPORTING">ERROR
  REPORTING</a></h1>
<p class="Pp">Storable uses the &quot;exception&quot; paradigm, in that it does
    not try to workaround failures: if something bad happens, an exception is
    generated from the caller's perspective (see Carp and
    <span class="Li">&quot;croak()&quot;</span>). Use eval {} to trap those
    exceptions.</p>
<p class="Pp">When Storable croaks, it tries to report the error via the
    <span class="Li">&quot;logcroak()&quot;</span> routine from the
    <span class="Li">&quot;Log::Agent&quot;</span> package, if it is
  available.</p>
<p class="Pp">Normal errors are reported by having <b>store()</b> or
    <b>retrieve()</b> return <span class="Li">&quot;undef&quot;</span>. Such
    errors are usually I/O errors (or truncated stream errors at retrieval).</p>
<p class="Pp">When Storable throws the &quot;Max. recursion depth with nested
    structures exceeded&quot; error we are already out of stack space.
    Unfortunately on some earlier perl versions cleaning up a recursive data
    structure recurses into the free calls, which will lead to stack overflows
    in the cleanup. This data structure is not properly cleaned up then, it will
    only be destroyed during global destruction.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="WIZARDS_ONLY"><a class="permalink" href="#WIZARDS_ONLY">WIZARDS
  ONLY</a></h1>
<section class="Ss">
<h2 class="Ss" id="Hooks"><a class="permalink" href="#Hooks">Hooks</a></h2>
<p class="Pp">Any class may define hooks that will be called during the
    serialization and deserialization process on objects that are instances of
    that class. Those hooks can redefine the way serialization is performed (and
    therefore, how the symmetrical deserialization should be conducted).</p>
<p class="Pp">Since we said earlier:</p>
<p class="Pp"></p>
<pre>    dclone(.) = thaw(freeze(.))
</pre>
<p class="Pp">everything we say about hooks should also hold for deep cloning.
    However, hooks get to know whether the operation is a mere serialization, or
    a cloning.</p>
<p class="Pp">Therefore, when serializing hooks are involved,</p>
<p class="Pp"></p>
<pre>    dclone(.) &lt;&gt; thaw(freeze(.))
</pre>
<p class="Pp">Well, you could keep them in sync, but there's no guarantee it
    will always hold on classes somebody else wrote. Besides, there is little to
    gain in doing so: a serializing hook could keep only one attribute of an
    object, which is probably not what should happen during a deep cloning of
    that same object.</p>
<p class="Pp">Here is the hooking interface:</p>
<dl class="Bl-tag">
  <dt>&quot;STORABLE_freeze&quot; <i>obj</i>, <i>cloning</i></dt>
  <dd>The serializing hook, called on the object during serialization. It can be
      inherited, or defined in the class itself, like any other method.
    <p class="Pp">Arguments: <i>obj</i> is the object to serialize,
        <i>cloning</i> is a flag indicating whether we're in a <b>dclone()</b>
        or a regular serialization via <b>store()</b> or <b>freeze()</b>.</p>
    <p class="Pp">Returned value: A LIST <span class="Li">&quot;($serialized,
        $ref1, $ref2, ...)&quot;</span> where
        <span class="Li">$serialized</span> is the serialized form to be used,
        and the optional <span class="Li">$ref1</span>,
        <span class="Li">$ref2</span>, etc... are extra references that you wish
        to let the Storable engine serialize.</p>
    <p class="Pp">At deserialization time, you will be given back the same LIST,
        but all the extra references will be pointing into the deserialized
        structure.</p>
    <p class="Pp">The <b>first time</b> the hook is hit in a serialization flow,
        you may have it return an empty list. That will signal the Storable
        engine to further discard that hook for this class and to therefore
        revert to the default serialization of the underlying Perl data. The
        hook will again be normally processed in the next serialization.</p>
    <p class="Pp">Unless you know better, serializing hook should always
      say:</p>
    <p class="Pp"></p>
    <pre>    sub STORABLE_freeze {
        my ($self, $cloning) = @_;
        return if $cloning;         # Regular default serialization
        ....
    }
    </pre>
    <p class="Pp">in order to keep reasonable <b>dclone()</b> semantics.</p>
  </dd>
  <dt>&quot;STORABLE_thaw&quot; <i>obj</i>, <i>cloning</i>, <i>serialized</i>,
    ...</dt>
  <dd>The deserializing hook called on the object during deserialization. But
      wait: if we're deserializing, there's no object yet... right?
    <p class="Pp">Wrong: the Storable engine creates an empty one for you. If
        you know Eiffel, you can view
        <span class="Li">&quot;STORABLE_thaw&quot;</span> as an alternate
        creation routine.</p>
    <p class="Pp">This means the hook can be inherited like any other method,
        and that <i>obj</i> is your blessed reference for this particular
        instance.</p>
    <p class="Pp">The other arguments should look familiar if you know
        <span class="Li">&quot;STORABLE_freeze&quot;</span>: <i>cloning</i> is
        true when we're part of a deep clone operation, <i>serialized</i> is the
        serialized string you returned to the engine in
        <span class="Li">&quot;STORABLE_freeze&quot;</span>, and there may be an
        optional list of references, in the same order you gave them at
        serialization time, pointing to the deserialized objects (which have
        been processed courtesy of the Storable engine).</p>
    <p class="Pp">When the Storable engine does not find any
        <span class="Li">&quot;STORABLE_thaw&quot;</span> hook routine, it tries
        to load the class by requiring the package dynamically (using the
        blessed package name), and then re-attempts the lookup. If at that time
        the hook cannot be located, the engine croaks. Note that this mechanism
        will fail if you define several classes in the same file, but perlmod
        warned you.</p>
    <p class="Pp">It is up to you to use this information to populate <i>obj</i>
        the way you want.</p>
    <p class="Pp">Returned value: none.</p>
  </dd>
  <dt>&quot;STORABLE_attach&quot; <i>class</i>, <i>cloning</i>,
    <i>serialized</i></dt>
  <dd>While <span class="Li">&quot;STORABLE_freeze&quot;</span> and
      <span class="Li">&quot;STORABLE_thaw&quot;</span> are useful for classes
      where each instance is independent, this mechanism has difficulty (or is
      incompatible) with objects that exist as common process-level or
      system-level resources, such as singleton objects, database pools, caches
      or memoized objects.
    <p class="Pp">The alternative
        <span class="Li">&quot;STORABLE_attach&quot;</span> method provides a
        solution for these shared objects. Instead of
        <span class="Li">&quot;STORABLE_freeze&quot;</span> --&gt;
        <span class="Li">&quot;STORABLE_thaw&quot;</span>, you implement
        <span class="Li">&quot;STORABLE_freeze&quot;</span> --&gt;
        <span class="Li">&quot;STORABLE_attach&quot;</span> instead.</p>
    <p class="Pp">Arguments: <i>class</i> is the class we are attaching to,
        <i>cloning</i> is a flag indicating whether we're in a <b>dclone()</b>
        or a regular de-serialization via <b>thaw()</b>, and <i>serialized</i>
        is the stored string for the resource object.</p>
    <p class="Pp">Because these resource objects are considered to be owned by
        the entire process/system, and not the &quot;property&quot; of whatever
        is being serialized, no references underneath the object should be
        included in the serialized string. Thus, in any class that implements
        <span class="Li">&quot;STORABLE_attach&quot;</span>, the
        <span class="Li">&quot;STORABLE_freeze&quot;</span> method cannot return
        any references, and <span class="Li">&quot;Storable&quot;</span> will
        throw an error if <span class="Li">&quot;STORABLE_freeze&quot;</span>
        tries to return references.</p>
    <p class="Pp">All information required to &quot;attach&quot; back to the
        shared resource object <b>must</b> be contained <b>only</b> in the
        <span class="Li">&quot;STORABLE_freeze&quot;</span> return string.
        Otherwise, <span class="Li">&quot;STORABLE_freeze&quot;</span> behaves
        as normal for <span class="Li">&quot;STORABLE_attach&quot;</span>
        classes.</p>
    <p class="Pp">Because <span class="Li">&quot;STORABLE_attach&quot;</span> is
        passed the class (rather than an object), it also returns the object
        directly, rather than modifying the passed object.</p>
    <p class="Pp">Returned value: object of type
        <span class="Li">&quot;class&quot;</span></p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Predicates"><a class="permalink" href="#Predicates">Predicates</a></h2>
<p class="Pp">Predicates are not exportable. They must be called by explicitly
    prefixing them with the Storable package name.</p>
<dl class="Bl-tag">
  <dt>&quot;Storable::last_op_in_netorder&quot;</dt>
  <dd>The <span class="Li">&quot;Storable::last_op_in_netorder()&quot;</span>
      predicate will tell you whether network order was used in the last store
      or retrieve operation. If you don't know how to use this, just forget
      about it.</dd>
  <dt>&quot;Storable::is_storing&quot;</dt>
  <dd>Returns true if within a store operation (via STORABLE_freeze hook).</dd>
  <dt>&quot;Storable::is_retrieving&quot;</dt>
  <dd>Returns true if within a retrieve operation (via STORABLE_thaw hook).</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Recursion"><a class="permalink" href="#Recursion">Recursion</a></h2>
<p class="Pp">With hooks comes the ability to recurse back to the Storable
    engine. Indeed, hooks are regular Perl code, and Storable is convenient when
    it comes to serializing and deserializing things, so why not use it to
    handle the serialization string?</p>
<p class="Pp">There are a few things you need to know, however:</p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>From Storable 3.05 to 3.13 we probed for the stack recursion limit for
      references, arrays and hashes to a maximal depth of ~1200-35000, otherwise
      we might fall into a stack-overflow. On JSON::XS this limit is 512 btw.
      With references not immediately referencing each other there's no such
      limit yet, so you might fall into such a stack-overflow segfault.
    <p class="Pp">This probing and the checks we performed have some
        limitations:</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>the stack size at build time might be different at run time, eg. the stack
      size may have been modified with <b>ulimit</b>(1). If it's larger at run
      time Storable may fail the <b>freeze()</b> or <b>thaw()</b> unnecessarily.
      If it's larger at build time Storable may segmentation fault when
      processing a deep structure at run time.</li>
  <li>the stack size might be different in a thread.</li>
  <li>array and hash recursion limits are checked separately against the same
      recursion depth, a frozen structure with a large sequence of nested arrays
      within many nested hashes may exhaust the processor stack without
      triggering Storable's recursion protection.</li>
</ul>
</div>
<div class="Bd-indent">
<p class="Pp">So these now have simple defaults rather than probing at
    build-time.</p>
<p class="Pp">You can control the maximum array and hash recursion depths by
    modifying <span class="Li">$Storable::recursion_limit</span> and
    <span class="Li">$Storable::recursion_limit_hash</span> respectively. Either
    can be set to <span class="Li">&quot;-1&quot;</span> to prevent any depth
    checks, though this isn't recommended.</p>
</div>
<ul class="Bl-bullet">
  <li>You can create endless loops if the things you serialize via
      <b>freeze()</b> (for instance) point back to the object we're trying to
      serialize in the hook.</li>
  <li>Shared references among objects will not stay shared: if we're serializing
      the list of object [A, C] where both object A and C refer to the SAME
      object B, and if there is a serializing hook in A that says freeze(B),
      then when deserializing, we'll get [A', C'] where A' refers to B', but C'
      refers to D, a deep clone of B'. The topology was not preserved.</li>
  <li>The maximal stack recursion limit for your system is returned by
      <span class="Li">&quot;stack_depth()&quot;</span> and
      <span class="Li">&quot;stack_depth_hash()&quot;</span>. The hash limit is
      usually half the size of the array and ref limit, as the Perl hash API is
      not optimal.</li>
</ul>
<p class="Pp">That's why <span class="Li">&quot;STORABLE_freeze&quot;</span>
    lets you provide a list of references to serialize. The engine guarantees
    that those will be serialized in the same context as the other objects, and
    therefore that shared objects will stay shared.</p>
<p class="Pp">In the above [A, C] example, the
    <span class="Li">&quot;STORABLE_freeze&quot;</span> hook could return:</p>
<p class="Pp"></p>
<pre>        (&quot;something&quot;, $self-&gt;{B})
</pre>
<p class="Pp">and the B part would be serialized by the engine. In
    <span class="Li">&quot;STORABLE_thaw&quot;</span>, you would get back the
    reference to the B' object, deserialized for you.</p>
<p class="Pp">Therefore, recursion should normally be avoided, but is
    nonetheless supported.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Deep_Cloning"><a class="permalink" href="#Deep_Cloning">Deep
  Cloning</a></h2>
<p class="Pp">There is a Clone module available on CPAN which implements deep
    cloning natively, i.e. without freezing to memory and thawing the result. It
    is aimed to replace Storable's <b>dclone()</b> some day. However, it does
    not currently support Storable hooks to redefine the way deep cloning is
    performed.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Storable_magic"><a class="permalink" href="#Storable_magic">Storable
  magic</a></h1>
<p class="Pp">Yes, there's a lot of that :-) But more precisely, in UNIX systems
    there's a utility called <span class="Li">&quot;file&quot;</span>, which
    recognizes data files based on their contents (usually their first few
    bytes). For this to work, a certain file called <i>magic</i> needs to taught
    about the <i>signature</i> of the data. Where that configuration file lives
    depends on the UNIX flavour; often it's something like
    <i>/usr/share/misc/magic</i> or <i>/etc/magic</i>. Your system administrator
    needs to do the updating of the <i>magic</i> file. The necessary signature
    information is output to STDOUT by invoking
    <b>Storable::show_file_magic()</b>. Note that the GNU implementation of the
    <span class="Li">&quot;file&quot;</span> utility, version 3.38 or later, is
    expected to contain support for recognising Storable files out-of-the-box,
    in addition to other kinds of Perl files.</p>
<p class="Pp">You can also use the following functions to extract the file
    header information from Storable images:</p>
<dl class="Bl-tag">
  <dt>$info = Storable::file_magic( $filename )</dt>
  <dd>If the given file is a Storable image return a hash describing it. If the
      file is readable, but not a Storable image return
      <span class="Li">&quot;undef&quot;</span>. If the file does not exist or
      is unreadable then croak.
    <p class="Pp">The hash returned has the following elements:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>&quot;version&quot;</dt>
  <dd>This returns the file format version. It is a string like &quot;2.7&quot;.
    <p class="Pp">Note that this version number is not the same as the version
        number of the Storable module itself. For instance Storable v0.7 create
        files in format v2.0 and Storable v2.15 create files in format v2.7. The
        file format version number only increment when additional features that
        would confuse older versions of the module are added.</p>
    <p class="Pp">Files older than v2.0 will have the one of the version numbers
        &quot;-1&quot;, &quot;0&quot; or &quot;1&quot;. No minor number was used
        at that time.</p>
  </dd>
  <dt>&quot;version_nv&quot;</dt>
  <dd>This returns the file format version as number. It is a string like
      &quot;2.007&quot;. This value is suitable for numeric comparisons.
    <p class="Pp">The constant function
        <span class="Li">&quot;Storable::BIN_VERSION_NV&quot;</span> returns a
        comparable number that represents the highest file version number that
        this version of Storable fully supports (but see discussion of
        <span class="Li">$Storable::accept_future_minor</span> above). The
        constant
        <span class="Li">&quot;Storable::BIN_WRITE_VERSION_NV&quot;</span>
        function returns what file version is written and might be less than
        <span class="Li">&quot;Storable::BIN_VERSION_NV&quot;</span> in some
        configurations.</p>
  </dd>
  <dt>&quot;major&quot;, &quot;minor&quot;</dt>
  <dd>This also returns the file format version. If the version is
      &quot;2.7&quot; then major would be 2 and minor would be 7. The minor
      element is missing for when major is less than 2.</dd>
  <dt>&quot;hdrsize&quot;</dt>
  <dd>The is the number of bytes that the Storable header occupies.</dd>
  <dt>&quot;netorder&quot;</dt>
  <dd>This is TRUE if the image store data in network order. This means that it
      was created with <b>nstore()</b> or similar.</dd>
  <dt>&quot;byteorder&quot;</dt>
  <dd>This is only present when <span class="Li">&quot;netorder&quot;</span> is
      FALSE. It is the <span class="Li">$Config</span>{byteorder} string of the
      perl that created this image. It is a string like &quot;1234&quot; (32 bit
      little endian) or &quot;87654321&quot; (64 bit big endian). This must
      match the current perl for the image to be readable by Storable.</dd>
  <dt>&quot;intsize&quot;, &quot;longsize&quot;, &quot;ptrsize&quot;,
    &quot;nvsize&quot;</dt>
  <dd>These are only present when <span class="Li">&quot;netorder&quot;</span>
      is FALSE. These are the sizes of various C datatypes of the perl that
      created this image. These must match the current perl for the image to be
      readable by Storable.
    <p class="Pp">The <span class="Li">&quot;nvsize&quot;</span> element is only
        present for file format v2.2 and higher.</p>
  </dd>
  <dt>&quot;file&quot;</dt>
  <dd>The name of the file.</dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>$info = Storable::read_magic( $buffer )</dt>
  <dd></dd>
  <dt>$info = Storable::read_magic( $buffer, $must_be_file )</dt>
  <dd>The <span class="Li">$buffer</span> should be a Storable image or the
      first few bytes of it. If <span class="Li">$buffer</span> starts with a
      Storable header, then a hash describing the image is returned, otherwise
      <span class="Li">&quot;undef&quot;</span> is returned.
    <p class="Pp">The hash has the same structure as the one returned by
        <b>Storable::file_magic()</b>. The
        <span class="Li">&quot;file&quot;</span> element is true if the image is
        a file image.</p>
    <p class="Pp">If the <span class="Li">$must_be_file</span> argument is
        provided and is TRUE, then return
        <span class="Li">&quot;undef&quot;</span> unless the image looks like it
        belongs to a file dump.</p>
    <p class="Pp">The maximum size of a Storable header is currently 21 bytes.
        If the provided <span class="Li">$buffer</span> is only the first part
        of a Storable image it should at least be this long to ensure that
        <b>read_magic()</b> will recognize it as such.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">Here are some code samples showing a possible usage of
  Storable:</p>
<p class="Pp"></p>
<pre> use Storable qw(store retrieve freeze thaw dclone);
 %color = ('Blue' =&gt; 0.1, 'Red' =&gt; 0.8, 'Black' =&gt; 0, 'White' =&gt; 1);
 store(\%color, 'mycolors') or die &quot;Can't store %a in mycolors!\n&quot;;
 $colref = retrieve('mycolors');
 die &quot;Unable to retrieve from mycolors!\n&quot; unless defined $colref;
 printf &quot;Blue is still %lf\n&quot;, $colref-&gt;{'Blue'};
 $colref2 = dclone(\%color);
 $str = freeze(\%color);
 printf &quot;Serialization of %%color is %d bytes long.\n&quot;, length($str);
 $colref3 = thaw($str);
</pre>
<p class="Pp">which prints (on my machine):</p>
<p class="Pp"></p>
<pre> Blue is still 0.100000
 Serialization of %color is 102 bytes long.
</pre>
<p class="Pp">Serialization of CODE references and deserialization in a safe
    compartment:</p>
<p class="Pp"></p>
<pre> use Storable qw(freeze thaw);
 use Safe;
 use strict;
 my $safe = new Safe;
        # because of opcodes used in &quot;use strict&quot;:
 $safe-&gt;permit(qw(:default require));
 local $Storable::Deparse = 1;
 local $Storable::Eval = sub { $safe-&gt;reval($_[0]) };
 my $serialized = freeze(sub { 42 });
 my $code = thaw($serialized);
 $code-&gt;() == 42;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SECURITY_WARNING"><a class="permalink" href="#SECURITY_WARNING">SECURITY
  WARNING</a></h1>
<p class="Pp"><b>Do not accept Storable documents from untrusted
  sources!</b></p>
<p class="Pp">Some features of Storable can lead to security vulnerabilities if
    you accept Storable documents from untrusted sources with the default flags.
    Most obviously, the optional (off by default) CODE reference serialization
    feature allows transfer of code to the deserializing process. Furthermore,
    any serialized object will cause Storable to helpfully load the module
    corresponding to the class of the object in the deserializing module. For
    manipulated module names, this can load almost arbitrary code. Finally, the
    deserialized object's destructors will be invoked when the objects get
    destroyed in the deserializing process. Maliciously crafted Storable
    documents may put such objects in the value of a hash key that is overridden
    by another key/value pair in the same hash, thus causing immediate
    destructor execution.</p>
<p class="Pp">To disable blessing objects while thawing/retrieving remove the
    flag <span class="Li">&quot;BLESS_OK&quot;</span> = 2 from
    <span class="Li">$Storable::flags</span> or set the 2nd argument for
    thaw/retrieve to 0.</p>
<p class="Pp">To disable tieing data while thawing/retrieving remove the flag
    <span class="Li">&quot;TIE_OK&quot;</span> = 4 from
    <span class="Li">$Storable::flags</span> or set the 2nd argument for
    thaw/retrieve to 0.</p>
<p class="Pp">With the default setting of
    <span class="Li">$Storable::flags</span> = 6, creating or destroying random
    objects, even renamed objects can be controlled by an attacker. See
    CVE-2015-1592 and its metasploit module.</p>
<p class="Pp">If your application requires accepting data from untrusted
    sources, you are best off with a less powerful and more-likely safe
    serialization format and implementation. If your data is sufficiently
    simple, Cpanel::JSON::XS, Data::MessagePack or Serial are the best choices
    and offers maximum interoperability, but note that Serial is unsafe by
    default.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="WARNING"><a class="permalink" href="#WARNING">WARNING</a></h1>
<p class="Pp">If you're using references as keys within your hash tables, you're
    bound to be disappointed when retrieving your data. Indeed, Perl stringifies
    references used as hash table keys. If you later wish to access the items
    via another reference stringification (i.e. using the same reference that
    was used for the key originally to record the value into the hash table), it
    will work because both references stringify to the same string.</p>
<p class="Pp">It won't work across a sequence of
    <span class="Li">&quot;store&quot;</span> and
    <span class="Li">&quot;retrieve&quot;</span> operations, however, because
    the addresses in the retrieved objects, which are part of the stringified
    references, will probably differ from the original addresses. The topology
    of your structure is preserved, but not hidden semantics like those.</p>
<p class="Pp">On platforms where it matters, be sure to call
    <span class="Li">&quot;binmode()&quot;</span> on the descriptors that you
    pass to Storable functions.</p>
<p class="Pp">Storing data canonically that contains large hashes can be
    significantly slower than storing the same data normally, as temporary
    arrays to hold the keys for each hash have to be allocated, populated,
    sorted and freed. Some tests have shown a halving of the speed of storing --
    the exact penalty will depend on the complexity of your data. There is no
    slowdown on retrieval.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="REGULAR_EXPRESSIONS"><a class="permalink" href="#REGULAR_EXPRESSIONS">REGULAR
  EXPRESSIONS</a></h1>
<p class="Pp">Storable now has experimental support for storing regular
    expressions, but there are significant limitations:</p>
<ul class="Bl-bullet">
  <li>perl 5.8 or later is required.</li>
  <li>regular expressions with code blocks, ie <span class="Li">&quot;/(?{ ...
      })/&quot;</span> or <span class="Li">&quot;/(??{</span>
      <span class="Li">... })/&quot;</span> will throw an exception when
    thawed.</li>
  <li>regular expression syntax and flags have changed over the history of perl,
      so a regular expression that you freeze in one version of perl may fail to
      thaw or behave differently in another version of perl.</li>
  <li>depending on the version of perl, regular expressions can change in
      behaviour depending on the context, but later perls will bake that
      behaviour into the regexp.</li>
</ul>
<p class="Pp">Storable will throw an exception if a frozen regular expression
    cannot be thawed.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">You can't store GLOB, FORMLINE, etc.... If you can define
    semantics for those operations, feel free to enhance Storable so that it can
    deal with them.</p>
<p class="Pp">The store functions will <span class="Li">&quot;croak&quot;</span>
    if they run into such references unless you set
    <span class="Li">$Storable::forgive_me</span> to some
    <span class="Li">&quot;TRUE&quot;</span> value. In that case, the fatal
    message is converted to a warning and some meaningless string is stored
    instead.</p>
<p class="Pp">Setting <span class="Li">$Storable::canonical</span> may not yield
    frozen strings that compare equal due to possible stringification of
    numbers. When the string version of a scalar exists, it is the form stored;
    therefore, if you happen to use your numbers as strings between two freezing
    operations on the same data structures, you will get different results.</p>
<p class="Pp">When storing doubles in network order, their value is stored as
    text. However, you should also not expect non-numeric floating-point values
    such as infinity and &quot;not a number&quot; to pass successfully through a
    <b>nstore()</b>/<b>retrieve()</b> pair.</p>
<p class="Pp">As Storable neither knows nor cares about character sets (although
    it does know that characters may be more than eight bits wide), any
    difference in the interpretation of character codes between a host and a
    target system is your problem. In particular, if host and target use
    different code points to represent the characters used in the text
    representation of floating-point numbers, you will not be able be able to
    exchange floating-point data, even with <b>nstore()</b>.</p>
<p class="Pp"><span class="Li">&quot;Storable::drop_utf8&quot;</span> is a blunt
    tool. There is no facility either to return <b>all</b> strings as utf8
    sequences, or to attempt to convert utf8 data back to 8 bit and
    <span class="Li">&quot;croak()&quot;</span> if the conversion fails.</p>
<p class="Pp">Prior to Storable 2.01, no distinction was made between signed and
    unsigned integers on storing. By default Storable prefers to store a scalars
    string representation (if it has one) so this would only cause problems when
    storing large unsigned integers that had never been converted to string or
    floating point. In other words values that had been generated by integer
    operations such as logic ops and then not used in any string or arithmetic
    context before storing.</p>
<section class="Ss">
<h2 class="Ss" id="64_bit_data_in_perl_5.6.0_and_5.6.1"><a class="permalink" href="#64_bit_data_in_perl_5.6.0_and_5.6.1">64
  bit data in perl 5.6.0 and 5.6.1</a></h2>
<p class="Pp">This section only applies to you if you have existing data written
    out by Storable 2.02 or earlier on perl 5.6.0 or 5.6.1 on Unix or Linux
    which has been configured with 64 bit integer support (not the default) If
    you got a precompiled perl, rather than running Configure to build your own
    perl from source, then it almost certainly does not affect you, and you can
    stop reading now (unless you're curious). If you're using perl on Windows it
    does not affect you.</p>
<p class="Pp">Storable writes a file header which contains the sizes of various
    C language types for the C compiler that built Storable (when not writing in
    network order), and will refuse to load files written by a Storable not on
    the same (or compatible) architecture. This check and a check on machine
    byteorder is needed because the size of various fields in the file are given
    by the sizes of the C language types, and so files written on different
    architectures are incompatible. This is done for increased speed. (When
    writing in network order, all fields are written out as standard lengths,
    which allows full interworking, but takes longer to read and write)</p>
<p class="Pp">Perl 5.6.x introduced the ability to optional configure the perl
    interpreter to use C's <span class="Li">&quot;long long&quot;</span> type to
    allow scalars to store 64 bit integers on 32 bit systems. However, due to
    the way the Perl configuration system generated the C configuration files on
    non-Windows platforms, and the way Storable generates its header, nothing in
    the Storable file header reflected whether the perl writing was using 32 or
    64 bit integers, despite the fact that Storable was storing some data
    differently in the file. Hence Storable running on perl with 64 bit integers
    will read the header from a file written by a 32 bit perl, not realise that
    the data is actually in a subtly incompatible format, and then go horribly
    wrong (possibly crashing) if it encountered a stored integer. This is a
    design failure.</p>
<p class="Pp">Storable has now been changed to write out and read in a file
    header with information about the size of integers. It's impossible to
    detect whether an old file being read in was written with 32 or 64 bit
    integers (they have the same header) so it's impossible to automatically
    switch to a correct backwards compatibility mode. Hence this Storable
    defaults to the new, correct behaviour.</p>
<p class="Pp">What this means is that if you have data written by Storable 1.x
    running on perl 5.6.0 or 5.6.1 configured with 64 bit integers on Unix or
    Linux then by default this Storable will refuse to read it, giving the error
    <i>Byte order is not compatible</i>. If you have such data then you should
    set <span class="Li">$Storable::interwork_56_64bit</span> to a true value to
    make this Storable read and write files with the old header. You should also
    migrate your data, or any older perl you are communicating with, to this
    current version of Storable.</p>
<p class="Pp">If you don't have data written with specific configuration of perl
    described above, then you do not and should not do anything. Don't set the
    flag - not only will Storable on an identically configured perl refuse to
    load them, but Storable a differently configured perl will load them
    believing them to be correct for it, and then may well fail or crash part
    way through reading them.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CREDITS"><a class="permalink" href="#CREDITS">CREDITS</a></h1>
<p class="Pp">Thank you to (in chronological order):</p>
<p class="Pp"></p>
<pre>        Jarkko Hietaniemi &lt;jhi@iki.fi&gt;
        Ulrich Pfeifer &lt;pfeifer@charly.informatik.uni-dortmund.de&gt;
        Benjamin A. Holzman &lt;bholzman@earthlink.net&gt;
        Andrew Ford &lt;A.Ford@ford-mason.co.uk&gt;
        Gisle Aas &lt;gisle@aas.no&gt;
        Jeff Gresham &lt;gresham_jeffrey@jpmorgan.com&gt;
        Murray Nesbitt &lt;murray@activestate.com&gt;
        Marc Lehmann &lt;pcg@opengroup.org&gt;
        Justin Banks &lt;justinb@wamnet.com&gt;
        Jarkko Hietaniemi &lt;jhi@iki.fi&gt; (AGAIN, as perl 5.7.0 Pumpkin!)
        Salvador Ortiz Garcia &lt;sog@msg.com.mx&gt;
        Dominic Dunlop &lt;domo@computer.org&gt;
        Erik Haugan &lt;erik@solbors.no&gt;
        Benjamin A. Holzman &lt;ben.holzman@grantstreet.com&gt;
        Reini Urban &lt;rurban@cpan.org&gt;
        Todd Rinaldo &lt;toddr@cpanel.net&gt;
        Aaron Crane &lt;arc@cpan.org&gt;
</pre>
<p class="Pp">for their bug reports, suggestions and contributions.</p>
<p class="Pp">Benjamin Holzman contributed the tied variable support, Andrew
    Ford contributed the canonical order for hashes, and Gisle Aas fixed a few
    misunderstandings of mine regarding the perl internals, and optimized the
    emission of &quot;tags&quot; in the output streams by simply counting the
    objects instead of tagging them (leading to a binary incompatibility for the
    Storable image starting at version 0.6--older images are, of course, still
    properly understood). Murray Nesbitt made Storable thread-safe. Marc Lehmann
    added overloading and references to tied items support. Benjamin Holzman
    added a performance improvement for overloaded classes; thanks to Grant
    Street Group for footing the bill. Reini Urban took over maintainance from
    p5p, and added security fixes and huge object support.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Storable was written by Raphael Manfredi
    <i>&lt;Raphael_Manfredi@pobox.com&gt;</i> Maintenance is now done by cperl
    &lt;http://perl11.org/cperl&gt;</p>
<p class="Pp">Please e-mail us with problems, bug fixes, comments and
    complaints, although if you have compliments you should send them to
    Raphael. Please don't e-mail Raphael with problems, as he no longer works on
    Storable, and your message will be delayed while he forwards it to us.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Clone.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2024-02-10</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

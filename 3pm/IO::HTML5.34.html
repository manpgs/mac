<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>IO::HTML(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">IO::HTML(3)</td>
    <td class="head-vol"><a href=".">User Contributed Perl Documentation</a></td>
    <td class="head-rtitle">IO::HTML(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">IO::HTML - Open an HTML file with automatic charset detection</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">This document describes version 1.001 of IO::HTML, released June
    28, 2014.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  use IO::HTML;                 # exports html_file by default
  use HTML::TreeBuilder;
  my $tree = HTML::TreeBuilder-&gt;new_from_file(
               html_file('foo.html')
             );
  # Alternative interface:
  open(my $in, '&lt;:raw', 'bar.html');
  my $encoding = IO::HTML::sniff_encoding($in, 'bar.html');
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">IO::HTML provides an easy way to open a file containing HTML while
    automatically determining its encoding. It uses the HTML5 encoding sniffing
    algorithm specified in section 8.2.2.2 of the draft standard.</p>
<p class="Pp">The algorithm as implemented here is:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>If the file begins with a byte order mark indicating UTF-16LE, UTF-16BE,
      or UTF-8, then that is the encoding.</dd>
  <dt>2.</dt>
  <dd>If the first 1024 bytes of the file contain a
      <span class="Li">&quot;&lt;meta&gt;&quot;</span> tag that indicates the
      charset, and Encode recognizes the specified charset name, then that is
      the encoding. (This portion of the algorithm is implemented by
      <span class="Li">&quot;find_charset_in&quot;</span>.)
    <p class="Pp">The <span class="Li">&quot;&lt;meta&gt;&quot;</span> tag can
        be in one of two formats:</p>
    <p class="Pp"></p>
    <pre>  &lt;meta charset=&quot;...&quot;&gt;
  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;...charset=...&quot;&gt;
    </pre>
    <p class="Pp">The search is case-insensitive, and the order of attributes
        within the tag is irrelevant. Any additional attributes of the tag are
        ignored. The first matching tag with a recognized encoding ends the
        search.</p>
  </dd>
  <dt>3.</dt>
  <dd>If the first 1024 bytes of the file are valid UTF-8 (with at least 1
      non-ASCII character), then the encoding is UTF-8.</dd>
  <dt>4.</dt>
  <dd>If all else fails, use the default character encoding. The HTML5 standard
      suggests the default encoding should be locale dependent, but currently it
      is always <span class="Li">&quot;cp1252&quot;</span> unless you set
      <span class="Li">$IO::HTML::default_encoding</span> to a different value.
      Note: <span class="Li">&quot;sniff_encoding&quot;</span> does not apply
      this step; only <span class="Li">&quot;html_file&quot;</span> does
    that.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SUBROUTINES"><a class="permalink" href="#SUBROUTINES">SUBROUTINES</a></h1>
<section class="Ss">
<h2 class="Ss" id="html_file"><a class="permalink" href="#html_file">html_file</a></h2>
<pre>  $filehandle = html_file($filename, \%options);
</pre>
<p class="Pp">This function (exported by default) is the primary entry point. It
    opens the file specified by <span class="Li">$filename</span> for reading,
    uses <span class="Li">&quot;sniff_encoding&quot;</span> to find a suitable
    encoding layer, and applies it. It also applies the
    <span class="Li">&quot;:crlf&quot;</span> layer. If the file begins with a
    BOM, the filehandle is positioned just after the BOM.</p>
<p class="Pp">The optional second argument is a hashref containing options. The
    possible keys are described under
    <span class="Li">&quot;find_charset_in&quot;</span>.</p>
<p class="Pp">If <span class="Li">&quot;sniff_encoding&quot;</span> is unable to
    determine the encoding, it defaults to
    <span class="Li">$IO::HTML::default_encoding</span>, which is set to
    <span class="Li">&quot;cp1252&quot;</span> (a.k.a. Windows-1252) by default.
    According to the standard, the default should be locale dependent, but that
    is not currently implemented.</p>
<p class="Pp">It dies if the file cannot be opened.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="html_file_and_encoding"><a class="permalink" href="#html_file_and_encoding">html_file_and_encoding</a></h2>
<pre>  ($filehandle, $encoding, $bom)
    = html_file_and_encoding($filename, \%options);
</pre>
<p class="Pp">This function (exported only by request) is just like
    <span class="Li">&quot;html_file&quot;</span>, but returns more information.
    In addition to the filehandle, it returns the name of the encoding used, and
    a flag indicating whether a byte order mark was found (if
    <span class="Li">$bom</span> is true, the file began with a BOM). This may
    be useful if you want to write the file out again (especially in conjunction
    with the <span class="Li">&quot;html_outfile&quot;</span> function).</p>
<p class="Pp">The optional second argument is a hashref containing options. The
    possible keys are described under
    <span class="Li">&quot;find_charset_in&quot;</span>.</p>
<p class="Pp">It dies if the file cannot be opened. The result of calling it in
    scalar context is undefined.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="html_outfile"><a class="permalink" href="#html_outfile">html_outfile</a></h2>
<pre>  $filehandle = html_outfile($filename, $encoding, $bom);
</pre>
<p class="Pp">This function (exported only by request) opens
    <span class="Li">$filename</span> for output using
    <span class="Li">$encoding</span>, and writes a BOM to it if
    <span class="Li">$bom</span> is true. If <span class="Li">$encoding</span>
    is <span class="Li">&quot;undef&quot;</span>, it defaults to
    <span class="Li">$IO::HTML::default_encoding</span>.
    <span class="Li">$encoding</span> may be either an encoding name or an
    Encode::Encoding object.</p>
<p class="Pp">It dies if the file cannot be opened.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="sniff_encoding"><a class="permalink" href="#sniff_encoding">sniff_encoding</a></h2>
<pre>  ($encoding, $bom) = sniff_encoding($filehandle, $filename, \%options);
</pre>
<p class="Pp">This function (exported only by request) runs the HTML5 encoding
    sniffing algorithm on <span class="Li">$filehandle</span> (which must be
    seekable, and should have been opened in
    <span class="Li">&quot;:raw&quot;</span> mode).
    <span class="Li">$filename</span> is used only for error messages (if
    there's a problem using the filehandle), and defaults to &quot;file&quot; if
    omitted. The optional third argument is a hashref containing options. The
    possible keys are described under
    <span class="Li">&quot;find_charset_in&quot;</span>.</p>
<p class="Pp">It returns Perl's canonical name for the encoding, which is not
    necessarily the same as the MIME or IANA charset name. It returns
    <span class="Li">&quot;undef&quot;</span> if the encoding cannot be
    determined. <span class="Li">$bom</span> is true if the file began with a
    byte order mark. In scalar context, it returns only
    <span class="Li">$encoding</span>.</p>
<p class="Pp">The filehandle's position is restored to its original position
    (normally the beginning of the file) unless <span class="Li">$bom</span> is
    true. In that case, the position is immediately after the BOM.</p>
<p class="Pp">Tip: If you want to run
    <span class="Li">&quot;sniff_encoding&quot;</span> on a file you've already
    loaded into a string, open an in-memory file on the string, and pass that
    handle:</p>
<p class="Pp"></p>
<pre>  ($encoding, $bom) = do {
    open(my $fh, '&lt;', \$string);  sniff_encoding($fh)
  };
</pre>
<p class="Pp">(This only makes sense if <span class="Li">$string</span> contains
    bytes, not characters.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="find_charset_in"><a class="permalink" href="#find_charset_in">find_charset_in</a></h2>
<pre>  $encoding = find_charset_in($string_containing_HTML, \%options);
</pre>
<p class="Pp">This function (exported only by request) looks for charset
    information in a <span class="Li">&quot;&lt;meta&gt;&quot;</span> tag in a
    possibly incomplete HTML document using the &quot;two step&quot; algorithm
    specified by HTML5. It does not look for a BOM. Only the first 1024 bytes of
    the string are checked.</p>
<p class="Pp">It returns Perl's canonical name for the encoding, which is not
    necessarily the same as the MIME or IANA charset name. It returns
    <span class="Li">&quot;undef&quot;</span> if no charset is specified or if
    the specified charset is not recognized by the Encode module.</p>
<p class="Pp">The optional second argument is a hashref containing options. The
    following keys are recognized:</p>
<dl class="Bl-tag">
  <dt>&quot;encoding&quot;</dt>
  <dd>If true, return the Encode::Encoding object instead of its name. Defaults
      to false.</dd>
  <dt>&quot;need_pragma&quot;</dt>
  <dd>If true (the default), follow the HTML5 spec and examine the
      <span class="Li">&quot;content&quot;</span> attribute only of
      <span class="Li">&quot;&lt;meta
      http-equiv=&quot;Content-Type&quot;&quot;</span>. If set to 0, relax the
      HTML5 spec, and look for &quot;charset=&quot; in the
      <span class="Li">&quot;content&quot;</span> attribute of <i>every</i> meta
      tag.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTS"><a class="permalink" href="#EXPORTS">EXPORTS</a></h1>
<p class="Pp">By default, only <span class="Li">&quot;html_file&quot;</span> is
    exported. Other functions may be exported on request.</p>
<p class="Pp">For people who prefer not to export functions, all functions
    beginning with <span class="Li">&quot;html_&quot;</span> have an alias
    without that prefix (e.g. you can call
    <span class="Li">&quot;IO::HTML::file(...)&quot;</span> instead of
    <span class="Li">&quot;IO::HTML::html_file(...)&quot;</span>. These aliases
    are not exportable.</p>
<p class="Pp">The following export tags are available:</p>
<dl class="Bl-tag">
  <dt>&quot;:all&quot;</dt>
  <dd>All exportable functions.</dd>
  <dt>&quot;:rw&quot;</dt>
  <dd><span class="Li">&quot;html_file&quot;</span>,
      <span class="Li">&quot;html_file_and_encoding&quot;</span>,
      <span class="Li">&quot;html_outfile&quot;</span>.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">The HTML5 specification, section 8.2.2.2 Determining the character
    encoding:
    &lt;http://www.w3.org/TR/html5/syntax.html#determining-the-character-encoding&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DIAGNOSTICS"><a class="permalink" href="#DIAGNOSTICS">DIAGNOSTICS</a></h1>
<dl class="Bl-tag">
  <dt>&quot;Could not read %s: %s&quot;</dt>
  <dd>The specified file could not be read from for the reason specified by
      <span class="Li">$!</span>.</dd>
  <dt>&quot;Could not seek %s: %s&quot;</dt>
  <dd>The specified file could not be rewound for the reason specified by
      <span class="Li">$!</span>.</dd>
  <dt>&quot;Failed to open %s: %s&quot;</dt>
  <dd>The specified file could not be opened for reading for the reason
      specified by <span class="Li">$!</span>.</dd>
  <dt>&quot;No default encoding specified&quot;</dt>
  <dd>The <span class="Li">&quot;sniff_encoding&quot;</span> algorithm didn't
      find an encoding to use, and you set
      <span class="Li">$IO::HTML::default_encoding</span> to
      <span class="Li">&quot;undef&quot;</span>.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="CONFIGURATION_AND_ENVIRONMENT"><a class="permalink" href="#CONFIGURATION_AND_ENVIRONMENT">CONFIGURATION
  AND ENVIRONMENT</a></h1>
<p class="Pp">IO::HTML requires no configuration files or environment
  variables.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DEPENDENCIES"><a class="permalink" href="#DEPENDENCIES">DEPENDENCIES</a></h1>
<p class="Pp">IO::HTML has no non-core dependencies for Perl 5.8.7+. With
    earlier versions of Perl 5.8, you need to upgrade Encode to at least version
    2.10, and you may need to upgrade Exporter to at least version 5.57.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="INCOMPATIBILITIES"><a class="permalink" href="#INCOMPATIBILITIES">INCOMPATIBILITIES</a></h1>
<p class="Pp">None reported.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS_AND_LIMITATIONS"><a class="permalink" href="#BUGS_AND_LIMITATIONS">BUGS
  AND LIMITATIONS</a></h1>
<p class="Pp">No bugs have been reported.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Christopher J. Madsen
    <span class="Li">&quot;&lt;perl&#x00A0;AT&#x00A0;cjmweb.net&gt;&quot;</span></p>
<p class="Pp">Please report any bugs or feature requests to
    <span class="Li">&quot;&lt;bug-IO-HTML&#x00A0;AT&#x00A0;rt.cpan.org&gt;&quot;</span>
    or through the web interface at
    &lt;http://rt.cpan.org/Public/Bug/Report.html?Queue=IO-HTML&gt;.</p>
<p class="Pp">You can follow or contribute to IO-HTML's development at
    &lt;https://github.com/madsen/io-html&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2014 by Christopher J. Madsen.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DISCLAIMER_OF_WARRANTY"><a class="permalink" href="#DISCLAIMER_OF_WARRANTY">DISCLAIMER
  OF WARRANTY</a></h1>
<p class="Pp">BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO
    WARRANTY FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT
    WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
    PROVIDE THE SOFTWARE &quot;AS IS&quot; WITHOUT WARRANTY OF ANY KIND, EITHER
    EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
    OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS
    TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH YOU. SHOULD THE
    SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
    REPAIR, OR CORRECTION.</p>
<p class="Pp">IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
    WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
    REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENSE, BE LIABLE TO
    YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL, OR
    CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
    SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED
    INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE
    SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF SUCH HOLDER OR OTHER
    PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-06-28</td>
    <td class="foot-os"><a href="..">perl v5.34.0</a></td>
  </tr>
</table>
</body>
</html>

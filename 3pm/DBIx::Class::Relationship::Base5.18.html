<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>DBIx::Class::Relationship::Base(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBIx::Class::Relationship::Base(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBIx::Class::Relationship::Base(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">DBIx::Class::Relationship::Base - Inter-table relationships</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
  __PACKAGE__-&gt;add_relationship(
    spiders =&gt; 'My::DB::Result::Creatures',
    sub {
      my $args = shift;
      return {
        &quot;$args-&gt;{foreign_alias}.id&quot;   =&gt; { -ident =&gt; &quot;$args-&gt;{self_alias}.id&quot; },
        &quot;$args-&gt;{foreign_alias}.type&quot; =&gt; 'arachnid'
      };
    },
  );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This class provides methods to describe the relationships between
    the tables in your database model. These are the &quot;bare bones&quot;
    relationships methods, for predefined ones, look in
    DBIx::Class::Relationship.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="add_relationship"><a class="permalink" href="#add_relationship">add_relationship</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:"><a class="permalink" href="#Arguments:">Arguments:
    'relname', 'Foreign::Class', $condition, $attrs</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  __PACKAGE__-&gt;add_relationship('relname',
                                'Foreign::Class',
                                $condition, $attrs);
</pre>
<p class="Pp">Create a custom relationship between one result source and another
    source, indicated by its class name.</p>
<p class="Pp"><i>condition</i></p>
<p class="Pp">The condition argument describes the
    <span class="Li">&quot;ON&quot;</span> clause of the
    <span class="Li">&quot;JOIN&quot;</span> expression used to connect the two
    sources when creating SQL queries.</p>
<p class="Pp">Simple equality</p>
<p class="Pp">To create simple equality joins, supply a hashref containing the
    remote table column name as the key(s) prefixed by
    <span class="Li">'foreign.'</span>, and the corresponding local table column
    name as the value(s) prefixed by <span class="Li">'self.'</span>. Both
    <span class="Li">&quot;foreign&quot;</span> and
    <span class="Li">&quot;self&quot;</span> are pseudo aliases and must be
    entered literally. They will be replaced with the actual correct table alias
    when the SQL is produced.</p>
<p class="Pp">For example given:</p>
<p class="Pp"></p>
<pre>
  My::Schema::Author-&gt;has_many(
    books =&gt; 'My::Schema::Book',
    { 'foreign.author_id' =&gt; 'self.id' }
  );
</pre>
<p class="Pp">A query like:</p>
<p class="Pp"></p>
<pre>
  $author_rs-&gt;search_related('books')-&gt;next
</pre>
<p class="Pp">will result in the following
    <span class="Li">&quot;JOIN&quot;</span> clause:</p>
<p class="Pp"></p>
<pre>
  ... FROM author me LEFT JOIN book books ON books.author_id = me.id ...
</pre>
<p class="Pp">This describes a relationship between the
    <span class="Li">&quot;Author&quot;</span> table and the
    <span class="Li">&quot;Book&quot;</span> table where the
    <span class="Li">&quot;Book&quot;</span> table has a column
    <span class="Li">&quot;author_id&quot;</span> containing the ID value of the
    <span class="Li">&quot;Author&quot;</span>.</p>
<p class="Pp">Similarly:</p>
<p class="Pp"></p>
<pre>
  My::Schema::Book-&gt;has_many(
    editions =&gt; 'My::Schema::Edition',
    {
      'foreign.publisher_id' =&gt; 'self.publisher_id',
      'foreign.type_id'      =&gt; 'self.type_id',
    }
  );

  ...

  $book_rs-&gt;search_related('editions')-&gt;next
</pre>
<p class="Pp">will result in the <span class="Li">&quot;JOIN&quot;</span>
    clause:</p>
<p class="Pp"></p>
<pre>
  ... FROM book me
      LEFT JOIN edition editions ON
           editions.publisher_id = me.publisher_id
       AND editions.type_id = me.type_id ...
</pre>
<p class="Pp">This describes the relationship from
    <span class="Li">&quot;Book&quot;</span> to
    <span class="Li">&quot;Edition&quot;</span>, where the
    <span class="Li">&quot;Edition&quot;</span> table refers to a publisher and
    a type (e.g. &quot;paperback&quot;):</p>
<p class="Pp">Multiple groups of simple equality conditions</p>
<p class="Pp">As is the default in SQL::Abstract, the key-value pairs will be
    <span class="Li">&quot;AND&quot;</span>ed in the resulting
    <span class="Li">&quot;JOIN&quot;</span> clause. An
    <span class="Li">&quot;OR&quot;</span> can be achieved with an arrayref. For
    example a condition like:</p>
<p class="Pp"></p>
<pre>
  My::Schema::Item-&gt;has_many(
    related_item_links =&gt; My::Schema::Item::Links,
    [
      { 'foreign.left_itemid'  =&gt; 'self.id' },
      { 'foreign.right_itemid' =&gt; 'self.id' },
    ],
  );
</pre>
<p class="Pp">will translate to the following
    <span class="Li">&quot;JOIN&quot;</span> clause:</p>
<p class="Pp"></p>
<pre>
 ... FROM item me JOIN item_relations related_item_links ON
         related_item_links.left_itemid = me.id
      OR related_item_links.right_itemid = me.id ...
</pre>
<p class="Pp">This describes the relationship from
    <span class="Li">&quot;Item&quot;</span> to
    <span class="Li">&quot;Item::Links&quot;</span>, where
    <span class="Li">&quot;Item::Links&quot;</span> is a many-to-many linking
    table, linking items back to themselves in a peer fashion (without a
    &quot;parent-child&quot; designation)</p>
<p class="Pp">Custom join conditions</p>
<p class="Pp"></p>
<pre>
  NOTE: The custom join condition specification mechanism is capable of
  generating JOIN clauses of virtually unlimited complexity. This may limit
  your ability to traverse some of the more involved relationship chains the
  way you expect, *and* may bring your RDBMS to its knees. Exercise care
  when declaring relationships as described here.
</pre>
<p class="Pp">To specify joins which describe more than a simple equality of
    column values, the custom join condition coderef syntax can be used. For
    example:</p>
<p class="Pp"></p>
<pre>
  My::Schema::Artist-&gt;has_many(
    cds_80s =&gt; 'My::Schema::CD',
    sub {
      my $args = shift;

      return {
        &quot;$args-&gt;{foreign_alias}.artist&quot; =&gt; { -ident =&gt; &quot;$args-&gt;{self_alias}.artistid&quot; },
        &quot;$args-&gt;{foreign_alias}.year&quot;   =&gt; { '&gt;', &quot;1979&quot;, '&lt;', &quot;1990&quot; },
      };
    }
  );

  ...

  $artist_rs-&gt;search_related('cds_80s')-&gt;next;
</pre>
<p class="Pp">will result in the <span class="Li">&quot;JOIN&quot;</span>
    clause:</p>
<p class="Pp"></p>
<pre>
  ... FROM artist me LEFT JOIN cd cds_80s ON
        cds_80s.artist = me.artistid
    AND cds_80s.year &lt; ?
    AND cds_80s.year &gt; ?
</pre>
<p class="Pp">with the bind values:</p>
<p class="Pp"></p>
<pre>
   '1990', '1979'
</pre>
<p class="Pp"><span class="Li">&quot;$args-&gt;{foreign_alias}&quot;</span> and
    <span class="Li">&quot;$args-&gt;{self_alias}&quot;</span> are supplied the
    same values that would be otherwise substituted for
    <span class="Li">&quot;foreign&quot;</span> and
    <span class="Li">&quot;self&quot;</span> in the simple hashref syntax
  case.</p>
<p class="Pp">The coderef is expected to return a valid SQL::Abstract
    query-structure, just like what one would supply as the first argument to
    &quot;search&quot; in DBIx::Class::ResultSet. The return value will be
    passed directly to SQL::Abstract and the resulting SQL will be used verbatim
    as the <span class="Li">&quot;ON&quot;</span> clause of the
    <span class="Li">&quot;JOIN&quot;</span> statement associated with this
    relationship.</p>
<p class="Pp">While every coderef-based condition must return a valid
    <span class="Li">&quot;ON&quot;</span> clause, it may elect to additionally
    return a simplified join-free condition hashref when invoked as
    <span class="Li">&quot;$result-&gt;relationship&quot;</span>, as opposed to
    <span class="Li">&quot;$rs-&gt;related_resultset('relationship')&quot;</span>.
    In this case <span class="Li">$result</span> is passed to the coderef as
    <span class="Li">&quot;$args-&gt;{self_rowobj}&quot;</span>, so a user can
    do the following:</p>
<p class="Pp"></p>
<pre>
  sub {
    my $args = shift;

    return (
      {
        &quot;$args-&gt;{foreign_alias}.artist&quot; =&gt; { -ident =&gt; &quot;$args-&gt;{self_alias}.artistid&quot; },
        &quot;$args-&gt;{foreign_alias}.year&quot;   =&gt; { '&gt;', &quot;1979&quot;, '&lt;', &quot;1990&quot; },
      },
      $args-&gt;{self_rowobj} &amp;&amp; {
        &quot;$args-&gt;{foreign_alias}.artist&quot; =&gt; $args-&gt;{self_rowobj}-&gt;artistid,
        &quot;$args-&gt;{foreign_alias}.year&quot;   =&gt; { '&gt;', &quot;1979&quot;, '&lt;', &quot;1990&quot; },
      },
    );
  }
</pre>
<p class="Pp">Now this code:</p>
<p class="Pp"></p>
<pre>
    my $artist = $schema-&gt;resultset(&quot;Artist&quot;)-&gt;find({ id =&gt; 4 });
    $artist-&gt;cds_80s-&gt;all;
</pre>
<p class="Pp">Can skip a <span class="Li">&quot;JOIN&quot;</span> altogether and
    instead produce:</p>
<p class="Pp"></p>
<pre>
    SELECT cds_80s.cdid, cds_80s.artist, cds_80s.title, cds_80s.year, cds_80s.genreid, cds_80s.single_track
      FROM cd cds_80s
      WHERE cds_80s.artist = ?
        AND cds_80s.year &lt; ?
        AND cds_80s.year &gt; ?
</pre>
<p class="Pp">With the bind values:</p>
<p class="Pp"></p>
<pre>
    '4', '1990', '1979'
</pre>
<p class="Pp">Note that in order to be able to use
    <span class="Li">$result</span>-&gt;create_related, the coderef must not
    only return as its second such a &quot;simple&quot; condition hashref which
    does not depend on joins being available, but the hashref must contain only
    plain values/deflatable objects, such that the result can be passed directly
    to &quot;set_from_related&quot; in DBIx::Class::Relationship::Base. For
    instance the <span class="Li">&quot;year&quot;</span> constraint in the
    above example prevents the relationship from being used to create related
    objects (an exception will be thrown).</p>
<p class="Pp">In order to allow the user to go truly crazy when generating a
    custom <span class="Li">&quot;ON&quot;</span> clause, the
    <span class="Li">$args</span> hashref passed to the subroutine contains some
    extra metadata. Currently the supplied coderef is executed as:</p>
<p class="Pp"></p>
<pre>
  $relationship_info-&gt;{cond}-&gt;({
    self_alias        =&gt; The alias of the invoking resultset ('me' in case of a result object),
    foreign_alias     =&gt; The alias of the to-be-joined resultset (often matches relname),
    self_resultsource =&gt; The invocant's resultsource,
    foreign_relname   =&gt; The relationship name (does *not* always match foreign_alias),
    self_rowobj       =&gt; The invocant itself in case of a $result_object-&gt;$relationship call
  });
</pre>
<p class="Pp"><i>attributes</i></p>
<p class="Pp">The standard ResultSet attributes may be used as relationship
    attributes. In particular, the 'where' attribute is useful for filtering
    relationships:</p>
<p class="Pp"></p>
<pre>
     __PACKAGE__-&gt;has_many( 'valid_users', 'MyApp::Schema::User',
        { 'foreign.user_id' =&gt; 'self.user_id' },
        { where =&gt; { valid =&gt; 1 } }
    );
</pre>
<p class="Pp">The following attributes are also valid:</p>
<dl class="Bl-tag">
  <dt id="join_type"><a class="permalink" href="#join_type">join_type</a></dt>
  <dd>Explicitly specifies the type of join to use in the relationship. Any SQL
      join type is valid, e.g. <span class="Li">&quot;LEFT&quot;</span> or
      <span class="Li">&quot;RIGHT&quot;</span>. It will be placed in the SQL
      command immediately before <span class="Li">&quot;JOIN&quot;</span>.</dd>
  <dt id="proxy"><a class="permalink" href="#proxy">proxy =&gt; $column |
    \@columns | \%column</a></dt>
  <dd>The 'proxy' attribute can be used to retrieve values, and to perform
      updates if the relationship has 'cascade_update' set. The 'might_have' and
      'has_one' relationships have this set by default; if you want a proxy to
      update across a 'belongs_to' relationship, you must set the attribute
      yourself.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>\@columns</dt>
  <dd>An arrayref containing a list of accessors in the foreign class to create
      in the main class. If, for example, you do the following:
    <p class="Pp"></p>
    <pre>
  MyApp::Schema::CD-&gt;might_have(liner_notes =&gt; 'MyApp::Schema::LinerNotes',
    undef, {
      proxy =&gt; [ qw/notes/ ],
    });
    </pre>
    <p class="Pp">Then, assuming MyApp::Schema::LinerNotes has an accessor named
        notes, you can do:</p>
    <p class="Pp"></p>
    <pre>
  my $cd = MyApp::Schema::CD-&gt;find(1);
  $cd-&gt;notes('Notes go here'); # set notes -- LinerNotes object is
                               # created if it doesn't exist
    </pre>
    <p class="Pp">For a 'belongs_to relationship, note the 'cascade_update':</p>
    <p class="Pp"></p>
    <pre>
  MyApp::Schema::Track-&gt;belongs_to( cd =&gt; 'DBICTest::Schema::CD', 'cd,
      { proxy =&gt; ['title'], cascade_update =&gt; 1 }
  );
  $track-&gt;title('New Title');
  $track-&gt;update; # updates title in CD
    </pre>
  </dd>
  <dt>\%column</dt>
  <dd>A hashref where each key is the accessor you want installed in the main
      class, and its value is the name of the original in the foreign class.
    <p class="Pp"></p>
    <pre>
  MyApp::Schema::Track-&gt;belongs_to( cd =&gt; 'DBICTest::Schema::CD', 'cd', {
      proxy =&gt; { cd_title =&gt; 'title' },
  });
    </pre>
    <p class="Pp">This will create an accessor named
        <span class="Li">&quot;cd_title&quot;</span> on the
        <span class="Li">$track</span> result object.</p>
  </dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">NOTE: you can pass a nested struct too, for example:</p>
<p class="Pp"></p>
<pre>
  MyApp::Schema::Track-&gt;belongs_to( cd =&gt; 'DBICTest::Schema::CD', 'cd', {
    proxy =&gt; [ 'year', { cd_title =&gt; 'title' } ],
  });
</pre>
</div>
<dl class="Bl-tag">
  <dt id="accessor"><a class="permalink" href="#accessor">accessor</a></dt>
  <dd>Specifies the type of accessor that should be created for the
      relationship. Valid values are <span class="Li">&quot;single&quot;</span>
      (for when there is only a single related object),
      <span class="Li">&quot;multi&quot;</span> (when there can be many), and
      <span class="Li">&quot;filter&quot;</span> (for when there is a single
      related object, but you also want the relationship accessor to double as a
      column accessor). For <span class="Li">&quot;multi&quot;</span> accessors,
      an add_to_* method is also created, which calls
      <span class="Li">&quot;create_related&quot;</span> for the
    relationship.</dd>
  <dt id="is_foreign_key_constraint"><a class="permalink" href="#is_foreign_key_constraint">is_foreign_key_constraint</a></dt>
  <dd>If you are using SQL::Translator to create SQL for you and you find that
      it is creating constraints where it shouldn't, or not creating them where
      it should, set this attribute to a true or false value to override the
      detection of when to create constraints.</dd>
  <dt id="cascade_copy"><a class="permalink" href="#cascade_copy">cascade_copy</a></dt>
  <dd>If <span class="Li">&quot;cascade_copy&quot;</span> is true on a
      <span class="Li">&quot;has_many&quot;</span> relationship for an object,
      then when you copy the object all the related objects will be copied too.
      To turn this behaviour off, pass <span class="Li">&quot;cascade_copy =&gt;
      0&quot;</span> in the <span class="Li">$attr</span> hashref.
    <p class="Pp">The behaviour defaults to <span class="Li">&quot;cascade_copy
        =&gt; 1&quot;</span> for <span class="Li">&quot;has_many&quot;</span>
        relationships.</p>
  </dd>
  <dt id="cascade_delete"><a class="permalink" href="#cascade_delete">cascade_delete</a></dt>
  <dd>By default, DBIx::Class cascades deletes across
      <span class="Li">&quot;has_many&quot;</span>,
      <span class="Li">&quot;has_one&quot;</span> and
      <span class="Li">&quot;might_have&quot;</span> relationships. You can
      disable this behaviour on a per-relationship basis by supplying
      <span class="Li">&quot;cascade_delete =&gt; 0&quot;</span> in the
      relationship attributes.
    <p class="Pp">The cascaded operations are performed after the requested
        delete, so if your database has a constraint on the relationship, it
        will have deleted/updated the related records or raised an exception
        before DBIx::Class gets to perform the cascaded operation.</p>
  </dd>
  <dt id="cascade_update"><a class="permalink" href="#cascade_update">cascade_update</a></dt>
  <dd>By default, DBIx::Class cascades updates across
      <span class="Li">&quot;has_one&quot;</span> and
      <span class="Li">&quot;might_have&quot;</span> relationships. You can
      disable this behaviour on a per-relationship basis by supplying
      <span class="Li">&quot;cascade_update =&gt; 0&quot;</span> in the
      relationship attributes.
    <p class="Pp">The <span class="Li">&quot;belongs_to&quot;</span>
        relationship does not update across relationships by default, so if you
        have a 'proxy' attribute on a belongs_to and want to use 'update' on it,
        you muse set <span class="Li">&quot;cascade_update =&gt;
      1&quot;</span>.</p>
    <p class="Pp">This is not a RDMS style cascade update - it purely means that
        when an object has update called on it, all the related objects also
        have update called. It will not change foreign keys automatically - you
        must arrange to do this yourself.</p>
  </dd>
  <dt id="on_delete"><a class="permalink" href="#on_delete">on_delete /
    on_update</a></dt>
  <dd>If you are using SQL::Translator to create SQL for you, you can use these
      attributes to explicitly set the desired <span class="Li">&quot;ON
      DELETE&quot;</span> or <span class="Li">&quot;ON UPDATE&quot;</span>
      constraint type. If not supplied the SQLT parser will attempt to infer the
      constraint type by interrogating the attributes of the <b>opposite</b>
      relationship. For any 'multi' relationship with
      <span class="Li">&quot;cascade_delete =&gt; 1&quot;</span>, the
      corresponding belongs_to relationship will be created with an
      <span class="Li">&quot;ON DELETE CASCADE&quot;</span> constraint. For any
      relationship bearing <span class="Li">&quot;cascade_copy =&gt;
      1&quot;</span> the resulting belongs_to constraint will be
      <span class="Li">&quot;ON UPDATE CASCADE&quot;</span>. If you wish to
      disable this autodetection, and just use the RDBMS' default constraint
      type, pass <span class="Li">&quot;on_delete =&gt; undef&quot;</span> or
      <span class="Li">&quot;on_delete =&gt; ''&quot;</span>, and the same for
      <span class="Li">&quot;on_update&quot;</span> respectively.</dd>
  <dt id="is_deferrable"><a class="permalink" href="#is_deferrable">is_deferrable</a></dt>
  <dd>Tells SQL::Translator that the foreign key constraint it creates should be
      deferrable. In other words, the user may request that the constraint be
      ignored until the end of the transaction. Currently, only the PostgreSQL
      producer actually supports this.</dd>
  <dt id="add_fk_index"><a class="permalink" href="#add_fk_index">add_fk_index</a></dt>
  <dd>Tells SQL::Translator to add an index for this constraint. Can also be
      specified globally in the args to &quot;deploy&quot; in
      DBIx::Class::Schema or &quot;create_ddl_dir&quot; in DBIx::Class::Schema.
      Default is on, set to 0 to disable.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="register_relationship"><a class="permalink" href="#register_relationship">register_relationship</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~2"><a class="permalink" href="#Arguments:~2">Arguments:
    $rel_name, $rel_info</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Registers a relationship on the class. This is called internally
    by DBIx::Class::ResultSourceProxy to set up Accessors and Proxies.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="related_resultset"><a class="permalink" href="#related_resultset">related_resultset</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~3"><a class="permalink" href="#Arguments:~3">Arguments:
    $rel_name</a></dt>
  <dd></dd>
  <dt id="Return"><a class="permalink" href="#Return">Return Value:
    $related_resultset</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  $rs = $cd-&gt;related_resultset('artist');
</pre>
<p class="Pp">Returns a DBIx::Class::ResultSet for the relationship named
    <span class="Li">$rel_name</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$relationship_accessor"><a class="permalink" href="#$relationship_accessor">$relationship_accessor</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~4"><a class="permalink" href="#Arguments:~4">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~2"><a class="permalink" href="#Return~2">Return Value: $result
    | $related_resultset | undef</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  # These pairs do the same thing
  $result = $cd-&gt;related_resultset('artist')-&gt;single;  # has_one relationship
  $result = $cd-&gt;artist;
  $rs = $cd-&gt;related_resultset('tracks');           # has_many relationship
  $rs = $cd-&gt;tracks;
</pre>
<p class="Pp">This is the recommended way to traverse through relationships,
    based on the &quot;accessor&quot; name given in the relationship
  definition.</p>
<p class="Pp">This will return either a Result or a ResultSet, depending on if
    the relationship is <span class="Li">&quot;single&quot;</span> (returns only
    one row) or <span class="Li">&quot;multi&quot;</span> (returns many rows).
    The method may also return <span class="Li">&quot;undef&quot;</span> if the
    relationship doesn't exist for this instance (like in the case of
    <span class="Li">&quot;might_have&quot;</span> relationships).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="search_related"><a class="permalink" href="#search_related">search_related</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~5"><a class="permalink" href="#Arguments:~5">Arguments:
    $rel_name, $cond?, \%attrs?</a></dt>
  <dd></dd>
  <dt id="Return~3"><a class="permalink" href="#Return~3">Return Value:
    $resultset (scalar context) | @result_objs (list context)</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Run a search on a related resultset. The search will be restricted
    to the results represented by the DBIx::Class::ResultSet it was called
  upon.</p>
<p class="Pp">See &quot;search_related&quot; in DBIx::Class::ResultSet for more
    information.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="search_related_rs"><a class="permalink" href="#search_related_rs">search_related_rs</a></h2>
<p class="Pp">This method works exactly the same as search_related, except that
    it guarantees a resultset, even in list context.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="count_related"><a class="permalink" href="#count_related">count_related</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~6"><a class="permalink" href="#Arguments:~6">Arguments:
    $rel_name, $cond?, \%attrs?</a></dt>
  <dd></dd>
  <dt id="Return~4"><a class="permalink" href="#Return~4">Return Value:
    $count</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Returns the count of all the rows in the related resultset,
    restricted by the current result or where conditions.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="new_related"><a class="permalink" href="#new_related">new_related</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~7"><a class="permalink" href="#Arguments:~7">Arguments:
    $rel_name, \%col_data</a></dt>
  <dd></dd>
  <dt id="Return~5"><a class="permalink" href="#Return~5">Return Value:
    $result</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Create a new result object of the related foreign class. It will
    magically set any foreign key columns of the new object to the related
    primary key columns of the source object for you. The newly created result
    will not be saved into your storage until you call &quot;insert&quot; in
    DBIx::Class::Row on it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="create_related"><a class="permalink" href="#create_related">create_related</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~8"><a class="permalink" href="#Arguments:~8">Arguments:
    $rel_name, \%col_data</a></dt>
  <dd></dd>
  <dt id="Return~6"><a class="permalink" href="#Return~6">Return Value:
    $result</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  my $result = $obj-&gt;create_related($rel_name, \%col_data);
</pre>
<p class="Pp">Creates a new result object, similarly to new_related, and also
    inserts the result's data into your storage medium. See the distinction
    between <span class="Li">&quot;create&quot;</span> and
    <span class="Li">&quot;new&quot;</span> in DBIx::Class::ResultSet for
    details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="find_related"><a class="permalink" href="#find_related">find_related</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~9"><a class="permalink" href="#Arguments:~9">Arguments:
    $rel_name, \%col_data | @pk_values, { key =&gt; $unique_constraint, %attrs
    }?</a></dt>
  <dd></dd>
  <dt id="Return~7"><a class="permalink" href="#Return~7">Return Value: $result
    | undef</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  my $result = $obj-&gt;find_related($rel_name, \%col_data);
</pre>
<p class="Pp">Attempt to find a related object using its primary key or unique
    constraints. See &quot;find&quot; in DBIx::Class::ResultSet for details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="find_or_new_related"><a class="permalink" href="#find_or_new_related">find_or_new_related</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~10"><a class="permalink" href="#Arguments:~10">Arguments:
    $rel_name, \%col_data, { key =&gt; $unique_constraint, %attrs }?</a></dt>
  <dd></dd>
  <dt id="Return~8"><a class="permalink" href="#Return~8">Return Value:
    $result</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Find a result object of a related class. See
    &quot;find_or_new&quot; in DBIx::Class::ResultSet for details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="find_or_create_related"><a class="permalink" href="#find_or_create_related">find_or_create_related</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~11"><a class="permalink" href="#Arguments:~11">Arguments:
    $rel_name, \%col_data, { key =&gt; $unique_constraint, %attrs }?</a></dt>
  <dd></dd>
  <dt id="Return~9"><a class="permalink" href="#Return~9">Return Value:
    $result</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Find or create a result object of a related class. See
    &quot;find_or_create&quot; in DBIx::Class::ResultSet for details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="update_or_create_related"><a class="permalink" href="#update_or_create_related">update_or_create_related</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~12"><a class="permalink" href="#Arguments:~12">Arguments:
    $rel_name, \%col_data, { key =&gt; $unique_constraint, %attrs }?</a></dt>
  <dd></dd>
  <dt id="Return~10"><a class="permalink" href="#Return~10">Return Value:
    $result</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Update or create a result object of a related class. See
    &quot;update_or_create&quot; in DBIx::Class::ResultSet for details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="set_from_related"><a class="permalink" href="#set_from_related">set_from_related</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~13"><a class="permalink" href="#Arguments:~13">Arguments:
    $rel_name, $result</a></dt>
  <dd></dd>
  <dt id="Return~11"><a class="permalink" href="#Return~11">Return Value: not
    defined</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  $book-&gt;set_from_related('author', $author_obj);
  $book-&gt;author($author_obj);                      ## same thing
</pre>
<p class="Pp">Set column values on the current object, using related values from
    the given related object. This is used to associate previously separate
    objects, for example, to set the correct author for a book, find the Author
    object, then call set_from_related on the book.</p>
<p class="Pp">This is called internally when you pass existing objects as values
    to &quot;create&quot; in DBIx::Class::ResultSet, or pass an object to a
    belongs_to accessor.</p>
<p class="Pp">The columns are only set in the local copy of the object, call
    &quot;update&quot; to set them in the storage.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="update_from_related"><a class="permalink" href="#update_from_related">update_from_related</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~14"><a class="permalink" href="#Arguments:~14">Arguments:
    $rel_name, $result</a></dt>
  <dd></dd>
  <dt id="Return~12"><a class="permalink" href="#Return~12">Return Value: not
    defined</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  $book-&gt;update_from_related('author', $author_obj);
</pre>
<p class="Pp">The same as &quot;set_from_related&quot;, but the changes are
    immediately updated in storage.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="delete_related"><a class="permalink" href="#delete_related">delete_related</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~15"><a class="permalink" href="#Arguments:~15">Arguments:
    $rel_name, $cond?, \%attrs?</a></dt>
  <dd></dd>
  <dt id="Return~13"><a class="permalink" href="#Return~13">Return Value:
    $underlying_storage_rv</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Delete any related row, subject to the given conditions.
    Internally, this calls:</p>
<p class="Pp"></p>
<pre>
  $self-&gt;search_related(@_)-&gt;delete
</pre>
<p class="Pp">And returns the result of that.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="add_to_$rel"><a class="permalink" href="#add_to_$rel">add_to_$rel</a></h2>
<p class="Pp"><b>Currently only available for
    </b><b>&quot;has_many&quot;</b><b>, </b><b>&quot;many_to_many&quot;</b><b>
    and 'multi' type</b> <b>relationships.</b></p>
<p class="Pp"><i>has_many / multi</i></p>
<dl class="Bl-tag">
  <dt id="Arguments:~16"><a class="permalink" href="#Arguments:~16">Arguments:
    \%col_data</a></dt>
  <dd></dd>
  <dt id="Return~14"><a class="permalink" href="#Return~14">Return Value:
    $result</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Creates/inserts a new result object. Internally, this calls:</p>
<p class="Pp"></p>
<pre>
  $self-&gt;create_related($rel, @_)
</pre>
<p class="Pp">And returns the result of that.</p>
<p class="Pp"><i>many_to_many</i></p>
<dl class="Bl-tag">
  <dt id="Arguments:~17"><a class="permalink" href="#Arguments:~17">Arguments:
    (\%col_data | $result), \%link_col_data?</a></dt>
  <dd></dd>
  <dt id="Return~15"><a class="permalink" href="#Return~15">Return Value:
    $result</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  my $role = $schema-&gt;resultset('Role')-&gt;find(1);
  $actor-&gt;add_to_roles($role);
      # creates a My::DBIC::Schema::ActorRoles linking table result object

  $actor-&gt;add_to_roles({ name =&gt; 'lead' }, { salary =&gt; 15_000_000 });
      # creates a new My::DBIC::Schema::Role result object and the linking table
      # object with an extra column in the link
</pre>
<p class="Pp">Adds a linking table object. If the first argument is a hash
    reference, the related object is created first with the column values in the
    hash. If an object reference is given, just the linking table object is
    created. In either case, any additional column values for the linking table
    object can be specified in
    <span class="Li">&quot;\%link_col_data&quot;</span>.</p>
<p class="Pp">See &quot;many_to_many&quot; in DBIx::Class::Relationship for
    additional details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="set_$rel"><a class="permalink" href="#set_$rel">set_$rel</a></h2>
<p class="Pp"><b>Currently only available for
    </b><b>&quot;many_to_many&quot;</b><b> relationships.</b></p>
<dl class="Bl-tag">
  <dt id="Arguments:~18"><a class="permalink" href="#Arguments:~18">Arguments:
    (\@hashrefs_of_col_data | \@result_objs), $link_vals?</a></dt>
  <dd></dd>
  <dt id="Return~16"><a class="permalink" href="#Return~16">Return Value: not
    defined</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  my $actor = $schema-&gt;resultset('Actor')-&gt;find(1);
  my @roles = $schema-&gt;resultset('Role')-&gt;search({ role =&gt;
     { '-in' =&gt; ['Fred', 'Barney'] } } );

  $actor-&gt;set_roles(\@roles);
     # Replaces all of $actor's previous roles with the two named

  $actor-&gt;set_roles(\@roles, { salary =&gt; 15_000_000 });
     # Sets a column in the link table for all roles
</pre>
<p class="Pp">Replace all the related objects with the given reference to a list
    of objects. This does a <span class="Li">&quot;delete&quot;</span> <b>on the
    link table resultset</b> to remove the association between the current
    object and all related objects, then calls
    <span class="Li">&quot;add_to_$rel&quot;</span> repeatedly to link all the
    new objects.</p>
<p class="Pp">Note that this means that this method will <b>not</b> delete any
    objects in the table on the right side of the relation, merely that it will
    delete the link between them.</p>
<p class="Pp">Due to a mistake in the original implementation of this method, it
    will also accept a list of objects or hash references. This is
    <b>deprecated</b> and will be removed in a future version.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="remove_from_$rel"><a class="permalink" href="#remove_from_$rel">remove_from_$rel</a></h2>
<p class="Pp"><b>Currently only available for
    </b><b>&quot;many_to_many&quot;</b><b> relationships.</b></p>
<dl class="Bl-tag">
  <dt id="Arguments:~19"><a class="permalink" href="#Arguments:~19">Arguments:
    $result</a></dt>
  <dd></dd>
  <dt id="Return~17"><a class="permalink" href="#Return~17">Return Value: not
    defined</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  my $role = $schema-&gt;resultset('Role')-&gt;find(1);
  $actor-&gt;remove_from_roles($role);
      # removes $role's My::DBIC::Schema::ActorRoles linking table result object
</pre>
<p class="Pp">Removes the link between the current object and the related
    object. Note that the related object itself won't be deleted unless you call
    -&gt;<i>delete()</i> on it. This method just removes the link between the
    two objects.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR_AND_CONTRIBUTORS"><a class="permalink" href="#AUTHOR_AND_CONTRIBUTORS">AUTHOR
  AND CONTRIBUTORS</a></h1>
<p class="Pp">See AUTHOR and CONTRIBUTORS in DBIx::Class</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">You may distribute this code under the same terms as Perl
  itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-05</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

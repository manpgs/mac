<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>JSON::MaybeXS(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">JSON::MaybeXS(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">JSON::MaybeXS(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">JSON::MaybeXS - Use Cpanel::JSON::XS with a fallback to JSON::XS
    and JSON::PP</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  use JSON::MaybeXS;
  my $data_structure = decode_json($json_input);
  my $json_output = encode_json($data_structure);
  my $json = JSON()-&gt;new;
  my $json_with_args = JSON::MaybeXS-&gt;new(utf8 =&gt; 1); # or { utf8 =&gt; 1 }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module first checks to see if either Cpanel::JSON::XS or
    JSON::XS (at at least version 3.0) is already loaded, in which case it uses
    that module. Otherwise it tries to load Cpanel::JSON::XS, then JSON::XS,
    then JSON::PP in order, and either uses the first module it finds or throws
    an error.</p>
<p class="Pp">It then exports the
    <span class="Li">&quot;encode_json&quot;</span> and
    <span class="Li">&quot;decode_json&quot;</span> functions from the loaded
    module, along with a <span class="Li">&quot;JSON&quot;</span> constant that
    returns the class name for calling <span class="Li">&quot;new&quot;</span>
    on.</p>
<p class="Pp">If you're writing fresh code rather than replacing JSON.pm usage,
    you might want to pass options as constructor args rather than calling
    mutators, so we provide our own <span class="Li">&quot;new&quot;</span>
    method that supports that.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTS"><a class="permalink" href="#EXPORTS">EXPORTS</a></h1>
<p class="Pp"><span class="Li">&quot;encode_json&quot;</span>,
    <span class="Li">&quot;decode_json&quot;</span> and
    <span class="Li">&quot;JSON&quot;</span> are exported by default;
    <span class="Li">&quot;is_bool&quot;</span> is exported on request.</p>
<p class="Pp">To import only some symbols, specify them on the
    <span class="Li">&quot;use&quot;</span> line:</p>
<p class="Pp"></p>
<pre>  use JSON::MaybeXS qw(encode_json decode_json is_bool); # functions only
  use JSON::MaybeXS qw(JSON); # JSON constant only
</pre>
<p class="Pp">To import all available sensible symbols
    (<span class="Li">&quot;encode_json&quot;</span>,
    <span class="Li">&quot;decode_json&quot;</span>, and
    <span class="Li">&quot;is_bool&quot;</span>), use
    <span class="Li">&quot;:all&quot;</span>:</p>
<p class="Pp"></p>
<pre>  use JSON::MaybeXS ':all';
</pre>
<p class="Pp">To import all symbols including those needed by legacy apps that
    use JSON::PP:</p>
<p class="Pp"></p>
<pre>  use JSON::MaybeXS ':legacy';
</pre>
<p class="Pp">This imports the <span class="Li">&quot;to_json&quot;</span> and
    <span class="Li">&quot;from_json&quot;</span> symbols as well as everything
    in <span class="Li">&quot;:all&quot;</span>. NOTE: This is to support legacy
    code that makes extensive use of <span class="Li">&quot;to_json&quot;</span>
    and <span class="Li">&quot;from_json&quot;</span> which you are not yet in a
    position to refactor. DO NOT use this import tag in new code, in order to
    avoid the crawling horrors of getting UTF-8 support subtly wrong. See the
    documentation for JSON for further details.</p>
<section class="Ss">
<h2 class="Ss" id="encode_json"><a class="permalink" href="#encode_json">encode_json</a></h2>
<p class="Pp">This is the <span class="Li">&quot;encode_json&quot;</span>
    function provided by the selected implementation module, and takes a perl
    data structure which is serialised to JSON text.</p>
<p class="Pp"></p>
<pre>  my $json_text = encode_json($data_structure);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="decode_json"><a class="permalink" href="#decode_json">decode_json</a></h2>
<p class="Pp">This is the <span class="Li">&quot;decode_json&quot;</span>
    function provided by the selected implementation module, and takes a string
    of JSON text to deserialise to a perl data structure.</p>
<p class="Pp"></p>
<pre>  my $data_structure = decode_json($json_text);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="to_json,_from_json"><a class="permalink" href="#to_json,_from_json">to_json,
  from_json</a></h2>
<p class="Pp">See JSON for details. These are included to support legacy code
    <b>only</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss">JSON</h2>
<p class="Pp">The <span class="Li">&quot;JSON&quot;</span> constant returns the
    selected implementation module's name for use as a class name - so:</p>
<p class="Pp"></p>
<pre>  my $json_obj = JSON()-&gt;new; # returns a Cpanel::JSON::XS or JSON::PP object
</pre>
<p class="Pp">and that object can then be used normally:</p>
<p class="Pp"></p>
<pre>  my $data_structure = $json_obj-&gt;decode($json_text); # etc.
</pre>
<p class="Pp">The use of parentheses here is optional, and only used as a hint
    to the reader that this use of <span class="Li">&quot;JSON&quot;</span> is a
    <i>subroutine</i> call, <i>not</i> a class name.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="is_bool"><a class="permalink" href="#is_bool">is_bool</a></h2>
<pre>  $is_boolean = is_bool($scalar)
</pre>
<p class="Pp">Returns true if the passed scalar represents either
    <span class="Li">&quot;true&quot;</span> or
    <span class="Li">&quot;false&quot;</span>, two constants that act like
    <span class="Li">1</span> and <span class="Li">0</span>, respectively and
    are used to represent JSON <span class="Li">&quot;true&quot;</span> and
    <span class="Li">&quot;false&quot;</span> values in Perl.</p>
<p class="Pp">Since this is a bare sub in the various backend classes, it cannot
    be called as a class method like the other interfaces; it must be called as
    a function, with no invocant. It supports the representation used in all
    JSON backends.</p>
<p class="Pp">Available since version 1.002004.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CONSTRUCTOR"><a class="permalink" href="#CONSTRUCTOR">CONSTRUCTOR</a></h1>
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
<p class="Pp">With JSON::PP, JSON::XS and Cpanel::JSON::XS you are required to
    call mutators to set options, such as:</p>
<p class="Pp"></p>
<pre>  my $json = $class-&gt;new-&gt;utf8(1)-&gt;pretty(1);
</pre>
<p class="Pp">Since this is a trifle irritating and noticeably un-perlish, we
    also offer:</p>
<p class="Pp"></p>
<pre>  my $json = JSON::MaybeXS-&gt;new(utf8 =&gt; 1, pretty =&gt; 1);
</pre>
<p class="Pp">which works equivalently to the above (and in the usual tradition
    will accept a hashref instead of a hash, should you so desire).</p>
<p class="Pp">The resulting object is blessed into the underlying backend, which
    offers (at least) the methods <span class="Li">&quot;encode&quot;</span> and
    <span class="Li">&quot;decode&quot;</span>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BOOLEANS"><a class="permalink" href="#BOOLEANS">BOOLEANS</a></h1>
<p class="Pp">To include JSON-aware booleans
    (<span class="Li">&quot;true&quot;</span>,
    <span class="Li">&quot;false&quot;</span>) in your data, just do:</p>
<p class="Pp"></p>
<pre>    use JSON::MaybeXS;
    my $true = JSON()-&gt;true;
    my $false = JSON()-&gt;false;
</pre>
<p class="Pp">The booleans are also available as subs or methods on
    JSON::MaybeXS.</p>
<p class="Pp"></p>
<pre>    use JSON::MaybeXS ();
    my $true = JSON::MaybeXS::true;
    my $true = JSON::MaybeXS-&gt;true;
    my $false = JSON::MaybeXS::false;
    my $false = JSON::MaybeXS-&gt;false;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="CONVERTING_FROM_JSON::Any"><a class="permalink" href="#CONVERTING_FROM_JSON::Any">CONVERTING
  FROM JSON::Any</a></h1>
<p class="Pp">JSON::Any used to be the favoured compatibility layer above the
    various JSON backends, but over time has grown a lot of extra code to deal
    with legacy backends (e.g. JSON::Syck) that are no longer needed. This is a
    rough guide of translating such code:</p>
<p class="Pp">Change code from:</p>
<p class="Pp"></p>
<pre>    use JSON::Any;
    my $json = JSON::Any-&gt;new-&gt;objToJson($data);    # or to_json($data), or Dump($data)
</pre>
<p class="Pp">to:</p>
<p class="Pp"></p>
<pre>    use JSON::MaybeXS;
    my $json = encode_json($data);
</pre>
<p class="Pp">Change code from:</p>
<p class="Pp"></p>
<pre>    use JSON::Any;
    my $data = JSON::Any-&gt;new-&gt;jsonToObj($json);    # or from_json($json), or Load($json)
</pre>
<p class="Pp">to:</p>
<p class="Pp"></p>
<pre>    use JSON::MaybeXS;
    my $json = decode_json($data);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<p class="Pp">The <span class="Li">&quot;new()&quot;</span> method in this
    module is technically a factory, not a constructor, because the objects it
    returns will <i>NOT</i> be blessed into the
    <span class="Li">&quot;JSON::MaybeXS&quot;</span> class.</p>
<p class="Pp">If you are using an object returned by this module as a Moo(se)
    attribute, this type constraint code:</p>
<p class="Pp"></p>
<pre>    is 'json' =&gt; ( isa =&gt; 'JSON::MaybeXS' );
</pre>
<p class="Pp">will <i>NOT</i> do what you expect. Instead, either rely on the
    <span class="Li">&quot;JSON&quot;</span> class constant described above, as
    so:</p>
<p class="Pp"></p>
<pre>    is 'json' =&gt; ( isa =&gt; JSON::MaybeXS::JSON() );
</pre>
<p class="Pp">Alternatively, you can use duck typing:</p>
<p class="Pp"></p>
<pre>    use Moose::Util::TypeConstraints 'duck_type';
    is 'json' =&gt; ( isa =&gt; Object , duck_type([qw/ encode decode /]));
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="INSTALLATION"><a class="permalink" href="#INSTALLATION">INSTALLATION</a></h1>
<p class="Pp">At installation time, <i>Makefile.PL</i> will attempt to determine
    if you have a working compiler available, and therefore whether you are able
    to run XS code. If so, Cpanel::JSON::XS will be added to the prerequisite
    list, unless JSON::XS is already installed at a high enough version.
    JSON::XS may also be upgraded to fix any incompatibility issues.</p>
<p class="Pp">Because running XS code is not mandatory and JSON::PP (which is in
    perl core) is used as a fallback backend, this module is safe to be used in
    a suite of code that is fatpacked or installed into a restricted-resource
    environment.</p>
<p class="Pp">You can also prevent any XS dependencies from being installed by
    setting <span class="Li">&quot;PUREPERL_ONLY=1&quot;</span> in
    <i>Makefile.PL</i> options (or in the
    <span class="Li">&quot;PERL_MM_OPT&quot;</span> environment variable), or
    using the <span class="Li">&quot;--pp&quot;</span> or
    <span class="Li">&quot;--pureperl&quot;</span> flags with the cpanminus
    client.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">mst - Matt S. Trout (cpan:MSTROUT) &lt;mst@shadowcat.co.uk&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<ul class="Bl-bullet">
  <li>Clinton Gormley &lt;drtech@cpan.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Kieren Diment &lt;diment@gmail.com&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 2013 the
    <span class="Li">&quot;JSON::MaybeXS&quot;</span> &quot;AUTHOR&quot; and
    &quot;CONTRIBUTORS&quot; as listed above.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">This library is free software and may be distributed under the
    same terms as perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-05-17</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

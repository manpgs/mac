<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PerlObjCBridge(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PerlObjCBridge(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">PerlObjCBridge(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">PerlObjCBridge.pm - Bridges Perl and Objective-C runtimes</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use Foundation;
    
    $s1 = NSString-&gt;stringWithCString_(&quot;Hello &quot;);
    $s2 = NSString-&gt;alloc()-&gt;initWithCString_(&quot;World&quot;);
    $s3 = $s1-&gt;stringByAppendingString_($s2);
    printf &quot;%s\n&quot;, $s3-&gt;cString();
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SUMMARY"><a class="permalink" href="#SUMMARY">SUMMARY</a></h1>
<p class="Pp">The PerlObjCBridge module supports creating and messaging
    Objective-C objects from Perl programs, allowing Cocoa objects in Apple
    Computer's Mac OS X to be directly manipulated from Perl. In addition, Perl
    objects can be messaged from Objective-C, making it possible for Perl
    objects to function as Cocoa delegates and as targets of notifications and
    other Cocoa call-back messages. Perl programs can take advantage of Cocoa's
    Distributed Objects mechanism to support messaging between Perl objects and
    Objective-C objects (or other Perl objects) in different address spaces,
    possibly on different machines.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LIMITATION"><a class="permalink" href="#LIMITATION">LIMITATION</a></h1>
<p class="Pp">This version of PerlObjCBridge does not directly support writing
    GUI Cocoa applications in Perl. Consult
    http://www.sourceforge.net/projects/camelbones for a freeware package that
    supports GUI Perl/Cocoa apps.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Using PerlObjCBridge, Perl programs can reference Objective-C
    objects in a manner similar to references to native Perl objects. The
    Objective-C objects must inherit from the NSObject root class in the Mac OS
    X Foundation framework (which is true for Cocoa objects). In Objective-C an
    object is accessed via an object identifier that is implemented as a pointer
    to a structure containing the object's instance data. PerlObjCBridge
    represents an Objective-C object as a Perl reference to a scalar value that
    contains the Objective-C ID. For example, if an Objective-C object has an ID
    with value 0x12345678, then PerlObjCBridge represents that object as a
    reference to a scalar with value 0x12345678. The Perl reference is
    &quot;blessed&quot; into a Perl class that has the same name as the
    Objective-C class. The Perl inheritance mechanism is then used to route any
    messages sent to the object from Perl through the PerlObjCBridge extension
    module and ultimately to the Objective-C object. The return values of the
    Objective-C messages are similarly routed back through the bridge where they
    are converted into Perl return values.</p>
<p class="Pp">It is also possible to use Perl objects in places where Cocoa
    methods normally take Objective-C arguments. For example, one can register
    Perl objects to receive NSNotifications, in which case the perl objects
    provide the notification handling methods that are asynchronously messaged
    by NSNotificationCenter when interesting events occur. As another example, a
    Perl object can be registered as a server object via NSConnection, after
    which Objective-C or Perl objects in other address spaces can send messages
    to the server object via the Distributed Objects mechanism. In these
    examples an Objective-C proxy object is created by PerlObjCBridge that gets
    passed to Objective-C methods, and that forwards messages from Objective-C
    to the Perl object.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MESSAGING"><a class="permalink" href="#MESSAGING">MESSAGING</a></h1>
<p class="Pp">Ordinary Perl &quot;object-&gt;method(argument-list)&quot; syntax
    is used to send messages to Objective-C objects. The ':' character that
    delimits arguments in Objective-C is illegal in Perl method names, so
    underscores are used instead. An method that is invoked in Objective-C
  as:</p>
<p class="Pp"></p>
<pre>    [anObject arg1:x arg2:y];
</pre>
<p class="Pp">can be invoked from Perl using something like:</p>
<p class="Pp"></p>
<pre>    $anObject-&gt;arg1_arg2_($x, $y);
</pre>
<p class="Pp">Contrast the following Objective-C code fragment with its Perl
    analogue in the synopsis at the top of this man page:</p>
<p class="Pp"></p>
<pre>    #import &lt;Foundation/Foundation.h&gt;
    NSString *s1 = [NSString stringWithCString:&quot;Hello &quot;];
    NSString *s2 = [[NSString alloc] initWithCString:&quot;World&quot;];
    NSString *s3 = [s1 stringByAppendingString:s2];
    printf(&quot;%s\n&quot;, [s3 cString]);
</pre>
<p class="Pp">To send a message to an Objective-C class, one uses the syntactic
    form ClassName-&gt;method(...args...). For example, one can send the
    &quot;defaultManager&quot; message to the NSFileManager class as
  follows:</p>
<p class="Pp"></p>
<pre>    $defMgr = NSFileManager-&gt;defaultManager();
</pre>
<p class="Pp">An important special case of a class method is a
    &quot;factory&quot; method that constructs a new instance of a class:</p>
<p class="Pp"></p>
<pre>    $array = NSMutableArray-&gt;array();
    
    $string = NSString-&gt;stringWithCString_(&quot;Hi there&quot;);
</pre>
<p class="Pp">The NSString factory method illustrates how PerlObjCBridge passes
    Perl strings to Objective-C as char *'s.</p>
<p class="Pp">To send a message to an Objective-C object, one uses the syntactic
    form <span class="Li">$object</span>-&gt;method(...args...). If
    <span class="Li">$array</span> is a reference to an NSMutableArray then one
    can add the NSString referenced by <span class="Li">$string</span> by
    sending <span class="Li">$array</span> the &quot;addObject:&quot;
  message:</p>
<p class="Pp"></p>
<pre>    $array-&gt;addObject_($string);
</pre>
<p class="Pp">Message sends can be chained from left to right:</p>
<p class="Pp"></p>
<pre>    $hostName = NSProcessInfo-&gt;processInfo()-&gt;hostName();
</pre>
<p class="Pp">In the above example, the object returned by
    NSProcessInfo-&gt;<b>processInfo()</b> is in turn sent the hostName
  message.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="USING_COCOA_FRAMEWORKS"><a class="permalink" href="#USING_COCOA_FRAMEWORKS">USING
  COCOA FRAMEWORKS</a></h1>
<p class="Pp">PerlObjCBridge automatically generates a bridge module for the
    Foundation framework that is included with the Cocoa environment in Mac OS
    X. This bridge module is created when PerlObjCBridge is built. The bridge
    module for a framework causes that framework to be dynamically loaded into
    the Perl program's address space. In addition Perl packages are created for
    each of the Objective-C classes in the framework so that the Objective-C
    classes exist in the Perl name space.</p>
<p class="Pp">To access a framework from Perl &quot;use&quot; its bridge module.
    For example, to access Foundation objects do:</p>
<p class="Pp"></p>
<pre>    use Foundation;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DISTRIBUTED_MESSAGING"><a class="permalink" href="#DISTRIBUTED_MESSAGING">DISTRIBUTED
  MESSAGING</a></h1>
<p class="Pp">Perl objects can send messages to other objects (Perl or Cocoa) in
    different address spaces by using Cocoa's Distributed Objects (DO)
    mechanism. This makes it easy to create distributed systems (such as
    client/server systems) that mix Perl and Cocoa programs. It also makes it
    easy to create a pure Perl distributed system, where Perl objects in
    different address spaces communicate via Cocoa DO.</p>
<p class="Pp">Here is a complete example of a distributed client/server system,
    where the client and server objects are written in Perl but communicate by
    means of DO. The system consists of a Perl client program, a Perl server
    program, and a Perl XSUB module that provides the glue between the Perl
    programs and DO. The XSUB module is initially created by running the
    following command:</p>
<p class="Pp"></p>
<pre>    h2xs -A -n AddSystem
</pre>
<p class="Pp">An AddSystem directory is created with these files:</p>
<p class="Pp"></p>
<pre>    ppport.h
    lib/AddSystem.pm
    AddSystem.xs
    Makefile.PL
    README
    t/AddSystem.t    
    Changes
    MANIFEST
</pre>
<p class="Pp">Edit the Makefile.PL to add the CCFLAGS entry with the '-x
    objective-c' flag:</p>
<p class="Pp"></p>
<pre>    'CCFLAGS'        =&gt; '-x objective-c',
</pre>
<p class="Pp">Modify the contents of AddSystem.pm to contain:</p>
<p class="Pp"></p>
<pre>    package AddSystem;
    @ISA = qw(Exporter DynaLoader);
    @EXPORT = qw( );
    $VERSION = '1.0';
    bootstrap AddSystem $VERSION;
    use Foundation;
    1;
</pre>
<p class="Pp">and modify AddSystem.xs to have the contents:</p>
<p class="Pp"></p>
<pre>    #include &lt;mach-o/dyld.h&gt;
    #include &quot;EXTERN.h&quot;
    #include &quot;perl.h&quot;
    #include &quot;XSUB.h&quot;
    #ifdef Move
    #undef Move
    #endif Move
    #ifdef DEBUG
    #undef DEBUG
    #endif DEBUG
    #ifdef I_POLL
    #undef I_POLL
    #endif I_POLL
    #import &lt;Foundation/Foundation.h&gt;
    @interface AddClient : NSObject
    @end
    @implementation AddClient
    - (int)firstNumber { return 0; }
    - (int)secondNumber { return 0; }
    @end
    @interface AddServer: NSObject
    @end
    @implementation AddServer
    - (int)addNumbersForClient:(NSObject *)client { return 0; }
    @end
    MODULE = AddSystem          PACKAGE = AddSystem
</pre>
<p class="Pp">AddSystem.xs defines &quot;dummy&quot; AddClient and AddServer
    Objective-C classes that implement the methods that the Perl client and
    server will provide. These dummy Objective-C classes are needed in this case
    because there would otherwise not be enough information for the DO runtime
    system to determine the numbers, types, and sizes of the method arguments
    and return values. These dummy Objective-C implementations are usually only
    needed when DO is being used and the Perl program does not link against any
    libraries that contain objects that already implement the methods. The
    actual method bodies are irrelevant and can be trivially defined to return 0
    or NULL. In the case of methods that return void, the dummy methods can have
    empty bodies.</p>
<p class="Pp">After modifying Makefile.PL, AddSystem.pm, and AddSystem.xs,
    execute the following commands (as root or as an admin user):</p>
<p class="Pp"></p>
<pre>    perl Makefile.PL
    make install
</pre>
<p class="Pp">Now add two Perl programs to the AddSystem directory. The first
    program is addServer:</p>
<p class="Pp"></p>
<pre>    #!/usr/bin/perl
    use AddSystem;
    package AddServer;
    @ISA = qw(PerlObjCBridge);
    @EXPORT = qw( );
    PerlObjCBridge::preloadSelectors('AddClient');
    sub new
    {
        my $class = shift;
        my $self = {};
        bless $self, $class;
        return $self;
    }
    sub addNumbersForClient_
    {
        my($self, $client) = @_;
        my $first = $client-&gt;firstNumber();
        my $second = $client-&gt;secondNumber();
        return int($first + $second);
    }
    $server = new AddServer;
    $connection = NSConnection-&gt;defaultConnection();
    $connection-&gt;setRootObject_($server);
    $connection-&gt;registerName_(NSString-&gt;stringWithCString_(&quot;AddServer&quot;));
    NSRunLoop-&gt;currentRunLoop()-&gt;run();
</pre>
<p class="Pp">Make sure that the line &quot;#!/usr/bin/perl&quot; does not
    contain leading whitespace.</p>
<p class="Pp">The line:</p>
<p class="Pp"></p>
<pre>    use AddSystem;
</pre>
<p class="Pp">causes addServer to load the AddSystem XSUB module, which in turn
    loads the dummy AddClient and AddServer Objective-C classes, thus making
    them available to the DO runtime system. The lines:</p>
<p class="Pp"></p>
<pre>    package AddServer;
    @ISA = qw(PerlObjCBridge);
    @EXPORT = qw( );
</pre>
<p class="Pp">cause the AddServer package to inherit from PerlObjCBridge. As a
    consequence, messages to and from AddServer objects will be routed through
    PerlObjCBridge.</p>
<p class="Pp">The line:</p>
<p class="Pp"></p>
<pre>    PerlObjCBridge::preloadSelectors('AddClient');
</pre>
<p class="Pp">instructs PerlObjCBridge to pre-cache all method selectors for the
    Objective-C class AddClient. By doing this, PerlObjCBridge is
    &quot;primed&quot; with the information needed to send messages to objects
    of class AddClient.</p>
<p class="Pp">After a standard &quot;new&quot; constructor method, there is a
    addNumbersForClient_ method that provides the service vended by the
    AddServer class. The method name &quot;addNumbersForClient_&quot;
    corresponds to the Objective-C selector &quot;addNumbersForClient:&quot;,
    which has a dummy implementation in AddSystem.xs. In addition to the
    standard <span class="Li">$self</span> argument, addNumbersForClient_ takes
    a second argument <span class="Li">$client</span> which is a reference to
    the invoking client object. The client object is then sent the messages
    &quot;firstNumber&quot; and &quot;secondNumber&quot;, each of which returns
    an integer. The server adds the two numbers and returns the result.</p>
<p class="Pp">The lines:</p>
<p class="Pp"></p>
<pre>    $server = new AddServer;
    $connection = NSConnection-&gt;defaultConnection();
    $connection-&gt;setRootObject_($server);
    $connection-&gt;registerName_(NSString-&gt;stringWithCString_(&quot;AddServer&quot;));
</pre>
<p class="Pp">create a new AddServer object and set it as the root object of a
    DO connection, registered with the name &quot;AddServer&quot;. Clients can
    then look up the name &quot;AddServer&quot; to connect to this object.</p>
<p class="Pp">The final line:</p>
<p class="Pp"></p>
<pre>    NSRunLoop-&gt;currentRunLoop()-&gt;run();
</pre>
<p class="Pp">puts addServer into a event loop, waiting for incoming connections
    from clients.</p>
<p class="Pp">The second program, addClient, consists of:</p>
<p class="Pp"></p>
<pre>    #!/usr/bin/perl
    use AddSystem;
    package AddClient;
    @ISA = qw(PerlObjCBridge);
    @EXPORT = qw( );
    PerlObjCBridge::preloadSelectors('AddServer');
    sub new
    {
        my $class = shift;
        my $self = {};
        bless $self, $class;
        $self{'firstNumber'} = shift;
        $self{'secondNumber'} = shift;
        return $self;
    }
    sub firstNumber
    {
        my($self) = @_;
        return $self{'firstNumber'};
    }
    sub secondNumber
    {
        my($self) = @_;
        return $self{'secondNumber'};
    }
    die &quot;usage: perlClient &lt;firstNumber&gt; &lt;secondNumber&gt;\n&quot; unless @ARGV == 2;
    # create client
    $client = new AddClient (@ARGV);
    
    # create connection to server
    $name = NSString-&gt;stringWithCString_(&quot;AddServer&quot;);
    $server = NSConnection-&gt;rootProxyForConnectionWithRegisteredName_host_($name, 0);
    if (!$server or !$$server) {
        print &quot;Can't get server\n&quot;;
        exit(1);
    }
    $server-&gt;retain();
    
    printf &quot;%d\n&quot;, $server-&gt;addNumbersForClient_($client);
</pre>
<p class="Pp">Make sure that the line &quot;#!/usr/bin/perl&quot; does not
    contain leading whitespace.</p>
<p class="Pp">The AddClient methods &quot;firstNumber&quot; and
    &quot;secondNumber&quot; implement the call-back methods invoked by the
    AddServer. The lines:</p>
<p class="Pp"></p>
<pre>    $name = NSString-&gt;stringWithCString_(&quot;AddServer&quot;);
    $server = NSConnection-&gt;rootProxyForConnectionWithRegisteredName_host_($name, 0);
    if (!$server or !$$server) {
        print &quot;Can't get server\n&quot;;
        exit(1);
    }
    $server-&gt;retain();
</pre>
<p class="Pp">results in <span class="Li">$server</span> being assigned a DO
    &quot;proxy&quot; object for the AddServer object in the addServer program.
    Any messages sent by the client will by forwarded by the DO proxy to the
    actual AddServer object in the addServer address space.</p>
<p class="Pp">The final line:</p>
<p class="Pp"></p>
<pre>    printf &quot;%d\n&quot;, $server-&gt;addNumbersForClient_($client);
</pre>
<p class="Pp">invokes the AddServer object with a reference to the client
    object. The control flow that results is:</p>
<p class="Pp"></p>
<pre>    addClient sends &quot;addNumbersForClient:&quot; to addServer
    addServer sends &quot;firstNumber&quot; to addClient
    addClient returns first number
    addServer sends &quot;secondNumber&quot; to addClient
    addClient returns second number
    addServer returns sum of first and second number
</pre>
<p class="Pp">To execute these programs, first make sure addServer and addClient
    are executable:</p>
<p class="Pp"></p>
<pre>    chmod +x addServer addClient
</pre>
<p class="Pp">Next run the server in one shell:</p>
<p class="Pp"></p>
<pre>    addServer
</pre>
<p class="Pp">then the client in another shell:</p>
<p class="Pp"></p>
<pre>    addClient 1 2
    3
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTOMATIC_STRING_CONVERSION"><a class="permalink" href="#AUTOMATIC_STRING_CONVERSION">AUTOMATIC
  STRING CONVERSION</a></h1>
<p class="Pp">For convenience, PerlObjCBridge automatically converts Perl
    strings into NSString Objective-C objects when an NSObject is expected as
    the argument to an Objective-C method. For example, suppose an Objective-C
    dictionary is created:</p>
<p class="Pp"></p>
<pre>    $dict = NSMutableDictionary-&gt;dictionary();
</pre>
<p class="Pp">The dictionary method &quot;setObject:forKey:&quot; expects the
    key argument to be an NSString and the value argument to be any NSObject.
    The following automatically converts both &quot;aKey&quot; and
    &quot;aValue&quot; to NSStrings and then inserts the pair into the
    dictionary:</p>
<p class="Pp"></p>
<pre>    $dict-&gt;setObject_forKey_(&quot;aValue&quot;, &quot;aKey&quot;);
</pre>
<p class="Pp">The value can be retrieved as follows, where &quot;aKey&quot; is
    again automatically converted to an NSString:</p>
<p class="Pp"></p>
<pre>    $value = $dict-&gt;objectForKey_(&quot;aKey&quot;);
    printf &quot;value is %s\n&quot;, $value-&gt;cString();
</pre>
<p class="Pp">Note that the return value assigned to
    <span class="Li">$value</span> is a reference to an NSString and is not
    automatically converted to a Perl string. The automatic conversions occur
    only from Perl strings to NSStrings for Objective-C method arguments.
    NSStrings return values are not automatically converted to Perl strings.</p>
<p class="Pp">Automatic conversion also occurs when a Perl string is passed as
    an argument to a method that expects an Objective-C selector. For example,
    the &quot;performSelector:&quot; message can be sent to any NSObject. The
    argument to the &quot;performSelector:&quot; message must be an Objective-C
    selector. In Objective-C, one can copy an existing NSString
    &quot;origString&quot; by asking it to perform the &quot;copy&quot;
    selector:</p>
<p class="Pp"></p>
<pre>    copy = [origString performSelector:@selector(copy)];
</pre>
<p class="Pp">This is equivalent to:</p>
<p class="Pp"></p>
<pre>    copy = [origString copy];
</pre>
<p class="Pp">In Perl the selector form can be executed as:</p>
<p class="Pp"></p>
<pre>    $copy = $origString-&gt;performSelector_(&quot;copy&quot;);
</pre>
<p class="Pp">In this case the Perl string &quot;copy&quot; is automatically
    converted to an Objective-C selector.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NIL_ARGUMENTS_AND_RETURN_VALUES"><a class="permalink" href="#NIL_ARGUMENTS_AND_RETURN_VALUES">NIL
  ARGUMENTS AND RETURN VALUES</a></h1>
<p class="Pp">It is sometimes necessary to pass the Objective-C object ID
    &quot;nil&quot; (a null pointer) as an argument to an Objective-C method.
    Since PerlObjCBridge represents Objective-C ID's as Perl references,
    strictly speaking the Perl value 0 is not a legal representation for
    Objective-C's nil because it is a simple scalar, not a reference. However,
    for convenience, when an argument to an Objective-C method is expected to be
    an object ID and the value 0 is passed from Perl, PerlObjCBridge coerces the
    0 value to a reference to a zero-valued scalar and the Objective-C method
    receives nil for that argument. In the following example, the Objective-c
    method &quot;arg1:optionalArg:&quot; would receive nil as its second
    argument.</p>
<p class="Pp"></p>
<pre>    MyClass-&gt;arg1_optionalArg_($obj, 0);
</pre>
<p class="Pp">The special value &quot;undef&quot; can also be used:</p>
<p class="Pp"></p>
<pre>    MyClass-&gt;arg1_optionalArg_($obj, undef);
</pre>
<p class="Pp">When an Objective-C method returns nil, the corresponding Perl
    return value is a reference to a zero-valued scalar. This return value can
    subsequently be passed as an argument to an Objective-C method. In the
    following example, if &quot;aMethod&quot; returns nil then
    &quot;arg1:optionalArg:&quot; would receive nil as its second argument:</p>
<p class="Pp"></p>
<pre>    MyClass-&gt;arg1_optionalArg_($obj, YourClass-&gt;aMethod());
</pre>
<p class="Pp">To determine whether an Objective-C method returned nil one should
    test both the Perl reference and its referent. The referent will be
    zero-valued when the Objective-C method returned nil, but it is also
    possible for the reference itself to be undefined (for example, when the
    method raised an NSException, as discussed below). The following example
    illustrates the use of an Objective-C NSEnumerator object to print the
    elements of an NSArray. In Objective-C, the enumerator returns nil after the
    last object in the array has been enumerated. In the Perl loop, both the
    reference <span class="Li">$obj</span> and the referent $$obj are tested in
    the loop condition. Under normal circumstances looping ends when $$obj
    becomes zero-valued, indicating the enumerator returned nil.</p>
<p class="Pp"></p>
<pre>    $enumerator = $array-&gt;objectEnumerator();
    while ($obj = $enumerator-&gt;nextObject() and $$obj) {
        printf &quot;%s\n&quot;, $obj-&gt;description()-&gt;cString();
    }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="ARGUMENTS_THAT_RETURN_OBJECTS_BY_REFERENCE"><a class="permalink" href="#ARGUMENTS_THAT_RETURN_OBJECTS_BY_REFERENCE">ARGUMENTS
  THAT RETURN OBJECTS BY REFERENCE</a></h1>
<p class="Pp">Sometimes Objective-C methods return objects to the caller using
    return-by-reference arguments. For example, the following method defines an
    argument that returns an NSError object by reference.</p>
<p class="Pp"></p>
<pre>    - (BOOL)doSomethingAndReturnError:(NSError **)error;
</pre>
<p class="Pp">When the doSomethingAndReturnError: method fails it returns a
    Boolean value of NO and (optionally) also returns a by-reference NSError
    argument. An Objective-C caller of this method will typically do something
    like the following.</p>
<p class="Pp"></p>
<pre>    NSError *error = nil;
    BOOL result = [anObject doSomethingAndReturnError:&amp;error];
    if ( ! result ) {
        if ( error ) {
            NSLog(@&quot;error code is %d&quot;, [error code]);
        }
    }
</pre>
<p class="Pp">Return-by-reference arguments can be used from Perl as illustrated
    by the following example.</p>
<p class="Pp"></p>
<pre>    my $errorVal;                   # declare $errorVal as an uninitialized scalar
    my $error = \$errorVal;         # initialize $error as a reference to $errorVal
    
    my $result = $anObject-&gt;doSomethingAndReturnError_($error);
    if ( ! $result ) {
        if ( $$error ) {
            printf &quot;error code is %d\n&quot;, $error-&gt;code( );
        }
    }
</pre>
<p class="Pp">Note: the following does not work.</p>
<p class="Pp"></p>
<pre>    my $errorVal;
    my $result = $anObject-&gt;doSomethingAndReturnError_($errorVal);
</pre>
<p class="Pp">The following does not work either.</p>
<p class="Pp"></p>
<pre>    my $errorVal;
    my $result = $anObject-&gt;doSomethingAndReturnError_(\$errorVal);
</pre>
<p class="Pp">Pass undef to avoid returning the Objective-C object:</p>
<p class="Pp"></p>
<pre>    my $result = $anObject-&gt;doSomethingAndReturnError_(undef);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="POINTERS_TO_BUFFERS"><a class="permalink" href="#POINTERS_TO_BUFFERS">POINTERS
  TO BUFFERS</a></h1>
<p class="Pp">For Objective-C methods such as -[NSData getBytes:length:] it is
    necessary to pass an argument that represents a pointer to a buffer of known
    length. This may be accomplished using the <b>pack()</b> and <b>unpack()</b>
    functions, as shown in the following example. The &quot;L!&quot; template
    forces the <b>unpack()</b> function to return a native-length unsigned long
    value, which is always the same size as a pointer in Mac OS X.</p>
<p class="Pp">In this example, assume <span class="Li">$nsData</span> points to
    a valid NSData object:</p>
<p class="Pp"></p>
<pre>    my $buffer;
    if ($nsData &amp;&amp; $$nsData) {
        my $length = $nsData-&gt;length();
        $buffer = '\0' x $length;
        my $pointerToBuffer = unpack(&quot;L!&quot;, pack(&quot;p&quot;, $buffer));
        $nsData-&gt;getBytes_length_($pointerToBuffer, $length);
    }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="EXCEPTION_HANDLING"><a class="permalink" href="#EXCEPTION_HANDLING">EXCEPTION
  HANDLING</a></h1>
<p class="Pp">NSExceptions that are raised as a result of messages sent by Perl
    programs to Objective-C objects are dealt with as follows. PerlObjCBridge
    has a built-in NSException handler that writes the message selector, the
    class of the target object, and the NSException name, reason, and userInfo
    to standard error. By default, the built-in NSException handler then dies
    with a message. The function <b>PerlObjCBridge::setDieOnExceptions()</b> can
    be used to control the latter behavior. Invoking <b>setDieOnExceptions()</b>
    with an argument of 0 will cause the built-in exception handler to issue a
    warning and return without dying, whereas a non-zero argument (or no
    argument) will cause the built-in exception handler to die. In the case
    where the built-in exception handler returns with a warning, the original
    message that caused the exception returns undef.</p>
<p class="Pp">Alternatively, the Perl program can set its own exception handler
    by calling <b>PerlObjCBridge::setNSExceptionHandler()</b> with a single
    argument that must be a reference to a Perl function that acts as the
    exception handler. The Perl program can get a reference to the current
    exception handler by calling <b>PerlObjCBridge::getNSExceptionHandler()</b>.
    If a user-defined exception handler is set and an NSException is raised then
    the user-defined handler will be called with five string arguments: (1) the
    Objective-C selector for the message that induced the NSException, (2) the
    class name of the object to which the message was sent, and (3,4,5) the
    NSException name, reason, and userInfo (the latter represented as the string
    [userInfo description]). If the user-defined exception handler returns, then
    the original message returns undef. When a user-defined exception handler is
    set, it is up to the handler to decide whether the program exits or
    continues when NSExceptions are raised (i.e., when a user-defined exception
    handler is set the function <b>setDieOnExceptions()</b> has no effect).</p>
<p class="Pp">The example below stores the original exception handler, sets a
    new exception handler, provokes an NSException by attempting to set a
    dictionary entry with a nil key and a nil value, and then restores the
    original exception handler.</p>
<p class="Pp"></p>
<pre>   sub myHandler
   {
       my($sel, $pkg, $name, $reason, $userInfo) = @_;
       print &quot;NSException raised!\n&quot;;
       print &quot;selector:  $selector\n&quot;;
       print &quot;package:   $package\n&quot;;
       print &quot;name:      $name\n&quot;;
       print &quot;reason:    $reason\n&quot;;
       print &quot;userInfo:  $userInfo\n&quot;;
   }
   $oldHandler = PerlObjCBridge::getNSExceptionHandler();
   PerlObjCBridge::setNSExceptionHandler(\&amp;myHandler);
   $dict = NSMutableDictionary-&gt;dictionary();
   $dict-&gt;setObject_forKey_(0, 0);
   PerlObjCBridge::setNSExceptionHandler($oldHandler);
</pre>
<p class="Pp">This results in myHandler printing the output:</p>
<p class="Pp"></p>
<pre>   NSException raised!
   selector:     setObject:forKey:
   target class: NSCFDictionary 
   name:         NSInvalidArgumentException
   reason:       *** -[NSCFDictionary setObject:forKey:]: attempt to insert nil key
   userInfo:
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="LARGE_NUMERIC_VALUES"><a class="permalink" href="#LARGE_NUMERIC_VALUES">LARGE
  NUMERIC VALUES</a></h1>
<p class="Pp">PerlObjCBridge assumes no Perl support for 64-bit integers. When
    an Objective-C method has a 64-bit integer return type (i.e., long long or
    unsigned long long) and the result of invoking that method is a return value
    that is too large (i.e., &gt;= 2^^31) or too small (&lt;= -(2^^31)) to be
    represented in Perl as a signed integer then the value is returned as a Perl
    double. Similarly, when a parameter to an Objective-C method is a long long
    or unsigned long long then the type of the Perl argument value is examined.
    If the argument value is a Perl integer then its value is passed directly to
    the Objective-C method in long long or unsigned long long form (coercing in
    the unsigned case). Otherwise if the argument value is a Perl double then it
    is coerced to the appropriate long long or unsigned long long form before it
    is passed to the method.</p>
<p class="Pp">Similar considerations apply to 32-bit unsigned longs and unsigned
    ints. When an Objective-C method has a 32-bit unsigned long or unsigned int
    return type and the result of invoking that method is a return value that is
    too large (&gt;= 2^^31) to be represented in Perl as a signed integer then
    the value is returned as a Perl double. When a parameter to an Objective-C
    method is a 32-bit unsigned long or unsigned int then the Perl int or float
    argument is simply coerced to the unsigned long or int. This can of course
    have unpleasant consequences if the Perl argument is negative or larger than
    2^^32.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTROL_FUNCTIONS"><a class="permalink" href="#CONTROL_FUNCTIONS">CONTROL
  FUNCTIONS</a></h1>
<p class="Pp">Calling <b>PerlObjCBridge::setTracing()</b> with a non-zero
    argument (or no argument) will cause PerlObjCBridge to log diagnostic
    messages as it executes. Calling <b>setTracing()</b> with an argument of
    zero turns the diagnostics off.</p>
<p class="Pp">Calling <b>PerlObjCBridge::setDieOnErrors()</b> with a non-zero
    argument (or no argument) will cause PerlObjCBridge to die with a warning
    message whenever there is an error during the sending of an Objective-C
    message (this is the default behavior). Calling <b>setDieOnErrors()</b> with
    an argument of zero allows the program to print a warning message but not
    die after such an error.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS_AND_LIMITATIONS"><a class="permalink" href="#BUGS_AND_LIMITATIONS">BUGS
  AND LIMITATIONS</a></h1>
<p class="Pp">PerlObjCBridge should take advantage of Perl support for 64-bit
    integers if available. Feel free to fix this.</p>
<p class="Pp">When structs are passed by value, sometimes pointers embedded in
    the structs get mangled. It is better to pass structs by reference if they
    contain embedded pointers.</p>
<p class="Pp">Varargs-style messaging is not supported. This is unfortunate, but
    it's due to the lack of varargs support in NSInvocation and
    NSMethodSignature. Fix that and it should be easy to support varargs
    messaging in PerlObjCBridge.</p>
<p class="Pp">Access to functions, variables, and other non-object-oriented
    constructs exported by libraries containing Objective-C is not currently
    supported. It seems dubious that those things are exported as C-level
    constructs to begin with, when they could/should be Objective-C class
    methods. One possible workaround is to create an XSUB that provides
    Objective-C &quot;covers&quot; for these items. For example, if a library
    exports a variable:</p>
<p class="Pp"></p>
<pre>    extern int GreatBigFoo;
</pre>
<p class="Pp">then an XSUB with a cover might define:</p>
<p class="Pp"></p>
<pre>    @interface Covers: NSObject
    + (int)GreatBigFoo;
    @end
    
    @implementation Covers
    + (int)GreatBigFoo
    {
        return GreatBigFoo;
    }
    @end
</pre>
<p class="Pp">Then the value of the variable could be accessed in Perl:</p>
<p class="Pp"></p>
<pre>    $gbf = Covers::GreatBigFoo();
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>perl</b>(1). Mac OS X:
    /Developer/Documentation/Cocoa/ObjectiveC Mac OS X:
    /Developer/Documentation/Cocoa/Reference/Foundation</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2023-10-12</td>
    <td class="foot-os">perl v5.34.1</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>IO::Socket::IP(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">IO::Socket::IP(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">IO::Socket::IP(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">&quot;IO::Socket::IP&quot; - Family-neutral IP socket supporting
    both IPv4 and IPv6</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre> use IO::Socket::IP;
 my $sock = IO::Socket::IP-&gt;new(
    PeerHost =&gt; &quot;www.google.com&quot;,
    PeerPort =&gt; &quot;http&quot;,
    Type     =&gt; SOCK_STREAM,
 ) or die &quot;Cannot construct socket - $@&quot;;
 my $familyname = ( $sock-&gt;sockdomain == PF_INET6 ) ? &quot;IPv6&quot; :
                  ( $sock-&gt;sockdomain == PF_INET  ) ? &quot;IPv4&quot; :
                                                      &quot;unknown&quot;;
 printf &quot;Connected to google via %s\n&quot;, $familyname;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module provides a protocol-independent way to use IPv4 and
    IPv6 sockets, intended as a replacement for IO::Socket::INET. Most
    constructor arguments and methods are provided in a backward-compatible way.
    For a list of known differences, see the
    <span class="Li">&quot;IO::Socket::INET&quot;</span> INCOMPATIBILITES
    section below.</p>
<p class="Pp">It uses the <span class="Li">getaddrinfo(3)</span> function to
    convert hostnames and service names or port numbers into sets of possible
    addresses to connect to or listen on. This allows it to work for IPv6 where
    the system supports it, while still falling back to IPv4-only on systems
    which don't.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="REPLACING__IO::Socket__DEFAULT_BEHAVIOUR"><a class="permalink" href="#REPLACING__IO::Socket__DEFAULT_BEHAVIOUR">REPLACING
  &quot;IO::Socket&quot; DEFAULT BEHAVIOUR</a></h1>
<p class="Pp">By placing <span class="Li">&quot;-register&quot;</span> in the
    import list to <span class="Li">&quot;IO::Socket::IP&quot;</span>, it will
    register itself with IO::Socket as the class that handles
    <span class="Li">&quot;PF_INET&quot;</span>. It will also ask to handle
    <span class="Li">&quot;PF_INET6&quot;</span> as well, provided that constant
    is available.</p>
<p class="Pp">Changing <span class="Li">&quot;IO::Socket&quot;</span>'s default
    behaviour means that calling the
    <span class="Li">&quot;IO::Socket&quot;</span> constructor with either
    <span class="Li">&quot;PF_INET&quot;</span> or
    <span class="Li">&quot;PF_INET6&quot;</span> as the
    <span class="Li">&quot;Domain&quot;</span> parameter will yield an
    <span class="Li">&quot;IO::Socket::IP&quot;</span> object.</p>
<p class="Pp"></p>
<pre> use IO::Socket::IP -register;
 my $sock = IO::Socket-&gt;new(
    Domain    =&gt; PF_INET6,
    LocalHost =&gt; &quot;::1&quot;,
    Listen    =&gt; 1,
 ) or die &quot;Cannot create socket - $@\n&quot;;
 print &quot;Created a socket of type &quot; . ref($sock) . &quot;\n&quot;;
</pre>
<p class="Pp">Note that <span class="Li">&quot;-register&quot;</span> is a
    global setting that applies to the entire program; it cannot be applied only
    for certain callers, removed, or limited by lexical scope.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONSTRUCTORS"><a class="permalink" href="#CONSTRUCTORS">CONSTRUCTORS</a></h1>
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
<pre>   $sock = IO::Socket::IP-&gt;new( %args )
</pre>
<p class="Pp">Creates a new <span class="Li">&quot;IO::Socket::IP&quot;</span>
    object, containing a newly created socket handle according to the named
    arguments passed. The recognised arguments are:</p>
<dl class="Bl-tag">
  <dt id="PeerHost"><a class="permalink" href="#PeerHost">PeerHost =&gt;
    STRING</a></dt>
  <dd></dd>
  <dt id="PeerService"><a class="permalink" href="#PeerService">PeerService
    =&gt; STRING</a></dt>
  <dd>Hostname and service name for the peer to
      <span class="Li">&quot;connect()&quot;</span> to. The service name may be
      given as a port number, as a decimal string.</dd>
  <dt id="PeerAddr"><a class="permalink" href="#PeerAddr">PeerAddr =&gt;
    STRING</a></dt>
  <dd></dd>
  <dt id="PeerPort"><a class="permalink" href="#PeerPort">PeerPort =&gt;
    STRING</a></dt>
  <dd>For symmetry with the accessor methods and compatibility with
      <span class="Li">&quot;IO::Socket::INET&quot;</span>, these are accepted
      as synonyms for <span class="Li">&quot;PeerHost&quot;</span> and
      <span class="Li">&quot;PeerService&quot;</span> respectively.</dd>
  <dt id="PeerAddrInfo"><a class="permalink" href="#PeerAddrInfo">PeerAddrInfo
    =&gt; ARRAY</a></dt>
  <dd>Alternate form of specifying the peer to
      <span class="Li">&quot;connect()&quot;</span> to. This should be an array
      of the form returned by
      <span class="Li">&quot;Socket::getaddrinfo&quot;</span>.
    <p class="Pp">This parameter takes precedence over the
        <span class="Li">&quot;Peer*&quot;</span>,
        <span class="Li">&quot;Family&quot;</span>,
        <span class="Li">&quot;Type&quot;</span> and
        <span class="Li">&quot;Proto&quot;</span> arguments.</p>
  </dd>
  <dt id="LocalHost"><a class="permalink" href="#LocalHost">LocalHost =&gt;
    STRING</a></dt>
  <dd></dd>
  <dt id="LocalService"><a class="permalink" href="#LocalService">LocalService
    =&gt; STRING</a></dt>
  <dd>Hostname and service name for the local address to
      <span class="Li">&quot;bind()&quot;</span> to.</dd>
  <dt id="LocalAddr"><a class="permalink" href="#LocalAddr">LocalAddr =&gt;
    STRING</a></dt>
  <dd></dd>
  <dt id="LocalPort"><a class="permalink" href="#LocalPort">LocalPort =&gt;
    STRING</a></dt>
  <dd>For symmetry with the accessor methods and compatibility with
      <span class="Li">&quot;IO::Socket::INET&quot;</span>, these are accepted
      as synonyms for <span class="Li">&quot;LocalHost&quot;</span> and
      <span class="Li">&quot;LocalService&quot;</span> respectively.</dd>
  <dt id="LocalAddrInfo"><a class="permalink" href="#LocalAddrInfo">LocalAddrInfo
    =&gt; ARRAY</a></dt>
  <dd>Alternate form of specifying the local address to
      <span class="Li">&quot;bind()&quot;</span> to. This should be an array of
      the form returned by
      <span class="Li">&quot;Socket::getaddrinfo&quot;</span>.
    <p class="Pp">This parameter takes precedence over the
        <span class="Li">&quot;Local*&quot;</span>,
        <span class="Li">&quot;Family&quot;</span>,
        <span class="Li">&quot;Type&quot;</span> and
        <span class="Li">&quot;Proto&quot;</span> arguments.</p>
  </dd>
  <dt id="Family"><a class="permalink" href="#Family">Family =&gt; INT</a></dt>
  <dd>The address family to pass to
      <span class="Li">&quot;getaddrinfo&quot;</span> (e.g.
      <span class="Li">&quot;AF_INET&quot;</span>,
      <span class="Li">&quot;AF_INET6&quot;</span>). Normally this will be left
      undefined, and <span class="Li">&quot;getaddrinfo&quot;</span> will search
      using any address family supported by the system.</dd>
  <dt id="Type"><a class="permalink" href="#Type">Type =&gt; INT</a></dt>
  <dd>The socket type to pass to <span class="Li">&quot;getaddrinfo&quot;</span>
      (e.g. <span class="Li">&quot;SOCK_STREAM&quot;</span>,
      <span class="Li">&quot;SOCK_DGRAM&quot;</span>). Normally defined by the
      caller; if left undefined <span class="Li">&quot;getaddrinfo&quot;</span>
      may attempt to infer the type from the service name.</dd>
  <dt id="Proto"><a class="permalink" href="#Proto">Proto =&gt; STRING or
    INT</a></dt>
  <dd>The IP protocol to use for the socket (e.g. <span class="Li">'tcp'</span>,
      <span class="Li">&quot;IPPROTO_TCP&quot;</span>,
      <span class="Li">'udp'</span>,<span class="Li">&quot;IPPROTO_UDP&quot;</span>).
      Normally this will be left undefined, and either
      <span class="Li">&quot;getaddrinfo&quot;</span> or the kernel will choose
      an appropriate value. May be given either in string name or numeric
    form.</dd>
  <dt id="GetAddrInfoFlags"><a class="permalink" href="#GetAddrInfoFlags">GetAddrInfoFlags
    =&gt; INT</a></dt>
  <dd>More flags to pass to the
      <span class="Li">&quot;getaddrinfo()&quot;</span> function. If not
      supplied, a default of <span class="Li">&quot;AI_ADDRCONFIG&quot;</span>
      will be used.
    <p class="Pp">These flags will be combined with
        <span class="Li">&quot;AI_PASSIVE&quot;</span> if the
        <span class="Li">&quot;Listen&quot;</span> argument is given. For more
        information see the documentation about
        <span class="Li">&quot;getaddrinfo()&quot;</span> in the Socket
      module.</p>
  </dd>
  <dt id="Listen"><a class="permalink" href="#Listen">Listen =&gt; INT</a></dt>
  <dd>If defined, puts the socket into listening mode where new connections can
      be accepted using the <span class="Li">&quot;accept&quot;</span> method.
      The value given is used as the <span class="Li">listen(2)</span> queue
      size.</dd>
  <dt id="ReuseAddr"><a class="permalink" href="#ReuseAddr">ReuseAddr =&gt;
    BOOL</a></dt>
  <dd>If true, set the <span class="Li">&quot;SO_REUSEADDR&quot;</span>
    sockopt</dd>
  <dt id="ReusePort"><a class="permalink" href="#ReusePort">ReusePort =&gt;
    BOOL</a></dt>
  <dd>If true, set the <span class="Li">&quot;SO_REUSEPORT&quot;</span> sockopt
      (not all OSes implement this sockopt)</dd>
  <dt id="Broadcast"><a class="permalink" href="#Broadcast">Broadcast =&gt;
    BOOL</a></dt>
  <dd>If true, set the <span class="Li">&quot;SO_BROADCAST&quot;</span>
    sockopt</dd>
  <dt id="Sockopts"><a class="permalink" href="#Sockopts">Sockopts =&gt;
    ARRAY</a></dt>
  <dd>An optional array of other socket options to apply after the three listed
      above. The value is an ARRAY containing 2- or 3-element ARRAYrefs. Each
      inner array relates to a single option, giving the level and option name,
      and an optional value. If the value element is missing, it will be given
      the value of a platform-sized integer 1 constant (i.e. suitable to enable
      most of the common boolean options).
    <p class="Pp">For example, both options given below are equivalent to
        setting <span class="Li">&quot;ReuseAddr&quot;</span>.</p>
    <p class="Pp"></p>
    <pre> Sockopts =&gt; [
    [ SOL_SOCKET, SO_REUSEADDR ],
    [ SOL_SOCKET, SO_REUSEADDR, pack( &quot;i&quot;, 1 ) ],
 ]
    </pre>
  </dd>
  <dt id="V6Only"><a class="permalink" href="#V6Only">V6Only =&gt; BOOL</a></dt>
  <dd>If defined, set the <span class="Li">&quot;IPV6_V6ONLY&quot;</span>
      sockopt when creating <span class="Li">&quot;PF_INET6&quot;</span> sockets
      to the given value. If true, a listening-mode socket will only listen on
      the <span class="Li">&quot;AF_INET6&quot;</span> addresses; if false it
      will also accept connections from
      <span class="Li">&quot;AF_INET&quot;</span> addresses.
    <p class="Pp">If not defined, the socket option will not be changed, and
        default value set by the operating system will apply. For repeatable
        behaviour across platforms it is recommended this value always be
        defined for listening-mode sockets.</p>
    <p class="Pp">Note that not all platforms support disabling this option.
        Some, at least OpenBSD and MirBSD, will fail with
        <span class="Li">&quot;EINVAL&quot;</span> if you attempt to disable it.
        To determine whether it is possible to disable, you may use the class
        method</p>
    <p class="Pp"></p>
    <pre> if( IO::Socket::IP-&gt;CAN_DISABLE_V6ONLY ) {
    ...
 }
 else {
    ...
 }
    </pre>
    <p class="Pp">If your platform does not support disabling this option but
        you still want to listen for both
        <span class="Li">&quot;AF_INET&quot;</span> and
        <span class="Li">&quot;AF_INET6&quot;</span> connections you will have
        to create two listening sockets, one bound to each protocol.</p>
  </dd>
  <dt id="MultiHomed"><a class="permalink" href="#MultiHomed">MultiHomed</a></dt>
  <dd>This <span class="Li">&quot;IO::Socket::INET&quot;</span>-style argument
      is ignored, except if it is defined but false. See the
      <span class="Li">&quot;IO::Socket::INET&quot;</span> INCOMPATIBILITES
      section below.
    <p class="Pp">However, the behaviour it enables is always performed by
        <span class="Li">&quot;IO::Socket::IP&quot;</span>.</p>
  </dd>
  <dt id="Blocking"><a class="permalink" href="#Blocking">Blocking =&gt;
    BOOL</a></dt>
  <dd>If defined but false, the socket will be set to non-blocking mode.
      Otherwise it will default to blocking mode. See the NON-BLOCKING section
      below for more detail.</dd>
  <dt id="Timeout"><a class="permalink" href="#Timeout">Timeout =&gt;
    NUM</a></dt>
  <dd>If defined, gives a maximum time in seconds to block per
      <span class="Li">&quot;connect()&quot;</span> call when in blocking mode.
      If missing, no timeout is applied other than that provided by the
      underlying operating system. When in non-blocking mode this parameter is
      ignored.
    <p class="Pp">Note that if the hostname resolves to multiple address
        candidates, the same timeout will apply to each connection attempt
        individually, rather than to the operation as a whole. Further note that
        the timeout does not apply to the initial hostname resolve operation, if
        connecting by hostname.</p>
    <p class="Pp">This behviour is copied inspired by
        <span class="Li">&quot;IO::Socket::INET&quot;</span>; for more fine
        grained control over connection timeouts, consider performing a
        nonblocking connect directly.</p>
  </dd>
</dl>
<p class="Pp">If neither <span class="Li">&quot;Type&quot;</span> nor
    <span class="Li">&quot;Proto&quot;</span> hints are provided, a default of
    <span class="Li">&quot;SOCK_STREAM&quot;</span> and
    <span class="Li">&quot;IPPROTO_TCP&quot;</span> respectively will be set, to
    maintain compatibility with
    <span class="Li">&quot;IO::Socket::INET&quot;</span>. Other named arguments
    that are not recognised are ignored.</p>
<p class="Pp">If neither <span class="Li">&quot;Family&quot;</span> nor any
    hosts or addresses are passed, nor any <span class="Li">*AddrInfo</span>,
    then the constructor has no information on which to decide a socket family
    to create. In this case, it performs a
    <span class="Li">&quot;getaddinfo&quot;</span> call with the
    <span class="Li">&quot;AI_ADDRCONFIG&quot;</span> flag, no host name, and a
    service name of <span class="Li">&quot;0&quot;</span>, and uses the family
    of the first returned result.</p>
<p class="Pp">If the constructor fails, it will set <span class="Li">$@</span>
    to an appropriate error message; this may be from <span class="Li">$!</span>
    or it may be some other string; not every failure necessarily has an
    associated <span class="Li">&quot;errno&quot;</span> value.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="new_(one_arg)"><a class="permalink" href="#new_(one_arg)">new
  (one arg)</a></h2>
<pre>   $sock = IO::Socket::IP-&gt;new( $peeraddr )
</pre>
<p class="Pp">As a special case, if the constructor is passed a single argument
    (as opposed to an even-sized list of key/value pairs), it is taken to be the
    value of the <span class="Li">&quot;PeerAddr&quot;</span> parameter. This is
    parsed in the same way, according to the behaviour given in the
    <span class="Li">&quot;PeerHost&quot;</span> AND
    <span class="Li">&quot;LocalHost&quot;</span> PARSING section below.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<p class="Pp">As well as the following methods, this class inherits all the
    methods in IO::Socket and IO::Handle.</p>
<section class="Ss">
<h2 class="Ss" id="sockhost_service"><a class="permalink" href="#sockhost_service">sockhost_service</a></h2>
<pre>   ( $host, $service ) = $sock-&gt;sockhost_service( $numeric )
</pre>
<p class="Pp">Returns the hostname and service name of the local address (that
    is, the socket address given by the
    <span class="Li">&quot;sockname&quot;</span> method).</p>
<p class="Pp">If <span class="Li">$numeric</span> is true, these will be given
    in numeric form rather than being resolved into names.</p>
<p class="Pp">The following four convenience wrappers may be used to obtain one
    of the two values returned here. If both host and service names are
    required, this method is preferable to the following wrappers, because it
    will call <span class="Li">getnameinfo(3)</span> only once.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="sockhost"><a class="permalink" href="#sockhost">sockhost</a></h2>
<pre>   $addr = $sock-&gt;sockhost
</pre>
<p class="Pp">Return the numeric form of the local address as a textual
    representation</p>
</section>
<section class="Ss">
<h2 class="Ss" id="sockport"><a class="permalink" href="#sockport">sockport</a></h2>
<pre>   $port = $sock-&gt;sockport
</pre>
<p class="Pp">Return the numeric form of the local port number</p>
</section>
<section class="Ss">
<h2 class="Ss" id="sockhostname"><a class="permalink" href="#sockhostname">sockhostname</a></h2>
<pre>   $host = $sock-&gt;sockhostname
</pre>
<p class="Pp">Return the resolved name of the local address</p>
</section>
<section class="Ss">
<h2 class="Ss" id="sockservice"><a class="permalink" href="#sockservice">sockservice</a></h2>
<pre>   $service = $sock-&gt;sockservice
</pre>
<p class="Pp">Return the resolved name of the local port number</p>
</section>
<section class="Ss">
<h2 class="Ss" id="sockaddr"><a class="permalink" href="#sockaddr">sockaddr</a></h2>
<pre>   $addr = $sock-&gt;sockaddr
</pre>
<p class="Pp">Return the local address as a binary octet string</p>
</section>
<section class="Ss">
<h2 class="Ss" id="peerhost_service"><a class="permalink" href="#peerhost_service">peerhost_service</a></h2>
<pre>   ( $host, $service ) = $sock-&gt;peerhost_service( $numeric )
</pre>
<p class="Pp">Returns the hostname and service name of the peer address (that
    is, the socket address given by the
    <span class="Li">&quot;peername&quot;</span> method), similar to the
    <span class="Li">&quot;sockhost_service&quot;</span> method.</p>
<p class="Pp">The following four convenience wrappers may be used to obtain one
    of the two values returned here. If both host and service names are
    required, this method is preferable to the following wrappers, because it
    will call <span class="Li">getnameinfo(3)</span> only once.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="peerhost"><a class="permalink" href="#peerhost">peerhost</a></h2>
<pre>   $addr = $sock-&gt;peerhost
</pre>
<p class="Pp">Return the numeric form of the peer address as a textual
    representation</p>
</section>
<section class="Ss">
<h2 class="Ss" id="peerport"><a class="permalink" href="#peerport">peerport</a></h2>
<pre>   $port = $sock-&gt;peerport
</pre>
<p class="Pp">Return the numeric form of the peer port number</p>
</section>
<section class="Ss">
<h2 class="Ss" id="peerhostname"><a class="permalink" href="#peerhostname">peerhostname</a></h2>
<pre>   $host = $sock-&gt;peerhostname
</pre>
<p class="Pp">Return the resolved name of the peer address</p>
</section>
<section class="Ss">
<h2 class="Ss" id="peerservice"><a class="permalink" href="#peerservice">peerservice</a></h2>
<pre>   $service = $sock-&gt;peerservice
</pre>
<p class="Pp">Return the resolved name of the peer port number</p>
</section>
<section class="Ss">
<h2 class="Ss" id="peeraddr"><a class="permalink" href="#peeraddr">peeraddr</a></h2>
<pre>   $addr = $peer-&gt;peeraddr
</pre>
<p class="Pp">Return the peer address as a binary octet string</p>
</section>
<section class="Ss">
<h2 class="Ss" id="as_inet"><a class="permalink" href="#as_inet">as_inet</a></h2>
<pre>   $inet = $sock-&gt;as_inet
</pre>
<p class="Pp">Returns a new IO::Socket::INET instance wrapping the same
    filehandle. This may be useful in cases where it is required, for
    backward-compatibility, to have a real object of
    <span class="Li">&quot;IO::Socket::INET&quot;</span> type instead of
    <span class="Li">&quot;IO::Socket::IP&quot;</span>. The new object will wrap
    the same underlying socket filehandle as the original, so care should be
    taken not to continue to use both objects concurrently. Ideally the original
    <span class="Li">$sock</span> should be discarded after this method is
    called.</p>
<p class="Pp">This method checks that the socket domain is
    <span class="Li">&quot;PF_INET&quot;</span> and will throw an exception if
    it isn't.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="NON-BLOCKING"><a class="permalink" href="#NON-BLOCKING">NON-BLOCKING</a></h1>
<p class="Pp">If the constructor is passed a defined but false value for the
    <span class="Li">&quot;Blocking&quot;</span> argument then the socket is put
    into non-blocking mode. When in non-blocking mode, the socket will not be
    set up by the time the constructor returns, because the underlying
    <span class="Li">connect(2)</span> syscall would otherwise have to
  block.</p>
<p class="Pp">The non-blocking behaviour is an extension of the
    <span class="Li">&quot;IO::Socket::INET&quot;</span> API, unique to
    <span class="Li">&quot;IO::Socket::IP&quot;</span>, because the former does
    not support multi-homed non-blocking connect.</p>
<p class="Pp">When using non-blocking mode, the caller must repeatedly check for
    writeability on the filehandle (for instance using
    <span class="Li">&quot;select&quot;</span> or
    <span class="Li">&quot;IO::Poll&quot;</span>). Each time the filehandle is
    ready to write, the <span class="Li">&quot;connect&quot;</span> method must
    be called, with no arguments. Note that some operating systems, most notably
    <span class="Li">&quot;MSWin32&quot;</span> do not report a
    <span class="Li">&quot;connect()&quot;</span> failure using write-ready; so
    you must also <span class="Li">&quot;select()&quot;</span> for exceptional
    status.</p>
<p class="Pp">While <span class="Li">&quot;connect&quot;</span> returns false,
    the value of <span class="Li">$!</span> indicates whether it should be tried
    again (by being set to the value
    <span class="Li">&quot;EINPROGRESS&quot;</span>, or
    <span class="Li">&quot;EWOULDBLOCK&quot;</span> on MSWin32), or whether a
    permanent error has occurred (e.g.
    <span class="Li">&quot;ECONNREFUSED&quot;</span>).</p>
<p class="Pp">Once the socket has been connected to the peer,
    <span class="Li">&quot;connect&quot;</span> will return true and the socket
    will now be ready to use.</p>
<p class="Pp">Note that calls to the platform's underlying
    <span class="Li">getaddrinfo(3)</span> function may block. If
    <span class="Li">&quot;IO::Socket::IP&quot;</span> has to perform this
    lookup, the constructor will block even when in non-blocking mode.</p>
<p class="Pp">To avoid this blocking behaviour, the caller should pass in the
    result of such a lookup using the
    <span class="Li">&quot;PeerAddrInfo&quot;</span> or
    <span class="Li">&quot;LocalAddrInfo&quot;</span> arguments. This can be
    achieved by using Net::LibAsyncNS, or the
    <span class="Li">getaddrinfo(3)</span> function can be called in a child
    process.</p>
<p class="Pp"></p>
<pre> use IO::Socket::IP;
 use Errno qw( EINPROGRESS EWOULDBLOCK );
 my @peeraddrinfo = ... # Caller must obtain the getaddinfo result here
 my $socket = IO::Socket::IP-&gt;new(
    PeerAddrInfo =&gt; \@peeraddrinfo,
    Blocking     =&gt; 0,
 ) or die &quot;Cannot construct socket - $@&quot;;
 while( !$socket-&gt;connect and ( $! == EINPROGRESS || $! == EWOULDBLOCK ) ) {
    my $wvec = '';
    vec( $wvec, fileno $socket, 1 ) = 1;
    my $evec = '';
    vec( $evec, fileno $socket, 1 ) = 1;
    select( undef, $wvec, $evec, undef ) or die &quot;Cannot select - $!&quot;;
 }
 die &quot;Cannot connect - $!&quot; if $!;
 ...
</pre>
<p class="Pp">The example above uses
    <span class="Li">&quot;select()&quot;</span>, but any similar mechanism
    should work analogously. <span class="Li">&quot;IO::Socket::IP&quot;</span>
    takes care when creating new socket filehandles to preserve the actual file
    descriptor number, so such techniques as
    <span class="Li">&quot;poll&quot;</span> or
    <span class="Li">&quot;epoll&quot;</span> should be transparent to its
    reallocation of a different socket underneath, perhaps in order to switch
    protocol family between <span class="Li">&quot;PF_INET&quot;</span> and
    <span class="Li">&quot;PF_INET6&quot;</span>.</p>
<p class="Pp">For another example using
    <span class="Li">&quot;IO::Poll&quot;</span> and
    <span class="Li">&quot;Net::LibAsyncNS&quot;</span>, see the
    <i>examples/nonblocking_libasyncns.pl</i> file in the module
  distribution.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="_PeerHost__AND__LocalHost__PARSING"><a class="permalink" href="#_PeerHost__AND__LocalHost__PARSING">&quot;PeerHost&quot;
  AND &quot;LocalHost&quot; PARSING</a></h1>
<p class="Pp">To support the
    <span class="Li">&quot;IO::Socket::INET&quot;</span> API, the host and port
    information may be passed in a single string rather than as two separate
    arguments.</p>
<p class="Pp">If either <span class="Li">&quot;LocalHost&quot;</span> or
    <span class="Li">&quot;PeerHost&quot;</span> (or their
    <span class="Li">&quot;...Addr&quot;</span> synonyms) have any of the
    following special forms then special parsing is applied.</p>
<p class="Pp">The value of the <span class="Li">&quot;...Host&quot;</span>
    argument will be split to give both the hostname and port (or service
  name):</p>
<p class="Pp"></p>
<pre> hostname.example.org:http    # Host name
 192.0.2.1:80                 # IPv4 address
 [2001:db8::1]:80             # IPv6 address
</pre>
<p class="Pp">In each case, the port or service name (e.g.
    <span class="Li">80</span>) is passed as the
    <span class="Li">&quot;LocalService&quot;</span> or
    <span class="Li">&quot;PeerService&quot;</span> argument.</p>
<p class="Pp">Either of <span class="Li">&quot;LocalService&quot;</span> or
    <span class="Li">&quot;PeerService&quot;</span> (or their
    <span class="Li">&quot;...Port&quot;</span> synonyms) can be either a
    service name, a decimal number, or a string containing both a service name
    and number, in a form such as</p>
<p class="Pp"></p>
<pre> http(80)
</pre>
<p class="Pp">In this case, the name (<span class="Li">&quot;http&quot;</span>)
    will be tried first, but if the resolver does not understand it then the
    port number (<span class="Li">80</span>) will be used instead.</p>
<p class="Pp">If the <span class="Li">&quot;...Host&quot;</span> argument is in
    this special form and the corresponding
    <span class="Li">&quot;...Service&quot;</span> or
    <span class="Li">&quot;...Port&quot;</span> argument is also defined, the
    one parsed from the <span class="Li">&quot;...Host&quot;</span> argument
    will take precedence and the other will be ignored.</p>
<section class="Ss">
<h2 class="Ss" id="split_addr"><a class="permalink" href="#split_addr">split_addr</a></h2>
<pre>   ( $host, $port ) = IO::Socket::IP-&gt;split_addr( $addr )
</pre>
<p class="Pp">Utility method that provides the parsing functionality described
    above. Returns a 2-element list, containing either the split hostname and
    port description if it could be parsed, or the given address and
    <span class="Li">&quot;undef&quot;</span> if it was not recognised.</p>
<p class="Pp"></p>
<pre> IO::Socket::IP-&gt;split_addr( &quot;hostname:http&quot; )
                              # ( &quot;hostname&quot;,  &quot;http&quot; )
 IO::Socket::IP-&gt;split_addr( &quot;192.0.2.1:80&quot; )
                              # ( &quot;192.0.2.1&quot;, &quot;80&quot;   )
 IO::Socket::IP-&gt;split_addr( &quot;[2001:db8::1]:80&quot; )
                              # ( &quot;2001:db8::1&quot;, &quot;80&quot; )
 IO::Socket::IP-&gt;split_addr( &quot;something.else&quot; )
                              # ( &quot;something.else&quot;, undef )
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="join_addr"><a class="permalink" href="#join_addr">join_addr</a></h2>
<pre>   $addr = IO::Socket::IP-&gt;join_addr( $host, $port )
</pre>
<p class="Pp">Utility method that performs the reverse of
    <span class="Li">&quot;split_addr&quot;</span>, returning a string formed by
    joining the specified host address and port number. The host address will be
    wrapped in <span class="Li">&quot;[]&quot;</span> brackets if required
    (because it is a raw IPv6 numeric address).</p>
<p class="Pp">This can be especially useful when combined with the
    <span class="Li">&quot;sockhost_service&quot;</span> or
    <span class="Li">&quot;peerhost_service&quot;</span> methods.</p>
<p class="Pp"></p>
<pre> say &quot;Connected to &quot;, IO::Socket::IP-&gt;join_addr( $sock-&gt;peerhost_service );
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="_IO::Socket::INET__INCOMPATIBILITES"><a class="permalink" href="#_IO::Socket::INET__INCOMPATIBILITES">&quot;IO::Socket::INET&quot;
  INCOMPATIBILITES</a></h1>
<ul class="Bl-bullet">
  <li>The behaviour enabled by <span class="Li">&quot;MultiHomed&quot;</span> is
      in fact implemented by <span class="Li">&quot;IO::Socket::IP&quot;</span>
      as it is required to correctly support searching for a useable address
      from the results of the <span class="Li">getaddrinfo(3)</span> call. The
      constructor will ignore the value of this argument, except if it is
      defined but false. An exception is thrown in this case, because that would
      request it disable the <span class="Li">getaddrinfo(3)</span> search
      behaviour in the first place.</li>
  <li><span class="Li">&quot;IO::Socket::IP&quot;</span> implements both the
      <span class="Li">&quot;Blocking&quot;</span> and
      <span class="Li">&quot;Timeout&quot;</span> parameters, but it implements
      the interaction of both in a different way.
    <p class="Pp">In <span class="Li">&quot;::INET&quot;</span>, supplying a
        timeout overrides the non-blocking behaviour, meaning that the
        <span class="Li">&quot;connect()&quot;</span> operation will still block
        despite that the caller asked for a non-blocking socket. This is not
        explicitly specified in its documentation, nor does this author believe
        that is a useful behaviour - it appears to come from a quirk of
        implementation.</p>
    <p class="Pp">In <span class="Li">&quot;::IP&quot;</span> therefore, the
        <span class="Li">&quot;Blocking&quot;</span> parameter takes precedence
        - if a non-blocking socket is requested, no operation will block. The
        <span class="Li">&quot;Timeout&quot;</span> parameter here simply
        defines the maximum time that a blocking
        <span class="Li">&quot;connect()&quot;</span> call will wait, if it
        blocks at all.</p>
    <p class="Pp">In order to specifically obtain the &quot;blocking connect
        then non-blocking send and receive&quot; behaviour of specifying this
        combination of options to <span class="Li">&quot;::INET&quot;</span>
        when using <span class="Li">&quot;::IP&quot;</span>, perform first a
        blocking connect, then afterwards turn the socket into nonblocking
      mode.</p>
    <p class="Pp"></p>
    <pre> my $sock = IO::Socket::IP-&gt;new(
    PeerHost =&gt; $peer,
    Timeout =&gt; 20,
 ) or die &quot;Cannot connect - $@&quot;;
 $sock-&gt;blocking( 0 );
    </pre>
    <p class="Pp">This code will behave identically under both
        <span class="Li">&quot;IO::Socket::INET&quot;</span> and
        <span class="Li">&quot;IO::Socket::IP&quot;</span>.</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="TODO"><a class="permalink" href="#TODO">TODO</a></h1>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>Investigate whether <span class="Li">&quot;POSIX::dup2&quot;</span> upsets
      BSD's <span class="Li">&quot;kqueue&quot;</span> watchers, and if so,
      consider what possible workarounds might be applied.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Paul Evans &lt;leonerd@leonerd.org.uk&gt;</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-10-04</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Moose(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Moose(3)</td>
    <td class="head-vol"><a href=".">User Contributed Perl Documentation</a></td>
    <td class="head-rtitle">Moose(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Moose - A postmodern object system for Perl 5</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 2.2012</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  package Point;
  use Moose; # automatically turns on strict and warnings
  has 'x' =&gt; (is =&gt; 'rw', isa =&gt; 'Int');
  has 'y' =&gt; (is =&gt; 'rw', isa =&gt; 'Int');
  sub clear {
      my $self = shift;
      $self-&gt;x(0);
      $self-&gt;y(0);
  }
  package Point3D;
  use Moose;
  extends 'Point';
  has 'z' =&gt; (is =&gt; 'rw', isa =&gt; 'Int');
  after 'clear' =&gt; sub {
      my $self = shift;
      $self-&gt;z(0);
  };
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Moose is an extension of the Perl 5 object system.</p>
<p class="Pp">The main goal of Moose is to make Perl 5 Object Oriented
    programming easier, more consistent, and less tedious. With Moose you can
    think more about what you want to do and less about the mechanics of
  OOP.</p>
<p class="Pp">Additionally, Moose is built on top of Class::MOP, which is a
    metaclass system for Perl 5. This means that Moose not only makes building
    normal Perl 5 objects better, but it provides the power of metaclass
    programming as well.</p>
<section class="Ss">
<h2 class="Ss" id="New_to_Moose?"><a class="permalink" href="#New_to_Moose?">New
  to Moose?</a></h2>
<p class="Pp">If you're new to Moose, the best place to start is the
    Moose::Manual docs, followed by the Moose::Cookbook. The intro will show you
    what Moose is, and how it makes Perl 5 OO better.</p>
<p class="Pp">The cookbook recipes on Moose basics will get you up to speed with
    many of Moose's features quickly. Once you have an idea of what Moose can
    do, you can use the API documentation to get more detail on features which
    interest you.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Moose_Extensions"><a class="permalink" href="#Moose_Extensions">Moose
  Extensions</a></h2>
<p class="Pp">The <span class="Li">&quot;MooseX::&quot;</span> namespace is the
    official place to find Moose extensions. These extensions can be found on
    the CPAN. The easiest way to find them is to search for them
    (&lt;https://metacpan.org/search?q=MooseX::&gt;), or to examine Task::Moose
    which aims to keep an up-to-date, easily installable list of Moose
    extensions.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TRANSLATIONS"><a class="permalink" href="#TRANSLATIONS">TRANSLATIONS</a></h1>
<p class="Pp">Much of the Moose documentation has been translated into other
    languages.</p>
<dl class="Bl-tag">
  <dt id="Japanese"><a class="permalink" href="#Japanese">Japanese</a></dt>
  <dd>Japanese docs can be found at
      &lt;http://perldoc.perlassociation.org/pod/Moose-Doc-JA/index.html&gt;.
      The source POD files can be found in GitHub:
      &lt;http://github.com/jpa/Moose-Doc-JA&gt;</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="BUILDING_CLASSES_WITH_MOOSE"><a class="permalink" href="#BUILDING_CLASSES_WITH_MOOSE">BUILDING
  CLASSES WITH MOOSE</a></h1>
<p class="Pp">Moose makes every attempt to provide as much convenience as
    possible during class construction/definition, but still stay out of your
    way if you want it to. Here are a few items to note when building classes
    with Moose.</p>
<p class="Pp">When you <span class="Li">&quot;use Moose&quot;</span>, Moose will
    set the class's parent class to Moose::Object, <i>unless</i> the class using
    Moose already has a parent class. In addition, specifying a parent with
    <span class="Li">&quot;extends&quot;</span> will change the parent
  class.</p>
<p class="Pp">Moose will also manage all attributes (including inherited ones)
    that are defined with <span class="Li">&quot;has&quot;</span>. And (assuming
    you call <span class="Li">&quot;new&quot;</span>, which is inherited from
    Moose::Object) this includes properly initializing all instance slots,
    setting defaults where appropriate, and performing any type constraint
    checking or coercion.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PROVIDED_METHODS"><a class="permalink" href="#PROVIDED_METHODS">PROVIDED
  METHODS</a></h1>
<p class="Pp">Moose provides a number of methods to all your classes, mostly
    through the inheritance of Moose::Object. There is however, one exception.
    By default, Moose will install a method named
    <span class="Li">&quot;meta&quot;</span> in any class which uses
    <span class="Li">&quot;Moose&quot;</span>. This method returns the current
    class's metaclass.</p>
<p class="Pp">If you'd like to rename this method, you can do so by passing the
    <span class="Li">&quot;-meta_name&quot;</span> option when using Moose:</p>
<p class="Pp"></p>
<pre>    use Moose -meta_name =&gt; 'my_meta';
</pre>
<p class="Pp">However, the Moose::Object class <i>also</i> provides a method
    named <span class="Li">&quot;meta&quot;</span> which does the same thing. If
    your class inherits from Moose::Object (which is the default), then you will
    still have a <span class="Li">&quot;meta&quot;</span> method. However, if
    your class inherits from a parent which provides a
    <span class="Li">&quot;meta&quot;</span> method of its own, your class will
    inherit that instead.</p>
<p class="Pp">If you'd like for Moose to not install a meta method at all, you
    can pass <span class="Li">&quot;undef&quot;</span> as the
    <span class="Li">&quot;-meta_name&quot;</span> option:</p>
<p class="Pp"></p>
<pre>    use Moose -meta_name =&gt; undef;
</pre>
<p class="Pp">Again, you will still inherit
    <span class="Li">&quot;meta&quot;</span> from Moose::Object in this
  case.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTED_FUNCTIONS"><a class="permalink" href="#EXPORTED_FUNCTIONS">EXPORTED
  FUNCTIONS</a></h1>
<p class="Pp">Moose will export a number of functions into the class's namespace
    which may then be used to set up the class. These functions all work
    directly on the current class.</p>
<section class="Ss">
<h2 class="Ss" id="extends_(@superclasses)"><a class="permalink" href="#extends_(@superclasses)">extends
  (@superclasses)</a></h2>
<p class="Pp">This function will set the superclass(es) for the current class.
    If the parent classes are not yet loaded, then
    <span class="Li">&quot;extends&quot;</span> tries to load them.</p>
<p class="Pp">This approach is recommended instead of <span class="Li">&quot;use
    base&quot;</span>/<span class="Li">&quot;use parent&quot;</span>, because
    <span class="Li">&quot;use base&quot;</span> actually
    <span class="Li">&quot;push&quot;</span>es onto the class's
    <span class="Li">@ISA</span>, whereas
    <span class="Li">&quot;extends&quot;</span> will replace it. This is
    important to ensure that classes which do not have superclasses still
    properly inherit from Moose::Object.</p>
<p class="Pp">Each superclass can be followed by a hash reference with options.
    Currently, only -version is recognized:</p>
<p class="Pp"></p>
<pre>    extends 'My::Parent'      =&gt; { -version =&gt; 0.01 },
            'My::OtherParent' =&gt; { -version =&gt; 0.03 };
</pre>
<p class="Pp">An exception will be thrown if the version requirements are not
    satisfied.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="with_(@roles)"><a class="permalink" href="#with_(@roles)">with
  (@roles)</a></h2>
<p class="Pp">This will apply a given set of <span class="Li">@roles</span> to
    the local class.</p>
<p class="Pp">Like with <span class="Li">&quot;extends&quot;</span>, each
    specified role can be followed by a hash reference with a -version
  option:</p>
<p class="Pp"></p>
<pre>    with 'My::Role'      =&gt; { -version =&gt; 0.32 },
         'My::Otherrole' =&gt; { -version =&gt; 0.23 };
</pre>
<p class="Pp">The specified version requirements must be satisfied, otherwise an
    exception will be thrown.</p>
<p class="Pp">If your role takes options or arguments, they can be passed along
    in the hash reference as well.</p>
<p class="Pp">You should only use one <span class="Li">&quot;with&quot;</span>,
    even if you are consuming multiple roles. If you consume roles using
    multiple <span class="Li">&quot;with&quot;</span> statements Moose cannot
    detect method conflicts between those roles.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="has_$name_@$names_=___options"><a class="permalink" href="#has_$name_@$names_=___options">has
  $name|@$names =&gt; %options</a></h2>
<p class="Pp">This will install an attribute of a given
    <span class="Li">$name</span> into the current class. If the first parameter
    is an array reference, it will create an attribute for every
    <span class="Li">$name</span> in the list. The
    <span class="Li">%options</span> will be passed to the constructor for
    Moose::Meta::Attribute (which inherits from Class::MOP::Attribute), so the
    full documentation for the valid options can be found there. These are the
    most commonly used options:</p>
<dl class="Bl-tag">
  <dt id="is"><a class="permalink" href="#is"><i>is =&gt; 'rw'|'ro'</i></a></dt>
  <dd>The <i>is</i> option accepts either <i>rw</i> (for read/write) or
      <i>ro</i> (for read only). These will create either a read/write accessor
      or a read-only accessor respectively, using the same name as the
      <span class="Li">$name</span> of the attribute.
    <p class="Pp">If you need more control over how your accessors are named,
        you can use the reader, writer and accessor options inherited from
        Class::MOP::Attribute, however if you use those, you won't need the
        <i>is</i> option.</p>
  </dd>
  <dt id="isa"><a class="permalink" href="#isa"><i>isa =&gt;
    </i><span class="Li"><i>$type_name</i></span><i></i></a></dt>
  <dd>The <i>isa</i> option uses Moose's type constraint facilities to set up
      runtime type checking for this attribute. Moose will perform the checks
      during class construction, and within any accessors. The
      <span class="Li">$type_name</span> argument must be a string. The string
      may be either a class name or a type defined using Moose's type definition
      features. (Refer to Moose::Util::TypeConstraints for information on how to
      define a new type, and how to retrieve type meta-data).</dd>
  <dt id="coerce"><a class="permalink" href="#coerce"><i>coerce =&gt;
    (1|0)</i></a></dt>
  <dd>This will attempt to use coercion with the supplied type constraint to
      change the value passed into any accessors or constructors. You
      <b>must</b> supply a type constraint, and that type constraint <b>must</b>
      define a coercion. See Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion
      for an example.</dd>
  <dt id="does"><a class="permalink" href="#does"><i>does =&gt;
    </i><span class="Li"><i>$role_name</i></span><i></i></a></dt>
  <dd>This will accept the name of a role which the value stored in this
      attribute is expected to have consumed.</dd>
  <dt id="required"><a class="permalink" href="#required"><i>required =&gt;
    (1|0)</i></a></dt>
  <dd>This marks the attribute as being required. This means a value must be
      supplied during class construction, <i>or</i> the attribute must be lazy
      and have either a default or a builder. Note that
      <span class="Li">&quot;required&quot;</span> does not say anything about
      the attribute's value, which can be
      <span class="Li">&quot;undef&quot;</span>.</dd>
  <dt id="weak_ref"><a class="permalink" href="#weak_ref"><i>weak_ref =&gt;
    (1|0)</i></a></dt>
  <dd>This will tell the class to store the value of this attribute as a
      weakened reference. If an attribute is a weakened reference, it
      <b>cannot</b> also be coerced. Note that when a weak ref expires, the
      attribute's value becomes undefined, and is still considered to be set for
      purposes of predicate, default, etc.</dd>
  <dt id="lazy"><a class="permalink" href="#lazy"><i>lazy =&gt;
    (1|0)</i></a></dt>
  <dd>This will tell the class to not create this slot until absolutely
      necessary. If an attribute is marked as lazy it <b>must</b> have a default
      or builder supplied.</dd>
  <dt id="trigger"><a class="permalink" href="#trigger"><i>trigger =&gt;
    </i><span class="Li"><i>$code</i></span><i></i></a></dt>
  <dd>The <i>trigger</i> option is a CODE reference which will be called after
      the value of the attribute is set. The CODE ref is passed the instance
      itself, the updated value, and the original value if the attribute was
      already set.
    <p class="Pp">You <b>can</b> have a trigger on a read-only attribute.</p>
    <p class="Pp"><b>NOTE:</b> Triggers will only fire when you <b>assign</b> to
        the attribute, either in the constructor, or using the writer. Default
        and built values will <b>not</b> cause the trigger to be fired.</p>
  </dd>
  <dt id="handles"><a class="permalink" href="#handles"><i>handles =&gt; ARRAY |
    HASH | REGEXP | ROLE | ROLETYPE | DUCKTYPE | CODE</i></a></dt>
  <dd>The <i>handles</i> option provides Moose classes with automated delegation
      features. This is a pretty complex and powerful option. It accepts many
      different option formats, each with its own benefits and drawbacks.
    <p class="Pp"><b>NOTE:</b> The class being delegated to does not need to be
        a Moose based class, which is why this feature is especially useful when
        wrapping non-Moose classes.</p>
    <p class="Pp">All <i>handles</i> option formats share the following
      traits:</p>
    <p class="Pp">You cannot override a locally defined method with a delegated
        method; an exception will be thrown if you try. That is to say, if you
        define <span class="Li">&quot;foo&quot;</span> in your class, you cannot
        override it with a delegated <span class="Li">&quot;foo&quot;</span>.
        This is almost never something you would want to do, and if it is, you
        should do it by hand and not use Moose.</p>
    <p class="Pp">You cannot override any of the methods found in Moose::Object,
        or the <span class="Li">&quot;BUILD&quot;</span> and
        <span class="Li">&quot;DEMOLISH&quot;</span> methods. These will not
        throw an exception, but will silently move on to the next method in the
        list. My reasoning for this is that you would almost never want to do
        this, since it usually breaks your class. As with overriding locally
        defined methods, if you do want to do this, you should do it manually,
        not with Moose.</p>
    <p class="Pp">You do not <i>need</i> to have a reader (or accessor) for the
        attribute in order to delegate to it. Moose will create a means of
        accessing the value for you, however this will be several times
        <b>less</b> efficient then if you had given the attribute a reader (or
        accessor) to use.</p>
    <p class="Pp">Below is the documentation for each option format:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>&quot;ARRAY&quot;</dt>
  <dd>This is the most common usage for <i>handles</i>. You basically pass a
      list of method names to be delegated, and Moose will install a delegation
      method for each one.</dd>
  <dt>&quot;HASH&quot;</dt>
  <dd>This is the second most common usage for <i>handles</i>. Instead of a list
      of method names, you pass a HASH ref where each key is the method name you
      want installed locally, and its value is the name of the original method
      in the class being delegated to.
    <p class="Pp">This can be very useful for recursive classes like trees. Here
        is a quick example (soon to be expanded into a Moose::Cookbook
      recipe):</p>
    <p class="Pp"></p>
    <pre>  package Tree;
  use Moose;
  has 'node' =&gt; (is =&gt; 'rw', isa =&gt; 'Any');
  has 'children' =&gt; (
      is      =&gt; 'ro',
      isa     =&gt; 'ArrayRef',
      default =&gt; sub { [] }
  );
  has 'parent' =&gt; (
      is          =&gt; 'rw',
      isa         =&gt; 'Tree',
      weak_ref    =&gt; 1,
      handles     =&gt; {
          parent_node =&gt; 'node',
          siblings    =&gt; 'children',
      }
  );
    </pre>
    <p class="Pp">In this example, the Tree package gets
        <span class="Li">&quot;parent_node&quot;</span> and
        <span class="Li">&quot;siblings&quot;</span> methods, which delegate to
        the <span class="Li">&quot;node&quot;</span> and
        <span class="Li">&quot;children&quot;</span> methods (respectively) of
        the Tree instance stored in the
        <span class="Li">&quot;parent&quot;</span> slot.</p>
    <p class="Pp">You may also use an array reference to curry arguments to the
        original method.</p>
    <p class="Pp"></p>
    <pre>  has 'thing' =&gt; (
      ...
      handles =&gt; { set_foo =&gt; [ set =&gt; 'foo' ] },
  );
  # $self-&gt;set_foo(...) calls $self-&gt;thing-&gt;set('foo', ...)
    </pre>
    <p class="Pp">The first element of the array reference is the original
        method name, and the rest is a list of curried arguments.</p>
  </dd>
  <dt>&quot;REGEXP&quot;</dt>
  <dd>The regexp option works very similar to the ARRAY option, except that it
      builds the list of methods for you. It starts by collecting all possible
      methods of the class being delegated to, then filters that list using the
      regexp supplied here.
    <p class="Pp"><b>NOTE:</b> An <i>isa</i> option is required when using the
        regexp option format. This is so that we can determine (at compile time)
        the method list from the class. Without an <i>isa</i> this is just not
        possible.</p>
  </dd>
  <dt>&quot;ROLE&quot; or &quot;ROLETYPE&quot;</dt>
  <dd>With the role option, you specify the name of a role or a role type whose
      &quot;interface&quot; then becomes the list of methods to handle. The
      &quot;interface&quot; can be defined as; the methods of the role and any
      required methods of the role. It should be noted that this does <b>not</b>
      include any method modifiers or generated attribute methods (which is
      consistent with role composition).</dd>
  <dt>&quot;DUCKTYPE&quot;</dt>
  <dd>With the duck type option, you pass a duck type object whose
      &quot;interface&quot; then becomes the list of methods to handle. The
      &quot;interface&quot; can be defined as the list of methods passed to
      <span class="Li">&quot;duck_type&quot;</span> to create a duck type
      object. For more information on
      <span class="Li">&quot;duck_type&quot;</span> please check
      Moose::Util::TypeConstraints.</dd>
  <dt>&quot;CODE&quot;</dt>
  <dd>This is the option to use when you really want to do something funky. You
      should only use it if you really know what you are doing, as it involves
      manual metaclass twiddling.
    <p class="Pp">This takes a code reference, which should expect two
        arguments. The first is the attribute meta-object this <i>handles</i> is
        attached to. The second is the metaclass of the class being delegated
        to. It expects you to return a hash (not a HASH ref) of the methods you
        want mapped.</p>
  </dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="traits"><a class="permalink" href="#traits"><i>traits =&gt; [
    </i><span class="Li"><i>@role_names</i></span><i> ]</i></a></dt>
  <dd>This tells Moose to take the list of <span class="Li">@role_names</span>
      and apply them to the attribute meta-object. Custom attribute metaclass
      traits are useful for extending the capabilities of the <i>has</i>
      keyword: they are the simplest way to extend the MOP, but they are still a
      fairly advanced topic and too much to cover here.
    <p class="Pp">See &quot;Metaclass and Trait Name Resolution&quot; for
        details on how a trait name is resolved to a role name.</p>
    <p class="Pp">Also see Moose::Cookbook::Meta::Labeled_AttributeTrait for a
        metaclass trait example.</p>
  </dd>
  <dt id="builder"><a class="permalink" href="#builder"><i>builder</i> =&gt;
    Str</a></dt>
  <dd>The value of this key is the name of the method that will be called to
      obtain the value used to initialize the attribute. See the builder option
      docs in Class::MOP::Attribute and/or
      Moose::Cookbook::Basics::BinaryTree_BuilderAndLazyBuild for more
      information.</dd>
  <dt id="default"><a class="permalink" href="#default"><i>default</i> =&gt;
    SCALAR | CODE</a></dt>
  <dd>The value of this key is the default value which will initialize the
      attribute.
    <p class="Pp">NOTE: If the value is a simple scalar (string or number), then
        it can be just passed as is. However, if you wish to initialize it with
        a HASH or ARRAY ref, then you need to wrap that inside a CODE reference.
        See the default option docs in Class::MOP::Attribute for more
        information.</p>
  </dd>
  <dt id="clearer"><a class="permalink" href="#clearer"><i>clearer</i> =&gt;
    Str</a></dt>
  <dd>Creates a method allowing you to clear the value. See the clearer option
      docs in Class::MOP::Attribute for more information.</dd>
  <dt id="predicate"><a class="permalink" href="#predicate"><i>predicate</i>
    =&gt; Str</a></dt>
  <dd>Creates a method to perform a basic test to see if a value has been set in
      the attribute. See the predicate option docs in Class::MOP::Attribute for
      more information.
    <p class="Pp">Note that the predicate will return true even for a
        <span class="Li">&quot;weak_ref&quot;</span> attribute whose value has
        expired.</p>
  </dd>
  <dt id="documentation"><a class="permalink" href="#documentation"><i>documentation</i>
    =&gt; $string</a></dt>
  <dd>An arbitrary string that can be retrieved later by calling
      <span class="Li">&quot;$attr-&gt;documentation&quot;</span>.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="has_+$name_=___options"><a class="permalink" href="#has_+$name_=___options">has
  +$name =&gt; %options</a></h2>
<p class="Pp">This is variation on the normal attribute creator
    <span class="Li">&quot;has&quot;</span> which allows you to clone and extend
    an attribute from a superclass or from a role. Here is an example of the
    superclass usage:</p>
<p class="Pp"></p>
<pre>  package Foo;
  use Moose;
  has 'message' =&gt; (
      is      =&gt; 'rw',
      isa     =&gt; 'Str',
      default =&gt; 'Hello, I am a Foo'
  );
  package My::Foo;
  use Moose;
  extends 'Foo';
  has '+message' =&gt; (default =&gt; 'Hello I am My::Foo');
</pre>
<p class="Pp">What is happening here is that <b>My::Foo</b> is cloning the
    <span class="Li">&quot;message&quot;</span> attribute from its parent class
    <b>Foo</b>, retaining the <span class="Li">&quot;is =&gt; 'rw'&quot;</span>
    and <span class="Li">&quot;isa =&gt;</span>
    <span class="Li">'Str'&quot;</span> characteristics, but changing the value
    in <span class="Li">&quot;default&quot;</span>.</p>
<p class="Pp">Here is another example, but within the context of a role:</p>
<p class="Pp"></p>
<pre>  package Foo::Role;
  use Moose::Role;
  has 'message' =&gt; (
      is      =&gt; 'rw',
      isa     =&gt; 'Str',
      default =&gt; 'Hello, I am a Foo'
  );
  package My::Foo;
  use Moose;
  with 'Foo::Role';
  has '+message' =&gt; (default =&gt; 'Hello I am My::Foo');
</pre>
<p class="Pp">In this case, we are basically taking the attribute which the role
    supplied and altering it within the bounds of this feature.</p>
<p class="Pp">Note that you can only extend an attribute from either a
    superclass or a role, you cannot extend an attribute in a role that composes
    over an attribute from another role.</p>
<p class="Pp">Aside from where the attributes come from (one from superclass,
    the other from a role), this feature works exactly the same. This feature is
    restricted somewhat, so as to try and force at least <i>some</i> sanity into
    it. Most options work the same, but there are some exceptions:</p>
<dl class="Bl-tag">
  <dt id="reader"><a class="permalink" href="#reader"><i>reader</i></a></dt>
  <dd></dd>
  <dt id="writer"><a class="permalink" href="#writer"><i>writer</i></a></dt>
  <dd></dd>
  <dt id="accessor"><a class="permalink" href="#accessor"><i>accessor</i></a></dt>
  <dd></dd>
  <dt id="clearer~2"><a class="permalink" href="#clearer~2"><i>clearer</i></a></dt>
  <dd></dd>
  <dt id="predicate~2"><a class="permalink" href="#predicate~2"><i>predicate</i></a></dt>
  <dd>These options can be added, but cannot override a superclass
    definition.</dd>
  <dt id="traits~2"><a class="permalink" href="#traits~2"><i>traits</i></a></dt>
  <dd>You are allowed to <b>add</b> additional traits to the
      <span class="Li">&quot;traits&quot;</span> definition. These traits will
      be composed into the attribute, but preexisting traits <b>are not</b>
      overridden, or removed.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="before_$name_@names_"><a class="permalink" href="#before_$name_@names_">before
  $name|@names|\@names|qr/.../ =&gt; sub { ... }</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="after_$name_@names_"><a class="permalink" href="#after_$name_@names_">after
  $name|@names|\@names|qr/.../ =&gt; sub { ... }</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="around_$name_@names_"><a class="permalink" href="#around_$name_@names_">around
  $name|@names|\@names|qr/.../ =&gt; sub { ... }</a></h2>
<p class="Pp">These three items are syntactic sugar for the before, after, and
    around method modifier features that Class::MOP provides. More information
    on these may be found in Moose::Manual::MethodModifiers and the
    Class::MOP::Class documentation.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="override_($name,_&amp;sub)"><a class="permalink" href="#override_($name,_&amp;sub)">override
  ($name, &amp;sub)</a></h2>
<p class="Pp">An <span class="Li">&quot;override&quot;</span> method is a way of
    explicitly saying &quot;I am overriding this method from my
    superclass&quot;. You can call <span class="Li">&quot;super&quot;</span>
    within this method, and it will work as expected. The same thing <i>can</i>
    be accomplished with a normal method call and the
    <span class="Li">&quot;SUPER::&quot;</span> pseudo-package; it is really
    your choice.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="super"><a class="permalink" href="#super">super</a></h2>
<p class="Pp">The keyword <span class="Li">&quot;super&quot;</span> is a no-op
    when called outside of an <span class="Li">&quot;override&quot;</span>
    method. In the context of an <span class="Li">&quot;override&quot;</span>
    method, it will call the next most appropriate superclass method with the
    same arguments as the original method.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="augment_($name,_&amp;sub)"><a class="permalink" href="#augment_($name,_&amp;sub)">augment
  ($name, &amp;sub)</a></h2>
<p class="Pp">An <span class="Li">&quot;augment&quot;</span> method, is a way of
    explicitly saying &quot;I am augmenting this method from my
    superclass&quot;. Once again, the details of how
    <span class="Li">&quot;inner&quot;</span> and
    <span class="Li">&quot;augment&quot;</span> work is best described in the
    Moose::Cookbook::Basics::Document_AugmentAndInner.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="inner"><a class="permalink" href="#inner">inner</a></h2>
<p class="Pp">The keyword <span class="Li">&quot;inner&quot;</span>, much like
    <span class="Li">&quot;super&quot;</span>, is a no-op outside of the context
    of an <span class="Li">&quot;augment&quot;</span> method. You can think of
    <span class="Li">&quot;inner&quot;</span> as being the inverse of
    <span class="Li">&quot;super&quot;</span>; the details of how
    <span class="Li">&quot;inner&quot;</span> and
    <span class="Li">&quot;augment&quot;</span> work is best described in the
    Moose::Cookbook::Basics::Document_AugmentAndInner.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="blessed"><a class="permalink" href="#blessed">blessed</a></h2>
<p class="Pp">This is the
    <span class="Li">&quot;Scalar::Util::blessed&quot;</span> function. It is
    highly recommended that this is used instead of
    <span class="Li">&quot;ref&quot;</span> anywhere you need to test for an
    object's class name.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="confess"><a class="permalink" href="#confess">confess</a></h2>
<p class="Pp">This is the <span class="Li">&quot;Carp::confess&quot;</span>
    function, and exported here for historical reasons.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METACLASS"><a class="permalink" href="#METACLASS">METACLASS</a></h1>
<p class="Pp">When you use Moose, you can specify traits which will be applied
    to your metaclass:</p>
<p class="Pp"></p>
<pre>    use Moose -traits =&gt; 'My::Trait';
</pre>
<p class="Pp">This is very similar to the attribute traits feature. When you do
    this, your class's <span class="Li">&quot;meta&quot;</span> object will have
    the specified traits applied to it. See &quot;Metaclass and Trait Name
    Resolution&quot; for more details.</p>
<section class="Ss">
<h2 class="Ss" id="Metaclass_and_Trait_Name_Resolution"><a class="permalink" href="#Metaclass_and_Trait_Name_Resolution">Metaclass
  and Trait Name Resolution</a></h2>
<p class="Pp">By default, when given a trait name, Moose simply tries to load a
    class of the same name. If such a class does not exist, it then looks for a
    class matching <b>Moose::Meta::$type::Custom::Trait::$trait_name</b>. The
    <span class="Li">$type</span> variable here will be one of <b>Attribute</b>
    or <b>Class</b>, depending on what the trait is being applied to.</p>
<p class="Pp">If a class with this long name exists, Moose checks to see if it
    has the method <span class="Li">&quot;register_implementation&quot;</span>.
    This method is expected to return the <i>real</i> class name of the trait.
    If there is no <span class="Li">&quot;register_implementation&quot;</span>
    method, it will fall back to using
    <b>Moose::Meta::$type::Custom::Trait::$trait</b> as the trait name.</p>
<p class="Pp">The lookup method for metaclasses is the same, except that it
    looks for a class matching
    <b>Moose::Meta::$type::Custom::$metaclass_name</b>.</p>
<p class="Pp">If all this is confusing, take a look at
    Moose::Cookbook::Meta::Labeled_AttributeTrait, which demonstrates how to
    create an attribute trait.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="UNIMPORTING_FUNCTIONS"><a class="permalink" href="#UNIMPORTING_FUNCTIONS">UNIMPORTING
  FUNCTIONS</a></h1>
<section class="Ss">
<h2 class="Ss"><b>unimport</b></h2>
<p class="Pp">Moose offers a way to remove the keywords it exports, through the
    <span class="Li">&quot;unimport&quot;</span> method. You simply have to say
    <span class="Li">&quot;no Moose&quot;</span> at the bottom of your code for
    this to work. Here is an example:</p>
<p class="Pp"></p>
<pre>    package Person;
    use Moose;
    has 'first_name' =&gt; (is =&gt; 'rw', isa =&gt; 'Str');
    has 'last_name'  =&gt; (is =&gt; 'rw', isa =&gt; 'Str');
    sub full_name {
        my $self = shift;
        $self-&gt;first_name . ' ' . $self-&gt;last_name
    }
    no Moose; # keywords are removed from the Person package
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXTENDING_AND_EMBEDDING_MOOSE"><a class="permalink" href="#EXTENDING_AND_EMBEDDING_MOOSE">EXTENDING
  AND EMBEDDING MOOSE</a></h1>
<p class="Pp">To learn more about extending Moose, we recommend checking out the
    &quot;Extending&quot; recipes in the Moose::Cookbook, starting with
    Moose::Cookbook::Extending::ExtensionOverview, which provides an overview of
    all the different ways you might extend Moose. Moose::Exporter and
    Moose::Util::MetaRole are the modules which provide the majority of the
    extension functionality, so reading their documentation should also be
    helpful.</p>
<section class="Ss">
<h2 class="Ss" id="The_MooseX::_namespace"><a class="permalink" href="#The_MooseX::_namespace">The
  MooseX:: namespace</a></h2>
<p class="Pp">Generally if you're writing an extension <i>for</i> Moose itself
    you'll want to put your extension in the
    <span class="Li">&quot;MooseX::&quot;</span> namespace. This namespace is
    specifically for extensions that make Moose better or different in some
    fundamental way. It is traditionally <b>not</b> for a package that just
    happens to use Moose. This namespace follows from the examples of the
    <span class="Li">&quot;LWPx::&quot;</span> and
    <span class="Li">&quot;DBIx::&quot;</span> namespaces that perform the same
    function for <span class="Li">&quot;LWP&quot;</span> and
    <span class="Li">&quot;DBI&quot;</span> respectively.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METACLASS_COMPATIBILITY_AND_MOOSE"><a class="permalink" href="#METACLASS_COMPATIBILITY_AND_MOOSE">METACLASS
  COMPATIBILITY AND MOOSE</a></h1>
<p class="Pp">Metaclass compatibility is a thorny subject. You should start by
    reading the &quot;About Metaclass compatibility&quot; section in the
    Class::MOP docs.</p>
<p class="Pp">Moose will attempt to resolve a few cases of metaclass
    incompatibility when you set the superclasses for a class, in addition to
    the cases that Class::MOP handles.</p>
<p class="Pp">Moose tries to determine if the metaclasses only &quot;differ by
    roles&quot;. This means that the parent and child's metaclass share a common
    ancestor in their respective hierarchies, and that the subclasses under the
    common ancestor are only different because of role applications. This case
    is actually fairly common when you mix and match various
    <span class="Li">&quot;MooseX::*&quot;</span> modules, many of which apply
    roles to the metaclass.</p>
<p class="Pp">If the parent and child do differ by roles, Moose replaces the
    metaclass in the child with a newly created metaclass. This metaclass is a
    subclass of the parent's metaclass which does all of the roles that the
    child's metaclass did before being replaced. Effectively, this means the new
    metaclass does all of the roles done by both the parent's and child's
    original metaclasses.</p>
<p class="Pp">Ultimately, this is all transparent to you except in the case of
    an unresolvable conflict.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<p class="Pp">It should be noted that <span class="Li">&quot;super&quot;</span>
    and <span class="Li">&quot;inner&quot;</span> <b>cannot</b> be used in the
    same method. However, they may be combined within the same class hierarchy;
    see <i>t/basics/override_augment_inner_super.t</i> for an example.</p>
<p class="Pp">The reason for this is that
    <span class="Li">&quot;super&quot;</span> is only valid within a method with
    the <span class="Li">&quot;override&quot;</span> modifier, and
    <span class="Li">&quot;inner&quot;</span> will never be valid within an
    <span class="Li">&quot;override&quot;</span> method. In fact,
    <span class="Li">&quot;augment&quot;</span> will skip over any
    <span class="Li">&quot;override&quot;</span> methods when searching for its
    appropriate <span class="Li">&quot;inner&quot;</span>.</p>
<p class="Pp">This might seem like a restriction, but I am of the opinion that
    keeping these two features separate (yet interoperable) actually makes them
    easy to use, since their behavior is then easier to predict. Time will tell
    whether I am right or not (UPDATE: so far so good).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="GETTING_HELP"><a class="permalink" href="#GETTING_HELP">GETTING
  HELP</a></h1>
<p class="Pp">We offer both a mailing list and a very active IRC channel.</p>
<p class="Pp">The mailing list is &lt;mailto:moose@perl.org&gt;. You must be
    subscribed to send a message. To subscribe, send an empty message to
    &lt;mailto:moose-subscribe@perl.org&gt;</p>
<p class="Pp">You can also visit us at
    <span class="Li">&quot;#moose&quot;</span> on
    &lt;irc://irc.perl.org/#moose&gt; This channel is quite active, and
    questions at all levels (on Moose-related topics ;) are welcome.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="WHAT_DOES_MOOSE_STAND_FOR?"><a class="permalink" href="#WHAT_DOES_MOOSE_STAND_FOR?">WHAT
  DOES MOOSE STAND FOR?</a></h1>
<p class="Pp">Moose doesn't stand for one thing in particular, however, if you
    want, here are a few of our favorites. Feel free to contribute more!</p>
<ul class="Bl-bullet">
  <li>Make Other Object Systems Envious</li>
  <li>Makes Object Orientation So Easy</li>
  <li>Makes Object Orientation Spiffy- Er (sorry ingy)</li>
  <li>Most Other Object Systems Emasculate</li>
  <li>Moose Often Ovulate Sorta Early</li>
  <li>Moose Offers Often Super Extensions</li>
  <li>Meta Object Obligates Salivary Excitation</li>
  <li>Meta Object Orientation Syntax Extensions</li>
  <li>Moo, Only Overengineered, Slow, and Execrable (blame rjbs!)</li>
  <li>Massive Object-Oriented Stacktrace Emitter</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGEMENTS"><a class="permalink" href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></h1>
<dl class="Bl-tag">
  <dt id="I"><a class="permalink" href="#I">I blame Sam Vilain for introducing
    me to the insanity that is meta-models.</a></dt>
  <dd></dd>
  <dt id="I~2"><a class="permalink" href="#I~2">I blame Audrey Tang for then
    encouraging my meta-model habit in #perl6.</a></dt>
  <dd></dd>
  <dt id="Without"><a class="permalink" href="#Without">Without Yuval
    &quot;nothingmuch&quot; Kogman this module would not be possible, and it
    certainly wouldn't have this name ;P</a></dt>
  <dd></dd>
  <dt id="The"><a class="permalink" href="#The">The basis of the TypeContraints
    module was Rob Kinyon's idea originally, I just ran with it.</a></dt>
  <dd></dd>
  <dt id="Thanks"><a class="permalink" href="#Thanks">Thanks to mst &amp;
    chansen and the whole #moose posse for all the early
    ideas/feature-requests/encouragement/bug-finding.</a></dt>
  <dd></dd>
  <dt id="Thanks~2"><a class="permalink" href="#Thanks~2">Thanks to David
    &quot;Theory&quot; Wheeler for meta-discussions and spelling fixes.</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<dl class="Bl-tag">
  <dt>&lt;http://moose.perl.org/&gt;</dt>
  <dd>This is the official web home of Moose. It contains links to our public
      git repository, as well as links to a number of talks and articles on
      Moose and Moose related technologies.</dd>
  <dt id="the"><a class="permalink" href="#the">the Moose manual</a></dt>
  <dd>This is an introduction to Moose which covers most of the basics.</dd>
  <dt id="Modern"><a class="permalink" href="#Modern">Modern Perl, by
    chromatic</a></dt>
  <dd>This is an introduction to modern Perl programming, which includes a
      section on Moose. It is available in print and as a free download from
      &lt;http://onyxneon.com/books/modern_perl/&gt;.</dd>
  <dt id="The~2"><a class="permalink" href="#The~2">The Moose is flying, a
    tutorial by Randal Schwartz</a></dt>
  <dd>Part 1 - &lt;http://www.stonehenge.com/merlyn/LinuxMag/col94.html&gt;
    <p class="Pp">Part 2 -
        &lt;http://www.stonehenge.com/merlyn/LinuxMag/col95.html&gt;</p>
  </dd>
  <dt id="Several"><a class="permalink" href="#Several">Several Moose extension
    modules in the &quot;MooseX::&quot; namespace.</a></dt>
  <dd>See &lt;https://metacpan.org/search?q=MooseX::&gt; for extensions.</dd>
</dl>
<section class="Ss">
<h2 class="Ss" id="Books"><a class="permalink" href="#Books">Books</a></h2>
<dl class="Bl-tag">
  <dt id="The~3"><a class="permalink" href="#The~3">The Art of the MetaObject
    Protocol</a></dt>
  <dd>I mention this in the Class::MOP docs too, as this book was critical in
      the development of both modules and is highly recommended.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Papers"><a class="permalink" href="#Papers">Papers</a></h2>
<dl class="Bl-tag">
  <dt>&lt;http://www.cs.utah.edu/plt/publications/oopsla04-gff.pdf&gt;</dt>
  <dd>This paper (suggested by lbr on #moose) was what lead to the
      implementation of the
      <span class="Li">&quot;super&quot;</span>/<span class="Li">&quot;override&quot;</span>
      and
      <span class="Li">&quot;inner&quot;</span>/<span class="Li">&quot;augment&quot;</span>
      features. If you really want to understand them, I suggest you read
    this.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">All complex software has bugs lurking in it, and this module is no
    exception.</p>
<p class="Pp">Please report any bugs to
    <span class="Li">&quot;bug-moose@rt.cpan.org&quot;</span>, or through the
    web interface at &lt;http://rt.cpan.org&gt;. You can also submit a
    <span class="Li">&quot;TODO&quot;</span> test as a pull request at
    &lt;https://github.com/moose/Moose&gt;.</p>
<p class="Pp">You can also discuss feature requests or possible bugs on the
    Moose mailing list (moose@perl.org) or on IRC at
    &lt;irc://irc.perl.org/#moose&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FEATURE_REQUESTS"><a class="permalink" href="#FEATURE_REQUESTS">FEATURE
  REQUESTS</a></h1>
<p class="Pp">We are very strict about what features we add to the Moose core,
    especially the user-visible features. Instead we have made sure that the
    underlying meta-system of Moose is as extensible as possible so that you can
    add your own features easily.</p>
<p class="Pp">That said, occasionally there is a feature needed in the
    meta-system to support your planned extension, in which case you should
    either email the mailing list (moose@perl.org) or join us on IRC at
    &lt;irc://irc.perl.org/#moose&gt; to discuss. The
    Moose::Manual::Contributing has more detail about how and when you can
    contribute.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CABAL"><a class="permalink" href="#CABAL">CABAL</a></h1>
<p class="Pp">There are only a few people with the rights to release a new
    version of Moose. The Moose Cabal are the people to go to with questions
    regarding the wider purview of Moose. They help maintain not just the code
    but the community as well. See the list below under
    <span class="Li">&quot;AUTHORS&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<p class="Pp">Moose is a community project, and as such, involves the work of
    many, many members of the community beyond just the members in the cabal. In
    particular:</p>
<p class="Pp">Dave (autarch) Rolsky wrote most of the documentation in
    Moose::Manual.</p>
<p class="Pp">John (jgoulah) Goulah wrote Moose::Cookbook::Snack::Keywords.</p>
<p class="Pp">Jess (castaway) Robinson wrote Moose::Cookbook::Snack::Types.</p>
<p class="Pp">Aran (bluefeet) Clary Deltac wrote
    Moose::Cookbook::Basics::Genome_OverloadingSubtypesAndCoercion.</p>
<p class="Pp">Anders (Debolaz) Nor Berle contributed Test::Moose and
    Moose::Util.</p>
<p class="Pp">Also, the code in Moose::Meta::Attribute::Native is based on code
    from the MooseX::AttributeHelpers distribution, which had contributions
    from:</p>
<p class="Pp">Chris (perigrin) Prather</p>
<p class="Pp">Cory (gphat) Watson</p>
<p class="Pp">Evan Carroll</p>
<p class="Pp">Florian (rafl) Ragwitz</p>
<p class="Pp">Jason May</p>
<p class="Pp">Jay Hannah</p>
<p class="Pp">Jesse (doy) Luehrs</p>
<p class="Pp">Paul (frodwith) Driver</p>
<p class="Pp">Robert (rlb3) Boone</p>
<p class="Pp">Robert Buels</p>
<p class="Pp">Robert (phaylon) Sedlacek</p>
<p class="Pp">Shawn (Sartak) Moore</p>
<p class="Pp">Stevan Little</p>
<p class="Pp">Tom (dec) Lanyon</p>
<p class="Pp">Yuval Kogman</p>
<p class="Pp">Finally, these people also contributed various tests, bug fixes,
    documentation, and features to the Moose codebase:</p>
<p class="Pp">Aankhen</p>
<p class="Pp">Adam (Alias) Kennedy</p>
<p class="Pp">Christian (chansen) Hansen</p>
<p class="Pp">Cory (gphat) Watson</p>
<p class="Pp">Dylan Hardison (doc fixes)</p>
<p class="Pp">Eric (ewilhelm) Wilhelm</p>
<p class="Pp">Evan Carroll</p>
<p class="Pp">Guillermo (groditi) Roditi</p>
<p class="Pp">Jason May</p>
<p class="Pp">Jay Hannah</p>
<p class="Pp">Jonathan (jrockway) Rockway</p>
<p class="Pp">Matt (mst) Trout</p>
<p class="Pp">Nathan (kolibrie) Gray</p>
<p class="Pp">Paul (frodwith) Driver</p>
<p class="Pp">Piotr (dexter) Roszatycki</p>
<p class="Pp">Robert Buels</p>
<p class="Pp">Robert (phaylon) Sedlacek</p>
<p class="Pp">Robert (rlb3) Boone</p>
<p class="Pp">Sam (mugwump) Vilain</p>
<p class="Pp">Scott (konobi) McWhirter</p>
<p class="Pp">Shlomi (rindolf) Fish</p>
<p class="Pp">Tom (dec) Lanyon</p>
<p class="Pp">Wallace (wreis) Reis</p>
<p class="Pp">... and many other #moose folks</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Stevan Little &lt;stevan.little@iinteractive.com&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
  <li>Shawn M Moore &lt;code@sartak.org&gt;</li>
  <li>&#x05D9;&#x05D5;&#x05D1;&#x05DC; &#x05E7;&#x05D5;&#x05D2;'&#x05DE;&#x05DF;
      (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Florian Ragwitz &lt;rafl@debian.org&gt;</li>
  <li>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</li>
  <li>Chris Prather &lt;chris@prather.org&gt;</li>
  <li>Matt S Trout &lt;mst@shadowcat.co.uk&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2006 by Infinity Interactive,
  Inc.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-11-22</td>
    <td class="foot-os"><a href="..">perl v5.34.0</a></td>
  </tr>
</table>
</body>
</html>

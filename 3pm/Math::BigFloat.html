<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Math::BigFloat(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Math::BigFloat(3pm)</td>
    <td class="head-vol"><a href=".">Perl Programmers Reference Guide</a></td>
    <td class="head-rtitle">Math::BigFloat(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Math::BigFloat - Arbitrary size floating point math package</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  use Math::BigFloat;
  # Configuration methods (may be used as class methods and instance methods)
  Math::BigFloat-&gt;accuracy();     # get class accuracy
  Math::BigFloat-&gt;accuracy($n);   # set class accuracy
  Math::BigFloat-&gt;precision();    # get class precision
  Math::BigFloat-&gt;precision($n);  # set class precision
  Math::BigFloat-&gt;round_mode();   # get class rounding mode
  Math::BigFloat-&gt;round_mode($m); # set global round mode, must be one of
                                  # 'even', 'odd', '+inf', '-inf', 'zero',
                                  # 'trunc', or 'common'
  Math::BigFloat-&gt;config(&quot;lib&quot;);  # name of backend math library
  # Constructor methods (when the class methods below are used as instance
  # methods, the value is assigned the invocand)
  $x = Math::BigFloat-&gt;new($str);               # defaults to 0
  $x = Math::BigFloat-&gt;new('0x123');            # from hexadecimal
  $x = Math::BigFloat-&gt;new('0b101');            # from binary
  $x = Math::BigFloat-&gt;from_hex('0xc.afep+3');  # from hex
  $x = Math::BigFloat-&gt;from_hex('cafe');        # ditto
  $x = Math::BigFloat-&gt;from_oct('1.3267p-4');   # from octal
  $x = Math::BigFloat-&gt;from_oct('0377');        # ditto
  $x = Math::BigFloat-&gt;from_bin('0b1.1001p-4'); # from binary
  $x = Math::BigFloat-&gt;from_bin('0101');        # ditto
  $x = Math::BigFloat-&gt;from_ieee754($b, &quot;binary64&quot;);  # from IEEE-754 bytes
  $x = Math::BigFloat-&gt;bzero();                 # create a +0
  $x = Math::BigFloat-&gt;bone();                  # create a +1
  $x = Math::BigFloat-&gt;bone('-');               # create a -1
  $x = Math::BigFloat-&gt;binf();                  # create a +inf
  $x = Math::BigFloat-&gt;binf('-');               # create a -inf
  $x = Math::BigFloat-&gt;bnan();                  # create a Not-A-Number
  $x = Math::BigFloat-&gt;bpi();                   # returns pi
  $y = $x-&gt;copy();        # make a copy (unlike $y = $x)
  $y = $x-&gt;as_int();      # return as BigInt
  # Boolean methods (these don't modify the invocand)
  $x-&gt;is_zero();          # if $x is 0
  $x-&gt;is_one();           # if $x is +1
  $x-&gt;is_one(&quot;+&quot;);        # ditto
  $x-&gt;is_one(&quot;-&quot;);        # if $x is -1
  $x-&gt;is_inf();           # if $x is +inf or -inf
  $x-&gt;is_inf(&quot;+&quot;);        # if $x is +inf
  $x-&gt;is_inf(&quot;-&quot;);        # if $x is -inf
  $x-&gt;is_nan();           # if $x is NaN
  $x-&gt;is_positive();      # if $x &gt; 0
  $x-&gt;is_pos();           # ditto
  $x-&gt;is_negative();      # if $x &lt; 0
  $x-&gt;is_neg();           # ditto
  $x-&gt;is_odd();           # if $x is odd
  $x-&gt;is_even();          # if $x is even
  $x-&gt;is_int();           # if $x is an integer
  # Comparison methods
  $x-&gt;bcmp($y);           # compare numbers (undef, &lt; 0, == 0, &gt; 0)
  $x-&gt;bacmp($y);          # compare absolutely (undef, &lt; 0, == 0, &gt; 0)
  $x-&gt;beq($y);            # true if and only if $x == $y
  $x-&gt;bne($y);            # true if and only if $x != $y
  $x-&gt;blt($y);            # true if and only if $x &lt; $y
  $x-&gt;ble($y);            # true if and only if $x &lt;= $y
  $x-&gt;bgt($y);            # true if and only if $x &gt; $y
  $x-&gt;bge($y);            # true if and only if $x &gt;= $y
  # Arithmetic methods
  $x-&gt;bneg();             # negation
  $x-&gt;babs();             # absolute value
  $x-&gt;bsgn();             # sign function (-1, 0, 1, or NaN)
  $x-&gt;bnorm();            # normalize (no-op)
  $x-&gt;binc();             # increment $x by 1
  $x-&gt;bdec();             # decrement $x by 1
  $x-&gt;badd($y);           # addition (add $y to $x)
  $x-&gt;bsub($y);           # subtraction (subtract $y from $x)
  $x-&gt;bmul($y);           # multiplication (multiply $x by $y)
  $x-&gt;bmuladd($y,$z);     # $x = $x * $y + $z
  $x-&gt;bdiv($y);           # division (floored), set $x to quotient
                          # return (quo,rem) or quo if scalar
  $x-&gt;btdiv($y);          # division (truncated), set $x to quotient
                          # return (quo,rem) or quo if scalar
  $x-&gt;bmod($y);           # modulus (x % y)
  $x-&gt;btmod($y);          # modulus (truncated)
  $x-&gt;bmodinv($mod);      # modular multiplicative inverse
  $x-&gt;bmodpow($y,$mod);   # modular exponentiation (($x ** $y) % $mod)
  $x-&gt;bpow($y);           # power of arguments (x ** y)
  $x-&gt;blog();             # logarithm of $x to base e (Euler's number)
  $x-&gt;blog($base);        # logarithm of $x to base $base (e.g., base 2)
  $x-&gt;bexp();             # calculate e ** $x where e is Euler's number
  $x-&gt;bnok($y);           # x over y (binomial coefficient n over k)
  $x-&gt;bsin();             # sine
  $x-&gt;bcos();             # cosine
  $x-&gt;batan();            # inverse tangent
  $x-&gt;batan2($y);         # two-argument inverse tangent
  $x-&gt;bsqrt();            # calculate square root
  $x-&gt;broot($y);          # $y'th root of $x (e.g. $y == 3 =&gt; cubic root)
  $x-&gt;bfac();             # factorial of $x (1*2*3*4*..$x)
  $x-&gt;blsft($n);          # left shift $n places in base 2
  $x-&gt;blsft($n,$b);       # left shift $n places in base $b
                          # returns (quo,rem) or quo (scalar context)
  $x-&gt;brsft($n);          # right shift $n places in base 2
  $x-&gt;brsft($n,$b);       # right shift $n places in base $b
                          # returns (quo,rem) or quo (scalar context)
  # Bitwise methods
  $x-&gt;band($y);           # bitwise and
  $x-&gt;bior($y);           # bitwise inclusive or
  $x-&gt;bxor($y);           # bitwise exclusive or
  $x-&gt;bnot();             # bitwise not (two's complement)
  # Rounding methods
  $x-&gt;round($A,$P,$mode); # round to accuracy or precision using
                          # rounding mode $mode
  $x-&gt;bround($n);         # accuracy: preserve $n digits
  $x-&gt;bfround($n);        # $n &gt; 0: round to $nth digit left of dec. point
                          # $n &lt; 0: round to $nth digit right of dec. point
  $x-&gt;bfloor();           # round towards minus infinity
  $x-&gt;bceil();            # round towards plus infinity
  $x-&gt;bint();             # round towards zero
  # Other mathematical methods
  $x-&gt;bgcd($y);            # greatest common divisor
  $x-&gt;blcm($y);            # least common multiple
  # Object property methods (do not modify the invocand)
  $x-&gt;sign();              # the sign, either +, - or NaN
  $x-&gt;digit($n);           # the nth digit, counting from the right
  $x-&gt;digit(-$n);          # the nth digit, counting from the left
  $x-&gt;length();            # return number of digits in number
  ($xl,$f) = $x-&gt;length(); # length of number and length of fraction
                           # part, latter is always 0 digits long
                           # for Math::BigInt objects
  $x-&gt;mantissa();          # return (signed) mantissa as BigInt
  $x-&gt;exponent();          # return exponent as BigInt
  $x-&gt;parts();             # return (mantissa,exponent) as BigInt
  $x-&gt;sparts();            # mantissa and exponent (as integers)
  $x-&gt;nparts();            # mantissa and exponent (normalised)
  $x-&gt;eparts();            # mantissa and exponent (engineering notation)
  $x-&gt;dparts();            # integer and fraction part
  # Conversion methods (do not modify the invocand)
  $x-&gt;bstr();         # decimal notation, possibly zero padded
  $x-&gt;bsstr();        # string in scientific notation with integers
  $x-&gt;bnstr();        # string in normalized notation
  $x-&gt;bestr();        # string in engineering notation
  $x-&gt;bdstr();        # string in decimal notation
  $x-&gt;as_hex();       # as signed hexadecimal string with prefixed 0x
  $x-&gt;as_bin();       # as signed binary string with prefixed 0b
  $x-&gt;as_oct();       # as signed octal string with prefixed 0
  $x-&gt;to_ieee754($format); # to bytes encoded according to IEEE 754-2008
  # Other conversion methods
  $x-&gt;numify();           # return as scalar (might overflow or underflow)
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Math::BigFloat provides support for arbitrary precision floating
    point. Overloading is also provided for Perl operators.</p>
<p class="Pp">All operators (including basic math operations) are overloaded if
    you declare your big floating point numbers as</p>
<p class="Pp"></p>
<pre>  $x = Math::BigFloat -&gt; new('12_3.456_789_123_456_789E-2');
</pre>
<p class="Pp">Operations with overloaded operators preserve the arguments, which
    is exactly what you expect.</p>
<section class="Ss">
<h2 class="Ss" id="Input"><a class="permalink" href="#Input">Input</a></h2>
<p class="Pp">Input values to these routines may be any scalar number or string
    that looks like a number and represents a floating point number.</p>
<ul class="Bl-bullet">
  <li>Leading and trailing whitespace is ignored.</li>
  <li>Leading and trailing zeros are ignored.</li>
  <li>If the string has a &quot;0x&quot; prefix, it is interpreted as a
      hexadecimal number.</li>
  <li>If the string has a &quot;0b&quot; prefix, it is interpreted as a binary
      number.</li>
  <li>For hexadecimal and binary numbers, the exponent must be separated from
      the significand (mantissa) by the letter &quot;p&quot; or &quot;P&quot;,
      not &quot;e&quot; or &quot;E&quot; as with decimal numbers.</li>
  <li>One underline is allowed between any two digits, including hexadecimal and
      binary digits.</li>
  <li>If the string can not be interpreted, NaN is returned.</li>
</ul>
<p class="Pp">Octal numbers are typically prefixed by &quot;0&quot;, but since
    leading zeros are stripped, these methods can not automatically recognize
    octal numbers, so use the constructor <b>from_oct()</b> to interpret octal
    strings.</p>
<p class="Pp">Some examples of valid string input</p>
<p class="Pp"></p>
<pre>    Input string                Resulting value
    123                         123
    1.23e2                      123
    12300e-2                    123
    0xcafe                      51966
    0b1101                      13
    67_538_754                  67538754
    -4_5_6.7_8_9e+0_1_0         -4567890000000
    0x1.921fb5p+1               3.14159262180328369140625e+0
    0b1.1001p-4                 9.765625e-2
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Output"><a class="permalink" href="#Output">Output</a></h2>
<p class="Pp">Output values are usually Math::BigFloat objects.</p>
<p class="Pp">Boolean operators <span class="Li">&quot;is_zero()&quot;</span>,
    <span class="Li">&quot;is_one()&quot;</span>,
    <span class="Li">&quot;is_inf()&quot;</span>, etc. return true or false.</p>
<p class="Pp">Comparison operators <span class="Li">&quot;bcmp()&quot;</span>
    and <span class="Li">&quot;bacmp()&quot;</span>) return -1, 0, 1, or
  undef.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<p class="Pp">Math::BigFloat supports all methods that Math::BigInt supports,
    except it calculates non-integer results when possible. Please see
    Math::BigInt for a full description of each method. Below are just the most
    important differences:</p>
<section class="Ss">
<h2 class="Ss" id="Configuration_methods"><a class="permalink" href="#Configuration_methods">Configuration
  methods</a></h2>
<dl class="Bl-tag">
  <dt id="accuracy()"><a class="permalink" href="#accuracy()"><b>accuracy()</b></a></dt>
  <dd>
    <pre>    $x-&gt;accuracy(5);           # local for $x
    CLASS-&gt;accuracy(5);        # global for all members of CLASS
                               # Note: This also applies to new()!
    $A = $x-&gt;accuracy();       # read out accuracy that affects $x
    $A = CLASS-&gt;accuracy();    # read out global accuracy
    </pre>
    <p class="Pp">Set or get the global or local accuracy, aka how many
        significant digits the results have. If you set a global accuracy, then
        this also applies to <b>new()</b>!</p>
    <p class="Pp">Warning! The accuracy <i>sticks</i>, e.g. once you created a
        number under the influence of
        <span class="Li">&quot;CLASS-&gt;accuracy($A)&quot;</span>, all results
        from math operations with that number will also be rounded.</p>
    <p class="Pp">In most cases, you should probably round the results
        explicitly using one of &quot;<b>round()</b>&quot; in Math::BigInt,
        &quot;<b>bround()</b>&quot; in Math::BigInt or
        &quot;<b>bfround()</b>&quot; in Math::BigInt or by passing the desired
        accuracy to the math operation as additional parameter:</p>
    <p class="Pp"></p>
    <pre>    my $x = Math::BigInt-&gt;new(30000);
    my $y = Math::BigInt-&gt;new(7);
    print scalar $x-&gt;copy()-&gt;bdiv($y, 2);           # print 4300
    print scalar $x-&gt;copy()-&gt;bdiv($y)-&gt;bround(2);   # print 4300
    </pre>
  </dd>
  <dt id="precision()"><a class="permalink" href="#precision()"><b>precision()</b></a></dt>
  <dd>
    <pre>    $x-&gt;precision(-2);        # local for $x, round at the second
                              # digit right of the dot
    $x-&gt;precision(2);         # ditto, round at the second digit
                              # left of the dot
    CLASS-&gt;precision(5);      # Global for all members of CLASS
                              # This also applies to new()!
    CLASS-&gt;precision(-5);     # ditto
    $P = CLASS-&gt;precision();  # read out global precision
    $P = $x-&gt;precision();     # read out precision that affects $x
    </pre>
    <p class="Pp">Note: You probably want to use &quot;<b>accuracy()</b>&quot;
        instead. With &quot;<b>accuracy()</b>&quot; you set the number of digits
        each result should have, with &quot;<b>precision()</b>&quot; you set the
        place where to round!</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Constructor_methods"><a class="permalink" href="#Constructor_methods">Constructor
  methods</a></h2>
<dl class="Bl-tag">
  <dt id="from_hex()"><a class="permalink" href="#from_hex()"><b>from_hex()</b></a></dt>
  <dd>
    <pre>    $x -&gt; from_hex(&quot;0x1.921fb54442d18p+1&quot;);
    $x = Math::BigFloat -&gt; from_hex(&quot;0x1.921fb54442d18p+1&quot;);
    </pre>
    <p class="Pp">Interpret input as a hexadecimal string.A prefix
        (&quot;0x&quot;, &quot;x&quot;, ignoring case) is optional. A single
        underscore character (&quot;_&quot;) may be placed between any two
        digits. If the input is invalid, a NaN is returned. The exponent is in
        base 2 using decimal digits.</p>
    <p class="Pp">If called as an instance method, the value is assigned to the
        invocand.</p>
  </dd>
  <dt id="from_oct()"><a class="permalink" href="#from_oct()"><b>from_oct()</b></a></dt>
  <dd>
    <pre>    $x -&gt; from_oct(&quot;1.3267p-4&quot;);
    $x = Math::BigFloat -&gt; from_oct(&quot;1.3267p-4&quot;);
    </pre>
    <p class="Pp">Interpret input as an octal string. A single underscore
        character (&quot;_&quot;) may be placed between any two digits. If the
        input is invalid, a NaN is returned. The exponent is in base 2 using
        decimal digits.</p>
    <p class="Pp">If called as an instance method, the value is assigned to the
        invocand.</p>
  </dd>
  <dt id="from_bin()"><a class="permalink" href="#from_bin()"><b>from_bin()</b></a></dt>
  <dd>
    <pre>    $x -&gt; from_bin(&quot;0b1.1001p-4&quot;);
    $x = Math::BigFloat -&gt; from_bin(&quot;0b1.1001p-4&quot;);
    </pre>
    <p class="Pp">Interpret input as a hexadecimal string. A prefix
        (&quot;0b&quot; or &quot;b&quot;, ignoring case) is optional. A single
        underscore character (&quot;_&quot;) may be placed between any two
        digits. If the input is invalid, a NaN is returned. The exponent is in
        base 2 using decimal digits.</p>
    <p class="Pp">If called as an instance method, the value is assigned to the
        invocand.</p>
  </dd>
  <dt id="from_ieee754()"><a class="permalink" href="#from_ieee754()"><b>from_ieee754()</b></a></dt>
  <dd>Interpret the input as a value encoded as described in IEEE754-2008. The
      input can be given as a byte string, hex string or binary string. The
      input is assumed to be in big-endian byte-order.
    <p class="Pp"></p>
    <pre>        # both $dbl and $mbf are 3.141592...
        $bytes = &quot;\x40\x09\x21\xfb\x54\x44\x2d\x18&quot;;
        $dbl = unpack &quot;d&gt;&quot;, $bytes;
        $mbf = Math::BigFloat -&gt; from_ieee754($bytes, &quot;binary64&quot;);
    </pre>
  </dd>
  <dt id="bpi()"><a class="permalink" href="#bpi()"><b>bpi()</b></a></dt>
  <dd>
    <pre>    print Math::BigFloat-&gt;bpi(100), &quot;\n&quot;;
    </pre>
    <p class="Pp">Calculate PI to N digits (including the 3 before the dot). The
        result is rounded according to the current rounding mode, which defaults
        to &quot;even&quot;.</p>
    <p class="Pp">This method was added in v1.87 of Math::BigInt (June
      2007).</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Arithmetic_methods"><a class="permalink" href="#Arithmetic_methods">Arithmetic
  methods</a></h2>
<dl class="Bl-tag">
  <dt id="bmuladd()"><a class="permalink" href="#bmuladd()"><b>bmuladd()</b></a></dt>
  <dd>
    <pre>    $x-&gt;bmuladd($y,$z);
    </pre>
    <p class="Pp">Multiply <span class="Li">$x</span> by
        <span class="Li">$y</span>, and then add <span class="Li">$z</span> to
        the result.</p>
    <p class="Pp">This method was added in v1.87 of Math::BigInt (June
      2007).</p>
  </dd>
  <dt id="bdiv()"><a class="permalink" href="#bdiv()"><b>bdiv()</b></a></dt>
  <dd>
    <pre>    $q = $x-&gt;bdiv($y);
    ($q, $r) = $x-&gt;bdiv($y);
    </pre>
    <p class="Pp">In scalar context, divides <span class="Li">$x</span> by
        <span class="Li">$y</span> and returns the result to the given or
        default accuracy/precision. In list context, does floored division
        (F-division), returning an integer <span class="Li">$q</span> and a
        remainder <span class="Li">$r</span> so that <span class="Li">$x</span>
        = <span class="Li">$q</span> * <span class="Li">$y</span> +
        <span class="Li">$r</span>. The remainer (modulo) is equal to what is
        returned by <span class="Li">&quot;$x-&gt;bmod($y)&quot;</span>.</p>
  </dd>
  <dt id="bmod()"><a class="permalink" href="#bmod()"><b>bmod()</b></a></dt>
  <dd>
    <pre>    $x-&gt;bmod($y);
    </pre>
    <p class="Pp">Returns <span class="Li">$x</span> modulo
        <span class="Li">$y</span>. When <span class="Li">$x</span> is finite,
        and <span class="Li">$y</span> is finite and non-zero, the result is
        identical to the remainder after floored division (F-division). If, in
        addition, both <span class="Li">$x</span> and <span class="Li">$y</span>
        are integers, the result is identical to the result from Perl's %
        operator.</p>
  </dd>
  <dt id="bexp()"><a class="permalink" href="#bexp()"><b>bexp()</b></a></dt>
  <dd>
    <pre>    $x-&gt;bexp($accuracy);            # calculate e ** X
    </pre>
    <p class="Pp">Calculates the expression <span class="Li">&quot;e **
        $x&quot;</span> where <span class="Li">&quot;e&quot;</span> is Euler's
        number.</p>
    <p class="Pp">This method was added in v1.82 of Math::BigInt (April
      2007).</p>
  </dd>
  <dt id="bnok()"><a class="permalink" href="#bnok()"><b>bnok()</b></a></dt>
  <dd>
    <pre>    $x-&gt;bnok($y);   # x over y (binomial coefficient n over k)
    </pre>
    <p class="Pp">Calculates the binomial coefficient n over k, also called the
        &quot;choose&quot; function. The result is equivalent to:</p>
    <p class="Pp"></p>
    <pre>    ( n )      n!
    | - |  = -------
    ( k )    k!(n-k)!
    </pre>
    <p class="Pp">This method was added in v1.84 of Math::BigInt (April
      2007).</p>
  </dd>
  <dt id="bsin()"><a class="permalink" href="#bsin()"><b>bsin()</b></a></dt>
  <dd>
    <pre>    my $x = Math::BigFloat-&gt;new(1);
    print $x-&gt;bsin(100), &quot;\n&quot;;
    </pre>
    <p class="Pp">Calculate the sinus of <span class="Li">$x</span>, modifying
        <span class="Li">$x</span> in place.</p>
    <p class="Pp">This method was added in v1.87 of Math::BigInt (June
      2007).</p>
  </dd>
  <dt id="bcos()"><a class="permalink" href="#bcos()"><b>bcos()</b></a></dt>
  <dd>
    <pre>    my $x = Math::BigFloat-&gt;new(1);
    print $x-&gt;bcos(100), &quot;\n&quot;;
    </pre>
    <p class="Pp">Calculate the cosinus of <span class="Li">$x</span>, modifying
        <span class="Li">$x</span> in place.</p>
    <p class="Pp">This method was added in v1.87 of Math::BigInt (June
      2007).</p>
  </dd>
  <dt id="batan()"><a class="permalink" href="#batan()"><b>batan()</b></a></dt>
  <dd>
    <pre>    my $x = Math::BigFloat-&gt;new(1);
    print $x-&gt;batan(100), &quot;\n&quot;;
    </pre>
    <p class="Pp">Calculate the arcus tanges of <span class="Li">$x</span>,
        modifying <span class="Li">$x</span> in place. See also
        &quot;<b>batan2()</b>&quot;.</p>
    <p class="Pp">This method was added in v1.87 of Math::BigInt (June
      2007).</p>
  </dd>
  <dt id="batan2()"><a class="permalink" href="#batan2()"><b>batan2()</b></a></dt>
  <dd>
    <pre>    my $y = Math::BigFloat-&gt;new(2);
    my $x = Math::BigFloat-&gt;new(3);
    print $y-&gt;batan2($x), &quot;\n&quot;;
    </pre>
    <p class="Pp">Calculate the arcus tanges of <span class="Li">$y</span>
        divided by <span class="Li">$x</span>, modifying
        <span class="Li">$y</span> in place. See also
        &quot;<b>batan()</b>&quot;.</p>
    <p class="Pp">This method was added in v1.87 of Math::BigInt (June
      2007).</p>
  </dd>
  <dt id="as_float()"><a class="permalink" href="#as_float()"><b>as_float()</b></a></dt>
  <dd>This method is called when Math::BigFloat encounters an object it doesn't
      know how to handle. For instance, assume <span class="Li">$x</span> is a
      Math::BigFloat, or subclass thereof, and <span class="Li">$y</span> is
      defined, but not a Math::BigFloat, or subclass thereof. If you do
    <p class="Pp"></p>
    <pre>    $x -&gt; badd($y);
    </pre>
    <p class="Pp"><span class="Li">$y</span> needs to be converted into an
        object that <span class="Li">$x</span> can deal with. This is done by
        first checking if <span class="Li">$y</span> is something that
        <span class="Li">$x</span> might be upgraded to. If that is the case, no
        further attempts are made. The next is to see if
        <span class="Li">$y</span> supports the method
        <span class="Li">&quot;as_float()&quot;</span>. The method
        <span class="Li">&quot;as_float()&quot;</span> is expected to return
        either an object that has the same class as <span class="Li">$x</span>,
        a subclass thereof, or a string that
        <span class="Li">&quot;ref($x)-&gt;new()&quot;</span> can parse to
        create an object.</p>
    <p class="Pp">In Math::BigFloat,
        <span class="Li">&quot;as_float()&quot;</span> has the same effect as
        <span class="Li">&quot;copy()&quot;</span>.</p>
  </dd>
  <dt id="to_ieee754()"><a class="permalink" href="#to_ieee754()"><b>to_ieee754()</b></a></dt>
  <dd>Encodes the invocand as a byte string in the given format as specified in
      IEEE 754-2008. Note that the encoded value is the nearest possible
      representation of the value. This value might not be exactly the same as
      the value in the invocand.
    <p class="Pp"></p>
    <pre>    # $x = 3.1415926535897932385
    $x = Math::BigFloat -&gt; bpi(30);
    $b = $x -&gt; to_ieee754(&quot;binary64&quot;);  # encode as 8 bytes
    $h = unpack &quot;H*&quot;, $b;               # &quot;400921fb54442d18&quot;
    # 3.141592653589793115997963...
    $y = Math::BigFloat -&gt; from_ieee754($h, &quot;binary64&quot;);
    </pre>
    <p class="Pp">All binary formats in IEEE 754-2008 are accepted. For
        convenience, som aliases are recognized: &quot;half&quot; for
        &quot;binary16&quot;, &quot;single&quot; for &quot;binary32&quot;,
        &quot;double&quot; for &quot;binary64&quot;, &quot;quadruple&quot; for
        &quot;binary128&quot;, &quot;octuple&quot; for &quot;binary256&quot;,
        and &quot;sexdecuple&quot; for &quot;binary512&quot;.</p>
    <p class="Pp">See also &lt;https://en.wikipedia.org/wiki/IEEE_754&gt;.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">ACCURACY AND PRECISION</h2>
<p class="Pp">See also: Rounding.</p>
<p class="Pp">Math::BigFloat supports both precision (rounding to a certain
    place before or after the dot) and accuracy (rounding to a certain number of
    digits). For a full documentation, examples and tips on these topics please
    see the large section about rounding in Math::BigInt.</p>
<p class="Pp">Since things like <span class="Li">sqrt(2)</span> or
    <span class="Li">&quot;1 / 3&quot;</span> must presented with a limited
    accuracy lest a operation consumes all resources, each operation produces no
    more than the requested number of digits.</p>
<p class="Pp">If there is no global precision or accuracy set, <b>and</b> the
    operation in question was not called with a requested precision or accuracy,
    <b>and</b> the input <span class="Li">$x</span> has no accuracy or precision
    set, then a fallback parameter will be used. For historical reasons, it is
    called <span class="Li">&quot;div_scale&quot;</span> and can be accessed
    via:</p>
<p class="Pp"></p>
<pre>    $d = Math::BigFloat-&gt;div_scale();       # query
    Math::BigFloat-&gt;div_scale($n);          # set to $n digits
</pre>
<p class="Pp">The default value for
    <span class="Li">&quot;div_scale&quot;</span> is 40.</p>
<p class="Pp">In case the result of one operation has more digits than
    specified, it is rounded. The rounding mode taken is either the default
    mode, or the one supplied to the operation after the <i>scale</i>:</p>
<p class="Pp"></p>
<pre>    $x = Math::BigFloat-&gt;new(2);
    Math::BigFloat-&gt;accuracy(5);              # 5 digits max
    $y = $x-&gt;copy()-&gt;bdiv(3);                 # gives 0.66667
    $y = $x-&gt;copy()-&gt;bdiv(3,6);               # gives 0.666667
    $y = $x-&gt;copy()-&gt;bdiv(3,6,undef,'odd');   # gives 0.666667
    Math::BigFloat-&gt;round_mode('zero');
    $y = $x-&gt;copy()-&gt;bdiv(3,6);               # will also give 0.666667
</pre>
<p class="Pp">Note that
    <span class="Li">&quot;Math::BigFloat-&gt;accuracy()&quot;</span> and
    <span class="Li">&quot;Math::BigFloat-&gt;precision()&quot;</span> set the
    global variables, and thus <b>any</b> newly created number will be subject
    to the global rounding <b>immediately</b>. This means that in the examples
    above, the <span class="Li">3</span> as argument to
    <span class="Li">&quot;bdiv()&quot;</span> will also get an accuracy of
    <b>5</b>.</p>
<p class="Pp">It is less confusing to either calculate the result fully, and
    afterwards round it explicitly, or use the additional parameters to the math
    functions like so:</p>
<p class="Pp"></p>
<pre>    use Math::BigFloat;
    $x = Math::BigFloat-&gt;new(2);
    $y = $x-&gt;copy()-&gt;bdiv(3);
    print $y-&gt;bround(5),&quot;\n&quot;;               # gives 0.66667
    or
    use Math::BigFloat;
    $x = Math::BigFloat-&gt;new(2);
    $y = $x-&gt;copy()-&gt;bdiv(3,5);             # gives 0.66667
    print &quot;$y\n&quot;;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Rounding"><a class="permalink" href="#Rounding">Rounding</a></h2>
<dl class="Bl-tag">
  <dt id="bfround"><a class="permalink" href="#bfround">bfround ( +$scale
    )</a></dt>
  <dd>Rounds to the <span class="Li">$scale</span>'th place left from the '.',
      counting from the dot. The first digit is numbered 1.</dd>
  <dt id="bfround~2"><a class="permalink" href="#bfround~2">bfround ( -$scale
    )</a></dt>
  <dd>Rounds to the <span class="Li">$scale</span>'th place right from the '.',
      counting from the dot.</dd>
  <dt id="bfround~3"><a class="permalink" href="#bfround~3">bfround ( 0
    )</a></dt>
  <dd>Rounds to an integer.</dd>
  <dt id="bround"><a class="permalink" href="#bround">bround ( +$scale
    )</a></dt>
  <dd>Preserves accuracy to <span class="Li">$scale</span> digits from the left
      (aka significant digits) and pads the rest with zeros. If the number is
      between 1 and -1, the significant digits count from the first non-zero
      after the '.'</dd>
  <dt id="bround~2"><a class="permalink" href="#bround~2">bround ( -$scale ) and
    bround ( 0 )</a></dt>
  <dd>These are effectively no-ops.</dd>
</dl>
<p class="Pp">All rounding functions take as a second parameter a rounding mode
    from one of the following: 'even', 'odd', '+inf', '-inf', 'zero', 'trunc' or
    'common'.</p>
<p class="Pp">The default rounding mode is 'even'. By using
    <span class="Li">&quot;Math::BigFloat-&gt;round_mode($round_mode);&quot;</span>
    you can get and set the default mode for subsequent rounding. The usage of
    <span class="Li">&quot;$Math::BigFloat::$round_mode&quot;</span> is no
    longer supported. The second parameter to the round functions then overrides
    the default temporarily.</p>
<p class="Pp">The <span class="Li">&quot;as_number()&quot;</span> function
    returns a BigInt from a Math::BigFloat. It uses 'trunc' as rounding mode to
    make it equivalent to:</p>
<p class="Pp"></p>
<pre>    $x = 2.5;
    $y = int($x) + 2;
</pre>
<p class="Pp">You can override this by passing the desired rounding mode as
    parameter to <span class="Li">&quot;as_number()&quot;</span>:</p>
<p class="Pp"></p>
<pre>    $x = Math::BigFloat-&gt;new(2.5);
    $y = $x-&gt;as_number('odd');      # $y = 3
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Autocreating_constants"><a class="permalink" href="#Autocreating_constants">Autocreating
  constants</a></h1>
<p class="Pp">After <span class="Li">&quot;use Math::BigFloat
    ':constant'&quot;</span> all the floating point constants in the given scope
    are converted to <span class="Li">&quot;Math::BigFloat&quot;</span>. This
    conversion happens at compile time.</p>
<p class="Pp">In particular</p>
<p class="Pp"></p>
<pre>    perl -MMath::BigFloat=:constant -e 'print 2E-100,&quot;\n&quot;'
</pre>
<p class="Pp">prints the value of <span class="Li">&quot;2E-100&quot;</span>.
    Note that without conversion of constants the expression 2E-100 will be
    calculated as normal floating point number.</p>
<p class="Pp">Please note that ':constant' does not affect integer constants,
    nor binary nor hexadecimal constants. Use bignum or Math::BigInt to get this
    to work.</p>
<section class="Ss">
<h2 class="Ss" id="Math_library"><a class="permalink" href="#Math_library">Math
  library</a></h2>
<p class="Pp">Math with the numbers is done (by default) by a module called
    Math::BigInt::Calc. This is equivalent to saying:</p>
<p class="Pp"></p>
<pre>    use Math::BigFloat lib =&gt; 'Calc';
</pre>
<p class="Pp">You can change this by using:</p>
<p class="Pp"></p>
<pre>    use Math::BigFloat lib =&gt; 'GMP';
</pre>
<p class="Pp"><b>Note</b>: General purpose packages should not be explicit about
    the library to use; let the script author decide which is best.</p>
<p class="Pp">Note: The keyword 'lib' will warn when the requested library could
    not be loaded. To suppress the warning use 'try' instead:</p>
<p class="Pp"></p>
<pre>    use Math::BigFloat try =&gt; 'GMP';
</pre>
<p class="Pp">If your script works with huge numbers and Calc is too slow for
    them, you can also for the loading of one of these libraries and if none of
    them can be used, the code will die:</p>
<p class="Pp"></p>
<pre>    use Math::BigFloat only =&gt; 'GMP,Pari';
</pre>
<p class="Pp">The following would first try to find Math::BigInt::Foo, then
    Math::BigInt::Bar, and when this also fails, revert to
  Math::BigInt::Calc:</p>
<p class="Pp"></p>
<pre>    use Math::BigFloat lib =&gt; 'Foo,Math::BigInt::Bar';
</pre>
<p class="Pp">See the respective low-level library documentation for further
    details.</p>
<p class="Pp">Please note that Math::BigFloat does <b>not</b> use the denoted
    library itself, but it merely passes the lib argument to Math::BigInt. So,
    instead of the need to do:</p>
<p class="Pp"></p>
<pre>    use Math::BigInt lib =&gt; 'GMP';
    use Math::BigFloat;
</pre>
<p class="Pp">you can roll it all into one line:</p>
<p class="Pp"></p>
<pre>    use Math::BigFloat lib =&gt; 'GMP';
</pre>
<p class="Pp">It is also possible to just require Math::BigFloat:</p>
<p class="Pp"></p>
<pre>    require Math::BigFloat;
</pre>
<p class="Pp">This will load the necessary things (like BigInt) when they are
    needed, and automatically.</p>
<p class="Pp">See Math::BigInt for more details than you ever wanted to know
    about using a different low-level library.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_Math::BigInt::Lite"><a class="permalink" href="#Using_Math::BigInt::Lite">Using
  Math::BigInt::Lite</a></h2>
<p class="Pp">For backwards compatibility reasons it is still possible to
    request a different storage class for use with Math::BigFloat:</p>
<p class="Pp"></p>
<pre>    use Math::BigFloat with =&gt; 'Math::BigInt::Lite';
</pre>
<p class="Pp">However, this request is ignored, as the current code now uses the
    low-level math library for directly storing the number parts.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTS"><a class="permalink" href="#EXPORTS">EXPORTS</a></h1>
<p class="Pp"><span class="Li">&quot;Math::BigFloat&quot;</span> exports nothing
    by default, but can export the <span class="Li">&quot;bpi()&quot;</span>
    method:</p>
<p class="Pp"></p>
<pre>    use Math::BigFloat qw/bpi/;
    print bpi(10), &quot;\n&quot;;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<p class="Pp">Do not try to be clever to insert some operations in between
    switching libraries:</p>
<p class="Pp"></p>
<pre>    require Math::BigFloat;
    my $matter = Math::BigFloat-&gt;bone() + 4;    # load BigInt and Calc
    Math::BigFloat-&gt;import( lib =&gt; 'Pari' );    # load Pari, too
    my $anti_matter = Math::BigFloat-&gt;bone()+4; # now use Pari
</pre>
<p class="Pp">This will create objects with numbers stored in two different
    backend libraries, and <b>VERY BAD THINGS</b> will happen when you use these
    together:</p>
<p class="Pp"></p>
<pre>    my $flash_and_bang = $matter + $anti_matter;    # Don't do this!
</pre>
<dl class="Bl-tag">
  <dt id="stringify,"><a class="permalink" href="#stringify,">stringify,
    <b>bstr()</b></a></dt>
  <dd>Both stringify and <b>bstr()</b> now drop the leading '+'. The old code
      would return '+1.23', the new returns '1.23'. See the documentation in
      Math::BigInt for reasoning and details.</dd>
  <dt id="brsft()"><a class="permalink" href="#brsft()"><b>brsft()</b></a></dt>
  <dd>The following will probably not print what you expect:
    <p class="Pp"></p>
    <pre>    my $c = Math::BigFloat-&gt;new('3.14159');
    print $c-&gt;brsft(3,10),&quot;\n&quot;;     # prints 0.00314153.1415
    </pre>
    <p class="Pp">It prints both quotient and remainder, since print calls
        <span class="Li">&quot;brsft()&quot;</span> in list context. Also,
        <span class="Li">&quot;$c-&gt;brsft()&quot;</span> will modify
        <span class="Li">$c</span>, so be careful. You probably want to use</p>
    <p class="Pp"></p>
    <pre>    print scalar $c-&gt;copy()-&gt;brsft(3,10),&quot;\n&quot;;
    # or if you really want to modify $c
    print scalar $c-&gt;brsft(3,10),&quot;\n&quot;;
    </pre>
    <p class="Pp">instead.</p>
  </dd>
  <dt id="Modifying"><a class="permalink" href="#Modifying">Modifying and
    =</a></dt>
  <dd>Beware of:
    <p class="Pp"></p>
    <pre>    $x = Math::BigFloat-&gt;new(5);
    $y = $x;
    </pre>
    <p class="Pp">It will not do what you think, e.g. making a copy of
        <span class="Li">$x</span>. Instead it just makes a second reference to
        the <b>same</b> object and stores it in <span class="Li">$y</span>. Thus
        anything that modifies <span class="Li">$x</span> will modify
        <span class="Li">$y</span> (except overloaded math operators), and vice
        versa. See Math::BigInt for details and how to avoid that.</p>
  </dd>
  <dt id="precision()~2"><a class="permalink" href="#precision()~2"><b>precision()</b>
    vs. <b>accuracy()</b></a></dt>
  <dd>A common pitfall is to use &quot;<b>precision()</b>&quot; when you want to
      round a result to a certain number of digits:
    <p class="Pp"></p>
    <pre>    use Math::BigFloat;
    Math::BigFloat-&gt;precision(4);           # does not do what you
                                            # think it does
    my $x = Math::BigFloat-&gt;new(12345);     # rounds $x to &quot;12000&quot;!
    print &quot;$x\n&quot;;                           # print &quot;12000&quot;
    my $y = Math::BigFloat-&gt;new(3);         # rounds $y to &quot;0&quot;!
    print &quot;$y\n&quot;;                           # print &quot;0&quot;
    $z = $x / $y;                           # 12000 / 0 =&gt; NaN!
    print &quot;$z\n&quot;;
    print $z-&gt;precision(),&quot;\n&quot;;             # 4
    </pre>
    <p class="Pp">Replacing &quot;<b>precision()</b>&quot; with
        &quot;<b>accuracy()</b>&quot; is probably not what you want, either:</p>
    <p class="Pp"></p>
    <pre>    use Math::BigFloat;
    Math::BigFloat-&gt;accuracy(4);          # enables global rounding:
    my $x = Math::BigFloat-&gt;new(123456);  # rounded immediately
                                          #   to &quot;12350&quot;
    print &quot;$x\n&quot;;                         # print &quot;123500&quot;
    my $y = Math::BigFloat-&gt;new(3);       # rounded to &quot;3
    print &quot;$y\n&quot;;                         # print &quot;3&quot;
    print $z = $x-&gt;copy()-&gt;bdiv($y),&quot;\n&quot;; # 41170
    print $z-&gt;accuracy(),&quot;\n&quot;;            # 4
    </pre>
    <p class="Pp">What you want to use instead is:</p>
    <p class="Pp"></p>
    <pre>    use Math::BigFloat;
    my $x = Math::BigFloat-&gt;new(123456);    # no rounding
    print &quot;$x\n&quot;;                           # print &quot;123456&quot;
    my $y = Math::BigFloat-&gt;new(3);         # no rounding
    print &quot;$y\n&quot;;                           # print &quot;3&quot;
    print $z = $x-&gt;copy()-&gt;bdiv($y,4),&quot;\n&quot;; # 41150
    print $z-&gt;accuracy(),&quot;\n&quot;;              # undef
    </pre>
    <p class="Pp">In addition to computing what you expected, the last example
        also does <b>not</b> &quot;taint&quot; the result with an accuracy or
        precision setting, which would influence any further operation.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">Please report any bugs or feature requests to
    <span class="Li">&quot;bug-math-bigint at rt.cpan.org&quot;</span>, or
    through the web interface at
    &lt;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt&gt; (requires
    login). We will be notified, and then you'll automatically be notified of
    progress on your bug as I make changes.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
<p class="Pp">You can find documentation for this module with the perldoc
    command.</p>
<p class="Pp"></p>
<pre>    perldoc Math::BigFloat
</pre>
<p class="Pp">You can also look for information at:</p>
<ul class="Bl-bullet">
  <li>RT: CPAN's request tracker
    <p class="Pp">&lt;https://rt.cpan.org/Public/Dist/Display.html?Name=Math-BigInt&gt;</p>
  </li>
  <li>AnnoCPAN: Annotated CPAN documentation
    <p class="Pp">&lt;http://annocpan.org/dist/Math-BigInt&gt;</p>
  </li>
  <li>CPAN Ratings
    <p class="Pp">&lt;https://cpanratings.perl.org/dist/Math-BigInt&gt;</p>
  </li>
  <li>MetaCPAN
    <p class="Pp">&lt;https://metacpan.org/release/Math-BigInt&gt;</p>
  </li>
  <li>CPAN Testers Matrix
    <p class="Pp">&lt;http://matrix.cpantesters.org/?dist=Math-BigInt&gt;</p>
  </li>
  <li>The Bignum mailing list</li>
</ul>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>Post to mailing list
    <p class="Pp"><span class="Li">&quot;bignum at
        lists.scsys.co.uk&quot;</span></p>
  </li>
  <li>View mailing list
    <p class="Pp">&lt;http://lists.scsys.co.uk/pipermail/bignum/&gt;</p>
  </li>
  <li>Subscribe/Unsubscribe
    <p class="Pp">&lt;http://lists.scsys.co.uk/cgi-bin/mailman/listinfo/bignum&gt;</p>
  </li>
</ul>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">This program is free software; you may redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Math::BigFloat and Math::BigInt as well as the backends
    Math::BigInt::FastCalc, Math::BigInt::GMP, and Math::BigInt::Pari.</p>
<p class="Pp">The pragmas bignum, bigint and bigrat also might be of interest
    because they solve the autoupgrading/downgrading issue, at least partly.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Mark Biggar, overloaded interface by Ilya Zakharevich, 1996-2001.</li>
  <li>Completely rewritten by Tels &lt;http://bloodgate.com&gt; in
    2001-2008.</li>
  <li>Florian Ragwitz &lt;flora@cpan.org&gt;, 2010.</li>
  <li>Peter John Acklam &lt;pjacklam@online.no&gt;, 2011-.</li>
</ul>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os"><a href="..">perl v5.34.1</a></td>
  </tr>
</table>
</body>
</html>

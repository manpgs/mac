<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Math::BigInt(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Math::BigInt(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Math::BigInt(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Math::BigInt - Arbitrary size integer/float math package</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  use Math::BigInt;
  # or make it faster with huge numbers: install (optional)
  # Math::BigInt::GMP and always use (it falls back to
  # pure Perl if the GMP library is not installed):
  # (See also the L&lt;MATH LIBRARY&gt; section!)
  # warns if Math::BigInt::GMP cannot be found
  use Math::BigInt lib =&gt; 'GMP';
  # to suppress the warning use this:
  # use Math::BigInt try =&gt; 'GMP';
  # dies if GMP cannot be loaded:
  # use Math::BigInt only =&gt; 'GMP';
  my $str = '1234567890';
  my @values = (64, 74, 18);
  my $n = 1; my $sign = '-';
  # Configuration methods (may be used as class methods and instance methods)
  Math::BigInt-&gt;accuracy();     # get class accuracy
  Math::BigInt-&gt;accuracy($n);   # set class accuracy
  Math::BigInt-&gt;precision();    # get class precision
  Math::BigInt-&gt;precision($n);  # set class precision
  Math::BigInt-&gt;round_mode();   # get class rounding mode
  Math::BigInt-&gt;round_mode($m); # set global round mode, must be one of
                                # 'even', 'odd', '+inf', '-inf', 'zero',
                                # 'trunc', or 'common'
  Math::BigInt-&gt;config();       # return hash with configuration
  # Constructor methods (when the class methods below are used as instance
  # methods, the value is assigned the invocand)
  $x = Math::BigInt-&gt;new($str);             # defaults to 0
  $x = Math::BigInt-&gt;new('0x123');          # from hexadecimal
  $x = Math::BigInt-&gt;new('0b101');          # from binary
  $x = Math::BigInt-&gt;from_hex('cafe');      # from hexadecimal
  $x = Math::BigInt-&gt;from_oct('377');       # from octal
  $x = Math::BigInt-&gt;from_bin('1101');      # from binary
  $x = Math::BigInt-&gt;from_base('why', 36);  # from any base
  $x = Math::BigInt-&gt;bzero();               # create a +0
  $x = Math::BigInt-&gt;bone();                # create a +1
  $x = Math::BigInt-&gt;bone('-');             # create a -1
  $x = Math::BigInt-&gt;binf();                # create a +inf
  $x = Math::BigInt-&gt;binf('-');             # create a -inf
  $x = Math::BigInt-&gt;bnan();                # create a Not-A-Number
  $x = Math::BigInt-&gt;bpi();                 # returns pi
  $y = $x-&gt;copy();         # make a copy (unlike $y = $x)
  $y = $x-&gt;as_int();       # return as a Math::BigInt
  # Boolean methods (these don't modify the invocand)
  $x-&gt;is_zero();          # if $x is 0
  $x-&gt;is_one();           # if $x is +1
  $x-&gt;is_one(&quot;+&quot;);        # ditto
  $x-&gt;is_one(&quot;-&quot;);        # if $x is -1
  $x-&gt;is_inf();           # if $x is +inf or -inf
  $x-&gt;is_inf(&quot;+&quot;);        # if $x is +inf
  $x-&gt;is_inf(&quot;-&quot;);        # if $x is -inf
  $x-&gt;is_nan();           # if $x is NaN
  $x-&gt;is_positive();      # if $x &gt; 0
  $x-&gt;is_pos();           # ditto
  $x-&gt;is_negative();      # if $x &lt; 0
  $x-&gt;is_neg();           # ditto
  $x-&gt;is_odd();           # if $x is odd
  $x-&gt;is_even();          # if $x is even
  $x-&gt;is_int();           # if $x is an integer
  # Comparison methods
  $x-&gt;bcmp($y);           # compare numbers (undef, &lt; 0, == 0, &gt; 0)
  $x-&gt;bacmp($y);          # compare absolutely (undef, &lt; 0, == 0, &gt; 0)
  $x-&gt;beq($y);            # true if and only if $x == $y
  $x-&gt;bne($y);            # true if and only if $x != $y
  $x-&gt;blt($y);            # true if and only if $x &lt; $y
  $x-&gt;ble($y);            # true if and only if $x &lt;= $y
  $x-&gt;bgt($y);            # true if and only if $x &gt; $y
  $x-&gt;bge($y);            # true if and only if $x &gt;= $y
  # Arithmetic methods
  $x-&gt;bneg();             # negation
  $x-&gt;babs();             # absolute value
  $x-&gt;bsgn();             # sign function (-1, 0, 1, or NaN)
  $x-&gt;bnorm();            # normalize (no-op)
  $x-&gt;binc();             # increment $x by 1
  $x-&gt;bdec();             # decrement $x by 1
  $x-&gt;badd($y);           # addition (add $y to $x)
  $x-&gt;bsub($y);           # subtraction (subtract $y from $x)
  $x-&gt;bmul($y);           # multiplication (multiply $x by $y)
  $x-&gt;bmuladd($y,$z);     # $x = $x * $y + $z
  $x-&gt;bdiv($y);           # division (floored), set $x to quotient
                          # return (quo,rem) or quo if scalar
  $x-&gt;btdiv($y);          # division (truncated), set $x to quotient
                          # return (quo,rem) or quo if scalar
  $x-&gt;bmod($y);           # modulus (x % y)
  $x-&gt;btmod($y);          # modulus (truncated)
  $x-&gt;bmodinv($mod);      # modular multiplicative inverse
  $x-&gt;bmodpow($y,$mod);   # modular exponentiation (($x ** $y) % $mod)
  $x-&gt;bpow($y);           # power of arguments (x ** y)
  $x-&gt;blog();             # logarithm of $x to base e (Euler's number)
  $x-&gt;blog($base);        # logarithm of $x to base $base (e.g., base 2)
  $x-&gt;bexp();             # calculate e ** $x where e is Euler's number
  $x-&gt;bnok($y);           # x over y (binomial coefficient n over k)
  $x-&gt;bsin();             # sine
  $x-&gt;bcos();             # cosine
  $x-&gt;batan();            # inverse tangent
  $x-&gt;batan2($y);         # two-argument inverse tangent
  $x-&gt;bsqrt();            # calculate square root
  $x-&gt;broot($y);          # $y'th root of $x (e.g. $y == 3 =&gt; cubic root)
  $x-&gt;bfac();             # factorial of $x (1*2*3*4*..$x)
  $x-&gt;blsft($n);          # left shift $n places in base 2
  $x-&gt;blsft($n,$b);       # left shift $n places in base $b
                          # returns (quo,rem) or quo (scalar context)
  $x-&gt;brsft($n);          # right shift $n places in base 2
  $x-&gt;brsft($n,$b);       # right shift $n places in base $b
                          # returns (quo,rem) or quo (scalar context)
  # Bitwise methods
  $x-&gt;band($y);           # bitwise and
  $x-&gt;bior($y);           # bitwise inclusive or
  $x-&gt;bxor($y);           # bitwise exclusive or
  $x-&gt;bnot();             # bitwise not (two's complement)
  # Rounding methods
  $x-&gt;round($A,$P,$mode); # round to accuracy or precision using
                          # rounding mode $mode
  $x-&gt;bround($n);         # accuracy: preserve $n digits
  $x-&gt;bfround($n);        # $n &gt; 0: round to $nth digit left of dec. point
                          # $n &lt; 0: round to $nth digit right of dec. point
  $x-&gt;bfloor();           # round towards minus infinity
  $x-&gt;bceil();            # round towards plus infinity
  $x-&gt;bint();             # round towards zero
  # Other mathematical methods
  $x-&gt;bgcd($y);            # greatest common divisor
  $x-&gt;blcm($y);            # least common multiple
  # Object property methods (do not modify the invocand)
  $x-&gt;sign();              # the sign, either +, - or NaN
  $x-&gt;digit($n);           # the nth digit, counting from the right
  $x-&gt;digit(-$n);          # the nth digit, counting from the left
  $x-&gt;length();            # return number of digits in number
  ($xl,$f) = $x-&gt;length(); # length of number and length of fraction
                           # part, latter is always 0 digits long
                           # for Math::BigInt objects
  $x-&gt;mantissa();          # return (signed) mantissa as a Math::BigInt
  $x-&gt;exponent();          # return exponent as a Math::BigInt
  $x-&gt;parts();             # return (mantissa,exponent) as a Math::BigInt
  $x-&gt;sparts();            # mantissa and exponent (as integers)
  $x-&gt;nparts();            # mantissa and exponent (normalised)
  $x-&gt;eparts();            # mantissa and exponent (engineering notation)
  $x-&gt;dparts();            # integer and fraction part
  # Conversion methods (do not modify the invocand)
  $x-&gt;bstr();         # decimal notation, possibly zero padded
  $x-&gt;bsstr();        # string in scientific notation with integers
  $x-&gt;bnstr();        # string in normalized notation
  $x-&gt;bestr();        # string in engineering notation
  $x-&gt;bdstr();        # string in decimal notation
  $x-&gt;to_hex();       # as signed hexadecimal string
  $x-&gt;to_bin();       # as signed binary string
  $x-&gt;to_oct();       # as signed octal string
  $x-&gt;to_bytes();     # as byte string
  $x-&gt;to_base($b);    # as string in any base
  $x-&gt;as_hex();       # as signed hexadecimal string with prefixed 0x
  $x-&gt;as_bin();       # as signed binary string with prefixed 0b
  $x-&gt;as_oct();       # as signed octal string with prefixed 0
  # Other conversion methods
  $x-&gt;numify();           # return as scalar (might overflow or underflow)
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Math::BigInt provides support for arbitrary precision integers.
    Overloading is also provided for Perl operators.</p>
<section class="Ss">
<h2 class="Ss" id="Input"><a class="permalink" href="#Input">Input</a></h2>
<p class="Pp">Input values to these routines may be any scalar number or string
    that looks like a number and represents an integer.</p>
<ul class="Bl-bullet">
  <li>Leading and trailing whitespace is ignored.</li>
  <li>Leading and trailing zeros are ignored.</li>
  <li>If the string has a &quot;0x&quot; prefix, it is interpreted as a
      hexadecimal number.</li>
  <li>If the string has a &quot;0b&quot; prefix, it is interpreted as a binary
      number.</li>
  <li>One underline is allowed between any two digits.</li>
  <li>If the string can not be interpreted, NaN is returned.</li>
</ul>
<p class="Pp">Octal numbers are typically prefixed by &quot;0&quot;, but since
    leading zeros are stripped, these methods can not automatically recognize
    octal numbers, so use the constructor <b>from_oct()</b> to interpret octal
    strings.</p>
<p class="Pp">Some examples of valid string input</p>
<p class="Pp"></p>
<pre>    Input string                Resulting value
    123                         123
    1.23e2                      123
    12300e-2                    123
    0xcafe                      51966
    0b1101                      13
    67_538_754                  67538754
    -4_5_6.7_8_9e+0_1_0         -4567890000000
</pre>
<p class="Pp">Input given as scalar numbers might lose precision. Quote your
    input to ensure that no digits are lost:</p>
<p class="Pp"></p>
<pre>    $x = Math::BigInt-&gt;new( 56789012345678901234 );   # bad
    $x = Math::BigInt-&gt;new('56789012345678901234');   # good
</pre>
<p class="Pp">Currently, Math::BigInt-&gt;<b>new()</b> defaults to 0, while
    Math::BigInt-&gt;new('') results in 'NaN'. This might change in the future,
    so use always the following explicit forms to get a zero or NaN:</p>
<p class="Pp"></p>
<pre>    $zero = Math::BigInt-&gt;bzero();
    $nan  = Math::BigInt-&gt;bnan();
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Output"><a class="permalink" href="#Output">Output</a></h2>
<p class="Pp">Output values are usually Math::BigInt objects.</p>
<p class="Pp">Boolean operators <span class="Li">&quot;is_zero()&quot;</span>,
    <span class="Li">&quot;is_one()&quot;</span>,
    <span class="Li">&quot;is_inf()&quot;</span>, etc. return true or false.</p>
<p class="Pp">Comparison operators <span class="Li">&quot;bcmp()&quot;</span>
    and <span class="Li">&quot;bacmp()&quot;</span>) return -1, 0, 1, or
  undef.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Configuration_methods"><a class="permalink" href="#Configuration_methods">Configuration
  methods</a></h2>
<p class="Pp">Each of the methods below (except <b>config()</b>,
    <b>accuracy()</b> and <b>precision()</b>) accepts three additional
    parameters. These arguments <span class="Li">$A</span>,
    <span class="Li">$P</span> and <span class="Li">$R</span> are
    <span class="Li">&quot;accuracy&quot;</span>,
    <span class="Li">&quot;precision&quot;</span> and
    <span class="Li">&quot;round_mode&quot;</span>. Please see the section about
    &quot;ACCURACY and PRECISION&quot; for more information.</p>
<p class="Pp">Setting a class variable effects all object instance that are
    created afterwards.</p>
<dl class="Bl-tag">
  <dt id="accuracy()"><a class="permalink" href="#accuracy()"><b>accuracy()</b></a></dt>
  <dd>
    <pre>    Math::BigInt-&gt;accuracy(5);      # set class accuracy
    $x-&gt;accuracy(5);                # set instance accuracy
    $A = Math::BigInt-&gt;accuracy();  # get class accuracy
    $A = $x-&gt;accuracy();            # get instance accuracy
    </pre>
    <p class="Pp">Set or get the accuracy, i.e., the number of significant
        digits. The accuracy must be an integer. If the accuracy is set to
        <span class="Li">&quot;undef&quot;</span>, no rounding is done.</p>
    <p class="Pp">Alternatively, one can round the results explicitly using one
        of &quot;<b>round()</b>&quot;, &quot;<b>bround()</b>&quot; or
        &quot;<b>bfround()</b>&quot; or by passing the desired accuracy to the
        method as an additional parameter:</p>
    <p class="Pp"></p>
    <pre>    my $x = Math::BigInt-&gt;new(30000);
    my $y = Math::BigInt-&gt;new(7);
    print scalar $x-&gt;copy()-&gt;bdiv($y, 2);               # prints 4300
    print scalar $x-&gt;copy()-&gt;bdiv($y)-&gt;bround(2);       # prints 4300
    </pre>
    <p class="Pp">Please see the section about &quot;ACCURACY and
        PRECISION&quot; for further details.</p>
    <p class="Pp"></p>
    <pre>    $y = Math::BigInt-&gt;new(1234567);    # $y is not rounded
    Math::BigInt-&gt;accuracy(4);          # set class accuracy to 4
    $x = Math::BigInt-&gt;new(1234567);    # $x is rounded automatically
    print &quot;$x $y&quot;;                      # prints &quot;1235000 1234567&quot;
    print $x-&gt;accuracy();       # prints &quot;4&quot;
    print $y-&gt;accuracy();       # also prints &quot;4&quot;, since
                                #   class accuracy is 4
    Math::BigInt-&gt;accuracy(5);  # set class accuracy to 5
    print $x-&gt;accuracy();       # prints &quot;4&quot;, since instance
                                #   accuracy is 4
    print $y-&gt;accuracy();       # prints &quot;5&quot;, since no instance
                                #   accuracy, and class accuracy is 5
    </pre>
    <p class="Pp">Note: Each class has it's own globals separated from
        Math::BigInt, but it is possible to subclass Math::BigInt and make the
        globals of the subclass aliases to the ones from Math::BigInt.</p>
  </dd>
  <dt id="precision()"><a class="permalink" href="#precision()"><b>precision()</b></a></dt>
  <dd>
    <pre>    Math::BigInt-&gt;precision(-2);     # set class precision
    $x-&gt;precision(-2);               # set instance precision
    $P = Math::BigInt-&gt;precision();  # get class precision
    $P = $x-&gt;precision();            # get instance precision
    </pre>
    <p class="Pp">Set or get the precision, i.e., the place to round relative to
        the decimal point. The precision must be a integer. Setting the
        precision to <span class="Li">$P</span> means that each number is
        rounded up or down, depending on the rounding mode, to the nearest
        multiple of 10**$P. If the precision is set to
        <span class="Li">&quot;undef&quot;</span>, no rounding is done.</p>
    <p class="Pp">You might want to use &quot;<b>accuracy()</b>&quot; instead.
        With &quot;<b>accuracy()</b>&quot; you set the number of digits each
        result should have, with &quot;<b>precision()</b>&quot; you set the
        place where to round.</p>
    <p class="Pp">Please see the section about &quot;ACCURACY and
        PRECISION&quot; for further details.</p>
    <p class="Pp"></p>
    <pre>    $y = Math::BigInt-&gt;new(1234567);    # $y is not rounded
    Math::BigInt-&gt;precision(4);         # set class precision to 4
    $x = Math::BigInt-&gt;new(1234567);    # $x is rounded automatically
    print $x;                           # prints &quot;1230000&quot;
    </pre>
    <p class="Pp">Note: Each class has its own globals separated from
        Math::BigInt, but it is possible to subclass Math::BigInt and make the
        globals of the subclass aliases to the ones from Math::BigInt.</p>
  </dd>
  <dt id="div_scale()"><a class="permalink" href="#div_scale()"><b>div_scale()</b></a></dt>
  <dd>Set/get the fallback accuracy. This is the accuracy used when neither
      accuracy nor precision is set explicitly. It is used when a computation
      might otherwise attempt to return an infinite number of digits.</dd>
  <dt id="round_mode()"><a class="permalink" href="#round_mode()"><b>round_mode()</b></a></dt>
  <dd>Set/get the rounding mode.</dd>
  <dt id="upgrade()"><a class="permalink" href="#upgrade()"><b>upgrade()</b></a></dt>
  <dd>Set/get the class for upgrading. When a computation might result in a
      non-integer, the operands are upgraded to this class. This is used for
      instance by bignum. The default is
      <span class="Li">&quot;undef&quot;</span>, thus the following operation
      creates a Math::BigInt, not a Math::BigFloat:
    <p class="Pp"></p>
    <pre>    my $i = Math::BigInt-&gt;new(123);
    my $f = Math::BigFloat-&gt;new('123.1');
    print $i + $f, &quot;\n&quot;;                # prints 246
    </pre>
  </dd>
  <dt id="downgrade()"><a class="permalink" href="#downgrade()"><b>downgrade()</b></a></dt>
  <dd>Set/get the class for downgrading. The default is
      <span class="Li">&quot;undef&quot;</span>. Downgrading is not done by
      Math::BigInt.</dd>
  <dt id="modify()"><a class="permalink" href="#modify()"><b>modify()</b></a></dt>
  <dd>
    <pre>    $x-&gt;modify('bpowd');
    </pre>
    <p class="Pp">This method returns 0 if the object can be modified with the
        given operation, or 1 if not.</p>
    <p class="Pp">This is used for instance by Math::BigInt::Constant.</p>
  </dd>
  <dt id="config()"><a class="permalink" href="#config()"><b>config()</b></a></dt>
  <dd>
    <pre>    Math::BigInt-&gt;config(&quot;trap_nan&quot; =&gt; 1);      # set
    $accu = Math::BigInt-&gt;config(&quot;accuracy&quot;);   # get
    </pre>
    <p class="Pp">Set or get class variables. Read-only parameters are marked as
        RO. Read-write parameters are marked as RW. The following parameters are
        supported.</p>
    <p class="Pp"></p>
    <pre>    Parameter       RO/RW   Description
                            Example
    ============================================================
    lib             RO      Name of the math backend library
                            Math::BigInt::Calc
    lib_version     RO      Version of the math backend library
                            0.30
    class           RO      The class of config you just called
                            Math::BigRat
    version         RO      version number of the class you used
                            0.10
    upgrade         RW      To which class numbers are upgraded
                            undef
    downgrade       RW      To which class numbers are downgraded
                            undef
    precision       RW      Global precision
                            undef
    accuracy        RW      Global accuracy
                            undef
    round_mode      RW      Global round mode
                            even
    div_scale       RW      Fallback accuracy for division etc.
                            40
    trap_nan        RW      Trap NaNs
                            undef
    trap_inf        RW      Trap +inf/-inf
                            undef
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Constructor_methods"><a class="permalink" href="#Constructor_methods">Constructor
  methods</a></h2>
<dl class="Bl-tag">
  <dt id="new()"><a class="permalink" href="#new()"><b>new()</b></a></dt>
  <dd>
    <pre>    $x = Math::BigInt-&gt;new($str,$A,$P,$R);
    </pre>
    <p class="Pp">Creates a new Math::BigInt object from a scalar or another
        Math::BigInt object. The input is accepted as decimal, hexadecimal (with
        leading '0x') or binary (with leading '0b').</p>
    <p class="Pp">See &quot;Input&quot; for more info on accepted input
      formats.</p>
  </dd>
  <dt id="from_hex()"><a class="permalink" href="#from_hex()"><b>from_hex()</b></a></dt>
  <dd>
    <pre>    $x = Math::BigInt-&gt;from_hex(&quot;0xcafe&quot;);    # input is hexadecimal
    </pre>
    <p class="Pp">Interpret input as a hexadecimal string. A &quot;0x&quot; or
        &quot;x&quot; prefix is optional. A single underscore character may be
        placed right after the prefix, if present, or between any two digits. If
        the input is invalid, a NaN is returned.</p>
  </dd>
  <dt id="from_oct()"><a class="permalink" href="#from_oct()"><b>from_oct()</b></a></dt>
  <dd>
    <pre>    $x = Math::BigInt-&gt;from_oct(&quot;0775&quot;);      # input is octal
    </pre>
    <p class="Pp">Interpret the input as an octal string and return the
        corresponding value. A &quot;0&quot; (zero) prefix is optional. A single
        underscore character may be placed right after the prefix, if present,
        or between any two digits. If the input is invalid, a NaN is
      returned.</p>
  </dd>
  <dt id="from_bin()"><a class="permalink" href="#from_bin()"><b>from_bin()</b></a></dt>
  <dd>
    <pre>    $x = Math::BigInt-&gt;from_bin(&quot;0b10011&quot;);   # input is binary
    </pre>
    <p class="Pp">Interpret the input as a binary string. A &quot;0b&quot; or
        &quot;b&quot; prefix is optional. A single underscore character may be
        placed right after the prefix, if present, or between any two digits. If
        the input is invalid, a NaN is returned.</p>
  </dd>
  <dt id="from_bytes()"><a class="permalink" href="#from_bytes()"><b>from_bytes()</b></a></dt>
  <dd>
    <pre>    $x = Math::BigInt-&gt;from_bytes(&quot;\xf3\x6b&quot;);  # $x = 62315
    </pre>
    <p class="Pp">Interpret the input as a byte string, assuming big endian byte
        order. The output is always a non-negative, finite integer.</p>
    <p class="Pp">In some special cases, <b>from_bytes()</b> matches the
        conversion done by <b>unpack()</b>:</p>
    <p class="Pp"></p>
    <pre>    $b = &quot;\x4e&quot;;                             # one char byte string
    $x = Math::BigInt-&gt;from_bytes($b);       # = 78
    $y = unpack &quot;C&quot;, $b;                     # ditto, but scalar
    $b = &quot;\xf3\x6b&quot;;                         # two char byte string
    $x = Math::BigInt-&gt;from_bytes($b);       # = 62315
    $y = unpack &quot;S&gt;&quot;, $b;                    # ditto, but scalar
    $b = &quot;\x2d\xe0\x49\xad&quot;;                 # four char byte string
    $x = Math::BigInt-&gt;from_bytes($b);       # = 769673645
    $y = unpack &quot;L&gt;&quot;, $b;                    # ditto, but scalar
    $b = &quot;\x2d\xe0\x49\xad\x2d\xe0\x49\xad&quot;; # eight char byte string
    $x = Math::BigInt-&gt;from_bytes($b);       # = 3305723134637787565
    $y = unpack &quot;Q&gt;&quot;, $b;                    # ditto, but scalar
    </pre>
  </dd>
  <dt id="from_base()"><a class="permalink" href="#from_base()"><b>from_base()</b></a></dt>
  <dd>Given a string, a base, and an optional collation sequence, interpret the
      string as a number in the given base. The collation sequence describes the
      value of each character in the string.
    <p class="Pp">If a collation sequence is not given, a default collation
        sequence is used. If the base is less than or equal to 36, the collation
        sequence is the string consisting of the 36 characters &quot;0&quot; to
        &quot;9&quot; and &quot;A&quot; to &quot;Z&quot;. In this case, the
        letter case in the input is ignored. If the base is greater than 36, and
        smaller than or equal to 62, the collation sequence is the string
        consisting of the 62 characters &quot;0&quot; to &quot;9&quot;,
        &quot;A&quot; to &quot;Z&quot;, and &quot;a&quot; to &quot;z&quot;. A
        base larger than 62 requires the collation sequence to be specified
        explicitly.</p>
    <p class="Pp">These examples show standard binary, octal, and hexadecimal
        conversion. All cases return 250.</p>
    <p class="Pp"></p>
    <pre>    $x = Math::BigInt-&gt;from_base(&quot;11111010&quot;, 2);
    $x = Math::BigInt-&gt;from_base(&quot;372&quot;, 8);
    $x = Math::BigInt-&gt;from_base(&quot;fa&quot;, 16);
    </pre>
    <p class="Pp">When the base is less than or equal to 36, and no collation
        sequence is given, the letter case is ignored, so both of these also
        return 250:</p>
    <p class="Pp"></p>
    <pre>    $x = Math::BigInt-&gt;from_base(&quot;6Y&quot;, 16);
    $x = Math::BigInt-&gt;from_base(&quot;6y&quot;, 16);
    </pre>
    <p class="Pp">When the base greater than 36, and no collation sequence is
        given, the default collation sequence contains both uppercase and
        lowercase letters, so the letter case in the input is not ignored:</p>
    <p class="Pp"></p>
    <pre>    $x = Math::BigInt-&gt;from_base(&quot;6S&quot;, 37);         # $x is 250
    $x = Math::BigInt-&gt;from_base(&quot;6s&quot;, 37);         # $x is 276
    $x = Math::BigInt-&gt;from_base(&quot;121&quot;, 3);         # $x is 16
    $x = Math::BigInt-&gt;from_base(&quot;XYZ&quot;, 36);        # $x is 44027
    $x = Math::BigInt-&gt;from_base(&quot;Why&quot;, 42);        # $x is 58314
    </pre>
    <p class="Pp">The collation sequence can be any set of unique characters.
        These two cases are equivalent</p>
    <p class="Pp"></p>
    <pre>    $x = Math::BigInt-&gt;from_base(&quot;100&quot;, 2, &quot;01&quot;);   # $x is 4
    $x = Math::BigInt-&gt;from_base(&quot;|--&quot;, 2, &quot;-|&quot;);   # $x is 4
    </pre>
  </dd>
  <dt id="bzero()"><a class="permalink" href="#bzero()"><b>bzero()</b></a></dt>
  <dd>
    <pre>    $x = Math::BigInt-&gt;bzero();
    $x-&gt;bzero();
    </pre>
    <p class="Pp">Returns a new Math::BigInt object representing zero. If used
        as an instance method, assigns the value to the invocand.</p>
  </dd>
  <dt id="bone()"><a class="permalink" href="#bone()"><b>bone()</b></a></dt>
  <dd>
    <pre>    $x = Math::BigInt-&gt;bone();          # +1
    $x = Math::BigInt-&gt;bone(&quot;+&quot;);       # +1
    $x = Math::BigInt-&gt;bone(&quot;-&quot;);       # -1
    $x-&gt;bone();                         # +1
    $x-&gt;bone(&quot;+&quot;);                      # +1
    $x-&gt;bone('-');                      # -1
    </pre>
    <p class="Pp">Creates a new Math::BigInt object representing one. The
        optional argument is either '-' or '+', indicating whether you want plus
        one or minus one. If used as an instance method, assigns the value to
        the invocand.</p>
  </dd>
  <dt id="binf()"><a class="permalink" href="#binf()"><b>binf()</b></a></dt>
  <dd>
    <pre>    $x = Math::BigInt-&gt;binf($sign);
    </pre>
    <p class="Pp">Creates a new Math::BigInt object representing infinity. The
        optional argument is either '-' or '+', indicating whether you want
        infinity or minus infinity. If used as an instance method, assigns the
        value to the invocand.</p>
    <p class="Pp"></p>
    <pre>    $x-&gt;binf();
    $x-&gt;binf('-');
    </pre>
  </dd>
  <dt id="bnan()"><a class="permalink" href="#bnan()"><b>bnan()</b></a></dt>
  <dd>
    <pre>    $x = Math::BigInt-&gt;bnan();
    </pre>
    <p class="Pp">Creates a new Math::BigInt object representing NaN (Not A
        Number). If used as an instance method, assigns the value to the
        invocand.</p>
    <p class="Pp"></p>
    <pre>    $x-&gt;bnan();
    </pre>
  </dd>
  <dt id="bpi()"><a class="permalink" href="#bpi()"><b>bpi()</b></a></dt>
  <dd>
    <pre>    $x = Math::BigInt-&gt;bpi(100);        # 3
    $x-&gt;bpi(100);                       # 3
    </pre>
    <p class="Pp">Creates a new Math::BigInt object representing PI. If used as
        an instance method, assigns the value to the invocand. With Math::BigInt
        this always returns 3.</p>
    <p class="Pp">If upgrading is in effect, returns PI, rounded to N digits
        with the current rounding mode:</p>
    <p class="Pp"></p>
    <pre>    use Math::BigFloat;
    use Math::BigInt upgrade =&gt; &quot;Math::BigFloat&quot;;
    print Math::BigInt-&gt;bpi(3), &quot;\n&quot;;           # 3.14
    print Math::BigInt-&gt;bpi(100), &quot;\n&quot;;         # 3.1415....
    </pre>
  </dd>
  <dt id="copy()"><a class="permalink" href="#copy()"><b>copy()</b></a></dt>
  <dd>
    <pre>    $x-&gt;copy();         # make a true copy of $x (unlike $y = $x)
    </pre>
  </dd>
  <dt id="as_int()"><a class="permalink" href="#as_int()"><b>as_int()</b></a></dt>
  <dd></dd>
  <dt id="as_number()"><a class="permalink" href="#as_number()"><b>as_number()</b></a></dt>
  <dd>These methods are called when Math::BigInt encounters an object it doesn't
      know how to handle. For instance, assume <span class="Li">$x</span> is a
      Math::BigInt, or subclass thereof, and <span class="Li">$y</span> is
      defined, but not a Math::BigInt, or subclass thereof. If you do
    <p class="Pp"></p>
    <pre>    $x -&gt; badd($y);
    </pre>
    <p class="Pp"><span class="Li">$y</span> needs to be converted into an
        object that <span class="Li">$x</span> can deal with. This is done by
        first checking if <span class="Li">$y</span> is something that
        <span class="Li">$x</span> might be upgraded to. If that is the case, no
        further attempts are made. The next is to see if
        <span class="Li">$y</span> supports the method
        <span class="Li">&quot;as_int()&quot;</span>. If it does,
        <span class="Li">&quot;as_int()&quot;</span> is called, but if it
        doesn't, the next thing is to see if <span class="Li">$y</span> supports
        the method <span class="Li">&quot;as_number()&quot;</span>. If it does,
        <span class="Li">&quot;as_number()&quot;</span> is called. The method
        <span class="Li">&quot;as_int()&quot;</span> (and
        <span class="Li">&quot;as_number()&quot;</span>) is expected to return
        either an object that has the same class as <span class="Li">$x</span>,
        a subclass thereof, or a string that
        <span class="Li">&quot;ref($x)-&gt;new()&quot;</span> can parse to
        create an object.</p>
    <p class="Pp"><span class="Li">&quot;as_number()&quot;</span> is an alias to
        <span class="Li">&quot;as_int()&quot;</span>.
        <span class="Li">&quot;as_number&quot;</span> was introduced in v1.22,
        while <span class="Li">&quot;as_int()&quot;</span> was introduced in
        v1.68.</p>
    <p class="Pp">In Math::BigInt, <span class="Li">&quot;as_int()&quot;</span>
        has the same effect as <span class="Li">&quot;copy()&quot;</span>.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Boolean_methods"><a class="permalink" href="#Boolean_methods">Boolean
  methods</a></h2>
<p class="Pp">None of these methods modify the invocand object.</p>
<dl class="Bl-tag">
  <dt id="is_zero()"><a class="permalink" href="#is_zero()"><b>is_zero()</b></a></dt>
  <dd>
    <pre>    $x-&gt;is_zero();              # true if $x is 0
    </pre>
    <p class="Pp">Returns true if the invocand is zero and false otherwise.</p>
  </dd>
  <dt id="is_one("><a class="permalink" href="#is_one(">is_one( [ SIGN
    ])</a></dt>
  <dd>
    <pre>    $x-&gt;is_one();               # true if $x is +1
    $x-&gt;is_one(&quot;+&quot;);            # ditto
    $x-&gt;is_one(&quot;-&quot;);            # true if $x is -1
    </pre>
    <p class="Pp">Returns true if the invocand is one and false otherwise.</p>
  </dd>
  <dt id="is_finite()"><a class="permalink" href="#is_finite()"><b>is_finite()</b></a></dt>
  <dd>
    <pre>    $x-&gt;is_finite();    # true if $x is not +inf, -inf or NaN
    </pre>
    <p class="Pp">Returns true if the invocand is a finite number, i.e., it is
        neither +inf, -inf, nor NaN.</p>
  </dd>
  <dt id="is_inf("><a class="permalink" href="#is_inf(">is_inf( [ SIGN ]
    )</a></dt>
  <dd>
    <pre>    $x-&gt;is_inf();               # true if $x is +inf
    $x-&gt;is_inf(&quot;+&quot;);            # ditto
    $x-&gt;is_inf(&quot;-&quot;);            # true if $x is -inf
    </pre>
    <p class="Pp">Returns true if the invocand is infinite and false
      otherwise.</p>
  </dd>
  <dt id="is_nan()"><a class="permalink" href="#is_nan()"><b>is_nan()</b></a></dt>
  <dd>
    <pre>    $x-&gt;is_nan();               # true if $x is NaN
    </pre>
  </dd>
  <dt id="is_positive()"><a class="permalink" href="#is_positive()"><b>is_positive()</b></a></dt>
  <dd></dd>
  <dt id="is_pos()"><a class="permalink" href="#is_pos()"><b>is_pos()</b></a></dt>
  <dd>
    <pre>    $x-&gt;is_positive();          # true if &gt; 0
    $x-&gt;is_pos();               # ditto
    </pre>
    <p class="Pp">Returns true if the invocand is positive and false otherwise.
        A <span class="Li">&quot;NaN&quot;</span> is neither positive nor
        negative.</p>
  </dd>
  <dt id="is_negative()"><a class="permalink" href="#is_negative()"><b>is_negative()</b></a></dt>
  <dd></dd>
  <dt id="is_neg()"><a class="permalink" href="#is_neg()"><b>is_neg()</b></a></dt>
  <dd>
    <pre>    $x-&gt;is_negative();          # true if &lt; 0
    $x-&gt;is_neg();               # ditto
    </pre>
    <p class="Pp">Returns true if the invocand is negative and false otherwise.
        A <span class="Li">&quot;NaN&quot;</span> is neither positive nor
        negative.</p>
  </dd>
  <dt id="is_odd()"><a class="permalink" href="#is_odd()"><b>is_odd()</b></a></dt>
  <dd>
    <pre>    $x-&gt;is_odd();               # true if odd, false for even
    </pre>
    <p class="Pp">Returns true if the invocand is odd and false otherwise.
        <span class="Li">&quot;NaN&quot;</span>,
        <span class="Li">&quot;+inf&quot;</span>, and
        <span class="Li">&quot;-inf&quot;</span> are neither odd nor even.</p>
  </dd>
  <dt id="is_even()"><a class="permalink" href="#is_even()"><b>is_even()</b></a></dt>
  <dd>
    <pre>    $x-&gt;is_even();              # true if $x is even
    </pre>
    <p class="Pp">Returns true if the invocand is even and false otherwise.
        <span class="Li">&quot;NaN&quot;</span>,
        <span class="Li">&quot;+inf&quot;</span>,
        <span class="Li">&quot;-inf&quot;</span> are not integers and are
        neither odd nor even.</p>
  </dd>
  <dt id="is_int()"><a class="permalink" href="#is_int()"><b>is_int()</b></a></dt>
  <dd>
    <pre>    $x-&gt;is_int();               # true if $x is an integer
    </pre>
    <p class="Pp">Returns true if the invocand is an integer and false
        otherwise. <span class="Li">&quot;NaN&quot;</span>,
        <span class="Li">&quot;+inf&quot;</span>,
        <span class="Li">&quot;-inf&quot;</span> are not integers.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Comparison_methods"><a class="permalink" href="#Comparison_methods">Comparison
  methods</a></h2>
<p class="Pp">None of these methods modify the invocand object. Note that a
    <span class="Li">&quot;NaN&quot;</span> is neither less than, greater than,
    or equal to anything else, even a
  <span class="Li">&quot;NaN&quot;</span>.</p>
<dl class="Bl-tag">
  <dt id="bcmp()"><a class="permalink" href="#bcmp()"><b>bcmp()</b></a></dt>
  <dd>
    <pre>    $x-&gt;bcmp($y);
    </pre>
    <p class="Pp">Returns -1, 0, 1 depending on whether
        <span class="Li">$x</span> is less than, equal to, or grater than
        <span class="Li">$y</span>. Returns undef if any operand is a NaN.</p>
  </dd>
  <dt id="bacmp()"><a class="permalink" href="#bacmp()"><b>bacmp()</b></a></dt>
  <dd>
    <pre>    $x-&gt;bacmp($y);
    </pre>
    <p class="Pp">Returns -1, 0, 1 depending on whether the absolute value of
        <span class="Li">$x</span> is less than, equal to, or grater than the
        absolute value of <span class="Li">$y</span>. Returns undef if any
        operand is a NaN.</p>
  </dd>
  <dt id="beq()"><a class="permalink" href="#beq()"><b>beq()</b></a></dt>
  <dd>
    <pre>    $x -&gt; beq($y);
    </pre>
    <p class="Pp">Returns true if and only if <span class="Li">$x</span> is
        equal to <span class="Li">$y</span>, and false otherwise.</p>
  </dd>
  <dt id="bne()"><a class="permalink" href="#bne()"><b>bne()</b></a></dt>
  <dd>
    <pre>    $x -&gt; bne($y);
    </pre>
    <p class="Pp">Returns true if and only if <span class="Li">$x</span> is not
        equal to <span class="Li">$y</span>, and false otherwise.</p>
  </dd>
  <dt id="blt()"><a class="permalink" href="#blt()"><b>blt()</b></a></dt>
  <dd>
    <pre>    $x -&gt; blt($y);
    </pre>
    <p class="Pp">Returns true if and only if <span class="Li">$x</span> is
        equal to <span class="Li">$y</span>, and false otherwise.</p>
  </dd>
  <dt id="ble()"><a class="permalink" href="#ble()"><b>ble()</b></a></dt>
  <dd>
    <pre>    $x -&gt; ble($y);
    </pre>
    <p class="Pp">Returns true if and only if <span class="Li">$x</span> is less
        than or equal to <span class="Li">$y</span>, and false otherwise.</p>
  </dd>
  <dt id="bgt()"><a class="permalink" href="#bgt()"><b>bgt()</b></a></dt>
  <dd>
    <pre>    $x -&gt; bgt($y);
    </pre>
    <p class="Pp">Returns true if and only if <span class="Li">$x</span> is
        greater than <span class="Li">$y</span>, and false otherwise.</p>
  </dd>
  <dt id="bge()"><a class="permalink" href="#bge()"><b>bge()</b></a></dt>
  <dd>
    <pre>    $x -&gt; bge($y);
    </pre>
    <p class="Pp">Returns true if and only if <span class="Li">$x</span> is
        greater than or equal to <span class="Li">$y</span>, and false
        otherwise.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Arithmetic_methods"><a class="permalink" href="#Arithmetic_methods">Arithmetic
  methods</a></h2>
<p class="Pp">These methods modify the invocand object and returns it.</p>
<dl class="Bl-tag">
  <dt id="bneg()"><a class="permalink" href="#bneg()"><b>bneg()</b></a></dt>
  <dd>
    <pre>    $x-&gt;bneg();
    </pre>
    <p class="Pp">Negate the number, e.g. change the sign between '+' and '-',
        or between '+inf' and '-inf', respectively. Does nothing for NaN or
        zero.</p>
  </dd>
  <dt id="babs()"><a class="permalink" href="#babs()"><b>babs()</b></a></dt>
  <dd>
    <pre>    $x-&gt;babs();
    </pre>
    <p class="Pp">Set the number to its absolute value, e.g. change the sign
        from '-' to '+' and from '-inf' to '+inf', respectively. Does nothing
        for NaN or positive numbers.</p>
  </dd>
  <dt id="bsgn()"><a class="permalink" href="#bsgn()"><b>bsgn()</b></a></dt>
  <dd>
    <pre>    $x-&gt;bsgn();
    </pre>
    <p class="Pp">Signum function. Set the number to -1, 0, or 1, depending on
        whether the number is negative, zero, or positive, respectively. Does
        not modify NaNs.</p>
  </dd>
  <dt id="bnorm()"><a class="permalink" href="#bnorm()"><b>bnorm()</b></a></dt>
  <dd>
    <pre>    $x-&gt;bnorm();                        # normalize (no-op)
    </pre>
    <p class="Pp">Normalize the number. This is a no-op and is provided only for
        backwards compatibility.</p>
  </dd>
  <dt id="binc()"><a class="permalink" href="#binc()"><b>binc()</b></a></dt>
  <dd>
    <pre>    $x-&gt;binc();                 # increment x by 1
    </pre>
  </dd>
  <dt id="bdec()"><a class="permalink" href="#bdec()"><b>bdec()</b></a></dt>
  <dd>
    <pre>    $x-&gt;bdec();                 # decrement x by 1
    </pre>
  </dd>
  <dt id="badd()"><a class="permalink" href="#badd()"><b>badd()</b></a></dt>
  <dd>
    <pre>    $x-&gt;badd($y);               # addition (add $y to $x)
    </pre>
  </dd>
  <dt id="bsub()"><a class="permalink" href="#bsub()"><b>bsub()</b></a></dt>
  <dd>
    <pre>    $x-&gt;bsub($y);               # subtraction (subtract $y from $x)
    </pre>
  </dd>
  <dt id="bmul()"><a class="permalink" href="#bmul()"><b>bmul()</b></a></dt>
  <dd>
    <pre>    $x-&gt;bmul($y);               # multiplication (multiply $x by $y)
    </pre>
  </dd>
  <dt id="bmuladd()"><a class="permalink" href="#bmuladd()"><b>bmuladd()</b></a></dt>
  <dd>
    <pre>    $x-&gt;bmuladd($y,$z);
    </pre>
    <p class="Pp">Multiply <span class="Li">$x</span> by
        <span class="Li">$y</span>, and then add <span class="Li">$z</span> to
        the result,</p>
    <p class="Pp">This method was added in v1.87 of Math::BigInt (June
      2007).</p>
  </dd>
  <dt id="bdiv()"><a class="permalink" href="#bdiv()"><b>bdiv()</b></a></dt>
  <dd>
    <pre>    $x-&gt;bdiv($y);               # divide, set $x to quotient
    </pre>
    <p class="Pp">Divides <span class="Li">$x</span> by
        <span class="Li">$y</span> by doing floored division (F-division), where
        the quotient is the floored (rounded towards negative infinity) quotient
        of the two operands. In list context, returns the quotient and the
        remainder. The remainder is either zero or has the same sign as the
        second operand. In scalar context, only the quotient is returned.</p>
    <p class="Pp">The quotient is always the greatest integer less than or equal
        to the real-valued quotient of the two operands, and the remainder (when
        it is non-zero) always has the same sign as the second operand; so, for
        example,</p>
    <p class="Pp"></p>
    <pre>      1 /  4  =&gt; ( 0,  1)
      1 / -4  =&gt; (-1, -3)
     -3 /  4  =&gt; (-1,  1)
     -3 / -4  =&gt; ( 0, -3)
    -11 /  2  =&gt; (-5,  1)
     11 / -2  =&gt; (-5, -1)
    </pre>
    <p class="Pp">The behavior of the overloaded operator % agrees with the
        behavior of Perl's built-in % operator (as documented in the perlop
        manpage), and the equation</p>
    <p class="Pp"></p>
    <pre>    $x == ($x / $y) * $y + ($x % $y)
    </pre>
    <p class="Pp">holds true for any finite <span class="Li">$x</span> and
        finite, non-zero <span class="Li">$y</span>.</p>
    <p class="Pp">Perl's &quot;use integer&quot; might change the behaviour of %
        and / for scalars. This is because under 'use integer' Perl does what
        the underlying C library thinks is right, and this varies. However,
        &quot;use integer&quot; does not change the way things are done with
        Math::BigInt objects.</p>
  </dd>
  <dt id="btdiv()"><a class="permalink" href="#btdiv()"><b>btdiv()</b></a></dt>
  <dd>
    <pre>    $x-&gt;btdiv($y);              # divide, set $x to quotient
    </pre>
    <p class="Pp">Divides <span class="Li">$x</span> by
        <span class="Li">$y</span> by doing truncated division (T-division),
        where quotient is the truncated (rouneded towards zero) quotient of the
        two operands. In list context, returns the quotient and the remainder.
        The remainder is either zero or has the same sign as the first operand.
        In scalar context, only the quotient is returned.</p>
  </dd>
  <dt id="bmod()"><a class="permalink" href="#bmod()"><b>bmod()</b></a></dt>
  <dd>
    <pre>    $x-&gt;bmod($y);               # modulus (x % y)
    </pre>
    <p class="Pp">Returns <span class="Li">$x</span> modulo
        <span class="Li">$y</span>, i.e., the remainder after floored division
        (F-division). This method is like Perl's % operator. See
        &quot;<b>bdiv()</b>&quot;.</p>
  </dd>
  <dt id="btmod()"><a class="permalink" href="#btmod()"><b>btmod()</b></a></dt>
  <dd>
    <pre>    $x-&gt;btmod($y);              # modulus
    </pre>
    <p class="Pp">Returns the remainer after truncated division (T-division).
        See &quot;<b>btdiv()</b>&quot;.</p>
  </dd>
  <dt id="bmodinv()"><a class="permalink" href="#bmodinv()"><b>bmodinv()</b></a></dt>
  <dd>
    <pre>    $x-&gt;bmodinv($mod);          # modular multiplicative inverse
    </pre>
    <p class="Pp">Returns the multiplicative inverse of
        <span class="Li">$x</span> modulo <span class="Li">$mod</span>. If</p>
    <p class="Pp"></p>
    <pre>    $y = $x -&gt; copy() -&gt; bmodinv($mod)
    </pre>
    <p class="Pp">then <span class="Li">$y</span> is the number closest to zero,
        and with the same sign as <span class="Li">$mod</span>, satisfying</p>
    <p class="Pp"></p>
    <pre>    ($x * $y) % $mod = 1 % $mod
    </pre>
    <p class="Pp">If <span class="Li">$x</span> and <span class="Li">$y</span>
        are non-zero, they must be relative primes, i.e.,
        <span class="Li">&quot;bgcd($y, $mod)==1&quot;</span>.
        '<span class="Li">&quot;NaN&quot;</span>' is returned when no modular
        multiplicative inverse exists.</p>
  </dd>
  <dt id="bmodpow()"><a class="permalink" href="#bmodpow()"><b>bmodpow()</b></a></dt>
  <dd>
    <pre>    $num-&gt;bmodpow($exp,$mod);           # modular exponentiation
                                        # ($num**$exp % $mod)
    </pre>
    <p class="Pp">Returns the value of <span class="Li">$num</span> taken to the
        power <span class="Li">$exp</span> in the modulus
        <span class="Li">$mod</span> using binary exponentiation.
        <span class="Li">&quot;bmodpow&quot;</span> is far superior to
      writing</p>
    <p class="Pp"></p>
    <pre>    $num ** $exp % $mod
    </pre>
    <p class="Pp">because it is much faster - it reduces internal variables into
        the modulus whenever possible, so it operates on smaller numbers.</p>
    <p class="Pp"><span class="Li">&quot;bmodpow&quot;</span> also supports
        negative exponents.</p>
    <p class="Pp"></p>
    <pre>    bmodpow($num, -1, $mod)
    </pre>
    <p class="Pp">is exactly equivalent to</p>
    <p class="Pp"></p>
    <pre>    bmodinv($num, $mod)
    </pre>
  </dd>
  <dt id="bpow()"><a class="permalink" href="#bpow()"><b>bpow()</b></a></dt>
  <dd>
    <pre>    $x-&gt;bpow($y);               # power of arguments (x ** y)
    </pre>
    <p class="Pp"><span class="Li">&quot;bpow()&quot;</span> (and the rounding
        functions) now modifies the first argument and returns it, unlike the
        old code which left it alone and only returned the result. This is to be
        consistent with <span class="Li">&quot;badd()&quot;</span> etc. The
        first three modifies <span class="Li">$x</span>, the last one won't:</p>
    <p class="Pp"></p>
    <pre>    print bpow($x,$i),&quot;\n&quot;;         # modify $x
    print $x-&gt;bpow($i),&quot;\n&quot;;        # ditto
    print $x **= $i,&quot;\n&quot;;           # the same
    print $x ** $i,&quot;\n&quot;;            # leave $x alone
    </pre>
    <p class="Pp">The form <span class="Li">&quot;$x **= $y&quot;</span> is
        faster than <span class="Li">&quot;$x = $x ** $y;&quot;</span>,
      though.</p>
  </dd>
  <dt id="blog()"><a class="permalink" href="#blog()"><b>blog()</b></a></dt>
  <dd>
    <pre>    $x-&gt;blog($base, $accuracy);         # logarithm of x to the base $base
    </pre>
    <p class="Pp">If <span class="Li">$base</span> is not defined, Euler's
        number (e) is used:</p>
    <p class="Pp"></p>
    <pre>    print $x-&gt;blog(undef, 100);         # log(x) to 100 digits
    </pre>
  </dd>
  <dt id="bexp()"><a class="permalink" href="#bexp()"><b>bexp()</b></a></dt>
  <dd>
    <pre>    $x-&gt;bexp($accuracy);                # calculate e ** X
    </pre>
    <p class="Pp">Calculates the expression <span class="Li">&quot;e **
        $x&quot;</span> where <span class="Li">&quot;e&quot;</span> is Euler's
        number.</p>
    <p class="Pp">This method was added in v1.82 of Math::BigInt (April
      2007).</p>
    <p class="Pp">See also &quot;<b>blog()</b>&quot;.</p>
  </dd>
  <dt id="bnok()"><a class="permalink" href="#bnok()"><b>bnok()</b></a></dt>
  <dd>
    <pre>    $x-&gt;bnok($y);               # x over y (binomial coefficient n over k)
    </pre>
    <p class="Pp">Calculates the binomial coefficient n over k, also called the
        &quot;choose&quot; function, which is</p>
    <p class="Pp"></p>
    <pre>    ( n )       n!
    |   |  = --------
    ( k )    k!(n-k)!
    </pre>
    <p class="Pp">when n and k are non-negative. This method implements the full
        Kronenburg extension (Kronenburg, M.J. &quot;The Binomial Coefficient
        for Negative Arguments.&quot; 18 May 2011.
        http://arxiv.org/abs/1105.3689/) illustrated by the following
        pseudo-code:</p>
    <p class="Pp"></p>
    <pre>    if n &gt;= 0 and k &gt;= 0:
        return binomial(n, k)
    if k &gt;= 0:
        return (-1)^k*binomial(-n+k-1, k)
    if k &lt;= n:
        return (-1)^(n-k)*binomial(-k-1, n-k)
    else
        return 0
    </pre>
    <p class="Pp">The behaviour is identical to the behaviour of the Maple and
        Mathematica function for negative integers n, k.</p>
  </dd>
  <dt id="bsin()"><a class="permalink" href="#bsin()"><b>bsin()</b></a></dt>
  <dd>
    <pre>    my $x = Math::BigInt-&gt;new(1);
    print $x-&gt;bsin(100), &quot;\n&quot;;
    </pre>
    <p class="Pp">Calculate the sine of <span class="Li">$x</span>, modifying
        <span class="Li">$x</span> in place.</p>
    <p class="Pp">In Math::BigInt, unless upgrading is in effect, the result is
        truncated to an integer.</p>
    <p class="Pp">This method was added in v1.87 of Math::BigInt (June
      2007).</p>
  </dd>
  <dt id="bcos()"><a class="permalink" href="#bcos()"><b>bcos()</b></a></dt>
  <dd>
    <pre>    my $x = Math::BigInt-&gt;new(1);
    print $x-&gt;bcos(100), &quot;\n&quot;;
    </pre>
    <p class="Pp">Calculate the cosine of <span class="Li">$x</span>, modifying
        <span class="Li">$x</span> in place.</p>
    <p class="Pp">In Math::BigInt, unless upgrading is in effect, the result is
        truncated to an integer.</p>
    <p class="Pp">This method was added in v1.87 of Math::BigInt (June
      2007).</p>
  </dd>
  <dt id="batan()"><a class="permalink" href="#batan()"><b>batan()</b></a></dt>
  <dd>
    <pre>    my $x = Math::BigFloat-&gt;new(0.5);
    print $x-&gt;batan(100), &quot;\n&quot;;
    </pre>
    <p class="Pp">Calculate the arcus tangens of <span class="Li">$x</span>,
        modifying <span class="Li">$x</span> in place.</p>
    <p class="Pp">In Math::BigInt, unless upgrading is in effect, the result is
        truncated to an integer.</p>
    <p class="Pp">This method was added in v1.87 of Math::BigInt (June
      2007).</p>
  </dd>
  <dt id="batan2()"><a class="permalink" href="#batan2()"><b>batan2()</b></a></dt>
  <dd>
    <pre>    my $x = Math::BigInt-&gt;new(1);
    my $y = Math::BigInt-&gt;new(1);
    print $y-&gt;batan2($x), &quot;\n&quot;;
    </pre>
    <p class="Pp">Calculate the arcus tangens of <span class="Li">$y</span>
        divided by <span class="Li">$x</span>, modifying
        <span class="Li">$y</span> in place.</p>
    <p class="Pp">In Math::BigInt, unless upgrading is in effect, the result is
        truncated to an integer.</p>
    <p class="Pp">This method was added in v1.87 of Math::BigInt (June
      2007).</p>
  </dd>
  <dt id="bsqrt()"><a class="permalink" href="#bsqrt()"><b>bsqrt()</b></a></dt>
  <dd>
    <pre>    $x-&gt;bsqrt();                # calculate square root
    </pre>
    <p class="Pp"><span class="Li">&quot;bsqrt()&quot;</span> returns the square
        root truncated to an integer.</p>
    <p class="Pp">If you want a better approximation of the square root, then
        use:</p>
    <p class="Pp"></p>
    <pre>    $x = Math::BigFloat-&gt;new(12);
    Math::BigFloat-&gt;precision(0);
    Math::BigFloat-&gt;round_mode('even');
    print $x-&gt;copy-&gt;bsqrt(),&quot;\n&quot;;           # 4
    Math::BigFloat-&gt;precision(2);
    print $x-&gt;bsqrt(),&quot;\n&quot;;                 # 3.46
    print $x-&gt;bsqrt(3),&quot;\n&quot;;                # 3.464
    </pre>
  </dd>
  <dt id="broot()"><a class="permalink" href="#broot()"><b>broot()</b></a></dt>
  <dd>
    <pre>    $x-&gt;broot($N);
    </pre>
    <p class="Pp">Calculates the N'th root of <span class="Li">$x</span>.</p>
  </dd>
  <dt id="bfac()"><a class="permalink" href="#bfac()"><b>bfac()</b></a></dt>
  <dd>
    <pre>    $x-&gt;bfac();                 # factorial of $x (1*2*3*4*..*$x)
    </pre>
    <p class="Pp">Returns the factorial of <span class="Li">$x</span>, i.e., the
        product of all positive integers up to and including
        <span class="Li">$x</span>.</p>
  </dd>
  <dt id="bdfac()"><a class="permalink" href="#bdfac()"><b>bdfac()</b></a></dt>
  <dd>
    <pre>    $x-&gt;bdfac();                # double factorial of $x (1*2*3*4*..*$x)
    </pre>
    <p class="Pp">Returns the double factorial of <span class="Li">$x</span>. If
        <span class="Li">$x</span> is an even integer, returns the product of
        all positive, even integers up to and including
        <span class="Li">$x</span>, i.e., 2*4*6*...*$x. If
        <span class="Li">$x</span> is an odd integer, returns the product of all
        positive, odd integers, i.e., 1*3*5*...*$x.</p>
  </dd>
  <dt id="bfib()"><a class="permalink" href="#bfib()"><b>bfib()</b></a></dt>
  <dd>
    <pre>    $F = $n-&gt;bfib();            # a single Fibonacci number
    @F = $n-&gt;bfib();            # a list of Fibonacci numbers
    </pre>
    <p class="Pp">In scalar context, returns a single Fibonacci number. In list
        context, returns a list of Fibonacci numbers. The invocand is the last
        element in the output.</p>
    <p class="Pp">The Fibonacci sequence is defined by</p>
    <p class="Pp"></p>
    <pre>    F(0) = 0
    F(1) = 1
    F(n) = F(n-1) + F(n-2)
    </pre>
    <p class="Pp">In list context, F(0) and F(n) is the first and last number in
        the output, respectively. For example, if <span class="Li">$n</span> is
        12, then <span class="Li">&quot;@F = $n-&gt;bfib()&quot;</span> returns
        the following values, F(0) to F(12):</p>
    <p class="Pp"></p>
    <pre>    0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144
    </pre>
    <p class="Pp">The sequence can also be extended to negative index n using
        the re-arranged recurrence relation</p>
    <p class="Pp"></p>
    <pre>    F(n-2) = F(n) - F(n-1)
    </pre>
    <p class="Pp">giving the bidirectional sequence</p>
    <p class="Pp"></p>
    <pre>       n  -7  -6  -5  -4  -3  -2  -1   0   1   2   3   4   5   6   7
    F(n)  13  -8   5  -3   2  -1   1   0   1   1   2   3   5   8  13
    </pre>
    <p class="Pp">If <span class="Li">$n</span> is -12, the following values,
        F(0) to F(12), are returned:</p>
    <p class="Pp"></p>
    <pre>    0, 1, -1, 2, -3, 5, -8, 13, -21, 34, -55, 89, -144
    </pre>
  </dd>
  <dt id="blucas()"><a class="permalink" href="#blucas()"><b>blucas()</b></a></dt>
  <dd>
    <pre>    $F = $n-&gt;blucas();          # a single Lucas number
    @F = $n-&gt;blucas();          # a list of Lucas numbers
    </pre>
    <p class="Pp">In scalar context, returns a single Lucas number. In list
        context, returns a list of Lucas numbers. The invocand is the last
        element in the output.</p>
    <p class="Pp">The Lucas sequence is defined by</p>
    <p class="Pp"></p>
    <pre>    L(0) = 2
    L(1) = 1
    L(n) = L(n-1) + L(n-2)
    </pre>
    <p class="Pp">In list context, L(0) and L(n) is the first and last number in
        the output, respectively. For example, if <span class="Li">$n</span> is
        12, then <span class="Li">&quot;@L = $n-&gt;blucas()&quot;</span>
        returns the following values, L(0) to L(12):</p>
    <p class="Pp"></p>
    <pre>    2, 1, 3, 4, 7, 11, 18, 29, 47, 76, 123, 199, 322
    </pre>
    <p class="Pp">The sequence can also be extended to negative index n using
        the re-arranged recurrence relation</p>
    <p class="Pp"></p>
    <pre>    L(n-2) = L(n) - L(n-1)
    </pre>
    <p class="Pp">giving the bidirectional sequence</p>
    <p class="Pp"></p>
    <pre>       n  -7  -6  -5  -4  -3  -2  -1   0   1   2   3   4   5   6   7
    L(n)  29 -18  11  -7   4  -3   1   2   1   3   4   7  11  18  29
    </pre>
    <p class="Pp">If <span class="Li">$n</span> is -12, the following values,
        L(0) to L(-12), are returned:</p>
    <p class="Pp"></p>
    <pre>    2, 1, -3, 4, -7, 11, -18, 29, -47, 76, -123, 199, -322
    </pre>
  </dd>
  <dt id="brsft()"><a class="permalink" href="#brsft()"><b>brsft()</b></a></dt>
  <dd>
    <pre>    $x-&gt;brsft($n);              # right shift $n places in base 2
    $x-&gt;brsft($n, $b);          # right shift $n places in base $b
    </pre>
    <p class="Pp">The latter is equivalent to</p>
    <p class="Pp"></p>
    <pre>    $x -&gt; bdiv($b -&gt; copy() -&gt; bpow($n))
    </pre>
  </dd>
  <dt id="blsft()"><a class="permalink" href="#blsft()"><b>blsft()</b></a></dt>
  <dd>
    <pre>    $x-&gt;blsft($n);              # left shift $n places in base 2
    $x-&gt;blsft($n, $b);          # left shift $n places in base $b
    </pre>
    <p class="Pp">The latter is equivalent to</p>
    <p class="Pp"></p>
    <pre>    $x -&gt; bmul($b -&gt; copy() -&gt; bpow($n))
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Bitwise_methods"><a class="permalink" href="#Bitwise_methods">Bitwise
  methods</a></h2>
<dl class="Bl-tag">
  <dt id="band()"><a class="permalink" href="#band()"><b>band()</b></a></dt>
  <dd>
    <pre>    $x-&gt;band($y);               # bitwise and
    </pre>
  </dd>
  <dt id="bior()"><a class="permalink" href="#bior()"><b>bior()</b></a></dt>
  <dd>
    <pre>    $x-&gt;bior($y);               # bitwise inclusive or
    </pre>
  </dd>
  <dt id="bxor()"><a class="permalink" href="#bxor()"><b>bxor()</b></a></dt>
  <dd>
    <pre>    $x-&gt;bxor($y);               # bitwise exclusive or
    </pre>
  </dd>
  <dt id="bnot()"><a class="permalink" href="#bnot()"><b>bnot()</b></a></dt>
  <dd>
    <pre>    $x-&gt;bnot();                 # bitwise not (two's complement)
    </pre>
    <p class="Pp">Two's complement (bitwise not). This is equivalent to, but
        faster than,</p>
    <p class="Pp"></p>
    <pre>    $x-&gt;binc()-&gt;bneg();
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Rounding_methods"><a class="permalink" href="#Rounding_methods">Rounding
  methods</a></h2>
<dl class="Bl-tag">
  <dt id="round()"><a class="permalink" href="#round()"><b>round()</b></a></dt>
  <dd>
    <pre>    $x-&gt;round($A,$P,$round_mode);
    </pre>
    <p class="Pp">Round <span class="Li">$x</span> to accuracy
        <span class="Li">$A</span> or precision <span class="Li">$P</span> using
        the round mode <span class="Li">$round_mode</span>.</p>
  </dd>
  <dt id="bround()"><a class="permalink" href="#bround()"><b>bround()</b></a></dt>
  <dd>
    <pre>    $x-&gt;bround($N);               # accuracy: preserve $N digits
    </pre>
    <p class="Pp">Rounds <span class="Li">$x</span> to an accuracy of
        <span class="Li">$N</span> digits.</p>
  </dd>
  <dt id="bfround()"><a class="permalink" href="#bfround()"><b>bfround()</b></a></dt>
  <dd>
    <pre>    $x-&gt;bfround($N);
    </pre>
    <p class="Pp">Rounds to a multiple of 10**$N. Examples:</p>
    <p class="Pp"></p>
    <pre>    Input            N          Result
    123456.123456    3          123500
    123456.123456    2          123450
    123456.123456   -2          123456.12
    123456.123456   -3          123456.123
    </pre>
  </dd>
  <dt id="bfloor()"><a class="permalink" href="#bfloor()"><b>bfloor()</b></a></dt>
  <dd>
    <pre>    $x-&gt;bfloor();
    </pre>
    <p class="Pp">Round <span class="Li">$x</span> towards minus infinity, i.e.,
        set <span class="Li">$x</span> to the largest integer less than or equal
        to <span class="Li">$x</span>.</p>
  </dd>
  <dt id="bceil()"><a class="permalink" href="#bceil()"><b>bceil()</b></a></dt>
  <dd>
    <pre>    $x-&gt;bceil();
    </pre>
    <p class="Pp">Round <span class="Li">$x</span> towards plus infinity, i.e.,
        set <span class="Li">$x</span> to the smallest integer greater than or
        equal to <span class="Li">$x</span>).</p>
  </dd>
  <dt id="bint()"><a class="permalink" href="#bint()"><b>bint()</b></a></dt>
  <dd>
    <pre>    $x-&gt;bint();
    </pre>
    <p class="Pp">Round <span class="Li">$x</span> towards zero.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Other_mathematical_methods"><a class="permalink" href="#Other_mathematical_methods">Other
  mathematical methods</a></h2>
<dl class="Bl-tag">
  <dt id="bgcd()"><a class="permalink" href="#bgcd()"><b>bgcd()</b></a></dt>
  <dd>
    <pre>    $x -&gt; bgcd($y);             # GCD of $x and $y
    $x -&gt; bgcd($y, $z, ...);    # GCD of $x, $y, $z, ...
    </pre>
    <p class="Pp">Returns the greatest common divisor (GCD).</p>
  </dd>
  <dt id="blcm()"><a class="permalink" href="#blcm()"><b>blcm()</b></a></dt>
  <dd>
    <pre>    $x -&gt; blcm($y);             # LCM of $x and $y
    $x -&gt; blcm($y, $z, ...);    # LCM of $x, $y, $z, ...
    </pre>
    <p class="Pp">Returns the least common multiple (LCM).</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Object_property_methods"><a class="permalink" href="#Object_property_methods">Object
  property methods</a></h2>
<dl class="Bl-tag">
  <dt id="sign()"><a class="permalink" href="#sign()"><b>sign()</b></a></dt>
  <dd>
    <pre>    $x-&gt;sign();
    </pre>
    <p class="Pp">Return the sign, of <span class="Li">$x</span>, meaning either
        <span class="Li">&quot;+&quot;</span>,
        <span class="Li">&quot;-&quot;</span>,
        <span class="Li">&quot;-inf&quot;</span>,
        <span class="Li">&quot;+inf&quot;</span> or NaN.</p>
    <p class="Pp">If you want <span class="Li">$x</span> to have a certain sign,
        use one of the following methods:</p>
    <p class="Pp"></p>
    <pre>    $x-&gt;babs();                 # '+'
    $x-&gt;babs()-&gt;bneg();         # '-'
    $x-&gt;bnan();                 # 'NaN'
    $x-&gt;binf();                 # '+inf'
    $x-&gt;binf('-');              # '-inf'
    </pre>
  </dd>
  <dt id="digit()"><a class="permalink" href="#digit()"><b>digit()</b></a></dt>
  <dd>
    <pre>    $x-&gt;digit($n);       # return the nth digit, counting from right
    </pre>
    <p class="Pp">If <span class="Li">$n</span> is negative, returns the digit
        counting from left.</p>
  </dd>
  <dt id="length()"><a class="permalink" href="#length()"><b>length()</b></a></dt>
  <dd>
    <pre>    $x-&gt;length();
    ($xl, $fl) = $x-&gt;length();
    </pre>
    <p class="Pp">Returns the number of digits in the decimal representation of
        the number. In list context, returns the length of the integer and
        fraction part. For Math::BigInt objects, the length of the fraction part
        is always 0.</p>
    <p class="Pp">The following probably doesn't do what you expect:</p>
    <p class="Pp"></p>
    <pre>    $c = Math::BigInt-&gt;new(123);
    print $c-&gt;length(),&quot;\n&quot;;                # prints 30
    </pre>
    <p class="Pp">It prints both the number of digits in the number and in the
        fraction part since print calls
        <span class="Li">&quot;length()&quot;</span> in list context. Use
        something like:</p>
    <p class="Pp"></p>
    <pre>    print scalar $c-&gt;length(),&quot;\n&quot;;         # prints 3
    </pre>
  </dd>
  <dt id="mantissa()"><a class="permalink" href="#mantissa()"><b>mantissa()</b></a></dt>
  <dd>
    <pre>    $x-&gt;mantissa();
    </pre>
    <p class="Pp">Return the signed mantissa of <span class="Li">$x</span> as a
        Math::BigInt.</p>
  </dd>
  <dt id="exponent()"><a class="permalink" href="#exponent()"><b>exponent()</b></a></dt>
  <dd>
    <pre>    $x-&gt;exponent();
    </pre>
    <p class="Pp">Return the exponent of <span class="Li">$x</span> as a
        Math::BigInt.</p>
  </dd>
  <dt id="parts()"><a class="permalink" href="#parts()"><b>parts()</b></a></dt>
  <dd>
    <pre>    $x-&gt;parts();
    </pre>
    <p class="Pp">Returns the significand (mantissa) and the exponent as
        integers. In Math::BigFloat, both are returned as Math::BigInt
      objects.</p>
  </dd>
  <dt id="sparts()"><a class="permalink" href="#sparts()"><b>sparts()</b></a></dt>
  <dd>Returns the significand (mantissa) and the exponent as integers. In scalar
      context, only the significand is returned. The significand is the integer
      with the smallest absolute value. The output of
      <span class="Li">&quot;sparts()&quot;</span> corresponds to the output
      from <span class="Li">&quot;bsstr()&quot;</span>.
    <p class="Pp">In Math::BigInt, this method is identical to
        <span class="Li">&quot;parts()&quot;</span>.</p>
  </dd>
  <dt id="nparts()"><a class="permalink" href="#nparts()"><b>nparts()</b></a></dt>
  <dd>Returns the significand (mantissa) and exponent corresponding to
      normalized notation. In scalar context, only the significand is returned.
      For finite non-zero numbers, the significand's absolute value is greater
      than or equal to 1 and less than 10. The output of
      <span class="Li">&quot;nparts()&quot;</span> corresponds to the output
      from <span class="Li">&quot;bnstr()&quot;</span>. In Math::BigInt, if the
      significand can not be represented as an integer, upgrading is performed
      or NaN is returned.</dd>
  <dt id="eparts()"><a class="permalink" href="#eparts()"><b>eparts()</b></a></dt>
  <dd>Returns the significand (mantissa) and exponent corresponding to
      engineering notation. In scalar context, only the significand is returned.
      For finite non-zero numbers, the significand's absolute value is greater
      than or equal to 1 and less than 1000, and the exponent is a multiple of
      3. The output of <span class="Li">&quot;eparts()&quot;</span> corresponds
      to the output from <span class="Li">&quot;bestr()&quot;</span>. In
      Math::BigInt, if the significand can not be represented as an integer,
      upgrading is performed or NaN is returned.</dd>
  <dt id="dparts()"><a class="permalink" href="#dparts()"><b>dparts()</b></a></dt>
  <dd>Returns the integer part and the fraction part. If the fraction part can
      not be represented as an integer, upgrading is performed or NaN is
      returned. The output of <span class="Li">&quot;dparts()&quot;</span>
      corresponds to the output from
      <span class="Li">&quot;bdstr()&quot;</span>.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="String_conversion_methods"><a class="permalink" href="#String_conversion_methods">String
  conversion methods</a></h2>
<dl class="Bl-tag">
  <dt id="bstr()"><a class="permalink" href="#bstr()"><b>bstr()</b></a></dt>
  <dd>Returns a string representing the number using decimal notation. In
      Math::BigFloat, the output is zero padded according to the current
      accuracy or precision, if any of those are defined.</dd>
  <dt id="bsstr()"><a class="permalink" href="#bsstr()"><b>bsstr()</b></a></dt>
  <dd>Returns a string representing the number using scientific notation where
      both the significand (mantissa) and the exponent are integers. The output
      corresponds to the output from
      <span class="Li">&quot;sparts()&quot;</span>.
    <p class="Pp"></p>
    <pre>      123 is returned as &quot;123e+0&quot;
     1230 is returned as &quot;123e+1&quot;
    12300 is returned as &quot;123e+2&quot;
    12000 is returned as &quot;12e+3&quot;
    10000 is returned as &quot;1e+4&quot;
    </pre>
  </dd>
  <dt id="bnstr()"><a class="permalink" href="#bnstr()"><b>bnstr()</b></a></dt>
  <dd>Returns a string representing the number using normalized notation, the
      most common variant of scientific notation. For finite non-zero numbers,
      the absolute value of the significand is greater than or equal to 1 and
      less than 10. The output corresponds to the output from
      <span class="Li">&quot;nparts()&quot;</span>.
    <p class="Pp"></p>
    <pre>      123 is returned as &quot;1.23e+2&quot;
     1230 is returned as &quot;1.23e+3&quot;
    12300 is returned as &quot;1.23e+4&quot;
    12000 is returned as &quot;1.2e+4&quot;
    10000 is returned as &quot;1e+4&quot;
    </pre>
  </dd>
  <dt id="bestr()"><a class="permalink" href="#bestr()"><b>bestr()</b></a></dt>
  <dd>Returns a string representing the number using engineering notation. For
      finite non-zero numbers, the absolute value of the significand is greater
      than or equal to 1 and less than 1000, and the exponent is a multiple of
      3. The output corresponds to the output from
      <span class="Li">&quot;eparts()&quot;</span>.
    <p class="Pp"></p>
    <pre>      123 is returned as &quot;123e+0&quot;
     1230 is returned as &quot;1.23e+3&quot;
    12300 is returned as &quot;12.3e+3&quot;
    12000 is returned as &quot;12e+3&quot;
    10000 is returned as &quot;10e+3&quot;
    </pre>
  </dd>
  <dt id="bdstr()"><a class="permalink" href="#bdstr()"><b>bdstr()</b></a></dt>
  <dd>Returns a string representing the number using decimal notation. The
      output corresponds to the output from
      <span class="Li">&quot;dparts()&quot;</span>.
    <p class="Pp"></p>
    <pre>      123 is returned as &quot;123&quot;
     1230 is returned as &quot;1230&quot;
    12300 is returned as &quot;12300&quot;
    12000 is returned as &quot;12000&quot;
    10000 is returned as &quot;10000&quot;
    </pre>
  </dd>
  <dt id="to_hex()"><a class="permalink" href="#to_hex()"><b>to_hex()</b></a></dt>
  <dd>
    <pre>    $x-&gt;to_hex();
    </pre>
    <p class="Pp">Returns a hexadecimal string representation of the number. See
        also <b>from_hex()</b>.</p>
  </dd>
  <dt id="to_bin()"><a class="permalink" href="#to_bin()"><b>to_bin()</b></a></dt>
  <dd>
    <pre>    $x-&gt;to_bin();
    </pre>
    <p class="Pp">Returns a binary string representation of the number. See also
        <b>from_bin()</b>.</p>
  </dd>
  <dt id="to_oct()"><a class="permalink" href="#to_oct()"><b>to_oct()</b></a></dt>
  <dd>
    <pre>    $x-&gt;to_oct();
    </pre>
    <p class="Pp">Returns an octal string representation of the number. See also
        <b>from_oct()</b>.</p>
  </dd>
  <dt id="to_bytes()"><a class="permalink" href="#to_bytes()"><b>to_bytes()</b></a></dt>
  <dd>
    <pre>    $x = Math::BigInt-&gt;new(&quot;1667327589&quot;);
    $s = $x-&gt;to_bytes();                    # $s = &quot;cafe&quot;
    </pre>
    <p class="Pp">Returns a byte string representation of the number using big
        endian byte order. The invocand must be a non-negative, finite integer.
        See also <b>from_bytes()</b>.</p>
  </dd>
  <dt id="to_base()"><a class="permalink" href="#to_base()"><b>to_base()</b></a></dt>
  <dd>
    <pre>    $x = Math::BigInt-&gt;new(&quot;250&quot;);
    $x-&gt;to_base(2);     # returns &quot;11111010&quot;
    $x-&gt;to_base(8);     # returns &quot;372&quot;
    $x-&gt;to_base(16);    # returns &quot;fa&quot;
    </pre>
    <p class="Pp">Returns a string representation of the number in the given
        base. If a collation sequence is given, the collation sequence
        determines which characters are used in the output.</p>
    <p class="Pp">Here are some more examples</p>
    <p class="Pp"></p>
    <pre>    $x = Math::BigInt-&gt;new(&quot;16&quot;)-&gt;to_base(3);       # returns &quot;121&quot;
    $x = Math::BigInt-&gt;new(&quot;44027&quot;)-&gt;to_base(36);   # returns &quot;XYZ&quot;
    $x = Math::BigInt-&gt;new(&quot;58314&quot;)-&gt;to_base(42);   # returns &quot;Why&quot;
    $x = Math::BigInt-&gt;new(&quot;4&quot;)-&gt;to_base(2, &quot;-|&quot;);  # returns &quot;|--&quot;
    </pre>
    <p class="Pp">See <b>from_base()</b> for information and examples.</p>
  </dd>
  <dt id="as_hex()"><a class="permalink" href="#as_hex()"><b>as_hex()</b></a></dt>
  <dd>
    <pre>    $x-&gt;as_hex();
    </pre>
    <p class="Pp">As, <span class="Li">&quot;to_hex()&quot;</span>, but with a
        &quot;0x&quot; prefix.</p>
  </dd>
  <dt id="as_bin()"><a class="permalink" href="#as_bin()"><b>as_bin()</b></a></dt>
  <dd>
    <pre>    $x-&gt;as_bin();
    </pre>
    <p class="Pp">As, <span class="Li">&quot;to_bin()&quot;</span>, but with a
        &quot;0b&quot; prefix.</p>
  </dd>
  <dt id="as_oct()"><a class="permalink" href="#as_oct()"><b>as_oct()</b></a></dt>
  <dd>
    <pre>    $x-&gt;as_oct();
    </pre>
    <p class="Pp">As, <span class="Li">&quot;to_oct()&quot;</span>, but with a
        &quot;0&quot; prefix.</p>
  </dd>
  <dt id="as_bytes()"><a class="permalink" href="#as_bytes()"><b>as_bytes()</b></a></dt>
  <dd>This is just an alias for
    <span class="Li">&quot;to_bytes()&quot;</span>.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Other_conversion_methods"><a class="permalink" href="#Other_conversion_methods">Other
  conversion methods</a></h2>
<dl class="Bl-tag">
  <dt id="numify()"><a class="permalink" href="#numify()"><b>numify()</b></a></dt>
  <dd>
    <pre>    print $x-&gt;numify();
    </pre>
    <p class="Pp">Returns a Perl scalar from <span class="Li">$x</span>. It is
        used automatically whenever a scalar is needed, for instance in array
        index operations.</p>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ACCURACY_and_PRECISION"><a class="permalink" href="#ACCURACY_and_PRECISION">ACCURACY
  and PRECISION</a></h1>
<p class="Pp">Math::BigInt and Math::BigFloat have full support for accuracy and
    precision based rounding, both automatically after every operation, as well
    as manually.</p>
<p class="Pp">This section describes the accuracy/precision handling in
    Math::BigInt and Math::BigFloat as it used to be and as it is now, complete
    with an explanation of all terms and abbreviations.</p>
<p class="Pp">Not yet implemented things (but with correct description) are
    marked with '!', things that need to be answered are marked with '?'.</p>
<p class="Pp">In the next paragraph follows a short description of terms used
    here (because these may differ from terms used by others people or
    documentation).</p>
<p class="Pp">During the rest of this document, the shortcuts A (for accuracy),
    P (for precision), F (fallback) and R (rounding mode) are be used.</p>
<section class="Ss">
<h2 class="Ss" id="Precision_P"><a class="permalink" href="#Precision_P">Precision
  P</a></h2>
<p class="Pp">Precision is a fixed number of digits before (positive) or after
    (negative) the decimal point. For example, 123.45 has a precision of -2. 0
    means an integer like 123 (or 120). A precision of 2 means at least two
    digits to the left of the decimal point are zero, so 123 with P = 1 becomes
    120. Note that numbers with zeros before the decimal point may have
    different precisions, because 1200 can have P = 0, 1 or 2 (depending on what
    the initial value was). It could also have p &lt; 0, when the digits after
    the decimal point are zero.</p>
<p class="Pp">The string output (of floating point numbers) is padded with
    zeros:</p>
<p class="Pp"></p>
<pre>    Initial value    P      A       Result          String
    ------------------------------------------------------------
    1234.01         -3              1000            1000
    1234            -2              1200            1200
    1234.5          -1              1230            1230
    1234.001         1              1234            1234.0
    1234.01          0              1234            1234
    1234.01          2              1234.01         1234.01
    1234.01          5              1234.01         1234.01000
</pre>
<p class="Pp">For Math::BigInt objects, no padding occurs.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Accuracy_A"><a class="permalink" href="#Accuracy_A">Accuracy
  A</a></h2>
<p class="Pp">Number of significant digits. Leading zeros are not counted. A
    number may have an accuracy greater than the non-zero digits when there are
    zeros in it or trailing zeros. For example, 123.456 has A of 6, 10203 has 5,
    123.0506 has 7, 123.45000 has 8 and 0.000123 has 3.</p>
<p class="Pp">The string output (of floating point numbers) is padded with
    zeros:</p>
<p class="Pp"></p>
<pre>    Initial value    P      A       Result          String
    ------------------------------------------------------------
    1234.01                 3       1230            1230
    1234.01                 6       1234.01         1234.01
    1234.1                  8       1234.1          1234.1000
</pre>
<p class="Pp">For Math::BigInt objects, no padding occurs.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Fallback_F"><a class="permalink" href="#Fallback_F">Fallback
  F</a></h2>
<p class="Pp">When both A and P are undefined, this is used as a fallback
    accuracy when dividing numbers.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Rounding_mode_R"><a class="permalink" href="#Rounding_mode_R">Rounding
  mode R</a></h2>
<p class="Pp">When rounding a number, different 'styles' or 'kinds' of rounding
    are possible. (Note that random rounding, as in Math::Round, is not
    implemented.)</p>
<p class="Pp"><i>Directed rounding</i></p>
<p class="Pp">These round modes always round in the same direction.</p>
<dl class="Bl-tag">
  <dt>'trunc'</dt>
  <dd>Round towards zero. Remove all digits following the rounding place, i.e.,
      replace them with zeros. Thus, 987.65 rounded to tens (P=1) becomes 980,
      and rounded to the fourth significant digit becomes 987.6 (A=4). 123.456
      rounded to the second place after the decimal point (P=-2) becomes 123.46.
      This corresponds to the IEEE 754 rounding mode 'roundTowardZero'.</dd>
</dl>
<p class="Pp"><i>Rounding to nearest</i></p>
<p class="Pp">These rounding modes round to the nearest digit. They differ in
    how they determine which way to round in the ambiguous case when there is a
    tie.</p>
<dl class="Bl-tag">
  <dt>'even'</dt>
  <dd>Round towards the nearest even digit, e.g., when rounding to nearest
      integer, -5.5 becomes -6, 4.5 becomes 4, but 4.501 becomes 5. This
      corresponds to the IEEE 754 rounding mode 'roundTiesToEven'.</dd>
  <dt>'odd'</dt>
  <dd>Round towards the nearest odd digit, e.g., when rounding to nearest
      integer, 4.5 becomes 5, -5.5 becomes -5, but 5.501 becomes 6. This
      corresponds to the IEEE 754 rounding mode 'roundTiesToOdd'.</dd>
  <dt>'+inf'</dt>
  <dd>Round towards plus infinity, i.e., always round up. E.g., when rounding to
      the nearest integer, 4.5 becomes 5, -5.5 becomes -5, and 4.501 also
      becomes 5. This corresponds to the IEEE 754 rounding mode
      'roundTiesToPositive'.</dd>
  <dt>'-inf'</dt>
  <dd>Round towards minus infinity, i.e., always round down. E.g., when rounding
      to the nearest integer, 4.5 becomes 4, -5.5 becomes -6, but 4.501 becomes
      5. This corresponds to the IEEE 754 rounding mode
    'roundTiesToNegative'.</dd>
  <dt>'zero'</dt>
  <dd>Round towards zero, i.e., round positive numbers down and negative numbers
      up. E.g., when rounding to the nearest integer, 4.5 becomes 4, -5.5
      becomes -5, but 4.501 becomes 5. This corresponds to the IEEE 754 rounding
      mode 'roundTiesToZero'.</dd>
  <dt>'common'</dt>
  <dd>Round away from zero, i.e., round to the number with the largest absolute
      value. E.g., when rounding to the nearest integer, -1.5 becomes -2, 1.5
      becomes 2 and 1.49 becomes 1. This corresponds to the IEEE 754 rounding
      mode 'roundTiesToAway'.</dd>
</dl>
<p class="Pp">The handling of A &amp; P in MBI/MBF (the old core code shipped
    with Perl versions &lt;= 5.7.2) is like this:</p>
<dl class="Bl-tag">
  <dt id="Precision"><a class="permalink" href="#Precision">Precision</a></dt>
  <dd>
    <pre>  * bfround($p) is able to round to $p number of digits after the decimal
    point
  * otherwise P is unused
    </pre>
  </dd>
  <dt id="Accuracy"><a class="permalink" href="#Accuracy">Accuracy (significant
    digits)</a></dt>
  <dd>
    <pre>  * bround($a) rounds to $a significant digits
  * only bdiv() and bsqrt() take A as (optional) parameter
    + other operations simply create the same number (bneg etc), or
      more (bmul) of digits
    + rounding/truncating is only done when explicitly calling one
      of bround or bfround, and never for Math::BigInt (not implemented)
  * bsqrt() simply hands its accuracy argument over to bdiv.
  * the documentation and the comment in the code indicate two
    different ways on how bdiv() determines the maximum number
    of digits it should calculate, and the actual code does yet
    another thing
    POD:
      max($Math::BigFloat::div_scale,length(dividend)+length(divisor))
    Comment:
      result has at most max(scale, length(dividend), length(divisor)) digits
    Actual code:
      scale = max(scale, length(dividend)-1,length(divisor)-1);
      scale += length(divisor) - length(dividend);
    So for lx = 3, ly = 9, scale = 10, scale will actually be 16 (10
    So for lx = 3, ly = 9, scale = 10, scale will actually be 16
    (10+9-3). Actually, the 'difference' added to the scale is cal-
    culated from the number of &quot;significant digits&quot; in dividend and
    divisor, which is derived by looking at the length of the man-
    tissa. Which is wrong, since it includes the + sign (oops) and
    actually gets 2 for '+100' and 4 for '+101'. Oops again. Thus
    124/3 with div_scale=1 will get you '41.3' based on the strange
    assumption that 124 has 3 significant digits, while 120/7 will
    get you '17', not '17.1' since 120 is thought to have 2 signif-
    icant digits. The rounding after the division then uses the
    remainder and $y to determine whether it must round up or down.
 ?  I have no idea which is the right way. That's why I used a slightly more
 ?  simple scheme and tweaked the few failing testcases to match it.
    </pre>
  </dd>
</dl>
<p class="Pp">This is how it works now:</p>
<dl class="Bl-tag">
  <dt id="Setting/Accessing"><a class="permalink" href="#Setting/Accessing">Setting/Accessing</a></dt>
  <dd>
    <pre>  * You can set the A global via Math::BigInt-&gt;accuracy() or
    Math::BigFloat-&gt;accuracy() or whatever class you are using.
  * You can also set P globally by using Math::SomeClass-&gt;precision()
    likewise.
  * Globals are classwide, and not inherited by subclasses.
  * to undefine A, use Math::SomeCLass-&gt;accuracy(undef);
  * to undefine P, use Math::SomeClass-&gt;precision(undef);
  * Setting Math::SomeClass-&gt;accuracy() clears automatically
    Math::SomeClass-&gt;precision(), and vice versa.
  * To be valid, A must be &gt; 0, P can have any value.
  * If P is negative, this means round to the P'th place to the right of the
    decimal point; positive values mean to the left of the decimal point.
    P of 0 means round to integer.
  * to find out the current global A, use Math::SomeClass-&gt;accuracy()
  * to find out the current global P, use Math::SomeClass-&gt;precision()
  * use $x-&gt;accuracy() respective $x-&gt;precision() for the local
    setting of $x.
  * Please note that $x-&gt;accuracy() respective $x-&gt;precision()
    return eventually defined global A or P, when $x's A or P is not
    set.
    </pre>
  </dd>
  <dt id="Creating"><a class="permalink" href="#Creating">Creating
    numbers</a></dt>
  <dd>
    <pre>  * When you create a number, you can give the desired A or P via:
    $x = Math::BigInt-&gt;new($number,$A,$P);
  * Only one of A or P can be defined, otherwise the result is NaN
  * If no A or P is give ($x = Math::BigInt-&gt;new($number) form), then the
    globals (if set) will be used. Thus changing the global defaults later on
    will not change the A or P of previously created numbers (i.e., A and P of
    $x will be what was in effect when $x was created)
  * If given undef for A and P, NO rounding will occur, and the globals will
    NOT be used. This is used by subclasses to create numbers without
    suffering rounding in the parent. Thus a subclass is able to have its own
    globals enforced upon creation of a number by using
    $x = Math::BigInt-&gt;new($number,undef,undef):
        use Math::BigInt::SomeSubclass;
        use Math::BigInt;
        Math::BigInt-&gt;accuracy(2);
        Math::BigInt::SomeSubClass-&gt;accuracy(3);
        $x = Math::BigInt::SomeSubClass-&gt;new(1234);
    $x is now 1230, and not 1200. A subclass might choose to implement
    this otherwise, e.g. falling back to the parent's A and P.
    </pre>
  </dd>
  <dt id="Usage"><a class="permalink" href="#Usage">Usage</a></dt>
  <dd>
    <pre>  * If A or P are enabled/defined, they are used to round the result of each
    operation according to the rules below
  * Negative P is ignored in Math::BigInt, since Math::BigInt objects never
    have digits after the decimal point
  * Math::BigFloat uses Math::BigInt internally, but setting A or P inside
    Math::BigInt as globals does not tamper with the parts of a Math::BigFloat.
    A flag is used to mark all Math::BigFloat numbers as 'never round'.
    </pre>
  </dd>
  <dt id="Precedence"><a class="permalink" href="#Precedence">Precedence</a></dt>
  <dd>
    <pre>  * It only makes sense that a number has only one of A or P at a time.
    If you set either A or P on one object, or globally, the other one will
    be automatically cleared.
  * If two objects are involved in an operation, and one of them has A in
    effect, and the other P, this results in an error (NaN).
  * A takes precedence over P (Hint: A comes before P).
    If neither of them is defined, nothing is used, i.e. the result will have
    as many digits as it can (with an exception for bdiv/bsqrt) and will not
    be rounded.
  * There is another setting for bdiv() (and thus for bsqrt()). If neither of
    A or P is defined, bdiv() will use a fallback (F) of $div_scale digits.
    If either the dividend's or the divisor's mantissa has more digits than
    the value of F, the higher value will be used instead of F.
    This is to limit the digits (A) of the result (just consider what would
    happen with unlimited A and P in the case of 1/3 :-)
  * bdiv will calculate (at least) 4 more digits than required (determined by
    A, P or F), and, if F is not used, round the result
    (this will still fail in the case of a result like 0.12345000000001 with A
    or P of 5, but this can not be helped - or can it?)
  * Thus you can have the math done by on Math::Big* class in two modi:
    + never round (this is the default):
      This is done by setting A and P to undef. No math operation
      will round the result, with bdiv() and bsqrt() as exceptions to guard
      against overflows. You must explicitly call bround(), bfround() or
      round() (the latter with parameters).
      Note: Once you have rounded a number, the settings will 'stick' on it
      and 'infect' all other numbers engaged in math operations with it, since
      local settings have the highest precedence. So, to get SaferRound[tm],
      use a copy() before rounding like this:
        $x = Math::BigFloat-&gt;new(12.34);
        $y = Math::BigFloat-&gt;new(98.76);
        $z = $x * $y;                           # 1218.6984
        print $x-&gt;copy()-&gt;bround(3);            # 12.3 (but A is now 3!)
        $z = $x * $y;                           # still 1218.6984, without
                                                # copy would have been 1210!
    + round after each op:
      After each single operation (except for testing like is_zero()), the
      method round() is called and the result is rounded appropriately. By
      setting proper values for A and P, you can have all-the-same-A or
      all-the-same-P modes. For example, Math::Currency might set A to undef,
      and P to -2, globally.
 ?Maybe an extra option that forbids local A &amp; P settings would be in order,
 ?so that intermediate rounding does not 'poison' further math?
    </pre>
  </dd>
  <dt id="Overriding"><a class="permalink" href="#Overriding">Overriding
    globals</a></dt>
  <dd>
    <pre>  * you will be able to give A, P and R as an argument to all the calculation
    routines; the second parameter is A, the third one is P, and the fourth is
    R (shift right by one for binary operations like badd). P is used only if
    the first parameter (A) is undefined. These three parameters override the
    globals in the order detailed as follows, i.e. the first defined value
    wins:
    (local: per object, global: global default, parameter: argument to sub)
      + parameter A
      + parameter P
      + local A (if defined on both of the operands: smaller one is taken)
      + local P (if defined on both of the operands: bigger one is taken)
      + global A
      + global P
      + global F
  * bsqrt() will hand its arguments to bdiv(), as it used to, only now for two
    arguments (A and P) instead of one
    </pre>
  </dd>
  <dt id="Local"><a class="permalink" href="#Local">Local settings</a></dt>
  <dd>
    <pre>  * You can set A or P locally by using $x-&gt;accuracy() or
    $x-&gt;precision()
    and thus force different A and P for different objects/numbers.
  * Setting A or P this way immediately rounds $x to the new value.
  * $x-&gt;accuracy() clears $x-&gt;precision(), and vice versa.
    </pre>
  </dd>
  <dt id="Rounding"><a class="permalink" href="#Rounding">Rounding</a></dt>
  <dd>
    <pre>  * the rounding routines will use the respective global or local settings.
    bround() is for accuracy rounding, while bfround() is for precision
  * the two rounding functions take as the second parameter one of the
    following rounding modes (R):
    'even', 'odd', '+inf', '-inf', 'zero', 'trunc', 'common'
  * you can set/get the global R by using Math::SomeClass-&gt;round_mode()
    or by setting $Math::SomeClass::round_mode
  * after each operation, $result-&gt;round() is called, and the result may
    eventually be rounded (that is, if A or P were set either locally,
    globally or as parameter to the operation)
  * to manually round a number, call $x-&gt;round($A,$P,$round_mode);
    this will round the number by using the appropriate rounding function
    and then normalize it.
  * rounding modifies the local settings of the number:
        $x = Math::BigFloat-&gt;new(123.456);
        $x-&gt;accuracy(5);
        $x-&gt;bround(4);
    Here 4 takes precedence over 5, so 123.5 is the result and $x-&gt;accuracy()
    will be 4 from now on.
    </pre>
  </dd>
  <dt id="Default"><a class="permalink" href="#Default">Default values</a></dt>
  <dd>
    <pre>  * R: 'even'
  * F: 40
  * A: undef
  * P: undef
    </pre>
  </dd>
  <dt id="Remarks"><a class="permalink" href="#Remarks">Remarks</a></dt>
  <dd>
    <pre>  * The defaults are set up so that the new code gives the same results as
    the old code (except in a few cases on bdiv):
    + Both A and P are undefined and thus will not be used for rounding
      after each operation.
    + round() is thus a no-op, unless given extra parameters A and P
    </pre>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Infinity_and_Not_a_Number"><a class="permalink" href="#Infinity_and_Not_a_Number">Infinity
  and Not a Number</a></h1>
<p class="Pp">While Math::BigInt has extensive handling of inf and NaN, certain
    quirks remain.</p>
<dl class="Bl-tag">
  <dt id="oct()"><a class="permalink" href="#oct()"><b>oct()</b>/<b>hex()</b></a></dt>
  <dd>These perl routines currently (as of Perl v.5.8.6) cannot handle passed
      inf.
    <p class="Pp"></p>
    <pre>    te@linux:~&gt; perl -wle 'print 2 ** 3333'
    Inf
    te@linux:~&gt; perl -wle 'print 2 ** 3333 == 2 ** 3333'
    1
    te@linux:~&gt; perl -wle 'print oct(2 ** 3333)'
    0
    te@linux:~&gt; perl -wle 'print hex(2 ** 3333)'
    Illegal hexadecimal digit 'I' ignored at -e line 1.
    0
    </pre>
    <p class="Pp">The same problems occur if you pass them
        Math::BigInt-&gt;<b>binf()</b> objects. Since overloading these routines
        is not possible, this cannot be fixed from Math::BigInt.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="INTERNALS"><a class="permalink" href="#INTERNALS">INTERNALS</a></h1>
<p class="Pp">You should neither care about nor depend on the internal
    representation; it might change without notice. Use <b>ONLY</b> method calls
    like <span class="Li">&quot;$x-&gt;sign();&quot;</span> instead relying on
    the internal representation.</p>
<section class="Ss">
<h2 class="Ss">MATH LIBRARY</h2>
<p class="Pp">Math with the numbers is done (by default) by a module called
    <span class="Li">&quot;Math::BigInt::Calc&quot;</span>. This is equivalent
    to saying:</p>
<p class="Pp"></p>
<pre>    use Math::BigInt try =&gt; 'Calc';
</pre>
<p class="Pp">You can change this backend library by using:</p>
<p class="Pp"></p>
<pre>    use Math::BigInt try =&gt; 'GMP';
</pre>
<p class="Pp"><b>Note</b>: General purpose packages should not be explicit about
    the library to use; let the script author decide which is best.</p>
<p class="Pp">If your script works with huge numbers and Calc is too slow for
    them, you can also for the loading of one of these libraries and if none of
    them can be used, the code dies:</p>
<p class="Pp"></p>
<pre>    use Math::BigInt only =&gt; 'GMP,Pari';
</pre>
<p class="Pp">The following would first try to find Math::BigInt::Foo, then
    Math::BigInt::Bar, and when this also fails, revert to
  Math::BigInt::Calc:</p>
<p class="Pp"></p>
<pre>    use Math::BigInt try =&gt; 'Foo,Math::BigInt::Bar';
</pre>
<p class="Pp">The library that is loaded last is used. Note that this can be
    overwritten at any time by loading a different library, and numbers
    constructed with different libraries cannot be used in math operations
    together.</p>
<p class="Pp"><i>What library to use?</i></p>
<p class="Pp"><b>Note</b>: General purpose packages should not be explicit about
    the library to use; let the script author decide which is best.</p>
<p class="Pp">Math::BigInt::GMP and Math::BigInt::Pari are in cases involving
    big numbers much faster than Calc, however it is slower when dealing with
    very small numbers (less than about 20 digits) and when converting very
    large numbers to decimal (for instance for printing, rounding, calculating
    their length in decimal etc).</p>
<p class="Pp">So please select carefully what library you want to use.</p>
<p class="Pp">Different low-level libraries use different formats to store the
    numbers. However, you should <b>NOT</b> depend on the number having a
    specific format internally.</p>
<p class="Pp">See the respective math library module documentation for further
    details.</p>
</section>
<section class="Ss">
<h2 class="Ss">SIGN</h2>
<p class="Pp">The sign is either '+', '-', 'NaN', '+inf' or '-inf'.</p>
<p class="Pp">A sign of 'NaN' is used to represent the result when input
    arguments are not numbers or as a result of 0/0. '+inf' and '-inf' represent
    plus respectively minus infinity. You get '+inf' when dividing a positive
    number by 0, and '-inf' when dividing any negative number by 0.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<pre>  use Math::BigInt;
  sub bigint { Math::BigInt-&gt;new(shift); }
  $x = Math::BigInt-&gt;bstr(&quot;1234&quot;)       # string &quot;1234&quot;
  $x = &quot;$x&quot;;                            # same as bstr()
  $x = Math::BigInt-&gt;bneg(&quot;1234&quot;);      # Math::BigInt &quot;-1234&quot;
  $x = Math::BigInt-&gt;babs(&quot;-12345&quot;);    # Math::BigInt &quot;12345&quot;
  $x = Math::BigInt-&gt;bnorm(&quot;-0.00&quot;);    # Math::BigInt &quot;0&quot;
  $x = bigint(1) + bigint(2);           # Math::BigInt &quot;3&quot;
  $x = bigint(1) + &quot;2&quot;;                 # ditto (auto-Math::BigIntify of &quot;2&quot;)
  $x = bigint(1);                       # Math::BigInt &quot;1&quot;
  $x = $x + 5 / 2;                      # Math::BigInt &quot;3&quot;
  $x = $x ** 3;                         # Math::BigInt &quot;27&quot;
  $x *= 2;                              # Math::BigInt &quot;54&quot;
  $x = Math::BigInt-&gt;new(0);            # Math::BigInt &quot;0&quot;
  $x--;                                 # Math::BigInt &quot;-1&quot;
  $x = Math::BigInt-&gt;badd(4,5)          # Math::BigInt &quot;9&quot;
  print $x-&gt;bsstr();                    # 9e+0
</pre>
<p class="Pp">Examples for rounding:</p>
<p class="Pp"></p>
<pre>  use Math::BigFloat;
  use Test::More;
  $x = Math::BigFloat-&gt;new(123.4567);
  $y = Math::BigFloat-&gt;new(123.456789);
  Math::BigFloat-&gt;accuracy(4);          # no more A than 4
  is ($x-&gt;copy()-&gt;bround(),123.4);      # even rounding
  print $x-&gt;copy()-&gt;bround(),&quot;\n&quot;;      # 123.4
  Math::BigFloat-&gt;round_mode('odd');    # round to odd
  print $x-&gt;copy()-&gt;bround(),&quot;\n&quot;;      # 123.5
  Math::BigFloat-&gt;accuracy(5);          # no more A than 5
  Math::BigFloat-&gt;round_mode('odd');    # round to odd
  print $x-&gt;copy()-&gt;bround(),&quot;\n&quot;;      # 123.46
  $y = $x-&gt;copy()-&gt;bround(4),&quot;\n&quot;;      # A = 4: 123.4
  print &quot;$y, &quot;,$y-&gt;accuracy(),&quot;\n&quot;;     # 123.4, 4
  Math::BigFloat-&gt;accuracy(undef);      # A not important now
  Math::BigFloat-&gt;precision(2);         # P important
  print $x-&gt;copy()-&gt;bnorm(),&quot;\n&quot;;       # 123.46
  print $x-&gt;copy()-&gt;bround(),&quot;\n&quot;;      # 123.46
</pre>
<p class="Pp">Examples for converting:</p>
<p class="Pp"></p>
<pre>  my $x = Math::BigInt-&gt;new('0b1'.'01' x 123);
  print &quot;bin: &quot;,$x-&gt;as_bin(),&quot; hex:&quot;,$x-&gt;as_hex(),&quot; dec: &quot;,$x,&quot;\n&quot;;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="Autocreating_constants"><a class="permalink" href="#Autocreating_constants">Autocreating
  constants</a></h1>
<p class="Pp">After <span class="Li">&quot;use Math::BigInt
    ':constant'&quot;</span> all the <b>integer</b> decimal, hexadecimal and
    binary constants in the given scope are converted to
    <span class="Li">&quot;Math::BigInt&quot;</span>. This conversion happens at
    compile time.</p>
<p class="Pp">In particular,</p>
<p class="Pp"></p>
<pre>  perl -MMath::BigInt=:constant -e 'print 2**100,&quot;\n&quot;'
</pre>
<p class="Pp">prints the integer value of
    <span class="Li">&quot;2**100&quot;</span>. Note that without conversion of
    constants the expression 2**100 is calculated using Perl scalars.</p>
<p class="Pp">Please note that strings and floating point constants are not
    affected, so that</p>
<p class="Pp"></p>
<pre>    use Math::BigInt qw/:constant/;
    $x = 1234567890123456789012345678901234567890
            + 123456789123456789;
    $y = '1234567890123456789012345678901234567890'
            + '123456789123456789';
</pre>
<p class="Pp">does not give you what you expect. You need an explicit
    Math::BigInt-&gt;<b>new()</b> around one of the operands. You should also
    quote large constants to protect loss of precision:</p>
<p class="Pp"></p>
<pre>    use Math::BigInt;
    $x = Math::BigInt-&gt;new('1234567889123456789123456789123456789');
</pre>
<p class="Pp">Without the quotes Perl would convert the large number to a
    floating point constant at compile time and then hand the result to
    Math::BigInt, which results in an truncated result or a NaN.</p>
<p class="Pp">This also applies to integers that look like floating point
    constants:</p>
<p class="Pp"></p>
<pre>    use Math::BigInt ':constant';
    print ref(123e2),&quot;\n&quot;;
    print ref(123.2e2),&quot;\n&quot;;
</pre>
<p class="Pp">prints nothing but newlines. Use either bignum or Math::BigFloat
    to get this to work.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PERFORMANCE"><a class="permalink" href="#PERFORMANCE">PERFORMANCE</a></h1>
<p class="Pp">Using the form <span class="Li">$x</span> +=
    <span class="Li">$y</span>; etc over <span class="Li">$x</span> =
    <span class="Li">$x</span> + <span class="Li">$y</span> is faster, since a
    copy of <span class="Li">$x</span> must be made in the second case. For long
    numbers, the copy can eat up to 20% of the work (in the case of
    addition/subtraction, less for multiplication/division). If
    <span class="Li">$y</span> is very small compared to
    <span class="Li">$x</span>, the form <span class="Li">$x</span> +=
    <span class="Li">$y</span> is MUCH faster than <span class="Li">$x</span> =
    <span class="Li">$x</span> + <span class="Li">$y</span> since making the
    copy of <span class="Li">$x</span> takes more time then the actual
  addition.</p>
<p class="Pp">With a technique called copy-on-write, the cost of copying with
    overload could be minimized or even completely avoided. A test
    implementation of COW did show performance gains for overloaded math, but
    introduced a performance loss due to a constant overhead for all other
    operations. So Math::BigInt does currently not COW.</p>
<p class="Pp">The rewritten version of this module (vs. v0.01) is slower on
    certain operations, like <span class="Li">&quot;new()&quot;</span>,
    <span class="Li">&quot;bstr()&quot;</span> and
    <span class="Li">&quot;numify()&quot;</span>. The reason are that it does
    now more work and handles much more cases. The time spent in these
    operations is usually gained in the other math operations so that code on
    the average should get (much) faster. If they don't, please contact the
    author.</p>
<p class="Pp">Some operations may be slower for small numbers, but are
    significantly faster for big numbers. Other operations are now constant
    (O(1), like <span class="Li">&quot;bneg()&quot;</span>,
    <span class="Li">&quot;babs()&quot;</span> etc), instead of O(N) and thus
    nearly always take much less time. These optimizations were done on
  purpose.</p>
<p class="Pp">If you find the Calc module to slow, try to install any of the
    replacement modules and see if they help you.</p>
<section class="Ss">
<h2 class="Ss" id="Alternative_math_libraries"><a class="permalink" href="#Alternative_math_libraries">Alternative
  math libraries</a></h2>
<p class="Pp">You can use an alternative library to drive Math::BigInt. See the
    section &quot;MATH LIBRARY&quot; for more information.</p>
<p class="Pp">For more benchmark results see
    &lt;http://bloodgate.com/perl/benchmarks.html&gt;.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SUBCLASSING"><a class="permalink" href="#SUBCLASSING">SUBCLASSING</a></h1>
<section class="Ss">
<h2 class="Ss" id="Subclassing_Math::BigInt"><a class="permalink" href="#Subclassing_Math::BigInt">Subclassing
  Math::BigInt</a></h2>
<p class="Pp">The basic design of Math::BigInt allows simple subclasses with
    very little work, as long as a few simple rules are followed:</p>
<ul class="Bl-bullet">
  <li>The public API must remain consistent, i.e. if a sub-class is overloading
      addition, the sub-class must use the same name, in this case
      <b>badd()</b>. The reason for this is that Math::BigInt is optimized to
      call the object methods directly.</li>
  <li>The private object hash keys like
      <span class="Li">&quot;$x-&gt;{sign}&quot;</span> may not be changed, but
      additional keys can be added, like
      <span class="Li">&quot;$x-&gt;{_custom}&quot;</span>.</li>
  <li>Accessor functions are available for all existing object hash keys and
      should be used instead of directly accessing the internal hash keys. The
      reason for this is that Math::BigInt itself has a pluggable interface
      which permits it to support different storage methods.</li>
</ul>
<p class="Pp">More complex sub-classes may have to replicate more of the logic
    internal of Math::BigInt if they need to change more basic behaviors. A
    subclass that needs to merely change the output only needs to overload
    <span class="Li">&quot;bstr()&quot;</span>.</p>
<p class="Pp">All other object methods and overloaded functions can be directly
    inherited from the parent class.</p>
<p class="Pp">At the very minimum, any subclass needs to provide its own
    <span class="Li">&quot;new()&quot;</span> and can store additional hash keys
    in the object. There are also some package globals that must be defined,
    e.g.:</p>
<p class="Pp"></p>
<pre>    # Globals
    $accuracy = undef;
    $precision = -2;       # round to 2 decimal places
    $round_mode = 'even';
    $div_scale = 40;
</pre>
<p class="Pp">Additionally, you might want to provide the following two globals
    to allow auto-upgrading and auto-downgrading to work correctly:</p>
<p class="Pp"></p>
<pre>    $upgrade = undef;
    $downgrade = undef;
</pre>
<p class="Pp">This allows Math::BigInt to correctly retrieve package globals
    from the subclass, like <span class="Li">$SubClass::precision</span>. See
    t/Math/BigInt/Subclass.pm or t/Math/BigFloat/SubClass.pm completely
    functional subclass examples.</p>
<p class="Pp">Don't forget to</p>
<p class="Pp"></p>
<pre>    use overload;
</pre>
<p class="Pp">in your subclass to automatically inherit the overloading from the
    parent. If you like, you can change part of the overloading, look at
    Math::String for an example.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="UPGRADING"><a class="permalink" href="#UPGRADING">UPGRADING</a></h1>
<p class="Pp">When used like this:</p>
<p class="Pp"></p>
<pre>    use Math::BigInt upgrade =&gt; 'Foo::Bar';
</pre>
<p class="Pp">certain operations 'upgrade' their calculation and thus the result
    to the class Foo::Bar. Usually this is used in conjunction with
    Math::BigFloat:</p>
<p class="Pp"></p>
<pre>    use Math::BigInt upgrade =&gt; 'Math::BigFloat';
</pre>
<p class="Pp">As a shortcut, you can use the module bignum:</p>
<p class="Pp"></p>
<pre>    use bignum;
</pre>
<p class="Pp">Also good for one-liners:</p>
<p class="Pp"></p>
<pre>    perl -Mbignum -le 'print 2 ** 255'
</pre>
<p class="Pp">This makes it possible to mix arguments of different classes (as
    in 2.5 + 2) as well es preserve accuracy (as in <b>sqrt</b>(3)).</p>
<p class="Pp">Beware: This feature is not fully implemented yet.</p>
<section class="Ss">
<h2 class="Ss" id="Auto-upgrade"><a class="permalink" href="#Auto-upgrade">Auto-upgrade</a></h2>
<p class="Pp">The following methods upgrade themselves unconditionally; that is
    if upgrade is in effect, they always hands up their work:</p>
<p class="Pp"></p>
<pre>    div bsqrt blog bexp bpi bsin bcos batan batan2
</pre>
<p class="Pp">All other methods upgrade themselves only when one (or all) of
    their arguments are of the class mentioned in
    <span class="Li">$upgrade</span>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTS"><a class="permalink" href="#EXPORTS">EXPORTS</a></h1>
<p class="Pp"><span class="Li">&quot;Math::BigInt&quot;</span> exports nothing
    by default, but can export the following methods:</p>
<p class="Pp"></p>
<pre>    bgcd
    blcm
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<p class="Pp">Some things might not work as you expect them. Below is documented
    what is known to be troublesome:</p>
<dl class="Bl-tag">
  <dt id="Comparing"><a class="permalink" href="#Comparing">Comparing numbers as
    strings</a></dt>
  <dd>Both <span class="Li">&quot;bstr()&quot;</span> and
      <span class="Li">&quot;bsstr()&quot;</span> as well as stringify via
      overload drop the leading '+'. This is to be consistent with Perl and to
      make <span class="Li">&quot;cmp&quot;</span> (especially with overloading)
      to work as you expect. It also solves problems with
      <span class="Li">&quot;Test.pm&quot;</span> and Test::More, which
      stringify arguments before comparing them.
    <p class="Pp">Mark Biggar said, when asked about to drop the '+' altogether,
        or make only <span class="Li">&quot;cmp&quot;</span> work:</p>
    <p class="Pp"></p>
    <pre>    I agree (with the first alternative), don't add the '+' on positive
    numbers.  It's not as important anymore with the new internal form
    for numbers.  It made doing things like abs and neg easier, but
    those have to be done differently now anyway.
    </pre>
    <p class="Pp">So, the following examples now works as expected:</p>
    <p class="Pp"></p>
    <pre>    use Test::More tests =&gt; 1;
    use Math::BigInt;
    my $x = Math::BigInt -&gt; new(3*3);
    my $y = Math::BigInt -&gt; new(3*3);
    is($x,3*3, 'multiplication');
    print &quot;$x eq 9&quot; if $x eq $y;
    print &quot;$x eq 9&quot; if $x eq '9';
    print &quot;$x eq 9&quot; if $x eq 3*3;
    </pre>
    <p class="Pp">Additionally, the following still works:</p>
    <p class="Pp"></p>
    <pre>    print &quot;$x == 9&quot; if $x == $y;
    print &quot;$x == 9&quot; if $x == 9;
    print &quot;$x == 9&quot; if $x == 3*3;
    </pre>
    <p class="Pp">There is now a <span class="Li">&quot;bsstr()&quot;</span>
        method to get the string in scientific notation aka
        <span class="Li">1e+2</span> instead of <span class="Li">100</span>. Be
        advised that overloaded 'eq' always uses <b>bstr()</b> for comparison,
        but Perl represents some numbers as 100 and others as 1e+308. If in
        doubt, convert both arguments to Math::BigInt before comparing them as
        strings:</p>
    <p class="Pp"></p>
    <pre>    use Test::More tests =&gt; 3;
    use Math::BigInt;
    $x = Math::BigInt-&gt;new('1e56'); $y = 1e56;
    is($x,$y);                     # fails
    is($x-&gt;bsstr(),$y);            # okay
    $y = Math::BigInt-&gt;new($y);
    is($x,$y);                     # okay
    </pre>
    <p class="Pp">Alternatively, simply use
        <span class="Li">&quot;&lt;=&gt;&quot;</span> for comparisons, this
        always gets it right. There is not yet a way to get a number
        automatically represented as a string that matches exactly the way Perl
        represents it.</p>
    <p class="Pp">See also the section about &quot;Infinity and Not a
        Number&quot; for problems in comparing NaNs.</p>
  </dd>
  <dt id="int()"><a class="permalink" href="#int()"><b>int()</b></a></dt>
  <dd><span class="Li">&quot;int()&quot;</span> returns (at least for Perl
      v5.7.1 and up) another Math::BigInt, not a Perl scalar:
    <p class="Pp"></p>
    <pre>    $x = Math::BigInt-&gt;new(123);
    $y = int($x);                           # 123 as a Math::BigInt
    $x = Math::BigFloat-&gt;new(123.45);
    $y = int($x);                           # 123 as a Math::BigFloat
    </pre>
    <p class="Pp">If you want a real Perl scalar, use
        <span class="Li">&quot;numify()&quot;</span>:</p>
    <p class="Pp"></p>
    <pre>    $y = $x-&gt;numify();                      # 123 as a scalar
    </pre>
    <p class="Pp">This is seldom necessary, though, because this is done
        automatically, like when you access an array:</p>
    <p class="Pp"></p>
    <pre>    $z = $array[$x];                        # does work automatically
    </pre>
  </dd>
  <dt id="Modifying"><a class="permalink" href="#Modifying">Modifying and
    =</a></dt>
  <dd>Beware of:
    <p class="Pp"></p>
    <pre>    $x = Math::BigFloat-&gt;new(5);
    $y = $x;
    </pre>
    <p class="Pp">This makes a second reference to the <b>same</b> object and
        stores it in <span class="Li">$y</span>. Thus anything that modifies
        <span class="Li">$x</span> (except overloaded operators) also modifies
        <span class="Li">$y</span>, and vice versa. Or in other words,
        <span class="Li">&quot;=&quot;</span> is only safe if you modify your
        Math::BigInt objects only via overloaded math. As soon as you use a
        method call it breaks:</p>
    <p class="Pp"></p>
    <pre>    $x-&gt;bmul(2);
    print &quot;$x, $y\n&quot;;       # prints '10, 10'
    </pre>
    <p class="Pp">If you want a true copy of <span class="Li">$x</span>,
      use:</p>
    <p class="Pp"></p>
    <pre>    $y = $x-&gt;copy();
    </pre>
    <p class="Pp">You can also chain the calls like this, this first makes a
        copy and then multiply it by 2:</p>
    <p class="Pp"></p>
    <pre>    $y = $x-&gt;copy()-&gt;bmul(2);
    </pre>
    <p class="Pp">See also the documentation for overload.pm regarding
        <span class="Li">&quot;=&quot;</span>.</p>
  </dd>
  <dt id="Overloading"><a class="permalink" href="#Overloading">Overloading
    -$x</a></dt>
  <dd>The following:
    <p class="Pp"></p>
    <pre>    $x = -$x;
    </pre>
    <p class="Pp">is slower than</p>
    <p class="Pp"></p>
    <pre>    $x-&gt;bneg();
    </pre>
    <p class="Pp">since overload calls
        <span class="Li">&quot;sub($x,0,1);&quot;</span> instead of
        <span class="Li">&quot;neg($x)&quot;</span>. The first variant needs to
        preserve <span class="Li">$x</span> since it does not know that it later
        gets overwritten. This makes a copy of <span class="Li">$x</span> and
        takes O(N), but <span class="Li">$x</span>-&gt;<b>bneg()</b> is
      O(1).</p>
  </dd>
  <dt id="Mixing"><a class="permalink" href="#Mixing">Mixing different object
    types</a></dt>
  <dd>With overloaded operators, it is the first (dominating) operand that
      determines which method is called. Here are some examples showing what
      actually gets called in various cases.
    <p class="Pp"></p>
    <pre>    use Math::BigInt;
    use Math::BigFloat;
    $mbf  = Math::BigFloat-&gt;new(5);
    $mbi2 = Math::BigInt-&gt;new(5);
    $mbi  = Math::BigInt-&gt;new(2);
                                    # what actually gets called:
    $float = $mbf + $mbi;           # $mbf-&gt;badd($mbi)
    $float = $mbf / $mbi;           # $mbf-&gt;bdiv($mbi)
    $integer = $mbi + $mbf;         # $mbi-&gt;badd($mbf)
    $integer = $mbi2 / $mbi;        # $mbi2-&gt;bdiv($mbi)
    $integer = $mbi2 / $mbf;        # $mbi2-&gt;bdiv($mbf)
    </pre>
    <p class="Pp">For instance, Math::BigInt-&gt;<b>bdiv()</b> always returns a
        Math::BigInt, regardless of whether the second operant is a
        Math::BigFloat. To get a Math::BigFloat you either need to call the
        operation manually, make sure each operand already is a Math::BigFloat,
        or cast to that type via Math::BigFloat-&gt;<b>new()</b>:</p>
    <p class="Pp"></p>
    <pre>    $float = Math::BigFloat-&gt;new($mbi2) / $mbi;     # = 2.5
    </pre>
    <p class="Pp">Beware of casting the entire expression, as this would cast
        the result, at which point it is too late:</p>
    <p class="Pp"></p>
    <pre>    $float = Math::BigFloat-&gt;new($mbi2 / $mbi);     # = 2
    </pre>
    <p class="Pp">Beware also of the order of more complicated expressions
      like:</p>
    <p class="Pp"></p>
    <pre>    $integer = ($mbi2 + $mbi) / $mbf;               # int / float =&gt; int
    $integer = $mbi2 / Math::BigFloat-&gt;new($mbi);   # ditto
    </pre>
    <p class="Pp">If in doubt, break the expression into simpler terms, or cast
        all operands to the desired resulting type.</p>
    <p class="Pp">Scalar values are a bit different, since:</p>
    <p class="Pp"></p>
    <pre>    $float = 2 + $mbf;
    $float = $mbf + 2;
    </pre>
    <p class="Pp">both result in the proper type due to the way the overloaded
        math works.</p>
    <p class="Pp">This section also applies to other overloaded math packages,
        like Math::String.</p>
    <p class="Pp">One solution to you problem might be autoupgrading|upgrading.
        See the pragmas bignum, bigint and bigrat for an easy way to do
      this.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">Please report any bugs or feature requests to
    <span class="Li">&quot;bug-math-bigint at rt.cpan.org&quot;</span>, or
    through the web interface at
    &lt;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt&gt; (requires
    login). We will be notified, and then you'll automatically be notified of
    progress on your bug as I make changes.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
<p class="Pp">You can find documentation for this module with the perldoc
    command.</p>
<p class="Pp"></p>
<pre>    perldoc Math::BigInt
</pre>
<p class="Pp">You can also look for information at:</p>
<ul class="Bl-bullet">
  <li>RT: CPAN's request tracker
    <p class="Pp">&lt;https://rt.cpan.org/Public/Dist/Display.html?Name=Math-BigInt&gt;</p>
  </li>
  <li>AnnoCPAN: Annotated CPAN documentation
    <p class="Pp">&lt;http://annocpan.org/dist/Math-BigInt&gt;</p>
  </li>
  <li>CPAN Ratings
    <p class="Pp">&lt;http://cpanratings.perl.org/dist/Math-BigInt&gt;</p>
  </li>
  <li>Search CPAN
    <p class="Pp">&lt;http://search.cpan.org/dist/Math-BigInt/&gt;</p>
  </li>
  <li>CPAN Testers Matrix
    <p class="Pp">&lt;http://matrix.cpantesters.org/?dist=Math-BigInt&gt;</p>
  </li>
  <li>The Bignum mailing list</li>
</ul>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>Post to mailing list
    <p class="Pp"><span class="Li">&quot;bignum at
        lists.scsys.co.uk&quot;</span></p>
  </li>
  <li>View mailing list
    <p class="Pp">&lt;http://lists.scsys.co.uk/pipermail/bignum/&gt;</p>
  </li>
  <li>Subscribe/Unsubscribe
    <p class="Pp">&lt;http://lists.scsys.co.uk/cgi-bin/mailman/listinfo/bignum&gt;</p>
  </li>
</ul>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">This program is free software; you may redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Math::BigFloat and Math::BigRat as well as the backends
    Math::BigInt::FastCalc, Math::BigInt::GMP, and Math::BigInt::Pari.</p>
<p class="Pp">The pragmas bignum, bigint and bigrat also might be of interest
    because they solve the autoupgrading/downgrading issue, at least partly.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Mark Biggar, overloaded interface by Ilya Zakharevich, 1996-2001.</li>
  <li>Completely rewritten by Tels &lt;http://bloodgate.com&gt;, 2001-2008.</li>
  <li>Florian Ragwitz &lt;flora@cpan.org&gt;, 2010.</li>
  <li>Peter John Acklam &lt;pjacklam@online.no&gt;, 2011-.</li>
</ul>
<p class="Pp">Many people contributed in one or more ways to the final beast,
    see the file CREDITS for an (incomplete) list. If you miss your name, please
    drop me a mail. Thank you!</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

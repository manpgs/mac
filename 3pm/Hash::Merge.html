<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Hash::Merge(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Hash::Merge(3)</td>
    <td class="head-vol"><a href=".">User Contributed Perl Documentation</a></td>
    <td class="head-rtitle">Hash::Merge(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Hash::Merge - Merges arbitrarily deep hashes into a single
  hash</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    my %a = (
        'foo'    =&gt; 1,
        'bar'    =&gt; [qw( a b e )],
        'querty' =&gt; { 'bob' =&gt; 'alice' },
    );
    my %b = (
        'foo'    =&gt; 2,
        'bar'    =&gt; [qw(c d)],
        'querty' =&gt; { 'ted' =&gt; 'margeret' },
    );
    
    my %c = %{ merge( \%a, \%b ) };
    
    Hash::Merge::set_behavior('RIGHT_PRECEDENT');
    
    # This is the same as above
    
    Hash::Merge::add_behavior_spec(
        {   'SCALAR' =&gt; {
                'SCALAR' =&gt; sub { $_[1] },
                'ARRAY'  =&gt; sub { [ $_[0], @{ $_[1] } ] },
                'HASH'   =&gt; sub { $_[1] },
            },
            'ARRAY' =&gt; {
                'SCALAR' =&gt; sub { $_[1] },
                'ARRAY'  =&gt; sub { [ @{ $_[0] }, @{ $_[1] } ] },
                'HASH'   =&gt; sub { $_[1] },
            },
            'HASH' =&gt; {
                'SCALAR' =&gt; sub { $_[1] },
                'ARRAY'  =&gt; sub { [ values %{ $_[0] }, @{ $_[1] } ] },
                'HASH'   =&gt; sub { Hash::Merge::_merge_hashes( $_[0], $_[1] ) },
            },
        },
        'My Behavior',
    );
    
    # Also there is OO interface.
    
    my $merger = Hash::Merge-&gt;new('LEFT_PRECEDENT');
    my %c = %{ $merger-&gt;merge( \%a, \%b ) };
    
    # All behavioral changes (e.g. $merge-&gt;set_behavior(...)), called on an object remain specific to that object
    # The legacy &quot;Global Setting&quot; behavior is respected only when new called as a non-OO function.
    # re-use globally specified behavior
    my $merger = Hash::Merge-&gt;new();
    $merger-&gt;add_behavior_spec(Hash::Merge::get_behavior_spec(&quot;My Behavior&quot;), &quot;My Behavior&quot;);
    my %c = %{ $merger-&gt;merge( \%a, \%b ) };
    # re-use externally specified behavior
    use Hash::Merge::Extra ();
    my $merger = Hash::Merge-&gt;new();
    $merger-&gt;add_behavior_spec(Hash::Merge::Extra::L_REPLACE, &quot;L_REPLACE&quot;);
    my %c = %{ $merger-&gt;merge( \%a, \%b ) };
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Hash::Merge merges two arbitrarily deep hashes into a single hash.
    That is, at any level, it will add non-conflicting key-value pairs from one
    hash to the other, and follows a set of specific rules when there are key
    value conflicts (as outlined below). The hash is followed recursively, so
    that deeply nested hashes that are at the same level will be merged when the
    parent hashes are merged. <b>Please note that self-referencing</b>
    <b>hashes, or recursive references, are not handled well by this
  method.</b></p>
<p class="Pp">Values in hashes are considered to be either ARRAY references,
    HASH references, or otherwise are treated as SCALARs. By default, the data
    passed to the merge function will be cloned using the Clone module; however,
    if necessary, this behavior can be changed to use as many of the original
    values as possible. (See
    <span class="Li">&quot;set_clone_behavior&quot;</span>).</p>
<p class="Pp">Because there are a number of possible ways that one may want to
    merge values when keys are conflicting, Hash::Merge provides several preset
    methods for your convenience, as well as a way to define you own. These are
    (currently):</p>
<dl class="Bl-tag">
  <dt id="Left"><a class="permalink" href="#Left">Left Precedence</a></dt>
  <dd>This is the default behavior.
    <p class="Pp">The values buried in the left hash will never be lost; any
        values that can be added from the right hash will be attempted.</p>
    <p class="Pp"></p>
    <pre>    my $merge = Hash::Merge-&gt;new();
    my $merge = Hash::Merge-&gt;new('LEFT_PRECEDENT');
    $merge-&gt;set_behavior('LEFT_PRECEDENT');
    Hash::Merge::set_behavior('LEFT_PRECEDENT');
    </pre>
  </dd>
  <dt id="Right"><a class="permalink" href="#Right">Right Precedence</a></dt>
  <dd>Same as Left Precedence, but with the right hash values never being lost
    <p class="Pp"></p>
    <pre>    my $merge = Hash::Merge-&gt;new('RIGHT_PRECEDENT');
    $merge-&gt;set_behavior('RIGHT_PRECEDENT');
    Hash::Merge::set_behavior('RIGHT_PRECEDENT');
    </pre>
  </dd>
  <dt id="Storage"><a class="permalink" href="#Storage">Storage
    Precedence</a></dt>
  <dd>If conflicting keys have two different storage mediums, the 'bigger'
      medium will win; arrays are preferred over scalars, hashes over either.
      The other medium will try to be fitted in the other, but if this isn't
      possible, the data is dropped.
    <p class="Pp"></p>
    <pre>    my $merge = Hash::Merge-&gt;new('STORAGE_PRECEDENT');
    $merge-&gt;set_behavior('STORAGE_PRECEDENT');
    Hash::Merge::set_behavior('STORAGE_PRECEDENT');
    </pre>
  </dd>
  <dt id="Retainment"><a class="permalink" href="#Retainment">Retainment
    Precedence</a></dt>
  <dd>No data will be lost; scalars will be joined with arrays, and scalars and
      arrays will be 'hashified' to fit them into a hash.
    <p class="Pp"></p>
    <pre>    my $merge = Hash::Merge-&gt;new('RETAINMENT_PRECEDENT');
    $merge-&gt;set_behavior('RETAINMENT_PRECEDENT');
    Hash::Merge::set_behavior('RETAINMENT_PRECEDENT');
    </pre>
  </dd>
</dl>
<p class="Pp">Specific descriptions of how these work are detailed below.</p>
<dl class="Bl-tag">
  <dt id="merge"><a class="permalink" href="#merge">merge ( &lt;hashref&gt;,
    &lt;hashref&gt; )</a></dt>
  <dd>Merges two hashes given the rules specified. Returns a reference to the
      new hash.</dd>
  <dt>_hashify( &lt;scalar&gt;|&lt;arrayref&gt; ) -- INTERNAL FUNCTION</dt>
  <dd>Returns a reference to a hash created from the scalar or array reference,
      where, for the scalar value, or each item in the array, there is a key and
      it's value equal to that specific value. Example, if you pass scalar '3',
      the hash will be { 3 =&gt; 3 }.</dd>
  <dt>_merge_hashes( &lt;hashref&gt;, &lt;hashref&gt; ) -- INTERNAL
    FUNCTION</dt>
  <dd>Actually does the key-by-key evaluation of two hashes and returns the new
      merged hash. Note that this recursively calls
      <span class="Li">&quot;merge&quot;</span>.</dd>
  <dt id="set_clone_behavior("><a class="permalink" href="#set_clone_behavior(">set_clone_behavior(
    &lt;scalar&gt; )</a></dt>
  <dd>Sets how the data cloning is handled by Hash::Merge. If this is true, then
      data will be cloned; if false, then original data will be used whenever
      possible. By default, cloning is on (set to true).</dd>
  <dt id="get_clone_behavior("><a class="permalink" href="#get_clone_behavior(">get_clone_behavior(
    )</a></dt>
  <dd>Returns the current behavior for data cloning.</dd>
  <dt id="set_behavior("><a class="permalink" href="#set_behavior(">set_behavior(
    &lt;scalar&gt; )</a></dt>
  <dd>Specify which built-in behavior for merging that is desired. The scalar
      must be one of those given below.</dd>
  <dt id="get_behavior("><a class="permalink" href="#get_behavior(">get_behavior(
    )</a></dt>
  <dd>Returns the behavior that is currently in use by Hash::Merge.</dd>
  <dt id="specify_behavior("><a class="permalink" href="#specify_behavior(">specify_behavior(
    &lt;hashref&gt;, [&lt;name&gt;] ) [deprecated]</a></dt>
  <dd>Alias for <span class="Li">&quot;add_behavior_spec&quot;</span>.</dd>
  <dt id="add_behavior_spec("><a class="permalink" href="#add_behavior_spec(">add_behavior_spec(
    &lt;hashref&gt;, [&lt;name&gt;] )</a></dt>
  <dd>Add a custom merge behavior spec for Hash::Merge. This must be a hashref
      defined with (at least) 3 keys, SCALAR, ARRAY, and HASH; each of those
      keys must have another hashref with (at least) the same 3 keys defined.
      Furthermore, the values in those hashes must be coderefs. These will be
      called with two arguments, the left and right values for the merge. Your
      coderef should return either a scalar or an array or hash reference as per
      your planned behavior. If necessary, use the functions _hashify and
      _merge_hashes as helper functions for these. For example, if you want to
      add the left SCALAR to the right ARRAY, you can have your behavior
      specification include:
    <p class="Pp"></p>
    <pre>    %spec = ( ...SCALAR =&gt; { ARRAY =&gt; sub { [ $_[0], @$_[1] ] }, ... } } );
    </pre>
    <p class="Pp">Note that you can import _hashify and _merge_hashes into your
        program's namespace with the 'custom' tag.</p>
  </dd>
  <dt id="get_behavior_spec("><a class="permalink" href="#get_behavior_spec(">get_behavior_spec(
    [&lt;name&gt;] )</a></dt>
  <dd>Return a previously defined merge behavior spec. If name ism't specified,
      the same default as add_behavior_spec is applied.
    <p class="Pp">If no such name is known referring to an behavior spec,
        nothing is returned.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="BUILT-IN_BEHAVIORS"><a class="permalink" href="#BUILT-IN_BEHAVIORS">BUILT-IN
  BEHAVIORS</a></h1>
<p class="Pp">Here is the specifics on how the current internal behaviors are
    called, and what each does. Assume that the left value is given as
    <span class="Li">$a</span>, and the right as <span class="Li">$b</span>
    (these are either scalars or appropriate references)</p>
<p class="Pp"></p>
<pre>    LEFT TYPE    RIGHT TYPE    LEFT_PRECEDENT       RIGHT_PRECEDENT
     SCALAR       SCALAR        $a                   $b
     SCALAR       ARRAY         $a                   ( $a, @$b )
     SCALAR       HASH          $a                   %$b
     ARRAY        SCALAR        ( @$a, $b )          $b
     ARRAY        ARRAY         ( @$a, @$b )         ( @$a, @$b )
     ARRAY        HASH          ( @$a, values %$b )  %$b 
     HASH         SCALAR        %$a                  $b
     HASH         ARRAY         %$a                  ( values %$a, @$b )
     HASH         HASH          merge( %$a, %$b )    merge( %$a, %$b )
    LEFT TYPE    RIGHT TYPE    STORAGE_PRECEDENT    RETAINMENT_PRECEDENT
     SCALAR       SCALAR        $a                   ( $a ,$b )
     SCALAR       ARRAY         ( $a, @$b )          ( $a, @$b )
     SCALAR       HASH          %$b                  merge( hashify( $a ), %$b )
     ARRAY        SCALAR        ( @$a, $b )          ( @$a, $b )
     ARRAY        ARRAY         ( @$a, @$b )         ( @$a, @$b )
     ARRAY        HASH          %$b                  merge( hashify( @$a ), %$b )
     HASH         SCALAR        %$a                  merge( %$a, hashify( $b ) )
     HASH         ARRAY         %$a                  merge( %$a, hashify( @$b ) )
     HASH         HASH          merge( %$a, %$b )    merge( %$a, %$b )
</pre>
<p class="Pp">(*) note that merge calls _merge_hashes, hashify calls
  _hashify.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Michael K. Neylon &lt;mneylon-pm@masemware.com&gt;, Daniel Muey
    &lt;dmuey@cpan.org&gt;, Jens Rehsack &lt;rehsack@cpan.org&gt;, Stefan Hermes
    &lt;hermes@cpan.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 2001,2002 Michael K. Neylon. All rights reserved.
    Copyright (c) 2013-2017 Jens Rehsack. All rights reserved. Copyright (c)
    2017 Stefan Hermes. All rights reserved.</p>
<p class="Pp">This library is free software. You can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-03-09</td>
    <td class="foot-os"><a href="..">perl v5.34.0</a></td>
  </tr>
</table>
</body>
</html>

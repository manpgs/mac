<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Moose::Manual::BestPractices(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Moose::Manual::BestPractices(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Moose::Manual::BestPractices(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Moose::Manual::BestPractices - Get the most out of Moose</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 2.1202</p>
</section>
<section class="Sh">
<h1 class="Sh" id="RECOMMENDATIONS"><a class="permalink" href="#RECOMMENDATIONS">RECOMMENDATIONS</a></h1>
<p class="Pp">Moose has a lot of features, and there's definitely more than one
    way to do it. However, we think that picking a subset of these features and
    using them consistently makes everyone's life easier.</p>
<p class="Pp">Of course, as with any list of &quot;best practices&quot;, these
    are really just opinions. Feel free to ignore us.</p>
<section class="Ss">
<h2 class="Ss" id="_namespace::autoclean__and_immutabilize"><a class="permalink" href="#_namespace::autoclean__and_immutabilize">&quot;namespace::autoclean&quot;
  and immutabilize</a></h2>
<p class="Pp">We recommend that you remove the Moose sugar and end your Moose
    class definitions by making your class immutable.</p>
<p class="Pp"></p>
<pre>
  package Person;

  use Moose;
  use namespace::autoclean;

  # extends, roles, attributes, etc.

  # methods

  __PACKAGE__-&gt;meta-&gt;make_immutable;

  1;
</pre>
<p class="Pp">The <span class="Li">&quot;use namespace::autoclean&quot;</span>
    bit is simply good code hygiene, as it removes imported symbols from your
    class's namespace at the end of your package's compile cycle, including
    Moose keywords. Once the class has been built, these keywords are not
    needed. (This is preferred to placing <span class="Li">&quot;no
    Moose&quot;</span> at the end of your package).</p>
<p class="Pp">The <span class="Li">&quot;make_immutable&quot;</span> call allows
    Moose to speed up a lot of things, most notably object construction. The
    trade-off is that you can no longer change the class definition.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Never_override__new_"><a class="permalink" href="#Never_override__new_">Never
  override &quot;new&quot;</a></h2>
<p class="Pp">Overriding <span class="Li">&quot;new&quot;</span> is a very bad
    practice. Instead, you should use a
    <span class="Li">&quot;BUILD&quot;</span> or
    <span class="Li">&quot;BUILDARGS&quot;</span> methods to do the same thing.
    When you override <span class="Li">&quot;new&quot;</span>, Moose can no
    longer inline a constructor when your class is immutabilized.</p>
<p class="Pp">There are two good reasons to override
    <span class="Li">&quot;new&quot;</span>. One, you are writing a MooseX
    extension that provides its own Moose::Object subclass <i>and</i> a subclass
    of Moose::Meta::Method::Constructor to inline the constructor. Two, you are
    subclassing a non-Moose parent.</p>
<p class="Pp">If you know how to do that, you know when to ignore this best
    practice ;)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Always_call_the_original/parent__BUILDARGS_"><a class="permalink" href="#Always_call_the_original/parent__BUILDARGS_">Always
  call the original/parent &quot;BUILDARGS&quot;</a></h2>
<p class="Pp">If you <span class="Li">&quot;override&quot;</span> the
    <span class="Li">&quot;BUILDARGS&quot;</span> method in your class, make
    sure to play nice and call <span class="Li">&quot;super()&quot;</span> to
    handle cases you're not checking for explicitly.</p>
<p class="Pp">The default <span class="Li">&quot;BUILDARGS&quot;</span> method
    in Moose::Object handles both a list and hashref of named parameters
    correctly, and also checks for a <i>non-hashref</i> single argument.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Provide_defaults_whenever_possible,_otherwise_use__required_"><a class="permalink" href="#Provide_defaults_whenever_possible,_otherwise_use__required_">Provide
  defaults whenever possible, otherwise use &quot;required&quot;</a></h2>
<p class="Pp">When your class provides defaults, this makes constructing new
    objects simpler. If you cannot provide a default, consider making the
    attribute <span class="Li">&quot;required&quot;</span>.</p>
<p class="Pp">If you don't do either, an attribute can simply be left unset,
    increasing the complexity of your object, because it has more possible
    states that you or the user of your class must account for.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Use__builder__instead_of__default__most_of_the_time"><a class="permalink" href="#Use__builder__instead_of__default__most_of_the_time">Use
  &quot;builder&quot; instead of &quot;default&quot; most of the time</a></h2>
<p class="Pp">Builders can be inherited, they have explicit names, and they're
    just plain cleaner.</p>
<p class="Pp">However, <i>do</i> use a default when the default is a
    non-reference, <i>or</i> when the default is simply an empty reference of
    some sort.</p>
<p class="Pp">Also, keep your builder methods private.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Be__lazy_"><a class="permalink" href="#Be__lazy_">Be
  &quot;lazy&quot;</a></h2>
<p class="Pp">Lazy is good, and often solves initialization ordering problems.
    It's also good for deferring work that may never have to be done. Make your
    attributes <span class="Li">&quot;lazy&quot;</span> unless they're
    <span class="Li">&quot;required&quot;</span> or have trivial defaults.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Consider_keeping_clearers_and_predicates_private"><a class="permalink" href="#Consider_keeping_clearers_and_predicates_private">Consider
  keeping clearers and predicates private</a></h2>
<p class="Pp">Does everyone <i>really</i> need to be able to clear an attribute?
    Probably not. Don't expose this functionality outside your class by
  default.</p>
<p class="Pp">Predicates are less problematic, but there's no reason to make
    your public API bigger than it has to be.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Avoid__lazy_build_"><a class="permalink" href="#Avoid__lazy_build_">Avoid
  &quot;lazy_build&quot;</a></h2>
<p class="Pp">As described above, you rarely actually need a clearer or a
    predicate. <span class="Li">&quot;lazy_build&quot;</span> adds both to your
    public API, which exposes you to use cases that you must now test for. It's
    much better to avoid adding them until you really need them - use explicit
    <span class="Li">&quot;lazy&quot;</span> and
    <span class="Li">&quot;builder&quot;</span> options instead.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Default_to_read-only,_and_consider_keeping_writers_private"><a class="permalink" href="#Default_to_read-only,_and_consider_keeping_writers_private">Default
  to read-only, and consider keeping writers private</a></h2>
<p class="Pp">Making attributes mutable just means more complexity to account
    for in your program. The alternative to mutable state is to encourage users
    of your class to simply make new objects as needed.</p>
<p class="Pp">If you <i>must</i> make an attribute read-write, consider making
    the writer a separate private method. Narrower APIs are easy to maintain,
    and mutable state is trouble.</p>
<p class="Pp">In order to declare such attributes, provide a private
    <span class="Li">&quot;writer&quot;</span> parameter:</p>
<p class="Pp"></p>
<pre>
    has pizza =&gt; (
        is     =&gt; 'ro',
        isa    =&gt; 'Pizza',
        writer =&gt; '_pizza',
    );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Think_twice_before_changing_an_attribute's_type_in_a_subclass"><a class="permalink" href="#Think_twice_before_changing_an_attribute's_type_in_a_subclass">Think
  twice before changing an attribute's type in a subclass</a></h2>
<p class="Pp">Down this path lies great confusion. If the attribute is an object
    itself, at least make sure that it has the same interface as the type of
    object in the parent class.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Don't_use_the__initializer__feature"><a class="permalink" href="#Don't_use_the__initializer__feature">Don't
  use the &quot;initializer&quot; feature</a></h2>
<p class="Pp">Don't know what we're talking about? That's fine.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Use_Moose::Meta::Attribute::Native_traits_instead_of__auto_deref_"><a class="permalink" href="#Use_Moose::Meta::Attribute::Native_traits_instead_of__auto_deref_">Use
  Moose::Meta::Attribute::Native traits instead of
  &quot;auto_deref&quot;</a></h2>
<p class="Pp">The <span class="Li">&quot;auto_deref&quot;</span> feature is a
    bit troublesome. Directly exposing a complex attribute is ugly. Instead,
    consider using Moose::Meta::Attribute::Native traits to define an API that
    only exposes the necessary pieces of functionality.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Always_call__inner__in_the_most_specific_subclass"><a class="permalink" href="#Always_call__inner__in_the_most_specific_subclass">Always
  call &quot;inner&quot; in the most specific subclass</a></h2>
<p class="Pp">When using <span class="Li">&quot;augment&quot;</span> and
    <span class="Li">&quot;inner&quot;</span>, we recommend that you call
    <span class="Li">&quot;inner&quot;</span> in the most specific subclass of
    your hierarchy. This makes it possible to subclass further and extend the
    hierarchy without changing the parents.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Namespace_your_types"><a class="permalink" href="#Namespace_your_types">Namespace
  your types</a></h2>
<p class="Pp">Use some sort of namespacing convention for type names. We
    recommend something like &quot;MyApp::Type::Foo&quot;. We also recommend
    considering MooseX::Types.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Do_not_coerce_Moose_built-ins_directly"><a class="permalink" href="#Do_not_coerce_Moose_built-ins_directly">Do
  not coerce Moose built-ins directly</a></h2>
<p class="Pp">If you define a coercion for a Moose built-in like
    <span class="Li">&quot;ArrayRef&quot;</span>, this will affect every
    application in the Perl interpreter that uses this type.</p>
<p class="Pp"></p>
<pre>
    # very naughty!
    coerce 'ArrayRef'
        =&gt; from Str
        =&gt; via { [ split /,/ ] };
</pre>
<p class="Pp">Instead, create a subtype and coerce that:</p>
<p class="Pp"></p>
<pre>
    subtype 'My::ArrayRef' =&gt; as 'ArrayRef';

    coerce 'My::ArrayRef'
        =&gt; from 'Str'
        =&gt; via { [ split /,/ ] };
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Do_not_coerce_class_names_directly"><a class="permalink" href="#Do_not_coerce_class_names_directly">Do
  not coerce class names directly</a></h2>
<p class="Pp">Just as with Moose built-in types, a class type is global for the
    entire interpreter. If you add a coercion for that class name, it can have
    magical side effects elsewhere:</p>
<p class="Pp"></p>
<pre>
    # also very naughty!
    coerce 'HTTP::Headers'
        =&gt; from 'HashRef'
        =&gt; via { HTTP::Headers-&gt;new( %{$_} ) };
</pre>
<p class="Pp">Instead, we can create an &quot;empty&quot; subtype for the
    coercion:</p>
<p class="Pp"></p>
<pre>
    subtype 'My::HTTP::Headers' =&gt; as class_type('HTTP::Headers');

    coerce 'My::HTTP::Headers'
        =&gt; from 'HashRef'
        =&gt; via { HTTP::Headers-&gt;new( %{$_} ) };
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Use_coercion_instead_of_unions"><a class="permalink" href="#Use_coercion_instead_of_unions">Use
  coercion instead of unions</a></h2>
<p class="Pp">Consider using a type coercion instead of a type union. This was
    covered in Moose::Manual::Types.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Define_all_your_types_in_one_module"><a class="permalink" href="#Define_all_your_types_in_one_module">Define
  all your types in one module</a></h2>
<p class="Pp">Define all your types and coercions in one module. This was also
    covered in Moose::Manual::Types.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BENEFITS_OF_BEST_PRACTICES"><a class="permalink" href="#BENEFITS_OF_BEST_PRACTICES">BENEFITS
  OF BEST PRACTICES</a></h1>
<p class="Pp">Following these practices has a number of benefits.</p>
<p class="Pp">It helps ensure that your code will play nice with others, making
    it more reusable and easier to extend.</p>
<p class="Pp">Following an accepted set of idioms will make maintenance easier,
    especially when someone else has to maintain your code. It will also make it
    easier to get support from other Moose users, since your code will be easier
    to digest quickly.</p>
<p class="Pp">Some of these practices are designed to help Moose do the right
    thing, especially when it comes to immutabilization. This means your code
    will be faster when immutabilized.</p>
<p class="Pp">Many of these practices also help get the most out of meta
    programming. If you used an overridden
    <span class="Li">&quot;new&quot;</span> to do type coercion by hand, rather
    than defining a real coercion, there is no introspectable metadata. This
    sort of thing is particularly problematic for MooseX extensions which rely
    on introspection to do the right thing.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Stevan Little &lt;stevan.little@iinteractive.com&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
  <li>Shawn M Moore &lt;code@sartak.org&gt;</li>
  <li>XXXX XXX'XX (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Florian Ragwitz &lt;rafl@debian.org&gt;</li>
  <li>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</li>
  <li>Chris Prather &lt;chris@prather.org&gt;</li>
  <li>Matt S Trout &lt;mst@shadowcat.co.uk&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2006 by Infinity Interactive,
  Inc..</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-19</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Sub::Exporter::Tutorial(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Sub::Exporter::Tutorial(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Sub::Exporter::Tutorial(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Sub::Exporter::Tutorial - a friendly guide to exporting with
    Sub::Exporter</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 0.987</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<section class="Ss">
<h2 class="Ss" id="What's_an_Exporter?"><a class="permalink" href="#What's_an_Exporter?">What's
  an Exporter?</a></h2>
<p class="Pp">When you <span class="Li">&quot;use&quot;</span> a module, first
    it is required, then its <span class="Li">&quot;import&quot;</span> method
    is called. The Perl documentation tells us that the following two lines are
    equivalent:</p>
<p class="Pp"></p>
<pre>  use Module LIST;
  BEGIN { require Module; Module-&gt;import(LIST); }
</pre>
<p class="Pp">The method named <span class="Li">&quot;import&quot;</span> is the
    module's <i>exporter</i>, it exports functions and variables into its
    caller's namespace.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Basics_of_Sub::Exporter"><a class="permalink" href="#The_Basics_of_Sub::Exporter">The
  Basics of Sub::Exporter</a></h2>
<p class="Pp">Sub::Exporter builds a custom exporter which can then be installed
    into your module. It builds this method based on configuration passed to its
    <span class="Li">&quot;setup_exporter&quot;</span> method.</p>
<p class="Pp">A very basic use case might look like this:</p>
<p class="Pp"></p>
<pre>  package Addition;
  use Sub::Exporter;
  Sub::Exporter::setup_exporter({ exports =&gt; [ qw(plus) ]});
  sub plus { my ($x, $y) = @_; return $x + $y; }
</pre>
<p class="Pp">This would mean that when someone used your Addition module, they
    could have its <span class="Li">&quot;plus&quot;</span> routine imported
    into their package:</p>
<p class="Pp"></p>
<pre>  use Addition qw(plus);
  my $z = plus(2, 2); # this works, because now plus is in the main package
</pre>
<p class="Pp">That syntax to set up the exporter, above, is a little verbose, so
    for the simple case of just naming some exports, you can write this:</p>
<p class="Pp"></p>
<pre>  use Sub::Exporter -setup =&gt; { exports =&gt; [ qw(plus) ] };
</pre>
<p class="Pp">...which is the same as the original example -- except that now
    the exporter is built and installed at compile time. Well, that and you
    typed less.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_Export_Groups"><a class="permalink" href="#Using_Export_Groups">Using
  Export Groups</a></h2>
<p class="Pp">You can specify whole groups of things that should be exportable
    together. These are called groups. Exporter calls these tags. To specify
    groups, you just pass a <span class="Li">&quot;groups&quot;</span> key in
    your exporter configuration:</p>
<p class="Pp"></p>
<pre>  package Food;
  use Sub::Exporter -setup =&gt; {
    exports =&gt; [ qw(apple banana beef fluff lox rabbit) ],
    groups  =&gt; {
      fauna  =&gt; [ qw(beef lox rabbit) ],
      flora  =&gt; [ qw(apple banana) ],
    }
  };
</pre>
<p class="Pp">Now, to import all that delicious foreign meat, your consumer
    needs only to write:</p>
<p class="Pp"></p>
<pre>  use Food qw(:fauna);
  use Food qw(-fauna);
</pre>
<p class="Pp">Either one of the above is acceptable. A colon is more
    traditional, but barewords with a leading colon can't be enquoted by a fat
    arrow. We'll see why that matters later on.</p>
<p class="Pp">Groups can contain other groups. If you include a group name (with
    the leading dash or colon) in a group definition, it will be expanded
    recursively when the exporter is called. The exporter will <b>not</b>
    recurse into the same group twice while expanding groups.</p>
<p class="Pp">There are two special groups:
    <span class="Li">&quot;all&quot;</span> and
    <span class="Li">&quot;default&quot;</span>. The
    <span class="Li">&quot;all&quot;</span> group is defined for you and
    contains all exportable subs. You can redefine it, if you want to export
    only a subset when all exports are requested. The
    <span class="Li">&quot;default&quot;</span> group is the set of routines to
    export when nothing specific is requested. By default, there is no
    <span class="Li">&quot;default&quot;</span> group.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Renaming_Your_Imports"><a class="permalink" href="#Renaming_Your_Imports">Renaming
  Your Imports</a></h2>
<p class="Pp">Sometimes you want to import something, but you don't like the
    name as which it's imported. Sub::Exporter can rename your imports for you.
    If you wanted to import <span class="Li">&quot;lox&quot;</span> from the
    Food package, but you don't like the name, you could write this:</p>
<p class="Pp"></p>
<pre>  use Food lox =&gt; { -as =&gt; 'salmon' };
</pre>
<p class="Pp">Now you'd get the <span class="Li">&quot;lox&quot;</span> routine,
    but it would be called salmon in your package. You can also rename entire
    groups by using the <span class="Li">&quot;prefix&quot;</span> option:</p>
<p class="Pp"></p>
<pre>  use Food -fauna =&gt; { -prefix =&gt; 'cute_little_' };
</pre>
<p class="Pp">Now you can call your
    <span class="Li">&quot;cute_little_rabbit&quot;</span> routine. (You can
    also call <span class="Li">&quot;cute_little_beef&quot;</span>, but that
    hardly seems as enticing.)</p>
<p class="Pp">When you define groups, you can include renaming.</p>
<p class="Pp"></p>
<pre>  use Sub::Exporter -setup =&gt; {
    exports =&gt; [ qw(apple banana beef fluff lox rabbit) ],
    groups  =&gt; {
      fauna  =&gt; [ qw(beef lox), rabbit =&gt; { -as =&gt; 'coney' } ],
    }
  };
</pre>
<p class="Pp">A prefix on a group like that does the right thing. This is when
    it's useful to use a dash instead of a colon to indicate a group: you can
    put a fat arrow between the group and its arguments, then.</p>
<p class="Pp"></p>
<pre>  use Food -fauna =&gt; { -prefix =&gt; 'lovely_' };
  eat( lovely_coney ); # this works
</pre>
<p class="Pp">Prefixes also apply recursively. That means that this code
  works:</p>
<p class="Pp"></p>
<pre>  use Sub::Exporter -setup =&gt; {
    exports =&gt; [ qw(apple banana beef fluff lox rabbit) ],
    groups  =&gt; {
      fauna   =&gt; [ qw(beef lox), rabbit =&gt; { -as =&gt; 'coney' } ],
      allowed =&gt; [ -fauna =&gt; { -prefix =&gt; 'willing_' }, 'banana' ],
    }
  };
  ...
  use Food -allowed =&gt; { -prefix =&gt; 'any_' };
  $dinner = any_willing_coney; # yum!
</pre>
<p class="Pp">Groups can also be passed a
    <span class="Li">&quot;-suffix&quot;</span> argument.</p>
<p class="Pp">Finally, if the <span class="Li">&quot;-as&quot;</span> argument
    to an exported routine is a reference to a scalar, a reference to the
    routine will be placed in that scalar.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Building_Subroutines_to_Order"><a class="permalink" href="#Building_Subroutines_to_Order">Building
  Subroutines to Order</a></h2>
<p class="Pp">Sometimes, you want to export things that you don't have on hand.
    You might want to offer customized routines built to the specification of
    your consumer; that's just good business! With Sub::Exporter, this is
  easy.</p>
<p class="Pp">To offer subroutines to order, you need to provide a generator
    when you set up your exporter. A generator is just a routine that returns a
    new routine. perlref is talking about these when it discusses closures and
    function templates. The canonical example of a generator builds a unique
    incrementor; here's how you'd do that with Sub::Exporter;</p>
<p class="Pp"></p>
<pre>  package Package::Counter;
  use Sub::Exporter -setup =&gt; {
    exports =&gt; [ counter =&gt; sub { my $i = 0; sub { $i++ } } ],
    groups  =&gt; { default =&gt; [ qw(counter) ] },
  };
</pre>
<p class="Pp">Now anyone can use your Package::Counter module and he'll receive
    a <span class="Li">&quot;counter&quot;</span> in his package. It will count
    up by one, and will never interfere with anyone else's counter.</p>
<p class="Pp">This isn't very useful, though, unless the consumer can explain
    what he wants. This is done, in part, by supplying arguments when importing.
    The following example shows how a generator can take and use arguments:</p>
<p class="Pp"></p>
<pre>  package Package::Counter;
  sub _build_counter {
    my ($class, $name, $arg) = @_;
    $arg ||= {};
    my $i = $arg-&gt;{start} || 0;
    return sub { $i++ };
  }
  use Sub::Exporter -setup =&gt; {
    exports =&gt; [ counter =&gt; \'_build_counter' ],
    groups  =&gt; { default =&gt; [ qw(counter) ] },
  };
</pre>
<p class="Pp">Now, the consumer can (if he wants) specify a starting value for
    his counter:</p>
<p class="Pp"></p>
<pre>  use Package::Counter counter =&gt; { start =&gt; 10 };
</pre>
<p class="Pp">Arguments to a group are passed along to the generators of
    routines in that group, but Sub::Exporter arguments -- anything beginning
    with a dash -- are never passed in. When groups are nested, the arguments
    are merged as the groups are expanded.</p>
<p class="Pp">Notice, too, that in the example above, we gave a reference to a
    method <i>name</i> rather than a method <i>implementation</i>. By giving the
    name rather than the subroutine, we make it possible for subclasses of our
    &quot;Package::Counter&quot; module to replace the
    <span class="Li">&quot;_build_counter&quot;</span> method.</p>
<p class="Pp">When a generator is called, it is passed four parameters:</p>
<ul class="Bl-bullet">
  <li>the invocant on which the exporter was called</li>
  <li>the name of the export being generated (not the name it's being installed
      as)</li>
  <li>the arguments supplied for the routine</li>
  <li>the collection of generic arguments</li>
</ul>
<p class="Pp">The fourth item is the last major feature that hasn't been
    covered.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Argument_Collectors"><a class="permalink" href="#Argument_Collectors">Argument
  Collectors</a></h2>
<p class="Pp">Sometimes you will want to accept arguments once that can then be
    available to any subroutine that you're going to export. To do this, you
    specify collectors, like this:</p>
<p class="Pp"></p>
<pre>  package Menu::Airline
  use Sub::Exporter -setup =&gt; {
    exports =&gt;  ... ,
    groups  =&gt;  ... ,
    collectors =&gt; [ qw(allergies ethics) ],
  };
</pre>
<p class="Pp">Collectors look like normal exports in the import call, but they
    don't do anything but collect data which can later be passed to generators.
    If the module was used like this:</p>
<p class="Pp"></p>
<pre>  use Menu::Airline allergies =&gt; [ qw(peanuts) ], ethics =&gt; [ qw(vegan) ];
</pre>
<p class="Pp">...the consumer would get a salad. Also, all the generators would
    be passed, as their fourth argument, something like this:</p>
<p class="Pp"></p>
<pre>  { allerges =&gt; [ qw(peanuts) ], ethics =&gt; [ qw(vegan) ] }
</pre>
<p class="Pp">Generators may have arguments in their definition, as well. These
    must be code refs that perform validation of the collected values. They are
    passed the collection value and may return true or false. If they return
    false, the exporter will throw an exception.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Generating_Many_Routines_in_One_Scope"><a class="permalink" href="#Generating_Many_Routines_in_One_Scope">Generating
  Many Routines in One Scope</a></h2>
<p class="Pp">Sometimes it's useful to have multiple routines generated in one
    scope. This way they can share lexical data which is otherwise unavailable.
    To do this, you can supply a generator for a group which returns a hashref
    of names and code references. This generator is passed all the usual data,
    and the group may receive the usual
    <span class="Li">&quot;-prefix&quot;</span> or
    <span class="Li">&quot;-suffix&quot;</span> arguments.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>Sub::Exporter for complete documentation and references to other
    exporters</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Ricardo Signes &lt;rjbs@cpan.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2007 by Ricardo Signes.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-10-18</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

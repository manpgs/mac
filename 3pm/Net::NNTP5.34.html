<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Net::NNTP(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Net::NNTP(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Net::NNTP(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Net::NNTP - NNTP Client class</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use Net::NNTP;
    $nntp = Net::NNTP-&gt;new(&quot;some.host.name&quot;);
    $nntp-&gt;quit;
    # start with SSL, e.g. nntps
    $nntp = Net::NNTP-&gt;new(&quot;some.host.name&quot;, SSL =&gt; 1);
    # start with plain and upgrade to SSL
    $nntp = Net::NNTP-&gt;new(&quot;some.host.name&quot;);
    $nntp-&gt;starttls;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><span class="Li">&quot;Net::NNTP&quot;</span> is a class
    implementing a simple NNTP client in Perl as described in RFC977 and
    RFC4642. With IO::Socket::SSL installed it also provides support for
    implicit and explicit TLS encryption, i.e. NNTPS or NNTP+STARTTLS.</p>
<p class="Pp">The Net::NNTP class is a subclass of Net::Cmd and (depending on
    avaibility) of IO::Socket::IP, IO::Socket::INET6 or IO::Socket::INET.</p>
<section class="Ss">
<h2 class="Ss" id="Class_Methods"><a class="permalink" href="#Class_Methods">Class
  Methods</a></h2>
<dl class="Bl-tag">
  <dt>&quot;new([$host][, %options])&quot;</dt>
  <dd>This is the constructor for a new Net::NNTP object.
      <span class="Li">$host</span> is the name of the remote host to which a
      NNTP connection is required. If not given then it may be passed as the
      <span class="Li">&quot;Host&quot;</span> option described below. If no
      host is passed then two environment variables are checked, first
      <span class="Li">&quot;NNTPSERVER&quot;</span> then
      <span class="Li">&quot;NEWSHOST&quot;</span>, then
      <span class="Li">&quot;Net::Config&quot;</span> is checked, and if a host
      is not found then <span class="Li">&quot;news&quot;</span> is used.
    <p class="Pp"><span class="Li">%options</span> are passed in a hash like
        fashion, using key and value pairs. Possible options are:</p>
    <p class="Pp"><b>Host</b> - NNTP host to connect to. It may be a single
        scalar, as defined for the <span class="Li">&quot;PeerAddr&quot;</span>
        option in IO::Socket::INET, or a reference to an array with hosts to try
        in turn. The &quot;host&quot; method will return the value which was
        used to connect to the host.</p>
    <p class="Pp"><b>Port</b> - port to connect to. Default - 119 for plain NNTP
        and 563 for immediate SSL (nntps).</p>
    <p class="Pp"><b>SSL</b> - If the connection should be done from start with
        SSL, contrary to later upgrade with
        <span class="Li">&quot;starttls&quot;</span>. You can use SSL arguments
        as documented in IO::Socket::SSL, but it will usually use the right
        arguments already.</p>
    <p class="Pp"><b>Timeout</b> - Maximum time, in seconds, to wait for a
        response from the NNTP server, a value of zero will cause all IO
        operations to block. (default: 120)</p>
    <p class="Pp"><b>Debug</b> - Enable the printing of debugging information to
        STDERR</p>
    <p class="Pp"><b>Reader</b> - If the remote server is INN then initially the
        connection will be to innd, by default
        <span class="Li">&quot;Net::NNTP&quot;</span> will issue a
        <span class="Li">&quot;MODE READER&quot;</span> command so that the
        remote server becomes nnrpd. If the
        <span class="Li">&quot;Reader&quot;</span> option is given with a value
        of zero, then this command will not be sent and the connection will be
        left talking to innd.</p>
    <p class="Pp"><b>LocalAddr</b> and <b>LocalPort</b> - These parameters are
        passed directly to IO::Socket to allow binding the socket to a specific
        local address and port.</p>
    <p class="Pp"><b>Domain</b> - This parameter is passed directly to
        IO::Socket and makes it possible to enforce IPv4 connections even if
        IO::Socket::IP is used as super class. Alternatively <b>Family</b> can
        be used.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Object_Methods"><a class="permalink" href="#Object_Methods">Object
  Methods</a></h2>
<p class="Pp">Unless otherwise stated all methods return either a <i>true</i> or
    <i>false</i> value, with <i>true</i> meaning that the operation was a
    success. When a method states that it returns a value, failure will be
    returned as <i>undef</i> or an empty list.</p>
<p class="Pp"><span class="Li">&quot;Net::NNTP&quot;</span> inherits from
    <span class="Li">&quot;Net::Cmd&quot;</span> so methods defined in
    <span class="Li">&quot;Net::Cmd&quot;</span> may be used to send commands to
    the remote NNTP server in addition to the methods documented here.</p>
<dl class="Bl-tag">
  <dt>&quot;host()&quot;</dt>
  <dd>Returns the value used by the constructor, and passed to IO::Socket::INET,
      to connect to the host.</dd>
  <dt>&quot;starttls()&quot;</dt>
  <dd>Upgrade existing plain connection to SSL. Any arguments necessary for SSL
      must be given in <span class="Li">&quot;new&quot;</span> already.</dd>
  <dt>&quot;article([{$msgid|$msgnum}[, $fh]])&quot;</dt>
  <dd>Retrieve the header, a blank line, then the body (text) of the specified
      article.
    <p class="Pp">If <span class="Li">$fh</span> is specified then it is
        expected to be a valid filehandle and the result will be printed to it,
        on success a true value will be returned. If <span class="Li">$fh</span>
        is not specified then the return value, on success, will be a reference
        to an array containing the article requested, each entry in the array
        will contain one line of the article.</p>
    <p class="Pp">If no arguments are passed then the current article in the
        currently selected newsgroup is fetched.</p>
    <p class="Pp"><span class="Li">$msgnum</span> is a numeric id of an article
        in the current newsgroup, and will change the current article pointer.
        <span class="Li">$msgid</span> is the message id of an article as shown
        in that article's header. It is anticipated that the client will obtain
        the <span class="Li">$msgid</span> from a list provided by the
        <span class="Li">&quot;newnews&quot;</span> command, from references
        contained within another article, or from the message-id provided in the
        response to some other commands.</p>
    <p class="Pp">If there is an error then
        <span class="Li">&quot;undef&quot;</span> will be returned.</p>
  </dd>
  <dt>&quot;body([{$msgid|$msgnum}[, [$fh]])&quot;</dt>
  <dd>Like <span class="Li">&quot;article&quot;</span> but only fetches the body
      of the article.</dd>
  <dt>&quot;head([{$msgid|$msgnum}[, [$fh]])&quot;</dt>
  <dd>Like <span class="Li">&quot;article&quot;</span> but only fetches the
      headers for the article.</dd>
  <dt>&quot;articlefh([{$msgid|$msgnum}])&quot;</dt>
  <dd></dd>
  <dt>&quot;bodyfh([{$msgid|$msgnum}])&quot;</dt>
  <dd></dd>
  <dt>&quot;headfh([{$msgid|$msgnum}])&quot;</dt>
  <dd>These are similar to <b>article()</b>, <b>body()</b> and <b>head()</b>,
      but rather than returning the requested data directly, they return a tied
      filehandle from which to read the article.</dd>
  <dt>&quot;nntpstat([{$msgid|$msgnum}])&quot;</dt>
  <dd>The <span class="Li">&quot;nntpstat&quot;</span> command is similar to the
      <span class="Li">&quot;article&quot;</span> command except that no text is
      returned. When selecting by message number within a group, the
      <span class="Li">&quot;nntpstat&quot;</span> command serves to set the
      &quot;current article pointer&quot; without sending text.
    <p class="Pp">Using the <span class="Li">&quot;nntpstat&quot;</span> command
        to select by message-id is valid but of questionable value, since a
        selection by message-id does <b>not</b> alter the &quot;current article
        pointer&quot;.</p>
    <p class="Pp">Returns the message-id of the &quot;current article&quot;.</p>
  </dd>
  <dt>&quot;group([$group])&quot;</dt>
  <dd>Set and/or get the current group. If <span class="Li">$group</span> is not
      given then information is returned on the current group.
    <p class="Pp">In a scalar context it returns the group name.</p>
    <p class="Pp">In an array context the return value is a list containing, the
        number of articles in the group, the number of the first article, the
        number of the last article and the group name.</p>
  </dd>
  <dt>&quot;help()&quot;</dt>
  <dd>Request help text (a short summary of commands that are understood by this
      implementation) from the server. Returns the text or undef upon
    failure.</dd>
  <dt>&quot;ihave($msgid[, $message])&quot;</dt>
  <dd>The <span class="Li">&quot;ihave&quot;</span> command informs the server
      that the client has an article whose id is <span class="Li">$msgid</span>.
      If the server desires a copy of that article and
      <span class="Li">$message</span> has been given then it will be sent.
    <p class="Pp">Returns <i>true</i> if the server desires the article and
        <span class="Li">$message</span> was successfully sent, if
      specified.</p>
    <p class="Pp">If <span class="Li">$message</span> is not specified then the
        message must be sent using the
        <span class="Li">&quot;datasend&quot;</span> and
        <span class="Li">&quot;dataend&quot;</span> methods from Net::Cmd</p>
    <p class="Pp"><span class="Li">$message</span> can be either an array of
        lines or a reference to an array and must be encoded by the caller to
        octets of whatever encoding is required, e.g. by using the Encode
        module's <span class="Li">&quot;encode()&quot;</span> function.</p>
  </dd>
  <dt>&quot;last()&quot;</dt>
  <dd>Set the &quot;current article pointer&quot; to the previous article in the
      current newsgroup.
    <p class="Pp">Returns the message-id of the article.</p>
  </dd>
  <dt>&quot;date()&quot;</dt>
  <dd>Returns the date on the remote server. This date will be in a UNIX time
      format (seconds since 1970)</dd>
  <dt>&quot;postok()&quot;</dt>
  <dd><span class="Li">&quot;postok&quot;</span> will return <i>true</i> if the
      servers initial response indicated that it will allow posting.</dd>
  <dt>&quot;authinfo($user, $pass)&quot;</dt>
  <dd>Authenticates to the server (using the original AUTHINFO USER / AUTHINFO
      PASS form, defined in RFC2980) using the supplied username and password.
      Please note that the password is sent in clear text to the server. This
      command should not be used with valuable passwords unless the connection
      to the server is somehow protected.</dd>
  <dt>&quot;authinfo_simple($user, $pass)&quot;</dt>
  <dd>Authenticates to the server (using the proposed NNTP V2 AUTHINFO SIMPLE
      form, defined and deprecated in RFC2980) using the supplied username and
      password. As with &quot;authinfo&quot; the password is sent in clear
    text.</dd>
  <dt>&quot;list()&quot;</dt>
  <dd>Obtain information about all the active newsgroups. The results is a
      reference to a hash where the key is a group name and each value is a
      reference to an array. The elements in this array are:- the last article
      number in the group, the first article number in the group and any
      information flags about the group.</dd>
  <dt>&quot;newgroups($since[, $distributions])&quot;</dt>
  <dd><span class="Li">$since</span> is a time value and
      <span class="Li">$distributions</span> is either a distribution pattern or
      a reference to a list of distribution patterns. The result is the same as
      <span class="Li">&quot;list&quot;</span>, but the groups return will be
      limited to those created after <span class="Li">$since</span> and, if
      specified, in one of the distribution areas in
      <span class="Li">$distributions</span>.</dd>
  <dt>&quot;newnews($since[, $groups[, $distributions]])&quot;</dt>
  <dd><span class="Li">$since</span> is a time value.
      <span class="Li">$groups</span> is either a group pattern or a reference
      to a list of group patterns. <span class="Li">$distributions</span> is
      either a distribution pattern or a reference to a list of distribution
      patterns.
    <p class="Pp">Returns a reference to a list which contains the message-ids
        of all news posted after <span class="Li">$since</span>, that are in a
        groups which matched <span class="Li">$groups</span> and a distribution
        which matches <span class="Li">$distributions</span>.</p>
  </dd>
  <dt>&quot;next()&quot;</dt>
  <dd>Set the &quot;current article pointer&quot; to the next article in the
      current newsgroup.
    <p class="Pp">Returns the message-id of the article.</p>
  </dd>
  <dt>&quot;post([$message])&quot;</dt>
  <dd>Post a new article to the news server. If <span class="Li">$message</span>
      is specified and posting is allowed then the message will be sent.
    <p class="Pp">If <span class="Li">$message</span> is not specified then the
        message must be sent using the
        <span class="Li">&quot;datasend&quot;</span> and
        <span class="Li">&quot;dataend&quot;</span> methods from Net::Cmd</p>
    <p class="Pp"><span class="Li">$message</span> can be either an array of
        lines or a reference to an array and must be encoded by the caller to
        octets of whatever encoding is required, e.g. by using the Encode
        module's <span class="Li">&quot;encode()&quot;</span> function.</p>
    <p class="Pp">The message, either sent via
        <span class="Li">&quot;datasend&quot;</span> or as the
        <span class="Li">$message</span> parameter, must be in the format as
        described by RFC822 and must contain From:, Newsgroups: and Subject:
        headers.</p>
  </dd>
  <dt>&quot;postfh()&quot;</dt>
  <dd>Post a new article to the news server using a tied filehandle. If posting
      is allowed, this method will return a tied filehandle that you can
      <b>print()</b> the contents of the article to be posted. You must
      explicitly <b>close()</b> the filehandle when you are finished posting the
      article, and the return value from the <b>close()</b> call will indicate
      whether the message was successfully posted.</dd>
  <dt>&quot;slave()&quot;</dt>
  <dd>Tell the remote server that I am not a user client, but probably another
      news server.</dd>
  <dt>&quot;quit()&quot;</dt>
  <dd>Quit the remote server and close the socket connection.</dd>
  <dt>&quot;can_inet6()&quot;</dt>
  <dd>Returns whether we can use IPv6.</dd>
  <dt>&quot;can_ssl()&quot;</dt>
  <dd>Returns whether we can use SSL.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Extension_Methods"><a class="permalink" href="#Extension_Methods">Extension
  Methods</a></h2>
<p class="Pp">These methods use commands that are not part of the RFC977
    documentation. Some servers may not support all of them.</p>
<dl class="Bl-tag">
  <dt>&quot;newsgroups([$pattern])&quot;</dt>
  <dd>Returns a reference to a hash where the keys are all the group names which
      match <span class="Li">$pattern</span>, or all of the groups if no pattern
      is specified, and each value contains the description text for the
    group.</dd>
  <dt>&quot;distributions()&quot;</dt>
  <dd>Returns a reference to a hash where the keys are all the possible
      distribution names and the values are the distribution descriptions.</dd>
  <dt>&quot;distribution_patterns()&quot;</dt>
  <dd>Returns a reference to an array where each element, itself an array
      reference, consists of the three fields of a line of the distrib.pats list
      maintained by some NNTP servers, namely: a weight, a wildmat and a value
      which the client may use to construct a Distribution header.</dd>
  <dt>&quot;subscriptions()&quot;</dt>
  <dd>Returns a reference to a list which contains a list of groups which are
      recommended for a new user to subscribe to.</dd>
  <dt>&quot;overview_fmt()&quot;</dt>
  <dd>Returns a reference to an array which contain the names of the fields
      returned by <span class="Li">&quot;xover&quot;</span>.</dd>
  <dt>&quot;active_times()&quot;</dt>
  <dd>Returns a reference to a hash where the keys are the group names and each
      value is a reference to an array containing the time the groups was
      created and an identifier, possibly an Email address, of the creator.</dd>
  <dt>&quot;active([$pattern])&quot;</dt>
  <dd>Similar to <span class="Li">&quot;list&quot;</span> but only active groups
      that match the pattern are returned. <span class="Li">$pattern</span> can
      be a group pattern.</dd>
  <dt>&quot;xgtitle($pattern)&quot;</dt>
  <dd>Returns a reference to a hash where the keys are all the group names which
      match <span class="Li">$pattern</span> and each value is the description
      text for the group.</dd>
  <dt>&quot;xhdr($header, $message_spec)&quot;</dt>
  <dd>Obtain the header field <span class="Li">$header</span> for all the
      messages specified.
    <p class="Pp">The return value will be a reference to a hash where the keys
        are the message numbers and each value contains the text of the
        requested header for that message.</p>
  </dd>
  <dt>&quot;xover($message_spec)&quot;</dt>
  <dd>The return value will be a reference to a hash where the keys are the
      message numbers and each value contains a reference to an array which
      contains the overview fields for that message.
    <p class="Pp">The names of the fields can be obtained by calling
        <span class="Li">&quot;overview_fmt&quot;</span>.</p>
  </dd>
  <dt>&quot;xpath($message_id)&quot;</dt>
  <dd>Returns the path name to the file on the server which contains the
      specified message.</dd>
  <dt>&quot;xpat($header, $pattern, $message_spec)&quot;</dt>
  <dd>The result is the same as <span class="Li">&quot;xhdr&quot;</span> except
      the is will be restricted to headers where the text of the header matches
      <span class="Li">$pattern</span></dd>
  <dt>&quot;xrover($message_spec)&quot;</dt>
  <dd>The XROVER command returns reference information for the article(s)
      specified.
    <p class="Pp">Returns a reference to a HASH where the keys are the message
        numbers and the values are the References: lines from the articles</p>
  </dd>
  <dt>&quot;listgroup([$group])&quot;</dt>
  <dd>Returns a reference to a list of all the active messages in
      <span class="Li">$group</span>, or the current group if
      <span class="Li">$group</span> is not specified.</dd>
  <dt>&quot;reader()&quot;</dt>
  <dd>Tell the server that you are a reader and not another server.
    <p class="Pp">This is required by some servers. For example if you are
        connecting to an INN server and you have transfer permission your
        connection will be connected to the transfer daemon, not the NNTP
        daemon. Issuing this command will cause the transfer daemon to hand over
        control to the NNTP daemon.</p>
    <p class="Pp">Some servers do not understand this command, but issuing it
        and ignoring the response is harmless.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Unsupported"><a class="permalink" href="#Unsupported">Unsupported</a></h2>
<p class="Pp">The following NNTP command are unsupported by the package, and
    there are no plans to do so.</p>
<p class="Pp"></p>
<pre>    AUTHINFO GENERIC
    XTHREAD
    XSEARCH
    XINDEX
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Definitions"><a class="permalink" href="#Definitions">Definitions</a></h2>
<dl class="Bl-tag">
  <dt>$message_spec</dt>
  <dd><span class="Li">$message_spec</span> is either a single message-id, a
      single message number, or a reference to a list of two message numbers.
    <p class="Pp">If <span class="Li">$message_spec</span> is a reference to a
        list of two message numbers and the second number in a range is less
        than or equal to the first then the range represents all messages in the
        group after the first message number.</p>
    <p class="Pp"><b>NOTE</b> For compatibility reasons only with earlier
        versions of Net::NNTP a message spec can be passed as a list of two
        numbers, this is deprecated and a reference to the list should now be
        passed</p>
  </dd>
  <dt>$pattern</dt>
  <dd>The <span class="Li">&quot;NNTP&quot;</span> protocol uses the
      <span class="Li">&quot;WILDMAT&quot;</span> format for patterns. The
      WILDMAT format was first developed by Rich Salz based on the format used
      in the UNIX &quot;find&quot; command to articulate file names. It was
      developed to provide a uniform mechanism for matching patterns in the same
      manner that the UNIX shell matches filenames.
    <p class="Pp">Patterns are implicitly anchored at the beginning and end of
        each string when testing for a match.</p>
    <p class="Pp">There are five pattern matching operations other than a strict
        one-to-one match between the pattern and the source to be checked for a
        match.</p>
    <p class="Pp">The first is an asterisk <span class="Li">&quot;*&quot;</span>
        to match any sequence of zero or more characters.</p>
    <p class="Pp">The second is a question mark
        <span class="Li">&quot;?&quot;</span> to match any single character. The
        third specifies a specific set of characters.</p>
    <p class="Pp">The set is specified as a list of characters, or as a range of
        characters where the beginning and end of the range are separated by a
        minus (or dash) character, or as any combination of lists and ranges.
        The dash can also be included in the set as a character it if is the
        beginning or end of the set. This set is enclosed in square brackets.
        The close square bracket <span class="Li">&quot;]&quot;</span> may be
        used in a set if it is the first character in the set.</p>
    <p class="Pp">The fourth operation is the same as the logical not of the
        third operation and is specified the same way as the third with the
        addition of a caret character <span class="Li">&quot;^&quot;</span> at
        the beginning of the test string just inside the open square
      bracket.</p>
    <p class="Pp">The final operation uses the backslash character to invalidate
        the special meaning of an open square bracket
        <span class="Li">&quot;[&quot;</span>, the asterisk, backslash or the
        question mark. Two backslashes in sequence will result in the evaluation
        of the backslash as a character with no special meaning.</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Examples"><a class="permalink" href="#Examples">Examples</a></dt>
  <dd></dd>
  <dt>&quot;[^]-]&quot;</dt>
  <dd>matches any single character other than a close square bracket or a minus
      sign/dash.</dd>
  <dt>*bdc</dt>
  <dd>matches any string that ends with the string &quot;bdc&quot; including the
      string &quot;bdc&quot; (without quotes).</dd>
  <dt>&quot;[0-9a-zA-Z]&quot;</dt>
  <dd>matches any single printable alphanumeric ASCII character.</dd>
  <dt>&quot;a??d&quot;</dt>
  <dd>matches any four character string which begins with a and ends with
    d.</dd>
</dl>
</div>
<div class="Bd-indent"></div>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTS"><a class="permalink" href="#EXPORTS">EXPORTS</a></h1>
<p class="Pp"><i>None</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="KNOWN_BUGS"><a class="permalink" href="#KNOWN_BUGS">KNOWN
  BUGS</a></h1>
<p class="Pp">See
    &lt;https://rt.cpan.org/Dist/Display.html?Status=Active&amp;Queue=libnet&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Net::Cmd, IO::Socket::SSL.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Graham Barr &lt;gbarr@pobox.com
    &lt;mailto:gbarr@pobox.com&gt;&gt;.</p>
<p class="Pp">Steve Hay &lt;shay@cpan.org &lt;mailto:shay@cpan.org&gt;&gt; is
    now maintaining libnet as of version 1.22_02.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (C) 1995-1997 Graham Barr. All rights reserved.</p>
<p class="Pp">Copyright (C) 2013-2016, 2020 Steve Hay. All rights reserved.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENCE"><a class="permalink" href="#LICENCE">LICENCE</a></h1>
<p class="Pp">This module is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself, i.e. under the terms of
    either the GNU General Public License or the Artistic License, as specified
    in the <i>LICENCE</i> file.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">Version 3.13</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DATE"><a class="permalink" href="#DATE">DATE</a></h1>
<p class="Pp">23 Dec 2020</p>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
<p class="Pp">See the <i>Changes</i> file.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os">perl v5.34.1</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Variable::Magic(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Variable::Magic(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Variable::Magic(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Variable::Magic - Associate user-defined magic to variables from
    Perl.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">Version 0.62</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use Variable::Magic qw&lt;wizard cast VMG_OP_INFO_NAME&gt;;
    { # A variable tracer
     my $wiz = wizard(
      set  =&gt; sub { print &quot;now set to ${$_[0]}!\n&quot; },
      free =&gt; sub { print &quot;destroyed!\n&quot; },
     );
     my $a = 1;
     cast $a, $wiz;
     $a = 2;        # &quot;now set to 2!&quot;
    }               # &quot;destroyed!&quot;
    { # A hash with a default value
     my $wiz = wizard(
      data     =&gt; sub { $_[1] },
      fetch    =&gt; sub { $_[2] = $_[1] unless exists $_[0]-&gt;{$_[2]}; () },
      store    =&gt; sub { print &quot;key $_[2] stored in $_[-1]\n&quot; },
      copy_key =&gt; 1,
      op_info  =&gt; VMG_OP_INFO_NAME,
     );
     my %h = (_default =&gt; 0, apple =&gt; 2);
     cast %h, $wiz, '_default';
     print $h{banana}, &quot;\n&quot;; # &quot;0&quot; (there is no 'banana' key in %h)
     $h{pear} = 1;           # &quot;key pear stored in helem&quot;
    }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Magic is Perl's way of enhancing variables. This mechanism lets
    the user add extra data to any variable and hook syntactical operations
    (such as access, assignment or destruction) that can be applied to it. With
    this module, you can add your own magic to any variable without having to
    write a single line of XS.</p>
<p class="Pp">You'll realize that these magic variables look a lot like tied
    variables. It is not surprising, as tied variables are implemented as a
    special kind of magic, just like any 'irregular' Perl variable : scalars
    like <span class="Li">$!</span>, <span class="Li">$(</span> or
    <span class="Li">$^W</span>, the <span class="Li">%ENV</span> and
    <span class="Li">%SIG</span> hashes, the <span class="Li">@ISA</span> array,
    <span class="Li">&quot;vec()&quot;</span> and
    <span class="Li">&quot;substr()&quot;</span> lvalues, threads::shared
    variables... They all share the same underlying C API, and this module gives
    you direct access to it.</p>
<p class="Pp">Still, the magic made available by this module differs from tieing
    and overloading in several ways :</p>
<ul class="Bl-bullet">
  <li>Magic is not copied on assignment.
    <p class="Pp">You attach it to variables, not values (as for blessed
        references).</p>
  </li>
  <li>Magic does not replace the original semantics.
    <p class="Pp">Magic callbacks usually get triggered before the original
        action takes place, and cannot prevent it from happening. This also
        makes catching individual events easier than with
        <span class="Li">&quot;tie&quot;</span>, where you have to provide
        fallbacks methods for all actions by usually inheriting from the correct
        <span class="Li">&quot;Tie::Std*&quot;</span> class and overriding
        individual methods in your own class.</p>
  </li>
  <li>Magic is multivalued.
    <p class="Pp">You can safely apply different kinds of magics to the same
        variable, and each of them will be invoked successively.</p>
  </li>
  <li>Magic is type-agnostic.
    <p class="Pp">The same magic can be applied on scalars, arrays, hashes, subs
        or globs. But the same hook (see below for a list) may trigger
        differently depending on the type of the variable.</p>
  </li>
  <li>Magic is invisible at Perl level.
    <p class="Pp">Magical and non-magical variables cannot be distinguished with
        <span class="Li">&quot;ref&quot;</span>,
        <span class="Li">&quot;tied&quot;</span> or another trick.</p>
  </li>
  <li>Magic is notably faster.
    <p class="Pp">Mainly because perl's way of handling magic is lighter by
        nature, and because there is no need for any method resolution. Also,
        since you don't have to reimplement all the variable semantics, you only
        pay for what you actually use.</p>
  </li>
</ul>
<p class="Pp">The operations that can be overloaded are :</p>
<ul class="Bl-bullet">
  <li><i>get</i>
    <p class="Pp">This magic is invoked when the variable is evaluated. It is
        never called for arrays and hashes.</p>
  </li>
  <li><i>set</i>
    <p class="Pp">This magic is called each time the value of the variable
        changes. It is called for array subscripts and slices, but never for
        hashes.</p>
  </li>
  <li><i>len</i>
    <p class="Pp">This magic only applies to arrays (though it used to also
        apply to scalars), and is triggered when the 'size' or the 'length' of
        the variable has to be known by Perl. This is typically the magic
        involved when an array is evaluated in scalar context, but also on array
        assignment and loops (<span class="Li">&quot;for&quot;</span>,
        <span class="Li">&quot;map&quot;</span> or
        <span class="Li">&quot;grep&quot;</span>). The length is returned from
        the callback as an integer.</p>
    <p class="Pp">Starting from perl 5.12, this magic is no longer called by the
        <span class="Li">&quot;length&quot;</span> keyword, and starting from
        perl 5.17.4 it is also no longer called for scalars in any situation,
        making this magic only meaningful on arrays. You can use the constants
        &quot;VMG_COMPAT_SCALAR_LENGTH_NOLEN&quot; and
        &quot;VMG_COMPAT_SCALAR_NOLEN&quot; to see if this magic is available
        for scalars or not.</p>
  </li>
  <li><i>clear</i>
    <p class="Pp">This magic is invoked when the variable is reset, such as when
        an array is emptied. Please note that this is different from undefining
        the variable, even though the magic is called when the clearing is a
        result of the undefine (e.g. for an array, but actually a bug prevent it
        to work before perl 5.9.5 - see the history).</p>
  </li>
  <li><i>free</i>
    <p class="Pp">This magic is called when a variable is destroyed as the
        result of going out of scope (but not when it is undefined). It behaves
        roughly like Perl object destructors (i.e.
        <span class="Li">&quot;DESTROY&quot;</span> methods), except that
        exceptions thrown from inside a <i>free</i> callback will always be
        propagated to the surrounding code.</p>
  </li>
  <li><i>copy</i>
    <p class="Pp">When applied to tied arrays and hashes, this magic fires when
        you try to access or change their elements.</p>
    <p class="Pp">Starting from perl 5.17.0, it can also be applied to closure
        prototypes, in which case the magic will be called when the prototype is
        cloned. The &quot;VMG_COMPAT_CODE_COPY_CLONE&quot; constant is true when
        your perl support this feature.</p>
  </li>
  <li><i>dup</i>
    <p class="Pp">This magic is invoked when the variable is cloned across
        threads. It is currently not available.</p>
  </li>
  <li><i>local</i>
    <p class="Pp">When this magic is set on a variable, all subsequent
        localizations of the variable will trigger the callback. It is available
        on your perl if and only if
        <span class="Li">&quot;MGf_LOCAL&quot;</span> is true.</p>
  </li>
</ul>
<p class="Pp">The following actions only apply to hashes and are available if
    and only if &quot;VMG_UVAR&quot; is true. They are referred to as
    <i>uvar</i> magics.</p>
<ul class="Bl-bullet">
  <li><i>fetch</i>
    <p class="Pp">This magic is invoked each time an element is fetched from the
        hash.</p>
  </li>
  <li><i>store</i>
    <p class="Pp">This one is called when an element is stored into the
      hash.</p>
  </li>
  <li><i>exists</i>
    <p class="Pp">This magic fires when a key is tested for existence in the
        hash.</p>
  </li>
  <li><i>delete</i>
    <p class="Pp">This magic is triggered when a key is deleted in the hash,
        regardless of whether the key actually exists in it.</p>
  </li>
</ul>
<p class="Pp">You can refer to the tests to have more insight of where the
    different magics are invoked.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTIONS"><a class="permalink" href="#FUNCTIONS">FUNCTIONS</a></h1>
<section class="Ss">
<h2 class="Ss" id="_wizard_"><a class="permalink" href="#_wizard_">&quot;wizard&quot;</a></h2>
<pre>    wizard(
     data     =&gt; sub { ... },
     get      =&gt; sub { my ($ref, $data [, $op]) = @_; ... },
     set      =&gt; sub { my ($ref, $data [, $op]) = @_; ... },
     len      =&gt; sub {
      my ($ref, $data, $len [, $op]) = @_; ... ; return $newlen
     },
     clear    =&gt; sub { my ($ref, $data [, $op]) = @_; ... },
     free     =&gt; sub { my ($ref, $data [, $op]) = @_, ... },
     copy     =&gt; sub { my ($ref, $data, $key, $elt [, $op]) = @_; ... },
     local    =&gt; sub { my ($ref, $data [, $op]) = @_; ... },
     fetch    =&gt; sub { my ($ref, $data, $key [, $op]) = @_; ... },
     store    =&gt; sub { my ($ref, $data, $key [, $op]) = @_; ... },
     exists   =&gt; sub { my ($ref, $data, $key [, $op]) = @_; ... },
     delete   =&gt; sub { my ($ref, $data, $key [, $op]) = @_; ... },
     copy_key =&gt; $bool,
     op_info  =&gt; [ 0 | VMG_OP_INFO_NAME | VMG_OP_INFO_OBJECT ],
    )
</pre>
<p class="Pp">This function creates a 'wizard', an opaque object that holds the
    magic information. It takes a list of keys / values as argument, whose keys
    can be :</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;data&quot;</span>
    <p class="Pp">A code (or string) reference to a private data constructor. It
        is called in scalar context each time the magic is cast onto a variable,
        with <span class="Li">$_[0]</span> being a reference to this variable
        and <span class="Li">@_[1 .. @_-1]</span> being all extra arguments that
        were passed to &quot;cast&quot;. The scalar returned from this call is
        then attached to the variable and can be retrieved later with
        &quot;getdata&quot;.</p>
  </li>
  <li><span class="Li">&quot;get&quot;</span>,
      <span class="Li">&quot;set&quot;</span>,
      <span class="Li">&quot;len&quot;</span>,
      <span class="Li">&quot;clear&quot;</span>,
      <span class="Li">&quot;free&quot;</span>,
      <span class="Li">&quot;copy&quot;</span>,
      <span class="Li">&quot;local&quot;</span>,
      <span class="Li">&quot;fetch&quot;</span>,
      <span class="Li">&quot;store&quot;</span>,
      <span class="Li">&quot;exists&quot;</span> and
      <span class="Li">&quot;delete&quot;</span>
    <p class="Pp">Code (or string) references to the respective magic callbacks.
        You don't have to specify all of them : the magic corresponding to
        undefined entries will simply not be hooked.</p>
    <p class="Pp">When those callbacks are executed,
        <span class="Li">$_[0]</span> is a reference to the magic variable and
        <span class="Li">$_[1]</span> is the associated private data (or
        <span class="Li">&quot;undef&quot;</span> when no private data
        constructor is supplied with the wizard). Other arguments depend on
        which kind of magic is involved :</p>
  </li>
</ul>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li><i>len</i>
    <p class="Pp"><span class="Li">$_[2]</span> contains the natural,
        non-magical length of the variable (which can only be a scalar or an
        array as <i>len</i> magic is only relevant for these types). The
        callback is expected to return the new scalar or array length to use, or
        <span class="Li">&quot;undef&quot;</span> to default to the normal
        length.</p>
  </li>
  <li><i>copy</i>
    <p class="Pp">When the variable for which the magic is invoked is an array
        or an hash, <span class="Li">$_[2]</span> is a either an alias or a copy
        of the current key, and <span class="Li">$_[3]</span> is an alias to the
        current element (i.e. the value). Since <span class="Li">$_[2]</span>
        might be a copy, it is useless to try to change it or cast magic on
      it.</p>
    <p class="Pp">Starting from perl 5.17.0, this magic can also be called for
        code references. In this case, <span class="Li">$_[2]</span> is always
        <span class="Li">&quot;undef&quot;</span> and
        <span class="Li">$_[3]</span> is a reference to the cloned anonymous
        subroutine.</p>
  </li>
  <li><i>fetch</i>, <i>store</i>, <i>exists</i> and <i>delete</i>
    <p class="Pp"><span class="Li">$_[2]</span> is an alias to the current key.
        Note that <span class="Li">$_[2]</span> may rightfully be readonly if
        the key comes from a bareword, and as such it is unsafe to assign to it.
        You can ask for a copy instead by passing
        <span class="Li">&quot;copy_key =&gt; 1&quot;</span> to
        &quot;wizard&quot; which, at the price of a small performance hit,
        allows you to safely assign to <span class="Li">$_[2]</span> in order to
        e.g. redirect the action to another key.</p>
  </li>
</ul>
</div>
<div class="Bd-indent">
<p class="Pp">Finally, if <span class="Li">&quot;op_info =&gt; $num&quot;</span>
    is also passed to <span class="Li">&quot;wizard&quot;</span>, then one extra
    element is appended to <span class="Li">@_</span>. Its nature depends on the
    value of <span class="Li">$num</span> :</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;VMG_OP_INFO_NAME&quot;</span>
    <p class="Pp"><span class="Li">$_[-1]</span> is the current op name.</p>
  </li>
  <li><span class="Li">&quot;VMG_OP_INFO_OBJECT&quot;</span>
    <p class="Pp"><span class="Li">$_[-1]</span> is the
        <span class="Li">&quot;B::OP&quot;</span> object for the current op.</p>
  </li>
</ul>
</div>
<div class="Bd-indent">
<p class="Pp">Both result in a small performance hit, but just getting the name
    is lighter than getting the op object.</p>
<p class="Pp">These callbacks are always executed in scalar context. The
    returned value is coerced into a signed integer, which is then passed
    straight to the perl magic API. However, note that perl currently only cares
    about the return value of the <i>len</i> magic callback and ignores all the
    others. Starting with Variable::Magic 0.58, a reference returned from a
    non-<i>len</i> magic callback will not be destroyed immediately but will be
    allowed to survive until the end of the statement that triggered the magic.
    This lets you use this return value as a token for triggering a destructor
    after the original magic action takes place. You can see an example of this
    technique in the cookbook.</p>
</div>
<p class="Pp">Each callback can be specified as :</p>
<ul class="Bl-bullet">
  <li>a code reference, which will be called as a subroutine.</li>
  <li>a string reference, where the string denotes which subroutine is to be
      called when magic is triggered. If the subroutine name is not fully
      qualified, then the current package at the time the magic is invoked will
      be used instead.</li>
  <li>a reference to <span class="Li">&quot;undef&quot;</span>, in which case a
      no-op magic callback is installed instead of the default one. This may
      especially be helpful for <i>local</i> magic, where an empty callback
      prevents magic from being copied during localization.</li>
</ul>
<p class="Pp">Note that <i>free</i> magic is never called during global
    destruction, as there is no way to ensure that the wizard object and the
    callback were not destroyed before the variable.</p>
<p class="Pp">Here is a simple usage example :</p>
<p class="Pp"></p>
<pre>    # A simple scalar tracer
    my $wiz = wizard(
     get  =&gt; sub { print STDERR &quot;got ${$_[0]}\n&quot; },
     set  =&gt; sub { print STDERR &quot;set to ${$_[0]}\n&quot; },
     free =&gt; sub { print STDERR &quot;${$_[0]} was deleted\n&quot; },
    );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_cast_"><a class="permalink" href="#_cast_">&quot;cast&quot;</a></h2>
<pre>    cast [$@%&amp;*]var, $wiz, @args
</pre>
<p class="Pp">This function associates <span class="Li">$wiz</span> magic to the
    supplied variable, without overwriting any other kind of magic. It returns
    true on success or when <span class="Li">$wiz</span> magic is already
    attached, and croaks on error. When <span class="Li">$wiz</span> provides a
    data constructor, it is called just before magic is cast onto the variable,
    and it receives a reference to the target variable in
    <span class="Li">$_[0]</span> and the content of
    <span class="Li">@args</span> in <span class="Li">@_[1 .. @args]</span>.
    Otherwise, <span class="Li">@args</span> is ignored.</p>
<p class="Pp"></p>
<pre>    # Casts $wiz onto $x, passing (\$x, '1') to the data constructor.
    my $x;
    cast $x, $wiz, 1;
</pre>
<p class="Pp">The <span class="Li">&quot;var&quot;</span> argument can be an
    array or hash value. Magic for these scalars behaves like for any other,
    except that it is dispelled when the entry is deleted from the container.
    For example, if you want to call
    <span class="Li">&quot;POSIX::tzset&quot;</span> each time the
    <span class="Li">'TZ'</span> environment variable is changed in
    <span class="Li">%ENV</span>, you can use :</p>
<p class="Pp"></p>
<pre>    use POSIX;
    cast $ENV{TZ}, wizard set =&gt; sub { POSIX::tzset(); () };
</pre>
<p class="Pp">If you want to handle the possible deletion of the
    <span class="Li">'TZ'</span> entry, you must also specify <i>store</i>
    magic.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_getdata_"><a class="permalink" href="#_getdata_">&quot;getdata&quot;</a></h2>
<pre>    getdata [$@%&amp;*]var, $wiz
</pre>
<p class="Pp">This accessor fetches the private data associated with the magic
    <span class="Li">$wiz</span> in the variable. It croaks when
    <span class="Li">$wiz</span> does not represent a valid magic object, and
    returns an empty list if no such magic is attached to the variable or when
    the wizard has no data constructor.</p>
<p class="Pp"></p>
<pre>    # Get the data attached to $wiz in $x, or undef if $wiz
    # did not attach any.
    my $data = getdata $x, $wiz;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_dispell_"><a class="permalink" href="#_dispell_">&quot;dispell&quot;</a></h2>
<pre>    dispell [$@%&amp;*]variable, $wiz
</pre>
<p class="Pp">The exact opposite of &quot;cast&quot; : it dissociates
    <span class="Li">$wiz</span> magic from the variable. This function returns
    true on success, <span class="Li">0</span> when no magic represented by
    <span class="Li">$wiz</span> could be found in the variable, and croaks if
    the supplied wizard is invalid.</p>
<p class="Pp"></p>
<pre>    # Dispell now.
    die 'no such magic in $x' unless dispell $x, $wiz;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CONSTANTS"><a class="permalink" href="#CONSTANTS">CONSTANTS</a></h1>
<section class="Ss">
<h2 class="Ss" id="_MGf_COPY_"><a class="permalink" href="#_MGf_COPY_">&quot;MGf_COPY&quot;</a></h2>
<p class="Pp">Evaluates to true if and only if the <i>copy</i> magic is
    available. This is the case for perl 5.7.3 and greater, which is ensured by
    the requirements of this module.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_MGf_DUP_"><a class="permalink" href="#_MGf_DUP_">&quot;MGf_DUP&quot;</a></h2>
<p class="Pp">Evaluates to true if and only if the <i>dup</i> magic is
    available. This is the case for perl 5.7.3 and greater, which is ensured by
    the requirements of this module.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_MGf_LOCAL_"><a class="permalink" href="#_MGf_LOCAL_">&quot;MGf_LOCAL&quot;</a></h2>
<p class="Pp">Evaluates to true if and only if the <i>local</i> magic is
    available. This is the case for perl 5.9.3 and greater.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_VMG_UVAR_"><a class="permalink" href="#_VMG_UVAR_">&quot;VMG_UVAR&quot;</a></h2>
<p class="Pp">When this constant is true, you can use the <i>fetch</i>,
    <i>store</i>, <i>exists</i> and <i>delete</i> magics on hashes. Initial
    &quot;VMG_UVAR&quot; capability was introduced in perl 5.9.5, with a fully
    functional implementation shipped with perl 5.10.0.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_VMG_COMPAT_SCALAR_LENGTH_NOLEN_"><a class="permalink" href="#_VMG_COMPAT_SCALAR_LENGTH_NOLEN_">&quot;VMG_COMPAT_SCALAR_LENGTH_NOLEN&quot;</a></h2>
<p class="Pp">True for perls that don't call <i>len</i> magic when taking the
    <span class="Li">&quot;length&quot;</span> of a magical scalar.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_VMG_COMPAT_SCALAR_NOLEN_"><a class="permalink" href="#_VMG_COMPAT_SCALAR_NOLEN_">&quot;VMG_COMPAT_SCALAR_NOLEN&quot;</a></h2>
<p class="Pp">True for perls that don't call <i>len</i> magic on scalars.
    Implies &quot;VMG_COMPAT_SCALAR_LENGTH_NOLEN&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_VMG_COMPAT_ARRAY_PUSH_NOLEN_"><a class="permalink" href="#_VMG_COMPAT_ARRAY_PUSH_NOLEN_">&quot;VMG_COMPAT_ARRAY_PUSH_NOLEN&quot;</a></h2>
<p class="Pp">True for perls that don't call <i>len</i> magic when you push an
    element in a magical array. Starting from perl 5.11.0, this only refers to
    pushes in non-void context and hence is false.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_VMG_COMPAT_ARRAY_PUSH_NOLEN_VOID_"><a class="permalink" href="#_VMG_COMPAT_ARRAY_PUSH_NOLEN_VOID_">&quot;VMG_COMPAT_ARRAY_PUSH_NOLEN_VOID&quot;</a></h2>
<p class="Pp">True for perls that don't call <i>len</i> magic when you push in
    void context an element in a magical array.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_VMG_COMPAT_ARRAY_UNSHIFT_NOLEN_VOID_"><a class="permalink" href="#_VMG_COMPAT_ARRAY_UNSHIFT_NOLEN_VOID_">&quot;VMG_COMPAT_ARRAY_UNSHIFT_NOLEN_VOID&quot;</a></h2>
<p class="Pp">True for perls that don't call <i>len</i> magic when you unshift
    in void context an element in a magical array.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_VMG_COMPAT_ARRAY_UNDEF_CLEAR_"><a class="permalink" href="#_VMG_COMPAT_ARRAY_UNDEF_CLEAR_">&quot;VMG_COMPAT_ARRAY_UNDEF_CLEAR&quot;</a></h2>
<p class="Pp">True for perls that call <i>clear</i> magic when undefining
    magical arrays.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_VMG_COMPAT_HASH_DELETE_NOUVAR_VOID_"><a class="permalink" href="#_VMG_COMPAT_HASH_DELETE_NOUVAR_VOID_">&quot;VMG_COMPAT_HASH_DELETE_NOUVAR_VOID&quot;</a></h2>
<p class="Pp">True for perls that don't call <i>delete</i> magic when you delete
    an element from a hash in void context.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_VMG_COMPAT_CODE_COPY_CLONE_"><a class="permalink" href="#_VMG_COMPAT_CODE_COPY_CLONE_">&quot;VMG_COMPAT_CODE_COPY_CLONE&quot;</a></h2>
<p class="Pp">True for perls that call <i>copy</i> magic when a magical closure
    prototype is cloned.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_VMG_COMPAT_GLOB_GET_"><a class="permalink" href="#_VMG_COMPAT_GLOB_GET_">&quot;VMG_COMPAT_GLOB_GET&quot;</a></h2>
<p class="Pp">True for perls that call <i>get</i> magic for operations on
  globs.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_VMG_PERL_PATCHLEVEL_"><a class="permalink" href="#_VMG_PERL_PATCHLEVEL_">&quot;VMG_PERL_PATCHLEVEL&quot;</a></h2>
<p class="Pp">The perl patchlevel this module was built with, or
    <span class="Li">0</span> for non-debugging perls.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_VMG_THREADSAFE_"><a class="permalink" href="#_VMG_THREADSAFE_">&quot;VMG_THREADSAFE&quot;</a></h2>
<p class="Pp">True if and only if this module could have been built with
    thread-safety features enabled.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_VMG_FORKSAFE_"><a class="permalink" href="#_VMG_FORKSAFE_">&quot;VMG_FORKSAFE&quot;</a></h2>
<p class="Pp">True if and only if this module could have been built with
    fork-safety features enabled. This is always true except on Windows where it
    is false for perl 5.10.0 and below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_VMG_OP_INFO_NAME_"><a class="permalink" href="#_VMG_OP_INFO_NAME_">&quot;VMG_OP_INFO_NAME&quot;</a></h2>
<p class="Pp">Value to pass with <span class="Li">&quot;op_info&quot;</span> to
    get the current op name in the magic callbacks.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_VMG_OP_INFO_OBJECT_"><a class="permalink" href="#_VMG_OP_INFO_OBJECT_">&quot;VMG_OP_INFO_OBJECT&quot;</a></h2>
<p class="Pp">Value to pass with <span class="Li">&quot;op_info&quot;</span> to
    get a <span class="Li">&quot;B::OP&quot;</span> object representing the
    current op in the magic callbacks.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="COOKBOOK"><a class="permalink" href="#COOKBOOK">COOKBOOK</a></h1>
<section class="Ss">
<h2 class="Ss" id="Associate_an_object_to_any_perl_variable"><a class="permalink" href="#Associate_an_object_to_any_perl_variable">Associate
  an object to any perl variable</a></h2>
<p class="Pp">This technique can be useful for passing user data through limited
    APIs. It is similar to using inside-out objects, but without the drawback of
    having to implement a complex destructor.</p>
<p class="Pp"></p>
<pre>    {
     package Magical::UserData;
     use Variable::Magic qw&lt;wizard cast getdata&gt;;
     my $wiz = wizard data =&gt; sub { \$_[1] };
     sub ud (\[$@%*&amp;]) : lvalue {
      my ($var) = @_;
      my $data = &amp;getdata($var, $wiz);
      unless (defined $data) {
       $data = \(my $slot);
       &amp;cast($var, $wiz, $slot)
                 or die &quot;Couldn't cast UserData magic onto the variable&quot;;
      }
      $$data;
     }
    }
    {
     BEGIN { *ud = \&amp;Magical::UserData::ud }
     my $cb;
     $cb = sub { print 'Hello, ', ud(&amp;$cb), &quot;!\n&quot; };
     ud(&amp;$cb) = 'world';
     $cb-&gt;(); # Hello, world!
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Recursively_cast_magic_on_datastructures"><a class="permalink" href="#Recursively_cast_magic_on_datastructures">Recursively
  cast magic on datastructures</a></h2>
<p class="Pp"><span class="Li">&quot;cast&quot;</span> can be called from any
    magical callback, and in particular from
    <span class="Li">&quot;data&quot;</span>. This allows you to recursively
    cast magic on datastructures :</p>
<p class="Pp"></p>
<pre>    my $wiz;
    $wiz = wizard data =&gt; sub {
     my ($var, $depth) = @_;
     $depth ||= 0;
     my $r = ref $var;
     if ($r eq 'ARRAY') {
      &amp;cast((ref() ? $_ : \$_), $wiz, $depth + 1) for @$var;
     } elsif ($r eq 'HASH') {
      &amp;cast((ref() ? $_ : \$_), $wiz, $depth + 1) for values %$var;
     }
     return $depth;
    },
    free =&gt; sub {
     my ($var, $depth) = @_;
     my $r = ref $var;
     print &quot;free $r at depth $depth\n&quot;;
     ();
    };
    {
     my %h = (
      a =&gt; [ 1, 2 ],
      b =&gt; { c =&gt; 3 }
     );
     cast %h, $wiz;
    }
</pre>
<p class="Pp">When <span class="Li">%h</span> goes out of scope, this prints
    something among the lines of :</p>
<p class="Pp"></p>
<pre>    free HASH at depth 0
    free HASH at depth 1
    free SCALAR at depth 2
    free ARRAY at depth 1
    free SCALAR at depth 3
    free SCALAR at depth 3
</pre>
<p class="Pp">Of course, this example does nothing with the values that are
    added after the <span class="Li">&quot;cast&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Delayed_magic_actions"><a class="permalink" href="#Delayed_magic_actions">Delayed
  magic actions</a></h2>
<p class="Pp">Starting with Variable::Magic 0.58, the return value of the magic
    callbacks can be used to delay the action until after the original action
    takes place :</p>
<p class="Pp"></p>
<pre>    my $delayed;
    my $delayed_aux = wizard(
     data =&gt; sub { $_[1] },
     free =&gt; sub {
      my ($target) = $_[1];
      my $target_data = &amp;getdata($target, $delayed);
      local $target_data-&gt;{guard} = 1;
      if (ref $target eq 'SCALAR') {
       my $orig = $$target;
       $$target = $target_data-&gt;{mangler}-&gt;($orig);
      }
      return;
     },
    );
    $delayed = wizard(
     data =&gt; sub {
      return +{ guard =&gt; 0, mangler =&gt; $_[1] };
     },
     set  =&gt; sub {
      return if $_[1]-&gt;{guard};
      my $token;
      cast $token, $delayed_aux, $_[0];
      return \$token;
     },
    );
    my $x = 1;
    cast $x, $delayed =&gt; sub { $_[0] * 2 };
    $x = 2;
    # $x is now 4
    # But note that the delayed action only takes place at the end of the
    # current statement :
    my @y = ($x = 5, $x);
    # $x is now 10, but @y is (5, 5)
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="PERL_MAGIC_HISTORY"><a class="permalink" href="#PERL_MAGIC_HISTORY">PERL
  MAGIC HISTORY</a></h1>
<p class="Pp">The places where magic is invoked have changed a bit through perl
    history. Here is a little list of the most recent ones.</p>
<ul class="Bl-bullet">
  <li><b>5.6.x</b>
    <p class="Pp"><i>p14416</i> : <i>copy</i> and <i>dup</i> magic.</p>
  </li>
  <li><b>5.8.9</b>
    <p class="Pp"><i>p28160</i> : Integration of <i>p25854</i> (see below).</p>
    <p class="Pp"><i>p32542</i> : Integration of <i>p31473</i> (see below).</p>
  </li>
  <li><b>5.9.3</b>
    <p class="Pp"><i>p25854</i> : <i>len</i> magic is no longer called when
        pushing an element into a magic array.</p>
    <p class="Pp"><i>p26569</i> : <i>local</i> magic.</p>
  </li>
  <li><b>5.9.5</b>
    <p class="Pp"><i>p31064</i> : Meaningful <i>uvar</i> magic.</p>
    <p class="Pp"><i>p31473</i> : <i>clear</i> magic was not invoked when
        undefining an array. The bug is fixed as of this version.</p>
  </li>
  <li><b>5.10.0</b>
    <p class="Pp">Since <span class="Li">&quot;PERL_MAGIC_uvar&quot;</span> is
        uppercased, <span class="Li">&quot;hv_magic_check()&quot;</span>
        triggers <i>copy</i> magic on hash stores for (non-tied) hashes that
        also have <i>uvar</i> magic.</p>
  </li>
  <li><b>5.11.x</b>
    <p class="Pp"><i>p32969</i> : <i>len</i> magic is no longer invoked when
        calling <span class="Li">&quot;length&quot;</span> with a magical
        scalar.</p>
    <p class="Pp"><i>p34908</i> : <i>len</i> magic is no longer called when
        pushing / unshifting an element into a magical array in void context.
        The <span class="Li">&quot;push&quot;</span> part was already covered by
        <i>p25854</i>.</p>
    <p class="Pp"><i>g9cdcb38b</i> : <i>len</i> magic is called again when
        pushing into a magical array in non-void context.</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORT"><a class="permalink" href="#EXPORT">EXPORT</a></h1>
<p class="Pp">The functions &quot;wizard&quot;, &quot;cast&quot;,
    &quot;getdata&quot; and &quot;dispell&quot; are only exported on request.
    All of them are exported by the tags <span class="Li">':funcs'</span> and
    <span class="Li">':all'</span>.</p>
<p class="Pp">All the constants are also only exported on request, either
    individually or by the tags <span class="Li">':consts'</span> and
    <span class="Li">':all'</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<p class="Pp">In order to hook hash operations with magic, you need at least
    perl 5.10.0 (see &quot;VMG_UVAR&quot;).</p>
<p class="Pp">If you want to store a magic object in the private data slot, you
    will not be able to recover the magic with &quot;getdata&quot;, since magic
    is not copied by assignment. You can work around this gotcha by storing a
    reference to the magic object instead.</p>
<p class="Pp">If you define a wizard with <i>free</i> magic and cast it on
    itself, it results in a memory cycle, so this destructor will not be called
    when the wizard is freed.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DEPENDENCIES"><a class="permalink" href="#DEPENDENCIES">DEPENDENCIES</a></h1>
<p class="Pp">perl 5.8.</p>
<p class="Pp">A C compiler. This module may happen to build with a C++ compiler
    as well, but don't rely on it, as no guarantee is made in this regard.</p>
<p class="Pp">Carp (core since perl 5), XSLoader (since 5.6.0).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">perlguts and perlapi for internal information about magic.</p>
<p class="Pp">perltie and overload for other ways of enhancing objects.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Vincent Pit, <span class="Li">&quot;&lt;perl at
    profvince.com&gt;&quot;</span>, &lt;http://www.profvince.com&gt;.</p>
<p class="Pp">You can contact me by mail or on
    <span class="Li">&quot;irc.perl.org&quot;</span> (vincent).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">Please report any bugs or feature requests to
    <span class="Li">&quot;bug-variable-magic at rt.cpan.org&quot;</span>, or
    through the web interface at
    &lt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Variable-Magic&gt;. I
    will be notified, and then you'll automatically be notified of progress on
    your bug as I make changes.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
<p class="Pp">You can find documentation for this module with the perldoc
    command.</p>
<p class="Pp"></p>
<pre>    perldoc Variable::Magic
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_&amp;_LICENSE"><a class="permalink" href="#COPYRIGHT_&amp;_LICENSE">COPYRIGHT
  &amp; LICENSE</a></h1>
<p class="Pp">Copyright 2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017
    Vincent Pit, all rights reserved.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-11-04</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

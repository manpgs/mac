<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion - Demonstrates
    subtypes and coercion use HTTP-related classes (Request, Protocol, etc.)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 2.2012</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  package Request;
  use Moose;
  use Moose::Util::TypeConstraints;
  use HTTP::Headers  ();
  use Params::Coerce ();
  use URI            ();
  subtype 'My::Types::HTTP::Headers' =&gt; as class_type('HTTP::Headers');
  coerce 'My::Types::HTTP::Headers'
      =&gt; from 'ArrayRef'
          =&gt; via { HTTP::Headers-&gt;new( @{$_} ) }
      =&gt; from 'HashRef'
          =&gt; via { HTTP::Headers-&gt;new( %{$_} ) };
  subtype 'My::Types::URI' =&gt; as class_type('URI');
  coerce 'My::Types::URI'
      =&gt; from 'Object'
          =&gt; via { $_-&gt;isa('URI')
                   ? $_
                   : Params::Coerce::coerce( 'URI', $_ ); }
      =&gt; from 'Str'
          =&gt; via { URI-&gt;new( $_, 'http' ) };
  subtype 'Protocol'
      =&gt; as 'Str'
      =&gt; where { /^HTTP\/[0-9]\.[0-9]$/ };
  has 'base' =&gt; ( is =&gt; 'rw', isa =&gt; 'My::Types::URI', coerce =&gt; 1 );
  has 'uri'  =&gt; ( is =&gt; 'rw', isa =&gt; 'My::Types::URI', coerce =&gt; 1 );
  has 'method'   =&gt; ( is =&gt; 'rw', isa =&gt; 'Str' );
  has 'protocol' =&gt; ( is =&gt; 'rw', isa =&gt; 'Protocol' );
  has 'headers'  =&gt; (
      is      =&gt; 'rw',
      isa     =&gt; 'My::Types::HTTP::Headers',
      coerce  =&gt; 1,
      default =&gt; sub { HTTP::Headers-&gt;new }
  );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This recipe introduces type coercions, which are defined with the
    <span class="Li">&quot;coerce&quot;</span> sugar function. Coercions are
    attached to existing type constraints, and define a (one-way) transformation
    from one type to another.</p>
<p class="Pp">This is very powerful, but it can also have unexpected
    consequences, so you have to explicitly ask for an attribute to be coerced.
    To do this, you must set the <span class="Li">&quot;coerce&quot;</span>
    attribute option to a true value.</p>
<p class="Pp">First, we create the subtype to which we will coerce the other
    types:</p>
<p class="Pp"></p>
<pre>  subtype 'My::Types::HTTP::Headers' =&gt; as class_type('HTTP::Headers');
</pre>
<p class="Pp">We are creating a subtype rather than using
    <span class="Li">&quot;HTTP::Headers&quot;</span> as a type directly. The
    reason we do this is that coercions are global, and a coercion defined for
    <span class="Li">&quot;HTTP::Headers&quot;</span> in our
    <span class="Li">&quot;Request&quot;</span> class would then be defined for
    <i>all</i> Moose-using classes in the current Perl interpreter. It's a best
    practice to avoid this sort of namespace pollution.</p>
<p class="Pp">The <span class="Li">&quot;class_type&quot;</span> sugar function
    is simply a shortcut for this:</p>
<p class="Pp"></p>
<pre>  subtype 'HTTP::Headers'
      =&gt; as 'Object'
      =&gt; where { $_-&gt;isa('HTTP::Headers') };
</pre>
<p class="Pp">Internally, Moose creates a type constraint for each Moose-using
    class, but for non-Moose classes, the type must be declared explicitly.</p>
<p class="Pp">We could go ahead and use this new type directly:</p>
<p class="Pp"></p>
<pre>  has 'headers' =&gt; (
      is      =&gt; 'rw',
      isa     =&gt; 'My::Types::HTTP::Headers',
      default =&gt; sub { HTTP::Headers-&gt;new }
  );
</pre>
<p class="Pp">This creates a simple attribute which defaults to an empty
    instance of HTTP::Headers.</p>
<p class="Pp">The constructor for HTTP::Headers accepts a list of key-value
    pairs representing the HTTP header fields. In Perl, such a list could be
    stored in an ARRAY or HASH reference. We want our
    <span class="Li">&quot;headers&quot;</span> attribute to accept those data
    structures instead of an <b>HTTP::Headers</b> instance, and just do the
    right thing. This is exactly what coercion is for:</p>
<p class="Pp"></p>
<pre>  coerce 'My::Types::HTTP::Headers'
      =&gt; from 'ArrayRef'
          =&gt; via { HTTP::Headers-&gt;new( @{$_} ) }
      =&gt; from 'HashRef'
          =&gt; via { HTTP::Headers-&gt;new( %{$_} ) };
</pre>
<p class="Pp">The first argument to <span class="Li">&quot;coerce&quot;</span>
    is the type <i>to</i> which we are coercing. Then we give it a set of
    <span class="Li">&quot;from&quot;</span>/<span class="Li">&quot;via&quot;</span>
    clauses. The <span class="Li">&quot;from&quot;</span> function takes some
    other type name and <span class="Li">&quot;via&quot;</span> takes a
    subroutine reference which actually does the coercion.</p>
<p class="Pp">However, defining the coercion doesn't do anything until we tell
    Moose we want a particular attribute to be coerced:</p>
<p class="Pp"></p>
<pre>  has 'headers' =&gt; (
      is      =&gt; 'rw',
      isa     =&gt; 'My::Types::HTTP::Headers',
      coerce  =&gt; 1,
      default =&gt; sub { HTTP::Headers-&gt;new }
  );
</pre>
<p class="Pp">Now, if we use an <span class="Li">&quot;ArrayRef&quot;</span> or
    <span class="Li">&quot;HashRef&quot;</span> to populate
    <span class="Li">&quot;headers&quot;</span>, it will be coerced into a new
    HTTP::Headers instance. With the coercion in place, the following lines of
    code are all equivalent:</p>
<p class="Pp"></p>
<pre>  $foo-&gt;headers( HTTP::Headers-&gt;new( bar =&gt; 1, baz =&gt; 2 ) );
  $foo-&gt;headers( [ 'bar', 1, 'baz', 2 ] );
  $foo-&gt;headers( { bar =&gt; 1, baz =&gt; 2 } );
</pre>
<p class="Pp">As you can see, careful use of coercions can produce a very open
    interface for your class, while still retaining the &quot;safety&quot; of
    your type constraint checks. (1)</p>
<p class="Pp">Our next coercion shows how we can leverage existing CPAN modules
    to help implement coercions. In this case we use Params::Coerce.</p>
<p class="Pp">Once again, we need to declare a class type for our non-Moose URI
    class:</p>
<p class="Pp"></p>
<pre>  subtype 'My::Types::URI' =&gt; as class_type('URI');
</pre>
<p class="Pp">Then we define the coercion:</p>
<p class="Pp"></p>
<pre>  coerce 'My::Types::URI'
      =&gt; from 'Object'
          =&gt; via { $_-&gt;isa('URI')
                   ? $_
                   : Params::Coerce::coerce( 'URI', $_ ); }
      =&gt; from 'Str'
          =&gt; via { URI-&gt;new( $_, 'http' ) };
</pre>
<p class="Pp">The first coercion takes any object and makes it a
    <span class="Li">&quot;URI&quot;</span> object. The coercion system isn't
    that smart, and does not check if the object is already a URI, so we check
    for that ourselves. If it's not a URI already, we let Params::Coerce do its
    magic, and we just use its return value.</p>
<p class="Pp">If Params::Coerce didn't return a URI object (for whatever
    reason), Moose would throw a type constraint error.</p>
<p class="Pp">The other coercion takes a string and converts it to a URI. In
    this case, we are using the coercion to apply a default behavior, where a
    string is assumed to be an <span class="Li">&quot;http&quot;</span> URI.</p>
<p class="Pp">Finally, we need to make sure our attributes enable coercion.</p>
<p class="Pp"></p>
<pre>  has 'base' =&gt; ( is =&gt; 'rw', isa =&gt; 'My::Types::URI', coerce =&gt; 1 );
  has 'uri'  =&gt; ( is =&gt; 'rw', isa =&gt; 'My::Types::URI', coerce =&gt; 1 );
</pre>
<p class="Pp">Re-using the coercion lets us enforce a consistent API across
    multiple attributes.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONCLUSION"><a class="permalink" href="#CONCLUSION">CONCLUSION</a></h1>
<p class="Pp">This recipe showed the use of coercions to create a more flexible
    and DWIM-y API. Like any powerful feature, we recommend some caution.
    Sometimes it's better to reject a value than just guess at how to DWIM.</p>
<p class="Pp">We also showed the use of the
    <span class="Li">&quot;class_type&quot;</span> sugar function as a shortcut
    for defining a new subtype of
  <span class="Li">&quot;Object&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FOOTNOTES"><a class="permalink" href="#FOOTNOTES">FOOTNOTES</a></h1>
<dl class="Bl-tag">
  <dt>(1)</dt>
  <dd>This particular example could be safer. Really we only want to coerce an
      array with an <i>even</i> number of elements. We could create a new
      <span class="Li">&quot;EvenElementArrayRef&quot;</span> type, and then
      coerce from that type, as opposed to a plain
      <span class="Li">&quot;ArrayRef&quot;</span></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Stevan Little &lt;stevan.little@iinteractive.com&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
  <li>Shawn M Moore &lt;code@sartak.org&gt;</li>
  <li>&#x05D9;&#x05D5;&#x05D1;&#x05DC; &#x05E7;&#x05D5;&#x05D2;'&#x05DE;&#x05DF;
      (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Florian Ragwitz &lt;rafl@debian.org&gt;</li>
  <li>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</li>
  <li>Chris Prather &lt;chris@prather.org&gt;</li>
  <li>Matt S Trout &lt;mst@shadowcat.co.uk&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2006 by Infinity Interactive,
  Inc.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-11-22</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

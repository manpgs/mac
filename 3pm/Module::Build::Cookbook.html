<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Module::Build::Cookbook(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Module::Build::Cookbook(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Module::Build::Cookbook(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Module::Build::Cookbook - Examples of Module::Build Usage</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><span class="Li">&quot;Module::Build&quot;</span> isn't
    conceptually very complicated, but examples are always helpful. The
    following recipes should help developers and/or installers put together the
    pieces from the other parts of the documentation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BASIC_RECIPES"><a class="permalink" href="#BASIC_RECIPES">BASIC
  RECIPES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Installing_modules_that_use_Module::Build"><a class="permalink" href="#Installing_modules_that_use_Module::Build">Installing
  modules that use Module::Build</a></h2>
<p class="Pp">In most cases, you can just issue the following commands:</p>
<p class="Pp"></p>
<pre>  perl Build.PL
  ./Build
  ./Build test
  ./Build install
</pre>
<p class="Pp">There's nothing complicated here - first you're running a script
    called <i>Build.PL</i>, then you're running a (newly-generated) script
    called <i>Build</i> and passing it various arguments.</p>
<p class="Pp">The exact commands may vary a bit depending on how you invoke perl
    scripts on your system. For instance, if you have multiple versions of perl
    installed, you can install to one particular perl's library directories like
    so:</p>
<p class="Pp"></p>
<pre>  /usr/bin/perl5.8.1 Build.PL
  ./Build
  ./Build test
  ./Build install
</pre>
<p class="Pp">If you're on Windows where the current directory is always
    searched first for scripts, you'll probably do something like this:</p>
<p class="Pp"></p>
<pre>  perl Build.PL
  Build
  Build test
  Build install
</pre>
<p class="Pp">On the old Mac OS (version 9 or lower) using MacPerl, you can
    double-click on the <i>Build.PL</i> script to create the <i>Build</i>
    script, then double-click on the <i>Build</i> script to run its
    <span class="Li">&quot;build&quot;</span>,
    <span class="Li">&quot;test&quot;</span>, and
    <span class="Li">&quot;install&quot;</span> actions.</p>
<p class="Pp">The <i>Build</i> script knows what perl was used to run
    <i>Build.PL</i>, so you don't need to re-invoke the <i>Build</i> script with
    the complete perl path each time. If you invoke it with the <i>wrong</i>
    perl path, you'll get a warning or a fatal error.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Modifying_Config.pm_values"><a class="permalink" href="#Modifying_Config.pm_values">Modifying
  Config.pm values</a></h2>
<p class="Pp"><span class="Li">&quot;Module::Build&quot;</span> relies heavily
    on various values from perl's <span class="Li">&quot;Config.pm&quot;</span>
    to do its work. For example, default installation paths are given by
    <span class="Li">&quot;installsitelib&quot;</span> and
    <span class="Li">&quot;installvendorman3dir&quot;</span> and friends, C
    linker &amp; compiler settings are given by
    <span class="Li">&quot;ld&quot;</span>,
    <span class="Li">&quot;lddlflags&quot;</span>,
    <span class="Li">&quot;cc&quot;</span>,
    <span class="Li">&quot;ccflags&quot;</span>, and so on. <i>If you're pretty
    sure</i> <i>you know what you're doing</i>, you can tell
    <span class="Li">&quot;Module::Build&quot;</span> to pretend there are
    different values in <i>Config.pm</i> than what's really there, by passing
    arguments for the <span class="Li">&quot;--config&quot;</span> parameter on
    the command line:</p>
<p class="Pp"></p>
<pre>  perl Build.PL --config cc=gcc --config ld=gcc
</pre>
<p class="Pp">Inside the <span class="Li">&quot;Build.PL&quot;</span> script the
    same thing can be accomplished by passing values for the
    <span class="Li">&quot;config&quot;</span> parameter to
    <span class="Li">&quot;new()&quot;</span>:</p>
<p class="Pp"></p>
<pre> my $build = Module::Build-&gt;new
   (
    ...
    config =&gt; { cc =&gt; 'gcc', ld =&gt; 'gcc' },
    ...
   );
</pre>
<p class="Pp">In custom build code, the same thing can be accomplished by
    calling the &quot;config&quot; in Module::Build method:</p>
<p class="Pp"></p>
<pre> $build-&gt;config( cc =&gt; 'gcc' );     # Set
 $build-&gt;config( ld =&gt; 'gcc' );     # Set
 ...
 my $linker = $build-&gt;config('ld'); # Get
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Installing_modules_using_the_programmatic_interface"><a class="permalink" href="#Installing_modules_using_the_programmatic_interface">Installing
  modules using the programmatic interface</a></h2>
<p class="Pp">If you need to build, test, and/or install modules from within
    some other perl code (as opposed to having the user type installation
    commands at the shell), you can use the programmatic interface. Create a
    Module::Build object (or an object of a custom Module::Build subclass) and
    then invoke its <span class="Li">&quot;dispatch()&quot;</span> method to run
    various actions.</p>
<p class="Pp"></p>
<pre>  my $build = Module::Build-&gt;new
    (
     module_name =&gt; 'Foo::Bar',
     license     =&gt; 'perl',
     requires    =&gt; { 'Some::Module'   =&gt; '1.23' },
    );
  $build-&gt;dispatch('build');
  $build-&gt;dispatch('test', verbose =&gt; 1);
  $build-&gt;dispatch('install');
</pre>
<p class="Pp">The first argument to
    <span class="Li">&quot;dispatch()&quot;</span> is the name of the action,
    and any following arguments are named parameters.</p>
<p class="Pp">This is the interface we use to test Module::Build itself in the
    regression tests.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Installing_to_a_temporary_directory"><a class="permalink" href="#Installing_to_a_temporary_directory">Installing
  to a temporary directory</a></h2>
<p class="Pp">To create packages for package managers like RedHat's
    <span class="Li">&quot;rpm&quot;</span> or Debian's
    <span class="Li">&quot;deb&quot;</span>, you may need to install to a
    temporary directory first and then create the package from that temporary
    installation. To do this, specify the
    <span class="Li">&quot;destdir&quot;</span> parameter to the
    <span class="Li">&quot;install&quot;</span> action:</p>
<p class="Pp"></p>
<pre>  ./Build install --destdir /tmp/my-package-1.003
</pre>
<p class="Pp">This essentially just prepends all the installation paths with the
    <i>/tmp/my-package-1.003</i> directory.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Installing_to_a_non-standard_directory"><a class="permalink" href="#Installing_to_a_non-standard_directory">Installing
  to a non-standard directory</a></h2>
<p class="Pp">To install to a non-standard directory (for example, if you don't
    have permission to install in the system-wide directories), you can use the
    <span class="Li">&quot;install_base&quot;</span> or
    <span class="Li">&quot;prefix&quot;</span> parameters:</p>
<p class="Pp"></p>
<pre>  ./Build install --install_base /foo/bar
</pre>
<p class="Pp">See &quot;INSTALL PATHS&quot; in Module::Build for a much more
    complete discussion of how installation paths are determined.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Installing_in_the_same_location_as_ExtUtils::MakeMaker"><a class="permalink" href="#Installing_in_the_same_location_as_ExtUtils::MakeMaker">Installing
  in the same location as ExtUtils::MakeMaker</a></h2>
<p class="Pp">With the introduction of
    <span class="Li">&quot;--prefix&quot;</span> in Module::Build 0.28 and
    <span class="Li">&quot;INSTALL_BASE&quot;</span> in
    <span class="Li">&quot;ExtUtils::MakeMaker&quot;</span> 6.31 its easy to get
    them both to install to the same locations.</p>
<p class="Pp">First, ensure you have at least version 0.28 of Module::Build
    installed and 6.31 of
    <span class="Li">&quot;ExtUtils::MakeMaker&quot;</span>. Prior versions have
    differing (and in some cases quite strange) installation behaviors.</p>
<p class="Pp">The following installation flags are equivalent between
    <span class="Li">&quot;ExtUtils::MakeMaker&quot;</span> and
    <span class="Li">&quot;Module::Build&quot;</span>.</p>
<p class="Pp"></p>
<pre>    MakeMaker             Module::Build
    PREFIX=...            --prefix ...
    INSTALL_BASE=...      --install_base ...
    DESTDIR=...           --destdir ...
    LIB=...               --install_path lib=...
    INSTALLDIRS=...       --installdirs ...
    INSTALLDIRS=perl      --installdirs core
    UNINST=...            --uninst ...
    INC=...               --extra_compiler_flags ...
    POLLUTE=1             --extra_compiler_flags -DPERL_POLLUTE
</pre>
<p class="Pp">For example, if you are currently installing
    <span class="Li">&quot;MakeMaker&quot;</span> modules with this command:</p>
<p class="Pp"></p>
<pre>    perl Makefile.PL PREFIX=~
    make test
    make install UNINST=1
</pre>
<p class="Pp">You can install into the same location with Module::Build using
    this:</p>
<p class="Pp"></p>
<pre>    perl Build.PL --prefix ~
    ./Build test
    ./Build install --uninst 1
</pre>
<p class="Pp"><i></i><span class="Li"><i>&quot;prefix&quot;</i></span><i> vs
    </i><span class="Li"><i>&quot;install_base&quot;</i></span><i></i></p>
<p class="Pp">The behavior of <span class="Li">&quot;prefix&quot;</span> is
    complicated and depends on how your Perl is configured. The resulting
    installation locations will vary from machine to machine and even different
    installations of Perl on the same machine. Because of this, it's difficult
    to document where <span class="Li">&quot;prefix&quot;</span> will place your
    modules.</p>
<p class="Pp">In contrast, <span class="Li">&quot;install_base&quot;</span> has
    predictable, easy to explain installation locations. Now that
    <span class="Li">&quot;Module::Build&quot;</span> and
    <span class="Li">&quot;MakeMaker&quot;</span> both have
    <span class="Li">&quot;install_base&quot;</span> there is little reason to
    use <span class="Li">&quot;prefix&quot;</span> other than to preserve your
    existing installation locations. If you are starting a fresh Perl
    installation we encourage you to use
    <span class="Li">&quot;install_base&quot;</span>. If you have an existing
    installation installed via <span class="Li">&quot;prefix&quot;</span>,
    consider moving it to an installation structure matching
    <span class="Li">&quot;install_base&quot;</span> and using that instead.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Running_a_single_test_file"><a class="permalink" href="#Running_a_single_test_file">Running
  a single test file</a></h2>
<p class="Pp"><span class="Li">&quot;Module::Build&quot;</span> supports running
    a single test, which enables you to track down errors more quickly. Use the
    following format:</p>
<p class="Pp"></p>
<pre>  ./Build test --test_files t/mytest.t
</pre>
<p class="Pp">In addition, you may want to run the test in verbose mode to get
    more informative output:</p>
<p class="Pp"></p>
<pre>  ./Build test --test_files t/mytest.t --verbose 1
</pre>
<p class="Pp">I run this so frequently that I define the following shell
  alias:</p>
<p class="Pp"></p>
<pre>  alias t './Build test --verbose 1 --test_files'
</pre>
<p class="Pp">So then I can just execute <span class="Li">&quot;t
    t/mytest.t&quot;</span> to run a single test.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ADVANCED_RECIPES"><a class="permalink" href="#ADVANCED_RECIPES">ADVANCED
  RECIPES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Making_a_"><a class="permalink" href="#Making_a_">Making a
  CPAN.pm-compatible distribution</a></h2>
<p class="Pp">New versions of CPAN.pm understand how to use a <i>Build.PL</i>
    script, but old versions don't. If authors want to help users who have old
    versions, some form of <i>Makefile.PL</i> should be supplied. The easiest
    way to accomplish this is to use the
    <span class="Li">&quot;create_makefile_pl&quot;</span> parameter to
    <span class="Li">&quot;Module::Build-&gt;new()&quot;</span> in the
    <span class="Li">&quot;Build.PL&quot;</span> script, which can create
    various flavors of <i>Makefile.PL</i> during the
    <span class="Li">&quot;dist&quot;</span> action.</p>
<p class="Pp">As a best practice, we recommend using the &quot;traditional&quot;
    style of <i>Makefile.PL</i> unless your distribution has needs that can't be
    accomplished that way.</p>
<p class="Pp">The <span class="Li">&quot;Module::Build::Compat&quot;</span>
    module, which is part of <span class="Li">&quot;Module::Build&quot;</span>'s
    distribution, is responsible for creating these <i>Makefile.PL</i>s. Please
    see Module::Build::Compat for the details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Changing_the_order_of_the_build_process"><a class="permalink" href="#Changing_the_order_of_the_build_process">Changing
  the order of the build process</a></h2>
<p class="Pp">The <span class="Li">&quot;build_elements&quot;</span> property
    specifies the steps <span class="Li">&quot;Module::Build&quot;</span> will
    take when building a distribution. To change the build order, change the
    order of the entries in that property:</p>
<p class="Pp"></p>
<pre>  # Process pod files first
  my @e = @{$build-&gt;build_elements};
  my ($i) = grep {$e[$_] eq 'pod'} 0..$#e;
  unshift @e, splice @e, $i, 1;
</pre>
<p class="Pp">Currently, <span class="Li">&quot;build_elements&quot;</span> has
    the following default value:</p>
<p class="Pp"></p>
<pre>  [qw( PL support pm xs pod script )]
</pre>
<p class="Pp">Do take care when altering this property, since there may be
    non-obvious (and non-documented!) ordering dependencies in the
    <span class="Li">&quot;Module::Build&quot;</span> code.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Adding_new_file_types_to_the_build_process"><a class="permalink" href="#Adding_new_file_types_to_the_build_process">Adding
  new file types to the build process</a></h2>
<p class="Pp">Sometimes you might have extra types of files that you want to
    install alongside the standard types like <i>.pm</i> and <i>.pod</i> files.
    For instance, you might have a <i>Bar.dat</i> file containing some data
    related to the <span class="Li">&quot;Foo::Bar&quot;</span> module and you'd
    like for it to end up as <i>Foo/Bar.dat</i> somewhere in perl's
    <span class="Li">@INC</span> path so
    <span class="Li">&quot;Foo::Bar&quot;</span> can access it easily at
    runtime. The following code from a sample
    <span class="Li">&quot;Build.PL&quot;</span> file demonstrates how to
    accomplish this:</p>
<p class="Pp"></p>
<pre>  use Module::Build;
  my $build = Module::Build-&gt;new
    (
     module_name =&gt; 'Foo::Bar',
     ...other stuff here...
    );
  $build-&gt;add_build_element('dat');
  $build-&gt;create_build_script;
</pre>
<p class="Pp">This will find all <i>.dat</i> files in the <i>lib/</i> directory,
    copy them to the <i>blib/lib/</i> directory during the
    <span class="Li">&quot;build&quot;</span> action, and install them during
    the <span class="Li">&quot;install&quot;</span> action.</p>
<p class="Pp">If your extra files aren't located in the
    <span class="Li">&quot;lib/&quot;</span> directory in your distribution, you
    can explicitly say where they are, just as you'd do with <i>.pm</i> or
    <i>.pod</i> files:</p>
<p class="Pp"></p>
<pre>  use Module::Build;
  my $build = new Module::Build
    (
     module_name =&gt; 'Foo::Bar',
     dat_files =&gt; {'some/dir/Bar.dat' =&gt; 'lib/Foo/Bar.dat'},
     ...other stuff here...
    );
  $build-&gt;add_build_element('dat');
  $build-&gt;create_build_script;
</pre>
<p class="Pp">If your extra files actually need to be created on the user's
    machine, or if they need some other kind of special processing, you'll
    probably want to subclass <span class="Li">&quot;Module::Build&quot;</span>
    and create a special method to process them, named
    <span class="Li">&quot;process_${kind}_files()&quot;</span>:</p>
<p class="Pp"></p>
<pre>  use Module::Build;
  my $class = Module::Build-&gt;subclass(code =&gt; &lt;&lt;'EOF');
    sub process_dat_files {
      my $self = shift;
      ... locate and process *.dat files,
      ... and create something in blib/lib/
    }
  EOF
  my $build = $class-&gt;new
    (
     module_name =&gt; 'Foo::Bar',
     ...other stuff here...
    );
  $build-&gt;add_build_element('dat');
  $build-&gt;create_build_script;
</pre>
<p class="Pp">If your extra files don't go in <i>lib/</i> but in some other
    place, see &quot;Adding new elements to the install process&quot; for how to
    actually get them installed.</p>
<p class="Pp">Please note that these examples use some capabilities of
    Module::Build that first appeared in version 0.26. Before that it could
    still be done, but the simple cases took a bit more work.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Adding_new_elements_to_the_install_process"><a class="permalink" href="#Adding_new_elements_to_the_install_process">Adding
  new elements to the install process</a></h2>
<p class="Pp">By default, Module::Build creates seven subdirectories of the
    <i>blib</i> directory during the build process: <i>lib</i>, <i>arch</i>,
    <i>bin</i>, <i>script</i>, <i>bindoc</i>, <i>libdoc</i>, and <i>html</i>
    (some of these may be missing or empty if there's nothing to go in them).
    Anything copied to these directories during the build will eventually be
    installed during the <span class="Li">&quot;install&quot;</span> action (see
    &quot;INSTALL PATHS&quot; in Module::Build.</p>
<p class="Pp">If you need to create a new custom type of installable element,
    e.g. <span class="Li">&quot;conf&quot;</span>, then you need to tell
    Module::Build where things in <i>blib/conf/</i> should be installed. To do
    this, use the <span class="Li">&quot;install_path&quot;</span> parameter to
    the <span class="Li">&quot;new()&quot;</span> method:</p>
<p class="Pp"></p>
<pre>  my $build = Module::Build-&gt;new
    (
     ...other stuff here...
     install_path =&gt; { conf =&gt; $installation_path }
    );
</pre>
<p class="Pp">Or you can call the
    <span class="Li">&quot;install_path()&quot;</span> method later:</p>
<p class="Pp"></p>
<pre>  $build-&gt;install_path(conf =&gt; $installation_path);
</pre>
<p class="Pp">The user may also specify the path on the command line:</p>
<p class="Pp"></p>
<pre>  perl Build.PL --install_path conf=/foo/path/etc
</pre>
<p class="Pp">The important part, though, is that <i>somehow</i> the install
    path needs to be set, or else nothing in the <i>blib/conf/</i> directory
    will get installed, and a runtime error during the
    <span class="Li">&quot;install&quot;</span> action will result.</p>
<p class="Pp">See also &quot;Adding new file types to the build process&quot;
    for how to create the stuff in <i>blib/conf/</i> in the first place.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES_ON_CPAN"><a class="permalink" href="#EXAMPLES_ON_CPAN">EXAMPLES
  ON CPAN</a></h1>
<p class="Pp">Several distributions on CPAN are making good use of various
    features of Module::Build. They can serve as real-world examples for
  others.</p>
<section class="Ss">
<h2 class="Ss" id="SVN-Notify-Mirror"><a class="permalink" href="#SVN-Notify-Mirror">SVN-Notify-Mirror</a></h2>
<p class="Pp">&lt;http://search.cpan.org/~jpeacock/SVN-Notify-Mirror/&gt;</p>
<p class="Pp">John Peacock, author of the
    <span class="Li">&quot;SVN-Notify-Mirror&quot;</span> distribution,
  says:</p>
<dl class="Bl-tag">
  <dt>1. Using &quot;auto_features&quot;, I check to see whether two optional
    modules are available - SVN::Notify::Config and Net::SSH;</dt>
  <dd></dd>
  <dt>2. If the S::N::Config module is loaded, I automatically generate test
    files for it during Build (using the &quot;PL_files&quot; property).</dt>
  <dd></dd>
  <dt>3. If the &quot;ssh_feature&quot; is available, I ask if the user wishes
    to perform the ssh tests (since it requires a little preliminary
    setup);</dt>
  <dd></dd>
  <dt>4. Only if the user has &quot;ssh_feature&quot; and answers yes to the
    testing, do I generate a test file.</dt>
  <dd>I'm sure I could not have handled this complexity with EU::MM, but it was
      very easy to do with M::B.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Modifying_an_action"><a class="permalink" href="#Modifying_an_action">Modifying
  an action</a></h2>
<p class="Pp">Sometimes you might need an to have an action, say
    <span class="Li">&quot;./Build install&quot;</span>, do something unusual.
    For instance, you might need to change the ownership of a file or do
    something else peculiar to your application.</p>
<p class="Pp">You can subclass <span class="Li">&quot;Module::Build&quot;</span>
    on the fly using the <span class="Li">&quot;subclass()&quot;</span> method
    and override the methods that perform the actions. You may need to read
    through <span class="Li">&quot;Module::Build::Authoring&quot;</span> and
    <span class="Li">&quot;Module::Build::API&quot;</span> to find the methods
    you want to override. All &quot;action&quot; methods are implemented by a
    method called &quot;ACTION_&quot; followed by the action's name, so here's
    an example of how it would work for the
    <span class="Li">&quot;install&quot;</span> action:</p>
<p class="Pp"></p>
<pre>  # Build.PL
  use Module::Build;
  my $class = Module::Build-&gt;subclass(
      class =&gt; &quot;Module::Build::Custom&quot;,
      code =&gt; &lt;&lt;'SUBCLASS' );
  sub ACTION_install {
      my $self = shift;
      # YOUR CODE HERE
      $self-&gt;SUPER::ACTION_install;
  }
  SUBCLASS
  $class-&gt;new(
      module_name =&gt; 'Your::Module',
      # rest of the usual Module::Build parameters
  )-&gt;create_build_script;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Adding_an_action"><a class="permalink" href="#Adding_an_action">Adding
  an action</a></h2>
<p class="Pp">You can add a new <span class="Li">&quot;./Build&quot;</span>
    action simply by writing the method for it in your subclass. Use
    <span class="Li">&quot;depends_on&quot;</span> to declare that another
    action must have been run before your action.</p>
<p class="Pp">For example, let's say you wanted to be able to write
    <span class="Li">&quot;./Build</span> <span class="Li">commit&quot;</span>
    to test your code and commit it to Subversion.</p>
<p class="Pp"></p>
<pre>  # Build.PL
  use Module::Build;
  my $class = Module::Build-&gt;subclass(
      class =&gt; &quot;Module::Build::Custom&quot;,
      code =&gt; &lt;&lt;'SUBCLASS' );
  sub ACTION_commit {
      my $self = shift;
      $self-&gt;depends_on(&quot;test&quot;);
      $self-&gt;do_system(qw(svn commit));
  }
  SUBCLASS
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Bundling_Module::Build"><a class="permalink" href="#Bundling_Module::Build">Bundling
  Module::Build</a></h2>
<p class="Pp">Note: This section probably needs an update as the technology
    improves (see contrib/bundle.pl in the distribution).</p>
<p class="Pp">Suppose you want to use some new-ish features of Module::Build,
    e.g. newer than the version of Module::Build your users are likely to
    already have installed on their systems. The first thing you should do is
    set <span class="Li">&quot;configure_requires&quot;</span> to your minimum
    version of Module::Build. See Module::Build::Authoring.</p>
<p class="Pp">But not every build system honors
    <span class="Li">&quot;configure_requires&quot;</span> yet. Here's how you
    can ship a copy of Module::Build, but still use a newer installed version to
    take advantage of any bug fixes and upgrades.</p>
<p class="Pp">First, install Module::Build into
    <i>Your-Project/inc/Module-Build</i>. CPAN will not index anything in the
    <i>inc</i> directory so this copy will not show up in CPAN searches.</p>
<p class="Pp"></p>
<pre>    cd Module-Build
    perl Build.PL --install_base /path/to/Your-Project/inc/Module-Build
    ./Build test
    ./Build install
</pre>
<p class="Pp">You should now have all the Module::Build .pm files in
    <i>Your-Project/inc/Module-Build/lib/perl5</i>.</p>
<p class="Pp">Next, add this to the top of your <i>Build.PL</i>.</p>
<p class="Pp"></p>
<pre>    my $Bundled_MB = 0.30;  # or whatever version it was.
    # Find out what version of Module::Build is installed or fail quietly.
    # This should be cross-platform.
    my $Installed_MB =
        `$^X -e &quot;eval q{require Module::Build; print Module::Build-&gt;VERSION} or exit 1&quot;`;
    # some operating systems put a newline at the end of every print.
    chomp $Installed_MB;
    $Installed_MB = 0 if $?;
    # Use our bundled copy of Module::Build if it's newer than the installed.
    unshift @INC, &quot;inc/Module-Build/lib/perl5&quot; if $Bundled_MB &gt; $Installed_MB;
    require Module::Build;
</pre>
<p class="Pp">And write the rest of your <i>Build.PL</i> normally. Module::Build
    will remember your change to <span class="Li">@INC</span> and use it when
    you run <i>./Build</i>.</p>
<p class="Pp">In the future, we hope to provide a more automated solution for
    this scenario; see <span class="Li">&quot;inc/latest.pm&quot;</span> in the
    Module::Build distribution for one indication of the direction we're
  moving.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Ken Williams &lt;kwilliams@cpan.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 2001-2008 Ken Williams. All rights reserved.</p>
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>perl</b>(1), Module::Build(3), Module::Build::Authoring(3),
    Module::Build::API(3)</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2024-02-10</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

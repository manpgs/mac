<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>XML::SAX::ParserFactory(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">XML::SAX::ParserFactory(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">XML::SAX::ParserFactory(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">XML::SAX::ParserFactory - Obtain a SAX parser</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  use XML::SAX::ParserFactory;
  use XML::SAX::XYZHandler;
  my $handler = XML::SAX::XYZHandler-&gt;new();
  my $p = XML::SAX::ParserFactory-&gt;parser(Handler =&gt; $handler);
  $p-&gt;parse_uri(&quot;foo.xml&quot;);
  # or $p-&gt;parse_string(&quot;&lt;foo/&gt;&quot;) or $p-&gt;parse_file($fh);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">XML::SAX::ParserFactory is a factory class for providing an
    application with a Perl SAX2 XML parser. It is akin to DBI - a front end for
    other parser classes. Each new SAX2 parser installed will register itself
    with XML::SAX, and then it will become available to all applications that
    use XML::SAX::ParserFactory to obtain a SAX parser.</p>
<p class="Pp">Unlike DBI however, XML/SAX parsers almost all work alike
    (especially if they subclass XML::SAX::Base, as they should), so rather than
    specifying the parser you want in the call to
    <span class="Li">&quot;parser()&quot;</span>, XML::SAX has several ways to
    automatically choose which parser to use:</p>
<ul class="Bl-bullet">
  <li><span class="Li">$XML::SAX::ParserPackage</span>
    <p class="Pp">If this package variable is set, then this package is
        <span class="Li">&quot;require()&quot;</span>d and an instance of this
        package is returned by calling the
        <span class="Li">&quot;new()&quot;</span> class method in that package.
        If it cannot be loaded or there is an error, an exception will be
        thrown. The variable can also contain a version number:</p>
    <p class="Pp"></p>
    <pre>  $XML::SAX::ParserPackage = &quot;XML::SAX::Expat (0.72)&quot;;
    </pre>
    <p class="Pp">And the number will be treated as a minimum version
      number.</p>
  </li>
  <li>Required features
    <p class="Pp">It is possible to require features from the parsers. For
        example, you may wish for a parser that supports validation via a DTD.
        To do that, use the following code:</p>
    <p class="Pp"></p>
    <pre>  use XML::SAX::ParserFactory;
  my $factory = XML::SAX::ParserFactory-&gt;new();
  $factory-&gt;require_feature('http://xml.org/sax/features/validation');
  my $parser = $factory-&gt;parser(...);
    </pre>
    <p class="Pp">Alternatively, specify the required features in the call to
        the ParserFactory constructor:</p>
    <p class="Pp"></p>
    <pre>  my $factory = XML::SAX::ParserFactory-&gt;new(
          RequiredFeatures =&gt; {
               'http://xml.org/sax/features/validation' =&gt; 1,
               }
          );
    </pre>
    <p class="Pp">If the features you have asked for are unavailable (for
        example the user might not have a validating parser installed), then an
        exception will be thrown.</p>
    <p class="Pp">The list of known parsers is searched in reverse order, so it
        will always return the last installed parser that supports all of your
        requested features (Note: this is subject to change if someone comes up
        with a better way of making this work).</p>
  </li>
  <li>SAX.ini
    <p class="Pp">ParserFactory will search <span class="Li">@INC</span> for a
        file called SAX.ini, which is in a simple format:</p>
    <p class="Pp"></p>
    <pre>  # a comment looks like this,
  ; or like this, and are stripped anywhere in the file
  key = value # SAX.in contains key/value pairs.
    </pre>
    <p class="Pp">All whitespace is non-significant.</p>
    <p class="Pp">This file can contain either a line:</p>
    <p class="Pp"></p>
    <pre>  ParserPackage = MyParserModule (1.02)
    </pre>
    <p class="Pp">Where MyParserModule is the module to load and use for the
        parser, and the number in brackets is a minimum version to load.</p>
    <p class="Pp">Or you can list required features:</p>
    <p class="Pp"></p>
    <pre>  http://xml.org/sax/features/validation = 1
    </pre>
    <p class="Pp">And each feature with a true value will be required.</p>
  </li>
  <li>Fallback
    <p class="Pp">If none of the above works, the last parser installed on the
        user's system will be used. The XML::SAX package ships with a pure perl
        XML parser, XML::SAX::PurePerl, so that there will always be a fallback
        parser.</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Matt Sergeant, matt@sergeant.org</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">This is free software, you may use it and distribute it under the
    same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-06-14</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

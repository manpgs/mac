<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Encode::PerlIO(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Encode::PerlIO(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Encode::PerlIO(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Encode::PerlIO -- a detailed document on Encode and PerlIO</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Overview"><a class="permalink" href="#Overview">Overview</a></h1>
<p class="Pp">It is very common to want to do encoding transformations when
    reading or writing files, network connections, pipes etc. If Perl is
    configured to use the new 'perlio' IO system then
    <span class="Li">&quot;Encode&quot;</span> provides a &quot;layer&quot; (see
    PerlIO) which can transform data as it is read or written.</p>
<p class="Pp">Here is how the blind poet would modernise the encoding:</p>
<p class="Pp"></p>
<pre>    use Encode;
    open(my $iliad,'&lt;:encoding(iso-8859-7)','iliad.greek');
    open(my $utf8,'&gt;:utf8','iliad.utf8');
    my @epic = &lt;$iliad&gt;;
    print $utf8 @epic;
    close($utf8);
    close($illiad);
</pre>
<p class="Pp">In addition, the new IO system can also be configured to
    read/write UTF-8 encoded characters (as noted above, this is efficient):</p>
<p class="Pp"></p>
<pre>    open(my $fh,'&gt;:utf8','anything');
    print $fh &quot;Any \x{0021} string \N{SMILEY FACE}\n&quot;;
</pre>
<p class="Pp">Either of the above forms of &quot;layer&quot; specifications can
    be made the default for a lexical scope with the <span class="Li">&quot;use
    open ...&quot;</span> pragma. See open.</p>
<p class="Pp">Once a handle is open, its layers can be altered using
    <span class="Li">&quot;binmode&quot;</span>.</p>
<p class="Pp">Without any such configuration, or if Perl itself is built using
    the system's own IO, then write operations assume that the file handle
    accepts only <i>bytes</i> and will <span class="Li">&quot;die&quot;</span>
    if a character larger than 255 is written to the handle. When reading, each
    octet from the handle becomes a byte-in-a-character. Note that this default
    is the same behaviour as bytes-only languages (including Perl before v5.6)
    would have, and is sufficient to handle native 8-bit encodings e.g.
    iso-8859-1, EBCDIC etc. and any legacy mechanisms for handling other
    encodings and binary data.</p>
<p class="Pp">In other cases, it is the program's responsibility to transform
    characters into bytes using the API above before doing writes, and to
    transform the bytes read from a handle into characters before doing
    &quot;character operations&quot; (e.g.
    <span class="Li">&quot;lc&quot;</span>,
    <span class="Li">&quot;/\W+/&quot;</span>, ...).</p>
<p class="Pp">You can also use PerlIO to convert larger amounts of data you
    don't want to bring into memory. For example, to convert between ISO-8859-1
    (Latin 1) and UTF-8 (or UTF-EBCDIC in EBCDIC machines):</p>
<p class="Pp"></p>
<pre>    open(F, &quot;&lt;:encoding(iso-8859-1)&quot;, &quot;data.txt&quot;) or die $!;
    open(G, &quot;&gt;:utf8&quot;,                 &quot;data.utf&quot;) or die $!;
    while (&lt;F&gt;) { print G }
    # Could also do &quot;print G &lt;F&gt;&quot; but that would pull
    # the whole file into memory just to write it out again.
</pre>
<p class="Pp">More examples:</p>
<p class="Pp"></p>
<pre>    open(my $f, &quot;&lt;:encoding(cp1252)&quot;)
    open(my $g, &quot;&gt;:encoding(iso-8859-2)&quot;)
    open(my $h, &quot;&gt;:encoding(latin9)&quot;)       # iso-8859-15
</pre>
<p class="Pp">See also encoding for how to change the default encoding of the
    data in your script.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="How_does_it_work?"><a class="permalink" href="#How_does_it_work?">How
  does it work?</a></h1>
<p class="Pp">Here is a crude diagram of how filehandle, PerlIO, and Encode
    interact.</p>
<p class="Pp"></p>
<pre>  filehandle &lt;-&gt; PerlIO        PerlIO &lt;-&gt; scalar (read/printed)
                       \      /
                        Encode
</pre>
<p class="Pp">When PerlIO receives data from either direction, it fills a buffer
    (currently with 1024 bytes) and passes the buffer to Encode. Encode tries to
    convert the valid part and passes it back to PerlIO, leaving invalid parts
    (usually a partial character) in the buffer. PerlIO then appends more data
    to the buffer, calls Encode again, and so on until the data stream ends.</p>
<p class="Pp">To do so, PerlIO always calls (de|en)code methods with CHECK set
    to 1. This ensures that the method stops at the right place when it
    encounters partial character. The following is what happens when PerlIO and
    Encode tries to encode (from utf8) more than 1024 bytes and the buffer
    boundary happens to be in the middle of a character.</p>
<p class="Pp"></p>
<pre>   A   B   C   ....   ~     \x{3000}    ....
  41  42  43   ....  7E   e3   80   80  ....
  &lt;- buffer ---------------&gt;
  &lt;&lt; encoded &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
                       &lt;- next buffer ------
</pre>
<p class="Pp">Encode converts from the beginning to \x7E, leaving \xe3 in the
    buffer because it is invalid (partial character).</p>
<p class="Pp">Unfortunately, this scheme does not work well with escape-based
    encodings such as ISO-2022-JP.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Line_Buffering"><a class="permalink" href="#Line_Buffering">Line
  Buffering</a></h1>
<p class="Pp">Now let's see what happens when you try to decode from ISO-2022-JP
    and the buffer ends in the middle of a character.</p>
<p class="Pp"></p>
<pre>              JIS208-ESC   \x{5f3e}
   A   B   C   ....   ~   \e   $   B  |DAN | ....
  41  42  43   ....  7E   1b  24  41  43  46 ....
  &lt;- buffer ---------------------------&gt;
  &lt;&lt; encoded &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
</pre>
<p class="Pp">As you see, the next buffer begins with \x43. But \x43 is 'C' in
    ASCII, which is wrong in this case because we are now in JISX 0208 area so
    it has to convert \x43\x46, not \x43. Unlike utf8 and EUC, in escape-based
    encodings you can't tell if a given octet is a whole character or just part
    of it.</p>
<p class="Pp">Fortunately PerlIO also supports line buffer if you tell PerlIO to
    use one instead of fixed buffer. Since ISO-2022-JP is guaranteed to revert
    to ASCII at the end of the line, partial character will never happen when
    line buffer is used.</p>
<p class="Pp">To tell PerlIO to use line buffer, implement -&gt;needs_lines
    method for your encoding object. See Encode::Encoding for details.</p>
<p class="Pp">Thanks to these efforts most encodings that come with Encode
    support PerlIO but that still leaves following encodings.</p>
<p class="Pp"></p>
<pre>  iso-2022-kr
  MIME-B
  MIME-Header
  MIME-Q
</pre>
<p class="Pp">Fortunately iso-2022-kr is hardly used (according to Jungshik) and
    MIME-* are very unlikely to be fed to PerlIO because they are for mail
    headers. See Encode::MIME::Header for details.</p>
<section class="Ss">
<h2 class="Ss" id="How_can_I_tell_whether_my_encoding_fully_supports_PerlIO_?"><a class="permalink" href="#How_can_I_tell_whether_my_encoding_fully_supports_PerlIO_?">How
  can I tell whether my encoding fully supports PerlIO ?</a></h2>
<p class="Pp">As of this writing, any encoding whose class belongs to Encode::XS
    and Encode::Unicode works. The Encode module has a
    <span class="Li">&quot;perlio_ok&quot;</span> method which you can use
    before applying PerlIO encoding to the filehandle. Here is an example:</p>
<p class="Pp"></p>
<pre>  my $use_perlio = perlio_ok($enc);
  my $layer = $use_perlio ? &quot;&lt;:raw&quot; : &quot;&lt;:encoding($enc)&quot;;
  open my $fh, $layer, $file or die &quot;$file : $!&quot;;
  while(&lt;$fh&gt;){
    $_ = decode($enc, $_) unless $use_perlio;
    # .... 
  }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Encode::Encoding, Encode::Supported, Encode::PerlIO, encoding,
    perlebcdic, &quot;open&quot; in perlfunc, perlunicode, utf8, the Perl
    Unicode Mailing List &lt;perl-unicode@perl.org&gt;</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

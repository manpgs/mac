<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Net::HTTP(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Net::HTTP(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Net::HTTP(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Net::HTTP - Low-level HTTP connection (client)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 6.19</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
 use Net::HTTP;
 my $s = Net::HTTP-&gt;new(Host =&gt; &quot;www.perl.com&quot;) || die $@;
 $s-&gt;write_request(GET =&gt; &quot;/&quot;, 'User-Agent' =&gt; &quot;Mozilla/5.0&quot;);
 my($code, $mess, %h) = $s-&gt;read_response_headers;

 while (1) {
    my $buf;
    my $n = $s-&gt;read_entity_body($buf, 1024);
    die &quot;read failed: $!&quot; unless defined $n;
    last unless $n;
    print $buf;
 }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The <span class="Li">&quot;Net::HTTP&quot;</span> class is a
    low-level HTTP client. An instance of the
    <span class="Li">&quot;Net::HTTP&quot;</span> class represents a connection
    to an HTTP server. The HTTP protocol is described in RFC 2616. The
    <span class="Li">&quot;Net::HTTP&quot;</span> class supports
    <span class="Li">&quot;HTTP/1.0&quot;</span> and
    <span class="Li">&quot;HTTP/1.1&quot;</span>.</p>
<p class="Pp"><span class="Li">&quot;Net::HTTP&quot;</span> is a sub-class of
    one of <span class="Li">&quot;IO::Socket::IP&quot;</span> (IPv6+IPv4),
    <span class="Li">&quot;IO::Socket::INET6&quot;</span> (IPv6+IPv4), or
    <span class="Li">&quot;IO::Socket::INET&quot;</span> (IPv4 only). You can
    mix the methods described below with reading and writing from the socket
    directly. This is not necessary a good idea, unless you know what you are
    doing.</p>
<p class="Pp">The following methods are provided (in addition to those of
    <span class="Li">&quot;IO::Socket::INET&quot;</span>):</p>
<dl class="Bl-tag">
  <dt>$s = Net::HTTP-&gt;new( %options )</dt>
  <dd>The <span class="Li">&quot;Net::HTTP&quot;</span> constructor method takes
      the same options as <span class="Li">&quot;IO::Socket::INET&quot;</span>'s
      as well as these:
    <p class="Pp"></p>
    <pre>
  Host:            Initial host attribute value
  KeepAlive:       Initial keep_alive attribute value
  SendTE:          Initial send_te attribute_value
  HTTPVersion:     Initial http_version attribute value
  PeerHTTPVersion: Initial peer_http_version attribute value
  MaxLineLength:   Initial max_line_length attribute value
  MaxHeaderLines:  Initial max_header_lines attribute value
    </pre>
    <p class="Pp">The <span class="Li">&quot;Host&quot;</span> option is also
        the default for <span class="Li">&quot;IO::Socket::INET&quot;</span>'s
        <span class="Li">&quot;PeerAddr&quot;</span>. The
        <span class="Li">&quot;PeerPort&quot;</span> defaults to 80 if not
        provided. The <span class="Li">&quot;PeerPort&quot;</span> specification
        can also be embedded in the <span class="Li">&quot;PeerAddr&quot;</span>
        by preceding it with a &quot;:&quot;, and closing the IPv6 address on
        brackets &quot;[]&quot; if necessary:
        &quot;192.0.2.1:80&quot;,&quot;[2001:db8::1]:80&quot;,&quot;any.example.com:80&quot;.</p>
    <p class="Pp">The <span class="Li">&quot;Listen&quot;</span> option provided
        by <span class="Li">&quot;IO::Socket::INET&quot;</span>'s constructor
        method is not allowed.</p>
    <p class="Pp">If unable to connect to the given HTTP server then the
        constructor returns <span class="Li">&quot;undef&quot;</span> and $@
        contains the reason. After a successful connect, a
        <span class="Li">&quot;Net:HTTP&quot;</span> object is returned.</p>
  </dd>
  <dt>$s-&gt;host</dt>
  <dd>Get/set the default value of the <span class="Li">&quot;Host&quot;</span>
      header to send. The <span class="Li">$host</span> must not be set to an
      empty string (or <span class="Li">&quot;undef&quot;</span>) for
    HTTP/1.1.</dd>
  <dt>$s-&gt;keep_alive</dt>
  <dd>Get/set the <i>keep-alive</i> value. If this value is TRUE then the
      request will be sent with headers indicating that the server should try to
      keep the connection open so that multiple requests can be sent.
    <p class="Pp">The actual headers set will depend on the value of the
        <span class="Li">&quot;http_version&quot;</span> and
        <span class="Li">&quot;peer_http_version&quot;</span> attributes.</p>
  </dd>
  <dt>$s-&gt;send_te</dt>
  <dd>Get/set the a value indicating if the request will be sent with a
      &quot;TE&quot; header to indicate the transfer encodings that the server
      can choose to use. The list of encodings announced as accepted by this
      client depends on availability of the following modules:
      <span class="Li">&quot;Compress::Raw::Zlib&quot;</span> for
      <i>deflate</i>, and
      <span class="Li">&quot;IO::Compress::Gunzip&quot;</span> for
    <i>gzip</i>.</dd>
  <dt>$s-&gt;http_version</dt>
  <dd>Get/set the HTTP version number that this client should announce. This
      value can only be set to &quot;1.0&quot; or &quot;1.1&quot;. The default
      is &quot;1.1&quot;.</dd>
  <dt>$s-&gt;peer_http_version</dt>
  <dd>Get/set the protocol version number of our peer. This value will initially
      be &quot;1.0&quot;, but will be updated by a successful
      <b>read_response_headers()</b> method call.</dd>
  <dt>$s-&gt;max_line_length</dt>
  <dd>Get/set a limit on the length of response line and response header lines.
      The default is 8192. A value of 0 means no limit.</dd>
  <dt>$s-&gt;max_header_length</dt>
  <dd>Get/set a limit on the number of header lines that a response can have.
      The default is 128. A value of 0 means no limit.</dd>
  <dt>$s-&gt;format_request($method, $uri, %headers, [$content])</dt>
  <dd>Format a request message and return it as a string. If the headers do not
      include a <span class="Li">&quot;Host&quot;</span> header, then a header
      is inserted with the value of the <span class="Li">&quot;host&quot;</span>
      attribute. Headers like <span class="Li">&quot;Connection&quot;</span> and
      <span class="Li">&quot;Keep-Alive&quot;</span> might also be added
      depending on the status of the
      <span class="Li">&quot;keep_alive&quot;</span> attribute.
    <p class="Pp">If <span class="Li">$content</span> is given (and it is
        non-empty), then a <span class="Li">&quot;Content-Length&quot;</span>
        header is automatically added unless it was already present.</p>
  </dd>
  <dt>$s-&gt;write_request($method, $uri, %headers, [$content])</dt>
  <dd>Format and send a request message. Arguments are the same as for
      <b>format_request()</b>. Returns true if successful.</dd>
  <dt>$s-&gt;format_chunk( $data )</dt>
  <dd>Returns the string to be written for the given chunk of data.</dd>
  <dt>$s-&gt;write_chunk($data)</dt>
  <dd>Will write a new chunk of request entity body data. This method should
      only be used if the <span class="Li">&quot;Transfer-Encoding&quot;</span>
      header with a value of <span class="Li">&quot;chunked&quot;</span> was
      sent in the request. Note, writing zero-length data is a no-op. Use the
      <b>write_chunk_eof()</b> method to signal end of entity body data.
    <p class="Pp">Returns true if successful.</p>
  </dd>
  <dt>$s-&gt;format_chunk_eof( %trailers )</dt>
  <dd>Returns the string to be written for signaling EOF when a
      <span class="Li">&quot;Transfer-Encoding&quot;</span> of
      <span class="Li">&quot;chunked&quot;</span> is used.</dd>
  <dt>$s-&gt;write_chunk_eof( %trailers )</dt>
  <dd>Will write eof marker for chunked data and optional trailers. Note that
      trailers should not really be used unless is was signaled with a
      <span class="Li">&quot;Trailer&quot;</span> header.
    <p class="Pp">Returns true if successful.</p>
  </dd>
  <dt>($code, $mess, %headers) = $s-&gt;read_response_headers( %opts )</dt>
  <dd>Read response headers from server and return it. The
      <span class="Li">$code</span> is the 3 digit HTTP status code (see
      HTTP::Status) and <span class="Li">$mess</span> is the textual message
      that came with it. Headers are then returned as key/value pairs. Since key
      letter casing is not normalized and the same key can even occur multiple
      times, assigning these values directly to a hash is not wise. Only the
      <span class="Li">$code</span> is returned if this method is called in
      scalar context.
    <p class="Pp">As a side effect this method updates the 'peer_http_version'
        attribute.</p>
    <p class="Pp">Options might be passed in as key/value pairs. There are
        currently only two options supported;
        <span class="Li">&quot;laxed&quot;</span> and
        <span class="Li">&quot;junk_out&quot;</span>.</p>
    <p class="Pp">The <span class="Li">&quot;laxed&quot;</span> option will make
        <b>read_response_headers()</b> more forgiving towards servers that have
        not learned how to speak HTTP properly. The
        <span class="Li">&quot;laxed&quot;</span> option is a boolean flag, and
        is enabled by passing in a TRUE value. The
        <span class="Li">&quot;junk_out&quot;</span> option can be used to
        capture bad header lines when <span class="Li">&quot;laxed&quot;</span>
        is enabled. The value should be an array reference. Bad header lines
        will be pushed onto the array.</p>
    <p class="Pp">The <span class="Li">&quot;laxed&quot;</span> option must be
        specified in order to communicate with pre-HTTP/1.0 servers that don't
        describe the response outcome or the data they send back with a header
        block. For these servers peer_http_version is set to &quot;0.9&quot; and
        this method returns (200, &quot;Assumed OK&quot;).</p>
    <p class="Pp">The method will raise an exception (die) if the server does
        not speak proper HTTP or if the
        <span class="Li">&quot;max_line_length&quot;</span> or
        <span class="Li">&quot;max_header_length&quot;</span> limits are
        reached. If the <span class="Li">&quot;laxed&quot;</span> option is
        turned on and <span class="Li">&quot;max_line_length&quot;</span> and
        <span class="Li">&quot;max_header_length&quot;</span> checks are turned
        off, then no exception will be raised and this method will always return
        a response code.</p>
  </dd>
  <dt>$n = $s-&gt;read_entity_body($buf, $size);</dt>
  <dd>Reads chunks of the entity body content. Basically the same interface as
      for <b>read()</b> and <b>sysread()</b>, but the buffer offset argument is
      not supported yet. This method should only be called after a successful
      <b>read_response_headers()</b> call.
    <p class="Pp">The return value will be
        <span class="Li">&quot;undef&quot;</span> on read errors, 0 on EOF, -1
        if no data could be returned this time, otherwise the number of bytes
        assigned to <span class="Li">$buf</span>. The
        <span class="Li">$buf</span> is set to &quot;&quot; when the return
        value is -1.</p>
    <p class="Pp">You normally want to retry this call if this function returns
        either -1 or <span class="Li">&quot;undef&quot;</span> with
        <span class="Li">$!</span> as EINTR or EAGAIN (see Errno). EINTR can
        happen if the application catches signals and EAGAIN can happen if you
        made the socket non-blocking.</p>
    <p class="Pp">This method will raise exceptions (die) if the server does not
        speak proper HTTP. This can only happen when reading chunked data.</p>
  </dd>
  <dt>%headers = $s-&gt;get_trailers</dt>
  <dd>After <b>read_entity_body()</b> has returned 0 to indicate end of the
      entity body, you might call this method to pick up any trailers.</dd>
  <dt>$s-&gt;_rbuf</dt>
  <dd>Get/set the read buffer content. The <b>read_response_headers()</b> and
      <b>read_entity_body()</b> methods use an internal buffer which they will
      look for data before they actually sysread more from the socket itself. If
      they read too much, the remaining data will be left in this buffer.</dd>
  <dt>$s-&gt;_rbuf_length</dt>
  <dd>Returns the number of bytes in the read buffer. This should always be the
      same as:
    <p class="Pp"></p>
    <pre>
    length($s-&gt;_rbuf)
    </pre>
    <p class="Pp">but might be more efficient.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SUBCLASSING"><a class="permalink" href="#SUBCLASSING">SUBCLASSING</a></h1>
<p class="Pp">The <b>read_response_headers()</b> and <b>read_entity_body()</b>
    will invoke the <b>sysread()</b> method when they need more data. Subclasses
    might want to override this method to control how reading takes place.</p>
<p class="Pp">The object itself is a glob. Subclasses should avoid using hash
    key names prefixed with <span class="Li">&quot;http_&quot;</span> and
    <span class="Li">&quot;io_&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">LWP, IO::Socket::INET, Net::HTTP::NB</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Gisle Aas &lt;gisle@activestate.com&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2001-2017 by Gisle Aas.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-05-16</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

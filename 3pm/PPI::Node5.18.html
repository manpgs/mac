<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PPI::Node(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PPI::Node(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">PPI::Node(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">PPI::Node - Abstract PPI Node class, an Element that can contain
    other Elements</p>
</section>
<section class="Sh">
<h1 class="Sh" id="INHERITANCE"><a class="permalink" href="#INHERITANCE">INHERITANCE</a></h1>
<pre>
  PPI::Node
  isa PPI::Element
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
  # Create a typical node (a Document in this case)
  my $Node = PPI::Document-&gt;new;
  
  # Add an element to the node( in this case, a token )
  my $Token = PPI::Token::Word-&gt;new('my');
  $Node-&gt;add_element( $Token );
  
  # Get the elements for the Node
  my @elements = $Node-&gt;children;
  
  # Find all the barewords within a Node
  my $barewords = $Node-&gt;find( 'PPI::Token::Word' );
  
  # Find by more complex criteria
  my $my_tokens = $Node-&gt;find( sub { $_[1]-&gt;content eq 'my' } );
  
  # Remove all the whitespace
  $Node-&gt;prune( 'PPI::Token::Whitespace' );
  
  # Remove by more complex criteria
  $Node-&gt;prune( sub { $_[1]-&gt;content eq 'my' } );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The <span class="Li">&quot;PPI::Node&quot;</span> class provides
    an abstract base class for the Element classes that are able to contain
    other elements PPI::Document, PPI::Statement, and PPI::Structure.</p>
<p class="Pp">As well as those listed below, all of the methods that apply to
    PPI::Element objects also apply to
    <span class="Li">&quot;PPI::Node&quot;</span> objects.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="scope"><a class="permalink" href="#scope">scope</a></h2>
<p class="Pp">The <span class="Li">&quot;scope&quot;</span> method returns true
    if the node represents a lexical scope boundary, or false if it does
  not.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="add_element_$Element"><a class="permalink" href="#add_element_$Element">add_element
  $Element</a></h2>
<p class="Pp">The <span class="Li">&quot;add_element&quot;</span> method adds a
    PPI::Element object to the end of a
    <span class="Li">&quot;PPI::Node&quot;</span>. Because Elements maintain
    links to their parent, an Element can only be added to a single Node.</p>
<p class="Pp">Returns true if the PPI::Element was added. Returns
    <span class="Li">&quot;undef&quot;</span> if the Element was already within
    another Node, or the method is not passed a PPI::Element object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="elements"><a class="permalink" href="#elements">elements</a></h2>
<p class="Pp">The <span class="Li">&quot;elements&quot;</span> method accesses
    all child elements <b>structurally</b> within the
    <span class="Li">&quot;PPI::Node&quot;</span> object. Note that in the base
    of the PPI::Structure classes, this <span class="Li">&quot;DOES&quot;</span>
    include the brace tokens at either end of the structure.</p>
<p class="Pp">Returns a list of zero or more PPI::Element objects.</p>
<p class="Pp">Alternatively, if called in the scalar context, the
    <span class="Li">&quot;elements&quot;</span> method returns a count of the
    number of elements.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="first_element"><a class="permalink" href="#first_element">first_element</a></h2>
<p class="Pp">The <span class="Li">&quot;first_element&quot;</span> method
    accesses the first element structurally within the
    <span class="Li">&quot;PPI::Node&quot;</span> object. As for the
    <span class="Li">&quot;elements&quot;</span> method, this does include the
    brace tokens for PPI::Structure objects.</p>
<p class="Pp">Returns a PPI::Element object, or
    <span class="Li">&quot;undef&quot;</span> if for some reason the
    <span class="Li">&quot;PPI::Node&quot;</span> object does not contain any
    elements.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="last_element"><a class="permalink" href="#last_element">last_element</a></h2>
<p class="Pp">The <span class="Li">&quot;last_element&quot;</span> method
    accesses the last element structurally within the
    <span class="Li">&quot;PPI::Node&quot;</span> object. As for the
    <span class="Li">&quot;elements&quot;</span> method, this does include the
    brace tokens for PPI::Structure objects.</p>
<p class="Pp">Returns a PPI::Element object, or
    <span class="Li">&quot;undef&quot;</span> if for some reason the
    <span class="Li">&quot;PPI::Node&quot;</span> object does not contain any
    elements.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="children"><a class="permalink" href="#children">children</a></h2>
<p class="Pp">The <span class="Li">&quot;children&quot;</span> method accesses
    all child elements lexically within the
    <span class="Li">&quot;PPI::Node&quot;</span> object. Note that in the case
    of the PPI::Structure classes, this does <b>NOT</b> include the brace tokens
    at either end of the structure.</p>
<p class="Pp">Returns a list of zero of more PPI::Element objects.</p>
<p class="Pp">Alternatively, if called in the scalar context, the
    <span class="Li">&quot;children&quot;</span> method returns a count of the
    number of lexical children.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="schildren"><a class="permalink" href="#schildren">schildren</a></h2>
<p class="Pp">The <span class="Li">&quot;schildren&quot;</span> method is really
    just a convenience, the significant-only variation of the normal
    <span class="Li">&quot;children&quot;</span> method.</p>
<p class="Pp">In list context, returns a list of significant children. In scalar
    context, returns the number of significant children.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="child_$index"><a class="permalink" href="#child_$index">child
  $index</a></h2>
<p class="Pp">The <span class="Li">&quot;child&quot;</span> method accesses a
    child PPI::Element object by its position within the Node.</p>
<p class="Pp">Returns a PPI::Element object, or
    <span class="Li">&quot;undef&quot;</span> if there is no child element at
    that node.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="schild_$index"><a class="permalink" href="#schild_$index">schild
  $index</a></h2>
<p class="Pp">The lexical structure of the Perl language ignores 'insignificant'
    items, such as whitespace and comments, while PPI treats these items as
    valid tokens so that it can reassemble the file at any time. Because of
    this, in many situations there is a need to find an Element within a Node by
    index, only counting lexically significant Elements.</p>
<p class="Pp">The <span class="Li">&quot;schild&quot;</span> method returns a
    child Element by index, ignoring insignificant Elements. The index of a
    child Element is specified in the same way as for a normal array, with the
    first Element at index 0, and negative indexes used to identify a &quot;from
    the end&quot; position.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="contains_$Element"><a class="permalink" href="#contains_$Element">contains
  $Element</a></h2>
<p class="Pp">The <span class="Li">&quot;contains&quot;</span> method is used to
    determine if another PPI::Element object is logically &quot;within&quot; a
    <span class="Li">&quot;PPI::Node&quot;</span>. For the special case of the
    brace tokens at either side of a PPI::Structure object, they are generally
    considered &quot;within&quot; a PPI::Structure object, even if they are not
    actually in the elements for the PPI::Structure.</p>
<p class="Pp">Returns true if the PPI::Element is within us, false if not, or
    <span class="Li">&quot;undef&quot;</span> on error.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="find_$class___"><a class="permalink" href="#find_$class___">find
  $class | \&amp;wanted</a></h2>
<p class="Pp">The <span class="Li">&quot;find&quot;</span> method is used to
    search within a code tree for PPI::Element objects that meet a particular
    condition.</p>
<p class="Pp">To specify the condition, the method can be provided with either a
    simple class name (full or shortened), or a
    <span class="Li">&quot;CODE&quot;</span>/function reference.</p>
<p class="Pp"></p>
<pre>
  # Find all single quotes in a Document (which is a Node)
  $Document-&gt;find('PPI::Quote::Single');
  
  # The same thing with a shortened class name
  $Document-&gt;find('Quote::Single');
  
  # Anything more elaborate, we so with the sub
  $Document-&gt;find( sub {
        # At the top level of the file...
        $_[1]-&gt;parent == $_[0]
        and (
                # ...find all comments and POD
                $_[1]-&gt;isa('PPI::Token::Pod')
                or
                $_[1]-&gt;isa('PPI::Token::Comment')
        )
  } );
</pre>
<p class="Pp">The function will be passed two arguments, the top-level
    <span class="Li">&quot;PPI::Node&quot;</span> you are searching in and the
    current PPI::Element that the condition is testing.</p>
<p class="Pp">The anonymous function should return one of three values.
    Returning true indicates a condition match, defined-false
    (<span class="Li">0</span> or <span class="Li">''</span>) indicates
    no-match, and <span class="Li">&quot;undef&quot;</span> indicates no-match
    and no-descend.</p>
<p class="Pp">In the last case, the tree walker will skip over anything below
    the <span class="Li">&quot;undef&quot;</span>-returning element and move on
    to the next element at the same level.</p>
<p class="Pp">To halt the entire search and return
    <span class="Li">&quot;undef&quot;</span> immediately, a condition function
    should throw an exception (i.e.
  <span class="Li">&quot;die&quot;</span>).</p>
<p class="Pp">Note that this same wanted logic is used for all methods
    documented to have a <span class="Li">&quot;\&amp;wanted&quot;</span>
    parameter, as this one does.</p>
<p class="Pp">The <span class="Li">&quot;find&quot;</span> method returns a
    reference to an array of PPI::Element objects that match the condition,
    false (but defined) if no Elements match the condition, or
    <span class="Li">&quot;undef&quot;</span> if you provide a bad condition, or
    an error occurs during the search process.</p>
<p class="Pp">In the case of a bad condition, a warning will be emitted as
  well.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="find_first_$class___"><a class="permalink" href="#find_first_$class___">find_first
  $class | \&amp;wanted</a></h2>
<p class="Pp">If the normal <span class="Li">&quot;find&quot;</span> method is
    like a grep, then <span class="Li">&quot;find_first&quot;</span> is
    equivalent to the Scalar::Util <span class="Li">&quot;first&quot;</span>
    function.</p>
<p class="Pp">Given an element class or a wanted function, it will search
    depth-first through a tree until it finds something that matches the
    condition, returning the first Element that it encounters.</p>
<p class="Pp">See the <span class="Li">&quot;find&quot;</span> method for
    details on the format of the search condition.</p>
<p class="Pp">Returns the first PPI::Element object that matches the condition,
    false if nothing matches the condition, or
    <span class="Li">&quot;undef&quot;</span> if given an invalid condition, or
    an error occurs.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="find_any_$class___"><a class="permalink" href="#find_any_$class___">find_any
  $class | \&amp;wanted</a></h2>
<p class="Pp">The <span class="Li">&quot;find_any&quot;</span> method is a
    short-circuiting true/false method that behaves like the normal
    <span class="Li">&quot;find&quot;</span> method, but returns true as soon as
    it finds any Elements that match the search condition.</p>
<p class="Pp">See the <span class="Li">&quot;find&quot;</span> method for
    details on the format of the search condition.</p>
<p class="Pp">Returns true if any Elements that match the condition can be
    found, false if not, or <span class="Li">&quot;undef&quot;</span> if given
    an invalid condition, or an error occurs.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="remove_child_$Element"><a class="permalink" href="#remove_child_$Element">remove_child
  $Element</a></h2>
<p class="Pp">If passed a PPI::Element object that is a direct child of the
    Node, the <span class="Li">&quot;remove_element&quot;</span> method will
    remove the <span class="Li">&quot;Element&quot;</span> intact, along with
    any of its children. As such, this method acts essentially as a 'cut'
    function.</p>
<p class="Pp">If successful, returns the removed element. Otherwise, returns
    <span class="Li">&quot;undef&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="prune_$class___"><a class="permalink" href="#prune_$class___">prune
  $class | \&amp;wanted</a></h2>
<p class="Pp">The <span class="Li">&quot;prune&quot;</span> method is used to
    strip PPI::Element objects out of a code tree. The argument is the same as
    for the <span class="Li">&quot;find&quot;</span> method, either a class
    name, or an anonymous subroutine which returns true/false. Any Element that
    matches the class|wanted will be deleted from the code tree, along with any
    of its children.</p>
<p class="Pp">The <span class="Li">&quot;prune&quot;</span> method returns the
    number of <span class="Li">&quot;Element&quot;</span> objects that matched
    and were removed, <b>non-recursively</b>. This might also be zero, so avoid
    a simple true/false test on the return false of the
    <span class="Li">&quot;prune&quot;</span> method. It returns
    <span class="Li">&quot;undef&quot;</span> on error, which you probably
    <b>should</b> test for.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TO_DO"><a class="permalink" href="#TO_DO">TO DO</a></h1>
<p class="Pp">- Move as much as possible to PPI::XS</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
<p class="Pp">See the support section in the main module.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Adam Kennedy &lt;adamk@cpan.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 2001 - 2011 Adam Kennedy.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">The full text of the license can be found in the LICENSE file
    included with this module.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2011-02-25</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

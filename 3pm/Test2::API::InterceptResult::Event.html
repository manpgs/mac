<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Test2::API::InterceptResult::Event(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Test2::API::InterceptResult::Event(3pm)</td>
    <td class="head-vol"><a href=".">Perl Programmers Reference Guide</a></td>
    <td class="head-rtitle">Test2::API::InterceptResult::Event(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Test2::API::InterceptResult::Event - Representation of an event
    for use in testing other test tools.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><span class="Li">&quot;intercept { ... }&quot;</span> from
    Test2::API returns an instance of Test2::API::InterceptResult which is a
    blessed arrayref of Test2::API::InterceptResult::Event objects.</p>
<p class="Pp">This POD documents the methods of these events, which are mainly
    provided for you to use when testing your test tools.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use Test2::V0;
    use Test2::API qw/intercept/;
    my $events = intercept {
        ok(1, &quot;A passing assertion&quot;);
        plan(1);
    };
    # This will convert all events into instances of
    # Test2::API::InterceptResult::Event. Until we do this they are the
    # original Test::Event::* instances
    $events-&gt;upgrade(in_place =&gt; 1);
    # Now we can get individual events in this form
    my $assert = $events-&gt;[0];
    my $plan   = $events-&gt;[1];
    # Or we can operate on all events at once:
    my $flattened = $events-&gt;flatten;
    is(
        $flattened,
        [
          {
            causes_failure =&gt; 0,
            name =&gt; 'A passing assertion',
            pass =&gt; 1,
            trace_file =&gt; 'xxx.t',
            trace_line =&gt; 5,
          },
          {
            causes_failure =&gt; 0,
            plan =&gt; 1,
            trace_file =&gt; 'xxx.t',
            trace_line =&gt; 6,
          },
        ],
        &quot;Flattened both events and returned an arrayref of the results
    );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="!!!_"><a class="permalink" href="#!!!_">!!! IMPORTANT NOTES
  ON DESIGN !!!</a></h2>
<p class="Pp">Please pay attention to what these return, many return a scalar
    when applicable or an empty list when not (as opposed to undef). Many also
    always return a list of 0 or more items. Some always return a scalar. Note
    that none of the methods care about context, their behavior is consistent
    regardless of scalar, list, or void context.</p>
<p class="Pp">This was done because this class was specifically designed to be
    used in a list and generate more lists in bulk operations. Sometimes in a
    map you want nothing to show up for the event, and you do not want an undef
    in its place. In general single event instances are not going to be used
    alone, though that is allowed.</p>
<p class="Pp">As a general rule any method prefixed with
    <span class="Li">&quot;the_&quot;</span> implies the event should have
    exactly 1 of the specified item, and and exception will be thrown if there
    are 0, or more than 1 of the item.</p>
</section>
<section class="Ss">
<h2 class="Ss">ATTRIBUTES</h2>
<dl class="Bl-tag">
  <dt>$hashref = $event-&gt;facet_data</dt>
  <dd>This will return the facet data hashref, which is all Test2 cares about
      for any given event.</dd>
  <dt>$class = $event-&gt;result_class</dt>
  <dd>This is normally Test2::API::InterceptResult. This is set at construction
      so that subtest results can be turned into instances of it on demand.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">DUPLICATION</h2>
<dl class="Bl-tag">
  <dt>$copy = $event-&gt;clone</dt>
  <dd>Create a deep copy of the event. Modifying either event will not effect
      the other.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">CONDENSED MULTI-FACET DATA</h2>
<dl class="Bl-tag">
  <dt>$bool = $event-&gt;causes_failure</dt>
  <dd></dd>
  <dt>$bool = $event-&gt;causes_fail</dt>
  <dd>These are both aliases of the same functionality.
    <p class="Pp">This will always return either a true value, or a false value.
        This never returns a list.</p>
    <p class="Pp">This method may be relatively slow (still super fast) because
        it determines pass or fail by creating an instance of Test2::Hub and
        asking it to process the event, and then asks the hub for its pass/fail
        state. This is slower than bulding in logic to do the check, but it is
        more reliable as it will always tell you what the hub thinks, so the
        logic will never be out of date relative to the Test2 logic that
        actually cares.</p>
  </dd>
  <dt id="STRING_OR_EMPTY_LIST"><a class="permalink" href="#STRING_OR_EMPTY_LIST">STRING_OR_EMPTY_LIST
    = $event-&gt;brief</a></dt>
  <dd>Not all events have a brief, some events are not rendered by the
      formatter, others have no &quot;brief&quot; data worth seeing. When this
      is the case an empty list is returned. This is done intentionally so it
      can be used in a map operation without having
      <span class="Li">&quot;undef&quot;</span> being included in the result.
    <p class="Pp">When a brief can be generated it is always a single 1-line
        string, and is returned as-is, not in a list.</p>
    <p class="Pp">Possible briefs:</p>
    <p class="Pp"></p>
    <pre>    # From control facets
    &quot;BAILED OUT&quot;
    &quot;BAILED OUT: $why&quot;
    # From error facets
    &quot;ERROR&quot;
    &quot;ERROR: $message&quot;
    &quot;ERROR: $partial_message [...]&quot;
    &quot;ERRORS: $first_error_message [...]&quot;
    # From assert facets
    &quot;PASS&quot;
    &quot;FAIL&quot;
    &quot;PASS with amnesty&quot;
    &quot;FAIL with amnesty&quot;
    # From plan facets
    &quot;PLAN $count&quot;
    &quot;NO PLAN&quot;
    &quot;SKIP ALL&quot;
    &quot;SKIP ALL: $why&quot;
    </pre>
    <p class="Pp">Note that only the first applicable brief is returned. This is
        essnetially a poor-mans TAP that only includes facets that could (but
        not necessarily do) cause a failure.</p>
  </dd>
  <dt>$hashref = $event-&gt;flatten</dt>
  <dd></dd>
  <dt>$hashref = $event-&gt;flatten(include_subevents =&gt; 1)</dt>
  <dd>This ALWAYS returns a hashref. This puts all the most useful data for the
      most interesting facets into a single hashref for easy validation.
    <p class="Pp">If there are no meaningful facets this will return an empty
        hashref.</p>
    <p class="Pp">If given the 'include_subevents' parameter it will also
        include subtest data:</p>
    <p class="Pp">Here is a list of EVERY possible field. If a field is not
        applicable it will not be present.</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="always"><a class="permalink" href="#always">always present</a></dt>
  <dd>
    <pre>        causes_failure =&gt; 1,    # Always present
    </pre>
  </dd>
  <dt id="Present"><a class="permalink" href="#Present">Present if the event has
    a trace facet</a></dt>
  <dd>
    <pre>        trace_line    =&gt; 42,
        trace_file    =&gt; 'Foo/Bar.pm',
        trace_details =&gt; 'Extra trace details',    # usually not present
    </pre>
  </dd>
  <dt id="If"><a class="permalink" href="#If">If an assertion is
    present</a></dt>
  <dd>
    <pre>        pass =&gt; 0,
        name =&gt; &quot;1 + 1 = 2, so math works&quot;,
    </pre>
  </dd>
  <dt id="If~2"><a class="permalink" href="#If~2">If a plan is present:</a></dt>
  <dd>
    <pre>        plan =&gt; $count_or_SKIP_ALL_or_NO_PLAN,
    </pre>
  </dd>
  <dt id="If~3"><a class="permalink" href="#If~3">If amnesty facets are
    present</a></dt>
  <dd>You get an array for each type that is present.
    <p class="Pp"></p>
    <pre>        todo =&gt; [    # Yes you could be under multiple todos, this will list them all.
            &quot;I will fix this later&quot;,
            &quot;I promise to fix these&quot;,
        ],
        skip =&gt; [&quot;This will format the main drive, do not run&quot;],
        ... =&gt; [&quot;Other amnesty&quot;]
    </pre>
  </dd>
  <dt id="If~4"><a class="permalink" href="#If~4">If Info (note/diag) facets are
    present</a></dt>
  <dd>You get an arrayref for any that are present, the key is not defined if
      they are not present.
    <p class="Pp"></p>
    <pre>        diag =&gt; [
            &quot;Test failed at Foo/Bar.pm line 42&quot;,
            &quot;You forgot to tie your boots&quot;,
        ],
        note =&gt; [&quot;Your boots are red&quot;],
        ...  =&gt; [&quot;Other info&quot;],
    </pre>
  </dd>
  <dt id="If~5"><a class="permalink" href="#If~5">If error facets are
    present</a></dt>
  <dd>Always an arrayref
    <p class="Pp"></p>
    <pre>        error =&gt; [
            &quot;non fatal error (does not cause test failure, just an FYI&quot;,
            &quot;FATAL: This is a fatal error (causes failure)&quot;,
        ],
        # Errors can have alternative tags, but in practice are always 'error',
        # listing this for completeness.
        ... =&gt; [ ... ]
    </pre>
  </dd>
  <dt id="Present~2"><a class="permalink" href="#Present~2">Present if the event
    is a subtest</a></dt>
  <dd>
    <pre>        subtest =&gt; {
            count      =&gt; 2,    # Number of assertions made
            failed     =&gt; 1,    # Number of test failures seen
            is_passing =&gt; 0,    # Boolean, true if the test would be passing
                                # after the events are processed.
            plan         =&gt; 2,  # Plan, either a number, undef, 'SKIP', or 'NO PLAN'
            follows_plan =&gt; 1,  # True if there is a plan and it was followed.
                                # False if the plan and assertions did not
                                # match, undef if no plan was present in the
                                # event list.
            bailed_out =&gt; &quot;foo&quot;,    # if there was a bail-out in the
                                    # events in this will be a string explaining
                                    # why there was a bailout, if no reason was
                                    # given this will simply be set to true (1).
            skip_reason =&gt; &quot;foo&quot;,   # If there was a skip_all this will give the
                                    # reason.
        },
    </pre>
    <p class="Pp">if <span class="Li">&quot;(include_subtest =&gt;
        1)&quot;</span> was provided as a parameter then the following will be
        included. This is the result of turning all subtest child events into an
        Test2::API::InterceptResult instance and calling the
        <span class="Li">&quot;flatten&quot;</span> method on it.</p>
    <p class="Pp"></p>
    <pre>        subevents =&gt; Test2::API::InterceptResult-&gt;new(@child_events)-&gt;flatten(...),
    </pre>
  </dd>
  <dt id="If~6"><a class="permalink" href="#If~6">If a bail-out is being
    requested</a></dt>
  <dd>If no reason was given this will be set to 1.
    <p class="Pp"></p>
    <pre>        bailed_out =&gt; &quot;reason&quot;,
    </pre>
  </dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>$hashref = $event-&gt;<b>summary()</b></dt>
  <dd>This returns a limited summary. See
      <span class="Li">&quot;flatten()&quot;</span>, which is usually a better
      option.
    <p class="Pp"></p>
    <pre>    {
        brief =&gt; $event-&gt;brief || '',
        causes_failure =&gt; $event-&gt;causes_failure,
        trace_line    =&gt; $event-&gt;trace_line,
        trace_file    =&gt; $event-&gt;trace_file,
        trace_tool    =&gt; $event-&gt;trace_subname,
        trace_details =&gt; $event-&gt;trace_details,
        facets =&gt; [ sort keys(%{$event-&gt;{+FACET_DATA}}) ],
    }
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">DIRECT ARBITRARY FACET ACCESS</h2>
<dl class="Bl-tag">
  <dt>@list_of_facets = $event-&gt;facet($name)</dt>
  <dd>This always returns a list of 0 or more items. This fetches the facet
      instances from the event. For facets like 'assert' this will always return
      0 or 1 item. For events like 'info' (diags, notes) this will return 0 or
      more instances, once for each instance of the facet.
    <p class="Pp">These will be blessed into the proper Test2::EventFacet
        subclass. If no subclass can be found it will be blessed as an
        Test2::API::InterceptResult::Facet generic facet class.</p>
  </dd>
  <dt>$undef_or_facet = $event-&gt;the_facet($name)</dt>
  <dd>If you know you will have exactly 1 instance of a facet you can call this.
    <p class="Pp">If you are correct and there is exactly one instance of the
        facet it will always return the hashref.</p>
    <p class="Pp">If there are 0 instances of the facet this will reutrn undef,
        not an empty list.</p>
    <p class="Pp">If there are more than 1 instance this will throw an exception
        because your assumption was incorrect.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">TRACE FACET</h2>
<dl class="Bl-tag">
  <dt>@list_of_facets = $event-&gt;trace</dt>
  <dd>TODO</dd>
  <dt>$undef_or_hashref = $event-&gt;the_trace</dt>
  <dd>This returns the trace hashref, or undef if it is not present.</dd>
  <dt>$undef_or_arrayref = $event-&gt;frame</dt>
  <dd>If a trace is present, and has a caller frame, this will be an arrayref:
    <p class="Pp"></p>
    <pre>    [$package, $file, $line, $subname]
    </pre>
    <p class="Pp">If the trace is not present, or has no caller frame this will
        return undef.</p>
  </dd>
  <dt>$undef_or_string = $event-&gt;trace_details</dt>
  <dd>This is usually undef, but occasionally has a string that overrides the
      file/line number debugging a trace usually provides on test failure.</dd>
  <dt>$undef_or_string = $event-&gt;trace_package</dt>
  <dd>Same as <span class="Li">&quot;(caller())[0]&quot;</span>, the first
      element of the trace frame.
    <p class="Pp">Will be undef if not present.</p>
  </dd>
  <dt>$undef_or_string = $event-&gt;trace_file</dt>
  <dd>Same as <span class="Li">&quot;(caller())[1]&quot;</span>, the second
      element of the trace frame.
    <p class="Pp">Will be undef if not present.</p>
  </dd>
  <dt>$undef_or_integer = $event-&gt;trace_line</dt>
  <dd>Same as <span class="Li">&quot;(caller())[2]&quot;</span>, the third
      element of the trace frame.
    <p class="Pp">Will be undef if not present.</p>
  </dd>
  <dt>$undef_or_string = $event-&gt;trace_subname</dt>
  <dd></dd>
  <dt>$undef_or_string = $event-&gt;trace_tool</dt>
  <dd>Aliases for the same thing
    <p class="Pp">Same as
        <span class="Li">&quot;(caller($level))[4]&quot;</span>, the fourth
        element of the trace frame.</p>
    <p class="Pp">Will be undef if not present.</p>
  </dd>
  <dt>$undef_or_string = $event-&gt;trace_signature</dt>
  <dd>A string that is a unique signature for the trace. If a single context
      generates multiple events they will all have the same signature. This can
      be used to tie assertions and diagnostics sent as seperate events together
      after the fact.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">ASSERT FACET</h2>
<dl class="Bl-tag">
  <dt>$bool = $event-&gt;has_assert</dt>
  <dd>Returns true if the event has an assert facet, false if it does not.</dd>
  <dt>$undef_or_hashref = $event-&gt;the_assert</dt>
  <dd>Returns the assert facet if present, undef if it is not.</dd>
  <dt>@list_of_facets = $event-&gt;assert</dt>
  <dd>TODO</dd>
  <dt id="EMPTY_LIST_OR_STRING"><a class="permalink" href="#EMPTY_LIST_OR_STRING">EMPTY_LIST_OR_STRING
    = $event-&gt;assert_brief</a></dt>
  <dd>Returns a string giving a brief of the assertion if an assertion is
      present. Returns an empty list if no assertion is present.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">SUBTESTS (PARENT FACET)</h2>
<dl class="Bl-tag">
  <dt>$bool = $event-&gt;has_subtest</dt>
  <dd>True if a subetest is present in this event.</dd>
  <dt>$undef_or_hashref = $event-&gt;the_subtest</dt>
  <dd>Get the one subtest if present, otherwise undef.</dd>
  <dt>@list_of_facets = $event-&gt;subtest</dt>
  <dd>TODO</dd>
  <dt id="EMPTY_LIST_OR_OBJECT"><a class="permalink" href="#EMPTY_LIST_OR_OBJECT">EMPTY_LIST_OR_OBJECT
    = $event-&gt;subtest_result</a></dt>
  <dd>Returns an empty list if there is no subtest.
    <p class="Pp">Get an instance of Test2::API::InterceptResult representing
        the subtest.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">CONTROL FACET (BAILOUT, ENCODING)</h2>
<dl class="Bl-tag">
  <dt>$bool = $event-&gt;has_bailout</dt>
  <dd>True if there was a bailout</dd>
  <dt>$undef_hashref = $event-&gt;the_bailout</dt>
  <dd>Return the control facet if it requested a bailout.</dd>
  <dt id="EMPTY_LIST_OR_HASHREF"><a class="permalink" href="#EMPTY_LIST_OR_HASHREF">EMPTY_LIST_OR_HASHREF
    = $event-&gt;bailout</a></dt>
  <dd>Get a list of 0 or 1 hashrefs. The hashref will be the control facet if a
      bail-out was requested.</dd>
  <dt id="EMPTY_LIST_OR_STRING~2"><a class="permalink" href="#EMPTY_LIST_OR_STRING~2">EMPTY_LIST_OR_STRING
    = $event-&gt;bailout_brief</a></dt>
  <dd>Get the brief of the balout if present.</dd>
  <dt id="EMPTY_LIST_OR_STRING~3"><a class="permalink" href="#EMPTY_LIST_OR_STRING~3">EMPTY_LIST_OR_STRING
    = $event-&gt;bailout_reason</a></dt>
  <dd>Get the reason for the bailout, an empty string if no reason was provided,
      or an empty list if there was no bailout.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">PLAN FACET</h2>
<p class="Pp">TODO</p>
<dl class="Bl-tag">
  <dt>$bool = $event-&gt;has_plan</dt>
  <dd></dd>
  <dt>$undef_or_hashref = $event-&gt;the_plan</dt>
  <dd></dd>
  <dt>@list_if_hashrefs = $event-&gt;plan</dt>
  <dd></dd>
  <dt id="EMPTY_LIST_OR_STRING~4"><a class="permalink" href="#EMPTY_LIST_OR_STRING~4">EMPTY_LIST_OR_STRING
    $event-&gt;plan_brief</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">AMNESTY FACET (TODO AND SKIP)</h2>
<p class="Pp">TODO</p>
<dl class="Bl-tag">
  <dt>$event-&gt;has_amnesty</dt>
  <dd></dd>
  <dt>$event-&gt;the_amnesty</dt>
  <dd></dd>
  <dt>$event-&gt;amnesty</dt>
  <dd></dd>
  <dt>$event-&gt;amnesty_reasons</dt>
  <dd></dd>
  <dt>$event-&gt;has_todos</dt>
  <dd></dd>
  <dt>$event-&gt;todos</dt>
  <dd></dd>
  <dt>$event-&gt;todo_reasons</dt>
  <dd></dd>
  <dt>$event-&gt;has_skips</dt>
  <dd></dd>
  <dt>$event-&gt;skips</dt>
  <dd></dd>
  <dt>$event-&gt;skip_reasons</dt>
  <dd></dd>
  <dt>$event-&gt;has_other_amnesty</dt>
  <dd></dd>
  <dt>$event-&gt;other_amnesty</dt>
  <dd></dd>
  <dt>$event-&gt;other_amnesty_reasons</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">ERROR FACET (CAPTURED EXCEPTIONS)</h2>
<p class="Pp">TODO</p>
<dl class="Bl-tag">
  <dt>$event-&gt;has_errors</dt>
  <dd></dd>
  <dt>$event-&gt;the_errors</dt>
  <dd></dd>
  <dt>$event-&gt;errors</dt>
  <dd></dd>
  <dt>$event-&gt;error_messages</dt>
  <dd></dd>
  <dt>$event-&gt;error_brief</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">INFO FACET (DIAG, NOTE)</h2>
<p class="Pp">TODO</p>
<dl class="Bl-tag">
  <dt>$event-&gt;has_info</dt>
  <dd></dd>
  <dt>$event-&gt;the_info</dt>
  <dd></dd>
  <dt>$event-&gt;info</dt>
  <dd></dd>
  <dt>$event-&gt;info_messages</dt>
  <dd></dd>
  <dt>$event-&gt;has_diags</dt>
  <dd></dd>
  <dt>$event-&gt;diags</dt>
  <dd></dd>
  <dt>$event-&gt;diag_messages</dt>
  <dd></dd>
  <dt>$event-&gt;has_notes</dt>
  <dd></dd>
  <dt>$event-&gt;notes</dt>
  <dd></dd>
  <dt>$event-&gt;note_messages</dt>
  <dd></dd>
  <dt>$event-&gt;has_other_info</dt>
  <dd></dd>
  <dt>$event-&gt;other_info</dt>
  <dd></dd>
  <dt>$event-&gt;other_info_messages</dt>
  <dd></dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SOURCE"><a class="permalink" href="#SOURCE">SOURCE</a></h1>
<p class="Pp">The source code repository for Test2 can be found at
    <i>http://github.com/Test-More/test-more/</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MAINTAINERS"><a class="permalink" href="#MAINTAINERS">MAINTAINERS</a></h1>
<dl class="Bl-tag">
  <dt id="Chad"><a class="permalink" href="#Chad">Chad Granum
    &lt;exodist@cpan.org&gt;</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<dl class="Bl-tag">
  <dt id="Chad~2"><a class="permalink" href="#Chad~2">Chad Granum
    &lt;exodist@cpan.org&gt;</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 2020 Chad Granum &lt;exodist@cpan.org&gt;.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">See <i>http://dev.perl.org/licenses/</i></p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os"><a href="..">perl v5.34.1</a></td>
  </tr>
</table>
</body>
</html>

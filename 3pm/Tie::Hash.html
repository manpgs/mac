<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Tie::Hash(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Tie::Hash(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Tie::Hash(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Tie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions
    for tied hashes</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    package NewHash;
    require Tie::Hash;
    @ISA = qw(Tie::Hash);
    sub DELETE { ... }          # Provides needed method
    sub CLEAR { ... }           # Overrides inherited method
    package NewStdHash;
    require Tie::Hash;
    @ISA = qw(Tie::StdHash);
    # All methods provided by default, define
    # only those needing overrides
    # Accessors access the storage in %{$_[0]};
    # TIEHASH should return a reference to the actual storage
    sub DELETE { ... }
    package NewExtraHash;
    require Tie::Hash;
    @ISA = qw(Tie::ExtraHash);
    # All methods provided by default, define 
    # only those needing overrides
    # Accessors access the storage in %{$_[0][0]};
    # TIEHASH should return an array reference with the first element
    # being the reference to the actual storage 
    sub DELETE { 
      $_[0][1]-&gt;('del', $_[0][0], $_[1]); # Call the report writer
      delete $_[0][0]-&gt;{$_[1]};           #  $_[0]-&gt;SUPER::DELETE($_[1])
    }
    package main;
    tie %new_hash, 'NewHash';
    tie %new_std_hash, 'NewStdHash';
    tie %new_extra_hash, 'NewExtraHash',
        sub {warn &quot;Doing \U$_[1]\E of $_[2].\n&quot;};
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module provides some skeletal methods for hash-tying classes.
    See perltie for a list of the functions required in order to tie a hash to a
    package. The basic <b>Tie::Hash</b> package provides a
    <span class="Li">&quot;new&quot;</span> method, as well as methods
    <span class="Li">&quot;TIEHASH&quot;</span>,
    <span class="Li">&quot;EXISTS&quot;</span> and
    <span class="Li">&quot;CLEAR&quot;</span>. The <b>Tie::StdHash</b> and
    <b>Tie::ExtraHash</b> packages provide most methods for hashes described in
    perltie (the exceptions are <span class="Li">&quot;UNTIE&quot;</span> and
    <span class="Li">&quot;DESTROY&quot;</span>). They cause tied hashes to
    behave exactly like standard hashes, and allow for selective overwriting of
    methods. <b>Tie::Hash</b> grandfathers the
    <span class="Li">&quot;new&quot;</span> method: it is used if
    <span class="Li">&quot;TIEHASH&quot;</span> is not defined in the case a
    class forgets to include a <span class="Li">&quot;TIEHASH&quot;</span>
    method.</p>
<p class="Pp">For developers wishing to write their own tied hashes, the
    required methods are briefly defined below. See the perltie section for more
    detailed descriptive, as well as example code:</p>
<dl class="Bl-tag">
  <dt id="TIEHASH"><a class="permalink" href="#TIEHASH">TIEHASH classname,
    LIST</a></dt>
  <dd>The method invoked by the command <span class="Li">&quot;tie %hash,
      classname&quot;</span>. Associates a new hash instance with the specified
      class. <span class="Li">&quot;LIST&quot;</span> would represent additional
      arguments (along the lines of AnyDBM_File and compatriots) needed to
      complete the association.</dd>
  <dt id="STORE"><a class="permalink" href="#STORE">STORE this, key,
    value</a></dt>
  <dd>Store datum <i>value</i> into <i>key</i> for the tied hash
    <i>this</i>.</dd>
  <dt id="FETCH"><a class="permalink" href="#FETCH">FETCH this, key</a></dt>
  <dd>Retrieve the datum in <i>key</i> for the tied hash <i>this</i>.</dd>
  <dt id="FIRSTKEY"><a class="permalink" href="#FIRSTKEY">FIRSTKEY this</a></dt>
  <dd>Return the first key in the hash.</dd>
  <dt id="NEXTKEY"><a class="permalink" href="#NEXTKEY">NEXTKEY this,
    lastkey</a></dt>
  <dd>Return the next key in the hash.</dd>
  <dt id="EXISTS"><a class="permalink" href="#EXISTS">EXISTS this, key</a></dt>
  <dd>Verify that <i>key</i> exists with the tied hash <i>this</i>.
    <p class="Pp">The <b>Tie::Hash</b> implementation is a stub that simply
        croaks.</p>
  </dd>
  <dt id="DELETE"><a class="permalink" href="#DELETE">DELETE this, key</a></dt>
  <dd>Delete the key <i>key</i> from the tied hash <i>this</i>.</dd>
  <dt id="CLEAR"><a class="permalink" href="#CLEAR">CLEAR this</a></dt>
  <dd>Clear all values from the tied hash <i>this</i>.</dd>
  <dt id="SCALAR"><a class="permalink" href="#SCALAR">SCALAR this</a></dt>
  <dd>Returns what evaluating the hash in scalar context yields.
    <p class="Pp"><b>Tie::Hash</b> does not implement this method (but
        <b>Tie::StdHash</b> and <b>Tie::ExtraHash</b> do).</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh">Inheriting from <b>Tie::StdHash</b></h1>
<p class="Pp">The accessor methods assume that the actual storage for the data
    in the tied hash is in the hash referenced by
    <span class="Li">&quot;tied(%tiedhash)&quot;</span>. Thus overwritten
    <span class="Li">&quot;TIEHASH&quot;</span> method should return a hash
    reference, and the remaining methods should operate on the hash referenced
    by the first argument:</p>
<p class="Pp"></p>
<pre>  package ReportHash;
  our @ISA = 'Tie::StdHash';
  sub TIEHASH  {
    my $storage = bless {}, shift;
    warn &quot;New ReportHash created, stored in $storage.\n&quot;;
    $storage
  }
  sub STORE    {
    warn &quot;Storing data with key $_[1] at $_[0].\n&quot;;
    $_[0]{$_[1]} = $_[2]
  }
</pre>
</section>
<section class="Sh">
<h1 class="Sh">Inheriting from <b>Tie::ExtraHash</b></h1>
<p class="Pp">The accessor methods assume that the actual storage for the data
    in the tied hash is in the hash referenced by
    <span class="Li">&quot;(tied(%tiedhash))-&gt;[0]&quot;</span>. Thus
    overwritten <span class="Li">&quot;TIEHASH&quot;</span> method should return
    an array reference with the first element being a hash reference, and the
    remaining methods should operate on the hash <span class="Li">&quot;%{
    $_[0]-&gt;[0] }&quot;</span>:</p>
<p class="Pp"></p>
<pre>  package ReportHash;
  our @ISA = 'Tie::ExtraHash';
  sub TIEHASH  {
    my $class = shift;
    my $storage = bless [{}, @_], $class;
    warn &quot;New ReportHash created, stored in $storage.\n&quot;;
    $storage;
  }
  sub STORE    {
    warn &quot;Storing data with key $_[1] at $_[0].\n&quot;;
    $_[0][0]{$_[1]} = $_[2]
  }
</pre>
<p class="Pp">The default <span class="Li">&quot;TIEHASH&quot;</span> method
    stores &quot;extra&quot; arguments to <b>tie()</b> starting from offset 1 in
    the array referenced by <span class="Li">&quot;tied(%tiedhash)&quot;</span>;
    this is the same storage algorithm as in TIEHASH subroutine above. Hence, a
    typical package inheriting from <b>Tie::ExtraHash</b> does not need to
    overwrite this method.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="_SCALAR_,__UNTIE__and__DESTROY_"><a class="permalink" href="#_SCALAR_,__UNTIE__and__DESTROY_">&quot;SCALAR&quot;,
  &quot;UNTIE&quot; and &quot;DESTROY&quot;</a></h1>
<p class="Pp">The methods <span class="Li">&quot;UNTIE&quot;</span> and
    <span class="Li">&quot;DESTROY&quot;</span> are not defined in
    <b>Tie::Hash</b>, <b>Tie::StdHash</b>, or <b>Tie::ExtraHash</b>. Tied hashes
    do not require presence of these methods, but if defined, the methods will
    be called in proper time, see perltie.</p>
<p class="Pp"><span class="Li">&quot;SCALAR&quot;</span> is only defined in
    <b>Tie::StdHash</b> and <b>Tie::ExtraHash</b>.</p>
<p class="Pp">If needed, these methods should be defined by the package
    inheriting from <b>Tie::Hash</b>, <b>Tie::StdHash</b>, or
    <b>Tie::ExtraHash</b>. See &quot;SCALAR&quot; in perltie to find out what
    happens when <span class="Li">&quot;SCALAR&quot;</span> does not exist.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MORE_INFORMATION"><a class="permalink" href="#MORE_INFORMATION">MORE
  INFORMATION</a></h1>
<p class="Pp">The packages relating to various DBM-related implementations
    (<i>DB_File</i>, <i>NDBM_File</i>, etc.) show examples of general tied
    hashes, as does the Config module. While these do not utilize
    <b>Tie::Hash</b>, they serve as good working examples.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

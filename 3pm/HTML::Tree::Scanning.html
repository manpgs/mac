<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>HTML::Tree::Scanning(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">HTML::Tree::Scanning(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">HTML::Tree::Scanning(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">HTML::Tree::Scanning -- article: &quot;Scanning HTML&quot;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  # This an article, not a module.
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The following article by Sean M. Burke first appeared in <i>The
    Perl</i> <i>Journal</i> #19 and is copyright 2000 The Perl Journal. It
    appears courtesy of Jon Orwant and The Perl Journal. This document may be
    distributed under the same terms as Perl itself.</p>
<p class="Pp">(Note that this is discussed in chapters 6 through 10 of the book
    <i>Perl and LWP</i> &lt;http://lwp.interglacial.com/&gt; which was written
    after the following documentation, and which is available free online.)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Scanning_HTML"><a class="permalink" href="#Scanning_HTML">Scanning
  HTML</a></h1>
<p class="Pp">-- Sean M. Burke</p>
<p class="Pp">In <i>The Perl Journal</i> issue 17, Ken MacFarlane's article
    &quot;Parsing HTML with HTML::Parser&quot; describes how the HTML::Parser
    module scans HTML source as a stream of start-tags, end-tags, text,
    comments, etc. In TPJ #18, my &quot;Trees&quot; article kicked around the
    idea of tree-shaped data structures. Now I'll try to tie it together, in a
    discussion of HTML trees.</p>
<p class="Pp">The CPAN module HTML::TreeBuilder takes the tags that HTML::Parser
    picks out, and builds a parse tree -- a tree-shaped network of
  objects...</p>
<p class="Pp"></p>
<div class="Bd-indent">Footnote: And if you need a quick explanation of objects,
  see my TPJ17 article &quot;A User's View of Object-Oriented Modules&quot;; or
  go whole hog and get Damian Conway's excellent book <i>Object-Oriented
  Perl</i>, from Manning Publications.</div>
<p class="Pp">...representing the structured content of the HTML document. And
    once the document is parsed as a tree, you'll find the common tasks of
    extracting data from that HTML document/tree to be quite
  straightforward.</p>
<section class="Ss">
<h2 class="Ss" id="HTML::Parser,_HTML::TreeBuilder,_and_HTML::Element"><a class="permalink" href="#HTML::Parser,_HTML::TreeBuilder,_and_HTML::Element">HTML::Parser,
  HTML::TreeBuilder, and HTML::Element</a></h2>
<p class="Pp">You use HTML::TreeBuilder to make a parse tree out of an HTML
    source file, by simply saying:</p>
<p class="Pp"></p>
<pre>  use HTML::TreeBuilder;
  my $tree = HTML::TreeBuilder-&gt;new();
  $tree-&gt;parse_file('foo.html');
</pre>
<p class="Pp">and then <span class="Li">$tree</span> contains a parse tree built
    from the HTML source from the file &quot;foo.html&quot;. The way this parse
    tree is represented is with a network of objects --
    <span class="Li">$tree</span> is the root, an element with tag-name
    &quot;html&quot;, and its children typically include a &quot;head&quot; and
    &quot;body&quot; element, and so on. Elements in the tree are objects of the
    class HTML::Element.</p>
<p class="Pp">So, if you take this source:</p>
<p class="Pp"></p>
<pre>  &lt;html&gt;&lt;head&gt;&lt;title&gt;Doc 1&lt;/title&gt;&lt;/head&gt;
  &lt;body&gt;
  Stuff &lt;hr&gt; 2000-08-17
  &lt;/body&gt;&lt;/html&gt;
</pre>
<p class="Pp">and feed it to HTML::TreeBuilder, it'll return a tree of objects
    that looks like this:</p>
<p class="Pp"></p>
<pre>               html
             /      \
         head        body
        /          /   |  \
     title    &quot;Stuff&quot;  hr  &quot;2000-08-17&quot;
       |
    &quot;Doc 1&quot;
</pre>
<p class="Pp">This is a pretty simple document, but if it were any more complex,
    it'd be a bit hard to draw in that style, since it's sprawl left and right.
    The same tree can be represented a bit more easily sideways, with
  indenting:</p>
<p class="Pp"></p>
<pre>  . html
     . head
        . title
           . &quot;Doc 1&quot;
     . body
        . &quot;Stuff&quot;
        . hr
        . &quot;2000-08-17&quot;
</pre>
<p class="Pp">Either way expresses the same structure. In that structure, the
    root node is an object of the class HTML::Element</p>
<p class="Pp"></p>
<div class="Bd-indent">Footnote: Well actually, the root is of the class
  HTML::TreeBuilder, but that's just a subclass of HTML::Element, plus the few
  extra methods like <span class="Li">&quot;parse_file&quot;</span> that
  elaborate the tree</div>
<p class="Pp">, with the tag name &quot;html&quot;, and with two children: an
    HTML::Element object whose tag names are &quot;head&quot; and
    &quot;body&quot;. And each of those elements have children, and so on down.
    Not all elements (as we'll call the objects of class HTML::Element) have
    children -- the &quot;hr&quot; element doesn't. And note all nodes in the
    tree are elements -- the text nodes (&quot;Doc 1&quot;, &quot;Stuff&quot;,
    and &quot;2000-08-17&quot;) are just strings.</p>
<p class="Pp">Objects of the class HTML::Element each have three noteworthy
    attributes:</p>
<dl class="Bl-tag">
  <dt>&quot;_tag&quot; -- (best accessed as &quot;$e-&gt;tag&quot;) this
    element's tag-name, lowercased (e.g., &quot;em&quot; for an &quot;em&quot;
    element).</dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">Footnote: Yes, this is misnamed. In proper SGML
  terminology, this is instead called a &quot;GI&quot;, short for &quot;generic
  identifier&quot;; and the term &quot;tag&quot; is used for a token of SGML
  source that represents either the start of an element (a start-tag like
  &quot;&lt;em lang='fr'&gt;&quot;) or the end of an element (an end-tag like
  &quot;&lt;/em&gt;&quot;. However, since more people claim to have been
  abducted by aliens than to have ever seen the SGML standard, and since both
  encounters typically involve a feeling of &quot;missing time&quot;, it's not
  surprising that the terminology of the SGML standard is not closely
  followed.</div>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;_parent&quot; -- (best accessed as &quot;$e-&gt;parent&quot;) the
    element that is $obj's parent, or undef if this element is the root of its
    tree.</dt>
  <dd></dd>
  <dt>&quot;_content&quot; -- (best accessed as &quot;$e-&gt;content_list&quot;)
    the list of nodes (i.e., elements or text segments) that are $e's
    children.</dt>
  <dd></dd>
</dl>
<p class="Pp">Moreover, if an element object has any attributes in the SGML
    sense of the word, then those are readable as
    <span class="Li">&quot;$e-&gt;attr('name')&quot;</span> -- for example, with
    the object built from having parsed &quot;&lt;a
    <b>id='foo'</b>&gt;bar&lt;/a&gt;&quot;,
    <span class="Li">&quot;$e-&gt;attr('id')&quot;</span> will return the string
    &quot;foo&quot;. Moreover, <span class="Li">&quot;$e-&gt;tag&quot;</span> on
    that object returns the string &quot;a&quot;,
    <span class="Li">&quot;$e-&gt;content_list&quot;</span> returns a list
    consisting of just the single scalar &quot;bar&quot;, and
    <span class="Li">&quot;$e-&gt;parent&quot;</span> returns the object that's
    this node's parent -- which may be, for example, a &quot;p&quot;
  element.</p>
<p class="Pp">And that's all that there is to it -- you throw HTML source at
    TreeBuilder, and it returns a tree built of HTML::Element objects and some
    text strings.</p>
<p class="Pp">However, what do you <i>do</i> with a tree of objects? People code
    information into HTML trees not for the fun of arranging elements, but to
    represent the structure of specific text and images -- some text is in this
    &quot;li&quot; element, some other text is in that heading, some images are
    in that other table cell that has those attributes, and so on.</p>
<p class="Pp">Now, it may happen that you're rendering that whole HTML tree into
    some layout format. Or you could be trying to make some systematic change to
    the HTML tree before dumping it out as HTML source again. But, in my
    experience, by far the most common programming task that Perl programmers
    face with HTML is in trying to extract some piece of information from a
    larger document. Since that's so common (and also since it involves concepts
    that are basic to more complex tasks), that is what the rest of this article
    will be about.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Scanning_"><a class="permalink" href="#Scanning_">Scanning
  HTML trees</a></h2>
<p class="Pp">Suppose you have a thousand HTML documents, each of them a press
    release. They all start out:</p>
<p class="Pp"></p>
<pre>  [...lots of leading images and junk...]
  &lt;h1&gt;ConGlomCo to Open New Corporate Office in Ougadougou&lt;/h1&gt;
  BAKERSFIELD, CA, 2000-04-24 -- ConGlomCo's vice president in charge
  of world conquest, Rock Feldspar, announced today the opening of a
  new office in Ougadougou, the capital city of Burkino Faso, gateway
  to the bustling &quot;Silicon Sahara&quot; of Africa...
  [...etc...]
</pre>
<p class="Pp">...and what you've got to do is, for each document, copy whatever
    text is in the &quot;h1&quot; element, so that you can, for example, make a
    table of contents of it. Now, there are three ways to do this:</p>
<ul class="Bl-bullet">
  <li>You can just use a regexp to scan the file for a text pattern.
    <p class="Pp">For many very simple tasks, this will do fine. Many HTML
        documents are, in practice, very consistently formatted as far as
        placement of linebreaks and whitespace, so you could just get away with
        scanning the file like so:</p>
    <p class="Pp"></p>
    <pre>  sub get_heading {
    my $filename = $_[0];
    local *HTML;
    open(HTML, $filename)
      or die &quot;Couldn't open $filename);
    my $heading;
   Line:
    while(&lt;HTML&gt;) {
      if( m{&lt;h1&gt;(.*?)&lt;/h1&gt;}i ) {  # match it!
        $heading = $1;
        last Line;
      }
    }
    close(HTML);
    warn &quot;No heading in $filename?&quot;
     unless defined $heading;
    return $heading;
  }
    </pre>
    <p class="Pp">This is quick and fast, but awfully fragile -- if there's a
        newline in the middle of a heading's text, it won't match the above
        regexp, and you'll get an error. The regexp will also fail if the
        &quot;h1&quot; element's start-tag has any attributes. If you have to
        adapt your code to fit more kinds of start-tags, you'll end up basically
        reinventing part of HTML::Parser, at which point you should probably
        just stop, and use HTML::Parser itself:</p>
  </li>
  <li>You can use HTML::Parser to scan the file for an &quot;h1&quot; start-tag
      token, then capture all the text tokens until the &quot;h1&quot;
      close-tag. This approach is extensively covered in the Ken MacFarlane's
      TPJ17 article &quot;Parsing HTML with HTML::Parser&quot;. (A variant of
      this approach is to use HTML::TokeParser, which presents a different and
      rather handier interface to the tokens that HTML::Parser picks out.)
    <p class="Pp">Using HTML::Parser is less fragile than our first approach,
        since it's not sensitive to the exact internal formatting of the
        start-tag (much less whether it's split across two lines). However, when
        you need more information about the context of the &quot;h1&quot;
        element, or if you're having to deal with any of the tricky bits of
        HTML, such as parsing of tables, you'll find out the flat list of tokens
        that HTML::Parser returns isn't immediately useful. To get something
        useful out of those tokens, you'll need to write code that knows some
        things about what elements take no content (as with &quot;hr&quot;
        elements), and that a &quot;&lt;/p&gt;&quot; end-tags are omissible, so
        a &quot;&lt;p&gt;&quot; will end any currently open paragraph -- and
        you're well on your way to pointlessly reinventing much of the code in
        HTML::TreeBuilder</p>
  </li>
</ul>
<div class="Bd-indent">
<p class="Pp"></p>
<div class="Bd-indent">Footnote: And, as the person who last rewrote that
  module, I can attest that it wasn't terribly easy to get right! Never
  underestimate the perversity of people coding HTML.</div>
</div>
<div class="Bd-indent">
<p class="Pp">, at which point you should probably just stop, and use
    HTML::TreeBuilder itself:</p>
</div>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>You can use HTML::Treebuilder, and scan the tree of element objects that
      you get back.</dd>
</dl>
<p class="Pp">The last approach, using HTML::TreeBuilder, is the diametric
    opposite of first approach: The first approach involves just elementary Perl
    and one regexp, whereas the TreeBuilder approach involves being at home with
    the concept of tree-shaped data structures and modules with object-oriented
    interfaces, as well as with the particular interfaces that HTML::TreeBuilder
    and HTML::Element provide.</p>
<p class="Pp">However, what the TreeBuilder approach has going for it is that
    it's the most robust, because it involves dealing with HTML in its
    &quot;native&quot; format -- it deals with the tree structure that HTML code
    represents, without any consideration of how the source is coded and with
    what tags omitted.</p>
<p class="Pp">So, to extract the text from the &quot;h1&quot; elements of an
    HTML document:</p>
<p class="Pp"></p>
<pre>  sub get_heading {
    my $tree = HTML::TreeBuilder-&gt;new;
    $tree-&gt;parse_file($_[0]);   # !
    my $heading;
    my $h1 = $tree-&gt;look_down('_tag', 'h1');  # !
    if($h1) {
      $heading = $h1-&gt;as_text;   # !
    } else {
      warn &quot;No heading in $_[0]?&quot;;
    }
    $tree-&gt;delete; # clear memory!
    return $heading;
  }
</pre>
<p class="Pp">This uses some unfamiliar methods that need explaining. The
    <span class="Li">&quot;parse_file&quot;</span> method that we've seen
    before, builds a tree based on source from the file given. The
    <span class="Li">&quot;delete&quot;</span> method is for marking a tree's
    contents as available for garbage collection, when you're done with the
    tree. The <span class="Li">&quot;as_text&quot;</span> method returns a
    string that contains all the text bits that are children (or otherwise
    descendants) of the given node -- to get the text content of the
    <span class="Li">$h1</span> object, we could just say:</p>
<p class="Pp"></p>
<pre>  $heading = join '', $h1-&gt;content_list;
</pre>
<p class="Pp">but that will work only if we're sure that the &quot;h1&quot;
    element's children will be only text bits -- if the document contained:</p>
<p class="Pp"></p>
<pre>  &lt;h1&gt;Local Man Sees &lt;cite&gt;Blade&lt;/cite&gt; Again&lt;/h1&gt;
</pre>
<p class="Pp">then the sub-tree would be:</p>
<p class="Pp"></p>
<pre>  . h1
    . &quot;Local Man Sees &quot;
    . cite
      . &quot;Blade&quot;
    . &quot; Again'
</pre>
<p class="Pp">so <span class="Li">&quot;join '',
    $h1-&gt;content_list&quot;</span> will be something like:</p>
<p class="Pp"></p>
<pre>  Local Man Sees HTML::Element=HASH(0x15424040) Again
</pre>
<p class="Pp">whereas <span class="Li">&quot;$h1-&gt;as_text&quot;</span> would
    yield:</p>
<p class="Pp"></p>
<pre>  Local Man Sees Blade Again
</pre>
<p class="Pp">and depending on what you're doing with the heading text, you
    might want the <span class="Li">&quot;as_HTML&quot;</span> method instead.
    It returns the (sub)tree represented as HTML source.
    <span class="Li">&quot;$h1-&gt;as_HTML&quot;</span> would yield:</p>
<p class="Pp"></p>
<pre>  &lt;h1&gt;Local Man Sees &lt;cite&gt;Blade&lt;/cite&gt; Again&lt;/h1&gt;
</pre>
<p class="Pp">However, if you wanted the contents of <span class="Li">$h1</span>
    as HTML, but not the <span class="Li">$h1</span> itself, you could say:</p>
<p class="Pp"></p>
<pre>  join '',
    map(
      ref($_) ? $_-&gt;as_HTML : $_,
      $h1-&gt;content_list
    )
</pre>
<p class="Pp">This <span class="Li">&quot;map&quot;</span> iterates over the
    nodes in <span class="Li">$h1</span>'s list of children; and for each node
    that's just a text bit (as &quot;Local Man Sees &quot; is), it just passes
    through that string value, and for each node that's an actual object
    (causing <span class="Li">&quot;ref&quot;</span> to be true),
    <span class="Li">&quot;as_HTML&quot;</span> will used instead of the string
    value of the object itself (which would be something quite useless, as most
    object values are). So that <span class="Li">&quot;as_HTML&quot;</span> for
    the &quot;cite&quot; element will be the string
    &quot;&lt;cite&gt;Blade&lt;/cite&gt;&quot;. And then, finally,
    <span class="Li">&quot;join&quot;</span> just puts into one string all the
    strings that the <span class="Li">&quot;map&quot;</span> returns.</p>
<p class="Pp">Last but not least, the most important method in our
    <span class="Li">&quot;get_heading&quot;</span> sub is the
    <span class="Li">&quot;look_down&quot;</span> method. This method looks down
    at the subtree starting at the given object (<span class="Li">$h1</span>),
    looking for elements that meet criteria you provide.</p>
<p class="Pp">The criteria are specified in the method's argument list. Each
    criterion can consist of two scalars, a key and a value, which express that
    you want elements that have that attribute (like &quot;_tag&quot;, or
    &quot;src&quot;) with the given value (&quot;h1&quot;); or the criterion can
    be a reference to a subroutine that, when called on the given element,
    returns true if that is a node you're looking for. If you specify several
    criteria, then that's taken to mean that you want all the elements that each
    satisfy <i>all</i> the criteria. (In other words, there's an &quot;implicit
    AND&quot;.)</p>
<p class="Pp">And finally, there's a bit of an optimization -- if you call the
    <span class="Li">&quot;look_down&quot;</span> method in a scalar context,
    you get just the <i>first</i> node (or undef if none) -- and, in fact, once
    <span class="Li">&quot;look_down&quot;</span> finds that first matching
    element, it doesn't bother looking any further.</p>
<p class="Pp">So the example:</p>
<p class="Pp"></p>
<pre>  $h1 = $tree-&gt;look_down('_tag', 'h1');
</pre>
<p class="Pp">returns the first element at-or-under
    <span class="Li">$tree</span> whose <span class="Li">&quot;_tag&quot;</span>
    attribute has the value <span class="Li">&quot;h1&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Complex_Criteria_in_Tree_Scanning"><a class="permalink" href="#Complex_Criteria_in_Tree_Scanning">Complex
  Criteria in Tree Scanning</a></h2>
<p class="Pp">Now, the above <span class="Li">&quot;look_down&quot;</span> code
    looks like a lot of bother, with barely more benefit than just grepping the
    file! But consider if your criteria were more complicated -- suppose you
    found that some of the press releases that you were scanning had several
    &quot;h1&quot; elements, possibly before or after the one you actually want.
    For example:</p>
<p class="Pp"></p>
<pre>  &lt;h1&gt;&lt;center&gt;Visit Our Corporate Partner
   &lt;br&gt;&lt;a href=&quot;/dyna/clickthru&quot;
     &gt;&lt;img src=&quot;/dyna/vend_ad&quot;&gt;&lt;/a&gt;
  &lt;/center&gt;&lt;/h1&gt;
  &lt;h1&gt;&lt;center&gt;ConGlomCo President Schreck to Visit Regional HQ
   &lt;br&gt;&lt;a href=&quot;/photos/Schreck_visit_large.jpg&quot;
     &gt;&lt;img src=&quot;/photos/Schreck_visit.jpg&quot;&gt;&lt;/a&gt;
  &lt;/center&gt;&lt;/h1&gt;
</pre>
<p class="Pp">Here, you want to ignore the first &quot;h1&quot; element because
    it contains an ad, and you want the text from the second &quot;h1&quot;. The
    problem is in formalizing the way you know that it's an ad. Since ad banners
    are always entreating you to &quot;visit&quot; the sponsoring site, you
    could exclude &quot;h1&quot; elements that contain the word
    &quot;visit&quot; under them:</p>
<p class="Pp"></p>
<pre>  my $real_h1 = $tree-&gt;look_down(
    '_tag', 'h1',
    sub {
      $_[0]-&gt;as_text !~ m/\bvisit/i
    }
  );
</pre>
<p class="Pp">The first criterion looks for &quot;h1&quot; elements, and the
    second criterion limits those to only the ones whose text content doesn't
    match <span class="Li">&quot;m/\bvisit/&quot;</span>. But unfortunately,
    that won't work for our example, since the second &quot;h1&quot; mentions
    &quot;ConGlomCo President Schreck to <i>Visit</i> Regional HQ&quot;.</p>
<p class="Pp">Instead you could try looking for the first &quot;h1&quot; element
    that doesn't contain an image:</p>
<p class="Pp"></p>
<pre>  my $real_h1 = $tree-&gt;look_down(
    '_tag', 'h1',
    sub {
      not $_[0]-&gt;look_down('_tag', 'img')
    }
  );
</pre>
<p class="Pp">This criterion sub might seem a bit odd, since it calls
    <span class="Li">&quot;look_down&quot;</span> as part of a larger
    <span class="Li">&quot;look_down&quot;</span> operation, but that's fine.
    Note that when considered as a boolean value, a
    <span class="Li">&quot;look_down&quot;</span> in a scalar context value
    returns false (specifically, undef) if there's no matching element at or
    under the given element; and it returns the first matching element (which,
    being a reference and object, is always a true value), if any matches. So,
    here,</p>
<p class="Pp"></p>
<pre>  sub {
    not $_[0]-&gt;look_down('_tag', 'img')
  }
</pre>
<p class="Pp">means &quot;return true only if this element has no 'img' element
    as descendants (and isn't an 'img' element itself).&quot;</p>
<p class="Pp">This correctly filters out the first &quot;h1&quot; that contains
    the ad, but it also incorrectly filters out the second &quot;h1&quot; that
    contains a non-advertisement photo besides the headline text you want.</p>
<p class="Pp">There clearly are detectable differences between the first and
    second &quot;h1&quot; elements -- the only second one contains the string
    &quot;Schreck&quot;, and we could just test for that:</p>
<p class="Pp"></p>
<pre>  my $real_h1 = $tree-&gt;look_down(
    '_tag', 'h1',
    sub {
      $_[0]-&gt;as_text =~ m{Schreck}
    }
  );
</pre>
<p class="Pp">And that works fine for this one example, but unless all thousand
    of your press releases have &quot;Schreck&quot; in the headline, that's just
    not a general solution. However, if all the ads-in-&quot;h1&quot;s that you
    want to exclude involve a link whose URL involves &quot;/dyna/&quot;, then
    you can use that:</p>
<p class="Pp"></p>
<pre>  my $real_h1 = $tree-&gt;look_down(
    '_tag', 'h1',
    sub {
      my $link = $_[0]-&gt;look_down('_tag','a');
      return 1 unless $link;
        # no link means it's fine
      return 0 if $link-&gt;attr('href') =~ m{/dyna/};
        # a link to there is bad
      return 1; # otherwise okay
    }
  );
</pre>
<p class="Pp">Or you can look at it another way and say that you want the first
    &quot;h1&quot; element that either contains no images, or else whose image
    has a &quot;src&quot; attribute whose value contains
  &quot;/photos/&quot;:</p>
<p class="Pp"></p>
<pre>  my $real_h1 = $tree-&gt;look_down(
    '_tag', 'h1',
    sub {
      my $img = $_[0]-&gt;look_down('_tag','img');
      return 1 unless $img;
        # no image means it's fine
      return 1 if $img-&gt;attr('src') =~ m{/photos/};
        # good if a photo
      return 0; # otherwise bad
    }
  );
</pre>
<p class="Pp">Recall that this use of
    <span class="Li">&quot;look_down&quot;</span> in a scalar context means to
    return the first element at or under <span class="Li">$tree</span> that
    matches all the criteria. But if you notice that you can formulate criteria
    that'll match several possible &quot;h1&quot; elements, some of which may be
    bogus but the <i>last</i> one of which is always the one you want, then you
    can use <span class="Li">&quot;look_down&quot;</span> in a list context, and
    just use the last element of that list:</p>
<p class="Pp"></p>
<pre>  my @h1s = $tree-&gt;look_down(
    '_tag', 'h1',
    ...maybe more criteria...
  );
  die &quot;What, no h1s here?&quot; unless @h1s;
  my $real_h1 = $h1s[-1]; # last or only
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="A_Case_Study:_Scanning_Yahoo_News's_"><a class="permalink" href="#A_Case_Study:_Scanning_Yahoo_News's_">A
  Case Study: Scanning Yahoo News's HTML</a></h2>
<p class="Pp">The above (somewhat contrived) case involves extracting data from
    a bunch of pre-existing HTML files. In that sort of situation, if your code
    works for all the files, then you know that the code <i>works</i> -- since
    the data it's meant to handle won't go changing or growing; and, typically,
    once you've used the program, you'll never need to use it again.</p>
<p class="Pp">The other kind of situation faced in many data extraction tasks is
    where the program is used recurringly to handle new data -- such as from
    ever-changing Web pages. As a real-world example of this, consider a program
    that you could use (suppose it's crontabbed) to extract headline-links from
    subsections of Yahoo News
    (<span class="Li">&quot;http://dailynews.yahoo.com/&quot;</span>).</p>
<p class="Pp">Yahoo News has several subsections:</p>
<dl class="Bl-tag">
  <dt id="http://dailynews.yahoo.com/h/tc/"><a class="permalink" href="#http://dailynews.yahoo.com/h/tc/">http://dailynews.yahoo.com/h/tc/
    for technology news</a></dt>
  <dd></dd>
  <dt id="http://dailynews.yahoo.com/h/sc/"><a class="permalink" href="#http://dailynews.yahoo.com/h/sc/">http://dailynews.yahoo.com/h/sc/
    for science news</a></dt>
  <dd></dd>
  <dt id="http://dailynews.yahoo.com/h/hl/"><a class="permalink" href="#http://dailynews.yahoo.com/h/hl/">http://dailynews.yahoo.com/h/hl/
    for health news</a></dt>
  <dd></dd>
  <dt id="http://dailynews.yahoo.com/h/wl/"><a class="permalink" href="#http://dailynews.yahoo.com/h/wl/">http://dailynews.yahoo.com/h/wl/
    for world news</a></dt>
  <dd></dd>
  <dt id="http://dailynews.yahoo.com/h/en/"><a class="permalink" href="#http://dailynews.yahoo.com/h/en/">http://dailynews.yahoo.com/h/en/
    for entertainment news</a></dt>
  <dd></dd>
</dl>
<p class="Pp">and others. All of them are built on the same basic HTML template
    -- and a scarily complicated template it is, especially when you look at it
    with an eye toward making up rules that will select where the real
    headline-links are, while screening out all the links to other parts of
    Yahoo, other news services, etc. You will need to puzzle over the HTML
    source, and scrutinize the output of
    <span class="Li">&quot;$tree-&gt;dump&quot;</span> on the parse tree of that
    HTML.</p>
<p class="Pp">Sometimes the only way to pin down what you're after is by
    position in the tree. For example, headlines of interest may be in the third
    column of the second row of the second table element in a page:</p>
<p class="Pp"></p>
<pre>  my $table = ( $tree-&gt;look_down('_tag','table') )[1];
  my $row2  = ( $table-&gt;look_down('_tag', 'tr' ) )[1];
  my $col3  = ( $row2-&gt;look-down('_tag', 'td')   )[2];
  ...then do things with $col3...
</pre>
<p class="Pp">Or they may be all the links in a &quot;p&quot; element that has
    at least three &quot;br&quot; elements as children:</p>
<p class="Pp"></p>
<pre>  my $p = $tree-&gt;look_down(
    '_tag', 'p',
    sub {
      2 &lt; grep { ref($_) and $_-&gt;tag eq 'br' }
               $_[0]-&gt;content_list
    }
  );
  @links = $p-&gt;look_down('_tag', 'a');
</pre>
<p class="Pp">But almost always, you can get away with looking for properties of
    the of the thing itself, rather than just looking for contexts. Now, if
    you're lucky, the document you're looking through has clear semantic
    tagging, such is as useful in CSS -- note the class=&quot;headlinelink&quot;
    bit here:</p>
<p class="Pp"></p>
<pre>  &lt;a href=&quot;...long_news_url...&quot; class=&quot;headlinelink&quot;&gt;Elvis
  seen in tortilla&lt;/a&gt;
</pre>
<p class="Pp">If you find anything like that, you could leap right in and select
    links with:</p>
<p class="Pp"></p>
<pre>  @links = $tree-&gt;look_down('class','headlinelink');
</pre>
<p class="Pp">Regrettably, your chances of seeing any sort of semantic markup
    principles really being followed with actual HTML are pretty thin.</p>
<p class="Pp"></p>
<div class="Bd-indent">Footnote: In fact, your chances of finding a page that is
  simply free of HTML errors are even thinner. And surprisingly, sites like
  Amazon or Yahoo are typically worse as far as quality of code than personal
  sites whose entire production cycle involves simply being saved and uploaded
  from Netscape Composer.</div>
<p class="Pp">The code may be sort of &quot;accidentally semantic&quot;, however
    -- for example, in a set of pages I was scanning recently, I found that
    looking for &quot;td&quot; elements with a &quot;width&quot; attribute value
    of &quot;375&quot; got me exactly what I wanted. No-one designing that page
    ever conceived of &quot;width=375&quot; as <i>meaning</i> &quot;this is a
    headline&quot;, but if you impute it to mean that, it works.</p>
<p class="Pp">An approach like this happens to work for the Yahoo News code,
    because the headline-links are distinguished by the fact that they (and they
    alone) contain a &quot;b&quot; element:</p>
<p class="Pp"></p>
<pre>  &lt;a href=&quot;...long_news_url...&quot;&gt;&lt;b&gt;Elvis seen in tortilla&lt;/b&gt;&lt;/a&gt;
</pre>
<p class="Pp">or, diagrammed as a part of the parse tree:</p>
<p class="Pp"></p>
<pre>  . a  [href=&quot;...long_news_url...&quot;]
    . b
      . &quot;Elvis seen in tortilla&quot;
</pre>
<p class="Pp">A rule that matches these can be formalized as &quot;look for any
    'a' element that has only one daughter node, which must be a 'b'
    element&quot;. And this is what it looks like when cooked up as a
    <span class="Li">&quot;look_down&quot;</span> expression and prefaced with a
    bit of code that retrieves the text of the given Yahoo News page and feeds
    it to TreeBuilder:</p>
<p class="Pp"></p>
<pre>  use strict;
  use HTML::TreeBuilder 2.97;
  use LWP::UserAgent;
  sub get_headlines {
    my $url = $_[0] || die &quot;What URL?&quot;;
    
    my $response = LWP::UserAgent-&gt;new-&gt;request(
      HTTP::Request-&gt;new( GET =&gt; $url )
    );
    unless($response-&gt;is_success) {
      warn &quot;Couldn't get $url: &quot;, $response-&gt;status_line, &quot;\n&quot;;
      return;
    }
    
    my $tree = HTML::TreeBuilder-&gt;new();
    $tree-&gt;parse($response-&gt;content);
    $tree-&gt;eof;
    
    my @out;
    foreach my $link (
      $tree-&gt;look_down(   # !
        '_tag', 'a',
        sub {
          return unless $_[0]-&gt;attr('href');
          my @c = $_[0]-&gt;content_list;
          @c == 1 and ref $c[0] and $c[0]-&gt;tag eq 'b';
        }
      )
    ) {
      push @out, [ $link-&gt;attr('href'), $link-&gt;as_text ];
    }
    
    warn &quot;Odd, fewer than 6 stories in $url!&quot; if @out &lt; 6;
    $tree-&gt;delete;
    return @out;
  }
</pre>
<p class="Pp">...and add a bit of code to actually call that routine and display
    the results...</p>
<p class="Pp"></p>
<pre>  foreach my $section (qw[tc sc hl wl en]) {
    my @links = get_headlines(
      &quot;http://dailynews.yahoo.com/h/$section/&quot;
    );
    print
      $section, &quot;: &quot;, scalar(@links), &quot; stories\n&quot;,
      map((&quot;  &quot;, $_-&gt;[0], &quot; : &quot;, $_-&gt;[1], &quot;\n&quot;), @links),
      &quot;\n&quot;;
  }
</pre>
<p class="Pp">And we've got our own headline-extractor service! This in and of
    itself isn't no amazingly useful (since if you want to see the headlines,
    you <i>can</i> just look at the Yahoo News pages), but it could easily be
    the basis for quite useful features like filtering the headlines for
    matching certain keywords of interest to you.</p>
<p class="Pp">Now, one of these days, Yahoo News will decide to change its HTML
    template. When this happens, this will appear to the above program as there
    being no links that meet the given criteria; or, less likely, dozens of
    erroneous links will meet the criteria. In either case, the criteria will
    have to be changed for the new template; they may just need adjustment, or
    you may need to scrap them and start over.</p>
</section>
<section class="Ss">
<h2 class="Ss"><i>Regardez, duvet!</i></h2>
<p class="Pp">It's often quite a challenge to write criteria to match the
    desired parts of an HTML parse tree. Very often you <i>can</i> pull it off
    with a simple <span class="Li">&quot;$tree-&gt;look_down('_tag',
    'h1')&quot;</span>, but sometimes you do have to keep adding and refining
    criteria, until you might end up with complex filters like what I've shown
    in this article. The benefit to learning how to deal with HTML parse trees
    is that one main search tool, the
    <span class="Li">&quot;look_down&quot;</span> method, can do most of the
    work, making simple things easy, while still making hard things
  possible.</p>
<p class="Pp"><b>[end body of article]</b></p>
</section>
<section class="Ss">
<h2 class="Ss" id="_Author_Credit_"><a class="permalink" href="#_Author_Credit_">[Author
  Credit]</a></h2>
<p class="Pp">Sean M. Burke
    (<span class="Li">&quot;sburke@cpan.org&quot;</span>) is the current
    maintainer of <span class="Li">&quot;HTML::TreeBuilder&quot;</span> and
    <span class="Li">&quot;HTML::Element&quot;</span>, both originally by Gisle
    Aas.</p>
<p class="Pp">Sean adds: &quot;I'd like to thank the folks who listened to me
    ramble incessantly about HTML::TreeBuilder and HTML::Element at this year's
    Yet Another Perl Conference and O'Reilly Open Source Software
    Convention.&quot;</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BACK"><a class="permalink" href="#BACK">BACK</a></h1>
<p class="Pp">Return to the HTML::Tree docs.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-11-05</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

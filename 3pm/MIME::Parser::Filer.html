<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>MIME::Parser::Filer(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">MIME::Parser::Filer(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">MIME::Parser::Filer(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">MIME::Parser::Filer - manage file-output of the parser</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">Before reading further, you should see MIME::Parser to make sure
    that you understand where this module fits into the grand scheme of things.
    Go on, do it now. I'll wait.</p>
<p class="Pp">Ready? Ok... now read &quot;DESCRIPTION&quot; below, and
    everything else should make sense.</p>
<section class="Ss">
<h2 class="Ss" id="Public_interface"><a class="permalink" href="#Public_interface">Public
  interface</a></h2>
<pre>    ### Create a &quot;filer&quot; of the desired class:
    my $filer = MIME::Parser::FileInto-&gt;new($dir);
    my $filer = MIME::Parser::FileUnder-&gt;new($basedir);
    ...
    ### Want added security?  Don't let outsiders name your files:
    $filer-&gt;ignore_filename(1);
    ### Prepare for the parsing of a new top-level message:
    $filer-&gt;init_parse;
    ### Return the path where this message's data should be placed:
    $path = $filer-&gt;output_path($head);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Semi-public_interface"><a class="permalink" href="#Semi-public_interface">Semi-public
  interface</a></h2>
<p class="Pp">These methods might be overridden or ignored in some subclasses,
    so they don't all make sense in all circumstances:</p>
<p class="Pp"></p>
<pre>    ### Tweak the mapping from content-type to extension:
    $emap = $filer-&gt;output_extension_map;
    $emap-&gt;{&quot;text/html&quot;} = &quot;.htm&quot;;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<section class="Ss">
<h2 class="Ss" id="How_this_class_is_used_when_parsing"><a class="permalink" href="#How_this_class_is_used_when_parsing">How
  this class is used when parsing</a></h2>
<p class="Pp">When a MIME::Parser decides that it wants to output a file to
    disk, it uses its &quot;Filer&quot; object -- an instance of a
    MIME::Parser::Filer subclass -- to determine where to put the file.</p>
<p class="Pp">Every parser has a single Filer object, which it uses for all
    parsing. You can get the Filer for a given <span class="Li">$parser</span>
    like this:</p>
<p class="Pp"></p>
<pre>    $filer = $parser-&gt;filer;
</pre>
<p class="Pp">At the beginning of each
    <span class="Li">&quot;parse()&quot;</span>, the filer's internal state is
    reset by the parser:</p>
<p class="Pp"></p>
<pre>    $parser-&gt;filer-&gt;init_parse;
</pre>
<p class="Pp">The parser can then get a path for each entity in the message by
    handing that entity's header (a MIME::Head) to the filer and having it do
    the work, like this:</p>
<p class="Pp"></p>
<pre>    $new_file = $parser-&gt;filer-&gt;output_path($head);
</pre>
<p class="Pp">Since it's nice to be able to clean up after a parse (especially a
    failed parse), the parser tells the filer when it has actually used a
  path:</p>
<p class="Pp"></p>
<pre>    $parser-&gt;filer-&gt;purgeable($new_file);
</pre>
<p class="Pp">Then, if you want to clean up the files which were created for a
    particular parse (and also any directories that the Filer created), you
    would do this:</p>
<p class="Pp"></p>
<pre>    $parser-&gt;filer-&gt;purge;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Writing_your_own_subclasses"><a class="permalink" href="#Writing_your_own_subclasses">Writing
  your own subclasses</a></h2>
<p class="Pp">There are two standard &quot;Filer&quot; subclasses (see below):
    <b>MIME::Parser::FileInto</b>, which throws all files from all parses into
    the same directory, and <b>MIME::Parser::FileUnder</b> (preferred), which
    creates a subdirectory for each message. Hopefully, these will be sufficient
    for most uses, but just in case...</p>
<p class="Pp">The only method you have to override is <b>output_path()</b>:</p>
<p class="Pp"></p>
<pre>    $filer-&gt;output_path($head);
</pre>
<p class="Pp">This method is invoked by MIME::Parser when it wants to put a
    decoded message body in an output file. The method should return a path to
    the file to create. Failure is indicated by throwing an exception.</p>
<p class="Pp">The path returned by
    <span class="Li">&quot;output_path()&quot;</span> should be &quot;ready for
    <b>open()</b>&quot;: any necessary parent directories need to exist at that
    point. These directories can be created by the Filer, if course, and they
    should be marked as <b></b><b>purgeable()</b><b></b> if a purge should
    delete them.</p>
<p class="Pp">Actually, if your issue is more <i>where</i> the files go than
    what they're named, you can use the default <b>output_path()</b> method and
    just override one of its components:</p>
<p class="Pp"></p>
<pre>    $dir  = $filer-&gt;output_dir($head);
    $name = $filer-&gt;output_filename($head);
    ...
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="PUBLIC_INTERFACE"><a class="permalink" href="#PUBLIC_INTERFACE">PUBLIC
  INTERFACE</a></h1>
<section class="Ss">
<h2 class="Ss" id="MIME::Parser::Filer"><a class="permalink" href="#MIME::Parser::Filer">MIME::Parser::Filer</a></h2>
<p class="Pp">This is the abstract superclass of all &quot;filer&quot;
  objects.</p>
<dl class="Bl-tag">
  <dt id="new"><a class="permalink" href="#new">new INITARGS...</a></dt>
  <dd><i>Class method, constructor.</i> Create a new outputter for the given
      parser. Any subsequent arguments are given to <b>init()</b>, which
      subclasses should override for their own use (the default init does
      nothing).</dd>
  <dt id="results"><a class="permalink" href="#results">results RESULTS</a></dt>
  <dd><i>Instance method.</i> Link this filer to a MIME::Parser::Results object
      which will tally the messages. Notice that we avoid linking it to the
      parser to avoid circular reference!</dd>
  <dt id="init_parse"><a class="permalink" href="#init_parse">init_parse</a></dt>
  <dd><i>Instance method.</i> Prepare to start parsing a new message. Subclasses
      should always be sure to invoke the inherited method.</dd>
  <dt id="evil_filename"><a class="permalink" href="#evil_filename">evil_filename
    FILENAME</a></dt>
  <dd><i>Instance method.</i> Is this an evil filename; i.e., one which should
      not be used in generating a disk file name? It is if any of these are
      true:
    <p class="Pp"></p>
    <pre>    * it is empty or entirely whitespace
    * it contains leading or trailing whitespace
    * it is a string of dots: &quot;.&quot;, &quot;..&quot;, etc.
    * it contains characters not in the set: &quot;A&quot; - &quot;Z&quot;, &quot;a&quot; - &quot;z&quot;,
      &quot;0&quot; - &quot;9&quot;, &quot;-&quot;, &quot;_&quot;, &quot;+&quot;, &quot;=&quot;, &quot;.&quot;, &quot;,&quot;, &quot;@&quot;, &quot;#&quot;,
      &quot;$&quot;, and &quot; &quot;.
    * it is too long
    </pre>
    <p class="Pp">If you just want to change this behavior, you should override
        this method in the subclass of MIME::Parser::Filer that you use.</p>
    <p class="Pp"><b>Warning:</b> at the time this method is invoked, the
        FILENAME has already been unmime'd into the local character set. If
        you're using any character set other than ASCII, ISO-8859-*, or UTF-8,
        the interpretation of the &quot;path&quot; characters might be very
        different, and you will probably need to override this method. See
        &quot;unmime&quot; in MIME::WordDecoder for more details.</p>
    <p class="Pp"><b>Note:</b> subclasses of MIME::Parser::Filer which override
        <b>output_path()</b> might not consult this method; note, however, that
        the built-in subclasses do consult it.</p>
    <p class="Pp"><i>Thanks to Andrew Pimlott for finding a real dumb bug in the
        original</i> <i>version. Thanks to Nickolay Saukh for noting that evil
        is in the</i> <i>eye of the beholder.</i></p>
  </dd>
  <dt id="exorcise_filename"><a class="permalink" href="#exorcise_filename">exorcise_filename
    FILENAME</a></dt>
  <dd><i>Instance method.</i> If a given filename is evil (see
      &quot;evil_filename&quot;) we try to rescue it by performing some basic
      operations: shortening it, removing bad characters, etc., and checking
      each against <b>evil_filename()</b>.
    <p class="Pp">Returns the exorcised filename (which is guaranteed to not be
        evil), or undef if it could not be salvaged.</p>
    <p class="Pp"><b>Warning:</b> at the time this method is invoked, the
        FILENAME has already been unmime'd into the local character set. If
        you're using anything character set other than ASCII, ISO-8859-*, or
        UTF-8, the interpretation of the &quot;path&quot; characters might be
        very very different, and you will probably need to override this method.
        See &quot;unmime&quot; in MIME::WordDecoder for more details.</p>
  </dd>
  <dt id="find_unused_path"><a class="permalink" href="#find_unused_path">find_unused_path
    DIR, FILENAME</a></dt>
  <dd><i>Instance method, subclasses only.</i> We have decided on an output
      directory and tentative filename, but there is a chance that it might
      already exist. Keep adding a numeric suffix &quot;-1&quot;,
      &quot;-2&quot;, etc. to the filename until an unused path is found, and
      then return that path.
    <p class="Pp">The suffix is actually added before the first &quot;.&quot; in
        the filename is there is one; for example:</p>
    <p class="Pp"></p>
    <pre>    picture.gif       archive.tar.gz      readme
    picture-1.gif     archive-1.tar.gz    readme-1
    picture-2.gif     archive-2.tar.gz    readme-2
    ...               ...                 ...
    picture-10.gif
    ...
    </pre>
    <p class="Pp">This can be a costly operation, and risky if you don't want
        files renamed, so it is in your best interest to minimize situations
        where these kinds of collisions occur. Unfortunately, if a multipart
        message gives all of its parts the same recommended filename, and you
        are placing them all in the same directory, this method might be
        unavoidable.</p>
  </dd>
  <dt id="ignore_filename"><a class="permalink" href="#ignore_filename">ignore_filename
    [YESNO]</a></dt>
  <dd><i>Instance method.</i> Return true if we should always ignore recommended
      filenames in messages, choosing instead to always generate our own
      filenames. With argument, sets this value.
    <p class="Pp"><b>Note:</b> subclasses of MIME::Parser::Filer which override
        <b>output_path()</b> might not honor this setting; note, however, that
        the built-in subclasses honor it.</p>
  </dd>
  <dt id="output_dir"><a class="permalink" href="#output_dir">output_dir
    HEAD</a></dt>
  <dd><i>Instance method.</i> Return the output directory for the given header.
      The default method returns &quot;.&quot;.</dd>
  <dt id="output_filename"><a class="permalink" href="#output_filename">output_filename
    HEAD</a></dt>
  <dd><i>Instance method, subclasses only.</i> A given recommended filename was
      either not given, or it was judged to be evil. Return a fake name,
      possibly using information in the message HEADer. Note that this is just
      the filename, not the full path.
    <p class="Pp">Used by <b>output_path()</b>. If you're using the default
        <span class="Li">&quot;output_path()&quot;</span>, you probably don't
        need to worry about avoiding collisions with existing files; we take
        care of that in <b>find_unused_path()</b>.</p>
  </dd>
  <dt id="output_prefix"><a class="permalink" href="#output_prefix">output_prefix
    [PREFIX]</a></dt>
  <dd><i>Instance method.</i> Get the short string that all filenames for
      extracted body-parts will begin with (assuming that there is no better
      &quot;recommended filename&quot;). The default is <i>&quot;msg&quot;</i>.
    <p class="Pp">If PREFIX <i>is not</i> given, the current output prefix is
        returned. If PREFIX <i>is</i> given, the output prefix is set to the new
        value, and the previous value is returned.</p>
    <p class="Pp">Used by <b>output_filename()</b>.</p>
    <p class="Pp"><b>Note:</b> subclasses of MIME::Parser::Filer which override
        <b>output_path()</b> or <b>output_filename()</b> might not honor this
        setting; note, however, that the built-in subclasses honor it.</p>
  </dd>
  <dt id="output_type_ext"><a class="permalink" href="#output_type_ext">output_type_ext</a></dt>
  <dd><i>Instance method.</i> Return a reference to the hash used by the default
      <b>output_filename()</b> for mapping from content-types to extensions when
      there is no default extension to use.
    <p class="Pp"></p>
    <pre>    $emap = $filer-&gt;output_typemap;
    $emap-&gt;{'text/plain'} = '.txt';
    $emap-&gt;{'text/html'}  = '.html';
    $emap-&gt;{'text/*'}     = '.txt';
    $emap-&gt;{'*/*'}        = '.dat';
    </pre>
    <p class="Pp"><b>Note:</b> subclasses of MIME::Parser::Filer which override
        <b>output_path()</b> or <b>output_filename()</b> might not consult this
        hash; note, however, that the built-in subclasses consult it.</p>
  </dd>
  <dt id="output_path"><a class="permalink" href="#output_path">output_path
    HEAD</a></dt>
  <dd><i>Instance method, subclasses only.</i> Given a MIME head for a file to
      be extracted, come up with a good output pathname for the extracted file.
      This is the only method you need to worry about if you are building a
      custom filer.
    <p class="Pp">The default implementation does a lot of work; subclass
        implementers <i>really</i> should try to just override its components
        instead of the whole thing. It works basically as follows:</p>
    <p class="Pp"></p>
    <pre>    $directory = $self-&gt;output_dir($head);
    $filename = $head-&gt;recommended_filename();
    if (!$filename or
         $self-&gt;ignore_filename() or
         $self-&gt;evil_filename($filename)) {
        $filename = $self-&gt;output_filename($head);
    }
    return $self-&gt;find_unused_path($directory, $filename);
    </pre>
    <p class="Pp"><b>Note:</b> There are many, many, many ways you might want to
        control the naming of files, based on your application. If you don't
        like the behavior of this function, you can easily define your own
        subclass of MIME::Parser::Filer and override it there.</p>
    <p class="Pp"><b>Note:</b> Nickolay Saukh pointed out that, given the
        subjective nature of what is &quot;evil&quot;, this function really
        shouldn't <i>warn</i> about an evil filename, but maybe just issue a
        <i>debug</i> message. I considered that, but then I thought: if
        debugging were off, people wouldn't know why (or even if) a given
        filename had been ignored. In mail robots that depend on
        externally-provided filenames, this could cause hard-to-diagnose
        problems. So, the message is still a warning.</p>
    <p class="Pp"><i>Thanks to Laurent Amon for pointing out problems with the
        original</i> <i>implementation, and for making some good suggestions.
        Thanks also to</i> <i>Achim Bohnet for pointing out that there should be
        a hookless, OO way of</i> <i>overriding the output path.</i></p>
  </dd>
  <dt id="purge"><a class="permalink" href="#purge">purge</a></dt>
  <dd><i>Instance method, final.</i> Purge all files/directories created by the
      last parse. This method simply goes through the purgeable list in reverse
      order (see &quot;purgeable&quot;) and removes all existing
      files/directories in it. You should not need to override this method.</dd>
  <dt id="purgeable"><a class="permalink" href="#purgeable">purgeable
    [FILE]</a></dt>
  <dd><i>Instance method, final.</i> Add FILE to the list of
      &quot;purgeable&quot; files/directories (those which will be removed if
      you do a <span class="Li">&quot;purge()&quot;</span>). You should not need
      to override this method.
    <p class="Pp">If FILE is not given, the &quot;purgeable&quot; list is
        returned. This may be used for more-sophisticated purging.</p>
    <p class="Pp">As a special case, invoking this method with a FILE that is an
        arrayref will replace the purgeable list with a copy of the array's
        contents, so [] may be used to clear the list.</p>
    <p class="Pp">Note that the &quot;purgeable&quot; list is cleared when a
        parser begins a new parse; therefore, if you want to use <b>purge()</b>
        to do cleanup, you <i>must</i> do so <i>before</i> starting a new
      parse!</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="MIME::Parser::FileInto"><a class="permalink" href="#MIME::Parser::FileInto">MIME::Parser::FileInto</a></h2>
<p class="Pp">This concrete subclass of MIME::Parser::Filer supports filing into
    a given directory.</p>
<dl class="Bl-tag">
  <dt id="init"><a class="permalink" href="#init">init DIRECTORY</a></dt>
  <dd><i>Instance method, initiallizer.</i> Set the directory where all files
      will go.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="MIME::Parser::FileUnder"><a class="permalink" href="#MIME::Parser::FileUnder">MIME::Parser::FileUnder</a></h2>
<p class="Pp">This concrete subclass of MIME::Parser::Filer supports filing
    under a given directory, using one subdirectory per message, but with all
    message parts in the same directory.</p>
<dl class="Bl-tag">
  <dt id="init~2"><a class="permalink" href="#init~2">init BASEDIR,
    OPTSHASH...</a></dt>
  <dd><i>Instance method, initiallizer.</i> Set the base directory which will
      contain the message directories. If used, then each parse of begins by
      creating a new subdirectory of BASEDIR where the actual parts of the
      message are placed. OPTSHASH can contain the following:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="DirName"><a class="permalink" href="#DirName">DirName</a></dt>
  <dd>Explicitly set the name of the subdirectory which is created. The default
      is to use the time, process id, and a sequence number, but you might want
      a predictable directory.</dd>
  <dt id="Purge"><a class="permalink" href="#Purge">Purge</a></dt>
  <dd>Automatically purge the contents of the directory (including all
      subdirectories) before each parse. This is really only needed if using an
      explicit DirName, and is provided as a convenience only. Currently we use
      the 1-arg form of File::Path::rmtree; you should familiarize yourself with
      the caveats therein.</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">The <b>output_dir()</b> will return the path to this
    message-specific directory until the next parse is begun, so you can do
    this:</p>
<p class="Pp"></p>
<pre>    use File::Path;
    $parser-&gt;output_under(&quot;/tmp&quot;);
    $ent = eval { $parser-&gt;parse_open($msg); };   ### parse
    if (!$ent) {         ### parse failed
        rmtree($parser-&gt;output_dir);
        die &quot;parse failed: $@&quot;;
    }
    else {               ### parse succeeded
        ...do stuff...
    }
</pre>
</div>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">MIME::Tools, MIME::Parser</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Eryq (<i>eryq@zeegee.com</i>), ZeeGee Software Inc
    (<i>http://www.zeegee.com</i>).</p>
<p class="Pp">All rights reserved. This program is free software; you can
    redistribute it and/or modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-08-13</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

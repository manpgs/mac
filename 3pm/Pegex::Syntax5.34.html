<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Pegex::Syntax(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Pegex::Syntax(3)</td>
    <td class="head-vol"><a href=".">User Contributed Perl Documentation</a></td>
    <td class="head-rtitle">Pegex::Syntax(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="Pegex_Syntax"><a class="permalink" href="#Pegex_Syntax">Pegex
  Syntax</a></h1>
<p class="Pp">The term &quot;Pegex&quot; can be used to mean both the Pegex
    Parser Framework and also the Pegex Grammar Language Syntax that is used to
    write Pegex grammar files. This document details the Pegex Syntax.</p>
<p class="Pp">Pegex is a self-hosting language. That means that the grammar for
    defining the Pegex Language is written in the Pegex Language itself. You can
    see it for yourself here:
    &lt;https://github.com/ingydotnet/pegex-pgx/blob/master/pegex.pgx&gt;.</p>
<p class="Pp">I encourage you to take a quick look at that link even now. A
    Pegex grammar (like this one) is made up of 2 parts: a meta section and a
    rule section.</p>
<p class="Pp">The meta section just contains keyword/value meta attributes about
    the grammar. Things like the grammar's name and version.</p>
<p class="Pp">The real meat of a Pegex grammar is in its rules. The very first
    rule of the grammar above is (basically):</p>
<p class="Pp"></p>
<pre>    grammar: meta_section rule_section
</pre>
<p class="Pp">Which says, a <b>grammar</b> <i>IS</i> a <b>meta_section</b>
    <i>followed by</i> a <b>rule_section</b>. But hey, we already knew that!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Meta_Section"><a class="permalink" href="#Meta_Section">Meta
  Section</a></h1>
<p class="Pp">The meta statements ate the top of a grammar file look like
  this:</p>
<p class="Pp"></p>
<pre>    %pegexKeyword value
</pre>
<p class="Pp">Let's look at the top the the pegex.pgx grammar:</p>
<p class="Pp"></p>
<pre>    # This is the Pegex grammar for Pegex grammars!
    %grammar pegex
    %version 0.1.0
</pre>
<p class="Pp">This defines two meta values:
    <span class="Li">&quot;grammar&quot;</span> and
    <span class="Li">&quot;version&quot;</span>, which specify the name and the
    version of the grammar, respectively.</p>
<p class="Pp">You'll also notice that the first line is a comment. Comments
    start with a <span class="Li">&quot;#&quot;</span> and go until the end of
    the line. Comments are allowed almost anywhere in the grammar, both on their
    own lines, after statements, and even within regex definitions as we will
    see later.</p>
<p class="Pp">The Pegex Meta Section ends when the Pegex Rule Section begins
    (with the first rule definition).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Rule_Section"><a class="permalink" href="#Rule_Section">Rule
  Section</a></h1>
<p class="Pp">The remainder of a Pegex grammar is a set of named rules. Each
    rule is a rule name, followed by a ':', followed by the definition of the
    rule, followed by a ';' or a newline.</p>
<p class="Pp">Here are a couple rules from the pegex.pgx grammar. (These are the
    rules that start to define a rule!).</p>
<p class="Pp"></p>
<pre>    rule_definition:
        rule_start
        rule_group
        ending
    rule_start: /
        ( rule_name )     # Capture the rule_name
        BLANK*
        COLON -
    /
</pre>
<p class="Pp">Rule definitions are infix expressions. They consist of tokens
    separated by operators, with parentheses to disambiguate binding precedence.
    There are 3 distinct tokens and 3 operators.</p>
<p class="Pp">The 3 token types are: rule-reference, regex and error-message.
    The 3 operators are AND (' '), OR ('|') and ALT ('%', '%%').</p>
<p class="Pp">Here's an example from a Pegex grammar for parsing JSON:</p>
<p class="Pp"></p>
<pre>    json: hash | array
    array: / LSQUARE / ( node* % / COMMA / ) (
        / RSQUARE / | `missing ']'` )
</pre>
<p class="Pp">This is saying: &quot;json is either a hash or array. array is
    '[', zero or more nodes separated by commas, and a ']'. error if no
    ']'&quot;.</p>
<p class="Pp"><span class="Li">&quot;hash&quot;</span>,
    <span class="Li">&quot;array&quot;</span> and
    <span class="Li">&quot;node&quot;</span> are rule references, meaning that
    they refer to named rules within the grammar that must match at that point.
    Text surrounded by a pair of '/' chars forms a regex. Text surrounding by
    backticks is an error message.</p>
<p class="Pp"><span class="Li">&quot;LSQUARE&quot;</span>,
    <span class="Li">&quot;RSQUARE&quot;</span> and
    <span class="Li">&quot;COMMA&quot;</span> are also rule references. Rules
    may be referred to inside of regexes, as long as they refer to regexes
    themselves. In this way big regexes can be assembled from smaller ones, thus
    leading to reuse and readability. Finally, the '*' after
    <span class="Li">&quot;node&quot;</span> is called a &quot;quantifier&quot;.
    More about those later.</p>
<section class="Ss">
<h2 class="Ss" id="Rule_References"><a class="permalink" href="#Rule_References">Rule
  References</a></h2>
<p class="Pp">A rule reference is the name of a rule inside angle brackets. The
    brackets are usually optional. Inside a regex, a rule reference without
    <span class="Li">&quot;&lt;&gt;&quot;</span> must be preceded by a
    whitespace character.</p>
<p class="Pp"></p>
<pre>    &lt;sub_rule_name&gt;
    sub_rule_name
</pre>
<p class="Pp">When used outside a regex, a reference can have a number of prefix
    modifiers. Note the the angle brackets are not required here, but add to
    readability.</p>
<p class="Pp"></p>
<pre>    =rule  # Zero-width positive assertion (look-ahead)
    !rule  # Zero-width negative assertion (look-ahead)
    .rule  # Skip (ie: parse but don't capture a subpattern)
    -rule  # Flat (flatten the array captures)
    +rule  # Always wrap
</pre>
<p class="Pp">(Skipping and wrapping are explained in [Return Values].)</p>
<p class="Pp">A reference can also have a number of suffixed quantifiers.
    Similar to regular expression syntax, a quantifier indicates how many times
    a rule (reference) should match.</p>
<p class="Pp"></p>
<pre>    rule?      # optional
    rule*      # 0 or more times
    rule+      # 1 or more times
    &lt;rule&gt;8    # exactly 8 times
    &lt;rule&gt;2+   # 2 or more times
    &lt;rule&gt;2-3  # 2 or 3 times
    &lt;rule&gt;0-6  # 0 to 6 times
</pre>
<p class="Pp">Note that you must use angle brackets if you are using a numbered
    modifier:</p>
<p class="Pp"></p>
<pre>    rule8    # WRONG!  This would match rule &quot;rule8&quot;.
    rule2+   # WRONG!  This would match rule &quot;rule2&quot;, 1 or more times.
    rule2-3  # WRONG!  Pegex syntax error
</pre>
<p class="Pp">There is a special set of predefined &quot;Atoms&quot; that refer
    to regular expression fragments. Atoms exist for every punctuation character
    and for characters commonly found in regular expressions. Atoms enhance
    readability in grammar texts, and allow special characters (like slash or
    hash) to be used as Pegex syntax.</p>
<p class="Pp">For example, a regex to match a comment might be '#' followed by
    anything, followed by a newline. In Pegex, you would write:</p>
<p class="Pp"></p>
<pre>    comment: / HASH ANY* EOL /
</pre>
<p class="Pp">instead of:</p>
<p class="Pp"></p>
<pre>    comment: /#.*\r?\n/
</pre>
<p class="Pp">Pegex would compile the former into the latter.</p>
<p class="Pp">Here are some atoms:</p>
<p class="Pp"></p>
<pre>    DASH    # -
    PLUS    # +
    TILDE   # ~
    SLASH   # /
    HASH    # # (literal)
    QMARK   # ? (literal)
    STAR    # * (literal)
    LPAREN  # ( (literal)
    RPAREN  # ) (literal)
    WORD    # \w
    WS      # \s
</pre>
<p class="Pp">The full list can be found in the [Atoms source
    code|&lt;https://metacpan.org/source/Pegex::Grammar::Atoms].&gt;</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Regexes"><a class="permalink" href="#Regexes">Regexes</a></h2>
<p class="Pp">In Pegex we call the syntax for a regular expression a
    &quot;regex&quot;. ie When the term &quot;regex&quot; is used, it is
    referring to Pegex syntax, and when the term &quot;regular expression&quot;
    is used it refers to the actual regular expression that the regex is
    compiled into.</p>
<p class="Pp">A regex is a string inside forward slashes.</p>
<p class="Pp"></p>
<pre>    /regex/
</pre>
<p class="Pp">The regex syntax mostly follows Perl, with the following
    exceptions:</p>
<p class="Pp"></p>
<pre>    # Any rules in angle brackets are referenced in the regex
    / ( &lt;rule1&gt; | 'non_rule' ) /  # &quot;non_rule&quot; is interpreted literally
    # The syntax implies a /x modifier, so whitespace and comments are
    # ignored.
    / (
        rule1+   # Match rule1 one or more times
        |
        rule2
    ) /
    # Whitespace is declared with dash and plus.
    / - rule3 + /  # - = \s*, + = \s+, etc.
    # Any (?XX ) syntax can have the question mark removed
    / (: a | b ) /  # same as / (?: a | b ) /
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Error_Message"><a class="permalink" href="#Error_Message">Error
  Message</a></h2>
<p class="Pp">An error message is a string inside backticks. If the parser gets
    to an error message in the grammar, it throws a parse error with that
    message.</p>
<p class="Pp"></p>
<pre>    `error message`
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Operators"><a class="permalink" href="#Operators">Operators</a></h2>
<p class="Pp">The Pegex operators in descending precedence order are: ALT, AND,
    and OR.</p>
<p class="Pp">AND and OR are the most common operators. AND is represented by
    the absence of an operator. Like in these rules:</p>
<p class="Pp"></p>
<pre>    r1: &lt;a&gt;&lt;b&gt;
    r2: a b
</pre>
<p class="Pp">Those are both the same. They mean rule
    <span class="Li">&quot;a&quot;</span> AND (followed immediately by) rule
    <span class="Li">&quot;b&quot;</span>.</p>
<p class="Pp">OR means match one or the other.</p>
<p class="Pp"></p>
<pre>    r: a | b | c
</pre>
<p class="Pp">means match rule <span class="Li">&quot;a&quot;</span> OR rule
    <span class="Li">&quot;b&quot;</span> OR rule
    <span class="Li">&quot;c&quot;</span>. The rules are checked in order and if
    one matches, the others are skipped.</p>
<p class="Pp">ALT means alternation. It's a way to specify a separator in a
    list.</p>
<p class="Pp"></p>
<pre>    r: a+ % b
</pre>
<p class="Pp">would match these:</p>
<p class="Pp"></p>
<pre>    a
    aba
    ababa
</pre>
<p class="Pp"><span class="Li">&quot;%%&quot;</span> means that a trailing
    separator is optional.</p>
<p class="Pp"></p>
<pre>    r: a+ %% b
</pre>
<p class="Pp">would match these:</p>
<p class="Pp"></p>
<pre>    a
    ab
    aba
    abab
</pre>
<p class="Pp">ANY operators take precedence over everything else, similar to
    other parsers. These rules have the same binding precedence:</p>
<p class="Pp"></p>
<pre>    r1: a b | c % d
    r2: (a b) | (c % d)
</pre>
<p class="Pp">Parens are not only used for indicating binding precedence; they
    also can create quantifiable groups:</p>
<p class="Pp"></p>
<pre>    r1: (a b)+ c
</pre>
<p class="Pp">would match:</p>
<p class="Pp"></p>
<pre>    abababac
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Return_Values"><a class="permalink" href="#Return_Values">Return
  Values</a></h1>
<p class="Pp">All return values are based on the capture groups
    (<span class="Li">&quot;$1/$2/$3/etc.&quot;</span> type variables) of parsed
    RE statements. The exact structure of the result tree depends on the type of
    Receiver used. For example, Pegex::Tree will return:</p>
<p class="Pp"></p>
<pre>    $1              # single capture group
    [ @+[1..$#+] ]  # multiple capture groups
</pre>
<p class="Pp">This would be a match directly from the RE rule. As rules go
    further back, things are put into arrays, but only if there is more than one
    result. For example:</p>
<p class="Pp"></p>
<pre>    r: (a b)+ % +
    a: /( ALPHA+ )/
    b: /( DIGIT+ )( PLUS )/
    # input = foobar123+
    # output (using Pegex::Tree) = [
    #     'foobar', [ '123', '+' ]
    # ]
    #
    # input = foobar123+ boofar789+
    # output (using Pegex::Tree) = [
    #     [ 'foobar', [ '123', '+' ] ],
    #     [ 'boofar', [ '789', '+' ] ],
    # ]
</pre>
<section class="Ss">
<h2 class="Ss" id="Skipping"><a class="permalink" href="#Skipping">Skipping</a></h2>
<p class="Pp">Any rule can use the skip modifier (DOT) to completely skip the
    return from that rule (and any children below it). The rule is still
    processed, but nothing is put into the tree. (This is different from, say,
    putting <span class="Li">&quot;undef&quot;</span> into the return.) This can
    also affect the number of values returned, and thus, whether a value comes
    as an array:</p>
<p class="Pp"></p>
<pre>    r: (a .b)+ % +
    a: /( ALPHA+ )/
    b: /( DIGIT+ )( PLUS )/
    # input = foobar123+ boofar789+
    # output (using Pegex::Tree) = [
    #     'foobar',
    #     'boofar',
    # ]
</pre>
<p class="Pp">The skip modifier can also be used with groups. (This is the only
    group modifier allowed so far.)</p>
<p class="Pp"></p>
<pre>    r: .(a b)+ % +
    a: /( ALPHA+ )/
    b: /( DIGIT+ )( PLUS )/
    # output (using Pegex::Tree) = []
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Wrapping"><a class="permalink" href="#Wrapping">Wrapping</a></h2>
<p class="Pp">You can also turn on &quot;wrapping&quot; with the
    Pegex::Tree::Wrap receiver. This will wrap all match values in a hash with
    the rule name, like so:</p>
<p class="Pp"></p>
<pre>    { rule_A =&gt; $match }
    { rule_B =&gt; [ @matches ] }
</pre>
<p class="Pp">Note that this behavior can be &quot;hard set&quot; with the
    <span class="Li">&quot;+/-&quot;</span> rule modifiers:</p>
<p class="Pp"></p>
<pre>    -rule  # Flatten array captures
    +rule  # Always wrap (even if using Pegex::Tree)
</pre>
<p class="Pp">This is simply a check in the
    <span class="Li">&quot;gotrule&quot;</span> for the receiver. So, any
    specific <span class="Li">&quot;got_*&quot;</span> receiver methods will
    override even these settings, and choose to pass the match as-is. In this
    case, the <span class="Li">&quot;got_*&quot;</span> sub return value
    dictates what ultimately gets put into the tree object:</p>
<p class="Pp"></p>
<pre>    +rule_A   # in this case, the + is useless here
    sub got_rule_A {
        my ($self, $matches_arrayref) = @_;
        return $matches_arrayref;
        # will be received as [ @matches ]
    }
</pre>
<p class="Pp">You can &quot;correct&quot; this behavior by passing it back to
    <span class="Li">&quot;gotrule&quot;</span>:</p>
<p class="Pp"></p>
<pre>    +rule_A   # now + is honored
    sub got_rule_A {
        my ($self, $matches_arrayref) = @_;
        return $self-&gt;gotrule($matches_arrayref);
        # will be received as { rule_A =&gt; [ @matches ] }
    }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="See_Also"><a class="permalink" href="#See_Also">See
  Also</a></h1>
<ul class="Bl-bullet">
  <li>Pegex::API</li>
  <li>Pegex::Tutorial</li>
  <li>Pegex::Resources</li>
</ul>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-02-13</td>
    <td class="foot-os"><a href="..">perl v5.34.0</a></td>
  </tr>
</table>
</body>
</html>

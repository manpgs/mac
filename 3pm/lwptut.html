<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>lwptut(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">lwptut(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">lwptut(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">lwptut -- An LWP Tutorial</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">LWP (short for &quot;Library for WWW in Perl&quot;) is a very
    popular group of Perl modules for accessing data on the Web. Like most Perl
    module-distributions, each of LWP's component modules comes with
    documentation that is a complete reference to its interface. However, there
    are so many modules in LWP that it's hard to know where to start looking for
    information on how to do even the simplest most common things.</p>
<p class="Pp">Really introducing you to using LWP would require a whole book --
    a book that just happens to exist, called <i>Perl &amp; LWP</i>. But this
    article should give you a taste of how you can go about some common tasks
    with LWP.</p>
<section class="Ss">
<h2 class="Ss" id="Getting_documents_with_LWP::Simple"><a class="permalink" href="#Getting_documents_with_LWP::Simple">Getting
  documents with LWP::Simple</a></h2>
<p class="Pp">If you just want to get what's at a particular URL, the simplest
    way to do it is LWP::Simple's functions.</p>
<p class="Pp">In a Perl program, you can call its
    <span class="Li">&quot;get($url)&quot;</span> function. It will try getting
    that URL's content. If it works, then it'll return the content; but if
    there's some error, it'll return undef.</p>
<p class="Pp"></p>
<pre>
  my $url = 'http://www.npr.org/programs/fa/?todayDate=current';
    # Just an example: the URL for the most recent /Fresh Air/ show

  use LWP::Simple;
  my $content = get $url;
  die &quot;Couldn't get $url&quot; unless defined $content;

  # Then go do things with $content, like this:

  if($content =~ m/jazz/i) {
    print &quot;They're talking about jazz today on Fresh Air!\n&quot;;
  }
  else {
    print &quot;Fresh Air is apparently jazzless today.\n&quot;;
  }
</pre>
<p class="Pp">The handiest variant on <span class="Li">&quot;get&quot;</span> is
    <span class="Li">&quot;getprint&quot;</span>, which is useful in Perl
    one-liners. If it can get the page whose URL you provide, it sends it to
    STDOUT; otherwise it complains to STDERR.</p>
<p class="Pp"></p>
<pre>
  % perl -MLWP::Simple -e &quot;getprint 'http://www.cpan.org/RECENT'&quot;
</pre>
<p class="Pp">That is the URL of a plain text file that lists new files in CPAN
    in the past two weeks. You can easily make it part of a tidy little shell
    command, like this one that mails you the list of new
    <span class="Li">&quot;Acme::&quot;</span> modules:</p>
<p class="Pp"></p>
<pre>
  % perl -MLWP::Simple -e &quot;getprint 'http://www.cpan.org/RECENT'&quot;  \
     | grep &quot;/by-module/Acme&quot; | mail -s &quot;New Acme modules! Joy!&quot; $USER
</pre>
<p class="Pp">There are other useful functions in LWP::Simple, including one
    function for running a HEAD request on a URL (useful for checking links, or
    getting the last-revised time of a URL), and two functions for
    saving/mirroring a URL to a local file. See the LWP::Simple documentation
    for the full details, or chapter 2 of <i>Perl</i> <i>&amp; LWP</i> for more
    examples.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Basics_of_the_"><a class="permalink" href="#The_Basics_of_the_">The
  Basics of the LWP Class Model</a></h2>
<p class="Pp">LWP::Simple's functions are handy for simple cases, but its
    functions don't support cookies or authorization, don't support setting
    header lines in the HTTP request, generally don't support reading header
    lines in the HTTP response (notably the full HTTP error message, in case of
    an error). To get at all those features, you'll have to use the full LWP
    class model.</p>
<p class="Pp">While LWP consists of dozens of classes, the main two that you
    have to understand are LWP::UserAgent and HTTP::Response. LWP::UserAgent is
    a class for &quot;virtual browsers&quot; which you use for performing
    requests, and HTTP::Response is a class for the responses (or error
    messages) that you get back from those requests.</p>
<p class="Pp">The basic idiom is <span class="Li">&quot;$response =
    $browser-&gt;get($url)&quot;</span>, or more fully illustrated:</p>
<p class="Pp"></p>
<pre>
  # Early in your program:
  
  use LWP 5.64; # Loads all important LWP classes, and makes
                #  sure your version is reasonably recent.

  my $browser = LWP::UserAgent-&gt;new;
  
  ...
  
  # Then later, whenever you need to make a get request:
  my $url = 'http://www.npr.org/programs/fa/?todayDate=current';
  
  my $response = $browser-&gt;get( $url );
  die &quot;Can't get $url -- &quot;, $response-&gt;status_line
   unless $response-&gt;is_success;

  die &quot;Hey, I was expecting HTML, not &quot;, $response-&gt;content_type
   unless $response-&gt;content_type eq 'text/html';
     # or whatever content-type you're equipped to deal with

  # Otherwise, process the content somehow:
  
  if($response-&gt;decoded_content =~ m/jazz/i) {
    print &quot;They're talking about jazz today on Fresh Air!\n&quot;;
  }
  else {
    print &quot;Fresh Air is apparently jazzless today.\n&quot;;
  }
</pre>
<p class="Pp">There are two objects involved: <span class="Li">$browser</span>,
    which holds an object of class LWP::UserAgent, and then the
    <span class="Li">$response</span> object, which is of class HTTP::Response.
    You really need only one browser object per program; but every time you make
    a request, you get back a new HTTP::Response object, which will have some
    interesting attributes:</p>
<ul class="Bl-bullet">
  <li>A status code indicating success or failure (which you can test with
      <span class="Li">&quot;$response-&gt;is_success&quot;</span>).</li>
  <li>An HTTP status line that is hopefully informative if there's failure
      (which you can see with
      <span class="Li">&quot;$response-&gt;status_line&quot;</span>, returning
      something like &quot;404 Not Found&quot;).</li>
  <li>A MIME content-type like &quot;text/html&quot;, &quot;image/gif&quot;,
      &quot;application/xml&quot;, etc., which you can see with
      <span class="Li">&quot;$response-&gt;content_type&quot;</span></li>
  <li>The actual content of the response, in
      <span class="Li">&quot;$response-&gt;decoded_content&quot;</span>. If the
      response is HTML, that's where the HTML source will be; if it's a GIF,
      then <span class="Li">&quot;$response-&gt;decoded_content&quot;</span>
      will be the binary GIF data.</li>
  <li>And dozens of other convenient and more specific methods that are
      documented in the docs for HTTP::Response, and its superclasses
      HTTP::Message and HTTP::Headers.</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Adding_Other_"><a class="permalink" href="#Adding_Other_">Adding
  Other HTTP Request Headers</a></h2>
<p class="Pp">The most commonly used syntax for requests is
    <span class="Li">&quot;$response =</span>
    <span class="Li">$browser-&gt;get($url)&quot;</span>, but in truth, you can
    add extra HTTP header lines to the request by adding a list of key-value
    pairs after the URL, like so:</p>
<p class="Pp"></p>
<pre>
  $response = $browser-&gt;get( $url, $key1, $value1, $key2, $value2, ... );
</pre>
<p class="Pp">For example, here's how to send some more Netscape-like headers,
    in case you're dealing with a site that would otherwise reject your
  request:</p>
<p class="Pp"></p>
<pre>
  my @ns_headers = (
   'User-Agent' =&gt; 'Mozilla/4.76 [en] (Win98; U)',
   'Accept' =&gt; 'image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*',
   'Accept-Charset' =&gt; 'iso-8859-1,*,utf-8',
   'Accept-Language' =&gt; 'en-US',
  );

  ...
  
  $response = $browser-&gt;get($url, @ns_headers);
</pre>
<p class="Pp">If you weren't reusing that array, you could just go ahead and do
    this:</p>
<p class="Pp"></p>
<pre>
  $response = $browser-&gt;get($url,
   'User-Agent' =&gt; 'Mozilla/4.76 [en] (Win98; U)',
   'Accept' =&gt; 'image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*',
   'Accept-Charset' =&gt; 'iso-8859-1,*,utf-8',
   'Accept-Language' =&gt; 'en-US',
  );
</pre>
<p class="Pp">If you were only ever changing the 'User-Agent' line, you could
    just change the <span class="Li">$browser</span> object's default line from
    &quot;libwww-perl/5.65&quot; (or the like) to whatever you like, using the
    LWP::UserAgent <span class="Li">&quot;agent&quot;</span> method:</p>
<p class="Pp"></p>
<pre>
   $browser-&gt;agent('Mozilla/4.76 [en] (Win98; U)');
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Enabling_Cookies"><a class="permalink" href="#Enabling_Cookies">Enabling
  Cookies</a></h2>
<p class="Pp">A default LWP::UserAgent object acts like a browser with its
    cookies support turned off. There are various ways of turning it on, by
    setting its <span class="Li">&quot;cookie_jar&quot;</span> attribute. A
    &quot;cookie jar&quot; is an object representing a little database of all
    the HTTP cookies that a browser can know about. It can correspond to a file
    on disk (the way Netscape uses its <i>cookies.txt</i> file), or it can be
    just an in-memory object that starts out empty, and whose collection of
    cookies will disappear once the program is finished running.</p>
<p class="Pp">To give a browser an in-memory empty cookie jar, you set its
    <span class="Li">&quot;cookie_jar&quot;</span> attribute like so:</p>
<p class="Pp"></p>
<pre>
  $browser-&gt;cookie_jar({});
</pre>
<p class="Pp">To give it a copy that will be read from a file on disk, and will
    be saved to it when the program is finished running, set the
    <span class="Li">&quot;cookie_jar&quot;</span> attribute like this:</p>
<p class="Pp"></p>
<pre>
  use HTTP::Cookies;
  $browser-&gt;cookie_jar( HTTP::Cookies-&gt;new(
    'file' =&gt; '/some/where/cookies.lwp',
        # where to read/write cookies
    'autosave' =&gt; 1,
        # save it to disk when done
  ));
</pre>
<p class="Pp">That file will be an LWP-specific format. If you want to be access
    the cookies in your Netscape cookies file, you can use the
    HTTP::Cookies::Netscape class:</p>
<p class="Pp"></p>
<pre>
  use HTTP::Cookies;
    # yes, loads HTTP::Cookies::Netscape too
  
  $browser-&gt;cookie_jar( HTTP::Cookies::Netscape-&gt;new(
    'file' =&gt; 'c:/Program Files/Netscape/Users/DIR-NAME-HERE/cookies.txt',
        # where to read cookies
  ));
</pre>
<p class="Pp">You could add an <span class="Li">&quot;'autosave' =&gt;
    1&quot;</span> line as further above, but at time of writing, it's uncertain
    whether Netscape might discard some of the cookies you could be writing back
    to disk.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Posting_Form_Data"><a class="permalink" href="#Posting_Form_Data">Posting
  Form Data</a></h2>
<p class="Pp">Many HTML forms send data to their server using an HTTP POST
    request, which you can send with this syntax:</p>
<p class="Pp"></p>
<pre>
 $response = $browser-&gt;post( $url,
   [
     formkey1 =&gt; value1, 
     formkey2 =&gt; value2, 
     ...
   ],
 );
</pre>
<p class="Pp">Or if you need to send HTTP headers:</p>
<p class="Pp"></p>
<pre>
 $response = $browser-&gt;post( $url,
   [
     formkey1 =&gt; value1, 
     formkey2 =&gt; value2, 
     ...
   ],
   headerkey1 =&gt; value1, 
   headerkey2 =&gt; value2, 
 );
</pre>
<p class="Pp">For example, the following program makes a search request to
    AltaVista (by sending some form data via an HTTP POST request), and extracts
    from the HTML the report of the number of matches:</p>
<p class="Pp"></p>
<pre>
  use strict;
  use warnings;
  use LWP 5.64;
  my $browser = LWP::UserAgent-&gt;new;

  my $word = 'tarragon';

  my $url = 'http://search.yahoo.com/yhs/search';
  my $response = $browser-&gt;post( $url,
    [ 'q' =&gt; $word,  # the Altavista query string
      'fr' =&gt; 'altavista', 'pg' =&gt; 'q', 'avkw' =&gt; 'tgz', 'kl' =&gt; 'XX',
    ]
  );
  die &quot;$url error: &quot;, $response-&gt;status_line
   unless $response-&gt;is_success;
  die &quot;Weird content type at $url -- &quot;, $response-&gt;content_type
   unless $response-&gt;content_is_html;

  if( $response-&gt;decoded_content =~ m{([0-9,]+)(?:&lt;.*?&gt;)? results for} ) {
    # The substring will be like &quot;996,000&lt;/strong&gt; results for&quot;
    print &quot;$word: $1\n&quot;;
  }
  else {
    print &quot;Couldn't find the match-string in the response\n&quot;;
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Sending_"><a class="permalink" href="#Sending_">Sending GET
  Form Data</a></h2>
<p class="Pp">Some HTML forms convey their form data not by sending the data in
    an HTTP POST request, but by making a normal GET request with the data stuck
    on the end of the URL. For example, if you went to
    <span class="Li">&quot;www.imdb.com&quot;</span> and ran a search on
    &quot;Blade Runner&quot;, the URL you'd see in your browser window would
  be:</p>
<p class="Pp"></p>
<pre>
  http://www.imdb.com/find?s=all&amp;q=Blade+Runner
</pre>
<p class="Pp">To run the same search with LWP, you'd use this idiom, which
    involves the URI class:</p>
<p class="Pp"></p>
<pre>
  use URI;
  my $url = URI-&gt;new( 'http://www.imdb.com/find' );
    # makes an object representing the URL

  $url-&gt;query_form(  # And here the form data pairs:
    'q' =&gt; 'Blade Runner',
    's' =&gt; 'all',
  );

  my $response = $browser-&gt;get($url);
</pre>
<p class="Pp">See chapter 5 of <i>Perl &amp; LWP</i> for a longer discussion of
    HTML forms and of form data, and chapters 6 through 9 for a longer
    discussion of extracting data from HTML.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Absolutizing_URLs"><a class="permalink" href="#Absolutizing_URLs">Absolutizing
  URLs</a></h2>
<p class="Pp">The URI class that we just mentioned above provides all sorts of
    methods for accessing and modifying parts of URLs (such as asking sort of
    URL it is with <span class="Li">&quot;$url-&gt;scheme&quot;</span>, and
    asking what host it refers to with
    <span class="Li">&quot;$url-&gt;host&quot;</span>, and so on, as described
    in the docs for the URI class. However, the methods of most immediate
    interest are the <span class="Li">&quot;query_form&quot;</span> method seen
    above, and now the <span class="Li">&quot;new_abs&quot;</span> method for
    taking a probably-relative URL string (like &quot;../foo.html&quot;) and
    getting back an absolute URL (like
    &quot;http://www.perl.com/stuff/foo.html&quot;), as shown here:</p>
<p class="Pp"></p>
<pre>
  use URI;
  $abs = URI-&gt;new_abs($maybe_relative, $base);
</pre>
<p class="Pp">For example, consider this program that matches URLs in the HTML
    list of new modules in CPAN:</p>
<p class="Pp"></p>
<pre>
  use strict;
  use warnings;
  use LWP;
  my $browser = LWP::UserAgent-&gt;new;
  
  my $url = 'http://www.cpan.org/RECENT.html';
  my $response = $browser-&gt;get($url);
  die &quot;Can't get $url -- &quot;, $response-&gt;status_line
   unless $response-&gt;is_success;
  
  my $html = $response-&gt;decoded_content;
  while( $html =~ m/&lt;A HREF=\&quot;(.*?)\&quot;/g ) {
    print &quot;$1\n&quot;;
  }
</pre>
<p class="Pp">When run, it emits output that starts out something like this:</p>
<p class="Pp"></p>
<pre>
  MIRRORING.FROM
  RECENT
  RECENT.html
  authors/00whois.html
  authors/01mailrc.txt.gz
  authors/id/A/AA/AASSAD/CHECKSUMS
  ...
</pre>
<p class="Pp">However, if you actually want to have those be absolute URLs, you
    can use the URI module's <span class="Li">&quot;new_abs&quot;</span> method,
    by changing the <span class="Li">&quot;while&quot;</span> loop to this:</p>
<p class="Pp"></p>
<pre>
  while( $html =~ m/&lt;A HREF=\&quot;(.*?)\&quot;/g ) {
    print URI-&gt;new_abs( $1, $response-&gt;base ) ,&quot;\n&quot;;
  }
</pre>
<p class="Pp">(The <span class="Li">&quot;$response-&gt;base&quot;</span> method
    from HTTP::Message is for returning what URL should be used for resolving
    relative URLs -- it's usually just the same as the URL that you
  requested.)</p>
<p class="Pp">That program then emits nicely absolute URLs:</p>
<p class="Pp"></p>
<pre>
  http://www.cpan.org/MIRRORING.FROM
  http://www.cpan.org/RECENT
  http://www.cpan.org/RECENT.html
  http://www.cpan.org/authors/00whois.html
  http://www.cpan.org/authors/01mailrc.txt.gz
  http://www.cpan.org/authors/id/A/AA/AASSAD/CHECKSUMS
  ...
</pre>
<p class="Pp">See chapter 4 of <i>Perl &amp; LWP</i> for a longer discussion of
    URI objects.</p>
<p class="Pp">Of course, using a regexp to match hrefs is a bit simplistic, and
    for more robust programs, you'll probably want to use an HTML-parsing module
    like HTML::LinkExtor or HTML::TokeParser or even maybe
  HTML::TreeBuilder.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Other_Browser_Attributes"><a class="permalink" href="#Other_Browser_Attributes">Other
  Browser Attributes</a></h2>
<p class="Pp">LWP::UserAgent objects have many attributes for controlling how
    they work. Here are a few notable ones:</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;$browser-&gt;timeout(15);&quot;</span>
    <p class="Pp">This sets this browser object to give up on requests that
        don't answer within 15 seconds.</p>
  </li>
  <li><span class="Li">&quot;$browser-&gt;protocols_allowed( [ 'http', 'gopher']
      );&quot;</span>
    <p class="Pp">This sets this browser object to not speak any protocols other
        than HTTP and gopher. If it tries accessing any other kind of URL (like
        an &quot;ftp:&quot; or &quot;mailto:&quot; or &quot;news:&quot; URL),
        then it won't actually try connecting, but instead will immediately
        return an error code 500, with a message like &quot;Access to 'ftp' URIs
        has been disabled&quot;.</p>
  </li>
  <li><span class="Li">&quot;use LWP::ConnCache;
      $browser-&gt;conn_cache(LWP::ConnCache-&gt;new());&quot;</span>
    <p class="Pp">This tells the browser object to try using the HTTP/1.1
        &quot;Keep-Alive&quot; feature, which speeds up requests by reusing the
        same socket connection for multiple requests to the same server.</p>
  </li>
  <li><span class="Li">&quot;$browser-&gt;agent( 'SomeName/1.23 (more info here
      maybe)' )&quot;</span>
    <p class="Pp">This changes how the browser object will identify itself in
        the default &quot;User-Agent&quot; line is its HTTP requests. By
        default, it'll send &quot;libwww-perl/<i>versionnumber</i>&quot;, like
        &quot;libwww-perl/5.65&quot;. You can change that to something more
        descriptive like this:</p>
    <p class="Pp"></p>
    <pre>
  $browser-&gt;agent( 'SomeName/3.14 (contact@robotplexus.int)' );
    </pre>
    <p class="Pp">Or if need be, you can go in disguise, like this:</p>
    <p class="Pp"></p>
    <pre>
  $browser-&gt;agent( 'Mozilla/4.0 (compatible; MSIE 5.12; Mac_PowerPC)' );
    </pre>
  </li>
  <li><span class="Li">&quot;push @{ $ua-&gt;requests_redirectable },
      'POST';&quot;</span>
    <p class="Pp">This tells this browser to obey redirection responses to POST
        requests (like most modern interactive browsers), even though the HTTP
        RFC says that should not normally be done.</p>
  </li>
</ul>
<p class="Pp">For more options and information, see the full documentation for
    LWP::UserAgent.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Writing_Polite_Robots"><a class="permalink" href="#Writing_Polite_Robots">Writing
  Polite Robots</a></h2>
<p class="Pp">If you want to make sure that your LWP-based program respects
    <i>robots.txt</i> files and doesn't make too many requests too fast, you can
    use the LWP::RobotUA class instead of the LWP::UserAgent class.</p>
<p class="Pp">LWP::RobotUA class is just like LWP::UserAgent, and you can use it
    like so:</p>
<p class="Pp"></p>
<pre>
  use LWP::RobotUA;
  my $browser = LWP::RobotUA-&gt;new('YourSuperBot/1.34', 'you@yoursite.com');
    # Your bot's name and your email address

  my $response = $browser-&gt;get($url);
</pre>
<p class="Pp">But HTTP::RobotUA adds these features:</p>
<ul class="Bl-bullet">
  <li>If the <i>robots.txt</i> on <span class="Li">$url</span>'s server forbids
      you from accessing <span class="Li">$url</span>, then the
      <span class="Li">$browser</span> object (assuming it's of class
      LWP::RobotUA) won't actually request it, but instead will give you back
      (in <span class="Li">$response</span>) a 403 error with a message
      &quot;Forbidden by robots.txt&quot;. That is, if you have this line:
    <p class="Pp"></p>
    <pre>
  die &quot;$url -- &quot;, $response-&gt;status_line, &quot;\nAborted&quot;
   unless $response-&gt;is_success;
    </pre>
    <p class="Pp">then the program would die with an error message like
      this:</p>
    <p class="Pp"></p>
    <pre>
  http://whatever.site.int/pith/x.html -- 403 Forbidden by robots.txt
  Aborted at whateverprogram.pl line 1234
    </pre>
  </li>
  <li>If this <span class="Li">$browser</span> object sees that the last time it
      talked to <span class="Li">$url</span>'s server was too recently, then it
      will pause (via <span class="Li">&quot;sleep&quot;</span>) to avoid making
      too many requests too often. How long it will pause for, is by default one
      minute -- but you can control it with the
      <span class="Li">&quot;$browser-&gt;delay(
      </span><i>minutes</i><span class="Li"> )&quot;</span> attribute.
    <p class="Pp">For example, this code:</p>
    <p class="Pp"></p>
    <pre>
  $browser-&gt;delay( 7/60 );
    </pre>
    <p class="Pp">...means that this browser will pause when it needs to avoid
        talking to any given server more than once every 7 seconds.</p>
  </li>
</ul>
<p class="Pp">For more options and information, see the full documentation for
    LWP::RobotUA.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_Proxies"><a class="permalink" href="#Using_Proxies">Using
  Proxies</a></h2>
<p class="Pp">In some cases, you will want to (or will have to) use proxies for
    accessing certain sites and/or using certain protocols. This is most
    commonly the case when your LWP program is running (or could be running) on
    a machine that is behind a firewall.</p>
<p class="Pp">To make a browser object use proxies that are defined in the usual
    environment variables (<span class="Li">&quot;HTTP_PROXY&quot;</span>,
    etc.), just call the <span class="Li">&quot;env_proxy&quot;</span> on a
    user-agent object before you go making any requests on it. Specifically:</p>
<p class="Pp"></p>
<pre>
  use LWP::UserAgent;
  my $browser = LWP::UserAgent-&gt;new;
  
  # And before you go making any requests:
  $browser-&gt;env_proxy;
</pre>
<p class="Pp">For more information on proxy parameters, see the LWP::UserAgent
    documentation, specifically the <span class="Li">&quot;proxy&quot;</span>,
    <span class="Li">&quot;env_proxy&quot;</span>, and
    <span class="Li">&quot;no_proxy&quot;</span> methods.</p>
</section>
<section class="Ss">
<h2 class="Ss">HTTP Authentication</h2>
<p class="Pp">Many web sites restrict access to documents by using &quot;HTTP
    Authentication&quot;. This isn't just any form of &quot;enter your
    password&quot; restriction, but is a specific mechanism where the HTTP
    server sends the browser an HTTP code that says &quot;That document is part
    of a protected 'realm', and you can access it only if you re-request it and
    add some special authorization headers to your request&quot;.</p>
<p class="Pp">For example, the Unicode.org admins stop email-harvesting bots
    from harvesting the contents of their mailing list archives, by protecting
    them with HTTP Authentication, and then publicly stating the username and
    password (at
    <span class="Li">&quot;http://www.unicode.org/mail-arch/&quot;</span>) --
    namely username &quot;unicode-ml&quot; and password &quot;unicode&quot;.</p>
<p class="Pp">For example, consider this URL, which is part of the protected
    area of the web site:</p>
<p class="Pp"></p>
<pre>
  http://www.unicode.org/mail-arch/unicode-ml/y2002-m08/0067.html
</pre>
<p class="Pp">If you access that with a browser, you'll get a prompt like
    &quot;Enter username and password for 'Unicode-MailList-Archives' at server
    'www.unicode.org'&quot;.</p>
<p class="Pp">In LWP, if you just request that URL, like this:</p>
<p class="Pp"></p>
<pre>
  use LWP;
  my $browser = LWP::UserAgent-&gt;new;

  my $url =
   'http://www.unicode.org/mail-arch/unicode-ml/y2002-m08/0067.html';
  my $response = $browser-&gt;get($url);

  die &quot;Error: &quot;, $response-&gt;header('WWW-Authenticate') || 'Error accessing',
    #  ('WWW-Authenticate' is the realm-name)
    &quot;\n &quot;, $response-&gt;status_line, &quot;\n at $url\n Aborting&quot;
   unless $response-&gt;is_success;
</pre>
<p class="Pp">Then you'll get this error:</p>
<p class="Pp"></p>
<pre>
  Error: Basic realm=&quot;Unicode-MailList-Archives&quot;
   401 Authorization Required
   at http://www.unicode.org/mail-arch/unicode-ml/y2002-m08/0067.html
   Aborting at auth1.pl line 9.  [or wherever]
</pre>
<p class="Pp">...because the <span class="Li">$browser</span> doesn't know any
    the username and password for that realm
    (&quot;Unicode-MailList-Archives&quot;) at that host
    (&quot;www.unicode.org&quot;). The simplest way to let the browser know
    about this is to use the <span class="Li">&quot;credentials&quot;</span>
    method to let it know about a username and password that it can try using
    for that realm at that host. The syntax is:</p>
<p class="Pp"></p>
<pre>
  $browser-&gt;credentials(
    'servername:portnumber',
    'realm-name',
   'username' =&gt; 'password'
  );
</pre>
<p class="Pp">In most cases, the port number is 80, the default TCP/IP port for
    HTTP; and you usually call the
    <span class="Li">&quot;credentials&quot;</span> method before you make any
    requests. For example:</p>
<p class="Pp"></p>
<pre>
  $browser-&gt;credentials(
    'reports.mybazouki.com:80',
    'web_server_usage_reports',
    'plinky' =&gt; 'banjo123'
  );
</pre>
<p class="Pp">So if we add the following to the program above, right after the
    <span class="Li">&quot;$browser = LWP::UserAgent-&gt;new;&quot;</span>
    line...</p>
<p class="Pp"></p>
<pre>
  $browser-&gt;credentials(  # add this to our $browser 's &quot;key ring&quot;
    'www.unicode.org:80',
    'Unicode-MailList-Archives',
    'unicode-ml' =&gt; 'unicode'
  );
</pre>
<p class="Pp">...then when we run it, the request succeeds, instead of causing
    the <span class="Li">&quot;die&quot;</span> to be called.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Accessing_"><a class="permalink" href="#Accessing_">Accessing
  HTTPS URLs</a></h2>
<p class="Pp">When you access an HTTPS URL, it'll work for you just like an HTTP
    URL would -- if your LWP installation has HTTPS support (via an appropriate
    Secure Sockets Layer library). For example:</p>
<p class="Pp"></p>
<pre>
  use LWP;
  my $url = 'https://www.paypal.com/';   # Yes, HTTPS!
  my $browser = LWP::UserAgent-&gt;new;
  my $response = $browser-&gt;get($url);
  die &quot;Error at $url\n &quot;, $response-&gt;status_line, &quot;\n Aborting&quot;
   unless $response-&gt;is_success;
  print &quot;Whee, it worked!  I got that &quot;,
   $response-&gt;content_type, &quot; document!\n&quot;;
</pre>
<p class="Pp">If your LWP installation doesn't have HTTPS support set up, then
    the response will be unsuccessful, and you'll get this error message:</p>
<p class="Pp"></p>
<pre>
  Error at https://www.paypal.com/
   501 Protocol scheme 'https' is not supported
   Aborting at paypal.pl line 7.   [or whatever program and line]
</pre>
<p class="Pp">If your LWP installation <i>does</i> have HTTPS support installed,
    then the response should be successful, and you should be able to consult
    <span class="Li">$response</span> just like with any normal HTTP
  response.</p>
<p class="Pp">For information about installing HTTPS support for your LWP
    installation, see the helpful <i>README.SSL</i> file that comes in the
    libwww-perl distribution.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Getting_Large_Documents"><a class="permalink" href="#Getting_Large_Documents">Getting
  Large Documents</a></h2>
<p class="Pp">When you're requesting a large (or at least potentially large)
    document, a problem with the normal way of using the request methods (like
    <span class="Li">&quot;$response = $browser-&gt;get($url)&quot;</span>) is
    that the response object in memory will have to hold the whole document --
    <i>in memory</i>. If the response is a thirty megabyte file, this is likely
    to be quite an imposition on this process's memory usage.</p>
<p class="Pp">A notable alternative is to have LWP save the content to a file on
    disk, instead of saving it up in memory. This is the syntax to use:</p>
<p class="Pp"></p>
<pre>
  $response = $ua-&gt;get($url,
                         ':content_file' =&gt; $filespec,
                      );
</pre>
<p class="Pp">For example,</p>
<p class="Pp"></p>
<pre>
  $response = $ua-&gt;get('http://search.cpan.org/',
                         ':content_file' =&gt; '/tmp/sco.html'
                      );
</pre>
<p class="Pp">When you use this
    <span class="Li">&quot;:content_file&quot;</span> option, the
    <span class="Li">$response</span> will have all the normal header lines, but
    <span class="Li">&quot;$response-&gt;content&quot;</span> will be empty.</p>
<p class="Pp">Note that this &quot;:content_file&quot; option isn't supported
    under older versions of LWP, so you should consider adding
    <span class="Li">&quot;use LWP 5.66;&quot;</span> to check the LWP version,
    if you think your program might run on systems with older versions.</p>
<p class="Pp">If you need to be compatible with older LWP versions, then use
    this syntax, which does the same thing:</p>
<p class="Pp"></p>
<pre>
  use HTTP::Request::Common;
  $response = $ua-&gt;request( GET($url), $filespec );
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Remember, this article is just the most rudimentary introduction
    to LWP -- to learn more about LWP and LWP-related tasks, you really must
    read from the following:</p>
<ul class="Bl-bullet">
  <li>LWP::Simple -- simple functions for getting/heading/mirroring URLs</li>
  <li>LWP -- overview of the libwww-perl modules</li>
  <li>LWP::UserAgent -- the class for objects that represent &quot;virtual
      browsers&quot;</li>
  <li>HTTP::Response -- the class for objects that represent the response to a
      LWP response, as in <span class="Li">&quot;$response =
      $browser-&gt;get(...)&quot;</span></li>
  <li>HTTP::Message and HTTP::Headers -- classes that provide more methods to
      HTTP::Response.</li>
  <li>URI -- class for objects that represent absolute or relative URLs</li>
  <li>URI::Escape -- functions for URL-escaping and URL-unescaping strings (like
      turning &quot;this &amp; that&quot; to and from
      &quot;this%20%26%20that&quot;).</li>
  <li>HTML::Entities -- functions for HTML-escaping and HTML-unescaping strings
      (like turning &quot;C. &amp; E. Brontee&quot; to and from &quot;C.
      &amp;amp; E. Bront&amp;euml;&quot;)</li>
  <li>HTML::TokeParser and HTML::TreeBuilder -- classes for parsing HTML</li>
  <li>HTML::LinkExtor -- class for finding links in HTML documents</li>
  <li>The book <i>Perl &amp; LWP</i> by Sean M. Burke. O'Reilly &amp;
      Associates, 2002. ISBN: 0-596-00178-9,
      &lt;http://oreilly.com/catalog/perllwp/&gt;. The whole book is also
      available free online: &lt;http://lwp.interglacial.com&gt;.</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 2002, Sean M. Burke. You can redistribute this document
    and/or modify it, but only under the same terms as Perl itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Sean M. Burke
  <span class="Li">&quot;sburke@cpan.org&quot;</span></p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2012-02-11</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Type::Tiny(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Type::Tiny(3)</td>
    <td class="head-vol"><a href=".">User Contributed Perl Documentation</a></td>
    <td class="head-rtitle">Type::Tiny(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Type::Tiny - tiny, yet Moo(se)-compatible type constraint</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre> use v5.12;
 use strict;
 use warnings;
 
 package Horse {
   use Moo;
   use Types::Standard qw( Str Int Enum ArrayRef Object );
   use Type::Params qw( compile );
   use namespace::autoclean;
   
   has name =&gt; (
     is       =&gt; 'ro',
     isa      =&gt; Str,
     required =&gt; 1,
   );
   has gender =&gt; (
     is       =&gt; 'ro',
     isa      =&gt; Enum[qw( f m )],
   );
   has age =&gt; (
     is       =&gt; 'rw',
     isa      =&gt; Int-&gt;where( '$_ &gt;= 0' ),
   );
   has children =&gt; (
     is       =&gt; 'ro',
     isa      =&gt; ArrayRef[Object],
     default  =&gt; sub { return [] },
   );
   
   sub add_child {
     state $check = compile( Object, Object );  # method signature
     
     my ($self, $child) = $check-&gt;(@_);         # unpack @_
     push @{ $self-&gt;children }, $child;
     
     return $self;
   }
 }
 
 package main;
 
 my $boldruler = Horse-&gt;new(
   name    =&gt; &quot;Bold Ruler&quot;,
   gender  =&gt; 'm',
   age     =&gt; 16,
 );
 
 my $secretariat = Horse-&gt;new(
   name    =&gt; &quot;Secretariat&quot;,
   gender  =&gt; 'm',
   age     =&gt; 0,
 );
 
 $boldruler-&gt;add_child( $secretariat );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="STATUS"><a class="permalink" href="#STATUS">STATUS</a></h1>
<p class="Pp">This module is covered by the Type-Tiny stability policy.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This documents the internals of the Type::Tiny class.
    Type::Tiny::Manual is a better starting place if you're new.</p>
<p class="Pp">Type::Tiny is a small class for creating Moose-like type
    constraint objects which are compatible with Moo, Moose and Mouse.</p>
<p class="Pp"></p>
<pre>   use Scalar::Util qw(looks_like_number);
   use Type::Tiny;
   
   my $NUM = &quot;Type::Tiny&quot;-&gt;new(
      name       =&gt; &quot;Number&quot;,
      constraint =&gt; sub { looks_like_number($_) },
      message    =&gt; sub { &quot;$_ ain't a number&quot; },
   );
   
   package Ermintrude {
      use Moo;
      has favourite_number =&gt; (is =&gt; &quot;ro&quot;, isa =&gt; $NUM);
   }
   
   package Bullwinkle {
      use Moose;
      has favourite_number =&gt; (is =&gt; &quot;ro&quot;, isa =&gt; $NUM);
   }
   
   package Maisy {
      use Mouse;
      has favourite_number =&gt; (is =&gt; &quot;ro&quot;, isa =&gt; $NUM);
   }
</pre>
<p class="Pp">Maybe now we won't need to have separate MooseX, MouseX and MooX
    versions of everything? We can but hope...</p>
<section class="Ss">
<h2 class="Ss" id="Constructor"><a class="permalink" href="#Constructor">Constructor</a></h2>
<dl class="Bl-tag">
  <dt>&quot;new(%attributes)&quot;</dt>
  <dd>Moose-style constructor function.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Attributes"><a class="permalink" href="#Attributes">Attributes</a></h2>
<p class="Pp">Attributes are named values that may be passed to the constructor.
    For each attribute, there is a corresponding reader method. For example:</p>
<p class="Pp"></p>
<pre>   my $type = Type::Tiny-&gt;new( name =&gt; &quot;Foo&quot; );
   print $type-&gt;name, &quot;\n&quot;;   # says &quot;Foo&quot;
</pre>
<p class="Pp"><i>Important attributes</i></p>
<p class="Pp">These are the attributes you are likely to be most interested in
    providing when creating your own type constraints, and most interested in
    reading when dealing with type constraint objects.</p>
<dl class="Bl-tag">
  <dt>&quot;constraint&quot;</dt>
  <dd>Coderef to validate a value (<span class="Li">$_</span>) against the type
      constraint. The coderef will not be called unless the value is known to
      pass any parent type constraint (see
      <span class="Li">&quot;parent&quot;</span> below).
    <p class="Pp">Alternatively, a string of Perl code checking
        <span class="Li">$_</span> can be passed as a parameter to the
        constructor, and will be converted to a coderef.</p>
    <p class="Pp">Defaults to <span class="Li">&quot;sub { 1 }&quot;</span> -
        i.e. a coderef that passes all values.</p>
  </dd>
  <dt>&quot;parent&quot;</dt>
  <dd>Optional attribute; parent type constraint. For example, an
      &quot;Integer&quot; type constraint might have a parent
      &quot;Number&quot;.
    <p class="Pp">If provided, must be a Type::Tiny object.</p>
  </dd>
  <dt>&quot;inlined&quot;</dt>
  <dd>A coderef which returns a string of Perl code suitable for inlining this
      type. Optional.
    <p class="Pp">(The coderef will be called in list context and can actually
        return a list of strings which will be joined with
        <span class="Li">&quot;&amp;&amp;&quot;</span>. If the first item on the
        list is undef, it will be substituted with the type's parent's inline
        check.)</p>
    <p class="Pp">If <span class="Li">&quot;constraint&quot;</span> (above) is a
        coderef generated via Sub::Quote, then Type::Tiny <i>may</i> be able to
        automatically generate <span class="Li">&quot;inlined&quot;</span> for
        you. If <span class="Li">&quot;constraint&quot;</span> (above) is a
        string, it will be able to.</p>
  </dd>
  <dt>&quot;name&quot;</dt>
  <dd>The name of the type constraint. These need to conform to certain naming
      rules (they must begin with an uppercase letter and continue using only
      letters, digits 0-9 and underscores).
    <p class="Pp">Optional; if not supplied will be an anonymous type
        constraint.</p>
  </dd>
  <dt>&quot;display_name&quot;</dt>
  <dd>A name to display for the type constraint when stringified. These don't
      have to conform to any naming rules. Optional; a default name will be
      calculated from the <span class="Li">&quot;name&quot;</span>.</dd>
  <dt>&quot;library&quot;</dt>
  <dd>The package name of the type library this type is associated with.
      Optional. Informational only: setting this attribute does not install the
      type into the package.</dd>
  <dt>&quot;deprecated&quot;</dt>
  <dd>Optional boolean indicating whether a type constraint is deprecated.
      Type::Library will issue a warning if you attempt to import a deprecated
      type constraint, but otherwise the type will continue to function as
      normal. There will not be deprecation warnings every time you validate a
      value, for instance. If omitted, defaults to the parent's deprecation
      status (or false if there's no parent).</dd>
  <dt>&quot;message&quot;</dt>
  <dd>Coderef that returns an error message when <span class="Li">$_</span> does
      not validate against the type constraint. Optional (there's a vaguely
      sensible default.)</dd>
  <dt>&quot;coercion&quot;</dt>
  <dd>A Type::Coercion object associated with this type.
    <p class="Pp">Generally speaking this attribute should not be passed to the
        constructor; you should rely on the default lazily-built coercion
        object.</p>
    <p class="Pp">You may pass <span class="Li">&quot;coercion =&gt;
        1&quot;</span> to the constructor to inherit coercions from the
        constraint's parent. (This requires the parent constraint to have a
        coercion.)</p>
  </dd>
  <dt>&quot;sorter&quot;</dt>
  <dd>A coderef which can be passed two values conforming to this type
      constraint and returns -1, 0, or 1 to put them in order. Alternatively an
      arrayref containing a pair of coderefs &#x2014; a sorter and a
      pre-processor for the Schwarzian transform. Optional.
    <p class="Pp">The idea is to allow for:</p>
    <p class="Pp"></p>
    <pre>  @sorted = Int-&gt;sort( 2, 1, 11 );    # =&gt; 1, 2, 11
  @sorted = Str-&gt;sort( 2, 1, 11 );    # =&gt; 1, 11, 2
    </pre>
  </dd>
  <dt>&quot;my_methods&quot;</dt>
  <dd>Experimental hashref of additional methods that can be called on the type
      constraint object.</dd>
</dl>
<p class="Pp"><i>Attributes related to parameterizable and parameterized
    types</i></p>
<p class="Pp">The following additional attributes are used for parameterizable
    (e.g. <span class="Li">&quot;ArrayRef&quot;</span>) and parameterized (e.g.
    <span class="Li">&quot;ArrayRef[Int]&quot;</span>) type constraints. Unlike
    Moose, these aren't handled by separate subclasses.</p>
<dl class="Bl-tag">
  <dt>&quot;constraint_generator&quot;</dt>
  <dd>Coderef that is called when a type constraint is parameterized. When
      called, it is passed the list of parameters, though any parameter which
      looks like a foreign type constraint (Moose type constraints, Mouse type
      constraints, etc, <i>and coderefs(!!!)</i>) is first coerced to a native
      Type::Tiny object.
    <p class="Pp">Note that for compatibility with the Moose API, the base type
        is <i>not</i> passed to the constraint generator, but can be found in
        the package variable
        <span class="Li">$Type::Tiny::parameterize_type</span>. The first
        parameter is also available as <span class="Li">$_</span>.</p>
    <p class="Pp">Types <i>can</i> be parameterized with an empty parameter
        list. For example, in Types::Standard,
        <span class="Li">&quot;Tuple&quot;</span> is just an alias for
        <span class="Li">&quot;ArrayRef&quot;</span> but
        <span class="Li">&quot;Tuple[]&quot;</span> will only allow zero-length
        arrayrefs to pass the constraint. If you wish
        <span class="Li">&quot;YourType&quot;</span> and
        <span class="Li">&quot;YourType[]&quot;</span> to mean the same thing,
        then do:</p>
    <p class="Pp"></p>
    <pre> return $Type::Tiny::parameterize_type unless @_;
    </pre>
    <p class="Pp">The constraint generator should generate and return a new
        constraint coderef based on the parameters. Alternatively, the
        constraint generator can return a fully-formed Type::Tiny object, in
        which case the <span class="Li">&quot;name_generator&quot;</span>,
        <span class="Li">&quot;inline_generator&quot;</span>, and
        <span class="Li">&quot;coercion_generator&quot;</span> attributes
        documented below are ignored.</p>
    <p class="Pp">Optional; providing a generator makes this type into a
        parameterizable type constraint. If there is no generator, attempting to
        parameterize the type constraint will throw an exception.</p>
  </dd>
  <dt>&quot;name_generator&quot;</dt>
  <dd>A coderef which generates a new display_name based on parameters. Called
      with the same parameters and package variables as the
      <span class="Li">&quot;constraint_generator&quot;</span>. Expected to
      return a string.
    <p class="Pp">Optional; the default is reasonable.</p>
  </dd>
  <dt>&quot;inline_generator&quot;</dt>
  <dd>A coderef which generates a new inlining coderef based on parameters.
      Called with the same parameters and package variables as the
      <span class="Li">&quot;constraint_generator&quot;</span>. Expected to
      return a coderef.
    <p class="Pp">Optional.</p>
  </dd>
  <dt>&quot;coercion_generator&quot;</dt>
  <dd>A coderef which generates a new Type::Coercion object based on parameters.
      Called with the same parameters and package variables as the
      <span class="Li">&quot;constraint_generator&quot;</span>. Expected to
      return a blessed object.
    <p class="Pp">Optional.</p>
  </dd>
  <dt>&quot;deep_explanation&quot;</dt>
  <dd>This API is not finalized. Coderef used by Error::TypeTiny::Assertion to
      peek inside parameterized types and figure out why a value doesn't pass
      the constraint.</dd>
  <dt>&quot;parameters&quot;</dt>
  <dd>In parameterized types, returns an arrayref of the parameters.</dd>
</dl>
<p class="Pp"><i>Lazy generated attributes</i></p>
<p class="Pp">The following attributes should not be usually passed to the
    constructor; unless you're doing something especially unusual, you should
    rely on the default lazily-built return values.</p>
<dl class="Bl-tag">
  <dt>&quot;compiled_check&quot;</dt>
  <dd>Coderef to validate a value (<span class="Li">$_[0]</span>) against the
      type constraint. This coderef is expected to also handle all validation
      for the parent type constraints.</dd>
  <dt>&quot;complementary_type&quot;</dt>
  <dd>A complementary type for this type. For example, the complementary type
      for an integer type would be all things that are not integers, including
      floating point numbers, but also alphabetic strings, arrayrefs,
      filehandles, etc.</dd>
  <dt>&quot;moose_type&quot;, &quot;mouse_type&quot;</dt>
  <dd>Objects equivalent to this type constraint, but as a
      Moose::Meta::TypeConstraint or Mouse::Meta::TypeConstraint.
    <p class="Pp">It should rarely be necessary to obtain a
        Moose::Meta::TypeConstraint object from Type::Tiny because the
        Type::Tiny object itself should be usable pretty much anywhere a
        Moose::Meta::TypeConstraint is expected.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Methods"><a class="permalink" href="#Methods">Methods</a></h2>
<p class="Pp"><i>Predicate methods</i></p>
<p class="Pp">These methods return booleans indicating information about the
    type constraint. They are each tightly associated with a particular
    attribute. (See &quot;Attributes&quot;.)</p>
<dl class="Bl-tag">
  <dt>&quot;has_parent&quot;, &quot;has_library&quot;, &quot;has_inlined&quot;,
    &quot;has_constraint_generator&quot;, &quot;has_inline_generator&quot;,
    &quot;has_coercion_generator&quot;, &quot;has_parameters&quot;,
    &quot;has_message&quot;, &quot;has_deep_explanation&quot;,
    &quot;has_sorter&quot;</dt>
  <dd>Simple Moose-style predicate methods indicating the presence or absence of
      an attribute.</dd>
  <dt>&quot;has_coercion&quot;</dt>
  <dd>Predicate method with a little extra DWIM. Returns false if the coercion
      is a no-op.</dd>
  <dt>&quot;is_anon&quot;</dt>
  <dd>Returns true iff the type constraint does not have a
      <span class="Li">&quot;name&quot;</span>.</dd>
  <dt>&quot;is_parameterized&quot;, &quot;is_parameterizable&quot;</dt>
  <dd>Indicates whether a type has been parameterized (e.g.
      <span class="Li">&quot;ArrayRef[Int]&quot;</span>) or could potentially be
      (e.g. <span class="Li">&quot;ArrayRef&quot;</span>).</dd>
  <dt>&quot;has_parameterized_from&quot;</dt>
  <dd>Useless alias for
    <span class="Li">&quot;is_parameterized&quot;</span>.</dd>
</dl>
<p class="Pp"><i>Validation and coercion</i></p>
<p class="Pp">The following methods are used for coercing and validating values
    against a type constraint:</p>
<dl class="Bl-tag">
  <dt>&quot;check($value)&quot;</dt>
  <dd>Returns true iff the value passes the type constraint.</dd>
  <dt>&quot;validate($value)&quot;</dt>
  <dd>Returns the error message for the value; returns an explicit undef if the
      value passes the type constraint.</dd>
  <dt>&quot;assert_valid($value)&quot;</dt>
  <dd>Like <span class="Li">&quot;check($value)&quot;</span> but dies if the
      value does not pass the type constraint.
    <p class="Pp">Yes, that's three very similar methods. Blame
        Moose::Meta::TypeConstraint whose API I'm attempting to emulate. :-)</p>
  </dd>
  <dt>&quot;assert_return($value)&quot;</dt>
  <dd>Like <span class="Li">&quot;assert_valid($value)&quot;</span> but returns
      the value if it passes the type constraint.
    <p class="Pp">This seems a more useful behaviour than
        <span class="Li">&quot;assert_valid($value)&quot;</span>. I would have
        just changed <span class="Li">&quot;assert_valid($value)&quot;</span> to
        do this, except that there are edge cases where it could break Moose
        compatibility.</p>
  </dd>
  <dt>&quot;get_message($value)&quot;</dt>
  <dd>Returns the error message for the value; even if the value passes the type
      constraint.</dd>
  <dt>&quot;validate_explain($value, $varname)&quot;</dt>
  <dd>Like <span class="Li">&quot;validate&quot;</span> but instead of a string
      error message, returns an arrayref of strings explaining the reasoning why
      the value does not meet the type constraint, examining parent types, etc.
    <p class="Pp">The <span class="Li">$varname</span> is an optional string
        like <span class="Li">'$foo'</span> indicating the name of the variable
        being checked.</p>
  </dd>
  <dt>&quot;coerce($value)&quot;</dt>
  <dd>Attempt to coerce <span class="Li">$value</span> to this type.</dd>
  <dt>&quot;assert_coerce($value)&quot;</dt>
  <dd>Attempt to coerce <span class="Li">$value</span> to this type. Throws an
      exception if this is not possible.</dd>
</dl>
<p class="Pp"><i>Child type constraint creation and parameterization</i></p>
<p class="Pp">These methods generate new type constraint objects that inherit
    from the constraint they are called upon:</p>
<dl class="Bl-tag">
  <dt>&quot;create_child_type(%attributes)&quot;</dt>
  <dd>Construct a new Type::Tiny object with this object as its parent.</dd>
  <dt>&quot;where($coderef)&quot;</dt>
  <dd>Shortcut for creating an anonymous child type constraint. Use it like
      <span class="Li">&quot;HashRef-&gt;where(sub { exists($_-&gt;{name})
      })&quot;</span>. That said, you can get a similar result using overloaded
      <span class="Li">&quot;&amp;&quot;</span>:
    <p class="Pp"></p>
    <pre>   HashRef &amp; sub { exists($_-&gt;{name}) }
    </pre>
    <p class="Pp">Like the <span class="Li">&quot;constraint&quot;</span>
        attribute, this will accept a string of Perl code:</p>
    <p class="Pp"></p>
    <pre>   HashRef-&gt;where('exists($_-&gt;{name})')
    </pre>
  </dd>
  <dt>&quot;child_type_class&quot;</dt>
  <dd>The class that create_child_type will construct by default.</dd>
  <dt>&quot;parameterize(@parameters)&quot;</dt>
  <dd>Creates a new parameterized type; throws an exception if called on a
      non-parameterizable type.</dd>
  <dt>&quot;of(@parameters)&quot;</dt>
  <dd>A cute alias for <span class="Li">&quot;parameterize&quot;</span>. Use it
      like <span class="Li">&quot;ArrayRef-&gt;of(Int)&quot;</span>.</dd>
  <dt>&quot;plus_coercions($type1, $code1, ...)&quot;</dt>
  <dd>Shorthand for creating a new child type constraint with the same coercions
      as this one, but then adding some extra coercions (at a higher priority
      than the existing ones).</dd>
  <dt>&quot;plus_fallback_coercions($type1, $code1, ...)&quot;</dt>
  <dd>Like <span class="Li">&quot;plus_coercions&quot;</span>, but added at a
      lower priority.</dd>
  <dt>&quot;minus_coercions($type1, ...)&quot;</dt>
  <dd>Shorthand for creating a new child type constraint with fewer type
      coercions.</dd>
  <dt>&quot;no_coercions&quot;</dt>
  <dd>Shorthand for creating a new child type constraint with no coercions at
      all.</dd>
</dl>
<p class="Pp"><i>Type relationship introspection methods</i></p>
<p class="Pp">These methods allow you to determine a type constraint's
    relationship to other type constraints in an organised hierarchy:</p>
<dl class="Bl-tag">
  <dt>&quot;equals($other)&quot;, &quot;is_subtype_of($other)&quot;,
    &quot;is_supertype_of($other)&quot;, &quot;is_a_type_of($other)&quot;</dt>
  <dd>Compare two types. See Moose::Meta::TypeConstraint for what these all
      mean. (OK, Moose doesn't define
      <span class="Li">&quot;is_supertype_of&quot;</span>, but you get the idea,
      right?)
    <p class="Pp">Note that these have a slightly DWIM side to them. If you
        create two Type::Tiny::Class objects which test the same class, they're
        considered equal. And:</p>
    <p class="Pp"></p>
    <pre>   my $subtype_of_Num = Types::Standard::Num-&gt;create_child_type;
   my $subtype_of_Int = Types::Standard::Int-&gt;create_child_type;
   $subtype_of_Int-&gt;is_subtype_of( $subtype_of_Num );  # true
    </pre>
  </dd>
  <dt>&quot;strictly_equals($other)&quot;,
    &quot;is_strictly_subtype_of($other)&quot;,
    &quot;is_strictly_supertype_of($other)&quot;,
    &quot;is_strictly_a_type_of($other)&quot;</dt>
  <dd>Stricter versions of the type comparison functions. These only care about
      explicit inheritance via <span class="Li">&quot;parent&quot;</span>.
    <p class="Pp"></p>
    <pre>   my $subtype_of_Num = Types::Standard::Num-&gt;create_child_type;
   my $subtype_of_Int = Types::Standard::Int-&gt;create_child_type;
   $subtype_of_Int-&gt;is_strictly_subtype_of( $subtype_of_Num );  # false
    </pre>
  </dd>
  <dt>&quot;parents&quot;</dt>
  <dd>Returns a list of all this type constraint's ancestor constraints. For
      example, if called on the <span class="Li">&quot;Str&quot;</span> type
      constraint would return the list <span class="Li">&quot;(Value, Defined,
      Item, Any)&quot;</span>.
    <p class="Pp"><i>Due to a historical misunderstanding, this differs from the
        Moose</i> <i>implementation of the
        </i><span class="Li"><i>&quot;parents&quot;</i></span><i> method. In
        Moose, </i><span class="Li"><i>&quot;parents&quot;</i></span><i> only
        returns the</i> <i>immediate parent type constraints, and because type
        constraints only have</i> <i>one immediate parent, this is effectively
        an alias for </i><span class="Li"><i>&quot;parent&quot;</i></span><i>.
        The</i> <i>extension module MooseX::Meta::TypeConstraint::Intersection
        is the only</i> <i>place where multiple type constraints are returned;
        and they are returned</i> <i>as an arrayref in violation of the base
        class' documentation. I'm keeping</i> <i>my behaviour as it seems more
        useful.</i></p>
  </dd>
  <dt>&quot;find_parent($coderef)&quot;</dt>
  <dd>Loops through the parent type constraints <i>including the invocant</i>
      <i>itself</i> and returns the nearest ancestor type constraint where the
      coderef evaluates to true. Within the coderef the ancestor currently being
      checked is <span class="Li">$_</span>. Returns undef if there is no match.
    <p class="Pp">In list context also returns the number of type constraints
        which had been looped through before the matching constraint was
      found.</p>
  </dd>
  <dt>&quot;find_constraining_type&quot;</dt>
  <dd>Finds the nearest ancestor type constraint (including the type itself)
      which has a <span class="Li">&quot;constraint&quot;</span> coderef.
    <p class="Pp">Equivalent to:</p>
    <p class="Pp"></p>
    <pre>   $type-&gt;find_parent(sub { not $_-&gt;_is_null_constraint })
    </pre>
  </dd>
  <dt>&quot;coercibles&quot;</dt>
  <dd>Return a type constraint which is the union of type constraints that can
      be coerced to this one (including this one). If this type constraint has
      no coercions, returns itself.</dd>
  <dt>&quot;type_parameter&quot;</dt>
  <dd>In parameterized type constraints, returns the first item on the list of
      parameters; otherwise returns undef. For example:
    <p class="Pp"></p>
    <pre>   ( ArrayRef[Int] )-&gt;type_parameter;    # returns Int
   ( ArrayRef[Int] )-&gt;parent;            # returns ArrayRef
    </pre>
    <p class="Pp">Note that parameterizable type constraints can perfectly
        legitimately take multiple parameters (several of the parameterizable
        type constraints in Types::Standard do). This method only returns the
        first such parameter. &quot;Attributes related to parameterizable and
        parameterized types&quot; documents the
        <span class="Li">&quot;parameters&quot;</span> attribute, which returns
        an arrayref of all the parameters.</p>
  </dd>
  <dt>&quot;parameterized_from&quot;</dt>
  <dd>Harder to spell alias for <span class="Li">&quot;parent&quot;</span> that
      only works for parameterized types.</dd>
</dl>
<p class="Pp"><i>Hint for people subclassing Type::Tiny:</i> Since version
    1.006000, the methods for determining subtype, supertype, and type equality
    should <i>not</i> be overridden in subclasses of Type::Tiny. This is because
    of the problem of diamond inheritance. If X and Y are both subclasses of
    Type::Tiny, they <i>both</i> need to be consulted to figure out how type
    constraints are related; not just one of them should be overriding these
    methods. See the source code for Type::Tiny::Enum for an example of how
    subclasses can give hints about type relationships to Type::Tiny. Summary:
    push a coderef onto <span class="Li">@Type::Tiny::CMP</span>. This coderef
    will be passed two type constraints. It should then return one of the
    constants Type::Tiny::CMP_SUBTYPE (first type is a subtype of second type),
    Type::Tiny::CMP_SUPERTYPE (second type is a subtype of first type),
    Type::Tiny::CMP_EQUAL (the two types are exactly the same),
    Type::Tiny::CMP_EQUIVALENT (the two types are effectively the same), or
    Type::Tiny::CMP_UNKNOWN (your coderef couldn't establish any
  relationship).</p>
<p class="Pp"><i>Type relationship introspection function</i></p>
<dl class="Bl-tag">
  <dt>&quot;Type::Tiny::cmp($type1, $type2)&quot;</dt>
  <dd>The subtype/supertype relationship between types results in a partial
      ordering of type constraints.
    <p class="Pp">This function will return one of the constants:
        Type::Tiny::CMP_SUBTYPE (first type is a subtype of second type),
        Type::Tiny::CMP_SUPERTYPE (second type is a subtype of first type),
        Type::Tiny::CMP_EQUAL (the two types are exactly the same),
        Type::Tiny::CMP_EQUIVALENT (the two types are effectively the same), or
        Type::Tiny::CMP_UNKNOWN (couldn't establish any relationship). In
        numeric contexts, these evaluate to -1, 1, 0, 0, and 0, making it
        potentially usable with <span class="Li">&quot;sort&quot;</span> (though
        you may need to silence warnings about treating the empty string as a
        numeric value).</p>
  </dd>
</dl>
<p class="Pp"><i>List processing methods</i></p>
<dl class="Bl-tag">
  <dt>&quot;grep(@list)&quot;</dt>
  <dd>Filters a list to return just the items that pass the type check.
    <p class="Pp"></p>
    <pre>  @integers = Int-&gt;grep(@list);
    </pre>
  </dd>
  <dt>&quot;first(@list)&quot;</dt>
  <dd>Filters the list to return the first item on the list that passes the type
      check, or undef if none do.
    <p class="Pp"></p>
    <pre>  $first_lady = Woman-&gt;first(@people);
    </pre>
  </dd>
  <dt>&quot;map(@list)&quot;</dt>
  <dd>Coerces a list of items. Only works on types which have a coercion.
    <p class="Pp"></p>
    <pre>  @truths = Bool-&gt;map(@list);
    </pre>
  </dd>
  <dt>&quot;sort(@list)&quot;</dt>
  <dd>Sorts a list of items according to the type's preferred sorting mechanism,
      or if the type doesn't have a sorter coderef, uses the parent type. If no
      ancestor type constraint has a sorter, throws an exception. The
      <span class="Li">&quot;Str&quot;</span>,
      <span class="Li">&quot;StrictNum&quot;</span>,
      <span class="Li">&quot;LaxNum&quot;</span>, and
      <span class="Li">&quot;Enum&quot;</span> type constraints include sorters.
    <p class="Pp"></p>
    <pre>  @sorted_numbers = Num-&gt;sort( Num-&gt;grep(@list) );
    </pre>
  </dd>
  <dt>&quot;rsort(@list)&quot;</dt>
  <dd>Like <span class="Li">&quot;sort&quot;</span> but backwards.</dd>
  <dt>&quot;any(@list)&quot;</dt>
  <dd>Returns true if any of the list match the type.
    <p class="Pp"></p>
    <pre>  if ( Int-&gt;any(@numbers) ) {
    say &quot;there was at least one integer&quot;;
  }
    </pre>
  </dd>
  <dt>&quot;all(@list)&quot;</dt>
  <dd>Returns true if all of the list match the type.
    <p class="Pp"></p>
    <pre>  if ( Int-&gt;all(@numbers) ) {
    say &quot;they were all integers&quot;;
  }
    </pre>
  </dd>
  <dt>&quot;assert_any(@list)&quot;</dt>
  <dd>Like <span class="Li">&quot;any&quot;</span> but instead of returning a
      boolean, returns the entire original list if any item on it matches the
      type, and dies if none does.</dd>
  <dt>&quot;assert_all(@list)&quot;</dt>
  <dd>Like <span class="Li">&quot;all&quot;</span> but instead of returning a
      boolean, returns the original list if all items on it match the type, but
      dies as soon as it finds one that does not.</dd>
</dl>
<p class="Pp"><i>Inlining methods</i></p>
<p class="Pp">The following methods are used to generate strings of Perl code
    which may be pasted into stringy
    <span class="Li">&quot;eval&quot;</span>uated subs to perform type
  checks:</p>
<dl class="Bl-tag">
  <dt>&quot;can_be_inlined&quot;</dt>
  <dd>Returns boolean indicating if this type can be inlined.</dd>
  <dt>&quot;inline_check($varname)&quot;</dt>
  <dd>Creates a type constraint check for a particular variable as a string of
      Perl code. For example:
    <p class="Pp"></p>
    <pre>   print( Types::Standard::Num-&gt;inline_check('$foo') );
    </pre>
    <p class="Pp">prints the following output:</p>
    <p class="Pp"></p>
    <pre>   (!ref($foo) &amp;&amp; Scalar::Util::looks_like_number($foo))
    </pre>
    <p class="Pp">For Moose-compat, there is an alias
        <span class="Li">&quot;_inline_check&quot;</span> for this method.</p>
  </dd>
  <dt>&quot;inline_assert($varname)&quot;</dt>
  <dd>Much like <span class="Li">&quot;inline_check&quot;</span> but outputs a
      statement of the form:
    <p class="Pp"></p>
    <pre>   ... or die ...;
    </pre>
    <p class="Pp">Can also be called line
        <span class="Li">&quot;inline_assert($varname, $typevarname,
        %extras)&quot;</span>. In this case, it will generate a string of code
        that may include <span class="Li">$typevarname</span> which is supposed
        to be the name of a variable holding the type itself. (This is kinda
        complicated, but it allows a useful string to still be produced if the
        type is not inlineable.) The <span class="Li">%extras</span> are
        additional options to be passed to Error::TypeTiny::Assertion's
        constructor and must be key-value pairs of strings only, no references
        or undefs.</p>
  </dd>
</dl>
<p class="Pp"><i>Other methods</i></p>
<dl class="Bl-tag">
  <dt>&quot;qualified_name&quot;</dt>
  <dd>For non-anonymous type constraints that have a library, returns a
      qualified <span class="Li">&quot;MyLib::MyType&quot;</span> sort of name.
      Otherwise, returns the same as
    <span class="Li">&quot;name&quot;</span>.</dd>
  <dt>&quot;isa($class)&quot;, &quot;can($method)&quot;,
    &quot;AUTOLOAD(@args)&quot;</dt>
  <dd>If Moose is loaded, then the combination of these methods is used to mock
      a Moose::Meta::TypeConstraint.
    <p class="Pp">If Mouse is loaded, then
        <span class="Li">&quot;isa&quot;</span> mocks
        Mouse::Meta::TypeConstraint.</p>
  </dd>
  <dt>&quot;DOES($role)&quot;</dt>
  <dd>Overridden to advertise support for various roles.
    <p class="Pp">See also Type::API::Constraint, etc.</p>
  </dd>
  <dt>&quot;TIESCALAR&quot;, &quot;TIEARRAY&quot;, &quot;TIEHASH&quot;</dt>
  <dd>These are provided as hooks that wrap Type::Tie. (Type::Tie is distributed
      separately, and can be used with non-Type::Tiny type constraints too.)
      They allow the following to work:
    <p class="Pp"></p>
    <pre>   use Types::Standard qw(Int);
   tie my @list, Int;
   push @list, 123, 456;   # ok
   push @list, &quot;Hello&quot;;    # dies
    </pre>
  </dd>
</dl>
<p class="Pp">The following methods exist for Moose/Mouse compatibility, but do
    not do anything useful.</p>
<dl class="Bl-tag">
  <dt>&quot;compile_type_constraint&quot;</dt>
  <dd></dd>
  <dt>&quot;hand_optimized_type_constraint&quot;</dt>
  <dd></dd>
  <dt>&quot;has_hand_optimized_type_constraint&quot;</dt>
  <dd></dd>
  <dt>&quot;inline_environment&quot;</dt>
  <dd></dd>
  <dt>&quot;meta&quot;</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Overloading"><a class="permalink" href="#Overloading">Overloading</a></h2>
<ul class="Bl-bullet">
  <li>Stringification is overloaded to return the qualified name.</li>
  <li>Boolification is overloaded to always return true.</li>
  <li>Coderefification is overloaded to call
      <span class="Li">&quot;assert_return&quot;</span>.</li>
  <li>On Perl 5.10.1 and above, smart match is overloaded to call
      <span class="Li">&quot;check&quot;</span>.</li>
  <li>The <span class="Li">&quot;==&quot;</span> operator is overloaded to call
      <span class="Li">&quot;equals&quot;</span>.</li>
  <li>The <span class="Li">&quot;&lt;&quot;</span> and
      <span class="Li">&quot;&gt;&quot;</span> operators are overloaded to call
      <span class="Li">&quot;is_subtype_of&quot;</span> and
      <span class="Li">&quot;is_supertype_of&quot;</span>.</li>
  <li>The <span class="Li">&quot;~&quot;</span> operator is overloaded to call
      <span class="Li">&quot;complementary_type&quot;</span>.</li>
  <li>The <span class="Li">&quot;|&quot;</span> operator is overloaded to build
      a union of two type constraints. See Type::Tiny::Union.</li>
  <li>The <span class="Li">&quot;&amp;&quot;</span> operator is overloaded to
      build the intersection of two type constraints. See
      Type::Tiny::Intersection.</li>
</ul>
<p class="Pp">Previous versions of Type::Tiny would overload the
    <span class="Li">&quot;+&quot;</span> operator to call
    <span class="Li">&quot;plus_coercions&quot;</span> or
    <span class="Li">&quot;plus_fallback_coercions&quot;</span> as appropriate.
    Support for this was dropped after 0.040.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Constants"><a class="permalink" href="#Constants">Constants</a></h2>
<dl class="Bl-tag">
  <dt>&quot;Type::Tiny::SUPPORT_SMARTMATCH&quot;</dt>
  <dd>Indicates whether the smart match overload is supported on your version of
      Perl.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Package_Variables"><a class="permalink" href="#Package_Variables">Package
  Variables</a></h2>
<dl class="Bl-tag">
  <dt>$Type::Tiny::DD</dt>
  <dd>This undef by default but may be set to a coderef that Type::Tiny and
      related modules will use to dump data structures in things like error
      messages.
    <p class="Pp">Otherwise Type::Tiny uses it's own routine to dump data
        structures. <span class="Li">$DD</span> may then be set to a number to
        limit the lengths of the dumps. (Default limit is 72.)</p>
    <p class="Pp">This is a package variable (rather than get/set class methods)
        to allow for easy localization.</p>
  </dd>
  <dt>$Type::Tiny::AvoidCallbacks</dt>
  <dd>If this variable is set to true (you should usually do it in a
      <span class="Li">&quot;local&quot;</span> scope), it acts as a hint for
      type constraints, when generating inlined code, to avoid making any
      callbacks to variables and functions defined outside the inlined code
      itself.
    <p class="Pp">This should have the effect that
        <span class="Li">&quot;$type-&gt;inline_check('$foo')&quot;</span> will
        return a string of code capable of checking the type on Perl
        installations that don't have Type::Tiny installed. This is intended to
        allow Type::Tiny to be used with things like Mite.</p>
    <p class="Pp">The variable works on the honour system. Types need to
        explicitly check it and decide to generate different code based on its
        truth value. The bundled types in Types::Standard,
        Types::Common::Numeric, and Types::Common::String all do.
        (<b>StrMatch</b> is sometimes unable to, and will issue a warning if it
        needs to rely on callbacks when asked not to.)</p>
    <p class="Pp">Most normal users can ignore this.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Environment"><a class="permalink" href="#Environment">Environment</a></h2>
<dl class="Bl-tag">
  <dt>&quot;PERL_TYPE_TINY_XS&quot;</dt>
  <dd>Currently this has more effect on Types::Standard than Type::Tiny. In
      future it may be used to trigger or suppress the loading XS
      implementations of parts of Type::Tiny.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">Please report any bugs to
    &lt;http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">The Type::Tiny homepage &lt;https://typetiny.toby.ink/&gt;.</p>
<p class="Pp">Type::Tiny::Manual, Type::API.</p>
<p class="Pp">Type::Library, Type::Utils, Types::Standard, Type::Coercion.</p>
<p class="Pp">Type::Tiny::Class, Type::Tiny::Role, Type::Tiny::Duck,
    Type::Tiny::Enum, Type::Tiny::Union, Type::Tiny::Intersection.</p>
<p class="Pp">Moose::Meta::TypeConstraint, Mouse::Meta::TypeConstraint.</p>
<p class="Pp">Type::Params.</p>
<p class="Pp">Type::Tiny on GitHub
    &lt;https://github.com/tobyink/p5-type-tiny&gt;, Type::Tiny on Travis-CI
    &lt;https://travis-ci.com/tobyink/p5-type-tiny&gt;, Type::Tiny on AppVeyor
    &lt;https://ci.appveyor.com/project/tobyink/p5-type-tiny&gt;, Type::Tiny on
    Codecov &lt;https://codecov.io/gh/tobyink/p5-type-tiny&gt;, Type::Tiny on
    Coveralls &lt;https://coveralls.io/github/tobyink/p5-type-tiny&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Toby Inkster &lt;tobyink@cpan.org&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="THANKS"><a class="permalink" href="#THANKS">THANKS</a></h1>
<p class="Pp">Thanks to Matt S Trout for advice on Moo integration.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENCE"><a class="permalink" href="#COPYRIGHT_AND_LICENCE">COPYRIGHT
  AND LICENCE</a></h1>
<p class="Pp">This software is copyright (c) 2013-2014, 2017-2020 by Toby
    Inkster.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DISCLAIMER_OF_WARRANTIES"><a class="permalink" href="#DISCLAIMER_OF_WARRANTIES">DISCLAIMER
  OF WARRANTIES</a></h1>
<p class="Pp">THIS PACKAGE IS PROVIDED &quot;AS IS&quot; AND WITHOUT ANY EXPRESS
    OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES
    OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-10-28</td>
    <td class="foot-os"><a href="..">perl v5.34.0</a></td>
  </tr>
</table>
</body>
</html>

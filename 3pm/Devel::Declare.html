<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Devel::Declare(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Devel::Declare(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Devel::Declare(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Devel::Declare - (DEPRECATED) Adding keywords to perl, in perl</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  use Method::Signatures;
  # or ...
  use MooseX::Declare;
  # etc.
  # Use some new and exciting syntax like:
  method hello (Str :$who, Int :$age where { $_ &gt; 0 }) {
    $self-&gt;say(&quot;Hello ${who}, I am ${age} years old!&quot;);
  }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Devel::Declare can install subroutines called declarators which
    locally take over Perl's parser, allowing the creation of new syntax.</p>
<p class="Pp">This document describes how to create a simple declarator.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="WARNING"><a class="permalink" href="#WARNING">WARNING</a></h1>
<p class="Pp"><b>Warning:</b> Devel::Declare is a giant bag of crack originally
    implemented by mst with the goal of upsetting the perl core developers so
    much by its very existence that they implemented proper keyword handling in
    the core.</p>
<p class="Pp">As of perl5 version 14, this goal has been achieved, and modules
    such as Devel::CallParser, Function::Parameters, and Keyword::Simple provide
    mechanisms to mangle perl syntax that don't require hallucinogenic drugs to
    interpret the error messages they produce.</p>
<p class="Pp">If you are using something that uses Devel::Declare, please for
    the love of kittens use something else:</p>
<ul class="Bl-bullet">
  <li>Instead of TryCatch, use Try::Tiny</li>
  <li>Instead of Method::Signatures, use real subroutine signatures (requires
      perl 5.22) or Moops</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="USAGE"><a class="permalink" href="#USAGE">USAGE</a></h1>
<p class="Pp">We'll demonstrate the usage of
    <span class="Li">&quot;Devel::Declare&quot;</span> with a motivating
    example: a new <span class="Li">&quot;method&quot;</span> keyword, which
    acts like the builtin <span class="Li">&quot;sub&quot;</span>, but
    automatically unpacks <span class="Li">$self</span> and the other
  arguments.</p>
<p class="Pp"></p>
<pre>  package My::Methods;
  use Devel::Declare;
</pre>
<section class="Ss">
<h2 class="Ss" id="Creating_a_declarator_with__setup_for_"><a class="permalink" href="#Creating_a_declarator_with__setup_for_">Creating
  a declarator with &quot;setup_for&quot;</a></h2>
<p class="Pp">You will typically create</p>
<p class="Pp"></p>
<pre>  sub import {
    my $class = shift;
    my $caller = caller;
    Devel::Declare-&gt;setup_for(
        $caller,
        { method =&gt; { const =&gt; \&amp;parser } }
    );
    no strict 'refs';
    *{$caller.'::method'} = sub (&amp;) {};
  }
</pre>
<p class="Pp">Starting from the end of this import routine, you'll see that
    we're creating a subroutine called
    <span class="Li">&quot;method&quot;</span> in the caller's namespace. Yes,
    that's just a normal subroutine, and it does nothing at all (yet!) Note the
    prototype <span class="Li">&quot;(&amp;)&quot;</span> which means that the
    caller would call it like so:</p>
<p class="Pp"></p>
<pre>    method {
        my ($self, $arg1, $arg2) = @_;
        ...
    }
</pre>
<p class="Pp">However we want to be able to call it like this</p>
<p class="Pp"></p>
<pre>    method foo ($arg1, $arg2) {
        ...
    }
</pre>
<p class="Pp">That's why we call <span class="Li">&quot;setup_for&quot;</span>
    above, to register the declarator 'method' with a custom parser, as per the
    next section. It acts on an optype, usually <span class="Li">'const'</span>
    as above. (Other valid values are <span class="Li">'check'</span> and
    <span class="Li">'rv2cv'</span>).</p>
<p class="Pp">For a simpler way to install new methods, see also
    Devel::Declare::MethodInstaller::Simple</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Writing_a_parser_subroutine"><a class="permalink" href="#Writing_a_parser_subroutine">Writing
  a parser subroutine</a></h2>
<p class="Pp">This subroutine is called at <i>compilation</i> time, and allows
    you to read the custom syntaxes that we want (in a syntax that may or may
    not be valid core Perl 5) and munge it so that the result will be parsed by
    the <span class="Li">&quot;perl&quot;</span> compiler.</p>
<p class="Pp">For this example, we're defining some globals for convenience:</p>
<p class="Pp"></p>
<pre>    our ($Declarator, $Offset);
</pre>
<p class="Pp">Then we define a parser subroutine to handle our declarator. We'll
    look at this in a few chunks.</p>
<p class="Pp"></p>
<pre>    sub parser {
      local ($Declarator, $Offset) = @_;
</pre>
<p class="Pp"><span class="Li">&quot;Devel::Declare&quot;</span> provides some
    very low level utility methods to parse character strings. We'll define some
    useful higher level routines below for convenience, and we can use these to
    parse the various elements in our new syntax.</p>
<p class="Pp">Notice how our parser subroutine is invoked at compile time, when
    the <span class="Li">&quot;perl&quot;</span> parser is pointed just
    <i>before</i> the declarator name.</p>
<p class="Pp"></p>
<pre>      skip_declarator;          # step past 'method'
      my $name = strip_name;    # strip out the name 'foo', if present
      my $proto = strip_proto;  # strip out the prototype '($arg1, $arg2)', if present
</pre>
<p class="Pp">Now we can prepare some code to 'inject' into the new subroutine.
    For example we might want the method as above to have
    <span class="Li">&quot;my ($self, $arg1, $arg2) = @_&quot;</span> injected
    at the beginning of it. We also do some clever stuff with scopes that we'll
    look at shortly.</p>
<p class="Pp"></p>
<pre>      my $inject = make_proto_unwrap($proto);
      if (defined $name) {
        $inject = scope_injector_call().$inject;
      }
      inject_if_block($inject);
</pre>
<p class="Pp">We've now managed to change <span class="Li">&quot;method ($arg1,
    $arg2) { ... }&quot;</span> into <span class="Li">&quot;method {</span>
    <span class="Li">injected_code; ... }&quot;</span>. This will compile... but
    we've lost the name of the method!</p>
<p class="Pp">In a cute (or horrifying, depending on your perspective) trick, we
    temporarily change the definition of the subroutine
    <span class="Li">&quot;method&quot;</span> itself, to specialise it with the
    <span class="Li">$name</span> we stripped, so that it assigns the code block
    to that name.</p>
<p class="Pp">Even though the <i>next</i> time
    <span class="Li">&quot;method&quot;</span> is compiled, it will be redefined
    again, <span class="Li">&quot;perl&quot;</span> caches these definitions in
    its parse tree, so we'll always get the right one!</p>
<p class="Pp">Note that we also handle the case where there was no name,
    allowing an anonymous method analogous to an anonymous subroutine.</p>
<p class="Pp"></p>
<pre>      if (defined $name) {
        $name = join('::', Devel::Declare::get_curstash_name(), $name)
          unless ($name =~ /::/);
        shadow(sub (&amp;) { no strict 'refs'; *{$name} = shift; });
      } else {
        shadow(sub (&amp;) { shift });
      }
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Parser_utilities_in_detail"><a class="permalink" href="#Parser_utilities_in_detail">Parser
  utilities in detail</a></h2>
<p class="Pp">For simplicity, we're using global variables like
    <span class="Li">$Offset</span> in these examples. You may prefer to look at
    Devel::Declare::Context::Simple, which encapsulates the context much more
    cleanly.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;skip_declarator&quot;</i></span><i></i></p>
<p class="Pp">This simple parser just moves across a 'token'. The common case is
    to skip the declarator, i.e. to move to the end of the string 'method' and
    before the prototype and code block.</p>
<p class="Pp"></p>
<pre>    sub skip_declarator {
      $Offset += Devel::Declare::toke_move_past_token($Offset);
    }
</pre>
<p class="Pp"><span class="Li">&quot;toke_move_past_token&quot;</span></p>
<p class="Pp">This builtin parser simply moves past a 'token' (matching
    <span class="Li">&quot;/[a-zA-Z_]\w*/&quot;</span>) It takes an offset into
    the source document, and skips past the token. It returns the number of
    characters skipped.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;strip_name&quot;</i></span><i></i></p>
<p class="Pp">This parser skips any whitespace, then scans the next word (again
    matching a 'token'). We can then analyse the current line, and manipulate it
    (using pure Perl). In this case we take the name of the method out, and
    return it.</p>
<p class="Pp"></p>
<pre>    sub strip_name {
      skipspace;
      if (my $len = Devel::Declare::toke_scan_word($Offset, 1)) {
        my $linestr = Devel::Declare::get_linestr();
        my $name = substr($linestr, $Offset, $len);
        substr($linestr, $Offset, $len) = '';
        Devel::Declare::set_linestr($linestr);
        return $name;
      }
      return;
    }
</pre>
<p class="Pp"><span class="Li">&quot;toke_scan_word&quot;</span></p>
<p class="Pp">This builtin parser, given an offset into the source document,
    matches a 'token' as above but does not skip. It returns the length of the
    token matched, if any.</p>
<p class="Pp"><span class="Li">&quot;get_linestr&quot;</span></p>
<p class="Pp">This builtin returns the full text of the current line of the
    source document.</p>
<p class="Pp"><span class="Li">&quot;set_linestr&quot;</span></p>
<p class="Pp">This builtin sets the full text of the current line of the source
    document. Beware that injecting a newline into the middle of the line is
    likely to fail in surprising ways. Generally, Perl's parser can rely on the
    `current line' actually being only a single line. Use other kinds of
    whitespace instead, in the code that you inject.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;skipspace&quot;</i></span><i></i></p>
<p class="Pp">This parser skips whitsepace.</p>
<p class="Pp"></p>
<pre>    sub skipspace {
      $Offset += Devel::Declare::toke_skipspace($Offset);
    }
</pre>
<p class="Pp"><span class="Li">&quot;toke_skipspace&quot;</span></p>
<p class="Pp">This builtin parser, given an offset into the source document,
    skips over any whitespace, and returns the number of characters skipped.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;strip_proto&quot;</i></span><i></i></p>
<p class="Pp">This is a more complex parser that checks if it's found something
    that starts with <span class="Li">'('</span> and returns everything till the
    matching <span class="Li">')'</span>.</p>
<p class="Pp"></p>
<pre>    sub strip_proto {
      skipspace;
      my $linestr = Devel::Declare::get_linestr();
      if (substr($linestr, $Offset, 1) eq '(') {
        my $length = Devel::Declare::toke_scan_str($Offset);
        my $proto = Devel::Declare::get_lex_stuff();
        Devel::Declare::clear_lex_stuff();
        $linestr = Devel::Declare::get_linestr();
        substr($linestr, $Offset, $length) = '';
        Devel::Declare::set_linestr($linestr);
        return $proto;
      }
      return;
    }
</pre>
<p class="Pp"><span class="Li">&quot;toke_scan_str&quot;</span></p>
<p class="Pp">This builtin parser uses Perl's own parsing routines to match a
    &quot;stringlike&quot; expression. Handily, this includes bracketed
    expressions (just think about things like <span class="Li">&quot;q(this is a
    quote)&quot;</span>).</p>
<p class="Pp">Also it Does The Right Thing with nested delimiters (like
    <span class="Li">&quot;q(this (is (a) quote))&quot;</span>).</p>
<p class="Pp">It returns the effective length of the expression matched. Really,
    what it returns is the difference in position between where the string
    started, within the buffer, and where it finished. If the string extended
    across multiple lines then the contents of the buffer may have been
    completely replaced by the new lines, so this position difference is not the
    same thing as the actual length of the expression matched. However, because
    moving backward in the buffer causes problems, the function arranges for the
    effective length to always be positive, padding the start of the buffer if
    necessary.</p>
<p class="Pp">Use <span class="Li">&quot;get_lex_stuff&quot;</span> to get the
    actual matched text, the content of the string. Because of the behaviour
    around multiline strings, you can't reliably get this from the buffer. In
    fact, after the function returns, you can't rely on any content of the
    buffer preceding the end of the string.</p>
<p class="Pp">If the string being scanned is not well formed (has no closing
    delimiter), <span class="Li">&quot;toke_scan_str&quot;</span> returns
    <span class="Li">&quot;undef&quot;</span>. In this case you cannot rely on
    the contents of the buffer.</p>
<p class="Pp"><span class="Li">&quot;get_lex_stuff&quot;</span></p>
<p class="Pp">This builtin returns what was matched by
    <span class="Li">&quot;toke_scan_str&quot;</span>. To avoid segfaults, you
    should call <span class="Li">&quot;clear_lex_stuff&quot;</span> immediately
    afterwards.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Munging_the_subroutine"><a class="permalink" href="#Munging_the_subroutine">Munging
  the subroutine</a></h2>
<p class="Pp">Let's look at what we need to do in detail.</p>
<p class="Pp"><i></i><span class="Li"><i>&quot;make_proto_unwrap&quot;</i></span><i></i></p>
<p class="Pp">We may have defined our method in different ways, which will
    result in a different value for our prototype, as parsed above. For
  example:</p>
<p class="Pp"></p>
<pre>    method foo         {  # undefined
    method foo ()      {  # ''
    method foo ($arg1) {  # '$arg1'
</pre>
<p class="Pp">We deal with them as follows, and return the appropriate
    <span class="Li">&quot;my ($self, ...) = @_;&quot;</span> string.</p>
<p class="Pp"></p>
<pre>    sub make_proto_unwrap {
      my ($proto) = @_;
      my $inject = 'my ($self';
      if (defined $proto) {
        $inject .= &quot;, $proto&quot; if length($proto);
        $inject .= ') = @_; ';
      } else {
        $inject .= ') = shift;';
      }
      return $inject;
    }
</pre>
<p class="Pp"><i></i><span class="Li"><i>&quot;inject_if_block&quot;</i></span><i></i></p>
<p class="Pp">Now we need to inject it after the opening
    <span class="Li">'{'</span> of the method body. We can do this with the
    building blocks we defined above like
    <span class="Li">&quot;skipspace&quot;</span> and
    <span class="Li">&quot;get_linestr&quot;</span>.</p>
<p class="Pp"></p>
<pre>    sub inject_if_block {
      my $inject = shift;
      skipspace;
      my $linestr = Devel::Declare::get_linestr;
      if (substr($linestr, $Offset, 1) eq '{') {
        substr($linestr, $Offset+1, 0) = $inject;
        Devel::Declare::set_linestr($linestr);
      }
    }
</pre>
<p class="Pp"><i></i><span class="Li"><i>&quot;scope_injector_call&quot;</i></span><i></i></p>
<p class="Pp">We want to be able to handle both named and anonymous methods.
    i.e.</p>
<p class="Pp"></p>
<pre>    method foo () { ... }
    my $meth = method () { ... };
</pre>
<p class="Pp">These will then get rewritten as</p>
<p class="Pp"></p>
<pre>    method { ... }
    my $meth = method { ... };
</pre>
<p class="Pp">where 'method' is a subroutine that takes a code block. Spot the
    problem? The first one doesn't have a semicolon at the end of it! Unlike
    'sub' which is a builtin, this is just a normal statement, so we need to
    terminate it. Luckily, using
    <span class="Li">&quot;B::Hooks::EndOfScope&quot;</span>, we can do
  this!</p>
<p class="Pp"></p>
<pre>  use B::Hooks::EndOfScope;
</pre>
<p class="Pp">We'll add this to what gets 'injected' at the beginning of the
    method source.</p>
<p class="Pp"></p>
<pre>  sub scope_injector_call {
    return ' BEGIN { MethodHandlers::inject_scope }; ';
  }
</pre>
<p class="Pp">So at the beginning of every method, we are passing a callback
    that will get invoked at the <i>end</i> of the method's compilation... i.e.
    exactly then the closing <span class="Li">'}'</span> is compiled.</p>
<p class="Pp"></p>
<pre>  sub inject_scope {
    on_scope_end {
      my $linestr = Devel::Declare::get_linestr;
      my $offset = Devel::Declare::get_linestr_offset;
      substr($linestr, $offset, 0) = ';';
      Devel::Declare::set_linestr($linestr);
    };
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Shadowing_each_method."><a class="permalink" href="#Shadowing_each_method.">Shadowing
  each method.</a></h2>
<p class="Pp"><i></i><span class="Li"><i>&quot;shadow&quot;</i></span><i></i></p>
<p class="Pp">We override the current definition of 'method' using
    <span class="Li">&quot;shadow&quot;</span>.</p>
<p class="Pp"></p>
<pre>    sub shadow {
      my $pack = Devel::Declare::get_curstash_name;
      Devel::Declare::shadow_sub(&quot;${pack}::${Declarator}&quot;, $_[0]);
    }
</pre>
<p class="Pp">For a named method we invoked like this:</p>
<p class="Pp"></p>
<pre>    shadow(sub (&amp;) { no strict 'refs'; *{$name} = shift; });
</pre>
<p class="Pp">So in the case of a <span class="Li">&quot;method foo { ...
    }&quot;</span>, this call would redefine
    <span class="Li">&quot;method&quot;</span> to be a subroutine that exports
    'sub foo' as the (munged) contents of
    <span class="Li">&quot;{...}&quot;</span>.</p>
<p class="Pp">The case of an anonymous method is also cute:</p>
<p class="Pp"></p>
<pre>    shadow(sub (&amp;) { shift });
</pre>
<p class="Pp">This means that</p>
<p class="Pp"></p>
<pre>    my $meth = method () { ... };
</pre>
<p class="Pp">is rewritten with <span class="Li">&quot;method&quot;</span>
    taking the codeblock, and returning it as is to become the value of
    <span class="Li">$meth</span>.</p>
<p class="Pp"><span class="Li">&quot;get_curstash_name&quot;</span></p>
<p class="Pp">This returns the package name <i>currently being compiled</i>.</p>
<p class="Pp"><span class="Li">&quot;shadow_sub&quot;</span></p>
<p class="Pp">Handles the details of redefining the subroutine.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">One of the best ways to learn
    <span class="Li">&quot;Devel::Declare&quot;</span> is still to look at
    modules that use it:</p>
<p class="Pp">&lt;http://cpants.perl.org/dist/used_by/Devel-Declare&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp">Matt S Trout - &lt;mst@shadowcat.co.uk&gt; - original author</p>
<p class="Pp">Company: http://www.shadowcat.co.uk/ Blog:
    http://chainsawblues.vox.com/</p>
<p class="Pp">Florian Ragwitz &lt;rafl@debian.org&gt; - maintainer</p>
<p class="Pp">osfameron &lt;osfameron@cpan.org&gt; - first draft of
    documentation</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This library is free software under the same terms as perl
  itself</p>
<p class="Pp">Copyright (c) 2007, 2008, 2009 Matt S Trout</p>
<p class="Pp">Copyright (c) 2008, 2009 Florian Ragwitz</p>
<p class="Pp">stolen_chunk_of_toke.c based on toke.c from the perl core, which
    is</p>
<p class="Pp">Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
    1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-04-26</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

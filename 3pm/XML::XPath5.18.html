<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>XPath(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">XPath(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">XPath(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">XML::XPath - a set of modules for parsing and evaluating XPath
    statements</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module aims to comply exactly to the XPath specification at
    http://www.w3.org/TR/xpath and yet allow extensions to be added in the form
    of functions. Modules such as XSLT and XPointer may need to do this as they
    support functionality beyond XPath.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
    use XML::XPath;
    use XML::XPath::XMLParser;
    
    my $xp = XML::XPath-&gt;new(filename =&gt; 'test.xhtml');
    
    my $nodeset = $xp-&gt;find('/html/body/p'); # find all paragraphs
    
    foreach my $node ($nodeset-&gt;get_nodelist) {
        print &quot;FOUND\n\n&quot;, 
            XML::XPath::XMLParser::as_string($node),
            &quot;\n\n&quot;;
    }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DETAILS"><a class="permalink" href="#DETAILS">DETAILS</a></h1>
<p class="Pp">There's an awful lot to all of this, so bear with it - if you
    stick it out it should be worth it. Please get a good understanding of XPath
    by reading the spec before asking me questions. All of the classes and parts
    herein are named to be synonimous with the names in the specification, so
    consult that if you don't understand why I'm doing something in the
  code.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="API"><a class="permalink" href="#API">API</a></h1>
<p class="Pp">The API of XML::XPath itself is extremely simple to allow you to
    get going almost immediately. The deeper API's are more complex, but you
    shouldn't have to touch most of that.</p>
<section class="Ss">
<h2 class="Ss"><i>new()</i></h2>
<p class="Pp">This constructor follows the often seen named parameter method
    call. Parameters you can use are: filename, parser, xml, ioref and context.
    The filename parameter specifies an XML file to parse. The xml parameter
    specifies a string to parse, and the ioref parameter specifies an ioref to
    parse. The context option allows you to specify a context node. The context
    node has to be in the format of a node as specified in
    XML::XPath::XMLParser. The 4 parameters filename, xml, ioref and context are
    mutually exclusive - you should only specify one (if you specify anything
    other than context, the context node is the root of your document). The
    parser option allows you to pass in an already prepared XML::Parser object,
    to save you having to create more than one in your application (if, for
    example, you're doing more than just XPath).</p>
<p class="Pp"></p>
<pre>
    my $xp = XML::XPath-&gt;new( context =&gt; $node );
</pre>
<p class="Pp">It is very much recommended that you use only 1 XPath object
    throughout the life of your application. This is because the object (and
    it's sub-objects) maintain certain bits of state information that will be
    useful (such as XPath variables) to later calls to <i>find()</i>. It's also
    a good idea because you'll use less memory this way.</p>
</section>
<section class="Ss">
<h2 class="Ss"><i>nodeset</i> = find($path, [$context])</h2>
<p class="Pp">The find function takes an XPath expression (a string) and returns
    either an XML::XPath::NodeSet object containing the nodes it found (or empty
    if no nodes matched the path), or one of XML::XPath::Literal (a string),
    XML::XPath::Number, or XML::XPath::Boolean. It should always return
    something - and you can use -&gt;<i>isa()</i> to find out what it returned.
    If you need to check how many nodes it found you should check
    <span class="Li">$nodeset</span>-&gt;size. See XML::XPath::NodeSet. An
    optional second parameter of a context node allows you to use this method
    repeatedly, for example XSLT needs to do this.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="findnodes($path,__$context_)"><a class="permalink" href="#findnodes($path,__$context_)">findnodes($path,
  [$context])</a></h2>
<p class="Pp">Returns a list of nodes found by <span class="Li">$path</span>,
    optionally in context <span class="Li">$context</span>. In scalar context
    returns an XML::XPath::NodeSet object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="findnodes_as_string($path,__$context_)"><a class="permalink" href="#findnodes_as_string($path,__$context_)">findnodes_as_string($path,
  [$context])</a></h2>
<p class="Pp">Returns the nodes found reproduced as XML. The result is not
    guaranteed to be valid XML though.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="findvalue($path,__$context_)"><a class="permalink" href="#findvalue($path,__$context_)">findvalue($path,
  [$context])</a></h2>
<p class="Pp">Returns either a
    <span class="Li">&quot;XML::XPath::Literal&quot;</span>, a
    <span class="Li">&quot;XML::XPath::Boolean&quot;</span> or a
    <span class="Li">&quot;XML::XPath::Number&quot;</span> object. If the path
    returns a NodeSet, <span class="Li">$nodeset</span>-&gt;to_literal is called
    automatically for you (and thus a
    <span class="Li">&quot;XML::XPath::Literal&quot;</span> is returned). Note
    that for each of the objects stringification is overloaded, so you can just
    print the value found, or manipulate it in the ways you would a normal perl
    value (e.g. using regular expressions).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="exists($path,__$context_)"><a class="permalink" href="#exists($path,__$context_)">exists($path,
  [$context])</a></h2>
<p class="Pp">Returns true if the given path exists.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="matches($node,_$path,__$context_)"><a class="permalink" href="#matches($node,_$path,__$context_)">matches($node,
  $path, [$context])</a></h2>
<p class="Pp">Returns true if the node matches the path (optionally in context
    <span class="Li">$context</span>).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="getNodeText($path)"><a class="permalink" href="#getNodeText($path)">getNodeText($path)</a></h2>
<p class="Pp">Returns the text string for a particular XML node. Returns a
    string, or undef if the node doesn't exist.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="setNodeText($path,_$text)"><a class="permalink" href="#setNodeText($path,_$text)">setNodeText($path,
  $text)</a></h2>
<p class="Pp">Sets the text string for a particular XML node. The node can be an
    element or an attribute. If the node to be set is an attribute, and the
    attribute node does not exist, it will be created automatically.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="createNode($path)"><a class="permalink" href="#createNode($path)">createNode($path)</a></h2>
<p class="Pp">Creates the node matching the path given. If part of the path
    given, or all of the path do not exist, the necessary nodes will be created
    automatically.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="set_namespace($prefix,_$uri)"><a class="permalink" href="#set_namespace($prefix,_$uri)">set_namespace($prefix,
  $uri)</a></h2>
<p class="Pp">Sets the namespace prefix mapping to the uri.</p>
<p class="Pp">Normally in XML::XPath the prefixes in XPath node tests take their
    context from the current node. This means that foo:bar will always match an
    element &lt;foo:bar&gt; regardless of the namespace that the prefix foo is
    mapped to (which might even change within the document, resulting in
    unexpected results). In order to make prefixes in XPath node tests actually
    map to a real URI, you need to enable that via a call to the set_namespace
    method of your XML::XPath object.</p>
</section>
<section class="Ss">
<h2 class="Ss"><i>clear_namespaces()</i></h2>
<p class="Pp">Clears all previously set namespace mappings.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$XML::XPath::Namespaces"><a class="permalink" href="#$XML::XPath::Namespaces">$XML::XPath::Namespaces</a></h2>
<p class="Pp">Set this to 0 if you <i>don't</i> want namespace processing to
    occur. This will make everything a little (tiny) bit faster, but you'll
    suffer for it, probably.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Node_Object_Model"><a class="permalink" href="#Node_Object_Model">Node
  Object Model</a></h1>
<p class="Pp">See XML::XPath::Node, XML::XPath::Node::Element,
    XML::XPath::Node::Text, XML::XPath::Node::Comment,
    XML::XPath::Node::Attribute, XML::XPath::Node::Namespace, and
    XML::XPath::Node::PI.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="On_Garbage_Collection"><a class="permalink" href="#On_Garbage_Collection">On
  Garbage Collection</a></h1>
<p class="Pp">XPath nodes work in a special way that allows circular references,
    and yet still lets Perl's reference counting garbage collector to clean up
    the nodes after use. This should be totally transparent to the user, with
    one caveat: <b>If you free your tree before letting go of a sub-tree,</b>
    <b>consider that playing with fire and you may get burned</b>. What does
    this mean to the average user? Not much. Provided you don't free (or let go
    out of scope) either the tree you passed to XML::XPath-&gt;new, or if you
    didn't pass a tree, and passed a filename or IO-ref, then provided you don't
    let the XML::XPath object go out of scope before you let results of
    <i>find()</i> and its friends go out of scope, then you'll be fine. Even if
    you <b>do</b> let the tree go out of scope before results, you'll probably
    still be fine. The only case where you may get stung is when the last part
    of your path/query is either an ancestor or parent axis. In that case the
    worst that will happen is you'll end up with a circular reference that won't
    get cleared until interpreter destruction time. You can get around that by
    explicitly calling <span class="Li">$node</span>-&gt;DESTROY on each of your
    result nodes, if you really need to do that.</p>
<p class="Pp">Mail me direct if that's not clear. Note that it's not doom and
    gloom. It's by no means perfect, but the worst that will happen is a long
    running process could leak memory. Most long running processes will
    therefore be able to explicitly be careful not to free the tree (or
    XML::XPath object) before freeing results. AxKit, an application that uses
    XML::XPath, does this and I didn't have to make any changes to the code -
    it's already sensible programming.</p>
<p class="Pp">If you <i>really</i> don't want all this to happen, then set the
    variable <span class="Li">$XML::XPath::SafeMode</span>, and call
    <span class="Li">$xp</span>-&gt;<i>cleanup()</i> on the XML::XPath object
    when you're finished, or <span class="Li">$tree</span>-&gt;<i>dispose()</i>
    if you have a tree instead.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Example"><a class="permalink" href="#Example">Example</a></h1>
<p class="Pp">Please see the test files in t/ for examples on how to use
  XPath.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Support/Author"><a class="permalink" href="#Support/Author">Support/Author</a></h1>
<p class="Pp">This module is copyright 2000 AxKit.com Ltd. This is free
    software, and as such comes with NO WARRANTY. No dates are used in this
    module. You may distribute this module under the terms of either the Gnu
    GPL, or the Artistic License (the same terms as Perl itself).</p>
<p class="Pp">For support, please subscribe to the Perl-XML mailing list at the
    URL http://listserv.activestate.com/mailman/listinfo/perl-xml</p>
<p class="Pp">Matt Sergeant, matt@sergeant.org</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">XML::XPath::Literal, XML::XPath::Boolean, XML::XPath::Number,
    XML::XPath::XMLParser, XML::XPath::NodeSet, XML::XPath::PerlSAX,
    XML::XPath::Builder.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2003-01-26</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

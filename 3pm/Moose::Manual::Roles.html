<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Moose::Manual::Roles(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Moose::Manual::Roles(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Moose::Manual::Roles(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Moose::Manual::Roles - Roles, an alternative to deep hierarchies
    and base classes</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 2.2012</p>
</section>
<section class="Sh">
<h1 class="Sh" id="WHAT_IS_A_ROLE?"><a class="permalink" href="#WHAT_IS_A_ROLE?">WHAT
  IS A ROLE?</a></h1>
<p class="Pp">A role encapsulates some piece of behavior or state that can be
    shared between classes. It is something that classes <i>do</i>. It is
    important to understand that <i>roles are not classes</i>. You cannot
    inherit from a role, and a role cannot be instantiated. We sometimes say
    that roles are <i>consumed</i>, either by classes or other roles.</p>
<p class="Pp">Instead, a role is <i>composed</i> into a class. In practical
    terms, this means that all of the methods, method modifiers, and attributes
    defined in a role are added directly to (we sometimes say &quot;flattened
    into&quot;) the class that consumes the role. These attributes and methods
    then appear as if they were defined in the class itself. A subclass of the
    consuming class will inherit all of these methods and attributes.</p>
<p class="Pp">Moose roles are similar to mixins or interfaces in other languages
    and are based on the original concept of Traits
    &lt;http://scg.unibe.ch/research/traits/&gt; for the Smalltalk-80 dialect
    Squeak.</p>
<p class="Pp">Besides defining their own methods and attributes, roles can also
    require that the consuming class define certain methods of its own. You
    could have a role that consisted only of a list of required methods, in
    which case the role would be very much like a Java interface.</p>
<p class="Pp">Note that attribute accessors also count as methods for the
    purposes of satisfying the requirements of a role.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="A_SIMPLE_ROLE"><a class="permalink" href="#A_SIMPLE_ROLE">A
  SIMPLE ROLE</a></h1>
<p class="Pp">Creating a role looks a lot like creating a Moose class:</p>
<p class="Pp"></p>
<pre>  package Breakable;
  use Moose::Role;
  has 'is_broken' =&gt; (
      is  =&gt; 'rw',
      isa =&gt; 'Bool',
  );
  sub break {
      my $self = shift;
      print &quot;I broke\n&quot;;
      $self-&gt;is_broken(1);
  }
</pre>
<p class="Pp">Except for our use of Moose::Role, this looks just like a class
    definition with Moose. However, this is not a class, and it cannot be
    instantiated.</p>
<p class="Pp">Instead, its attributes and methods will be composed into classes
    which use the role:</p>
<p class="Pp"></p>
<pre>  package Car;
  use Moose;
  with 'Breakable';
  has 'engine' =&gt; (
      is  =&gt; 'ro',
      isa =&gt; 'Engine',
  );
</pre>
<p class="Pp">The <span class="Li">&quot;with&quot;</span> function composes
    roles into a class. Once that is done, the
    <span class="Li">&quot;Car&quot;</span> class has an
    <span class="Li">&quot;is_broken&quot;</span> attribute and a
    <span class="Li">&quot;break&quot;</span> method. The
    <span class="Li">&quot;Car&quot;</span> class also
    <span class="Li">&quot;does('Breakable')&quot;</span>:</p>
<p class="Pp"></p>
<pre>  my $car = Car-&gt;new( engine =&gt; Engine-&gt;new );
  print $car-&gt;is_broken ? 'Busted' : 'Still working';
  $car-&gt;break;
  print $car-&gt;is_broken ? 'Busted' : 'Still working';
  $car-&gt;does('Breakable'); # true
</pre>
<p class="Pp">This prints:</p>
<p class="Pp"></p>
<pre>  Still working
  I broke
  Busted
</pre>
<p class="Pp">We could use this same role in a
    <span class="Li">&quot;Bone&quot;</span> class:</p>
<p class="Pp"></p>
<pre>  package Bone;
  use Moose;
  with 'Breakable';
  has 'marrow' =&gt; (
      is  =&gt; 'ro',
      isa =&gt; 'Marrow',
  );
</pre>
<p class="Pp">See also Moose::Cookbook::Roles::Comparable_CodeReuse for an
    example.</p>
<p class="Pp">It's possible to compose existing roles into new roles. For
    example, we can have a <span class="Li">&quot;HandleWithCare&quot;</span>
    class which applies both the <span class="Li">&quot;Breakable&quot;</span>
    and <span class="Li">&quot;Package&quot;</span> roles to any class which
    consumes it:</p>
<p class="Pp"></p>
<pre>  package HandleWithCare;
  use Moose::Role;
  with 'Breakable', 'Package';
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="REQUIRED_METHODS"><a class="permalink" href="#REQUIRED_METHODS">REQUIRED
  METHODS</a></h1>
<p class="Pp">As mentioned previously, a role can require that consuming classes
    provide one or more methods. Using our
    <span class="Li">&quot;Breakable&quot;</span> example, let's make it require
    that consuming classes implement their own
    <span class="Li">&quot;break&quot;</span> methods:</p>
<p class="Pp"></p>
<pre>  package Breakable;
  use Moose::Role;
  requires 'break';
  has 'is_broken' =&gt; (
      is  =&gt; 'rw',
      isa =&gt; 'Bool',
  );
  after 'break' =&gt; sub {
      my $self = shift;
      $self-&gt;is_broken(1);
  };
</pre>
<p class="Pp">If we try to consume this role in a class that does not have a
    <span class="Li">&quot;break&quot;</span> method, we will get an
  exception.</p>
<p class="Pp">You can see that we added a method modifier on
    <span class="Li">&quot;break&quot;</span>. We want classes that consume this
    role to implement their own logic for breaking, but we make sure that the
    <span class="Li">&quot;is_broken&quot;</span> attribute is always set to
    true when <span class="Li">&quot;break&quot;</span> is called.</p>
<p class="Pp"></p>
<pre>  package Car
  use Moose;
  with 'Breakable';
  has 'engine' =&gt; (
      is  =&gt; 'ro',
      isa =&gt; 'Engine',
  );
  sub break {
      my $self = shift;
      if ( $self-&gt;is_moving ) {
          $self-&gt;stop;
      }
  }
</pre>
<section class="Ss">
<h2 class="Ss" id="Roles_Versus_Abstract_Base_Classes"><a class="permalink" href="#Roles_Versus_Abstract_Base_Classes">Roles
  Versus Abstract Base Classes</a></h2>
<p class="Pp">If you are familiar with the concept of abstract base classes in
    other languages, you may be tempted to use roles in the same way.</p>
<p class="Pp">You <i>can</i> define an &quot;interface-only&quot; role, one that
    contains <i>just</i> a list of required methods.</p>
<p class="Pp">However, any class which consumes this role must implement all of
    the required methods, either directly or through inheritance from a parent.
    You cannot delay the method requirement check so that they can be
    implemented by future subclasses.</p>
<p class="Pp">Because the role defines the required methods directly, adding a
    base class to the mix would not achieve anything. We recommend that you
    simply consume the interface role in each class which implements that
    interface.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CONSUMING_ROLES"><a class="permalink" href="#CONSUMING_ROLES">CONSUMING
  ROLES</a></h1>
<p class="Pp">Roles are consumed using the
    <span class="Li">&quot;with&quot;</span> function.</p>
<p class="Pp">Most of the time, you should only use one
    <span class="Li">&quot;with&quot;</span>, even if you are consuming multiple
    roles. If you consume roles using multiple
    <span class="Li">&quot;with&quot;</span> statements Moose cannot detect
    method conflicts between those roles.</p>
<p class="Pp">Roles can be consumed by classes or by other roles. When a class
    consumes a role which in turn consumes other roles, the class gets all of
    the roles applied at once.</p>
<section class="Ss">
<h2 class="Ss" id="Required_Methods_Provided_by_Attributes"><a class="permalink" href="#Required_Methods_Provided_by_Attributes">Required
  Methods Provided by Attributes</a></h2>
<p class="Pp">As mentioned before, a role's required method may also be
    satisfied by an attribute accessor. However, the call to
    <span class="Li">&quot;has&quot;</span> which defines an attribute happens
    at runtime. This means that you must define the attribute <i>before</i>
    consuming the role, or else the role will not see the generated accessor.
    These attributes are Moose Attributes.</p>
<p class="Pp"></p>
<pre>  package Breakable;
  use Moose::Role;
  requires 'stress';
  ########
  package Car;
  use Moose;
  has 'stress' =&gt; (
      is  =&gt; 'ro',
      isa =&gt; 'Int',
  );
  with 'Breakable';
</pre>
<p class="Pp">In general, we recommend that you always consume roles
    <i>after</i> declaring all your attributes.</p>
<p class="Pp">It may also be the case that a class wants to consume two roles
    where one role has an attribute providing a required method for another. For
    example:</p>
<p class="Pp"></p>
<pre>  package Breakable;
  use Moose::Role;
  requires 'stress';
  ########
  package Stressable;
  use Moose::Role;
  has 'stress' =&gt; (
      is  =&gt; 'ro',
      isa =&gt; 'Int',
  );
  ########
  package Car;
  use Moose;
  # XXX - this will not work
  with 'Breakable', 'Stressable';
</pre>
<p class="Pp">However, this won't work. The problem is that the accessor methods
    created for the <span class="Li">&quot;stress&quot;</span> attribute won't
    be present in the class when the required method checks are done.</p>
<p class="Pp">There are two possible workarounds. The recommended one is to use
    &quot;stub&quot; subroutine(s) in the role providing the accessor(s):</p>
<p class="Pp"></p>
<pre>  package Stressable;
  use Moose::Role;
  sub stress;
  has 'stress' =&gt; (
      is  =&gt; 'ro',
      isa =&gt; 'Int',
  );
</pre>
<p class="Pp">The <span class="Li">&quot;sub stress;&quot;</span> line is called
    a &quot;forward&quot; declaration in the Perl documentation. It creates what
    is called a &quot;stub&quot; subroutine, a declaration without a body. This
    is good enough to satisfy the required method checks done by Moose. The stub
    will not interfere with the creation of a real subroutine later.</p>
<p class="Pp">The other alternative is to use two separate calls to
    <span class="Li">&quot;with&quot;</span> in the consuming class:</p>
<p class="Pp"></p>
<pre>  package Car;
  use Moose;
  # Not recommended
  with 'Stressable';
  with 'Breakable';
</pre>
<p class="Pp">Each <span class="Li">&quot;with&quot;</span> is run as it is
    seen. The first call will consume just the
    <span class="Li">&quot;Stressable&quot;</span> role, which will add the
    <span class="Li">&quot;stress&quot;</span> attribute to the
    <span class="Li">&quot;Car&quot;</span> package, which in turn will create
    an accessor method named <span class="Li">&quot;stress&quot;</span>. Then
    when the <span class="Li">&quot;Breakable&quot;</span> role is consumed, the
    method it requires already exists.</p>
<p class="Pp">However, as mentioned earlier, multiple
    <span class="Li">&quot;with&quot;</span> declarations are not recommended,
    because method conflicts between the roles cannot be seen. In the example
    above, if both <span class="Li">&quot;Stressable&quot;</span> and
    <span class="Li">&quot;Breakable&quot;</span> contained methods of the same
    name, what would happen is that the version in
    <span class="Li">&quot;Stressable&quot;</span> would <i>silently</i>
    override the one in <span class="Li">&quot;Breakable&quot;</span>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="USING_METHOD_MODIFIERS"><a class="permalink" href="#USING_METHOD_MODIFIERS">USING
  METHOD MODIFIERS</a></h1>
<p class="Pp">Method modifiers and roles are a very powerful combination. Often,
    a role will combine method modifiers and required methods. We already saw
    one example with our <span class="Li">&quot;Breakable&quot;</span>
  example.</p>
<p class="Pp">Method modifiers increase the complexity of roles, because they
    make the role application order relevant. If a class uses multiple roles,
    each of which modify the same method, those modifiers will be applied in the
    same order as the roles are used:</p>
<p class="Pp"></p>
<pre>  package MovieCar;
  use Moose;
  extends 'Car';
  with 'Breakable', 'ExplodesOnBreakage';
</pre>
<p class="Pp">Assuming that the new
    <span class="Li">&quot;ExplodesOnBreakage&quot;</span> role <i>also</i> has
    an <span class="Li">&quot;after&quot;</span> modifier on
    <span class="Li">&quot;break&quot;</span>, the
    <span class="Li">&quot;after&quot;</span> modifiers will run one after the
    other. The modifier from <span class="Li">&quot;Breakable&quot;</span> will
    run first, then the one from
    <span class="Li">&quot;ExplodesOnBreakage&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHOD_CONFLICTS"><a class="permalink" href="#METHOD_CONFLICTS">METHOD
  CONFLICTS</a></h1>
<p class="Pp">If a class composes multiple roles, and those roles have methods
    of the same name, we will have a conflict. In that case, the composing class
    is required to provide its <i>own</i> method of the same name.</p>
<p class="Pp"></p>
<pre>  package Breakdancer;
  use Moose::Role;
  sub break {
  }
</pre>
<p class="Pp">If we compose both <span class="Li">&quot;Breakable&quot;</span>
    and <span class="Li">&quot;Breakdancer&quot;</span> in a class, we must
    provide our own <span class="Li">&quot;break&quot;</span> method:</p>
<p class="Pp"></p>
<pre>  package FragileDancer;
  use Moose;
  with 'Breakable', 'Breakdancer';
  sub break { ... }
</pre>
<p class="Pp">A role can be a collection of other roles:</p>
<p class="Pp"></p>
<pre>  package Break::Bundle;
  use Moose::Role;
  with ('Breakable', 'Breakdancer');
</pre>
<p class="Pp">When a role consumes another a role, the <i>consuming</i> role's
    methods silently win in any conflict, and the consumed role's methods are
    simply ignored.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHOD_EXCLUSION_AND_ALIASING"><a class="permalink" href="#METHOD_EXCLUSION_AND_ALIASING">METHOD
  EXCLUSION AND ALIASING</a></h1>
<p class="Pp">If we want our <span class="Li">&quot;FragileDancer&quot;</span>
    class to be able to call the methods from both its roles, we can alias the
    methods:</p>
<p class="Pp"></p>
<pre>  package FragileDancer;
  use Moose;
  with 'Breakable'   =&gt; { -alias =&gt; { break =&gt; 'break_bone' } },
       'Breakdancer' =&gt; { -alias =&gt; { break =&gt; 'break_dance' } };
</pre>
<p class="Pp">However, aliasing a method simply makes a <i>copy</i> of the
    method with the new name. We also need to exclude the original name:</p>
<p class="Pp"></p>
<pre>  with 'Breakable' =&gt; {
      -alias    =&gt; { break =&gt; 'break_bone' },
      -excludes =&gt; 'break',
      },
      'Breakdancer' =&gt; {
      -alias    =&gt; { break =&gt; 'break_dance' },
      -excludes =&gt; 'break',
      };
</pre>
<p class="Pp">The excludes parameter prevents the
    <span class="Li">&quot;break&quot;</span> method from being composed into
    the <span class="Li">&quot;FragileDancer&quot;</span> class, so we don't
    have a conflict. This means that
    <span class="Li">&quot;FragileDancer&quot;</span> does not need to implement
    its own <span class="Li">&quot;break&quot;</span> method.</p>
<p class="Pp">This is useful, but it's worth noting that this breaks the
    contract implicit in consuming a role. Our
    <span class="Li">&quot;FragileDancer&quot;</span> class does both the
    <span class="Li">&quot;Breakable&quot;</span> and
    <span class="Li">&quot;BreakDancer&quot;</span>, but does not provide a
    <span class="Li">&quot;break&quot;</span> method. If some API expects an
    object that does one of those roles, it probably expects it to implement
    that method.</p>
<p class="Pp">In some use cases we might alias and exclude methods from roles,
    but then provide a method of the same name in the class itself.</p>
<p class="Pp">Also see Moose::Cookbook::Roles::Restartable_AdvancedComposition
    for an example.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OVERLOADING"><a class="permalink" href="#OVERLOADING">OVERLOADING</a></h1>
<p class="Pp">When a Moose role uses overloading, that overloading is composed
    into any classes that consume the role. This includes the setting of the
    <span class="Li">&quot;fallback&quot;</span> value for that role's
    overloading. Just as with methods and attributes, when a role consumes
    another role, that other role's overloading settings are applied to the
    role.</p>
<p class="Pp">Just as with methods, there can be conflicts with overloading
    implementations between multiple roles when they are all consumed by a
    class. If two roles both provide different overloading implementations for a
    given operator, that is a conflict. If two roles both implement overloading
    and have different <span class="Li">&quot;fallback&quot;</span> values, that
    is also considered a conflict. These conflicts are detected when multiple
    roles are being composed into a class together.</p>
<p class="Pp">When a role consumes another role, the consuming role's
    overloading fallback and operator implementations silently &quot;win&quot;
    the conflict.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ROLE_EXCLUSION"><a class="permalink" href="#ROLE_EXCLUSION">ROLE
  EXCLUSION</a></h1>
<p class="Pp">A role can say that it cannot be combined with some other role.
    This should be used with great caution, since it limits the re-usability of
    the role.</p>
<p class="Pp"></p>
<pre>  package Breakable;
  use Moose::Role;
  excludes 'BreakDancer';
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="ADDING_A_ROLE_TO_AN_OBJECT_INSTANCE"><a class="permalink" href="#ADDING_A_ROLE_TO_AN_OBJECT_INSTANCE">ADDING
  A ROLE TO AN OBJECT INSTANCE</a></h1>
<p class="Pp">You may want to add a role to an object instance, rather than to a
    class. For example, you may want to add debug tracing to one instance of an
    object while debugging a particular bug. Another use case might be to
    dynamically change objects based on a user's configuration, as a plugin
    system.</p>
<p class="Pp">The best way to do this is to use the
    <span class="Li">&quot;apply_all_roles()&quot;</span> function from
    Moose::Util:</p>
<p class="Pp"></p>
<pre>  use Moose::Util qw( apply_all_roles );
  my $car = Car-&gt;new;
  apply_all_roles( $car, 'Breakable' );
</pre>
<p class="Pp">This function can apply more than one role at a time, and will do
    so using the normal Moose role combination system. We recommend using this
    function to apply roles to an object. This is what Moose uses internally
    when you call <span class="Li">&quot;with&quot;</span>.</p>
<section class="Ss">
<h2 class="Ss" id="Handling_required_attributes_for_roles."><a class="permalink" href="#Handling_required_attributes_for_roles.">Handling
  required attributes for roles.</a></h2>
<p class="Pp">Application of some roles will require additional parameters being
    specified to satisfy them, for example:</p>
<p class="Pp"></p>
<pre>    {
        package Car;
        use Moose;
    }
    {
        package Breakable;
        use Moose::Role;
        has 'breakable_parts' =&gt; ( is =&gt; 'ro', required =&gt; 1 );
    }
    my $car = Car-&gt;new;
    # next line dies with: Attribute (breakable_parts) is required
    apply_all_roles( $car, 'Breakable' );
</pre>
<p class="Pp">This will require passing the additional parameters at application
    time as follows:</p>
<p class="Pp"></p>
<pre>    apply_all_roles( $car, 'Breakable' =&gt; {
            rebless_params =&gt; {
                # Parameters to 'Breakable'
                breakable_parts =&gt; [qw( tires wheels windscreen )],
            }
    });
</pre>
<p class="Pp">Obviously, this interface is better simplified as a method on
    <span class="Li">&quot;Car&quot;</span>:</p>
<p class="Pp"></p>
<pre>    sub make_breakable {
        my ( $self, %params ) = @_;
        apply_all_roles($self, 'Breakable', { rebless_params =&gt; \%params });
    }
    my $car = Car-&gt;new();
    $car-&gt;make_breakable( breakable_parts =&gt; [qw( tires wheels windscreen )] );
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Stevan Little &lt;stevan.little@iinteractive.com&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
  <li>Shawn M Moore &lt;code@sartak.org&gt;</li>
  <li>&#x05D9;&#x05D5;&#x05D1;&#x05DC; &#x05E7;&#x05D5;&#x05D2;'&#x05DE;&#x05DF;
      (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Florian Ragwitz &lt;rafl@debian.org&gt;</li>
  <li>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</li>
  <li>Chris Prather &lt;chris@prather.org&gt;</li>
  <li>Matt S Trout &lt;mst@shadowcat.co.uk&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2006 by Infinity Interactive,
  Inc.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-11-22</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

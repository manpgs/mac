<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Specio::Declare(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Specio::Declare(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Specio::Declare(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Specio::Declare - Specio declaration subroutines</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 0.46</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    package MyApp::Type::Library;
    use parent 'Specio::Exporter';
    use Specio::Declare;
    use Specio::Library::Builtins;
    declare(
        'Foo',
        parent =&gt; t('Str'),
        where  =&gt; sub { $_[0] =~ /foo/i },
    );
    declare(
        'ArrayRefOfInt',
        parent =&gt; t( 'ArrayRef', of =&gt; t('Int') ),
    );
    my $even = anon(
        parent =&gt; t('Int'),
        inline =&gt; sub {
            my $type      = shift;
            my $value_var = shift;
            return $value_var . ' % 2 == 0';
        },
    );
    coerce(
        t('ArrayRef'),
        from  =&gt; t('Foo'),
        using =&gt; sub { [ $_[0] ] },
    );
    coerce(
        $even,
        from  =&gt; t('Int'),
        using =&gt; sub { $_[0] % 2 ? $_[0] + 1 : $_[0] },
    );
    # Specio name is DateTime
    any_isa_type('DateTime');
    # Specio name is DateTimeObject
    object_isa_type( 'DateTimeObject', class =&gt; 'DateTime' );
    any_can_type(
        'Duck',
        methods =&gt; [ 'duck_walk', 'quack' ],
    );
    object_can_type(
        'DuckObject',
        methods =&gt; [ 'duck_walk', 'quack' ],
    );
    enum(
        'Colors',
        values =&gt; [qw( blue green red )],
    );
    intersection(
        'HashRefAndArrayRef',
        of =&gt; [ t('HashRef'), t('ArrayRef') ],
    );
    union(
        'IntOrArrayRef',
        of =&gt; [ t('Int'), t('ArrayRef') ],
    );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This package exports a set of type declaration helpers. Importing
    this package also causes it to create a
    <span class="Li">&quot;t&quot;</span> subroutine the caller.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUBROUTINES"><a class="permalink" href="#SUBROUTINES">SUBROUTINES</a></h1>
<p class="Pp">This module exports the following subroutines.</p>
<section class="Ss">
<h2 class="Ss" id="t('name')"><a class="permalink" href="#t('name')">t('name')</a></h2>
<p class="Pp">This subroutine lets you access any types you have declared so
    far, as well as any types you imported from another type library.</p>
<p class="Pp">If you pass an unknown name, it throws an exception.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="declare(...)"><a class="permalink" href="#declare(...)">declare(...)</a></h2>
<p class="Pp">This subroutine declares a named type. The first argument is the
    type name, followed by a set of key/value parameters:</p>
<ul class="Bl-bullet">
  <li>parent =&gt; <span class="Li">$type</span>
    <p class="Pp">The parent should be another type object. Specifically, it can
        be anything which does the Specio::Constraint::Role::Interface role. The
        parent can be a named or anonymous type.</p>
  </li>
  <li>where =&gt; sub { ... }
    <p class="Pp">This is a subroutine which defines the type constraint. It
        will be passed a single argument, the value to check, and it should
        return true or false to indicate whether or not the value is valid for
        the type.</p>
    <p class="Pp">This parameter is mutually exclusive with the
        <span class="Li">&quot;inline&quot;</span> parameter.</p>
  </li>
  <li>inline =&gt; sub { ... }
    <p class="Pp">This is a subroutine that is called to generate inline code to
        validate the type. Inlining can be <i>much</i> faster than simply
        providing a subroutine with the
        <span class="Li">&quot;where&quot;</span> parameter, but is often more
        complicated to get right.</p>
    <p class="Pp">The inline generator is called as a method on the type with
        one argument. This argument is a <i>string</i> containing the variable
        name to use in the generated code. Typically this is something like
        <span class="Li">'$_[0]'</span> or <span class="Li">'$value'</span>.</p>
    <p class="Pp">The inline generator subroutine should return a <i>string</i>
        of code representing a single term, and it <i>should not</i> be
        terminated with a semicolon. This allows the inlined code to be safely
        included in an <span class="Li">&quot;if&quot;</span> statement, for
        example. You can use <span class="Li">&quot;do { }&quot;</span> blocks
        and ternaries to get everything into one term. Do not assign to the
        variable you are testing. This single term should evaluate to true or
        false.</p>
    <p class="Pp">The inline generator is expected to include code to implement
        both the current type and all its parents. Typically, the easiest way to
        do this is to write a subroutine something like this:</p>
    <p class="Pp"></p>
    <pre>  sub {
      my $self = shift;
      my $var  = shift;
      return $self-&gt;parent-&gt;inline_check($var)
          . ' and more checking code goes here';
  }
    </pre>
    <p class="Pp">Or, more concisely:</p>
    <p class="Pp"></p>
    <pre>  sub { $_[0]-&gt;parent-&gt;inline_check( $_[1] ) . 'more code that checks $_[1]' }
    </pre>
    <p class="Pp">The <span class="Li">&quot;inline&quot;</span> parameter is
        mutually exclusive with the <span class="Li">&quot;where&quot;</span>
        parameter.</p>
  </li>
  <li>message_generator =&gt; sub { ... }
    <p class="Pp">A subroutine to generate an error message when the type check
        fails. The default message says something like &quot;Validation failed
        for type named Int declared in package Specio::Library::Builtins
        (.../Specio/blib/lib/Specio/Library/Builtins.pm) at line 147 in sub
        named (eval) with value 1.1&quot;.</p>
    <p class="Pp">You can override this to provide something more specific about
        the way the type failed.</p>
    <p class="Pp">The subroutine you provide will be called as a method on the
        type with two arguments. The first is the description of the type (the
        bit in the message above that starts with &quot;type named Int ...&quot;
        and ends with &quot;... in sub named (eval)&quot;. This description says
        what the thing is and where it was defined.</p>
    <p class="Pp">The second argument is the value that failed the type check,
        after any coercions that might have been applied.</p>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="anon(...)"><a class="permalink" href="#anon(...)">anon(...)</a></h2>
<p class="Pp">This subroutine declares an anonymous type. It is identical to
    <span class="Li">&quot;declare&quot;</span> except that it expects a list of
    key/value parameters without a type name as the first parameter.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="coerce(...)"><a class="permalink" href="#coerce(...)">coerce(...)</a></h2>
<p class="Pp">This declares a coercion from one type to another. The first
    argument should be an object which does the
    Specio::Constraint::Role::Interface role. This can be either a named or
    anonymous type. This type is the type that the coercion is <i>to</i>.</p>
<p class="Pp">The remaining arguments are key/value parameters:</p>
<ul class="Bl-bullet">
  <li>from =&gt; <span class="Li">$type</span>
    <p class="Pp">This must be an object which does the
        Specio::Constraint::Role::Interface role. This is type that we are
        coercing <i>from</i>. Again, this can be either a named or anonymous
        type.</p>
  </li>
  <li>using =&gt; sub { ... }
    <p class="Pp">This is a subroutine which defines the type coercion. It will
        be passed a single argument, the value to coerce. It should return a new
        value of the type this coercion is to.</p>
    <p class="Pp">This parameter is mutually exclusive with the
        <span class="Li">&quot;inline&quot;</span> parameter.</p>
  </li>
  <li>inline =&gt; sub { ... }
    <p class="Pp">This is a subroutine that is called to generate inline code to
        perform the coercion.</p>
    <p class="Pp">The inline generator is called as a method on the type with
        one argument. This argument is a <i>string</i> containing the variable
        name to use in the generated code. Typically this is something like
        <span class="Li">'$_[0]'</span> or <span class="Li">'$value'</span>.</p>
    <p class="Pp">The inline generator subroutine should return a <i>string</i>
        of code representing a single term, and it <i>should not</i> be
        terminated with a semicolon. This allows the inlined code to be safely
        included in an <span class="Li">&quot;if&quot;</span> statement, for
        example. You can use <span class="Li">&quot;do { }&quot;</span> blocks
        and ternaries to get everything into one term. This single term should
        evaluate to the new value.</p>
  </li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DECLARATION_HELPERS"><a class="permalink" href="#DECLARATION_HELPERS">DECLARATION
  HELPERS</a></h1>
<p class="Pp">This module also exports some helper subs for declaring certain
    kinds of types:</p>
<section class="Ss">
<h2 class="Ss" id="any_isa_type,_object_isa_type"><a class="permalink" href="#any_isa_type,_object_isa_type">any_isa_type,
  object_isa_type</a></h2>
<p class="Pp">The <span class="Li">&quot;any_isa_type&quot;</span> helper
    creates a type which accepts a class name or object of the given class. The
    <span class="Li">&quot;object_isa_type&quot;</span> helper creates a type
    which only accepts an object of the given class.</p>
<p class="Pp">These subroutines take a type name as the first argument. The
    remaining arguments are key/value pairs. Currently this is just the
    <span class="Li">&quot;class&quot;</span> key, which should be a class name.
    This is the class that the type requires.</p>
<p class="Pp">The type name argument can be omitted to create an anonymous
  type.</p>
<p class="Pp">You can also pass just a single argument, in which case that will
    be used as both the type's name and the class for the constraint to
  check.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="any_does_type,_object_does_type"><a class="permalink" href="#any_does_type,_object_does_type">any_does_type,
  object_does_type</a></h2>
<p class="Pp">The <span class="Li">&quot;any_does_type&quot;</span> helper
    creates a type which accepts a class name or object which does the given
    role. The <span class="Li">&quot;object_does_type&quot;</span> helper
    creates a type which only accepts an object which does the given role.</p>
<p class="Pp">These subroutines take a type name as the first argument. The
    remaining arguments are key/value pairs. Currently this is just the
    <span class="Li">&quot;role&quot;</span> key, which should be a role name.
    This is the class that the type requires.</p>
<p class="Pp">This should just work (I hope) with roles created by Moose, Mouse,
    and Moo (using Role::Tiny).</p>
<p class="Pp">The type name argument can be omitted to create an anonymous
  type.</p>
<p class="Pp">You can also pass just a single argument, in which case that will
    be used as both the type's name and the role for the constraint to
  check.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="any_can_type,_object_can_type"><a class="permalink" href="#any_can_type,_object_can_type">any_can_type,
  object_can_type</a></h2>
<p class="Pp">The <span class="Li">&quot;any_can_type&quot;</span> helper
    creates a type which accepts a class name or object with the given methods.
    The <span class="Li">&quot;object_can_type&quot;</span> helper creates a
    type which only accepts an object with the given methods.</p>
<p class="Pp">These subroutines take a type name as the first argument. The
    remaining arguments are key/value pairs. Currently this is just the
    <span class="Li">&quot;methods&quot;</span> key, which can be either a
    string or array reference of strings. These strings are the required methods
    for the type.</p>
<p class="Pp">The type name argument can be omitted to create an anonymous
  type.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="enum"><a class="permalink" href="#enum">enum</a></h2>
<p class="Pp">This creates a type which accepts a string matching a given list
    of acceptable values.</p>
<p class="Pp">The first argument is the type name. The remaining arguments are
    key/value pairs. Currently this is just the
    <span class="Li">&quot;values&quot;</span> key. This should an array
    reference of acceptable string values.</p>
<p class="Pp">The type name argument can be omitted to create an anonymous
  type.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="intersection"><a class="permalink" href="#intersection">intersection</a></h2>
<p class="Pp">This creates a type which is the intersection of two or more other
    types. A union only accepts values which match all of its underlying
  types.</p>
<p class="Pp">The first argument is the type name. The remaining arguments are
    key/value pairs. Currently this is just the
    <span class="Li">&quot;of&quot;</span> key. This should an array reference
    of types.</p>
<p class="Pp">The type name argument can be omitted to create an anonymous
  type.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="union"><a class="permalink" href="#union">union</a></h2>
<p class="Pp">This creates a type which is the union of two or more other types.
    A union accepts any of its underlying types.</p>
<p class="Pp">The first argument is the type name. The remaining arguments are
    key/value pairs. Currently this is just the
    <span class="Li">&quot;of&quot;</span> key. This should an array reference
    of types.</p>
<p class="Pp">The type name argument can be omitted to create an anonymous
  type.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="PARAMETERIZED_TYPES"><a class="permalink" href="#PARAMETERIZED_TYPES">PARAMETERIZED
  TYPES</a></h1>
<p class="Pp">You can create a parameterized type by calling
    <span class="Li">&quot;t&quot;</span> with additional parameters, like
  this:</p>
<p class="Pp"></p>
<pre>  my $arrayref_of_int = t( 'ArrayRef', of =&gt; t('Int') );
  my $arrayref_of_hashref_of_int = t(
      'ArrayRef',
      of =&gt; t(
          'HashRef',
          of =&gt; t('Int'),
      ),
  );
</pre>
<p class="Pp">The <span class="Li">&quot;t&quot;</span> subroutine assumes that
    if it receives more than one argument, it should look up the named type and
    call <span class="Li">&quot;$type-&gt;parameterize(...)&quot;</span> with
    the additional arguments.</p>
<p class="Pp">If the named type cannot be parameterized, it throws an error.</p>
<p class="Pp">You can also call
    <span class="Li">&quot;$type-&gt;parameterize&quot;</span> directly if
    needed. See Specio::Constraint::Parameterizable for details.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
<p class="Pp">Bugs may be submitted at
    &lt;https://github.com/houseabsolute/Specio/issues&gt;.</p>
<p class="Pp">I am also usually active on IRC as 'autarch' on
    <span class="Li">&quot;irc://irc.perl.org&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SOURCE"><a class="permalink" href="#SOURCE">SOURCE</a></h1>
<p class="Pp">The source code repository for Specio can be found at
    &lt;https://github.com/houseabsolute/Specio&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Dave Rolsky &lt;autarch@urth.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is Copyright (c) 2012 - 2020 by Dave Rolsky.</p>
<p class="Pp">This is free software, licensed under:</p>
<p class="Pp"></p>
<pre>  The Artistic License 2.0 (GPL Compatible)
</pre>
<p class="Pp">The full text of the license can be found in the <i>LICENSE</i>
    file included with this distribution.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-03-14</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

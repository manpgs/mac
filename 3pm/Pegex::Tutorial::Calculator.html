<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Pegex::Tutorial::Calculator(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Pegex::Tutorial::Calculator(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Pegex::Tutorial::Calculator(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="Pegex_Tutorial_Calculator"><a class="permalink" href="#Pegex_Tutorial_Calculator">Pegex
  Tutorial Calculator</a></h1>
<p class="Pp">A Pegex Calculator</p>
<p class="Pp">When you look around the web for stuff about parsing, you
    inevitably find a bunch of examples about how to write a precedence parser
    for mathematical expressions.</p>
<ul class="Bl-bullet">
  <li>&lt;http://en.wikipedia.org/wiki/Operator-precedence_parser&gt;</li>
  <li>&lt;http://eli.thegreenplace.net/2010/01/02/top-down-operator-precedence-parsing/&gt;</li>
  <li>&lt;http://www.hokstad.com/operator-precedence-parser.html&gt;</li>
  <li>&lt;http://www.perlmonks.org/?node_id=554516&gt;</li>
</ul>
<p class="Pp">This tutorial is the Pegex version of that. Pegex actually comes
    with an examples directory that contains two arithmetic expression
    parser/evaluator calculator programs:</p>
<ul class="Bl-bullet">
  <li>&lt;https://github.com/ingydotnet/pegex-pm/blob/master/eg/calculator/calculator1.pl&gt;</li>
  <li>&lt;https://github.com/ingydotnet/pegex-pm/blob/master/eg/calculator/calculator2.pl&gt;</li>
</ul>
<p class="Pp">They both do the same thing but using different parsing
    approaches. We'll cover both of them in detail. I hope you'll find that
    Pegex handles operator precedence parsing elegantly.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="The_Problem"><a class="permalink" href="#The_Problem">The
  Problem</a></h1>
<p class="Pp">Precedence parsers are interesting because you need to deal with
    operators that have the same precedence, different precedences and both left
    and right associativity.</p>
<p class="Pp">Consider the equation:</p>
<p class="Pp"></p>
<pre>    1 - 2 ^ 3 ^ 4 + 5 * 6 / 7
</pre>
<p class="Pp">Normal precedence and associativity rules make this the same
  as:</p>
<p class="Pp"></p>
<pre>    (1 - (2 ^ (3 ^ 4)) + ((5 * 6) / 7))
</pre>
<p class="Pp">Our calculator should produce the same result for both. Note that
    this means we will be parsing numbers, 5 operators, parentheses, and
    separating whitespace.</p>
<p class="Pp">Here's an example of the calculator program running:</p>
<p class="Pp"></p>
<pre>    &gt; perl eg/calculator1.pl
    Enter an equation: 1+2*3
    1+2*3 = 7
    Enter an equation: (1 + 2) * 3
    (1 + 2) * 3 = 9
    Enter an equation:
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="The_Solutions"><a class="permalink" href="#The_Solutions">The
  Solutions</a></h1>
<p class="Pp">Most of the solutions that you'll read about on the web, involve
    (or assume) a lexing/tokenizing step before parsing. Pegex always parses an
    input stream directly, pulling out &quot;tokens&quot; that it needs using
    regex captures. So the parse happens as one operation, which has many
    advantages.</p>
<p class="Pp">But how do we get the operator precedence rules into this? Well,
    we have 2 different ways:</p>
<section class="Ss">
<h2 class="Ss" id="calculator1.pl_"><a class="permalink" href="#calculator1.pl_">calculator1.pl
  - Operator Precedence Climbing</a></h2>
<p class="Pp">Note: The code in this example is copy/pasted from
    &quot;calculator/&quot; in example
  <br/>
   files. The code in those running files is slightly different but
  <br/>
   rewritten to make more sense in this doc.</p>
<p class="Pp">Our first example calculator uses what is known as the Operator
    Precedence Climbing method. See:
    &lt;http://en.wikipedia.org/wiki/Operator-precedence_parser#Precedence_climbing_method&gt;.</p>
<p class="Pp">This is basically a clever technique of specifying our grammar
    rules such that they imply precedence. Here's the pegex grammar from the
    code:</p>
<p class="Pp"></p>
<pre>    expr: add-sub
    add-sub: mul-div+ % /- ( [ '+-' ])/
    mul-div: power+ % /- ([ '*/' ])/
    power: token+ % /- '^' /
    token: /- '(' -/ expr /- ')'/ | number
    number: /- ( '-'? DIGIT+ )/
</pre>
<p class="Pp">It's a little bit wonky but it works. It says that any expression
    is an add/subtract and that an add/subtract is really a multiply/divide etc.
    Finally after the last operator comes the number token and the parens.</p>
<p class="Pp">It feels a bit backwards. One of the biggest drawbacks of PCM is
    that it becomes less and less efficient with more and more operators. It
    needs to go through the whole tree, just to find each number.</p>
<p class="Pp">But it works and the code is minimal. The receiver class gets the
    numbers in the correct order, immediately evaluates the answer and returns
    the answer for each level. Whatever the return value of the final operation
    is, becomes the result of the parse. Here's the receiver class:</p>
<p class="Pp"></p>
<pre>    {
        package Calculator;
        use base 'Pegex::Tree';
        sub gotrule {
            my ($self, $list) = @_;
            return $list unless ref $list;
            # Right associative:
            if ($self-&gt;rule eq 'power') {
                while (@$list &gt; 1) {
                    my ($a, $b) = splice(@$list, -2, 2);
                    push @$list, $a ** $b;
                }
            }
            # Left associative:
            else {
                while (@$list &gt; 1) {
                    my ($a, $op, $b) = splice(@$list, 0, 3);
                    unshift @$list,
                        ($op eq '+') ? ($a + $b) :
                        ($op eq '-') ? ($a - $b) :
                        ($op eq '*') ? ($a * $b) :
                        ($op eq '/') ? ($a / $b) :
                        die;
                }
            }
            return @$list;
        }
    }
</pre>
<p class="Pp">As you can see, it has an action method for each level or
    precedence. It loops over the expression, evaluating it. Whether it loops
    from left to right or right to left depends on the associativity that we
    want to use.</p>
<p class="Pp">Our runner code looks like this:</p>
<p class="Pp"></p>
<pre>    while (1) {
        print &quot;\nEnter an equation: &quot;;
        my $expr = &lt;&gt; || '';
        chomp $expr;
        last unless length $expr;
        calc($expr);
    }
    sub calc {
        my ($expr) = @_;
        my $result = pegex($grammar, 'Calculator')-&gt;parse($expr);
        if ($@) {
            warn $@;
            return;
        }
        print &quot;$expr = $result\n&quot;;
    }
</pre>
<p class="Pp">And that's the whole thing. We have a working calculator as
    specced!</p>
<p class="Pp">However the real point of this is to explore good parsing
    techniques, and the PCM leaves us wanting to try something more efficient.
    Let's try another approach...</p>
</section>
<section class="Ss">
<h2 class="Ss" id="calculator2.pl_"><a class="permalink" href="#calculator2.pl_">calculator2.pl
  - Shunting Yard Algorithm</a></h2>
<p class="Pp">An age old way of parsing expressions is to somehow get the
    numbers and operators into an RPN (Reverse Polish Notation) stack, which is
    each operand follow by its operator. Once in that form, precedence and
    associativity are accounted for.</p>
<p class="Pp">For example:</p>
<p class="Pp"></p>
<pre>    1 / 2 - ( -3 * 4 )
</pre>
<p class="Pp">becomes:</p>
<p class="Pp"></p>
<pre>    1, 2, /, -3, 4, *, -
</pre>
<p class="Pp">To evaluate an RPN you pop off an operator and then attempt to pop
    off and operand. If the operand is another operator you recurse. When you
    have 2 operands you do the operation and put the result back on the stack.
    When there is only 1 element on the stack, you are done. That's your
  result.</p>
<p class="Pp">Let's look at our new grammar in
    <span class="Li">&quot;calculator2.pl&quot;</span>:</p>
<p class="Pp"></p>
<pre>    expr: operand (operator operand)*
    operator: /- (['+-*/^'])/
    operand: num | /- '('/ expr /- ')'/
    num: /- ('-'? DIGIT+)/
</pre>
<p class="Pp">This is much easier to understand. We are just parsing out the
    tokens. In a (very real) sense, we are using Pegex as a lexer.</p>
<p class="Pp">Now let's look at the receiver class:</p>
<p class="Pp"></p>
<pre>    {
        package Calculator;
        use base 'Pegex::Tree', 'Precedence';
        my $operator_precedence_table = {
            '+' =&gt; {p =&gt; 1, a =&gt; 'l'},
            '-' =&gt; {p =&gt; 1, a =&gt; 'l'},
            '*' =&gt; {p =&gt; 2, a =&gt; 'l'},
            '/' =&gt; {p =&gt; 2, a =&gt; 'l'},
            '^' =&gt; {p =&gt; 3, a =&gt; 'r'},
        };
        sub got_expr {
            my ($self, $expr) = @_;
            $self-&gt;precedence_rpn($expr, $operator_precedence_table);
        }
    }
</pre>
<p class="Pp">This is also much simpler. There's only one method. What's going
    on? Well the secret is that I put the code to turn the tokens into RPN in a
    separate base class called &quot;lib/Precedence.pm&quot; in example.</p>
<p class="Pp">This is an implementation of Edsger Dijkstra's famous
    Shunting-yard Algorithm from 1961! It's only 20 lines of Perl. I won't
    include it inline here, but have a look at it for yourself.
    &lt;https://github.com/ingydotnet/pegex-pm/blob/master/eg/calculator/lib/Precedence.pm&gt;</p>
<p class="Pp">The Shunting-yard algorithm simply takes a list of expression
    tokens and transforms them into an RPN stack. It uses information from a
    precedence/associativity table like the one above.</p>
<p class="Pp">Unlike calculator1.pl where we evaluated as we parsed,
    calculator2.pl creates an RPN which is akin to an AST. In other words, it's
    more like something an actually language compiler would do.</p>
<p class="Pp">But we are writing a calculator and we still need to evaluate this
    puppy. I changed the runner code to look like this:</p>
<p class="Pp"></p>
<pre>    sub calc {
        my $expr = shift;
        my $calculator = pegex($grammar, 'Calculator');
        my $rpn = eval { $calculator-&gt;parse($expr) };
        my $result = RPN::evaluate($rpn);
        print $@ || &quot;$expr = $result\n&quot;;
    }
</pre>
<p class="Pp">So overall, this second solution was a bit more code, but also
    feels more solid on several levels.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Conclusion"><a class="permalink" href="#Conclusion">Conclusion</a></h1>
<p class="Pp">Pegex strives to be the nicest and most reusable way to write new
    parsers. Operator precedence parsers are a necessary part of parsing
    mathematical expressions and computer languages. This tutorial showed you 2
    ways to do it. As the demands for Pegex grow, we may see even more ways to
    do it.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-02-13</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

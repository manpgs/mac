<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>CGI(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">CGI(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">CGI(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">CGI - Handle Common Gateway Interface requests and responses</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
    use strict;
    use warnings;

    use CGI;

        # create a CGI object (query) for use
    my $q = CGI-&gt;new;

    # Process an HTTP request
    my @values  = $q-&gt;multi_param('form_field');
    my $value   = $q-&gt;param('param_name');

    my $fh      = $q-&gt;upload('file_field');

    my $riddle  = $q-&gt;cookie('riddle_name');
    my %answers = $q-&gt;cookie('answers');

    # Prepare various HTTP responses
    print $q-&gt;header();
    print $q-&gt;header('application/json');

    my $cookie1 = $q-&gt;cookie(
        -name  =&gt; 'riddle_name',
        -value =&gt; &quot;The Sphynx's Question&quot;
    );

    my $cookie2 = $q-&gt;cookie(
        -name  =&gt; 'answers',
        -value =&gt; \%answers
    );

    print $q-&gt;header(
        -type    =&gt; 'image/gif',
        -expires =&gt; '+3d',
        -cookie  =&gt; [ $cookie1,$cookie2 ]
    );

    print $q-&gt;redirect('http://somewhere.else/in/movie/land');
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">CGI.pm is a stable, complete and mature solution for processing
    and preparing HTTP requests and responses. Major features including
    processing form submissions, file uploads, reading and writing cookies,
    query string generation and manipulation, and processing and preparing HTTP
    headers.</p>
<p class="Pp">CGI.pm performs very well in a vanilla CGI.pm environment and also
    comes with built-in support for mod_perl and mod_perl2 as well as
  FastCGI.</p>
<p class="Pp">It has the benefit of having developed and refined over 20 years
    with input from dozens of contributors and being deployed on thousands of
    websites. CGI.pm was included in the perl distribution from perl v5.4 to
    v5.20, however is has now been removed from the perl core...</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CGI.pm_HAS_BEEN_REMOVED_FROM_THE_PERL_CORE"><a class="permalink" href="#CGI.pm_HAS_BEEN_REMOVED_FROM_THE_PERL_CORE">CGI.pm
  HAS BEEN REMOVED FROM THE PERL CORE</a></h1>
<p class="Pp">&lt;http://perl5.git.perl.org/perl.git/commitdiff/e9fa5a80&gt;</p>
<p class="Pp">If you upgrade to a new version of perl or if you rely on a system
    or vendor perl and get an updated version of perl through a system update,
    then you will have to install CGI.pm yourself with cpan/cpanm/a vendor
    package/manually. To make this a little easier the CGI::Fast module has been
    split into its own distribution, meaning you do not need access to a
    compiler to install CGI.pm</p>
<p class="Pp">The rationale for this decision is that CGI.pm is no longer
    considered good practice for developing web applications, <b>including</b>
    quick prototyping and small web scripts. There are far better, cleaner,
    quicker, easier, safer, more scalable, more extensible, more modern
    alternatives available at this point in time. These will be documented with
    CGI::Alternatives.</p>
<p class="Pp">For more discussion on the removal of CGI.pm from core please
  see:</p>
<p class="Pp">&lt;http://www.nntp.perl.org/group/perl.perl5.porters/2013/05/msg202130.html&gt;</p>
<p class="Pp">Note that the v4 releases of CGI.pm will retain back compatibility
    <b>as much</b> <b>as possible</b>, however you may need to make some minor
    changes to your code if you are using deprecated methods or some of the more
    obscure features of the module. If you plan to upgrade to v4.00 and beyond
    you should read the Changes file for more information and <b>test your
    code</b> against CGI.pm before deploying it.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="HTML_Generation_functions_should_no_longer_be_used"><a class="permalink" href="#HTML_Generation_functions_should_no_longer_be_used">HTML
  Generation functions should no longer be used</a></h1>
<p class="Pp"><b>All</b> HTML generation functions within CGI.pm are no longer
    being maintained. Any issues, bugs, or patches will be rejected unless they
    relate to fundamentally broken page rendering.</p>
<p class="Pp">The rationale for this is that the HTML generation functions of
    CGI.pm are an obfuscation at best and a maintenance nightmare at worst. You
    should be using a template engine for better separation of concerns. See
    CGI::Alternatives for an example of using CGI.pm with the Template::Toolkit
    module.</p>
<p class="Pp">These functions, and perldoc for them, are considered deprecated,
    they are no longer being maintained and no fixes or features for them will
    be accepted. They will, however, continue to exist in CGI.pm without any
    deprecation warnings (&quot;soft&quot; deprecation) so you can continue to
    use them if you really want to. All documentation for these functions has
    been moved to CGI::HTML::Functions.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Programming_style"><a class="permalink" href="#Programming_style">Programming
  style</a></h1>
<p class="Pp">There are two styles of programming with CGI.pm, an
    object-oriented (OO) style and a function-oriented style. You are
    recommended to use the OO style as CGI.pm will create an internal default
    object when the functions are called procedurally and you will not have to
    worry about method names clashing with perl builtins.</p>
<p class="Pp">In the object-oriented style you create one or more CGI objects
    and then use object methods to create the various elements of the page. Each
    CGI object starts out with the list of named parameters that were passed to
    your CGI script by the server. You can modify the objects, save them to a
    file or database and recreate them. Because each object corresponds to the
    &quot;state&quot; of the CGI script, and because each object's parameter
    list is independent of the others, this allows you to save the state of the
    script and restore it later.</p>
<p class="Pp">For example, using the object oriented style:</p>
<p class="Pp"></p>
<pre>
    #!/usr/bin/env perl

    use strict;
    use warnings;

    use CGI;                             # load CGI routines

    my $q = CGI-&gt;new;                    # create new CGI object
    print $q-&gt;header;                    # create the HTTP header
</pre>
<p class="Pp">In the function-oriented style, there is one default CGI object
    that you rarely deal with directly. Instead you just call functions to
    retrieve CGI parameters, manage cookies, and so on. The following example is
    identical to above, in terms of output, but uses the function-oriented
    interface. The main differences are that we now need to import a set of
    functions into our name space (usually the &quot;standard&quot; functions),
    and we don't need to create the CGI object.</p>
<p class="Pp"></p>
<pre>
    #!/usr/bin/env perl

    use strict;
    use warnings;

    use CGI qw/:standard/;           # load standard CGI routines
    print header();                  # create the HTTP header
</pre>
<p class="Pp">The examples in this document mainly use the object-oriented
    style. See HOW TO IMPORT FUNCTIONS for important information on
    function-oriented programming in CGI.pm</p>
<section class="Ss">
<h2 class="Ss" id="Calling_"><a class="permalink" href="#Calling_">Calling
  CGI.pm routines</a></h2>
<p class="Pp">Most CGI.pm routines accept several arguments, sometimes as many
    as 20 optional ones! To simplify this interface, all routines use a named
    argument calling style that looks like this:</p>
<p class="Pp"></p>
<pre>
    print $q-&gt;header(
        -type    =&gt; 'image/gif',
        -expires =&gt; '+3d',
    );
</pre>
<p class="Pp">Each argument name is preceded by a dash. Neither case nor order
    matters in the argument list: -type, -Type, and -TYPE are all acceptable. In
    fact, only the first argument needs to begin with a dash. If a dash is
    present in the first argument CGI.pm assumes dashes for the subsequent
  ones.</p>
<p class="Pp">Several routines are commonly called with just one argument. In
    the case of these routines you can provide the single argument without an
    argument name. <b>header()</b> happens to be one of these routines. In this
    case, the single argument is the document type.</p>
<p class="Pp"></p>
<pre>
    print $q-&gt;header('text/html');
</pre>
<p class="Pp">Other such routines are documented below.</p>
<p class="Pp">Sometimes named arguments expect a scalar, sometimes a reference
    to an array, and sometimes a reference to a hash. Often, you can pass any
    type of argument and the routine will do whatever is most appropriate. For
    example, the <b>param()</b> routine is used to set a CGI parameter to a
    single or a multi-valued value. The two cases are shown below:</p>
<p class="Pp"></p>
<pre>
    $q-&gt;param(
        -name  =&gt; 'veggie',
        -value =&gt; 'tomato',
    );

    $q-&gt;param(
        -name  =&gt; 'veggie',
        -value =&gt; [ qw/tomato tomahto potato potahto/ ],
    );
</pre>
<p class="Pp">Many routines will do something useful with a named argument that
    it doesn't recognize. For example, you can produce non-standard HTTP header
    fields by providing them as named arguments:</p>
<p class="Pp"></p>
<pre>
    print $q-&gt;header(
        -type            =&gt; 'text/html',
        -cost            =&gt; 'Three smackers',
        -annoyance_level =&gt; 'high',
        -complaints_to   =&gt; 'bit bucket',
    );
</pre>
<p class="Pp">This will produce the following nonstandard HTTP header:</p>
<p class="Pp"></p>
<pre>
    HTTP/1.0 200 OK
    Cost: Three smackers
    Annoyance-level: high
    Complaints-to: bit bucket
    Content-type: text/html
</pre>
<p class="Pp">Notice the way that underscores are translated automatically into
    hyphens.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Creating_a_new_query_object_(object-oriented_style)"><a class="permalink" href="#Creating_a_new_query_object_(object-oriented_style)">Creating
  a new query object (object-oriented style)</a></h2>
<pre>
    my $q = CGI-&gt;new;
</pre>
<p class="Pp">This will parse the input (from POST, GET and DELETE methods) and
    store it into a perl5 object called <span class="Li">$q</span>. Note that
    because the input parsing happens at object instantiation you have to set
    any CGI package variables that control parsing <b>before</b> you call
    CGI-&gt;new.</p>
<p class="Pp">Any filehandles from file uploads will have their position reset
    to the beginning of the file.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Creating_a_new_query_object_from_an_input_file"><a class="permalink" href="#Creating_a_new_query_object_from_an_input_file">Creating
  a new query object from an input file</a></h2>
<pre>
    my $q = CGI-&gt;new( $input_filehandle );
</pre>
<p class="Pp">If you provide a file handle to the <b>new()</b> method, it will
    read parameters from the file (or STDIN, or whatever). The file can be in
    any of the forms describing below under debugging (i.e. a series of newline
    delimited TAG=VALUE pairs will work). Conveniently, this type of file is
    created by the <b>save()</b> method (see below). Multiple records can be
    saved and restored.</p>
<p class="Pp">Perl purists will be pleased to know that this syntax accepts
    references to file handles, or even references to filehandle globs, which is
    the &quot;official&quot; way to pass a filehandle. You can also initialize
    the CGI object with a FileHandle or IO::File object.</p>
<p class="Pp">If you are using the function-oriented interface and want to
    initialize CGI state from a file handle, the way to do this is with
    <b></b><b>restore_parameters()</b><b></b>. This will (re)initialize the
    default CGI object from the indicated file handle.</p>
<p class="Pp"></p>
<pre>
    open( my $in_fh,'&lt;',&quot;test.in&quot;) || die &quot;Couldn't open test.in for read: $!&quot;;
    restore_parameters( $in_fh );
    close( $in_fh );
</pre>
<p class="Pp">You can also initialize the query object from a hash
  reference:</p>
<p class="Pp"></p>
<pre>
    my $q = CGI-&gt;new( {
        'dinosaur' =&gt; 'barney',
        'song'     =&gt; 'I love you',
        'friends'  =&gt; [ qw/ Jessica George Nancy / ]
    } );
</pre>
<p class="Pp">or from a properly formatted, URL-escaped query string:</p>
<p class="Pp"></p>
<pre>
    my $q = CGI-&gt;new('dinosaur=barney&amp;color=purple');
</pre>
<p class="Pp">or from a previously existing CGI object (currently this clones
    the parameter list, but none of the other object-specific fields, such as
    autoescaping):</p>
<p class="Pp"></p>
<pre>
    my $old_query = CGI-&gt;new;
    my $new_query = CGI-&gt;new($old_query);
</pre>
<p class="Pp">To create an empty query, initialize it from an empty string or
    hash:</p>
<p class="Pp"></p>
<pre>
    my $empty_query = CGI-&gt;new(&quot;&quot;);

       -or-

    my $empty_query = CGI-&gt;new({});
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Fetching_a_list_of_keywords_from_the_query"><a class="permalink" href="#Fetching_a_list_of_keywords_from_the_query">Fetching
  a list of keywords from the query</a></h2>
<pre>
    my @keywords = $q-&gt;keywords
</pre>
<p class="Pp">If the script was invoked as the result of an ISINDEX search, the
    parsed keywords can be obtained as an array using the <b>keywords()</b>
    method.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Fetching_the_names_of_all_the_parameters_passed_to_your_script"><a class="permalink" href="#Fetching_the_names_of_all_the_parameters_passed_to_your_script">Fetching
  the names of all the parameters passed to your script</a></h2>
<pre>
    my @names = $q-&gt;multi_param

    my @names = $q-&gt;param
</pre>
<p class="Pp">If the script was invoked with a parameter list (e.g.
    &quot;name1=value1&amp;name2=value2&amp;name3=value3&quot;), the
    <b>param()</b> / <b>multi_param()</b> methods will return the parameter
    names as a list. If the script was invoked as an ISINDEX script and contains
    a string without ampersands (e.g. &quot;value1+value2+value3&quot;), there
    will be a single parameter named &quot;keywords&quot; containing the
    &quot;+&quot;-delimited keywords.</p>
<p class="Pp">The array of parameter names returned will be in the same order as
    they were submitted by the browser. Usually this order is the same as the
    order in which the parameters are defined in the form (however, this isn't
    part of the spec, and so isn't guaranteed).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Fetching_the_value_or_values_of_a_single_named_parameter"><a class="permalink" href="#Fetching_the_value_or_values_of_a_single_named_parameter">Fetching
  the value or values of a single named parameter</a></h2>
<pre>
    my @values = $q-&gt;multi_param('foo');

        -or-

    my $value = $q-&gt;param('foo');

        -or-

    my @values = $q-&gt;param('foo'); # list context, discouraged and will raise
                                   # a warning (use -&gt;multi_param instead)
</pre>
<p class="Pp">Pass the <b>param()</b> / <b>multi_param()</b> method a single
    argument to fetch the value of the named parameter. When calling
    <b>param()</b> If the parameter is multivalued (e.g. from multiple
    selections in a scrolling list), you can ask to receive an array. Otherwise
    the method will return the <b>first</b> value.</p>
<p class="Pp"><b>Warning</b> - calling <b>param()</b> in list context can lead
    to vulnerabilities if you do not sanitise user input as it is possible to
    inject other param keys and values into your code. This is why the
    <b>multi_param()</b> method exists, to make it clear that a list is being
    returned, note that <b>param()</b> can still be called in list context and
    will return a list for back compatibility.</p>
<p class="Pp">The following code is an example of a vulnerability as the call to
    param will be evaluated in list context and thus possibly inject extra keys
    and values into the hash:</p>
<p class="Pp"></p>
<pre>
    my %user_info = (
        id   =&gt; 1,
        name =&gt; $q-&gt;param('name'),
    );
</pre>
<p class="Pp">The fix for the above is to force scalar context on the call to
    -&gt;param by prefixing it with &quot;scalar&quot;</p>
<p class="Pp"></p>
<pre>
    name =&gt; scalar $q-&gt;param('name'),
</pre>
<p class="Pp">If you call <b>param()</b> in list context with an argument a
    warning will be raised by CGI.pm, you can disable this warning by setting
    <span class="Li">$CGI::LIST_CONTEXT_WARN</span> to 0 or by using the
    <b>multi_param()</b> method instead</p>
<p class="Pp">If a value is not given in the query string, as in the queries
    &quot;name1=&amp;name2=&quot;, it will be returned as an empty string.</p>
<p class="Pp">If the parameter does not exist at all, then <b>param()</b> will
    return undef in scalar context, and the empty list in a list context.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Setting_the_value(s)_of_a_named_parameter"><a class="permalink" href="#Setting_the_value(s)_of_a_named_parameter">Setting
  the value(s) of a named parameter</a></h2>
<pre>
    $q-&gt;param('foo','an','array','of','values');
</pre>
<p class="Pp">This sets the value for the named parameter 'foo' to an array of
    values. This is one way to change the value of a field AFTER the script has
    been invoked once before.</p>
<p class="Pp"><b>param()</b> also recognizes a named parameter style of calling
    described in more detail later:</p>
<p class="Pp"></p>
<pre>
    $q-&gt;param(
        -name   =&gt; 'foo',
        -values =&gt; ['an','array','of','values'],
    );

                -or-

    $q-&gt;param(
        -name  =&gt; 'foo',
        -value =&gt; 'the value',
    );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Appending_additional_values_to_a_named_parameter"><a class="permalink" href="#Appending_additional_values_to_a_named_parameter">Appending
  additional values to a named parameter</a></h2>
<pre>
    $q-&gt;append(
        -name   =&gt;'foo',
        -values =&gt;['yet','more','values'],
    );
</pre>
<p class="Pp">This adds a value or list of values to the named parameter. The
    values are appended to the end of the parameter if it already exists.
    Otherwise the parameter is created. Note that this method only recognizes
    the named argument calling syntax.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Importing_all_parameters_into_a_namespace"><a class="permalink" href="#Importing_all_parameters_into_a_namespace">Importing
  all parameters into a namespace</a></h2>
<pre>
    $q-&gt;import_names('R');
</pre>
<p class="Pp">This creates a series of variables in the 'R' namespace. For
    example, <span class="Li">$R::foo</span>, <span class="Li">@R:foo</span>.
    For keyword lists, a variable <span class="Li">@R::keywords</span> will
    appear. If no namespace is given, this method will assume 'Q'.
    <b>WARNING</b>: don't import anything into 'main'; this is a major security
    risk!</p>
<p class="Pp">NOTE 1: Variable names are transformed as necessary into legal
    perl variable names. All non-legal characters are transformed into
    underscores. If you need to keep the original names, you should use the
    <b>param()</b> method instead to access CGI variables by name.</p>
<p class="Pp">In fact, you should probably not use this method at all given the
    above caveats and security risks.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Deleting_a_parameter_completely"><a class="permalink" href="#Deleting_a_parameter_completely">Deleting
  a parameter completely</a></h2>
<pre>
    $q-&gt;delete('foo','bar','baz');
</pre>
<p class="Pp">This completely clears a list of parameters. It sometimes useful
    for resetting parameters that you don't want passed down between script
    invocations.</p>
<p class="Pp">If you are using the function call interface, use
    &quot;<b>Delete()</b>&quot; instead to avoid conflicts with perl's built-in
    delete operator.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Deleting_all_parameters"><a class="permalink" href="#Deleting_all_parameters">Deleting
  all parameters</a></h2>
<pre>
    $q-&gt;delete_all();
</pre>
<p class="Pp">This clears the CGI object completely. It might be useful to
    ensure that all the defaults are taken when you create a fill-out form.</p>
<p class="Pp">Use <b>Delete_all()</b> instead if you are using the function call
    interface.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Handling_non-urlencoded_arguments"><a class="permalink" href="#Handling_non-urlencoded_arguments">Handling
  non-urlencoded arguments</a></h2>
<p class="Pp">If POSTed data is not of type application/x-www-form-urlencoded or
    multipart/form-data, then the POSTed data will not be processed, but instead
    be returned as-is in a parameter named POSTDATA. To retrieve it, use code
    like this:</p>
<p class="Pp"></p>
<pre>
    my $data = $q-&gt;param('POSTDATA');
</pre>
<p class="Pp">Likewise if PUTed and PATCHed data can be retrieved with code like
    this:</p>
<p class="Pp"></p>
<pre>
    my $data = $q-&gt;param('PUTDATA');

    my $data = $q-&gt;param('PATCHDATA');
</pre>
<p class="Pp">(If you don't know what the preceding means, worry not. It only
    affects people trying to use CGI for XML processing and other specialized
    tasks)</p>
<p class="Pp">PUTDATA/POSTDATA/PATCHDATA are also available via upload_hook, and
    as file uploads via &quot;-putdata_upload&quot; option.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Direct_access_to_the_parameter_list"><a class="permalink" href="#Direct_access_to_the_parameter_list">Direct
  access to the parameter list</a></h2>
<pre>
    $q-&gt;param_fetch('address')-&gt;[1] = '1313 Mockingbird Lane';
    unshift @{$q-&gt;param_fetch(-name=&gt;'address')},'George Munster';
</pre>
<p class="Pp">If you need access to the parameter list in a way that isn't
    covered by the methods given in the previous sections, you can obtain a
    direct reference to it by calling the <b></b><b>param_fetch()</b><b></b>
    method with the name of the parameter. This will return an array reference
    to the named parameter, which you then can manipulate in any way you
  like.</p>
<p class="Pp">You can also use a named argument style using the <b>-name</b>
    argument.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Fetching_the_parameter_list_as_a_hash"><a class="permalink" href="#Fetching_the_parameter_list_as_a_hash">Fetching
  the parameter list as a hash</a></h2>
<pre>
    my $params = $q-&gt;Vars;
    print $params-&gt;{'address'};
    my @foo = split(&quot;\0&quot;,$params-&gt;{'foo'});
    my %params = $q-&gt;Vars;

    use CGI ':cgi-lib';
    my $params = Vars();
</pre>
<p class="Pp">Many people want to fetch the entire parameter list as a hash in
    which the keys are the names of the CGI parameters, and the values are the
    parameters' values. The <b>Vars()</b> method does this. Called in a scalar
    context, it returns the parameter list as a tied hash reference. Changing a
    key changes the value of the parameter in the underlying CGI parameter list.
    Called in a list context, it returns the parameter list as an ordinary hash.
    This allows you to read the contents of the parameter list, but not to
    change it.</p>
<p class="Pp">When using this, the thing you must watch out for are multivalued
    CGI parameters. Because a hash cannot distinguish between scalar and list
    context, multivalued parameters will be returned as a packed string,
    separated by the &quot;\0&quot; (null) character. You must split this packed
    string in order to get at the individual values. This is the convention
    introduced long ago by Steve Brenner in his cgi-lib.pl module for perl
    version 4, and may be replaced in future versions with array references.</p>
<p class="Pp">If you wish to use <b>Vars()</b> as a function, import the
    <i>:cgi-lib</i> set of function calls (also see the section on CGI-LIB
    compatibility).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Saving_the_state_of_the_script_to_a_file"><a class="permalink" href="#Saving_the_state_of_the_script_to_a_file">Saving
  the state of the script to a file</a></h2>
<pre>
    $q-&gt;save(\*FILEHANDLE)
</pre>
<p class="Pp">This will write the current state of the form to the provided
    filehandle. You can read it back in by providing a filehandle to the
    <b>new()</b> method. Note that the filehandle can be a file, a pipe, or
    whatever.</p>
<p class="Pp">The format of the saved file is:</p>
<p class="Pp"></p>
<pre>
    NAME1=VALUE1
    NAME1=VALUE1'
    NAME2=VALUE2
    NAME3=VALUE3
    =
</pre>
<p class="Pp">Both name and value are URL escaped. Multi-valued CGI parameters
    are represented as repeated names. A session record is delimited by a single
    = symbol. You can write out multiple records and read them back in with
    several calls to <b>new</b>. You can do this across several sessions by
    opening the file in append mode, allowing you to create primitive guest
    books, or to keep a history of users' queries. Here's a short example of
    creating multiple session records:</p>
<p class="Pp"></p>
<pre>
    use strict;
    use warnings;
    use CGI;

    open (my $out_fh,'&gt;&gt;','test.out') || die &quot;Can't open test.out: $!&quot;;
    my $records = 5;
    for ( 0 .. $records ) {
        my $q = CGI-&gt;new;
        $q-&gt;param( -name =&gt; 'counter',-value =&gt; $_ );
        $q-&gt;save( $out_fh );
    }
    close( $out_fh );

    # reopen for reading
    open (my $in_fh,'&lt;','test.out') || die &quot;Can't open test.out: $!&quot;;
    while (!eof($in_fh)) {
        my $q = CGI-&gt;new($in_fh);
        print $q-&gt;param('counter'),&quot;\n&quot;;
    }
</pre>
<p class="Pp">The file format used for save/restore is identical to that used by
    the Whitehead Genome Center's data exchange format &quot;Boulderio&quot;,
    and can be manipulated and even databased using Boulderio utilities. See
    Boulder for further details.</p>
<p class="Pp">If you wish to use this method from the function-oriented (non-OO)
    interface, the exported name for this method is
    <b></b><b>save_parameters()</b><b></b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Retrieving_cgi_errors"><a class="permalink" href="#Retrieving_cgi_errors">Retrieving
  cgi errors</a></h2>
<p class="Pp">Errors can occur while processing user input, particularly when
    processing uploaded files. When these errors occur, CGI will stop processing
    and return an empty parameter list. You can test for the existence and
    nature of errors using the <i></i><b><i>cgi_error()</i></b><i></i> function.
    The error messages are formatted as HTTP status codes. You can either
    incorporate the error text into a page, or use it as the value of the HTTP
    status:</p>
<p class="Pp"></p>
<pre>
    if ( my $error = $q-&gt;cgi_error ) {
        print $q-&gt;header( -status =&gt; $error );
        print &quot;Error: $error&quot;;
        exit 0;
    }
</pre>
<p class="Pp">When using the function-oriented interface (see the next section),
    errors may only occur the first time you call
    <i></i><b><i>param()</i></b><i></i>. Be ready for this!</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_the_function-oriented_interface"><a class="permalink" href="#Using_the_function-oriented_interface">Using
  the function-oriented interface</a></h2>
<p class="Pp">To use the function-oriented interface, you must specify which
    CGI.pm routines or sets of routines to import into your script's namespace.
    There is a small overhead associated with this importation, but it isn't
    much.</p>
<p class="Pp"></p>
<pre>
    use strict;
    use warnings;

    use CGI qw/ list of methods /;
</pre>
<p class="Pp">The listed methods will be imported into the current package; you
    can call them directly without creating a CGI object first. This example
    shows how to import the <b></b><b>param()</b><b></b> and
    <b></b><b>header()</b><b></b> methods, and then use them directly:</p>
<p class="Pp"></p>
<pre>
    use strict;
    use warnings;

    use CGI qw/ param header /;
    print header('text/plain');
    my $zipcode = param('zipcode');
</pre>
<p class="Pp">More frequently, you'll import common sets of functions by
    referring to the groups by name. All function sets are preceded with a
    &quot;:&quot; character as in &quot;:cgi&quot; (for CGI protocol handling
    methods).</p>
<p class="Pp">Here is a list of the function sets you can import:</p>
<dl class="Bl-tag">
  <dt><b>:cgi</b></dt>
  <dd>Import all CGI-handling methods, such as <b></b><b>param()</b><b></b>,
      <b></b><b>path_info()</b><b></b> and the like.</dd>
  <dt><b>:all</b></dt>
  <dd>Import all the available methods. For the full list, see the CGI.pm code,
      where the variable <span class="Li">%EXPORT_TAGS</span> is defined. (N.B.
      the :cgi-lib imports will <b>not</b> be included in the :all import, you
      will have to import :cgi-lib to get those)</dd>
</dl>
<p class="Pp">Note that in the interests of execution speed CGI.pm does
    <b>not</b> use the standard Exporter syntax for specifying load symbols.
    This may change in the future.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Pragmas"><a class="permalink" href="#Pragmas">Pragmas</a></h2>
<p class="Pp">In addition to the function sets, there are a number of pragmas
    that you can import. Pragmas, which are always preceded by a hyphen, change
    the way that CGI.pm functions in various ways. Pragmas, function sets, and
    individual functions can all be imported in the same <b>use()</b> line. For
    example, the following use statement imports the cgi set of functions and
    enables debugging mode (pragma -debug):</p>
<p class="Pp"></p>
<pre>
    use strict;
    use warninigs;
    use CGI qw/ :cgi -debug /;
</pre>
<p class="Pp">The current list of pragmas is as follows:</p>
<dl class="Bl-tag">
  <dt id="no_undef_params"><a class="permalink" href="#no_undef_params">-no_undef_params</a></dt>
  <dd>This keeps CGI.pm from including undef params in the parameter list.</dd>
  <dt id="utf8"><a class="permalink" href="#utf8">-utf8</a></dt>
  <dd>This makes CGI.pm treat all parameters as text strings rather than binary
      strings (see perlunitut for the distinction), assuming UTF-8 for the
      encoding.
    <p class="Pp">CGI.pm does the decoding from the UTF-8 encoded input data,
        restricting this decoding to input text as distinct from binary upload
        data which are left untouched. Therefore, a ':utf8' layer must
        <b>not</b> be used on STDIN.</p>
    <p class="Pp">If you do not use this option you can manually select which
        fields are expected to return utf-8 strings and convert them using code
        like this:</p>
    <p class="Pp"></p>
    <pre>
    use strict;
    use warnings;

    use CGI;
    use Encode qw/ decode /;

    my $cgi   = CGI-&gt;new;
    my $param = $cgi-&gt;param('foo');
    $param    = decode( 'UTF-8',$param );
    </pre>
  </dd>
  <dt id="putdata_upload"><a class="permalink" href="#putdata_upload">-putdata_upload
    / -postdata_upload / -patchdata_upload</a></dt>
  <dd>Makes <span class="Li">&quot;$cgi-&gt;param('PUTDATA');&quot;</span>,
      <span class="Li">&quot;$cgi-&gt;param('PATCHDATA');&quot;</span>, and
      <span class="Li">&quot;$cgi-&gt;param('POSTDATA');&quot;</span> act like
      file uploads named PUTDATA, PATCHDATA, and POSTDATA. See &quot;Handling
      non-urlencoded arguments&quot; and &quot;Processing a file upload
      field&quot; PUTDATA/POSTDATA/PATCHDATA are also available via
    upload_hook.</dd>
  <dt id="nph"><a class="permalink" href="#nph">-nph</a></dt>
  <dd>This makes CGI.pm produce a header appropriate for an NPH (no parsed
      header) script. You may need to do other things as well to tell the server
      that the script is NPH. See the discussion of NPH scripts below.</dd>
  <dt id="newstyle_urls"><a class="permalink" href="#newstyle_urls">-newstyle_urls</a></dt>
  <dd>Separate the name=value pairs in CGI parameter query strings with
      semicolons rather than ampersands. For example:
    <p class="Pp"></p>
    <pre>
    ?name=fred;age=24;favorite_color=3
    </pre>
    <p class="Pp">Semicolon-delimited query strings are always accepted, and
        will be emitted by <b>self_url()</b> and <b>query_string()</b>.
        newstyle_urls became the default in version 2.64.</p>
  </dd>
  <dt id="oldstyle_urls"><a class="permalink" href="#oldstyle_urls">-oldstyle_urls</a></dt>
  <dd>Separate the name=value pairs in CGI parameter query strings with
      ampersands rather than semicolons. This is no longer the default.</dd>
  <dt id="no_debug"><a class="permalink" href="#no_debug">-no_debug</a></dt>
  <dd>This turns off the command-line processing features. If you want to run a
      CGI.pm script from the command line, and you don't want it to read CGI
      parameters from the command line or STDIN, then use this pragma:
    <p class="Pp"></p>
    <pre>
   use CGI qw/ -no_debug :standard /;
    </pre>
  </dd>
  <dt id="debug"><a class="permalink" href="#debug">-debug</a></dt>
  <dd>This turns on full debugging. In addition to reading CGI arguments from
      the command-line processing, CGI.pm will pause and try to read arguments
      from STDIN, producing the message &quot;(offline mode: enter name=value
      pairs on standard input)&quot; features.
    <p class="Pp">See the section on debugging for more details.</p>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="GENERATING_DYNAMIC_DOCUMENTS"><a class="permalink" href="#GENERATING_DYNAMIC_DOCUMENTS">GENERATING
  DYNAMIC DOCUMENTS</a></h1>
<p class="Pp">Most of CGI.pm's functions deal with creating documents on the
    fly. Generally you will produce the HTTP header first, followed by the
    document itself. CGI.pm provides functions for generating HTTP headers of
    various types.</p>
<p class="Pp">Each of these functions produces a fragment of HTTP which you can
    print out directly so that it is processed by the browser, appended to a
    string, or saved to a file for later use.</p>
<section class="Ss">
<h2 class="Ss" id="Creating_a_standard_http_header"><a class="permalink" href="#Creating_a_standard_http_header">Creating
  a standard http header</a></h2>
<p class="Pp">Normally the first thing you will do in any CGI script is print
    out an HTTP header. This tells the browser what type of document to expect,
    and gives other optional information, such as the language, expiration date,
    and whether to cache the document. The header can also be manipulated for
    special purposes, such as server push and pay per view pages.</p>
<p class="Pp"></p>
<pre>
    use strict;
    use warnings;

    use CGI;

    my $cgi = CGI-&gt;new;

    print $cgi-&gt;header;

        -or-

    print $cgi-&gt;header('image/gif');

        -or-

    print $cgi-&gt;header('text/html','204 No response');

        -or-

    print $cgi-&gt;header(
        -type       =&gt; 'image/gif',
        -nph        =&gt; 1,
        -status     =&gt; '402 Payment required',
        -expires    =&gt; '+3d',
        -cookie     =&gt; $cookie,
        -charset    =&gt; 'utf-8',
        -attachment =&gt; 'foo.gif',
        -Cost       =&gt; '$2.00'
    );
</pre>
<p class="Pp"><b>header()</b> returns the Content-type: header. You can provide
    your own MIME type if you choose, otherwise it defaults to text/html. An
    optional second parameter specifies the status code and a human-readable
    message. For example, you can specify 204, &quot;No response&quot; to create
    a script that tells the browser to do nothing at all. Note that RFC 2616
    expects the human-readable phase to be there as well as the numeric status
    code.</p>
<p class="Pp">The last example shows the named argument style for passing
    arguments to the CGI methods using named parameters. Recognized parameters
    are <b>-type</b>, <b>-status</b>, <b>-expires</b>, and <b>-cookie</b>. Any
    other named parameters will be stripped of their initial hyphens and turned
    into header fields, allowing you to specify any HTTP header you desire.
    Internal underscores will be turned into hyphens:</p>
<p class="Pp"></p>
<pre>
    print $cgi-&gt;header( -Content_length =&gt; 3002 );
</pre>
<p class="Pp">Most browsers will not cache the output from CGI scripts. Every
    time the browser reloads the page, the script is invoked anew. You can
    change this behavior with the <b>-expires</b> parameter. When you specify an
    absolute or relative expiration interval with this parameter, some browsers
    and proxy servers will cache the script's output until the indicated
    expiration date. The following forms are all valid for the -expires
  field:</p>
<p class="Pp"></p>
<pre>
    +30s                                  30 seconds from now
    +10m                                  ten minutes from now
    +1h                                   one hour from now
    -1d                                   yesterday (i.e. &quot;ASAP!&quot;)
    now                                   immediately
    +3M                                   in three months
    +10y                                  in ten years time
    Thursday, 25-Apr-2018 00:40:33 GMT    at the indicated time &amp; date
</pre>
<p class="Pp">The <b>-cookie</b> parameter generates a header that tells the
    browser to provide a &quot;magic cookie&quot; during all subsequent
    transactions with your script. Some cookies have a special format that
    includes interesting attributes such as expiration time. Use the
    <b>cookie()</b> method to create and retrieve session cookies.</p>
<p class="Pp">The <b>-nph</b> parameter, if set to a true value, will issue the
    correct headers to work with a NPH (no-parse-header) script. This is
    important to use with certain servers that expect all their scripts to be
    NPH.</p>
<p class="Pp">The <b>-charset</b> parameter can be used to control the character
    set sent to the browser. If not provided, defaults to ISO-8859-1. As a side
    effect, this sets the <b>charset()</b> method as well. <b>Note</b> that the
    default being ISO-8859-1 may not make sense for all content types, e.g.:</p>
<p class="Pp"></p>
<pre>
    Content-Type: image/gif; charset=ISO-8859-1
</pre>
<p class="Pp">In the above case you need to pass -charset =&gt; '' to prevent
    the default being used.</p>
<p class="Pp">The <b>-attachment</b> parameter can be used to turn the page into
    an attachment. Instead of displaying the page, some browsers will prompt the
    user to save it to disk. The value of the argument is the suggested name for
    the saved file. In order for this to work, you may have to set the
    <b>-type</b> to &quot;application/octet-stream&quot;.</p>
<p class="Pp">The <b>-p3p</b> parameter will add a P3P tag to the outgoing
    header. The parameter can be an arrayref or a space-delimited string of P3P
    tags. For example:</p>
<p class="Pp"></p>
<pre>
    print $cgi-&gt;header( -p3p =&gt; [ qw/ CAO DSP LAW CURa / ] );
    print $cgi-&gt;header( -p3p =&gt; 'CAO DSP LAW CURa' );
</pre>
<p class="Pp">In either case, the outgoing header will be formatted as:</p>
<p class="Pp"></p>
<pre>
    P3P: policyref=&quot;/w3c/p3p.xml&quot; cp=&quot;CAO DSP LAW CURa&quot;
</pre>
<p class="Pp">CGI.pm will accept valid multi-line headers when each line is
    separated with a CRLF value (&quot;\r\n&quot; on most platforms) followed by
    at least one space. For example:</p>
<p class="Pp"></p>
<pre>
    print $cgi-&gt;header( -ingredients =&gt; &quot;ham\r\n\seggs\r\n\sbacon&quot; );
</pre>
<p class="Pp">Invalid multi-line header input will trigger in an exception. When
    multi-line headers are received, CGI.pm will always output them back as a
    single line, according to the folding rules of RFC 2616: the newlines will
    be removed, while the white space remains.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Generating_a_redirection_header"><a class="permalink" href="#Generating_a_redirection_header">Generating
  a redirection header</a></h2>
<pre>
    print $q-&gt;redirect( 'http://somewhere.else/in/movie/land' );
</pre>
<p class="Pp">Sometimes you don't want to produce a document yourself, but
    simply redirect the browser elsewhere, perhaps choosing a URL based on the
    time of day or the identity of the user.</p>
<p class="Pp">The <b>redirect()</b> method redirects the browser to a different
    URL. If you use redirection like this, you should <b>not</b> print out a
    header as well.</p>
<p class="Pp">You are advised to use full URLs (absolute with respect to current
    URL or even including the http: or ftp: part) in redirection requests as
    relative URLs are resolved by the user agent of the client so may not do
    what you want or expect them to do.</p>
<p class="Pp">You can also use named arguments:</p>
<p class="Pp"></p>
<pre>
    print $q-&gt;redirect(
        -uri    =&gt; 'http://somewhere.else/in/movie/land',
        -nph    =&gt; 1,
        -status =&gt; '301 Moved Permanently'
    );
</pre>
<p class="Pp">All names arguments recognized by <b>header()</b> are also
    recognized by <b>redirect()</b>. However, most HTTP headers, including those
    generated by -cookie and -target, are ignored by the browser.</p>
<p class="Pp">The <b>-nph</b> parameter, if set to a true value, will issue the
    correct headers to work with a NPH (no-parse-header) script. This is
    important to use with certain servers, such as Microsoft IIS, which expect
    all their scripts to be NPH.</p>
<p class="Pp">The <b>-status</b> parameter will set the status of the redirect.
    HTTP defines several different possible redirection status codes, and the
    default if not specified is 302, which means &quot;moved temporarily.&quot;
    You may change the status to another status code if you wish.</p>
<p class="Pp">Note that the human-readable phrase is also expected to be present
    to conform with RFC 2616, section 6.1.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Creating_a_self-referencing_url_that_preserves_state_information"><a class="permalink" href="#Creating_a_self-referencing_url_that_preserves_state_information">Creating
  a self-referencing url that preserves state information</a></h2>
<pre>
    my $myself = $q-&gt;self_url;
    print qq(&lt;a href=&quot;$myself&quot;&gt;I'm talking to myself.&lt;/a&gt;);
</pre>
<p class="Pp"><b>self_url()</b> will return a URL, that, when selected, will
    re-invoke this script with all its state information intact. This is most
    useful when you want to jump around within the document using internal
    anchors but you don't want to disrupt the current contents of the form(s).
    Something like this will do the trick:</p>
<p class="Pp"></p>
<pre>
     my $myself = $q-&gt;self_url;
     print &quot;&lt;a href=\&quot;$myself#table1\&quot;&gt;See table 1&lt;/a&gt;&quot;;
     print &quot;&lt;a href=\&quot;$myself#table2\&quot;&gt;See table 2&lt;/a&gt;&quot;;
     print &quot;&lt;a href=\&quot;$myself#yourself\&quot;&gt;See for yourself&lt;/a&gt;&quot;;
</pre>
<p class="Pp">If you want more control over what's returned, using the
    <b></b><b>url()</b><b></b> method instead.</p>
<p class="Pp">You can also retrieve a query string representation of the current
    object state with <b>query_string()</b>:</p>
<p class="Pp"></p>
<pre>
    my $the_string = $q-&gt;query_string();
</pre>
<p class="Pp">The behavior of calling query_string is currently undefined when
    the HTTP method is something other than GET.</p>
<p class="Pp">If you want to retrieved the query string as set in the webserver,
    namely the environment variable, you can call <b>env_query_string()</b></p>
</section>
<section class="Ss">
<h2 class="Ss" id="Obtaining_the_script's_url"><a class="permalink" href="#Obtaining_the_script's_url">Obtaining
  the script's url</a></h2>
<pre>
    my $full_url      = url();
    my $full_url      = url( -full =&gt;1 );  # alternative syntax
    my $relative_url  = url( -relative =&gt; 1 );
    my $absolute_url  = url( -absolute =&gt;1 );
    my $url_with_path = url( -path_info =&gt; 1 );
    my $url_path_qry  = url( -path_info =&gt; 1, -query =&gt;1 );
    my $netloc        = url( -base =&gt; 1 );
</pre>
<p class="Pp"><b></b><b>url()</b><b></b> returns the script's URL in a variety
    of formats. Called without any arguments, it returns the full form of the
    URL, including host name and port number</p>
<p class="Pp"></p>
<pre>
    http://your.host.com/path/to/script.cgi
</pre>
<p class="Pp">You can modify this format with the following named arguments:</p>
<dl class="Bl-tag">
  <dt id="absolute"><a class="permalink" href="#absolute"><b>-absolute</b></a></dt>
  <dd>If true, produce an absolute URL, e.g.
    <p class="Pp"></p>
    <pre>
    /path/to/script.cgi
    </pre>
  </dd>
  <dt id="relative"><a class="permalink" href="#relative"><b>-relative</b></a></dt>
  <dd>Produce a relative URL. This is useful if you want to re-invoke your
      script with different parameters. For example:
    <p class="Pp"></p>
    <pre>
    script.cgi
    </pre>
  </dd>
  <dt id="full"><a class="permalink" href="#full"><b>-full</b></a></dt>
  <dd>Produce the full URL, exactly as if called without any arguments. This
      overrides the -relative and -absolute arguments.</dd>
  <dt id="path"><a class="permalink" href="#path"><b>-path</b>
    (<b>-path_info</b>)</a></dt>
  <dd>Append the additional path information to the URL. This can be combined
      with <b>-full</b>, <b>-absolute</b> or <b>-relative</b>. <b>-path_info</b>
      is provided as a synonym.</dd>
  <dt id="query"><a class="permalink" href="#query"><b>-query</b>
    (<b>-query_string</b>)</a></dt>
  <dd>Append the query string to the URL. This can be combined with
      <b>-full</b>, <b>-absolute</b> or <b>-relative</b>. <b>-query_string</b>
      is provided as a synonym.</dd>
  <dt id="base"><a class="permalink" href="#base"><b>-base</b></a></dt>
  <dd>Generate just the protocol and net location, as in
    http://www.foo.com:8000</dd>
  <dt id="rewrite"><a class="permalink" href="#rewrite"><b>-rewrite</b></a></dt>
  <dd>If Apache's mod_rewrite is turned on, then the script name and path info
      probably won't match the request that the user sent. Set -rewrite =&gt; 1
      (default) to return URLs that match what the user sent (the original
      request URI). Set -rewrite =&gt; 0 to return URLs that match the URL after
      the mod_rewrite rules have run.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Mixing_post_and_url_parameters"><a class="permalink" href="#Mixing_post_and_url_parameters">Mixing
  post and url parameters</a></h2>
<pre>
    my $color = url_param('color');
</pre>
<p class="Pp">It is possible for a script to receive CGI parameters in the URL
    as well as in the fill-out form by creating a form that POSTs to a URL
    containing a query string (a &quot;?&quot; mark followed by arguments). The
    <b></b><b>param()</b><b></b> method will always return the contents of the
    POSTed fill-out form, ignoring the URL's query string. To retrieve URL
    parameters, call the <b></b><b>url_param()</b><b></b> method. Use it in the
    same way as <b></b><b>param()</b><b></b>. The main difference is that it
    allows you to read the parameters, but not set them.</p>
<p class="Pp">Under no circumstances will the contents of the URL query string
    interfere with similarly-named CGI parameters in POSTed forms. If you try to
    mix a URL query string with a form submitted with the GET method, the
    results will not be what you expect.</p>
<p class="Pp">If running from the command line,
    <span class="Li">&quot;url_param&quot;</span> will not pick up any
    parameters given on the command line.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Processing_a_file_upload_field"><a class="permalink" href="#Processing_a_file_upload_field">Processing
  a file upload field</a></h2>
<p class="Pp"><i>Basics</i></p>
<p class="Pp">When the form is processed, you can retrieve an IO::File
    compatible handle for a file upload field like this:</p>
<p class="Pp"></p>
<pre>
    use autodie;

    # undef may be returned if it's not a valid file handle
    if ( my $io_handle = $q-&gt;upload('field_name') ) {
        open ( my $out_file,'&gt;&gt;','/usr/local/web/users/feedback' );
        while ( my $bytesread = $io_handle-&gt;read($buffer,1024) ) {
            print $out_file $buffer;
        }
    }
</pre>
<p class="Pp">In a list context, <b>upload()</b> will return an array of
    filehandles. This makes it possible to process forms that use the same name
    for multiple upload fields.</p>
<p class="Pp">If you want the entered file name for the file, you can just call
    <b>param()</b>:</p>
<p class="Pp"></p>
<pre>
    my $filename = $q-&gt;param('field_name');
</pre>
<p class="Pp">Different browsers will return slightly different things for the
    name. Some browsers return the filename only. Others return the full path to
    the file, using the path conventions of the user's machine. Regardless, the
    name returned is always the name of the file on the <i>user's</i> machine,
    and is unrelated to the name of the temporary file that CGI.pm creates
    during upload spooling (see below).</p>
<p class="Pp">When a file is uploaded the browser usually sends along some
    information along with it in the format of headers. The information usually
    includes the MIME content type. To retrieve this information, call
    <b>uploadInfo()</b>. It returns a reference to a hash containing all the
    document headers.</p>
<p class="Pp"></p>
<pre>
    my $filehandle = $q-&gt;upload( 'uploaded_file' );
    my $type       = $q-&gt;uploadInfo( $filehandle )-&gt;{'Content-Type'};
    if ( $type ne 'text/html' ) {
        die &quot;HTML FILES ONLY!&quot;;
    }
</pre>
<p class="Pp">Note that you must use -&gt;upload or -&gt;param to get the
    file-handle to pass into uploadInfo as internally this is represented as a
    File::Temp object (which is what will be returned by -&gt;upload or
    -&gt;param). When using -&gt;Vars you will get the literal filename rather
    than the File::Temp object, which will not return anything when passed to
    uploadInfo. So don't use -&gt;Vars.</p>
<p class="Pp">If you are using a machine that recognizes &quot;text&quot; and
    &quot;binary&quot; data modes, be sure to understand when and how to use
    them (see the Camel book). Otherwise you may find that binary files are
    corrupted during file uploads.</p>
<p class="Pp"><i>Accessing the temp files directly</i></p>
<p class="Pp">When processing an uploaded file, CGI.pm creates a temporary file
    on your hard disk and passes you a file handle to that file. After you are
    finished with the file handle, CGI.pm unlinks (deletes) the temporary file.
    If you need to you can access the temporary file directly. You can access
    the temp file for a file upload by passing the file name to the
    <b>tmpFileName()</b> method:</p>
<p class="Pp"></p>
<pre>
    my $filehandle  = $q-&gt;upload( 'uploaded_file' );
    my $tmpfilename = $q-&gt;tmpFileName( $filehandle );
</pre>
<p class="Pp">As with -&gt;uploadInfo, using the reference returned by
    -&gt;upload or -&gt;param is preferred, although unlike -&gt;uploadInfo,
    plain filenames also work if possible for backwards compatibility.</p>
<p class="Pp">The temporary file will be deleted automatically when your program
    exits unless you manually rename it or set
    <span class="Li">$CGI::UNLINK_TMP_FILES</span> to 0. On some operating
    systems (such as Windows NT), you will need to close the temporary file's
    filehandle before your program exits. Otherwise the attempt to delete the
    temporary file will fail.</p>
<p class="Pp"><i>Changes in temporary file handling (v4.05+)</i></p>
<p class="Pp">CGI.pm had its temporary file handling significantly refactored,
    this logic is now all deferred to File::Temp (which is wrapped in a
    compatibility object, CGI::File::Temp - <b>DO NOT USE THIS PACKAGE
    DIRECTLY</b>). As a consequence the PRIVATE_TEMPFILES variable has been
    removed along with deprecation of the private_tempfiles routine and
    <b>complete</b> removal of the CGITempFile package. The
    <span class="Li">$CGITempFile::TMPDIRECTORY</span> is no longer used to set
    the temp directory, refer to the perldoc for File::Temp if you want to
    override the default settings in that package (the TMPDIR env variable is
    still available on some platforms). For Windows platforms the temporary
    directory order remains as before: TEMP &gt; TMP &gt; WINDIR ( &gt; TMPDIR )
    so if you have any of these in use in existing scripts they should still
    work.</p>
<p class="Pp">The Fh package still exists but does nothing, the CGI::File::Temp
    class is a subclass of both File::Temp and the empty Fh package, so if you
    have any code that checks that the filehandle isa Fh this should still
  work.</p>
<p class="Pp">When you get the internal file handle you will receive a
    File::Temp object, this should be transparent as File::Temp isa IO::Handle
    and isa IO::Seekable meaning it behaves as previously. If you are doing
    anything out of the ordinary with regards to temp files you should test your
    code before deploying this update and refer to the File::Temp documentation
    for more information.</p>
<p class="Pp"><i>Handling interrupted file uploads</i></p>
<p class="Pp">There are occasionally problems involving parsing the uploaded
    file. This usually happens when the user presses &quot;Stop&quot; before the
    upload is finished. In this case, CGI.pm will return undef for the name of
    the uploaded file and set <i></i><b><i>cgi_error()</i></b><i></i> to the
    string &quot;400 Bad request (malformed multipart POST)&quot;. This error
    message is designed so that you can incorporate it into a status code to be
    sent to the browser. Example:</p>
<p class="Pp"></p>
<pre>
    my $file = $q-&gt;upload( 'uploaded_file' );
    if ( !$file &amp;&amp; $q-&gt;cgi_error ) {
        print $q-&gt;header( -status =&gt; $q-&gt;cgi_error );
        exit 0;
    }
</pre>
<p class="Pp"><i>Progress bars for file uploads and avoiding temp files</i></p>
<p class="Pp">CGI.pm gives you low-level access to file upload management
    through a file upload hook. You can use this feature to completely turn off
    the temp file storage of file uploads, or potentially write your own file
    upload progress meter.</p>
<p class="Pp">This is much like the UPLOAD_HOOK facility available in
    Apache::Request, with the exception that the first argument to the callback
    is an Apache::Upload object, here it's the remote filename.</p>
<p class="Pp"></p>
<pre>
    my $q = CGI-&gt;new( \&amp;hook [,$data [,$use_tempfile]] );

    sub hook {
        my ( $filename, $buffer, $bytes_read, $data ) = @_;
        print &quot;Read $bytes_read bytes of $filename\n&quot;;
    }
</pre>
<p class="Pp">The <span class="Li">$data</span> field is optional; it lets you
    pass configuration information (e.g. a database handle) to your hook
    callback.</p>
<p class="Pp">The <span class="Li">$use_tempfile</span> field is a flag that
    lets you turn on and off CGI.pm's use of a temporary disk-based file during
    file upload. If you set this to a FALSE value (default true) then
    <span class="Li">$q</span>-&gt;param('uploaded_file') will no longer work,
    and the only way to get at the uploaded data is via the hook you
  provide.</p>
<p class="Pp">If using the function-oriented interface, call the
    <b>CGI::upload_hook()</b> method before calling <b>param()</b> or any other
    CGI functions:</p>
<p class="Pp"></p>
<pre>
    CGI::upload_hook( \&amp;hook [,$data [,$use_tempfile]] );
</pre>
<p class="Pp">This method is not exported by default. You will have to import it
    explicitly if you wish to use it without the CGI:: prefix.</p>
<p class="Pp"><i>Troubleshooting file uploads on Windows</i></p>
<p class="Pp">If you are using CGI.pm on a Windows platform and find that binary
    files get slightly larger when uploaded but that text files remain the same,
    then you have forgotten to activate binary mode on the output filehandle. Be
    sure to call <b>binmode()</b> on any handle that you create to write the
    uploaded file to disk.</p>
<p class="Pp"><i>Older ways to process file uploads</i></p>
<p class="Pp">This section is here for completeness. if you are building a new
    application with CGI.pm, you can skip it.</p>
<p class="Pp">The original way to process file uploads with CGI.pm was to use
    <b>param()</b>. The value it returns has a dual nature as both a file name
    and a lightweight filehandle. This dual nature is problematic if you
    following the recommended practice of having <span class="Li">&quot;use
    strict&quot;</span> in your code. perl will complain when you try to use a
    string as a filehandle. More seriously, it is possible for the remote user
    to type garbage into the upload field, in which case what you get from
    <b>param()</b> is not a filehandle at all, but a string.</p>
<p class="Pp">To solve this problem the <b>upload()</b> method was added, which
    always returns a lightweight filehandle. This generally works well, but will
    have trouble interoperating with some other modules because the file handle
    is not derived from IO::File. So that brings us to current recommendation
    given above, which is to call the <b>handle()</b> method on the file handle
    returned by <b>upload()</b>. That upgrades the handle to an IO::File. It's a
    big win for compatibility for a small penalty of loading IO::File the first
    time you call it.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="HTTP_COOKIES"><a class="permalink" href="#HTTP_COOKIES">HTTP
  COOKIES</a></h1>
<p class="Pp">CGI.pm has several methods that support cookies.</p>
<p class="Pp">A cookie is a name=value pair much like the named parameters in a
    CGI query string. CGI scripts create one or more cookies and send them to
    the browser in the HTTP header. The browser maintains a list of cookies that
    belong to a particular Web server, and returns them to the CGI script during
    subsequent interactions.</p>
<p class="Pp">In addition to the required name=value pair, each cookie has
    several optional attributes:</p>
<dl class="Bl-tag">
  <dt>1. an expiration time</dt>
  <dd>This is a time/date string (in a special GMT format) that indicates when a
      cookie expires. The cookie will be saved and returned to your script until
      this expiration date is reached if the user exits the browser and restarts
      it. If an expiration date isn't specified, the cookie will remain active
      until the user quits the browser.</dd>
  <dt>2. a domain</dt>
  <dd>This is a partial or complete domain name for which the cookie is valid.
      The browser will return the cookie to any host that matches the partial
      domain name. For example, if you specify a domain name of
      &quot;.capricorn.com&quot;, then the browser will return the cookie to Web
      servers running on any of the machines &quot;www.capricorn.com&quot;,
      &quot;www2.capricorn.com&quot;, &quot;feckless.capricorn.com&quot;, etc.
      Domain names must contain at least two periods to prevent attempts to
      match on top level domains like &quot;.edu&quot;. If no domain is
      specified, then the browser will only return the cookie to servers on the
      host the cookie originated from.</dd>
  <dt>3. a path</dt>
  <dd>If you provide a cookie path attribute, the browser will check it against
      your script's URL before returning the cookie. For example, if you specify
      the path &quot;/cgi-bin&quot;, then the cookie will be returned to each of
      the scripts &quot;/cgi-bin/tally.pl&quot;, &quot;/cgi-bin/order.pl&quot;,
      and &quot;/cgi-bin/customer_service/complain.pl&quot;, but not to the
      script &quot;/cgi-private/site_admin.pl&quot;. By default, path is set to
      &quot;/&quot;, which causes the cookie to be sent to any CGI script on
      your site.</dd>
  <dt>4. a &quot;secure&quot; flag</dt>
  <dd>If the &quot;secure&quot; attribute is set, the cookie will only be sent
      to your script if the CGI request is occurring on a secure channel, such
      as SSL.</dd>
</dl>
<p class="Pp">The interface to HTTP cookies is the <b></b><b>cookie()</b><b></b>
    method:</p>
<p class="Pp"></p>
<pre>
    my $cookie = $q-&gt;cookie(
        -name    =&gt; 'sessionID',
        -value   =&gt; 'xyzzy',
        -expires =&gt; '+1h',
        -path    =&gt; '/cgi-bin/database',
        -domain  =&gt; '.capricorn.org',
        -secure  =&gt; 1
    );

    print $q-&gt;header( -cookie =&gt; $cookie );
</pre>
<p class="Pp"><b></b><b>cookie()</b><b></b> creates a new cookie. Its parameters
    include:</p>
<dl class="Bl-tag">
  <dt id="name"><a class="permalink" href="#name"><b>-name</b></a></dt>
  <dd>The name of the cookie (required). This can be any string at all. Although
      browsers limit their cookie names to non-whitespace alphanumeric
      characters, CGI.pm removes this restriction by escaping and unescaping
      cookies behind the scenes.</dd>
  <dt id="value"><a class="permalink" href="#value"><b>-value</b></a></dt>
  <dd>The value of the cookie. This can be any scalar value, array reference, or
      even hash reference. For example, you can store an entire hash into a
      cookie this way:
    <p class="Pp"></p>
    <pre>
    my $cookie = $q-&gt;cookie(
        -name  =&gt; 'family information',
        -value =&gt; \%childrens_ages
    );
    </pre>
  </dd>
  <dt id="path~2"><a class="permalink" href="#path~2"><b>-path</b></a></dt>
  <dd>The optional partial path for which this cookie will be valid, as
      described above.</dd>
  <dt id="domain"><a class="permalink" href="#domain"><b>-domain</b></a></dt>
  <dd>The optional partial domain for which this cookie will be valid, as
      described above.</dd>
  <dt id="expires"><a class="permalink" href="#expires"><b>-expires</b></a></dt>
  <dd>The optional expiration date for this cookie. The format is as described
      in the section on the <b></b><b>header()</b><b></b> method:
    <p class="Pp"></p>
    <pre>
    &quot;+1h&quot;  one hour from now
    </pre>
  </dd>
  <dt id="secure"><a class="permalink" href="#secure"><b>-secure</b></a></dt>
  <dd>If set to true, this cookie will only be used within a secure SSL
    session.</dd>
</dl>
<p class="Pp">The cookie created by <b>cookie()</b> must be incorporated into
    the HTTP header within the string returned by the <b>header()</b>
  method:</p>
<p class="Pp"></p>
<pre>
    use strict;
    use warnings;

    use CGI;

    my $q      = CGI-&gt;new;
    my $cookie = ...
    print $q-&gt;header( -cookie =&gt; $cookie );
</pre>
<p class="Pp">To create multiple cookies, give <b>header()</b> an array
    reference:</p>
<p class="Pp"></p>
<pre>
    my $cookie1 = $q-&gt;cookie(
        -name  =&gt; 'riddle_name',
        -value =&gt; &quot;The Sphynx's Question&quot;
    );

    my $cookie2 = $q-&gt;cookie(
        -name  =&gt; 'answers',
        -value =&gt; \%answers
    );

    print $q-&gt;header( -cookie =&gt; [ $cookie1,$cookie2 ] );
</pre>
<p class="Pp">To retrieve a cookie, request it by name by calling
    <b>cookie()</b> method without the <b>-value</b> parameter. This example
    uses the object-oriented form:</p>
<p class="Pp"></p>
<pre>
    my $riddle  = $q-&gt;cookie('riddle_name');
    my %answers = $q-&gt;cookie('answers');
</pre>
<p class="Pp">Cookies created with a single scalar value, such as the
    &quot;riddle_name&quot; cookie, will be returned in that form. Cookies with
    array and hash values can also be retrieved.</p>
<p class="Pp">The cookie and CGI namespaces are separate. If you have a
    parameter named 'answers' and a cookie named 'answers', the values retrieved
    by <b>param()</b> and <b>cookie()</b> are independent of each other.
    However, it's simple to turn a CGI parameter into a cookie, and
  vice-versa:</p>
<p class="Pp"></p>
<pre>
    # turn a CGI parameter into a cookie
    my $c = cookie( -name =&gt; 'answers',-value =&gt; [$q-&gt;param('answers')] );
    # vice-versa
    $q-&gt;param( -name =&gt; 'answers',-value =&gt; [ $q-&gt;cookie('answers')] );
</pre>
<p class="Pp">If you call <b>cookie()</b> without any parameters, it will return
    a list of the names of all cookies passed to your script:</p>
<p class="Pp"></p>
<pre>
    my @cookies = $q-&gt;cookie();
</pre>
<p class="Pp">See the <b>cookie.cgi</b> example script for some ideas on how to
    use cookies effectively.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DEBUGGING"><a class="permalink" href="#DEBUGGING">DEBUGGING</a></h1>
<p class="Pp">If you are running the script from the command line or in the perl
    debugger, you can pass the script a list of keywords or parameter=value
    pairs on the command line or from standard input (you don't have to worry
    about tricking your script into reading from environment variables). You can
    pass keywords like this:</p>
<p class="Pp"></p>
<pre>
    your_script.pl keyword1 keyword2 keyword3
</pre>
<p class="Pp">or this:</p>
<p class="Pp"></p>
<pre>
   your_script.pl keyword1+keyword2+keyword3
</pre>
<p class="Pp">or this:</p>
<p class="Pp"></p>
<pre>
    your_script.pl name1=value1 name2=value2
</pre>
<p class="Pp">or this:</p>
<p class="Pp"></p>
<pre>
    your_script.pl name1=value1&amp;name2=value2
</pre>
<p class="Pp">To turn off this feature, use the -no_debug pragma.</p>
<p class="Pp">To test the POST method, you may enable full debugging with the
    -debug pragma. This will allow you to feed newline-delimited name=value
    pairs to the script on standard input.</p>
<p class="Pp">When debugging, you can use quotes and backslashes to escape
    characters in the familiar shell manner, letting you place spaces and other
    funny characters in your parameter=value pairs:</p>
<p class="Pp"></p>
<pre>
    your_script.pl &quot;name1='I am a long value'&quot; &quot;name2=two\ words&quot;
</pre>
<p class="Pp">Finally, you can set the path info for the script by prefixing the
    first name/value parameter with the path followed by a question mark
  (?):</p>
<p class="Pp"></p>
<pre>
    your_script.pl /your/path/here?name1=value1&amp;name2=value2
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="FETCHING_ENVIRONMENT_VARIABLES"><a class="permalink" href="#FETCHING_ENVIRONMENT_VARIABLES">FETCHING
  ENVIRONMENT VARIABLES</a></h1>
<p class="Pp">Some of the more useful environment variables can be fetched
    through this interface. The methods are as follows:</p>
<dl class="Bl-tag">
  <dt id="Accept()"><a class="permalink" href="#Accept()"><b></b><b>Accept()</b><b></b></a></dt>
  <dd>Return a list of MIME types that the remote browser accepts. If you give
      this method a single argument corresponding to a MIME type, as in
      Accept('text/html'), it will return a floating point value corresponding
      to the browser's preference for this type from 0.0 (don't want) to 1.0.
      Glob types (e.g. text/*) in the browser's accept list are handled
      correctly.
    <p class="Pp">Note that the capitalization changed between version 2.43 and
        2.44 in order to avoid conflict with perl's <b>accept()</b>
      function.</p>
  </dd>
  <dt id="raw_cookie()"><a class="permalink" href="#raw_cookie()"><b></b><b>raw_cookie()</b><b></b></a></dt>
  <dd>Returns the HTTP_COOKIE variable. Cookies have a special format, and this
      method call just returns the raw form (?cookie dough). See <b>cookie()</b>
      for ways of setting and retrieving cooked cookies.
    <p class="Pp">Called with no parameters, <b>raw_cookie()</b> returns the
        packed cookie structure. You can separate it into individual cookies by
        splitting on the character sequence &quot;; &quot;. Called with the name
        of a cookie, retrieves the <b>unescaped</b> form of the cookie. You can
        use the regular <b>cookie()</b> method to get the names, or use the
        <b>raw_fetch()</b> method from the CGI::Cookie module.</p>
  </dd>
  <dt id="env_query_string()"><a class="permalink" href="#env_query_string()"><b></b><b>env_query_string()</b><b></b></a></dt>
  <dd>Returns the QUERY_STRING variable, note that this is the original value as
      set in the environment by the webserver and (possibly) not the same value
      as returned by <b>query_string()</b>, which represents the object
    state</dd>
  <dt id="user_agent()"><a class="permalink" href="#user_agent()"><b></b><b>user_agent()</b><b></b></a></dt>
  <dd>Returns the HTTP_USER_AGENT variable. If you give this method a single
      argument, it will attempt to pattern match on it, allowing you to do
      something like user_agent(Mozilla);</dd>
  <dt id="path_info()"><a class="permalink" href="#path_info()"><b></b><b>path_info()</b><b></b></a></dt>
  <dd>Returns additional path information from the script URL. E.G. fetching
      /cgi-bin/your_script/additional/stuff will result in <b>path_info()</b>
      returning &quot;/additional/stuff&quot;.
    <p class="Pp">NOTE: The Microsoft Internet Information Server is broken with
        respect to additional path information. If you use the perl DLL library,
        the IIS server will attempt to execute the additional path information
        as a perl script. If you use the ordinary file associations mapping, the
        path information will be present in the environment, but incorrect. The
        best thing to do is to avoid using additional path information in CGI
        scripts destined for use with IIS. A best attempt has been made to make
        CGI.pm do the right thing.</p>
  </dd>
  <dt id="path_translated()"><a class="permalink" href="#path_translated()"><b></b><b>path_translated()</b><b></b></a></dt>
  <dd>As per <b>path_info()</b> but returns the additional path information
      translated into a physical path, e.g.
      &quot;/usr/local/etc/httpd/htdocs/additional/stuff&quot;.
    <p class="Pp">The Microsoft IIS is broken with respect to the translated
        path as well.</p>
  </dd>
  <dt id="remote_host()"><a class="permalink" href="#remote_host()"><b></b><b>remote_host()</b><b></b></a></dt>
  <dd>Returns either the remote host name or IP address if the former is
      unavailable.</dd>
  <dt id="remote_ident()"><a class="permalink" href="#remote_ident()"><b></b><b>remote_ident()</b><b></b></a></dt>
  <dd>Returns the name of the remote user (as returned by identd) or undef if
      not set</dd>
  <dt id="remote_addr()"><a class="permalink" href="#remote_addr()"><b></b><b>remote_addr()</b><b></b></a></dt>
  <dd>Returns the remote host IP address, or 127.0.0.1 if the address is
      unavailable.</dd>
  <dt id="request_uri()"><a class="permalink" href="#request_uri()"><b></b><b>request_uri()</b><b></b></a></dt>
  <dd>Returns the interpreted pathname of the requested document or CGI
      (relative to the document root). Or undef if not set.</dd>
  <dt id="script_name()"><a class="permalink" href="#script_name()"><b></b><b>script_name()</b><b></b></a></dt>
  <dd>Return the script name as a partial URL, for self-referring scripts.</dd>
  <dt id="referer()"><a class="permalink" href="#referer()"><b></b><b>referer()</b><b></b></a></dt>
  <dd>Return the URL of the page the browser was viewing prior to fetching your
      script.</dd>
  <dt id="auth_type()"><a class="permalink" href="#auth_type()"><b></b><b>auth_type()</b><b></b></a></dt>
  <dd>Return the authorization/verification method in use for this script, if
      any.</dd>
  <dt id="server_name()"><a class="permalink" href="#server_name()"><b></b><b>server_name()</b><b></b></a></dt>
  <dd>Returns the name of the server, usually the machine's host name.</dd>
  <dt id="virtual_host()"><a class="permalink" href="#virtual_host()"><b></b><b>virtual_host()</b><b></b></a></dt>
  <dd>When using virtual hosts, returns the name of the host that the browser
      attempted to contact</dd>
  <dt id="server_port()"><a class="permalink" href="#server_port()"><b></b><b>server_port()</b><b></b></a></dt>
  <dd>Return the port that the server is listening on.</dd>
  <dt id="server_protocol()"><a class="permalink" href="#server_protocol()"><b></b><b>server_protocol()</b><b></b></a></dt>
  <dd>Returns the protocol and revision of the incoming request, or defaults to
      HTTP/1.0 if this is not set</dd>
  <dt id="virtual_port()"><a class="permalink" href="#virtual_port()"><b></b><b>virtual_port()</b><b></b></a></dt>
  <dd>Like <b>server_port()</b> except that it takes virtual hosts into account.
      Use this when running with virtual hosts.</dd>
  <dt id="server_software()"><a class="permalink" href="#server_software()"><b></b><b>server_software()</b><b></b></a></dt>
  <dd>Returns the server software and version number.</dd>
  <dt id="remote_user()"><a class="permalink" href="#remote_user()"><b></b><b>remote_user()</b><b></b></a></dt>
  <dd>Return the authorization/verification name used for user verification, if
      this script is protected.</dd>
  <dt id="user_name()"><a class="permalink" href="#user_name()"><b></b><b>user_name()</b><b></b></a></dt>
  <dd>Attempt to obtain the remote user's name, using a variety of different
      techniques. May not work in all browsers.</dd>
  <dt id="request_method()"><a class="permalink" href="#request_method()"><b></b><b>request_method()</b><b></b></a></dt>
  <dd>Returns the method used to access your script, usually one of 'POST',
      'GET' or 'HEAD'. If running from the command line it will be undef.</dd>
  <dt id="content_type()"><a class="permalink" href="#content_type()"><b></b><b>content_type()</b><b></b></a></dt>
  <dd>Returns the content_type of data submitted in a POST, generally
      multipart/form-data or application/x-www-form-urlencoded</dd>
  <dt id="http()"><a class="permalink" href="#http()"><b></b><b>http()</b><b></b></a></dt>
  <dd>Called with no arguments returns the list of HTTP environment variables,
      including such things as HTTP_USER_AGENT, HTTP_ACCEPT_LANGUAGE, and
      HTTP_ACCEPT_CHARSET, corresponding to the like-named HTTP header fields in
      the request. Called with the name of an HTTP header field, returns its
      value. Capitalization and the use of hyphens versus underscores are not
      significant.
    <p class="Pp">For example, all three of these examples are equivalent:</p>
    <p class="Pp"></p>
    <pre>
    my $requested_language = $q-&gt;http('Accept-language');

    my $requested_language = $q-&gt;http('Accept_language');

    my $requested_language = $q-&gt;http('HTTP_ACCEPT_LANGUAGE');
    </pre>
  </dd>
  <dt id="https()"><a class="permalink" href="#https()"><b></b><b>https()</b><b></b></a></dt>
  <dd>The same as <i></i><b><i>http()</i></b><i></i>, but operates on the HTTPS
      environment variables present when the SSL protocol is in effect. Can be
      used to determine whether SSL is turned on.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="USING_NPH_SCRIPTS"><a class="permalink" href="#USING_NPH_SCRIPTS">USING
  NPH SCRIPTS</a></h1>
<p class="Pp">NPH, or &quot;no-parsed-header&quot;, scripts bypass the server
    completely by sending the complete HTTP header directly to the browser. This
    has slight performance benefits, but is of most use for taking advantage of
    HTTP extensions that are not directly supported by your server, such as
    server push and PICS headers.</p>
<p class="Pp">Servers use a variety of conventions for designating CGI scripts
    as NPH. Many Unix servers look at the beginning of the script's name for the
    prefix &quot;nph-&quot;. The Macintosh WebSTAR server and Microsoft's
    Internet Information Server, in contrast, try to decide whether a program is
    an NPH script by examining the first line of script output.</p>
<p class="Pp">CGI.pm supports NPH scripts with a special NPH mode. When in this
    mode, CGI.pm will output the necessary extra header information when the
    <b>header()</b> and <b>redirect()</b> methods are called.</p>
<p class="Pp">The Microsoft Internet Information Server requires NPH mode. As of
    version 2.30, CGI.pm will automatically detect when the script is running
    under IIS and put itself into this mode. You do not need to do this
    manually, although it won't hurt anything if you do.</p>
<dl class="Bl-tag">
  <dt id="In"><a class="permalink" href="#In">In the <b>use</b>
    statement</a></dt>
  <dd>Simply add the &quot;-nph&quot; pragma to the list of symbols to be
      imported into your script:
    <p class="Pp"></p>
    <pre>
    use CGI qw(:standard -nph)
    </pre>
  </dd>
  <dt id="By"><a class="permalink" href="#By">By calling the
    <b></b><b>nph()</b><b></b> method:</a></dt>
  <dd>Call <b></b><b>nph()</b><b></b> with a non-zero parameter at any point
      after using CGI.pm in your program.
    <p class="Pp"></p>
    <pre>
    CGI-&gt;nph(1)
    </pre>
  </dd>
  <dt id="By~2"><a class="permalink" href="#By~2">By using <b>-nph</b>
    parameters</a></dt>
  <dd>in the <b></b><b>header()</b><b></b> and <b></b><b>redirect()</b><b></b>
      statements:
    <p class="Pp"></p>
    <pre>
    print header(-nph=&gt;1);
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SERVER_PUSH"><a class="permalink" href="#SERVER_PUSH">SERVER
  PUSH</a></h1>
<p class="Pp">CGI.pm provides four simple functions for producing multipart
    documents of the type needed to implement server push. These functions were
    graciously provided by Ed Jordan &lt;ed@fidalgo.net&gt;. To import these
    into your namespace, you must import the &quot;:push&quot; set. You are also
    advised to put the script into NPH mode and to set $| to 1 to avoid
    buffering problems.</p>
<p class="Pp">Here is a simple script that demonstrates server push:</p>
<p class="Pp"></p>
<pre>
    #!/usr/bin/env perl

    use strict;
    use warnings;

    use CGI qw/:push -nph/;

    $| = 1;
    print multipart_init( -boundary=&gt;'----here we go!' );
    for (0 .. 4) {
        print multipart_start( -type=&gt;'text/plain' ),
            &quot;The current time is &quot;,scalar( localtime ),&quot;\n&quot;;
        if ($_ &lt; 4) {
            print multipart_end();
        } else {
            print multipart_final();
        }
        sleep 1;
    }
</pre>
<p class="Pp">This script initializes server push by calling
    <b></b><b>multipart_init()</b><b></b>. It then enters a loop in which it
    begins a new multipart section by calling
    <b></b><b>multipart_start()</b><b></b>, prints the current local time, and
    ends a multipart section with <b></b><b>multipart_end()</b><b></b>. It then
    sleeps a second, and begins again. On the final iteration, it ends the
    multipart section with <b></b><b>multipart_final()</b><b></b> rather than
    with <b></b><b>multipart_end()</b><b></b>.</p>
<dl class="Bl-tag">
  <dt id="multipart_init()"><a class="permalink" href="#multipart_init()"><b>multipart_init()</b></a></dt>
  <dd>
    <pre>
    multipart_init( -boundary =&gt; $boundary, -charset =&gt; $charset );
    </pre>
    <p class="Pp">Initialize the multipart system. The -boundary argument
        specifies what MIME boundary string to use to separate parts of the
        document. If not provided, CGI.pm chooses a reasonable boundary for
      you.</p>
    <p class="Pp">The -charset provides the character set, if not provided this
        will default to ISO-8859-1</p>
  </dd>
  <dt id="multipart_start()"><a class="permalink" href="#multipart_start()"><b>multipart_start()</b></a></dt>
  <dd>
    <pre>
    multipart_start( -type =&gt; $type, -charset =&gt; $charset );
    </pre>
    <p class="Pp">Start a new part of the multipart document using the specified
        MIME type and charset. If not specified, text/html ISO-8859-1 is
        assumed.</p>
  </dd>
  <dt id="multipart_end()"><a class="permalink" href="#multipart_end()"><b>multipart_end()</b></a></dt>
  <dd>
    <pre>
    multipart_end()
    </pre>
    <p class="Pp">End a part. You must remember to call <b>multipart_end()</b>
        once for each <b>multipart_start()</b>, except at the end of the last
        part of the multipart document when <b>multipart_final()</b> should be
        called instead of <b>multipart_end()</b>.</p>
  </dd>
  <dt id="multipart_final()"><a class="permalink" href="#multipart_final()"><b>multipart_final()</b></a></dt>
  <dd>
    <pre>
    multipart_final()
    </pre>
    <p class="Pp">End all parts. You should call <b>multipart_final()</b> rather
        than <b>multipart_end()</b> at the end of the last part of the multipart
        document.</p>
  </dd>
</dl>
<p class="Pp">Users interested in server push applications should also have a
    look at the CGI::Push module.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AVOIDING_DENIAL_OF_SERVICE_ATTACKS"><a class="permalink" href="#AVOIDING_DENIAL_OF_SERVICE_ATTACKS">AVOIDING
  DENIAL OF SERVICE ATTACKS</a></h1>
<p class="Pp">A potential problem with CGI.pm is that, by default, it attempts
    to process form POSTings no matter how large they are. A wily hacker could
    attack your site by sending a CGI script a huge POST of many gigabytes.
    CGI.pm will attempt to read the entire POST into a variable, growing hugely
    in size until it runs out of memory. While the script attempts to allocate
    the memory the system may slow down dramatically. This is a form of denial
    of service attack.</p>
<p class="Pp">Another possible attack is for the remote user to force CGI.pm to
    accept a huge file upload. CGI.pm will accept the upload and store it in a
    temporary directory even if your script doesn't expect to receive an
    uploaded file. CGI.pm will delete the file automatically when it terminates,
    but in the meantime the remote user may have filled up the server's disk
    space, causing problems for other programs.</p>
<p class="Pp">The best way to avoid denial of service attacks is to limit the
    amount of memory, CPU time and disk space that CGI scripts can use. Some Web
    servers come with built-in facilities to accomplish this. In other cases,
    you can use the shell <i>limit</i> or <i>ulimit</i> commands to put ceilings
    on CGI resource usage.</p>
<p class="Pp">CGI.pm also has some simple built-in protections against denial of
    service attacks, but you must activate them before you can use them. These
    take the form of two global variables in the CGI name space:</p>
<dl class="Bl-tag">
  <dt><b></b><b>$CGI::POST_MAX</b><b></b></dt>
  <dd>If set to a non-negative integer, this variable puts a ceiling on the size
      of POSTings, in bytes. If CGI.pm detects a POST that is greater than the
      ceiling, it will immediately exit with an error message. This value will
      affect both ordinary POSTs and multipart POSTs, meaning that it limits the
      maximum size of file uploads as well. You should set this to a reasonably
      high value, such as 10 megabytes.</dd>
  <dt><b></b><b>$CGI::DISABLE_UPLOADS</b><b></b></dt>
  <dd>If set to a non-zero value, this will disable file uploads completely.
      Other fill-out form values will work as usual.</dd>
</dl>
<p class="Pp">To use these variables, set the variable at the top of the script,
    right after the &quot;use&quot; statement:</p>
<p class="Pp"></p>
<pre>
    #!/usr/bin/env perl

    use strict;
    use warnings;

    use CGI;

    $CGI::POST_MAX = 1024 * 1024 * 10;  # max 10MB posts
    $CGI::DISABLE_UPLOADS = 1;          # no uploads
</pre>
<p class="Pp">An attempt to send a POST larger than
    <span class="Li">$POST_MAX</span> bytes will cause
    <i></i><b><i>param()</i></b><i></i> to return an empty CGI parameter list.
    You can test for this event by checking
    <i></i><b><i>cgi_error()</i></b><i></i>, either after you create the CGI
    object or, if you are using the function-oriented interface, call
    &lt;<b>param()</b>&gt; for the first time. If the POST was intercepted, then
    <b>cgi_error()</b> will return the message &quot;413 POST too
  large&quot;.</p>
<p class="Pp">This error message is actually defined by the HTTP protocol, and
    is designed to be returned to the browser as the CGI script's status code.
    For example:</p>
<p class="Pp"></p>
<pre>
    my $uploaded_file = $q-&gt;param('upload');
    if ( !$uploaded_file &amp;&amp; $q-&gt;cgi_error() ) {
        print $q-&gt;header( -status =&gt; $q-&gt;cgi_error() );
        exit 0;
   }
</pre>
<p class="Pp">However it isn't clear that any browser currently knows what to do
    with this status code. It might be better just to create a page that warns
    the user of the problem.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COMPATIBILITY_WITH_CGI"><a class="permalink" href="#COMPATIBILITY_WITH_CGI">COMPATIBILITY
  WITH CGI-LIB.PL</a></h1>
<p class="Pp">To make it easier to port existing programs that use cgi-lib.pl
    the compatibility routine &quot;ReadParse&quot; is provided. Porting is
    simple:</p>
<p class="Pp">OLD VERSION</p>
<p class="Pp"></p>
<pre>
    require &quot;cgi-lib.pl&quot;;
    &amp;ReadParse;
    print &quot;The value of the antique is $in{antique}.\n&quot;;
</pre>
<p class="Pp">NEW VERSION</p>
<p class="Pp"></p>
<pre>
    use CGI;
    CGI::ReadParse();
    print &quot;The value of the antique is $in{antique}.\n&quot;;
</pre>
<p class="Pp">CGI.pm's <b>ReadParse()</b> routine creates a tied variable named
    <span class="Li">%in</span>, which can be accessed to obtain the query
    variables. Like ReadParse, you can also provide your own variable.
    Infrequently used features of ReadParse, such as the creation of
    <span class="Li">@in</span> and <span class="Li">$in</span> variables, are
    not supported.</p>
<p class="Pp">Once you use ReadParse, you can retrieve the query object itself
    this way:</p>
<p class="Pp"></p>
<pre>
    my $q = $in{CGI};
</pre>
<p class="Pp">This allows you to start using the more interesting features of
    CGI.pm without rewriting your old scripts from scratch.</p>
<p class="Pp">An even simpler way to mix cgi-lib calls with CGI.pm calls is to
    import both the <span class="Li">&quot;:cgi-lib&quot;</span> and
    <span class="Li">&quot;:standard&quot;</span> method:</p>
<p class="Pp"></p>
<pre>
    use CGI qw(:cgi-lib :standard);
    &amp;ReadParse;
    print &quot;The price of your purchase is $in{price}.\n&quot;;
    print textfield(-name=&gt;'price', -default=&gt;'$1.99');
</pre>
<section class="Ss">
<h2 class="Ss" id="Cgi-lib_functions_that_are_available_in_"><a class="permalink" href="#Cgi-lib_functions_that_are_available_in_">Cgi-lib
  functions that are available in CGI.pm</a></h2>
<p class="Pp">In compatibility mode, the following cgi-lib.pl functions are
    available for your use:</p>
<p class="Pp"></p>
<pre>
    ReadParse()
    PrintHeader()
    SplitParam()
    MethGet()
    MethPost()
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">The CGI.pm distribution is copyright 1995-2007, Lincoln D. Stein.
    It is distributed under the Artistic License 2.0. It is currently maintained
    by Lee Johnson (LEEJO) with help from many contributors.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CREDITS"><a class="permalink" href="#CREDITS">CREDITS</a></h1>
<p class="Pp">Thanks very much to:</p>
<dl class="Bl-tag">
  <dt id="Mark"><a class="permalink" href="#Mark">Mark Stosberg
    (mark@stosberg.com)</a></dt>
  <dd></dd>
  <dt id="Matt"><a class="permalink" href="#Matt">Matt Heffron
    (heffron@falstaff.css.beckman.com)</a></dt>
  <dd></dd>
  <dt id="James"><a class="permalink" href="#James">James Taylor
    (james.taylor@srs.gov)</a></dt>
  <dd></dd>
  <dt id="Scott"><a class="permalink" href="#Scott">Scott Anguish
    (sanguish@digifix.com)</a></dt>
  <dd></dd>
  <dt id="Mike"><a class="permalink" href="#Mike">Mike Jewell
    (mlj3u@virginia.edu)</a></dt>
  <dd></dd>
  <dt id="Timothy"><a class="permalink" href="#Timothy">Timothy Shimmin
    (tes@kbs.citri.edu.au)</a></dt>
  <dd></dd>
  <dt id="Joergen"><a class="permalink" href="#Joergen">Joergen Haegg
    (jh@axis.se)</a></dt>
  <dd></dd>
  <dt id="Laurent"><a class="permalink" href="#Laurent">Laurent Delfosse
    (delfosse@delfosse.com)</a></dt>
  <dd></dd>
  <dt id="Richard"><a class="permalink" href="#Richard">Richard Resnick
    (applepi1@aol.com)</a></dt>
  <dd></dd>
  <dt id="Craig"><a class="permalink" href="#Craig">Craig Bishop
    (csb@barwonwater.vic.gov.au)</a></dt>
  <dd></dd>
  <dt id="Tony"><a class="permalink" href="#Tony">Tony Curtis
    (tc@vcpc.univie.ac.at)</a></dt>
  <dd></dd>
  <dt id="Tim"><a class="permalink" href="#Tim">Tim Bunce
    (Tim.Bunce@ig.co.uk)</a></dt>
  <dd></dd>
  <dt id="Tom"><a class="permalink" href="#Tom">Tom Christiansen
    (tchrist@convex.com)</a></dt>
  <dd></dd>
  <dt id="Andreas"><a class="permalink" href="#Andreas">Andreas Koenig
    (k@franz.ww.TU-Berlin.DE)</a></dt>
  <dd></dd>
  <dt id="Tim~2"><a class="permalink" href="#Tim~2">Tim MacKenzie
    (Tim.MacKenzie@fulcrum.com.au)</a></dt>
  <dd></dd>
  <dt id="Kevin"><a class="permalink" href="#Kevin">Kevin B. Hendricks
    (kbhend@dogwood.tyler.wm.edu)</a></dt>
  <dd></dd>
  <dt id="Stephen"><a class="permalink" href="#Stephen">Stephen Dahmen
    (joyfire@inxpress.net)</a></dt>
  <dd></dd>
  <dt id="Ed"><a class="permalink" href="#Ed">Ed Jordan
    (ed@fidalgo.net)</a></dt>
  <dd></dd>
  <dt id="David"><a class="permalink" href="#David">David Alan Pisoni
    (david@cnation.com)</a></dt>
  <dd></dd>
  <dt id="Doug"><a class="permalink" href="#Doug">Doug MacEachern
    (dougm@opengroup.org)</a></dt>
  <dd></dd>
  <dt id="Robin"><a class="permalink" href="#Robin">Robin Houston
    (robin@oneworld.org)</a></dt>
  <dd></dd>
  <dt>...and many many more...</dt>
  <dd>for suggestions and bug fixes.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">Address bug reports and comments to:
    &lt;https://github.com/leejo/CGI.pm/issues&gt;</p>
<p class="Pp">See the
    &lt;https://github.com/leejo/CGI.pm/blob/master/CONTRIBUTING.md&gt; file for
    information on raising issues and contributing</p>
<p class="Pp">The original bug tracker can be found at:
    &lt;https://rt.cpan.org/Public/Dist/Display.html?Queue=CGI.pm&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">CGI::Carp - provides Carp implementation tailored to the CGI
    environment.</p>
<p class="Pp">CGI::Fast - supports running CGI applications under FastCGI</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-06-02</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

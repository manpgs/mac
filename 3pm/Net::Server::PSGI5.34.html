<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Net::Server::PSGI(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Net::Server::PSGI(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Net::Server::PSGI(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Net::Server::PSGI - basic Net::Server based PSGI HTTP server
  class</p>
</section>
<section class="Sh">
<h1 class="Sh" id="TEST_ONE_LINER"><a class="permalink" href="#TEST_ONE_LINER">TEST
  ONE LINER</a></h1>
<pre>    perl -e 'use base qw(Net::Server::PSGI); main-&gt;run(port =&gt; 8080, ipv =&gt; &quot;*&quot;)'
    # runs a default echo server
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use base qw(Net::Server::PSGI);
    __PACKAGE__-&gt;run(app =&gt; \&amp;my_echo_handler); # will bind IPv4 port 80
    sub my_echo_handler {
        my $env = shift;
        my $txt = qq{&lt;form method=&quot;post&quot; action=&quot;/bam&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;foo&quot;&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;\n};
        require Data::Dumper;
        local $Data::Dumper::Sortkeys = 1;
        require CGI::PSGI;
        my $form = {};
        my $q = CGI::PSGI-&gt;new($env);
        $form-&gt;{$_} = $q-&gt;param($_) for $q-&gt;param;
        $txt .= &quot;&lt;pre&gt;&quot;.Data::Dumper-&gt;Dump([$env, $form], ['env', 'form']).&quot;&lt;/pre&gt;&quot;;
        return [200, ['Content-type', 'text/html'], [$txt]];
    }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">If you want a more fully featured PSGI experience, it would be
    wise to look at the Plack and Starman set of modules. Net::Server::PSGI is
    intended as an easy gateway into PSGI. But to get the most out of all that
    PSGI has to offer, you should review the Plack and Plack::Middleware. If you
    only need something a little more rudimentary, then Net::Server::PSGI may be
    good for you.</p>
<p class="Pp">Net::Server::PSGI takes Net::Server::HTTP one level farther. It
    begins with base type MultiType defaulting to Net::Server::Fork. It is easy
    to change it to any of the other Net::Server flavors by passing server_type
    =&gt; <span class="Li">$other_flavor</span> in the server configurtation.
    The port has also been defaulted to port 80 - but could easily be changed to
    another through the server configuration. You can also very easily add ssl
    by including, proto=&gt;&quot;ssl&quot; and provide a SSL_cert_file and
    SSL_key_file.</p>
<p class="Pp">For example, here is a basic server that will bind to all
    interfaces, will speak both HTTP on port 8080 as well as HTTPS on 8443, and
    will speak both IPv4, as well as IPv6 if it is available.</p>
<p class="Pp"></p>
<pre>    use base qw(Net::Server::PSGI);
    __PACKAGE__-&gt;run(
        port  =&gt; [8080, &quot;8443/ssl&quot;],
        ipv   =&gt; '*', # IPv6 if available
        SSL_key_file  =&gt; '/my/key',
        SSL_cert_file =&gt; '/my/cert',
    );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<dl class="Bl-tag">
  <dt>&quot;process_request&quot;</dt>
  <dd>This method has been overridden in Net::Server::PSGI - you should not use
      it while using Net::Server::PSGI. This overridden method parses the
      environment and sets up request alarms and handles dying failures. It
      calls process_psgi_request once the request is ready and headers have been
      parsed.</dd>
  <dt>&quot;process_psgi_request&quot;</dt>
  <dd>Used when psgi_enabled is true. During this method, find_psgi_handler will
      be called to return the appropriate psgi response handler. Once finished,
      print_psgi_headers and print_psgi_body are used to print out the response.
      See PSGI.
    <p class="Pp">Typically this method should not be overridden. Instead, an
        appropriate method for finding the app should be given to
        find_psgi_handler or app.</p>
  </dd>
  <dt>&quot;find_psgi_handler&quot;</dt>
  <dd>Used to lookup the appropriate PSGI handler. A reference to the already
      parsed <span class="Li">$env</span> hashref is passed. PATH_INFO will be
      initialized to the full path portion of the URI. SCRIPT_NAME will be
      initialized to the empty string. This handler should set the appropriate
      values for SCRIPT_NAME and PATH_INFO depending upon the path matched. A
      code reference for the handler should be returned. The default
      find_psgi_handler will call the <span class="Li">&quot;app&quot;</span>
      method. If that fails a reference to the psgi_echo_handler is returned as
      the default application.
    <p class="Pp"></p>
    <pre>    sub find_psgi_handler {
        my ($self, $env) = @_;
        if ($env-&gt;{'PATH_INFO'} &amp;&amp; $env-&gt;{'PATH_INFO'} =~ s{^ (/foo) (?= $ | /) }{}x) {
            $env-&gt;{'SCRIPT_NAME'} = $1;
            return \&amp;foo_app;
        }
        return $self-&gt;SUPER::find_psgi_handler($env);
    }
    </pre>
  </dd>
  <dt>&quot;app&quot;</dt>
  <dd>Return a reference to the application being served. This should be a valid
      PSGI application. See PSGI. By default it will look at the value of the
      <span class="Li">&quot;app&quot;</span> configuration option. The
      <span class="Li">&quot;app&quot;</span> method may also be used to set the
      <span class="Li">&quot;app&quot;</span> configuration option.
    <p class="Pp"></p>
    <pre>    package MyApp;
    use base qw(Net::Server::PSGI);
    sub default_server_type { 'Prefork' }
    sub my_app {
        my $env = shift;
        return [200, ['Content-type', 'text/html'], [&quot;Hello world&quot;]];
    }
    MyApp-&gt;run(app =&gt; \&amp;my_app);
    # OR
    sub app { \&amp;my_app }
    MyApp-&gt;run;
    # OR
    my $server = MyApp-&gt;new;
    $server-&gt;app(\&amp;my_app);
    $server-&gt;run;
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="OPTIONS"><a class="permalink" href="#OPTIONS">OPTIONS</a></h1>
<p class="Pp">In addition to the command line arguments of the Net::Server::HTTP
    base classes you can also set the following options.</p>
<dl class="Bl-tag">
  <dt id="app"><a class="permalink" href="#app">app</a></dt>
  <dd>Should return a coderef of the PSGI application. Is returned by the app
      method.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Paul T. Seamons paul@seamons.com</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Please see also Plack, Starman,</p>
<p class="Pp">Net::Server::Fork, Net::Server::INET, Net::Server::PreFork,
    Net::Server::PreForkSimple, Net::Server::MultiType, Net::Server::Single
    Net::Server::SIG Net::Server::Daemonize Net::Server::Proto
  Net::Server::HTTP</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-08-10</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

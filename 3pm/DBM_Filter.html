<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>DBM_Filter(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBM_Filter(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">DBM_Filter(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">DBM_Filter -- Filter DBM keys/values</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
    use DBM_Filter ;
    use SDBM_File; # or DB_File, GDBM_File, NDBM_File, or ODBM_File

    $db = tie %hash, ...

    $db-&gt;Filter_Push(Fetch =&gt; sub {...},
                     Store =&gt; sub {...});

    $db-&gt;Filter_Push('my_filter1');
    $db-&gt;Filter_Push('my_filter2', params...);

    $db-&gt;Filter_Key_Push(...) ;
    $db-&gt;Filter_Value_Push(...) ;

    $db-&gt;Filter_Pop();
    $db-&gt;Filtered();

    package DBM_Filter::my_filter1;

    sub Store { ... }
    sub Fetch { ... }

    1;

    package DBM_Filter::my_filter2;

    sub Filter
    {
        my @opts = @_;
        ...
        return (
            sub Store { ... },
            sub Fetch { ... } );
    }

    1;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module provides an interface that allows filters to be
    applied to tied Hashes associated with DBM files. It builds on the DBM
    Filter hooks that are present in all the *DB*_File modules included with the
    standard Perl source distribution from version 5.6.1 onwards. In addition to
    the *DB*_File modules distributed with Perl, the BerkeleyDB module,
    available on CPAN, supports the DBM Filter hooks. See perldbmfilter for more
    details on the DBM Filter hooks.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="What_is_a_DBM_Filter?"><a class="permalink" href="#What_is_a_DBM_Filter?">What
  is a DBM Filter?</a></h1>
<p class="Pp">A DBM Filter allows the keys and/or values in a tied hash to be
    modified by some user-defined code just before it is written to the DBM file
    and just after it is read back from the DBM file. For example, this snippet
    of code</p>
<p class="Pp"></p>
<pre>
    $some_hash{&quot;abc&quot;} = 42;
</pre>
<p class="Pp">could potentially trigger two filters, one for the writing of the
    key &quot;abc&quot; and another for writing the value 42. Similarly, this
    snippet</p>
<p class="Pp"></p>
<pre>
    my ($key, $value) = each %some_hash
</pre>
<p class="Pp">will trigger two filters, one for the reading of the key and one
    for the reading of the value.</p>
<p class="Pp">Like the existing DBM Filter functionality, this module arranges
    for the <span class="Li">$_</span> variable to be populated with the key or
    value that a filter will check. This usually means that most DBM filters
    tend to be very short.</p>
<section class="Ss">
<h2 class="Ss" id="So_what's_new?"><a class="permalink" href="#So_what's_new?">So
  what's new?</a></h2>
<p class="Pp">The main enhancements over the standard DBM Filter hooks are:</p>
<ul class="Bl-bullet">
  <li>A cleaner interface.</li>
  <li>The ability to easily apply multiple filters to a single DBM file.</li>
  <li>The ability to create &quot;canned&quot; filters. These allow commonly
      used filters to be packaged into a stand-alone module.</li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<p class="Pp">This module will arrange for the following methods to be available
    via the object returned from the <span class="Li">&quot;tie&quot;</span>
    call.</p>
<section class="Ss">
<h2 class="Ss">$db-&gt;<b>Filter_Push()</b> / $db-&gt;<b>Filter_Key_Push()</b> /
  $db-&gt;<b>Filter_Value_Push()</b></h2>
<p class="Pp">Add a filter to filter stack for the database,
    <span class="Li">$db</span>. The three formats vary only in whether they
    apply to the DBM key, the DBM value or both.</p>
<dl class="Bl-tag">
  <dt id="Filter_Push"><a class="permalink" href="#Filter_Push">Filter_Push</a></dt>
  <dd>The filter is applied to <i>both</i> keys and values.</dd>
  <dt id="Filter_Key_Push"><a class="permalink" href="#Filter_Key_Push">Filter_Key_Push</a></dt>
  <dd>The filter is applied to the key <i>only</i>.</dd>
  <dt id="Filter_Value_Push"><a class="permalink" href="#Filter_Value_Push">Filter_Value_Push</a></dt>
  <dd>The filter is applied to the value <i>only</i>.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="$db"><a class="permalink" href="#$db">$db-&gt;<b>Filter_Pop()</b></a></h2>
<p class="Pp">Removes the last filter that was applied to the DBM file
    associated with <span class="Li">$db</span>, if present.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$db~2"><a class="permalink" href="#$db~2">$db-&gt;<b>Filtered()</b></a></h2>
<p class="Pp">Returns TRUE if there are any filters applied to the DBM
    associated with <span class="Li">$db</span>. Otherwise returns FALSE.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Writing_a_Filter"><a class="permalink" href="#Writing_a_Filter">Writing
  a Filter</a></h1>
<p class="Pp">Filters can be created in two main ways</p>
<section class="Ss">
<h2 class="Ss" id="Immediate_Filters"><a class="permalink" href="#Immediate_Filters">Immediate
  Filters</a></h2>
<p class="Pp">An immediate filter allows you to specify the filter code to be
    used at the point where the filter is applied to a dbm. In this mode the
    Filter_*_Push methods expects to receive exactly two parameters.</p>
<p class="Pp"></p>
<pre>
    my $db = tie %hash, 'SDBM_File', ...
    $db-&gt;Filter_Push( Store =&gt; sub { },
                      Fetch =&gt; sub { });
</pre>
<p class="Pp">The code reference associated with
    <span class="Li">&quot;Store&quot;</span> will be called before any
    key/value is written to the database and the code reference associated with
    <span class="Li">&quot;Fetch&quot;</span> will be called after any key/value
    is read from the database.</p>
<p class="Pp">For example, here is a sample filter that adds a trailing NULL
    character to all strings before they are written to the DBM file, and
    removes the trailing NULL when they are read from the DBM file</p>
<p class="Pp"></p>
<pre>
    my $db = tie %hash, 'SDBM_File', ...
    $db-&gt;Filter_Push( Store =&gt; sub { $_ .= &quot;\x00&quot; ; },
                      Fetch =&gt; sub { s/\x00$// ;    });
</pre>
<p class="Pp">Points to note:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>Both the Store and Fetch filters manipulate
    <span class="Li">$_</span>.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Canned_Filters"><a class="permalink" href="#Canned_Filters">Canned
  Filters</a></h2>
<p class="Pp">Immediate filters are useful for one-off situations. For more
    generic problems it can be useful to package the filter up in its own
    module.</p>
<p class="Pp">The usage is for a canned filter is:</p>
<p class="Pp"></p>
<pre>
    $db-&gt;Filter_Push(&quot;name&quot;, params)
</pre>
<p class="Pp">where</p>
<dl class="Bl-tag">
  <dt>&quot;name&quot;</dt>
  <dd>is the name of the module to load. If the string specified does not
      contain the package separator characters &quot;::&quot;, it is assumed to
      refer to the full module name &quot;DBM_Filter::name&quot;. This means
      that the full names for canned filters, &quot;null&quot; and
      &quot;utf8&quot;, included with this module are:
    <p class="Pp"></p>
    <pre>
    DBM_Filter::null
    DBM_Filter::utf8
    </pre>
  </dd>
  <dt id="params"><a class="permalink" href="#params">params</a></dt>
  <dd>any optional parameters that need to be sent to the filter. See the encode
      filter for an example of a module that uses parameters.</dd>
</dl>
<p class="Pp">The module that implements the canned filter can take one of two
    forms. Here is a template for the first</p>
<p class="Pp"></p>
<pre>
    package DBM_Filter::null ;

    use strict;
    use warnings;

    sub Store 
    {
        # store code here    
    }

    sub Fetch
    {
        # fetch code here
    }

    1;
</pre>
<p class="Pp">Notes:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>The package name uses the <span class="Li">&quot;DBM_Filter::&quot;</span>
      prefix.</dd>
  <dt>2.</dt>
  <dd>The module <i>must</i> have both a Store and a Fetch method. If only one
      is present, or neither are present, a fatal error will be thrown.</dd>
</dl>
<p class="Pp">The second form allows the filter to hold state information using
    a closure, thus:</p>
<p class="Pp"></p>
<pre>
    package DBM_Filter::encoding ;

    use strict;
    use warnings;

    sub Filter
    {
        my @params = @_ ;

        ...
        return {
            Store   =&gt; sub { $_ = $encoding-&gt;encode($_) },
            Fetch   =&gt; sub { $_ = $encoding-&gt;decode($_) }
            } ;
    }

    1;
</pre>
<p class="Pp">In this instance the &quot;Store&quot; and &quot;Fetch&quot;
    methods are encapsulated inside a &quot;Filter&quot; method.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Filters_Included"><a class="permalink" href="#Filters_Included">Filters
  Included</a></h1>
<p class="Pp">A number of canned filers are provided with this module. They
    cover a number of the main areas that filters are needed when interfacing
    with DBM files. They also act as templates for your own filters.</p>
<p class="Pp">The filter included are:</p>
<ul class="Bl-bullet">
  <li>utf8
    <p class="Pp">This module will ensure that all data written to the DBM will
        be encoded in UTF-8.</p>
    <p class="Pp">This module needs the Encode module.</p>
  </li>
  <li>encode
    <p class="Pp">Allows you to choose the character encoding will be store in
        the DBM file.</p>
  </li>
  <li>compress
    <p class="Pp">This filter will compress all data before it is written to the
        database and uncompressed it on reading.</p>
    <p class="Pp">This module needs Compress::Zlib.</p>
  </li>
  <li>int32
    <p class="Pp">This module is used when interoperating with a C/C++
        application that uses a C int as either the key and/or value in the DBM
        file.</p>
  </li>
  <li>null
    <p class="Pp">This module ensures that all data written to the DBM file is
        null terminated. This is useful when you have a perl script that needs
        to interoperate with a DBM file that a C program also uses. A fairly
        common issue is for the C application to include the terminating null in
        a string when it writes to the DBM file. This filter will ensure that
        all data written to the DBM file can be read by the C application.</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Maintain_Round_Trip_Integrity"><a class="permalink" href="#Maintain_Round_Trip_Integrity">Maintain
  Round Trip Integrity</a></h2>
<p class="Pp">When writing a DBM filter it is <i>very</i> important to ensure
    that it is possible to retrieve all data that you have written when the DBM
    filter is in place. In practice, this means that whatever transformation is
    applied to the data in the Store method, the <i>exact</i> inverse operation
    should be applied in the Fetch method.</p>
<p class="Pp">If you don't provide an exact inverse transformation, you will
    find that code like this will not behave as you expect.</p>
<p class="Pp"></p>
<pre>
     while (my ($k, $v) = each %hash)
     {
         ...
     }
</pre>
<p class="Pp">Depending on the transformation, you will find that one or more of
    the following will happen</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>The loop will never terminate.</dd>
  <dt>2.</dt>
  <dd>Too few records will be retrieved.</dd>
  <dt>3.</dt>
  <dd>Too many will be retrieved.</dd>
  <dt>4.</dt>
  <dd>The loop will do the right thing for a while, but it will unexpectedly
      fail.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Don't_mix_filtered_&amp;_non-filtered_data_in_the_same_database_file."><a class="permalink" href="#Don't_mix_filtered_&amp;_non-filtered_data_in_the_same_database_file.">Don't
  mix filtered &amp; non-filtered data in the same database file.</a></h2>
<p class="Pp">This is just a restatement of the previous section. Unless you are
    completely certain you know what you are doing, avoid mixing filtered &amp;
    non-filtered data.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLE"><a class="permalink" href="#EXAMPLE">EXAMPLE</a></h1>
<p class="Pp">Say you need to interoperate with a legacy C application that
    stores keys as C ints and the values and null terminated UTF-8 strings. Here
    is how you would set that up</p>
<p class="Pp"></p>
<pre>
    my $db = tie %hash, 'SDBM_File', ...

    $db-&gt;Filter_Key_Push('int32') ;

    $db-&gt;Filter_Value_Push('utf8');
    $db-&gt;Filter_Value_Push('null');
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">&lt;DB_File&gt;, GDBM_File, NDBM_File, ODBM_File, SDBM_File,
    perldbmfilter</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Paul Marquess &lt;pmqs@cpan.org&gt;</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Moose::Cookbook::Basics::BinaryTree_AttributeFeatures(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Moose::Cookbook::Basics::BinaryTree_AttributeFeatures(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Moose::Cookbook::Basics::BinaryTree_AttributeFeatures(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Moose::Cookbook::Basics::BinaryTree_AttributeFeatures -
    Demonstrates various attribute features including lazy, predicates, weak
    refs, and more</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 2.2012</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
  package BinaryTree;
  use Moose;

  has 'node' =&gt; ( is =&gt; 'rw', isa =&gt; 'Any' );

  has 'parent' =&gt; (
      is        =&gt; 'rw',
      isa       =&gt; 'BinaryTree',
      predicate =&gt; 'has_parent',
      weak_ref  =&gt; 1,
  );

  has 'left' =&gt; (
      is        =&gt; 'rw',
      isa       =&gt; 'BinaryTree',
      predicate =&gt; 'has_left',
      lazy      =&gt; 1,
      default   =&gt; sub { BinaryTree-&gt;new( parent =&gt; $_[0] ) },
      trigger   =&gt; \&amp;_set_parent_for_child
  );

  has 'right' =&gt; (
      is        =&gt; 'rw',
      isa       =&gt; 'BinaryTree',
      predicate =&gt; 'has_right',
      lazy      =&gt; 1,
      default   =&gt; sub { BinaryTree-&gt;new( parent =&gt; $_[0] ) },
      trigger   =&gt; \&amp;_set_parent_for_child
  );

  sub _set_parent_for_child {
      my ( $self, $child ) = @_;

      confess &quot;You cannot insert a tree which already has a parent&quot;
          if $child-&gt;has_parent;

      $child-&gt;parent($self);
  }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This recipe shows how various advanced attribute features can be
    used to create complex and powerful behaviors. In particular, we introduce a
    number of new attribute options, including
    <span class="Li">&quot;predicate&quot;</span>,
    <span class="Li">&quot;lazy&quot;</span>, and
    <span class="Li">&quot;trigger&quot;</span>.</p>
<p class="Pp">The example class is a classic binary tree. Each node in the tree
    is itself an instance of <span class="Li">&quot;BinaryTree&quot;</span>. It
    has a <span class="Li">&quot;node&quot;</span>, which holds some arbitrary
    value. It has <span class="Li">&quot;right&quot;</span> and
    <span class="Li">&quot;left&quot;</span> attributes, which refer to its
    child trees, and a <span class="Li">&quot;parent&quot;</span>.</p>
<p class="Pp">Let's take a look at the <span class="Li">&quot;node&quot;</span>
    attribute:</p>
<p class="Pp"></p>
<pre>
  has 'node' =&gt; ( is =&gt; 'rw', isa =&gt; 'Any' );
</pre>
<p class="Pp">Moose generates a read-write accessor for this attribute. The type
    constraint is <span class="Li">&quot;Any&quot;</span>, which literally means
    it can contain anything.</p>
<p class="Pp">We could have left out the <span class="Li">&quot;isa&quot;</span>
    option, but in this case, we are including it for the benefit of other
    programmers, not the computer.</p>
<p class="Pp">Next, let's move on to the
    <span class="Li">&quot;parent&quot;</span> attribute:</p>
<p class="Pp"></p>
<pre>
  has 'parent' =&gt; (
      is        =&gt; 'rw',
      isa       =&gt; 'BinaryTree',
      predicate =&gt; 'has_parent',
      weak_ref  =&gt; 1,
  );
</pre>
<p class="Pp">Again, we have a read-write accessor. This time, the
    <span class="Li">&quot;isa&quot;</span> option says that this attribute must
    always be an instance of <span class="Li">&quot;BinaryTree&quot;</span>. In
    the second recipe, we saw that every time we create a Moose-based class, we
    also get a corresponding class type constraint.</p>
<p class="Pp">The <span class="Li">&quot;predicate&quot;</span> option is new.
    It creates a method which can be used to check whether or not a given
    attribute has been initialized. In this case, the method is named
    <span class="Li">&quot;has_parent&quot;</span>.</p>
<p class="Pp">This brings us to our last attribute option,
    <span class="Li">&quot;weak_ref&quot;</span>. Since
    <span class="Li">&quot;parent&quot;</span> is a circular reference (the tree
    in <span class="Li">&quot;parent&quot;</span> should already have a
    reference to this one, in its <span class="Li">&quot;left&quot;</span> or
    <span class="Li">&quot;right&quot;</span> attribute), we want to make sure
    that we weaken the reference to avoid memory leaks. If
    <span class="Li">&quot;weak_ref&quot;</span> is true, it alters the accessor
    function so that the reference is weakened when it is set.</p>
<p class="Pp">Finally, we have the <span class="Li">&quot;left&quot;</span> and
    <span class="Li">&quot;right&quot;</span> attributes. They are essentially
    identical except for their names, so we'll just look at
    <span class="Li">&quot;left&quot;</span>:</p>
<p class="Pp"></p>
<pre>
  has 'left' =&gt; (
      is        =&gt; 'rw',
      isa       =&gt; 'BinaryTree',
      predicate =&gt; 'has_left',
      lazy      =&gt; 1,
      default   =&gt; sub { BinaryTree-&gt;new( parent =&gt; $_[0] ) },
      trigger   =&gt; \&amp;_set_parent_for_child
  );
</pre>
<p class="Pp">There are three new options here,
    <span class="Li">&quot;lazy&quot;</span>,
    <span class="Li">&quot;default&quot;</span>, and
    <span class="Li">&quot;trigger&quot;</span>. The
    <span class="Li">&quot;lazy&quot;</span> and
    <span class="Li">&quot;default&quot;</span> options are linked. In fact, you
    cannot have a <span class="Li">&quot;lazy&quot;</span> attribute unless it
    has a <span class="Li">&quot;default&quot;</span> (or a
    <span class="Li">&quot;builder&quot;</span>, but we'll cover that later). If
    you try to make an attribute lazy without a default, class creation will
    fail with an exception. (2)</p>
<p class="Pp">In the second recipe the <b>BankAccount</b>'s
    <span class="Li">&quot;balance&quot;</span> attribute had a default value of
    <span class="Li">0</span>. Given a non-reference, Perl copies the
    <i>value</i>. However, given a reference, it does not do a deep clone,
    instead simply copying the reference. If you just specified a simple
    reference for a default, Perl would create it once and it would be shared by
    all objects with that attribute.</p>
<p class="Pp">As a workaround, we use an anonymous subroutine to generate a new
    reference every time the default is called.</p>
<p class="Pp"></p>
<pre>
  has 'foo' =&gt; ( is =&gt; 'rw', default =&gt; sub { [] } );
</pre>
<p class="Pp">In fact, using a non-subroutine reference as a default is illegal
    in Moose.</p>
<p class="Pp"></p>
<pre>
  # will fail
  has 'foo' =&gt; ( is =&gt; 'rw', default =&gt; [] );
</pre>
<p class="Pp">This will blow up, so don't do it.</p>
<p class="Pp">You'll notice that we use <span class="Li">$_[0]</span> in our
    default sub. When the default subroutine is executed, it is called as a
    method on the object.</p>
<p class="Pp">In our case, we're making a new
    <span class="Li">&quot;BinaryTree&quot;</span> object in our default, with
    the current tree as the parent.</p>
<p class="Pp">Normally, when an object is instantiated, any defaults are
    evaluated immediately. With our
    <span class="Li">&quot;BinaryTree&quot;</span> class, this would be a big
    problem! We'd create the first object, which would immediately try to
    populate its <span class="Li">&quot;left&quot;</span> and
    <span class="Li">&quot;right&quot;</span> attributes, which would create a
    new <span class="Li">&quot;BinaryTree&quot;</span>, which would populate
    <i>its</i> <span class="Li">&quot;left&quot;</span> and
    <span class="Li">&quot;right&quot;</span> slots. Kaboom!</p>
<p class="Pp">By making our <span class="Li">&quot;left&quot;</span> and
    <span class="Li">&quot;right&quot;</span> attributes
    <span class="Li">&quot;lazy&quot;</span>, we avoid this problem. If the
    attribute has a value when it is read, the default is never executed at
  all.</p>
<p class="Pp">We still have one last bit of behavior to add. The autogenerated
    <span class="Li">&quot;right&quot;</span> and
    <span class="Li">&quot;left&quot;</span> accessors are not quite correct.
    When one of these is set, we want to make sure that we update the parent of
    the <span class="Li">&quot;left&quot;</span> or
    <span class="Li">&quot;right&quot;</span> attribute's tree.</p>
<p class="Pp">We could write our own accessors, but then why use Moose at all?
    Instead, we use a <span class="Li">&quot;trigger&quot;</span>. A
    <span class="Li">&quot;trigger&quot;</span> accepts a subroutine reference,
    which will be called as a method whenever the attribute is set. This can
    happen both during object construction or later by passing a new object to
    the attribute's accessor method. However, it is not called when a value is
    provided by a <span class="Li">&quot;default&quot;</span> or
    <span class="Li">&quot;builder&quot;</span>.</p>
<p class="Pp"></p>
<pre>
  sub _set_parent_for_child {
      my ( $self, $child ) = @_;

      confess &quot;You cannot insert a tree which already has a parent&quot;
          if $child-&gt;has_parent;

      $child-&gt;parent($self);
  }
</pre>
<p class="Pp">This trigger does two things. First, it ensures that the new child
    node does not already have a parent. This is done for the sake of
    simplifying the example. If we wanted to be more clever, we would remove the
    child from its old parent tree and add it to the new one.</p>
<p class="Pp">If the child has no parent, we will add it to the current tree,
    and we ensure that is has the correct value for its
    <span class="Li">&quot;parent&quot;</span> attribute.</p>
<p class="Pp">As with all the other recipes, <b>BinaryTree</b> can be used just
    like any other Perl 5 class. A more detailed example of its usage can be
    found in <i>t/recipes/basics_binarytree_attributefeatures.t</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONCLUSION"><a class="permalink" href="#CONCLUSION">CONCLUSION</a></h1>
<p class="Pp">This recipe introduced several of Moose's advanced features. We
    hope that this inspires you to think of other ways these features can be
    used to simplify your code.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FOOTNOTES"><a class="permalink" href="#FOOTNOTES">FOOTNOTES</a></h1>
<dl class="Bl-tag">
  <dt>(1)</dt>
  <dd>Weak references are tricky things, and should be used sparingly and
      appropriately (such as in the case of circular refs). If you are not
      careful, attribute values could disappear &quot;mysteriously&quot; because
      Perl's reference counting garbage collector has gone and removed the item
      you are weak-referencing.
    <p class="Pp">In short, don't use them unless you know what you are doing
      :)</p>
  </dd>
  <dt>(2)</dt>
  <dd>You <i>can</i> use the <span class="Li">&quot;default&quot;</span> option
      without the <span class="Li">&quot;lazy&quot;</span> option if you like,
      as we showed in the second recipe.
    <p class="Pp">Also, you can use <span class="Li">&quot;builder&quot;</span>
        instead of <span class="Li">&quot;default&quot;</span>. See
        Moose::Cookbook::Basics::BinaryTree_BuilderAndLazyBuild for details.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Stevan Little &lt;stevan.little@iinteractive.com&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
  <li>Shawn M Moore &lt;code@sartak.org&gt;</li>
  <li>&#x05D9;&#x05D5;&#x05D1;&#x05DC; &#x05E7;&#x05D5;&#x05D2;'&#x05DE;&#x05DF;
      (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Florian Ragwitz &lt;rafl@debian.org&gt;</li>
  <li>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</li>
  <li>Chris Prather &lt;chris@prather.org&gt;</li>
  <li>Matt S Trout &lt;mst@shadowcat.co.uk&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2006 by Infinity Interactive,
  Inc.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-11-22</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

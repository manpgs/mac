<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Digest(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Digest(3pm)</td>
    <td class="head-vol"><a href=".">Perl Programmers Reference Guide</a></td>
    <td class="head-rtitle">Digest(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Digest - Modules that calculate message digests</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  $md5  = Digest-&gt;new(&quot;MD5&quot;);
  $sha1 = Digest-&gt;new(&quot;SHA-1&quot;);
  $sha256 = Digest-&gt;new(&quot;SHA-256&quot;);
  $sha384 = Digest-&gt;new(&quot;SHA-384&quot;);
  $sha512 = Digest-&gt;new(&quot;SHA-512&quot;);
  $hmac = Digest-&gt;HMAC_MD5($key);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The <span class="Li">&quot;Digest::&quot;</span> modules calculate
    digests, also called &quot;fingerprints&quot; or &quot;hashes&quot;, of some
    data, called a message. The digest is (usually) some small/fixed size
    string. The actual size of the digest depend of the algorithm used. The
    message is simply a sequence of arbitrary bytes or bits.</p>
<p class="Pp">An important property of the digest algorithms is that the digest
    is <i>likely</i> to change if the message change in some way. Another
    property is that digest functions are one-way functions, that is it should
    be <i>hard</i> to find a message that correspond to some given digest.
    Algorithms differ in how &quot;likely&quot; and how &quot;hard&quot;, as
    well as how efficient they are to compute.</p>
<p class="Pp">Note that the properties of the algorithms change over time, as
    the algorithms are analyzed and machines grow faster. If your application
    for instance depends on it being &quot;impossible&quot; to generate the same
    digest for a different message it is wise to make it easy to plug in
    stronger algorithms as the one used grow weaker. Using the interface
    documented here should make it easy to change algorithms later.</p>
<p class="Pp">All <span class="Li">&quot;Digest::&quot;</span> modules provide
    the same programming interface. A functional interface for simple use, as
    well as an object oriented interface that can handle messages of arbitrary
    length and which can read files directly.</p>
<p class="Pp">The digest can be delivered in three formats:</p>
<dl class="Bl-tag">
  <dt id="binary"><a class="permalink" href="#binary"><i>binary</i></a></dt>
  <dd>This is the most compact form, but it is not well suited for printing or
      embedding in places that can't handle arbitrary data.</dd>
  <dt id="hex"><a class="permalink" href="#hex"><i>hex</i></a></dt>
  <dd>A twice as long string of lowercase hexadecimal digits.</dd>
  <dt id="base64"><a class="permalink" href="#base64"><i>base64</i></a></dt>
  <dd>A string of portable printable characters. This is the base64 encoded
      representation of the digest with any trailing padding removed. The string
      will be about 30% longer than the binary version. MIME::Base64 tells you
      more about this encoding.</dd>
</dl>
<p class="Pp">The functional interface is simply importable functions with the
    same name as the algorithm. The functions take the message as argument and
    return the digest. Example:</p>
<p class="Pp"></p>
<pre>  use Digest::MD5 qw(md5);
  $digest = md5($message);
</pre>
<p class="Pp">There are also versions of the functions with &quot;_hex&quot; or
    &quot;_base64&quot; appended to the name, which returns the digest in the
    indicated form.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OO_INTERFACE"><a class="permalink" href="#OO_INTERFACE">OO
  INTERFACE</a></h1>
<p class="Pp">The following methods are available for all
    <span class="Li">&quot;Digest::&quot;</span> modules:</p>
<dl class="Bl-tag">
  <dt>$ctx = Digest-&gt;XXX($arg,...)</dt>
  <dd></dd>
  <dt>$ctx = Digest-&gt;new(XXX =&gt; $arg,...)</dt>
  <dd></dd>
  <dt>$ctx = Digest::XXX-&gt;new($arg,...)</dt>
  <dd>The constructor returns some object that encapsulate the state of the
      message-digest algorithm. You can add data to the object and finally ask
      for the digest. The &quot;XXX&quot; should of course be replaced by the
      proper name of the digest algorithm you want to use.
    <p class="Pp">The two first forms are simply syntactic sugar which
        automatically load the right module on first use. The second form allow
        you to use algorithm names which contains letters which are not legal
        perl identifiers, e.g. &quot;SHA-1&quot;. If no implementation for the
        given algorithm can be found, then an exception is raised.</p>
    <p class="Pp">To know what arguments (if any) the constructor takes (the
        <span class="Li">&quot;$args,...&quot;</span> above) consult the docs
        for the specific digest implementation.</p>
    <p class="Pp">If <b>new()</b> is called as an instance method (i.e.
        <span class="Li">$ctx</span>-&gt;new) it will just reset the state the
        object to the state of a newly created object. No new object is created
        in this case, and the return value is the reference to the object (i.e.
        <span class="Li">$ctx</span>).</p>
  </dd>
  <dt>$other_ctx = $ctx-&gt;clone</dt>
  <dd>The clone method creates a copy of the digest state object and returns a
      reference to the copy.</dd>
  <dt>$ctx-&gt;reset</dt>
  <dd>This is just an alias for <span class="Li">$ctx</span>-&gt;new.</dd>
  <dt>$ctx-&gt;add( $data )</dt>
  <dd></dd>
  <dt>$ctx-&gt;add( $chunk1, $chunk2, ... )</dt>
  <dd>The string value of the <span class="Li">$data</span> provided as argument
      is appended to the message we calculate the digest for. The return value
      is the <span class="Li">$ctx</span> object itself.
    <p class="Pp">If more arguments are provided then they are all appended to
        the message, thus all these lines will have the same effect on the state
        of the <span class="Li">$ctx</span> object:</p>
    <p class="Pp"></p>
    <pre>  $ctx-&gt;add(&quot;a&quot;); $ctx-&gt;add(&quot;b&quot;); $ctx-&gt;add(&quot;c&quot;);
  $ctx-&gt;add(&quot;a&quot;)-&gt;add(&quot;b&quot;)-&gt;add(&quot;c&quot;);
  $ctx-&gt;add(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
  $ctx-&gt;add(&quot;abc&quot;);
    </pre>
    <p class="Pp">Most algorithms are only defined for strings of bytes and this
        method might therefore croak if the provided arguments contain chars
        with ordinal number above 255.</p>
  </dd>
  <dt>$ctx-&gt;addfile( $io_handle )</dt>
  <dd>The <span class="Li">$io_handle</span> is read until EOF and the content
      is appended to the message we calculate the digest for. The return value
      is the <span class="Li">$ctx</span> object itself.
    <p class="Pp">The <b>addfile()</b> method will <b>croak()</b> if it fails
        reading data for some reason. If it croaks it is unpredictable what the
        state of the <span class="Li">$ctx</span> object will be in. The
        <b>addfile()</b> method might have been able to read the file partially
        before it failed. It is probably wise to discard or reset the
        <span class="Li">$ctx</span> object if this occurs.</p>
    <p class="Pp">In most cases you want to make sure that the
        <span class="Li">$io_handle</span> is in &quot;binmode&quot; before you
        pass it as argument to the <b>addfile()</b> method.</p>
  </dd>
  <dt>$ctx-&gt;add_bits( $data, $nbits )</dt>
  <dd></dd>
  <dt>$ctx-&gt;add_bits( $bitstring )</dt>
  <dd>The <b>add_bits()</b> method is an alternative to <b>add()</b> that allow
      partial bytes to be appended to the message. Most users can just ignore
      this method since typical applications involve only whole-byte data.
    <p class="Pp">The two argument form of <b>add_bits()</b> will add the first
        <span class="Li">$nbits</span> bits from <span class="Li">$data</span>.
        For the last potentially partial byte only the high order
        <span class="Li">&quot;$nbits % 8&quot;</span> bits are used. If
        <span class="Li">$nbits</span> is greater than
        <span class="Li">&quot;length($data) * 8&quot;</span>, then this method
        would do the same as
        <span class="Li">&quot;$ctx-&gt;add($data)&quot;</span>.</p>
    <p class="Pp">The one argument form of <b>add_bits()</b> takes a
        <span class="Li">$bitstring</span> of &quot;1&quot; and &quot;0&quot;
        chars as argument. It's a shorthand for
        <span class="Li">&quot;$ctx-&gt;add_bits(pack(&quot;B*&quot;,</span>
        <span class="Li">$bitstring), length($bitstring))&quot;</span>.</p>
    <p class="Pp">The return value is the <span class="Li">$ctx</span> object
        itself.</p>
    <p class="Pp">This example shows two calls that should have the same
      effect:</p>
    <p class="Pp"></p>
    <pre>   $ctx-&gt;add_bits(&quot;111100001010&quot;);
   $ctx-&gt;add_bits(&quot;\xF0\xA0&quot;, 12);
    </pre>
    <p class="Pp">Most digest algorithms are byte based and for these it is not
        possible to add bits that are not a multiple of 8, and the
        <b>add_bits()</b> method will croak if you try.</p>
  </dd>
  <dt>$ctx-&gt;digest</dt>
  <dd>Return the binary digest for the message.
    <p class="Pp">Note that the <span class="Li">&quot;digest&quot;</span>
        operation is effectively a destructive, read-once operation. Once it has
        been performed, the <span class="Li">$ctx</span> object is automatically
        <span class="Li">&quot;reset&quot;</span> and can be used to calculate
        another digest value. Call
        <span class="Li">$ctx</span>-&gt;clone-&gt;digest if you want to
        calculate the digest without resetting the digest state.</p>
  </dd>
  <dt>$ctx-&gt;hexdigest</dt>
  <dd>Same as <span class="Li">$ctx</span>-&gt;digest, but will return the
      digest in hexadecimal form.</dd>
  <dt>$ctx-&gt;b64digest</dt>
  <dd>Same as <span class="Li">$ctx</span>-&gt;digest, but will return the
      digest as a base64 encoded string without padding.</dd>
  <dt>$ctx-&gt;base64_padded_digest</dt>
  <dd>Same as <span class="Li">$ctx</span>-&gt;digest, but will return the
      digest as a base64 encoded string.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Digest_speed"><a class="permalink" href="#Digest_speed">Digest
  speed</a></h1>
<p class="Pp">This table should give some indication on the relative speed of
    different algorithms. It is sorted by throughput based on a benchmark done
    with of some implementations of this API:</p>
<p class="Pp"></p>
<pre> Algorithm      Size    Implementation                  MB/s
 MD4            128     Digest::MD4 v1.3               165.0
 MD5            128     Digest::MD5 v2.33               98.8
 SHA-256        256     Digest::SHA2 v1.1.0             66.7
 SHA-1          160     Digest::SHA v4.3.1              58.9
 SHA-1          160     Digest::SHA1 v2.10              48.8
 SHA-256        256     Digest::SHA v4.3.1              41.3
 Haval-256      256     Digest::Haval256 v1.0.4         39.8
 SHA-384        384     Digest::SHA2 v1.1.0             19.6
 SHA-512        512     Digest::SHA2 v1.1.0             19.3
 SHA-384        384     Digest::SHA v4.3.1              19.2
 SHA-512        512     Digest::SHA v4.3.1              19.2
 Whirlpool      512     Digest::Whirlpool v1.0.2        13.0
 MD2            128     Digest::MD2 v2.03                9.5
 Adler-32        32     Digest::Adler32 v0.03            1.3
 CRC-16          16     Digest::CRC v0.05                1.1
 CRC-32          32     Digest::CRC v0.05                1.1
 MD5            128     Digest::Perl::MD5 v1.5           1.0
 CRC-CCITT       16     Digest::CRC v0.05                0.8
</pre>
<p class="Pp">These numbers was achieved Apr 2004 with ActivePerl-5.8.3 running
    under Linux on a P4 2.8 GHz CPU. The last 5 entries differ by being pure
    perl implementations of the algorithms, which explains why they are so
  slow.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Digest::Adler32, Digest::CRC, Digest::Haval256, Digest::HMAC,
    Digest::MD2, Digest::MD4, Digest::MD5, Digest::SHA, Digest::SHA1,
    Digest::SHA2, Digest::Whirlpool</p>
<p class="Pp">New digest implementations should consider subclassing from
    Digest::base.</p>
<p class="Pp">MIME::Base64</p>
<p class="Pp">http://en.wikipedia.org/wiki/Cryptographic_hash_function</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Gisle Aas &lt;gisle@aas.no&gt;</p>
<p class="Pp">The <span class="Li">&quot;Digest::&quot;</span> interface is
    based on the interface originally developed by Neil Winton for his
    <span class="Li">&quot;MD5&quot;</span> module.</p>
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp"></p>
<pre>    Copyright 1998-2006 Gisle Aas.
    Copyright 1995,1996 Neil Winton.
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os"><a href="..">perl v5.34.1</a></td>
  </tr>
</table>
</body>
</html>

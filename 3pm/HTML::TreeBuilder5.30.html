<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>HTML::TreeBuilder(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">HTML::TreeBuilder(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">HTML::TreeBuilder(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">HTML::TreeBuilder - Parser that builds a HTML syntax tree</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">This document describes version 5.07 of HTML::TreeBuilder,
    released August 31, 2017 as part of HTML-Tree.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  use HTML::TreeBuilder 5 -weak; # Ensure weak references in use
  foreach my $file_name (@ARGV) {
    my $tree = HTML::TreeBuilder-&gt;new; # empty tree
    $tree-&gt;parse_file($file_name);
    print &quot;Hey, here's a dump of the parse tree of $file_name:\n&quot;;
    $tree-&gt;dump; # a method we inherit from HTML::Element
    print &quot;And here it is, bizarrely rerendered as HTML:\n&quot;,
      $tree-&gt;as_HTML, &quot;\n&quot;;
    # Now that we're done with it, we must destroy it.
    # $tree = $tree-&gt;delete; # Not required with weak references
  }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">(This class is part of the HTML::Tree dist.)</p>
<p class="Pp">This class is for HTML syntax trees that get built out of HTML
    source. The way to use it is to:</p>
<p class="Pp">1. start a new (empty) HTML::TreeBuilder object,</p>
<p class="Pp">2. then use one of the methods from HTML::Parser (presumably with
    <span class="Li">&quot;$tree-&gt;parse_file($filename)&quot;</span> for
    files, or with
    <span class="Li">&quot;$tree-&gt;parse($document_content)&quot;</span> and
    <span class="Li">&quot;$tree-&gt;eof&quot;</span> if you've got the content
    in a string) to parse the HTML document into the tree
    <span class="Li">$tree</span>.</p>
<p class="Pp">(You can combine steps 1 and 2 with the &quot;new_from_file&quot;
    or &quot;new_from_content&quot; methods.)</p>
<p class="Pp">2b. call
    <span class="Li">&quot;$root-&gt;elementify()&quot;</span> if you want.</p>
<p class="Pp">3. do whatever you need to do with the syntax tree, presumably
    involving traversing it looking for some bit of information in it,</p>
<p class="Pp">4. previous versions of HTML::TreeBuilder required you to call
    <span class="Li">&quot;$tree-&gt;delete()&quot;</span> to erase the contents
    of the tree from memory when you're done with the tree. This is not normally
    required anymore. See &quot;Weak References&quot; in HTML::Element for
    details.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ATTRIBUTES"><a class="permalink" href="#ATTRIBUTES">ATTRIBUTES</a></h1>
<p class="Pp">Most of the following attributes native to HTML::TreeBuilder
    control how parsing takes place; they should be set <i>before</i> you try
    parsing into the given object. You can set the attributes by passing a TRUE
    or FALSE value as argument. E.g.,
    <span class="Li">&quot;$root-&gt;implicit_tags&quot;</span> returns the
    current setting for the <span class="Li">&quot;implicit_tags&quot;</span>
    option, <span class="Li">&quot;$root-&gt;implicit_tags(1)&quot;</span> turns
    that option on, and
    <span class="Li">&quot;$root-&gt;implicit_tags(0)&quot;</span> turns it
  off.</p>
<section class="Ss">
<h2 class="Ss" id="implicit_tags"><a class="permalink" href="#implicit_tags">implicit_tags</a></h2>
<p class="Pp">Setting this attribute to true will instruct the parser to try to
    deduce implicit elements and implicit end tags. If it is false you get a
    parse tree that just reflects the text as it stands, which is unlikely to be
    useful for anything but quick and dirty parsing. (In fact, I'd be curious to
    hear from anyone who finds it useful to have
    <span class="Li">&quot;implicit_tags&quot;</span> set to false.) Default is
    true.</p>
<p class="Pp">Implicit elements have the &quot;implicit&quot; in HTML::Element
    attribute set.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="implicit_body_p_tag"><a class="permalink" href="#implicit_body_p_tag">implicit_body_p_tag</a></h2>
<p class="Pp">This controls an aspect of implicit element behavior, if
    <span class="Li">&quot;implicit_tags&quot;</span> is on: If a text element
    (PCDATA) or a phrasal element (such as
    <span class="Li">&quot;&lt;em&gt;&quot;</span>) is to be inserted under
    <span class="Li">&quot;&lt;body&gt;&quot;</span>, two things can happen: if
    <span class="Li">&quot;implicit_body_p_tag&quot;</span> is true, it's placed
    under a new, implicit <span class="Li">&quot;&lt;p&gt;&quot;</span> tag.
    (Past DTDs suggested this was the only correct behavior, and this is how
    past versions of this module behaved.) But if
    <span class="Li">&quot;implicit_body_p_tag&quot;</span> is false, nothing is
    implicated -- the PCDATA or phrasal element is simply placed under
    <span class="Li">&quot;&lt;body&gt;&quot;</span>. Default is false.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="no_expand_entities"><a class="permalink" href="#no_expand_entities">no_expand_entities</a></h2>
<p class="Pp">This attribute controls whether entities are decoded during the
    initial parse of the source. Enable this if you don't want entities decoded
    to their character value. e.g. '&amp;amp;' is decoded to '&amp;' by default,
    but will be unchanged if this is enabled. Default is false (entities will be
    decoded.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ignore_unknown"><a class="permalink" href="#ignore_unknown">ignore_unknown</a></h2>
<p class="Pp">This attribute controls whether unknown tags should be represented
    as elements in the parse tree, or whether they should be ignored. Default is
    true (to ignore unknown tags.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ignore_text"><a class="permalink" href="#ignore_text">ignore_text</a></h2>
<p class="Pp">Do not represent the text content of elements. This saves space if
    all you want is to examine the structure of the document. Default is
  false.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ignore_ignorable_whitespace"><a class="permalink" href="#ignore_ignorable_whitespace">ignore_ignorable_whitespace</a></h2>
<p class="Pp">If set to true, TreeBuilder will try to avoid creating ignorable
    whitespace text nodes in the tree. Default is true. (In fact, I'd be
    interested in hearing if there's ever a case where you need this off, or
    where leaving it on leads to incorrect behavior.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="no_space_compacting"><a class="permalink" href="#no_space_compacting">no_space_compacting</a></h2>
<p class="Pp">This determines whether TreeBuilder compacts all whitespace
    strings in the document (well, outside of PRE or TEXTAREA elements), or
    leaves them alone. Normally (default, value of 0), each string of contiguous
    whitespace in the document is turned into a single space. But that's not
    done if <span class="Li">&quot;no_space_compacting&quot;</span> is set to
  1.</p>
<p class="Pp">Setting <span class="Li">&quot;no_space_compacting&quot;</span> to
    1 might be useful if you want to read in a tree just to make some minor
    changes to it before writing it back out.</p>
<p class="Pp">This method is experimental. If you use it, be sure to report any
    problems you might have with it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="p_strict"><a class="permalink" href="#p_strict">p_strict</a></h2>
<p class="Pp">If set to true (and it defaults to false), TreeBuilder will take a
    narrower than normal view of what can be under a
    <span class="Li">&quot;&lt;p&gt;&quot;</span> element; if it sees a
    non-phrasal element about to be inserted under a
    <span class="Li">&quot;&lt;p&gt;&quot;</span>, it will close that
    <span class="Li">&quot;&lt;p&gt;&quot;</span>. Otherwise it will close
    <span class="Li">&quot;&lt;p&gt;&quot;</span> elements only for other
    <span class="Li">&quot;&lt;p&gt;&quot;</span>'s, headings, and
    <span class="Li">&quot;&lt;form&gt;&quot;</span> (although the latter may be
    removed in future versions).</p>
<p class="Pp">For example, when going thru this snippet of code,</p>
<p class="Pp"></p>
<pre>  &lt;p&gt;stuff
  &lt;ul&gt;
</pre>
<p class="Pp">TreeBuilder will normally (with
    <span class="Li">&quot;p_strict&quot;</span> false) put the
    <span class="Li">&quot;&lt;ul&gt;&quot;</span> element under the
    <span class="Li">&quot;&lt;p&gt;&quot;</span> element. However, with
    <span class="Li">&quot;p_strict&quot;</span> set to true, it will close the
    <span class="Li">&quot;&lt;p&gt;&quot;</span> first.</p>
<p class="Pp">In theory, there should be strictness options like this for
    other/all elements besides just
    <span class="Li">&quot;&lt;p&gt;&quot;</span>; but I treat this as a special
    case simply because of the fact that
    <span class="Li">&quot;&lt;p&gt;&quot;</span> occurs so frequently and its
    end-tag is omitted so often; and also because application of strictness
    rules at parse-time across all elements often makes tiny errors in HTML
    coding produce drastically bad parse-trees, in my experience.</p>
<p class="Pp">If you find that you wish you had an option like this to enforce
    content-models on all elements, then I suggest that what you want is
    content-model checking as a stage after TreeBuilder has finished
  parsing.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="store_comments"><a class="permalink" href="#store_comments">store_comments</a></h2>
<p class="Pp">This determines whether TreeBuilder will normally store comments
    found while parsing content into <span class="Li">$root</span>. Currently,
    this is off by default.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="store_declarations"><a class="permalink" href="#store_declarations">store_declarations</a></h2>
<p class="Pp">This determines whether TreeBuilder will normally store markup
    declarations found while parsing content into <span class="Li">$root</span>.
    This is on by default.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="store_pis"><a class="permalink" href="#store_pis">store_pis</a></h2>
<p class="Pp">This determines whether TreeBuilder will normally store processing
    instructions found while parsing content into <span class="Li">$root</span>
    -- assuming a recent version of HTML::Parser (old versions won't parse PIs
    correctly). Currently, this is off (false) by default.</p>
<p class="Pp">It is somewhat of a known bug (to be fixed one of these days, if
    anyone needs it?) that PIs in the preamble (before the
    <span class="Li">&quot;&lt;html&gt;&quot;</span> start-tag) end up actually
    <i>under</i> the <span class="Li">&quot;&lt;html&gt;&quot;</span>
  element.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="warn"><a class="permalink" href="#warn">warn</a></h2>
<p class="Pp">This determines whether syntax errors during parsing should
    generate warnings, emitted via Perl's
    <span class="Li">&quot;warn&quot;</span> function.</p>
<p class="Pp">This is off (false) by default.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<p class="Pp">Objects of this class inherit the methods of both HTML::Parser and
    HTML::Element. The methods inherited from HTML::Parser are used for building
    the HTML tree, and the methods inherited from HTML::Element are what you use
    to scrutinize the tree. Besides this (HTML::TreeBuilder) documentation, you
    must also carefully read the HTML::Element documentation, and also skim the
    HTML::Parser documentation -- probably only its parse and parse_file methods
    are of interest.</p>
<section class="Ss">
<h2 class="Ss" id="new_from_file"><a class="permalink" href="#new_from_file">new_from_file</a></h2>
<pre>  $root = HTML::TreeBuilder-&gt;new_from_file($filename_or_filehandle);
</pre>
<p class="Pp">This &quot;shortcut&quot; constructor merely combines constructing
    a new object (with the &quot;new&quot; method, below), and calling
    <span class="Li">&quot;$new-&gt;parse_file(...)&quot;</span> on it. Returns
    the new object. Note that this provides no way of setting any parse options
    like <span class="Li">&quot;store_comments&quot;</span> (for that, call
    <span class="Li">&quot;new&quot;</span>, and then set options, before
    calling <span class="Li">&quot;parse_file&quot;</span>). See the notes
    (below) on parameters to &quot;parse_file&quot;.</p>
<p class="Pp">If HTML::TreeBuilder is unable to read the file, then
    <span class="Li">&quot;new_from_file&quot;</span> dies. The error can also
    be found in <span class="Li">$!</span>. (This behavior is new in HTML-Tree
    5. Previous versions returned a tree with only implicit elements.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="new_from_content"><a class="permalink" href="#new_from_content">new_from_content</a></h2>
<pre>  $root = HTML::TreeBuilder-&gt;new_from_content(...);
</pre>
<p class="Pp">This &quot;shortcut&quot; constructor merely combines constructing
    a new object (with the &quot;new&quot; method, below), and calling
    <span class="Li">&quot;for(...){$new-&gt;parse($_)}&quot;</span> and
    <span class="Li">&quot;$new-&gt;eof&quot;</span> on it. Returns the new
    object. Note that this provides no way of setting any parse options like
    <span class="Li">&quot;store_comments&quot;</span> (for that, call
    <span class="Li">&quot;new&quot;</span>, and then set options, before
    calling <span class="Li">&quot;parse&quot;</span>). Example usages:
    <span class="Li">&quot;HTML::TreeBuilder-&gt;new_from_content(@lines)&quot;</span>,
    or
    <span class="Li">&quot;HTML::TreeBuilder-&gt;new_from_content($content)&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="new_from_url"><a class="permalink" href="#new_from_url">new_from_url</a></h2>
<pre>  $root = HTML::TreeBuilder-&gt;new_from_url($url)
</pre>
<p class="Pp">This &quot;shortcut&quot; constructor combines constructing a new
    object (with the &quot;new&quot; method, below), loading LWP::UserAgent,
    fetching the specified URL, and calling
    <span class="Li">&quot;$new-&gt;parse(
    $response-&gt;decoded_content)&quot;</span> and
    <span class="Li">&quot;$new-&gt;eof&quot;</span> on it. Returns the new
    object. Note that this provides no way of setting any parse options like
    <span class="Li">&quot;store_comments&quot;</span>.</p>
<p class="Pp">If LWP is unable to fetch the URL, or the response is not HTML (as
    determined by &quot;content_is_html&quot; in HTTP::Headers), then
    <span class="Li">&quot;new_from_url&quot;</span> dies, and the
    HTTP::Response object is found in
    <span class="Li">$HTML::TreeBuilder::lwp_response</span>.</p>
<p class="Pp">You must have installed LWP::UserAgent for this method to work.
    LWP is not installed automatically, because it's a large set of modules and
    you might not need it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
<pre>  $root = HTML::TreeBuilder-&gt;new();
</pre>
<p class="Pp">This creates a new HTML::TreeBuilder object. This method takes no
    attributes.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="parse_file"><a class="permalink" href="#parse_file">parse_file</a></h2>
<pre> $root-&gt;parse_file(...)
</pre>
<p class="Pp">[An important method inherited from HTML::Parser, which see.
    Current versions of HTML::Parser can take a filespec, or a filehandle
    object, like *FOO, or some object from class IO::Handle, IO::File,
    IO::Socket) or the like. I think you should check that a given file exists
    <i>before</i> calling
    <span class="Li">&quot;$root-&gt;parse_file($filespec)&quot;</span>.]</p>
<p class="Pp">When you pass a filename to
    <span class="Li">&quot;parse_file&quot;</span>, HTML::Parser opens it in
    binary mode, which means it's interpreted as Latin-1 (ISO-8859-1). If the
    file is in another encoding, like UTF-8 or UTF-16, this will not do the
    right thing.</p>
<p class="Pp">One solution is to open the file yourself using the proper
    <span class="Li">&quot;:encoding&quot;</span> layer, and pass the filehandle
    to <span class="Li">&quot;parse_file&quot;</span>. You can automate this
    process by using &quot;html_file&quot; in IO::HTML, which will use the HTML5
    encoding sniffing algorithm to automatically determine the proper
    <span class="Li">&quot;:encoding&quot;</span> layer and apply it.</p>
<p class="Pp">In the next major release of HTML-Tree, I plan to have it use
    IO::HTML automatically. If you really want your file opened in binary mode,
    you should open it yourself and pass the filehandle to
    <span class="Li">&quot;parse_file&quot;</span>.</p>
<p class="Pp">The return value is <span class="Li">&quot;undef&quot;</span> if
    there's an error opening the file. In that case, the error will be in
    <span class="Li">$!</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="parse"><a class="permalink" href="#parse">parse</a></h2>
<pre>  $root-&gt;parse(...)
</pre>
<p class="Pp">[A important method inherited from HTML::Parser, which see. See
    the note below for <span class="Li">&quot;$root-&gt;eof()&quot;</span>.]</p>
</section>
<section class="Ss">
<h2 class="Ss" id="eof"><a class="permalink" href="#eof">eof</a></h2>
<pre>  $root-&gt;eof();
</pre>
<p class="Pp">This signals that you're finished parsing content into this tree;
    this runs various kinds of crucial cleanup on the tree. This is called
    <i>for you</i> when you call
    <span class="Li">&quot;$root-&gt;parse_file(...)&quot;</span>, but not when
    you call <span class="Li">&quot;$root-&gt;parse(...)&quot;</span>. So if you
    call <span class="Li">&quot;$root-&gt;parse(...)&quot;</span>, then you
    <i>must</i> call <span class="Li">&quot;$root-&gt;eof()&quot;</span> once
    you've finished feeding all the chunks to
    <span class="Li">&quot;parse(...)&quot;</span>, and before you actually
    start doing anything else with the tree in
  <span class="Li">$root</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="parse_content"><a class="permalink" href="#parse_content">parse_content</a></h2>
<pre>  $root-&gt;parse_content(...);
</pre>
<p class="Pp">Basically a handy alias for
    <span class="Li">&quot;$root-&gt;parse(...); $root-&gt;eof&quot;</span>.
    Takes the exact same arguments as
    <span class="Li">&quot;$root-&gt;parse()&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="delete"><a class="permalink" href="#delete">delete</a></h2>
<pre>  $root-&gt;delete();
</pre>
<p class="Pp">[A previously important method inherited from HTML::Element, which
    see.]</p>
</section>
<section class="Ss">
<h2 class="Ss" id="elementify"><a class="permalink" href="#elementify">elementify</a></h2>
<pre>  $root-&gt;elementify();
</pre>
<p class="Pp">This changes the class of the object in
    <span class="Li">$root</span> from HTML::TreeBuilder to the class used for
    all the rest of the elements in that tree (generally HTML::Element). Returns
    <span class="Li">$root</span>.</p>
<p class="Pp">For most purposes, this is unnecessary, but if you call this after
    (after!!) you've finished building a tree, then it keeps you from
    accidentally trying to call anything but HTML::Element methods on it. (I.e.,
    if you accidentally call
    <span class="Li">&quot;$root-&gt;parse_file(...)&quot;</span> on the
    already-complete and elementified tree, then instead of charging ahead and
    <i>wreaking havoc</i>, it'll throw a fatal error -- since
    <span class="Li">$root</span> is now an object just of class HTML::Element
    which has no <span class="Li">&quot;parse_file&quot;</span> method.</p>
<p class="Pp">Note that <span class="Li">&quot;elementify&quot;</span> currently
    deletes all the private attributes of <span class="Li">$root</span> except
    for &quot;_tag&quot;, &quot;_parent&quot;, &quot;_content&quot;,
    &quot;_pos&quot;, and &quot;_implicit&quot;. If anyone requests that I
    change this to leave in yet more private attributes, I might do so, in
    future versions.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="guts"><a class="permalink" href="#guts">guts</a></h2>
<pre> @nodes = $root-&gt;guts();
 $parent_for_nodes = $root-&gt;guts();
</pre>
<p class="Pp">In list context (as in the first case), this method returns the
    topmost non-implicit nodes in a tree. This is useful when you're parsing
    HTML code that you know doesn't expect an HTML document, but instead just a
    fragment of an HTML document. For example, if you wanted the parse tree for
    a file consisting of just this:</p>
<p class="Pp"></p>
<pre>  &lt;li&gt;I like pie!
</pre>
<p class="Pp">Then you would get that with <span class="Li">&quot;@nodes =
    $root-&gt;guts();&quot;</span>. It so happens that in this case,
    <span class="Li">@nodes</span> will contain just one element object,
    representing the <span class="Li">&quot;&lt;li&gt;&quot;</span> node (with
    &quot;I like pie!&quot; being its text child node). However, consider if you
    were parsing this:</p>
<p class="Pp"></p>
<pre>  &lt;hr&gt;Hooboy!&lt;hr&gt;
</pre>
<p class="Pp">In that case, <span class="Li">&quot;$root-&gt;guts()&quot;</span>
    would return three items: an element object for the first
    <span class="Li">&quot;&lt;hr&gt;&quot;</span>, a text string
    &quot;Hooboy!&quot;, and another
    <span class="Li">&quot;&lt;hr&gt;&quot;</span> element object.</p>
<p class="Pp">For cases where you want definitely one element (so you can treat
    it as a &quot;document fragment&quot;, roughly speaking), call
    <span class="Li">&quot;guts()&quot;</span> in scalar context, as in
    <span class="Li">&quot;$parent_for_nodes = $root-&gt;guts()&quot;</span>.
    That works like <span class="Li">&quot;guts()&quot;</span> in list context;
    in fact, <span class="Li">&quot;guts()&quot;</span> in list context would
    have returned exactly one value, and if it would have been an object (as
    opposed to a text string), then that's what
    <span class="Li">&quot;guts&quot;</span> in scalar context will return.
    Otherwise, if <span class="Li">&quot;guts()&quot;</span> in list context
    would have returned no values at all, then
    <span class="Li">&quot;guts()&quot;</span> in scalar context returns undef.
    In all other cases, <span class="Li">&quot;guts()&quot;</span> in scalar
    context returns an implicit <span class="Li">&quot;&lt;div&gt;&quot;</span>
    element node, with children consisting of whatever nodes
    <span class="Li">&quot;guts()&quot;</span> in list context would have
    returned. Note that that may detach those nodes from
    <span class="Li">$root</span>'s tree.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="disembowel"><a class="permalink" href="#disembowel">disembowel</a></h2>
<pre>  @nodes = $root-&gt;disembowel();
  $parent_for_nodes = $root-&gt;disembowel();
</pre>
<p class="Pp">The <span class="Li">&quot;disembowel()&quot;</span> method works
    just like the <span class="Li">&quot;guts()&quot;</span> method, except that
    disembowel definitively destroys the tree above the nodes that are returned.
    Usually when you want the guts from a tree, you're just going to toss out
    the rest of the tree anyway, so this saves you the bother. (Remember,
    &quot;disembowel&quot; means &quot;remove the guts from&quot;.)</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="INTERNAL_METHODS"><a class="permalink" href="#INTERNAL_METHODS">INTERNAL
  METHODS</a></h1>
<p class="Pp">You should not need to call any of the following methods
  directly.</p>
<section class="Ss">
<h2 class="Ss" id="element_class"><a class="permalink" href="#element_class">element_class</a></h2>
<pre>  $classname = $h-&gt;element_class;
</pre>
<p class="Pp">This method returns the class which will be used for new elements.
    It defaults to HTML::Element, but can be overridden by subclassing or
    esoteric means best left to those will will read the source and then not
    complain when those esoteric means change. (Just subclass.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="comment"><a class="permalink" href="#comment">comment</a></h2>
<p class="Pp">Accept a &quot;here's a comment&quot; signal from
  HTML::Parser.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="declaration"><a class="permalink" href="#declaration">declaration</a></h2>
<p class="Pp">Accept a &quot;here's a markup declaration&quot; signal from
    HTML::Parser.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="done"><a class="permalink" href="#done">done</a></h2>
<p class="Pp">TODO: document</p>
</section>
<section class="Ss">
<h2 class="Ss" id="end"><a class="permalink" href="#end">end</a></h2>
<p class="Pp">Either: Acccept an end-tag signal from HTML::Parser Or: Method for
    closing currently open elements in some fairly complex way, as used by other
    methods in this class.</p>
<p class="Pp">TODO: Why is this hidden?</p>
</section>
<section class="Ss">
<h2 class="Ss" id="process"><a class="permalink" href="#process">process</a></h2>
<p class="Pp">Accept a &quot;here's a PI&quot; signal from HTML::Parser.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="start"><a class="permalink" href="#start">start</a></h2>
<p class="Pp">Accept a signal from HTML::Parser for start-tags.</p>
<p class="Pp">TODO: Why is this hidden?</p>
</section>
<section class="Ss">
<h2 class="Ss" id="stunt"><a class="permalink" href="#stunt">stunt</a></h2>
<p class="Pp">TODO: document</p>
</section>
<section class="Ss">
<h2 class="Ss" id="stunted"><a class="permalink" href="#stunted">stunted</a></h2>
<p class="Pp">TODO: document</p>
</section>
<section class="Ss">
<h2 class="Ss" id="text"><a class="permalink" href="#text">text</a></h2>
<p class="Pp">Accept a &quot;here's a text token&quot; signal from
  HTML::Parser.</p>
<p class="Pp">TODO: Why is this hidden?</p>
</section>
<section class="Ss">
<h2 class="Ss" id="tighten_up"><a class="permalink" href="#tighten_up">tighten_up</a></h2>
<p class="Pp">Legacy</p>
<p class="Pp">Redirects to &quot;delete_ignorable_whitespace&quot; in
    HTML::Element.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="warning"><a class="permalink" href="#warning">warning</a></h2>
<p class="Pp">Wrapper for CORE::warn</p>
<p class="Pp">TODO: why not just use carp?</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SUBROUTINES"><a class="permalink" href="#SUBROUTINES">SUBROUTINES</a></h1>
<section class="Ss">
<h2 class="Ss">DEBUG</h2>
<p class="Pp">Are we in Debug mode? This is a constant subroutine, to allow
    compile-time optimizations. To control debug mode, set
    <span class="Li">$HTML::TreeBuilder::DEBUG</span> <i>before</i> loading
    HTML::TreeBuilder.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="HTML_AND_ITS_DISCONTENTS"><a class="permalink" href="#HTML_AND_ITS_DISCONTENTS">HTML
  AND ITS DISCONTENTS</a></h1>
<p class="Pp">HTML is rather harder to parse than people who write it generally
    suspect.</p>
<p class="Pp">Here's the problem: HTML is a kind of SGML that permits
    &quot;minimization&quot; and &quot;implication&quot;. In short, this means
    that you don't have to close every tag you open (because the opening of a
    subsequent tag may implicitly close it), and if you use a tag that can't
    occur in the context you seem to using it in, under certain conditions the
    parser will be able to realize you mean to leave the current context and
    enter the new one, that being the only one that your code could correctly be
    interpreted in.</p>
<p class="Pp">Now, this would all work flawlessly and unproblematically if: 1)
    all the rules that both prescribe and describe HTML were (and had been)
    clearly set out, and 2) everyone was aware of these rules and wrote their
    code in compliance to them.</p>
<p class="Pp">However, it didn't happen that way, and so most HTML pages are
    difficult if not impossible to correctly parse with nearly any set of
    straightforward SGML rules. That's why the internals of HTML::TreeBuilder
    consist of lots and lots of special cases -- instead of being just a generic
    SGML parser with HTML DTD rules plugged in.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="TRANSLATIONS?"><a class="permalink" href="#TRANSLATIONS?">TRANSLATIONS?</a></h1>
<p class="Pp">The techniques that HTML::TreeBuilder uses to perform what I
    consider very robust parses on everyday code are not things that can work
    only in Perl. To date, the algorithms at the center of HTML::TreeBuilder
    have been implemented only in Perl, as far as I know; and I don't foresee
    getting around to implementing them in any other language any time soon.</p>
<p class="Pp">If, however, anyone is looking for a semester project for an
    applied programming class (or if they merely enjoy <i>extra-curricular</i>
    masochism), they might do well to see about choosing as a topic the
    implementation/adaptation of these routines to any other interesting
    programming language that you feel currently suffers from a lack of robust
    HTML-parsing. I welcome correspondence on this subject, and point out that
    one can learn a great deal about languages by trying to translate between
    them, and then comparing the result.</p>
<p class="Pp">The HTML::TreeBuilder source may seem long and complex, but it is
    rather well commented, and symbol names are generally self-explanatory. (You
    are encouraged to read the Mozilla HTML parser source for comparison.) Some
    of the complexity comes from little-used features, and some of it comes from
    having the HTML tokenizer (HTML::Parser) being a separate module, requiring
    somewhat of a different interface than you'd find in a combined tokenizer
    and tree-builder. But most of the length of the source comes from the fact
    that it's essentially a long list of special cases, with lots and lots of
    sanity-checking, and sanity-recovery -- because, as Roseanne Rosannadanna
    once said, &quot;it's always <i>something</i>&quot;.</p>
<p class="Pp">Users looking to compare several HTML parsers should look at the
    source for Raggett's Tidy
    (<span class="Li">&quot;&lt;http://www.w3.org/People/Raggett/tidy/&gt;&quot;</span>),
    Mozilla
    (<span class="Li">&quot;&lt;http://www.mozilla.org/&gt;&quot;</span>), and
    possibly root around the browsers section of Yahoo to find the various
    open-source ones
    (<span class="Li">&quot;&lt;http://dir.yahoo.com/Computers_and_Internet/Software/Internet/World_Wide_Web/Browsers/&gt;&quot;</span>).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">* Framesets seem to work correctly now. Email me if you get a
    strange parse from a document with framesets.</p>
<p class="Pp">* Really bad HTML code will, often as not, make for a somewhat
    objectionable parse tree. Regrettable, but unavoidably true.</p>
<p class="Pp">* If you're running with
    <span class="Li">&quot;implicit_tags&quot;</span> off (God help you!),
    consider that <span class="Li">&quot;$tree-&gt;content_list&quot;</span>
    probably contains the tree or grove from the parse, and not
    <span class="Li">$tree</span> itself (which will, oddly enough, be an
    implicit <span class="Li">&quot;&lt;html&gt;&quot;</span> element). This
    seems counter-intuitive and problematic; but seeing as how almost no HTML
    ever parses correctly with <span class="Li">&quot;implicit_tags&quot;</span>
    off, this interface oddity seems the least of your problems.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUG_REPORTS"><a class="permalink" href="#BUG_REPORTS">BUG
  REPORTS</a></h1>
<p class="Pp">When a document parses in a way different from how you think it
    should, I ask that you report this to me as a bug. The first thing you
    should do is copy the document, trim out as much of it as you can while
    still producing the bug in question, and <i>then</i> email me that
    mini-document <i>and</i> the code you're using to parse it, to the
    HTML::Tree bug queue at
    <span class="Li">&quot;&lt;bug-html-tree&#x00A0;at&#x00A0;rt.cpan.org&gt;&quot;</span>.</p>
<p class="Pp">Include a note as to how it parses (presumably including its
    <span class="Li">&quot;$tree-&gt;dump&quot;</span> output), and then a
    <i>careful and clear</i> explanation of where you think the parser is going
    astray, and how you would prefer that it work instead.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">For more information about the HTML-Tree distribution:
  HTML::Tree.</p>
<p class="Pp">Modules used by HTML::TreeBuilder: HTML::Parser, HTML::Element,
    HTML::Tagset.</p>
<p class="Pp">For converting between XML::DOM::Node, HTML::Element, and
    XML::Element trees: HTML::DOMbo.</p>
<p class="Pp">For opening a HTML file with automatic charset detection:
    IO::HTML.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Current maintainers:</p>
<ul class="Bl-bullet">
  <li>Christopher J. Madsen
      <span class="Li">&quot;&lt;perl&#x00A0;AT&#x00A0;cjmweb.net&gt;&quot;</span></li>
  <li>Jeff Fearn
      <span class="Li">&quot;&lt;jfearn&#x00A0;AT&#x00A0;cpan.org&gt;&quot;</span></li>
</ul>
<p class="Pp">Original HTML-Tree author:</p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>Gisle Aas</dd>
</dl>
<p class="Pp">Former maintainers:</p>
<ul class="Bl-bullet">
  <li>Sean M. Burke</li>
  <li>Andy Lester</li>
  <li>Pete Krawczyk
      <span class="Li">&quot;&lt;petek&#x00A0;AT&#x00A0;cpan.org&gt;&quot;</span></li>
</ul>
<p class="Pp">You can follow or contribute to HTML-Tree's development at
    &lt;https://github.com/kentfredric/HTML-Tree&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">Copyright 1995-1998 Gisle Aas, 1999-2004 Sean M. Burke, 2005 Andy
    Lester, 2006 Pete Krawczyk, 2010 Jeff Fearn, 2012 Christopher J. Madsen.</p>
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">The programs in this library are distributed in the hope that they
    will be useful, but without any warranty; without even the implied warranty
    of merchantability or fitness for a particular purpose.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2024-02-10</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

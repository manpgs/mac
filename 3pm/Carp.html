<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Carp(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Carp(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Carp(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Carp - alternative warn and die for modules</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use Carp;
    # warn user (from perspective of caller)
    carp &quot;string trimmed to 80 chars&quot;;
    # die of errors (from perspective of caller)
    croak &quot;We're outta here!&quot;;
    # die of errors with stack backtrace
    confess &quot;not implemented&quot;;
    # cluck, longmess and shortmess not exported by default
    use Carp qw(cluck longmess shortmess);
    cluck &quot;This is how we got here!&quot;; # warn with stack backtrace
    $long_message   = longmess( &quot;message from cluck() or confess()&quot; );
    $short_message  = shortmess( &quot;message from carp() or croak()&quot; );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The Carp routines are useful in your own modules because they act
    like <span class="Li">&quot;die()&quot;</span> or
    <span class="Li">&quot;warn()&quot;</span>, but with a message which is more
    likely to be useful to a user of your module. In the case of
    <span class="Li">&quot;cluck()&quot;</span> and
    <span class="Li">&quot;confess()&quot;</span>, that context is a summary of
    every call in the call-stack; <span class="Li">&quot;longmess()&quot;</span>
    returns the contents of the error message.</p>
<p class="Pp">For a shorter message you can use
    <span class="Li">&quot;carp()&quot;</span> or
    <span class="Li">&quot;croak()&quot;</span> which report the error as being
    from where your module was called.
    <span class="Li">&quot;shortmess()&quot;</span> returns the contents of this
    error message. There is no guarantee that that is where the error was, but
    it is a good educated guess.</p>
<p class="Pp"><span class="Li">&quot;Carp&quot;</span> takes care not to clobber
    the status variables <span class="Li">$!</span> and
    <span class="Li">$^E</span> in the course of assembling its error messages.
    This means that a <span class="Li">$SIG{__DIE__}</span> or
    <span class="Li">$SIG{__WARN__}</span> handler can capture the error
    information held in those variables, if it is required to augment the error
    message, and if the code calling <span class="Li">&quot;Carp&quot;</span>
    left useful values there. Of course,
    <span class="Li">&quot;Carp&quot;</span> can't guarantee the latter.</p>
<p class="Pp">You can also alter the way the output and logic of
    <span class="Li">&quot;Carp&quot;</span> works, by changing some global
    variables in the <span class="Li">&quot;Carp&quot;</span> namespace. See the
    section on <span class="Li">&quot;GLOBAL VARIABLES&quot;</span> below.</p>
<p class="Pp">Here is a more complete description of how
    <span class="Li">&quot;carp&quot;</span> and
    <span class="Li">&quot;croak&quot;</span> work. What they do is search the
    call-stack for a function call stack where they have not been told that
    there shouldn't be an error. If every call is marked safe, they give up and
    give a full stack backtrace instead. In other words they presume that the
    first likely looking potential suspect is guilty. Their rules for telling
    whether a call shouldn't generate errors work as follows:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>Any call from a package to itself is safe.</dd>
  <dt>2.</dt>
  <dd>Packages claim that there won't be errors on calls to or from packages
      explicitly marked as safe by inclusion in
      <span class="Li">@CARP_NOT</span>, or (if that array is empty)
      <span class="Li">@ISA</span>. The ability to override what
      <span class="Li">@ISA</span> says is new in 5.8.</dd>
  <dt>3.</dt>
  <dd>The trust in item 2 is transitive. If A trusts B, and B trusts C, then A
      trusts C. So if you do not override <span class="Li">@ISA</span> with
      <span class="Li">@CARP_NOT</span>, then this trust relationship is
      identical to, &quot;inherits from&quot;.</dd>
  <dt>4.</dt>
  <dd>Any call from an internal Perl module is safe. (Nothing keeps user modules
      from marking themselves as internal to Perl, but this practice is
      discouraged.)</dd>
  <dt>5.</dt>
  <dd>Any call to Perl's warning system (eg Carp itself) is safe. (This rule is
      what keeps it from reporting the error at the point where you call
      <span class="Li">&quot;carp&quot;</span> or
      <span class="Li">&quot;croak&quot;</span>.)</dd>
  <dt>6.</dt>
  <dd><span class="Li">$Carp::CarpLevel</span> can be set to skip a fixed number
      of additional call levels. Using this is not recommended because it is
      very difficult to get it to behave correctly.</dd>
</dl>
<section class="Ss">
<h2 class="Ss" id="Forcing_a_Stack_Trace"><a class="permalink" href="#Forcing_a_Stack_Trace">Forcing
  a Stack Trace</a></h2>
<p class="Pp">As a debugging aid, you can force Carp to treat a croak as a
    confess and a carp as a cluck across <i>all</i> modules. In other words,
    force a detailed stack trace to be given. This can be very helpful when
    trying to understand why, or from where, a warning or error is being
    generated.</p>
<p class="Pp">This feature is enabled by 'importing' the non-existent symbol
    'verbose'. You would typically enable it by saying</p>
<p class="Pp"></p>
<pre>    perl -MCarp=verbose script.pl
</pre>
<p class="Pp">or by including the string
    <span class="Li">&quot;-MCarp=verbose&quot;</span> in the PERL5OPT
    environment variable.</p>
<p class="Pp">Alternately, you can set the global variable
    <span class="Li">$Carp::Verbose</span> to true. See the
    <span class="Li">&quot;GLOBAL VARIABLES&quot;</span> section below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Stack_Trace_formatting"><a class="permalink" href="#Stack_Trace_formatting">Stack
  Trace formatting</a></h2>
<p class="Pp">At each stack level, the subroutine's name is displayed along with
    its parameters. For simple scalars, this is sufficient. For complex data
    types, such as objects and other references, this can simply display
    <span class="Li">'HASH(0x1ab36d8)'</span>.</p>
<p class="Pp">Carp gives two ways to control this.</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>For objects, a method, <span class="Li">&quot;CARP_TRACE&quot;</span>,
      will be called, if it exists. If this method doesn't exist, or it recurses
      into <span class="Li">&quot;Carp&quot;</span>, or it otherwise throws an
      exception, this is skipped, and Carp moves on to the next option,
      otherwise checking stops and the string returned is used. It is
      recommended that the object's type is part of the string to make debugging
      easier.</dd>
  <dt>2.</dt>
  <dd>For any type of reference, <span class="Li">$Carp::RefArgFormatter</span>
      is checked (see below). This variable is expected to be a code reference,
      and the current parameter is passed in. If this function doesn't exist
      (the variable is undef), or it recurses into
      <span class="Li">&quot;Carp&quot;</span>, or it otherwise throws an
      exception, this is skipped, and Carp moves on to the next option,
      otherwise checking stops and the string returned is used.</dd>
  <dt>3.</dt>
  <dd>Otherwise, if neither <span class="Li">&quot;CARP_TRACE&quot;</span> nor
      <span class="Li">$Carp::RefArgFormatter</span> is available, stringify the
      value ignoring any overloading.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="GLOBAL_VARIABLES"><a class="permalink" href="#GLOBAL_VARIABLES">GLOBAL
  VARIABLES</a></h1>
<section class="Ss">
<h2 class="Ss" id="$Carp::MaxEvalLen"><a class="permalink" href="#$Carp::MaxEvalLen">$Carp::MaxEvalLen</a></h2>
<p class="Pp">This variable determines how many characters of a string-eval are
    to be shown in the output. Use a value of <span class="Li">0</span> to show
    all text.</p>
<p class="Pp">Defaults to <span class="Li">0</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$Carp::MaxArgLen"><a class="permalink" href="#$Carp::MaxArgLen">$Carp::MaxArgLen</a></h2>
<p class="Pp">This variable determines how many characters of each argument to a
    function to print. Use a value of <span class="Li">0</span> to show the full
    length of the argument.</p>
<p class="Pp">Defaults to <span class="Li">64</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$Carp::MaxArgNums"><a class="permalink" href="#$Carp::MaxArgNums">$Carp::MaxArgNums</a></h2>
<p class="Pp">This variable determines how many arguments to each function to
    show. Use a false value to show all arguments to a function call. To
    suppress all arguments, use <span class="Li">&quot;-1&quot;</span> or
    <span class="Li">'0 but true'</span>.</p>
<p class="Pp">Defaults to <span class="Li">8</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$Carp::Verbose"><a class="permalink" href="#$Carp::Verbose">$Carp::Verbose</a></h2>
<p class="Pp">This variable makes <span class="Li">&quot;carp()&quot;</span> and
    <span class="Li">&quot;croak()&quot;</span> generate stack backtraces just
    like <span class="Li">&quot;cluck()&quot;</span> and
    <span class="Li">&quot;confess()&quot;</span>. This is how
    <span class="Li">&quot;use Carp 'verbose'&quot;</span> is implemented
    internally.</p>
<p class="Pp">Defaults to <span class="Li">0</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$Carp::RefArgFormatter"><a class="permalink" href="#$Carp::RefArgFormatter">$Carp::RefArgFormatter</a></h2>
<p class="Pp">This variable sets a general argument formatter to display
    references. Plain scalars and objects that implement
    <span class="Li">&quot;CARP_TRACE&quot;</span> will not go through this
    formatter. Calling <span class="Li">&quot;Carp&quot;</span> from within this
    function is not supported.</p>
<p class="Pp"></p>
<pre>    local $Carp::RefArgFormatter = sub {
        require Data::Dumper;
        Data::Dumper-&gt;Dump($_[0]); # not necessarily safe
    };
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="@CARP_NOT"><a class="permalink" href="#@CARP_NOT">@CARP_NOT</a></h2>
<p class="Pp">This variable, <i>in your package</i>, says which packages are
    <i>not</i> to be considered as the location of an error. The
    <span class="Li">&quot;carp()&quot;</span> and
    <span class="Li">&quot;cluck()&quot;</span> functions will skip over callers
    when reporting where an error occurred.</p>
<p class="Pp">NB: This variable must be in the package's symbol table, thus:</p>
<p class="Pp"></p>
<pre>    # These work
    our @CARP_NOT; # file scope
    use vars qw(@CARP_NOT); # package scope
    @My::Package::CARP_NOT = ... ; # explicit package variable
    # These don't work
    sub xyz { ... @CARP_NOT = ... } # w/o declarations above
    my @CARP_NOT; # even at top-level
</pre>
<p class="Pp">Example of use:</p>
<p class="Pp"></p>
<pre>    package My::Carping::Package;
    use Carp;
    our @CARP_NOT;
    sub bar     { .... or _error('Wrong input') }
    sub _error  {
        # temporary control of where'ness, __PACKAGE__ is implicit
        local @CARP_NOT = qw(My::Friendly::Caller);
        carp(@_)
    }
</pre>
<p class="Pp">This would make <span class="Li">&quot;Carp&quot;</span> report
    the error as coming from a caller not in
    <span class="Li">&quot;My::Carping::Package&quot;</span>, nor from
    <span class="Li">&quot;My::Friendly::Caller&quot;</span>.</p>
<p class="Pp">Also read the &quot;DESCRIPTION&quot; section above, about how
    <span class="Li">&quot;Carp&quot;</span> decides where the error is reported
    from.</p>
<p class="Pp">Use <span class="Li">@CARP_NOT</span>, instead of
    <span class="Li">$Carp::CarpLevel</span>.</p>
<p class="Pp">Overrides <span class="Li">&quot;Carp&quot;</span>'s use of
    <span class="Li">@ISA</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_Carp::Internal"><a class="permalink" href="#_Carp::Internal">%Carp::Internal</a></h2>
<p class="Pp">This says what packages are internal to Perl.
    <span class="Li">&quot;Carp&quot;</span> will never report an error as being
    from a line in a package that is internal to Perl. For example:</p>
<p class="Pp"></p>
<pre>    $Carp::Internal{ (__PACKAGE__) }++;
    # time passes...
    sub foo { ... or confess(&quot;whatever&quot;) };
</pre>
<p class="Pp">would give a full stack backtrace starting from the first caller
    outside of __PACKAGE__. (Unless that package was also internal to Perl.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_Carp::CarpInternal"><a class="permalink" href="#_Carp::CarpInternal">%Carp::CarpInternal</a></h2>
<p class="Pp">This says which packages are internal to Perl's warning system.
    For generating a full stack backtrace this is the same as being internal to
    Perl, the stack backtrace will not start inside packages that are listed in
    <span class="Li">%Carp::CarpInternal</span>. But it is slightly different
    for the summary message generated by
    <span class="Li">&quot;carp&quot;</span> or
    <span class="Li">&quot;croak&quot;</span>. There errors will not be reported
    on any lines that are calling packages in
    <span class="Li">%Carp::CarpInternal</span>.</p>
<p class="Pp">For example <span class="Li">&quot;Carp&quot;</span> itself is
    listed in <span class="Li">%Carp::CarpInternal</span>. Therefore the full
    stack backtrace from <span class="Li">&quot;confess&quot;</span> will not
    start inside of <span class="Li">&quot;Carp&quot;</span>, and the short
    message from calling <span class="Li">&quot;croak&quot;</span> is not placed
    on the line where <span class="Li">&quot;croak&quot;</span> was called.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$Carp::CarpLevel"><a class="permalink" href="#$Carp::CarpLevel">$Carp::CarpLevel</a></h2>
<p class="Pp">This variable determines how many additional call frames are to be
    skipped that would not otherwise be when reporting where an error occurred
    on a call to one of <span class="Li">&quot;Carp&quot;</span>'s functions. It
    is fairly easy to count these call frames on calls that generate a full
    stack backtrace. However it is much harder to do this accounting for calls
    that generate a short message. Usually people skip too many call frames. If
    they are lucky they skip enough that
    <span class="Li">&quot;Carp&quot;</span> goes all of the way through the
    call stack, realizes that something is wrong, and then generates a full
    stack backtrace. If they are unlucky then the error is reported from
    somewhere misleading very high in the call stack.</p>
<p class="Pp">Therefore it is best to avoid
    <span class="Li">$Carp::CarpLevel</span>. Instead use
    <span class="Li">@CARP_NOT</span>, <span class="Li">%Carp::Internal</span>
    and <span class="Li">%Carp::CarpInternal</span>.</p>
<p class="Pp">Defaults to <span class="Li">0</span>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">The Carp routines don't handle exception objects currently. If
    called with a first argument that is a reference, they simply call
    <b>die()</b> or <b>warn()</b>, as appropriate.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Carp::Always, Carp::Clan</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTING"><a class="permalink" href="#CONTRIBUTING">CONTRIBUTING</a></h1>
<p class="Pp">Carp is maintained by the perl 5 porters as part of the core perl
    5 version control repository. Please see the perlhack perldoc for how to
    submit patches and contribute to it.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">The Carp module first appeared in Larry Wall's perl 5.000
    distribution. Since then it has been modified by several of the perl 5
    porters. Andrew Main (Zefram) &lt;zefram@fysh.org&gt; divested Carp into an
    independent distribution.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (C) 1994-2013 Larry Wall</p>
<p class="Pp">Copyright (C) 2011, 2012, 2013 Andrew Main (Zefram)
    &lt;zefram@fysh.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">This module is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os">perl v5.34.1</td>
  </tr>
</table>
</body>
</html>

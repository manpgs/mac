<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>URI::file(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">URI::file(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">URI::file(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">URI::file - URI that maps to local file names</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre> use URI::file;
 
 $u1 = URI-&gt;new(&quot;file:/foo/bar&quot;);
 $u2 = URI-&gt;new(&quot;foo/bar&quot;, &quot;file&quot;);
 
 $u3 = URI::file-&gt;new($path);
 $u4 = URI::file-&gt;new(&quot;c:\\windows\\&quot;, &quot;win32&quot;);
 
 $u1-&gt;file;
 $u1-&gt;file(&quot;mac&quot;);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The <span class="Li">&quot;URI::file&quot;</span> class supports
    <span class="Li">&quot;URI&quot;</span> objects belonging to the <i>file</i>
    URI scheme. This scheme allows us to map the conventional file names found
    on various computer systems to the URI name space. An old specification of
    the <i>file</i> URI scheme is found in RFC 1738. Some older background
    information is also in RFC 1630. There are no newer specifications as far as
    I know.</p>
<p class="Pp">If you simply want to construct <i>file</i> URI objects from URI
    strings, use the normal <span class="Li">&quot;URI&quot;</span> constructor.
    If you want to construct <i>file</i> URI objects from the actual file names
    used by various systems, then use one of the following
    <span class="Li">&quot;URI::file&quot;</span> constructors:</p>
<dl class="Bl-tag">
  <dt>$u = URI::file-&gt;new( $filename, [$os] )</dt>
  <dd>Maps a file name to the <i>file:</i> URI name space, creates a URI object
      and returns it. The <span class="Li">$filename</span> is interpreted as
      belonging to the indicated operating system ($os), which defaults to the
      value of the $^O variable. The <span class="Li">$filename</span> can be
      either absolute or relative, and the corresponding type of URI object for
      <span class="Li">$os</span> is returned.</dd>
  <dt>$u = URI::file-&gt;new_abs( $filename, [$os] )</dt>
  <dd>Same as URI::file-&gt;new, but makes sure that the URI returned represents
      an absolute file name. If the <span class="Li">$filename</span> argument
      is relative, then the name is resolved relative to the current directory,
      i.e. this constructor is really the same as:
    <p class="Pp"></p>
    <pre>  URI::file-&gt;new($filename)-&gt;abs(URI::file-&gt;cwd);
    </pre>
  </dd>
  <dt>$u = URI::file-&gt;cwd</dt>
  <dd>Returns a <i>file</i> URI that represents the current working directory.
      See Cwd.</dd>
</dl>
<p class="Pp">The following methods are supported for <i>file</i> URI (in
    addition to the common and generic methods described in URI):</p>
<dl class="Bl-tag">
  <dt>$u-&gt;file( [$os] )</dt>
  <dd>Returns a file name. It maps from the URI name space to the file name
      space of the indicated operating system.
    <p class="Pp">It might return <span class="Li">&quot;undef&quot;</span> if
        the name can not be represented in the indicated file system.</p>
  </dd>
  <dt>$u-&gt;dir( [$os] )</dt>
  <dd>Some systems use a different form for names of directories than for plain
      files. Use this method if you know you want to use the name for a
      directory.</dd>
</dl>
<p class="Pp">The <span class="Li">&quot;URI::file&quot;</span> module can be
    used to map generic file names to names suitable for the current system. As
    such, it can work as a nice replacement for the
    <span class="Li">&quot;File::Spec&quot;</span> module. For instance, the
    following code translates the UNIX-style file name <i>Foo/Bar.pm</i> to a
    name suitable for the local system:</p>
<p class="Pp"></p>
<pre>  $file = URI::file-&gt;new(&quot;Foo/Bar.pm&quot;, &quot;unix&quot;)-&gt;file;
  die &quot;Can't map filename Foo/Bar.pm for $^O&quot; unless defined $file;
  open(FILE, $file) || die &quot;Can't open '$file': $!&quot;;
  # do something with FILE
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="MAPPING_NOTES"><a class="permalink" href="#MAPPING_NOTES">MAPPING
  NOTES</a></h1>
<p class="Pp">Most computer systems today have hierarchically organized file
    systems. Mapping the names used in these systems to the generic URI syntax
    allows us to work with relative file URIs that behave as they should when
    resolved using the generic algorithm for URIs (specified in RFC 2396).
    Mapping a file name to the generic URI syntax involves mapping the path
    separator character to &quot;/&quot; and encoding any reserved characters
    that appear in the path segments of the file name. If path segments
    consisting of the strings &quot;.&quot; or &quot;..&quot; have a different
    meaning than what is specified for generic URIs, then these must be encoded
    as well.</p>
<p class="Pp">If the file system has device, volume or drive specifications as
    the root of the name space, then it makes sense to map them to the authority
    field of the generic URI syntax. This makes sure that relative URIs can not
    be resolved &quot;above&quot; them, i.e. generally how relative file names
    work in those systems.</p>
<p class="Pp">Another common use of the authority field is to encode the host on
    which this file name is valid. The host name &quot;localhost&quot; is
    special and generally has the same meaning as a missing or empty authority
    field. This use is in conflict with using it as a device specification, but
    can often be resolved for device specifications having characters not legal
    in plain host names.</p>
<p class="Pp">File name to URI mapping in normally not one-to-one. There are
    usually many URIs that map to any given file name. For instance, an
    authority of &quot;localhost&quot; maps the same as a URI with a missing or
    empty authority.</p>
<p class="Pp">Example 1: The Mac classic (Mac OS 9 and earlier) used
    &quot;:&quot; as path separator, but not in the same way as a generic URI.
    &quot;:foo&quot; was a relative name. &quot;foo:bar&quot; was an absolute
    name. Also, path segments could contain the &quot;/&quot; character as well
    as the literal &quot;.&quot; or &quot;..&quot;. So the mapping looks like
    this:</p>
<p class="Pp"></p>
<pre>  Mac classic           URI
  ----------            -------------------
  :foo:bar     &lt;==&gt;     foo/bar
  :            &lt;==&gt;     ./
  ::foo:bar    &lt;==&gt;     ../foo/bar
  :::          &lt;==&gt;     ../../
  foo:bar      &lt;==&gt;     file:/foo/bar
  foo:bar:     &lt;==&gt;     file:/foo/bar/
  ..           &lt;==&gt;     %2E%2E
  &lt;undef&gt;      &lt;==      /
  foo/         &lt;==      file:/foo%2F
  ./foo.txt    &lt;==      file:/.%2Ffoo.txt
</pre>
<p class="Pp">Note that if you want a relative URL, you *must* begin the path
    with a :. Any path that begins with [^:] is treated as absolute.</p>
<p class="Pp">Example 2: The UNIX file system is easy to map, as it uses the
    same path separator as URIs, has a single root, and segments of
    &quot;.&quot; and &quot;..&quot; have the same meaning. URIs that have the
    character &quot;\0&quot; or &quot;/&quot; as part of any path segment can
    not be turned into valid UNIX file names.</p>
<p class="Pp"></p>
<pre>  UNIX                  URI
  ----------            ------------------
  foo/bar      &lt;==&gt;     foo/bar
  /foo/bar     &lt;==&gt;     file:/foo/bar
  /foo/bar     &lt;==      file://localhost/foo/bar
  file:         ==&gt;     ./file:
  &lt;undef&gt;      &lt;==      file:/fo%00/bar
  /            &lt;==&gt;     file:/
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="CONFIGURATION_VARIABLES"><a class="permalink" href="#CONFIGURATION_VARIABLES">CONFIGURATION
  VARIABLES</a></h1>
<p class="Pp">The following configuration variables influence how the class and
    its methods behave:</p>
<dl class="Bl-tag">
  <dt>%URI::file::OS_CLASS</dt>
  <dd>This hash maps OS identifiers to implementation classes. You might want to
      add or modify this if you want to plug in your own file handler class.
      Normally the keys should match the $^O values in use.
    <p class="Pp">If there is no mapping then the &quot;Unix&quot;
        implementation is used.</p>
  </dd>
  <dt>$URI::file::DEFAULT_AUTHORITY</dt>
  <dd>This determine what &quot;authority&quot; string to include in absolute
      file URIs. It defaults to &quot;&quot;. If you prefer verbose URIs you
      might set it to be &quot;localhost&quot;.
    <p class="Pp">Setting this value to
        <span class="Li">&quot;undef&quot;</span> force behaviour compatible to
        URI v1.31 and earlier. In this mode host names in UNC paths and drive
        letters are mapped to the authority component on Windows, while we
        produce authority-less URIs on Unix.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">URI, File::Spec, perlport</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 1995-1998,2004 Gisle Aas.</p>
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-01-09</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

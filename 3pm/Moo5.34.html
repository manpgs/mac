<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Moo(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Moo(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Moo(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Moo - Minimalist Object Orientation (with Moose compatibility)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  package Cat::Food;
  use Moo;
  use strictures 2;
  use namespace::clean;
  sub feed_lion {
    my $self = shift;
    my $amount = shift || 1;
    $self-&gt;pounds( $self-&gt;pounds - $amount );
  }
  has taste =&gt; (
    is =&gt; 'ro',
  );
  has brand =&gt; (
    is  =&gt; 'ro',
    isa =&gt; sub {
      die &quot;Only SWEET-TREATZ supported!&quot; unless $_[0] eq 'SWEET-TREATZ'
    },
  );
  has pounds =&gt; (
    is  =&gt; 'rw',
    isa =&gt; sub { die &quot;$_[0] is too much cat food!&quot; unless $_[0] &lt; 15 },
  );
  1;
</pre>
<p class="Pp">And elsewhere:</p>
<p class="Pp"></p>
<pre>  my $full = Cat::Food-&gt;new(
      taste  =&gt; 'DELICIOUS.',
      brand  =&gt; 'SWEET-TREATZ',
      pounds =&gt; 10,
  );
  $full-&gt;feed_lion;
  say $full-&gt;pounds;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><span class="Li">&quot;Moo&quot;</span> is an extremely
    light-weight Object Orientation system. It allows one to concisely define
    objects and roles with a convenient syntax that avoids the details of Perl's
    object system. <span class="Li">&quot;Moo&quot;</span> contains a subset of
    Moose and is optimised for rapid startup.</p>
<p class="Pp"><span class="Li">&quot;Moo&quot;</span> avoids depending on any XS
    modules to allow for simple deployments. The name
    <span class="Li">&quot;Moo&quot;</span> is based on the idea that it
    provides almost -- but not quite -- two thirds of Moose. As such, the
    Moose::Manual can serve as an effective guide to
    <span class="Li">&quot;Moo&quot;</span> aside from the MOP and Types
    sections.</p>
<p class="Pp">Unlike Mouse this module does not aim at full compatibility with
    Moose's surface syntax, preferring instead to provide full interoperability
    via the metaclass inflation capabilities described in &quot;MOO AND
    MOOSE&quot;.</p>
<p class="Pp">For a full list of the minor differences between Moose and Moo's
    surface syntax, see &quot;INCOMPATIBILITIES WITH MOOSE&quot;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="WHY_MOO_EXISTS"><a class="permalink" href="#WHY_MOO_EXISTS">WHY
  MOO EXISTS</a></h1>
<p class="Pp">If you want a full object system with a rich Metaprotocol, Moose
    is already wonderful.</p>
<p class="Pp">But if you don't want to use Moose, you may not want &quot;less
    metaprotocol&quot; like Mouse offers, but you probably want &quot;no
    metaprotocol&quot;, which is what Moo provides.
    <span class="Li">&quot;Moo&quot;</span> is ideal for some situations where
    deployment or startup time precludes using Moose and Mouse:</p>
<dl class="Bl-tag">
  <dt id="a"><a class="permalink" href="#a">a command line or CGI script where
    fast startup is essential</a></dt>
  <dd></dd>
  <dt id="code"><a class="permalink" href="#code">code designed to be deployed
    as a single file via App::FatPacker</a></dt>
  <dd></dd>
  <dt id="a~2"><a class="permalink" href="#a~2">a CPAN module that may be used
    by others in the above situations</a></dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li">&quot;Moo&quot;</span> maintains transparent
    compatibility with Moose so if you install and load Moose you can use Moo
    classes and roles in Moose code without modification.</p>
<p class="Pp">Moo -- Minimal Object Orientation -- aims to make it smooth to
    upgrade to Moose when you need more than the minimal features offered by
    Moo.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MOO_AND_MOOSE"><a class="permalink" href="#MOO_AND_MOOSE">MOO
  AND MOOSE</a></h1>
<p class="Pp">If Moo detects Moose being loaded, it will automatically register
    metaclasses for your Moo and Moo::Role packages, so you should be able to
    use them in Moose code without modification.</p>
<p class="Pp">Moo will also create Moose type constraints for Moo classes and
    roles, so that in Moose classes <span class="Li">&quot;isa =&gt;
    'MyMooClass'&quot;</span> and <span class="Li">&quot;isa =&gt;
    'MyMooRole'&quot;</span> work the same as for Moose classes and roles.</p>
<p class="Pp">Extending a Moose class or consuming a Moose::Role will also
  work.</p>
<p class="Pp">Extending a Mouse class or consuming a Mouse::Role will also work.
    But note that we don't provide Mouse metaclasses or metaroles so the other
    way around doesn't work. This feature exists for Any::Moose users porting to
    Moo; enabling Mouse users to use Moo classes is not a priority for us.</p>
<p class="Pp">This means that there is no need for anything like Any::Moose for
    Moo code - Moo and Moose code should simply interoperate without problem. To
    handle Mouse code, you'll likely need an empty Moo role or class consuming
    or extending the Mouse stuff since it doesn't register true Moose
    metaclasses like Moo does.</p>
<p class="Pp">If you need to disable the metaclass creation, add:</p>
<p class="Pp"></p>
<pre>  no Moo::sification;
</pre>
<p class="Pp">to your code before Moose is loaded, but bear in mind that this
    switch is global and turns the mechanism off entirely so don't put this in
    library code.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MOO_AND_CLASS::XSACCESSOR"><a class="permalink" href="#MOO_AND_CLASS::XSACCESSOR">MOO
  AND CLASS::XSACCESSOR</a></h1>
<p class="Pp">If a new enough version of Class::XSAccessor is available, it will
    be used to generate simple accessors, readers, and writers for better
    performance. Simple accessors are those without lazy defaults, type
    checks/coercions, or triggers. Simple readers are those without lazy
    defaults. Readers and writers generated by Class::XSAccessor will behave
    slightly differently: they will reject attempts to call them with the
    incorrect number of parameters.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MOO_VERSUS_ANY::MOOSE"><a class="permalink" href="#MOO_VERSUS_ANY::MOOSE">MOO
  VERSUS ANY::MOOSE</a></h1>
<p class="Pp">Any::Moose will load Mouse normally, and Moose in a program using
    Moose - which theoretically allows you to get the startup time of Mouse
    without disadvantaging Moose users.</p>
<p class="Pp">Sadly, this doesn't entirely work, since the selection is load
    order dependent - Moo's metaclass inflation system explained above in
    &quot;MOO AND MOOSE&quot; is significantly more reliable.</p>
<p class="Pp">So if you want to write a CPAN module that loads fast or has only
    pure perl dependencies but is also fully usable by Moose users, you should
    be using Moo.</p>
<p class="Pp">For a full explanation, see the article
    &lt;https://shadow.cat/blog/matt-s-trout/moo-versus-any-moose&gt; which
    explains the differing strategies in more detail and provides a direct
    example of where Moo succeeds and Any::Moose fails.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PUBLIC_METHODS"><a class="permalink" href="#PUBLIC_METHODS">PUBLIC
  METHODS</a></h1>
<p class="Pp">Moo provides several methods to any class using it.</p>
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
<pre>  Foo::Bar-&gt;new( attr1 =&gt; 3 );
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre>  Foo::Bar-&gt;new({ attr1 =&gt; 3 });
</pre>
<p class="Pp">The constructor for the class. By default it will accept
    attributes either as a hashref, or a list of key value pairs. This can be
    customized with the &quot;BUILDARGS&quot; method.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="does"><a class="permalink" href="#does">does</a></h2>
<pre>  if ($foo-&gt;does('Some::Role1')) {
    ...
  }
</pre>
<p class="Pp">Returns true if the object composes in the passed role.</p>
</section>
<section class="Ss">
<h2 class="Ss">DOES</h2>
<pre>  if ($foo-&gt;DOES('Some::Role1') || $foo-&gt;DOES('Some::Class1')) {
    ...
  }
</pre>
<p class="Pp">Similar to &quot;does&quot;, but will also return true for both
    composed roles and superclasses.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="meta"><a class="permalink" href="#meta">meta</a></h2>
<pre>  my $meta = Foo::Bar-&gt;meta;
  my @methods = $meta-&gt;get_method_list;
</pre>
<p class="Pp">Returns an object that will behave as if it is a Moose metaclass
    object for the class. If you call anything other than
    <span class="Li">&quot;make_immutable&quot;</span> on it, the object will be
    transparently upgraded to a genuine Moose::Meta::Class instance, loading
    Moose in the process if required.
    <span class="Li">&quot;make_immutable&quot;</span> itself is a no-op, since
    we generate metaclasses that are already immutable, and users converting
    from Moose had an unfortunate tendency to accidentally load Moose by calling
    it.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="LIFECYCLE_METHODS"><a class="permalink" href="#LIFECYCLE_METHODS">LIFECYCLE
  METHODS</a></h1>
<p class="Pp">There are several methods that you can define in your class to
    control construction and destruction of objects. They should be used rather
    than trying to modify <span class="Li">&quot;new&quot;</span> or
    <span class="Li">&quot;DESTROY&quot;</span> yourself.</p>
<section class="Ss">
<h2 class="Ss">BUILDARGS</h2>
<pre>  around BUILDARGS =&gt; sub {
    my ( $orig, $class, @args ) = @_;
    return { attr1 =&gt; $args[0] }
      if @args == 1 &amp;&amp; !ref $args[0];
    return $class-&gt;$orig(@args);
  };
  Foo::Bar-&gt;new( 3 );
</pre>
<p class="Pp">This class method is used to transform the arguments to
    <span class="Li">&quot;new&quot;</span> into a hash reference of attribute
    values.</p>
<p class="Pp">The default implementation accepts a hash or hash reference of
    named parameters. If it receives a single argument that isn't a hash
    reference it will throw an error.</p>
<p class="Pp">You can override this method in your class to handle other types
    of options passed to the constructor.</p>
<p class="Pp">This method should always return a hash reference of named
    options.</p>
</section>
<section class="Ss">
<h2 class="Ss">FOREIGNBUILDARGS</h2>
<pre>  sub FOREIGNBUILDARGS {
    my ( $class, $options ) = @_;
    return $options-&gt;{foo};
  }
</pre>
<p class="Pp">If you are inheriting from a non-Moo class, the arguments passed
    to the parent class constructor can be manipulated by defining a
    <span class="Li">&quot;FOREIGNBUILDARGS&quot;</span> method. It will receive
    the same arguments as &quot;BUILDARGS&quot;, and should return a list of
    arguments to pass to the parent class constructor.</p>
</section>
<section class="Ss">
<h2 class="Ss">BUILD</h2>
<pre>  sub BUILD {
    my ($self, $args) = @_;
    die &quot;foo and bar cannot be used at the same time&quot;
      if exists $args-&gt;{foo} &amp;&amp; exists $args-&gt;{bar};
  }
</pre>
<p class="Pp">On object creation, any <span class="Li">&quot;BUILD&quot;</span>
    methods in the class's inheritance hierarchy will be called on the object
    and given the results of &quot;BUILDARGS&quot;. They each will be called in
    order from the parent classes down to the child, and thus should not
    themselves call the parent's method. Typically this is used for object
    validation or possibly logging.</p>
</section>
<section class="Ss">
<h2 class="Ss">DEMOLISH</h2>
<pre>  sub DEMOLISH {
    my ($self, $in_global_destruction) = @_;
    ...
  }
</pre>
<p class="Pp">When an object is destroyed, any
    <span class="Li">&quot;DEMOLISH&quot;</span> methods in the inheritance
    hierarchy will be called on the object. They are given boolean to inform
    them if global destruction is in progress, and are called from the child
    class upwards to the parent. This is similar to &quot;BUILD&quot; methods
    but in the opposite order.</p>
<p class="Pp">Note that this is implemented by a
    <span class="Li">&quot;DESTROY&quot;</span> method, which is only created on
    on the first construction of an object of your class. This saves on overhead
    for classes that are never instantiated or those without
    <span class="Li">&quot;DEMOLISH&quot;</span> methods. If you try to define
    your own <span class="Li">&quot;DESTROY&quot;</span>, this will cause
    undefined results.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="IMPORTED_SUBROUTINES"><a class="permalink" href="#IMPORTED_SUBROUTINES">IMPORTED
  SUBROUTINES</a></h1>
<section class="Ss">
<h2 class="Ss" id="extends"><a class="permalink" href="#extends">extends</a></h2>
<pre>  extends 'Parent::Class';
</pre>
<p class="Pp">Declares a base class. Multiple superclasses can be passed for
    multiple inheritance but please consider using roles instead. The class will
    be loaded but no errors will be triggered if the class can't be found and
    there are already subs in the class.</p>
<p class="Pp">Calling extends more than once will REPLACE your superclasses, not
    add to them like 'use base' would.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="with"><a class="permalink" href="#with">with</a></h2>
<pre>  with 'Some::Role1';
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre>  with 'Some::Role1', 'Some::Role2';
</pre>
<p class="Pp">Composes one or more Moo::Role (or Role::Tiny) roles into the
    current class. An error will be raised if these roles cannot be composed
    because they have conflicting method definitions. The roles will be loaded
    using the same mechanism as <span class="Li">&quot;extends&quot;</span>
    uses.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="has"><a class="permalink" href="#has">has</a></h2>
<pre>  has attr =&gt; (
    is =&gt; 'ro',
  );
</pre>
<p class="Pp">Declares an attribute for the class.</p>
<p class="Pp"></p>
<pre>  package Foo;
  use Moo;
  has 'attr' =&gt; (
    is =&gt; 'ro'
  );
  package Bar;
  use Moo;
  extends 'Foo';
  has '+attr' =&gt; (
    default =&gt; sub { &quot;blah&quot; },
  );
</pre>
<p class="Pp">Using the <span class="Li">&quot;+&quot;</span> notation, it's
    possible to override an attribute.</p>
<p class="Pp"></p>
<pre>  has [qw(attr1 attr2 attr3)] =&gt; (
    is =&gt; 'ro',
  );
</pre>
<p class="Pp">Using an arrayref with multiple attribute names, it's possible to
    declare multiple attributes with the same options.</p>
<p class="Pp">The options for <span class="Li">&quot;has&quot;</span> are as
    follows:</p>
<dl class="Bl-tag">
  <dt>&quot;is&quot;</dt>
  <dd><b>required</b>, may be <span class="Li">&quot;ro&quot;</span>,
      <span class="Li">&quot;lazy&quot;</span>,
      <span class="Li">&quot;rwp&quot;</span> or
      <span class="Li">&quot;rw&quot;</span>.
    <p class="Pp"><span class="Li">&quot;ro&quot;</span> stands for
        &quot;read-only&quot; and generates an accessor that dies if you attempt
        to write to it - i.e. a getter only - by defaulting
        <span class="Li">&quot;reader&quot;</span> to the name of the
      attribute.</p>
    <p class="Pp"><span class="Li">&quot;lazy&quot;</span> generates a reader
        like <span class="Li">&quot;ro&quot;</span>, but also sets
        <span class="Li">&quot;lazy&quot;</span> to 1 and
        <span class="Li">&quot;builder&quot;</span> to
        <span class="Li">&quot;_build_${attribute_name}&quot;</span> to allow
        on-demand generated attributes. This feature was my attempt to fix my
        incompetence when originally designing
        <span class="Li">&quot;lazy_build&quot;</span>, and is also implemented
        by MooseX::AttributeShortcuts. There is, however, nothing to stop you
        using <span class="Li">&quot;lazy&quot;</span> and
        <span class="Li">&quot;builder&quot;</span> yourself with
        <span class="Li">&quot;rwp&quot;</span> or
        <span class="Li">&quot;rw&quot;</span> - it's just that this isn't
        generally a good idea so we don't provide a shortcut for it.</p>
    <p class="Pp"><span class="Li">&quot;rwp&quot;</span> stands for
        &quot;read-write protected&quot; and generates a reader like
        <span class="Li">&quot;ro&quot;</span>, but also sets
        <span class="Li">&quot;writer&quot;</span> to
        <span class="Li">&quot;_set_${attribute_name}&quot;</span> for
        attributes that are designed to be written from inside of the class, but
        read-only from outside. This feature comes from
        MooseX::AttributeShortcuts.</p>
    <p class="Pp"><span class="Li">&quot;rw&quot;</span> stands for
        &quot;read-write&quot; and generates a normal getter/setter by
        defaulting the <span class="Li">&quot;accessor&quot;</span> to the name
        of the attribute specified.</p>
  </dd>
  <dt>&quot;isa&quot;</dt>
  <dd>Takes a coderef which is used to validate the attribute. Unlike Moose, Moo
      does not include a basic type system, so instead of doing
      <span class="Li">&quot;isa =&gt; 'Num'&quot;</span>, one should do
    <p class="Pp"></p>
    <pre>  use Scalar::Util qw(looks_like_number);
  ...
  isa =&gt; sub {
    die &quot;$_[0] is not a number!&quot; unless looks_like_number $_[0]
  },
    </pre>
    <p class="Pp">Note that the return value for
        <span class="Li">&quot;isa&quot;</span> is discarded. Only if the sub
        dies does type validation fail.</p>
    <p class="Pp">Sub::Quote aware</p>
    <p class="Pp">Since Moo does <b>not</b> run the
        <span class="Li">&quot;isa&quot;</span> check before
        <span class="Li">&quot;coerce&quot;</span> if a coercion subroutine has
        been supplied, <span class="Li">&quot;isa&quot;</span> checks are not
        structural to your code and can, if desired, be omitted on non-debug
        builds (although if this results in an uncaught bug causing your program
        to break, the Moo authors guarantee nothing except that you get to keep
        both halves).</p>
    <p class="Pp">If you want Moose compatible or MooseX::Types style named
        types, look at Type::Tiny.</p>
    <p class="Pp">To cause your <span class="Li">&quot;isa&quot;</span> entries
        to be automatically mapped to named Moose::Meta::TypeConstraint objects
        (rather than the default behaviour of creating an anonymous type),
      set:</p>
    <p class="Pp"></p>
    <pre>  $Moo::HandleMoose::TYPE_MAP{$isa_coderef} = sub {
    require MooseX::Types::Something;
    return MooseX::Types::Something::TypeName();
  };
    </pre>
    <p class="Pp">Note that this example is purely illustrative; anything that
        returns a Moose::Meta::TypeConstraint object or something similar enough
        to it to make Moose happy is fine.</p>
  </dd>
  <dt>&quot;coerce&quot;</dt>
  <dd>Takes a coderef which is meant to coerce the attribute. The basic idea is
      to do something like the following:
    <p class="Pp"></p>
    <pre> coerce =&gt; sub {
   $_[0] % 2 ? $_[0] : $_[0] + 1
 },
    </pre>
    <p class="Pp">Note that Moo will always execute your coercion: this is to
        permit <span class="Li">&quot;isa&quot;</span> entries to be used purely
        for bug trapping, whereas coercions are always structural to your code.
        We do, however, apply any supplied
        <span class="Li">&quot;isa&quot;</span> check after the coercion has run
        to ensure that it returned a valid value.</p>
    <p class="Pp">Sub::Quote aware</p>
    <p class="Pp">If the <span class="Li">&quot;isa&quot;</span> option is a
        blessed object providing a <span class="Li">&quot;coerce&quot;</span> or
        <span class="Li">&quot;coercion&quot;</span> method, then the
        <span class="Li">&quot;coerce&quot;</span> option may be set to just
        <span class="Li">1</span>.</p>
  </dd>
  <dt>&quot;handles&quot;</dt>
  <dd>Takes a string
    <p class="Pp"></p>
    <pre>  handles =&gt; 'RobotRole'
    </pre>
    <p class="Pp">Where <span class="Li">&quot;RobotRole&quot;</span> is a role
        that defines an interface which becomes the list of methods to
      handle.</p>
    <p class="Pp">Takes a list of methods</p>
    <p class="Pp"></p>
    <pre>  handles =&gt; [ qw( one two ) ]
    </pre>
    <p class="Pp">Takes a hashref</p>
    <p class="Pp"></p>
    <pre>  handles =&gt; {
    un =&gt; 'one',
  }
    </pre>
  </dd>
  <dt>&quot;trigger&quot;</dt>
  <dd>Takes a coderef which will get called any time the attribute is set. This
      includes the constructor, but not default or built values. The coderef
      will be invoked against the object with the new value as an argument.
    <p class="Pp">If you set this to just <span class="Li">1</span>, it
        generates a trigger which calls the
        <span class="Li">&quot;_trigger_${attr_name}&quot;</span> method on
        <span class="Li">$self</span>. This feature comes from
        MooseX::AttributeShortcuts.</p>
    <p class="Pp">Note that Moose also passes the old value, if any; this
        feature is not yet supported.</p>
    <p class="Pp">Sub::Quote aware</p>
  </dd>
  <dt>&quot;default&quot;</dt>
  <dd>Takes a coderef which will get called with <span class="Li">$self</span>
      as its only argument to populate an attribute if no value for that
      attribute was supplied to the constructor. Alternatively, if the attribute
      is lazy, <span class="Li">&quot;default&quot;</span> executes when the
      attribute is first retrieved if no value has yet been provided.
    <p class="Pp">If a simple scalar is provided, it will be inlined as a
        string. Any non-code reference (hash, array) will result in an error -
        for that case instead use a code reference that returns the desired
        value.</p>
    <p class="Pp">Note that if your default is fired during <b>new()</b> there
        is no guarantee that other attributes have been populated yet so you
        should not rely on their existence.</p>
    <p class="Pp">Sub::Quote aware</p>
  </dd>
  <dt>&quot;predicate&quot;</dt>
  <dd>Takes a method name which will return true if an attribute has a value.
    <p class="Pp">If you set this to just <span class="Li">1</span>, the
        predicate is automatically named
        <span class="Li">&quot;has_${attr_name}&quot;</span> if your attribute's
        name does not start with an underscore, or
        <span class="Li">&quot;_has_${attr_name_without_the_underscore}&quot;</span>
        if it does. This feature comes from MooseX::AttributeShortcuts.</p>
  </dd>
  <dt>&quot;builder&quot;</dt>
  <dd>Takes a method name which will be called to create the attribute -
      functions exactly like default except that instead of calling
    <p class="Pp"></p>
    <pre>  $default-&gt;($self);
    </pre>
    <p class="Pp">Moo will call</p>
    <p class="Pp"></p>
    <pre>  $self-&gt;$builder;
    </pre>
    <p class="Pp">The following features come from
      MooseX::AttributeShortcuts:</p>
    <p class="Pp">If you set this to just <span class="Li">1</span>, the builder
        is automatically named
        <span class="Li">&quot;_build_${attr_name}&quot;</span>.</p>
    <p class="Pp">If you set this to a coderef or code-convertible object, that
        variable will be installed under
        <span class="Li">&quot;$class::_build_${attr_name}&quot;</span> and the
        builder set to the same name.</p>
  </dd>
  <dt>&quot;clearer&quot;</dt>
  <dd>Takes a method name which will clear the attribute.
    <p class="Pp">If you set this to just <span class="Li">1</span>, the clearer
        is automatically named
        <span class="Li">&quot;clear_${attr_name}&quot;</span> if your
        attribute's name does not start with an underscore, or
        <span class="Li">&quot;_clear_${attr_name_without_the_underscore}&quot;</span>
        if it does. This feature comes from MooseX::AttributeShortcuts.</p>
    <p class="Pp"><b>NOTE:</b> If the attribute is
        <span class="Li">&quot;lazy&quot;</span>, it will be regenerated from
        <span class="Li">&quot;default&quot;</span> or
        <span class="Li">&quot;builder&quot;</span> the next time it is
        accessed. If it is not lazy, it will be
        <span class="Li">&quot;undef&quot;</span>.</p>
  </dd>
  <dt>&quot;lazy&quot;</dt>
  <dd><b>Boolean</b>. Set this if you want values for the attribute to be
      grabbed lazily. This is usually a good idea if you have a
      &quot;builder&quot; which requires another attribute to be set.</dd>
  <dt>&quot;required&quot;</dt>
  <dd><b>Boolean</b>. Set this if the attribute must be passed on object
      instantiation.</dd>
  <dt>&quot;reader&quot;</dt>
  <dd>The name of the method that returns the value of the attribute. If you
      like Java style methods, you might set this to
      <span class="Li">&quot;get_foo&quot;</span></dd>
  <dt>&quot;writer&quot;</dt>
  <dd>The value of this attribute will be the name of the method to set the
      value of the attribute. If you like Java style methods, you might set this
      to <span class="Li">&quot;set_foo&quot;</span>.</dd>
  <dt>&quot;weak_ref&quot;</dt>
  <dd><b>Boolean</b>. Set this if you want the reference that the attribute
      contains to be weakened. Use this when circular references, which cause
      memory leaks, are possible.</dd>
  <dt>&quot;init_arg&quot;</dt>
  <dd>Takes the name of the key to look for at instantiation time of the object.
      A common use of this is to make an underscored attribute have a
      non-underscored initialization name.
      <span class="Li">&quot;undef&quot;</span> means that passing the value in
      on instantiation is ignored.</dd>
  <dt>&quot;moosify&quot;</dt>
  <dd>Takes either a coderef or array of coderefs which is meant to transform
      the given attributes specifications if necessary when upgrading to a Moose
      role or class. You shouldn't need this by default, but is provided as a
      means of possible extensibility.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="before"><a class="permalink" href="#before">before</a></h2>
<pre>  before foo =&gt; sub { ... };
</pre>
<p class="Pp">See &quot;before method(s) =&gt; sub { ... };&quot; in
    Class::Method::Modifiers for full documentation.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="around"><a class="permalink" href="#around">around</a></h2>
<pre>  around foo =&gt; sub { ... };
</pre>
<p class="Pp">See &quot;around method(s) =&gt; sub { ... };&quot; in
    Class::Method::Modifiers for full documentation.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="after"><a class="permalink" href="#after">after</a></h2>
<pre>  after foo =&gt; sub { ... };
</pre>
<p class="Pp">See &quot;after method(s) =&gt; sub { ... };&quot; in
    Class::Method::Modifiers for full documentation.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SUB_QUOTE_AWARE"><a class="permalink" href="#SUB_QUOTE_AWARE">SUB
  QUOTE AWARE</a></h1>
<p class="Pp">&quot;quote_sub&quot; in Sub::Quote allows us to create coderefs
    that are &quot;inlineable,&quot; giving us a handy, XS-free speed boost. Any
    option that is Sub::Quote aware can take advantage of this.</p>
<p class="Pp">To do this, you can write</p>
<p class="Pp"></p>
<pre>  use Sub::Quote;
  use Moo;
  use namespace::clean;
  has foo =&gt; (
    is =&gt; 'ro',
    isa =&gt; quote_sub(q{ die &quot;Not &lt;3&quot; unless $_[0] &lt; 3 })
  );
</pre>
<p class="Pp">which will be inlined as</p>
<p class="Pp"></p>
<pre>  do {
    local @_ = ($_[0]-&gt;{foo});
    die &quot;Not &lt;3&quot; unless $_[0] &lt; 3;
  }
</pre>
<p class="Pp">or to avoid localizing <span class="Li">@_</span>,</p>
<p class="Pp"></p>
<pre>  has foo =&gt; (
    is =&gt; 'ro',
    isa =&gt; quote_sub(q{ my ($val) = @_; die &quot;Not &lt;3&quot; unless $val &lt; 3 })
  );
</pre>
<p class="Pp">which will be inlined as</p>
<p class="Pp"></p>
<pre>  do {
    my ($val) = ($_[0]-&gt;{foo});
    die &quot;Not &lt;3&quot; unless $val &lt; 3;
  }
</pre>
<p class="Pp">See Sub::Quote for more information, including how to pass lexical
    captures that will also be compiled into the subroutine.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CLEANING_UP_IMPORTS"><a class="permalink" href="#CLEANING_UP_IMPORTS">CLEANING
  UP IMPORTS</a></h1>
<p class="Pp">Moo will not clean up imported subroutines for you; you will have
    to do that manually. The recommended way to do this is to declare your
    imports first, then <span class="Li">&quot;use Moo&quot;</span>, then
    <span class="Li">&quot;use namespace::clean&quot;</span>. Anything imported
    before namespace::clean will be scrubbed. Anything imported or declared
    after will be still be available.</p>
<p class="Pp"></p>
<pre>  package Record;
  use Digest::MD5 qw(md5_hex);
  use Moo;
  use namespace::clean;
  has name =&gt; (is =&gt; 'ro', required =&gt; 1);
  has id =&gt; (is =&gt; 'lazy');
  sub _build_id {
    my ($self) = @_;
    return md5_hex($self-&gt;name);
  }
  1;
</pre>
<p class="Pp">For example if you were to import these subroutines after
    namespace::clean like this</p>
<p class="Pp"></p>
<pre>  use namespace::clean;
  use Digest::MD5 qw(md5_hex);
  use Moo;
</pre>
<p class="Pp">then any <span class="Li">&quot;Record&quot;</span>
    <span class="Li">$r</span> would have methods such as
    <span class="Li">&quot;$r-&gt;md5_hex()&quot;</span>,
    <span class="Li">&quot;$r-&gt;has()&quot;</span> and
    <span class="Li">&quot;$r-&gt;around()&quot;</span> - almost certainly not
    what you intend!</p>
<p class="Pp">Moo::Roles behave slightly differently. Since their methods are
    composed into the consuming class, they can do a little more for you
    automatically. As long as you declare your imports before calling
    <span class="Li">&quot;use Moo::Role&quot;</span>, those imports and the
    ones Moo::Role itself provides will not be composed into consuming classes
    so there's usually no need to use namespace::clean.</p>
<p class="Pp"><b>On namespace::autoclean:</b> Older versions of
    namespace::autoclean would inflate Moo classes to full Moose classes, losing
    the benefits of Moo. If you want to use namespace::autoclean with a Moo
    class, make sure you are using version 0.16 or newer.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="INCOMPATIBILITIES_WITH_MOOSE"><a class="permalink" href="#INCOMPATIBILITIES_WITH_MOOSE">INCOMPATIBILITIES
  WITH MOOSE</a></h1>
<section class="Ss">
<h2 class="Ss">TYPES</h2>
<p class="Pp">There is no built-in type system.
    <span class="Li">&quot;isa&quot;</span> is verified with a coderef; if you
    need complex types, Type::Tiny can provide types, type libraries, and will
    work seamlessly with both Moo and Moose. Type::Tiny can be considered the
    successor to MooseX::Types and provides a similar API, so that you can
  write</p>
<p class="Pp"></p>
<pre>  use Types::Standard qw(Int);
  has days_to_live =&gt; (is =&gt; 'ro', isa =&gt; Int);
</pre>
</section>
<section class="Ss">
<h2 class="Ss">API INCOMPATIBILITIES</h2>
<p class="Pp"><span class="Li">&quot;initializer&quot;</span> is not supported
    in core since the author considers it to be a bad idea and Moose best
    practices recommend avoiding it. Meanwhile
    <span class="Li">&quot;trigger&quot;</span> or
    <span class="Li">&quot;coerce&quot;</span> are more likely to be able to
    fulfill your needs.</p>
<p class="Pp">No support for <span class="Li">&quot;super&quot;</span>,
    <span class="Li">&quot;override&quot;</span>,
    <span class="Li">&quot;inner&quot;</span>, or
    <span class="Li">&quot;augment&quot;</span> - the author considers augment
    to be a bad idea, and override can be translated:</p>
<p class="Pp"></p>
<pre>  override foo =&gt; sub {
    ...
    super();
    ...
  };
  around foo =&gt; sub {
    my ($orig, $self) = (shift, shift);
    ...
    $self-&gt;$orig(@_);
    ...
  };
</pre>
<p class="Pp">The <span class="Li">&quot;dump&quot;</span> method is not
    provided by default. The author suggests loading Devel::Dwarn into
    <span class="Li">&quot;main::&quot;</span> (via <span class="Li">&quot;perl
    -MDevel::Dwarn ...&quot;</span> for example) and using
    <span class="Li">&quot;$obj-&gt;$::Dwarn()&quot;</span> instead.</p>
<p class="Pp">&quot;default&quot; only supports coderefs and plain scalars,
    because passing a hash or array reference as a default is almost always
    incorrect since the value is then shared between all objects using that
    default.</p>
<p class="Pp"><span class="Li">&quot;lazy_build&quot;</span> is not supported;
    you are instead encouraged to use the <span class="Li">&quot;is =&gt;
    'lazy'&quot;</span> option supported by Moo and
  MooseX::AttributeShortcuts.</p>
<p class="Pp"><span class="Li">&quot;auto_deref&quot;</span> is not supported
    since the author considers it a bad idea and it has been considered best
    practice to avoid it for some time.</p>
<p class="Pp"><span class="Li">&quot;documentation&quot;</span> will show up in
    a Moose metaclass created from your class but is otherwise ignored. Then
    again, Moose ignores it as well, so this is arguably not an
  incompatibility.</p>
<p class="Pp">Since <span class="Li">&quot;coerce&quot;</span> does not require
    <span class="Li">&quot;isa&quot;</span> to be defined but Moose does require
    it, the metaclass inflation for coerce alone is a trifle insane and if you
    attempt to subtype the result will almost certainly break.</p>
<p class="Pp">Handling of warnings: when you <span class="Li">&quot;use
    Moo&quot;</span> we enable strict and warnings, in a similar way to Moose.
    The authors recommend the use of
    <span class="Li">&quot;strictures&quot;</span>, which enables FATAL
    warnings, and several extra pragmas when used in development: indirect,
    multidimensional, and bareword::filehandles.</p>
<p class="Pp">Additionally, Moo supports a set of attribute option shortcuts
    intended to reduce common boilerplate. The set of shortcuts is the same as
    in the Moose module MooseX::AttributeShortcuts as of its version 0.009+. So
    if you:</p>
<p class="Pp"></p>
<pre>  package MyClass;
  use Moo;
  use strictures 2;
</pre>
<p class="Pp">The nearest Moose invocation would be:</p>
<p class="Pp"></p>
<pre>  package MyClass;
  use Moose;
  use warnings FATAL =&gt; &quot;all&quot;;
  use MooseX::AttributeShortcuts;
</pre>
<p class="Pp">or, if you're inheriting from a non-Moose class,</p>
<p class="Pp"></p>
<pre>  package MyClass;
  use Moose;
  use MooseX::NonMoose;
  use warnings FATAL =&gt; &quot;all&quot;;
  use MooseX::AttributeShortcuts;
</pre>
</section>
<section class="Ss">
<h2 class="Ss">META OBJECT</h2>
<p class="Pp">There is no meta object. If you need this level of complexity you
    need Moose - Moo is small because it explicitly does not provide a
    metaprotocol. However, if you load Moose, then</p>
<p class="Pp"></p>
<pre>  Class::MOP::class_of($moo_class_or_role)
</pre>
<p class="Pp">will return an appropriate metaclass pre-populated by Moo.</p>
</section>
<section class="Ss">
<h2 class="Ss">IMMUTABILITY</h2>
<p class="Pp">Finally, Moose requires you to call</p>
<p class="Pp"></p>
<pre>  __PACKAGE__-&gt;meta-&gt;make_immutable;
</pre>
<p class="Pp">at the end of your class to get an inlined (i.e. not horribly
    slow) constructor. Moo does it automatically the first time -&gt;new is
    called on your class. (<span class="Li">&quot;make_immutable&quot;</span> is
    a no-op in Moo to ease migration.)</p>
<p class="Pp">An extension MooX::late exists to ease translating Moose packages
    to Moo by providing a more Moose-like interface.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="COMPATIBILITY_WITH_OLDER_PERL_VERSIONS"><a class="permalink" href="#COMPATIBILITY_WITH_OLDER_PERL_VERSIONS">COMPATIBILITY
  WITH OLDER PERL VERSIONS</a></h1>
<p class="Pp">Moo is compatible with perl versions back to 5.6. When running on
    older versions, additional prerequisites will be required. If you are
    packaging a script with its dependencies, such as with App::FatPacker, you
    will need to be certain that the extra prerequisites are included.</p>
<dl class="Bl-tag">
  <dt id="MRO::Compat"><a class="permalink" href="#MRO::Compat">MRO::Compat</a></dt>
  <dd>Required on perl versions prior to 5.10.0.</dd>
  <dt id="Devel::GlobalDestruction"><a class="permalink" href="#Devel::GlobalDestruction">Devel::GlobalDestruction</a></dt>
  <dd>Required on perl versions prior to 5.14.0.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
<p class="Pp">IRC: #moose on irc.perl.org</p>
<p class="Pp">Bugtracker:
    &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=Moo&gt;</p>
<p class="Pp">Git repository: &lt;git://github.com/moose/Moo.git&gt;</p>
<p class="Pp">Git browser: &lt;https://github.com/moose/Moo&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">mst - Matt S. Trout (cpan:MSTROUT) &lt;mst@shadowcat.co.uk&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<p class="Pp">dg - David Leadbeater (cpan:DGL) &lt;dgl@dgl.cx&gt;</p>
<p class="Pp">frew - Arthur Axel &quot;fREW&quot; Schmidt (cpan:FREW)
    &lt;frioux@gmail.com&gt;</p>
<p class="Pp">hobbs - Andrew Rodland (cpan:ARODLAND)
  &lt;arodland@cpan.org&gt;</p>
<p class="Pp">jnap - John Napiorkowski (cpan:JJNAPIORK)
    &lt;jjn1056@yahoo.com&gt;</p>
<p class="Pp">ribasushi - Peter Rabbitson (cpan:RIBASUSHI)
    &lt;ribasushi@cpan.org&gt;</p>
<p class="Pp">chip - Chip Salzenberg (cpan:CHIPS) &lt;chip@pobox.com&gt;</p>
<p class="Pp">ajgb - Alex J. G. Burzy&#x0144;ski (cpan:AJGB)
    &lt;ajgb@cpan.org&gt;</p>
<p class="Pp">doy - Jesse Luehrs (cpan:DOY) &lt;doy at tozt dot net&gt;</p>
<p class="Pp">perigrin - Chris Prather (cpan:PERIGRIN)
  &lt;chris@prather.org&gt;</p>
<p class="Pp">Mithaldu - Christian Walde (cpan:MITHALDU)
    &lt;walde.christian@googlemail.com&gt;</p>
<p class="Pp">ilmari - Dagfinn Ilmari Manns&#x00E5;ker (cpan:ILMARI)
    &lt;ilmari@ilmari.org&gt;</p>
<p class="Pp">tobyink - Toby Inkster (cpan:TOBYINK) &lt;tobyink@cpan.org&gt;</p>
<p class="Pp">haarg - Graham Knop (cpan:HAARG) &lt;haarg@cpan.org&gt;</p>
<p class="Pp">mattp - Matt Phillips (cpan:MATTP) &lt;mattp@cpan.org&gt;</p>
<p class="Pp">bluefeet - Aran Deltac (cpan:BLUEFEET)
  &lt;bluefeet@gmail.com&gt;</p>
<p class="Pp">bubaflub - Bob Kuo (cpan:BUBAFLUB) &lt;bubaflub@cpan.org&gt;</p>
<p class="Pp">ether = Karen Etheridge (cpan:ETHER) &lt;ether@cpan.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 2010-2015 the Moo &quot;AUTHOR&quot; and
    &quot;CONTRIBUTORS&quot; as listed above.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">This library is free software and may be distributed under the
    same terms as perl itself. See &lt;https://dev.perl.org/licenses/&gt;.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-04-09</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

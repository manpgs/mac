<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Thread::Queue(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Thread::Queue(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Thread::Queue(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Thread::Queue - Thread-safe queues</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">This document describes Thread::Queue version 3.13</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use strict;
    use warnings;
    use threads;
    use Thread::Queue;
    my $q = Thread::Queue-&gt;new();    # A new empty queue
    # Worker thread
    my $thr = threads-&gt;create(
        sub {
            # Thread will loop until no more work
            while (defined(my $item = $q-&gt;dequeue())) {
                # Do work on $item
                ...
            }
        }
    );
    # Send work to the thread
    $q-&gt;enqueue($item1, ...);
    # Signal that there is no more work to be sent
    $q-&gt;end();
    # Join up with the thread when it finishes
    $thr-&gt;join();
    ...
    # Count of items in the queue
    my $left = $q-&gt;pending();
    # Non-blocking dequeue
    if (defined(my $item = $q-&gt;dequeue_nb())) {
        # Work on $item
    }
    # Blocking dequeue with 5-second timeout
    if (defined(my $item = $q-&gt;dequeue_timed(5))) {
        # Work on $item
    }
    # Set a size for a queue
    $q-&gt;limit = 5;
    # Get the second item in the queue without dequeuing anything
    my $item = $q-&gt;peek(1);
    # Insert two items into the queue just behind the head
    $q-&gt;insert(1, $item1, $item2);
    # Extract the last two items on the queue
    my ($item1, $item2) = $q-&gt;extract(-2, 2);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module provides thread-safe FIFO queues that can be accessed
    safely by any number of threads.</p>
<p class="Pp">Any data types supported by threads::shared can be passed via
    queues:</p>
<dl class="Bl-tag">
  <dt id="Ordinary"><a class="permalink" href="#Ordinary">Ordinary
    scalars</a></dt>
  <dd></dd>
  <dt id="Array"><a class="permalink" href="#Array">Array refs</a></dt>
  <dd></dd>
  <dt id="Hash"><a class="permalink" href="#Hash">Hash refs</a></dt>
  <dd></dd>
  <dt id="Scalar"><a class="permalink" href="#Scalar">Scalar refs</a></dt>
  <dd></dd>
  <dt id="Objects"><a class="permalink" href="#Objects">Objects based on the
    above</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Ordinary scalars are added to queues as they are.</p>
<p class="Pp">If not already thread-shared, the other complex data types will be
    cloned (recursively, if needed, and including any
    <span class="Li">&quot;bless&quot;</span>ings and read-only settings) into
    thread-shared structures before being placed onto a queue.</p>
<p class="Pp">For example, the following would cause Thread::Queue to create a
    empty, shared array reference via
    <span class="Li">&quot;&amp;shared([])&quot;</span>, copy the elements
    'foo', 'bar' and 'baz' from <span class="Li">@ary</span> into it, and then
    place that shared reference onto the queue:</p>
<p class="Pp"></p>
<pre> my @ary = qw/foo bar baz/;
 $q-&gt;enqueue(\@ary);
</pre>
<p class="Pp">However, for the following, the items are already shared, so their
    references are added directly to the queue, and no cloning takes place:</p>
<p class="Pp"></p>
<pre> my @ary :shared = qw/foo bar baz/;
 $q-&gt;enqueue(\@ary);
 my $obj = &amp;shared({});
 $$obj{'foo'} = 'bar';
 $$obj{'qux'} = 99;
 bless($obj, 'My::Class');
 $q-&gt;enqueue($obj);
</pre>
<p class="Pp">See &quot;LIMITATIONS&quot; for caveats related to passing objects
    via queues.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="QUEUE_CREATION"><a class="permalink" href="#QUEUE_CREATION">QUEUE
  CREATION</a></h1>
<dl class="Bl-tag">
  <dt>-&gt;<b>new()</b></dt>
  <dd>Creates a new empty queue.</dd>
  <dt>-&gt;new(LIST)</dt>
  <dd>Creates a new queue pre-populated with the provided list of items.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="BASIC_METHODS"><a class="permalink" href="#BASIC_METHODS">BASIC
  METHODS</a></h1>
<p class="Pp">The following methods deal with queues on a FIFO basis.</p>
<dl class="Bl-tag">
  <dt>-&gt;enqueue(LIST)</dt>
  <dd>Adds a list of items onto the end of the queue.</dd>
  <dt>-&gt;<b>dequeue()</b></dt>
  <dd></dd>
  <dt>-&gt;dequeue(COUNT)</dt>
  <dd>Removes the requested number of items (default is 1) from the head of the
      queue, and returns them. If the queue contains fewer than the requested
      number of items, then the thread will be blocked until the requisite
      number of items are available (i.e., until other threads
      <span class="Li">&quot;enqueue&quot;</span> more items).</dd>
  <dt>-&gt;<b>dequeue_nb()</b></dt>
  <dd></dd>
  <dt>-&gt;dequeue_nb(COUNT)</dt>
  <dd>Removes the requested number of items (default is 1) from the head of the
      queue, and returns them. If the queue contains fewer than the requested
      number of items, then it immediately (i.e., non-blocking) returns whatever
      items there are on the queue. If the queue is empty, then
      <span class="Li">&quot;undef&quot;</span> is returned.</dd>
  <dt>-&gt;dequeue_timed(TIMEOUT)</dt>
  <dd></dd>
  <dt>-&gt;dequeue_timed(TIMEOUT, COUNT)</dt>
  <dd>Removes the requested number of items (default is 1) from the head of the
      queue, and returns them. If the queue contains fewer than the requested
      number of items, then the thread will be blocked until the requisite
      number of items are available, or until the timeout is reached. If the
      timeout is reached, it returns whatever items there are on the queue, or
      <span class="Li">&quot;undef&quot;</span> if the queue is empty.
    <p class="Pp">The timeout may be a number of seconds relative to the current
        time (e.g., 5 seconds from when the call is made), or may be an absolute
        timeout in <i>epoch</i> seconds the same as would be used with
        <b>cond_timedwait()</b>. Fractional seconds (e.g., 2.5 seconds) are also
        supported (to the extent of the underlying implementation).</p>
    <p class="Pp">If <span class="Li">&quot;TIMEOUT&quot;</span> is missing,
        <span class="Li">&quot;undef&quot;</span>, or less than or equal to 0,
        then this call behaves the same as
        <span class="Li">&quot;dequeue_nb&quot;</span>.</p>
  </dd>
  <dt>-&gt;<b>pending()</b></dt>
  <dd>Returns the number of items still in the queue. Returns
      <span class="Li">&quot;undef&quot;</span> if the queue has been ended (see
      below), and there are no more items in the queue.</dd>
  <dt>-&gt;limit</dt>
  <dd>Sets the size of the queue. If set, calls to
      <span class="Li">&quot;enqueue()&quot;</span> will block until the number
      of pending items in the queue drops below the
      <span class="Li">&quot;limit&quot;</span>. The
      <span class="Li">&quot;limit&quot;</span> does not prevent enqueuing items
      beyond that count:
    <p class="Pp"></p>
    <pre> my $q = Thread::Queue-&gt;new(1, 2);
 $q-&gt;limit = 4;
 $q-&gt;enqueue(3, 4, 5);   # Does not block
 $q-&gt;enqueue(6);         # Blocks until at least 2 items are
                         # dequeued
 my $size = $q-&gt;limit;   # Returns the current limit (may return
                         # 'undef')
 $q-&gt;limit = 0;          # Queue size is now unlimited
    </pre>
    <p class="Pp">Calling any of the dequeue methods with
        <span class="Li">&quot;COUNT&quot;</span> greater than a queue's
        <span class="Li">&quot;limit&quot;</span> will generate an error.</p>
  </dd>
  <dt>-&gt;<b>end()</b></dt>
  <dd>Declares that no more items will be added to the queue.
    <p class="Pp">All threads blocking on
        <span class="Li">&quot;dequeue()&quot;</span> calls will be unblocked
        with any remaining items in the queue and/or
        <span class="Li">&quot;undef&quot;</span> being returned. Any subsequent
        calls to <span class="Li">&quot;dequeue()&quot;</span> will behave like
        <span class="Li">&quot;dequeue_nb()&quot;</span>.</p>
    <p class="Pp">Once ended, no more items may be placed in the queue.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="ADVANCED_METHODS"><a class="permalink" href="#ADVANCED_METHODS">ADVANCED
  METHODS</a></h1>
<p class="Pp">The following methods can be used to manipulate items anywhere in
    a queue.</p>
<p class="Pp">To prevent the contents of a queue from being modified by another
    thread while it is being examined and/or changed, lock the queue inside a
    local block:</p>
<p class="Pp"></p>
<pre> {
     lock($q);   # Keep other threads from changing the queue's contents
     my $item = $q-&gt;peek();
     if ($item ...) {
         ...
     }
 }
 # Queue is now unlocked
</pre>
<dl class="Bl-tag">
  <dt>-&gt;<b>peek()</b></dt>
  <dd></dd>
  <dt>-&gt;peek(INDEX)</dt>
  <dd>Returns an item from the queue without dequeuing anything. Defaults to the
      the head of queue (at index position 0) if no index is specified. Negative
      index values are supported as with arrays (i.e., -1 is the end of the
      queue, -2 is next to last, and so on).
    <p class="Pp">If no items exists at the specified index (i.e., the queue is
        empty, or the index is beyond the number of items on the queue), then
        <span class="Li">&quot;undef&quot;</span> is returned.</p>
    <p class="Pp">Remember, the returned item is not removed from the queue, so
        manipulating a <span class="Li">&quot;peek&quot;</span>ed at reference
        affects the item on the queue.</p>
  </dd>
  <dt>-&gt;insert(INDEX, LIST)</dt>
  <dd>Adds the list of items to the queue at the specified index position (0 is
      the head of the list). Any existing items at and beyond that position are
      pushed back past the newly added items:
    <p class="Pp"></p>
    <pre> $q-&gt;enqueue(1, 2, 3, 4);
 $q-&gt;insert(1, qw/foo bar/);
 # Queue now contains:  1, foo, bar, 2, 3, 4
    </pre>
    <p class="Pp">Specifying an index position greater than the number of items
        in the queue just adds the list to the end.</p>
    <p class="Pp">Negative index positions are supported:</p>
    <p class="Pp"></p>
    <pre> $q-&gt;enqueue(1, 2, 3, 4);
 $q-&gt;insert(-2, qw/foo bar/);
 # Queue now contains:  1, 2, foo, bar, 3, 4
    </pre>
    <p class="Pp">Specifying a negative index position greater than the number
        of items in the queue adds the list to the head of the queue.</p>
  </dd>
  <dt>-&gt;<b>extract()</b></dt>
  <dd></dd>
  <dt>-&gt;extract(INDEX)</dt>
  <dd></dd>
  <dt>-&gt;extract(INDEX, COUNT)</dt>
  <dd>Removes and returns the specified number of items (defaults to 1) from the
      specified index position in the queue (0 is the head of the queue). When
      called with no arguments, <span class="Li">&quot;extract&quot;</span>
      operates the same as <span class="Li">&quot;dequeue_nb&quot;</span>.
    <p class="Pp">This method is non-blocking, and will return only as many
        items as are available to fulfill the request:</p>
    <p class="Pp"></p>
    <pre> $q-&gt;enqueue(1, 2, 3, 4);
 my $item  = $q-&gt;extract(2)     # Returns 3
                                # Queue now contains:  1, 2, 4
 my @items = $q-&gt;extract(1, 3)  # Returns (2, 4)
                                # Queue now contains:  1
    </pre>
    <p class="Pp">Specifying an index position greater than the number of items
        in the queue results in <span class="Li">&quot;undef&quot;</span> or an
        empty list being returned.</p>
    <p class="Pp"></p>
    <pre> $q-&gt;enqueue('foo');
 my $nada = $q-&gt;extract(3)      # Returns undef
 my @nada = $q-&gt;extract(1, 3)   # Returns ()
    </pre>
    <p class="Pp">Negative index positions are supported. Specifying a negative
        index position greater than the number of items in the queue may return
        items from the head of the queue (similar to
        <span class="Li">&quot;dequeue_nb&quot;</span>) if the count overlaps
        the head of the queue from the specified position (i.e. if queue size +
        index + count is greater than zero):</p>
    <p class="Pp"></p>
    <pre> $q-&gt;enqueue(qw/foo bar baz/);
 my @nada = $q-&gt;extract(-6, 2);  # Returns ()      - (3+(-6)+2) &lt;= 0
 my @some = $q-&gt;extract(-6, 4);  # Returns (foo)   - (3+(-6)+4) &gt; 0
                                 # Queue now contains:  bar, baz
 my @rest = $q-&gt;extract(-3, 4);  # Returns (bar, baz) -
                                 #                   (2+(-3)+4) &gt; 0
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<p class="Pp">Queues created by Thread::Queue can be used in both threaded and
    non-threaded applications.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LIMITATIONS"><a class="permalink" href="#LIMITATIONS">LIMITATIONS</a></h1>
<p class="Pp">Passing objects on queues may not work if the objects' classes do
    not support sharing. See &quot;BUGS AND LIMITATIONS&quot; in threads::shared
    for more.</p>
<p class="Pp">Passing array/hash refs that contain objects may not work for Perl
    prior to 5.10.0.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Thread::Queue on MetaCPAN:
    &lt;https://metacpan.org/release/Thread-Queue&gt;</p>
<p class="Pp">Code repository for CPAN distribution:
    &lt;https://github.com/Dual-Life/Thread-Queue&gt;</p>
<p class="Pp">threads, threads::shared</p>
<p class="Pp">Sample code in the <i>examples</i> directory of this distribution
    on CPAN.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MAINTAINER"><a class="permalink" href="#MAINTAINER">MAINTAINER</a></h1>
<p class="Pp">Jerry D. Hedden,
    &lt;jdhedden&#x00A0;AT&#x00A0;cpan&#x00A0;DOT&#x00A0;org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>MooseX::Types::Structured(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">MooseX::Types::Structured(3pm)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">MooseX::Types::Structured(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">MooseX::Types::Structured - Structured Type Constraints for
  Moose</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 0.36</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">The following is example usage for this module.</p>
<p class="Pp"></p>
<pre>    package Person;
    use Moose;
    use MooseX::Types::Moose qw(Str Int HashRef);
    use MooseX::Types::Structured qw(Dict Tuple Optional);
    ## A name has a first and last part, but middle names are not required
    has name =&gt; (
        isa=&gt;Dict[
            first =&gt; Str,
            last =&gt; Str,
            middle =&gt; Optional[Str],
        ],
    );
    ## description is a string field followed by a HashRef of tagged data.
    has description =&gt; (
      isa=&gt;Tuple[
        Str,
        Optional[HashRef],
     ],
    );
    ## Remainder of your class attributes and methods
</pre>
<p class="Pp">Then you can instantiate this class with something like:</p>
<p class="Pp"></p>
<pre>    my $john = Person-&gt;new(
        name =&gt; {
            first =&gt; 'John',
            middle =&gt; 'James'
            last =&gt; 'Napiorkowski',
        },
        description =&gt; [
            'A cool guy who loves Perl and Moose.', {
                married_to =&gt; 'Vanessa Li',
                born_in =&gt; 'USA',
            };
        ]
    );
</pre>
<p class="Pp">Or with:</p>
<p class="Pp"></p>
<pre>    my $vanessa = Person-&gt;new(
        name =&gt; {
            first =&gt; 'Vanessa',
            last =&gt; 'Li'
        },
        description =&gt; ['A great student!'],
    );
</pre>
<p class="Pp">But all of these would cause a constraint error for the
    <span class="Li">&quot;name&quot;</span> attribute:</p>
<p class="Pp"></p>
<pre>    ## Value for 'name' not a HashRef
    Person-&gt;new( name =&gt; 'John' );
    ## Value for 'name' has incorrect hash key and missing required keys
    Person-&gt;new( name =&gt; {
        first_name =&gt; 'John'
    });
    ## Also incorrect keys
    Person-&gt;new( name =&gt; {
        first_name =&gt; 'John',
        age =&gt; 39,
    });
    ## key 'middle' incorrect type, should be a Str not a ArrayRef
    Person-&gt;new( name =&gt; {
        first =&gt; 'Vanessa',
        middle =&gt; [1,2],
        last =&gt; 'Li',
    });
</pre>
<p class="Pp">And these would cause a constraint error for the
    <span class="Li">&quot;description&quot;</span> attribute:</p>
<p class="Pp"></p>
<pre>    ## Should be an ArrayRef
    Person-&gt;new( description =&gt; 'Hello I am a String' );
    ## First element must be a string not a HashRef.
    Person-&gt;new (description =&gt; [{
        tag1 =&gt; 'value1',
        tag2 =&gt; 'value2'
    }]);
</pre>
<p class="Pp">Please see the test cases for more examples.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">A structured type constraint is a standard container Moose type
    constraint, such as an <span class="Li">&quot;ArrayRef&quot;</span> or
    <span class="Li">&quot;HashRef&quot;</span>, which has been enhanced to
    allow you to explicitly name all the allowed type constraints inside the
    structure. The generalized form is:</p>
<p class="Pp"></p>
<pre>    TypeConstraint[@TypeParameters or %TypeParameters]
</pre>
<p class="Pp">Where <span class="Li">&quot;TypeParameters&quot;</span> is an
    array reference or hash references of Moose::Meta::TypeConstraint
  objects.</p>
<p class="Pp">This type library enables structured type constraints. It is built
    on top of the MooseX::Types library system, so you should review the
    documentation for that if you are not familiar with it.</p>
<section class="Ss">
<h2 class="Ss" id="Comparing_Parameterized_types_to_Structured_types"><a class="permalink" href="#Comparing_Parameterized_types_to_Structured_types">Comparing
  Parameterized types to Structured types</a></h2>
<p class="Pp">Parameterized constraints are built into core Moose and you are
    probably already familiar with the type constraints
    <span class="Li">&quot;HashRef&quot;</span> and
    <span class="Li">&quot;ArrayRef&quot;</span>. Structured types have similar
    functionality, so their syntax is likewise similar. For example, you could
    define a parameterized constraint like:</p>
<p class="Pp"></p>
<pre>    subtype ArrayOfInts,
     as ArrayRef[Int];
</pre>
<p class="Pp">which would constrain a value to something like [1,2,3,...] and so
    on. On the other hand, a structured type constraint explicitly names all
    it's allowed 'internal' type parameter constraints. For the example:</p>
<p class="Pp"></p>
<pre>    subtype StringFollowedByInt,
     as Tuple[Str,Int];
</pre>
<p class="Pp">would constrain its value to things like
    <span class="Li">&quot;['hello', 111]&quot;</span> but
    <span class="Li">&quot;['hello', 'world']&quot;</span> would fail, as well
    as <span class="Li">&quot;['hello', 111, 'world']&quot;</span> and so on.
    Here's another example:</p>
<p class="Pp"></p>
<pre>        package MyApp::Types;
    use MooseX::Types -declare [qw(StringIntOptionalHashRef)];
    use MooseX::Types::Moose qw(Str Int);
    use MooseX::Types::Structured qw(Tuple Optional);
    subtype StringIntOptionalHashRef,
     as Tuple[
        Str, Int,
        Optional[HashRef]
     ];
</pre>
<p class="Pp">This defines a type constraint that validates values like:</p>
<p class="Pp"></p>
<pre>    ['Hello', 100, {key1 =&gt; 'value1', key2 =&gt; 'value2'}];
    ['World', 200];
</pre>
<p class="Pp">Notice that the last type constraint in the structure is optional.
    This is enabled via the helper <span class="Li">&quot;Optional&quot;</span>
    type constraint, which is a variation of the core Moose type constraint
    <span class="Li">&quot;Maybe&quot;</span>. The main difference is that
    <span class="Li">&quot;Optional&quot;</span> type constraints are required
    to validate if they exist, while <span class="Li">&quot;Maybe&quot;</span>
    permits undefined values. So the following example would not validate:</p>
<p class="Pp"></p>
<pre>    StringIntOptionalHashRef-&gt;validate(['Hello Undefined', 1000, undef]);
</pre>
<p class="Pp">Please note the subtle difference between undefined and null. If
    you wish to allow both null and undefined, you should use the core Moose
    <span class="Li">&quot;Maybe&quot;</span> type constraint instead:</p>
<p class="Pp"></p>
<pre>    package MyApp::Types;
    use MooseX::Types -declare [qw(StringIntMaybeHashRef)];
    use MooseX::Types::Moose qw(Str Int Maybe);
    use MooseX::Types::Structured qw(Tuple);
    subtype StringIntMaybeHashRef,
     as Tuple[
        Str, Int, Maybe[HashRef]
     ];
</pre>
<p class="Pp">This would validate the following:</p>
<p class="Pp"></p>
<pre>    ['Hello', 100, {key1 =&gt; 'value1', key2 =&gt; 'value2'}];
    ['World', 200, undef];
    ['World', 200];
</pre>
<p class="Pp">Structured constraints are not limited to arrays. You can define a
    structure against a <span class="Li">&quot;HashRef&quot;</span> with the
    <span class="Li">&quot;Dict&quot;</span> type constraint as in this
  example:</p>
<p class="Pp"></p>
<pre>    subtype FirstNameLastName,
     as Dict[
        firstname =&gt; Str,
        lastname =&gt; Str,
     ];
</pre>
<p class="Pp">This would constrain a <span class="Li">&quot;HashRef&quot;</span>
    that validates something like:</p>
<p class="Pp"></p>
<pre>    {firstname =&gt; 'Christopher', lastname =&gt; 'Parsons'};
</pre>
<p class="Pp">but all the following would fail validation:</p>
<p class="Pp"></p>
<pre>    ## Incorrect keys
    {first =&gt; 'Christopher', last =&gt; 'Parsons'};
    ## Too many keys
    {firstname =&gt; 'Christopher', lastname =&gt; 'Parsons', middlename =&gt; 'Allen'};
    ## Not a HashRef
    ['Christopher', 'Parsons'];
</pre>
<p class="Pp">These structures can be as simple or elaborate as you wish. You
    can even combine various structured, parameterized and simple constraints
    all together:</p>
<p class="Pp"></p>
<pre>    subtype Crazy,
     as Tuple[
        Int,
        Dict[name=&gt;Str, age=&gt;Int],
        ArrayRef[Int]
     ];
</pre>
<p class="Pp">Which would match:</p>
<p class="Pp"></p>
<pre>    [1, {name=&gt;'John', age=&gt;25},[10,11,12]];
</pre>
<p class="Pp">Please notice how the type parameters can be visually arranged to
    your liking and to improve the clarity of your meaning. You don't need to
    run then altogether onto a single line. Additionally, since the
    <span class="Li">&quot;Dict&quot;</span> type constraint defines a hash
    constraint, the key order is not meaningful. For example:</p>
<p class="Pp"></p>
<pre>    subtype AnyKeyOrder,
      as Dict[
        key1=&gt;Int,
        key2=&gt;Str,
        key3=&gt;Int,
     ];
</pre>
<p class="Pp">Would validate both:</p>
<p class="Pp"></p>
<pre>    {key1 =&gt; 1, key2 =&gt; &quot;Hi!&quot;, key3 =&gt; 2};
    {key2 =&gt; &quot;Hi!&quot;, key1 =&gt; 100, key3 =&gt; 300};
</pre>
<p class="Pp">As you would expect, since underneath it's just a plain old Perl
    hash at work.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Alternatives"><a class="permalink" href="#Alternatives">Alternatives</a></h2>
<p class="Pp">You should exercise some care as to whether or not your complex
    structured constraints would be better off contained by a real object as in
    the following example:</p>
<p class="Pp"></p>
<pre>    package MyApp::MyStruct;
    use Moose;
    ## lazy way to make a bunch of attributes
    has $_ for qw(full_name age_in_years);
    package MyApp::MyClass;
    use Moose;
    has person =&gt; (isa =&gt; 'MyApp::MyStruct');
    my $instance = MyApp::MyClass-&gt;new(
        person=&gt;MyApp::MyStruct-&gt;new(
            full_name =&gt; 'John',
            age_in_years =&gt; 39,
        ),
    );
</pre>
<p class="Pp">This method may take some additional time to set up but will give
    you more flexibility. However, structured constraints are highly compatible
    with this method, granting some interesting possibilities for coercion.
  Try:</p>
<p class="Pp"></p>
<pre>    package MyApp::MyClass;
    use Moose;
    use MyApp::MyStruct;
    ## It's recommended your type declarations live in a separate class in order
    ## to promote reusability and clarity.  Inlined here for brevity.
    use MooseX::Types::DateTime qw(DateTime);
    use MooseX::Types -declare [qw(MyStruct)];
    use MooseX::Types::Moose qw(Str Int);
    use MooseX::Types::Structured qw(Dict);
    ## Use class_type to create an ISA type constraint if your object doesn't
    ## inherit from Moose::Object.
    class_type 'MyApp::MyStruct';
    ## Just a shorter version really.
    subtype MyStruct,
     as 'MyApp::MyStruct';
    ## Add the coercions.
    coerce MyStruct,
     from Dict[
        full_name=&gt;Str,
        age_in_years=&gt;Int
     ], via {
        MyApp::MyStruct-&gt;new(%$_);
     },
     from Dict[
        lastname=&gt;Str,
        firstname=&gt;Str,
        dob=&gt;DateTime
     ], via {
        my $name = $_-&gt;{firstname} .' '. $_-&gt;{lastname};
        my $age = DateTime-&gt;now - $_-&gt;{dob};
        MyApp::MyStruct-&gt;new(
            full_name=&gt;$name,
            age_in_years=&gt;$age-&gt;years,
        );
     };
    has person =&gt; (isa=&gt;MyStruct);
</pre>
<p class="Pp">This would allow you to instantiate with something like:</p>
<p class="Pp"></p>
<pre>    my $obj = MyApp::MyClass-&gt;new( person =&gt; {
        full_name=&gt;'John Napiorkowski',
        age_in_years=&gt;39,
    });
</pre>
<p class="Pp">Or even:</p>
<p class="Pp"></p>
<pre>    my $obj = MyApp::MyClass-&gt;new( person =&gt; {
        lastname=&gt;'John',
        firstname=&gt;'Napiorkowski',
        dob=&gt;DateTime-&gt;new(year=&gt;1969),
    });
</pre>
<p class="Pp">If you are not familiar with how coercions work, check out the
    Moose cookbook entry Moose::Cookbook::Recipe5 for an explanation. The
    section &quot;Coercions&quot; has additional examples and discussion.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Subtyping_a_Structured_type_constraint"><a class="permalink" href="#Subtyping_a_Structured_type_constraint">Subtyping
  a Structured type constraint</a></h2>
<p class="Pp">You need to exercise some care when you try to subtype a
    structured type as in this example:</p>
<p class="Pp"></p>
<pre>    subtype Person,
     as Dict[name =&gt; Str];
    subtype FriendlyPerson,
     as Person[
        name =&gt; Str,
        total_friends =&gt; Int,
     ];
</pre>
<p class="Pp">This will actually work BUT you have to take care that the subtype
    has a structure that does not contradict the structure of it's parent. For
    now the above works, but I will clarify the syntax for this at a future
    point, so it's recommended to avoid (should not really be needed so much
    anyway). For now this is supported in an EXPERIMENTAL way. Your thoughts,
    test cases and patches are welcomed for discussion. If you find a good use
    for this, please let me know.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Coercions"><a class="permalink" href="#Coercions">Coercions</a></h2>
<p class="Pp">Coercions currently work for 'one level' deep. That is you can
  do:</p>
<p class="Pp"></p>
<pre>    subtype Person,
     as Dict[
        name =&gt; Str,
        age =&gt; Int
    ];
    subtype Fullname,
     as Dict[
        first =&gt; Str,
        last =&gt; Str
     ];
    coerce Person,
     ## Coerce an object of a particular class
     from BlessedPersonObject, via {
        +{
            name=&gt;$_-&gt;name,
            age=&gt;$_-&gt;age,
        };
     },
     ## Coerce from [$name, $age]
     from ArrayRef, via {
        +{
            name=&gt;$_-&gt;[0],
            age=&gt;$_-&gt;[1],
        },
     },
     ## Coerce from {fullname=&gt;{first=&gt;...,last=&gt;...}, dob=&gt;$DateTimeObject}
     from Dict[fullname=&gt;Fullname, dob=&gt;DateTime], via {
        my $age = $_-&gt;dob - DateTime-&gt;now;
        my $firstn = $_-&gt;{fullname}-&gt;{first};
        my $lastn = $_-&gt;{fullname}-&gt;{last}
        +{
            name =&gt; $_-&gt;{fullname}-&gt;{first} .' '. ,
            age =&gt;$age-&gt;years
        }
     };
</pre>
<p class="Pp">And that should just work as expected. However, if there are any
    'inner' coercions, such as a coercion on
    <span class="Li">&quot;Fullname&quot;</span> or on
    <span class="Li">&quot;DateTime&quot;</span>, that coercion won't currently
    get activated.</p>
<p class="Pp">Please see the test <i>07-coerce.t</i> for a more detailed
    example. Discussion on extending coercions to support this welcome on the
    Moose development channel or mailing list.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Recursion"><a class="permalink" href="#Recursion">Recursion</a></h2>
<p class="Pp">Newer versions of MooseX::Types support recursive type
    constraints. That is you can include a type constraint as a contained type
    constraint of itself. For example:</p>
<p class="Pp"></p>
<pre>    subtype Person,
     as Dict[
         name=&gt;Str,
         friends=&gt;Optional[
             ArrayRef[Person]
         ],
     ];
</pre>
<p class="Pp">This would declare a <span class="Li">&quot;Person&quot;</span>
    subtype that contains a name and an optional
    <span class="Li">&quot;ArrayRef&quot;</span> of
    <span class="Li">&quot;Person&quot;</span>s who are friends as in:</p>
<p class="Pp"></p>
<pre>    {
        name =&gt; 'Mike',
        friends =&gt; [
            { name =&gt; 'John' },
            { name =&gt; 'Vincent' },
            {
                name =&gt; 'Tracey',
                friends =&gt; [
                    { name =&gt; 'Stephenie' },
                    { name =&gt; 'Ilya' },
                ],
            },
        ],
    };
</pre>
<p class="Pp">Please take care to make sure the recursion node is either
    <span class="Li">&quot;Optional&quot;</span>, or declare a union with an
    non-recursive option such as:</p>
<p class="Pp"></p>
<pre>    subtype Value
     as Tuple[
         Str,
         Str|Tuple,
     ];
</pre>
<p class="Pp">Which validates:</p>
<p class="Pp"></p>
<pre>    [
        'Hello', [
            'World', [
                'Is', [
                    'Getting',
                    'Old',
                ],
            ],
        ],
    ];
</pre>
<p class="Pp">Otherwise you will define a subtype that is impossible to validate
    since it is infinitely recursive. For more information about defining
    recursive types, please see the documentation in MooseX::Types and the test
    cases.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TYPE_CONSTRAINTS"><a class="permalink" href="#TYPE_CONSTRAINTS">TYPE
  CONSTRAINTS</a></h1>
<p class="Pp">This type library defines the following constraints.</p>
<section class="Ss">
<h2 class="Ss" id="Tuple_@constraints_"><a class="permalink" href="#Tuple_@constraints_">Tuple[@constraints]</a></h2>
<p class="Pp">This defines an ArrayRef based constraint which allows you to
    validate a specific list of contained constraints. For example:</p>
<p class="Pp"></p>
<pre>    Tuple[Int,Str]; ## Validates [1,'hello']
    Tuple[Str|Object, Int]; ## Validates ['hello', 1] or [$object, 2]
</pre>
<p class="Pp">The Values of <span class="Li">@constraints</span> should ideally
    be MooseX::Types declared type constraints. We do support 'old style' Moose
    string based constraints to a limited degree but these string type
    constraints are considered deprecated. There will be limited support for
    bugs resulting from mixing string and MooseX::Types in your structures. If
    you encounter such a bug and really need it fixed, we will required a
    detailed test case at the minimum.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Dict__constraints_"><a class="permalink" href="#Dict__constraints_">Dict[%constraints]</a></h2>
<p class="Pp">This defines a HashRef based constraint which allowed you to
    validate a specific hashref. For example:</p>
<p class="Pp"></p>
<pre>    Dict[name=&gt;Str, age=&gt;Int]; ## Validates {name=&gt;'John', age=&gt;39}
</pre>
<p class="Pp">The keys in <span class="Li">%constraints</span> follow the same
    rules as <span class="Li">@constraints</span> in the above section.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Map__$key_constraint,_$value_constraint__"><a class="permalink" href="#Map__$key_constraint,_$value_constraint__">Map[
  $key_constraint, $value_constraint ]</a></h2>
<p class="Pp">This defines a <span class="Li">&quot;HashRef&quot;</span>-based
    constraint in which both the keys and values are required to meet certain
    constraints. For example, to map hostnames to IP addresses, you might
  say:</p>
<p class="Pp"></p>
<pre>  Map[ HostName, IPAddress ]
</pre>
<p class="Pp">The type constraint would only be met if every key was a valid
    <span class="Li">&quot;HostName&quot;</span> and every value was a valid
    <span class="Li">&quot;IPAddress&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Optional_$constraint_"><a class="permalink" href="#Optional_$constraint_">Optional[$constraint]</a></h2>
<p class="Pp">This is primarily a helper constraint for
    <span class="Li">&quot;Dict&quot;</span> and
    <span class="Li">&quot;Tuple&quot;</span> type constraints. What this allows
    is for you to assert that a given type constraint is allowed to be null (but
    NOT undefined). If the value is null, then the type constraint passes but if
    the value is defined it must validate against the type constraint. This
    makes it easy to make a Dict where one or more of the keys doesn't have to
    exist or a tuple where some of the values are not required. For example:</p>
<p class="Pp"></p>
<pre>    subtype Name() =&gt; as Dict[
        first=&gt;Str,
        last=&gt;Str,
        middle=&gt;Optional[Str],
    ];
</pre>
<p class="Pp">...creates a constraint that validates against a hashref with the
    keys 'first' and 'last' being strings and required while an optional key
    'middle' is must be a string if it appears but doesn't have to appear. So in
    this case both the following are valid:</p>
<p class="Pp"></p>
<pre>    {first=&gt;'John', middle=&gt;'James', last=&gt;'Napiorkowski'}
    {first=&gt;'Vanessa', last=&gt;'Li'}
</pre>
<p class="Pp">If you use the <span class="Li">&quot;Maybe&quot;</span> type
    constraint instead, your values will also validate against
    <span class="Li">&quot;undef&quot;</span>, which may be incorrect for
  you.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTABLE_SUBROUTINES"><a class="permalink" href="#EXPORTABLE_SUBROUTINES">EXPORTABLE
  SUBROUTINES</a></h1>
<p class="Pp">This type library makes available for export the following
    subroutines</p>
<section class="Ss">
<h2 class="Ss" id="slurpy"><a class="permalink" href="#slurpy">slurpy</a></h2>
<p class="Pp">Structured type constraints by their nature are closed; that is
    validation will depend on an exact match between your structure definition
    and the arguments to be checked. Sometimes you might wish for a slightly
    looser amount of validation. For example, you may wish to validate the first
    3 elements of an array reference and allow for an arbitrary number of
    additional elements. At first thought you might think you could do it this
    way:</p>
<p class="Pp"></p>
<pre>    #  I want to validate stuff like: [1,&quot;hello&quot;, $obj, 2,3,4,5,6,...]
    subtype AllowTailingArgs,
     as Tuple[
       Int,
       Str,
       Object,
       ArrayRef[Int],
     ];
</pre>
<p class="Pp">However what this will actually validate are structures like
  this:</p>
<p class="Pp"></p>
<pre>    [10,&quot;Hello&quot;, $obj, [11,12,13,...] ]; # Notice element 4 is an ArrayRef
</pre>
<p class="Pp">In order to allow structured validation of, &quot;and then
    some&quot;, arguments, you can use the &quot;slurpy&quot; method against a
    type constraint. For example:</p>
<p class="Pp"></p>
<pre>    use MooseX::Types::Structured qw(Tuple slurpy);
    subtype AllowTailingArgs,
     as Tuple[
       Int,
       Str,
       Object,
       slurpy ArrayRef[Int],
     ];
</pre>
<p class="Pp">This will now work as expected, validating ArrayRef structures
    such as:</p>
<p class="Pp"></p>
<pre>    [1,&quot;hello&quot;, $obj, 2,3,4,5,6,...]
</pre>
<p class="Pp">A few caveats apply. First, the slurpy type constraint must be the
    last one in the list of type constraint parameters. Second, the parent type
    of the slurpy type constraint must match that of the containing type
    constraint. That means that a <span class="Li">&quot;Tuple&quot;</span> can
    allow a slurpy <span class="Li">&quot;ArrayRef&quot;</span> (or children of
    <span class="Li">&quot;ArrayRef&quot;</span>s, including another
    <span class="Li">&quot;Tuple&quot;</span>) and a
    <span class="Li">&quot;Dict&quot;</span> can allow a slurpy
    <span class="Li">&quot;HashRef&quot;</span> (or children/subtypes of
    HashRef, also including other <span class="Li">&quot;Dict&quot;</span>
    constraints).</p>
<p class="Pp">Please note the technical way this works 'under the hood' is that
    the slurpy keyword transforms the target type constraint into a coderef.
    Please do not try to create your own custom coderefs; always use the slurpy
    method. The underlying technology may change in the future but the slurpy
    keyword will be supported.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ERROR_MESSAGES"><a class="permalink" href="#ERROR_MESSAGES">ERROR
  MESSAGES</a></h1>
<p class="Pp">Error reporting has been improved to return more useful debugging
    messages. Now I will stringify the incoming check value with
    Devel::PartialDump so that you can see the actual structure that is tripping
    up validation. Also, I report the 'internal' validation error, so that if a
    particular element inside the Structured Type is failing validation, you
    will see that. There's a limit to how deep this internal reporting goes, but
    you shouldn't see any of the &quot;failed with ARRAY(XXXXXX)&quot; that we
    got with earlier versions of this module.</p>
<p class="Pp">This support is continuing to expand, so it's best to use these
    messages for debugging purposes and not for creating messages that 'escape
    into the wild' such as error messages sent to the user.</p>
<p class="Pp">Please see the test '12-error.t' for a more lengthy example. Your
    thoughts and preferable tests or code patches very welcome!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">Here are some additional example usage for structured types. All
    examples can be found also in the 't/examples.t' test. Your contributions
    are also welcomed.</p>
<section class="Ss">
<h2 class="Ss" id="Normalize_a_HashRef"><a class="permalink" href="#Normalize_a_HashRef">Normalize
  a HashRef</a></h2>
<p class="Pp">You need a hashref to conform to a canonical structure but are
    required accept a bunch of different incoming structures. You can normalize
    using the <span class="Li">&quot;Dict&quot;</span> type constraint and
    coercions. This example also shows structured types mixed which other
    MooseX::Types libraries.</p>
<p class="Pp"></p>
<pre>    package Test::MooseX::Meta::TypeConstraint::Structured::Examples::Normalize;
    use Moose;
    use DateTime;
    use MooseX::Types::Structured qw(Dict Tuple);
    use MooseX::Types::DateTime qw(DateTime);
    use MooseX::Types::Moose qw(Int Str Object);
    use MooseX::Types -declare =&gt; [qw(Name Age Person)];
    subtype Person,
     as Dict[
         name=&gt;Str,
         age=&gt;Int,
     ];
    coerce Person,
     from Dict[
         first=&gt;Str,
         last=&gt;Str,
         years=&gt;Int,
     ], via { +{
        name =&gt; &quot;$_-&gt;{first} $_-&gt;{last}&quot;,
        age =&gt; $_-&gt;{years},
     }},
     from Dict[
         fullname=&gt;Dict[
             last=&gt;Str,
             first=&gt;Str,
         ],
         dob=&gt;DateTime,
     ],
     ## DateTime needs to be inside of single quotes here to disambiguate the
     ## class package from the DataTime type constraint imported via the
     ## line &quot;use MooseX::Types::DateTime qw(DateTime);&quot;
     via { +{
        name =&gt; &quot;$_-&gt;{fullname}{first} $_-&gt;{fullname}{last}&quot;,
        age =&gt; ($_-&gt;{dob} - 'DateTime'-&gt;now)-&gt;years,
     }};
    has person =&gt; (is=&gt;'rw', isa=&gt;Person, coerce=&gt;1);
</pre>
<p class="Pp">And now you can instantiate with all the following:</p>
<p class="Pp"></p>
<pre>    __PACKAGE__-&gt;new(
        person=&gt;{
            name=&gt;'John Napiorkowski',
            age=&gt;39,
        },
    );
    __PACKAGE__-&gt;new(
        person=&gt;{
            first=&gt;'John',
            last=&gt;'Napiorkowski',
            years=&gt;39,
        },
    );
    __PACKAGE__-&gt;new(
        person=&gt;{
            fullname =&gt; {
                first=&gt;'John',
                last=&gt;'Napiorkowski'
            },
            dob =&gt; 'DateTime'-&gt;new(
                year=&gt;1969,
                month=&gt;2,
                day=&gt;13
            ),
        },
    );
</pre>
<p class="Pp">This technique is a way to support various ways to instantiate
    your class in a clean and declarative way.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">The following modules or resources may be of interest.</p>
<p class="Pp">Moose, MooseX::Types, Moose::Meta::TypeConstraint,
    MooseX::Meta::TypeConstraint::Structured</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
<p class="Pp">Bugs may be submitted through the RT bug tracker
    &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=MooseX-Types-Structured&gt;
    (or bug-MooseX-Types-Structured@rt.cpan.org
    &lt;mailto:bug-MooseX-Types-Structured@rt.cpan.org&gt;).</p>
<p class="Pp">There is also a mailing list available for users of this
    distribution, at &lt;http://lists.perl.org/list/moose.html&gt;.</p>
<p class="Pp">There is also an irc channel available for users of this
    distribution, at <span class="Li">&quot;#moose&quot;</span> on
    <span class="Li">&quot;irc.perl.org&quot;</span>
    &lt;irc://irc.perl.org/#moose&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>John Napiorkowski &lt;jjnapiork@cpan.org&gt;</li>
  <li>Florian Ragwitz &lt;rafl@debian.org&gt;</li>
  <li>XXXX XXX'XX (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</li>
  <li>Tomas (t0m) Doran &lt;bobtfish@bobtfish.net&gt;</li>
  <li>Robert Sedlacek &lt;rs@474.at&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<ul class="Bl-bullet">
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Ricardo Signes &lt;rjbs@cpan.org&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>Ansgar Burchardt &lt;ansgar@43-1.org&gt;</li>
  <li>Stevan Little &lt;stevan.little@iinteractive.com&gt;</li>
  <li>arcanez &lt;justin.d.hunter@gmail.com&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
  <li>D. Ilmari Mannsaaker &lt;ilmari@cpan.org&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2008 by John Napiorkowski.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-05-09</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

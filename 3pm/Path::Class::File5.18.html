<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Path::Class::File(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Path::Class::File(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Path::Class::File(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Path::Class::File - Objects representing files</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 0.33</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
  use Path::Class;  # Exports file() by default
  
  my $file = file('foo', 'bar.txt');  # Path::Class::File object
  my $file = Path::Class::File-&gt;new('foo', 'bar.txt'); # Same thing
  
  # Stringifies to 'foo/bar.txt' on Unix, 'foo\bar.txt' on Windows, etc.
  print &quot;file: $file\n&quot;;
  
  if ($file-&gt;is_absolute) { ... }
  if ($file-&gt;is_relative) { ... }
  
  my $v = $file-&gt;volume; # Could be 'C:' on Windows, empty string
                         # on Unix, 'Macintosh HD:' on Mac OS
  
  $file-&gt;cleanup; # Perform logical cleanup of pathname
  $file-&gt;resolve; # Perform physical cleanup of pathname
  
  my $dir = $file-&gt;dir;  # A Path::Class::Dir object
  
  my $abs = $file-&gt;absolute; # Transform to absolute path
  my $rel = $file-&gt;relative; # Transform to relative path
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The <span class="Li">&quot;Path::Class::File&quot;</span> class
    contains functionality for manipulating file names in a cross-platform
  way.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<dl class="Bl-tag">
  <dt>$file = Path::Class::File-&gt;new( &lt;dir1&gt;, &lt;dir2&gt;, ...,
    &lt;file&gt; )</dt>
  <dd></dd>
  <dt>$file = file( &lt;dir1&gt;, &lt;dir2&gt;, ..., &lt;file&gt; )</dt>
  <dd>Creates a new <span class="Li">&quot;Path::Class::File&quot;</span> object
      and returns it. The arguments specify the path to the file. Any volume may
      also be specified as the first argument, or as part of the first argument.
      You can use platform-neutral syntax:
    <p class="Pp"></p>
    <pre>
  my $file = file( 'foo', 'bar', 'baz.txt' );
    </pre>
    <p class="Pp">or platform-native syntax:</p>
    <p class="Pp"></p>
    <pre>
  my $file = file( 'foo/bar/baz.txt' );
    </pre>
    <p class="Pp">or a mixture of the two:</p>
    <p class="Pp"></p>
    <pre>
  my $file = file( 'foo/bar', 'baz.txt' );
    </pre>
    <p class="Pp">All three of the above examples create relative paths. To
        create an absolute path, either use the platform native syntax for doing
        so:</p>
    <p class="Pp"></p>
    <pre>
  my $file = file( '/var/tmp/foo.txt' );
    </pre>
    <p class="Pp">or use an empty string as the first argument:</p>
    <p class="Pp"></p>
    <pre>
  my $file = file( '', 'var', 'tmp', 'foo.txt' );
    </pre>
    <p class="Pp">If the second form seems awkward, that's somewhat intentional
        - paths like <span class="Li">&quot;/var/tmp&quot;</span> or
        <span class="Li">&quot;\Windows&quot;</span> aren't cross-platform
        concepts in the first place, so they probably shouldn't appear in your
        code if you're trying to be cross-platform. The first form is perfectly
        fine, because paths like this may come from config files, user input, or
        whatever.</p>
  </dd>
  <dt>$file-&gt;stringify</dt>
  <dd>This method is called internally when a
      <span class="Li">&quot;Path::Class::File&quot;</span> object is used in a
      string context, so the following are equivalent:
    <p class="Pp"></p>
    <pre>
  $string = $file-&gt;stringify;
  $string = &quot;$file&quot;;
    </pre>
  </dd>
  <dt>$file-&gt;volume</dt>
  <dd>Returns the volume (e.g. <span class="Li">&quot;C:&quot;</span> on
      Windows, <span class="Li">&quot;Macintosh HD:&quot;</span> on Mac OS,
      etc.) of the object, if any. Otherwise, returns the empty string.</dd>
  <dt>$file-&gt;basename</dt>
  <dd>Returns the name of the file as a string, without the directory portion
      (if any).</dd>
  <dt>$file-&gt;components</dt>
  <dd>Returns a list of the directory components of this file, followed by the
      basename.
    <p class="Pp">Note: unlike
        <span class="Li">&quot;$dir-&gt;components&quot;</span>, this method
        currently does not accept any arguments to select which elements of the
        list will be returned. It may do so in the future. Currently it throws
        an exception if such arguments are present.</p>
  </dd>
  <dt>$file-&gt;is_dir</dt>
  <dd>Returns a boolean value indicating whether this object represents a
      directory. Not surprisingly,
      <span class="Li">&quot;Path::Class::File&quot;</span> objects always
      return false, and Path::Class::Dir objects always return true.</dd>
  <dt>$file-&gt;is_absolute</dt>
  <dd>Returns true or false depending on whether the file refers to an absolute
      path specifier (like
      <span class="Li">&quot;/usr/local/foo.txt&quot;</span> or
      <span class="Li">&quot;\Windows\Foo.txt&quot;</span>).</dd>
  <dt>$file-&gt;is_relative</dt>
  <dd>Returns true or false depending on whether the file refers to a relative
      path specifier (like <span class="Li">&quot;lib/foo.txt&quot;</span> or
      <span class="Li">&quot;.\Foo.txt&quot;</span>).</dd>
  <dt>$file-&gt;cleanup</dt>
  <dd>Performs a logical cleanup of the file path. For instance:
    <p class="Pp"></p>
    <pre>
  my $file = file('/foo//baz/./foo.txt')-&gt;cleanup;
  # $file now represents '/foo/baz/foo.txt';
    </pre>
  </dd>
  <dt>$dir-&gt;resolve</dt>
  <dd>Performs a physical cleanup of the file path. For instance:
    <p class="Pp"></p>
    <pre>
  my $file = file('/foo/baz/../foo.txt')-&gt;resolve;
  # $file now represents '/foo/foo.txt', assuming no symlinks
    </pre>
    <p class="Pp">This actually consults the filesystem to verify the validity
        of the path.</p>
  </dd>
  <dt>$dir = $file-&gt;dir</dt>
  <dd>Returns a <span class="Li">&quot;Path::Class::Dir&quot;</span> object
      representing the directory containing this file.</dd>
  <dt>$dir = $file-&gt;parent</dt>
  <dd>A synonym for the <span class="Li">&quot;dir()&quot;</span> method.</dd>
  <dt>$abs = $file-&gt;absolute</dt>
  <dd>Returns a <span class="Li">&quot;Path::Class::File&quot;</span> object
      representing <span class="Li">$file</span> as an absolute path. An
      optional argument, given as either a string or a Path::Class::Dir object,
      specifies the directory to use as the base of relativity - otherwise the
      current working directory will be used.</dd>
  <dt>$rel = $file-&gt;relative</dt>
  <dd>Returns a <span class="Li">&quot;Path::Class::File&quot;</span> object
      representing <span class="Li">$file</span> as a relative path. An optional
      argument, given as either a string or a
      <span class="Li">&quot;Path::Class::Dir&quot;</span> object, specifies the
      directory to use as the base of relativity - otherwise the current working
      directory will be used.</dd>
  <dt>$foreign = $file-&gt;as_foreign($type)</dt>
  <dd>Returns a <span class="Li">&quot;Path::Class::File&quot;</span> object
      representing <span class="Li">$file</span> as it would be specified on a
      system of type <span class="Li">$type</span>. Known types include
      <span class="Li">&quot;Unix&quot;</span>,
      <span class="Li">&quot;Win32&quot;</span>,
      <span class="Li">&quot;Mac&quot;</span>,
      <span class="Li">&quot;VMS&quot;</span>, and
      <span class="Li">&quot;OS2&quot;</span>, i.e. anything for which there is
      a subclass of <span class="Li">&quot;File::Spec&quot;</span>.
    <p class="Pp">Any generated objects (subdirectories, files, parents, etc.)
        will also retain this type.</p>
  </dd>
  <dt>$foreign = Path::Class::File-&gt;new_foreign($type, @args)</dt>
  <dd>Returns a <span class="Li">&quot;Path::Class::File&quot;</span> object
      representing a file as it would be specified on a system of type
      <span class="Li">$type</span>. Known types include
      <span class="Li">&quot;Unix&quot;</span>,
      <span class="Li">&quot;Win32&quot;</span>,
      <span class="Li">&quot;Mac&quot;</span>,
      <span class="Li">&quot;VMS&quot;</span>, and
      <span class="Li">&quot;OS2&quot;</span>, i.e. anything for which there is
      a subclass of <span class="Li">&quot;File::Spec&quot;</span>.
    <p class="Pp">The arguments in <span class="Li">@args</span> are the same as
        they would be specified in
      <span class="Li">&quot;new()&quot;</span>.</p>
  </dd>
  <dt>$fh = $file-&gt;open($mode, $permissions)</dt>
  <dd>Passes the given arguments, including <span class="Li">$file</span>, to
      <span class="Li">&quot;IO::File-&gt;new&quot;</span> (which in turn calls
      <span class="Li">&quot;IO::File-&gt;open&quot;</span> and returns the
      result as an IO::File object. If the opening fails,
      <span class="Li">&quot;undef&quot;</span> is returned and
      <span class="Li">$!</span> is set.</dd>
  <dt>$fh = $file-&gt;<i>openr()</i></dt>
  <dd>A shortcut for
    <p class="Pp"></p>
    <pre>
 $fh = $file-&gt;open('r') or croak &quot;Can't read $file: $!&quot;;
    </pre>
  </dd>
  <dt>$fh = $file-&gt;<i>openw()</i></dt>
  <dd>A shortcut for
    <p class="Pp"></p>
    <pre>
 $fh = $file-&gt;open('w') or croak &quot;Can't write to $file: $!&quot;;
    </pre>
  </dd>
  <dt>$fh = $file-&gt;<i>opena()</i></dt>
  <dd>A shortcut for
    <p class="Pp"></p>
    <pre>
 $fh = $file-&gt;open('a') or croak &quot;Can't append to $file: $!&quot;;
    </pre>
  </dd>
  <dt>$file-&gt;touch</dt>
  <dd>Sets the modification and access time of the given file to right now, if
      the file exists. If it doesn't exist,
      <span class="Li">&quot;touch()&quot;</span> will <i>make</i> it exist, and
      - YES! - set its modification and access time to now.</dd>
  <dt>$file-&gt;<i>slurp()</i></dt>
  <dd>In a scalar context, returns the contents of <span class="Li">$file</span>
      in a string. In a list context, returns the lines of
      <span class="Li">$file</span> (according to how <span class="Li">$/</span>
      is set) as a list. If the file can't be read, this method will throw an
      exception.
    <p class="Pp">If you want <span class="Li">&quot;chomp()&quot;</span> run on
        each line of the file, pass a true value for the
        <span class="Li">&quot;chomp&quot;</span> or
        <span class="Li">&quot;chomped&quot;</span> parameters:</p>
    <p class="Pp"></p>
    <pre>
  my @lines = $file-&gt;slurp(chomp =&gt; 1);
    </pre>
    <p class="Pp">You may also use the
        <span class="Li">&quot;iomode&quot;</span> parameter to pass in an IO
        mode to use when opening the file, usually IO layers (though anything
        accepted by the MODE argument of
        <span class="Li">&quot;open()&quot;</span> is accepted here). Just make
        sure it's a <i>reading</i> mode.</p>
    <p class="Pp"></p>
    <pre>
  my @lines = $file-&gt;slurp(iomode =&gt; ':crlf');
  my $lines = $file-&gt;slurp(iomode =&gt; '&lt;:encoding(UTF-8)');
    </pre>
    <p class="Pp">The default <span class="Li">&quot;iomode&quot;</span> is
        <span class="Li">&quot;r&quot;</span>.</p>
    <p class="Pp">Lines can also be automatically split, mimicking the perl
        command-line option <span class="Li">&quot;-a&quot;</span> by using the
        <span class="Li">&quot;split&quot;</span> parameter. If this parameter
        is used, each line will be returned as an array ref.</p>
    <p class="Pp"></p>
    <pre>
    my @lines = $file-&gt;slurp( chomp =&gt; 1, split =&gt; qr/\s*,\s*/ );
    </pre>
    <p class="Pp">The <span class="Li">&quot;split&quot;</span> parameter can
        only be used in a list context.</p>
  </dd>
  <dt>$file-&gt;spew( $content );</dt>
  <dd>The opposite of &quot;slurp&quot;, this takes a list of strings and prints
      them to the file in write mode. If the file can't be written to, this
      method will throw an exception.
    <p class="Pp">The content to be written can be either an array ref or a
        plain scalar. If the content is an array ref then each entry in the
        array will be written to the file.</p>
    <p class="Pp">You may use the <span class="Li">&quot;iomode&quot;</span>
        parameter to pass in an IO mode to use when opening the file, just like
        &quot;slurp&quot; supports.</p>
    <p class="Pp"></p>
    <pre>
  $file-&gt;spew(iomode =&gt; '&gt;:raw', $content);
    </pre>
    <p class="Pp">The default <span class="Li">&quot;iomode&quot;</span> is
        <span class="Li">&quot;w&quot;</span>.</p>
  </dd>
  <dt>$file-&gt;traverse(sub { ... }, @args)</dt>
  <dd>Calls the given callback on <span class="Li">$file</span>. This doesn't do
      much on its own, but see the associated documentation in
    Path::Class::Dir.</dd>
  <dt>$file-&gt;<i>remove()</i></dt>
  <dd>This method will remove the file in a way that works well on all
      platforms, and returns a boolean value indicating whether or not the file
      was successfully removed.
    <p class="Pp"><span class="Li">&quot;remove()&quot;</span> is better than
        simply calling Perl's <span class="Li">&quot;unlink()&quot;</span>
        function, because on some platforms (notably VMS) you actually may need
        to call <span class="Li">&quot;unlink()&quot;</span> several times
        before all versions of the file are gone - the
        <span class="Li">&quot;remove()&quot;</span> method handles this process
        for you.</p>
  </dd>
  <dt>$st = $file-&gt;<i>stat()</i></dt>
  <dd>Invokes <span class="Li">&quot;File::stat::stat()&quot;</span> on this
      file and returns a File::stat object representing the result.</dd>
  <dt>$st = $file-&gt;<i>lstat()</i></dt>
  <dd>Same as <span class="Li">&quot;stat()&quot;</span>, but if
      <span class="Li">$file</span> is a symbolic link,
      <span class="Li">&quot;lstat()&quot;</span> stats the link instead of the
      file the link points to.</dd>
  <dt>$class = $file-&gt;<i>dir_class()</i></dt>
  <dd>Returns the class which should be used to create directory objects.
    <p class="Pp">Generally overridden whenever this class is subclassed.</p>
  </dd>
  <dt>$file-&gt;copy_to( $dest );</dt>
  <dd>Copies the <span class="Li">$file</span> to
    <span class="Li">$dest</span>.</dd>
  <dt>$file-&gt;move_to( $dest );</dt>
  <dd>Moves the <span class="Li">$file</span> to
    <span class="Li">$dest</span>.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Ken Williams, kwilliams@cpan.org</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Path::Class, Path::Class::Dir, File::Spec</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-12</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Net::SSLeay(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Net::SSLeay(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Net::SSLeay(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Net::SSLeay - Perl extension for using OpenSSL</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
  use Net::SSLeay qw(get_https post_https sslcat make_headers make_form);

  ($page) = get_https('www.bacus.pt', 443, '/');                 # Case 1

  ($page, $response, %reply_headers)
         = get_https('www.bacus.pt', 443, '/',                   # Case 2
                make_headers(User-Agent =&gt; 'Cryptozilla/5.0b1',
                             Referer    =&gt; 'https://www.bacus.pt'
                ));

  ($page, $result, %headers) =                                   # Case 2b
         = get_https('www.bacus.pt', 443, '/protected.html',
              make_headers(Authorization =&gt;
                           'Basic ' . MIME::Base64::encode(&quot;$user:$pass&quot;,''))
              );

  ($page, $response, %reply_headers)
         = post_https('www.bacus.pt', 443, '/foo.cgi', '',       # Case 3
                make_form(OK   =&gt; '1',
                          name =&gt; 'Sampo'
                ));

  $reply = sslcat($host, $port, $request);                       # Case 4

  ($reply, $err, $server_cert) = sslcat($host, $port, $request); # Case 5

  $Net::SSLeay::trace = 2;  # 0=no debugging, 1=ciphers, 2=trace, 3=dump data

  Net::SSLeay::initialize(); # Initialize ssl library once
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Net::SSLeay module contains perl bindings to openssl
    (&lt;http://www.openssl.org&gt;) library.</p>
<p class="Pp"><b>COMPATIBILITY NOTE:</b> Net::SSLeay cannot be built with
    pre-0.9.3 openssl. It is strongly recommended to use at least 0.9.7 (as
    older versions are not tested during development). Some low level API
    functions may be available with certain openssl versions.</p>
<p class="Pp">It is compatible with OpenSSL 1.0 and 1.1. Some functions are not
    available under OpenSSL 1.1.</p>
<p class="Pp">Net::SSLeay module basically comprise of:</p>
<ul class="Bl-bullet">
  <li>High level functions for accessing web servers (by using HTTP/HTTPS)</li>
  <li>Low level API (mostly mapped 1:1 to openssl's C functions)</li>
  <li>Convenience functions (related to low level API but with more perl
      friendly interface)</li>
</ul>
<p class="Pp">There is also a related module called Net::SSLeay::Handle included
    in this distribution that you might want to use instead. It has its own pod
    documentation.</p>
<section class="Ss">
<h2 class="Ss" id="High_level_functions_for_accessing_web_servers"><a class="permalink" href="#High_level_functions_for_accessing_web_servers">High
  level functions for accessing web servers</a></h2>
<p class="Pp">This module offers some high level convenience functions for
    accessing web pages on SSL servers (for symmetry, the same API is offered
    for accessing http servers, too), an
    <span class="Li">&quot;sslcat()&quot;</span> function for writing your own
    clients, and finally access to the SSL api of the SSLeay/OpenSSL package so
    you can write servers or clients for more complicated applications.</p>
<p class="Pp">For high level functions it is most convenient to import them into
    your main namespace as indicated in the synopsis.</p>
<p class="Pp"><i>Basic set of functions</i></p>
<ul class="Bl-bullet">
  <li>get_https</li>
  <li>post_https</li>
  <li>put_https</li>
  <li>head_https</li>
  <li>do_https</li>
  <li>sslcat</li>
  <li>https_cat</li>
  <li>make_form</li>
  <li>make_headers</li>
</ul>
<p class="Pp"><b>Case 1 (in SYNOPSIS)</b> demonstrates the typical invocation of
    <b>get_https()</b> to fetch an HTML page from secure server. The first
    argument provides the hostname or IP in dotted decimal notation of the
    remote server to contact. The second argument is the TCP port at the remote
    end (your own port is picked arbitrarily from high numbered ports as usual
    for TCP). The third argument is the URL of the page without the host name
    part. If in doubt consult the HTTP specifications at
    &lt;http://www.w3c.org&gt;.</p>
<p class="Pp"><b>Case 2 (in SYNOPSIS)</b> demonstrates full fledged use of
    <span class="Li">&quot;get_https()&quot;</span>. As can be seen,
    <span class="Li">&quot;get_https()&quot;</span> parses the response and
    response headers and returns them as a list, which can be captured in a hash
    for later reference. Also a fourth argument to
    <span class="Li">&quot;get_https()&quot;</span> is used to insert some
    additional headers in the request.
    <span class="Li">&quot;make_headers()&quot;</span> is a function that will
    convert a list or hash to such headers. By default
    <span class="Li">&quot;get_https()&quot;</span> supplies
    <span class="Li">&quot;Host&quot;</span> (to make virtual hosting easy) and
    <span class="Li">&quot;Accept&quot;</span> (reportedly needed by IIS)
    headers.</p>
<p class="Pp"><b>Case 2b (in SYNOPSIS)</b> demonstrates how to get a password
    protected page. Refer to the HTTP protocol specifications for further
    details (e.g. RFC-2617).</p>
<p class="Pp"><b>Case 3 (in SYNOPSIS)</b> invokes
    <span class="Li">&quot;post_https()&quot;</span> to submit a HTML/CGI form
    to a secure server. The first four arguments are equal to
    <span class="Li">&quot;get_https()&quot;</span> (note that the empty string
    (<span class="Li">''</span>) is passed as header argument). The fifth
    argument is the contents of the form formatted according to CGI
    specification. Do not post UTF-8 data as content: use utf8::downgrade first.
    In this case the helper function
    <span class="Li">&quot;make_https()&quot;</span> is used to do the
    formatting, but you could pass any string.
    <span class="Li">&quot;post_https()&quot;</span> automatically adds
    <span class="Li">&quot;Content-Type&quot;</span> and
    <span class="Li">&quot;Content-Length&quot;</span> headers to the
  request.</p>
<p class="Pp"><b>Case 4 (in SYNOPSIS)</b> shows the fundamental
    <span class="Li">&quot;sslcat()&quot;</span> function (inspired in spirit by
    the <span class="Li">&quot;netcat&quot;</span> utility :-). It's your swiss
    army knife that allows you to easily contact servers, send some data, and
    then get the response. You are responsible for formatting the data and
    parsing the response - <span class="Li">&quot;sslcat()&quot;</span> is just
    a transport.</p>
<p class="Pp"><b>Case 5 (in SYNOPSIS)</b> is a full invocation of
    <span class="Li">&quot;sslcat()&quot;</span> which allows the return of
    errors as well as the server (peer) certificate.</p>
<p class="Pp">The <span class="Li">$trace</span> global variable can be used to
    control the verbosity of the high level functions. Level 0 guarantees
    silence, level 1 (the default) only emits error messages.</p>
<p class="Pp"><i>Alternate versions of high-level API</i></p>
<ul class="Bl-bullet">
  <li>get_https3</li>
  <li>post_https3</li>
  <li>put_https3</li>
  <li>get_https4</li>
  <li>post_https4</li>
  <li>put_https4</li>
</ul>
<p class="Pp">The above mentioned functions actually return the response headers
    as a list, which only gets converted to hash upon assignment (this
    assignment looses information if the same header occurs twice, as may be the
    case with cookies). There are also other variants of the functions that
    return unprocessed headers and that return a reference to a hash.</p>
<p class="Pp"></p>
<pre>
  ($page, $response, @headers) = get_https('www.bacus.pt', 443, '/');
  for ($i = 0; $i &lt; $#headers; $i+=2) {
      print &quot;$headers[$i] = &quot; . $headers[$i+1] . &quot;\n&quot;;
  }

  ($page, $response, $headers, $server_cert)
    = get_https3('www.bacus.pt', 443, '/');
  print &quot;$headers\n&quot;;

  ($page, $response, $headers_ref)
    = get_https4('www.bacus.pt', 443, '/');
  for $k (sort keys %{$headers_ref}) {
      for $v (@{$$headers_ref{$k}}) {
          print &quot;$k = $v\n&quot;;
      }
  }
</pre>
<p class="Pp">All of the above code fragments accomplish the same thing: display
    all values of all headers. The API functions ending in &quot;3&quot; return
    the headers simply as a scalar string and it is up to the application to
    split them up. The functions ending in &quot;4&quot; return a reference to a
    hash of arrays (see perlref and perllol if you are not familiar with complex
    perl data structures). To access a single value of such a header hash you
    would do something like</p>
<p class="Pp"></p>
<pre>
  print $$headers_ref{COOKIE}[0];
</pre>
<p class="Pp">Variants 3 and 4 also allow you to discover the server certificate
    in case you would like to store or display it, e.g.</p>
<p class="Pp"></p>
<pre>
  ($p, $resp, $hdrs, $server_cert) = get_https3('www.bacus.pt', 443, '/');
  if (!defined($server_cert) || ($server_cert == 0)) {
      warn &quot;Subject Name: undefined, Issuer  Name: undefined&quot;;
  } else {
      warn 'Subject Name: '
          . Net::SSLeay::X509_NAME_oneline(
                 Net::SSLeay::X509_get_subject_name($server_cert))
              . 'Issuer  Name: '
                  . Net::SSLeay::X509_NAME_oneline(
                         Net::SSLeay::X509_get_issuer_name($server_cert));
  }
</pre>
<p class="Pp">Beware that this method only allows after the fact verification of
    the certificate: by the time
    <span class="Li">&quot;get_https3()&quot;</span> has returned the https
    request has already been sent to the server, whether you decide to trust it
    or not. To do the verification correctly you must either employ the OpenSSL
    certificate verification framework or use the lower level API to first
    connect and verify the certificate and only then send the http data. See the
    implementation of <span class="Li">&quot;ds_https3()&quot;</span> for
    guidance on how to do this.</p>
<p class="Pp"><i>Using client certificates</i></p>
<p class="Pp">Secure web communications are encrypted using symmetric crypto
    keys exchanged using encryption based on the certificate of the server.
    Therefore in all SSL connections the server must have a certificate. This
    serves both to authenticate the server to the clients and to perform the key
    exchange.</p>
<p class="Pp">Sometimes it is necessary to authenticate the client as well. Two
    options are available: HTTP basic authentication and a client side
    certificate. The basic authentication over HTTPS is actually quite safe
    because HTTPS guarantees that the password will not travel in the clear.
    Never-the-less, problems like easily guessable passwords remain. The client
    certificate method involves authentication of the client at the SSL level
    using a certificate. For this to work, both the client and the server have
    certificates (which typically are different) and private keys.</p>
<p class="Pp">The API functions outlined above accept additional arguments that
    allow one to supply the client side certificate and key files. The format of
    these files is the same as used for server certificates and the caveat about
    encrypting private keys applies.</p>
<p class="Pp"></p>
<pre>
  ($page, $result, %headers) =                                   # 2c
         = get_https('www.bacus.pt', 443, '/protected.html',
              make_headers(Authorization =&gt;
                           'Basic ' . MIME::Base64::encode(&quot;$user:$pass&quot;,'')),
              '', $mime_type6, $path_to_crt7, $path_to_key8);

  ($page, $response, %reply_headers)
         = post_https('www.bacus.pt', 443, '/foo.cgi',           # 3b
              make_headers('Authorization' =&gt;
                           'Basic ' . MIME::Base64::encode(&quot;$user:$pass&quot;,'')),
              make_form(OK   =&gt; '1', name =&gt; 'Sampo'),
              $mime_type6, $path_to_crt7, $path_to_key8);
</pre>
<p class="Pp"><b>Case 2c (in SYNOPSIS)</b> demonstrates getting a password
    protected page that also requires a client certificate, i.e. it is possible
    to use both authentication methods simultaneously.</p>
<p class="Pp"><b>Case 3b (in SYNOPSIS)</b> is a full blown POST to a secure
    server that requires both password authentication and a client certificate,
    just like in case 2c.</p>
<p class="Pp">Note: The client will not send a certificate unless the server
    requests one. This is typically achieved by setting the verify mode to
    <span class="Li">&quot;VERIFY_PEER&quot;</span> on the server:</p>
<p class="Pp"></p>
<pre>
  Net::SSLeay::set_verify(ssl, Net::SSLeay::VERIFY_PEER, 0);
</pre>
<p class="Pp">See <span class="Li">&quot;perldoc
    ~openssl/doc/ssl/SSL_CTX_set_verify.pod&quot;</span> for a full
  description.</p>
<p class="Pp"><i>Working through a web proxy</i></p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>set_proxy</dd>
</dl>
<p class="Pp"><span class="Li">&quot;Net::SSLeay&quot;</span> can use a web
    proxy to make its connections. You need to first set the proxy host and port
    using <span class="Li">&quot;set_proxy()&quot;</span> and then just use the
    normal API functions, e.g:</p>
<p class="Pp"></p>
<pre>
  Net::SSLeay::set_proxy('gateway.myorg.com', 8080);
  ($page) = get_https('www.bacus.pt', 443, '/');
</pre>
<p class="Pp">If your proxy requires authentication, you can supply a username
    and password as well</p>
<p class="Pp"></p>
<pre>
  Net::SSLeay::set_proxy('gateway.myorg.com', 8080, 'joe', 'salainen');
  ($page, $result, %headers) =
         = get_https('www.bacus.pt', 443, '/protected.html',
              make_headers(Authorization =&gt;
                           'Basic ' . MIME::Base64::encode(&quot;susie:pass&quot;,''))
              );
</pre>
<p class="Pp">This example demonstrates the case where we authenticate to the
    proxy as <span class="Li">&quot;joe&quot;</span> and to the final web server
    as <span class="Li">&quot;susie&quot;</span>. Proxy authentication requires
    the <span class="Li">&quot;MIME::Base64&quot;</span> module to work.</p>
<p class="Pp"><i>HTTP (without S) API</i></p>
<ul class="Bl-bullet">
  <li>get_http</li>
  <li>post_http</li>
  <li>tcpcat</li>
  <li>get_httpx</li>
  <li>post_httpx</li>
  <li>tcpxcat</li>
</ul>
<p class="Pp">Over the years it has become clear that it would be convenient to
    use the light-weight flavour API of
    <span class="Li">&quot;Net::SSLeay&quot;</span> for normal HTTP as well (see
    <span class="Li">&quot;LWP&quot;</span> for the heavy-weight object-oriented
    approach). In fact it would be nice to be able to flip https on and off on
    the fly. Thus regular HTTP support was evolved.</p>
<p class="Pp"></p>
<pre>
  use Net::SSLeay qw(get_http post_http tcpcat
                      get_httpx post_httpx tcpxcat
                      make_headers make_form);

  ($page, $result, %headers)
         = get_http('www.bacus.pt', 443, '/protected.html',
              make_headers(Authorization =&gt;
                           'Basic ' . MIME::Base64::encode(&quot;$user:$pass&quot;,''))
              );

  ($page, $response, %reply_headers)
         = post_http('www.bacus.pt', 443, '/foo.cgi', '',
                make_form(OK   =&gt; '1',
                          name =&gt; 'Sampo'
                ));

  ($reply, $err) = tcpcat($host, $port, $request);

  ($page, $result, %headers)
         = get_httpx($usessl, 'www.bacus.pt', 443, '/protected.html',
              make_headers(Authorization =&gt;
                           'Basic ' . MIME::Base64::encode(&quot;$user:$pass&quot;,''))
              );

  ($page, $response, %reply_headers)
         = post_httpx($usessl, 'www.bacus.pt', 443, '/foo.cgi', '',
                make_form(OK   =&gt; '1',  name =&gt; 'Sampo' ));

  ($reply, $err, $server_cert) = tcpxcat($usessl, $host, $port, $request);
</pre>
<p class="Pp">As can be seen, the <span class="Li">&quot;x&quot;</span> family
    of APIs takes as the first argument a flag which indicates whether SSL is
    used or not.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Certificate_verification_and_Certificate_Revocation_Lists_(CRLs)"><a class="permalink" href="#Certificate_verification_and_Certificate_Revocation_Lists_(CRLs)">Certificate
  verification and Certificate Revocation Lists (CRLs)</a></h2>
<p class="Pp">OpenSSL supports the ability to verify peer certificates. It can
    also optionally check the peer certificate against a Certificate Revocation
    List (CRL) from the certificates issuer. A CRL is a file, created by the
    certificate issuer that lists all the certificates that it previously
    signed, but which it now revokes. CRLs are in PEM format.</p>
<p class="Pp">You can enable <span class="Li">&quot;Net::SSLeay CRL&quot;</span>
    checking like this:</p>
<p class="Pp"></p>
<pre>
            &amp;Net::SSLeay::X509_STORE_set_flags
                (&amp;Net::SSLeay::CTX_get_cert_store($ssl),
                 &amp;Net::SSLeay::X509_V_FLAG_CRL_CHECK);
</pre>
<p class="Pp">After setting this flag, if OpenSSL checks a peer's certificate,
    then it will attempt to find a CRL for the issuer. It does this by looking
    for a specially named file in the search directory specified by
    CTX_load_verify_locations. CRL files are named with the hash of the issuer's
    subject name, followed by <span class="Li">&quot;.r0&quot;</span>,
    <span class="Li">&quot;.r1&quot;</span> etc. For example
    <span class="Li">&quot;ab1331b2.r0&quot;</span>,
    <span class="Li">&quot;ab1331b2.r1&quot;</span>. It will read all the .r
    files for the issuer, and then check for a revocation of the peer
    certificate in all of them. (You can also force it to look in a specific
    named CRL file., see below). You can find out the hash of the issuer subject
    name in a CRL with</p>
<p class="Pp"></p>
<pre>
        openssl crl -in crl.pem -hash -noout
</pre>
<p class="Pp">If the peer certificate does not pass the revocation list, or if
    no CRL is found, then the handshaking fails with an error.</p>
<p class="Pp">You can also force OpenSSL to look for CRLs in one or more
    arbitrarily named files.</p>
<p class="Pp"></p>
<pre>
    my $bio = Net::SSLeay::BIO_new_file($crlfilename, 'r');
    my $crl = Net::SSLeay::PEM_read_bio_X509_CRL($bio);
    if ($crl) {
        Net::SSLeay::X509_STORE_add_crl(
             Net::SSLeay::CTX_get_cert_store($ssl, $crl)
        );
    } else {
        error reading CRL....
    }
</pre>
<p class="Pp">Usually the URLs where you can download the CRLs is contained in
    the certificate itself and you can extract them with</p>
<p class="Pp"></p>
<pre>
    my @url = Net::SSLeay::P_X509_get_crl_distribution_points($cert)
</pre>
<p class="Pp">But there is no automatic downloading of the CRLs and often these
    CRLs are too huge to just download them to verify a single certificate.
    Also, these CRLs are often in DER format which you need to convert to PEM
    before you can use it:</p>
<p class="Pp"></p>
<pre>
    openssl crl -in crl.der -inform der -out crl.pem
</pre>
<p class="Pp">So as an alternative for faster and timely revocation checks you
    better use the Online Status Revocation Protocol (OCSP).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Certificate_verification_and_Online_Status_Revocation_Protocol_("><a class="permalink" href="#Certificate_verification_and_Online_Status_Revocation_Protocol_(">Certificate
  verification and Online Status Revocation Protocol (OCSP)</a></h2>
<p class="Pp">While checking for revoked certificates is possible and fast with
    Certificate Revocation Lists, you need to download the complete and often
    huge list before you can verify a single certificate.</p>
<p class="Pp">A faster way is to ask the CA to check the revocation of just a
    single or a few certificates using OCSP. Basically you generate for each
    certificate an OCSP_CERTID based on the certificate itself and its issuer,
    put the ids togetether into an OCSP_REQUEST and send the request to the URL
    given in the certificate.</p>
<p class="Pp">As a result you get back an OCSP_RESPONSE and need to check the
    status of the response, check that it is valid (e.g. signed by the CA) and
    finally extract the information about each OCSP_CERTID to find out if the
    certificate is still valid or got revoked.</p>
<p class="Pp">With Net::SSLeay this can be done like this:</p>
<p class="Pp"></p>
<pre>
    # get id(s) for given certs, like from get_peer_certificate
    # or get_peer_cert_chain. This will croak if
    # - one tries to make an OCSP_CERTID for a self-signed certificate
    # - the issuer of the certificate cannot be found in the SSL objects
    #   store, nor in the current certificate chain
    my $cert = Net::SSLeay::get_peer_certificate($ssl);
    my $id = eval { Net::SSLeay::OCSP_cert2ids($ssl,$cert) };
    die &quot;failed to make OCSP_CERTID: $@&quot; if $@;

    # create OCSP_REQUEST from id(s)
    # Multiple can be put into the same request, if the same OCSP responder
    # is responsible for them.
    my $req = Net::SSLeay::OCSP_ids2req($id);

    # determine URI of OCSP responder
    my $uri = Net::SSLeay::P_X509_get_ocsp_uri($cert);

    # Send stringified OCSP_REQUEST with POST to $uri.
    # We can ignore certificate verification for https, because the OCSP
    # response itself is signed.
    my $ua = HTTP::Tiny-&gt;new(verify_SSL =&gt; 0);
    my $res = $ua-&gt;request( 'POST',$uri, {
        headers =&gt; { 'Content-type' =&gt; 'application/ocsp-request' },
        content =&gt; Net::SSLeay::i2d_OCSP_REQUEST($req)
    });
    my $content = $res &amp;&amp; $res-&gt;{success} &amp;&amp; $res-&gt;{content}
        or die &quot;query failed&quot;;

    # Extract OCSP_RESPONSE.
    # this will croak if the string is not an OCSP_RESPONSE
    my $resp = eval { Net::SSLeay::d2i_OCSP_RESPONSE($content) };

    # Check status of response.
    my $status = Net::SSLeay::OCSP_response_status($resp);
    if ($status != Net::SSLeay::OCSP_RESPONSE_STATUS_SUCCESSFUL())
        die &quot;OCSP response failed: &quot;.
            Net::SSLeay::OCSP_response_status_str($status);
    }

    # Verify signature of response and if nonce matches request.
    # This will croak if there is a nonce in the response, but it does not match
    # the request. It will return false if the signature could not be verified,
    # in which case details can be retrieved with Net::SSLeay::ERR_get_error.
    # It will not complain if the response does not contain a nonce, which is
    # usually the case with pre-signed responses.
    if ( ! eval { Net::SSLeay::OCSP_response_verify($ssl,$resp,$req) }) {
        die &quot;OCSP response verification failed&quot;;
    }

    # Extract information from OCSP_RESPONSE for each of the ids.

    # If called in scalar context it will return the time (as time_t), when the
    # next update is due (minimum of all successful responses inside $resp). It
    # will croak on the following problems:
    # - response is expired or not yet valid
    # - no response for given OCSP_CERTID
    # - certificate status is not good (e.g. revoked or unknown)
    if ( my $nextupd = eval { Net::SSLeay::OCSP_response_results($resp,$id) }) {
        warn &quot;certificate is valid, next update in &quot;.
            ($nextupd-time()).&quot; seconds\n&quot;;
    } else {
        die &quot;certificate is not valid: $@&quot;;
    }

    # But in array context it will return detailed information about each given
    # OCSP_CERTID instead croaking on errors:
    # if no @ids are given it will return information about all single responses
    # in the OCSP_RESPONSE
    my @results = Net::SSLeay::OCSP_response_results($resp,@ids);
    for my $r (@results) {
        print Dumper($r);
        # @results are in the same order as the @ids and contain:
        # $r-&gt;[0] - OCSP_CERTID
        # $r-&gt;[1] - undef if no error (certificate good) OR error message as string
        # $r-&gt;[2] - hash with details:
        #   thisUpdate - time_t of this single response
        #   nextUpdate - time_t when update is expected
        #   statusType - integer:
        #      V_OCSP_CERTSTATUS_GOOD(0)
        #      V_OCSP_CERTSTATUS_REVOKED(1)
        #      V_OCSP_CERTSTATUS_UNKNOWN(2)
        #   revocationTime - time_t (only if revoked)
        #   revocationReason - integer (only if revoked)
        #   revocationReason_str - reason as string (only if revoked)
    }
</pre>
<p class="Pp">To further speed up certificate revocation checking one can use a
    TLS extension to instruct the server to staple the OCSP response:</p>
<p class="Pp"></p>
<pre>
    # set TLS extension before doing SSL_connect
    Net::SSLeay::set_tlsext_status_type($ssl,
        Net::SSLeay::TLSEXT_STATUSTYPE_ocsp());

    # setup callback to verify OCSP response
    my $cert_valid = undef;
    Net::SSLeay::CTX_set_tlsext_status_cb($context,sub {
        my ($ssl,$resp) = @_;
        if (!$resp) {
            # Lots of servers don't return an OCSP response.
            # In this case we must check the OCSP status outside the SSL
            # handshake.
            warn &quot;server did not return stapled OCSP response\n&quot;;
            return 1;
        }
        # verify status
        my $status = Net::SSLeay::OCSP_response_status($resp);
        if ($status != Net::SSLeay::OCSP_RESPONSE_STATUS_SUCCESSFUL()) {
            warn &quot;OCSP response failure: $status\n&quot;;
            return 1;
        }
        # verify signature - we have no OCSP_REQUEST here to check nonce
        if (!eval { Net::SSLeay::OCSP_response_verify($ssl,$resp) }) {
            warn &quot;OCSP response verify failed\n&quot;;
            return 1;
        }
        # check if the certificate is valid
        # we should check here against the peer_certificate
        my $cert = Net::SSLeay::get_peer_certificate();
        my $certid = eval { Net::SSLeay::OCSP_cert2ids($ssl,$cert) } or do {
            warn &quot;cannot get certid from cert: $@&quot;;
            $cert_valid = -1;
            return 1;
        };

        if ( $nextupd = eval {
            Net::SSLeay::OCSP_response_results($resp,$certid) }) {
            warn &quot;certificate not revoked\n&quot;;
            $cert_valid = 1;
        } else {
            warn &quot;certificate not valid: $@&quot;;
            $cert_valid = 0;
        }
    });

    # do SSL handshake here
    ....
    # check if certificate revocation was checked already
    if ( ! defined $cert_valid) {
        # check revocation outside of SSL handshake by asking OCSP responder
        ...
    } elsif ( ! $cert_valid ) {
        die &quot;certificate not valid - closing SSL connection&quot;;
    } elsif ( $cert_valid&lt;0 ) {
        die &quot;cannot verify certificate revocation - self-signed ?&quot;;
    } else {
        # everything fine
        ...
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_Net::SSLeay_in_multi-threaded_applications"><a class="permalink" href="#Using_Net::SSLeay_in_multi-threaded_applications">Using
  Net::SSLeay in multi-threaded applications</a></h2>
<p class="Pp"><b>IMPORTANT: versions 1.42 or earlier are not
  thread-safe!</b></p>
<p class="Pp">Net::SSLeay module implements all necessary stuff to be ready for
    multi-threaded environment - it requires openssl-0.9.7 or newer. The
    implementation fully follows thread safety related requirements of openssl
    library(see &lt;http://www.openssl.org/docs/crypto/threads.html&gt;).</p>
<p class="Pp">If you are about to use Net::SSLeay (or any other module based on
    Net::SSLeay) in multi-threaded perl application it is recommended to follow
    this best-practice:</p>
<p class="Pp"><i>Initialization</i></p>
<p class="Pp">Load and initialize Net::SSLeay module in the main thread:</p>
<p class="Pp"></p>
<pre>
    use threads;
    use Net::SSLeay;

    Net::SSLeay::load_error_strings();
    Net::SSLeay::SSLeay_add_ssl_algorithms();
    Net::SSLeay::randomize();

    sub do_master_job {
      #... call whatever from Net::SSLeay
    }

    sub do_worker_job {
      #... call whatever from Net::SSLeay
    }

    #start threads
    my $master  = threads-&gt;new(\&amp;do_master_job, 'param1', 'param2');
    my @workers = threads-&gt;new(\&amp;do_worker_job, 'arg1', 'arg2') for (1..10);

    #waiting for all threads to finish
    $_-&gt;join() for (threads-&gt;list);
</pre>
<p class="Pp">NOTE: Openssl's <span class="Li">&quot;int
    SSL_library_init(void)&quot;</span> function (which is also aliased as
    <span class="Li">&quot;SSLeay_add_ssl_algorithms&quot;</span>,
    <span class="Li">&quot;OpenSSL_add_ssl_algorithms&quot;</span> and
    <span class="Li">&quot;add_ssl_algorithms&quot;</span>) is not re-entrant
    and multiple calls can cause a crash in threaded application. Net::SSLeay
    implements flags preventing repeated calls to this function, therefore even
    multiple initialization via <b>Net::SSLeay::SSLeay_add_ssl_algorithms()</b>
    should work without trouble.</p>
<p class="Pp"><i>Using callbacks</i></p>
<p class="Pp">Do not use callbacks across threads (the module blocks
    cross-thread callback operations and throws a warning). Always do the
    callback setup, callback use and callback destruction within the same
    thread.</p>
<p class="Pp"><i>Using openssl elements</i></p>
<p class="Pp">All openssl elements (X509, SSL_CTX, ...) can be directly passed
    between threads.</p>
<p class="Pp"></p>
<pre>
    use threads;
    use Net::SSLeay;

    Net::SSLeay::load_error_strings();
    Net::SSLeay::SSLeay_add_ssl_algorithms();
    Net::SSLeay::randomize();

    sub do_job {
      my $context = shift;
      Net::SSLeay::CTX_set_default_passwd_cb($context, sub { &quot;secret&quot; });
      #...
    }

    my $c = Net::SSLeay::CTX_new();
    threads-&gt;create(\&amp;do_job, $c);
</pre>
<p class="Pp">Or:</p>
<p class="Pp"></p>
<pre>
    use threads;
    use Net::SSLeay;

    my $context; #does not need to be 'shared'

    Net::SSLeay::load_error_strings();
    Net::SSLeay::SSLeay_add_ssl_algorithms();
    Net::SSLeay::randomize();

    sub do_job {
      Net::SSLeay::CTX_set_default_passwd_cb($context, sub { &quot;secret&quot; });
      #...
    }

    $context = Net::SSLeay::CTX_new();
    threads-&gt;create(\&amp;do_job);
</pre>
<p class="Pp"><i>Using other perl modules based on Net::SSLeay</i></p>
<p class="Pp">It should be fine to use any other module based on Net::SSLeay
    (like IO::Socket::SSL) in multi-threaded applications. It is generally
    recommended to do any global initialization of such a module in the main
    thread before calling
    <span class="Li">&quot;threads-&gt;new(..)&quot;</span> or
    <span class="Li">&quot;threads-&gt;create(..)&quot;</span> but it might
    differ module by module.</p>
<p class="Pp">To be safe you can load and init Net::SSLeay explicitly in the
    main thread:</p>
<p class="Pp"></p>
<pre>
    use Net::SSLeay;
    use Other::SSLeay::Based::Module;

    Net::SSLeay::load_error_strings();
    Net::SSLeay::SSLeay_add_ssl_algorithms();
    Net::SSLeay::randomize();
</pre>
<p class="Pp">Or even safer:</p>
<p class="Pp"></p>
<pre>
    use Net::SSLeay;
    use Other::SSLeay::Based::Module;

    BEGIN {
      Net::SSLeay::load_error_strings();
      Net::SSLeay::SSLeay_add_ssl_algorithms();
      Net::SSLeay::randomize();
    }
</pre>
<p class="Pp"><i>Combining Net::SSLeay with other modules linked with
    openssl</i></p>
<p class="Pp"><b>BEWARE: This might be a big trouble! This is not guaranteed be
    thread-safe!</b></p>
<p class="Pp">There are many other (XS) modules linked directly to openssl
    library (like Crypt::SSLeay).</p>
<p class="Pp">As it is expected that also &quot;another&quot; module will call
    <span class="Li">&quot;SSLeay_add_ssl_algorithms&quot;</span> at some point
    we have again a trouble with multiple openssl initialization by Net::SSLeay
    and &quot;another&quot; module.</p>
<p class="Pp">As you can expect Net::SSLeay is not able to avoid multiple
    initialization of openssl library called by &quot;another&quot; module, thus
    you have to handle this on your own (in some cases it might not be possible
    at all to avoid this).</p>
<p class="Pp"><i>Threading with get_https and friends</i></p>
<p class="Pp">The convenience functions get_https, post_https etc all initialize
    the SSL library by calling Net::SSLeay::initialize which does the
    conventional library initialization:</p>
<p class="Pp"></p>
<pre>
    Net::SSLeay::load_error_strings();
    Net::SSLeay::SSLeay_add_ssl_algorithms();
    Net::SSLeay::randomize();
</pre>
<p class="Pp">Net::SSLeay::initialize initializes the SSL library at most once.
    You can override the Net::SSLeay::initialize function if you desire some
    other type of initialization behaviour by get_https and friends. You can
    call Net::SSLeay::initialize from your own code if you desire this
    conventional library initialization.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Convenience_routines"><a class="permalink" href="#Convenience_routines">Convenience
  routines</a></h2>
<p class="Pp">To be used with Low level API</p>
<p class="Pp"></p>
<pre>
    Net::SSLeay::randomize($rn_seed_file,$additional_seed);
    Net::SSLeay::set_cert_and_key($ctx, $cert_path, $key_path);
    $cert = Net::SSLeay::dump_peer_certificate($ssl);
    Net::SSLeay::ssl_write_all($ssl, $message) or die &quot;ssl write failure&quot;;
    $got = Net::SSLeay::ssl_read_all($ssl) or die &quot;ssl read failure&quot;;

    $got = Net::SSLeay::ssl_read_CRLF($ssl [, $max_length]);
    $got = Net::SSLeay::ssl_read_until($ssl [, $delimit [, $max_length]]);
    Net::SSLeay::ssl_write_CRLF($ssl, $message);
</pre>
<ul class="Bl-bullet">
  <li>randomize
    <p class="Pp">seeds the openssl PRNG with
        <span class="Li">&quot;/dev/urandom&quot;</span> (see the top of
        <span class="Li">&quot;SSLeay.pm&quot;</span> for how to change or
        configure this) and optionally with user provided data. It is very
        important to properly seed your random numbers, so do not forget to call
        this. The high level API functions automatically call
        <span class="Li">&quot;randomize()&quot;</span> so it is not needed with
        them. See also caveats.</p>
  </li>
  <li>set_cert_and_key
    <p class="Pp">takes two file names as arguments and sets the certificate and
        private key to those. This can be used to set either server certificates
        or client certificates.</p>
  </li>
  <li>dump_peer_certificate
    <p class="Pp">allows you to get a plaintext description of the certificate
        the peer (usually the server) presented to us.</p>
  </li>
  <li>ssl_read_all
    <p class="Pp">see ssl_write_all (below)</p>
  </li>
  <li>ssl_write_all
    <p class="Pp"><span class="Li">&quot;ssl_read_all()&quot;</span> and
        <span class="Li">&quot;ssl_write_all()&quot;</span> provide true
        blocking semantics for these operations (see limitation, below, for
        explanation). These are much preferred to the low level API equivalents
        (which implement BSD blocking semantics). The message argument to
        <span class="Li">&quot;ssl_write_all()&quot;</span> can be a reference.
        This is helpful to avoid unnecessary copying when writing something big,
        e.g:</p>
    <p class="Pp"></p>
    <pre>
    $data = 'A' x 1000000000;
    Net::SSLeay::ssl_write_all($ssl, \$data) or die &quot;ssl write failed&quot;;
    </pre>
  </li>
  <li>ssl_read_CRLF
    <p class="Pp">uses <span class="Li">&quot;ssl_read_all()&quot;</span> to
        read in a line terminated with a carriage return followed by a linefeed
        (CRLF). The CRLF is included in the returned scalar.</p>
  </li>
  <li>ssl_read_until
    <p class="Pp">uses <span class="Li">&quot;ssl_read_all()&quot;</span> to
        read from the SSL input stream until it encounters a programmer
        specified delimiter. If the delimiter is undefined,
        <span class="Li">$/</span> is used. If <span class="Li">$/</span> is
        undefined, <span class="Li">&quot;\n&quot;</span> is used. One can
        optionally set a maximum length of bytes to read from the SSL input
        stream.</p>
  </li>
  <li>ssl_write_CRLF
    <p class="Pp">writes <span class="Li">$message</span> and appends CRLF to
        the SSL output stream.</p>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Initialization"><a class="permalink" href="#Initialization">Initialization</a></h2>
<p class="Pp">In order to use the low level API you should start your programs
    with the following incantation:</p>
<p class="Pp"></p>
<pre>
        use Net::SSLeay qw(die_now die_if_ssl_error);
        Net::SSLeay::load_error_strings();
        Net::SSLeay::SSLeay_add_ssl_algorithms();    # Important!
        Net::SSLeay::ENGINE_load_builtin_engines();  # If you want built-in engines
        Net::SSLeay::ENGINE_register_all_complete(); # If you want built-in engines
        Net::SSLeay::randomize();
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Error_handling_functions"><a class="permalink" href="#Error_handling_functions">Error
  handling functions</a></h2>
<p class="Pp">I can not emphasize the need to check for error enough. Use these
    functions even in the most simple programs, they will reduce debugging time
    greatly. Do not ask questions on the mailing list without having first
    sprinkled these in your code.</p>
<ul class="Bl-bullet">
  <li>die_now</li>
  <li>die_if_ssl_error
    <p class="Pp"><span class="Li">&quot;die_now()&quot;</span> and
        <span class="Li">&quot;die_if_ssl_error()&quot;</span> are used to
        conveniently print the SSLeay error stack when something goes wrong:</p>
    <p class="Pp"></p>
    <pre>
        Net::SSLeay::connect($ssl) or die_now(&quot;Failed SSL connect ($!)&quot;);


        Net::SSLeay::write($ssl, &quot;foo&quot;) or die_if_ssl_error(&quot;SSL write ($!)&quot;);
    </pre>
  </li>
  <li>print_errs
    <p class="Pp">You can also use
        <span class="Li">&quot;Net::SSLeay::print_errs()&quot;</span> to dump
        the error stack without exiting the program. As can be seen, your code
        becomes much more readable if you import the error reporting functions
        into your main name space.</p>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Sockets"><a class="permalink" href="#Sockets">Sockets</a></h2>
<p class="Pp">Perl uses file handles for all I/O. While SSLeay has a quite
    flexible BIO mechanism and perl has an evolved PerlIO mechanism, this module
    still sticks to using file descriptors. Thus to attach SSLeay to a socket
    you should use <span class="Li">&quot;fileno()&quot;</span> to extract the
    underlying file descriptor:</p>
<p class="Pp"></p>
<pre>
    Net::SSLeay::set_fd($ssl, fileno(S));   # Must use fileno
</pre>
<p class="Pp">You should also set <span class="Li">$|</span> to 1 to eliminate
    STDIO buffering so you do not get confused if you use perl I/O functions to
    manipulate your socket handle.</p>
<p class="Pp">If you need to <span class="Li">select(2)</span> on the socket, go
    right ahead, but be warned that OpenSSL does some internal buffering so
    SSL_read does not always return data even if the socket selected for reading
    (just keep on selecting and trying to read).
    <span class="Li">&quot;Net::SSLeay&quot;</span> is no different from the C
    language OpenSSL in this respect.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Callbacks"><a class="permalink" href="#Callbacks">Callbacks</a></h2>
<p class="Pp">You can establish a per-context verify callback function something
    like this:</p>
<p class="Pp"></p>
<pre>
        sub verify {
            my ($ok, $x509_store_ctx) = @_;
            print &quot;Verifying certificate...\n&quot;;
                ...
            return $ok;
        }
</pre>
<p class="Pp">It is used like this:</p>
<p class="Pp"></p>
<pre>
        Net::SSLeay::set_verify ($ssl, Net::SSLeay::VERIFY_PEER, \&amp;verify);
</pre>
<p class="Pp">Per-context callbacks for decrypting private keys are
  implemented.</p>
<p class="Pp"></p>
<pre>
        Net::SSLeay::CTX_set_default_passwd_cb($ctx, sub { &quot;top-secret&quot; });
        Net::SSLeay::CTX_use_PrivateKey_file($ctx, &quot;key.pem&quot;,
                                             Net::SSLeay::FILETYPE_PEM)
            or die &quot;Error reading private key&quot;;
        Net::SSLeay::CTX_set_default_passwd_cb($ctx, undef);
</pre>
<p class="Pp">If Hello Extensions are supported by your OpenSSL, a session
    secret callback can be set up to be called when a session secret is set by
    openssl.</p>
<p class="Pp">Establish it like this:
  <br/>
   Net::SSLeay::set_session_secret_cb($ssl, \&amp;session_secret_cb,
    <span class="Li">$somedata</span>);</p>
<p class="Pp">It will be called like this:</p>
<p class="Pp"></p>
<pre>
    sub session_secret_cb
    {
        my ($secret, \@cipherlist, \$preferredcipher, $somedata) = @_;
    }
</pre>
<p class="Pp">No other callbacks are implemented. You do not need to use any
    callback for simple (i.e. normal) cases where the SSLeay built-in verify
    mechanism satisfies your needs.</p>
<p class="Pp">It is required to reset these callbacks to undef immediately after
    use to prevent memory leaks, thread safety problems and crashes on exit that
    can occur if different threads set different callbacks.</p>
<p class="Pp">If you want to use callback stuff, see examples/callback.pl! It's
    the only one I am able to make work reliably.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Low_level_"><a class="permalink" href="#Low_level_">Low level
  API</a></h2>
<p class="Pp">In addition to the high level functions outlined above, this
    module contains straight-forward access to CRYPTO and SSL parts of OpenSSL C
    API.</p>
<p class="Pp">See the <span class="Li">&quot;*.h&quot;</span> headers from
    OpenSSL C distribution for a list of low level SSLeay functions to call
    (check SSLeay.xs to see if some function has been implemented). The module
    strips the initial <span class="Li">&quot;SSL_&quot;</span> off of the
    SSLeay names. Generally you should use
    <span class="Li">&quot;Net::SSLeay::&quot;</span> in its place.</p>
<p class="Pp">Note that some functions are prefixed with
    <span class="Li">&quot;P_&quot;</span> - these are very close to the
    original API however contain some kind of a wrapper making its interface
    more perl friendly.</p>
<p class="Pp">For example:</p>
<p class="Pp">In C:</p>
<p class="Pp"></p>
<pre>
        #include &lt;ssl.h&gt;

        err = SSL_set_verify (ssl, SSL_VERIFY_CLIENT_ONCE,
                                   &amp;your_call_back_here);
</pre>
<p class="Pp">In Perl:</p>
<p class="Pp"></p>
<pre>
        use Net::SSLeay;

        $err = Net::SSLeay::set_verify ($ssl,
                                        Net::SSLeay::VERIFY_CLIENT_ONCE,
                                        \&amp;your_call_back_here);
</pre>
<p class="Pp">If the function does not start with
    <span class="Li">&quot;SSL_&quot;</span> you should use the full function
    name, e.g.:</p>
<p class="Pp"></p>
<pre>
        $err = Net::SSLeay::ERR_get_error;
</pre>
<p class="Pp">The following new functions behave in perlish way:</p>
<p class="Pp"></p>
<pre>
        $got = Net::SSLeay::read($ssl);
                                    # Performs SSL_read, but returns $got
                                    # resized according to data received.
                                    # Returns undef on failure.

        Net::SSLeay::write($ssl, $foo) || die;
                                    # Performs SSL_write, but automatically
                                    # figures out the size of $foo
</pre>
<p class="Pp"><i>Low level API: Version related functions</i></p>
<ul class="Bl-bullet">
  <li>SSLeay
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and
        before</p>
    <p class="Pp">Gives version number (numeric) of underlaying openssl
      library.</p>
    <p class="Pp"></p>
    <pre>
 my $ver_number = Net::SSLeay::SSLeay();
 # returns: the number identifying the openssl release
 #
 # 0x00903100 =&gt; openssl-0.9.3
 # 0x00904100 =&gt; openssl-0.9.4
 # 0x00905100 =&gt; openssl-0.9.5
 # 0x0090600f =&gt; openssl-0.9.6
 # 0x0090601f =&gt; openssl-0.9.6a
 # 0x0090602f =&gt; openssl-0.9.6b
 # ...
 # 0x009060df =&gt; openssl-0.9.6m
 # 0x0090700f =&gt; openssl-0.9.7
 # 0x0090701f =&gt; openssl-0.9.7a
 # 0x0090702f =&gt; openssl-0.9.7b
 # ...
 # 0x009070df =&gt; openssl-0.9.7m
 # 0x0090800f =&gt; openssl-0.9.8
 # 0x0090801f =&gt; openssl-0.9.8a
 # 0x0090802f =&gt; openssl-0.9.8b
 # ...
 # 0x0090814f =&gt; openssl-0.9.8t
 # 0x1000000f =&gt; openssl-1.0.0
 # 0x1000004f =&gt; openssl-1.0.0d
 # 0x1000007f =&gt; openssl-1.0.0g
    </pre>
    <p class="Pp">You can use it like this:</p>
    <p class="Pp"></p>
    <pre>
  if (Net::SSLeay::SSLeay() &lt; 0x0090800f) {
    die &quot;you need openssl-0.9.8 or higher&quot;;
  }
    </pre>
  </li>
  <li>SSLeay_version
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and
        before</p>
    <p class="Pp">Gives version number (string) of underlaying openssl
      library.</p>
    <p class="Pp"></p>
    <pre>
 my $ver_string = Net::SSLeay::SSLeay_version($type);
 # $type
 #   SSLEAY_VERSION  - e.g. 'OpenSSL 1.0.0d 8 Feb 2011'
 #   SSLEAY_CFLAGS   - e.g. 'compiler: gcc -D_WINDLL -DOPENSSL_USE_APPLINK .....'
 #   SSLEAY_BUILT_ON - e.g. 'built on: Fri May  6 00:00:46 GMT 2011'
 #   SSLEAY_PLATFORM - e.g. 'platform: mingw'
 #   SSLEAY_DIR      - e.g. 'OPENSSLDIR: &quot;z:/....&quot;'
 #
 # returns: string

 Net::SSLeay::SSLeay_version();
 #is equivalent to
 Net::SSLeay::SSLeay_version(SSLEAY_VERSION);
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/man1.0.2/crypto/SSLeay_version.html&gt;</p>
  </li>
  <li>OpenSSL_version_num
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.82 and
        before; requires at least OpenSSL 1.1.0</p>
    <p class="Pp">Gives version number (numeric) of underlaying openssl library.
        See &quot;SSLeay&quot; for interpreting the result.</p>
    <p class="Pp"></p>
    <pre>
 my $ver_number = Net::SSLeay::OpenSSL_version_num();
 # returns: the number identifying the openssl release
    </pre>
  </li>
  <li>OpenSSL_version
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.82 and
        before; requires at least OpenSSL 1.1.0</p>
    <p class="Pp">Gives version number (string) of underlaying openssl
      library.</p>
    <p class="Pp"></p>
    <pre>
 my $ver_string = Net::SSLeay::OpenSSL_version($t);
 # $t
 #   OPENSSL_VERSION     - e.g. 'OpenSSL 1.1.0g  2 Nov 2017'
 #   OPENSSL_CFLAGS      - e.g. 'compiler: cc -DDSO_DLFCN -DHAVE_DLFCN_H .....'
 #   OPENSSL_BUILT_ON    - e.g. 'built on: reproducible build, date unspecified'
 #   OPENSSL_PLATFORM    - e.g. 'platform: darwin64-x86_64-cc'
 #   OPENSSL_DIR         - e.g. 'OPENSSLDIR: &quot;/opt/openssl-1.1.0g&quot;'
 #   OPENSSL_ENGINES_DIR - e.g. 'ENGINESDIR: &quot;/opt/openssl-1.1.0g/lib/engines-1.1&quot;'
 #
 # returns: string

 Net::SSLeay::OpenSSL_version();
 #is equivalent to
 Net::SSLeay::OpenSSL_version(OPENSSL_VERSION);
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/crypto/OpenSSL_version.html&gt;</p>
  </li>
</ul>
<p class="Pp"><i>Low level API: Initialization related functions</i></p>
<ul class="Bl-bullet">
  <li>library_init
    <p class="Pp">Initialize SSL library by registering algorithms.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::library_init();
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_library_init.html&gt;</p>
    <p class="Pp">While the original function from OpenSSL always returns 1,
        Net::SSLeay adds a wrapper around it to make sure that the OpenSSL
        function is only called once. Thus the function will return 1 if
        initialization was done and 0 if not, i.e. if initialization was done
        already before.</p>
  </li>
  <li>add_ssl_algorithms
    <p class="Pp">The alias for &quot;library_init&quot;</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::add_ssl_algorithms();
    </pre>
  </li>
  <li>OpenSSL_add_ssl_algorithms
    <p class="Pp">The alias for &quot;library_init&quot;</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::OpenSSL_add_ssl_algorithms();
    </pre>
  </li>
  <li>SSLeay_add_ssl_algorithms
    <p class="Pp">The alias for &quot;library_init&quot;</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::SSLeay_add_ssl_algorithms();
    </pre>
  </li>
  <li>load_error_strings
    <p class="Pp">Registers the error strings for all libcrypto + libssl related
        functions.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::load_error_strings();
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/ERR_load_crypto_strings.html&gt;</p>
  </li>
  <li>ERR_load_crypto_strings
    <p class="Pp">Registers the error strings for all libcrypto functions. No
        need to call this function if you have already called
        &quot;load_error_strings&quot;.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::ERR_load_crypto_strings();
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/ERR_load_crypto_strings.html&gt;</p>
  </li>
  <li>ERR_load_RAND_strings
    <p class="Pp">Registers the error strings for RAND related functions. No
        need to call this function if you have already called
        &quot;load_error_strings&quot;.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::ERR_load_RAND_strings();
 #
 # returns: no return value
    </pre>
  </li>
  <li>ERR_load_SSL_strings
    <p class="Pp">Registers the error strings for SSL related functions. No need
        to call this function if you have already called
        &quot;load_error_strings&quot;.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::ERR_load_SSL_strings();
 #
 # returns: no return value
    </pre>
  </li>
  <li>OpenSSL_add_all_algorithms
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Add algorithms to internal table.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::OpenSSL_add_all_algorithms();
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/OpenSSL_add_all_algorithms.html&gt;</p>
  </li>
  <li>OPENSSL_add_all_algorithms_conf
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Similar to &quot;OpenSSL_add_all_algorithms&quot; - will
        ALWAYS load the config file</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::OPENSSL_add_all_algorithms_conf();
 #
 # returns: no return value
    </pre>
  </li>
  <li>OPENSSL_add_all_algorithms_noconf
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Similar to &quot;OpenSSL_add_all_algorithms&quot; - will NEVER
        load the config file</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::OPENSSL_add_all_algorithms_noconf();
 #
 # returns: no return value
    </pre>
  </li>
</ul>
<p class="Pp"><i>Low level API: ERR_* and SSL_alert_* related functions</i></p>
<p class="Pp"><b>NOTE:</b> Please note that SSL_alert_* function have
    &quot;SSL_&quot; part stripped from their names.</p>
<ul class="Bl-bullet">
  <li>ERR_clear_error
    <p class="Pp">Clear the error queue.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::ERR_clear_error();
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/ERR_clear_error.html&gt;</p>
  </li>
  <li>ERR_error_string
    <p class="Pp">Generates a human-readable string representing the error code
        <span class="Li">$error</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::ERR_error_string($error);
 # $error - (unsigned integer) error code
 #
 # returns: string
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/ERR_error_string.html&gt;</p>
  </li>
  <li>ERR_get_error
    <p class="Pp">Returns the earliest error code from the thread's error queue
        and removes the entry. This function can be called repeatedly until
        there are no more error codes to return.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::ERR_get_error();
 #
 # returns: (unsigned integer) error code
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/ERR_get_error.html&gt;</p>
  </li>
  <li>ERR_peek_error
    <p class="Pp">Returns the earliest error code from the thread's error queue
        without modifying it.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::ERR_peek_error();
 #
 # returns: (unsigned integer) error code
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/ERR_get_error.html&gt;</p>
  </li>
  <li>ERR_put_error
    <p class="Pp">Adds an error code to the thread's error queue. It signals
        that the error of <span class="Li">$reason</span> code reason occurred
        in function <span class="Li">$func</span> of library
        <span class="Li">$lib</span>, in line number
        <span class="Li">$line</span> of <span class="Li">$file</span>.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::ERR_put_error($lib, $func, $reason, $file, $line);
 # $lib - (integer) library id (check openssl/err.h for constants e.g. ERR_LIB_SSL)
 # $func - (integer) function id (check openssl/ssl.h for constants e.g. SSL_F_SSL23_READ)
 # $reason - (integer) reason id (check openssl/ssl.h for constants e.g. SSL_R_SSL_HANDSHAKE_FAILURE)
 # $file - (string) file name
 # $line - (integer) line number in $file
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/ERR_put_error.html&gt; and
        &lt;http://www.openssl.org/docs/crypto/err.html&gt;</p>
  </li>
  <li>alert_desc_string
    <p class="Pp">Returns a two letter string as a short form describing the
        reason of the alert specified by value.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::alert_desc_string($value);
 # $value - (integer) allert id (check openssl/ssl.h for SSL3_AD_* and TLS1_AD_* constants)
 #
 # returns: description string (2 letters)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_alert_type_string.html&gt;</p>
  </li>
  <li>alert_desc_string_long
    <p class="Pp">Returns a string describing the reason of the alert specified
        by value.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::alert_desc_string_long($value);
 # $value - (integer) allert id (check openssl/ssl.h for SSL3_AD_* and TLS1_AD_* constants)
 #
 # returns: description string
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_alert_type_string.html&gt;</p>
  </li>
  <li>alert_type_string
    <p class="Pp">Returns a one letter string indicating the type of the alert
        specified by value.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::alert_type_string($value);
 # $value - (integer) allert id (check openssl/ssl.h for SSL3_AD_* and TLS1_AD_* constants)
 #
 # returns: string (1 letter)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_alert_type_string.html&gt;</p>
  </li>
  <li>alert_type_string_long
    <p class="Pp">Returns a string indicating the type of the alert specified by
        value.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::alert_type_string_long($value);
 # $value - (integer) allert id (check openssl/ssl.h for SSL3_AD_* and TLS1_AD_* constants)
 #
 # returns: string
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_alert_type_string.html&gt;</p>
  </li>
</ul>
<p class="Pp"><i>Low level API: SSL_METHOD_* related functions</i></p>
<ul class="Bl-bullet">
  <li>SSLv23_method, SSLv23_server_method and SSLv23_client_method
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.82 and
        before.</p>
    <p class="Pp">Returns SSL_METHOD structure corresponding to general-purpose
        version-flexible TLS method, the return value can be later used as a
        param of &quot;CTX_new_with_method&quot;.</p>
    <p class="Pp"><b>NOTE:</b> Consider using TLS_method, TLS_server_method or
        TLS_client_method with new code.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::SSLv2_method();
 #
 # returns: value corresponding to openssl's SSL_METHOD structure (0 on failure)
    </pre>
  </li>
  <li>SSLv2_method
    <p class="Pp">Returns SSL_METHOD structure corresponding to SSLv2 method,
        the return value can be later used as a param of
        &quot;CTX_new_with_method&quot;. Only available where supported by the
        underlying openssl.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::SSLv2_method();
 #
 # returns: value corresponding to openssl's SSL_METHOD structure (0 on failure)
    </pre>
  </li>
  <li>SSLv3_method
    <p class="Pp">Returns SSL_METHOD structure corresponding to SSLv3 method,
        the return value can be later used as a param of
        &quot;CTX_new_with_method&quot;.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::SSLv3_method();
 #
 # returns: value corresponding to openssl's SSL_METHOD structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_new.html&gt;</p>
  </li>
  <li>TLSv1_method, TLSv1_server_method and TLSv1_client_method
    <p class="Pp"><b>COMPATIBILITY:</b> Server and client methods not available
        in Net-SSLeay-1.82 and before.</p>
    <p class="Pp">Returns SSL_METHOD structure corresponding to TLSv1 method,
        the return value can be later used as a param of
        &quot;CTX_new_with_method&quot;.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::TLSv1_method();
 #
 # returns: value corresponding to openssl's SSL_METHOD structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_new.html&gt;</p>
  </li>
  <li>TLSv1_1_method, TLSv1_1_server_method and TLSv1_1_client_method
    <p class="Pp"><b>COMPATIBILITY:</b> Server and client methods not available
        in Net-SSLeay-1.82 and before.</p>
    <p class="Pp">Returns SSL_METHOD structure corresponding to TLSv1_1 method,
        the return value can be later used as a param of
        &quot;CTX_new_with_method&quot;. Only available where supported by the
        underlying openssl.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::TLSv1_1_method();
 #
 # returns: value corresponding to openssl's SSL_METHOD structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_new.html&gt;</p>
  </li>
  <li>TLSv1_2_method, TLSv1_2_server_method and TLSv1_2_client_method
    <p class="Pp"><b>COMPATIBILITY:</b> Server and client methods not available
        in Net-SSLeay-1.82 and before.</p>
    <p class="Pp">Returns SSL_METHOD structure corresponding to TLSv1_2 method,
        the return value can be later used as a param of
        &quot;CTX_new_with_method&quot;. Only available where supported by the
        underlying openssl.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::TLSv1_2_method();
 #
 # returns: value corresponding to openssl's SSL_METHOD structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_new.html&gt;</p>
  </li>
  <li>TLS_method, TLS_server_method and TLS_client_method
    <p class="Pp"><b>COMPATIBILITY:</b> Not available in Net-SSLeay-1.82 and
        before.</p>
    <p class="Pp">Returns SSL_METHOD structure corresponding to general-purpose
        version-flexible TLS method, the return value can be later used as a
        param of &quot;CTX_new_with_method&quot;. Only available where supported
        by the underlying openssl.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::TLS_method();
 #
 # returns: value corresponding to openssl's SSL_METHOD structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_new.html&gt;</p>
  </li>
</ul>
<p class="Pp"><i>Low level API: ENGINE_* related functions</i></p>
<ul class="Bl-bullet">
  <li>ENGINE_load_builtin_engines
    <p class="Pp"><b>COMPATIBILITY:</b> Requires an OpenSSL build with dynamic
        engine loading support.</p>
    <p class="Pp">Load all bundled ENGINEs into memory and make them
      visible.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::ENGINE_load_builtin_engines();
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/engine.html&gt;</p>
  </li>
  <li>ENGINE_register_all_complete
    <p class="Pp"><b>COMPATIBILITY:</b> Requires an OpenSSL build with dynamic
        engine loading support.</p>
    <p class="Pp">Register all loaded ENGINEs for every algorithm they
        collectively implement.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::ENGINE_register_all_complete();
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/engine.html&gt;</p>
  </li>
  <li>ENGINE_set_default
    <p class="Pp"><b>COMPATIBILITY:</b> Requires an OpenSSL build with dynamic
        engine loading support.</p>
    <p class="Pp">Set default engine to <span class="Li">$e</span> + set its
        flags to <span class="Li">$flags</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::ENGINE_set_default($e, $flags);
 # $e - value corresponding to openssl's ENGINE structure
 # $flags - (integer) engine flags
 #          flags value can be made by bitwise &quot;OR&quot;ing:
 #          0x0001 - ENGINE_METHOD_RSA
 #          0x0002 - ENGINE_METHOD_DSA
 #          0x0004 - ENGINE_METHOD_DH
 #          0x0008 - ENGINE_METHOD_RAND
 #          0x0010 - ENGINE_METHOD_ECDH
 #          0x0020 - ENGINE_METHOD_ECDSA
 #          0x0040 - ENGINE_METHOD_CIPHERS
 #          0x0080 - ENGINE_METHOD_DIGESTS
 #          0x0100 - ENGINE_METHOD_STORE
 #          0x0200 - ENGINE_METHOD_PKEY_METHS
 #          0x0400 - ENGINE_METHOD_PKEY_ASN1_METHS
 #          Obvious all-or-nothing cases:
 #          0xFFFF - ENGINE_METHOD_ALL
 #          0x0000 - ENGINE_METHOD_NONE
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/engine.html&gt;</p>
  </li>
  <li>ENGINE_by_id
    <p class="Pp">Get ENGINE by its identification
      <span class="Li">$id</span>.</p>
    <p class="Pp"><b>COMPATIBILITY:</b> Requires an OpenSSL build with dynamic
        engine loading support.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::ENGINE_by_id($id);
 # $id - (string) engine identification e.g. &quot;dynamic&quot;
 #
 # returns: value corresponding to openssl's ENGINE structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/engine.html&gt;</p>
  </li>
</ul>
<p class="Pp"><i>Low level API: EVP_PKEY_* related functions</i></p>
<ul class="Bl-bullet">
  <li>EVP_PKEY_copy_parameters
    <p class="Pp">Copies the parameters from key <span class="Li">$from</span>
        to key <span class="Li">$to</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::EVP_PKEY_copy_parameters($to, $from);
 # $to - value corresponding to openssl's EVP_PKEY structure
 # $from - value corresponding to openssl's EVP_PKEY structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/EVP_PKEY_cmp.html&gt;</p>
  </li>
  <li>EVP_PKEY_new
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Creates a new EVP_PKEY structure.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::EVP_PKEY_new();
 #
 # returns: value corresponding to openssl's EVP_PKEY structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/EVP_PKEY_new.html&gt;</p>
  </li>
  <li>EVP_PKEY_free
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Free an allocated EVP_PKEY structure.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::EVP_PKEY_free($pkey);
 # $pkey - value corresponding to openssl's EVP_PKEY structure
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/EVP_PKEY_new.html&gt;</p>
  </li>
  <li>EVP_PKEY_assign_RSA
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Set the key referenced by <span class="Li">$pkey</span> to
        <span class="Li">$key</span></p>
    <p class="Pp"><b>NOTE:</b> No reference counter will be increased, i.e.
        <span class="Li">$key</span> will be freed if
        <span class="Li">$pkey</span> is freed.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::EVP_PKEY_assign_RSA($pkey, $key);
 # $pkey - value corresponding to openssl's EVP_PKEY structure
 # $key - value corresponding to openssl's RSA structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/EVP_PKEY_assign_RSA.html&gt;</p>
  </li>
  <li>EVP_PKEY_assign_EC_KEY
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.74 and
        before</p>
    <p class="Pp">Set the key referenced by <span class="Li">$pkey</span> to
        <span class="Li">$key</span></p>
    <p class="Pp"><b>NOTE:</b> No reference counter will be increased, i.e.
        <span class="Li">$key</span> will be freed if
        <span class="Li">$pkey</span> is freed.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::EVP_PKEY_assign_EC_KEY($pkey, $key);
 # $pkey - value corresponding to openssl's EVP_PKEY structure
 # $key - value corresponding to openssl's EC_KEY structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/EVP_PKEY_assign_EC_KEY.html&gt;</p>
  </li>
  <li>EVP_PKEY_bits
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Returns the size of the key <span class="Li">$pkey</span> in
        bits.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::EVP_PKEY_bits($pkey);
 # $pkey - value corresponding to openssl's EVP_PKEY structure
 #
 # returns: size in bits
    </pre>
  </li>
  <li>EVP_PKEY_size
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Returns the maximum size of a signature in bytes. The actual
        signature may be smaller.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::EVP_PKEY_size($pkey);
 # $pkey - value corresponding to openssl's EVP_PKEY structure
 #
 # returns: the maximum size in bytes
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/EVP_SignInit.html&gt;</p>
  </li>
  <li>EVP_PKEY_id
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before; requires at least openssl-1.0.0</p>
    <p class="Pp">Returns <span class="Li">$pkey</span> type (integer value of
        corresponding NID).</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::EVP_PKEY_id($pkey);
 # $pkey - value corresponding to openssl's EVP_PKEY structure
 #
 # returns: (integer) key type
    </pre>
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>
 my $pubkey = Net::SSLeay::X509_get_pubkey($x509);
 my $type = Net::SSLeay::EVP_PKEY_id($pubkey);
 print Net::SSLeay::OBJ_nid2sn($type);             #prints e.g. 'rsaEncryption'
    </pre>
  </li>
</ul>
<p class="Pp"><i>Low level API: PEM_* related functions</i></p>
<p class="Pp">Check openssl doc
    &lt;http://www.openssl.org/docs/crypto/pem.html&gt;</p>
<ul class="Bl-bullet">
  <li>PEM_read_bio_X509
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Loads PEM formatted X509 certificate via given BIO
      structure.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::PEM_read_bio_X509($bio);
 # $bio - value corresponding to openssl's BIO structure
 #
 # returns: value corresponding to openssl's X509 structure (0 on failure)
    </pre>
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>
 my $bio = Net::SSLeay::BIO_new_file($filename, 'r');
 my $x509 = Net::SSLeay::PEM_read_bio_X509($bio);
 Net::SSLeay::BIO_free($bio);
    </pre>
  </li>
  <li>PEM_read_bio_X509_REQ
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Loads PEM formatted X509_REQ object via given BIO
      structure.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::PEM_read_bio_X509_REQ($bio, $x=NULL, $cb=NULL, $u=NULL);
 # $bio - value corresponding to openssl's BIO structure
 #
 # returns: value corresponding to openssl's X509_REQ structure (0 on failure)
    </pre>
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>
 my $bio = Net::SSLeay::BIO_new_file($filename, 'r');
 my $x509_req = Net::SSLeay::PEM_read_bio_X509_REQ($bio);
 Net::SSLeay::BIO_free($bio);
    </pre>
  </li>
  <li>PEM_read_bio_DHparams
    <p class="Pp">Reads DH structure from BIO.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::PEM_read_bio_DHparams($bio);
 # $bio - value corresponding to openssl's BIO structure
 #
 # returns: value corresponding to openssl's DH structure (0 on failure)
    </pre>
  </li>
  <li>PEM_read_bio_X509_CRL
    <p class="Pp">Reads X509_CRL structure from BIO.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::PEM_read_bio_X509_CRL($bio);
 # $bio - value corresponding to openssl's BIO structure
 #
 # returns: value corresponding to openssl's X509_CRL structure (0 on failure)
    </pre>
  </li>
  <li>PEM_read_bio_PrivateKey
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Loads PEM formatted private key via given BIO structure.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::PEM_read_bio_PrivateKey($bio, $cb, $data);
 # $bio - value corresponding to openssl's BIO structure
 # $cb - reference to perl callback function
 # $data - data that will be passed to callback function (see examples below)
 #
 # returns: value corresponding to openssl's EVP_PKEY structure (0 on failure)
    </pre>
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>
 my $bio = Net::SSLeay::BIO_new_file($filename, 'r');
 my $privkey = Net::SSLeay::PEM_read_bio_PrivateKey($bio); #ask for password if needed
 Net::SSLeay::BIO_free($bio);
    </pre>
    <p class="Pp">To use password you have the following options:</p>
    <p class="Pp"></p>
    <pre>
 $privkey = Net::SSLeay::PEM_read_bio_PrivateKey($bio, \&amp;callback_func); # use callback func for getting password
 $privkey = Net::SSLeay::PEM_read_bio_PrivateKey($bio, \&amp;callback_func, $data); # use callback_func + pass $data to callback_func
 $privkey = Net::SSLeay::PEM_read_bio_PrivateKey($bio, undef, &quot;secret&quot;); # use password &quot;secret&quot;
 $privkey = Net::SSLeay::PEM_read_bio_PrivateKey($bio, undef, &quot;&quot;);       # use empty password
    </pre>
    <p class="Pp">Callback function signature:</p>
    <p class="Pp"></p>
    <pre>
 sub callback_func {
   my ($max_passwd_size, $rwflag, $data) = @_;
   # $max_passwd_size - maximum size of returned password (longer values will be discarded)
   # $rwflag - indicates whether we are loading (0) or storing (1) - for PEM_read_bio_PrivateKey always 0
   # $data - the data passed to PEM_read_bio_PrivateKey as 3rd parameter

   return &quot;secret&quot;;
 }
    </pre>
  </li>
  <li>PEM_X509_INFO_read_bio
    <p class="Pp">Reads a BIO containing a PEM formatted file into a
        STACK_OF(X509_INFO) structure.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::PEM_X509_INFO_read_bio($bio);
 # $bio - value corresponding to openssl's BIO structure
 #
 # returns: value corresponding to openssl's STACK_OF(X509_INFO) structure.
    </pre>
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>
 my $bio = Net::SSLeay::BIO_new_file($filename, 'r');
 my $sk_x509_info = Net::SSLeay::PEM_X509_INFO_read_bio($bio);
 Net::SSLeay::BIO_free($bio);
    </pre>
  </li>
  <li>PEM_get_string_X509
    <p class="Pp"><b>NOTE:</b> Does not exactly correspond to any low level API
        function</p>
    <p class="Pp">Converts/exports X509 certificate to string (PEM format).</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::PEM_get_string_X509($x509);
 # $x509 - value corresponding to openssl's X509 structure
 #
 # returns: string with $x509 in PEM format
    </pre>
  </li>
  <li>PEM_get_string_PrivateKey
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Converts public key <span class="Li">$pk</span> into PEM
        formatted string (optionally protected with password).</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::PEM_get_string_PrivateKey($pk, $passwd, $enc_alg);
 # $pk - value corresponding to openssl's EVP_PKEY structure
 # $passwd - [optional] (string) password to use for key encryption
 # $enc_alg - [optional] algorithm to use for key encryption (default: DES_CBC) - value corresponding to openssl's EVP_CIPHER structure
 #
 # returns: PEM formatted string
    </pre>
    <p class="Pp">Examples:</p>
    <p class="Pp"></p>
    <pre>
 $pem_privkey = Net::SSLeay::PEM_get_string_PrivateKey($pk);
 $pem_privkey = Net::SSLeay::PEM_get_string_PrivateKey($pk, &quot;secret&quot;);
 $pem_privkey = Net::SSLeay::PEM_get_string_PrivateKey($pk, &quot;secret&quot;, Net::SSLeay::EVP_get_cipherbyname(&quot;DES-EDE3-CBC&quot;));
    </pre>
  </li>
  <li>PEM_get_string_X509_CRL
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Converts X509_CRL object <span class="Li">$x509_crl</span>
        into PEM formatted string.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::PEM_get_string_X509_CRL($x509_crl);
 # $x509_crl - value corresponding to openssl's X509_CRL structure
 #
 # returns: no return value
    </pre>
  </li>
  <li>PEM_get_string_X509_REQ
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Converts X509_REQ object <span class="Li">$x509_crl</span>
        into PEM formatted string.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::PEM_get_string_X509_REQ($x509_req);
 # $x509_req - value corresponding to openssl's X509_REQ structure
 #
 # returns: no return value
    </pre>
  </li>
</ul>
<p class="Pp"><i>Low level API: d2i_* (DER format) related functions</i></p>
<ul class="Bl-bullet">
  <li>d2i_X509_bio
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Loads DER formatted X509 certificate via given BIO
      structure.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::d2i_X509_bio($bp);
 # $bp - value corresponding to openssl's BIO structure
 #
 # returns: value corresponding to openssl's X509 structure (0 on failure)
    </pre>
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>
 my $bio = Net::SSLeay::BIO_new_file($filename, 'rb');
 my $x509 = Net::SSLeay::d2i_X509_bio($bio);
 Net::SSLeay::BIO_free($bio);
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/d2i_X509.html&gt;</p>
  </li>
  <li>d2i_X509_CRL_bio
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Loads DER formatted X509_CRL object via given BIO
      structure.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::d2i_X509_CRL_bio($bp);
 # $bp - value corresponding to openssl's BIO structure
 #
 # returns: value corresponding to openssl's X509_CRL structure (0 on failure)
    </pre>
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>
 my $bio = Net::SSLeay::BIO_new_file($filename, 'rb');
 my $x509_crl = Net::SSLeay::d2i_X509_CRL_bio($bio);
 Net::SSLeay::BIO_free($bio);
    </pre>
  </li>
  <li>d2i_X509_REQ_bio
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Loads DER formatted X509_REQ object via given BIO
      structure.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::d2i_X509_REQ_bio($bp);
 # $bp - value corresponding to openssl's BIO structure
 #
 # returns: value corresponding to openssl's X509_REQ structure (0 on failure)
    </pre>
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>
 my $bio = Net::SSLeay::BIO_new_file($filename, 'rb');
 my $x509_req = Net::SSLeay::d2i_X509_REQ_bio($bio);
 Net::SSLeay::BIO_free($bio);
    </pre>
  </li>
</ul>
<p class="Pp"><i>Low level API: PKCS12 related functions</i></p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>P_PKCS12_load_file
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Loads X509 certificate + private key + certificates of CA
        chain (if present in PKCS12 file).</p>
    <p class="Pp"></p>
    <pre>
 my ($privkey, $cert, @cachain) = Net::SSLeay::P_PKCS12_load_file($filename, $load_chain, $password);
 # $filename - name of PKCS12 file
 # $load_chain - [optional] whether load (1) or not(0) CA chain (default: 0)
 # $password - [optional] password for private key
 #
 # returns: triplet ($privkey, $cert, @cachain)
 #          $privkey - value corresponding to openssl's EVP_PKEY structure
 #          $cert - value corresponding to openssl's X509 structure
 #          @cachain - array of values corresponding to openssl's X509 structure (empty if no CA chain in PKCS12)
    </pre>
    <p class="Pp"><b>IMPORTANT NOTE:</b> after you do the job you need to call
        <b>X509_free()</b> on <span class="Li">$privkey</span> + all members of
        <span class="Li">@cachain</span> and <b>EVP_PKEY_free()</b> on
        <span class="Li">$privkey</span>.</p>
    <p class="Pp">Examples:</p>
    <p class="Pp"></p>
    <pre>
 my ($privkey, $cert) = Net::SSLeay::P_PKCS12_load_file($filename);
 #or
 my ($privkey, $cert) = Net::SSLeay::P_PKCS12_load_file($filename, 0, $password);
 #or
 my ($privkey, $cert, @cachain) = Net::SSLeay::P_PKCS12_load_file($filename, 1);
 #or
 my ($privkey, $cert, @cachain) = Net::SSLeay::P_PKCS12_load_file($filename, 1, $password);

 #BEWARE: THIS IS WRONG - MEMORY LEAKS! (you cannot free @cachain items)
 my ($privkey, $cert) = Net::SSLeay::P_PKCS12_load_file($filename, 1, $password);
    </pre>
    <p class="Pp"><b>NOTE</b> With some combinations of Windows, perl, compiler
        and compiler options, you may see a runtime error &quot;no
        OPENSSL_Applink&quot;, when calling Net::SSLeay::P_PKCS12_load_file. See
        README.Win32 for more details.</p>
  </dd>
</dl>
<p class="Pp"><i>Low level API: SESSION_* related functions</i></p>
<ul class="Bl-bullet">
  <li>d2i_SSL_SESSION
    <p class="Pp"><b>COMPATIBILITY:</b> does not work in Net-SSLeay-1.85 and
        before</p>
    <p class="Pp">Transforms the binary ASN1 representation string of an SSL/TLS
        session into an SSL_SESSION object.</p>
    <p class="Pp"></p>
    <pre>
 my $ses = Net::SSLeay::d2i_SSL_SESSION($data);
 # $data - the session as ASN1 representation string
 #
 # returns: $ses - the new SSL_SESSION
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/ssl/i2d_SSL_SESSION.html&gt;</p>
  </li>
  <li>i2d_SSL_SESSION
    <p class="Pp"><b>COMPATIBILITY:</b> does not work in Net-SSLeay-1.85 and
        before</p>
    <p class="Pp">Transforms the SSL_SESSION object in into the ASN1
        representation and returns it as string.</p>
    <p class="Pp"></p>
    <pre>
 my $data = Net::SSLeay::i2d_SSL_SESSION($ses);
 # $ses - value corresponding to openssl's SSL_SESSION structure
 #
 # returns: $data - session as string
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/ssl/d2i_SSL_SESSION.html&gt;</p>
  </li>
  <li>SESSION_new
    <p class="Pp">Creates a new SSL_SESSION structure.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::SESSION_new();
 #
 # returns: value corresponding to openssl's SSL_SESSION structure (0 on failure)
    </pre>
  </li>
  <li>SESSION_free
    <p class="Pp">Free an allocated SSL_SESSION structure.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::SESSION_free($ses);
 # $ses - value corresponding to openssl's SSL_SESSION structure
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_SESSION_free.html&gt;</p>
  </li>
  <li>SESSION_up_ref
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and
        before; requires at least OpenSSL 1.1.0 or LibreSSL 2.7.0</p>
    <p class="Pp">Increases the reference counter on a SSL_SESSION
      structure.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::SESSION_up_ref($ses);
 # $ses - value corresponding to openssl's SSL_SESSION structure
 #
 # returns: 1 on success else 0
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/ssl/SSL_SESSION_up_ref.html&gt;</p>
  </li>
  <li>SESSION_dup
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and
        before; requires at least OpenSSL 1.1.1, not in LibreSSL</p>
    <p class="Pp">Duplicates a SSL_SESSION structure.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::SESSION_dup($ses);
 # $ses - value corresponding to openssl's SSL_SESSION structure
 #
 # returns: the duplicated session
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/ssl/SSL_SESSION_dup.html&gt;</p>
  </li>
  <li>SESSION_is_resumable
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and
        before; requires at least OpenSSL 1.1.1, not in LibreSSL</p>
    <p class="Pp">Determine whether an SSL_SESSION object can be used for
        resumption.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::SESSION_is_resumable($ses);
 # $ses - value corresponding to openssl's SSL_SESSION structure
 #
 # returns: (integer) 1 if it can or 0 if not
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_is_resumable.html&gt;</p>
  </li>
  <li>SESSION_cmp
    <p class="Pp">Compare two SSL_SESSION structures.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::SESSION_cmp($sesa, $sesb);
 # $sesa - value corresponding to openssl's SSL_SESSION structure
 # $sesb - value corresponding to openssl's SSL_SESSION structure
 #
 # returns: 0 if the two structures are the same
    </pre>
    <p class="Pp"><b>NOTE:</b> Not available in openssl 1.0 or later</p>
  </li>
  <li>SESSION_get_app_data
    <p class="Pp">Can be used to get application defined value/data.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::SESSION_get_app_data($ses);
 # $ses - value corresponding to openssl's SSL_SESSION structure
 #
 # returns: string/buffer/pointer ???
    </pre>
  </li>
  <li>SESSION_set_app_data
    <p class="Pp">Can be used to set some application defined value/data.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::SESSION_set_app_data($s, $a);
 # $s - value corresponding to openssl's SSL_SESSION structure
 # $a - (string/buffer/pointer ???) data
 #
 # returns: ???
    </pre>
  </li>
  <li>SESSION_get_ex_data
    <p class="Pp">Is used to retrieve the information for
        <span class="Li">$idx</span> from session
      <span class="Li">$ses</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::SESSION_get_ex_data($ses, $idx);
 # $ses - value corresponding to openssl's SSL_SESSION structure
 # $idx - (integer) index for application specific data
 #
 # returns: pointer to ???
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_SESSION_get_ex_new_index.html&gt;</p>
  </li>
  <li>SESSION_set_ex_data
    <p class="Pp">Is used to store application data at arg for idx into the
        session object.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::SESSION_set_ex_data($ss, $idx, $data);
 # $ss - value corresponding to openssl's SSL_SESSION structure
 # $idx - (integer) ???
 # $data - (pointer) ???
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_SESSION_get_ex_new_index.html&gt;</p>
  </li>
  <li>SESSION_get_ex_new_index
    <p class="Pp">Is used to register a new index for application specific
      data.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::SESSION_get_ex_new_index($argl, $argp, $new_func, $dup_func, $free_func);
 # $argl - (long) ???
 # $argp - (pointer) ???
 # $new_func - function pointer ??? (CRYPTO_EX_new *)
 # $dup_func - function pointer ??? (CRYPTO_EX_dup *)
 # $free_func - function pointer ??? (CRYPTO_EX_free *)
 #
 # returns: (integer) ???
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_SESSION_get_ex_new_index.html&gt;</p>
  </li>
  <li>SESSION_get_master_key
    <p class="Pp"><b>NOTE:</b> Does not exactly correspond to any low level API
        function</p>
    <p class="Pp">Returns 'master_key' value from SSL_SESSION structure
        <span class="Li">$s</span></p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::SESSION_get_master_key($s);
 # $s - value corresponding to openssl's SSL_SESSION structure
 #
 # returns: master key (binary data)
    </pre>
  </li>
  <li>SESSION_set_master_key
    <p class="Pp">Sets 'master_key' value for SSL_SESSION structure
        <span class="Li">$s</span></p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::SESSION_set_master_key($s, $key);
 # $s - value corresponding to openssl's SSL_SESSION structure
 # $key - master key (binary data)
 #
 # returns: no return value
    </pre>
    <p class="Pp">Not available with OpenSSL 1.1 and later. Code that previously
        used
      <br/>
       SESSION_set_master_key must now set <span class="Li">$secret</span> in
        the session_secret
      <br/>
       callback set with SSL_set_session_secret_cb.</p>
  </li>
  <li>SESSION_get_time
    <p class="Pp">Returns the time at which the session s was established. The
        time is given in seconds since 1.1.1970.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::SESSION_get_time($s);
 # $s - value corresponding to openssl's SSL_SESSION structure
 #
 # returns: timestamp (seconds since 1.1.1970)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_SESSION_get_time.html&gt;</p>
  </li>
  <li>get_time
    <p class="Pp">Technically the same functionality as
        &quot;SESSION_get_time&quot;.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_time($s);
    </pre>
  </li>
  <li>SESSION_get_timeout
    <p class="Pp">Returns the timeout value set for session
        <span class="Li">$s</span> in seconds.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::SESSION_get_timeout($s);
 # $s - value corresponding to openssl's SSL_SESSION structure
 #
 # returns: timeout (in seconds)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_SESSION_get_time.html&gt;</p>
  </li>
  <li>get_timeout
    <p class="Pp">Technically the same functionality as
        &quot;SESSION_get_timeout&quot;.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_timeout($s);
    </pre>
  </li>
  <li>SESSION_print
    <p class="Pp"><b>NOTE:</b> Does not exactly correspond to any low level API
        function</p>
    <p class="Pp">Prints session details (e.g. protocol version, cipher,
        session-id ...) to BIO.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::SESSION_print($fp, $ses);
 # $fp - value corresponding to openssl's BIO structure
 # $ses - value corresponding to openssl's SSL_SESSION structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">You have to use necessary BIO functions like this:</p>
    <p class="Pp"></p>
    <pre>
 # let us have $ssl corresponding to openssl's SSL structure
 my $ses = Net::SSLeay::get_session($ssl);
 my $bio = Net::SSLeay::BIO_new(&amp;Net::SSLeay::BIO_s_mem);
 Net::SSLeay::SESSION_print($bio, $ses);
 print Net::SSLeay::BIO_read($bio);
    </pre>
  </li>
  <li>SESSION_print_fp
    <p class="Pp">Prints session details (e.g. protocol version, cipher,
        session-id ...) to file handle.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::SESSION_print_fp($fp, $ses);
 # $fp - perl file handle
 # $ses - value corresponding to openssl's SSL_SESSION structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>
 # let us have $ssl corresponding to openssl's SSL structure
 my $ses = Net::SSLeay::get_session($ssl);
 open my $fh, &quot;&gt;&quot;, &quot;output.txt&quot;;
 Net::SSLeay::SESSION_print_fp($fh,$ses);
    </pre>
  </li>
  <li>SESSION_set_time
    <p class="Pp">Replaces the creation time of the session s with the chosen
        value <span class="Li">$t</span> (seconds since 1.1.1970).</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::SESSION_set_time($ses, $t);
 # $ses - value corresponding to openssl's SSL_SESSION structure
 # $t - time value
 #
 # returns: 1 on success
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_SESSION_get_time.html&gt;</p>
  </li>
  <li>set_time
    <p class="Pp">Technically the same functionality as
        &quot;SESSION_set_time&quot;.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::set_time($ses, $t);
    </pre>
  </li>
  <li>SESSION_set_timeout
    <p class="Pp">Sets the timeout value for session s in seconds to
        <span class="Li">$t</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::SESSION_set_timeout($s, $t);
 # $s - value corresponding to openssl's SSL_SESSION structure
 # $t - timeout (in seconds)
 #
 # returns: 1 on success
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_SESSION_get_time.html&gt;</p>
  </li>
  <li>set_timeout
    <p class="Pp">Technically the same functionality as
        &quot;SESSION_set_timeout&quot;.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::set_timeout($ses, $t);
    </pre>
  </li>
</ul>
<p class="Pp"><i>Low level API: SSL_CTX_* related functions</i></p>
<p class="Pp"><b>NOTE:</b> Please note that the function described in this
    chapter have &quot;SSL_&quot; part stripped from their original openssl
    names.</p>
<ul class="Bl-bullet">
  <li>CTX_add_client_CA
    <p class="Pp">Adds the CA name extracted from
        <span class="Li">$cacert</span> to the list of CAs sent to the client
        when requesting a client certificate for
      <span class="Li">$ctx</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_add_client_CA($ctx, $cacert);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $cacert - value corresponding to openssl's X509 structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_client_CA_list.html&gt;</p>
  </li>
  <li>CTX_add_extra_chain_cert
    <p class="Pp">Adds the certificate <span class="Li">$x509</span> to the
        certificate chain presented together with the certificate. Several
        certificates can be added one after the other.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_add_extra_chain_cert($ctx, $x509);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $x509 - value corresponding to openssl's X509 structure
 #
 # returns: 1 on success, check out the error stack to find out the reason for failure otherwise
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_add_extra_chain_cert.html&gt;</p>
  </li>
  <li>CTX_add_session
    <p class="Pp">Adds the session <span class="Li">$ses</span> to the context
        <span class="Li">$ctx</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_add_session($ctx, $ses);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $ses - value corresponding to openssl's SSL_SESSION structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_add_session.html&gt;</p>
  </li>
  <li>CTX_callback_ctrl
    <p class="Pp">??? (more info needed)</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_callback_ctrl($ctx, $cmd, $fp);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $cmd - (integer) command id
 # $fp - (function pointer) ???
 #
 # returns: ???
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_ctrl.html&gt;</p>
  </li>
  <li>CTX_check_private_key
    <p class="Pp">Checks the consistency of a private key with the corresponding
        certificate loaded into <span class="Li">$ctx</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_check_private_key($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: 1 on success, otherwise check out the error stack to find out the reason
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p>
  </li>
  <li>CTX_ctrl
    <p class="Pp">Internal handling function for SSL_CTX objects.</p>
    <p class="Pp"><b>BEWARE:</b> openssl doc says: This function should never be
        called directly!</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_ctrl($ctx, $cmd, $larg, $parg);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $cmd - (integer) command id
 # $larg - (integer) long ???
 # $parg - (string/pointer) ???
 #
 # returns: (long) result of given command ???

 #valid $cmd values
  1 - SSL_CTRL_NEED_TMP_RSA
  2 - SSL_CTRL_SET_TMP_RSA
  3 - SSL_CTRL_SET_TMP_DH
  4 - SSL_CTRL_SET_TMP_ECDH
  5 - SSL_CTRL_SET_TMP_RSA_CB
  6 - SSL_CTRL_SET_TMP_DH_CB
  7 - SSL_CTRL_SET_TMP_ECDH_CB
  8 - SSL_CTRL_GET_SESSION_REUSED
  9 - SSL_CTRL_GET_CLIENT_CERT_REQUEST
 10 - SSL_CTRL_GET_NUM_RENEGOTIATIONS
 11 - SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS
 12 - SSL_CTRL_GET_TOTAL_RENEGOTIATIONS
 13 - SSL_CTRL_GET_FLAGS
 14 - SSL_CTRL_EXTRA_CHAIN_CERT
 15 - SSL_CTRL_SET_MSG_CALLBACK
 16 - SSL_CTRL_SET_MSG_CALLBACK_ARG
 17 - SSL_CTRL_SET_MTU
 20 - SSL_CTRL_SESS_NUMBER
 21 - SSL_CTRL_SESS_CONNECT
 22 - SSL_CTRL_SESS_CONNECT_GOOD
 23 - SSL_CTRL_SESS_CONNECT_RENEGOTIATE
 24 - SSL_CTRL_SESS_ACCEPT
 25 - SSL_CTRL_SESS_ACCEPT_GOOD
 26 - SSL_CTRL_SESS_ACCEPT_RENEGOTIATE
 27 - SSL_CTRL_SESS_HIT
 28 - SSL_CTRL_SESS_CB_HIT
 29 - SSL_CTRL_SESS_MISSES
 30 - SSL_CTRL_SESS_TIMEOUTS
 31 - SSL_CTRL_SESS_CACHE_FULL
 32 - SSL_CTRL_OPTIONS
 33 - SSL_CTRL_MODE
 40 - SSL_CTRL_GET_READ_AHEAD
 41 - SSL_CTRL_SET_READ_AHEAD
 42 - SSL_CTRL_SET_SESS_CACHE_SIZE
 43 - SSL_CTRL_GET_SESS_CACHE_SIZE
 44 - SSL_CTRL_SET_SESS_CACHE_MODE
 45 - SSL_CTRL_GET_SESS_CACHE_MODE
 50 - SSL_CTRL_GET_MAX_CERT_LIST
 51 - SSL_CTRL_SET_MAX_CERT_LIST
 52 - SSL_CTRL_SET_MAX_SEND_FRAGMENT
 53 - SSL_CTRL_SET_TLSEXT_SERVERNAME_CB
 54 - SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG
 55 - SSL_CTRL_SET_TLSEXT_HOSTNAME
 56 - SSL_CTRL_SET_TLSEXT_DEBUG_CB
 57 - SSL_CTRL_SET_TLSEXT_DEBUG_ARG
 58 - SSL_CTRL_GET_TLSEXT_TICKET_KEYS
 59 - SSL_CTRL_SET_TLSEXT_TICKET_KEYS
 60 - SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT
 61 - SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT_CB
 62 - SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT_CB_ARG
 63 - SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB
 64 - SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB_ARG
 65 - SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE
 66 - SSL_CTRL_GET_TLSEXT_STATUS_REQ_EXTS
 67 - SSL_CTRL_SET_TLSEXT_STATUS_REQ_EXTS
 68 - SSL_CTRL_GET_TLSEXT_STATUS_REQ_IDS
 69 - SSL_CTRL_SET_TLSEXT_STATUS_REQ_IDS
 70 - SSL_CTRL_GET_TLSEXT_STATUS_REQ_OCSP_RESP
 71 - SSL_CTRL_SET_TLSEXT_STATUS_REQ_OCSP_RESP
 72 - SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB
 73 - DTLS_CTRL_GET_TIMEOUT
 74 - DTLS_CTRL_HANDLE_TIMEOUT
 75 - DTLS_CTRL_LISTEN
 76 - SSL_CTRL_GET_RI_SUPPORT
 77 - SSL_CTRL_CLEAR_OPTIONS
 78 - SSL_CTRL_CLEAR_MODE

 82 - SSL_CTRL_GET_EXTRA_CHAIN_CERTS
 83 - SSL_CTRL_CLEAR_EXTRA_CHAIN_CERTS

 88 - SSL_CTRL_CHAIN
 89 - SSL_CTRL_CHAIN_CERT

 90 - SSL_CTRL_GET_CURVES
 91 - SSL_CTRL_SET_CURVES
 92 - SSL_CTRL_SET_CURVES_LIST
 93 - SSL_CTRL_GET_SHARED_CURVE 
 94 - SSL_CTRL_SET_ECDH_AUTO
 97 - SSL_CTRL_SET_SIGALGS
 98 - SSL_CTRL_SET_SIGALGS_LIST
 99 - SSL_CTRL_CERT_FLAGS
 100 - SSL_CTRL_CLEAR_CERT_FLAGS
 101 - SSL_CTRL_SET_CLIENT_SIGALGS
 102 - SSL_CTRL_SET_CLIENT_SIGALGS_LIST
 103 - SSL_CTRL_GET_CLIENT_CERT_TYPES
 104 - SSL_CTRL_SET_CLIENT_CERT_TYPES
 105 - SSL_CTRL_BUILD_CERT_CHAIN
 106 - SSL_CTRL_SET_VERIFY_CERT_STORE
 107 - SSL_CTRL_SET_CHAIN_CERT_STORE
 108 - SSL_CTRL_GET_PEER_SIGNATURE_NID
 109 - SSL_CTRL_GET_SERVER_TMP_KEY
 110 - SSL_CTRL_GET_RAW_CIPHERLIST
 111 - SSL_CTRL_GET_EC_POINT_FORMATS
 112 - SSL_CTRL_GET_TLSA_RECORD
 113 - SSL_CTRL_SET_TLSA_RECORD
 114 - SSL_CTRL_PULL_TLSA_RECORD
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_ctrl.html&gt;</p>
  </li>
  <li>CTX_flush_sessions
    <p class="Pp">Causes a run through the session cache of
        <span class="Li">$ctx</span> to remove sessions expired at time
        <span class="Li">$tm</span>.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::CTX_flush_sessions($ctx, $tm);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $tm - specifies the time which should be used for the expiration test (seconds since 1.1.1970)
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_flush_sessions.html&gt;</p>
  </li>
  <li>CTX_free
    <p class="Pp">Free an allocated SSL_CTX object.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::CTX_free($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_free.html&gt;</p>
  </li>
  <li>CTX_get_app_data
    <p class="Pp">Can be used to get application defined value/data.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_get_app_data($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: string/buffer/pointer ???
    </pre>
  </li>
  <li>CTX_set_app_data
    <p class="Pp">Can be used to set some application defined value/data.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_set_app_data($ctx, $arg);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $arg - (string/buffer/pointer ???) data
 #
 # returns: ???
    </pre>
  </li>
  <li>CTX_get0_param
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.82 and
        before; requires at least OpenSSL 1.0.2</p>
    <p class="Pp">Returns the current verification parameters.</p>
    <p class="Pp"></p>
    <pre>
 my $vpm = Net::SSLeay::CTX_get0_param($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: value corresponding to openssl's X509_VERIFY_PARAM structure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/ssl/SSL_CTX_get0_param.html&gt;</p>
  </li>
  <li>CTX_get_cert_store
    <p class="Pp">Returns the current certificate verification storage.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_get_cert_store($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: value corresponding to openssl's X509_STORE structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_cert_store.html&gt;</p>
  </li>
  <li>CTX_get_client_CA_list
    <p class="Pp">Returns the list of client CAs explicitly set for
        <span class="Li">$ctx</span> using
      &quot;CTX_set_client_CA_list&quot;.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_get_client_CA_list($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: value corresponding to openssl's X509_NAME_STACK structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_get_client_CA_list.html&gt;</p>
  </li>
  <li>CTX_get_ex_data
    <p class="Pp">Is used to retrieve the information for index
        <span class="Li">$idx</span> from <span class="Li">$ctx</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_get_ex_data($ssl, $idx);
 # $ssl - value corresponding to openssl's SSL_CTX structure
 # $idx - (integer) index for application specific data
 #
 # returns: pointer to ???
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_get_ex_new_index.html&gt;</p>
  </li>
  <li>CTX_get_ex_new_index
    <p class="Pp">Is used to register a new index for application specific
      data.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_get_ex_new_index($argl, $argp, $new_func, $dup_func, $free_func);
 # $argl - (long) ???
 # $argp - (pointer) ???
 # $new_func - function pointer ??? (CRYPTO_EX_new *)
 # $dup_func - function pointer ??? (CRYPTO_EX_dup *)
 # $free_func - function pointer ??? (CRYPTO_EX_free *)
 #
 # returns: (integer) ???
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_get_ex_new_index.html&gt;</p>
  </li>
  <li>CTX_get_mode
    <p class="Pp">Returns the mode set for ctx.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_get_mode($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: mode (bitmask)

 #to decode the return value (bitmask) use:
 0x00000001 corresponds to SSL_MODE_ENABLE_PARTIAL_WRITE
 0x00000002 corresponds to SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER
 0x00000004 corresponds to SSL_MODE_AUTO_RETRY
 0x00000008 corresponds to SSL_MODE_NO_AUTO_CHAIN
 0x00000010 corresponds to SSL_MODE_RELEASE_BUFFERS
 (note: some of the bits might not be supported by older openssl versions)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_mode.html&gt;</p>
  </li>
  <li>CTX_set_mode
    <p class="Pp">Adds the mode set via bitmask in <span class="Li">$mode</span>
        to <span class="Li">$ctx</span>. Options already set before are not
        cleared.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_set_mode($ctx, $mode);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $mode - mode bitmask
 #
 # returns: the new mode bitmask after adding $mode
    </pre>
    <p class="Pp">For bitmask details see &quot;CTX_get_mode&quot; (above).</p>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_mode.html&gt;</p>
  </li>
  <li>CTX_get_options
    <p class="Pp">Returns the options (bitmask) set for
        <span class="Li">$ctx</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_get_options($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: options (bitmask)
    </pre>
    <p class="Pp"><b>BEWARE:</b> The available constants and their values in
        bitmask depend on the TLS library. For example, SSL_OP_NO_TLSv1_3 became
        available much later than SSL_OP_NO_COMPRESS which is already deprecated
        by some libraries. Also, some previously used option values have been
        recycled and are now used for newer options. See the list of constants
        in this document for options Net::SSLeay currently supports.</p>
    <p class="Pp">You are strongly encouraged to <b>check your TLS library</b>
        if you need to use numeric values directly. The following is a sample of
        historic values. It may not be correct anymore.</p>
    <p class="Pp"></p>
    <pre>
 #to decode the return value (bitmask) use:
 0x00000004 corresponds to SSL_OP_LEGACY_SERVER_CONNECT
 0x00000800 corresponds to SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS
 0x00004000 corresponds to SSL_OP_NO_TICKET
 0x00010000 corresponds to SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION
 0x00400000 corresponds to SSL_OP_CIPHER_SERVER_PREFERENCE
 0x04000000 corresponds to SSL_OP_NO_TLSv1
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html&gt;</p>
  </li>
  <li>CTX_set_options
    <p class="Pp">Adds the options set via bitmask in
        <span class="Li">$options</span> to ctx. Options already set before are
        not cleared.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::CTX_set_options($ctx, $options);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $options - options bitmask
 #
 # returns: the new options bitmask after adding $options
    </pre>
    <p class="Pp">For bitmask details see &quot;CTX_get_options&quot;
      (above).</p>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html&gt;</p>
  </li>
  <li>CTX_get_quiet_shutdown
    <p class="Pp">Returns the 'quiet shutdown' setting of
        <span class="Li">$ctx</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_get_quiet_shutdown($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: (integer) the current setting
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_quiet_shutdown.html&gt;</p>
  </li>
  <li>CTX_get_read_ahead
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_get_read_ahead($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: (integer) read_ahead value
    </pre>
  </li>
  <li>CTX_get_session_cache_mode
    <p class="Pp">Returns the currently used cache mode (bitmask).</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_get_session_cache_mode($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: mode (bitmask)
    </pre>
    <p class="Pp"><b>BEWARE:</b> SESS_CACHE_OFF and other constants are not
        available in Net-SSLeay-1.82 and before. If the constants are not
        available, the following values have historically been correct. You are
        strongly encouraged to <b>check your TLS library</b> for the current
        values.</p>
    <p class="Pp"></p>
    <pre>
 #to decode the return value (bitmask) use:
 0x0000 corresponds to SSL_SESS_CACHE_OFF
 0x0001 corresponds to SSL_SESS_CACHE_CLIENT
 0x0002 corresponds to SSL_SESS_CACHE_SERVER
 0x0080 corresponds to SSL_SESS_CACHE_NO_AUTO_CLEAR
 0x0100 corresponds to SSL_SESS_CACHE_NO_INTERNAL_LOOKUP
 0x0200 corresponds to SSL_SESS_CACHE_NO_INTERNAL_STORE
 (note: some of the bits might not be supported by older openssl versions)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_session_cache_mode.html&gt;</p>
  </li>
  <li>CTX_set_session_cache_mode
    <p class="Pp">Enables/disables session caching by setting the operational
        mode for <span class="Li">$ctx</span> to
      <span class="Li">$mode</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_set_session_cache_mode($ctx, $mode);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $mode - mode (bitmask)
 #
 # returns: previously set cache mode
    </pre>
    <p class="Pp">For bitmask details see &quot;CTX_get_session_cache_mode&quot;
        (above).</p>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_session_cache_mode.html&gt;</p>
  </li>
  <li>CTX_get_timeout
    <p class="Pp">Returns the currently set timeout value for
        <span class="Li">$ctx</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_get_timeout($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: timeout in seconds
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_timeout.html&gt;</p>
  </li>
  <li>CTX_get_verify_depth
    <p class="Pp">Returns the verification depth limit currently set in
        <span class="Li">$ctx</span>. If no limit has been explicitly set, -1 is
        returned and the default value will be used.&quot;,</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_get_verify_depth($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: depth limit currently set in $ctx, -1 if no limit has been explicitly set
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_get_verify_mode.html&gt;</p>
  </li>
  <li>CTX_get_verify_mode
    <p class="Pp">Returns the verification mode (bitmask) currently set in
        <span class="Li">$ctx</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_get_verify_mode($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: mode (bitmask)
    </pre>
    <p class="Pp">For bitmask details see &quot;CTX_set_verify&quot;.</p>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_verify_mode.html&gt;</p>
  </li>
  <li>CTX_set_verify
    <p class="Pp">Sets the verification flags for <span class="Li">$ctx</span>
        to be <span class="Li">$mode</span> and specifies the verify_callback
        function to be used.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::CTX_set_verify($ctx, $mode, $callback);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $mode - mode (bitmask), see OpenSSL manual
 # $callback - [optional] reference to perl callback function
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_verify.html&gt;</p>
  </li>
  <li>CTX_set_post_handshake_auth
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and
        before; requires at least OpenSSL 1.1.1, not in LibreSSL</p>
    <p class="Pp">Enable the Post-Handshake Authentication extension to be added
        to the ClientHello such that post-handshake authentication can be
        requested by the server.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::CTX_set_posthandshake_auth($ctx, $val);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $val - 0 then the extension is not sent, otherwise it is
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_post_handshake_auth
        &lt;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_post_handshake_auth.html&gt;</p>
  </li>
  <li>CTX_load_verify_locations
    <p class="Pp">Specifies the locations for <span class="Li">$ctx</span>, at
        which CA certificates for verification purposes are located. The
        certificates available via <span class="Li">$CAfile</span> and
        <span class="Li">$CApath</span> are trusted.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_load_verify_locations($ctx, $CAfile, $CApath);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $CAfile - (string) file of CA certificates in PEM format, the file can contain several CA certificates (or '')
 # $CApath - (string) directory containing CA certificates in PEM format (or '')
 #
 # returns: 1 on success, 0 on failure (check the error stack to find out the reason)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_load_verify_locations.html&gt;</p>
  </li>
  <li>CTX_need_tmp_RSA
    <p class="Pp">Return the result of
        <span class="Li">&quot;SSL_CTX_ctrl(ctx,SSL_CTRL_NEED_TMP_RSA,0,NULL)&quot;</span></p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_need_tmp_RSA($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: result of SSL_CTRL_NEED_TMP_RSA command
    </pre>
    <p class="Pp">Not available with OpenSSL 1.1 and later.</p>
  </li>
  <li>CTX_new
    <p class="Pp">The same as &quot;CTX_v23_new&quot;</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_new();
 #
 # returns: value corresponding to openssl's SSL_CTX structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_new.html&gt;</p>
    <p class="Pp">Not available with OpenSSL 1.1 and later.</p>
  </li>
  <li>CTX_v2_new
    <p class="Pp">Creates a new SSL_CTX object - based on <b>SSLv2_method()</b>
        - as framework to establish TLS/SSL enabled connections.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_v2_new();
 #
 # returns: value corresponding to openssl's SSL_CTX structure (0 on failure)
    </pre>
  </li>
  <li>CTX_v23_new
    <p class="Pp">Creates a new SSL_CTX object - based on <b>SSLv23_method()</b>
        - as framework to establish TLS/SSL enabled connections.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_v23_new();
 #
 # returns: value corresponding to openssl's SSL_CTX structure (0 on failure)
    </pre>
  </li>
  <li>CTX_v3_new
    <p class="Pp">Creates a new SSL_CTX object - based on <b>SSLv3_method()</b>
        - as framework to establish TLS/SSL enabled connections.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_v3_new();
 #
 # returns: value corresponding to openssl's SSL_CTX structure (0 on failure)
    </pre>
  </li>
  <li>CTX_tlsv1_new
    <p class="Pp">Creates a new SSL_CTX object - based on <b>TLSv1_method()</b>
        - as framework to establish TLS/SSL enabled connections.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_tlsv1_new();
 #
 # returns: value corresponding to openssl's SSL_CTX structure (0 on failure)
    </pre>
  </li>
  <li>CTX_tlsv1_1_new
    <p class="Pp">Creates a new SSL_CTX object - based on
        <b>TLSv1_1_method()</b> - as framework to establish TLS/SSL enabled
        connections. Only available where supported by the underlying
      openssl.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_tlsv1_1_new();
 #
 # returns: value corresponding to openssl's SSL_CTX structure (0 on failure)
    </pre>
  </li>
  <li>CTX_tlsv1_2_new
    <p class="Pp">Creates a new SSL_CTX object - based on
        <b>TLSv1_2_method()</b> - as framework to establish TLS/SSL enabled
        connections. Only available where supported by the underlying
      openssl.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_tlsv1_2_new();
 #
 # returns: value corresponding to openssl's SSL_CTX structure (0 on failure)
    </pre>
  </li>
  <li>CTX_new_with_method
    <p class="Pp">Creates a new SSL_CTX object based on
        <span class="Li">$meth</span> method</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_new_with_method($meth);
 # $meth - value corresponding to openssl's SSL_METHOD structure
 #
 # returns: value corresponding to openssl's SSL_CTX structure (0 on failure)

 #example
 my $ctx = Net::SSLeay::CTX_new_with_method(&amp;Net::SSLeay::TLSv1_method);
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_new.html&gt;</p>
  </li>
  <li>CTX_set_min_proto_version, CTX_set_max_proto_version,
      set_min_proto_version and set_max_proto_version,
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.82 and
        before; requires at least OpenSSL 1.1.0 or LibreSSL 2.6.0</p>
    <p class="Pp">Set the minimum and maximum supported protocol for
        <span class="Li">$ctx</span> or <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_set_min_proto_version($ctx, $version)
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $version - (integer) constat version value or 0 for automatic lowest or highest value
 #
 # returns: 1 on success, 0 on failure

 #example: allow only TLS 1.2 for a SSL_CTX
 my $rv_min = Net::SSLeay::CTX_set_min_proto_version($ctx, Net::SSLeay::TLS1_2_VERSION());
 my $rv_max = Net::SSLeay::CTX_set_max_proto_version($ctx, Net::SSLeay::TLS1_2_VERSION());

 #example: allow only TLS 1.1 for a SSL
 my $rv_min = Net::SSLeay::set_min_proto_version($ssl, Net::SSLeay::TLS1_1_VERSION());
 my $rv_max = Net::SSLeay::set_max_proto_version($ssl, Net::SSLeay::TLS1_1_VERSION());
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_min_proto_version.html&gt;</p>
  </li>
  <li>CTX_get_min_proto_version, CTX_get_max_proto_version,
      get_min_proto_version and get_max_proto_version,
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.82 and
        before; requires at least OpenSSL 1.1.0g</p>
    <p class="Pp">Get the minimum and maximum supported protocol for
        <span class="Li">$ctx</span> or <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $version = Net::SSLeay::CTX_get_min_proto_version($ctx)
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: 0 automatic lowest or highest value, configured value otherwise
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_min_proto_version.html&gt;</p>
  </li>
  <li>CTX_remove_session
    <p class="Pp">Removes the session <span class="Li">$ses</span> from the
        context <span class="Li">$ctx</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_remove_session($ctx, $ses);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $ses - value corresponding to openssl's SSL_SESSION structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_add_session.html&gt;</p>
  </li>
  <li>CTX_sess_accept
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_sess_accept($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: number of started SSL/TLS handshakes in server mode
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html&gt;</p>
  </li>
  <li>CTX_sess_accept_good
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_sess_accept_good($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: number of successfully established SSL/TLS sessions in server mode
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html&gt;</p>
  </li>
  <li>CTX_sess_accept_renegotiate
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_sess_accept_renegotiate($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: number of start renegotiations in server mode
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html&gt;</p>
  </li>
  <li>CTX_sess_cache_full
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_sess_cache_full($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: number of sessions that were removed because the maximum session cache size was exceeded
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html&gt;</p>
  </li>
  <li>CTX_sess_cb_hits
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_sess_cb_hits($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: number of successfully retrieved sessions from the external session cache in server mode
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html&gt;</p>
  </li>
  <li>CTX_sess_connect
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_sess_connect($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: number of started SSL/TLS handshakes in client mode
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html&gt;</p>
  </li>
  <li>CTX_sess_connect_good
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_sess_connect_good($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: number of successfully established SSL/TLS sessions in client mode
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html&gt;</p>
  </li>
  <li>CTX_sess_connect_renegotiate
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_sess_connect_renegotiate($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: number of start renegotiations in client mode
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html&gt;</p>
  </li>
  <li>CTX_sess_get_cache_size
    <p class="Pp">Returns the currently valid session cache size.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_sess_get_cache_size($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: current size
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_sess_set_cache_size.html&gt;</p>
  </li>
  <li>CTX_sess_hits
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_sess_hits($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: number of successfully reused sessions
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html&gt;</p>
  </li>
  <li>CTX_sess_misses
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_sess_misses($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: number of sessions proposed by clients that were not found in the internal session cache in server mode
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html&gt;</p>
  </li>
  <li>CTX_sess_number
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_sess_number($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: current number of sessions in the internal session cache
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html&gt;</p>
  </li>
  <li>CTX_sess_set_cache_size
    <p class="Pp">Sets the size of the internal session cache of context
        <span class="Li">$ctx</span> to <span class="Li">$size</span>.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::CTX_sess_set_cache_size($ctx, $size);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $size - cache size (0 = unlimited)
 #
 # returns: previously valid size
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_sess_set_cache_size.html&gt;</p>
  </li>
  <li>CTX_sess_timeouts
    <p class="Pp">Returns the number of sessions proposed by clients and either
        found in the internal or external session cache in server mode, but that
        were invalid due to timeout. These sessions are not included in the
        SSL_CTX_sess_hits count.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_sess_timeouts($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: number of sessions
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html&gt;</p>
  </li>
  <li>CTX_sess_set_new_cb
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and
        before</p>
    <p class="Pp">Sets the callback function, which is automatically called
        whenever a new session was negotiated.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::CTX_sess_set_new_cb($ctx, $func);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $func - perl reference to callback function
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_set_new_cb.html&gt;</p>
  </li>
  <li>CTX_sess_set_remove_cb
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and
        before</p>
    <p class="Pp">Sets the callback function, which is automatically called
        whenever a session is removed by the SSL engine.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::CTX_sess_set_remove_cb($ctx, $func);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $func - perl reference to callback function
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_set_remove_cb.html&gt;</p>
  </li>
  <li>CTX_sessions
    <p class="Pp">Returns a pointer to the lhash databases containing the
        internal session cache for ctx.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_sessions($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: value corresponding to openssl's LHASH structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_sessions.html&gt;</p>
  </li>
  <li>CTX_set1_param
    <p class="Pp">Applies X509 verification parameters
        <span class="Li">$vpm</span> on <span class="Li">$ctx</span></p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_set1_param($ctx, $vpm);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $vpm - value corresponding to openssl's X509_VERIFY_PARAM structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/ssl/SSL_CTX_get0_param.html&gt;</p>
  </li>
  <li>CTX_set_cert_store
    <p class="Pp">Sets/replaces the certificate verification storage of
        <span class="Li">$ctx</span> to/with <span class="Li">$store</span>.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::CTX_set_cert_store($ctx, $store);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $store - value corresponding to openssl's X509_STORE structure
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_cert_store.html&gt;</p>
  </li>
  <li>CTX_set_cert_verify_callback
    <p class="Pp">Sets the verification callback function for
        <span class="Li">$ctx</span>. SSL objects that are created from
        <span class="Li">$ctx</span> inherit the setting valid at the time when
        <span class="Li">&quot;Net::SSLeay::new($ctx)&quot;</span> is
      called.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::CTX_set_cert_verify_callback($ctx, $func, $data);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $func - perl reference to callback function
 # $data - [optional] data that will be passed to callback function when invoked
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_cert_verify_callback.html&gt;</p>
  </li>
  <li>CTX_set_cipher_list
    <p class="Pp">Sets the list of available ciphers for
        <span class="Li">$ctx</span> using the control string
        <span class="Li">$str</span>. The list of ciphers is inherited by all
        ssl objects created from <span class="Li">$ctx</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_set_cipher_list($s, $str);
 # $s - value corresponding to openssl's SSL_CTX structure
 # $str - (string) cipher list e.g. '3DES:+RSA'
 #
 # returns: 1 if any cipher could be selected and 0 on complete failure
    </pre>
    <p class="Pp">The format of <span class="Li">$str</span> is described in
        &lt;http://www.openssl.org/docs/apps/ciphers.html&gt;</p>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_cipher_list.html&gt;</p>
  </li>
  <li>CTX_set_ciphersuites
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and
        before; requires at least OpenSSL 1.1.1, not in LibreSSL</p>
    <p class="Pp">Configure the available TLSv1.3 ciphersuites.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_set_ciphersuites($ctx, $str);
 # $ctx  - value corresponding to openssl's SSL_CTX structure
 # $str  - colon (&quot;:&quot;) separated list of TLSv1.3 ciphersuite names in order of preference
 #
 # returns: (integer) 1 if the requested ciphersuite list was configured, and 0 otherwise
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_ciphersuites.html&gt;</p>
  </li>
  <li>CTX_set_client_CA_list
    <p class="Pp">Sets the list of CAs sent to the client when requesting a
        client certificate for <span class="Li">$ctx</span>.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::CTX_set_client_CA_list($ctx, $list);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $list - value corresponding to openssl's X509_NAME_STACK structure
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_client_CA_list.html&gt;</p>
  </li>
  <li>CTX_set_default_passwd_cb
    <p class="Pp">Sets the default password callback called when loading/storing
        a PEM certificate with encryption.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::CTX_set_default_passwd_cb($ctx, $func);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $func - perl reference to callback function
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_default_passwd_cb.html&gt;</p>
  </li>
  <li>CTX_set_default_passwd_cb_userdata
    <p class="Pp">Sets a pointer to userdata which will be provided to the
        password callback on invocation.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::CTX_set_default_passwd_cb_userdata($ctx, $userdata);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $userdata - data that will be passed to callback function when invoked
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_default_passwd_cb.html&gt;</p>
  </li>
  <li>CTX_set_default_verify_paths
    <p class="Pp">??? (more info needed)</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_set_default_verify_paths($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>CTX_set_ex_data
    <p class="Pp">Is used to store application data at
        <span class="Li">$data</span> for <span class="Li">$idx</span> into the
        <span class="Li">$ctx</span> object.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_set_ex_data($ssl, $idx, $data);
 # $ssl - value corresponding to openssl's SSL_CTX structure
 # $idx - (integer) ???
 # $data - (pointer) ???
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_get_ex_new_index.html&gt;</p>
  </li>
  <li>CTX_set_purpose
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_set_purpose($s, $purpose);
 # $s - value corresponding to openssl's SSL_CTX structure
 # $purpose - (integer) purpose identifier
 #
 # returns: 1 on success, 0 on failure

 #avainable purpose identifier
 1 - X509_PURPOSE_SSL_CLIENT
 2 - X509_PURPOSE_SSL_SERVER
 3 - X509_PURPOSE_NS_SSL_SERVER
 4 - X509_PURPOSE_SMIME_SIGN
 5 - X509_PURPOSE_SMIME_ENCRYPT
 6 - X509_PURPOSE_CRL_SIGN
 7 - X509_PURPOSE_ANY
 8 - X509_PURPOSE_OCSP_HELPER
 9 - X509_PURPOSE_TIMESTAMP_SIGN

 #or use corresponding constants
 $purpose = &amp;Net::SSLeay::X509_PURPOSE_SSL_CLIENT;
 ...
 $purpose = &amp;Net::SSLeay::X509_PURPOSE_TIMESTAMP_SIGN;
    </pre>
  </li>
  <li>CTX_set_quiet_shutdown
    <p class="Pp">Sets the 'quiet shutdown' flag for
        <span class="Li">$ctx</span> to be mode. SSL objects created from
        <span class="Li">$ctx</span> inherit the mode valid at the time
        <span class="Li">&quot;Net::SSLeay::new($ctx)&quot;</span> is
      called.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::CTX_set_quiet_shutdown($ctx, $mode);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $mode - 0 or 1
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_quiet_shutdown.html&gt;</p>
  </li>
  <li>CTX_set_read_ahead
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_set_read_ahead($ctx, $val);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $val - read_ahead value to be set
 #
 # returns: the original read_ahead value
    </pre>
  </li>
  <li>CTX_set_session_id_context
    <p class="Pp">Sets the context <span class="Li">$sid_ctx</span> of length
        <span class="Li">$sid_ctx_len</span> within which a session can be
        reused for the <span class="Li">$ctx</span> object.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_set_session_id_context($ctx, $sid_ctx, $sid_ctx_len);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $sid_ctx - data buffer
 # $sid_ctx_len - length of data in $sid_ctx
 #
 # returns: 1 on success, 0 on failure (the error is logged to the error stack)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_session_id_context.html&gt;</p>
  </li>
  <li>CTX_set_ssl_version
    <p class="Pp">Sets a new default TLS/SSL method for SSL objects newly
        created from this <span class="Li">$ctx</span>. SSL objects already
        created with <span class="Li">&quot;Net::SSLeay::new($ctx)&quot;</span>
        are not affected, except when
        <span class="Li">&quot;Net::SSLeay:clear($ssl)&quot;</span> is being
        called.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_set_ssl_version($ctx, $meth);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $meth - value corresponding to openssl's SSL_METHOD structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_ssl_version.html&gt;</p>
  </li>
  <li>CTX_set_timeout
    <p class="Pp">Sets the timeout for newly created sessions for
        <span class="Li">$ctx</span> to <span class="Li">$t</span>. The timeout
        value <span class="Li">$t</span> must be given in seconds.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_set_timeout($ctx, $t);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $t - timeout in seconds
 #
 # returns: previously set timeout value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_timeout.html&gt;</p>
  </li>
  <li>CTX_set_tmp_dh
    <p class="Pp">Sets DH parameters to be used to be
        <span class="Li">$dh</span>. The key is inherited by all ssl objects
        created from <span class="Li">$ctx</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_set_tmp_dh($ctx, $dh);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $dh - value corresponding to openssl's DH structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_tmp_dh_callback.html&gt;</p>
  </li>
  <li>CTX_set_tmp_dh_callback
    <p class="Pp">Sets the callback function for <span class="Li">$ctx</span> to
        be used when a DH parameters are required to
        <span class="Li">$tmp_dh_callback</span>.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::CTX_set_tmp_dh_callback($ctx, $tmp_dh_callback);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # tmp_dh_callback - (function pointer) ???
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_tmp_dh_callback.html&gt;</p>
  </li>
  <li>CTX_set_tmp_rsa
    <p class="Pp">Sets the temporary/ephemeral RSA key to be used to be
        <span class="Li">$rsa</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_set_tmp_rsa($ctx, $rsa);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $rsa - value corresponding to openssl's RSA structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_tmp_rsa_callback.html&gt;</p>
    <p class="Pp">Not available with OpenSSL 1.1 and later.</p>
  </li>
  <li>CTX_set_tmp_rsa_callback
    <p class="Pp">Sets the callback function for ctx to be used when a
        temporary/ephemeral RSA key is required to
        <span class="Li">$tmp_rsa_callback</span>.</p>
    <p class="Pp">??? (does this function really work?)</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::CTX_set_tmp_rsa_callback($ctx, $tmp_rsa_callback);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $tmp_rsa_callback - (function pointer) ???
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_tmp_rsa_callback.html&gt;</p>
    <p class="Pp">Not available with OpenSSL 1.1 and later.</p>
  </li>
  <li>CTX_set_trust
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_set_trust($s, $trust);
 # $s - value corresponding to openssl's SSL_CTX structure
 # $trust - (integer) trust identifier
 #
 # returns: the original value

 #available trust identifiers
 1 - X509_TRUST_COMPAT
 2 - X509_TRUST_SSL_CLIENT
 3 - X509_TRUST_SSL_SERVER
 4 - X509_TRUST_EMAIL
 5 - X509_TRUST_OBJECT_SIGN
 6 - X509_TRUST_OCSP_SIGN
 7 - X509_TRUST_OCSP_REQUEST
 8 - X509_TRUST_TSA

 #or use corresponding constants
 $trust = &amp;Net::SSLeay::X509_TRUST_COMPAT;
 ...
 $trust = &amp;Net::SSLeay::X509_TRUST_TSA;
    </pre>
  </li>
  <li>CTX_set_verify_depth
    <p class="Pp">Sets the maximum depth for the certificate chain verification
        that shall be allowed for ctx.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::CTX_set_verify_depth($ctx, $depth);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $depth - max. depth
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html&gt;</p>
  </li>
  <li>CTX_use_PKCS12_file
    <p class="Pp">Adds the certificate and private key from PKCS12 file
        <span class="Li">$p12filename</span> to
      <span class="Li">$ctx</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_use_PKCS12_file($ctx, $p12filename, $password);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $p12filename - (string) filename
 # $password - (string) password to decrypt private key
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>CTX_use_PrivateKey
    <p class="Pp">Adds the private key <span class="Li">$pkey</span> to
        <span class="Li">$ctx</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_use_PrivateKey($ctx, $pkey);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $pkey - value corresponding to openssl's EVP_PKEY structure
 #
 # returns: 1 on success, otherwise check out the error stack to find out the reason
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p>
  </li>
  <li>CTX_use_PrivateKey_file
    <p class="Pp">Adds the first private key found in
        <span class="Li">$file</span> to <span class="Li">$ctx</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_use_PrivateKey_file($ctx, $file, $type);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $file - (string) file name
 # $type - (integer) type - use constants &amp;Net::SSLeay::FILETYPE_PEM or &amp;Net::SSLeay::FILETYPE_ASN1
 #
 # returns: 1 on success, otherwise check out the error stack to find out the reason
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p>
  </li>
  <li>CTX_use_RSAPrivateKey
    <p class="Pp">Adds the RSA private key <span class="Li">$rsa</span> to
        <span class="Li">$ctx</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_use_RSAPrivateKey($ctx, $rsa);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $rsa - value corresponding to openssl's RSA structure
 #
 # returns: 1 on success, otherwise check out the error stack to find out the reason
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p>
  </li>
  <li>CTX_use_RSAPrivateKey_file
    <p class="Pp">Adds the first RSA private key found in
        <span class="Li">$file</span> to <span class="Li">$ctx</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_use_RSAPrivateKey_file($ctx, $file, $type);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $file - (string) file name
 # $type - (integer) type - use constants &amp;Net::SSLeay::FILETYPE_PEM or &amp;Net::SSLeay::FILETYPE_ASN1
 #
 # returns: 1 on success, otherwise check out the error stack to find out the reason
    </pre>
  </li>
  <li>CTX_use_certificate
    <p class="Pp">Loads the certificate <span class="Li">$x</span> into
        <span class="Li">$ctx</span></p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_use_certificate($ctx, $x);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $x - value corresponding to openssl's X509 structure
 #
 # returns: 1 on success, otherwise check out the error stack to find out the reason
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p>
  </li>
  <li>CTX_use_certificate_chain_file
    <p class="Pp">Loads a certificate chain from <span class="Li">$file</span>
        into <span class="Li">$ctx</span>. The certificates must be in PEM
        format and must be sorted starting with the subject's certificate
        (actual client or server certificate), followed by intermediate CA
        certificates if applicable, and ending at the highest level (root)
      CA.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_use_certificate_chain_file($ctx, $file);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $file - (string) file name
 #
 # returns: 1 on success, otherwise check out the error stack to find out the reason
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p>
  </li>
  <li>CTX_use_certificate_file
    <p class="Pp">Loads the first certificate stored in
        <span class="Li">$file</span> into <span class="Li">$ctx</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_use_certificate_file($ctx, $file, $type);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $file - (string) file name
 # $type - (integer) type - use constants &amp;Net::SSLeay::FILETYPE_PEM or &amp;Net::SSLeay::FILETYPE_ASN1
 #
 # returns: 1 on success, otherwise check out the error stack to find out the reason
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p>
  </li>
  <li>CTX_get_security_level
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and
        before; requires at least OpenSSL 1.1.0, not in LibreSSL</p>
    <p class="Pp">Returns the security level associated with
        <span class="Li">$ctx</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $level = Net::SSLeay::CTX_get_security_level($ctx);
 # $ctx   - value corresponding to openssl's SSL_CTX structure
 #
 # returns: (integer) current security level
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_security_level.html&gt;</p>
  </li>
  <li>CTX_set_security_level
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and
        before; requires at least OpenSSL 1.1.0, not in LibreSSL</p>
    <p class="Pp">Sets the security level associated with
        <span class="Li">$ctx</span> to <span class="Li">$level</span>.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::CTX_set_security_level($ctx, $level);
 # $ssl   - value corresponding to openssl's SSL_CTX structure
 # $level - new security level
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_security_level.html&gt;</p>
  </li>
  <li>CTX_set_num_tickets
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and
        before; requires at least OpenSSL 1.1.1, not in LibreSSL</p>
    <p class="Pp">Set number of TLSv1.3 session tickets that will be sent to a
        client.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CTX_set_num_tickets($ctx, $number_of_tickets);
 # $ctx  - value corresponding to openssl's SSL_CTX structure
 # $number_of_tickets - number of tickets to send
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Set to zero if you do not no want to support a session
        resumption.</p>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_num_tickets.html&gt;</p>
  </li>
  <li>CTX_get_num_tickets
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and
        before; requires at least OpenSSL 1.1.1, not in LibreSSL</p>
    <p class="Pp">Get number of TLSv1.3 session tickets that will be sent to a
        client.</p>
    <p class="Pp"></p>
    <pre>
 my $number_of_tickets = Net::SSLeay::CTX_get_num_tickets($ctx);
 # $ctx  - value corresponding to openssl's SSL_CTX structure
 #
 # returns: (integer) number of tickets to send
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_num_tickets.html&gt;</p>
  </li>
</ul>
<p class="Pp"><i>Low level API: SSL_* related functions</i></p>
<p class="Pp"><b>NOTE:</b> Please note that the function described in this
    chapter have &quot;SSL_&quot; part stripped from their original openssl
    names.</p>
<ul class="Bl-bullet">
  <li>new
    <p class="Pp">Creates a new SSL structure which is needed to hold the data
        for a TLS/SSL connection. The new structure inherits the settings of the
        underlying context <span class="Li">$ctx:</span> connection method
        (SSLv2/v3/TLSv1), options, verification settings, timeout settings.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::new($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: value corresponding to openssl's SSL structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_new.html&gt;</p>
  </li>
  <li>accept
    <p class="Pp">Waits for a TLS/SSL client to initiate the TLS/SSL handshake.
        The communication channel must already have been set and assigned to the
        ssl by setting an underlying BIO.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::accept($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: 1 = success, 0 = handshake not successful, &lt;0 = fatal error during handshake
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_accept.html&gt;</p>
  </li>
  <li>add_client_CA
    <p class="Pp">Adds the CA name extracted from cacert to the list of CAs sent
        to the client when requesting a client certificate for the chosen ssl,
        overriding the setting valid for ssl's SSL_CTX object.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::add_client_CA($ssl, $x);
 # $ssl - value corresponding to openssl's SSL structure
 # $x - value corresponding to openssl's X509 structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_client_CA_list.html&gt;</p>
  </li>
  <li>callback_ctrl
    <p class="Pp">??? (more info needed)</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::callback_ctrl($ssl, $cmd, $fp);
 # $ssl - value corresponding to openssl's SSL structure
 # $cmd - (integer) command id
 # $fp - (function pointer) ???
 #
 # returns: ???
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_ctrl.html&gt;</p>
  </li>
  <li>check_private_key
    <p class="Pp">Checks the consistency of a private key with the corresponding
        certificate loaded into <span class="Li">$ssl</span></p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::check_private_key($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: 1 on success, otherwise check out the error stack to find out the reason
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p>
  </li>
  <li>clear
    <p class="Pp">Reset SSL object to allow another connection.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::clear($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_clear.html&gt;</p>
  </li>
  <li>connect
    <p class="Pp">Initiate the TLS/SSL handshake with an TLS/SSL server.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::connect($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: 1 = success, 0 = handshake not successful, &lt;0 = fatal error during handshake
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_connect.html&gt;</p>
  </li>
  <li>copy_session_id
    <p class="Pp">Copies the session structure fro <span class="Li">$from</span>
        to <span class="Li">$to</span> (+ also the private key and certificate
        associated with <span class="Li">$from</span>).</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::copy_session_id($to, $from);
 # $to - value corresponding to openssl's SSL structure
 # $from - value corresponding to openssl's SSL structure
 #
 # returns: no return value
    </pre>
  </li>
  <li>ctrl
    <p class="Pp">Internal handling function for SSL objects.</p>
    <p class="Pp"><b>BEWARE:</b> openssl doc says: This function should never be
        called directly!</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::ctrl($ssl, $cmd, $larg, $parg);
 # $ssl - value corresponding to openssl's SSL structure
 # $cmd - (integer) command id
 # $larg - (integer) long ???
 # $parg - (string/pointer) ???
 #
 # returns: (long) result of given command ???
    </pre>
    <p class="Pp">For more details about valid <span class="Li">$cmd</span>
        values check &quot;CTX_ctrl&quot;.</p>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_ctrl.html&gt;</p>
  </li>
  <li>do_handshake
    <p class="Pp">Will wait for a SSL/TLS handshake to take place. If the
        connection is in client mode, the handshake will be started. The
        handshake routines may have to be explicitly set in advance using either
        SSL_set_connect_state or <b>SSL_set_accept_state</b>(3).</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::do_handshake($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: 1 = success, 0 = handshake not successful, &lt;0 = fatal error during handshake
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_do_handshake.html&gt;</p>
  </li>
  <li>dup
    <p class="Pp">Returns a duplicate of <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::dup($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: value corresponding to openssl's SSL structure (0 on failure)
    </pre>
  </li>
  <li>free
    <p class="Pp">Free an allocated SSL structure.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::free($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_free.html&gt;</p>
  </li>
  <li>get0_param
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.82 and
        before; requires at least OpenSSL 1.0.2</p>
    <p class="Pp">Returns the current verification parameters.</p>
    <p class="Pp"></p>
    <pre>
 my $vpm = Net::SSLeay::get0_param($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: value corresponding to openssl's X509_VERIFY_PARAM structure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/ssl/SSL_CTX_get0_param.html&gt;</p>
  </li>
  <li>get_SSL_CTX
    <p class="Pp">Returns a pointer to the SSL_CTX object, from which
        <span class="Li">$ssl</span> was created with Net::SSLeay::new.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_SSL_CTX($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: value corresponding to openssl's SSL_CTX structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_get_SSL_CTX.html&gt;</p>
  </li>
  <li>set_SSL_CTX
    <p class="Pp">Sets the SSL_CTX the corresponds to an SSL session.</p>
    <p class="Pp"></p>
    <pre>
 my $the_ssl_ctx = Net::SSLeay::set_SSL_CTX($ssl, $ssl_ctx);
 # $ssl - value corresponding to openssl's SSL structure
 # $ssl_ctx - Change the ssl object to the given ssl_ctx
 #
 # returns - the ssl_ctx
    </pre>
  </li>
  <li>get_app_data
    <p class="Pp">Can be used to get application defined value/data.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_app_data($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: string/buffer/pointer ???
    </pre>
  </li>
  <li>set_app_data
    <p class="Pp">Can be used to set some application defined value/data.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::set_app_data($ssl, $arg);
 # $ssl - value corresponding to openssl's SSL structure
 # $arg - (string/buffer/pointer ???) data
 #
 # returns: ???
    </pre>
  </li>
  <li>get_certificate
    <p class="Pp">Gets X509 certificate from an established SSL connection.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_certificate($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: value corresponding to openssl's X509 structure (0 on failure)
    </pre>
  </li>
  <li>get_cipher
    <p class="Pp">Obtains the name of the currently used cipher.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_cipher($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: (string) cipher name e.g. 'DHE-RSA-AES256-SHA' or '', when no session has been established.
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_get_current_cipher.html&gt;</p>
  </li>
  <li>get_cipher_bits
    <p class="Pp">Obtain the number of secret/algorithm bits used.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_cipher_bits($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: number of secret bits used by current cipher
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_get_current_cipher.html&gt; and
        &lt;http://www.openssl.org/docs/ssl/SSL_CIPHER_get_name.html&gt;</p>
  </li>
  <li>get_cipher_list
    <p class="Pp">Returns the name (string) of the SSL_CIPHER listed for
        <span class="Li">$ssl</span> with priority
      <span class="Li">$n</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_cipher_list($ssl, $n);
 # $ssl - value corresponding to openssl's SSL structure
 # $n - (integer) priority
 #
 # returns: (string) cipher name e.g. 'EDH-DSS-DES-CBC3-SHA' or '' in case of error
    </pre>
    <p class="Pp">Call Net::SSLeay::get_cipher_list with priority starting from
        0 to obtain the sorted list of available ciphers, until '' is
      returned:</p>
    <p class="Pp"></p>
    <pre>
 my $priority = 0;
 while (my $c = Net::SSLeay::get_cipher_list($ssl, $priority)) {
   print &quot;cipher[$priority] = $c\n&quot;;
   $priority++;
 }
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_get_ciphers.html&gt;</p>
  </li>
  <li>get_client_CA_list
    <p class="Pp">Returns the list of client CAs explicitly set for
        <span class="Li">$ssl</span> using
        <span class="Li">&quot;Net::SSleay::set_client_CA_list&quot;</span> or
        <span class="Li">$ssl</span>'s SSL_CTX object with
        <span class="Li">&quot;Net::SSLeay::CTX_set_client_CA_list&quot;</span>,
        when in server mode.</p>
    <p class="Pp">In client mode, returns the list of client CAs sent from the
        server, if any.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_client_CA_list($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: value corresponding to openssl's STACK_OF(X509_NAME) structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_get_client_CA_list.html&gt;</p>
  </li>
  <li>get_current_cipher
    <p class="Pp">Returns the cipher actually used.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_current_cipher($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: value corresponding to openssl's SSL_CIPHER structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_get_current_cipher.html&gt;</p>
  </li>
  <li>get_default_timeout
    <p class="Pp">Returns the default timeout value assigned to SSL_SESSION
        objects negotiated for the protocol valid for
        <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_default_timeout($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: (long) timeout in seconds
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_get_default_timeout.html&gt;</p>
  </li>
  <li>get_error
    <p class="Pp">Returns a result code for a preceding call to
        <span class="Li">&quot;connect&quot;</span>,
        <span class="Li">&quot;accept&quot;</span>,
        <span class="Li">&quot;do_handshake&quot;</span>,
        <span class="Li">&quot;read&quot;</span>,
        <span class="Li">&quot;peek&quot;</span> or
        <span class="Li">&quot;write&quot;</span> on
        <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_error($ssl, $ret);
 # $ssl - value corresponding to openssl's SSL structure
 # $ret - return value of preceding TLS/SSL I/O operation
 #
 # returns: result code, which is one of the following values:
 #  0 - SSL_ERROR_NONE
 #  1 - SSL_ERROR_SSL
 #  2 - SSL_ERROR_WANT_READ
 #  3 - SSL_ERROR_WANT_WRITE
 #  4 - SSL_ERROR_WANT_X509_LOOKUP
 #  5 - SSL_ERROR_SYSCALL
 #  6 - SSL_ERROR_ZERO_RETURN
 #  7 - SSL_ERROR_WANT_CONNECT
 #  8 - SSL_ERROR_WANT_ACCEPT
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_get_error.html&gt;</p>
  </li>
  <li>get_ex_data
    <p class="Pp">Is used to retrieve the information for
        <span class="Li">$idx</span> from <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_ex_data($ssl, $idx);
 # $ssl - value corresponding to openssl's SSL structure
 # $idx - (integer) index for application specific data
 #
 # returns: pointer to ???
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_get_ex_new_index.html&gt;</p>
  </li>
  <li>set_ex_data
    <p class="Pp">Is used to store application data at
        <span class="Li">$data</span> for <span class="Li">$idx</span> into the
        <span class="Li">$ssl</span> object.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::set_ex_data($ssl, $idx, $data);
 # $ssl - value corresponding to openssl's SSL structure
 # $idx - (integer) ???
 # $data - (pointer) ???
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_get_ex_new_index.html&gt;</p>
  </li>
  <li>get_ex_new_index
    <p class="Pp">Is used to register a new index for application specific
      data.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_ex_new_index($argl, $argp, $new_func, $dup_func, $free_func);
 # $argl - (long) ???
 # $argp - (pointer) ???
 # $new_func - function pointer ??? (CRYPTO_EX_new *)
 # $dup_func - function pointer ??? (CRYPTO_EX_dup *)
 # $free_func - function pointer ??? (CRYPTO_EX_free *)
 #
 # returns: (integer) ???
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_get_ex_new_index.html&gt;</p>
  </li>
  <li>get_fd
    <p class="Pp">Returns the file descriptor which is linked to
        <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_fd($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: file descriptor (&gt;=0) or -1 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_get_fd.html&gt;</p>
  </li>
  <li>get_finished
    <p class="Pp">Obtains the latest 'Finished' message sent to the peer. Return
        value is zero if there's been no Finished message yet. Default count is
        2*EVP_MAX_MD_SIZE that is long enough for all possible Finish messages.
        If you supply a non-default count, the resulting return value may be
        longer than returned buf's length.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_finished($ssl, $buf, $count);
 # $ssl - value corresponding to openssl's SSL structure
 # $buf - buffer where the returned data will be stored
 # $count - [optional] max size of return data - default is 2*EVP_MAX_MD_SIZE
 #
 # returns: length of latest Finished message
    </pre>
  </li>
  <li>get_peer_finished
    <p class="Pp">Obtains the latest 'Finished' message expected from the peer.
        Parameters and return value are similar to <b>get_finished()</b>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_peer_finished($ssl, $buf, $count);
 # $ssl - value corresponding to openssl's SSL structure
 # $buf - buffer where the returned data will be stored
 # $count - [optional] max size of return data - default is 2*EVP_MAX_MD_SIZE
 #
 # returns: length of latest Finished message
    </pre>
  </li>
  <li>get_keyblock_size
    <p class="Pp">Gets the length of the TLS keyblock.</p>
    <p class="Pp"><b>NOTE:</b> Does not exactly correspond to any low level API
        function.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_keyblock_size($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: keyblock size, -1 on error
    </pre>
  </li>
  <li>get_mode
    <p class="Pp">Returns the mode (bitmask) set for
        <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_mode($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: mode (bitmask)
    </pre>
    <p class="Pp">To decode the return value (bitmask) see documentation for
        &quot;CTX_get_mode&quot;.</p>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_mode.html&gt;</p>
  </li>
  <li>set_mode
    <p class="Pp">Adds the mode set via bitmask in <span class="Li">$mode</span>
        to <span class="Li">$ssl</span>. Options already set before are not
        cleared.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::set_mode($ssl, $mode);
 # $ssl - value corresponding to openssl's SSL structure
 # $mode - mode (bitmask)
 #
 # returns: the new mode bitmask after adding $mode
    </pre>
    <p class="Pp">For <span class="Li">$mode</span> bitmask details see
        &quot;CTX_get_mode&quot;.</p>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_mode.html&gt;</p>
  </li>
  <li>get_options
    <p class="Pp">Returns the options (bitmask) set for
        <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_options($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: options (bitmask)
    </pre>
    <p class="Pp">To decode the return value (bitmask) see documentation for
        &quot;CTX_get_options&quot;.</p>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_options.html&gt;</p>
  </li>
  <li>set_options
    <p class="Pp">Adds the options set via bitmask in
        <span class="Li">$options</span> to <span class="Li">$ssl</span>.
        Options already set before are not cleared!</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::set_options($ssl, $options);
 # $ssl - value corresponding to openssl's SSL structure
 # $options - options (bitmask)
 #
 # returns: the new options bitmask after adding $options
    </pre>
    <p class="Pp">For <span class="Li">$options</span> bitmask details see
        &quot;CTX_get_options&quot;.</p>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_options.html&gt;</p>
  </li>
  <li>get_peer_certificate
    <p class="Pp">Get the X509 certificate of the peer.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_peer_certificate($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: value corresponding to openssl's X509 structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_get_peer_certificate.html&gt;</p>
  </li>
  <li>get_peer_cert_chain
    <p class="Pp">Get the certificate chain of the peer as an array of X509
        structures.</p>
    <p class="Pp"></p>
    <pre>
 my @rv = Net::SSLeay::get_peer_cert_chain($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: list of X509 structures
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_get_peer_certificate.html&gt;</p>
  </li>
  <li>get_quiet_shutdown
    <p class="Pp">Returns the 'quiet shutdown' setting of ssl.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_quiet_shutdown($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: (integer) current 'quiet shutdown' value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_quiet_shutdown.html&gt;</p>
  </li>
  <li>get_rbio
    <p class="Pp">Get 'read' BIO linked to an SSL object
        <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_rbio($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: value corresponding to openssl's BIO structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_get_rbio.html&gt;</p>
  </li>
  <li>get_read_ahead
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_read_ahead($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: (integer) read_ahead value
    </pre>
  </li>
  <li>set_read_ahead
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::set_read_ahead($ssl, $val);
 # $ssl - value corresponding to openssl's SSL structure
 # $val - read_ahead value to be set
 #
 # returns: the original read_ahead value
    </pre>
  </li>
  <li>get_security_level
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and
        before; requires at least OpenSSL 1.1.0, not in LibreSSL</p>
    <p class="Pp">Returns the security level associated with
        <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $level = Net::SSLeay::get_security_level($ssl);
 # $ssl   - value corresponding to openssl's SSL structure
 #
 # returns: (integer) current security level
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/manmaster/man3/SSL_get_security_level.html&gt;</p>
  </li>
  <li>set_security_level
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and
        before; requires at least OpenSSL 1.1.0, not in LibreSSL</p>
    <p class="Pp">Sets the security level associated with
        <span class="Li">$ssl</span> to <span class="Li">$level</span>.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::set_security_level($ssl, $level);
 # $ssl   - value corresponding to openssl's SSL structure
 # $level - new security level
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/manmaster/man3/SSL_set_security_level.html&gt;</p>
  </li>
  <li>set_num_tickets
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and
        before; requires at least OpenSSL 1.1.1, not in LibreSSL</p>
    <p class="Pp">Set number of TLSv1.3 session tickets that will be sent to a
        client.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::set_num_tickets($ssl, $number_of_tickets);
 # $ssl  - value corresponding to openssl's SSL structure
 # $number_of_tickets - number of tickets to send
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Set to zero if you do not no want to support a session
        resumption.</p>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/manmaster/man3/SSL_set_num_tickets.html&gt;</p>
  </li>
  <li>get_num_tickets
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and
        before; requires at least OpenSSL 1.1.1, not in LibreSSL</p>
    <p class="Pp">Get number of TLSv1.3 session tickets that will be sent to a
        client.</p>
    <p class="Pp"></p>
    <pre>
 my $number_of_tickets = Net::SSLeay::get_num_tickets($ctx);
 # $ctx  - value corresponding to openssl's SSL structure
 #
 # returns: number of tickets to send
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/manmaster/man3/SSL_get_num_tickets.html&gt;</p>
  </li>
  <li>get_server_random
    <p class="Pp">Returns internal SSLv3 server_random value.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::get_server_random($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: server_random value (binary data)
    </pre>
  </li>
  <li>get_client_random
    <p class="Pp"><b>NOTE:</b> Does not exactly correspond to any low level API
        function</p>
    <p class="Pp">Returns internal SSLv3 client_random value.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::get_client_random($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: client_random value (binary data)
    </pre>
  </li>
  <li>export_keying_material
    <p class="Pp">Returns keying material based on the string
        <span class="Li">$label</span> and optional
        <span class="Li">$context</span>. Note that with TLSv1.2 and lower,
        empty context (empty string) and undefined context (no value or 'undef')
        will return different values.</p>
    <p class="Pp"></p>
    <pre>
  my $out = Net::SSLeay::export_keying_material($ssl, $olen, $label, $context);
  # $ssl - value corresponding to openssl's SSL structure
  # $olen - number of bytes to return
  # $label - application specific label
  # $context - [optional] context - default is undef for no context
  #
  # returns: keying material (binary data) or undef on error
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/manmaster/man3/SSL_export_keying_material.html&gt;</p>
  </li>
  <li>get_session
    <p class="Pp">Retrieve TLS/SSL session data used in
        <span class="Li">$ssl</span>. The reference count of the SSL_SESSION is
        NOT incremented.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_session($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: value corresponding to openssl's SSL_SESSION structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_get_session.html&gt;</p>
  </li>
  <li>SSL_get0_session
    <p class="Pp">The alias for &quot;get_session&quot; (note that the name is
        <span class="Li">&quot;SSL_get0_session&quot;</span> NOT
        <span class="Li">&quot;get0_session&quot;</span>).</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::SSL_get0_session();
    </pre>
  </li>
  <li>get1_session
    <p class="Pp">Returns a pointer to the SSL_SESSION actually used in
        <span class="Li">$ssl</span>. The reference count of the SSL_SESSION is
        incremented by 1.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get1_session($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: value corresponding to openssl's SSL_SESSION structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_get_session.html&gt;</p>
  </li>
  <li>get_shared_ciphers
    <p class="Pp">Returns string with a list (colon ':' separated) of ciphers
        shared between client and server within SSL session
        <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_shared_ciphers()
 #
 # returns: string like 'ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES256-SHA:DHE-DSS-AES256-SHA:...'
    </pre>
  </li>
  <li>get_shutdown
    <p class="Pp">Returns the shutdown mode of <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_shutdown($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: shutdown mode (bitmask) of ssl

 #to decode the return value (bitmask) use:
 0 - No shutdown setting, yet
 1 - SSL_SENT_SHUTDOWN
 2 - SSL_RECEIVED_SHUTDOWN
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_set_shutdown.html&gt;</p>
  </li>
  <li>get_ssl_method
    <p class="Pp">Returns a function pointer to the TLS/SSL method set in
        <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_ssl_method($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: value corresponding to openssl's SSL_METHOD structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_ssl_version.html&gt;</p>
  </li>
  <li>in_init, in_before, is_init_finished, in_connect_init, in_accept_init
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and
        before.</p>
    <p class="Pp">Retrieve information about the handshake state machine. All
        functions take <span class="Li">$ssl</span> as the only argument and
        return 0 or 1. These functions are recommended over <b>get_state()</b>
        and <b>state()</b>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::is_init_finished($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: All functions return 1 or 0
    </pre>
    <p class="Pp">Check openssl doc
        https://www.openssl.org/docs/ssl/SSL_in_init.html
        &lt;http://www.openssl.org/docs/ssl/SSL_in_init.html&gt;</p>
  </li>
  <li>get_state
    <p class="Pp"><b>COMPATIBILITY:</b> OpenSSL 1.1.0 and later use different
        constants which are not made available. Use <b>is_init_finished()</b>
        and related functions instead.</p>
    <p class="Pp">Returns the SSL connection state.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_state($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: (integer) state value
 #          to decode the returned state check:
 #          SSL_ST_* constants in openssl/ssl.h
 #          SSL2_ST_* constants in openssl/ssl2.h
 #          SSL23_ST_* constants in openssl/ssl23.h
 #          SSL3_ST_* + DTLS1_ST_* constants in openssl/ssl3.h
    </pre>
  </li>
  <li>state
    <p class="Pp">Exactly the same as &quot;get_state&quot;.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::state($ssl);
    </pre>
  </li>
  <li>set_state
    <p class="Pp">Sets the SSL connection state.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::set_state($ssl,Net::SSLeay::SSL_ST_ACCEPT());
    </pre>
    <p class="Pp">Not available with OpenSSL 1.1 and later.</p>
  </li>
  <li>get_verify_depth
    <p class="Pp">Returns the verification depth limit currently set in
        <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_verify_depth($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: current depth or -1 if no limit has been explicitly set
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_get_verify_mode.html&gt;</p>
  </li>
  <li>set_verify_depth
    <p class="Pp">Sets the maximum depth for the certificate chain verification
        that shall be allowed for <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::set_verify_depth($ssl, $depth);
 # $ssl - value corresponding to openssl's SSL structure
 # $depth - (integer) depth
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html&gt;</p>
  </li>
  <li>get_verify_mode
    <p class="Pp">Returns the verification mode (bitmask) currently set in
        <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_verify_mode($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: mode (bitmask)
    </pre>
    <p class="Pp">To decode the return value (bitmask) see documentation for
        &quot;CTX_get_verify_mode&quot;.</p>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_get_verify_mode.html&gt;</p>
  </li>
  <li>set_verify
    <p class="Pp">Sets the verification flags for <span class="Li">$ssl</span>
        to be <span class="Li">$mode</span> and specifies the
        <span class="Li">$verify_callback</span> function to be used.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::set_verify($ssl, $mode, $callback);
 # $ssl - value corresponding to openssl's SSL structure
 # $mode - mode (bitmask)
 # $callback - [optional] reference to perl callback function
 #
 # returns: no return value
    </pre>
    <p class="Pp">For <span class="Li">$mode</span> bitmask details see
        &quot;CTX_get_verify_mode&quot;.</p>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html&gt;</p>
  </li>
  <li>set_post_handshake_auth
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and
        before; requires at least OpenSSL 1.1.1, not in LibreSSL</p>
    <p class="Pp">Enable the Post-Handshake Authentication extension to be added
        to the ClientHello such that post-handshake authentication can be
        requested by the server.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::set_posthandshake_auth($ssl, $val);
 # $ssl - value corresponding to openssl's SSL structure
 # $val - 0 then the extension is not sent, otherwise it is
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        https://www.openssl.org/docs/manmaster/man3/SSL_set_post_handshake_auth
        &lt;https://www.openssl.org/docs/manmaster/man3/SSL_set_post_handshake_auth.html&gt;</p>
  </li>
  <li>verify_client_post_handshake
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and
        before; requires at least OpenSSL 1.1.1, not in LibreSSL</p>
    <p class="Pp">verify_client_post_handshake causes a CertificateRequest
        message to be sent by a server on the given ssl connection.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::verify_client_post_handshake($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: 1 if the request succeeded, and 0 if the request failed. The error stack can be examined to determine the failure reason.
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/manmaster/man3/SSL_verify_client_post_handshake.html&gt;</p>
  </li>
  <li>get_verify_result
    <p class="Pp">Returns the result of the verification of the X509 certificate
        presented by the peer, if any.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_verify_result($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: (integer)
 #      0 - X509_V_OK: ok
 #      2 - X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT: unable to get issuer certificate
 #      3 - X509_V_ERR_UNABLE_TO_GET_CRL: unable to get certificate CRL
 #      4 - X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE: unable to decrypt certificate's signature
 #      5 - X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE: unable to decrypt CRL's signature
 #      6 - X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY: unable to decode issuer public key
 #      7 - X509_V_ERR_CERT_SIGNATURE_FAILURE: certificate signature failure
 #      8 - X509_V_ERR_CRL_SIGNATURE_FAILURE: CRL signature failure
 #      9 - X509_V_ERR_CERT_NOT_YET_VALID: certificate is not yet valid
 #     10 - X509_V_ERR_CERT_HAS_EXPIRED: certificate has expired
 #     11 - X509_V_ERR_CRL_NOT_YET_VALID: CRL is not yet valid
 #     12 - X509_V_ERR_CRL_HAS_EXPIRED: CRL has expired
 #     13 - X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD: format error in certificate's notBefore field
 #     14 - X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD: format error in certificate's notAfter field
 #     15 - X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD: format error in CRL's lastUpdate field
 #     16 - X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD: format error in CRL's nextUpdate field
 #     17 - X509_V_ERR_OUT_OF_MEM: out of memory
 #     18 - X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT: self signed certificate
 #     19 - X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN: self signed certificate in certificate chain
 #     20 - X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY: unable to get local issuer certificate
 #     21 - X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE: unable to verify the first certificate
 #     22 - X509_V_ERR_CERT_CHAIN_TOO_LONG: certificate chain too long
 #     23 - X509_V_ERR_CERT_REVOKED: certificate revoked
 #     24 - X509_V_ERR_INVALID_CA: invalid CA certificate
 #     25 - X509_V_ERR_PATH_LENGTH_EXCEEDED: path length constraint exceeded
 #     26 - X509_V_ERR_INVALID_PURPOSE: unsupported certificate purpose
 #     27 - X509_V_ERR_CERT_UNTRUSTED: certificate not trusted
 #     28 - X509_V_ERR_CERT_REJECTED: certificate rejected
 #     29 - X509_V_ERR_SUBJECT_ISSUER_MISMATCH: subject issuer mismatch
 #     30 - X509_V_ERR_AKID_SKID_MISMATCH: authority and subject key identifier mismatch
 #     31 - X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH: authority and issuer serial number mismatch
 #     32 - X509_V_ERR_KEYUSAGE_NO_CERTSIGN:key usage does not include certificate signing
 #     50 - X509_V_ERR_APPLICATION_VERIFICATION: application verification failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_get_verify_result.html&gt;</p>
  </li>
  <li>set_verify_result
    <p class="Pp">Override result of peer certificate verification.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::set_verify_result($ssl, $v);
 # $ssl - value corresponding to openssl's SSL structure
 # $v - (integer) result value
 #
 # returns: no return value
    </pre>
    <p class="Pp">For more info about valid return values see
        &quot;get_verify_result&quot;</p>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_set_verify_result.html&gt;</p>
  </li>
  <li>get_wbio
    <p class="Pp">Get 'write' BIO linked to an SSL object
        <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_wbio($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: value corresponding to openssl's BIO structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_get_rbio.html&gt;</p>
  </li>
  <li>load_client_CA_file
    <p class="Pp">Load X509 certificates from file (PEM formatted).</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::load_client_CA_file($file);
 # $file - (string) file name
 #
 # returns: value corresponding to openssl's STACK_OF(X509_NAME) structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_load_client_CA_file.html&gt;</p>
  </li>
  <li>clear_num_renegotiations
    <p class="Pp">Executes SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS command on
        <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::clear_num_renegotiations($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: command result
    </pre>
  </li>
  <li>need_tmp_RSA
    <p class="Pp">Executes SSL_CTRL_NEED_TMP_RSA command on
        <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::need_tmp_RSA($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: command result
    </pre>
    <p class="Pp">Not available with OpenSSL 1.1 and later.</p>
  </li>
  <li>num_renegotiations
    <p class="Pp">Executes SSL_CTRL_GET_NUM_RENEGOTIATIONS command on
        <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::num_renegotiations($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: command result
    </pre>
  </li>
  <li>total_renegotiations
    <p class="Pp">Executes SSL_CTRL_GET_TOTAL_RENEGOTIATIONS command on
        <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::total_renegotiations($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: command result
    </pre>
  </li>
  <li>peek
    <p class="Pp">Copies <span class="Li">$max</span> bytes from the specified
        <span class="Li">$ssl</span> into the returned value. In contrast to the
        <span class="Li">&quot;Net::SSLeay::read()&quot;</span> function, the
        data in the SSL buffer is unmodified after the <b>SSL_peek()</b>
        operation.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::peek($ssl, $max);
 # $ssl - value corresponding to openssl's SSL structure
 # $max - [optional] max bytes to peek (integer) - default is 32768
 #
 # in scalar context: data read from the TLS/SSL connection, undef on error
 # in list context:   two-item array consisting of data read (undef on error),
 #                      and return code from SSL_peek().
    </pre>
  </li>
  <li>peek_ex
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and
        before; requires at least OpenSSL 1.1.1, not in LibreSSL</p>
    <p class="Pp">Copies <span class="Li">$max</span> bytes from the specified
        <span class="Li">$ssl</span> into the returned value. In contrast to the
        <span class="Li">&quot;Net::SSLeay::read_ex()&quot;</span> function, the
        data in the SSL buffer is unmodified after the <b>SSL_peek_ex()</b>
        operation.</p>
    <p class="Pp"></p>
    <pre>
 my($got, $rv) = Net::SSLeay::peek_ex($ssl, $max);
 # $ssl - value corresponding to openssl's SSL structure
 # $max - [optional] max bytes to peek (integer) - default is 32768
 #
 # returns a list: two-item list consisting of data read (undef on error),
 #                 and return code from SSL_peek_ex().
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/manmaster/man3/SSL_peek_ex.html&gt;</p>
  </li>
  <li>pending
    <p class="Pp">Obtain number of readable bytes buffered in
        <span class="Li">$ssl</span> object.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::pending($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: the number of bytes pending
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_pending.html&gt;</p>
  </li>
  <li>has_pending
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and
        before; requires at least OpenSSL 1.1.0, not in LibreSSL</p>
    <p class="Pp">Returns 1 if <span class="Li">$ssl</span> has buffered data
        (whether processed or unprocessed) and 0 otherwise.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::has_pending($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: (integer) 1 or 0
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/manmaster/man3/SSL_has_pending.html&gt;</p>
  </li>
  <li>read
    <p class="Pp">Tries to read <span class="Li">$max</span> bytes from the
        specified <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $got = Net::SSLeay::read($ssl, $max);
 my($got, $rv) = Net::SSLeay::read($ssl, $max);
 # $ssl - value corresponding to openssl's SSL structure
 # $max - [optional] max bytes to read (integer) - default is 32768
 #
 # returns:
 # in scalar context: data read from the TLS/SSL connection, undef on error
 # in list context:   two-item array consisting of data read (undef on error),
 #                      and return code from SSL_read().
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_read.html&gt;</p>
  </li>
  <li>read_ex
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and
        before; requires at least OpenSSL 1.1.1, not in LibreSSL</p>
    <p class="Pp">Tries to read <span class="Li">$max</span> bytes from the
        specified <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my($got, $rv) = Net::SSLeay::read_ex($ssl, $max);
 # $ssl - value corresponding to openssl's SSL structure
 # $max - [optional] max bytes to read (integer) - default is 32768
 #
 # returns a list: two-item list consisting of data read (undef on error),
 #                 and return code from SSL_read_ex().
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/manmaster/man3/SSL_read_ex.html&gt;</p>
  </li>
  <li>renegotiate
    <p class="Pp">Turn on flags for renegotiation so that renegotiation will
        happen</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::renegotiate($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>rstate_string
    <p class="Pp">Returns a 2 letter string indicating the current read state of
        the SSL object <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::rstate_string($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: 2-letter string
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_rstate_string.html&gt;</p>
  </li>
  <li>rstate_string_long
    <p class="Pp">Returns a string indicating the current read state of the SSL
        object ssl.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::rstate_string_long($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: string with current state
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_rstate_string.html&gt;</p>
  </li>
  <li>session_reused
    <p class="Pp">Query whether a reused session was negotiated during
        handshake.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::session_reused($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: 0 - new session was negotiated; 1 - session was reused.
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_session_reused.html&gt;</p>
  </li>
  <li>set1_param
    <p class="Pp">Applies X509 verification parameters
        <span class="Li">$vpm</span> on <span class="Li">$ssl</span></p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::set1_param($ssl, $vpm);
 # $ssl - value corresponding to openssl's SSL structure
 # $vpm - value corresponding to openssl's X509_VERIFY_PARAM structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>set_accept_state
    <p class="Pp">Sets <span class="Li">$ssl</span> to work in server mode.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::set_accept_state($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_set_connect_state.html&gt;</p>
  </li>
  <li>set_bio
    <p class="Pp">Connects the BIOs <span class="Li">$rbio</span> and
        <span class="Li">$wbio</span> for the read and write operations of the
        TLS/SSL (encrypted) side of <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::set_bio($ssl, $rbio, $wbio);
 # $ssl - value corresponding to openssl's SSL structure
 # $rbio - value corresponding to openssl's BIO structure
 # $wbio - value corresponding to openssl's BIO structure
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_set_bio.html&gt;</p>
  </li>
  <li>set_cipher_list
    <p class="Pp">Sets the list of ciphers only for ssl.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::set_cipher_list($ssl, $str);
 # $ssl - value corresponding to openssl's SSL structure
 # $str - (string) cipher list e.g. '3DES:+RSA'
 #
 # returns: 1 if any cipher could be selected and 0 on complete failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_cipher_list.html&gt;</p>
  </li>
  <li>set_ciphersuites
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and
        before; requires at least OpenSSL 1.1.1, not in LibreSSL</p>
    <p class="Pp">Configure the available TLSv1.3 ciphersuites.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::set_ciphersuites($ssl, $str);
 # $ssl  - value corresponding to openssl's SSL structure
 # $str  - colon (&quot;:&quot;) separated list of TLSv1.3 ciphersuite names in order of preference
 #
 # returns: (integer) 1 if the requested ciphersuite list was configured, and 0 otherwise
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/manmaster/man3/SSL_set_ciphersuites.html&gt;</p>
  </li>
  <li>set_client_CA_list
    <p class="Pp">Sets the list of CAs sent to the client when requesting a
        client certificate for the chosen <span class="Li">$ssl</span>,
        overriding the setting valid for <span class="Li">$ssl</span>'s SSL_CTX
        object.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::set_client_CA_list($ssl, $list);
 # $ssl - value corresponding to openssl's SSL structure
 # $list - value corresponding to openssl's STACK_OF(X509_NAME) structure
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_client_CA_list.html&gt;</p>
  </li>
  <li>set_connect_state
    <p class="Pp">Sets <span class="Li">$ssl</span> to work in client mode.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::set_connect_state($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_set_connect_state.html&gt;</p>
  </li>
  <li>set_fd
    <p class="Pp">Sets the file descriptor <span class="Li">$fd</span> as the
        input/output facility for the TLS/SSL (encrypted) side of
        <span class="Li">$ssl</span>, <span class="Li">$fd</span> will typically
        be the socket file descriptor of a network connection.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::set_fd($ssl, $fd);
 # $ssl - value corresponding to openssl's SSL structure
 # $fd - (integer) file handle (got via perl's fileno)
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_set_fd.html&gt;</p>
  </li>
  <li>set_psk_client_callback
    <p class="Pp">Sets the psk client callback.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::set_psk_client_callback($ssl, sub { my $hint = shift; return ($identity, $key) } );
 # $ssl - value corresponding to openssl's SSL structure
 # $hint - PSK identity hint send by the server
 # $identity - PSK identity
 # $key - PSK key, hex string without the leading '0x', e.g. 'deadbeef'
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_set_psk_client_callback.html&gt;</p>
  </li>
  <li>set_rfd
    <p class="Pp">Sets the file descriptor <span class="Li">$fd</span> as the
        input (read) facility for the TLS/SSL (encrypted) side of
        <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::set_rfd($ssl, $fd);
 # $ssl - value corresponding to openssl's SSL structure
 # $fd - (integer) file handle (got via perl's fileno)
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_set_fd.html&gt;</p>
  </li>
  <li>set_wfd
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::set_wfd($ssl, $fd);
 # $ssl - value corresponding to openssl's SSL structure
 # $fd - (integer) file handle (got via perl's fileno)
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_set_fd.html&gt;</p>
  </li>
  <li>set_info_callback
    <p class="Pp">Sets the callback function, that can be used to obtain state
        information for <span class="Li">$ssl</span> during connection setup and
        use. When callback is undef, the callback setting currently valid for
        ctx is used.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::set_info_callback($ssl, $cb, [$data]);
 # $ssl - value corresponding to openssl's SSL structure
 # $cb - sub { my ($ssl,$where,$ret,$data) = @_; ... }
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_info_callback.html&gt;</p>
  </li>
  <li>CTX_set_info_callback
    <p class="Pp">Sets the callback function on ctx, that can be used to obtain
        state information during ssl connection setup and use. When callback is
        undef, an existing callback will be disabled.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::CTX_set_info_callback($ssl, $cb, [$data]);
 # $ssl - value corresponding to openssl's SSL structure
 # $cb - sub { my ($ssl,$where,$ret,$data) = @_; ... }
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_info_callback.html&gt;</p>
  </li>
  <li>set_pref_cipher
    <p class="Pp">Sets the list of available ciphers for
        <span class="Li">$ssl</span> using the control string
        <span class="Li">$str</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::set_pref_cipher($ssl, $str);
 # $ssl - value corresponding to openssl's SSL structure
 # $str - (string) cipher list e.g. '3DES:+RSA'
 #
 # returns: 1 if any cipher could be selected and 0 on complete failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_cipher_list.html&gt;</p>
  </li>
  <li>CTX_set_psk_client_callback
    <p class="Pp">Sets the psk client callback.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::CTX_set_psk_client_callback($ssl, sub { my $hint = shift; return ($identity, $key) } );
 # $ssl - value corresponding to openssl's SSL structure
 # $hint - PSK identity hint send by the server
 # $identity - PSK identity
 # $key - PSK key, hex string without the leading '0x', e.g. 'deadbeef'
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_psk_client_callback.html&gt;</p>
  </li>
  <li>set_purpose
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::set_purpose($ssl, $purpose);
 # $ssl - value corresponding to openssl's SSL structure
 # $purpose - (integer) purpose identifier
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">For more info about available <span class="Li">$purpose</span>
        identifiers see &quot;CTX_set_purpose&quot;.</p>
  </li>
  <li>set_quiet_shutdown
    <p class="Pp">Sets the 'quiet shutdown' flag for
        <span class="Li">$ssl</span> to be <span class="Li">$mode</span>.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::set_quiet_shutdown($ssl, $mode);
 # $ssl - value corresponding to openssl's SSL structure
 # $mode - 0 or 1
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_quiet_shutdown.html&gt;</p>
  </li>
  <li>set_session
    <p class="Pp">Set a TLS/SSL session to be used during TLS/SSL connect.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::set_session($to, $ses);
 # $to - value corresponding to openssl's SSL structure
 # $ses - value corresponding to openssl's SSL_SESSION structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_set_session.html&gt;</p>
  </li>
  <li>set_session_id_context
    <p class="Pp">Sets the context <span class="Li">$sid_ctx</span> of length
        <span class="Li">$sid_ctx_len</span> within which a session can be
        reused for the <span class="Li">$ssl</span> object.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::set_session_id_context($ssl, $sid_ctx, $sid_ctx_len);
 # $ssl - value corresponding to openssl's SSL structure
 # $sid_ctx - data buffer
 # $sid_ctx_len - length of data in $sid_ctx
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_session_id_context.html&gt;</p>
  </li>
  <li>set_session_secret_cb
    <p class="Pp">Setup pre-shared secret session resumption function.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::set_session_secret_cb($ssl, $func, $data);
 # $ssl - value corresponding to openssl's SSL structure
 # $func - perl reference to callback function
 # $data - [optional] data that will be passed to callback function when invoked
 #
 # returns: no return value
    </pre>
    <p class="Pp">The callback function will be called like:
        callback_function($secret, <span class="Li">$ciphers</span>,
        <span class="Li">$pref_cipher</span>,
      <span class="Li">$data</span>);</p>
    <p class="Pp"># <span class="Li">$secret</span> is the current master
        session key, usually all 0s at the beginning of a session #
        <span class="Li">$ciphers</span> is ref to an array of peer cipher names
        # <span class="Li">$pref_cipher</span> is a ref to an index into the
        list of cipher names of # the preferred cipher. Set it if you want to
        specify a preferred cipher # <span class="Li">$data</span> is the data
        passed to set_session_secret_cb</p>
    <p class="Pp">The callback function should return 1 if it likes the
        suggested cipher (or has selected an alternative by setting
        pref_cipher), else it should return 0 (in which case OpenSSL will select
        its own preferred cipher).</p>
    <p class="Pp">With OpenSSL 1.1 and later, callback_function can change the
        master key for the session by altering <span class="Li">$secret</span>
        and returning 1.</p>
  </li>
  <li>CTX_set_tlsext_ticket_getkey_cb
    <p class="Pp">Setup encryption for TLS session tickets (stateless session
        reuse).</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::CTX_set_tlsext_ticket_getkey_cb($ctx, $func, $data);
 # $ctx  - value corresponding to openssl's SSL_CTX structure
 # $func - perl reference to callback function
 # $data - [optional] data that will be passed to callback function when invoked
 #
 # returns: no return value
    </pre>
    <p class="Pp">The callback function will be called like:
        getkey($data,[$key_name]) -&gt; ($key,$current_key_name)</p>
    <p class="Pp"># <span class="Li">$data</span> is the data passed to
        set_session_secret_cb # <span class="Li">$key_name</span> is the name of
        the key OpenSSL has extracted from the session ticket #
        <span class="Li">$key</span> is the requested key for ticket encryption
        + HMAC # <span class="Li">$current_key_name</span> is the name for the
        currently valid key</p>
    <p class="Pp">OpenSSL will call the function without a key name if it
        generates a new ticket. It then needs the callback to return the
        encryption+HMAC key and an identifier (key name) for this key.</p>
    <p class="Pp">When OpenSSL gets a session ticket from the client it extracts
        the key name and calls the callback with this name as argument. It then
        expects the callback to return the encryption+HMAC key matching the
        requested key name and and also the key name which should be used at the
        moment. If the requested key name and the returned key name differ it
        means that this session ticket was created with an expired key and need
        to be renewed. In this case OpenSSL will call the callback again with no
        key name to create a new session ticket based on the old one.</p>
    <p class="Pp">The key must be at least 32 byte of random data which can be
        created with RAND_bytes. Internally the first 16 byte are used as key in
        AES-128 encryption while the next 16 byte are used for the SHA-256 HMAC.
        The key name are binary data and must be exactly 16 byte long.</p>
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>
    Net::SSLeay::RAND_bytes(my $oldkey,32);
    Net::SSLeay::RAND_bytes(my $newkey,32);
    my $oldkey_name = pack(&quot;a16&quot;,'oldsecret');
    my $newkey_name = pack(&quot;a16&quot;,'newsecret');

    my @keys = (
        [ $newkey_name, $newkey ], # current active key
        [ $oldkey_name, $oldkey ], # already expired
    );

    Net::SSLeay::CTX_set_tlsext_ticket_getkey_cb($server2-&gt;_ctx, sub {
        my ($mykeys,$name) = @_;

        # return (current_key, current_key_name) if no name given
        return ($mykeys-&gt;[0][1],$mykeys-&gt;[0][0]) if ! $name;

        # return (matching_key, current_key_name) if we find a key matching
        # the given name
        for(my $i = 0; $i&lt;@$mykeys; $i++) {
            next if $name ne $mykeys-&gt;[$i][0];
            return ($mykeys-&gt;[$i][1],$mykeys-&gt;[0][0]);
        }

        # no matching key found
        return;
    },\@keys);
    </pre>
    <p class="Pp">This function is based on the OpenSSL function
        SSL_CTX_set_tlsext_ticket_key_cb but provides a simpler to use
        interface. For more information see
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_tlsext_ticket_key_cb.html&gt;</p>
  </li>
  <li>set_session_ticket_ext_cb
    <p class="Pp">Setup callback for TLS session tickets (stateless session
        reuse).</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::set_session_ticket_ext_cb($ssl, $func, $data);
 # $ssl  - value corresponding to openssl's SSL structure
 # $func - perl reference to callback function
 # $data - [optional] data that will be passed to callback function when invoked
 #
 # returns: no return value
    </pre>
    <p class="Pp">The callback function will be called like:
        getticket($ssl,$ticket,$data) -&gt;
        <span class="Li">$return_value</span></p>
    <p class="Pp"># <span class="Li">$ssl</span> is a value corresponding to
        openssl's SSL structure # <span class="Li">$ticket</span> is a value of
        received TLS session ticket (can also be empty) #
        <span class="Li">$data</span> is the data passed to
        set_session_ticket_ext_cb # <span class="Li">$return_value</span> is
        either 0 (failure) or 1 (success)</p>
    <p class="Pp">This function is based on the OpenSSL function
        SSL_set_session_ticket_ext_cb.</p>
  </li>
  <li>set_session_ticket_ext
    <p class="Pp">Set TLS session ticket (stateless session reuse).</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::set_session_ticket_ext($ssl, $ticket);
 # $ssl    - value corresponding to openssl's SSL structure
 # $ticket - is a value of TLS session ticket which client will send (can also be empty string)
 #
 # returns: no return value
    </pre>
    <p class="Pp">The callback function will be called like:
        getticket($ssl,$ticket,$data) -&gt;
        <span class="Li">$return_value</span></p>
    <p class="Pp"># <span class="Li">$ssl</span> is a value corresponding to
        openssl's SSL structure # <span class="Li">$ticket</span> is a value of
        received TLS session ticket (can also be empty) #
        <span class="Li">$data</span> is the data passed to
        set_session_ticket_ext_cb # <span class="Li">$return_value</span> is
        either 0 (failure) or 1 (success)</p>
    <p class="Pp">This function is based on the OpenSSL function
        SSL_set_session_ticket_ext_cb.</p>
  </li>
  <li>set_shutdown
    <p class="Pp">Sets the shutdown state of <span class="Li">$ssl</span> to
        <span class="Li">$mode</span>.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::set_shutdown($ssl, $mode);
 # $ssl - value corresponding to openssl's SSL structure
 # $mode - (integer) shutdown mode:
 #         0 - No shutdown
 #         1 - SSL_SENT_SHUTDOWN
 #         2 - SSL_RECEIVED_SHUTDOWN
 #         3 - SSL_RECEIVED_SHUTDOWN+SSL_SENT_SHUTDOWN
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_set_shutdown.html&gt;</p>
  </li>
  <li>set_ssl_method
    <p class="Pp">Sets a new TLS/SSL method for a particular
        <span class="Li">$ssl</span> object.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::set_ssl_method($ssl, $method);
 # $ssl - value corresponding to openssl's SSL structure
 # $method - value corresponding to openssl's SSL_METHOD structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_ssl_version.html&gt;</p>
  </li>
  <li>set_tmp_dh
    <p class="Pp">Sets DH parameters to be used to be
        <span class="Li">$dh</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::set_tmp_dh($ssl, $dh);
 # $ssl - value corresponding to openssl's SSL structure
 # $dh - value corresponding to openssl's DH structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_tmp_dh_callback.html&gt;</p>
  </li>
  <li>set_tmp_dh_callback
    <p class="Pp">Sets the callback function for <span class="Li">$ssl</span> to
        be used when a DH parameters are required to
        <span class="Li">$dh_cb</span>.</p>
    <p class="Pp">??? (does this function really work?)</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::set_tmp_dh_callback($ssl, $dh);
 # $ssl - value corresponding to openssl's SSL structure
 # $dh_cb - pointer to function ???
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_tmp_dh_callback.html&gt;</p>
  </li>
  <li>set_tmp_rsa
    <p class="Pp">Sets the temporary/ephemeral RSA key to be used in
        <span class="Li">$ssl</span> to be <span class="Li">$rsa</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::set_tmp_rsa($ssl, $rsa);
 # $ssl - value corresponding to openssl's SSL structure
 # $rsa - value corresponding to openssl's RSA structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>
 $rsakey = Net::SSLeay::RSA_generate_key();
 Net::SSLeay::set_tmp_rsa($ssl, $rsakey);
 Net::SSLeay::RSA_free($rsakey);
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_tmp_rsa_callback.html&gt;</p>
  </li>
  <li>set_tmp_rsa_callback
    <p class="Pp">Sets the callback function for <span class="Li">$ssl</span> to
        be used when a temporary/ephemeral RSA key is required to
        <span class="Li">$tmp_rsa_callback</span>.</p>
    <p class="Pp">??? (does this function really work?)</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::set_tmp_rsa_callback($ssl, $tmp_rsa_callback);
 # $ssl - value corresponding to openssl's SSL structure
 # $tmp_rsa_callback - (function pointer) ???
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_tmp_rsa_callback.html&gt;</p>
  </li>
  <li>set_trust
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::set_trust($ssl, $trust);
 # $ssl - value corresponding to openssl's SSL structure
 # $trust - (integer) trust identifier
 #
 # returns: the original value
    </pre>
    <p class="Pp">For more details about <span class="Li">$trust</span> values
        see &quot;CTX_set_trust&quot;.</p>
  </li>
  <li>shutdown
    <p class="Pp">Shuts down an active TLS/SSL connection. It sends the 'close
        notify' shutdown alert to the peer.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::shutdown($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: 1 - shutdown was successfully completed
 #          0 - shutdown is not yet finished,
 #         -1 - shutdown was not successful
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_shutdown.html&gt;</p>
  </li>
  <li>state_string
    <p class="Pp">Returns a 6 letter string indicating the current state of the
        SSL object <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::state_string($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: 6-letter string
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_state_string.html&gt;</p>
  </li>
  <li>state_string_long
    <p class="Pp">Returns a string indicating the current state of the SSL
        object <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::state_string_long($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: state strings
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_state_string.html&gt;</p>
  </li>
  <li>set_default_passwd_cb
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.82 and
        before; requires at least OpenSSL 1.1.0f. Not needed with LibreSSL.</p>
    <p class="Pp">Sets the default password callback called when loading/storing
        a PEM certificate with encryption for <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::set_default_passwd_cb($ssl, $func);
 # $ssl - value corresponding to openssl's SSL structure
 # $func - perl reference to callback function
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_default_passwd_cb.html&gt;</p>
  </li>
  <li>set_default_passwd_cb_userdata
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.82 and
        before; requires at least OpenSSL 1.1.0f. Not needed with LibreSSL.</p>
    <p class="Pp">Sets a pointer to userdata which will be provided to the
        password callback of <span class="Li">$ssl</span> on invocation.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::set_default_passwd_cb_userdata($ssl, $userdata);
 # $ssl - value corresponding to openssl's SSL structure
 # $userdata - data that will be passed to callback function when invoked
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_default_passwd_cb.html&gt;</p>
  </li>
  <li>use_PrivateKey
    <p class="Pp">Adds <span class="Li">$pkey</span> as private key to
        <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::use_PrivateKey($ssl, $pkey);
 # $ssl - value corresponding to openssl's SSL structure
 # $pkey - value corresponding to openssl's EVP_PKEY structure
 #
 # returns: 1 on success, otherwise check out the error stack to find out the reason
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p>
  </li>
  <li>use_PrivateKey_ASN1
    <p class="Pp">Adds the private key of type <span class="Li">$pk</span>
        stored in <span class="Li">$data</span> to
      <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::use_PrivateKey_ASN1($pk, $ssl, $d, $len);
 # $pk - (integer) key type, NID of corresponding algorithm
 # $ssl - value corresponding to openssl's SSL structure
 # $data - key data (binary)
 # $len - length of $data
 #
 # returns: 1 on success, otherwise check out the error stack to find out the reason
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p>
  </li>
  <li>use_PrivateKey_file
    <p class="Pp">Adds the first private key found in
        <span class="Li">$file</span> to <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::use_PrivateKey_file($ssl, $file, $type);
 # $ssl - value corresponding to openssl's SSL structure
 # $file - (string) file name
 # $type - (integer) type - use constants &amp;Net::SSLeay::FILETYPE_PEM or &amp;Net::SSLeay::FILETYPE_ASN1
 #
 # returns: 1 on success, otherwise check out the error stack to find out the reason
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p>
  </li>
  <li>use_RSAPrivateKey
    <p class="Pp">Adds <span class="Li">$rsa</span> as RSA private key to
        <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::use_RSAPrivateKey($ssl, $rsa);
 # $ssl - value corresponding to openssl's SSL structure
 # $rsa - value corresponding to openssl's RSA structure
 #
 # returns: 1 on success, otherwise check out the error stack to find out the reason
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p>
  </li>
  <li>use_RSAPrivateKey_ASN1
    <p class="Pp">Adds RSA private key stored in <span class="Li">$data</span>
        to <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::use_RSAPrivateKey_ASN1($ssl, $data, $len);
 # $ssl - value corresponding to openssl's SSL structure
 # $data - key data (binary)
 # $len - length of $data
 #
 # returns: 1 on success, otherwise check out the error stack to find out the reason
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p>
  </li>
  <li>use_RSAPrivateKey_file
    <p class="Pp">Adds the first RSA private key found in
        <span class="Li">$file</span> to <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::use_RSAPrivateKey_file($ssl, $file, $type);
 # $ssl - value corresponding to openssl's SSL structure
 # $file - (string) file name
 # $type - (integer) type - use constants &amp;Net::SSLeay::FILETYPE_PEM or &amp;Net::SSLeay::FILETYPE_ASN1
 #
 # returns: 1 on success, otherwise check out the error stack to find out the reason
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p>
  </li>
  <li>use_certificate
    <p class="Pp">Loads the certificate <span class="Li">$x</span> into
        <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::use_certificate($ssl, $x);
 # $ssl - value corresponding to openssl's SSL structure
 # $x - value corresponding to openssl's X509 structure
 #
 # returns: 1 on success, otherwise check out the error stack to find out the reason
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p>
  </li>
  <li>use_certificate_ASN1
    <p class="Pp">Loads the ASN1 encoded certificate from
        <span class="Li">$data</span> to <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::use_certificate_ASN1($ssl, $data, $len);
 # $ssl - value corresponding to openssl's SSL structure
 # $data - certificate data (binary)
 # $len - length of $data
 #
 # returns: 1 on success, otherwise check out the error stack to find out the reason
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p>
  </li>
  <li>use_certificate_chain_file
    <p class="Pp"><b>COMPATIBILITY</b>: not available in Net-SSLeay-1.82 and
        before; requires at least OpenSSL 1.1.0</p>
    <p class="Pp">Loads a certificate chain from <span class="Li">$file</span>
        into <span class="Li">$ssl</span>. The certificates must be in PEM
        format and must be sorted starting with the subject's certificate
        (actual client or server certificate), followed by intermediate CA
        certificates if applicable, and ending at the highest level (root)
      CA.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::use_certificate_chain_file($ssl, $file);
 # $ssl - value corresponding to openssl's SSL structure
 # $file - (string) file name
 #
 # returns: 1 on success, otherwise check out the error stack to find out the reason
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p>
  </li>
  <li>use_certificate_file
    <p class="Pp">Loads the first certificate stored in
        <span class="Li">$file</span> into <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::use_certificate_file($ssl, $file, $type);
 # $ssl - value corresponding to openssl's SSL structure
 # $file - (string) file name
 # $type - (integer) type - use constants &amp;Net::SSLeay::FILETYPE_PEM or &amp;Net::SSLeay::FILETYPE_ASN1
 #
 # returns: 1 on success, otherwise check out the error stack to find out the reason
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p>
  </li>
  <li>get_version
    <p class="Pp">Returns SSL/TLS protocol name</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::get_version($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: (string) protocol name, see OpenSSL manual for the full list
 #          TLSv1
 #          TLSv1.3
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/manmaster/man3/SSL_get_version.html&gt;</p>
  </li>
  <li>version
    <p class="Pp">Returns SSL/TLS protocol version</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::version($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: (integer) protocol version, see OpenSSL manual for the full list
 #          0x0301 - TLS1_VERSION  (TLSv1)
 #          0xFEFF - DTLS1_VERSION (DTLSv1)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/manmaster/man3/SSL_version.html&gt;</p>
  </li>
  <li>client_version
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and
        before; requires at least OpenSSL 1.1.0, not in LibreSSL</p>
    <p class="Pp">Returns TLS protocol version used by the client when
        initiating the connection</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::client_version($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: (integer) protocol version, see OpenSSL manual for the full list
 #          0x0301 - TLS1_VERSION  (TLSv1)
 #          0xFEFF - DTLS1_VERSION (DTLSv1)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/manmaster/man3/SSL_client_version.html&gt;</p>
  </li>
  <li>is_dtls
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and
        before; requires at least OpenSSL 1.1.0, not in LibreSSL</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::is_dtls($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: (integer) zero or one
 #          0 - connection is not using DTLS
 #          1 - connection is using DTLS
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/manmaster/man3/SSL_is_dtls.html&gt;</p>
  </li>
  <li>want
    <p class="Pp">Returns state information for the SSL object
        <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::want($ssl);
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: state
 #          1 - SSL_NOTHING
 #          2 - SSL_WRITING
 #          3 - SSL_READING
 #          4 - SSL_X509_LOOKUP
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_want.html&gt;</p>
  </li>
  <li>write
    <p class="Pp">Writes data from the buffer <span class="Li">$data</span> into
        the specified <span class="Li">$ssl</span> connection.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::write($ssl, $data);
 # $ssl - value corresponding to openssl's SSL structure
 # $data - data to be written
 #
 # returns: &gt;0 - (success) number of bytes actually written to the TLS/SSL connection
 #           0 - write not successful, probably the underlying connection was closed
 #          &lt;0 - error
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_write.html&gt;</p>
  </li>
  <li>write_ex
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and
        before; requires at least OpenSSL 1.1.1, not in LibreSSL</p>
    <p class="Pp">Writes data from the buffer <span class="Li">$data</span> into
        the specified <span class="Li">$ssl</span> connection.</p>
    <p class="Pp"></p>
    <pre>
 my ($len, $rv) = Net::SSLeay::write_ex($ssl, $data);
 # $ssl - value corresponding to openssl's SSL structure
 # $data - data to be written
 #
 # returns a list: two-item list consisting of number of bytes written,
 #                 and return code from SSL_write_ex()
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/manmaster/man3/SSL_write_ex.html&gt;</p>
  </li>
  <li>write_partial
    <p class="Pp"><b>NOTE:</b> Does not exactly correspond to any low level API
        function</p>
    <p class="Pp">Writes a fragment of data in <span class="Li">$data</span>
        from the buffer <span class="Li">$data</span> into the specified
        <span class="Li">$ssl</span> connection. This is a non-blocking function
        like <b>Net::SSLeay::write()</b>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::write_partial($ssl, $from, $count, $data);
 # $ssl - value corresponding to openssl's SSL structure
 # $from - (integer) offset from the beginning of $data
 # $count - (integer) length of data to be written
 # $data - data buffer
 #
 # returns: &gt;0 - (success) number of bytes actually written to the TLS/SSL connection
 #           0 - write not successful, probably the underlying connection was closed
 #          &lt;0 - error
    </pre>
  </li>
  <li>set_tlsext_host_name
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before; requires at least openssl-0.9.8f</p>
    <p class="Pp">Sets TLS servername extension on SLL object
        <span class="Li">$ssl</span> to value <span class="Li">$name</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = set_tlsext_host_name($ssl, $name);
 # $ssl - value corresponding to openssl's SSL structure
 # $name - (string) name to be set
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
</ul>
<p class="Pp"><i>Low level API: RAND_* related functions</i></p>
<p class="Pp">Check openssl doc related to RAND stuff
    &lt;http://www.openssl.org/docs/crypto/rand.html&gt;</p>
<ul class="Bl-bullet">
  <li>RAND_add
    <p class="Pp">Mixes the <span class="Li">$num</span> bytes at
        <span class="Li">$buf</span> into the PRNG state.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::RAND_add($buf, $num, $entropy);
 # $buf - buffer with data to be mixed into the PRNG state
 # $num - number of bytes in $buf
 # $entropy - estimate of how much randomness is contained in $buf (in bytes)
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/RAND_add.html&gt;</p>
  </li>
  <li>RAND_seed
    <p class="Pp">Equivalent to &quot;RAND_add&quot; when
        <span class="Li">$num</span> == <span class="Li">$entropy</span>.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::RAND_seed($buf);   # Perlishly figures out buf size
 # $buf - buffer with data to be mixed into the PRNG state
 # $num - number of bytes in $buf
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/RAND_add.html&gt;</p>
  </li>
  <li>RAND_status
    <p class="Pp">Gives PRNG status (seeded enough or not).</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::RAND_status();
 #returns: 1 if the PRNG has been seeded with enough data, 0 otherwise
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/RAND_add.html&gt;</p>
  </li>
  <li>RAND_bytes
    <p class="Pp">Puts <span class="Li">$num</span> cryptographically strong
        pseudo-random bytes into <span class="Li">$buf</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::RAND_bytes($buf, $num);
 # $buf - buffer where the random data will be stored
 # $num - the size (in bytes) of requested random data
 #
 # returns: 1 on success, -1 if not supported by the current RAND method, or 0 on other failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/manmaster/man3/RAND_bytes.html&gt;</p>
  </li>
  <li>RAND_priv_bytes
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.85 and
        before; requires at least OpenSSL 1.1.1, not in LibreSSL</p>
    <p class="Pp">Puts <span class="Li">$num</span> cryptographically strong
        pseudo-random bytes into <span class="Li">$buf</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::RAND_priv_bytes($buf, $num);
 # $buf - buffer where the random data will be stored
 # $num - the size (in bytes) of requested random data
 #
 # returns: 1 on success, -1 if not supported by the current RAND method, or 0 on other failure
    </pre>
    <p class="Pp">RAND_priv_bytes has the same semantics as RAND_bytes, but see
        see the documentation for more information.</p>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/manmaster/man3/RAND_priv_bytes.html&gt;</p>
  </li>
  <li>RAND_pseudo_bytes
    <p class="Pp">Puts <span class="Li">$num</span> pseudo-random (not
        necessarily unpredictable) bytes into <span class="Li">$buf</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::RAND_pseudo_bytes($buf, $num);
 # $buf - buffer where the random data will be stored
 # $num - the size (in bytes) of requested random data
 #
 # returns: 1 if the bytes generated are cryptographically strong, 0 otherwise
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/RAND_bytes.html&gt;</p>
  </li>
  <li>RAND_cleanup
    <p class="Pp">Erase the PRNG state.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::RAND_cleanup();
 # no args, no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/RAND_cleanup.html&gt;</p>
  </li>
  <li>RAND_egd_bytes
    <p class="Pp">Queries the entropy gathering daemon EGD on socket
        <span class="Li">$path</span> for <span class="Li">$bytes</span>
      bytes.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::RAND_egd_bytes($path, $bytes);
 # $path - path to a socket of entropy gathering daemon EGD
 # $bytes - number of bytes we want from EGD
 #
 # returns: the number of bytes read from the daemon on success, and -1 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/RAND_egd.html&gt;</p>
  </li>
  <li>RAND_file_name
    <p class="Pp">Generates a default path for the random seed file.</p>
    <p class="Pp"></p>
    <pre>
 my $file = Net::SSLeay::RAND_file_name($num);
 # $num - maximum size of returned file name
 #
 # returns: string with file name on success, '' (empty string) on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/RAND_load_file.html&gt;</p>
  </li>
  <li>RAND_load_file
    <p class="Pp"><b>COMPATIBILITY:</b> Is no longer functional on LibreSSL</p>
    <p class="Pp">Reads <span class="Li">$max_bytes</span> of bytes from
        <span class="Li">$file_name</span> and adds them to the PRNG.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::RAND_load_file($file_name, $max_bytes);
 # $file_name - the name of file
 # $max_bytes - bytes to read from $file_name; -1 =&gt; the complete file is read
 #
 # returns: the number of bytes read
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/RAND_load_file.html&gt;</p>
  </li>
  <li>RAND_write_file
    <p class="Pp">Writes 1024 random bytes to <span class="Li">$file_name</span>
        which can be used to initialize the PRNG by calling
        &quot;RAND_load_file&quot; in a later session.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::RAND_write_file($file_name);
 # $file_name - the name of file
 #
 # returns: the number of bytes written, and -1 if the bytes written were generated without appropriate seed
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/RAND_load_file.html&gt;</p>
  </li>
  <li>RAND_poll
    <p class="Pp">Collects some entropy from operating system and adds it to the
        PRNG.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::RAND_poll();
 # returns: 1 on success, 0 on failure (unable to gather reasonable entropy)
    </pre>
  </li>
</ul>
<p class="Pp"><i>Low level API: OBJ_* related functions</i></p>
<ul class="Bl-bullet">
  <li>OBJ_cmp
    <p class="Pp">Compares ASN1_OBJECT <span class="Li">$a</span> to ASN1_OBJECT
        <span class="Li">$b</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::OBJ_cmp($a, $b);
 # $a - value corresponding to openssl's ASN1_OBJECT structure
 # $b - value corresponding to openssl's ASN1_OBJECT structure
 #
 # returns: if the two are identical 0 is returned
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/OBJ_nid2obj.html&gt;</p>
  </li>
  <li>OBJ_dup
    <p class="Pp">Returns a copy/duplicate of <span class="Li">$o</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::OBJ_dup($o);
 # $o - value corresponding to openssl's ASN1_OBJECT structure
 #
 # returns: value corresponding to openssl's ASN1_OBJECT structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/OBJ_nid2obj.html&gt;</p>
  </li>
  <li>OBJ_nid2ln
    <p class="Pp">Returns long name for given NID
      <span class="Li">$n</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::OBJ_nid2ln($n);
 # $n - (integer) NID
 #
 # returns: (string) long name e.g. 'commonName'
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/OBJ_nid2obj.html&gt;</p>
  </li>
  <li>OBJ_ln2nid
    <p class="Pp">Returns NID corresponding to given long name
        <span class="Li">$n</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::OBJ_ln2nid($s);
 # $s - (string) long name e.g. 'commonName'
 #
 # returns: (integer) NID
    </pre>
  </li>
  <li>OBJ_nid2sn
    <p class="Pp">Returns short name for given NID
      <span class="Li">$n</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::OBJ_nid2sn($n);
 # $n - (integer) NID
 #
 # returns: (string) short name e.g. 'CN'
    </pre>
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>
 print Net::SSLeay::OBJ_nid2sn(&amp;Net::SSLeay::NID_commonName);
    </pre>
  </li>
  <li>OBJ_sn2nid
    <p class="Pp">Returns NID corresponding to given short name
        <span class="Li">$s</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::OBJ_sn2nid($s);
 # $s - (string) short name e.g. 'CN'
 #
 # returns: (integer) NID
    </pre>
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>
 print &quot;NID_commonName constant=&quot;, &amp;Net::SSLeay::NID_commonName;
 print &quot;OBJ_sn2nid('CN')=&quot;, Net::SSLeay::OBJ_sn2nid('CN');
    </pre>
  </li>
  <li>OBJ_nid2obj
    <p class="Pp">Returns ASN1_OBJECT for given NID
      <span class="Li">$n</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::OBJ_nid2obj($n);
 # $n - (integer) NID
 #
 # returns: value corresponding to openssl's ASN1_OBJECT structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/OBJ_nid2obj.html&gt;</p>
  </li>
  <li>OBJ_obj2nid
    <p class="Pp">Returns NID corresponding to given ASN1_OBJECT
        <span class="Li">$o</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::OBJ_obj2nid($o);
 # $o - value corresponding to openssl's ASN1_OBJECT structure
 #
 # returns: (integer) NID
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/OBJ_nid2obj.html&gt;</p>
  </li>
  <li>OBJ_txt2obj
    <p class="Pp">Converts the text string s into an ASN1_OBJECT structure. If
        <span class="Li">$no_name</span> is 0 then long names (e.g.
        'commonName') and short names (e.g. 'CN') will be interpreted as well as
        numerical forms (e.g. '2.5.4.3'). If <span class="Li">$no_name</span> is
        1 only the numerical form is acceptable.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::OBJ_txt2obj($s, $no_name);
 # $s - text string to be converted
 # $no_name - (integer) 0 or 1
 #
 # returns: value corresponding to openssl's ASN1_OBJECT structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/OBJ_nid2obj.html&gt;</p>
  </li>
  <li>OBJ_obj2txt
    <p class="Pp">Converts the ASN1_OBJECT a into a textual representation.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::OBJ_obj2txt($a, $no_name);
 # $a - value corresponding to openssl's ASN1_OBJECT structure
 # $no_name - (integer) 0 or 1
 #
 # returns: textual representation e.g. 'commonName' ($no_name=0), '2.5.4.3' ($no_name=1)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/OBJ_nid2obj.html&gt;</p>
  </li>
  <li>OBJ_txt2nid
    <p class="Pp">Returns NID corresponding to text string
        <span class="Li">$s</span> which can be a long name, a short name or the
        numerical representation of an object.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::OBJ_txt2nid($s);
 # $s - (string) e.g. 'commonName' or 'CN' or '2.5.4.3'
 #
 # returns: (integer) NID
    </pre>
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>
 my $nid = Net::SSLeay::OBJ_txt2nid('2.5.4.3');
 Net::SSLeay::OBJ_nid2sn($n);
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/OBJ_nid2obj.html&gt;</p>
  </li>
</ul>
<p class="Pp"><i>Low level API: ASN1_INTEGER_* related functions</i></p>
<ul class="Bl-bullet">
  <li>ASN1_INTEGER_new
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Creates a new ASN1_INTEGER structure.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::ASN1_INTEGER_new();
 #
 # returns: value corresponding to openssl's ASN1_INTEGER structure (0 on failure)
    </pre>
  </li>
  <li>ASN1_INTEGER_free
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Free an allocated ASN1_INTEGER structure.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::ASN1_INTEGER_free($i);
 # $i - value corresponding to openssl's ASN1_INTEGER structure
 #
 # returns: no return value
    </pre>
  </li>
  <li>ASN1_INTEGER_get
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Returns integer value of given ASN1_INTEGER object.</p>
    <p class="Pp"><b>BEWARE:</b> If the value stored in ASN1_INTEGER is greater
        than max. integer that can be stored in 'long' type (usually 32bit but
        may vary according to platform) then this function will return -1. For
        getting large ASN1_INTEGER values consider using
        &quot;P_ASN1_INTEGER_get_dec&quot; or
        &quot;P_ASN1_INTEGER_get_hex&quot;.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::ASN1_INTEGER_get($a);
 # $a - value corresponding to openssl's ASN1_INTEGER structure
 #
 # returns: integer value of ASN1_INTEGER object in $a
    </pre>
  </li>
  <li>ASN1_INTEGER_set
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Sets value of given ASN1_INTEGER object to value
        <span class="Li">$val</span></p>
    <p class="Pp"><b>BEWARE:</b> <span class="Li">$val</span> has max. limit (=
        max. integer that can be stored in 'long' type). For setting large
        ASN1_INTEGER values consider using &quot;P_ASN1_INTEGER_set_dec&quot; or
        &quot;P_ASN1_INTEGER_set_hex&quot;.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::ASN1_INTEGER_set($i, $val);
 # $i - value corresponding to openssl's ASN1_INTEGER structure
 # $val - integer value
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>P_ASN1_INTEGER_get_dec
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Returns string with decimal representation of integer value of
        given ASN1_INTEGER object.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::P_ASN1_INTEGER_get_dec($i);
 # $i - value corresponding to openssl's ASN1_INTEGER structure
 #
 # returns: string with decimal representation
    </pre>
  </li>
  <li>P_ASN1_INTEGER_get_hex
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Returns string with hexadecimal representation of integer
        value of given ASN1_INTEGER object.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::P_ASN1_INTEGER_get_hex($i);
 # $i - value corresponding to openssl's ASN1_INTEGER structure
 #
 # returns: string with hexadecimal representation
    </pre>
  </li>
  <li>P_ASN1_INTEGER_set_dec
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Sets value of given ASN1_INTEGER object to value
        <span class="Li">$val</span> (decimal string, suitable for large
        integers)</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::P_ASN1_INTEGER_set_dec($i, $str);
 # $i - value corresponding to openssl's ASN1_INTEGER structure
 # $str - string with decimal representation
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>P_ASN1_INTEGER_set_hex
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Sets value of given ASN1_INTEGER object to value
        <span class="Li">$val</span> (hexadecimal string, suitable for large
        integers)</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::P_ASN1_INTEGER_set_hex($i, $str);
 # $i - value corresponding to openssl's ASN1_INTEGER structure
 # $str - string with hexadecimal representation
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
</ul>
<p class="Pp"><i>Low level API: ASN1_STRING_* related functions</i></p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>P_ASN1_STRING_get
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Returns string value of given ASN1_STRING object.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::P_ASN1_STRING_get($s, $utf8_decode);
 # $s - value corresponding to openssl's ASN1_STRING structure
 # $utf8_decode - [optional] 0 or 1 whether the returned value should be utf8 decoded (default=0)
 #
 # returns: string

 $string = Net::SSLeay::P_ASN1_STRING_get($s);
 #is the same as:
 $string = Net::SSLeay::P_ASN1_STRING_get($s, 0);
    </pre>
  </dd>
</dl>
<p class="Pp"><i>Low level API: ASN1_TIME_* related functions</i></p>
<ul class="Bl-bullet">
  <li>ASN1_TIME_new
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and
        before</p>
    <p class="Pp"></p>
    <pre>
 my $time = ASN1_TIME_new();
 # returns: value corresponding to openssl's ASN1_TIME structure
    </pre>
  </li>
  <li>ASN1_TIME_free
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and
        before</p>
    <p class="Pp"></p>
    <pre>
 ASN1_TIME_free($time);
 # $time - value corresponding to openssl's ASN1_TIME structure
    </pre>
  </li>
  <li>ASN1_TIME_set
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and
        before</p>
    <p class="Pp"></p>
    <pre>
 ASN1_TIME_set($time, $t);
 # $time - value corresponding to openssl's ASN1_TIME structure
 # $t - time value in seconds since 1.1.1970
    </pre>
    <p class="Pp"><b>BEWARE:</b> It is platform dependent how this function will
        handle dates after 2038. Although perl's integer is large enough the
        internal implementation of this function is dependent on the size of
        time_t structure (32bit time_t has problem with 2038).</p>
    <p class="Pp">If you want to safely set date and time after 2038 use
        function &quot;P_ASN1_TIME_set_isotime&quot;.</p>
  </li>
  <li>P_ASN1_TIME_get_isotime
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and
        before; requires at least openssl-0.9.7e</p>
    <p class="Pp"><b>NOTE:</b> Does not exactly correspond to any low level API
        function</p>
    <p class="Pp">Gives ISO-8601 string representation of ASN1_TIME
      structure.</p>
    <p class="Pp"></p>
    <pre>
 my $datetime_string = P_ASN1_TIME_get_isotime($time);
 # $time - value corresponding to openssl's ASN1_TIME structure
 #
 # returns: datetime string like '2033-05-16T20:39:37Z' or '' on failure
    </pre>
    <p class="Pp">The output format is compatible with module
        DateTime::Format::RFC3339</p>
  </li>
  <li>P_ASN1_TIME_set_isotime
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and
        before; requires at least openssl-0.9.7e</p>
    <p class="Pp"><b>NOTE:</b> Does not exactly correspond to any low level API
        function</p>
    <p class="Pp">Sets time and date value of ANS1_time structure.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = P_ASN1_TIME_set_isotime($time, $string);
 # $time - value corresponding to openssl's ASN1_TIME structure
 # $string - ISO-8601 timedate string like '2033-05-16T20:39:37Z'
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">The <span class="Li">$string</span> parameter has to be in
        full form like <span class="Li">&quot;2012-03-22T23:55:33&quot;</span>
        or <span class="Li">&quot;2012-03-22T23:55:33Z&quot;</span> or
        <span class="Li">&quot;2012-03-22T23:55:33CET&quot;</span>. Short forms
        like <span class="Li">&quot;2012-03-22T23:55&quot;</span> or
        <span class="Li">&quot;2012-03-22&quot;</span> are not supported.</p>
  </li>
  <li>P_ASN1_TIME_put2string
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and
        before, has bugs with openssl-0.9.8i</p>
    <p class="Pp"><b>NOTE:</b> Does not exactly correspond to any low level API
        function</p>
    <p class="Pp">Gives string representation of ASN1_TIME structure.</p>
    <p class="Pp"></p>
    <pre>
 my $str = P_ASN1_TIME_put2string($time);
 # $time - value corresponding to openssl's ASN1_TIME structure
 #
 # returns: datetime string like 'May 16 20:39:37 2033 GMT'
    </pre>
  </li>
  <li>P_ASN1_UTCTIME_put2string
    <p class="Pp"><b>NOTE:</b> deprecated function, only for backward
        compatibility, just an alias for &quot;P_ASN1_TIME_put2string&quot;</p>
  </li>
</ul>
<p class="Pp"><i>Low level API: X509_* related functions</i></p>
<ul class="Bl-bullet">
  <li>X509_new
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Allocates and initializes a X509 structure.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_new();
 #
 # returns: value corresponding to openssl's X509 structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/X509_new.html&gt;</p>
  </li>
  <li>X509_free
    <p class="Pp">Frees up the X509 structure.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::X509_free($a);
 # $a - value corresponding to openssl's X509 structure
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/X509_new.html&gt;</p>
  </li>
  <li>X509_check_host
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.68 and
        before; requires at least OpenSSL 1.0.2.
        X509_CHECK_FLAG_NEVER_CHECK_SUBJECT requires OpenSSL 1.1.0.</p>
    <p class="Pp">Checks f the certificate Subject Alternative Name (SAN) or
        Subject CommonName (CN) matches the specified host name.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_check_host($cert, $name, $flags, $peername);
 # $cert - value corresponding to openssl's X509 structure
 # $name - host name to check
 # $flags (optional, default: 0) - can be the bitwise OR of:
 #   &amp;Net::SSLeay::X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT
 #   &amp;Net::SSLeay::X509_CHECK_FLAG_NO_WILDCARDS
 #   &amp;Net::SSLeay::X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS
 #   &amp;Net::SSLeay::X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS
 #   &amp;Net::SSLeay::X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS
 #   &amp;Net::SSLeay::X509_CHECK_FLAG_NEVER_CHECK_SUBJECT
 # $peername (optional) - If not omitted and $host matches $cert,
 #                        a copy of the matching SAN or CN from
 #                        the peer certificate is stored in $peername.
 #
 # returns:
 #   1 for a successful match
 #   0 for a failed match
 #  -1 for an internal error
 #  -2 if the input is malformed
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/crypto/X509_check_host.html&gt;.</p>
  </li>
  <li>X509_check_email
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.68 and
        before; requires at least OpenSSL 1.0.2.</p>
    <p class="Pp">Checks if the certificate matches the specified email
      address.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_check_email($cert, $address, $flags);
 # $cert - value corresponding to openssl's X509 structure
 # $address - email address to check
 # $flags (optional, default: 0) - see X509_check_host()
 #
 # returns: see X509_check_host()
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/crypto/X509_check_email.html&gt;.</p>
  </li>
  <li>X509_check_ip
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.68 and
        before; requires at least OpenSSL 1.0.2.</p>
    <p class="Pp">Checks if the certificate matches the specified IPv4 or IPv6
        address.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_check_email($cert, $address, $flags);
 # $cert - value corresponding to openssl's X509 structure
 # $address - IP address to check in binary format, in network byte order
 # $flags (optional, default: 0) - see X509_check_host()
 #
 # returns: see X509_check_host()
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/crypto/X509_check_ip.html&gt;.</p>
  </li>
  <li>X509_check_ip_asc
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.68 and
        before; requires at least OpenSSL 1.0.2.</p>
    <p class="Pp">Checks if the certificate matches the specified IPv4 or IPv6
        address.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_check_email($cert, $address, $flags);
 # $cert - value corresponding to openssl's X509 structure
 # $address - IP address to check in text representation
 # $flags (optional, default: 0) - see X509_check_host()
 #
 # returns: see X509_check_host()
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/crypto/X509_check_ip_asc.html&gt;.</p>
  </li>
  <li>X509_certificate_type
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Returns bitmask with type of certificate
        <span class="Li">$x</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_certificate_type($x);
 # $x - value corresponding to openssl's X509 structure
 #
 # returns: (integer) bitmask with certificate type

 #to decode bitmask returned by this function use these constants:
 &amp;Net::SSLeay::EVP_PKS_DSA
 &amp;Net::SSLeay::EVP_PKS_EC
 &amp;Net::SSLeay::EVP_PKS_RSA
 &amp;Net::SSLeay::EVP_PKT_ENC
 &amp;Net::SSLeay::EVP_PKT_EXCH
 &amp;Net::SSLeay::EVP_PKT_EXP
 &amp;Net::SSLeay::EVP_PKT_SIGN
 &amp;Net::SSLeay::EVP_PK_DH
 &amp;Net::SSLeay::EVP_PK_DSA
 &amp;Net::SSLeay::EVP_PK_EC
 &amp;Net::SSLeay::EVP_PK_RSA
    </pre>
  </li>
  <li>X509_digest
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Computes digest/fingerprint of X509
        <span class="Li">$data</span> using <span class="Li">$type</span> hash
        function.</p>
    <p class="Pp"></p>
    <pre>
 my $digest_value = Net::SSLeay::X509_digest($data, $type);
 # $data - value corresponding to openssl's X509 structure
 # $type - value corresponding to openssl's EVP_MD structure - e.g. got via EVP_get_digestbyname()
 #
 # returns: hash value (binary)

 #to get printable (hex) value of digest use:
 print unpack('H*', $digest_value);
    </pre>
  </li>
  <li>X509_issuer_and_serial_hash
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Sort of a checksum of issuer name and serial number of X509
        certificate <span class="Li">$x</span>. The result is not a full hash
        (e.g. sha-1), it is kind-of-a-hash truncated to the size of 'unsigned
        long' (32 bits). The resulting value might differ across different
        openssl versions for the same X509 certificate.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_issuer_and_serial_hash($x);
 # $x - value corresponding to openssl's X509 structure
 #
 # returns: number representing checksum
    </pre>
  </li>
  <li>X509_issuer_name_hash
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Sort of a checksum of issuer name of X509 certificate
        <span class="Li">$x</span>. The result is not a full hash (e.g. sha-1),
        it is kind-of-a-hash truncated to the size of 'unsigned long' (32 bits).
        The resulting value might differ across different openssl versions for
        the same X509 certificate.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_issuer_name_hash($x);
 # $x - value corresponding to openssl's X509 structure
 #
 # returns: number representing checksum
    </pre>
  </li>
  <li>X509_subject_name_hash
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Sort of a checksum of subject name of X509 certificate
        <span class="Li">$x</span>. The result is not a full hash (e.g. sha-1),
        it is kind-of-a-hash truncated to the size of 'unsigned long' (32 bits).
        The resulting value might differ across different openssl versions for
        the same X509 certificate.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_subject_name_hash($x);
 # $x - value corresponding to openssl's X509 structure
 #
 # returns: number representing checksum
    </pre>
  </li>
  <li>X509_pubkey_digest
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before; requires at least openssl-0.9.7</p>
    <p class="Pp">Computes digest/fingerprint of public key from X509
        certificate <span class="Li">$data</span> using
        <span class="Li">$type</span> hash function.</p>
    <p class="Pp"></p>
    <pre>
 my $digest_value = Net::SSLeay::X509_pubkey_digest($data, $type);
 # $data - value corresponding to openssl's X509 structure
 # $type - value corresponding to openssl's EVP_MD structure - e.g. got via EVP_get_digestbyname()
 #
 # returns: hash value (binary)

 #to get printable (hex) value of digest use:
 print unpack('H*', $digest_value);
    </pre>
  </li>
  <li>X509_set_issuer_name
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Sets issuer of X509 certificate <span class="Li">$x</span> to
        <span class="Li">$name</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_set_issuer_name($x, $name);
 # $x - value corresponding to openssl's X509 structure
 # $name - value corresponding to openssl's X509_NAME structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>X509_set_pubkey
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Sets public key of X509 certificate <span class="Li">$x</span>
        to <span class="Li">$pkey</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_set_pubkey($x, $pkey);
 # $x - value corresponding to openssl's X509 structure
 # $pkey - value corresponding to openssl's EVP_PKEY structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>X509_set_serialNumber
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Sets serial number of X509 certificate
        <span class="Li">$x</span> to <span class="Li">$serial</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_set_serialNumber($x, $serial);
 # $x - value corresponding to openssl's X509 structure
 # $serial - value corresponding to openssl's ASN1_INTEGER structure
 #
 # returns: 1 on success, 0 on failure

 #to create $serial value use one of these:
 $serial = Net::SSLeay::P_ASN1_INTEGER_set_hex('45ad6f');
 $serial = Net::SSLeay::P_ASN1_INTEGER_set_dec('7896541238529631478');
 $serial = Net::SSLeay::ASN1_INTEGER_set(45896);
    </pre>
  </li>
  <li>X509_set_subject_name
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Sets subject of X509 certificate <span class="Li">$x</span> to
        <span class="Li">$name</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_set_subject_name($x, $name);
 # $x - value corresponding to openssl's X509 structure
 # $name - value corresponding to openssl's X509_NAME structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>X509_set_version
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Set 'version' value for X509 certificate $ to
        <span class="Li">$version</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_set_version($x, $version);
 # $x - value corresponding to openssl's X509 structure
 # $version - (integer) version number
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>X509_sign
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Sign X509 certificate <span class="Li">$x</span> with private
        key <span class="Li">$pkey</span> (using digest algorithm
        <span class="Li">$md</span>).</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_sign($x, $pkey, $md);
 # $x - value corresponding to openssl's X509 structure
 # $pkey - value corresponding to openssl's EVP_PKEY structure
 # $md - value corresponding to openssl's EVP_MD structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>X509_verify
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Verifies X509 object <span class="Li">$a</span> using public
        key <span class="Li">$r</span> (pubkey of issuing CA).</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_verify($x, $r);
 # $x - value corresponding to openssl's X509 structure
 # $r - value corresponding to openssl's EVP_PKEY structure
 #
 # returns: 0 - verify failure, 1 - verify OK, &lt;0 - error
    </pre>
  </li>
  <li>X509_get_ext_count
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Returns the total number of extensions in X509 object
        <span class="Li">$x</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_get_ext_count($x);
 # $x - value corresponding to openssl's X509 structure
 #
 # returns: count of extensions
    </pre>
  </li>
  <li>X509_get_pubkey
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Returns public key corresponding to given X509 object
        <span class="Li">$x</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_get_pubkey($x);
 # $x - value corresponding to openssl's X509 structure
 #
 # returns: value corresponding to openssl's EVP_PKEY structure (0 on failure)
    </pre>
    <p class="Pp"><b>NOTE:</b> This method returns only the public key's key
        bits, without the algorithm or parameters. Use
        <span class="Li">&quot;X509_get_X509_PUBKEY()&quot;</span> to return the
        full public key (SPKI) instead.</p>
  </li>
  <li>X509_get_X509_PUBKEY
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.72 and
        before</p>
    <p class="Pp">Returns the full public key (SPKI) of given X509 certificate
        <span class="Li">$x</span>.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::X509_get_X509_PUBKEY($x);
 # $x - value corresponding to openssl's X509 structure
 #
 # returns: public key data in DER format (binary)
    </pre>
  </li>
  <li>X509_get_serialNumber
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Returns serial number of X509 certificate
        <span class="Li">$x</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_get_serialNumber($x);
 # $x - value corresponding to openssl's X509 structure
 #
 # returns: value corresponding to openssl's ASN1_INTEGER structure (0 on failure)
    </pre>
    <p class="Pp">See &quot;P_ASN1_INTEGER_get_dec&quot;,
        &quot;P_ASN1_INTEGER_get_hex&quot; or &quot;ASN1_INTEGER_get&quot; to
        decode ASN1_INTEGER object.</p>
  </li>
  <li>X509_get0_serialNumber
    <p class="Pp"><b>COMPATIBILITY:</b> available in Net-SSLeay-1.86 onwards</p>
    <p class="Pp"><b>X509_get0_serialNumber()</b> is the same as
        <b>X509_get_serialNumber()</b> except it accepts a const parameter and
        returns a const result.</p>
  </li>
  <li>X509_get_version
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Returns 'version' value of given X509 certificate
        <span class="Li">$x</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_get_version($x);
 # $x - value corresponding to openssl's X509 structure
 #
 # returns: (integer) version
    </pre>
  </li>
  <li>X509_get_ext
    <p class="Pp">Returns X509_EXTENSION from <span class="Li">$x509</span>
        based on given position/index.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_get_ext($x509, $index);
 # $x509 - value corresponding to openssl's X509 structure
 # $index - (integer) position/index of extension within $x509
 #
 # returns: value corresponding to openssl's X509_EXTENSION structure (0 on failure)
    </pre>
  </li>
  <li>X509_get_ext_by_NID
    <p class="Pp">Returns X509_EXTENSION from <span class="Li">$x509</span>
        based on given NID.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_get_ext_by_NID($x509, $nid, $loc);
 # $x509 - value corresponding to openssl's X509 structure
 # $nid - (integer) NID value
 # $loc - (integer) position to start lookup at
 #
 # returns: position/index of extension, negative value on error
 #          call Net::SSLeay::X509_get_ext($x509, $rv) to get the actual extension
    </pre>
  </li>
  <li>X509_get_fingerprint
    <p class="Pp">Returns fingerprint of certificate
        <span class="Li">$cert</span>.</p>
    <p class="Pp"><b>NOTE:</b> Does not exactly correspond to any low level API
        function. The implementation is basen on openssl's
        <span class="Li">&quot;X509_digest()&quot;</span>.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::X509_get_fingerprint($x509, $type);
 # $x509 - value corresponding to openssl's X509 structure
 # $type - (string) digest type, currently supported values:
 #         &quot;md5&quot;
 #         &quot;sha1&quot;
 #         &quot;sha256&quot;
 #         &quot;ripemd160&quot;
 #
 # returns: certificate digest - hexadecimal string (NOT binary data!)
    </pre>
  </li>
  <li>X509_get_issuer_name
    <p class="Pp">Return an X509_NAME object representing the issuer of the
        certificate <span class="Li">$cert</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_get_issuer_name($cert);
 # $cert - value corresponding to openssl's X509 structure
 #
 # returns: value corresponding to openssl's X509_NAME structure (0 on failure)
    </pre>
  </li>
  <li>X509_get_notAfter
    <p class="Pp">Return an object giving the time after which the certificate
        <span class="Li">$cert</span> is not valid.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_get_notAfter($cert);
 # $cert - value corresponding to openssl's X509 structure
 #
 # returns: value corresponding to openssl's ASN1_TIME structure (0 on failure)
    </pre>
    <p class="Pp">To get human readable/printable form the return value you can
        use:</p>
    <p class="Pp"></p>
    <pre>
 my $time = Net::SSLeay::X509_get_notAfter($cert);
 print &quot;notAfter=&quot;, Net::SSLeay::P_ASN1_TIME_get_isotime($time), &quot;\n&quot;;
    </pre>
  </li>
  <li>X509_get_notBefore
    <p class="Pp">Return an object giving the time before which the certificate
        <span class="Li">$cert</span> is not valid</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_get_notBefore($cert);
 # $cert - value corresponding to openssl's X509 structure
 #
 # returns: value corresponding to openssl's ASN1_TIME structure (0 on failure)
    </pre>
    <p class="Pp">To get human readable/printable form the return value you can
        use:</p>
    <p class="Pp"></p>
    <pre>
 my $time = Net::SSLeay::X509_get_notBefore($cert);
 print &quot;notBefore=&quot;, Net::SSLeay::P_ASN1_TIME_get_isotime($time), &quot;\n&quot;;
    </pre>
  </li>
  <li>X509_get_subjectAltNames
    <p class="Pp"><b>NOTE:</b> Does not exactly correspond to any low level API
        function.</p>
    <p class="Pp">Returns the list of alternative subject names from X509
        certificate <span class="Li">$cert</span>.</p>
    <p class="Pp"></p>
    <pre>
 my @rv = Net::SSLeay::X509_get_subjectAltNames($cert);
 # $cert - value corresponding to openssl's X509 structure
 #
 # returns: list containing pairs - name_type (integer), name_value (string)
 #          where name_type can be:
 #          0 - GEN_OTHERNAME
 #          1 - GEN_EMAIL
 #          2 - GEN_DNS
 #          3 - GEN_X400
 #          4 - GEN_DIRNAME
 #          5 - GEN_EDIPARTY
 #          6 - GEN_URI
 #          7 - GEN_IPADD
 #          8 - GEN_RID
    </pre>
    <p class="Pp">Note: type 7 - GEN_IPADD contains the IP address as a packed
        binary address.</p>
  </li>
  <li>X509_get_subject_name
    <p class="Pp">Returns the subject of the certificate
        <span class="Li">$cert</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_get_subject_name($cert);
 # $cert - value corresponding to openssl's X509 structure
 #
 # returns: value corresponding to openssl's X509_NAME structure (0 on failure)
    </pre>
  </li>
  <li>X509_gmtime_adj
    <p class="Pp">Adjust th ASN1_TIME object to the timestamp (in GMT).</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_gmtime_adj($s, $adj);
 # $s - value corresponding to openssl's ASN1_TIME structure
 # $adj - timestamp (seconds since 1.1.1970)
 #
 # returns: value corresponding to openssl's ASN1_TIME structure (0 on failure)
    </pre>
    <p class="Pp"><b>BEWARE:</b> this function may fail for dates after 2038 as
        it is dependent on time_t size on your system (32bit time_t does not
        work after 2038). Consider using &quot;P_ASN1_TIME_set_isotime&quot;
        instead).</p>
  </li>
  <li>X509_load_cert_crl_file
    <p class="Pp">Takes PEM file and loads all X509 certificates and X509 CRLs
        from that file into X509_LOOKUP structure.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_load_cert_crl_file($ctx, $file, $type);
 # $ctx - value corresponding to openssl's X509_LOOKUP structure
 # $file - (string) file name
 # $type - (integer) type - use constants &amp;Net::SSLeay::FILETYPE_PEM or &amp;Net::SSLeay::FILETYPE_ASN1
 #                          if not FILETYPE_PEM then behaves as Net::SSLeay::X509_load_cert_file()
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>X509_load_cert_file
    <p class="Pp">Loads/adds X509 certificate from <span class="Li">$file</span>
        to X509_LOOKUP structure</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_load_cert_file($ctx, $file, $type);
 # $ctx - value corresponding to openssl's X509_LOOKUP structure
 # $file - (string) file name
 # $type - (integer) type - use constants &amp;Net::SSLeay::FILETYPE_PEM or &amp;Net::SSLeay::FILETYPE_ASN1
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>X509_load_crl_file
    <p class="Pp">Loads/adds X509 CRL from <span class="Li">$file</span> to
        X509_LOOKUP structure</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_load_crl_file($ctx, $file, $type);
 # $ctx - value corresponding to openssl's X509_LOOKUP structure
 # $file - (string) file name
 # $type - (integer) type - use constants &amp;Net::SSLeay::FILETYPE_PEM or &amp;Net::SSLeay::FILETYPE_ASN1
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>X509_policy_level_get0_node
    <p class="Pp">??? (more info needed)</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_policy_level_get0_node($level, $i);
 # $level - value corresponding to openssl's X509_POLICY_LEVEL structure
 # $i - (integer) index/position
 #
 # returns: value corresponding to openssl's X509_POLICY_NODE structure (0 on failure)
    </pre>
  </li>
  <li>X509_policy_level_node_count
    <p class="Pp">??? (more info needed)</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_policy_level_node_count($level);
 # $level - value corresponding to openssl's X509_POLICY_LEVEL structure
 #
 # returns: (integer) node count
    </pre>
  </li>
  <li>X509_policy_node_get0_parent
    <p class="Pp">??? (more info needed)</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_policy_node_get0_parent($node);
 # $node - value corresponding to openssl's X509_POLICY_NODE structure
 #
 # returns: value corresponding to openssl's X509_POLICY_NODE structure (0 on failure)
    </pre>
  </li>
  <li>X509_policy_node_get0_policy
    <p class="Pp">??? (more info needed)</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_policy_node_get0_policy($node);
 # $node - value corresponding to openssl's X509_POLICY_NODE structure
 #
 # returns: value corresponding to openssl's ASN1_OBJECT structure (0 on failure)
    </pre>
  </li>
  <li>X509_policy_node_get0_qualifiers
    <p class="Pp">??? (more info needed)</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_policy_node_get0_qualifiers($node);
 # $node - value corresponding to openssl's X509_POLICY_NODE structure
 #
 # returns: value corresponding to openssl's STACK_OF(POLICYQUALINFO) structure (0 on failure)
    </pre>
  </li>
  <li>X509_policy_tree_free
    <p class="Pp">??? (more info needed)</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::X509_policy_tree_free($tree);
 # $tree - value corresponding to openssl's X509_POLICY_TREE structure
 #
 # returns: no return value
    </pre>
  </li>
  <li>X509_policy_tree_get0_level
    <p class="Pp">??? (more info needed)</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_policy_tree_get0_level($tree, $i);
 # $tree - value corresponding to openssl's X509_POLICY_TREE structure
 # $i - (integer) level index
 #
 # returns: value corresponding to openssl's X509_POLICY_LEVEL structure (0 on failure)
    </pre>
  </li>
  <li>X509_policy_tree_get0_policies
    <p class="Pp">??? (more info needed)</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_policy_tree_get0_policies($tree);
 # $tree - value corresponding to openssl's X509_POLICY_TREE structure
 #
 # returns: value corresponding to openssl's X509_POLICY_NODE structure (0 on failure)
    </pre>
  </li>
  <li>X509_policy_tree_get0_user_policies
    <p class="Pp">??? (more info needed)</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_policy_tree_get0_user_policies($tree);
 # $tree - value corresponding to openssl's X509_POLICY_TREE structure
 #
 # returns: value corresponding to openssl's X509_POLICY_NODE structure (0 on failure)
    </pre>
  </li>
  <li>X509_policy_tree_level_count
    <p class="Pp">??? (more info needed)</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_policy_tree_level_count($tree);
 # $tree - value corresponding to openssl's X509_POLICY_TREE structure
 #
 # returns: (integer) count
    </pre>
  </li>
  <li>X509_verify_cert_error_string
    <p class="Pp">Returns a human readable error string for verification error
        <span class="Li">$n</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_verify_cert_error_string($n);
 # $n - (long) numeric error code
 #
 # returns: error string
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/X509_STORE_CTX_get_error.html&gt;</p>
  </li>
  <li>P_X509_add_extensions
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Adds one or more X509 extensions to X509 object
        <span class="Li">$x</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::P_X509_add_extensions($x, $ca_cert, $nid, $value);
 # $x - value corresponding to openssl's X509 structure
 # $ca_cert - value corresponding to openssl's X509 structure (issuer's cert - necessary for sertting NID_authority_key_identifier)
 # $nid - NID identifying extension to be set
 # $value - extension value
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">You can set more extensions at once:</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::P_X509_add_extensions($x509, $ca_cert,
                &amp;Net::SSLeay::NID_key_usage =&gt; 'digitalSignature,keyEncipherment',
                &amp;Net::SSLeay::NID_subject_key_identifier =&gt; 'hash',
                &amp;Net::SSLeay::NID_authority_key_identifier =&gt; 'keyid',
                &amp;Net::SSLeay::NID_authority_key_identifier =&gt; 'issuer',
                &amp;Net::SSLeay::NID_basic_constraints =&gt; 'CA:FALSE',
                &amp;Net::SSLeay::NID_ext_key_usage =&gt; 'serverAuth,clientAuth',
                &amp;Net::SSLeay::NID_netscape_cert_type =&gt; 'server',
                &amp;Net::SSLeay::NID_subject_alt_name =&gt; 'DNS:s1.dom.com,DNS:s2.dom.com,DNS:s3.dom.com',
          );
    </pre>
  </li>
  <li>P_X509_copy_extensions
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Copies X509 extensions from X509_REQ object to X509 object -
        handy when you need to turn X509_REQ into X509 certificate.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::P_X509_copy_extensions($x509_req, $x509, $override);
 # $x509_req - value corresponding to openssl's X509_REQ structure
 # $x509 - value corresponding to openssl's X509 structure
 # $override - (integer) flag indication whether to override already existing items in $x509 (default 1)
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>P_X509_get_crl_distribution_points
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before; requires at least openssl-0.9.7</p>
    <p class="Pp">Get the list of CRL distribution points from X509
      certificate.</p>
    <p class="Pp"></p>
    <pre>
 my @cdp = Net::SSLeay::P_X509_get_crl_distribution_points($x509);
 # $x509 - value corresponding to openssl's X509 structure
 #
 # returns: list of distribution points (usually URLs)
    </pre>
  </li>
  <li>P_X509_get_ext_key_usage
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before; requires at least openssl-0.9.7</p>
    <p class="Pp">Gets the list of extended key usage of given X509 certificate
        <span class="Li">$cert</span>.</p>
    <p class="Pp"></p>
    <pre>
 my @ext_usage = Net::SSLeay::P_X509_get_ext_key_usage($cert, $format);
 # $cert - value corresponding to openssl's X509 structure
 # $format - choose type of return values: 0=OIDs, 1=NIDs, 2=shortnames, 3=longnames
 #
 # returns: list of values
    </pre>
    <p class="Pp">Examples:</p>
    <p class="Pp"></p>
    <pre>
 my @extkeyusage_oid = Net::SSLeay::P_X509_get_ext_key_usage($x509,0);
 # returns for example: (&quot;1.3.6.1.5.5.7.3.1&quot;, &quot;1.3.6.1.5.5.7.3.2&quot;)

 my @extkeyusage_nid = Net::SSLeay::P_X509_get_ext_key_usage($x509,1);
 # returns for example: (129, 130)

 my @extkeyusage_sn  = Net::SSLeay::P_X509_get_ext_key_usage($x509,2);
 # returns for example: (&quot;serverAuth&quot;, &quot;clientAuth&quot;)

 my @extkeyusage_ln  = Net::SSLeay::P_X509_get_ext_key_usage($x509,3);
 # returns for example: (&quot;TLS Web Server Authentication&quot;,  &quot;TLS Web Client Authentication&quot;)
    </pre>
  </li>
  <li>P_X509_get_key_usage
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Gets the list of key usage of given X509 certificate
        <span class="Li">$cert</span>.</p>
    <p class="Pp"></p>
    <pre>
 my @keyusage = Net::SSLeay::P_X509_get_key_usage($cert);
 # $cert - value corresponding to openssl's X509 structure
 #
 # returns: list of key usage values which can be none, one or more from the following list:
 #          &quot;digitalSignature&quot;
 #          &quot;nonRepudiation&quot;
 #          &quot;keyEncipherment&quot;
 #          &quot;dataEncipherment&quot;
 #          &quot;keyAgreement&quot;
 #          &quot;keyCertSign&quot;
 #          &quot;cRLSign&quot;
 #          &quot;encipherOnly&quot;
 #          &quot;decipherOnly&quot;
    </pre>
  </li>
  <li>P_X509_get_netscape_cert_type
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Gets the list of Netscape cert types of given X509 certificate
        <span class="Li">$cert</span>.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::P_X509_get_netscape_cert_type($cert);
 # $cert - value corresponding to openssl's X509 structure
 #
 # returns: list of Netscape type values which can be none, one or more from the following list:
 #          &quot;client&quot;
 #          &quot;server&quot;
 #          &quot;email&quot;
 #          &quot;objsign&quot;
 #          &quot;reserved&quot;
 #          &quot;sslCA&quot;
 #          &quot;emailCA&quot;
 #          &quot;objCA&quot;
    </pre>
  </li>
  <li>P_X509_get_pubkey_alg
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Returns ASN1_OBJECT corresponding to X509 certificate public
        key algorithm.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::P_X509_get_pubkey_alg($x);
 # $x - value corresponding to openssl's X509 structure
 #
 # returns: value corresponding to openssl's ASN1_OBJECT structure (0 on failure)
    </pre>
    <p class="Pp">To get textual representation use:</p>
    <p class="Pp"></p>
    <pre>
 my $alg = Net::SSLeay::OBJ_obj2txt(Net::SSLeay::P_X509_get_pubkey_alg($x509));
 # returns for example: &quot;rsaEncryption&quot;
    </pre>
  </li>
  <li>P_X509_get_signature_alg
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Returns ASN1_OBJECT corresponding to X509 signarite key
        algorithm.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::P_X509_get_signature_alg($x);
 # $x - value corresponding to openssl's X509 structure
 #
 # returns: value corresponding to openssl's ASN1_OBJECT structure (0 on failure)
    </pre>
    <p class="Pp">To get textual representation use:</p>
    <p class="Pp"></p>
    <pre>
 my $alg = Net::SSLeay::OBJ_obj2txt(Net::SSLeay::P_X509_get_signature_alg($x509))
 # returns for example: &quot;sha1WithRSAEncryption&quot;
    </pre>
  </li>
  <li>sk_X509_new_null
    <p class="Pp">Returns a new, empty, STACK_OF(X509) structure.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::sk_X509_new_null();
 #
 # returns: value corresponding to openssl's STACK_OF(X509) structure
    </pre>
  </li>
  <li>sk_X509_push
    <p class="Pp">Pushes an X509 structure onto a STACK_OF(X509) structure.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::sk_X509_push($sk_x509, $x509);
 # $sk_x509 - value corresponding to openssl's STACK_OF(X509) structure
 # $x509 - value corresponding to openssl's X509 structure
 #
 # returns: 1 if successful, 0 if unsuccessful
    </pre>
  </li>
</ul>
<p class="Pp"><i>Low level API: X509_REQ_* related functions</i></p>
<ul class="Bl-bullet">
  <li>X509_REQ_new
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Creates a new X509_REQ structure.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_REQ_new();
 #
 # returns: value corresponding to openssl's X509_REQ structure (0 on failure)
    </pre>
  </li>
  <li>X509_REQ_free
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Free an allocated X509_REQ structure.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::X509_REQ_free($x);
 # $x - value corresponding to openssl's X509_REQ structure
 #
 # returns: no return value
    </pre>
  </li>
  <li>X509_REQ_add1_attr_by_NID
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Adds an attribute whose name is defined by a NID
        <span class="Li">$nid</span>. The field value to be added is in
        <span class="Li">$bytes</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_REQ_add1_attr_by_NID($req, $nid, $type, $bytes);
 # $req - value corresponding to openssl's X509_REQ structure
 # $nid - (integer) NID value
 # $type - (integer) type of data in $bytes (see below)
 # $bytes - data to be set
 #
 # returns: 1 on success, 0 on failure

 # values for $type - use constants:
 &amp;Net::SSLeay::MBSTRING_UTF8     - $bytes contains utf8 encoded data
 &amp;Net::SSLeay::MBSTRING_ASC      - $bytes contains ASCII data
    </pre>
  </li>
  <li>X509_REQ_digest
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Computes digest/fingerprint of X509_REQ
        <span class="Li">$data</span> using <span class="Li">$type</span> hash
        function.</p>
    <p class="Pp"></p>
    <pre>
 my $digest_value = Net::SSLeay::X509_REQ_digest($data, $type);
 # $data - value corresponding to openssl's X509_REQ structure
 # $type - value corresponding to openssl's EVP_MD structure - e.g. got via EVP_get_digestbyname()
 #
 # returns: hash value (binary)

 #to get printable (hex) value of digest use:
 print unpack('H*', $digest_value);
    </pre>
  </li>
  <li>X509_REQ_get_attr_by_NID
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Retrieve the next index matching <span class="Li">$nid</span>
        after <span class="Li">$lastpos</span> ($lastpos should initially be set
        to -1).</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_REQ_get_attr_by_NID($req, $nid, $lastpos=-1);
 # $req - value corresponding to openssl's X509_REQ structure
 # $nid - (integer) NID value
 # $lastpos - [optional] (integer) index where to start search (default -1)
 #
 # returns: index (-1 if there are no more entries)
    </pre>
    <p class="Pp">Note: use &quot;P_X509_REQ_get_attr&quot; to get the actual
        attribute value - e.g.</p>
    <p class="Pp"></p>
    <pre>
 my $index = Net::SSLeay::X509_REQ_get_attr_by_NID($req, $nid);
 my @attr_values = Net::SSLeay::P_X509_REQ_get_attr($req, $index);
    </pre>
  </li>
  <li>X509_REQ_get_attr_by_OBJ
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Retrieve the next index matching <span class="Li">$obj</span>
        after <span class="Li">$lastpos</span> ($lastpos should initially be set
        to -1).</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_REQ_get_attr_by_OBJ($req, $obj, $lastpos=-1);
 # $req - value corresponding to openssl's X509_REQ structure
 # $obj - value corresponding to openssl's ASN1_OBJECT structure
 # $lastpos - [optional] (integer) index where to start search (default -1)
 #
 # returns: index (-1 if there are no more entries)
    </pre>
    <p class="Pp">Note: use &quot;P_X509_REQ_get_attr&quot; to get the actual
        attribute value - e.g.</p>
    <p class="Pp"></p>
    <pre>
 my $index = Net::SSLeay::X509_REQ_get_attr_by_NID($req, $nid);
 my @attr_values = Net::SSLeay::P_X509_REQ_get_attr($req, $index);
    </pre>
  </li>
  <li>X509_REQ_get_attr_count
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Returns the total number of attributes in
        <span class="Li">$req</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_REQ_get_attr_count($req);
 # $req - value corresponding to openssl's X509_REQ structure
 #
 # returns: (integer) items count
    </pre>
  </li>
  <li>X509_REQ_get_pubkey
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Returns public key corresponding to given X509_REQ object
        <span class="Li">$x</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_REQ_get_pubkey($x);
 # $x - value corresponding to openssl's X509_REQ structure
 #
 # returns: value corresponding to openssl's EVP_PKEY structure (0 on failure)
    </pre>
  </li>
  <li>X509_REQ_get_subject_name
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Returns X509_NAME object corresponding to subject name of
        given X509_REQ object <span class="Li">$x</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_REQ_get_subject_name($x);
 # $x - value corresponding to openssl's X509_REQ structure
 #
 # returns: value corresponding to openssl's X509_NAME structure (0 on failure)
    </pre>
  </li>
  <li>X509_REQ_get_version
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Returns 'version' value for given X509_REQ object
        <span class="Li">$x</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_REQ_get_version($x);
 # $x - value corresponding to openssl's X509_REQ structure
 #
 # returns: (integer) version e.g. 0 = &quot;version 1&quot;
    </pre>
  </li>
  <li>X509_REQ_set_pubkey
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Sets public key of given X509_REQ object
        <span class="Li">$x</span> to <span class="Li">$pkey</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_REQ_set_pubkey($x, $pkey);
 # $x - value corresponding to openssl's X509_REQ structure
 # $pkey - value corresponding to openssl's EVP_PKEY structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>X509_REQ_set_subject_name
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Sets subject name of given X509_REQ object
        <span class="Li">$x</span> to X509_NAME object
        <span class="Li">$name</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_REQ_set_subject_name($x, $name);
 # $x - value corresponding to openssl's X509_REQ structure
 # $name - value corresponding to openssl's X509_NAME structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>X509_REQ_set_version
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Sets 'version' of given X509_REQ object
        <span class="Li">$x</span> to <span class="Li">$version</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_REQ_set_version($x, $version);
 # $x - value corresponding to openssl's X509_REQ structure
 # $version - (integer) e.g. 0 = &quot;version 1&quot;
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>X509_REQ_sign
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Sign X509_REQ object <span class="Li">$x</span> with private
        key <span class="Li">$pk</span> (using digest algorithm
        <span class="Li">$md</span>).</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_REQ_sign($x, $pk, $md);
 # $x - value corresponding to openssl's X509_REQ structure
 # $pk - value corresponding to openssl's EVP_PKEY structure (requestor's private key)
 # $md - value corresponding to openssl's EVP_MD structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>X509_REQ_verify
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Verifies X509_REQ object <span class="Li">$x</span> using
        public key <span class="Li">$r</span> (pubkey of requesting party).</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_REQ_verify($x, $r);
 # $x - value corresponding to openssl's X509_REQ structure
 # $r - value corresponding to openssl's EVP_PKEY structure
 #
 # returns: 0 - verify failure, 1 - verify OK, &lt;0 - error
    </pre>
  </li>
  <li>P_X509_REQ_add_extensions
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Adds one or more X509 extensions to X509_REQ object
        <span class="Li">$x</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::P_X509_REQ_add_extensions($x, $nid, $value);
 # $x - value corresponding to openssl's X509_REQ structure
 # $nid - NID identifying extension to be set
 # $value - extension value
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">You can set more extensions at once:</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::P_X509_REQ_add_extensions($x509_req,
            &amp;Net::SSLeay::NID_key_usage =&gt; 'digitalSignature,keyEncipherment',
            &amp;Net::SSLeay::NID_basic_constraints =&gt; 'CA:FALSE',
            &amp;Net::SSLeay::NID_ext_key_usage =&gt; 'serverAuth,clientAuth',
            &amp;Net::SSLeay::NID_netscape_cert_type =&gt; 'server',
            &amp;Net::SSLeay::NID_subject_alt_name =&gt; 'DNS:s1.com,DNS:s2.com',
            &amp;Net::SSLeay::NID_crl_distribution_points =&gt; 'URI:http://pki.com/crl1,URI:http://pki.com/crl2',
          );
    </pre>
  </li>
  <li>P_X509_REQ_get_attr
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before; requires at least openssl-0.9.7</p>
    <p class="Pp">Returns attribute value for X509_REQ's attribute at index
        <span class="Li">$n</span>.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::P_X509_REQ_get_attr($req, $n);
 # $req - value corresponding to openssl's X509_REQ structure
 # $n - (integer) attribute index
 #
 # returns: value corresponding to openssl's ASN1_STRING structure
    </pre>
  </li>
</ul>
<p class="Pp"><i>Low level API: X509_CRL_* related functions</i></p>
<ul class="Bl-bullet">
  <li>X509_CRL_new
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Creates a new X509_CRL structure.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_CRL_new();
 #
 # returns: value corresponding to openssl's X509_CRL structure (0 on failure)
    </pre>
  </li>
  <li>X509_CRL_free
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Free an allocated X509_CRL structure.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::X509_CRL_free($x);
 # $x - value corresponding to openssl's X509_CRL structure
 #
 # returns: no return value
    </pre>
  </li>
  <li>X509_CRL_digest
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Computes digest/fingerprint of X509_CRL
        <span class="Li">$data</span> using <span class="Li">$type</span> hash
        function.</p>
    <p class="Pp"></p>
    <pre>
 my $digest_value = Net::SSLeay::X509_CRL_digest($data, $type);
 # $data - value corresponding to openssl's X509_CRL structure
 # $type - value corresponding to openssl's EVP_MD structure - e.g. got via EVP_get_digestbyname()
 #
 # returns: hash value (binary)
    </pre>
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>
 my $x509_crl
 my $md = Net::SSLeay::EVP_get_digestbyname(&quot;sha1&quot;);
 my $digest_value = Net::SSLeay::X509_CRL_digest($x509_crl, $md);
 #to get printable (hex) value of digest use:
 print &quot;digest=&quot;, unpack('H*', $digest_value), &quot;\n&quot;;
    </pre>
  </li>
  <li>X509_CRL_get_ext
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.54 and
        before</p>
    <p class="Pp">Returns X509_EXTENSION from <span class="Li">$x509</span>
        based on given position/index.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_CRL_get_ext($x509, $index);
 # $x509 - value corresponding to openssl's X509_CRL structure
 # $index - (integer) position/index of extension within $x509
 #
 # returns: value corresponding to openssl's X509_EXTENSION structure (0 on failure)
    </pre>
  </li>
  <li>X509_CRL_get_ext_by_NID
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.54 and
        before</p>
    <p class="Pp">Returns X509_EXTENSION from <span class="Li">$x509</span>
        based on given NID.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_CRL_get_ext_by_NID($x509, $nid, $loc);
 # $x509 - value corresponding to openssl's X509_CRL structure
 # $nid - (integer) NID value
 # $loc - (integer) position to start lookup at
 #
 # returns: position/index of extension, negative value on error
 #          call Net::SSLeay::X509_CRL_get_ext($x509, $rv) to get the actual extension
    </pre>
  </li>
  <li>X509_CRL_get_ext_count
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.54 and
        before</p>
    <p class="Pp">Returns the total number of extensions in X509_CRL object
        <span class="Li">$x</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_CRL_get_ext_count($x);
 # $x - value corresponding to openssl's X509_CRL structure
 #
 # returns: count of extensions
    </pre>
  </li>
  <li>X509_CRL_get_issuer
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Returns X509_NAME object corresponding to the issuer of
        X509_CRL <span class="Li">$x</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_CRL_get_issuer($x);
 # $x - value corresponding to openssl's X509_CRL structure
 #
 # returns: value corresponding to openssl's X509_NAME structure (0 on failure)
    </pre>
    <p class="Pp">See other <span class="Li">&quot;X509_NAME_*&quot;</span>
        functions to get more info from X509_NAME structure.</p>
  </li>
  <li>X509_CRL_get_lastUpdate
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Returns 'lastUpdate' date-time value of X509_CRL object
        <span class="Li">$x</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_CRL_get_lastUpdate($x);
 # $x - value corresponding to openssl's X509_CRL structure
 #
 # returns: value corresponding to openssl's ASN1_TIME structure (0 on failure)
    </pre>
  </li>
  <li>X509_CRL_get_nextUpdate
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Returns 'nextUpdate' date-time value of X509_CRL object
        <span class="Li">$x</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_CRL_get_nextUpdate($x);
 # $x - value corresponding to openssl's X509_CRL structure
 #
 # returns: value corresponding to openssl's ASN1_TIME structure (0 on failure)
    </pre>
  </li>
  <li>X509_CRL_get_version
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Returns 'version' value of given X509_CRL structure
        <span class="Li">$x</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_CRL_get_version($x);
 # $x - value corresponding to openssl's X509_CRL structure
 #
 # returns: (integer) version
    </pre>
  </li>
  <li>X509_CRL_set_issuer_name
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before; requires at least openssl-0.9.7</p>
    <p class="Pp">Sets the issuer of X509_CRL object <span class="Li">$x</span>
        to X509_NAME object <span class="Li">$name</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_CRL_set_issuer_name($x, $name);
 # $x - value corresponding to openssl's X509_CRL structure
 # $name - value corresponding to openssl's X509_NAME structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>X509_CRL_set_lastUpdate
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before; requires at least openssl-0.9.7</p>
    <p class="Pp">Sets 'lastUpdate' value of X509_CRL object
        <span class="Li">$x</span> to <span class="Li">$tm</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_CRL_set_lastUpdate($x, $tm);
 # $x - value corresponding to openssl's X509_CRL structure
 # $tm - value corresponding to openssl's ASN1_TIME structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>X509_CRL_set_nextUpdate
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before; requires at least openssl-0.9.7</p>
    <p class="Pp">Sets 'nextUpdate' value of X509_CRL object
        <span class="Li">$x</span> to <span class="Li">$tm</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_CRL_set_nextUpdate($x, $tm);
 # $x - value corresponding to openssl's X509_CRL structure
 # $tm - value corresponding to openssl's ASN1_TIME structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>X509_CRL_set_version
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before; requires at least openssl-0.9.7</p>
    <p class="Pp">Sets 'version' value of given X509_CRL structure
        <span class="Li">$x</span> to <span class="Li">$version</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_CRL_set_version($x, $version);
 # $x - value corresponding to openssl's X509_CRL structure
 # $version - (integer) version number (1 = version 2 CRL)
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Note that if you want to use any X509_CRL extension you need
        to set &quot;version 2 CRL&quot; -
        <span class="Li">&quot;Net::SSLeay::X509_CRL_set_version($x,
        1)&quot;</span>.</p>
  </li>
  <li>X509_CRL_sign
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Sign X509_CRL object <span class="Li">$x</span> with private
        key <span class="Li">$pkey</span> (using digest algorithm
        <span class="Li">$md</span>).</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_CRL_sign($x, $pkey, $md);
 # $x - value corresponding to openssl's X509_CRL structure
 # $pkey - value corresponding to openssl's EVP_PKEY structure
 # $md - value corresponding to openssl's EVP_MD structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>X509_CRL_sort
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before; requires at least openssl-0.9.7</p>
    <p class="Pp">Sorts the data of X509_CRL object so it will be written in
        serial number order.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_CRL_sort($x);
 # $x - value corresponding to openssl's X509_CRL structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>X509_CRL_verify
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Verifies X509_CRL object <span class="Li">$a</span> using
        public key <span class="Li">$r</span> (pubkey of issuing CA).</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_CRL_verify($a, $r);
 # $a - value corresponding to openssl's X509_CRL structure
 # $r - value corresponding to openssl's EVP_PKEY structure
 #
 # returns: 0 - verify failure, 1 - verify OK, &lt;0 - error
    </pre>
  </li>
  <li>P_X509_CRL_add_revoked_serial_hex
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before; requires at least openssl-0.9.7</p>
    <p class="Pp">Adds given serial number <span class="Li">$serial_hex</span>
        to X509_CRL object <span class="Li">$crl</span>.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::P_X509_CRL_add_revoked_serial_hex($crl, $serial_hex, $rev_time, $reason_code, $comp_time);
 # $crl - value corresponding to openssl's X509_CRL structure
 # $serial_hex - string (hexadecimal) representation of serial number
 # $rev_time - (revocation time) value corresponding to openssl's ASN1_TIME structure
 # $reason_code - [optional] (integer) reason code (see below) - default 0
 # $comp_time - [optional] (compromise time) value corresponding to openssl's ASN1_TIME structure
 #
 # returns: no return value

 reason codes:
 0 - unspecified
 1 - keyCompromise
 2 - CACompromise
 3 - affiliationChanged
 4 - superseded
 5 - cessationOfOperation
 6 - certificateHold
 7 - removeFromCRL
    </pre>
  </li>
  <li>P_X509_CRL_get_serial
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before; requires at least openssl-0.9.7</p>
    <p class="Pp">Returns serial number of X509_CRL object.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::P_X509_CRL_get_serial($crl);
 # $crl - value corresponding to openssl's X509_CRL structure
 #
 # returns: value corresponding to openssl's ASN1_INTEGER structure (0 on failure)
    </pre>
  </li>
  <li>P_X509_CRL_set_serial
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before; requires at least openssl-0.9.7</p>
    <p class="Pp">Sets serial number of X509_CRL object to
        <span class="Li">$crl_number</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::P_X509_CRL_set_serial($crl, $crl_number);
 # $crl - value corresponding to openssl's X509_CRL structure
 # $crl_number - value corresponding to openssl's ASN1_INTEGER structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
</ul>
<p class="Pp"><i>Low level API: X509_EXTENSION_* related functions</i></p>
<ul class="Bl-bullet">
  <li>X509_EXTENSION_get_critical
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Returns 'critical' flag of given X509_EXTENSION object
        <span class="Li">$ex</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_EXTENSION_get_critical($ex);
 # $ex - value corresponding to openssl's X509_EXTENSION structure
 #
 # returns: (integer) 1 - critical, 0 - noncritical
    </pre>
  </li>
  <li>X509_EXTENSION_get_data
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Returns value (raw data) of X509_EXTENSION object
        <span class="Li">$ne</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_EXTENSION_get_data($ne);
 # $ne - value corresponding to openssl's X509_EXTENSION structure
 #
 # returns: value corresponding to openssl's ASN1_OCTET_STRING structure (0 on failure)
    </pre>
    <p class="Pp">Note: you can use &quot;P_ASN1_STRING_get&quot; to convert
        ASN1_OCTET_STRING into perl scalar variable.</p>
  </li>
  <li>X509_EXTENSION_get_object
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Returns OID (ASN1_OBJECT) of X509_EXTENSION object
        <span class="Li">$ne</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_EXTENSION_get_object($ex);
 # $ex - value corresponding to openssl's X509_EXTENSION structure
 #
 # returns: value corresponding to openssl's ASN1_OBJECT structure (0 on failure)
    </pre>
  </li>
  <li>X509V3_EXT_print
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Returns string representation of given X509_EXTENSION object
        <span class="Li">$ext</span>.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::X509V3_EXT_print($ext, $flags, $utf8_decode);
 # $ext - value corresponding to openssl's X509_EXTENSION structure
 # $flags - [optional] (integer) Currently the flag argument is unused and should be set to 0
 # $utf8_decode - [optional] 0 or 1 whether the returned value should be utf8 decoded (default=0)
 #
 # returns: no return value
    </pre>
  </li>
  <li>X509V3_EXT_d2i
    <p class="Pp">Parses an extension and returns its internal structure.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509V3_EXT_d2i($ext);
 # $ext - value corresponding to openssl's X509_EXTENSION structure
 #
 # returns: pointer ???
    </pre>
  </li>
</ul>
<p class="Pp"><i>Low level API: X509_NAME_* related functions</i></p>
<ul class="Bl-bullet">
  <li>X509_NAME_ENTRY_get_data
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Retrieves the field value of <span class="Li">$ne</span> in
        and ASN1_STRING structure.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_NAME_ENTRY_get_data($ne);
 # $ne - value corresponding to openssl's X509_NAME_ENTRY structure
 #
 # returns: value corresponding to openssl's ASN1_STRING structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/X509_NAME_ENTRY_get_object.html&gt;</p>
  </li>
  <li>X509_NAME_ENTRY_get_object
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Retrieves the field name of <span class="Li">$ne</span> in and
        ASN1_OBJECT structure.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_NAME_ENTRY_get_object($ne);
 # $ne - value corresponding to openssl's X509_NAME_ENTRY structure
 #
 # returns: value corresponding to openssl's ASN1_OBJECT structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/X509_NAME_ENTRY_get_object.html&gt;</p>
  </li>
  <li>X509_NAME_new
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.55 and
        before; requires at least openssl-0.9.5</p>
    <p class="Pp">Creates a new X509_NAME structure. Adds a field whose name is
        defined by a string <span class="Li">$field</span>. The field value to
        be added is in <span class="Li">$bytes</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_NAME_new();
 #
 # returns: value corresponding to openssl's X509_NAME structure (0 on failure)
    </pre>
  </li>
  <li>X509_NAME_hash
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.55 and
        before; requires at least openssl-0.9.5</p>
    <p class="Pp">Sort of a checksum of issuer name
        <span class="Li">$name</span>. The result is not a full hash (e.g.
        sha-1), it is kind-of-a-hash truncated to the size of 'unsigned long'
        (32 bits). The resulting value might differ across different openssl
        versions for the same X509 certificate.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_NAME_hash($name);
 # $name - value corresponding to openssl's X509_NAME structure
 #
 # returns: number representing checksum
    </pre>
  </li>
  <li>X509_NAME_add_entry_by_txt
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before; requires at least openssl-0.9.5</p>
    <p class="Pp">Adds a field whose name is defined by a string
        <span class="Li">$field</span>. The field value to be added is in
        <span class="Li">$bytes</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_NAME_add_entry_by_txt($name, $field, $type, $bytes, $len, $loc, $set);
 # $name - value corresponding to openssl's X509_NAME structure
 # $field - (string) field definition (name) - e.g. &quot;organizationName&quot;
 # $type - (integer) type of data in $bytes (see below)
 # $bytes - data to be set
 # $loc - [optional] (integer) index where the new entry is inserted: if it is -1 (default) it is appended
 # $set - [optional] (integer) determines how the new type is added. If it is 0 (default) a new RDN is created
 #
 # returns: 1 on success, 0 on failure

 # values for $type - use constants:
 &amp;Net::SSLeay::MBSTRING_UTF8     - $bytes contains utf8 encoded data
 &amp;Net::SSLeay::MBSTRING_ASC      - $bytes contains ASCII data
    </pre>
    <p class="Pp">Unicode note: when passing non-ascii (unicode) string in
        <span class="Li">$bytes</span> do not forget to set
        <span class="Li">&quot;$flags =
        &amp;Net::SSLeay::MBSTRING_UTF8&quot;</span> and encode the perl
        <span class="Li">$string</span> via <span class="Li">&quot;$bytes =
        encode('utf-8', $string)&quot;</span>.</p>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/X509_NAME_add_entry_by_txt.html&gt;</p>
  </li>
  <li>X509_NAME_add_entry_by_NID
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before; requires at least openssl-0.9.5</p>
    <p class="Pp">Adds a field whose name is defined by a NID
        <span class="Li">$nid</span>. The field value to be added is in
        <span class="Li">$bytes</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_NAME_add_entry_by_NID($name, $nid, $type, $bytes, $len, $loc, $set);
 # $name - value corresponding to openssl's X509_NAME structure
 # $nid - (integer) field definition - NID value
 # $type - (integer) type of data in $bytes (see below)
 # $bytes - data to be set
 # $loc - [optional] (integer) index where the new entry is inserted: if it is -1 (default) it is appended
 # $set - [optional] (integer) determines how the new type is added. If it is 0 (default) a new RDN is created
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/X509_NAME_add_entry_by_txt.html&gt;</p>
  </li>
  <li>X509_NAME_add_entry_by_OBJ
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before; requires at least openssl-0.9.5</p>
    <p class="Pp">Adds a field whose name is defined by a object (OID)
        <span class="Li">$obj</span> . The field value to be added is in
        <span class="Li">$bytes</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_NAME_add_entry_by_OBJ($name, $obj, $type, $bytes, $len, $loc, $set);
 # $name - value corresponding to openssl's X509_NAME structure
 # $obj - field definition - value corresponding to openssl's ASN1_OBJECT structure
 # $type - (integer) type of data in $bytes (see below)
 # $bytes - data to be set
 # $loc - [optional] (integer) index where the new entry is inserted: if it is -1 (default) it is appended
 # $set - [optional] (integer) determines how the new type is added. If it is 0 (default) a new RDN is created
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/X509_NAME_add_entry_by_txt.html&gt;</p>
  </li>
  <li>X509_NAME_cmp
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Compares two X509_NAME obejcts.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_NAME_cmp($a, $b);
 # $a - value corresponding to openssl's X509_NAME structure
 # $b - value corresponding to openssl's X509_NAME structure
 #
 # returns: 0 if $a matches $b; non zero otherwise
    </pre>
  </li>
  <li>X509_NAME_digest
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Computes digest/fingerprint of X509_NAME
        <span class="Li">$data</span> using <span class="Li">$type</span> hash
        function.</p>
    <p class="Pp"></p>
    <pre>
 my $digest_value = Net::SSLeay::X509_NAME_digest($data, $type);
 # $data - value corresponding to openssl's X509_NAME structure
 # $type - value corresponding to openssl's EVP_MD structure - e.g. got via EVP_get_digestbyname()
 #
 # returns: hash value (binary)

 #to get printable (hex) value of digest use:
 print unpack('H*', $digest_value);
    </pre>
  </li>
  <li>X509_NAME_entry_count
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Returns the total number of entries in
        <span class="Li">$name</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_NAME_entry_count($name);
 # $name - value corresponding to openssl's X509_NAME structure
 #
 # returns: (integer) entries count
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/X509_NAME_get_index_by_NID.html&gt;</p>
  </li>
  <li>X509_NAME_get_entry
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Retrieves the X509_NAME_ENTRY from
        <span class="Li">$name</span> corresponding to index
        <span class="Li">$loc</span>. Acceptable values for
        <span class="Li">$loc</span> run from 0 to
        <span class="Li">&quot;Net::SSLeay::X509_NAME_entry_count($name)-
        1&quot;</span>. The value returned is an internal pointer which must not
        be freed.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_NAME_get_entry($name, $loc);
 # $name - value corresponding to openssl's X509_NAME structure
 # $loc - (integer) index of wanted entry
 #
 # returns: value corresponding to openssl's X509_NAME_ENTRY structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/X509_NAME_get_index_by_NID.html&gt;</p>
  </li>
  <li>X509_NAME_print_ex
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Returns a string with human readable version of
        <span class="Li">$name</span>.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::X509_NAME_print_ex($name, $flags, $utf8_decode);
 # $name - value corresponding to openssl's X509_NAME structure
 # $flags - [optional] conversion flags (default XN_FLAG_RFC2253) - see below
 # $utf8_decode - [optional] 0 or 1 whether the returned value should be utf8 decoded (default=0)
 #
 # returns: string representation of $name

 #available conversion flags - use constants:
 &amp;Net::SSLeay::XN_FLAG_COMPAT
 &amp;Net::SSLeay::XN_FLAG_DN_REV
 &amp;Net::SSLeay::XN_FLAG_DUMP_UNKNOWN_FIELDS
 &amp;Net::SSLeay::XN_FLAG_FN_ALIGN
 &amp;Net::SSLeay::XN_FLAG_FN_LN
 &amp;Net::SSLeay::XN_FLAG_FN_MASK
 &amp;Net::SSLeay::XN_FLAG_FN_NONE
 &amp;Net::SSLeay::XN_FLAG_FN_OID
 &amp;Net::SSLeay::XN_FLAG_FN_SN
 &amp;Net::SSLeay::XN_FLAG_MULTILINE
 &amp;Net::SSLeay::XN_FLAG_ONELINE
 &amp;Net::SSLeay::XN_FLAG_RFC2253
 &amp;Net::SSLeay::XN_FLAG_SEP_COMMA_PLUS
 &amp;Net::SSLeay::XN_FLAG_SEP_CPLUS_SPC
 &amp;Net::SSLeay::XN_FLAG_SEP_MASK
 &amp;Net::SSLeay::XN_FLAG_SEP_MULTILINE
 &amp;Net::SSLeay::XN_FLAG_SEP_SPLUS_SPC
 &amp;Net::SSLeay::XN_FLAG_SPC_EQ
    </pre>
    <p class="Pp">Most likely you will be fine with default:</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::X509_NAME_print_ex($name, &amp;Net::SSLeay::XN_FLAG_RFC2253);
    </pre>
    <p class="Pp">Or you might want RFC2253-like output without utf8 chars
        escaping:</p>
    <p class="Pp"></p>
    <pre>
 use Net::SSLeay qw/XN_FLAG_RFC2253 ASN1_STRFLGS_ESC_MSB/;
 my $flag_rfc22536_utf8 = (XN_FLAG_RFC2253) &amp; (~ ASN1_STRFLGS_ESC_MSB);
 my $result = Net::SSLeay::X509_NAME_print_ex($name, $flag_rfc22536_utf8, 1);
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/X509_NAME_print_ex.html&gt;</p>
  </li>
  <li>X509_NAME_get_text_by_NID
    <p class="Pp">Retrieves the text from the first entry in name which matches
        <span class="Li">$nid</span>, if no such entry exists -1 is
      returned.</p>
    <p class="Pp"><b>openssl note:</b> this is a legacy function which has
        various limitations which makes it of minimal use in practice. It can
        only find the first matching entry and will copy the contents of the
        field verbatim: this can be highly confusing if the target is a
        multicharacter string type like a BMPString or a UTF8String.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::X509_NAME_get_text_by_NID($name, $nid);
 # $name - value corresponding to openssl's X509_NAME structure
 # $nid - NID value (integer)
 #
 # returns: text value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/X509_NAME_get_index_by_NID.html&gt;</p>
  </li>
  <li>X509_NAME_oneline
    <p class="Pp">Return an ASCII version of <span class="Li">$name</span>.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::X509_NAME_oneline($name);
 # $name - value corresponding to openssl's X509_NAME structure
 #
 # returns: (string) ASCII version of $name
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/X509_NAME_print_ex.html&gt;</p>
  </li>
  <li>sk_X509_NAME_free
    <p class="Pp">Free an allocated STACK_OF(X509_NAME) structure.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::sk_X509_NAME_free($sk);
 # $sk - value corresponding to openssl's STACK_OF(X509_NAME) structure
 #
 # returns: no return value
    </pre>
  </li>
  <li>sk_X509_NAME_num
    <p class="Pp">Return number of items in STACK_OF(X509_NAME)</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::sk_X509_NAME_num($sk);
 # $sk - value corresponding to openssl's STACK_OF(X509_NAME) structure
 #
 # returns: number of items
    </pre>
  </li>
  <li>sk_X509_NAME_value
    <p class="Pp">Returns X509_NAME from position <span class="Li">$index</span>
        in STACK_OF(X509_NAME)</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::sk_X509_NAME_value($sk, $i);
 # $sk - value corresponding to openssl's STACK_OF(X509_NAME) structure
 # $i - (integer) index/position
 #
 # returns: value corresponding to openssl's X509_NAME structure (0 on failure)
    </pre>
  </li>
  <li>add_file_cert_subjects_to_stack
    <p class="Pp">Add a file of certs to a stack. All certs in
        <span class="Li">$file</span> that are not already in the
        <span class="Li">$stackCAs</span> will be added.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::add_file_cert_subjects_to_stack($stackCAs, $file);
 # $stackCAs - value corresponding to openssl's STACK_OF(X509_NAME) structure
 # $file - (string) filename
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>add_dir_cert_subjects_to_stack
    <p class="Pp">Add a directory of certs to a stack. All certs in
        <span class="Li">$dir</span> that are not already in the
        <span class="Li">$stackCAs</span> will be added.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::add_dir_cert_subjects_to_stack($stackCAs, $dir);
 # $stackCAs - value corresponding to openssl's STACK_OF(X509_NAME) structure
 # $dir - (string) the directory to append from. All files in this directory will be examined as potential certs. Any that are acceptable to SSL_add_dir_cert_subjects_to_stack() that are not already in the stack will be included.
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
</ul>
<p class="Pp"><i>Low level API: X509_STORE_* related functions</i></p>
<ul class="Bl-bullet">
  <li>X509_STORE_CTX_new
    <p class="Pp">returns a newly initialised X509_STORE_CTX structure.</p>
  </li>
  <li>X509_STORE_CTX_init
    <p class="Pp"><b>X509_STORE_CTX_init()</b> sets up an X509_STORE_CTX for a
        subsequent verification operation. It must be called before each call to
        <b>X509_verify_cert()</b>.</p>
    <p class="Pp">Net::SSLeay::X509_STORE_CTX_init($x509_store_ctx,
        <span class="Li">$x509_store</span>, <span class="Li">$x509</span>,
        <span class="Li">$chain</span>);</p>
    <p class="Pp"># <span class="Li">$x509_store_ctx</span> - value
        corresponding to openssl's X509_STORE_CTX structure (required) #
        <span class="Li">$x509_store</span> - value corresponding to openssl's
        X509_STORE structure (optional) # <span class="Li">$x509</span> - value
        corresponding to openssl's X509 structure (optional) #
        <span class="Li">$chain</span> - value corresponding to openssl's
        STACK_OF(X509) structure (optional)</p>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/man1.0.2/crypto/X509_STORE_CTX_init.html&gt;</p>
  </li>
  <li>X509_STORE_CTX_free
    <p class="Pp">Frees an X509_STORE_CTX structure.</p>
    <p class="Pp">Net::SSLeay::X509_STORE_CTX_free($x509_store_ctx);</p>
    <p class="Pp"># <span class="Li">$x509_store_ctx</span> - value
        corresponding to openssl's X509_STORE_CTX structure</p>
  </li>
  <li>X509_verify_cert
    <p class="Pp">The <b>X509_verify_cert()</b> function attempts to discover
        and validate a certificate chain based on parameters in ctx. A complete
        description of the process is contained in the <b>verify</b>(1) manual
        page.</p>
    <p class="Pp">If this function returns 0, use X509_STORE_CTX_get_error to
        get additional error information.</p>
    <p class="Pp">my <span class="Li">$rv</span> =
        Net::SSLeay::X509_verify_cert($x509_store_ctx); #
        <span class="Li">$x509_store_ctx</span> - value corresponding to
        openssl's X509_STORE_CTX structure # # returns: 1 if a complete chain
        can be built and validated, otherwise 0</p>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/manmaster/man3/X509_verify_cert.html&gt;</p>
  </li>
  <li>X509_STORE_CTX_get_current_cert
    <p class="Pp">Returns the certificate in ctx which caused the error or 0 if
        no certificate is relevant.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_STORE_CTX_get_current_cert($x509_store_ctx);
 # $x509_store_ctx - value corresponding to openssl's X509_STORE_CTX structure
 #
 # returns: value corresponding to openssl's X509 structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/X509_STORE_CTX_get_error.html&gt;</p>
  </li>
  <li>X509_STORE_CTX_get_error
    <p class="Pp">Returns the error code of <span class="Li">$ctx</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_STORE_CTX_get_error($x509_store_ctx);
 # $x509_store_ctx - value corresponding to openssl's X509_STORE_CTX structure
 #
 # returns: (integer) error code
    </pre>
    <p class="Pp">For more info about erro code values check function
        &quot;get_verify_result&quot;.</p>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/X509_STORE_CTX_get_error.html&gt;</p>
  </li>
  <li>X509_STORE_CTX_get_error_depth
    <p class="Pp">Returns the depth of the error. This is a non-negative integer
        representing where in the certificate chain the error occurred. If it is
        zero it occurred in the end entity certificate, one if it is the
        certificate which signed the end entity certificate and so on.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_STORE_CTX_get_error_depth($x509_store_ctx);
 # $x509_store_ctx - value corresponding to openssl's X509_STORE_CTX structure
 #
 # returns: (integer) depth
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/X509_STORE_CTX_get_error.html&gt;</p>
  </li>
  <li>X509_STORE_CTX_get_ex_data
    <p class="Pp">Is used to retrieve the information for
        <span class="Li">$idx</span> from
        <span class="Li">$x509_store_ctx</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_STORE_CTX_get_ex_data($x509_store_ctx, $idx);
 # $x509_store_ctx - value corresponding to openssl's X509_STORE_CTX structure
 # $idx - (integer) index for application specific data
 #
 # returns: pointer to ???
    </pre>
  </li>
  <li>X509_STORE_CTX_set_ex_data
    <p class="Pp">Is used to store application data at arg for idx into
        <span class="Li">$x509_store_ctx</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_STORE_CTX_set_ex_data($x509_store_ctx, $idx, $data);
 # $x509_store_ctx - value corresponding to openssl's X509_STORE_CTX structure
 # $idx - (integer) ???
 # $data - (pointer) ???
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>X509_STORE_CTX_set_cert
    <p class="Pp">Sets the certificate to be verified in
        <span class="Li">$x509_store_ctx</span> to
      <span class="Li">$x</span>.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::X509_STORE_CTX_set_cert($x509_store_ctx, $x);
 # $x509_store_ctx - value corresponding to openssl's X509_STORE_CTX structure
 # $x - value corresponding to openssl's X509 structure
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/X509_STORE_CTX_new.html&gt;</p>
  </li>
  <li>X509_STORE_new
    <p class="Pp">Returns a newly initialized X509_STORE structure.</p>
    <p class="Pp">my <span class="Li">$rv</span> =
        <b>Net::SSLeay::X509_STORE_new()</b>; # # returns: value corresponding
        to openssl's X509_STORE structure (0 on failure)</p>
  </li>
  <li>X509_STORE_free
    <p class="Pp">Frees an X509_STORE structure</p>
    <p class="Pp">Net::SSLeay::X509_STORE_free($x509_store); #
        <span class="Li">$x509_store</span> - value corresponding to openssl's
        X509_STORE structure</p>
  </li>
  <li>X509_STORE_add_lookup
    <p class="Pp">Adds a lookup to an X509_STORE for a given lookup method.</p>
    <p class="Pp">my <span class="Li">$method</span> =
        &amp;Net::SSLeay::X509_LOOKUP_hash_dir; my <span class="Li">$rv</span> =
        Net::SSLeay::X509_STORE_add_lookup($x509_store,
        <span class="Li">$method</span>); # <span class="Li">$method</span> -
        value corresponding to openssl's X509_LOOKUP_METHOD structure #
        <span class="Li">$x509_store</span> - value corresponding to openssl's
        X509_STORE structure # # returns: value corresponding to openssl's
        X509_LOOKUP structure</p>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/man1.1.1/man3/X509_load_crl_file.html&gt;</p>
  </li>
  <li>X509_STORE_CTX_set_error
    <p class="Pp">Sets the error code of <span class="Li">$ctx</span> to
        <span class="Li">$s</span>. For example it might be used in a
        verification callback to set an error based on additional checks.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::X509_STORE_CTX_set_error($x509_store_ctx, $s);
 # $x509_store_ctx - value corresponding to openssl's X509_STORE_CTX structure
 # $s - (integer) error id
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/X509_STORE_CTX_get_error.html&gt;</p>
  </li>
  <li>X509_STORE_add_cert
    <p class="Pp">Adds X509 certificate <span class="Li">$x</span> into the
        X509_STORE <span class="Li">$store</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_STORE_add_cert($store, $x);
 # $store - value corresponding to openssl's X509_STORE structure
 # $x - value corresponding to openssl's X509 structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>X509_STORE_add_crl
    <p class="Pp">Adds X509 CRL <span class="Li">$x</span> into the X509_STORE
        <span class="Li">$store</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_STORE_add_crl($store, $x);
 # $store - value corresponding to openssl's X509_STORE structure
 # $x - value corresponding to openssl's X509_CRL structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>X509_STORE_set1_param
    <p class="Pp">??? (more info needed)</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_STORE_set1_param($store, $pm);
 # $store - value corresponding to openssl's X509_STORE structure
 # $pm - value corresponding to openssl's X509_VERIFY_PARAM structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>X509_LOOKUP_hash_dir
    <p class="Pp">Returns an X509_LOOKUP structure that instructs an X509_STORE
        to load files from a directory containing certificates with filenames in
        the format <i>hash.N</i> or crls with filenames in the format
        <i>hash.</i><b>r</b><i>N</i></p>
    <p class="Pp">my <span class="Li">$rv</span> =
        <b>Net::SSLeay::X509_LOOKUP_hash_dir()</b>; # # returns: value
        corresponding to openssl's X509_LOOKUP_METHOD structure, with the hashed
        directory method</p>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/man1.1.1/man3/X509_load_crl_file.html&gt;</p>
  </li>
  <li>X509_LOOKUP_add_dir
    <p class="Pp">Add a directory to an X509_LOOKUP structure, usually obtained
        from X509_STORE_add_lookup.</p>
    <p class="Pp">my <span class="Li">$method</span> =
        &amp;Net::SSLeay::X509_LOOKUP_hash_dir; my
        <span class="Li">$lookup</span> =
        Net::SSLeay::X509_STORE_add_lookup($x509_store,
        <span class="Li">$method</span>); my <span class="Li">$type</span> =
        &amp;Net::SSLeay::X509_FILETYPE_PEM;
        Net::SSLeay::X509_LOOKUP_add_dir($lookup, <span class="Li">$dir</span>,
        <span class="Li">$type</span>); # <span class="Li">$lookup</span> -
        value corresponding to openssl's X509_LOOKUP structure #
        <span class="Li">$dir</span> - string path to a directory s#
        <span class="Li">$type</span> - constant corresponding to the type of
        file in the directory - can be X509_FILETYPE_PEM, X509_FILETYPE_DEFAULT,
        or X509_FILETYPE_ASN1</p>
  </li>
  <li>X509_STORE_set_flags
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::X509_STORE_set_flags($ctx, $flags);
 # $ctx - value corresponding to openssl's X509_STORE structure
 # $flags - (unsigned long) flags to be set (bitmask)
 #
 # returns: no return value

 #to create $flags value use corresponding constants like
 $flags = Net::SSLeay::X509_V_FLAG_CRL_CHECK();
    </pre>
    <p class="Pp">For more details about <span class="Li">$flags</span> bitmask
        see &quot;X509_VERIFY_PARAM_set_flags&quot;.</p>
  </li>
  <li>X509_STORE_set_purpose
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::X509_STORE_set_purpose($ctx, $purpose);
 # $ctx - value corresponding to openssl's X509_STORE structure
 # $purpose - (integer) purpose identifier
 #
 # returns: no return value
    </pre>
    <p class="Pp">For more details about <span class="Li">$purpose</span>
        identifier check &quot;CTX_set_purpose&quot;.</p>
  </li>
  <li>X509_STORE_set_trust
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::X509_STORE_set_trust($ctx, $trust);
 # $ctx - value corresponding to openssl's X509_STORE structure
 # $trust - (integer) trust identifier
 #
 # returns: no return value
    </pre>
    <p class="Pp">For more details about <span class="Li">$trust</span>
        identifier check &quot;CTX_set_trust&quot;.</p>
  </li>
</ul>
<p class="Pp"><i>Low Level API: X509_INFO related functions</i></p>
<ul class="Bl-bullet">
  <li>sk_X509_INFO_num
    <p class="Pp">Returns the number of values in a STACK_OF(X509_INFO)
        structure.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::sk_X509_INFO_num($sk_x509_info);
 # $sk_x509_info - value corresponding to openssl's STACK_OF(X509_INFO) structure
 #
 # returns: number of values in $sk_X509_info
    </pre>
  </li>
  <li>sk_X509_INFO_value
    <p class="Pp">Returns the value of a STACK_OF(X509_INFO) structure at a
        given index.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::sk_X509_INFO_value($sk_x509_info, $index);
 # $sk_x509_info - value corresponding to openssl's STACK_OF(X509_INFO) structure
 # $index - index into the stack
 #
 # returns: value corresponding to openssl's X509_INFO structure at the given index
    </pre>
  </li>
  <li>P_X509_INFO_get_x509
    <p class="Pp">Returns the X509 structure stored in an X509_INFO
      structure.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::P_X509_INFO_get_x509($x509_info);
 # $x509_info - value corresponding to openssl's X509_INFO structure
 #
 # returns: value corresponding to openssl's X509 structure
    </pre>
  </li>
</ul>
<p class="Pp"><i>Low level API: X509_VERIFY_PARAM_* related functions</i></p>
<ul class="Bl-bullet">
  <li>X509_VERIFY_PARAM_add0_policy
    <p class="Pp">Enables policy checking (it is disabled by default) and adds
        <span class="Li">$policy</span> to the acceptable policy set.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_VERIFY_PARAM_add0_policy($param, $policy);
 # $param - value corresponding to openssl's X509_VERIFY_PARAM structure
 # $policy - value corresponding to openssl's ASN1_OBJECT structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p>
  </li>
  <li>X509_VERIFY_PARAM_add0_table
    <p class="Pp">??? (more info needed)</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_VERIFY_PARAM_add0_table($param);
 # $param - value corresponding to openssl's X509_VERIFY_PARAM structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>X509_VERIFY_PARAM_add1_host
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.82 and
        before; requires at least OpenSSL 1.0.2</p>
    <p class="Pp">Adds an additional reference identifier that can match the
        peer's certificate.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_VERIFY_PARAM_add1_host($param, $name);
 # $param - value corresponding to openssl's X509_VERIFY_PARAM structure
 # $name - (string) name to be set
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">See also OpenSSL docs, &quot;X509_VERIFY_PARAM_set1_host&quot;
        and &quot;X509_VERIFY_PARAM_set_hostflags&quot; for more information,
        including wildcard matching.</p>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p>
  </li>
  <li>X509_VERIFY_PARAM_clear_flags
    <p class="Pp">Clears the flags <span class="Li">$flags</span> in param.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_VERIFY_PARAM_clear_flags($param, $flags);
 # $param - value corresponding to openssl's X509_VERIFY_PARAM structure
 # $flags - (unsigned long) flags to be set (bitmask)
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">For more details about <span class="Li">$flags</span> bitmask
        see &quot;X509_VERIFY_PARAM_set_flags&quot;.</p>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p>
  </li>
  <li>X509_VERIFY_PARAM_free
    <p class="Pp">Frees up the X509_VERIFY_PARAM structure.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::X509_VERIFY_PARAM_free($param);
 # $param - value corresponding to openssl's X509_VERIFY_PARAM structure
 #
 # returns: no return value
    </pre>
  </li>
  <li>X509_VERIFY_PARAM_get0_peername
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.82 and
        before; requires at least OpenSSL 1.0.2</p>
    <p class="Pp">Returns the DNS hostname or subject CommonName from the peer
        certificate that matched one of the reference identifiers.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_VERIFY_PARAM_get0_peername($param);
 # $param - value corresponding to openssl's X509_VERIFY_PARAM structure
 #
 # returns: (string) name e.g. '*.example.com' or undef
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p>
  </li>
  <li>X509_VERIFY_PARAM_get_depth
    <p class="Pp">Returns the current verification depth.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_VERIFY_PARAM_get_depth($param);
 # $param - value corresponding to openssl's X509_VERIFY_PARAM structure
 #
 # returns: (ineger) depth
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p>
  </li>
  <li>X509_VERIFY_PARAM_get_flags
    <p class="Pp">Returns the current verification flags.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_VERIFY_PARAM_get_flags($param);
 # $param - value corresponding to openssl's X509_VERIFY_PARAM structure
 #
 # returns: (unsigned long) flags to be set (bitmask)
    </pre>
    <p class="Pp">For more details about returned flags bitmask see
        &quot;X509_VERIFY_PARAM_set_flags&quot;.</p>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p>
  </li>
  <li>X509_VERIFY_PARAM_set_flags
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_VERIFY_PARAM_set_flags($param, $flags);
 # $param - value corresponding to openssl's X509_VERIFY_PARAM structure
 # $flags - (unsigned long) flags to be set (bitmask)
 #
 # returns: 1 on success, 0 on failure

 #to create $flags value use corresponding constants like
 $flags = Net::SSLeay::X509_V_FLAG_CRL_CHECK();
    </pre>
    <p class="Pp">For more details about <span class="Li">$flags</span> bitmask,
        see the OpenSSL docs below.</p>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p>
  </li>
  <li>X509_VERIFY_PARAM_inherit
    <p class="Pp">??? (more info needed)</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_VERIFY_PARAM_inherit($to, $from);
 # $to - value corresponding to openssl's X509_VERIFY_PARAM structure
 # $from - value corresponding to openssl's X509_VERIFY_PARAM structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>X509_VERIFY_PARAM_lookup
    <p class="Pp">Finds X509_VERIFY_PARAM by name.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_VERIFY_PARAM_lookup($name);
 # $name - (string) name we want to find
 #
 # returns: value corresponding to openssl's X509_VERIFY_PARAM structure (0 on failure)
    </pre>
  </li>
  <li>X509_VERIFY_PARAM_new
    <p class="Pp">Creates a new X509_VERIFY_PARAM structure.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_VERIFY_PARAM_new();
 #
 # returns: value corresponding to openssl's X509_VERIFY_PARAM structure (0 on failure)
    </pre>
  </li>
  <li>X509_VERIFY_PARAM_set1
    <p class="Pp">Sets the name of X509_VERIFY_PARAM structure
        <span class="Li">$to</span> to the same value as the name of
        X509_VERIFY_PARAM structure <span class="Li">$from</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_VERIFY_PARAM_set1($to, $from);
 # $to - value corresponding to openssl's X509_VERIFY_PARAM structure
 # $from - value corresponding to openssl's X509_VERIFY_PARAM structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>X509_VERIFY_PARAM_set1_email
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.82 and
        before; requires at least OpenSSL 1.0.2</p>
    <p class="Pp">Sets the expected RFC822 email address to email.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_VERIFY_PARAM_set1_email($param, $email);
 # $param - value corresponding to openssl's X509_VERIFY_PARAM structure
 # $email - (string) email to be set
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p>
  </li>
  <li>X509_VERIFY_PARAM_set1_host
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.82 and
        before; requires at least OpenSSL 1.0.2</p>
    <p class="Pp">Sets the expected DNS hostname to name clearing any previously
        specified host name or names.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_VERIFY_PARAM_set1_host($param, $name);
 # $param - value corresponding to openssl's X509_VERIFY_PARAM structure
 # $name - (string) name to be set
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">See also OpenSSL docs, &quot;X509_VERIFY_PARAM_add1_host&quot;
        and &quot;X509_VERIFY_PARAM_set_hostflags&quot; for more information,
        including wildcard matching.</p>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p>
  </li>
  <li>X509_VERIFY_PARAM_set1_ip
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.82 and
        before; requires at least OpenSSL 1.0.2</p>
    <p class="Pp">Sets the expected IP address to ip.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_VERIFY_PARAM_set1_ip($param, $ip);
 # $param - value corresponding to openssl's X509_VERIFY_PARAM structure
 # $ip - (binary) 4 octet IPv4 or 16 octet IPv6 address
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p>
  </li>
  <li>X509_VERIFY_PARAM_set1_ip_asc
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.82 and
        before; requires at least OpenSSL 1.0.2</p>
    <p class="Pp">Sets the expected IP address to ipasc.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_VERIFY_PARAM_set1_asc($param, $ipasc);
 # $param - value corresponding to openssl's X509_VERIFY_PARAM structure
 # $ip - (string) IPv4 or IPv6 address
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p>
  </li>
  <li>X509_VERIFY_PARAM_set1_name
    <p class="Pp">Sets the name of X509_VERIFY_PARAM structure
        <span class="Li">$param</span> to <span class="Li">$name</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_VERIFY_PARAM_set1_name($param, $name);
 # $param - value corresponding to openssl's X509_VERIFY_PARAM structure
 # $name - (string) name to be set
 #
 # returns: 1 on success, 0 on failure
    </pre>
  </li>
  <li>X509_VERIFY_PARAM_set1_policies
    <p class="Pp">Enables policy checking (it is disabled by default) and sets
        the acceptable policy set to policies. Any existing policy set is
        cleared. The policies parameter can be 0 to clear an existing policy
        set.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_VERIFY_PARAM_set1_policies($param, $policies);
 # $param - value corresponding to openssl's X509_VERIFY_PARAM structure
 # $policies - value corresponding to openssl's STACK_OF(ASN1_OBJECT) structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p>
  </li>
  <li>X509_VERIFY_PARAM_set_depth
    <p class="Pp">Sets the maximum verification depth to depth. That is the
        maximum number of untrusted CA certificates that can appear in a
      chain.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::X509_VERIFY_PARAM_set_depth($param, $depth);
 # $param - value corresponding to openssl's X509_VERIFY_PARAM structure
 # $depth - (integer) depth to be set
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p>
  </li>
  <li>X509_VERIFY_PARAM_set_hostflags
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::X509_VERIFY_PARAM_set_hostflags($param, $flags);
 # $param - value corresponding to openssl's X509_VERIFY_PARAM structure
 # $flags - (unsigned int) flags to be set (bitmask)
 #
 # returns: no return value
    </pre>
    <p class="Pp">See also OpenSSL docs, &quot;X509_VERIFY_PARAM_add1_host&quot;
        and &quot;X509_VERIFY_PARAM_set1_host&quot; for more information. The
        flags for controlling wildcard checks and other features are defined in
        OpenSSL docs.</p>
    <p class="Pp">Check openssl doc
        &lt;https://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p>
  </li>
  <li>X509_VERIFY_PARAM_set_purpose
    <p class="Pp">Sets the verification purpose in
        <span class="Li">$param</span> to <span class="Li">$purpose</span>. This
        determines the acceptable purpose of the certificate chain, for example
        SSL client or SSL server.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_VERIFY_PARAM_set_purpose($param, $purpose);
 # $param - value corresponding to openssl's X509_VERIFY_PARAM structure
 # $purpose - (integer) purpose identifier
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">For more details about <span class="Li">$purpose</span>
        identifier check &quot;CTX_set_purpose&quot;.</p>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p>
  </li>
  <li>X509_VERIFY_PARAM_set_time
    <p class="Pp">Sets the verification time in <span class="Li">$param</span>
        to <span class="Li">$t</span>. Normally the current time is used.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::X509_VERIFY_PARAM_set_time($param, $t);
 # $param - value corresponding to openssl's X509_VERIFY_PARAM structure
 # $t - (time_t) time in seconds since 1.1.1970
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p>
  </li>
  <li>X509_VERIFY_PARAM_set_trust
    <p class="Pp">Sets the trust setting in <span class="Li">$param</span> to
        <span class="Li">$trust</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::X509_VERIFY_PARAM_set_trust($param, $trust);
 # $param - value corresponding to openssl's X509_VERIFY_PARAM structure
 # $trust - (integer) trust identifier
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">For more details about <span class="Li">$trust</span>
        identifier check &quot;CTX_set_trust&quot;.</p>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p>
  </li>
  <li>X509_VERIFY_PARAM_table_cleanup
    <p class="Pp">??? (more info needed)</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::X509_VERIFY_PARAM_table_cleanup();
 #
 # returns: no return value
    </pre>
  </li>
</ul>
<p class="Pp"><i>Low level API: Cipher (EVP_CIPHER_*) related functions</i></p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>EVP_get_cipherbyname
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before</p>
    <p class="Pp">Returns an EVP_CIPHER structure when passed a cipher name.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::EVP_get_cipherbyname($name);
 # $name - (string) cipher name e.g. 'aes-128-cbc', 'camellia-256-ecb', 'des-ede', ...
 #
 # returns: value corresponding to openssl's EVP_CIPHER structure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/EVP_EncryptInit.html&gt;</p>
  </dd>
</dl>
<p class="Pp"><i>Low level API: Digest (EVP_MD_*) related functions</i></p>
<ul class="Bl-bullet">
  <li>OpenSSL_add_all_digests
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and
        before</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::OpenSSL_add_all_digests();
 # no args, no return value
    </pre>
    <p class="Pp">http://www.openssl.org/docs/crypto/OpenSSL_add_all_algorithms.html</p>
  </li>
  <li>P_EVP_MD_list_all
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and
        before; requires at least openssl-1.0.0</p>
    <p class="Pp"><b>NOTE:</b> Does not exactly correspond to any low level API
        function</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::P_EVP_MD_list_all();
 #
 # returns: arrayref - list of available digest names
    </pre>
    <p class="Pp">The returned digest names correspond to values expected by
        &quot;EVP_get_digestbyname&quot;.</p>
    <p class="Pp">Note that some of the digests are available by default and
        some only after calling &quot;OpenSSL_add_all_digests&quot;.</p>
  </li>
  <li>EVP_get_digestbyname
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and
        before</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::EVP_get_digestbyname($name);
 # $name - string with digest name
 #
 # returns: value corresponding to openssl's EVP_MD structure
    </pre>
    <p class="Pp">The <span class="Li">$name</span> param can be:</p>
    <p class="Pp"></p>
    <pre>
 md2
 md4
 md5
 mdc2
 ripemd160
 sha
 sha1
 sha224
 sha256
 sha512
 whirlpool
    </pre>
    <p class="Pp">Or better check the supported digests by calling
        &quot;P_EVP_MD_list_all&quot;.</p>
  </li>
  <li>EVP_MD_type
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and
        before</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::EVP_MD_type($md);
 # $md - value corresponding to openssl's EVP_MD structure
 #
 # returns: the NID (integer) of the OBJECT IDENTIFIER representing the given message digest
    </pre>
  </li>
  <li>EVP_MD_size
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and
        before</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::EVP_MD_size($md);
 # $md - value corresponding to openssl's EVP_MD structure
 #
 # returns: the size of the message digest in bytes (e.g. 20 for SHA1)
    </pre>
  </li>
  <li>EVP_MD_CTX_md
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and
        before; requires at least openssl-0.9.7</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::EVP_MD_CTX_md($ctx);
 # $ctx - value corresponding to openssl's EVP_MD_CTX structure
 #
 # returns: value corresponding to openssl's EVP_MD structure
    </pre>
  </li>
  <li>EVP_MD_CTX_create
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and
        before; requires at least openssl-0.9.7</p>
    <p class="Pp">Allocates, initializes and returns a digest context.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::EVP_MD_CTX_create();
 #
 # returns: value corresponding to openssl's EVP_MD_CTX structure
    </pre>
    <p class="Pp">The complete idea behind EVP_MD_CTX looks like this
      example:</p>
    <p class="Pp"></p>
    <pre>
  Net::SSLeay::OpenSSL_add_all_digests();

  my $md = Net::SSLeay::EVP_get_digestbyname(&quot;sha1&quot;);
  my $ctx = Net::SSLeay::EVP_MD_CTX_create();
  Net::SSLeay::EVP_DigestInit($ctx, $md);

  while(my $chunk = get_piece_of_data()) {
    Net::SSLeay::EVP_DigestUpdate($ctx,$chunk);
  }

  my $result = Net::SSLeay::EVP_DigestFinal($ctx);
  Net::SSLeay::EVP_MD_CTX_destroy($ctx);

  print &quot;digest=&quot;, unpack('H*', $result), &quot;\n&quot;; #print hex value
    </pre>
  </li>
  <li>EVP_DigestInit_ex
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and
        before; requires at least openssl-0.9.7</p>
    <p class="Pp">Sets up digest context <span class="Li">$ctx</span> to use a
        digest <span class="Li">$type</span> from ENGINE
        <span class="Li">$impl</span>, <span class="Li">$ctx</span> must be
        initialized before calling this function, type will typically be
        supplied by a function such as &quot;EVP_get_digestbyname&quot;. If
        <span class="Li">$impl</span> is 0 then the default implementation of
        digest <span class="Li">$type</span> is used.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::EVP_DigestInit_ex($ctx, $type, $impl);
 # $ctx  - value corresponding to openssl's EVP_MD_CTX structure
 # $type - value corresponding to openssl's EVP_MD structure
 # $impl - value corresponding to openssl's ENGINE structure
 #
 # returns: 1 for success and 0 for failure
    </pre>
  </li>
  <li>EVP_DigestInit
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and
        before; requires at least openssl-0.9.7</p>
    <p class="Pp">Behaves in the same way as &quot;EVP_DigestInit_ex&quot;
        except the passed context <span class="Li">$ctx</span> does not have to
        be initialized, and it always uses the default digest
      implementation.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::EVP_DigestInit($ctx, $type);
 # $ctx - value corresponding to openssl's EVP_MD_CTX structure
 # $type - value corresponding to openssl's EVP_MD structure
 #
 # returns: 1 for success and 0 for failure
    </pre>
  </li>
  <li>EVP_MD_CTX_destroy
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and
        before; requires at least openssl-0.9.7</p>
    <p class="Pp">Cleans up digest context <span class="Li">$ctx</span> and
        frees up the space allocated to it, it should be called only on a
        context created using &quot;EVP_MD_CTX_create&quot;.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::EVP_MD_CTX_destroy($ctx);
 # $ctx - value corresponding to openssl's EVP_MD_CTX structure
 #
 # returns: no return value
    </pre>
  </li>
  <li>EVP_DigestUpdate
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and
        before; requires at least openssl-0.9.7</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::EVP_DigestUpdate($ctx, $data);
 # $ctx  - value corresponding to openssl's EVP_MD_CTX structure
 # $data - data to be hashed
 #
 # returns: 1 for success and 0 for failure
    </pre>
  </li>
  <li>EVP_DigestFinal_ex
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and
        before; requires at least openssl-0.9.7</p>
    <p class="Pp">Retrieves the digest value from <span class="Li">$ctx</span>.
        After calling &quot;EVP_DigestFinal_ex&quot; no additional calls to
        &quot;EVP_DigestUpdate&quot; can be made, but
        &quot;EVP_DigestInit_ex&quot; can be called to initialize a new digest
        operation.</p>
    <p class="Pp"></p>
    <pre>
 my $digest_value = Net::SSLeay::EVP_DigestFinal_ex($ctx);
 # $ctx - value corresponding to openssl's EVP_MD_CTX structure
 #
 # returns: hash value (binary)

 #to get printable (hex) value of digest use:
 print unpack('H*', $digest_value);
    </pre>
  </li>
  <li>EVP_DigestFinal
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and
        before; requires at least openssl-0.9.7</p>
    <p class="Pp">Similar to &quot;EVP_DigestFinal_ex&quot; except the digest
        context ctx is automatically cleaned up.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::EVP_DigestFinal($ctx);
 # $ctx - value corresponding to openssl's EVP_MD_CTX structure
 #
 # returns: hash value (binary)

 #to get printable (hex) value of digest use:
 print unpack('H*', $digest_value);
    </pre>
  </li>
  <li>MD2
    <p class="Pp"><b>COMPATIBILITY:</b> no supported by default in
      openssl-1.0.0</p>
    <p class="Pp">Computes MD2 from given <span class="Li">$data</span> (all
        data needs to be loaded into memory)</p>
    <p class="Pp"></p>
    <pre>
 my $digest = Net::SSLeay::MD2($data);
 print &quot;digest(hexadecimal)=&quot;, unpack('H*', $digest);
    </pre>
  </li>
  <li>MD4
    <p class="Pp">Computes MD4 from given <span class="Li">$data</span> (all
        data needs to be loaded into memory)</p>
    <p class="Pp"></p>
    <pre>
 my $digest = Net::SSLeay::MD4($data);
 print &quot;digest(hexadecimal)=&quot;, unpack('H*', $digest);
    </pre>
  </li>
  <li>MD5
    <p class="Pp">Computes MD5 from given <span class="Li">$data</span> (all
        data needs to be loaded into memory)</p>
    <p class="Pp"></p>
    <pre>
 my $digest = Net::SSLeay::MD5($data);
 print &quot;digest(hexadecimal)=&quot;, unpack('H*', $digest);
    </pre>
  </li>
  <li>RIPEMD160
    <p class="Pp">Computes RIPEMD160 from given <span class="Li">$data</span>
        (all data needs to be loaded into memory)</p>
    <p class="Pp"></p>
    <pre>
 my $digest = Net::SSLeay::RIPEMD160($data);
 print &quot;digest(hexadecimal)=&quot;, unpack('H*', $digest);
    </pre>
  </li>
  <li>SHA1
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and
        before</p>
    <p class="Pp">Computes SHA1 from given <span class="Li">$data</span> (all
        data needs to be loaded into memory)</p>
    <p class="Pp"></p>
    <pre>
 my $digest = Net::SSLeay::SHA1($data);
 print &quot;digest(hexadecimal)=&quot;, unpack('H*', $digest);
    </pre>
  </li>
  <li>SHA256
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and
        before; requires at least openssl-0.9.8</p>
    <p class="Pp">Computes SHA256 from given <span class="Li">$data</span> (all
        data needs to be loaded into memory)</p>
    <p class="Pp"></p>
    <pre>
 my $digest = Net::SSLeay::SHA256($data);
 print &quot;digest(hexadecimal)=&quot;, unpack('H*', $digest);
    </pre>
  </li>
  <li>SHA512
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and
        before; requires at least openssl-0.9.8</p>
    <p class="Pp">Computes SHA512 from given <span class="Li">$data</span> (all
        data needs to be loaded into memory)</p>
    <p class="Pp"></p>
    <pre>
 my $digest = Net::SSLeay::SHA512($data);
 print &quot;digest(hexadecimal)=&quot;, unpack('H*', $digest);
    </pre>
  </li>
  <li>EVP_Digest
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and
        before; requires at least openssl-0.9.7</p>
    <p class="Pp">Computes &quot;any&quot; digest from given
        <span class="Li">$data</span> (all data needs to be loaded into
      memory)</p>
    <p class="Pp"></p>
    <pre>
 my $md = Net::SSLeay::EVP_get_digestbyname(&quot;sha1&quot;); #or any other algorithm
 my $digest = Net::SSLeay::EVP_Digest($data, $md);
 print &quot;digest(hexadecimal)=&quot;, unpack('H*', $digest);
    </pre>
  </li>
  <li>EVP_sha1
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and
        before</p>
    <p class="Pp"></p>
    <pre>
 my $md = Net::SSLeay::EVP_sha1();
 #
 # returns: value corresponding to openssl's EVP_MD structure
    </pre>
  </li>
  <li>EVP_sha256
    <p class="Pp"><b>COMPATIBILITY:</b> requires at least openssl-0.9.8</p>
    <p class="Pp"></p>
    <pre>
 my $md = Net::SSLeay::EVP_sha256();
 #
 # returns: value corresponding to openssl's EVP_MD structure
    </pre>
  </li>
  <li>EVP_sha512
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and
        before; requires at least openssl-0.9.8</p>
    <p class="Pp"></p>
    <pre>
 my $md = Net::SSLeay::EVP_sha512();
 #
 # returns: value corresponding to openssl's EVP_MD structure
    </pre>
  </li>
  <li>EVP_add_digest
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::EVP_add_digest($digest);
 # $digest - value corresponding to openssl's EVP_MD structure
 #
 # returns: 1 on success, 0 otherwise
    </pre>
  </li>
</ul>
<p class="Pp"><i>Low level API: CIPHER_* related functions</i></p>
<ul class="Bl-bullet">
  <li>CIPHER_get_name
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.42 and
        before</p>
    <p class="Pp">Returns name of the cipher used.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CIPHER_description($cipher);
 # $cipher - value corresponding to openssl's SSL_CIPHER structure
 #
 # returns: (string) cipher name e.g. 'DHE-RSA-AES256-SHA'
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CIPHER_get_name.html&gt;</p>
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>
 my $ssl_cipher = Net::SSLeay::get_current_cipher($ssl);
 my $cipher_name = Net::SSLeay::CIPHER_get_name($ssl_cipher);
    </pre>
  </li>
  <li>CIPHER_description
    <p class="Pp">Returns a textual description of the cipher used.</p>
    <p class="Pp">??? (does this function really work?)</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CIPHER_description($cipher, $buf, $size);
 # $cipher - value corresponding to openssl's SSL_CIPHER structure
 # $bufer - (string/buffer) ???
 # $size - (integer) ???
 #
 # returns: (string) cipher description e.g. 'DHE-RSA-AES256-SHA SSLv3 Kx=DH Au=RSA Enc=AES(256) Mac=SHA1'
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CIPHER_get_name.html&gt;</p>
  </li>
  <li>CIPHER_get_bits
    <p class="Pp">Returns the number of secret bits used for cipher.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::CIPHER_get_bits($c);
 # $c - value corresponding to openssl's SSL_CIPHER structure
 #
 # returns: (integert) number of secret bits, 0 on error
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_CIPHER_get_name.html&gt;</p>
  </li>
</ul>
<p class="Pp"><i>Low level API: RSA_* related functions</i></p>
<ul class="Bl-bullet">
  <li>RSA_generate_key
    <p class="Pp">Generates a key pair and returns it in a newly allocated RSA
        structure. The pseudo-random number generator must be seeded prior to
        calling RSA_generate_key.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::RSA_generate_key($bits, $e, $perl_cb, $perl_cb_arg);
 # $bits - (integer) modulus size in bits e.g. 512, 1024, 2048
 # $e - (integer) public exponent, an odd number, typically 3, 17 or 65537
 # $perl_cb - [optional] reference to perl callback function
 # $perl_cb_arg - [optional] data that will be passed to callback function when invoked
 #
 # returns: value corresponding to openssl's RSA structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/RSA_generate_key.html&gt;</p>
  </li>
  <li>RSA_free
    <p class="Pp">Frees the RSA structure and its components. The key is erased
        before the memory is returned to the system.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::RSA_free($r);
 # $r - value corresponding to openssl's RSA structure
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/RSA_new.html&gt;</p>
  </li>
  <li>RSA_get_key_parameters
    <p class="Pp">Returns a list of pointers to BIGNUMs representing the
        parameters of the key in this order: (n, e, d, p, q, dmp1, dmq1, iqmp)
        Caution: returned list consists of SV pointers to BIGNUMs, which would
        need to be blessed as Crypt::OpenSSL::Bignum for further use</p>
    <p class="Pp">my (@params) = RSA_get_key_parameters($r);</p>
  </li>
</ul>
<p class="Pp"><i>Low level API: BIO_* related functions</i></p>
<ul class="Bl-bullet">
  <li>BIO_eof
    <p class="Pp">Returns 1 if the BIO has read EOF, the precise meaning of
        'EOF' varies according to the BIO type.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::BIO_eof($s);
 # $s - value corresponding to openssl's BIO structure
 #
 # returns: 1 if EOF has been reached 0 otherwise
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/BIO_ctrl.html&gt;</p>
  </li>
  <li>BIO_f_ssl
    <p class="Pp">Returns the SSL BIO method. This is a filter BIO which is a
        wrapper round the OpenSSL SSL routines adding a BIO 'flavour' to SSL
        I/O.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::BIO_f_ssl();
 #
 # returns: value corresponding to openssl's BIO_METHOD structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/BIO_f_ssl.html&gt;</p>
  </li>
  <li>BIO_free
    <p class="Pp">Frees up a single BIO.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::BIO_free($bio;);
 # $bio; - value corresponding to openssl's BIO structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/BIO_new.html&gt;</p>
  </li>
  <li>BIO_new
    <p class="Pp">Returns a new BIO using method
      <span class="Li">$type</span></p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::BIO_new($type);
 # $type - value corresponding to openssl's BIO_METHOD structure
 #
 # returns: value corresponding to openssl's BIO structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/BIO_new.html&gt;</p>
  </li>
  <li>BIO_new_buffer_ssl_connect
    <p class="Pp">Creates a new BIO chain consisting of a buffering BIO, an SSL
        BIO (using ctx) and a connect BIO.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::BIO_new_buffer_ssl_connect($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: value corresponding to openssl's BIO structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/BIO_f_ssl.html&gt;</p>
  </li>
  <li>BIO_new_file
    <p class="Pp">Creates a new file BIO with mode <span class="Li">$mode</span>
        the meaning of mode is the same as the stdio function <b>fopen()</b>.
        The BIO_CLOSE flag is set on the returned BIO.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::BIO_new_file($filename, $mode);
 # $filename - (string) filename
 # $mode - (string) opening mode (as mode by stdio function fopen)
 #
 # returns: value corresponding to openssl's BIO structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/BIO_s_file.html&gt;</p>
  </li>
  <li>BIO_new_ssl
    <p class="Pp">Allocates an SSL BIO using SSL_CTX ctx and using client mode
        if client is non zero.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::BIO_new_ssl($ctx, $client);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $client - (integer) 0 or 1 - indicates ssl client mode
 #
 # returns: value corresponding to openssl's BIO structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/BIO_f_ssl.html&gt;</p>
  </li>
  <li>BIO_new_ssl_connect
    <p class="Pp">Creates a new BIO chain consisting of an SSL BIO (using ctx)
        followed by a connect BIO.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::BIO_new_ssl_connect($ctx);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 #
 # returns: value corresponding to openssl's BIO structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/BIO_f_ssl.html&gt;</p>
  </li>
  <li>BIO_pending
    <p class="Pp">Return the number of pending characters in the BIOs read
        buffers.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::BIO_pending($s);
 # $s - value corresponding to openssl's BIO structure
 #
 # returns: the amount of pending data
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/BIO_ctrl.html&gt;</p>
  </li>
  <li>BIO_wpending
    <p class="Pp">Return the number of pending characters in the BIOs write
        buffers.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::BIO_wpending($s);
 # $s - value corresponding to openssl's BIO structure
 #
 # returns: the amount of pending data
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/BIO_ctrl.html&gt;</p>
  </li>
  <li>BIO_read
    <p class="Pp">Read the underlying descriptor.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::BIO_read($s, $max);
 # $s - value corresponding to openssl's BIO structure
 # $max - [optional] max. bytes to read (if not specified, the value 32768 is used)
 #
 # returns: data
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/BIO_read.html&gt;</p>
  </li>
  <li>BIO_write
    <p class="Pp">Attempts to write data from <span class="Li">$buffer</span> to
        BIO <span class="Li">$b</span>.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::BIO_write($b, $buffer);
 # $b - value corresponding to openssl's BIO structure
 # $buffer - data
 #
 # returns: amount of data successfully written
 #          or that no data was successfully read or written if the result is 0 or -1
 #          or -2 when the operation is not implemented in the specific BIO type
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/BIO_read.html&gt;</p>
  </li>
  <li>BIO_s_mem
    <p class="Pp">Return the memory BIO method function.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::BIO_s_mem();
 #
 # returns: value corresponding to openssl's BIO_METHOD structure (0 on failure)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/BIO_s_mem.html&gt;</p>
  </li>
  <li>BIO_ssl_copy_session_id
    <p class="Pp">Copies an SSL session id between BIO chains from and to. It
        does this by locating the SSL BIOs in each chain and calling
        <b>SSL_copy_session_id()</b> on the internal SSL pointer.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::BIO_ssl_copy_session_id($to, $from);
 # $to - value corresponding to openssl's BIO structure
 # $from - value corresponding to openssl's BIO structure
 #
 # returns: 1 on success, 0 on failure
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/BIO_f_ssl.html&gt;</p>
  </li>
  <li>BIO_ssl_shutdown
    <p class="Pp">Closes down an SSL connection on BIO chain bio. It does this
        by locating the SSL BIO in the chain and calling <b>SSL_shutdown()</b>
        on its internal SSL pointer.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::BIO_ssl_shutdown($ssl_bio);
 # $ssl_bio - value corresponding to openssl's BIO structure
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/BIO_f_ssl.html&gt;</p>
  </li>
</ul>
<p class="Pp"><i>Low level API: Server side Server Name Indication (SNI)
    support</i></p>
<ul class="Bl-bullet">
  <li>set_tlsext_host_name
    <p class="Pp">TBA</p>
  </li>
  <li>get_servername
    <p class="Pp">TBA</p>
  </li>
  <li>get_servername_type
    <p class="Pp">TBA</p>
  </li>
  <li>CTX_set_tlsext_servername_callback
    <p class="Pp"><b>COMPATIBILITY:</b> requires at least OpenSSL 0.9.8f</p>
    <p class="Pp">This function is used in a server to support Server side
        Server Name Indication (SNI).</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::CTX_set_tlsext_servername_callback($ctx, $code)
 # $ctx - SSL context
 # $code - reference to a subroutine that will be called when a new connection is being initiated
 #
 # returns: no return value
On the client side:
use set_tlsext_host_name($ssl, $servername) before initiating the SSL connection.
    </pre>
    <p class="Pp">On the server side: Set up an additional <b>SSL_CTX()</b> for
        each different certificate;</p>
    <p class="Pp">Add a servername callback to each <b>SSL_CTX()</b> using
        <b>CTX_set_tlsext_servername_callback()</b>;</p>
    <p class="Pp">The callback function is required to retrieve the
        client-supplied servername with get_servername(ssl). Figure out the
        right SSL_CTX to go with that host name, then switch the SSL object to
        that SSL_CTX with <b>set_SSL_CTX()</b>.</p>
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>
 # set callback
 Net::SSLeay::CTX_set_tlsext_servername_callback($ctx, 
    sub {
      my $ssl = shift;
      my $h = Net::SSLeay::get_servername($ssl);
      Net::SSLeay::set_SSL_CTX($ssl, $hostnames{$h}-&gt;{ctx}) if exists $hostnames{$h};
    } );
    </pre>
    <p class="Pp">More complete example:</p>
    <p class="Pp"></p>
    <pre>
 # ... initialize Net::SSLeay

 my %hostnames = (
   'sni1' =&gt; { cert=&gt;'sni1.pem', key=&gt;'sni1.key' },
   'sni2' =&gt; { cert=&gt;'sni2.pem', key=&gt;'sni2.key' },
 );

 # create a new context for each certificate/key pair
 for my $name (keys %hostnames) {
   $hostnames{$name}-&gt;{ctx} = Net::SSLeay::CTX_new or die;
   Net::SSLeay::CTX_set_cipher_list($hostnames{$name}-&gt;{ctx}, 'ALL');
   Net::SSLeay::set_cert_and_key($hostnames{$name}-&gt;{ctx},
   $hostnames{$name}-&gt;{cert}, $hostnames{$name}-&gt;{key}) or die;
 }

 # create default context
 my $ctx = Net::SSLeay::CTX_new or die;
 Net::SSLeay::CTX_set_cipher_list($ctx, 'ALL');
 Net::SSLeay::set_cert_and_key($ctx, 'cert.pem','key.pem') or die;

 # set callback
 Net::SSLeay::CTX_set_tlsext_servername_callback($ctx, sub {
   my $ssl = shift;
   my $h = Net::SSLeay::get_servername($ssl);
   Net::SSLeay::set_SSL_CTX($ssl, $hostnames{$h}-&gt;{ctx}) if exists $hostnames{$h};
   } );

 # ... later

 $s = Net::SSLeay::new($ctx);
 Net::SSLeay::set_fd($s, fileno($accepted_socket));
 Net::SSLeay::accept($s);
    </pre>
  </li>
</ul>
<p class="Pp"><i>Low level API: NPN (next protocol negotiation) related
    functions</i></p>
<p class="Pp">NPN is being replaced with ALPN, a more recent TLS extension for
    application protocol negotiation that's in process of being adopted by IETF.
    Please look below for APLN API description.</p>
<p class="Pp">Simple approach for using NPN support looks like this:</p>
<p class="Pp"></p>
<pre>
 ### client side
 use Net::SSLeay;
 use IO::Socket::INET;

 Net::SSLeay::initialize();
 my $sock = IO::Socket::INET-&gt;new(PeerAddr=&gt;'encrypted.google.com:443') or die;
 my $ctx = Net::SSLeay::CTX_tlsv1_new() or die;
 Net::SSLeay::CTX_set_options($ctx, &amp;Net::SSLeay::OP_ALL);
 Net::SSLeay::CTX_set_next_proto_select_cb($ctx, ['http1.1','spdy/2']);
 my $ssl = Net::SSLeay::new($ctx) or die;
 Net::SSLeay::set_fd($ssl, fileno($sock)) or die;
 Net::SSLeay::connect($ssl);

 warn &quot;client:negotiated=&quot;,Net::SSLeay::P_next_proto_negotiated($ssl), &quot;\n&quot;;
 warn &quot;client:last_status=&quot;, Net::SSLeay::P_next_proto_last_status($ssl), &quot;\n&quot;;
 
 ### server side 
 use Net::SSLeay;
 use IO::Socket::INET;
 
 Net::SSLeay::initialize();
 my $ctx = Net::SSLeay::CTX_tlsv1_new() or die;
 Net::SSLeay::CTX_set_options($ctx, &amp;Net::SSLeay::OP_ALL);
 Net::SSLeay::set_cert_and_key($ctx, &quot;cert.pem&quot;, &quot;key.pem&quot;);
 Net::SSLeay::CTX_set_next_protos_advertised_cb($ctx, ['spdy/2','http1.1']);
 my $sock = IO::Socket::INET-&gt;new(LocalAddr=&gt;'localhost', LocalPort=&gt;5443, Proto=&gt;'tcp', Listen=&gt;20) or die;
 
 while (1) {
   my $ssl = Net::SSLeay::new($ctx);
   warn(&quot;server:waiting for incoming connection...\n&quot;);
   my $fd = $sock-&gt;accept();
   Net::SSLeay::set_fd($ssl, $fd-&gt;fileno);
   Net::SSLeay::accept($ssl);  
   warn &quot;server:negotiated=&quot;,Net::SSLeay::P_next_proto_negotiated($ssl),&quot;\n&quot;;
   my $got = Net::SSLeay::read($ssl);
   Net::SSLeay::ssl_write_all($ssl, &quot;length=&quot;.length($got));
   Net::SSLeay::free($ssl);
   $fd-&gt;close();
 }
 # check with: openssl s_client -connect localhost:5443 -nextprotoneg http/1.1,spdy/2
</pre>
<p class="Pp">Please note that the selection (negotiation) is performed by
    client side, the server side simply advertise the list of supported
    protocols.</p>
<p class="Pp">Advanced approach allows you to implement your own negotiation
    algorithm.</p>
<p class="Pp"></p>
<pre>
 #see below documentation for:
 Net::SSleay::CTX_set_next_proto_select_cb($ctx, $perl_callback_function, $callback_data);
 Net::SSleay::CTX_set_next_protos_advertised_cb($ctx, $perl_callback_function, $callback_data);
</pre>
<p class="Pp">Detection of NPN support (works even in older Net::SSLeay
    versions):</p>
<p class="Pp"></p>
<pre>
 use Net::SSLeay;
 
 if (exists &amp;Net::SSLeay::P_next_proto_negotiated) {
   # do NPN stuff
 }
</pre>
<ul class="Bl-bullet">
  <li>CTX_set_next_proto_select_cb
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before; requires at least openssl-1.0.1</p>
    <p class="Pp"><b>NOTE:</b> You need CTX_set_next_proto_select_cb on
        <b>client side</b> of SSL connection.</p>
    <p class="Pp">Simple usage - in this case a &quot;common&quot; negotiation
        algorithm (as implemented by openssl's function SSL_select_next_proto)
        is used.</p>
    <p class="Pp"></p>
    <pre>
 $rv = Net::SSleay::CTX_set_next_proto_select_cb($ctx, $arrayref);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $arrayref - list of accepted protocols - e.g. ['http1.0', 'http1.1']
 #
 # returns: 0 on success, 1 on failure
    </pre>
    <p class="Pp">Advanced usage (you probably do not need this):</p>
    <p class="Pp"></p>
    <pre>
 $rv = Net::SSleay::CTX_set_next_proto_select_cb($ctx, $perl_callback_function, $callback_data);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $perl_callback_function - reference to perl function
 # $callback_data - [optional] data to passed to callback function when invoked
 #
 # returns: 0 on success, 1 on failure
 
 # where callback function looks like
 sub npn_advertised_cb_invoke {
   my ($ssl, $arrayref_proto_list_advertised_by_server, $callback_data) = @_;
   my $status;
   # ...
   $status = 1;   #status can be:
                  # 0 - OPENSSL_NPN_UNSUPPORTED
                  # 1 - OPENSSL_NPN_NEGOTIATED
                  # 2 - OPENSSL_NPN_NO_OVERLAP
   return $status, ['http1.1','spdy/2']; # the callback has to return 2 values
 }
    </pre>
    <p class="Pp">To undefine/clear this callback use:</p>
    <p class="Pp"></p>
    <pre>
 Net::SSleay::CTX_set_next_proto_select_cb($ctx, undef);
    </pre>
  </li>
  <li>CTX_set_next_protos_advertised_cb
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before; requires at least openssl-1.0.1</p>
    <p class="Pp"><b>NOTE:</b> You need CTX_set_next_proto_select_cb on
        <b>server side</b> of SSL connection.</p>
    <p class="Pp">Simple usage:</p>
    <p class="Pp"></p>
    <pre>
 $rv = Net::SSleay::CTX_set_next_protos_advertised_cb($ctx, $arrayref);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $arrayref - list of advertised protocols - e.g. ['http1.0', 'http1.1']
 #
 # returns: 0 on success, 1 on failure
    </pre>
    <p class="Pp">Advanced usage (you probably do not need this):</p>
    <p class="Pp"></p>
    <pre>
 $rv = Net::SSleay::CTX_set_next_protos_advertised_cb($ctx, $perl_callback_function, $callback_data);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $perl_callback_function - reference to perl function
 # $callback_data - [optional] data to passed to callback function when invoked
 #
 # returns: 0 on success, 1 on failure
 
 # where callback function looks like
 sub npn_advertised_cb_invoke {
   my ($ssl, $callback_data) = @_;
   # ...
   return ['http1.1','spdy/2']; # the callback has to return arrayref
 }
    </pre>
    <p class="Pp">To undefine/clear this callback use:</p>
    <p class="Pp"></p>
    <pre>
 Net::SSleay::CTX_set_next_protos_advertised_cb($ctx, undef);
    </pre>
  </li>
  <li>P_next_proto_negotiated
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before; requires at least openssl-1.0.1</p>
    <p class="Pp">Returns the name of negotiated protocol for given SSL
        connection <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 $rv = Net::SSLeay::P_next_proto_negotiated($ssl)
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: (string) negotiated protocol name (or undef if no negotiation was done or failed with fatal error)
    </pre>
  </li>
  <li>P_next_proto_last_status
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.45 and
        before; requires at least openssl-1.0.1</p>
    <p class="Pp">Returns the result of the last negotiation for given SSL
        connection <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 $rv = Net::SSLeay::P_next_proto_last_status($ssl)
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: (integer) negotiation status
 #          0 - OPENSSL_NPN_UNSUPPORTED
 #          1 - OPENSSL_NPN_NEGOTIATED
 #          2 - OPENSSL_NPN_NO_OVERLAP
    </pre>
  </li>
</ul>
<p class="Pp"><i>Low level API: ALPN (application layer protocol negotiation)
    related functions</i></p>
<p class="Pp">Application protocol can be negotiated via two different
    mechanisms employing two different TLS extensions: NPN (obsolete) and ALPN
    (recommended).</p>
<p class="Pp">The API is rather similar, with slight differences reflecting
    protocol specifics. In particular, with ALPN the protocol negotiation takes
    place on server, while with NPN the client implements the protocol
    negotiation logic.</p>
<p class="Pp">With ALPN, the most basic implementation looks like this:</p>
<p class="Pp"></p>
<pre>
 ### client side
 use Net::SSLeay;
 use IO::Socket::INET;

 Net::SSLeay::initialize();
 my $sock = IO::Socket::INET-&gt;new(PeerAddr=&gt;'encrypted.google.com:443') or die;
 my $ctx = Net::SSLeay::CTX_tlsv1_new() or die;
 Net::SSLeay::CTX_set_options($ctx, &amp;Net::SSLeay::OP_ALL);
 Net::SSLeay::CTX_set_alpn_protos($ctx, ['http/1.1', 'http/2.0', 'spdy/3]);
 my $ssl = Net::SSLeay::new($ctx) or die;
 Net::SSLeay::set_fd($ssl, fileno($sock)) or die;
 Net::SSLeay::connect($ssl);

 warn &quot;client:selected=&quot;,Net::SSLeay::P_alpn_selected($ssl), &quot;\n&quot;;

 ### server side
 use Net::SSLeay;
 use IO::Socket::INET;

 Net::SSLeay::initialize();
 my $ctx = Net::SSLeay::CTX_tlsv1_new() or die;
 Net::SSLeay::CTX_set_options($ctx, &amp;Net::SSLeay::OP_ALL);
 Net::SSLeay::set_cert_and_key($ctx, &quot;cert.pem&quot;, &quot;key.pem&quot;);
 Net::SSLeay::CTX_set_alpn_select_cb($ctx, ['http/1.1', 'http/2.0', 'spdy/3]);
 my $sock = IO::Socket::INET-&gt;new(LocalAddr=&gt;'localhost', LocalPort=&gt;5443, Proto=&gt;'tcp', Listen=&gt;20) or die;

 while (1) {
   my $ssl = Net::SSLeay::new($ctx);
   warn(&quot;server:waiting for incoming connection...\n&quot;);
   my $fd = $sock-&gt;accept();
   Net::SSLeay::set_fd($ssl, $fd-&gt;fileno);
   Net::SSLeay::accept($ssl);
   warn &quot;server:selected=&quot;,Net::SSLeay::P_alpn_selected($ssl),&quot;\n&quot;;
   my $got = Net::SSLeay::read($ssl);
   Net::SSLeay::ssl_write_all($ssl, &quot;length=&quot;.length($got));
   Net::SSLeay::free($ssl);
   $fd-&gt;close();
 }
 # check with: openssl s_client -connect localhost:5443 -alpn spdy/3,http/1.1
</pre>
<p class="Pp">Advanced approach allows you to implement your own negotiation
    algorithm.</p>
<p class="Pp"></p>
<pre>
 #see below documentation for:
 Net::SSleay::CTX_set_alpn_select_cb($ctx, $perl_callback_function, $callback_data);
</pre>
<p class="Pp">Detection of ALPN support (works even in older Net::SSLeay
    versions):</p>
<p class="Pp"></p>
<pre>
 use Net::SSLeay;

 if (exists &amp;Net::SSLeay::P_alpn_selected) {
   # do ALPN stuff
 }
</pre>
<ul class="Bl-bullet">
  <li>CTX_set_alpn_select_cb
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.55 and
        before; requires at least openssl-1.0.2</p>
    <p class="Pp"><b>NOTE:</b> You need CTX_set_alpn_select_cb on <b>server
        side</b> of TLS connection.</p>
    <p class="Pp">Simple usage - in this case a &quot;common&quot; negotiation
        algorithm (as implemented by openssl's function SSL_select_next_proto)
        is used.</p>
    <p class="Pp"></p>
    <pre>
 $rv = Net::SSleay::CTX_set_alpn_select_cb($ctx, $arrayref);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $arrayref - list of accepted protocols - e.g. ['http/2.0', 'http/1.1', 'spdy/3']
 #
 # returns: 0 on success, 1 on failure
    </pre>
    <p class="Pp">Advanced usage (you probably do not need this):</p>
    <p class="Pp"></p>
    <pre>
 $rv = Net::SSleay::CTX_set_alpn_select_cb($ctx, $perl_callback_function, $callback_data);
 # $ctx - value corresponding to openssl's SSL_CTX structure
 # $perl_callback_function - reference to perl function
 # $callback_data - [optional] data to passed to callback function when invoked
 #
 # returns: 0 on success, 1 on failure

 # where callback function looks like
 sub alpn_select_cb_invoke {
   my ($ssl, $arrayref_proto_list_advertised_by_client, $callback_data) = @_;
   # ...
   if ($negotiated) {
     return 'http/2.0';
   } else {
     return undef;
   }
 }
    </pre>
    <p class="Pp">To undefine/clear this callback use:</p>
    <p class="Pp"></p>
    <pre>
 Net::SSleay::CTX_set_alpn_select_cb($ctx, undef);
    </pre>
  </li>
  <li>set_alpn_protos
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.55 and
        before; requires at least openssl-1.0.2</p>
    <p class="Pp"><b>NOTE:</b> You need set_alpn_protos on <b>client side</b> of
        TLS connection.</p>
    <p class="Pp">This adds list of supported application layer protocols to
        ClientHello message sent by a client. It advertises the enumeration of
        supported protocols:</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::set_alpn_protos($ssl, ['http/1.1', 'http/2.0', 'spdy/3]);
 # returns 0 on success
    </pre>
  </li>
  <li>CTX_set_alpn_protos
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.55 and
        before; requires at least openssl-1.0.2</p>
    <p class="Pp"><b>NOTE:</b> You need CTX_set_alpn_protos on <b>client
        side</b> of TLS connection.</p>
    <p class="Pp">This adds list of supported application layer protocols to
        ClientHello message sent by a client. It advertises the enumeration of
        supported protocols:</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::CTX_set_alpn_protos($ctx, ['http/1.1', 'http/2.0', 'spdy/3]);
 # returns 0 on success
    </pre>
  </li>
  <li>P_alpn_selected
    <p class="Pp"><b>COMPATIBILITY:</b> not available in Net-SSLeay-1.55 and
        before; requires at least openssl-1.0.2</p>
    <p class="Pp">Returns the name of negotiated protocol for given TLS
        connection <span class="Li">$ssl</span>.</p>
    <p class="Pp"></p>
    <pre>
 $rv = Net::SSLeay::P_alpn_selected($ssl)
 # $ssl - value corresponding to openssl's SSL structure
 #
 # returns: (string) negotiated protocol name (or undef if no negotiation was done or failed with fatal error)
    </pre>
  </li>
</ul>
<p class="Pp"><i>Low level API: DANE Support</i></p>
<p class="Pp">OpenSSL version 1.0.2 adds preliminary support RFC6698 Domain
    Authentication of Named Entities (DANE) Transport Layer Association within
    OpenSSL</p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>SSL_get_tlsa_record_byname
    <p class="Pp"><b>COMPATIBILITY:</b> DELETED from net-ssleay, since it is not
        supported by OpenSSL</p>
    <p class="Pp">In order to facilitate DANE there is additional interface,
        SSL_get_tlsa_record_byname, accepting hostname, port and socket type
        that returns packed TLSA record. In order to make it even easier there
        is additional SSL_ctrl function that calls SSL_get_tlsa_record_byname
        for you. Latter is recommended for programmers that wish to maintain
        broader binary compatibility, e.g. make application work with both 1.0.2
        and prior version (in which case call to SSL_ctrl with new code
        returning error would have to be ignored when running with prior
        version).</p>
    <p class="Pp">Net::SSLeay::get_tlsa_record_byname($name,
        <span class="Li">$port</span>, <span class="Li">$type</span>);</p>
  </dd>
</dl>
<p class="Pp"><i>Low level API: Other functions</i></p>
<ul class="Bl-bullet">
  <li>COMP_add_compression_method
    <p class="Pp">Adds the compression method cm with the identifier id to the
        list of available compression methods. This list is globally maintained
        for all SSL operations within this application. It cannot be set for
        specific SSL_CTX or SSL objects.</p>
    <p class="Pp"></p>
    <pre>
 my $rv = Net::SSLeay::COMP_add_compression_method($id, $cm);
 # $id - (integer) compression method id
 #       0 to 63:    methods defined by the IETF
 #       64 to 192:  external party methods assigned by IANA
 #       193 to 255: reserved for private use
 #
 # $cm - value corresponding to openssl's COMP_METHOD structure
 #
 # returns: 0 on success, 1 on failure (check the error queue to find out the reason)
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/ssl/SSL_COMP_add_compression_method.html&gt;</p>
  </li>
  <li>DH_free
    <p class="Pp">Frees the DH structure and its components. The values are
        erased before the memory is returned to the system.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay::DH_free($dh);
 # $dh - value corresponding to openssl's DH structure
 #
 # returns: no return value
    </pre>
    <p class="Pp">Check openssl doc
        &lt;http://www.openssl.org/docs/crypto/DH_new.html&gt;</p>
  </li>
  <li>FIPS_mode_set
    <p class="Pp">Enable or disable FIPS mode in a FIPS capable OpenSSL.</p>
    <p class="Pp"></p>
    <pre>
 Net::SSLeay:: FIPS_mode_set($enable);
 # $enable - (integer) 1 to enable, 0 to disable
    </pre>
  </li>
</ul>
<p class="Pp"><i>Low level API: EC related functions</i></p>
<ul class="Bl-bullet">
  <li>CTX_set_tmp_ecdh
    <p class="Pp">TBA</p>
  </li>
  <li>EC_KEY_free
    <p class="Pp">TBA</p>
  </li>
  <li>EC_KEY_new_by_curve_name
    <p class="Pp">TBA</p>
  </li>
  <li>EC_KEY_generate_key
    <p class="Pp">Generates a EC key and returns it in a newly allocated EC_KEY
        structure. The EC key then can be used to create a PKEY which can be
        used in calls like X509_set_pubkey.</p>
    <p class="Pp"></p>
    <pre>
 my $key = Net::SSLeay::EVP_PKEY_new();
 my $ec  = Net::SSLeay::EC_KEY_generate_key($curve);
 Net::SSLeay::EVP_PKEY_assign_EC_KEY($key,$ec);

 # $curve - curve name like 'secp521r1' or the matching Id (integer) of the curve
 #
 # returns: value corresponding to openssl's EC_KEY structure (0 on failure)
    </pre>
    <p class="Pp">This function has no equivalent in OpenSSL but combines
        multiple OpenSSL functions for an easier interface.</p>
  </li>
  <li>CTX_set_ecdh_auto, set_ecdh_auto
    <p class="Pp">These functions enable or disable the automatic curve
        selection on the server side by calling SSL_CTX_set_ecdh_auto or
        SSL_set_ecdh_auto respectively. If enabled the highest preference curve
        is automatically used for ECDH temporary keys used during key exchange.
        This function is no longer available for OpenSSL 1.1.0 or higher.</p>
    <p class="Pp"></p>
    <pre>
  Net::SSLeay::CTX_set_ecdh_auto($ctx,1);
  Net::SSLeay::set_ecdh_auto($ssl,1);
    </pre>
  </li>
  <li>CTX_set1_curves_list, set1_curves_list
    <p class="Pp">These functions set the supported curves (in order of
        preference) by calling SSL_CTX_set1_curves_list or SSL_set1_curves_list
        respectively. For a TLS client these curves are offered to the server in
        the supported curves extension while on the server side these are used
        to determine the shared curve. These functions are only available since
        OpenSSL 1.1.0.</p>
    <p class="Pp"></p>
    <pre>
  Net::SSLeay::CTX_set1_curves_list($ctx,&quot;P-521:P-384:P-256&quot;);
  Net::SSLeay::set1_curves_list($ssl,&quot;P-521:P-384:P-256&quot;);
    </pre>
  </li>
  <li>CTX_set1_groups_list, set1_groups_list
    <p class="Pp">These functions set the supported groups (in order of
        preference) by calling SSL_CTX_set1_groups_list or SSL_set1_groups_list
        respectively. This is practically the same as CTX_set1_curves_list and
        set1_curves_list except that all DH groups can be given as supported by
        TLS 1.3. These functions are only available since OpenSSL 1.1.1.</p>
    <p class="Pp"></p>
    <pre>
  Net::SSLeay::CTX_set1_groups_list($ctx,&quot;P-521:P-384:P-256&quot;);
  Net::SSLeay::set1_groups_list($ssl,&quot;P-521:P-384:P-256&quot;);
    </pre>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Constants"><a class="permalink" href="#Constants">Constants</a></h2>
<p class="Pp">There are many openssl constants available in Net::SSLeay. You can
    use them like this:</p>
<p class="Pp"></p>
<pre>
 use Net::SSLeay;
 print &amp;Net::SSLeay::NID_commonName;
 #or
 print Net::SSLeay::NID_commonName();
</pre>
<p class="Pp">Or you can import them and use:</p>
<p class="Pp"></p>
<pre>
 use Net::SSLeay qw/NID_commonName/;
 print &amp;NID_commonName;
 #or
 print NID_commonName();
 #or
 print NID_commonName;
</pre>
<p class="Pp">The constants names are derived from openssl constants, however
    constants starting with <span class="Li">&quot;SSL_&quot;</span> prefix have
    name with <span class="Li">&quot;SSL_&quot;</span> part stripped - e.g.
    openssl's constant <span class="Li">&quot;SSL_OP_ALL&quot;</span> is
    available as <span class="Li">&quot;Net::SSleay::OP_ALL&quot;</span></p>
<p class="Pp">The list of all available constant names:</p>
<p class="Pp"></p>
<pre>
 ASN1_STRFLGS_ESC_CTRL           NID_netscape                              R_UNKNOWN_REMOTE_ERROR_TYPE
 ASN1_STRFLGS_ESC_MSB            NID_netscape_base_url                     R_UNKNOWN_STATE
 ASN1_STRFLGS_ESC_QUOTE          NID_netscape_ca_policy_url                R_X509_LIB
 ASN1_STRFLGS_RFC2253            NID_netscape_ca_revocation_url            SENT_SHUTDOWN
 CB_ACCEPT_EXIT                  NID_netscape_cert_extension               SESSION_ASN1_VERSION
 CB_ACCEPT_LOOP                  NID_netscape_cert_sequence                SESS_CACHE_BOTH
 CB_ALERT                        NID_netscape_cert_type                    SESS_CACHE_CLIENT
 CB_CONNECT_EXIT                 NID_netscape_comment                      SESS_CACHE_NO_AUTO_CLEAR
 CB_CONNECT_LOOP                 NID_netscape_data_type                    SESS_CACHE_NO_INTERNAL
 CB_EXIT                         NID_netscape_renewal_url                  SESS_CACHE_NO_INTERNAL_LOOKUP
 CB_HANDSHAKE_DONE               NID_netscape_revocation_url               SESS_CACHE_NO_INTERNAL_STORE
 CB_HANDSHAKE_START              NID_netscape_ssl_server_name              SESS_CACHE_OFF
 CB_LOOP                         NID_ns_sgc                                SESS_CACHE_SERVER
 CB_READ                         NID_organizationName                      SSL3_VERSION
 CB_READ_ALERT                   NID_organizationalUnitName                SSLEAY_BUILT_ON
 CB_WRITE                        NID_pbeWithMD2AndDES_CBC                  SSLEAY_CFLAGS
 CB_WRITE_ALERT                  NID_pbeWithMD2AndRC2_CBC                  SSLEAY_DIR
 ERROR_NONE                      NID_pbeWithMD5AndCast5_CBC                SSLEAY_PLATFORM
 ERROR_SSL                       NID_pbeWithMD5AndDES_CBC                  SSLEAY_VERSION
 ERROR_SYSCALL                   NID_pbeWithMD5AndRC2_CBC                  ST_ACCEPT
 ERROR_WANT_ACCEPT               NID_pbeWithSHA1AndDES_CBC                 ST_BEFORE
 ERROR_WANT_CONNECT              NID_pbeWithSHA1AndRC2_CBC                 ST_CONNECT
 ERROR_WANT_READ                 NID_pbe_WithSHA1And128BitRC2_CBC          ST_INIT
 ERROR_WANT_WRITE                NID_pbe_WithSHA1And128BitRC4              ST_OK
 ERROR_WANT_X509_LOOKUP          NID_pbe_WithSHA1And2_Key_TripleDES_CBC    ST_READ_BODY
 ERROR_ZERO_RETURN               NID_pbe_WithSHA1And3_Key_TripleDES_CBC    ST_READ_HEADER
 EVP_PKS_DSA                     NID_pbe_WithSHA1And40BitRC2_CBC           TLS1_1_VERSION
 EVP_PKS_EC                      NID_pbe_WithSHA1And40BitRC4               TLS1_2_VERSION
 EVP_PKS_RSA                     NID_pbes2                                 TLS1_3_VERSION
 EVP_PKT_ENC                     NID_pbmac1                                TLS1_VERSION
 EVP_PKT_EXCH                    NID_pkcs                                  TLSEXT_STATUSTYPE_ocsp
 EVP_PKT_EXP                     NID_pkcs3                                 VERIFY_CLIENT_ONCE
 EVP_PKT_SIGN                    NID_pkcs7                                 VERIFY_FAIL_IF_NO_PEER_CERT
 EVP_PK_DH                       NID_pkcs7_data                            VERIFY_NONE
 EVP_PK_DSA                      NID_pkcs7_digest                          VERIFY_PEER
 EVP_PK_EC                       NID_pkcs7_encrypted                       VERIFY_POST_HANDSHAKE
 EVP_PK_RSA                      NID_pkcs7_enveloped                       V_OCSP_CERTSTATUS_GOOD
 FILETYPE_ASN1                   NID_pkcs7_signed                          V_OCSP_CERTSTATUS_REVOKED
 FILETYPE_PEM                    NID_pkcs7_signedAndEnveloped              V_OCSP_CERTSTATUS_UNKNOWN
 F_CLIENT_CERTIFICATE            NID_pkcs8ShroudedKeyBag                   WRITING
 F_CLIENT_HELLO                  NID_pkcs9                                 X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT
 F_CLIENT_MASTER_KEY             NID_pkcs9_challengePassword               X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS
 F_D2I_SSL_SESSION               NID_pkcs9_contentType                     X509_CHECK_FLAG_NEVER_CHECK_SUBJECT
 F_GET_CLIENT_FINISHED           NID_pkcs9_countersignature                X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS
 F_GET_CLIENT_HELLO              NID_pkcs9_emailAddress                    X509_CHECK_FLAG_NO_WILDCARDS
 F_GET_CLIENT_MASTER_KEY         NID_pkcs9_extCertAttributes               X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS
 F_GET_SERVER_FINISHED           NID_pkcs9_messageDigest                   X509_FILETYPE_ASN1
 F_GET_SERVER_HELLO              NID_pkcs9_signingTime                     X509_FILETYPE_DEFAULT
 F_GET_SERVER_VERIFY             NID_pkcs9_unstructuredAddress             X509_FILETYPE_PEM
 F_I2D_SSL_SESSION               NID_pkcs9_unstructuredName                X509_LOOKUP
 F_READ_N                        NID_private_key_usage_period              X509_PURPOSE_ANY
 F_REQUEST_CERTIFICATE           NID_rc2_40_cbc                            X509_PURPOSE_CRL_SIGN
 F_SERVER_HELLO                  NID_rc2_64_cbc                            X509_PURPOSE_NS_SSL_SERVER
 F_SSL_CERT_NEW                  NID_rc2_cbc                               X509_PURPOSE_OCSP_HELPER
 F_SSL_GET_NEW_SESSION           NID_rc2_cfb64                             X509_PURPOSE_SMIME_ENCRYPT
 F_SSL_NEW                       NID_rc2_ecb                               X509_PURPOSE_SMIME_SIGN
 F_SSL_READ                      NID_rc2_ofb64                             X509_PURPOSE_SSL_CLIENT
 F_SSL_RSA_PRIVATE_DECRYPT       NID_rc4                                   X509_PURPOSE_SSL_SERVER
 F_SSL_RSA_PUBLIC_ENCRYPT        NID_rc4_40                                X509_PURPOSE_TIMESTAMP_SIGN
 F_SSL_SESSION_NEW               NID_rc5_cbc                               X509_TRUST_COMPAT
 F_SSL_SESSION_PRINT_FP          NID_rc5_cfb64                             X509_TRUST_EMAIL
 F_SSL_SET_FD                    NID_rc5_ecb                               X509_TRUST_OBJECT_SIGN
 F_SSL_SET_RFD                   NID_rc5_ofb64                             X509_TRUST_OCSP_REQUEST
 F_SSL_SET_WFD                   NID_ripemd160                             X509_TRUST_OCSP_SIGN
 F_SSL_USE_CERTIFICATE           NID_ripemd160WithRSA                      X509_TRUST_SSL_CLIENT
 F_SSL_USE_CERTIFICATE_ASN1      NID_rle_compression                       X509_TRUST_SSL_SERVER
 F_SSL_USE_CERTIFICATE_FILE      NID_rsa                                   X509_TRUST_TSA
 F_SSL_USE_PRIVATEKEY            NID_rsaEncryption                         X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH
 F_SSL_USE_PRIVATEKEY_ASN1       NID_rsadsi                                X509_V_ERR_AKID_SKID_MISMATCH
 F_SSL_USE_PRIVATEKEY_FILE       NID_safeContentsBag                       X509_V_ERR_APPLICATION_VERIFICATION
 F_SSL_USE_RSAPRIVATEKEY         NID_sdsiCertificate                       X509_V_ERR_CA_KEY_TOO_SMALL
 F_SSL_USE_RSAPRIVATEKEY_ASN1    NID_secretBag                             X509_V_ERR_CA_MD_TOO_WEAK
 F_SSL_USE_RSAPRIVATEKEY_FILE    NID_serialNumber                          X509_V_ERR_CERT_CHAIN_TOO_LONG
 F_WRITE_PENDING                 NID_server_auth                           X509_V_ERR_CERT_HAS_EXPIRED
 GEN_DIRNAME                     NID_sha                                   X509_V_ERR_CERT_NOT_YET_VALID
 GEN_DNS                         NID_sha1                                  X509_V_ERR_CERT_REJECTED
 GEN_EDIPARTY                    NID_sha1WithRSA                           X509_V_ERR_CERT_REVOKED
 GEN_EMAIL                       NID_sha1WithRSAEncryption                 X509_V_ERR_CERT_SIGNATURE_FAILURE
 GEN_IPADD                       NID_shaWithRSAEncryption                  X509_V_ERR_CERT_UNTRUSTED
 GEN_OTHERNAME                   NID_stateOrProvinceName                   X509_V_ERR_CRL_HAS_EXPIRED
 GEN_RID                         NID_subject_alt_name                      X509_V_ERR_CRL_NOT_YET_VALID
 GEN_URI                         NID_subject_key_identifier                X509_V_ERR_CRL_PATH_VALIDATION_ERROR
 GEN_X400                        NID_surname                               X509_V_ERR_CRL_SIGNATURE_FAILURE
 LIBRESSL_VERSION_NUMBER         NID_sxnet                                 X509_V_ERR_DANE_NO_MATCH
 MBSTRING_ASC                    NID_time_stamp                            X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT
 MBSTRING_BMP                    NID_title                                 X509_V_ERR_DIFFERENT_CRL_SCOPE
 MBSTRING_FLAG                   NID_undef                                 X509_V_ERR_EE_KEY_TOO_SMALL
 MBSTRING_UNIV                   NID_uniqueIdentifier                      X509_V_ERR_EMAIL_MISMATCH
 MBSTRING_UTF8                   NID_x509Certificate                       X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD
 MIN_RSA_MODULUS_LENGTH_IN_BYTES NID_x509Crl                               X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD
 MODE_ACCEPT_MOVING_WRITE_BUFFER NID_zlib_compression                      X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD
 MODE_AUTO_RETRY                 NOTHING                                   X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD
 MODE_ENABLE_PARTIAL_WRITE       OCSP_RESPONSE_STATUS_INTERNALERROR        X509_V_ERR_EXCLUDED_VIOLATION
 MODE_RELEASE_BUFFERS            OCSP_RESPONSE_STATUS_MALFORMEDREQUEST     X509_V_ERR_HOSTNAME_MISMATCH
 NID_OCSP_sign                   OCSP_RESPONSE_STATUS_SIGREQUIRED          X509_V_ERR_INVALID_CA
 NID_SMIMECapabilities           OCSP_RESPONSE_STATUS_SUCCESSFUL           X509_V_ERR_INVALID_CALL
 NID_X500                        OCSP_RESPONSE_STATUS_TRYLATER             X509_V_ERR_INVALID_EXTENSION
 NID_X509                        OCSP_RESPONSE_STATUS_UNAUTHORIZED         X509_V_ERR_INVALID_NON_CA
 NID_ad_OCSP                     OPENSSL_BUILT_ON                          X509_V_ERR_INVALID_POLICY_EXTENSION
 NID_ad_ca_issuers               OPENSSL_CFLAGS                            X509_V_ERR_INVALID_PURPOSE
 NID_algorithm                   OPENSSL_DIR                               X509_V_ERR_IP_ADDRESS_MISMATCH
 NID_authority_key_identifier    OPENSSL_ENGINES_DIR                       X509_V_ERR_KEYUSAGE_NO_CERTSIGN
 NID_basic_constraints           OPENSSL_PLATFORM                          X509_V_ERR_KEYUSAGE_NO_CRL_SIGN
 NID_bf_cbc                      OPENSSL_VERSION                           X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE
 NID_bf_cfb64                    OPENSSL_VERSION_NUMBER                    X509_V_ERR_NO_EXPLICIT_POLICY
 NID_bf_ecb                      OP_ALL                                    X509_V_ERR_NO_VALID_SCTS
 NID_bf_ofb64                    OP_ALLOW_NO_DHE_KEX                       X509_V_ERR_OCSP_CERT_UNKNOWN
 NID_cast5_cbc                   OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION      X509_V_ERR_OCSP_VERIFY_FAILED
 NID_cast5_cfb64                 OP_CIPHER_SERVER_PREFERENCE               X509_V_ERR_OCSP_VERIFY_NEEDED
 NID_cast5_ecb                   OP_CISCO_ANYCONNECT                       X509_V_ERR_OUT_OF_MEM
 NID_cast5_ofb64                 OP_COOKIE_EXCHANGE                        X509_V_ERR_PATH_LENGTH_EXCEEDED
 NID_certBag                     OP_CRYPTOPRO_TLSEXT_BUG                   X509_V_ERR_PATH_LOOP
 NID_certificate_policies        OP_DONT_INSERT_EMPTY_FRAGMENTS            X509_V_ERR_PERMITTED_VIOLATION
 NID_client_auth                 OP_ENABLE_MIDDLEBOX_COMPAT                X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED
 NID_code_sign                   OP_EPHEMERAL_RSA                          X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED
 NID_commonName                  OP_LEGACY_SERVER_CONNECT                  X509_V_ERR_PROXY_SUBJECT_NAME_VIOLATION
 NID_countryName                 OP_MICROSOFT_BIG_SSLV3_BUFFER             X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN
 NID_crlBag                      OP_MICROSOFT_SESS_ID_BUG                  X509_V_ERR_STORE_LOOKUP
 NID_crl_distribution_points     OP_MSIE_SSLV2_RSA_PADDING                 X509_V_ERR_SUBJECT_ISSUER_MISMATCH
 NID_crl_number                  OP_NETSCAPE_CA_DN_BUG                     X509_V_ERR_SUBTREE_MINMAX
 NID_crl_reason                  OP_NETSCAPE_CHALLENGE_BUG                 X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256
 NID_delta_crl                   OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG        X509_V_ERR_SUITE_B_INVALID_ALGORITHM
 NID_des_cbc                     OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG       X509_V_ERR_SUITE_B_INVALID_CURVE
 NID_des_cfb64                   OP_NON_EXPORT_FIRST                       X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM
 NID_des_ecb                     OP_NO_ANTI_REPLAY                         X509_V_ERR_SUITE_B_INVALID_VERSION
 NID_des_ede                     OP_NO_CLIENT_RENEGOTIATION                X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED
 NID_des_ede3                    OP_NO_COMPRESSION                         X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY
 NID_des_ede3_cbc                OP_NO_ENCRYPT_THEN_MAC                    X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE
 NID_des_ede3_cfb64              OP_NO_QUERY_MTU                           X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE
 NID_des_ede3_ofb64              OP_NO_RENEGOTIATION                       X509_V_ERR_UNABLE_TO_GET_CRL
 NID_des_ede_cbc                 OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER
 NID_des_ede_cfb64               OP_NO_SSL_MASK                            X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT
 NID_des_ede_ofb64               OP_NO_SSLv2                               X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY
 NID_des_ofb64                   OP_NO_SSLv3                               X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE
 NID_description                 OP_NO_TICKET                              X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION
 NID_desx_cbc                    OP_NO_TLSv1                               X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION
 NID_dhKeyAgreement              OP_NO_TLSv1_1                             X509_V_ERR_UNNESTED_RESOURCE
 NID_dnQualifier                 OP_NO_TLSv1_2                             X509_V_ERR_UNSPECIFIED
 NID_dsa                         OP_NO_TLSv1_3                             X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX
 NID_dsaWithSHA                  OP_PKCS1_CHECK_1                          X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE
 NID_dsaWithSHA1                 OP_PKCS1_CHECK_2                          X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE
 NID_dsaWithSHA1_2               OP_PRIORITIZE_CHACHA                      X509_V_ERR_UNSUPPORTED_NAME_SYNTAX
 NID_dsa_2                       OP_SAFARI_ECDHE_ECDSA_BUG                 X509_V_FLAG_ALLOW_PROXY_CERTS
 NID_email_protect               OP_SINGLE_DH_USE                          X509_V_FLAG_CB_ISSUER_CHECK
 NID_ext_key_usage               OP_SINGLE_ECDH_USE                        X509_V_FLAG_CHECK_SS_SIGNATURE
 NID_ext_req                     OP_SSLEAY_080_CLIENT_DH_BUG               X509_V_FLAG_CRL_CHECK
 NID_friendlyName                OP_SSLREF2_REUSE_CERT_TYPE_BUG            X509_V_FLAG_CRL_CHECK_ALL
 NID_givenName                   OP_TLSEXT_PADDING                         X509_V_FLAG_EXPLICIT_POLICY
 NID_hmacWithSHA1                OP_TLS_BLOCK_PADDING_BUG                  X509_V_FLAG_EXTENDED_CRL_SUPPORT
 NID_id_ad                       OP_TLS_D5_BUG                             X509_V_FLAG_IGNORE_CRITICAL
 NID_id_ce                       OP_TLS_ROLLBACK_BUG                       X509_V_FLAG_INHIBIT_ANY
 NID_id_kp                       READING                                   X509_V_FLAG_INHIBIT_MAP
 NID_id_pbkdf2                   RECEIVED_SHUTDOWN                         X509_V_FLAG_NOTIFY_POLICY
 NID_id_pe                       RSA_3                                     X509_V_FLAG_NO_ALT_CHAINS
 NID_id_pkix                     RSA_F4                                    X509_V_FLAG_NO_CHECK_TIME
 NID_id_qt_cps                   R_BAD_AUTHENTICATION_TYPE                 X509_V_FLAG_PARTIAL_CHAIN
 NID_id_qt_unotice               R_BAD_CHECKSUM                            X509_V_FLAG_POLICY_CHECK
 NID_idea_cbc                    R_BAD_MAC_DECODE                          X509_V_FLAG_POLICY_MASK
 NID_idea_cfb64                  R_BAD_RESPONSE_ARGUMENT                   X509_V_FLAG_SUITEB_128_LOS
 NID_idea_ecb                    R_BAD_SSL_FILETYPE                        X509_V_FLAG_SUITEB_128_LOS_ONLY
 NID_idea_ofb64                  R_BAD_SSL_SESSION_ID_LENGTH               X509_V_FLAG_SUITEB_192_LOS
 NID_info_access                 R_BAD_STATE                               X509_V_FLAG_TRUSTED_FIRST
 NID_initials                    R_BAD_WRITE_RETRY                         X509_V_FLAG_USE_CHECK_TIME
 NID_invalidity_date             R_CHALLENGE_IS_DIFFERENT                  X509_V_FLAG_USE_DELTAS
 NID_issuer_alt_name             R_CIPHER_TABLE_SRC_ERROR                  X509_V_FLAG_X509_STRICT
 NID_keyBag                      R_INVALID_CHALLENGE_LENGTH                X509_V_OK
 NID_key_usage                   R_NO_CERTIFICATE_SET                      XN_FLAG_COMPAT
 NID_localKeyID                  R_NO_CERTIFICATE_SPECIFIED                XN_FLAG_DN_REV
 NID_localityName                R_NO_CIPHER_LIST                          XN_FLAG_DUMP_UNKNOWN_FIELDS
 NID_md2                         R_NO_CIPHER_MATCH                         XN_FLAG_FN_ALIGN
 NID_md2WithRSAEncryption        R_NO_PRIVATEKEY                           XN_FLAG_FN_LN
 NID_md5                         R_NO_PUBLICKEY                            XN_FLAG_FN_MASK
 NID_md5WithRSA                  R_NULL_SSL_CTX                            XN_FLAG_FN_NONE
 NID_md5WithRSAEncryption        R_PEER_DID_NOT_RETURN_A_CERTIFICATE       XN_FLAG_FN_OID
 NID_md5_sha1                    R_PEER_ERROR                              XN_FLAG_FN_SN
 NID_mdc2                        R_PEER_ERROR_CERTIFICATE                  XN_FLAG_MULTILINE
 NID_mdc2WithRSA                 R_PEER_ERROR_NO_CIPHER                    XN_FLAG_ONELINE
 NID_ms_code_com                 R_PEER_ERROR_UNSUPPORTED_CERTIFICATE_TYPE XN_FLAG_RFC2253
 NID_ms_code_ind                 R_PUBLIC_KEY_ENCRYPT_ERROR                XN_FLAG_SEP_COMMA_PLUS
 NID_ms_ctl_sign                 R_PUBLIC_KEY_IS_NOT_RSA                   XN_FLAG_SEP_CPLUS_SPC
 NID_ms_efs                      R_READ_WRONG_PACKET_TYPE                  XN_FLAG_SEP_MASK
 NID_ms_ext_req                  R_SHORT_READ                              XN_FLAG_SEP_MULTILINE
 NID_ms_sgc                      R_SSL_SESSION_ID_IS_DIFFERENT             XN_FLAG_SEP_SPLUS_SPC
 NID_name                        R_UNABLE_TO_EXTRACT_PUBLIC_KEY            XN_FLAG_SPC_EQ
</pre>
</section>
<section class="Ss">
<h2 class="Ss">INTERNAL ONLY functions (do not use these)</h2>
<p class="Pp">The following functions are not intended for use from outside of
    Net::SSLeay module. They might be removed, renamed or changed without prior
    notice in future version.</p>
<p class="Pp">Simply <b>DO NOT USE THEM</b>!</p>
<ul class="Bl-bullet">
  <li>hello</li>
  <li>blength</li>
  <li>constant</li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">One very good example to look at is the implementation of
    <span class="Li">&quot;sslcat()&quot;</span> in the
    <span class="Li">&quot;SSLeay.pm&quot;</span> file.</p>
<p class="Pp">The following is a simple SSLeay client (with too little error
    checking :-(</p>
<p class="Pp"></p>
<pre>
    #!/usr/bin/perl
    use Socket;
    use Net::SSLeay qw(die_now die_if_ssl_error) ;
    Net::SSLeay::load_error_strings();
    Net::SSLeay::SSLeay_add_ssl_algorithms();
    Net::SSLeay::randomize();

    ($dest_serv, $port, $msg) = @ARGV;      # Read command line
    $port = getservbyname ($port, 'tcp') unless $port =~ /^\d+$/;
    $dest_ip = gethostbyname ($dest_serv);
    $dest_serv_params  = sockaddr_in($port, $dest_ip);

    socket  (S, &amp;AF_INET, &amp;SOCK_STREAM, 0)  or die &quot;socket: $!&quot;;
    connect (S, $dest_serv_params)          or die &quot;connect: $!&quot;;
    select  (S); $| = 1; select (STDOUT);   # Eliminate STDIO buffering

    # The network connection is now open, lets fire up SSL

    $ctx = Net::SSLeay::CTX_new() or die_now(&quot;Failed to create SSL_CTX $!&quot;);
    Net::SSLeay::CTX_set_options($ctx, &amp;Net::SSLeay::OP_ALL)
         or die_if_ssl_error(&quot;ssl ctx set options&quot;);
    $ssl = Net::SSLeay::new($ctx) or die_now(&quot;Failed to create SSL $!&quot;);
    Net::SSLeay::set_fd($ssl, fileno(S));   # Must use fileno
    $res = Net::SSLeay::connect($ssl) and die_if_ssl_error(&quot;ssl connect&quot;);
    print &quot;Cipher `&quot; . Net::SSLeay::get_cipher($ssl) . &quot;'\n&quot;;

    # Exchange data

    $res = Net::SSLeay::write($ssl, $msg);  # Perl knows how long $msg is
    die_if_ssl_error(&quot;ssl write&quot;);
    CORE::shutdown S, 1;  # Half close --&gt; No more output, sends EOF to server
    $got = Net::SSLeay::read($ssl);         # Perl returns undef on failure
    die_if_ssl_error(&quot;ssl read&quot;);
    print $got;

    Net::SSLeay::free ($ssl);               # Tear down connection
    Net::SSLeay::CTX_free ($ctx);
    close S;
</pre>
<p class="Pp">The following is a simple SSLeay echo server (non forking):</p>
<p class="Pp"></p>
<pre>
    #!/usr/bin/perl -w
    use Socket;
    use Net::SSLeay qw(die_now die_if_ssl_error);
    Net::SSLeay::load_error_strings();
    Net::SSLeay::SSLeay_add_ssl_algorithms();
    Net::SSLeay::randomize();

    $our_ip = &quot;\0\0\0\0&quot;; # Bind to all interfaces
    $port = 1235;
    $sockaddr_template = 'S n a4 x8';
    $our_serv_params = pack ($sockaddr_template, &amp;AF_INET, $port, $our_ip);

    socket (S, &amp;AF_INET, &amp;SOCK_STREAM, 0)  or die &quot;socket: $!&quot;;
    bind (S, $our_serv_params)             or die &quot;bind:   $!&quot;;
    listen (S, 5)                          or die &quot;listen: $!&quot;;
    $ctx = Net::SSLeay::CTX_new ()         or die_now(&quot;CTX_new ($ctx): $!&quot;);
    Net::SSLeay::CTX_set_options($ctx, &amp;Net::SSLeay::OP_ALL)
         or die_if_ssl_error(&quot;ssl ctx set options&quot;);

    # Following will ask password unless private key is not encrypted
    Net::SSLeay::CTX_use_RSAPrivateKey_file ($ctx, 'plain-rsa.pem',
                                             &amp;Net::SSLeay::FILETYPE_PEM);
    die_if_ssl_error(&quot;private key&quot;);
    Net::SSLeay::CTX_use_certificate_file ($ctx, 'plain-cert.pem',
                                           &amp;Net::SSLeay::FILETYPE_PEM);
    die_if_ssl_error(&quot;certificate&quot;);

    while (1) {
        print &quot;Accepting connections...\n&quot;;
        ($addr = accept (NS, S))           or die &quot;accept: $!&quot;;
        select (NS); $| = 1; select (STDOUT);  # Piping hot!

        ($af,$client_port,$client_ip) = unpack($sockaddr_template,$addr);
        @inetaddr = unpack('C4',$client_ip);
        print &quot;$af connection from &quot; .
        join ('.', @inetaddr) . &quot;:$client_port\n&quot;;

        # We now have a network connection, lets fire up SSLeay...

        $ssl = Net::SSLeay::new($ctx)      or die_now(&quot;SSL_new ($ssl): $!&quot;);
        Net::SSLeay::set_fd($ssl, fileno(NS));

        $err = Net::SSLeay::accept($ssl) and die_if_ssl_error('ssl accept');
        print &quot;Cipher `&quot; . Net::SSLeay::get_cipher($ssl) . &quot;'\n&quot;;

        # Connected. Exchange some data.

        $got = Net::SSLeay::read($ssl);     # Returns undef on fail
        die_if_ssl_error(&quot;ssl read&quot;);
        print &quot;Got `$got' (&quot; . length ($got) . &quot; chars)\n&quot;;

        Net::SSLeay::write ($ssl, uc ($got)) or die &quot;write: $!&quot;;
        die_if_ssl_error(&quot;ssl write&quot;);

        Net::SSLeay::free ($ssl);           # Tear down connection
        close NS;
    }
</pre>
<p class="Pp">Yet another echo server. This one runs from
    <span class="Li">&quot;/etc/inetd.conf&quot;</span> so it avoids all the
    socket code overhead. Only caveat is opening an rsa key file - it had better
    be without any encryption or else it will not know where to ask for the
    password. Note how <span class="Li">&quot;STDIN&quot;</span> and
    <span class="Li">&quot;STDOUT&quot;</span> are wired to SSL.</p>
<p class="Pp"></p>
<pre>
    #!/usr/bin/perl
    # /etc/inetd.conf
    #    ssltst stream tcp nowait root /path/to/server.pl server.pl
    # /etc/services
    #    ssltst         1234/tcp

    use Net::SSLeay qw(die_now die_if_ssl_error);
    Net::SSLeay::load_error_strings();
    Net::SSLeay::SSLeay_add_ssl_algorithms();
    Net::SSLeay::randomize();

    chdir '/key/dir' or die &quot;chdir: $!&quot;;
    $| = 1;  # Piping hot!
    open LOG, &quot;&gt;&gt;/dev/console&quot; or die &quot;Can't open log file $!&quot;;
    select LOG; print &quot;server.pl started\n&quot;;

    $ctx = Net::SSLeay::CTX_new()     or die_now &quot;CTX_new ($ctx) ($!)&quot;;
    $ssl = Net::SSLeay::new($ctx)     or die_now &quot;new ($ssl) ($!)&quot;;
    Net::SSLeay::set_options($ssl, &amp;Net::SSLeay::OP_ALL)
         and die_if_ssl_error(&quot;ssl set options&quot;);

    # We get already open network connection from inetd, now we just
    # need to attach SSLeay to STDIN and STDOUT
    Net::SSLeay::set_rfd($ssl, fileno(STDIN));
    Net::SSLeay::set_wfd($ssl, fileno(STDOUT));

    Net::SSLeay::use_RSAPrivateKey_file ($ssl, 'plain-rsa.pem',
                                         Net::SSLeay::FILETYPE_PEM);
    die_if_ssl_error(&quot;private key&quot;);
    Net::SSLeay::use_certificate_file ($ssl, 'plain-cert.pem',
                                       Net::SSLeay::FILETYPE_PEM);
    die_if_ssl_error(&quot;certificate&quot;);

    Net::SSLeay::accept($ssl) and die_if_ssl_err(&quot;ssl accept: $!&quot;);
    print &quot;Cipher `&quot; . Net::SSLeay::get_cipher($ssl) . &quot;'\n&quot;;

    $got = Net::SSLeay::read($ssl);
    die_if_ssl_error(&quot;ssl read&quot;);
    print &quot;Got `$got' (&quot; . length ($got) . &quot; chars)\n&quot;;

    Net::SSLeay::write ($ssl, uc($got)) or die &quot;write: $!&quot;;
    die_if_ssl_error(&quot;ssl write&quot;);

    Net::SSLeay::free ($ssl);         # Tear down the connection
    Net::SSLeay::CTX_free ($ctx);
    close LOG;
</pre>
<p class="Pp">There are also a number of example/test programs in the examples
    directory:</p>
<p class="Pp"></p>
<pre>
    sslecho.pl   -  A simple server, not unlike the one above
    minicli.pl   -  Implements a client using low level SSLeay routines
    sslcat.pl    -  Demonstrates using high level sslcat utility function
    get_page.pl  -  Is a utility for getting html pages from secure servers
    callback.pl  -  Demonstrates certificate verification and callback usage
    stdio_bulk.pl       - Does SSL over Unix pipes
    ssl-inetd-serv.pl   - SSL server that can be invoked from inetd.conf
    httpd-proxy-snif.pl - Utility that allows you to see how a browser
                          sends https request to given server and what reply
                          it gets back (very educative :-)
    makecert.pl  -  Creates a self signed cert (does not use this module)
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="INSTALLATION"><a class="permalink" href="#INSTALLATION">INSTALLATION</a></h1>
<p class="Pp">See README and README.* in the distribution directory for
    installation guidance on a variety of platforms.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LIMITATIONS"><a class="permalink" href="#LIMITATIONS">LIMITATIONS</a></h1>
<p class="Pp"><span class="Li">&quot;Net::SSLeay::read()&quot;</span> uses an
    internal buffer of 32KB, thus no single read will return more. In practice
    one read returns much less, usually as much as fits in one network packet.
    To work around this, you should use a loop like this:</p>
<p class="Pp"></p>
<pre>
    $reply = '';
    while ($got = Net::SSLeay::read($ssl)) {
        last if print_errs('SSL_read');
        $reply .= $got;
    }
</pre>
<p class="Pp">Although there is no built-in limit in
    <span class="Li">&quot;Net::SSLeay::write()&quot;</span>, the network packet
    size limitation applies here as well, thus use:</p>
<p class="Pp"></p>
<pre>
    $written = 0;

    while ($written &lt; length($message)) {
        $written += Net::SSLeay::write($ssl, substr($message, $written));
        last if print_errs('SSL_write');
    }
</pre>
<p class="Pp">Or alternatively you can just use the following convenience
    functions:</p>
<p class="Pp"></p>
<pre>
    Net::SSLeay::ssl_write_all($ssl, $message) or die &quot;ssl write failure&quot;;
    $got = Net::SSLeay::ssl_read_all($ssl) or die &quot;ssl read failure&quot;;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="KNOWN_BUGS_AND_CAVEATS"><a class="permalink" href="#KNOWN_BUGS_AND_CAVEATS">KNOWN
  BUGS AND CAVEATS</a></h1>
<p class="Pp">An OpenSSL bug CVE-2015-0290 &quot;OpenSSL Multiblock Corrupted
    Pointer Issue&quot; can cause POST requests of over 90kB to fail or crash.
    This bug is reported to be fixed in OpenSSL 1.0.2a.</p>
<p class="Pp">Autoloader emits a</p>
<p class="Pp"></p>
<pre>
    Argument &quot;xxx&quot; isn't numeric in entersub at blib/lib/Net/SSLeay.pm'
</pre>
<p class="Pp">warning if die_if_ssl_error is made autoloadable. If you figure
    out why, drop me a line.</p>
<p class="Pp">Callback set using
    <span class="Li">&quot;SSL_set_verify()&quot;</span> does not appear to
    work. This may well be an openssl problem (e.g. see
    <span class="Li">&quot;ssl/ssl_lib.c&quot;</span> line 1029). Try using
    <span class="Li">&quot;SSL_CTX_set_verify()&quot;</span> instead and do not
    be surprised if even this stops working in future versions.</p>
<p class="Pp">Callback and certificate verification stuff is generally too
    little tested.</p>
<p class="Pp">Random numbers are not initialized randomly enough, especially if
    you do not have <span class="Li">&quot;/dev/random&quot;</span> and/or
    <span class="Li">&quot;/dev/urandom&quot;</span> (such as in Solaris
    platforms - but it's been suggested that cryptorand daemon from the SUNski
    package solves this). In this case you should investigate third party
    software that can emulate these devices, e.g. by way of a named pipe to some
    program.</p>
<p class="Pp">Another gotcha with random number initialization is randomness
    depletion. This phenomenon, which has been extensively discussed in OpenSSL,
    Apache-SSL, and Apache-mod_ssl forums, can cause your script to block if you
    use <span class="Li">&quot;/dev/random&quot;</span> or to operate insecurely
    if you use <span class="Li">&quot;/dev/urandom&quot;</span>. What happens is
    that when too much randomness is drawn from the operating system's
    randomness pool then randomness can temporarily be unavailable.
    <span class="Li">&quot;/dev/random&quot;</span> solves this problem by
    waiting until enough randomness can be gathered - and this can take a long
    time since blocking reduces activity in the machine and less activity
    provides less random events: a vicious circle.
    <span class="Li">&quot;/dev/urandom&quot;</span> solves this dilemma more
    pragmatically by simply returning predictable &quot;random&quot; numbers.
    Some<span class="Li">&quot; /dev/urandom&quot;</span> emulation software
    however actually seems to implement
    <span class="Li">&quot;/dev/random&quot;</span> semantics. Caveat
  emptor.</p>
<p class="Pp">I've been pointed to two such daemons by Mik Firestone
    &lt;mik@@speed.stdio._com&gt; who has used them on Solaris 8:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>Entropy Gathering Daemon (EGD) at
      &lt;http://www.lothar.com/tech/crypto/&gt;</dd>
  <dt>2.</dt>
  <dd>Pseudo-random number generating daemon (PRNGD) at
      &lt;http://www.aet.tu-cottbus.de/personen/jaenicke/postfix_tls/prngd.html&gt;</dd>
</dl>
<p class="Pp">If you are using the low level API functions to communicate with
    other SSL implementations, you would do well to call</p>
<p class="Pp"></p>
<pre>
    Net::SSLeay::CTX_set_options($ctx, &amp;Net::SSLeay::OP_ALL)
         or die_if_ssl_error(&quot;ssl ctx set options&quot;);
</pre>
<p class="Pp">to cope with some well know bugs in some other SSL
    implementations. The high level API functions always set all known
    compatibility options.</p>
<p class="Pp">Sometimes <span class="Li">&quot;sslcat()&quot;</span> (and the
    high level HTTPS functions that build on it) is too fast in signaling the
    EOF to legacy HTTPS servers. This causes the server to return empty page. To
    work around this problem you can set the global variable</p>
<p class="Pp"></p>
<pre>
    $Net::SSLeay::slowly = 1;   # Add sleep so broken servers can keep up
</pre>
<p class="Pp">HTTP/1.1 is not supported. Specifically this module does not know
    to issue or serve multiple http requests per connection. This is a serious
    shortcoming, but using the SSL session cache on your server helps to
    alleviate the CPU load somewhat.</p>
<p class="Pp">As of version 1.09 many newer OpenSSL auxiliary functions were
    added (from
    <span class="Li">&quot;REM_AUTOMATICALLY_GENERATED_1_09&quot;</span> onwards
    in <span class="Li">&quot;SSLeay.xs&quot;</span>). Unfortunately I have not
    had any opportunity to test these. Some of them are trivial enough that I
    believe they &quot;just work&quot;, but others have rather complex
    interfaces with function pointers and all. In these cases you should proceed
    wit great caution.</p>
<p class="Pp">This module defaults to using OpenSSL automatic protocol
    negotiation code for automatically detecting the version of the SSL/TLS
    protocol that the other end talks. With most web servers this works just
    fine, but once in a while I get complaints from people that the module does
    not work with some web servers. Usually this can be solved by explicitly
    setting the protocol version, e.g.</p>
<p class="Pp"></p>
<pre>
   $Net::SSLeay::ssl_version = 2;  # Insist on SSLv2
   $Net::SSLeay::ssl_version = 3;  # Insist on SSLv3
   $Net::SSLeay::ssl_version = 10; # Insist on TLSv1
   $Net::SSLeay::ssl_version = 11; # Insist on TLSv1.1
   $Net::SSLeay::ssl_version = 12; # Insist on TLSv1.2
   $Net::SSLeay::ssl_version = 13; # Insist on TLSv1.3
</pre>
<p class="Pp">Although the autonegotiation is nice to have, the SSL standards do
    not formally specify any such mechanism. Most of the world has accepted the
    SSLeay/OpenSSL way of doing it as the de facto standard. But for the few
    that think differently, you have to explicitly speak the correct version.
    This is not really a bug, but rather a deficiency in the standards. If a
    site refuses to respond or sends back some nonsensical error codes (at the
    SSL handshake level), try this option before mailing me.</p>
<p class="Pp">On some systems, OpenSSL may be compiled without support for
    SSLv2. If this is the case, Net::SSLeay will warn if ssl_version has been
    set to 2.</p>
<p class="Pp">The high level API returns the certificate of the peer, thus
    allowing one to check what certificate was supplied. However, you will only
    be able to check the certificate after the fact, i.e. you already sent your
    form data by the time you find out that you did not trust them, oops.</p>
<p class="Pp">So, while being able to know the certificate after the fact is
    surely useful, the security minded would still choose to do the connection
    and certificate verification first and only then exchange data with the
    site. Currently none of the high level API functions do this, thus you would
    have to program it using the low level API. A good place to start is to see
    how the <span class="Li">&quot;Net::SSLeay::http_cat()&quot;</span> function
    is implemented.</p>
<p class="Pp">The high level API functions use a global file handle
    <span class="Li">&quot;SSLCAT_S&quot;</span> internally. This really should
    not be a problem because there is no way to interleave the high level API
    functions, unless you use threads (but threads are not very well supported
    in perl anyway). However, you may run into problems if you call undocumented
    internal functions in an interleaved fashion. The best solution is to
    &quot;require Net::SSLeay&quot; in one thread after all the threads have
    been created.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DIAGNOSTICS"><a class="permalink" href="#DIAGNOSTICS">DIAGNOSTICS</a></h1>
<dl class="Bl-tag">
  <dt id="Random"><a class="permalink" href="#Random">Random number generator
    not seeded!!!</a></dt>
  <dd><b>(W)</b> This warning indicates that
      <span class="Li">&quot;randomize()&quot;</span> was not able to read
      <span class="Li">&quot;/dev/random&quot;</span> or
      <span class="Li">&quot;/dev/urandom&quot;</span>, possibly because your
      system does not have them or they are differently named. You can still use
      SSL, but the encryption will not be as strong.</dd>
  <dt id="open_tcp_connection:"><a class="permalink" href="#open_tcp_connection:">open_tcp_connection:
    destination host not found:`server' (port 123) ($!)</a></dt>
  <dd>Name lookup for host named <span class="Li">&quot;server&quot;</span>
      failed.</dd>
  <dt id="open_tcp_connection:~2"><a class="permalink" href="#open_tcp_connection:~2">open_tcp_connection:
    failed `server', 123 ($!)</a></dt>
  <dd>The name was resolved, but establishing the TCP connection failed.</dd>
  <dt id="msg"><a class="permalink" href="#msg">msg 123: 1 - error:140770F8:SSL
    routines:SSL23_GET_SERVER_HELLO:unknown proto</a></dt>
  <dd>SSLeay error string. The first number (123) is the PID, the second number
      (1) indicates the position of the error message in SSLeay error stack. You
      often see a pile of these messages as errors cascade.</dd>
  <dt id="msg~2"><a class="permalink" href="#msg~2">msg 123: 1 -
    <b>error:02001002::lib</b>(2) :<b>func</b>(1) :<b>reason</b>(2)</a></dt>
  <dd>The same as above, but you didn't call <b>load_error_strings()</b> so
      SSLeay couldn't verbosely explain the error. You can still find out what
      it means with this command:
    <p class="Pp"></p>
    <pre>
    /usr/local/ssl/bin/ssleay errstr 02001002
    </pre>
  </dd>
  <dt id="Password"><a class="permalink" href="#Password">Password is being
    asked for private key</a></dt>
  <dd>This is normal behaviour if your private key is encrypted. Either you have
      to supply the password or you have to use an unencrypted private key. Scan
      OpenSSL.org for the FAQ that explains how to do this (or just study
      examples/makecert.pl which is used during <span class="Li">&quot;make
      test&quot;</span> to do just that).</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SECURITY"><a class="permalink" href="#SECURITY">SECURITY</a></h1>
<p class="Pp">You can mitigate some of the security vulnerabilities that might
    be present in your SSL/TLS application:</p>
<section class="Ss">
<h2 class="Ss">BEAST Attack</h2>
<p class="Pp">http://blogs.cisco.com/security/beat-the-beast-with-tls/
    https://community.qualys.com/blogs/securitylabs/2011/10/17/mitigating-the-beast-attack-on-tls
    http://blog.zoller.lu/2011/09/beast-summary-tls-cbc-countermeasures.html</p>
<p class="Pp">The BEAST attack relies on a weakness in the way CBC mode is used
    in SSL/TLS. In OpenSSL versions 0.9.6d and later, the protocol-level
    mitigation is enabled by default, thus making it not vulnerable to the BEAST
    attack.</p>
<p class="Pp">Solutions:</p>
<ul class="Bl-bullet">
  <li>Compile with OpenSSL versions 0.9.6d or later, which enables SSL_OP_ALL by
      default</li>
  <li>Ensure SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS is not enabled (its not enabled
      by default)</li>
  <li>Don't support SSLv2, SSLv3</li>
  <li>Actively control the ciphers your server supports with
    set_cipher_list:</li>
</ul>
<p class="Pp">Net::SSLeay::set_cipher_list($ssl, 'RC4-SHA:HIGH:!ADH');</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Session_Resumption"><a class="permalink" href="#Session_Resumption">Session
  Resumption</a></h2>
<p class="Pp">http://www.openssl.org/docs/ssl/SSL_CTX_set_options.html</p>
<p class="Pp">The SSL Labs vulnerability test on your SSL server might report in
    red:</p>
<p class="Pp">Session resumption No (IDs assigned but not accepted)</p>
<p class="Pp">This report is not really bug or a vulnerability, since the server
    will not accept session resumption requests. However, you can prevent this
    noise in the report by disabling the session cache altogether:
    Net::SSLeay::CTX_set_session_cache_mode($ssl_ctx,
    <b>Net::SSLeay::SESS_CACHE_OFF()</b>); Use 0 if you don't have
    SESS_CACHE_OFF constant.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Secure_Renegotiation_and_DoS_Attack"><a class="permalink" href="#Secure_Renegotiation_and_DoS_Attack">Secure
  Renegotiation and DoS Attack</a></h2>
<p class="Pp">https://community.qualys.com/blogs/securitylabs/2011/10/31/tls-renegotiation-and-denial-of-service-attacks</p>
<p class="Pp">This is not a &quot;security flaw,&quot; it is more of a DoS
    vulnerability.</p>
<p class="Pp">Solutions:</p>
<ul class="Bl-bullet">
  <li>Do not support SSLv2</li>
  <li>Do not set the SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION option</li>
  <li>Compile with OpenSSL 0.9.8m or later</li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">If you encounter a problem with this module that you believe is a
    bug, please report it in one of the following ways:</p>
<ul class="Bl-bullet">
  <li>create a new issue
      &lt;https://github.com/radiator-software/p5-net-ssleay/issues/new&gt;
      under the Net-SSLeay GitHub project at
      &lt;https://github.com/radiator-software/p5-net-ssleay&gt;;</li>
  <li>open a ticket
      &lt;https://rt.cpan.org/Ticket/Create.html?Queue=Net-SSLeay&gt; using the
      CPAN RT bug tracker's web interface at
      &lt;https://rt.cpan.org/Dist/Display.html?Queue=Net-SSLeay&gt;;</li>
  <li>send an email to the CPAN RT bug tracker at bug-Net-SSLeay@rt.cpan.org
      &lt;mailto:bug-Net-SSLeay@rt.cpan.org&gt;.</li>
</ul>
<p class="Pp">Please make sure your bug report includes the following
    information:</p>
<ul class="Bl-bullet">
  <li>the code you are trying to run;</li>
  <li>your operating system name and version;</li>
  <li>the output of <span class="Li">&quot;perl -V&quot;</span>;</li>
  <li>the version of OpenSSL or LibreSSL you are using.</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Originally written by Sampo Kellom&#x00E4;ki.</p>
<p class="Pp">Maintained by Florian Ragwitz between November 2005 and January
    2010.</p>
<p class="Pp">Maintained by Mike McCauley between November 2005 and June
  2018.</p>
<p class="Pp">Maintained by Chris Novakovic, Tuure Vartiainen and Heikki
    Vatiainen since June 2018.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 1996-2003 Sampo Kellom&#x00E4;ki
    &lt;sampo@iki.fi&gt;</p>
<p class="Pp">Copyright (c) 2005-2010 Florian Ragwitz
  &lt;rafl@debian.org&gt;</p>
<p class="Pp">Copyright (c) 2005-2018 Mike McCauley
  &lt;mikem@airspayce.com&gt;</p>
<p class="Pp">Copyright (c) 2018- Chris Novakovic &lt;chris@chrisn.me.uk&gt;</p>
<p class="Pp">Copyright (c) 2018- Tuure Vartiainen
    &lt;vartiait@radiatorsoftware.com&gt;</p>
<p class="Pp">Copyright (c) 2018- Heikki Vatiainen
    &lt;hvn@radiatorsoftware.com&gt;</p>
<p class="Pp">All rights reserved.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">This module is released under the terms of the Artistic License
    2.0. For details, see the <span class="Li">&quot;LICENSE&quot;</span> file
    distributed with Net-SSLeay's source code.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<pre>
  Net::SSLeay::Handle                      - File handle interface
  ./examples                               - Example servers and a clients
  &lt;http://www.openssl.org/&gt;                - OpenSSL source, documentation, etc
  openssl-users-request@openssl.org        - General OpenSSL mailing list
  &lt;http://www.ietf.org/rfc/rfc2246.txt&gt;    - TLS 1.0 specification
  &lt;http://www.w3c.org&gt;                     - HTTP specifications
  &lt;http://www.ietf.org/rfc/rfc2617.txt&gt;    - How to send password
  &lt;http://www.lothar.com/tech/crypto/&gt;     - Entropy Gathering Daemon (EGD)
  &lt;http://www.aet.tu-cottbus.de/personen/jaenicke/postfix_tls/prngd.html&gt;
                           - pseudo-random number generating daemon (PRNGD)
  perl(1)
  perlref(1)
  perllol(1)
  perldoc ~openssl/doc/ssl/SSL_CTX_set_verify.pod
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-05-07</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

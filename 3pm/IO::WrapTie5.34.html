<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>IO::WrapTie(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">IO::WrapTie(3)</td>
    <td class="head-vol"><a href=".">User Contributed Perl Documentation</a></td>
    <td class="head-rtitle">IO::WrapTie(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">IO::WrapTie - wrap tieable objects in IO::Handle interface</p>
<p class="Pp">This is currently Alpha code, released for comments.
  <br/>
   Please give me your feedback!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">First of all, you'll need <b>tie()</b>, so:</p>
<p class="Pp"></p>
<pre>   require 5.004;
</pre>
<p class="Pp"><i>Function interface (experimental).</i> Use this with any
    existing class...</p>
<p class="Pp"></p>
<pre>   use IO::WrapTie;
   use FooHandle;                  ### implements TIEHANDLE interface
   ### Suppose we want a &quot;FooHandle-&gt;new(&amp;FOO_RDWR, 2)&quot;.
   ### We can instead say...
   $FH = wraptie('FooHandle', &amp;FOO_RDWR, 2); 
   ### Now we can use...    
   print $FH &quot;Hello, &quot;;            ### traditional operator syntax...
   $FH-&gt;print(&quot;world!\n&quot;);         ### ...and OO syntax as well!
</pre>
<p class="Pp"><i>OO interface (preferred).</i> You can inherit from the
    IO::WrapTie::Slave mixin to get a nifty
    <span class="Li">&quot;new_tie()&quot;</span> constructor...</p>
<p class="Pp"></p>
<pre>   #------------------------------    
   package FooHandle;                        ### a class which can TIEHANDLE
   use IO::WrapTie;  
   @ISA = qw(IO::WrapTie::Slave);            ### inherit new_tie()
   ...
   #------------------------------    
   package main; 
   $FH = FooHandle-&gt;new_tie(&amp;FOO_RDWR, 2);   ### $FH is an IO::WrapTie::Master
   print $FH &quot;Hello, &quot;;                      ### traditional operator syntax
   $FH-&gt;print(&quot;world!\n&quot;);                   ### OO syntax
</pre>
<p class="Pp">See IO::Scalar as an example. It also shows you how to create
    classes which work both with and without 5.004.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Suppose you have a class
    <span class="Li">&quot;FooHandle&quot;</span>, where...</p>
<ul class="Bl-bullet">
  <li><b>FooHandle does not inherit from IO::Handle;</b> that is, it performs
      filehandle-like I/O, but to something other than an underlying file
      descriptor. Good examples are IO::Scalar (for printing to a string) and
      IO::Lines (for printing to an array of lines).</li>
  <li><b>FooHandle implements the TIEHANDLE interface</b> (see perltie); that
      is, it provides methods TIEHANDLE, GETC, PRINT, PRINTF, READ, and
      READLINE.</li>
  <li><b>FooHandle implements the traditional OO interface</b> of FileHandle and
      IO::Handle; i.e., it contains methods like <b>getline()</b>,
      <b>read()</b>, <b>print()</b>, <b>seek()</b>, <b>tell()</b>, <b>eof()</b>,
      etc.</li>
</ul>
<p class="Pp">Normally, users of your class would have two options:</p>
<ul class="Bl-bullet">
  <li><b>Use only OO syntax,</b> and forsake named I/O operators like
    'print'.</li>
  <li><b>Use with tie,</b> and forsake treating it as a first-class object
      (i.e., class-specific methods can only be invoked through the underlying
      object via <b>tied()</b>... giving the object a &quot;split
      personality&quot;).</li>
</ul>
<p class="Pp">But now with IO::WrapTie, you can say:</p>
<p class="Pp"></p>
<pre>    $WT = wraptie('FooHandle', &amp;FOO_RDWR, 2);
    $WT-&gt;print(&quot;Hello, world\n&quot;);   ### OO syntax
    print $WT &quot;Yes!\n&quot;;             ### Named operator syntax too!
    $WT-&gt;weird_stuff;               ### Other methods!
</pre>
<p class="Pp">And if you're authoring a class like FooHandle, just have it
    inherit from <span class="Li">&quot;IO::WrapTie::Slave&quot;</span> and that
    first line becomes even prettier:</p>
<p class="Pp"></p>
<pre>    $WT = FooHandle-&gt;new_tie(&amp;FOO_RDWR, 2);
</pre>
<p class="Pp"><b>The bottom line:</b> now, almost any class can look and work
    exactly like an IO::Handle... and be used both with OO and non-OO filehandle
    syntax.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="HOW_IT_ALL_WORKS"><a class="permalink" href="#HOW_IT_ALL_WORKS">HOW
  IT ALL WORKS</a></h1>
<section class="Ss">
<h2 class="Ss" id="The_data_structures"><a class="permalink" href="#The_data_structures">The
  data structures</a></h2>
<p class="Pp">Consider this example code, using classes in this
  distribution:</p>
<p class="Pp"></p>
<pre>    use IO::Scalar;
    use IO::WrapTie;
    $WT = wraptie('IO::Scalar',\$s);
    print $WT &quot;Hello, &quot;;
    $WT-&gt;print(&quot;world!\n&quot;);
</pre>
<p class="Pp">In it, the <b>wraptie()</b> function creates a data structure as
    follows:</p>
<p class="Pp"></p>
<pre>                          * $WT is a blessed reference to a tied filehandle
              $WT           glob; that glob is tied to the &quot;Slave&quot; object.
               |          * You would do all your i/o with $WT directly.
               |       
               |
               |     ,---isa--&gt; IO::WrapTie::Master &gt;--isa--&gt; IO::Handle
               V    /
        .-------------. 
        |             | 
        |             |   * Perl i/o operators work on the tied object,  
        |  &quot;Master&quot;   |     invoking the TIEHANDLE methods.
        |             |   * Method invocations are delegated to the tied 
        |             |     slave.
        `-------------' 
               |    
    tied(*$WT) |     .---isa--&gt; IO::WrapTie::Slave
               V    /   
        .-------------.
        |             |
        |   &quot;Slave&quot;   |   * Instance of FileHandle-like class which doesn't
        |             |     actually use file descriptors, like IO::Scalar.
        |  IO::Scalar |   * The slave can be any kind of object.
        |             |   * Must implement the TIEHANDLE interface.
        `-------------'
</pre>
<p class="Pp"><i>NOTE:</i> just as an IO::Handle is really just a blessed
    reference to a <i>traditional</i> filehandle glob... so also, an
    IO::WrapTie::Master is really just a blessed reference to a filehandle glob
    <i>which has been tied to some &quot;slave&quot; class.</i></p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_"><a class="permalink" href="#How_">How <b>wraptie()</b>
  works</a></h2>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>The call to function <span class="Li">&quot;wraptie(SLAVECLASS,
      TIEARGS...)&quot;</span> is passed onto
      <span class="Li">&quot;IO::WrapTie::Master::new()&quot;</span>. Note that
      class IO::WrapTie::Master is a subclass of IO::Handle.</dd>
  <dt>2.</dt>
  <dd>The <span class="Li">&quot;IO::WrapTie::Master::new&quot;</span> method
      creates a new IO::Handle object, reblessed into class IO::WrapTie::Master.
      This object is the <i>master</i>, which will be returned from the
      constructor. At the same time...</dd>
  <dt>3.</dt>
  <dd>The <span class="Li">&quot;new&quot;</span> method also creates the
      <i>slave</i>: this is an instance of SLAVECLASS which is created by tying
      the master's IO::Handle to SLAVECLASS via
      <span class="Li">&quot;tie(HANDLE, SLAVECLASS, TIEARGS...)&quot;</span>.
      This call to <span class="Li">&quot;tie()&quot;</span> creates the slave
      in the following manner:</dd>
  <dt>4.</dt>
  <dd>Class SLAVECLASS is sent the message
      <span class="Li">&quot;TIEHANDLE(TIEARGS...)&quot;</span>; it will usually
      delegate this to
      <span class="Li">&quot;SLAVECLASS::new(TIEARGS...)&quot;</span>, resulting
      in a new instance of SLAVECLASS being created and returned.</dd>
  <dt>5.</dt>
  <dd>Once both master and slave have been created, the master is returned to
      the caller.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="How_I/O_operators_work_(on_the_master)"><a class="permalink" href="#How_I/O_operators_work_(on_the_master)">How
  I/O operators work (on the master)</a></h2>
<p class="Pp">Consider using an i/o operator on the master:</p>
<p class="Pp"></p>
<pre>    print $WT &quot;Hello, world!\n&quot;;
</pre>
<p class="Pp">Since the master ($WT) is really a [blessed] reference to a glob,
    the normal Perl i/o operators like <span class="Li">&quot;print&quot;</span>
    may be used on it. They will just operate on the symbol part of the
  glob.</p>
<p class="Pp">Since the glob is tied to the slave, the slave's PRINT method
    (part of the TIEHANDLE interface) will be automatically invoked.</p>
<p class="Pp">If the slave is an IO::Scalar, that means IO::Scalar::PRINT will
    be invoked, and that method happens to delegate to the
    <span class="Li">&quot;print()&quot;</span> method of the same class. So the
    <i>real</i> work is ultimately done by <b>IO::Scalar::print()</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_methods_work_(on_the_master)"><a class="permalink" href="#How_methods_work_(on_the_master)">How
  methods work (on the master)</a></h2>
<p class="Pp">Consider using a method on the master:</p>
<p class="Pp"></p>
<pre>    $WT-&gt;print(&quot;Hello, world!\n&quot;);
</pre>
<p class="Pp">Since the master ($WT) is blessed into the class
    IO::WrapTie::Master, Perl first attempts to find a
    <span class="Li">&quot;print()&quot;</span> method there. Failing that, Perl
    next attempts to find a <span class="Li">&quot;print()&quot;</span> method
    in the superclass, IO::Handle. It just so happens that there <i>is</i> such
    a method; that method merely invokes the
    <span class="Li">&quot;print&quot;</span> i/o operator on the self object...
    and for that, see above!</p>
<p class="Pp">But let's suppose we're dealing with a method which <i>isn't</i>
    part of IO::Handle... for example:</p>
<p class="Pp"></p>
<pre>    my $sref = $WT-&gt;sref;
</pre>
<p class="Pp">In this case, the intuitive behavior is to have the master
    delegate the method invocation to the slave (now do you see where the
    designations come from?). This is indeed what happens: IO::WrapTie::Master
    contains an AUTOLOAD method which performs the delegation.</p>
<p class="Pp">So: when <span class="Li">&quot;sref()&quot;</span> can't be found
    in IO::Handle, the AUTOLOAD method of IO::WrapTie::Master is invoked, and
    the standard behavior of delegating the method to the underlying slave
    (here, an IO::Scalar) is done.</p>
<p class="Pp">Sometimes, to get this to work properly, you may need to create a
    subclass of IO::WrapTie::Master which is an effective master for <i>your</i>
    class, and do the delegation there.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<p class="Pp"><b>Why not simply use the object's OO interface?</b>
  <br/>
   Because that means forsaking the use of named operators like <b>print()</b>,
    and you may need to pass the object to a subroutine which will attempt to
    use those operators:</p>
<p class="Pp"></p>
<pre>    $O = FooHandle-&gt;new(&amp;FOO_RDWR, 2);
    $O-&gt;print(&quot;Hello, world\n&quot;);  ### OO syntax is okay, BUT....
    sub nope { print $_[0] &quot;Nope!\n&quot; }
 X  nope($O);                     ### ERROR!!! (not a glob ref)
</pre>
<p class="Pp"><b>Why not simply use </b><b>tie()</b><b>?</b>
  <br/>
   Because (1) you have to use <b>tied()</b> to invoke methods in the object's
    public interface (yuck), and (2) you may need to pass the tied symbol to
    another subroutine which will attempt to treat it in an OO-way... and that
    will break it:</p>
<p class="Pp"></p>
<pre>    tie *T, 'FooHandle', &amp;FOO_RDWR, 2; 
    print T &quot;Hello, world\n&quot;;   ### Operator is okay, BUT... 
    tied(*T)-&gt;other_stuff;      ### yuck! AND...
    sub nope { shift-&gt;print(&quot;Nope!\n&quot;) }
 X  nope(\*T);                  ### ERROR!!! (method &quot;print&quot; on unblessed ref)
</pre>
<p class="Pp"><b>Why a master and slave?</b>
  <br/>
  <b> Why not simply write FooHandle to inherit from IO::Handle?</b>
  <br/>
   I tried this, with an implementation similar to that of IO::Socket. The
    problem is that <i>the whole point is to use this with objects</i> <i>that
    don't have an underlying file/socket descriptor.</i>. Subclassing IO::Handle
    will work fine for the OO stuff, and fine with named operators <i>if</i> you
    <b>tie()</b>... but if you just attempt to say:</p>
<p class="Pp"></p>
<pre>    $IO = FooHandle-&gt;new(&amp;FOO_RDWR, 2);
    print $IO &quot;Hello!\n&quot;;
</pre>
<p class="Pp">you get a warning from Perl like:</p>
<p class="Pp"></p>
<pre>    Filehandle GEN001 never opened
</pre>
<p class="Pp">because it's trying to do system-level i/o on an (unopened) file
    descriptor. To avoid this, you apparently have to <b>tie()</b> the handle...
    which brings us right back to where we started! At least the IO::WrapTie
    mixin lets us say:</p>
<p class="Pp"></p>
<pre>    $IO = FooHandle-&gt;new_tie(&amp;FOO_RDWR, 2);
    print $IO &quot;Hello!\n&quot;;
</pre>
<p class="Pp">and so is not <i>too</i> bad.
    <span class="Li">&quot;:-)&quot;</span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="WARNINGS"><a class="permalink" href="#WARNINGS">WARNINGS</a></h1>
<p class="Pp">Remember: this stuff is for doing FileHandle-like i/o on things
    <i>without underlying file descriptors</i>. If you have an underlying file
    descriptor, you're better off just inheriting from IO::Handle.</p>
<p class="Pp"><b>Be aware that </b><b>new_tie()</b><b> always returns an
    instance of a</b> <b>kind of IO::WrapTie::Master...</b> it does <b>not</b>
    return an instance of the i/o class you're tying to!</p>
<p class="Pp">Invoking some methods on the master object causes AUTOLOAD to
    delegate them to the slave object... so it <i>looks</i> like you're
    manipulating a &quot;FooHandle&quot; object directly, but you're not.</p>
<p class="Pp">I have not explored all the ramifications of this use of
    <b>tie()</b>. <i>Here there be dragons</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp"><span class="Li">$Id:</span> WrapTie.pm,v 1.2 2005/02/10 21:21:53
    dfs Exp $</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<dl class="Bl-tag">
  <dt id="Primary"><a class="permalink" href="#Primary">Primary
    Maintainer</a></dt>
  <dd>Dianne Skoll (<i>dfs@roaringpenguin.com</i>).</dd>
  <dt id="Original"><a class="permalink" href="#Original">Original
    Author</a></dt>
  <dd>Eryq (<i>eryq@zeegee.com</i>). President, ZeeGee Software Inc
      (<i>http://www.zeegee.com</i>).</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="POD_ERRORS"><a class="permalink" href="#POD_ERRORS">POD
  ERRORS</a></h1>
<p class="Pp">Hey! <b>The above document had some coding errors, which are
    explained below:</b></p>
<dl class="Bl-tag">
  <dt id="Around"><a class="permalink" href="#Around">Around line 481:</a></dt>
  <dd>'=item' outside of any '=over'
    <p class="Pp">=over without closing =back</p>
  </dd>
</dl>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2015-04-22</td>
    <td class="foot-os"><a href="..">perl v5.34.0</a></td>
  </tr>
</table>
</body>
</html>

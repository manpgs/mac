<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>TAP::Harness(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">TAP::Harness(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">TAP::Harness(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">TAP::Harness - Run test scripts with statistics</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">Version 3.26</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This is a simple test harness which allows tests to be run and
    results automatically aggregated and output to STDOUT.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
 use TAP::Harness;
 my $harness = TAP::Harness-&gt;new( \%args );
 $harness-&gt;runtests(@tests);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Class_Methods"><a class="permalink" href="#Class_Methods">Class
  Methods</a></h2>
<p class="Pp"><i></i><i>&quot;new&quot;</i><i></i></p>
<p class="Pp"></p>
<pre>
 my %args = (
    verbosity =&gt; 1,
    lib     =&gt; [ 'lib', 'blib/lib', 'blib/arch' ],
 )
 my $harness = TAP::Harness-&gt;new( \%args );
</pre>
<p class="Pp">The constructor returns a new
    <span class="Li">&quot;TAP::Harness&quot;</span> object. It accepts an
    optional hashref whose allowed keys are:</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;verbosity&quot;</span>
    <p class="Pp">Set the verbosity level:</p>
    <p class="Pp"></p>
    <pre>
     1   verbose        Print individual test results to STDOUT.
     0   normal
    -1   quiet          Suppress some test output (mostly failures 
                        while tests are running).
    -2   really quiet   Suppress everything but the tests summary.
    -3   silent         Suppress everything.
    </pre>
  </li>
  <li><span class="Li">&quot;timer&quot;</span>
    <p class="Pp">Append run time for each test to output. Uses Time::HiRes if
        available.</p>
  </li>
  <li><span class="Li">&quot;failures&quot;</span>
    <p class="Pp">Show test failures (this is a no-op if
        <span class="Li">&quot;verbose&quot;</span> is selected).</p>
  </li>
  <li><span class="Li">&quot;comments&quot;</span>
    <p class="Pp">Show test comments (this is a no-op if
        <span class="Li">&quot;verbose&quot;</span> is selected).</p>
  </li>
  <li><span class="Li">&quot;show_count&quot;</span>
    <p class="Pp">Update the running test count during testing.</p>
  </li>
  <li><span class="Li">&quot;normalize&quot;</span>
    <p class="Pp">Set to a true value to normalize the TAP that is emitted in
        verbose modes.</p>
  </li>
  <li><span class="Li">&quot;lib&quot;</span>
    <p class="Pp">Accepts a scalar value or array ref of scalar values
        indicating which paths to allowed libraries should be included if Perl
        tests are executed. Naturally, this only makes sense in the context of
        tests written in Perl.</p>
  </li>
  <li><span class="Li">&quot;switches&quot;</span>
    <p class="Pp">Accepts a scalar value or array ref of scalar values
        indicating which switches should be included if Perl tests are executed.
        Naturally, this only makes sense in the context of tests written in
        Perl.</p>
  </li>
  <li><span class="Li">&quot;test_args&quot;</span>
    <p class="Pp">A reference to an <span class="Li">@INC</span> style array of
        arguments to be passed to each test program.</p>
    <p class="Pp"></p>
    <pre>
  test_args =&gt; ['foo', 'bar'],
    </pre>
    <p class="Pp">if you want to pass different arguments to each test then you
        should pass a hash of arrays, keyed by the alias for each test:</p>
    <p class="Pp"></p>
    <pre>
  test_args =&gt; {
    my_test    =&gt; ['foo', 'bar'],
    other_test =&gt; ['baz'],
  }
    </pre>
  </li>
  <li><span class="Li">&quot;color&quot;</span>
    <p class="Pp">Attempt to produce color output.</p>
  </li>
  <li><span class="Li">&quot;exec&quot;</span>
    <p class="Pp">Typically, Perl tests are run through this. However, anything
        which spits out TAP is fine. You can use this argument to specify the
        name of the program (and optional switches) to run your tests with:</p>
    <p class="Pp"></p>
    <pre>
  exec =&gt; ['/usr/bin/ruby', '-w']
    </pre>
    <p class="Pp">You can also pass a subroutine reference in order to determine
        and return the proper program to run based on a given test script. The
        subroutine reference should expect the TAP::Harness object itself as the
        first argument, and the file name as the second argument. It should
        return an array reference containing the command to be run and including
        the test file name. It can also simply return
        <span class="Li">&quot;undef&quot;</span>, in which case TAP::Harness
        will fall back on executing the test script in Perl:</p>
    <p class="Pp"></p>
    <pre>
    exec =&gt; sub {
        my ( $harness, $test_file ) = @_;

        # Let Perl tests run.
        return undef if $test_file =~ /[.]t$/;
        return [ qw( /usr/bin/ruby -w ), $test_file ]
          if $test_file =~ /[.]rb$/;
      }
    </pre>
    <p class="Pp">If the subroutine returns a scalar with a newline or a
        filehandle, it will be interpreted as raw TAP or as a TAP stream,
        respectively.</p>
  </li>
  <li><span class="Li">&quot;merge&quot;</span>
    <p class="Pp">If <span class="Li">&quot;merge&quot;</span> is true the
        harness will create parsers that merge STDOUT and STDERR together for
        any processes they start.</p>
  </li>
  <li><span class="Li">&quot;sources&quot;</span>
    <p class="Pp"><i>NEW to 3.18</i>.</p>
    <p class="Pp">If set, <span class="Li">&quot;sources&quot;</span> must be a
        hashref containing the names of the TAP::Parser::SourceHandlers to load
        and/or configure. The values are a hash of configuration that will be
        accessible to to the source handlers via &quot;config_for&quot; in
        TAP::Parser::Source.</p>
    <p class="Pp">For example:</p>
    <p class="Pp"></p>
    <pre>
  sources =&gt; {
    Perl =&gt; { exec =&gt; '/path/to/custom/perl' },
    File =&gt; { extensions =&gt; [ '.tap', '.txt' ] },
    MyCustom =&gt; { some =&gt; 'config' },
  }
    </pre>
    <p class="Pp">The <span class="Li">&quot;sources&quot;</span> parameter
        affects how <span class="Li">&quot;source&quot;</span>,
        <span class="Li">&quot;tap&quot;</span> and
        <span class="Li">&quot;exec&quot;</span> parameters are handled.</p>
    <p class="Pp">For more details, see the
        <span class="Li">&quot;sources&quot;</span> parameter in &quot;new&quot;
        in TAP::Parser, TAP::Parser::Source, and
      TAP::Parser::IteratorFactory.</p>
  </li>
  <li><span class="Li">&quot;aggregator_class&quot;</span>
    <p class="Pp">The name of the class to use to aggregate test results. The
        default is TAP::Parser::Aggregator.</p>
  </li>
  <li><span class="Li">&quot;version&quot;</span>
    <p class="Pp"><i>NEW to 3.22</i>.</p>
    <p class="Pp">Assume this TAP version for TAP::Parser instead of default TAP
        version 12.</p>
  </li>
  <li><span class="Li">&quot;formatter_class&quot;</span>
    <p class="Pp">The name of the class to use to format output. The default is
        TAP::Formatter::Console, or TAP::Formatter::File if the output isn't a
        TTY.</p>
  </li>
  <li><span class="Li">&quot;multiplexer_class&quot;</span>
    <p class="Pp">The name of the class to use to multiplex tests during
        parallel testing. The default is TAP::Parser::Multiplexer.</p>
  </li>
  <li><span class="Li">&quot;parser_class&quot;</span>
    <p class="Pp">The name of the class to use to parse TAP. The default is
        TAP::Parser.</p>
  </li>
  <li><span class="Li">&quot;scheduler_class&quot;</span>
    <p class="Pp">The name of the class to use to schedule test execution. The
        default is TAP::Parser::Scheduler.</p>
  </li>
  <li><span class="Li">&quot;formatter&quot;</span>
    <p class="Pp">If set <span class="Li">&quot;formatter&quot;</span> must be
        an object that is capable of formatting the TAP output. See
        TAP::Formatter::Console for an example.</p>
  </li>
  <li><span class="Li">&quot;errors&quot;</span>
    <p class="Pp">If parse errors are found in the TAP output, a note of this
        will be made in the summary report. To see all of the parse errors, set
        this argument to true:</p>
    <p class="Pp"></p>
    <pre>
  errors =&gt; 1
    </pre>
  </li>
  <li><span class="Li">&quot;directives&quot;</span>
    <p class="Pp">If set to a true value, only test results with directives will
        be displayed. This overrides other settings such as
        <span class="Li">&quot;verbose&quot;</span> or
        <span class="Li">&quot;failures&quot;</span>.</p>
  </li>
  <li><span class="Li">&quot;ignore_exit&quot;</span>
    <p class="Pp">If set to a true value instruct
        <span class="Li">&quot;TAP::Parser&quot;</span> to ignore exit and wait
        status from test scripts.</p>
  </li>
  <li><span class="Li">&quot;jobs&quot;</span>
    <p class="Pp">The maximum number of parallel tests to run at any time. Which
        tests can be run in parallel is controlled by
        <span class="Li">&quot;rules&quot;</span>. The default is to run only
        one test at a time.</p>
  </li>
  <li><span class="Li">&quot;rules&quot;</span>
    <p class="Pp">A reference to a hash of rules that control which tests may be
        executed in parallel. This is an experimental feature and the interface
        may change.</p>
    <p class="Pp"></p>
    <pre>
    $harness-&gt;rules(
        {   par =&gt; [
                { seq =&gt; '../ext/DB_File/t/*' },
                { seq =&gt; '../ext/IO_Compress_Zlib/t/*' },
                { seq =&gt; '../lib/CPANPLUS/*' },
                { seq =&gt; '../lib/ExtUtils/t/*' },
                '*'
            ]
        }
    );
    </pre>
  </li>
  <li><span class="Li">&quot;stdout&quot;</span>
    <p class="Pp">A filehandle for catching standard output.</p>
  </li>
  <li><span class="Li">&quot;trap&quot;</span>
    <p class="Pp">Attempt to print summary information if run is interrupted by
        SIGINT (Ctrl-C).</p>
  </li>
</ul>
<p class="Pp">Any keys for which the value is
    <span class="Li">&quot;undef&quot;</span> will be ignored.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Instance_Methods"><a class="permalink" href="#Instance_Methods">Instance
  Methods</a></h2>
<p class="Pp"><i></i><i>&quot;runtests&quot;</i><i></i></p>
<p class="Pp"></p>
<pre>
    $harness-&gt;runtests(@tests);
</pre>
<p class="Pp">Accepts an array of <span class="Li">@tests</span> to be run. This
    should generally be the names of test files, but this is not required. Each
    element in <span class="Li">@tests</span> will be passed to
    <span class="Li">&quot;TAP::Parser::new()&quot;</span> as a
    <span class="Li">&quot;source&quot;</span>. See TAP::Parser for more
    information.</p>
<p class="Pp">It is possible to provide aliases that will be displayed in place
    of the test name by supplying the test as a reference to an array containing
    <span class="Li">&quot;[ $test, $alias ]&quot;</span>:</p>
<p class="Pp"></p>
<pre>
    $harness-&gt;runtests( [ 't/foo.t', 'Foo Once' ],
                        [ 't/foo.t', 'Foo Twice' ] );
</pre>
<p class="Pp">Normally it is an error to attempt to run the same test twice.
    Aliases allow you to overcome this limitation by giving each run of the test
    a unique name.</p>
<p class="Pp">Tests will be run in the order found.</p>
<p class="Pp">If the environment variable
    <span class="Li">&quot;PERL_TEST_HARNESS_DUMP_TAP&quot;</span> is defined it
    should name a directory into which a copy of the raw TAP for each test will
    be written. TAP is written to files named for each test. Subdirectories will
    be created as needed.</p>
<p class="Pp">Returns a TAP::Parser::Aggregator containing the test results.</p>
<p class="Pp"><i></i><i>&quot;summary&quot;</i><i></i></p>
<p class="Pp"></p>
<pre>
  $harness-&gt;summary( $aggregator );
</pre>
<p class="Pp">Output the summary for a TAP::Parser::Aggregator.</p>
<p class="Pp"><i></i><i>&quot;aggregate_tests&quot;</i><i></i></p>
<p class="Pp"></p>
<pre>
  $harness-&gt;aggregate_tests( $aggregate, @tests );
</pre>
<p class="Pp">Run the named tests and display a summary of result. Tests will be
    run in the order found.</p>
<p class="Pp">Test results will be added to the supplied
    TAP::Parser::Aggregator. <span class="Li">&quot;aggregate_tests&quot;</span>
    may be called multiple times to run several sets of tests. Multiple
    <span class="Li">&quot;Test::Harness&quot;</span> instances may be used to
    pass results to a single aggregator so that different parts of a complex
    test suite may be run using different
    <span class="Li">&quot;TAP::Harness&quot;</span> settings. This is useful,
    for example, in the case where some tests should run in parallel but others
    are unsuitable for parallel execution.</p>
<p class="Pp"></p>
<pre>
    my $formatter   = TAP::Formatter::Console-&gt;new;
    my $ser_harness = TAP::Harness-&gt;new( { formatter =&gt; $formatter } );
    my $par_harness = TAP::Harness-&gt;new(
        {   formatter =&gt; $formatter,
            jobs      =&gt; 9
        }
    );
    my $aggregator = TAP::Parser::Aggregator-&gt;new;

    $aggregator-&gt;start();
    $ser_harness-&gt;aggregate_tests( $aggregator, @ser_tests );
    $par_harness-&gt;aggregate_tests( $aggregator, @par_tests );
    $aggregator-&gt;stop();
    $formatter-&gt;summary($aggregator);
</pre>
<p class="Pp">Note that for simpler testing requirements it will often be
    possible to replace the above code with a single call to
    <span class="Li">&quot;runtests&quot;</span>.</p>
<p class="Pp">Each element of the <span class="Li">@tests</span> array is
    either:</p>
<ul class="Bl-bullet">
  <li>the source name of a test to run</li>
  <li>a reference to a [ source name, display name ] array</li>
</ul>
<p class="Pp">In the case of a perl test suite, typically <i>source names</i>
    are simply the file names of the test scripts to run.</p>
<p class="Pp">When you supply a separate display name it becomes possible to run
    a test more than once; the display name is effectively the alias by which
    the test is known inside the harness. The harness doesn't care if it runs
    the same test more than once when each invocation uses a different name.</p>
<p class="Pp"><i></i><i>&quot;make_scheduler&quot;</i><i></i></p>
<p class="Pp">Called by the harness when it needs to create a
    TAP::Parser::Scheduler. Override in a subclass to provide an alternative
    scheduler. <span class="Li">&quot;make_scheduler&quot;</span> is passed the
    list of tests that was passed to
    <span class="Li">&quot;aggregate_tests&quot;</span>.</p>
<p class="Pp"><i></i><i>&quot;jobs&quot;</i><i></i></p>
<p class="Pp">Gets or sets the number of concurrent test runs the harness is
    handling. By default, this value is 1 -- for parallel testing, this should
    be set higher.</p>
<p class="Pp"><i></i><i>&quot;make_parser&quot;</i><i></i></p>
<p class="Pp">Make a new parser and display formatter session. Typically used
    and/or overridden in subclasses.</p>
<p class="Pp"></p>
<pre>
    my ( $parser, $session ) = $harness-&gt;make_parser;
</pre>
<p class="Pp"><i></i><i>&quot;finish_parser&quot;</i><i></i></p>
<p class="Pp">Terminate use of a parser. Typically used and/or overridden in
    subclasses. The parser isn't destroyed as a result of this.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CONFIGURING"><a class="permalink" href="#CONFIGURING">CONFIGURING</a></h1>
<p class="Pp"><span class="Li">&quot;TAP::Harness&quot;</span> is designed to be
    easy to configure.</p>
<section class="Ss">
<h2 class="Ss" id="Plugins"><a class="permalink" href="#Plugins">Plugins</a></h2>
<p class="Pp"><span class="Li">&quot;TAP::Parser&quot;</span> plugins let you
    change the way TAP is <i>input</i> to and <i>output</i> from the parser.</p>
<p class="Pp">TAP::Parser::SourceHandlers handle TAP <i>input</i>. You can
    configure them and load custom handlers using the
    <span class="Li">&quot;sources&quot;</span> parameter to
  &quot;new&quot;.</p>
<p class="Pp">TAP::Formatters handle TAP <i>output</i>. You can load custom
    formatters by using the <span class="Li">&quot;formatter_class&quot;</span>
    parameter to &quot;new&quot;. To configure a formatter, you currently need
    to instantiate it outside of TAP::Harness and pass it in with the
    <span class="Li">&quot;formatter&quot;</span> parameter to &quot;new&quot;.
    This <i>may</i> be addressed by adding a <i>formatters</i> parameter to
    &quot;new&quot; in the future.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_Module::Build_"><a class="permalink" href="#_Module::Build_">&quot;Module::Build&quot;</a></h2>
<p class="Pp">Module::Build version <span class="Li">0.30</span> supports
    <span class="Li">&quot;TAP::Harness&quot;</span>.</p>
<p class="Pp">To load <span class="Li">&quot;TAP::Harness&quot;</span> plugins,
    you'll need to use the <span class="Li">&quot;tap_harness_args&quot;</span>
    parameter to <span class="Li">&quot;new&quot;</span>, typically from your
    <span class="Li">&quot;Build.PL&quot;</span>. For example:</p>
<p class="Pp"></p>
<pre>
  Module::Build-&gt;new(
      module_name        =&gt; 'MyApp',
      test_file_exts     =&gt; [qw(.t .tap .txt)],
      use_tap_harness    =&gt; 1,
      tap_harness_args   =&gt; {
          sources =&gt; {
              MyCustom =&gt; {},
              File =&gt; {
                  extensions =&gt; ['.tap', '.txt'],
              },
          },
          formatter_class =&gt; 'TAP::Formatter::HTML',
      },
      build_requires     =&gt; {
          'Module::Build' =&gt; '0.30',
          'TAP::Harness'  =&gt; '3.18',
      },
  )-&gt;create_build_script;
</pre>
<p class="Pp">See &quot;new&quot;</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_ExtUtils::MakeMaker_"><a class="permalink" href="#_ExtUtils::MakeMaker_">&quot;ExtUtils::MakeMaker&quot;</a></h2>
<p class="Pp">ExtUtils::MakeMaker does not support TAP::Harness
  out-of-the-box.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_prove_"><a class="permalink" href="#_prove_">&quot;prove&quot;</a></h2>
<p class="Pp">prove supports <span class="Li">&quot;TAP::Harness&quot;</span>
    plugins, and has a plugin system of its own. See &quot;FORMATTERS&quot; in
    prove, &quot;SOURCE HANDLERS&quot; in prove and App::Prove for more
  details.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="WRITING_PLUGINS"><a class="permalink" href="#WRITING_PLUGINS">WRITING
  PLUGINS</a></h1>
<p class="Pp">If you can't configure
    <span class="Li">&quot;TAP::Harness&quot;</span> to do what you want, and
    you can't find an existing plugin, consider writing one.</p>
<p class="Pp">The two primary use cases supported by TAP::Harness for plugins
    are <i>input</i> and <i>output</i>:</p>
<dl class="Bl-tag">
  <dt id="Customize"><a class="permalink" href="#Customize">Customize how TAP
    gets into the parser</a></dt>
  <dd>To do this, you can either extend an existing TAP::Parser::SourceHandler,
      or write your own. It's a pretty simple API, and they can be loaded and
      configured using the <span class="Li">&quot;sources&quot;</span> parameter
      to &quot;new&quot;.</dd>
  <dt id="Customize~2"><a class="permalink" href="#Customize~2">Customize how
    TAP results are output from the parser</a></dt>
  <dd>To do this, you can either extend an existing TAP::Formatter, or write
      your own. Writing formatters are a bit more involved than writing a
      <i>SourceHandler</i>, as you'll need to understand the TAP::Parser API. A
      good place to start is by understanding how &quot;aggregate_tests&quot;
      works.
    <p class="Pp">Custom formatters can be loaded configured using the
        <span class="Li">&quot;formatter_class&quot;</span> parameter to
        &quot;new&quot;.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SUBCLASSING"><a class="permalink" href="#SUBCLASSING">SUBCLASSING</a></h1>
<p class="Pp">If you can't configure
    <span class="Li">&quot;TAP::Harness&quot;</span> to do exactly what you
    want, and writing a plugin isn't an option, consider extending it. It is
    designed to be (mostly) easy to subclass, though the cases when sub-classing
    is necessary should be few and far between.</p>
<section class="Ss">
<h2 class="Ss" id="Methods"><a class="permalink" href="#Methods">Methods</a></h2>
<p class="Pp">The following methods are ones you may wish to override if you
    want to subclass <span class="Li">&quot;TAP::Harness&quot;</span>.</p>
<dl class="Bl-tag">
  <dt>&quot;new&quot;</dt>
  <dd></dd>
  <dt>&quot;runtests&quot;</dt>
  <dd></dd>
  <dt>&quot;summary&quot;</dt>
  <dd></dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="REPLACING"><a class="permalink" href="#REPLACING">REPLACING</a></h1>
<p class="Pp">If you like the <span class="Li">&quot;prove&quot;</span> utility
    and TAP::Parser but you want your own harness, all you need to do is write
    one and provide <span class="Li">&quot;new&quot;</span> and
    <span class="Li">&quot;runtests&quot;</span> methods. Then you can use the
    <span class="Li">&quot;prove&quot;</span> utility like so:</p>
<p class="Pp"></p>
<pre>
 prove --harness My::Test::Harness
</pre>
<p class="Pp">Note that while <span class="Li">&quot;prove&quot;</span> accepts
    a list of tests (or things to be tested),
    <span class="Li">&quot;new&quot;</span> has a fairly rich set of arguments.
    You'll probably want to read over this code carefully to see how all of them
    are being used.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Test::Harness</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>HTTP::Request(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">HTTP::Request(3)</td>
    <td class="head-vol"><a href=".">User Contributed Perl Documentation</a></td>
    <td class="head-rtitle">HTTP::Request(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">HTTP::Request - HTTP style request message</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 6.22</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre> require HTTP::Request;
 $request = HTTP::Request-&gt;new(GET =&gt; 'http://www.example.com/');
</pre>
<p class="Pp">and usually used like this:</p>
<p class="Pp"></p>
<pre> $ua = LWP::UserAgent-&gt;new;
 $response = $ua-&gt;request($request);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><span class="Li">&quot;HTTP::Request&quot;</span> is a class
    encapsulating HTTP style requests, consisting of a request line, some
    headers, and a content body. Note that the LWP library uses HTTP style
    requests even for non-HTTP protocols. Instances of this class are usually
    passed to the <b>request()</b> method of an
    <span class="Li">&quot;LWP::UserAgent&quot;</span> object.</p>
<p class="Pp"><span class="Li">&quot;HTTP::Request&quot;</span> is a subclass of
    <span class="Li">&quot;HTTP::Message&quot;</span> and therefore inherits its
    methods. The following additional methods are available:</p>
<dl class="Bl-tag">
  <dt>$r = HTTP::Request-&gt;new( $method, $uri )</dt>
  <dd></dd>
  <dt>$r = HTTP::Request-&gt;new( $method, $uri, $header )</dt>
  <dd></dd>
  <dt>$r = HTTP::Request-&gt;new( $method, $uri, $header, $content )</dt>
  <dd>Constructs a new <span class="Li">&quot;HTTP::Request&quot;</span> object
      describing a request on the object <span class="Li">$uri</span> using
      method <span class="Li">$method</span>. The
      <span class="Li">$method</span> argument must be a string. The
      <span class="Li">$uri</span> argument can be either a string, or a
      reference to a <span class="Li">&quot;URI&quot;</span> object. The
      optional <span class="Li">$header</span> argument should be a reference to
      an <span class="Li">&quot;HTTP::Headers&quot;</span> object or a plain
      array reference of key/value pairs. The optional
      <span class="Li">$content</span> argument should be a string of
    bytes.</dd>
  <dt>$r = HTTP::Request-&gt;parse( $str )</dt>
  <dd>This constructs a new request object by parsing the given string.</dd>
  <dt>$r-&gt;method</dt>
  <dd></dd>
  <dt>$r-&gt;method( $val )</dt>
  <dd>This is used to get/set the method attribute. The method should be a short
      string like &quot;GET&quot;, &quot;HEAD&quot;, &quot;PUT&quot;,
      &quot;PATCH&quot; or &quot;POST&quot;.</dd>
  <dt>$r-&gt;uri</dt>
  <dd></dd>
  <dt>$r-&gt;uri( $val )</dt>
  <dd>This is used to get/set the uri attribute. The
      <span class="Li">$val</span> can be a reference to a URI object or a plain
      string. If a string is given, then it should be parsable as an absolute
      URI.</dd>
  <dt>$r-&gt;header( $field )</dt>
  <dd></dd>
  <dt>$r-&gt;header( $field =&gt; $value )</dt>
  <dd>This is used to get/set header values and it is inherited from
      <span class="Li">&quot;HTTP::Headers&quot;</span> via
      <span class="Li">&quot;HTTP::Message&quot;</span>. See HTTP::Headers for
      details and other similar methods that can be used to access the
    headers.</dd>
  <dt>$r-&gt;accept_decodable</dt>
  <dd>This will set the <span class="Li">&quot;Accept-Encoding&quot;</span>
      header to the list of encodings that <b>decoded_content()</b> can
    decode.</dd>
  <dt>$r-&gt;content</dt>
  <dd></dd>
  <dt>$r-&gt;content( $bytes )</dt>
  <dd>This is used to get/set the content and it is inherited from the
      <span class="Li">&quot;HTTP::Message&quot;</span> base class. See
      HTTP::Message for details and other methods that can be used to access the
      content.
    <p class="Pp">Note that the content should be a string of bytes. Strings in
        perl can contain characters outside the range of a byte. The
        <span class="Li">&quot;Encode&quot;</span> module can be used to turn
        such strings into a string of bytes.</p>
  </dd>
  <dt>$r-&gt;as_string</dt>
  <dd></dd>
  <dt>$r-&gt;as_string( $eol )</dt>
  <dd>Method returning a textual representation of the request.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">Creating requests to be sent with LWP::UserAgent or others can be
    easy. Here are a few examples.</p>
<section class="Ss">
<h2 class="Ss" id="Simple_"><a class="permalink" href="#Simple_">Simple
  POST</a></h2>
<p class="Pp">Here, we'll create a simple POST request that could be used to
    send JSON data to an endpoint.</p>
<p class="Pp"></p>
<pre>    #!/usr/bin/env perl
    use strict;
    use warnings;
    use HTTP::Request ();
    use JSON::MaybeXS qw(encode_json);
    my $url = 'https://www.example.com/api/user/123';
    my $header = ['Content-Type' =&gt; 'application/json; charset=UTF-8'];
    my $data = {foo =&gt; 'bar', baz =&gt; 'quux'};
    my $encoded_data = encode_json($data);
    my $r = HTTP::Request-&gt;new('POST', $url, $header, $encoded_data);
    # at this point, we could send it via LWP::UserAgent
    # my $ua = LWP::UserAgent-&gt;new();
    # my $res = $ua-&gt;request($r);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Batch_"><a class="permalink" href="#Batch_">Batch POST
  Request</a></h2>
<p class="Pp">Some services, like Google, allow multiple requests to be sent in
    one batch. &lt;https://developers.google.com/drive/v3/web/batch&gt; for
    example. Using the <span class="Li">&quot;add_part&quot;</span> method from
    HTTP::Message makes this simple.</p>
<p class="Pp"></p>
<pre>    #!/usr/bin/env perl
    use strict;
    use warnings;
    use HTTP::Request ();
    use JSON::MaybeXS qw(encode_json);
    my $auth_token = 'auth_token';
    my $batch_url = 'https://www.googleapis.com/batch';
    my $url = 'https://www.googleapis.com/drive/v3/files/fileId/permissions?fields=id';
    my $url_no_email = 'https://www.googleapis.com/drive/v3/files/fileId/permissions?fields=id&amp;sendNotificationEmail=false';
    # generate a JSON post request for one of the batch entries
    my $req1 = build_json_request($url, {
        emailAddress =&gt; 'example@appsrocks.com',
        role =&gt; &quot;writer&quot;,
        type =&gt; &quot;user&quot;,
    });
    # generate a JSON post request for one of the batch entries
    my $req2 = build_json_request($url_no_email, {
        domain =&gt; &quot;appsrocks.com&quot;,
        role =&gt; &quot;reader&quot;,
        type =&gt; &quot;domain&quot;,
    });
    # generate a multipart request to send all of the other requests
    my $r = HTTP::Request-&gt;new('POST', $batch_url, [
        'Accept-Encoding' =&gt; 'gzip',
        # if we don't provide a boundary here, HTTP::Message will generate
        # one for us. We could use UUID::uuid() here if we wanted.
        'Content-Type' =&gt; 'multipart/mixed; boundary=END_OF_PART'
    ]);
    # add the two POST requests to the main request
    $r-&gt;add_part($req1, $req2);
    # at this point, we could send it via LWP::UserAgent
    # my $ua = LWP::UserAgent-&gt;new();
    # my $res = $ua-&gt;request($r);
    exit();
    sub build_json_request {
        my ($url, $href) = @_;
        my $header = ['Authorization' =&gt; &quot;Bearer $auth_token&quot;, 'Content-Type' =&gt; 'application/json; charset=UTF-8'];
        return HTTP::Request-&gt;new('POST', $url, $header, encode_json($href));
    }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">HTTP::Headers, HTTP::Message, HTTP::Request::Common,
    HTTP::Response</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Gisle Aas &lt;gisle@activestate.com&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 1994-2017 by Gisle Aas.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-02-24</td>
    <td class="foot-os"><a href="..">perl v5.34.0</a></td>
  </tr>
</table>
</body>
</html>

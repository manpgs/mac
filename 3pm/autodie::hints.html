<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>autodie::hints(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">autodie::hints(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">autodie::hints(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">autodie::hints - Provide hints about user subroutines to
  autodie</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
    package Your::Module;

    our %DOES = ( 'autodie::hints::provider' =&gt; 1 );

    sub AUTODIE_HINTS {
        return {
            foo =&gt; { scalar =&gt; HINTS, list =&gt; SOME_HINTS },
            bar =&gt; { scalar =&gt; HINTS, list =&gt; MORE_HINTS },
        }
    }

    # Later, in your main program...

    use Your::Module qw(foo bar);
    use autodie      qw(:default foo bar);

    foo();         # succeeds or dies based on scalar hints

    # Alternatively, hints can be set on subroutines we've
    # imported.

    use autodie::hints;
    use Some::Module qw(think_positive);

    BEGIN {
        autodie::hints-&gt;set_hints_for(
            \&amp;think_positive,
            {
                fail =&gt; sub { $_[0] &lt;= 0 }
            }
        )
    }
    use autodie qw(think_positive);

    think_positive(...);    # Returns positive or dies.
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<section class="Ss">
<h2 class="Ss" id="Introduction"><a class="permalink" href="#Introduction">Introduction</a></h2>
<p class="Pp">The autodie pragma is very smart when it comes to working with
    Perl's built-in functions. The behaviour for these functions are fixed, and
    <span class="Li">&quot;autodie&quot;</span> knows exactly how they try to
    signal failure.</p>
<p class="Pp">But what about user-defined subroutines from modules? If you use
    <span class="Li">&quot;autodie&quot;</span> on a user-defined subroutine
    then it assumes the following behaviour to demonstrate failure:</p>
<ul class="Bl-bullet">
  <li>A false value, in scalar context</li>
  <li>An empty list, in list context</li>
  <li>A list containing a single undef, in list context</li>
</ul>
<p class="Pp">All other return values (including the list of the single zero,
    and the list containing a single empty string) are considered successful.
    However, real-world code isn't always that easy. Perhaps the code you're
    working with returns a string containing the word &quot;FAIL&quot; upon
    failure, or a two element list containing <span class="Li">&quot;(undef,
    &quot;human error message&quot;)&quot;</span>. To make autodie work with
    these sorts of subroutines, we have the <i>hinting interface</i>.</p>
<p class="Pp">The hinting interface allows <i>hints</i> to be provided to
    <span class="Li">&quot;autodie&quot;</span> on how it should detect failure
    from user-defined subroutines. While these <i>can</i> be provided by the
    end-user of <span class="Li">&quot;autodie&quot;</span>, they are ideally
    written into the module itself, or into a helper module or sub-class of
    <span class="Li">&quot;autodie&quot;</span> itself.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="What_are_hints?"><a class="permalink" href="#What_are_hints?">What
  are hints?</a></h2>
<p class="Pp">A <i>hint</i> is a subroutine or value that is checked against the
    return value of an autodying subroutine. If the match returns true,
    <span class="Li">&quot;autodie&quot;</span> considers the subroutine to have
    failed.</p>
<p class="Pp">If the hint provided is a subroutine, then
    <span class="Li">&quot;autodie&quot;</span> will pass the complete return
    value to that subroutine. If the hint is any other value, then
    <span class="Li">&quot;autodie&quot;</span> will smart-match against the
    value provided. In Perl 5.8.x there is no smart-match operator, and as such
    only subroutine hints are supported in these versions.</p>
<p class="Pp">Hints can be provided for both scalar and list contexts. Note that
    an autodying subroutine will never see a void context, as
    <span class="Li">&quot;autodie&quot;</span> always needs to capture the
    return value for examination. Autodying subroutines called in void context
    act as if they're called in a scalar context, but their return value is
    discarded after it has been checked.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Example_hints"><a class="permalink" href="#Example_hints">Example
  hints</a></h2>
<p class="Pp">Hints may consist of subroutine references, objects overloading
    smart-match, regular expressions, and depending on Perl version possibly
    other things. You can specify different hints for how failure should be
    identified in scalar and list contexts.</p>
<p class="Pp">These examples apply for use in the
    <span class="Li">&quot;AUTODIE_HINTS&quot;</span> subroutine and when
    calling
    <span class="Li">&quot;autodie::hints-&quot;</span><b>set_hints_for()</b>&gt;.</p>
<p class="Pp">The most common context-specific hints are:</p>
<p class="Pp"></p>
<pre>
        # Scalar failures always return undef:
            {  scalar =&gt; sub { !defined($_[0]) }  }

        # Scalar failures return any false value [default expectation]:
            {  scalar =&gt; sub { ! $_[0] }  }

        # Scalar failures always return zero explicitly:
            {  scalar =&gt; sub { defined($_[0]) &amp;&amp; $_[0] eq '0' }  }

        # List failures always return an empty list:
            {  list =&gt; sub { !@_ }  }

        # List failures return () or (undef) [default expectation]:
            {  list =&gt; sub { ! @_ || @_ == 1 &amp;&amp; !defined $_[0] }  }

        # List failures return () or a single false value:
            {  list =&gt; sub { ! @_ || @_ == 1 &amp;&amp; !$_[0] }  }

        # List failures return (undef, &quot;some string&quot;)
            {  list =&gt; sub { @_ == 2 &amp;&amp; !defined $_[0] }  }

        # Unsuccessful foo() returns 'FAIL' or '_FAIL' in scalar context,
        #                    returns (-1) in list context...
        autodie::hints-&gt;set_hints_for(
            \&amp;foo,
            {
                scalar =&gt; qr/^ _? FAIL $/xms,
                list   =&gt; sub { @_ == 1 &amp;&amp; $_[0] eq -1 },
            }
        );

        # Unsuccessful foo() returns 0 in all contexts...
        autodie::hints-&gt;set_hints_for(
            \&amp;foo,
            {
                scalar =&gt; sub { defined($_[0]) &amp;&amp; $_[0] == 0 },
                list   =&gt; sub { @_ == 1 &amp;&amp; defined($_[0]) &amp;&amp; $_[0] == 0 },
            }
        );
</pre>
<p class="Pp">This &quot;in all contexts&quot; construction is very common, and
    can be abbreviated, using the 'fail' key. This sets both the
    <span class="Li">&quot;scalar&quot;</span> and
    <span class="Li">&quot;list&quot;</span> hints to the same value:</p>
<p class="Pp"></p>
<pre>
        # Unsuccessful foo() returns 0 in all contexts...
        autodie::hints-&gt;set_hints_for(
            \&amp;foo,
            {
                fail =&gt; sub { @_ == 1 and defined $_[0] and $_[0] == 0 }
            }
        );

        # Unsuccessful think_positive() returns negative number on failure...
        autodie::hints-&gt;set_hints_for(
            \&amp;think_positive,
            {
                fail =&gt; sub { $_[0] &lt; 0 }
            }
        );

        # Unsuccessful my_system() returns non-zero on failure...
        autodie::hints-&gt;set_hints_for(
            \&amp;my_system,
            {
                fail =&gt; sub { $_[0] != 0 }
            }
        );
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Manually_setting_hints_from_within_your_program"><a class="permalink" href="#Manually_setting_hints_from_within_your_program">Manually
  setting hints from within your program</a></h1>
<p class="Pp">If you are using a module which returns something special on
    failure, then you can manually create hints for each of the desired
    subroutines. Once the hints are specified, they are available for all files
    and modules loaded thereafter, thus you can move this work into a module and
    it will still work.</p>
<p class="Pp"></p>
<pre>
        use Some::Module qw(foo bar);
        use autodie::hints;

        autodie::hints-&gt;set_hints_for(
                \&amp;foo,
                {
                        scalar =&gt; SCALAR_HINT,
                        list   =&gt; LIST_HINT,
                }
        );
        autodie::hints-&gt;set_hints_for(
                \&amp;bar,
                { fail =&gt; SOME_HINT, }
        );
</pre>
<p class="Pp">It is possible to pass either a subroutine reference (recommended)
    or a fully qualified subroutine name as the first argument. This means you
    can set hints on modules that <i>might</i> get loaded:</p>
<p class="Pp"></p>
<pre>
        use autodie::hints;
        autodie::hints-&gt;set_hints_for(
                'Some::Module:bar', { fail =&gt; SCALAR_HINT, }
        );
</pre>
<p class="Pp">This technique is most useful when you have a project that uses a
    lot of third-party modules. You can define all your possible hints in
    one-place. This can even be in a sub-class of autodie. For example:</p>
<p class="Pp"></p>
<pre>
        package my::autodie;

        use parent qw(autodie);
        use autodie::hints;

        autodie::hints-&gt;set_hints_for(...);

        1;
</pre>
<p class="Pp">You can now <span class="Li">&quot;use my::autodie&quot;</span>,
    which will work just like the standard
    <span class="Li">&quot;autodie&quot;</span>, but is now aware of any hints
    that you've set.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Adding_hints_to_your_module"><a class="permalink" href="#Adding_hints_to_your_module">Adding
  hints to your module</a></h1>
<p class="Pp"><span class="Li">&quot;autodie&quot;</span> provides a passive
    interface to allow you to declare hints for your module. These hints will be
    found and used by <span class="Li">&quot;autodie&quot;</span> if it is
    loaded, but otherwise have no effect (or dependencies) without autodie. To
    set these, your module needs to declare that it <i>does</i> the
    <span class="Li">&quot;autodie::hints::provider&quot;</span> role. This can
    be done by writing your own <span class="Li">&quot;DOES&quot;</span> method,
    using a system such as <span class="Li">&quot;Class::DOES&quot;</span> to
    handle the heavy-lifting for you, or declaring a
    <span class="Li">%DOES</span> package variable with a
    <span class="Li">&quot;autodie::hints::provider&quot;</span> key and a
    corresponding true value.</p>
<p class="Pp">Note that checking for a <span class="Li">%DOES</span> hash is an
    <span class="Li">&quot;autodie&quot;</span>-only short-cut. Other modules do
    not use this mechanism for checking roles, although you can use the
    <span class="Li">&quot;Class::DOES&quot;</span> module from the CPAN to
    allow it.</p>
<p class="Pp">In addition, you must define a
    <span class="Li">&quot;AUTODIE_HINTS&quot;</span> subroutine that returns a
    hash-reference containing the hints for your subroutines:</p>
<p class="Pp"></p>
<pre>
        package Your::Module;

        # We can use the Class::DOES from the CPAN to declare adherence
        # to a role.

        use Class::DOES 'autodie::hints::provider' =&gt; 1;

        # Alternatively, we can declare the role in %DOES.  Note that
        # this is an autodie specific optimisation, although Class::DOES
        # can be used to promote this to a true role declaration.

        our %DOES = ( 'autodie::hints::provider' =&gt; 1 );

        # Finally, we must define the hints themselves.

        sub AUTODIE_HINTS {
            return {
                foo =&gt; { scalar =&gt; HINTS, list =&gt; SOME_HINTS },
                bar =&gt; { scalar =&gt; HINTS, list =&gt; MORE_HINTS },
                baz =&gt; { fail =&gt; HINTS },
            }
        }
</pre>
<p class="Pp">This allows your code to set hints without relying on
    <span class="Li">&quot;autodie&quot;</span> and
    <span class="Li">&quot;autodie::hints&quot;</span> being loaded, or even
    installed. In this way your code can do the right thing when
    <span class="Li">&quot;autodie&quot;</span> is installed, but does not need
    to depend upon it to function.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Insisting_on_hints"><a class="permalink" href="#Insisting_on_hints">Insisting
  on hints</a></h1>
<p class="Pp">When a user-defined subroutine is wrapped by
    <span class="Li">&quot;autodie&quot;</span>, it will use hints if they are
    available, and otherwise reverts to the <i>default behaviour</i> described
    in the introduction of this document. This can be problematic if we expect a
    hint to exist, but (for whatever reason) it has not been loaded.</p>
<p class="Pp">We can ask autodie to <i>insist</i> that a hint be used by
    prefixing an exclamation mark to the start of the subroutine name. A lone
    exclamation mark indicates that <i>all</i> subroutines after it must have
    hints declared.</p>
<p class="Pp"></p>
<pre>
        # foo() and bar() must have their hints defined
        use autodie qw( !foo !bar baz );

        # Everything must have hints (recommended).
        use autodie qw( ! foo bar baz );

        # bar() and baz() must have their hints defined
        use autodie qw( foo ! bar baz );

        # Enable autodie for all of Perl's supported built-ins,
        # as well as for foo(), bar() and baz().  Everything must
        # have hints.
        use autodie qw( ! :all foo bar baz );
</pre>
<p class="Pp">If hints are not available for the specified subroutines, this
    will cause a compile-time error. Insisting on hints for Perl's built-in
    functions (eg, <span class="Li">&quot;open&quot;</span> and
    <span class="Li">&quot;close&quot;</span>) is always successful.</p>
<p class="Pp">Insisting on hints is <i>strongly</i> recommended.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Diagnostics"><a class="permalink" href="#Diagnostics">Diagnostics</a></h1>
<dl class="Bl-tag">
  <dt id="Attempts"><a class="permalink" href="#Attempts">Attempts to
    set_hints_for unidentifiable subroutine</a></dt>
  <dd>You've called
      <span class="Li">&quot;autodie::hints-&gt;set_hints_for()&quot;</span>
      using a subroutine reference, but that reference could not be resolved
      back to a subroutine name. It may be an anonymous subroutine (which can't
      be made autodying), or may lack a name for other reasons.
    <p class="Pp">If you receive this error with a subroutine that has a real
        name, then you may have found a bug in autodie. See &quot;BUGS&quot; in
        autodie for how to report this.</p>
  </dd>
  <dt id="fail"><a class="permalink" href="#fail">fail hints cannot be provided
    with either scalar or list hints for %s</a></dt>
  <dd>When defining hints, you can either supply both
      <span class="Li">&quot;list&quot;</span> and
      <span class="Li">&quot;scalar&quot;</span> keywords, <i>or</i> you can
      provide a single <span class="Li">&quot;fail&quot;</span> keyword. You
      can't mix and match them.</dd>
  <dt>%s hint missing for %s</dt>
  <dd>You've provided either a <span class="Li">&quot;scalar&quot;</span> hint
      without supplying a <span class="Li">&quot;list&quot;</span> hint, or
      vice-versa. You <i>must</i> supply both
      <span class="Li">&quot;scalar&quot;</span> and
      <span class="Li">&quot;list&quot;</span> hints, <i>or</i> a single
      <span class="Li">&quot;fail&quot;</span> hint.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGEMENTS"><a class="permalink" href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></h1>
<ul class="Bl-bullet">
  <li>Dr Damian Conway for suggesting the hinting interface and providing the
      example usage.</li>
  <li>Jacinta Richardson for translating much of my ideas into this
      documentation.</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Copyright 2009, Paul Fenwick &lt;pjf@perltraining.com.au&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">This module is free software. You may distribute it under the same
    terms as Perl itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">autodie, Class::DOES</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

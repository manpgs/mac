<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Moose::Manual::Construction(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Moose::Manual::Construction(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Moose::Manual::Construction(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Moose::Manual::Construction - Object construction (and
    destruction) with Moose</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 2.2012</p>
</section>
<section class="Sh">
<h1 class="Sh" id="WHERE'S_THE_CONSTRUCTOR?"><a class="permalink" href="#WHERE'S_THE_CONSTRUCTOR?">WHERE'S
  THE CONSTRUCTOR?</a></h1>
<p class="Pp"><b>Do not define a
    </b><span class="Li"><b>&quot;new()&quot;</b></span><b> method for your
    classes!</b></p>
<p class="Pp">When you <span class="Li">&quot;use Moose&quot;</span> in your
    class, your class becomes a subclass of Moose::Object. The Moose::Object
    provides a <span class="Li">&quot;new()&quot;</span> method for your class.
    If you follow our recommendations in Moose::Manual::BestPractices and make
    your class immutable, then you actually get a class-specific
    <span class="Li">&quot;new()&quot;</span> method &quot;inlined&quot; in your
    class.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OBJECT_CONSTRUCTION_AND_ATTRIBUTES"><a class="permalink" href="#OBJECT_CONSTRUCTION_AND_ATTRIBUTES">OBJECT
  CONSTRUCTION AND ATTRIBUTES</a></h1>
<p class="Pp">The Moose-provided constructor accepts a hash or hash reference of
    named parameters matching your attributes (actually, matching their
    <span class="Li">&quot;init_arg&quot;</span>s). This is just another way in
    which Moose keeps you from worrying <i>how</i> classes are implemented.
    Simply define a class and you're ready to start creating objects!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OBJECT_CONSTRUCTION_HOOKS"><a class="permalink" href="#OBJECT_CONSTRUCTION_HOOKS">OBJECT
  CONSTRUCTION HOOKS</a></h1>
<p class="Pp">Moose lets you hook into object construction. You can validate an
    object's state, do logging, customize construction from parameters which do
    not match your attributes, or maybe allow non-hash(ref) constructor
    arguments. You can do this by creating
    <span class="Li">&quot;BUILD&quot;</span> and/or
    <span class="Li">&quot;BUILDARGS&quot;</span> methods.</p>
<p class="Pp">If these methods exist in your class, Moose will arrange for them
    to be called as part of the object construction process.</p>
<section class="Ss">
<h2 class="Ss">BUILDARGS</h2>
<p class="Pp">The <span class="Li">&quot;BUILDARGS&quot;</span> method is called
    as a class method <i>before</i> an object is created. It will receive all of
    the arguments that were passed to <span class="Li">&quot;new()&quot;</span>
    <i>as-is</i>, and is expected to return a hash reference. This hash
    reference will be used to construct the object, so it should contain keys
    matching your attributes' names (well,
    <span class="Li">&quot;init_arg&quot;</span>s).</p>
<p class="Pp">One common use for <span class="Li">&quot;BUILDARGS&quot;</span>
    is to accommodate a non-hash(ref) calling style. For example, we might want
    to allow our Person class to be called with a single argument of a social
    security number,
  <span class="Li">&quot;Person-&gt;new($ssn)&quot;</span>.</p>
<p class="Pp">Without a <span class="Li">&quot;BUILDARGS&quot;</span> method,
    Moose will complain, because it expects a hash or hash reference. We can use
    the <span class="Li">&quot;BUILDARGS&quot;</span> method to accommodate this
    calling style:</p>
<p class="Pp"></p>
<pre>  around BUILDARGS =&gt; sub {
      my $orig  = shift;
      my $class = shift;
      if ( @_ == 1 &amp;&amp; !ref $_[0] ) {
          return $class-&gt;$orig( ssn =&gt; $_[0] );
      }
      else {
          return $class-&gt;$orig(@_);
      }
  };
</pre>
<p class="Pp">Note the call to
    <span class="Li">&quot;$class-&gt;$orig&quot;</span>. This will call the
    default <span class="Li">&quot;BUILDARGS&quot;</span> in Moose::Object. This
    method takes care of distinguishing between a hash reference and a plain
    hash for you.</p>
</section>
<section class="Ss">
<h2 class="Ss">BUILD</h2>
<p class="Pp">The <span class="Li">&quot;BUILD&quot;</span> method is called
    <i>after</i> an object is created. There are several reasons to use a
    <span class="Li">&quot;BUILD&quot;</span> method. One of the most common is
    to check that the object state is valid. While we can validate individual
    attributes through the use of types, we can't validate the state of a whole
    object that way.</p>
<p class="Pp"></p>
<pre>  sub BUILD {
      my $self = shift;
      if ( $self-&gt;country_of_residence eq 'USA' ) {
          die 'All US residents must have an SSN'
              unless $self-&gt;has_ssn;
      }
  }
</pre>
<p class="Pp">Another use of a <span class="Li">&quot;BUILD&quot;</span> method
    could be for logging or tracking object creation.</p>
<p class="Pp"></p>
<pre>  sub BUILD {
      my $self = shift;
      debug( 'Made a new person - SSN = ', $self-&gt;ssn, );
  }
</pre>
<p class="Pp">The <span class="Li">&quot;BUILD&quot;</span> method is called
    with the hash reference of the parameters passed to the constructor (after
    munging by <span class="Li">&quot;BUILDARGS&quot;</span>). This gives you a
    chance to do something with parameters that do not represent object
    attributes.</p>
<p class="Pp"></p>
<pre>  sub BUILD {
      my $self = shift;
      my $args = shift;
      $self-&gt;add_friend(
          My::User-&gt;new(
              user_id =&gt; $args-&gt;{user_id},
          )
      );
  }
</pre>
<p class="Pp"><i>BUILD and parent classes</i></p>
<p class="Pp">The interaction between multiple
    <span class="Li">&quot;BUILD&quot;</span> methods in an inheritance
    hierarchy is different from normal Perl methods. <b>You should never call
    </b><span class="Li"><b>&quot;$self-&gt;SUPER::BUILD&quot;</b></span><b></b>,
    nor should you ever apply a method modifier to
    <span class="Li">&quot;BUILD&quot;</span>. Roles are an exception to this
    rule, though: it's completely acceptable to apply a method modifier to
    <span class="Li">&quot;BUILD&quot;</span> in a role; you can even provide an
    empty <span class="Li">&quot;BUILD&quot;</span> subroutine in a role so the
    role is applicable even to classes without their own
    <span class="Li">&quot;BUILD&quot;</span>.</p>
<p class="Pp">Moose arranges to have all of the
    <span class="Li">&quot;BUILD&quot;</span> methods in a hierarchy called when
    an object is constructed, <i>from parents to</i> <i>children</i>. This might
    be surprising at first, because it reverses the normal order of method
    inheritance.</p>
<p class="Pp">The theory behind this is that
    <span class="Li">&quot;BUILD&quot;</span> methods can only be used for
    increasing specialization of a class's constraints, so it makes sense to
    call the least specific <span class="Li">&quot;BUILD&quot;</span> method
    first. Also, this is how Perl 6 does it.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="OBJECT_DESTRUCTION"><a class="permalink" href="#OBJECT_DESTRUCTION">OBJECT
  DESTRUCTION</a></h1>
<p class="Pp">Moose provides a hook for object destruction with the
    <span class="Li">&quot;DEMOLISH&quot;</span> method. As with
    <span class="Li">&quot;BUILD&quot;</span>, you should never explicitly call
    <span class="Li">&quot;$self-&gt;SUPER::DEMOLISH&quot;</span>. Moose will
    arrange for all of the <span class="Li">&quot;DEMOLISH&quot;</span> methods
    in your hierarchy to be called, from most to least specific.</p>
<p class="Pp">Each <span class="Li">&quot;DEMOLISH&quot;</span> method is called
    with a single argument. This is a boolean value indicating whether or not
    this method was called as part of the global destruction process (when the
    Perl interpreter exits).</p>
<p class="Pp">In most cases, Perl's built-in garbage collection is sufficient,
    and you won't need to provide a <span class="Li">&quot;DEMOLISH&quot;</span>
    method.</p>
<section class="Ss">
<h2 class="Ss" id="Error_Handling_During_Destruction"><a class="permalink" href="#Error_Handling_During_Destruction">Error
  Handling During Destruction</a></h2>
<p class="Pp">The interaction of object destruction and Perl's global
    <span class="Li">$@</span> and <span class="Li">$?</span> variables can be
    very confusing.</p>
<p class="Pp">Moose always localizes <span class="Li">$?</span> when an object
    is being destroyed. This means that if you explicitly call
    <span class="Li">&quot;exit&quot;</span>, that exit code will be preserved
    even if an object's destructor makes a system call.</p>
<p class="Pp">Moose also preserves <span class="Li">$@</span> against any
    <span class="Li">&quot;eval&quot;</span> calls that may happen during object
    destruction. However, if an object's
    <span class="Li">&quot;DEMOLISH&quot;</span> method actually dies, Moose
    explicitly rethrows that error.</p>
<p class="Pp">If you do not like this behavior, you will have to provide your
    own <span class="Li">&quot;DESTROY&quot;</span> method and use that instead
    of the one provided by Moose::Object. You can do this to preserve
    <span class="Li">$@</span> <i>and</i> capture any errors from object
    destruction by creating an error stack.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Stevan Little &lt;stevan.little@iinteractive.com&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
  <li>Shawn M Moore &lt;code@sartak.org&gt;</li>
  <li>&#x05D9;&#x05D5;&#x05D1;&#x05DC; &#x05E7;&#x05D5;&#x05D2;'&#x05DE;&#x05DF;
      (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Florian Ragwitz &lt;rafl@debian.org&gt;</li>
  <li>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</li>
  <li>Chris Prather &lt;chris@prather.org&gt;</li>
  <li>Matt S Trout &lt;mst@shadowcat.co.uk&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2006 by Infinity Interactive,
  Inc.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-11-22</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

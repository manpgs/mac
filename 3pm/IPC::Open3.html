<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>IPC::Open3(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">IPC::Open3(3pm)</td>
    <td class="head-vol"><a href=".">Perl Programmers Reference Guide</a></td>
    <td class="head-rtitle">IPC::Open3(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">IPC::Open3 - open a process for reading, writing, and error
    handling using open3()</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use Symbol 'gensym'; # vivify a separate handle for STDERR
    my $pid = open3(my $chld_in, my $chld_out, my $chld_err = gensym,
                    'some', 'cmd', 'and', 'args');
    # or pass the command through the shell
    my $pid = open3(my $chld_in, my $chld_out, my $chld_err = gensym,
                    'some cmd and args');
    # read from parent STDIN
    # send STDOUT and STDERR to already open handle
    open my $outfile, '&gt;&gt;', 'output.txt' or die &quot;open failed: $!&quot;;
    my $pid = open3('&lt;&amp;STDIN', $outfile, undef,
                    'some', 'cmd', 'and', 'args');
    # write to parent STDOUT and STDERR
    my $pid = open3(my $chld_in, '&gt;&amp;STDOUT', '&gt;&amp;STDERR',
                    'some', 'cmd', 'and', 'args');
    # reap zombie and retrieve exit status
    waitpid( $pid, 0 );
    my $child_exit_status = $? &gt;&gt; 8;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Extremely similar to <b>open2()</b>, <b>open3()</b> spawns the
    given command and connects <span class="Li">$chld_out</span> for reading
    from the child, <span class="Li">$chld_in</span> for writing to the child,
    and <span class="Li">$chld_err</span> for errors. If
    <span class="Li">$chld_err</span> is false, or the same file descriptor as
    <span class="Li">$chld_out</span>, then STDOUT and STDERR of the child are
    on the same filehandle. This means that an autovivified lexical cannot be
    used for the STDERR filehandle, but gensym from Symbol can be used to vivify
    a new glob reference, see &quot;SYNOPSIS&quot;. The
    <span class="Li">$chld_in</span> will have autoflush turned on.</p>
<p class="Pp">If <span class="Li">$chld_in</span> begins with
    <span class="Li">&quot;&lt;&amp;&quot;</span>, then
    <span class="Li">$chld_in</span> will be closed in the parent, and the child
    will read from it directly. If <span class="Li">$chld_out</span> or
    <span class="Li">$chld_err</span> begins with
    <span class="Li">&quot;&gt;&amp;&quot;</span>, then the child will send
    output directly to that filehandle. In both cases, there will be a
    <b>dup</b>(2) instead of a <b>pipe</b>(2) made.</p>
<p class="Pp">If either reader or writer is the empty string or undefined, this
    will be replaced by an autogenerated filehandle. If so, you must pass a
    valid lvalue in the parameter slot so it can be overwritten in the caller,
    or an exception will be raised.</p>
<p class="Pp">The filehandles may also be integers, in which case they are
    understood as file descriptors.</p>
<p class="Pp"><b>open3()</b> returns the process ID of the child process. It
    doesn't return on failure: it just raises an exception matching
    <span class="Li">&quot;/^open3:/&quot;</span>. However,
    <span class="Li">&quot;exec&quot;</span> failures in the child (such as no
    such file or permission denied), are just reported to
    <span class="Li">$chld_err</span> under Windows and OS/2, as it is not
    possible to trap them.</p>
<p class="Pp">If the child process dies for any reason, the next write to
    <span class="Li">$chld_in</span> is likely to generate a SIGPIPE in the
    parent, which is fatal by default. So you may wish to handle this
  signal.</p>
<p class="Pp">Note if you specify <span class="Li">&quot;-&quot;</span> as the
    command, in an analogous fashion to <span class="Li">&quot;open(my $fh,
    &quot;-|&quot;)&quot;</span> the child process will just be the forked Perl
    process rather than an external command. This feature isn't yet supported on
    Win32 platforms.</p>
<p class="Pp"><b>open3()</b> does not wait for and reap the child process after
    it exits. Except for short programs where it's acceptable to let the
    operating system take care of this, you need to do this yourself. This is
    normally as simple as calling <span class="Li">&quot;waitpid $pid,
    0&quot;</span> when you're done with the process. Failing to do this can
    result in an accumulation of defunct or &quot;zombie&quot; processes. See
    &quot;waitpid&quot; in perlfunc for more information.</p>
<p class="Pp">If you try to read from the child's stdout writer and their stderr
    writer, you'll have problems with blocking, which means you'll want to use
    <b>select()</b> or IO::Select, which means you'd best use <b>sysread()</b>
    instead of <b>readline()</b> for normal stuff.</p>
<p class="Pp">This is very dangerous, as you may block forever. It assumes it's
    going to talk to something like <b>bc</b>(1), both writing to it and reading
    from it. This is presumably safe because you &quot;know&quot; that commands
    like <b>bc</b>(1) will read a line at a time and output a line at a time.
    Programs like <b>sort</b>(1) that read their entire input stream first,
    however, are quite apt to cause deadlock.</p>
<p class="Pp">The big problem with this approach is that if you don't have
    control over source code being run in the child process, you can't control
    what it does with pipe buffering. Thus you can't just open a pipe to
    <span class="Li">&quot;cat -v&quot;</span> and continually read and write a
    line from it.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="See_Also"><a class="permalink" href="#See_Also">See
  Also</a></h1>
<dl class="Bl-tag">
  <dt id="IPC::Open2"><a class="permalink" href="#IPC::Open2">IPC::Open2</a></dt>
  <dd>Like Open3 but without STDERR capture.</dd>
  <dt id="IPC::Run"><a class="permalink" href="#IPC::Run">IPC::Run</a></dt>
  <dd>This is a CPAN module that has better error handling and more facilities
      than Open3.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="WARNING"><a class="permalink" href="#WARNING">WARNING</a></h1>
<p class="Pp">The order of arguments differs from that of <b>open2()</b>.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os"><a href="..">perl v5.34.1</a></td>
  </tr>
</table>
</body>
</html>

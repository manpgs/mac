<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>DBI::DBD(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBI::DBD(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBI::DBD(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">DBI::DBD - Perl DBI Database Driver Writer's Guide</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  perldoc DBI::DBD
</pre>
<section class="Ss">
<h2 class="Ss" id="Version_and_volatility"><a class="permalink" href="#Version_and_volatility">Version
  and volatility</a></h2>
<p class="Pp">This document is <i>still</i> a minimal draft which is in need of
    further work.</p>
<p class="Pp">Please read the <b>DBI</b> documentation first and fully. Then
    look at the implementation of some high-profile and regularly maintained
    drivers like DBD::Oracle, DBD::ODBC, DBD::Pg etc. (Those are no no
    particular order.)</p>
<p class="Pp">Then reread the <b>DBI</b> specification and the code of those
    drivers again as you're reading this. It'll help. Where this document and
    the driver code differ it's likely that the driver code is more correct,
    especially if multiple drivers do the same thing.</p>
<p class="Pp">This document is a patchwork of contributions from various
    authors. More contributions (preferably as patches) are very welcome.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This document is primarily intended to help people writing new
    database drivers for the Perl Database Interface (Perl DBI). It may also
    help others interested in discovering why the internals of a <b>DBD</b>
    driver are written the way they are.</p>
<p class="Pp">This is a guide. Few (if any) of the statements in it are
    completely authoritative under all possible circumstances. This means you
    will need to use judgement in applying the guidelines in this document. If
    in <i>any</i> doubt at all, please do contact the <i>dbi-dev</i> mailing
    list (details given below) where Tim Bunce and other driver authors can
    help.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CREATING_A_NEW_DRIVER"><a class="permalink" href="#CREATING_A_NEW_DRIVER">CREATING
  A NEW DRIVER</a></h1>
<p class="Pp">The first rule for creating a new database driver for the Perl DBI
    is very simple: <b>DON'T!</b></p>
<p class="Pp">There is usually a driver already available for the database you
    want to use, almost regardless of which database you choose. Very often, the
    database will provide an ODBC driver interface, so you can often use
    <b>DBD::ODBC</b> to access the database. This is typically less convenient
    on a Unix box than on a Microsoft Windows box, but there are numerous
    options for ODBC driver managers on Unix too, and very often the ODBC driver
    is provided by the database supplier.</p>
<p class="Pp">Before deciding that you need to write a driver, do your homework
    to ensure that you are not wasting your energies.</p>
<p class="Pp">[As of December 2002, the consensus is that if you need an ODBC
    driver manager on Unix, then the unixODBC driver (available from
    &lt;http://www.unixodbc.org/&gt;) is the way to go.]</p>
<p class="Pp">The second rule for creating a new database driver for the Perl
    DBI is also very simple: <b>Don't -- get someone else to do it for
  you!</b></p>
<p class="Pp">Nevertheless, there are occasions when it is necessary to write a
    new driver, often to use a proprietary language or API to access the
    database more swiftly, or more comprehensively, than an ODBC driver can.
    Then you should read this document very carefully, but with a suitably
    sceptical eye.</p>
<p class="Pp">If there is something in here that does not make any sense,
    question it. You might be right that the information is bogus, but don't
    come to that conclusion too quickly.</p>
<section class="Ss">
<h2 class="Ss" id="URLs_and_mailing_lists"><a class="permalink" href="#URLs_and_mailing_lists">URLs
  and mailing lists</a></h2>
<p class="Pp">The primary web-site for locating <b>DBI</b> software and
    information is</p>
<p class="Pp"></p>
<pre>  http://dbi.perl.org/
</pre>
<p class="Pp">There are two main and one auxiliary mailing lists for people
    working with <b>DBI</b>. The primary lists are <i>dbi-users@perl.org</i> for
    general users of <b>DBI</b> and <b>DBD</b> drivers, and
    <i>dbi-dev@perl.org</i> mainly for <b>DBD</b> driver writers (don't join the
    <i>dbi-dev</i> list unless you have a good reason). The auxiliary list is
    <i>dbi-announce@perl.org</i> for announcing new releases of <b>DBI</b> or
    <b>DBD</b> drivers.</p>
<p class="Pp">You can join these lists by accessing the web-site
    &lt;http://dbi.perl.org/&gt;. The lists are closed so you cannot send email
    to any of the lists unless you join the list first.</p>
<p class="Pp">You should also consider monitoring the <i>comp.lang.perl.*</i>
    newsgroups, especially <i>comp.lang.perl.modules</i>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Cheetah_book"><a class="permalink" href="#The_Cheetah_book">The
  Cheetah book</a></h2>
<p class="Pp">The definitive book on Perl DBI is the Cheetah book, so called
    because of the picture on the cover. Its proper title is '<i>Programming
    the</i> <i>Perl DBI: Database programming with Perl</i>' by Alligator
    Descartes and Tim Bunce, published by O'Reilly Associates, February 2000,
    ISBN 1-56592-699-4. Buy it now if you have not already done so, and read
  it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Locating_drivers"><a class="permalink" href="#Locating_drivers">Locating
  drivers</a></h2>
<p class="Pp">Before writing a new driver, it is in your interests to find out
    whether there already is a driver for your database. If there is such a
    driver, it would be much easier to make use of it than to write your
  own!</p>
<p class="Pp">The primary web-site for locating Perl software is
    &lt;http://search.cpan.org/&gt;. You should look under the various modules
    listings for the software you are after. For example:</p>
<p class="Pp"></p>
<pre>  http://search.cpan.org/modlist/Database_Interfaces
</pre>
<p class="Pp">Follow the <b>DBD::</b> and <b>DBIx::</b> links at the top to see
    those subsets.</p>
<p class="Pp">See the <b>DBI</b> docs for information on <b>DBI</b> web sites
    and mailing lists.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Registering_a_new_driver"><a class="permalink" href="#Registering_a_new_driver">Registering
  a new driver</a></h2>
<p class="Pp">Before going through any official registration process, you will
    need to establish that there is no driver already in the works. You'll do
    that by asking the <b>DBI</b> mailing lists whether there is such a driver
    available, or whether anybody is working on one.</p>
<p class="Pp">When you get the go ahead, you will need to establish the name of
    the driver and a prefix for the driver. Typically, the name is based on the
    name of the database software it uses, and the prefix is a contraction of
    that. Hence, <b>DBD::Oracle</b> has the name <i>Oracle</i> and the prefix
    '<i>ora_</i>'. The prefix must be lowercase and contain no underscores other
    than the one at the end.</p>
<p class="Pp">This information will be recorded in the <b>DBI</b> module. Apart
    from documentation purposes, registration is a prerequisite for installing
    private methods.</p>
<p class="Pp">If you are writing a driver which will not be distributed on CPAN,
    then you should choose a prefix beginning with '<i>x_</i>', to avoid
    potential prefix collisions with drivers registered in the future. Thus, if
    you wrote a non-CPAN distributed driver called <b>DBD::CustomDB</b>, the
    prefix might be '<i>x_cdb_</i>'.</p>
<p class="Pp">This document assumes you are writing a driver called
    <b>DBD::Driver</b>, and that the prefix '<i>drv_</i>' is assigned to the
    driver.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Two_styles_of_database_driver"><a class="permalink" href="#Two_styles_of_database_driver">Two
  styles of database driver</a></h2>
<p class="Pp">There are two distinct styles of database driver that can be
    written to work with the Perl DBI.</p>
<p class="Pp">Your driver can be written in pure Perl, requiring no C compiler.
    When feasible, this is the best solution, but most databases are not written
    in such a way that this can be done. Some examples of pure Perl drivers are
    <b>DBD::File</b> and <b>DBD::CSV</b>.</p>
<p class="Pp">Alternatively, and most commonly, your driver will need to use
    some C code to gain access to the database. This will be classified as a
    C/XS driver.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="What_code_will_you_write?"><a class="permalink" href="#What_code_will_you_write?">What
  code will you write?</a></h2>
<p class="Pp">There are a number of files that need to be written for either a
    pure Perl driver or a C/XS driver. There are no extra files needed only by a
    pure Perl driver, but there are several extra files needed only by a C/XS
    driver.</p>
<p class="Pp"><i>Files common to pure Perl and C/XS drivers</i></p>
<p class="Pp">Assuming that your driver is called <b>DBD::Driver</b>, these
    files are:</p>
<ul class="Bl-bullet">
  <li><i>Makefile.PL</i></li>
  <li><i>META.yml</i></li>
  <li><i>README</i></li>
  <li><i>MANIFEST</i></li>
  <li><i>Driver.pm</i></li>
  <li><i>lib/Bundle/DBD/Driver.pm</i></li>
  <li><i>lib/DBD/Driver/Summary.pm</i></li>
  <li><i>t/*.t</i></li>
</ul>
<p class="Pp">The first four files are mandatory. <i>Makefile.PL</i> is used to
    control how the driver is built and installed. The <i>README</i> file tells
    people who download the file about how to build the module and any
    prerequisite software that must be installed. The <i>MANIFEST</i> file is
    used by the standard Perl module distribution mechanism. It lists all the
    source files that need to be distributed with your module. <i>Driver.pm</i>
    is what is loaded by the <b>DBI</b> code; it contains the methods peculiar
    to your driver.</p>
<p class="Pp">Although the <i>META.yml</i> file is not <b>required</b> you are
    advised to create one. Of particular importance are the
    <i>build_requires</i> and <i>configure_requires</i> attributes which newer
    CPAN modules understand. You use these to tell the CPAN module (and
    CPANPLUS) that your build and configure mechanisms require DBI. The best
    reference for META.yml (at the time of writing) is
    &lt;http://module-build.sourceforge.net/META-spec-v1.4.html&gt;. You can
    find a reasonable example of a <i>META.yml</i> in DBD::ODBC.</p>
<p class="Pp">The <i>lib/Bundle/DBD/Driver.pm</i> file allows you to specify
    other Perl modules on which yours depends in a format that allows someone to
    type a simple command and ensure that all the pre-requisites are in place as
    well as building your driver.</p>
<p class="Pp">The <i>lib/DBD/Driver/Summary.pm</i> file contains (an updated
    version of) the information that was included - or that would have been
    included - in the appendices of the Cheetah book as a summary of the
    abilities of your driver and the associated database.</p>
<p class="Pp">The files in the <i>t</i> subdirectory are unit tests for your
    driver. You should write your tests as stringently as possible, while taking
    into account the diversity of installations that you can encounter:</p>
<ul class="Bl-bullet">
  <li>Your tests should not casually modify operational databases.</li>
  <li>You should never damage existing tables in a database.</li>
  <li>You should code your tests to use a constrained name space within the
      database. For example, the tables (and all other named objects) that are
      created could all begin with '<i>dbd_drv_</i>'.</li>
  <li>At the end of a test run, there should be no testing objects left behind
      in the database.</li>
  <li>If you create any databases, you should remove them.</li>
  <li>If your database supports temporary tables that are automatically removed
      at the end of a session, then exploit them as often as possible.</li>
  <li>Try to make your tests independent of each other. If you have a test
      <i>t/t11dowhat.t</i> that depends upon the successful running of
      <i>t/t10thingamy.t</i>, people cannot run the single test case
      <i>t/t11dowhat.t</i>. Further, running <i>t/t11dowhat.t</i> twice in a row
      is likely to fail (at least, if <i>t/t11dowhat.t</i> modifies the database
      at all) because the database at the start of the second run is not what
      you saw at the start of the first run.</li>
  <li>Document in your <i>README</i> file what you do, and what privileges
      people need to do it.</li>
  <li>You can, and probably should, sequence your tests by including a test
      number before an abbreviated version of the test name; the tests are run
      in the order in which the names are expanded by shell-style globbing.</li>
  <li>It is in your interests to ensure that your tests work as widely as
      possible.</li>
</ul>
<p class="Pp">Many drivers also install sub-modules
    <b>DBD::Driver::SubModule</b> for any of a variety of different reasons,
    such as to support the metadata methods (see the discussion of
    &quot;METADATA METHODS&quot; below). Such sub-modules are conventionally
    stored in the directory <i>lib/DBD/Driver</i>. The module itself would
    usually be in a file <i>SubModule.pm</i>. All such sub-modules should
    themselves be version stamped (see the discussions far below).</p>
<p class="Pp"><i>Extra files needed by C/XS drivers</i></p>
<p class="Pp">The software for a C/XS driver will typically contain at least
    four extra files that are not relevant to a pure Perl driver.</p>
<ul class="Bl-bullet">
  <li><i>Driver.xs</i></li>
  <li><i>Driver.h</i></li>
  <li><i>dbdimp.h</i></li>
  <li><i>dbdimp.c</i></li>
</ul>
<p class="Pp">The <i>Driver.xs</i> file is used to generate C code that Perl can
    call to gain access to the C functions you write that will, in turn, call
    down onto your database software.</p>
<p class="Pp">The <i>Driver.h</i> header is a stylized header that ensures you
    can access the necessary Perl and <b>DBI</b> macros, types, and function
    declarations.</p>
<p class="Pp">The <i>dbdimp.h</i> is used to specify which functions have been
    implemented by your driver.</p>
<p class="Pp">The <i>dbdimp.c</i> file is where you write the C code that does
    the real work of translating between Perl-ish data types and what the
    database expects to use and return.</p>
<p class="Pp">There are some (mainly small, but very important) differences
    between the contents of <i>Makefile.PL</i> and <i>Driver.pm</i> for pure
    Perl and C/XS drivers, so those files are described both in the section on
    creating a pure Perl driver and in the section on creating a C/XS
  driver.</p>
<p class="Pp">Obviously, you can add extra source code files to the list.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Requirements_on_a_driver_and_driver_writer"><a class="permalink" href="#Requirements_on_a_driver_and_driver_writer">Requirements
  on a driver and driver writer</a></h2>
<p class="Pp">To be remotely useful, your driver must be implemented in a format
    that allows it to be distributed via CPAN, the Comprehensive Perl Archive
    Network (&lt;http://www.cpan.org/&gt; and &lt;http://search.cpan.org&gt;).
    Of course, it is easier if you do not have to meet this criterion, but you
    will not be able to ask for much help if you do not do so, and no-one is
    likely to want to install your module if they have to learn a new
    installation mechanism.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CREATING_A_PURE_PERL_DRIVER"><a class="permalink" href="#CREATING_A_PURE_PERL_DRIVER">CREATING
  A PURE PERL DRIVER</a></h1>
<p class="Pp">Writing a pure Perl driver is surprisingly simple. However, there
    are some problems you should be aware of. The best option is of course
    picking up an existing driver and carefully modifying one method after the
    other.</p>
<p class="Pp">Also look carefully at <b>DBD::AnyData</b> and
    <b>DBD::Template</b>.</p>
<p class="Pp">As an example we take a look at the <b>DBD::File</b> driver, a
    driver for accessing plain files as tables, which is part of the
    <b>DBD::CSV</b> package.</p>
<p class="Pp">The minimal set of files we have to implement are
    <i>Makefile.PL</i>, <i>README</i>, <i>MANIFEST</i> and <i>Driver.pm</i>.</p>
<section class="Ss">
<h2 class="Ss" id="Pure_Perl_version_of_Makefile.PL"><a class="permalink" href="#Pure_Perl_version_of_Makefile.PL">Pure
  Perl version of Makefile.PL</a></h2>
<p class="Pp">You typically start with writing <i>Makefile.PL</i>, a Makefile
    generator. The contents of this file are described in detail in the
    ExtUtils::MakeMaker man pages. It is definitely a good idea if you start
    reading them. At least you should know about the variables <i>CONFIGURE</i>,
    <i>DEFINED</i>, <i>PM</i>, <i>DIR</i>, <i>EXE_FILES</i>, <i>INC</i>,
    <i>LIBS</i>, <i>LINKTYPE</i>, <i>NAME</i>, <i>OPTIMIZE</i>, <i>PL_FILES</i>,
    <i>VERSION</i>, <i>VERSION_FROM</i>, <i>clean</i>, <i>depend</i>,
    <i>realclean</i> from the ExtUtils::MakeMaker man page: these are used in
    almost any <i>Makefile.PL</i>.</p>
<p class="Pp">Additionally read the section on <i>Overriding MakeMaker
    Methods</i> and the descriptions of the <i>distcheck</i>, <i>disttest</i>
    and <i>dist</i> targets: They will definitely be useful for you.</p>
<p class="Pp">Of special importance for <b>DBI</b> drivers is the
    <i>postamble</i> method from the ExtUtils::MM_Unix man page.</p>
<p class="Pp">For Emacs users, I recommend the <i>libscan</i> method, which
    removes Emacs backup files (file names which end with a tilde '~') from
    lists of files.</p>
<p class="Pp">Now an example, I use the word
    <span class="Li">&quot;Driver&quot;</span> wherever you should insert your
    driver's name:</p>
<p class="Pp"></p>
<pre>  # -*- perl -*-
  use ExtUtils::MakeMaker;
  WriteMakefile(
      dbd_edit_mm_attribs( {
          'NAME'         =&gt; 'DBD::Driver',
          'VERSION_FROM' =&gt; 'Driver.pm',
          'INC'          =&gt; '',
          'dist'         =&gt; { 'SUFFIX'   =&gt; '.gz',
                              'COMPRESS' =&gt; 'gzip -9f' },
          'realclean'    =&gt; { FILES =&gt; '*.xsi' },
          'PREREQ_PM'    =&gt; '1.03',
          'CONFIGURE'    =&gt; sub {
              eval {require DBI::DBD;};
              if ($@) {
                  warn $@;
                  exit 0;
              }
              my $dbi_arch_dir = dbd_dbi_arch_dir();
              if (exists($opts{INC})) {
                  return {INC =&gt; &quot;$opts{INC} -I$dbi_arch_dir&quot;};
              } else {
                  return {INC =&gt; &quot;-I$dbi_arch_dir&quot;};
              }
          }
      },
      { create_pp_tests =&gt; 1})
  );
  package MY;
  sub postamble { return main::dbd_postamble(@_); }
  sub libscan {
      my ($self, $path) = @_;
      ($path =~ m/\~$/) ? undef : $path;
  }
</pre>
<p class="Pp">Note the calls to
    <span class="Li">&quot;dbd_edit_mm_attribs()&quot;</span> and
    <span class="Li">&quot;dbd_postamble()&quot;</span>.</p>
<p class="Pp">The second hash reference in the call to
    <span class="Li">&quot;dbd_edit_mm_attribs()&quot;</span> (containing
    <span class="Li">&quot;create_pp_tests()&quot;</span>) is optional; you
    should not use it unless your driver is a pure Perl driver (that is, it does
    not use C and XS code). Therefore, the call to
    <span class="Li">&quot;dbd_edit_mm_attribs()&quot;</span> is not relevant
    for C/XS drivers and may be omitted; simply use the (single) hash reference
    containing NAME etc as the only argument to
    <span class="Li">&quot;WriteMakefile()&quot;</span>.</p>
<p class="Pp">Note that the
    <span class="Li">&quot;dbd_edit_mm_attribs()&quot;</span> code will fail if
    you do not have a <i>t</i> sub-directory containing at least one test
  case.</p>
<p class="Pp"><i>PREREQ_PM</i> tells MakeMaker that DBI (version 1.03 in this
    case) is required for this module. This will issue a warning that DBI 1.03
    is missing if someone attempts to install your DBD without DBI 1.03. See
    <i>CONFIGURE</i> below for why this does not work reliably in stopping cpan
    testers failing your module if DBI is not installed.</p>
<p class="Pp"><i>CONFIGURE</i> is a subroutine called by MakeMaker during
    <span class="Li">&quot;WriteMakefile&quot;</span>. By putting the
    <span class="Li">&quot;require DBI::DBD&quot;</span> in this section we can
    attempt to load DBI::DBD but if it is missing we exit with success. As we
    exit successfully without creating a Makefile when DBI::DBD is missing cpan
    testers will not report a failure. This may seem at odds with
    <i>PREREQ_PM</i> but <i>PREREQ_PM</i> does not cause
    <span class="Li">&quot;WriteMakefile&quot;</span> to fail (unless you also
    specify PREREQ_FATAL which is strongly discouraged by MakeMaker) so
    <span class="Li">&quot;WriteMakefile&quot;</span> would continue to call
    <span class="Li">&quot;dbd_dbi_arch_dir&quot;</span> and fail.</p>
<p class="Pp">All drivers must use
    <span class="Li">&quot;dbd_postamble()&quot;</span> or risk running into
    problems.</p>
<p class="Pp">Note the specification of <i>VERSION_FROM</i>; the named file
    (<i>Driver.pm</i>) will be scanned for the first line that looks like an
    assignment to <i></i><span class="Li"><i>$VERSION</i></span><i></i>, and the
    subsequent text will be used to determine the version number. Note the
    commentary in ExtUtils::MakeMaker on the subject of correctly formatted
    version numbers.</p>
<p class="Pp">If your driver depends upon external software (it usually will),
    you will need to add code to ensure that your environment is workable before
    the call to <span class="Li">&quot;WriteMakefile()&quot;</span>. If you need
    to check for the existence of an external library and perhaps modify
    <i>INC</i> to include the paths to where the external library header files
    are located and you cannot find the library or header files make sure you
    output a message saying they cannot be found but <span class="Li">&quot;exit
    0&quot;</span> (success) <b>before</b> calling
    <span class="Li">&quot;WriteMakefile&quot;</span> or CPAN testers will fail
    your module if the external library is not found.</p>
<p class="Pp">A full-fledged <i>Makefile.PL</i> can be quite large (for example,
    the files for <b>DBD::Oracle</b> and <b>DBD::Informix</b> are both over 1000
    lines long, and the Informix one uses - and creates - auxiliary modules
    too).</p>
<p class="Pp">See also ExtUtils::MakeMaker and ExtUtils::MM_Unix. Consider using
    CPAN::MakeMaker in place of <i>ExtUtils::MakeMaker</i>.</p>
</section>
<section class="Ss">
<h2 class="Ss">README</h2>
<p class="Pp">The README file should describe what the driver is for, the
    pre-requisites for the build process, the actual build process, how to
    report errors, and who to report them to.</p>
<p class="Pp">Users will find ways of breaking the driver build and test process
    which you would never even have dreamed to be possible in your worst
    nightmares. Therefore, you need to write this document defensively,
    precisely and concisely.</p>
<p class="Pp">As always, use the <i>README</i> from one of the established
    drivers as a basis for your own; the version in <b>DBD::Informix</b> is
    worth a look as it has been quite successful in heading off problems.</p>
<ul class="Bl-bullet">
  <li>Note that users will have versions of Perl and <b>DBI</b> that are both
      older and newer than you expected, but this will seldom cause much
      trouble. When it does, it will be because you are using features of
      <b>DBI</b> that are not supported in the version they are using.</li>
  <li>Note that users will have versions of the database software that are both
      older and newer than you expected. You will save yourself time in the long
      run if you can identify the range of versions which have been tested and
      warn about versions which are not known to be OK.</li>
  <li>Note that many people trying to install your driver will not be experts in
      the database software.</li>
  <li>Note that many people trying to install your driver will not be experts in
      C or Perl.</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss">MANIFEST</h2>
<p class="Pp">The <i>MANIFEST</i> will be used by the Makefile's dist target to
    build the distribution tar file that is uploaded to CPAN. It should list
    every file that you want to include in your distribution, one per line.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="lib/Bundle/DBD/Driver.pm"><a class="permalink" href="#lib/Bundle/DBD/Driver.pm">lib/Bundle/DBD/Driver.pm</a></h2>
<p class="Pp">The CPAN module provides an extremely powerful bundle mechanism
    that allows you to specify pre-requisites for your driver.</p>
<p class="Pp">The primary pre-requisite is <b>Bundle::DBI</b>; you may want or
    need to add some more. With the bundle set up correctly, the user can
  type:</p>
<p class="Pp"></p>
<pre>        perl -MCPAN -e 'install Bundle::DBD::Driver'
</pre>
<p class="Pp">and Perl will download, compile, test and install all the Perl
    modules needed to build your driver.</p>
<p class="Pp">The prerequisite modules are listed in the
    <span class="Li">&quot;CONTENTS&quot;</span> section, with the official name
    of the module followed by a dash and an informal name or description.</p>
<ul class="Bl-bullet">
  <li>Listing <b>Bundle::DBI</b> as the main pre-requisite simplifies life.</li>
  <li>Don't forget to list your driver.</li>
  <li>Note that unless the DBMS is itself a Perl module, you cannot list it as a
      pre-requisite in this file.</li>
  <li>You should keep the version of the bundle the same as the version of your
      driver.</li>
  <li>You should add configuration management, copyright, and licencing
      information at the top.</li>
</ul>
<p class="Pp">A suitable skeleton for this file is shown below.</p>
<p class="Pp"></p>
<pre>  package Bundle::DBD::Driver;
  $VERSION = '0.01';
  1;
  __END__
  =head1 NAME
  Bundle::DBD::Driver - A bundle to install all DBD::Driver related modules
  =head1 SYNOPSIS
  C&lt;perl -MCPAN -e 'install Bundle::DBD::Driver'&gt;
  =head1 CONTENTS
  Bundle::DBI  - Bundle for DBI by TIMB (Tim Bunce)
  DBD::Driver  - DBD::Driver by YOU (Your Name)
  =head1 DESCRIPTION
  This bundle includes all the modules used by the Perl Database
  Interface (DBI) driver for Driver (DBD::Driver), assuming the
  use of DBI version 1.13 or later, created by Tim Bunce.
  If you've not previously used the CPAN module to install any
  bundles, you will be interrogated during its setup phase.
  But when you've done it once, it remembers what you told it.
  You could start by running:
    C&lt;perl -MCPAN -e 'install Bundle::CPAN'&gt;
  =head1 SEE ALSO
  Bundle::DBI
  =head1 AUTHOR
  Your Name E&lt;lt&gt;F&lt;you@yourdomain.com&gt;E&lt;gt&gt;
  =head1 THANKS
  This bundle was created by ripping off Bundle::libnet created by
  Graham Barr E&lt;lt&gt;F&lt;gbarr@ti.com&gt;E&lt;gt&gt;, and radically simplified
  with some information from Jochen Wiedmann E&lt;lt&gt;F&lt;joe@ispsoft.de&gt;E&lt;gt&gt;.
  The template was then included in the DBI::DBD documentation by
  Jonathan Leffler E&lt;lt&gt;F&lt;jleffler@informix.com&gt;E&lt;gt&gt;.
  =cut
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="lib/DBD/Driver/Summary.pm"><a class="permalink" href="#lib/DBD/Driver/Summary.pm">lib/DBD/Driver/Summary.pm</a></h2>
<p class="Pp">There is no substitute for taking the summary file from a driver
    that was documented in the Perl book (such as <b>DBD::Oracle</b> or
    <b>DBD::Informix</b> or <b>DBD::ODBC</b>, to name but three), and adapting
    it to describe the facilities available via <b>DBD::Driver</b> when
    accessing the Driver database.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Pure_Perl_version_of_Driver.pm"><a class="permalink" href="#Pure_Perl_version_of_Driver.pm">Pure
  Perl version of Driver.pm</a></h2>
<p class="Pp">The <i>Driver.pm</i> file defines the Perl module
    <b>DBD::Driver</b> for your driver. It will define a package
    <b>DBD::Driver</b> along with some version information, some variable
    definitions, and a function <span class="Li">&quot;driver()&quot;</span>
    which will have a more or less standard structure.</p>
<p class="Pp">It will also define three sub-packages of <b>DBD::Driver</b>:</p>
<dl class="Bl-tag">
  <dt id="DBD::Driver::dr"><a class="permalink" href="#DBD::Driver::dr">DBD::Driver::dr</a></dt>
  <dd>with methods <span class="Li">&quot;connect()&quot;</span>,
      <span class="Li">&quot;data_sources()&quot;</span> and
      <span class="Li">&quot;disconnect_all()&quot;</span>;</dd>
  <dt id="DBD::Driver::db"><a class="permalink" href="#DBD::Driver::db">DBD::Driver::db</a></dt>
  <dd>with methods such as <span class="Li">&quot;prepare()&quot;</span>;</dd>
  <dt id="DBD::Driver::st"><a class="permalink" href="#DBD::Driver::st">DBD::Driver::st</a></dt>
  <dd>with methods such as <span class="Li">&quot;execute()&quot;</span> and
      <span class="Li">&quot;fetch()&quot;</span>.</dd>
</dl>
<p class="Pp">The <i>Driver.pm</i> file will also contain the documentation
    specific to <b>DBD::Driver</b> in the format used by perldoc.</p>
<p class="Pp">In a pure Perl driver, the <i>Driver.pm</i> file is the core of
    the implementation. You will need to provide all the key methods needed by
    <b>DBI</b>.</p>
<p class="Pp">Now let's take a closer look at an excerpt of <i>File.pm</i> as an
    example. We ignore things that are common to any module (even non-DBI
    modules) or really specific to the <b>DBD::File</b> package.</p>
<p class="Pp"><i>The DBD::Driver package</i></p>
<p class="Pp">The header</p>
<p class="Pp"></p>
<pre>  package DBD::File;
  use strict;
  use vars qw($VERSION $drh);
  $VERSION = &quot;1.23.00&quot;  # Version number of DBD::File
</pre>
<p class="Pp">This is where the version number of your driver is specified, and
    is where <i>Makefile.PL</i> looks for this information. Please ensure that
    any other modules added with your driver are also version stamped so that
    CPAN does not get confused.</p>
<p class="Pp">It is recommended that you use a two-part (1.23) or three-part
    (1.23.45) version number. Also consider the CPAN system, which gets confused
    and considers version 1.10 to precede version 1.9, so that using a raw CVS,
    RCS or SCCS version number is probably not appropriate (despite being very
    common).</p>
<p class="Pp">For Subversion you could use:</p>
<p class="Pp"></p>
<pre>  $VERSION = &quot;12.012346&quot;;
</pre>
<p class="Pp">(use lots of leading zeros on the second portion so if you move
    the code to a shared repository like svn.perl.org the much larger revision
    numbers won't cause a problem, at least not for a few years). For RCS or CVS
    you can use:</p>
<p class="Pp"></p>
<pre>  $VERSION = &quot;11.22&quot;;
</pre>
<p class="Pp">which pads out the fractional part with leading zeros so all is
    well (so long as you don't go past x.99)</p>
<p class="Pp"></p>
<pre>  $drh = undef;         # holds driver handle once initialized
</pre>
<p class="Pp">This is where the driver handle will be stored, once created. Note
    that you may assume there is only one handle for your driver.</p>
<p class="Pp">The driver constructor</p>
<p class="Pp">The <span class="Li">&quot;driver()&quot;</span> method is the
    driver handle constructor. Note that the
    <span class="Li">&quot;driver()&quot;</span> method is in the
    <b>DBD::Driver</b> package, not in one of the sub-packages
    <b>DBD::Driver::dr</b>, <b>DBD::Driver::db</b>, or
  <b>DBD::Driver::db</b>.</p>
<p class="Pp"></p>
<pre>  sub driver
  {
      return $drh if $drh;      # already created - return same one
      my ($class, $attr) = @_;
      $class .= &quot;::dr&quot;;
      DBD::Driver::db-&gt;install_method('drv_example_dbh_method');
      DBD::Driver::st-&gt;install_method('drv_example_sth_method');
      # not a 'my' since we use it above to prevent multiple drivers
      $drh = DBI::_new_drh($class, {
              'Name'        =&gt; 'File',
              'Version'     =&gt; $VERSION,
              'Attribution' =&gt; 'DBD::File by Jochen Wiedmann',
          })
          or return undef;
      return $drh;
  }
</pre>
<p class="Pp">This is a reasonable example of how <b>DBI</b> implements its
    handles. There are three kinds: <b>driver handles</b> (typically stored in
    <i></i><span class="Li"><i>$drh</i></span><i></i>; from now on called
    <i>drh</i> or <i></i><span class="Li"><i>$drh</i></span><i></i>),
    <b>database handles</b> (from now on called <i>dbh</i> or
    <i></i><span class="Li"><i>$dbh</i></span><i></i>) and <b>statement
    handles</b> (from now on called <i>sth</i> or
    <i></i><span class="Li"><i>$sth</i></span><i></i>).</p>
<p class="Pp">The prototype of
    <span class="Li">&quot;DBI::_new_drh()&quot;</span> is</p>
<p class="Pp"></p>
<pre>  $drh = DBI::_new_drh($class, $public_attrs, $private_attrs);
</pre>
<p class="Pp">with the following arguments:</p>
<dl class="Bl-tag">
  <dt><i></i><span class="Li"><i>$class</i></span><i></i></dt>
  <dd>is typically the class for your driver, (for example,
      &quot;DBD::File::dr&quot;), passed as the first argument to the
      <span class="Li">&quot;driver()&quot;</span> method.</dd>
  <dt><i></i><span class="Li"><i>$public_attrs</i></span><i></i></dt>
  <dd>is a hash ref to attributes like <i>Name</i>, <i>Version</i>, and
      <i>Attribution</i>. These are processed and used by <b>DBI</b>. You had
      better not make any assumptions about them nor should you add private
      attributes here.</dd>
  <dt><i></i><span class="Li"><i>$private_attrs</i></span><i></i></dt>
  <dd>This is another (optional) hash ref with your private attributes.
      <b>DBI</b> will store them and otherwise leave them alone.</dd>
</dl>
<p class="Pp">The <span class="Li">&quot;DBI::_new_drh()&quot;</span> method and
    the <span class="Li">&quot;driver()&quot;</span> method both return
    <span class="Li">&quot;undef&quot;</span> for failure (in which case you
    must look at <i></i><span class="Li"><i>$DBI::err</i></span><i></i> and
    <i></i><span class="Li"><i>$DBI::errstr</i></span><i></i> for the failure
    information, because you have no driver handle to use).</p>
<p class="Pp">Using <b>install_method()</b> to expose driver-private methods</p>
<p class="Pp"></p>
<pre>    DBD::Foo::db-&gt;install_method($method_name, \%attr);
</pre>
<p class="Pp">Installs the driver-private method named by
    <span class="Li">$method_name</span> into the DBI method dispatcher so it
    can be called directly, avoiding the need to use the <b>func()</b>
  method.</p>
<p class="Pp">It is called as a static method on the driver class to which the
    method belongs. The method name must begin with the corresponding registered
    driver-private prefix. For example, for DBD::Oracle
    <span class="Li">$method_name</span> must being with
    '<span class="Li">&quot;ora_&quot;</span>', and for DBD::AnyData it must
    begin with '<span class="Li">&quot;ad_&quot;</span>'.</p>
<p class="Pp">The <span class="Li">&quot;\%attr&quot;</span> attributes can be
    used to provide fine control over how the DBI dispatcher handles the
    dispatching of the method. However it's undocumented at the moment. See the
    IMA_* #define's in DBI.xs and the O=&gt;0x000x values in the initialization
    of <span class="Li">%DBI::DBI_methods</span> in DBI.pm. (Volunteers to
    polish up and document the interface are very welcome to get in touch via
    dbi-dev@perl.org).</p>
<p class="Pp">Methods installed using install_method default to the standard
    error handling behaviour for DBI methods: clearing err and errstr before
    calling the method, and checking for errors to trigger RaiseError etc. on
    return. This differs from the default behaviour of <b>func()</b>.</p>
<p class="Pp">Note for driver authors: The DBD::Foo::xx-&gt;install_method call
    won't work until the class-hierarchy has been setup. Normally the DBI looks
    after that just after the driver is loaded. This means
    <b>install_method()</b> can't be called at the time the driver is loaded
    unless the class-hierarchy is set up first. The way to do that is to call
    the <b>setup_driver()</b> method:</p>
<p class="Pp"></p>
<pre>    DBI-&gt;setup_driver('DBD::Foo');
</pre>
<p class="Pp">before using <b>install_method()</b>.</p>
<p class="Pp">The CLONE special subroutine</p>
<p class="Pp">Also needed here, in the <b>DBD::Driver</b> package, is a
    <span class="Li">&quot;CLONE()&quot;</span> method that will be called by
    perl when an interpreter is cloned. All your
    <span class="Li">&quot;CLONE()&quot;</span> method needs to do, currently,
    is clear the cached <i></i><span class="Li"><i>$drh</i></span><i></i> so the
    new interpreter won't start using the cached
    <i></i><span class="Li"><i>$drh</i></span><i></i> from the old
  interpreter:</p>
<p class="Pp"></p>
<pre>  sub CLONE {
    undef $drh;
  }
</pre>
<p class="Pp">See
    &lt;http://search.cpan.org/dist/perl/pod/perlmod.pod#Making_your_module_threadsafe&gt;
    for details.</p>
<p class="Pp"><i>The DBD::Driver::dr package</i></p>
<p class="Pp">The next lines of code look as follows:</p>
<p class="Pp"></p>
<pre>  package DBD::Driver::dr; # ====== DRIVER ======
  $DBD::Driver::dr::imp_data_size = 0;
</pre>
<p class="Pp">Note that no <i></i><span class="Li"><i>@ISA</i></span><i></i> is
    needed here, or for the other <b>DBD::Driver::*</b> classes, because the
    <b>DBI</b> takes care of that for you when the driver is loaded.</p>
<p class="Pp"></p>
<pre> *FIX ME* Explain what the imp_data_size is, so that implementors aren't
 practicing cargo-cult programming.
</pre>
<p class="Pp">The database handle constructor</p>
<p class="Pp">The database handle constructor is the driver's (hence the changed
    namespace) <span class="Li">&quot;connect()&quot;</span> method:</p>
<p class="Pp"></p>
<pre>  sub connect
  {
      my ($drh, $dr_dsn, $user, $auth, $attr) = @_;
      # Some database specific verifications, default settings
      # and the like can go here. This should only include
      # syntax checks or similar stuff where it's legal to
      # 'die' in case of errors.
      # For example, many database packages requires specific
      # environment variables to be set; this could be where you
      # validate that they are set, or default them if they are not set.
      my $driver_prefix = &quot;drv_&quot;; # the assigned prefix for this driver
      # Process attributes from the DSN; we assume ODBC syntax
      # here, that is, the DSN looks like var1=val1;...;varN=valN
      foreach my $var ( split /;/, $dr_dsn ) {
          my ($attr_name, $attr_value) = split '=', $var, 2;
          return $drh-&gt;set_err($DBI::stderr, &quot;Can't parse DSN part '$var'&quot;)
              unless defined $attr_value;
          # add driver prefix to attribute name if it doesn't have it already
          $attr_name = $driver_prefix.$attr_name
              unless $attr_name =~ /^$driver_prefix/o;
          # Store attribute into %$attr, replacing any existing value.
          # The DBI will STORE() these into $dbh after we've connected
          $attr-&gt;{$attr_name} = $attr_value;
      }
      # Get the attributes we'll use to connect.
      # We use delete here because these no need to STORE them
      my $db = delete $attr-&gt;{drv_database} || delete $attr-&gt;{drv_db}
          or return $drh-&gt;set_err($DBI::stderr, &quot;No database name given in DSN '$dr_dsn'&quot;);
      my $host = delete $attr-&gt;{drv_host} || 'localhost';
      my $port = delete $attr-&gt;{drv_port} || 123456;
      # Assume you can attach to your database via drv_connect:
      my $connection = drv_connect($db, $host, $port, $user, $auth)
          or return $drh-&gt;set_err($DBI::stderr, &quot;Can't connect to $dr_dsn: ...&quot;);
      # create a 'blank' dbh (call superclass constructor)
      my ($outer, $dbh) = DBI::_new_dbh($drh, { Name =&gt; $dr_dsn });
      $dbh-&gt;STORE('Active', 1 );
      $dbh-&gt;{drv_connection} = $connection;
      return $outer;
  }
</pre>
<p class="Pp">This is mostly the same as in the <i>driver handle constructor</i>
    above. The arguments are described in DBI.</p>
<p class="Pp">The constructor
    <span class="Li">&quot;DBI::_new_dbh()&quot;</span> is called, returning a
    database handle. The constructor's prototype is:</p>
<p class="Pp"></p>
<pre>  ($outer, $inner) = DBI::_new_dbh($drh, $public_attr, $private_attr);
</pre>
<p class="Pp">with similar arguments to those in the <i>driver handle
    constructor</i>, except that the
    <i></i><span class="Li"><i>$class</i></span><i></i> is replaced by
    <i></i><span class="Li"><i>$drh</i></span><i></i>. The <i>Name</i> attribute
    is a standard <b>DBI</b> attribute (see &quot;Database Handle
    Attributes&quot; in DBI).</p>
<p class="Pp">In scalar context, only the outer handle is returned.</p>
<p class="Pp">Note the use of the <span class="Li">&quot;STORE()&quot;</span>
    method for setting the <i>dbh</i> attributes. That's because within the
    driver code, the handle object you have is the 'inner' handle of a tied
    hash, not the outer handle that the users of your driver have.</p>
<p class="Pp">Because you have the inner handle, tie magic doesn't get invoked
    when you get or set values in the hash. This is often very handy for speed
    when you want to get or set simple non-special driver-specific
  attributes.</p>
<p class="Pp">However, some attribute values, such as those handled by the
    <b>DBI</b> like <i>PrintError</i>, don't actually exist in the hash and must
    be read via <span class="Li">&quot;$h-&gt;FETCH($attrib)&quot;</span> and
    set via <span class="Li">&quot;$h-&gt;STORE($attrib, $value)&quot;</span>.
    If in any doubt, use these methods.</p>
<p class="Pp">The <b>data_sources()</b> method</p>
<p class="Pp">The <span class="Li">&quot;data_sources()&quot;</span> method must
    populate and return a list of valid data sources, prefixed with the
    &quot;<i>dbi:Driver</i>&quot; incantation that allows them to be used in the
    first argument of the <span class="Li">&quot;DBI-&gt;connect()&quot;</span>
    method. An example of this might be scanning the
    <i></i><span class="Li"><i>$HOME</i></span><i>/.odbcini</i> file on Unix for
    ODBC data sources (DSNs).</p>
<p class="Pp">As a trivial example, consider a fixed list of data sources:</p>
<p class="Pp"></p>
<pre>  sub data_sources
  {
      my($drh, $attr) = @_;
      my(@list) = ();
      # You need more sophisticated code than this to set @list...
      push @list, &quot;dbi:Driver:abc&quot;;
      push @list, &quot;dbi:Driver:def&quot;;
      push @list, &quot;dbi:Driver:ghi&quot;;
      # End of code to set @list
      return @list;
  }
</pre>
<p class="Pp">The <b>disconnect_all()</b> method</p>
<p class="Pp">If you need to release any resources when the driver is unloaded,
    you can provide a disconnect_all method.</p>
<p class="Pp">Other driver handle methods</p>
<p class="Pp">If you need any other driver handle methods, they can follow
  here.</p>
<p class="Pp">Error handling</p>
<p class="Pp">It is quite likely that something fails in the connect method.
    With <b>DBD::File</b> for example, you might catch an error when setting the
    current directory to something not existent by using the (driver-specific)
    <i>f_dir</i> attribute.</p>
<p class="Pp">To report an error, you use the
    <span class="Li">&quot;set_err()&quot;</span> method:</p>
<p class="Pp"></p>
<pre>  $h-&gt;set_err($err, $errmsg, $state);
</pre>
<p class="Pp">This will ensure that the error is recorded correctly and that
    <i>RaiseError</i> and <i>PrintError</i> etc are handled correctly.</p>
<p class="Pp">Typically you'll always use the method instance, aka your method's
    first argument.</p>
<p class="Pp">As <span class="Li">&quot;set_err()&quot;</span> always returns
    <span class="Li">&quot;undef&quot;</span> your error handling code can
    usually be simplified to something like this:</p>
<p class="Pp"></p>
<pre>  return $h-&gt;set_err($err, $errmsg, $state) if ...;
</pre>
<p class="Pp"><i>The DBD::Driver::db package</i></p>
<p class="Pp"></p>
<pre>  package DBD::Driver::db; # ====== DATABASE ======
  $DBD::Driver::db::imp_data_size = 0;
</pre>
<p class="Pp">The statement handle constructor</p>
<p class="Pp">There's nothing much new in the statement handle constructor,
    which is the <span class="Li">&quot;prepare()&quot;</span> method:</p>
<p class="Pp"></p>
<pre>  sub prepare
  {
      my ($dbh, $statement, @attribs) = @_;
      # create a 'blank' sth
      my ($outer, $sth) = DBI::_new_sth($dbh, { Statement =&gt; $statement });
      $sth-&gt;STORE('NUM_OF_PARAMS', ($statement =~ tr/?//));
      $sth-&gt;{drv_params} = [];
      return $outer;
  }
</pre>
<p class="Pp">This is still the same -- check the arguments and call the super
    class constructor <span class="Li">&quot;DBI::_new_sth()&quot;</span>.
    Again, in scalar context, only the outer handle is returned. The
    <i>Statement</i> attribute should be cached as shown.</p>
<p class="Pp">Note the prefix <i>drv_</i> in the attribute names: it is required
    that all your private attributes use a lowercase prefix unique to your
    driver. As mentioned earlier in this document, the <b>DBI</b> contains a
    registry of known driver prefixes and may one day warn about unknown
    attributes that don't have a registered prefix.</p>
<p class="Pp">Note that we parse the statement here in order to set the
    attribute <i>NUM_OF_PARAMS</i>. The technique illustrated is not very
    reliable; it can be confused by question marks appearing in quoted strings,
    delimited identifiers or in SQL comments that are part of the SQL statement.
    We could set <i>NUM_OF_PARAMS</i> in the
    <span class="Li">&quot;execute()&quot;</span> method instead because the
    <b>DBI</b> specification explicitly allows a driver to defer this, but then
    the user could not call
  <span class="Li">&quot;bind_param()&quot;</span>.</p>
<p class="Pp">Transaction handling</p>
<p class="Pp">Pure Perl drivers will rarely support transactions. Thus your
    <span class="Li">&quot;commit()&quot;</span> and
    <span class="Li">&quot;rollback()&quot;</span> methods will typically be
    quite simple:</p>
<p class="Pp"></p>
<pre>  sub commit
  {
      my ($dbh) = @_;
      if ($dbh-&gt;FETCH('Warn')) {
          warn(&quot;Commit ineffective while AutoCommit is on&quot;);
      }
      0;
  }
  sub rollback {
      my ($dbh) = @_;
      if ($dbh-&gt;FETCH('Warn')) {
          warn(&quot;Rollback ineffective while AutoCommit is on&quot;);
      }
      0;
  }
</pre>
<p class="Pp">Or even simpler, just use the default methods provided by the
    <b>DBI</b> that do nothing except return
    <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp">The <b>DBI</b>'s default
    <span class="Li">&quot;begin_work()&quot;</span> method can be used by
    inheritance.</p>
<p class="Pp">The <b>STORE()</b> and <b>FETCH()</b> methods</p>
<p class="Pp">These methods (that we have already used, see above) are called
    for you, whenever the user does a:</p>
<p class="Pp"></p>
<pre>  $dbh-&gt;{$attr} = $val;
</pre>
<p class="Pp">or, respectively,</p>
<p class="Pp"></p>
<pre>  $val = $dbh-&gt;{$attr};
</pre>
<p class="Pp">See perltie for details on tied hash refs to understand why these
    methods are required.</p>
<p class="Pp">The <b>DBI</b> will handle most attributes for you, in particular
    attributes like <i>RaiseError</i> or <i>PrintError</i>. All you have to do
    is handle your driver's private attributes and any attributes, like
    <i>AutoCommit</i> and <i>ChopBlanks</i>, that the <b>DBI</b> can't handle
    for you.</p>
<p class="Pp">A good example might look like this:</p>
<p class="Pp"></p>
<pre>  sub STORE
  {
      my ($dbh, $attr, $val) = @_;
      if ($attr eq 'AutoCommit') {
          # AutoCommit is currently the only standard attribute we have
          # to consider.
          if (!$val) { die &quot;Can't disable AutoCommit&quot;; }
          return 1;
      }
      if ($attr =~ m/^drv_/) {
          # Handle only our private attributes here
          # Note that we could trigger arbitrary actions.
          # Ideally we should warn about unknown attributes.
          $dbh-&gt;{$attr} = $val; # Yes, we are allowed to do this,
          return 1;             # but only for our private attributes
      }
      # Else pass up to DBI to handle for us
      $dbh-&gt;SUPER::STORE($attr, $val);
  }
  sub FETCH
  {
      my ($dbh, $attr) = @_;
      if ($attr eq 'AutoCommit') { return 1; }
      if ($attr =~ m/^drv_/) {
          # Handle only our private attributes here
          # Note that we could trigger arbitrary actions.
          return $dbh-&gt;{$attr}; # Yes, we are allowed to do this,
                                # but only for our private attributes
      }
      # Else pass up to DBI to handle
      $dbh-&gt;SUPER::FETCH($attr);
  }
</pre>
<p class="Pp">The <b>DBI</b> will actually store and fetch driver-specific
    attributes (with all lowercase names) without warning or error, so there's
    actually no need to implement driver-specific any code in your
    <span class="Li">&quot;FETCH()&quot;</span> and
    <span class="Li">&quot;STORE()&quot;</span> methods unless you need extra
    logic/checks, beyond getting or setting the value.</p>
<p class="Pp">Unless your driver documentation indicates otherwise, the return
    value of the <span class="Li">&quot;STORE()&quot;</span> method is
    unspecified and the caller shouldn't use that value.</p>
<p class="Pp">Other database handle methods</p>
<p class="Pp">As with the driver package, other database handle methods may
    follow here. In particular you should consider a (possibly empty)
    <span class="Li">&quot;disconnect()&quot;</span> method and possibly a
    <span class="Li">&quot;quote()&quot;</span> method if <b>DBI</b>'s default
    isn't correct for you. You may also need the
    <span class="Li">&quot;type_info_all()&quot;</span> and
    <span class="Li">&quot;get_info()&quot;</span> methods, as described
    elsewhere in this document.</p>
<p class="Pp">Where reasonable use
    <span class="Li">&quot;$h-&gt;SUPER::foo()&quot;</span> to call the
    <b>DBI</b>'s method in some or all cases and just wrap your custom behavior
    around that.</p>
<p class="Pp">If you want to use private trace flags you'll probably want to be
    able to set them by name. To do that you'll need to define a
    <span class="Li">&quot;parse_trace_flag()&quot;</span> method (note that's
    &quot;parse_trace_flag&quot;, singular, not &quot;parse_trace_flags&quot;,
    plural).</p>
<p class="Pp"></p>
<pre>  sub parse_trace_flag {
      my ($h, $name) = @_;
      return 0x01000000 if $name eq 'foo';
      return 0x02000000 if $name eq 'bar';
      return 0x04000000 if $name eq 'baz';
      return 0x08000000 if $name eq 'boo';
      return 0x10000000 if $name eq 'bop';
      return $h-&gt;SUPER::parse_trace_flag($name);
  }
</pre>
<p class="Pp">All private flag names must be lowercase, and all private flags
    must be in the top 8 of the 32 bits.</p>
<p class="Pp"><i>The DBD::Driver::st package</i></p>
<p class="Pp">This package follows the same pattern the others do:</p>
<p class="Pp"></p>
<pre>  package DBD::Driver::st;
  $DBD::Driver::st::imp_data_size = 0;
</pre>
<p class="Pp">The <b>execute()</b> and <b>bind_param()</b> methods</p>
<p class="Pp">This is perhaps the most difficult method because we have to
    consider parameter bindings here. In addition to that, there are a number of
    statement attributes which must be set for inherited <b>DBI</b> methods to
    function correctly (see &quot;Statement attributes&quot; below).</p>
<p class="Pp">We present a simplified implementation by using the
    <i>drv_params</i> attribute from above:</p>
<p class="Pp"></p>
<pre>  sub bind_param
  {
      my ($sth, $pNum, $val, $attr) = @_;
      my $type = (ref $attr) ? $attr-&gt;{TYPE} : $attr;
      if ($type) {
          my $dbh = $sth-&gt;{Database};
          $val = $dbh-&gt;quote($sth, $type);
      }
      my $params = $sth-&gt;{drv_params};
      $params-&gt;[$pNum-1] = $val;
      1;
  }
  sub execute
  {
      my ($sth, @bind_values) = @_;
      # start of by finishing any previous execution if still active
      $sth-&gt;finish if $sth-&gt;FETCH('Active');
      my $params = (@bind_values) ?
          \@bind_values : $sth-&gt;{drv_params};
      my $numParam = $sth-&gt;FETCH('NUM_OF_PARAMS');
      return $sth-&gt;set_err($DBI::stderr, &quot;Wrong number of parameters&quot;)
          if @$params != $numParam;
      my $statement = $sth-&gt;{'Statement'};
      for (my $i = 0;  $i &lt; $numParam;  $i++) {
          $statement =~ s/?/$params-&gt;[$i]/; # XXX doesn't deal with quoting etc!
      }
      # Do anything ... we assume that an array ref of rows is
      # created and store it:
      $sth-&gt;{'drv_data'} = $data;
      $sth-&gt;{'drv_rows'} = @$data; # number of rows
      $sth-&gt;STORE('NUM_OF_FIELDS') = $numFields;
      $sth-&gt;{Active} = 1;
      @$data || '0E0';
  }
</pre>
<p class="Pp">There are a number of things you should note here.</p>
<p class="Pp">We initialize the <i>NUM_OF_FIELDS</i> and <i>Active</i>
    attributes here, because they are essential for
    <span class="Li">&quot;bind_columns()&quot;</span> to work.</p>
<p class="Pp">We use attribute
    <span class="Li">&quot;$sth-&gt;{Statement}&quot;</span> which we created
    within <span class="Li">&quot;prepare()&quot;</span>. The attribute
    <span class="Li">&quot;$sth-&gt;{Database}&quot;</span>, which is nothing
    else than the <i>dbh</i>, was automatically created by <b>DBI</b>.</p>
<p class="Pp">Finally, note that (as specified in the <b>DBI</b> specification)
    we return the string <span class="Li">'0E0'</span> instead of the number 0,
    so that the result tests true but equal to zero.</p>
<p class="Pp"></p>
<pre>  $sth-&gt;execute() or die $sth-&gt;errstr;
</pre>
<p class="Pp">The <b>execute_array()</b>, <b>execute_for_fetch()</b> and
    <b>bind_param_array()</b> methods</p>
<p class="Pp">In general, DBD's only need to implement
    <span class="Li">&quot;execute_for_fetch()&quot;</span> and
    <span class="Li">&quot;bind_param_array&quot;</span>. DBI's default
    <span class="Li">&quot;execute_array()&quot;</span> will invoke the DBD's
    <span class="Li">&quot;execute_for_fetch()&quot;</span> as needed.</p>
<p class="Pp">The following sequence describes the interaction between DBI
    <span class="Li">&quot;execute_array&quot;</span> and a DBD's
    <span class="Li">&quot;execute_for_fetch&quot;</span>:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>App calls <span class="Li">&quot;$sth-&gt;execute_array(\%attrs,
      @array_of_arrays)&quot;</span></dd>
  <dt>2.</dt>
  <dd>If <span class="Li">@array_of_arrays</span> was specified, DBI processes
      <span class="Li">@array_of_arrays</span> by calling DBD's
      <span class="Li">&quot;bind_param_array()&quot;</span>. Alternately, App
      may have directly called
      <span class="Li">&quot;bind_param_array()&quot;</span></dd>
  <dt>3.</dt>
  <dd>DBD validates and binds each array</dd>
  <dt>4.</dt>
  <dd>DBI retrieves the validated param arrays from DBD's ParamArray
    attribute</dd>
  <dt>5.</dt>
  <dd>DBI calls DBD's <span class="Li">&quot;execute_for_fetch($fetch_tuple_sub,
      \@tuple_status)&quot;</span>, where
      <span class="Li">&amp;$fetch_tuple_sub</span> is a closure to iterate over
      the returned ParamArray values, and
      <span class="Li">&quot;\@tuple_status&quot;</span> is an array to receive
      the disposition status of each tuple.</dd>
  <dt>6.</dt>
  <dd>DBD iteratively calls <span class="Li">&amp;$fetch_tuple_sub</span> to
      retrieve parameter tuples to be added to its bulk database
      operation/request.</dd>
  <dt>7.</dt>
  <dd>when DBD reaches the limit of tuples it can handle in a single database
      operation/request, or the <span class="Li">&amp;$fetch_tuple_sub</span>
      indicates no more tuples by returning undef, the DBD executes the bulk
      operation, and reports the disposition of each tuple in
    \@tuple_status.</dd>
  <dt>8.</dt>
  <dd>DBD repeats steps 6 and 7 until all tuples are processed.</dd>
</dl>
<p class="Pp">E.g., here's the essence of DBD::Oracle's execute_for_fetch:</p>
<p class="Pp"></p>
<pre>       while (1) {
           my @tuple_batch;
           for (my $i = 0; $i &lt; $batch_size; $i++) {
                push @tuple_batch, [ @{$fetch_tuple_sub-&gt;() || last} ];
           }
           last unless @tuple_batch;
           my $res = ora_execute_array($sth, \@tuple_batch,
              scalar(@tuple_batch), $tuple_batch_status);
           push @$tuple_status, @$tuple_batch_status;
       }
</pre>
<p class="Pp">Note that DBI's default
    <b>execute_array()</b>/<b>execute_for_fetch()</b> implementation requires
    the use of positional (i.e., '?') placeholders. Drivers which <b>require</b>
    named placeholders must either emulate positional placeholders (e.g., see
    DBD::Oracle), or must implement their own
    <b>execute_array()</b>/<b>execute_for_fetch()</b> methods to properly
    sequence bound parameter arrays.</p>
<p class="Pp">Fetching data</p>
<p class="Pp">Only one method needs to be written for fetching data,
    <span class="Li">&quot;fetchrow_arrayref()&quot;</span>. The other methods,
    <span class="Li">&quot;fetchrow_array()&quot;</span>,
    <span class="Li">&quot;fetchall_arrayref()&quot;</span>, etc, as well as the
    database handle's <span class="Li">&quot;select*&quot;</span> methods are
    part of <b>DBI</b>, and call
    <span class="Li">&quot;fetchrow_arrayref()&quot;</span> as necessary.</p>
<p class="Pp"></p>
<pre>  sub fetchrow_arrayref
  {
      my ($sth) = @_;
      my $data = $sth-&gt;{drv_data};
      my $row = shift @$data;
      if (!$row) {
          $sth-&gt;STORE(Active =&gt; 0); # mark as no longer active
          return undef;
      }
      if ($sth-&gt;FETCH('ChopBlanks')) {
          map { $_ =~ s/\s+$//; } @$row;
      }
      return $sth-&gt;_set_fbav($row);
  }
  *fetch = \&amp;fetchrow_arrayref; # required alias for fetchrow_arrayref
</pre>
<p class="Pp">Note the use of the method
    <span class="Li">&quot;_set_fbav()&quot;</span> -- this is required so that
    <span class="Li">&quot;bind_col()&quot;</span> and
    <span class="Li">&quot;bind_columns()&quot;</span> work.</p>
<p class="Pp">If an error occurs which leaves the
    <i></i><span class="Li"><i>$sth</i></span><i></i> in a state where remaining
    rows can't be fetched then <i>Active</i> should be turned off before the
    method returns.</p>
<p class="Pp">The <span class="Li">&quot;rows()&quot;</span> method for this
    driver can be implemented like this:</p>
<p class="Pp"></p>
<pre>  sub rows { shift-&gt;{drv_rows} }
</pre>
<p class="Pp">because it knows in advance how many rows it has fetched.
    Alternatively you could delete that method and so fallback to the
    <b>DBI</b>'s own method which does the right thing based on the number of
    calls to <span class="Li">&quot;_set_fbav()&quot;</span>.</p>
<p class="Pp">The more_results method</p>
<p class="Pp">If your driver doesn't support multiple result sets, then don't
    even implement this method.</p>
<p class="Pp">Otherwise, this method needs to get the statement handle ready to
    fetch results from the next result set, if there is one. Typically you'd
    start with:</p>
<p class="Pp"></p>
<pre>    $sth-&gt;finish;
</pre>
<p class="Pp">then you should delete all the attributes from the attribute cache
    that may no longer be relevant for the new result set:</p>
<p class="Pp"></p>
<pre>    delete $sth-&gt;{$_}
        for qw(NAME TYPE PRECISION SCALE ...);
</pre>
<p class="Pp">for drivers written in C use:</p>
<p class="Pp"></p>
<pre>    hv_delete((HV*)SvRV(sth), &quot;NAME&quot;, 4, G_DISCARD);
    hv_delete((HV*)SvRV(sth), &quot;NULLABLE&quot;, 8, G_DISCARD);
    hv_delete((HV*)SvRV(sth), &quot;NUM_OF_FIELDS&quot;, 13, G_DISCARD);
    hv_delete((HV*)SvRV(sth), &quot;PRECISION&quot;, 9, G_DISCARD);
    hv_delete((HV*)SvRV(sth), &quot;SCALE&quot;, 5, G_DISCARD);
    hv_delete((HV*)SvRV(sth), &quot;TYPE&quot;, 4, G_DISCARD);
</pre>
<p class="Pp">Don't forget to also delete, or update, any driver-private
    attributes that may not be correct for the next resultset.</p>
<p class="Pp">The NUM_OF_FIELDS attribute is a special case. It should be set
    using STORE:</p>
<p class="Pp"></p>
<pre>    $sth-&gt;STORE(NUM_OF_FIELDS =&gt; 0); /* for DBI &lt;= 1.53 */
    $sth-&gt;STORE(NUM_OF_FIELDS =&gt; $new_value);
</pre>
<p class="Pp">for drivers written in C use this incantation:</p>
<p class="Pp"></p>
<pre>    /* Adjust NUM_OF_FIELDS - which also adjusts the row buffer size */
    DBIc_NUM_FIELDS(imp_sth) = 0; /* for DBI &lt;= 1.53 */
    DBIc_STATE(imp_xxh)-&gt;set_attr_k(sth, sv_2mortal(newSVpvn(&quot;NUM_OF_FIELDS&quot;,13)), 0,
        sv_2mortal(newSViv(mysql_num_fields(imp_sth-&gt;result)))
    );
</pre>
<p class="Pp">For DBI versions prior to 1.54 you'll also need to explicitly
    adjust the number of elements in the row buffer array
    (<span class="Li">&quot;DBIc_FIELDS_AV(imp_sth)&quot;</span>) to match the
    new result set. Fill any new values with <b>newSV</b>(0) not &amp;sv_undef.
    Alternatively you could free DBIc_FIELDS_AV(imp_sth) and set it to null, but
    that would mean <b>bind_columns()</b> wouldn't work across result sets.</p>
<p class="Pp">Statement attributes</p>
<p class="Pp">The main difference between <i>dbh</i> and <i>sth</i> attributes
    is, that you should implement a lot of attributes here that are required by
    the <b>DBI</b>, such as <i>NAME</i>, <i>NULLABLE</i>, <i>TYPE</i>, etc. See
    &quot;Statement Handle Attributes&quot; in DBI for a complete list.</p>
<p class="Pp">Pay attention to attributes which are marked as read only, such as
    <i>NUM_OF_PARAMS</i>. These attributes can only be set the first time a
    statement is executed. If a statement is prepared, then executed multiple
    times, warnings may be generated.</p>
<p class="Pp">You can protect against these warnings, and prevent the
    recalculation of attributes which might be expensive to calculate (such as
    the <i>NAME</i> and <i>NAME_*</i> attributes):</p>
<p class="Pp"></p>
<pre>    my $storedNumParams = $sth-&gt;FETCH('NUM_OF_PARAMS');
    if (!defined $storedNumParams or $storedNumFields &lt; 0) {
        $sth-&gt;STORE('NUM_OF_PARAMS') = $numParams;
        # Set other useful attributes that only need to be set once
        # for a statement, like $sth-&gt;{NAME} and $sth-&gt;{TYPE}
    }
</pre>
<p class="Pp">One particularly important attribute to set correctly (mentioned
    in &quot;ATTRIBUTES COMMON TO ALL HANDLES&quot; in DBI is <i>Active</i>.
    Many <b>DBI</b> methods, including
    <span class="Li">&quot;bind_columns()&quot;</span>, depend on this
    attribute.</p>
<p class="Pp">Besides that the <span class="Li">&quot;STORE()&quot;</span> and
    <span class="Li">&quot;FETCH()&quot;</span> methods are mainly the same as
    above for <i>dbh</i>'s.</p>
<p class="Pp">Other statement methods</p>
<p class="Pp">A trivial <span class="Li">&quot;finish()&quot;</span> method to
    discard stored data, reset any attributes (such as <i>Active</i>) and do
    <span class="Li">&quot;$sth-&gt;SUPER::finish()&quot;</span>.</p>
<p class="Pp">If you've defined a
    <span class="Li">&quot;parse_trace_flag()&quot;</span> method in <b>::db</b>
    you'll also want it in <b>::st</b>, so just alias it in:</p>
<p class="Pp"></p>
<pre>  *parse_trace_flag = \&amp;DBD::foo:db::parse_trace_flag;
</pre>
<p class="Pp">And perhaps some other methods that are not part of the <b>DBI</b>
    specification, in particular to make metadata available. Remember that they
    must have names that begin with your drivers registered prefix so they can
    be installed using <span class="Li">&quot;install_method()&quot;</span>.</p>
<p class="Pp">If <span class="Li">&quot;DESTROY()&quot;</span> is called on a
    statement handle that's still active
    (<span class="Li">&quot;$sth-&gt;{Active}&quot;</span> is true) then it
    should effectively call <span class="Li">&quot;finish()&quot;</span>.</p>
<p class="Pp"></p>
<pre>    sub DESTROY {
        my $sth = shift;
        $sth-&gt;finish if $sth-&gt;FETCH('Active');
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Tests"><a class="permalink" href="#Tests">Tests</a></h2>
<p class="Pp">The test process should conform as closely as possibly to the Perl
    standard test harness.</p>
<p class="Pp">In particular, most (all) of the tests should be run in the
    <i>t</i> sub-directory, and should simply produce an
    <span class="Li">&quot;ok&quot;</span> when run under
    <span class="Li">&quot;make test&quot;</span>. For details on how this is
    done, see the Camel book and the section in Chapter 7, &quot;The Standard
    Perl Library&quot; on Test::Harness.</p>
<p class="Pp">The tests may need to adapt to the type of database which is being
    used for testing, and to the privileges of the user testing the driver. For
    example, the <b>DBD::Informix</b> test code has to adapt in a number of
    places to the type of database to which it is connected as different
    Informix databases have different capabilities: some of the tests are for
    databases without transaction logs; others are for databases with a
    transaction log; some versions of the server have support for blobs, or
    stored procedures, or user-defined data types, and others do not.</p>
<p class="Pp">When a complete file of tests must be skipped, you can provide a
    reason in a pseudo-comment:</p>
<p class="Pp"></p>
<pre>    if ($no_transactions_available)
    {
        print &quot;1..0 # Skip: No transactions available\n&quot;;
        exit 0;
    }
</pre>
<p class="Pp">Consider downloading the <b>DBD::Informix</b> code and look at the
    code in <i>DBD/Informix/TestHarness.pm</i> which is used throughout the
    <b>DBD::Informix</b> tests in the <i>t</i> sub-directory.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CREATING_A_C/XS_DRIVER"><a class="permalink" href="#CREATING_A_C/XS_DRIVER">CREATING
  A C/XS DRIVER</a></h1>
<p class="Pp">Please also see the section under &quot;CREATING A PURE PERL
    DRIVER&quot; regarding the creation of the <i>Makefile.PL</i>.</p>
<p class="Pp">Creating a new C/XS driver from scratch will always be a daunting
    task. You can and should greatly simplify your task by taking a good
    reference driver implementation and modifying that to match the database
    product for which you are writing a driver.</p>
<p class="Pp">The de facto reference driver has been the one for
    <b>DBD::Oracle</b> written by Tim Bunce, who is also the author of the
    <b>DBI</b> package. The <b>DBD::Oracle</b> module is a good example of a
    driver implemented around a C-level API.</p>
<p class="Pp">Nowadays it it seems better to base on <b>DBD::ODBC</b>, another
    driver maintained by Tim and Jeff Urlwin, because it offers a lot of
    metadata and seems to become the guideline for the future development. (Also
    as <b>DBD::Oracle</b> digs deeper into the Oracle 8 OCI interface it'll get
    even more hairy than it is now.)</p>
<p class="Pp">The <b>DBD::Informix</b> driver is one driver implemented using
    embedded SQL instead of a function-based API. <b>DBD::Ingres</b> may also be
    worth a look.</p>
<section class="Ss">
<h2 class="Ss" id="C/XS_version_of_Driver.pm"><a class="permalink" href="#C/XS_version_of_Driver.pm">C/XS
  version of Driver.pm</a></h2>
<p class="Pp">A lot of the code in the <i>Driver.pm</i> file is very similar to
    the code for pure Perl modules - see above. However, there are also some
    subtle (and not so subtle) differences, including:</p>
<ul class="Bl-bullet">
  <li>The variables
      <i></i><span class="Li"><i>$DBD::Driver::</i></span><i>{dr|db|st}::imp_data_size</i>
      are not defined here, but in the XS code, because they declare the size of
      certain C structures.</li>
  <li>Some methods are typically moved to the XS code, in particular
      <span class="Li">&quot;prepare()&quot;</span>,
      <span class="Li">&quot;execute()&quot;</span>,
      <span class="Li">&quot;disconnect()&quot;</span>,
      <span class="Li">&quot;disconnect_all()&quot;</span> and the
      <span class="Li">&quot;STORE()&quot;</span> and
      <span class="Li">&quot;FETCH()&quot;</span> methods.</li>
  <li>Other methods are still part of <i>Driver.pm</i>, but have callbacks to
      the XS code.</li>
  <li>If the driver-specific parts of the <i>imp_drh_t</i> structure need to be
      formally initialized (which does not seem to be a common requirement),
      then you need to add a call to an appropriate XS function in the driver
      method of <span class="Li">&quot;DBD::Driver::driver()&quot;</span>, and
      you define the corresponding function in <i>Driver.xs</i>, and you define
      the C code in <i>dbdimp.c</i> and the prototype in <i>dbdimp.h</i>.
    <p class="Pp">For example, <b>DBD::Informix</b> has such a requirement, and
        adds the following call after the call to
        <span class="Li">&quot;_new_drh()&quot;</span> in
      <i>Informix.pm</i>:</p>
    <p class="Pp"></p>
    <pre>  DBD::Informix::dr::driver_init($drh);
    </pre>
    <p class="Pp">and the following code in <i>Informix.xs</i>:</p>
    <p class="Pp"></p>
    <pre>  # Initialize the DBD::Informix driver data structure
  void
  driver_init(drh)
      SV *drh
      CODE:
      ST(0) = dbd_ix_dr_driver_init(drh) ? &amp;sv_yes : &amp;sv_no;
    </pre>
    <p class="Pp">and the code in <i>dbdimp.h</i> declares:</p>
    <p class="Pp"></p>
    <pre>  extern int dbd_ix_dr_driver_init(SV *drh);
    </pre>
    <p class="Pp">and the code in <i>dbdimp.ec</i> (equivalent to
        <i>dbdimp.c</i>) defines:</p>
    <p class="Pp"></p>
    <pre>  /* Formally initialize the DBD::Informix driver structure */
  int
  dbd_ix_dr_driver(SV *drh)
  {
      D_imp_drh(drh);
      imp_drh-&gt;n_connections = 0;       /* No active connections */
      imp_drh-&gt;current_connection = 0;  /* No current connection */
      imp_drh-&gt;multipleconnections = (ESQLC_VERSION &gt;= 600) ? True : False;
      dbd_ix_link_newhead(&amp;imp_drh-&gt;head);  /* Empty linked list of connections */
      return 1;
  }
    </pre>
    <p class="Pp"><b>DBD::Oracle</b> has a similar requirement but gets around
        it by checking whether the private data part of the driver handle is all
        zeroed out, rather than add extra functions.</p>
  </li>
</ul>
<p class="Pp">Now let's take a closer look at an excerpt from <i>Oracle.pm</i>
    (revised heavily to remove idiosyncrasies) as an example, ignoring things
    that were already discussed for pure Perl drivers.</p>
<p class="Pp"><i>The connect method</i></p>
<p class="Pp">The connect method is the database handle constructor. You could
    write either of two versions of this method: either one which takes
    connection attributes (new code) and one which ignores them (old code
  only).</p>
<p class="Pp">If you ignore the connection attributes, then you omit all mention
    of the <i></i><span class="Li"><i>$auth</i></span><i></i> variable (which is
    a reference to a hash of attributes), and the XS system manages the
    differences for you.</p>
<p class="Pp"></p>
<pre>  sub connect
  {
      my ($drh, $dbname, $user, $auth, $attr) = @_;
      # Some database specific verifications, default settings
      # and the like following here. This should only include
      # syntax checks or similar stuff where it's legal to
      # 'die' in case of errors.
      my $dbh = DBI::_new_dbh($drh, {
              'Name'   =&gt; $dbname,
          })
          or return undef;
      # Call the driver-specific function _login in Driver.xs file which
      # calls the DBMS-specific function(s) to connect to the database,
      # and populate internal handle data.
      DBD::Driver::db::_login($dbh, $dbname, $user, $auth, $attr)
          or return undef;
      $dbh;
  }
</pre>
<p class="Pp">This is mostly the same as in the pure Perl case, the exception
    being the use of the private <span class="Li">&quot;_login()&quot;</span>
    callback, which is the function that will really connect to the database. It
    is implemented in <i>Driver.xst</i> (you should not implement it) and calls
    <span class="Li">&quot;dbd_db_login6()&quot;</span> or
    <span class="Li">&quot;dbd_db_login6_sv&quot;</span> from <i>dbdimp.c</i>.
    See below for details.</p>
<p class="Pp">If your driver has driver-specific attributes which may be passed
    in the connect method and hence end up in <span class="Li">$attr</span> in
    <span class="Li">&quot;dbd_db_login6&quot;</span> then it is best to delete
    any you process so DBI does not send them again via STORE after connect. You
    can do this in C like this:</p>
<p class="Pp"></p>
<pre>  DBD_ATTRIB_DELETE(attr, &quot;my_attribute_name&quot;,
                    strlen(&quot;my_attribute_name&quot;));
</pre>
<p class="Pp">However, prior to DBI subversion version 11605 (and fixed post
    1.607) DBD_ATTRIB_DELETE segfaulted so if you cannot guarantee the DBI
    version will be post 1.607 you need to use:</p>
<p class="Pp"></p>
<pre>  hv_delete((HV*)SvRV(attr), &quot;my_attribute_name&quot;,
                     strlen(&quot;my_attribute_name&quot;), G_DISCARD);
 *FIX ME* Discuss removing attributes in Perl code.
</pre>
<p class="Pp"><i>The disconnect_all method</i></p>
<p class="Pp"></p>
<pre> *FIX ME* T.B.S
</pre>
<p class="Pp"><i>The data_sources method</i></p>
<p class="Pp">If your <span class="Li">&quot;data_sources()&quot;</span> method
    can be implemented in pure Perl, then do so because it is easier than doing
    it in XS code (see the section above for pure Perl drivers).</p>
<p class="Pp">If your <span class="Li">&quot;data_sources()&quot;</span> method
    must call onto compiled functions, then you will need to define
    <i>dbd_dr_data_sources</i> in your <i>dbdimp.h</i> file, which will trigger
    <i>Driver.xst</i> (in <b>DBI</b> v1.33 or greater) to generate the XS code
    that calls your actual C function (see the discussion below for details) and
    you do not code anything in <i>Driver.pm</i> to handle it.</p>
<p class="Pp"><i>The prepare method</i></p>
<p class="Pp">The prepare method is the statement handle constructor, and most
    of it is not new. Like the <span class="Li">&quot;connect()&quot;</span>
    method, it now has a C callback:</p>
<p class="Pp"></p>
<pre>  package DBD::Driver::db; # ====== DATABASE ======
  use strict;
  sub prepare
  {
      my ($dbh, $statement, $attribs) = @_;
      # create a 'blank' sth
      my $sth = DBI::_new_sth($dbh, {
          'Statement' =&gt; $statement,
          })
          or return undef;
      # Call the driver-specific function _prepare in Driver.xs file
      # which calls the DBMS-specific function(s) to prepare a statement
      # and populate internal handle data.
      DBD::Driver::st::_prepare($sth, $statement, $attribs)
          or return undef;
      $sth;
  }
</pre>
<p class="Pp"><i>The execute method</i></p>
<p class="Pp"></p>
<pre> *FIX ME* T.B.S
</pre>
<p class="Pp"><i>The fetchrow_arrayref method</i></p>
<p class="Pp"></p>
<pre> *FIX ME* T.B.S
</pre>
<p class="Pp"><i>Other methods?</i></p>
<p class="Pp"></p>
<pre> *FIX ME* T.B.S
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Driver.xs"><a class="permalink" href="#Driver.xs">Driver.xs</a></h2>
<p class="Pp"><i>Driver.xs</i> should look something like this:</p>
<p class="Pp"></p>
<pre>  #include &quot;Driver.h&quot;
  DBISTATE_DECLARE;
  INCLUDE: Driver.xsi
  MODULE = DBD::Driver    PACKAGE = DBD::Driver::dr
  /* Non-standard drh XS methods following here, if any.       */
  /* If none (the usual case), omit the MODULE line above too. */
  MODULE = DBD::Driver    PACKAGE = DBD::Driver::db
  /* Non-standard dbh XS methods following here, if any.       */
  /* Currently this includes things like _list_tables from     */
  /* DBD::mSQL and DBD::mysql.                                 */
  MODULE = DBD::Driver    PACKAGE = DBD::Driver::st
  /* Non-standard sth XS methods following here, if any.       */
  /* In particular this includes things like _list_fields from */
  /* DBD::mSQL and DBD::mysql for accessing metadata.          */
</pre>
<p class="Pp">Note especially the include of <i>Driver.xsi</i> here: <b>DBI</b>
    inserts stub functions for almost all private methods here which will
    typically do much work for you.</p>
<p class="Pp">Wherever you really have to implement something, it will call a
    private function in <i>dbdimp.c</i>, and this is what you have to
  implement.</p>
<p class="Pp">You need to set up an extra routine if your driver needs to export
    constants of its own, analogous to the SQL types available when you say:</p>
<p class="Pp"></p>
<pre>  use DBI qw(:sql_types);
 *FIX ME* T.B.S
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Driver.h"><a class="permalink" href="#Driver.h">Driver.h</a></h2>
<p class="Pp"><i>Driver.h</i> is very simple and the operational contents should
    look like this:</p>
<p class="Pp"></p>
<pre>  #ifndef DRIVER_H_INCLUDED
  #define DRIVER_H_INCLUDED
  #define NEED_DBIXS_VERSION 93    /* 93 for DBI versions 1.00 to 1.51+ */
  #define PERL_NO_GET_CONTEXT      /* if used require DBI 1.51+ */
  #include &lt;DBIXS.h&gt;      /* installed by the DBI module  */
  #include &quot;dbdimp.h&quot;
  #include &quot;dbivport.h&quot;   /* see below                    */
  #include &lt;dbd_xsh.h&gt;    /* installed by the DBI module  */
  #endif /* DRIVER_H_INCLUDED */
</pre>
<p class="Pp">The <i>DBIXS.h</i> header defines most of the interesting
    information that the writer of a driver needs.</p>
<p class="Pp">The file <i>dbd_xsh.h</i> header provides prototype declarations
    for the C functions that you might decide to implement. Note that you should
    normally only define one of
    <span class="Li">&quot;dbd_db_login()&quot;</span>,
    <span class="Li">&quot;dbd_db_login6()&quot;</span> or
    <span class="Li">&quot;dbd_db_login6_sv&quot;</span> unless you are intent
    on supporting really old versions of <b>DBI</b> (prior to <b>DBI</b> 1.06)
    as well as modern versions. The only standard, <b>DBI</b>-mandated functions
    that you need write are those specified in the <i>dbd_xsh.h</i> header. You
    might also add extra driver-specific functions in <i>Driver.xs</i>.</p>
<p class="Pp">The <i>dbivport.h</i> file should be <i>copied</i> from the latest
    <b>DBI</b> release into your distribution each time you modify your driver.
    Its job is to allow you to enhance your code to work with the latest
    <b>DBI</b> API while still allowing your driver to be compiled and used with
    older versions of the <b>DBI</b> (for example, when the
    <span class="Li">&quot;DBIh_SET_ERR_CHAR()&quot;</span> macro was added to
    <b>DBI</b> 1.41, an emulation of it was added to <i>dbivport.h</i>). This
    makes users happy and your life easier. Always read the notes in
    <i>dbivport.h</i> to check for any limitations in the emulation that you
    should be aware of.</p>
<p class="Pp">With <b>DBI</b> v1.51 or better I recommend that the driver
    defines <i>PERL_NO_GET_CONTEXT</i> before <i>DBIXS.h</i> is included. This
    can significantly improve efficiency when running under a thread enabled
    perl. (Remember that the standard perl in most Linux distributions is built
    with threads enabled. So is ActiveState perl for Windows, and perl built for
    Apache mod_perl2.) If you do this there are some things to keep in mind:</p>
<ul class="Bl-bullet">
  <li>If <i>PERL_NO_GET_CONTEXT</i> is defined, then every function that calls
      the Perl API will need to start out with a
      <span class="Li">&quot;dTHX;&quot;</span> declaration.</li>
  <li>You'll know which functions need this, because the C compiler will
      complain that the undeclared identifier
      <span class="Li">&quot;my_perl&quot;</span> is used if <i>and only if</i>
      the perl you are using to develop and test your driver has threads
      enabled.</li>
  <li>If you don't remember to test with a thread-enabled perl before making a
      release it's likely that you'll get failure reports from users who
    are.</li>
  <li>For driver private functions it is possible to gain even more efficiency
      by replacing <span class="Li">&quot;dTHX;&quot;</span> with
      <span class="Li">&quot;pTHX_&quot;</span> prepended to the parameter list
      and then <span class="Li">&quot;aTHX_&quot;</span> prepended to the
      argument list where the function is called.</li>
</ul>
<p class="Pp">See &quot;How multiple interpreters and concurrency are
    supported&quot; in perlguts for additional information about
    <i>PERL_NO_GET_CONTEXT</i>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Implementation_header_dbdimp.h"><a class="permalink" href="#Implementation_header_dbdimp.h">Implementation
  header dbdimp.h</a></h2>
<p class="Pp">This header file has two jobs:</p>
<p class="Pp">First it defines data structures for your private part of the
    handles. Note that the DBI provides many common fields for you. For example
    the statement handle (imp_sth) already has a row_count field with an IV type
    that accessed via the DBIc_ROW_COUNT(imp_sth) macro. Using this is strongly
    recommended as it's built in to some DBI internals so the DBI can 'just
    work' in more cases and you'll have less driver-specific code to write.
    Study DBIXS.h to see what's included with each type of handle.</p>
<p class="Pp">Second it defines macros that rename the generic names like
    <span class="Li">&quot;dbd_db_login()&quot;</span> to database specific
    names like <span class="Li">&quot;ora_db_login()&quot;</span>. This avoids
    name clashes and enables use of different drivers when you work with a
    statically linked perl.</p>
<p class="Pp">It also will have the important task of disabling XS methods that
    you don't want to implement.</p>
<p class="Pp">Finally, the macros will also be used to select alternate
    implementations of some functions. For example, the
    <span class="Li">&quot;dbd_db_login()&quot;</span> function is not passed
    the attribute hash.</p>
<p class="Pp">Since <b>DBI</b> v1.06, if a
    <span class="Li">&quot;dbd_db_login6()&quot;</span> macro is defined (for a
    function with 6 arguments), it will be used instead with the attribute hash
    passed as the sixth argument.</p>
<p class="Pp">Since <b>DBI</b> post v1.607, if a
    <span class="Li">&quot;dbd_db_login6_sv()&quot;</span> macro is defined (for
    a function like dbd_db_login6 but with scalar pointers for the dbname,
    username and password), it will be used instead. This will allow your login6
    function to see if there are any Unicode characters in the dbname.</p>
<p class="Pp">Similarly defining dbd_db_do4_iv is preferred over dbd_db_do4,
    dbd_st_rows_iv over dbd_st_rows, and dbd_st_execute_iv over dbd_st_execute.
    The *_iv forms are declared to return the IV type instead of an int.</p>
<p class="Pp">People used to just pick Oracle's <i>dbdimp.c</i> and use the same
    names, structures and types. I strongly recommend against that. At first
    glance this saves time, but your implementation will be less readable. It
    was just hell when I had to separate <b>DBI</b> specific parts, Oracle
    specific parts, mSQL specific parts and mysql specific parts in
    <b>DBD::mysql</b>'s <i>dbdimp.h</i> and <i>dbdimp.c</i>. (<b>DBD::mysql</b>
    was a port of <b>DBD::mSQL</b> which was based on <b>DBD::Oracle</b>.)
    [Seconded, based on the experience taking <b>DBD::Informix</b> apart, even
    though the version inherited in 1996 was only based on
  <b>DBD::Oracle</b>.]</p>
<p class="Pp">This part of the driver is <i>your exclusive part</i>. Rewrite it
    from scratch, so it will be clean and short: in other words, a better piece
    of code. (Of course keep an eye on other people's work.)</p>
<p class="Pp"></p>
<pre>  struct imp_drh_st {
      dbih_drc_t com;           /* MUST be first element in structure   */
      /* Insert your driver handle attributes here */
  };
  struct imp_dbh_st {
      dbih_dbc_t com;           /* MUST be first element in structure   */
      /* Insert your database handle attributes here */
  };
  struct imp_sth_st {
      dbih_stc_t com;           /* MUST be first element in structure   */
      /* Insert your statement handle attributes here */
  };
  /*  Rename functions for avoiding name clashes; prototypes are  */
  /*  in dbd_xsh.h                                                */
  #define dbd_init            drv_dr_init
  #define dbd_db_login6_sv    drv_db_login_sv
  #define dbd_db_do           drv_db_do
  ... many more here ...
</pre>
<p class="Pp">These structures implement your private part of the handles.</p>
<p class="Pp">You <i>have</i> to use the name
    <span class="Li">&quot;imp_dbh_{dr|db|st}&quot;</span> and the first field
    <i>must</i> be of type <i>dbih_drc_t|_dbc_t|_stc_t</i> and <i>must</i> be
    called <span class="Li">&quot;com&quot;</span>.</p>
<p class="Pp">You should never access these fields directly, except by using the
    <i></i><b><i>DBIc_xxx()</i></b><i></i> macros below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Implementation_source_dbdimp.c"><a class="permalink" href="#Implementation_source_dbdimp.c">Implementation
  source dbdimp.c</a></h2>
<p class="Pp">Conventionally, <i>dbdimp.c</i> is the main implementation file
    (but <b>DBD::Informix</b> calls the file <i>dbdimp.ec</i>). This section
    includes a short note on each function that is used in the <i>Driver.xsi</i>
    template and thus <i>has</i> to be implemented.</p>
<p class="Pp">Of course, you will probably also need to implement other support
    functions, which should usually be file static if they are placed in
    <i>dbdimp.c</i>. If they are placed in other files, you need to list those
    files in <i>Makefile.PL</i> (and <i>MANIFEST</i>) to handle them
  correctly.</p>
<p class="Pp">It is wise to adhere to a namespace convention for your functions
    to avoid conflicts. For example, for a driver with prefix <i>drv_</i>, you
    might call externally visible functions <i>dbd_drv_xxxx</i>. You should also
    avoid non-constant global variables as much as possible to improve the
    support for threading.</p>
<p class="Pp">Since Perl requires support for function prototypes (ANSI or ISO
    or Standard C), you should write your code using function prototypes
  too.</p>
<p class="Pp">It is possible to use either the unmapped names such as
    <span class="Li">&quot;dbd_init()&quot;</span> or the mapped names such as
    <span class="Li">&quot;dbd_ix_dr_init()&quot;</span> in the <i>dbdimp.c</i>
    file. <b>DBD::Informix</b> uses the mapped names which makes it easier to
    identify where to look for linkage problems at runtime (which will report
    errors using the mapped names).</p>
<p class="Pp">Most other drivers, and in particular <b>DBD::Oracle</b>, use the
    unmapped names in the source code which makes it a little easier to compare
    code between drivers and eases discussions on the <i>dbi-dev</i> mailing
    list. The majority of the code fragments here will use the unmapped
  names.</p>
<p class="Pp">Ultimately, you should provide implementations for most of the
    functions listed in the <i>dbd_xsh.h</i> header. The exceptions are optional
    functions (such as <span class="Li">&quot;dbd_st_rows()&quot;</span>) and
    those functions with alternative signatures, such as
    <span class="Li">&quot;dbd_db_login6_sv&quot;</span>,
    <span class="Li">&quot;dbd_db_login6()&quot;</span> and
    <i></i><b><i>dbd_db_login()</i></b><i></i>. Then you should only implement
    one of the alternatives, and generally the newer one of the
  alternatives.</p>
<p class="Pp"><i>The dbd_init method</i></p>
<p class="Pp"></p>
<pre>  #include &quot;Driver.h&quot;
  DBISTATE_DECLARE;
  void dbd_init(dbistate_t* dbistate)
  {
      DBISTATE_INIT;  /*  Initialize the DBI macros  */
  }
</pre>
<p class="Pp">The <span class="Li">&quot;dbd_init()&quot;</span> function will
    be called when your driver is first loaded; the bootstrap command in
    <span class="Li">&quot;DBD::Driver::dr::driver()&quot;</span> triggers this,
    and the call is generated in the <i>BOOT</i> section of <i>Driver.xst</i>.
    These statements are needed to allow your driver to use the <b>DBI</b>
    macros. They will include your private header file <i>dbdimp.h</i> in turn.
    Note that <i>DBISTATE_INIT</i> requires the name of the argument to
    <span class="Li">&quot;dbd_init()&quot;</span> to be called
    <span class="Li">&quot;dbistate()&quot;</span>.</p>
<p class="Pp"><i>The dbd_drv_error method</i></p>
<p class="Pp">You need a function to record errors so <b>DBI</b> can access them
    properly. You can call it whatever you like, but we'll call it
    <span class="Li">&quot;dbd_drv_error()&quot;</span> here.</p>
<p class="Pp">The argument list depends on your database software; different
    systems provide different ways to get at error information.</p>
<p class="Pp"></p>
<pre>  static void dbd_drv_error(SV *h, int rc, const char *what)
  {
</pre>
<p class="Pp">Note that <i>h</i> is a generic handle, may it be a driver handle,
    a database or a statement handle.</p>
<p class="Pp"></p>
<pre>      D_imp_xxh(h);
</pre>
<p class="Pp">This macro will declare and initialize a variable <i>imp_xxh</i>
    with a pointer to your private handle pointer. You may cast this to to
    <i>imp_drh_t</i>, <i>imp_dbh_t</i> or <i>imp_sth_t</i>.</p>
<p class="Pp">To record the error correctly, equivalent to the
    <span class="Li">&quot;set_err()&quot;</span> method, use one of the
    <span class="Li">&quot;DBIh_SET_ERR_CHAR(...)&quot;</span> or
    <span class="Li">&quot;DBIh_SET_ERR_SV(...)&quot;</span> macros, which were
    added in <b>DBI</b> 1.41:</p>
<p class="Pp"></p>
<pre>  DBIh_SET_ERR_SV(h, imp_xxh, err, errstr, state, method);
  DBIh_SET_ERR_CHAR(h, imp_xxh, err_c, err_i, errstr, state, method);
</pre>
<p class="Pp">For <span class="Li">&quot;DBIh_SET_ERR_SV&quot;</span> the
    <i>err</i>, <i>errstr</i>, <i>state</i>, and <i>method</i> parameters are
    <span class="Li">&quot;SV*&quot;</span> (use &amp;sv_undef instead of
  NULL).</p>
<p class="Pp">For <span class="Li">&quot;DBIh_SET_ERR_CHAR&quot;</span> the
    <i>err_c</i>, <i>errstr</i>, <i>state</i>, <i>method</i> parameters are
    <span class="Li">&quot;char*&quot;</span>.</p>
<p class="Pp">The <i>err_i</i> parameter is an
    <span class="Li">&quot;IV&quot;</span> that's used instead of <i>err_c</i>
    if <i>err_c</i> is <span class="Li">&quot;Null&quot;</span>.</p>
<p class="Pp">The <i>method</i> parameter can be ignored.</p>
<p class="Pp">The <span class="Li">&quot;DBIh_SET_ERR_CHAR&quot;</span> macro is
    usually the simplest to use when you just have an integer error code and an
    error message string:</p>
<p class="Pp"></p>
<pre>  DBIh_SET_ERR_CHAR(h, imp_xxh, Nullch, rc, what, Nullch, Nullch);
</pre>
<p class="Pp">As you can see, any parameters that aren't relevant to you can be
    <span class="Li">&quot;Null&quot;</span>.</p>
<p class="Pp">To make drivers compatible with <b>DBI</b> &lt; 1.41 you should be
    using <i>dbivport.h</i> as described in &quot;Driver.h&quot; above.</p>
<p class="Pp">The (obsolete) macros such as
    <span class="Li">&quot;DBIh_EVENT2&quot;</span> should be removed from
    drivers.</p>
<p class="Pp">The names <span class="Li">&quot;dbis&quot;</span> and
    <span class="Li">&quot;DBIS&quot;</span>, which were used in previous
    versions of this document, should be replaced with the
    <span class="Li">&quot;DBIc_DBISTATE(imp_xxh)&quot;</span> macro.</p>
<p class="Pp">The name <span class="Li">&quot;DBILOGFP&quot;</span>, which was
    also used in previous versions of this document, should be replaced by
    <span class="Li">&quot;DBIc_LOGPIO(imp_xxh)&quot;</span>.</p>
<p class="Pp">Your code should not call the C
    <span class="Li">&quot;&lt;stdio.h&gt;&quot;</span> I/O functions; you
    should use <span class="Li">&quot;PerlIO_printf()&quot;</span> as shown:</p>
<p class="Pp"></p>
<pre>      if (DBIc_TRACE_LEVEL(imp_xxh) &gt;= 2)
          PerlIO_printf(DBIc_LOGPIO(imp_xxh), &quot;foobar %s: %s\n&quot;,
              foo, neatsvpv(errstr,0));
</pre>
<p class="Pp">That's the first time we see how tracing works within a <b>DBI</b>
    driver. Make use of this as often as you can, but don't output anything at a
    trace level less than 3. Levels 1 and 2 are reserved for the <b>DBI</b>.</p>
<p class="Pp">You can define up to 8 private trace flags using the top 8 bits of
    <span class="Li">&quot;DBIc_TRACE_FLAGS(imp)&quot;</span>, that is:
    <span class="Li">0xFF000000</span>. See the
    <span class="Li">&quot;parse_trace_flag()&quot;</span> method elsewhere in
    this document.</p>
<p class="Pp"><i>The dbd_dr_data_sources method</i></p>
<p class="Pp">This method is optional; the support for it was added in
    <b>DBI</b> v1.33.</p>
<p class="Pp">As noted in the discussion of <i>Driver.pm</i>, if the data
    sources can be determined by pure Perl code, do it that way. If, as in
    <b>DBD::Informix</b>, the information is obtained by a C function call, then
    you need to define a function that matches the prototype:</p>
<p class="Pp"></p>
<pre>  extern AV *dbd_dr_data_sources(SV *drh, imp_drh_t *imp_drh, SV *attrs);
</pre>
<p class="Pp">An outline implementation for <b>DBD::Informix</b> follows,
    assuming that the <span class="Li">&quot;sqgetdbs()&quot;</span> function
    call shown will return up to 100 databases names, with the pointers to each
    name in the array dbsname and the name strings themselves being stores in
    dbsarea.</p>
<p class="Pp"></p>
<pre>  AV *dbd_dr_data_sources(SV *drh, imp_drh_t *imp_drh, SV *attr)
  {
      int ndbs;
      int i;
      char *dbsname[100];
      char  dbsarea[10000];
      AV *av = Nullav;
      if (sqgetdbs(&amp;ndbs, dbsname, 100, dbsarea, sizeof(dbsarea)) == 0)
      {
          av = NewAV();
          av_extend(av, (I32)ndbs);
          sv_2mortal((SV *)av);
          for (i = 0; i &lt; ndbs; i++)
            av_store(av, i, newSVpvf(&quot;dbi:Informix:%s&quot;, dbsname[i]));
      }
      return(av);
  }
</pre>
<p class="Pp">The actual <b>DBD::Informix</b> implementation has a number of
    extra lines of code, logs function entry and exit, reports the error from
    <span class="Li">&quot;sqgetdbs()&quot;</span>, and uses
    <span class="Li">&quot;#define&quot;</span>'d constants for the array
  sizes.</p>
<p class="Pp"><i>The dbd_db_login6 method</i></p>
<p class="Pp"></p>
<pre>  int dbd_db_login6_sv(SV* dbh, imp_dbh_t* imp_dbh, SV* dbname,
                       SV* user, SV* auth, SV *attr);
  or
  int dbd_db_login6(SV* dbh, imp_dbh_t* imp_dbh, char* dbname,
                   char* user, char* auth, SV *attr);
</pre>
<p class="Pp">This function will really connect to the database. The argument
    <i>dbh</i> is the database handle. <i>imp_dbh</i> is the pointer to the
    handles private data, as is <i>imp_xxx</i> in
    <span class="Li">&quot;dbd_drv_error()&quot;</span> above. The arguments
    <i>dbname</i>, <i>user</i>, <i>auth</i> and <i>attr</i> correspond to the
    arguments of the driver handle's
    <span class="Li">&quot;connect()&quot;</span> method.</p>
<p class="Pp">You will quite often use database specific attributes here, that
    are specified in the DSN. I recommend you parse the DSN (using Perl) within
    the <span class="Li">&quot;connect()&quot;</span> method and pass the
    segments of the DSN via the attributes parameter through
    <span class="Li">&quot;_login()&quot;</span> to
    <span class="Li">&quot;dbd_db_login6()&quot;</span>.</p>
<p class="Pp">Here's how you fetch them; as an example we use <i>hostname</i>
    attribute, which can be up to 12 characters long excluding null
  terminator:</p>
<p class="Pp"></p>
<pre>  SV** svp;
  STRLEN len;
  char* hostname;
  if ( (svp = DBD_ATTRIB_GET_SVP(attr, &quot;drv_hostname&quot;, 12)) &amp;&amp; SvTRUE(*svp)) {
      hostname = SvPV(*svp, len);
      DBD_ATTRIB_DELETE(attr, &quot;drv_hostname&quot;, 12); /* avoid later STORE */
  } else {
      hostname = &quot;localhost&quot;;
  }
</pre>
<p class="Pp">If you handle any driver specific attributes in the dbd_db_login6
    method you probably want to delete them from
    <span class="Li">&quot;attr&quot;</span> (as above with DBD_ATTRIB_DELETE).
    If you don't delete your handled attributes DBI will call
    <span class="Li">&quot;STORE&quot;</span> for each attribute after the
    connect/login and this is at best redundant for attributes you have already
    processed.</p>
<p class="Pp"><b>Note: Until revision 11605 (post DBI 1.607), there was a
    problem with</b> <b>DBD_ATTRIBUTE_DELETE so unless you require a DBI version
    after 1.607</b> <b>you need to replace each DBD_ATTRIBUTE_DELETE call
    with:</b></p>
<p class="Pp"></p>
<pre>  hv_delete((HV*)SvRV(attr), key, key_len, G_DISCARD)
</pre>
<p class="Pp">Note that you can also obtain standard attributes such as
    <i>AutoCommit</i> and <i>ChopBlanks</i> from the attributes parameter, using
    <span class="Li">&quot;DBD_ATTRIB_GET_IV&quot;</span> for integer
    attributes.</p>
<p class="Pp">If, for example, your database does not support transactions but
    <i>AutoCommit</i> is set off (requesting transaction support), then you can
    emulate a 'failure to connect'.</p>
<p class="Pp">Now you should really connect to the database. In general, if the
    connection fails, it is best to ensure that all allocated resources are
    released so that the handle does not need to be destroyed separately. If you
    are successful (and possibly even if you fail but you have allocated some
    resources), you should use the following macros:</p>
<p class="Pp"></p>
<pre>  DBIc_IMPSET_on(imp_dbh);
</pre>
<p class="Pp">This indicates that the driver (implementor) has allocated
    resources in the <i>imp_dbh</i> structure and that the implementors private
    <span class="Li">&quot;dbd_db_destroy()&quot;</span> function should be
    called when the handle is destroyed.</p>
<p class="Pp"></p>
<pre>  DBIc_ACTIVE_on(imp_dbh);
</pre>
<p class="Pp">This indicates that the handle has an active connection to the
    server and that the <span class="Li">&quot;dbd_db_disconnect()&quot;</span>
    function should be called before the handle is destroyed.</p>
<p class="Pp">Note that if you do need to fail, you should report errors via the
    <i>drh</i> or <i>imp_drh</i> rather than via <i>dbh</i> or <i>imp_dbh</i>
    because <i>imp_dbh</i> will be destroyed by the failure, so errors recorded
    in that handle will not be visible to <b>DBI</b>, and hence not the user
    either.</p>
<p class="Pp">Note too, that the function is passed <i>dbh</i> and
    <i>imp_dbh</i>, and there is a macro
    <span class="Li">&quot;D_imp_drh_from_dbh&quot;</span> which can recover the
    <i>imp_drh</i> from the <i>imp_dbh</i>. However, there is no <b>DBI</b>
    macro to provide you with the <i>drh</i> given either the <i>imp_dbh</i> or
    the <i>dbh</i> or the <i>imp_drh</i> (and there's no way to recover the
    <i>dbh</i> given just the <i>imp_dbh</i>).</p>
<p class="Pp">This suggests that, despite the above notes about
    <span class="Li">&quot;dbd_drv_error()&quot;</span> taking an
    <span class="Li">&quot;SV *&quot;</span>, it may be better to have two error
    routines, one taking <i>imp_dbh</i> and one taking <i>imp_drh</i> instead.
    With care, you can factor most of the formatting code out so that these are
    small routines calling a common error formatter. See the code in
    <b>DBD::Informix</b> 1.05.00 for more information.</p>
<p class="Pp">The <span class="Li">&quot;dbd_db_login6()&quot;</span> function
    should return <i>TRUE</i> for success, <i>FALSE</i> otherwise.</p>
<p class="Pp">Drivers implemented long ago may define the five-argument function
    <span class="Li">&quot;dbd_db_login()&quot;</span> instead of
    <span class="Li">&quot;dbd_db_login6()&quot;</span>. The missing argument is
    the attributes. There are ways to work around the missing attributes, but
    they are ungainly; it is much better to use the 6-argument form. Even later
    drivers will use <span class="Li">&quot;dbd_db_login6_sv()&quot;</span>
    which provides the dbname, username and password as SVs.</p>
<p class="Pp"><i>The dbd_db_commit and dbd_db_rollback methods</i></p>
<p class="Pp"></p>
<pre>  int dbd_db_commit(SV *dbh, imp_dbh_t *imp_dbh);
  int dbd_db_rollback(SV* dbh, imp_dbh_t* imp_dbh);
</pre>
<p class="Pp">These are used for commit and rollback. They should return
    <i>TRUE</i> for success, <i>FALSE</i> for error.</p>
<p class="Pp">The arguments <i>dbh</i> and <i>imp_dbh</i> are the same as for
    <span class="Li">&quot;dbd_db_login6()&quot;</span> above; I will omit
    describing them in what follows, as they appear always.</p>
<p class="Pp">These functions should return <i>TRUE</i> for success,
    <i>FALSE</i> otherwise.</p>
<p class="Pp"><i>The dbd_db_disconnect method</i></p>
<p class="Pp">This is your private part of the
    <span class="Li">&quot;disconnect()&quot;</span> method. Any <i>dbh</i> with
    the <i>ACTIVE</i> flag on must be disconnected. (Note that you have to set
    it in <span class="Li">&quot;dbd_db_connect()&quot;</span> above.)</p>
<p class="Pp"></p>
<pre>  int dbd_db_disconnect(SV* dbh, imp_dbh_t* imp_dbh);
</pre>
<p class="Pp">The database handle will return <i>TRUE</i> for success,
    <i>FALSE</i> otherwise. In any case it should do a:</p>
<p class="Pp"></p>
<pre>  DBIc_ACTIVE_off(imp_dbh);
</pre>
<p class="Pp">before returning so <b>DBI</b> knows that
    <span class="Li">&quot;dbd_db_disconnect()&quot;</span> was executed.</p>
<p class="Pp">Note that there's nothing to stop a <i>dbh</i> being
    <i>disconnected</i> while it still have active children. If your database
    API reacts badly to trying to use an <i>sth</i> in this situation then
    you'll need to add code like this to all <i>sth</i> methods:</p>
<p class="Pp"></p>
<pre>  if (!DBIc_ACTIVE(DBIc_PARENT_COM(imp_sth)))
    return 0;
</pre>
<p class="Pp">Alternatively, you can add code to your driver to keep explicit
    track of the statement handles that exist for each database handle and
    arrange to destroy those handles before disconnecting from the database.
    There is code to do this in <b>DBD::Informix</b>. Similar comments apply to
    the driver handle keeping track of all the database handles.</p>
<p class="Pp">Note that the code which destroys the subordinate handles should
    only release the associated database resources and mark the handles
    inactive; it does not attempt to free the actual handle structures.</p>
<p class="Pp">This function should return <i>TRUE</i> for success, <i>FALSE</i>
    otherwise, but it is not clear what anything can do about a failure.</p>
<p class="Pp"><i>The dbd_db_discon_all method</i></p>
<p class="Pp"></p>
<pre>  int dbd_discon_all (SV *drh, imp_drh_t *imp_drh);
</pre>
<p class="Pp">This function may be called at shutdown time. It should make
    best-efforts to disconnect all database handles - if possible. Some
    databases don't support that, in which case you can do nothing but return
    'success'.</p>
<p class="Pp">This function should return <i>TRUE</i> for success, <i>FALSE</i>
    otherwise, but it is not clear what anything can do about a failure.</p>
<p class="Pp"><i>The dbd_db_destroy method</i></p>
<p class="Pp">This is your private part of the database handle destructor. Any
    <i>dbh</i> with the <i>IMPSET</i> flag on must be destroyed, so that you can
    safely free resources. (Note that you have to set it in
    <span class="Li">&quot;dbd_db_connect()&quot;</span> above.)</p>
<p class="Pp"></p>
<pre>  void dbd_db_destroy(SV* dbh, imp_dbh_t* imp_dbh)
  {
      DBIc_IMPSET_off(imp_dbh);
  }
</pre>
<p class="Pp">The <b>DBI</b> <i>Driver.xst</i> code will have called
    <span class="Li">&quot;dbd_db_disconnect()&quot;</span> for you, if the
    handle is still 'active', before calling
    <span class="Li">&quot;dbd_db_destroy()&quot;</span>.</p>
<p class="Pp">Before returning the function must switch <i>IMPSET</i> to off, so
    <b>DBI</b> knows that the destructor was called.</p>
<p class="Pp">A <b>DBI</b> handle doesn't keep references to its children. But
    children do keep references to their parents. So a database handle won't be
    <span class="Li">&quot;DESTROY&quot;</span>'d until all its children have
    been <span class="Li">&quot;DESTROY&quot;</span>'d.</p>
<p class="Pp"><i>The dbd_db_STORE_attrib method</i></p>
<p class="Pp">This function handles</p>
<p class="Pp"></p>
<pre>  $dbh-&gt;{$key} = $value;
</pre>
<p class="Pp">Its prototype is:</p>
<p class="Pp"></p>
<pre>  int dbd_db_STORE_attrib(SV* dbh, imp_dbh_t* imp_dbh, SV* keysv,
                          SV* valuesv);
</pre>
<p class="Pp">You do not handle all attributes; on the contrary, you should not
    handle <b>DBI</b> attributes here: leave this to <b>DBI</b>. (There are two
    exceptions, <i>AutoCommit</i> and <i>ChopBlanks</i>, which you should care
    about.)</p>
<p class="Pp">The return value is <i>TRUE</i> if you have handled the attribute
    or <i>FALSE</i> otherwise. If you are handling an attribute and something
    fails, you should call <span class="Li">&quot;dbd_drv_error()&quot;</span>,
    so <b>DBI</b> can raise exceptions, if desired. If
    <span class="Li">&quot;dbd_drv_error()&quot;</span> returns, however, you
    have a problem: the user will never know about the error, because he
    typically will not check
    <span class="Li">&quot;$dbh-&gt;errstr()&quot;</span>.</p>
<p class="Pp">I cannot recommend a general way of going on, if
    <span class="Li">&quot;dbd_drv_error()&quot;</span> returns, but there are
    examples where even the <b>DBI</b> specification expects that you
    <span class="Li">&quot;croak()&quot;</span>. (See the <i>AutoCommit</i>
    method in DBI.)</p>
<p class="Pp">If you have to store attributes, you should either use your
    private data structure <i>imp_xxx</i>, the handle hash (via
    <span class="Li">&quot;(HV*)SvRV(dbh)&quot;</span>), or use the private
    <i>imp_data</i>.</p>
<p class="Pp">The first is best for internal C values like integers or pointers
    and where speed is important within the driver. The handle hash is best for
    values the user may want to get/set via driver-specific attributes. The
    private <i>imp_data</i> is an additional
    <span class="Li">&quot;SV&quot;</span> attached to the handle. You could
    think of it as an unnamed handle attribute. It's not normally used.</p>
<p class="Pp"><i>The dbd_db_FETCH_attrib method</i></p>
<p class="Pp">This is the counterpart of
    <span class="Li">&quot;dbd_db_STORE_attrib()&quot;</span>, needed for:</p>
<p class="Pp"></p>
<pre>  $value = $dbh-&gt;{$key};
</pre>
<p class="Pp">Its prototype is:</p>
<p class="Pp"></p>
<pre>  SV* dbd_db_FETCH_attrib(SV* dbh, imp_dbh_t* imp_dbh, SV* keysv);
</pre>
<p class="Pp">Unlike all previous methods this returns an
    <span class="Li">&quot;SV&quot;</span> with the value. Note that you should
    normally execute <span class="Li">&quot;sv_2mortal()&quot;</span>, if you
    return a nonconstant value. (Constant values are
    <span class="Li">&amp;sv_undef</span>, <span class="Li">&amp;sv_no</span>
    and <span class="Li">&amp;sv_yes</span>.)</p>
<p class="Pp">Note, that <b>DBI</b> implements a caching algorithm for attribute
    values. If you think, that an attribute may be fetched, you store it in the
    <i>dbh</i> itself:</p>
<p class="Pp"></p>
<pre>  if (cacheit) /* cache value for later DBI 'quick' fetch? */
      hv_store((HV*)SvRV(dbh), key, kl, cachesv, 0);
</pre>
<p class="Pp"><i>The dbd_st_prepare method</i></p>
<p class="Pp">This is the private part of the
    <span class="Li">&quot;prepare()&quot;</span> method. Note that you <b>must
    not</b> really execute the statement here. You may, however, preparse and
    validate the statement, or do similar things.</p>
<p class="Pp"></p>
<pre>  int dbd_st_prepare(SV* sth, imp_sth_t* imp_sth, char* statement,
                     SV* attribs);
</pre>
<p class="Pp">A typical, simple, possibility is to do nothing and rely on the
    perl <span class="Li">&quot;prepare()&quot;</span> code that set the
    <i>Statement</i> attribute on the handle. This attribute can then be used by
    <span class="Li">&quot;dbd_st_execute()&quot;</span>.</p>
<p class="Pp">If the driver supports placeholders then the <i>NUM_OF_PARAMS</i>
    attribute must be set correctly by
    <span class="Li">&quot;dbd_st_prepare()&quot;</span>:</p>
<p class="Pp"></p>
<pre>  DBIc_NUM_PARAMS(imp_sth) = ...
</pre>
<p class="Pp">If you can, you should also setup attributes like
    <i>NUM_OF_FIELDS</i>, <i>NAME</i>, etc. here, but <b>DBI</b> doesn't require
    that - they can be deferred until <b>execute()</b> is called. However, if
    you do, document it.</p>
<p class="Pp">In any case you should set the <i>IMPSET</i> flag, as you did in
    <span class="Li">&quot;dbd_db_connect()&quot;</span> above:</p>
<p class="Pp"></p>
<pre>  DBIc_IMPSET_on(imp_sth);
</pre>
<p class="Pp"><i>The dbd_st_execute method</i></p>
<p class="Pp">This is where a statement will really be executed.</p>
<p class="Pp"></p>
<pre>  int dbd_st_execute(SV* sth, imp_sth_t* imp_sth);
</pre>
<p class="Pp"><span class="Li">&quot;dbd_st_execute&quot;</span> should return
    -2 for any error, -1 if the number of rows affected is unknown else it
    should be the number of affected (updated, inserted) rows.</p>
<p class="Pp">Note that you must be aware a statement may be executed
    repeatedly. Also, you should not expect that
    <span class="Li">&quot;finish()&quot;</span> will be called between two
    executions, so you might need code, like the following, near the start of
    the function:</p>
<p class="Pp"></p>
<pre>  if (DBIc_ACTIVE(imp_sth))
      dbd_st_finish(h, imp_sth);
</pre>
<p class="Pp">If your driver supports the binding of parameters (it should!),
    but the database doesn't, you must do it here. This can be done as
  follows:</p>
<p class="Pp"></p>
<pre>  SV *svp;
  char* statement = DBD_ATTRIB_GET_PV(h, &quot;Statement&quot;, 9, svp, &quot;&quot;);
  int numParam = DBIc_NUM_PARAMS(imp_sth);
  int i;
  for (i = 0; i &lt; numParam; i++)
  {
      char* value = dbd_db_get_param(sth, imp_sth, i);
      /* It is your drivers task to implement dbd_db_get_param,    */
      /* it must be setup as a counterpart of dbd_bind_ph.         */
      /* Look for '?' and replace it with 'value'.  Difficult      */
      /* task, note that you may have question marks inside        */
      /* quotes and comments the like ...  :-(                     */
      /* See DBD::mysql for an example. (Don't look too deep into  */
      /* the example, you will notice where I was lazy ...)        */
  }
</pre>
<p class="Pp">The next thing is to really execute the statement.</p>
<p class="Pp">Note that you must set the attributes <i>NUM_OF_FIELDS</i>,
    <i>NAME</i>, etc when the statement is successfully executed if the driver
    has not already done so: they may be used even before a potential
    <span class="Li">&quot;fetchrow()&quot;</span>. In particular you have to
    tell <b>DBI</b> the number of fields that the statement has, because it will
    be used by <b>DBI</b> internally. Thus the function will typically ends
    with:</p>
<p class="Pp"></p>
<pre>  if (isSelectStatement) {
      DBIc_NUM_FIELDS(imp_sth) = numFields;
      DBIc_ACTIVE_on(imp_sth);
  }
</pre>
<p class="Pp">It is important that the <i>ACTIVE</i> flag only be set for
    <span class="Li">&quot;SELECT&quot;</span> statements (or any other
    statements that can return many values from the database using a cursor-like
    mechanism). See <span class="Li">&quot;dbd_db_connect()&quot;</span> above
    for more explanations.</p>
<p class="Pp">There plans for a preparse function to be provided by <b>DBI</b>,
    but this has not reached fruition yet. Meantime, if you want to know how
    ugly it can get, try looking at the
    <span class="Li">&quot;dbd_ix_preparse()&quot;</span> in
    <b>DBD::Informix</b> <i>dbdimp.ec</i> and the related functions in
    <i>iustoken.c</i> and <i>sqltoken.c</i>.</p>
<p class="Pp"><i>The dbd_st_fetch method</i></p>
<p class="Pp">This function fetches a row of data. The row is stored in in an
    array, of <span class="Li">&quot;SV&quot;</span>'s that <b>DBI</b> prepares
    for you. This has two advantages: it is fast (you even reuse the
    <span class="Li">&quot;SV&quot;</span>'s, so they don't have to be created
    after the first <span class="Li">&quot;fetchrow()&quot;</span>), and it
    guarantees that <b>DBI</b> handles
    <span class="Li">&quot;bind_cols()&quot;</span> for you.</p>
<p class="Pp">What you do is the following:</p>
<p class="Pp"></p>
<pre>  AV* av;
  int numFields = DBIc_NUM_FIELDS(imp_sth); /* Correct, if NUM_FIELDS
      is constant for this statement. There are drivers where this is
      not the case! */
  int chopBlanks = DBIc_is(imp_sth, DBIcf_ChopBlanks);
  int i;
  if (!fetch_new_row_of_data(...)) {
      ... /* check for error or end-of-data */
      DBIc_ACTIVE_off(imp_sth); /* turn off Active flag automatically */
      return Nullav;
  }
  /* get the fbav (field buffer array value) for this row       */
  /* it is very important to only call this after you know      */
  /* that you have a row of data to return.                     */
  av = DBIc_DBISTATE(imp_sth)-&gt;get_fbav(imp_sth);
  for (i = 0; i &lt; numFields; i++) {
      SV* sv = fetch_a_field(..., i);
      if (chopBlanks &amp;&amp; SvOK(sv) &amp;&amp; type_is_blank_padded(field_type[i])) {
          /*  Remove white space from end (only) of sv  */
      }
      sv_setsv(AvARRAY(av)[i], sv); /* Note: (re)use! */
  }
  return av;
</pre>
<p class="Pp">There's no need to use a
    <span class="Li">&quot;fetch_a_field()&quot;</span> function returning an
    <span class="Li">&quot;SV*&quot;</span>. It's more common to use your
    database API functions to fetch the data as character strings and use code
    like this:</p>
<p class="Pp"></p>
<pre>  sv_setpvn(AvARRAY(av)[i], char_ptr, char_count);
</pre>
<p class="Pp"><span class="Li">&quot;NULL&quot;</span> values must be returned
    as <span class="Li">&quot;undef&quot;</span>. You can use code like
  this:</p>
<p class="Pp"></p>
<pre>  SvOK_off(AvARRAY(av)[i]);
</pre>
<p class="Pp">The function returns the <span class="Li">&quot;AV&quot;</span>
    prepared by <b>DBI</b> for success or
    <span class="Li">&quot;Nullav&quot;</span> otherwise.</p>
<p class="Pp"></p>
<pre> *FIX ME* Discuss what happens when there's no more data to fetch.
 Are errors permitted if another fetch occurs after the first fetch
 that reports no more data. (Permitted, not required.)
</pre>
<p class="Pp">If an error occurs which leaves the
    <i></i><span class="Li"><i>$sth</i></span><i></i> in a state where remaining
    rows can't be fetched then <i>Active</i> should be turned off before the
    method returns.</p>
<p class="Pp"><i>The dbd_st_finish3 method</i></p>
<p class="Pp">The <span class="Li">&quot;$sth-&gt;finish()&quot;</span> method
    can be called if the user wishes to indicate that no more rows will be
    fetched even if the database has more rows to offer, and the <b>DBI</b> code
    can call the function when handles are being destroyed. See the <b>DBI</b>
    specification for more background details.</p>
<p class="Pp">In both circumstances, the <b>DBI</b> code ends up calling the
    <span class="Li">&quot;dbd_st_finish3()&quot;</span> method (if you provide
    a mapping for <span class="Li">&quot;dbd_st_finish3()&quot;</span> in
    <i>dbdimp.h</i>), or <span class="Li">&quot;dbd_st_finish()&quot;</span>
    otherwise. The difference is that
    <span class="Li">&quot;dbd_st_finish3()&quot;</span> takes a third argument
    which is an <span class="Li">&quot;int&quot;</span> with the value 1 if it
    is being called from a <span class="Li">&quot;destroy()&quot;</span> method
    and 0 otherwise.</p>
<p class="Pp">Note that <b>DBI</b> v1.32 and earlier test on
    <span class="Li">&quot;dbd_db_finish3()&quot;</span> to call
    <span class="Li">&quot;dbd_st_finish3()&quot;</span>; if you provide
    <span class="Li">&quot;dbd_st_finish3()&quot;</span>, either define
    <span class="Li">&quot;dbd_db_finish3()&quot;</span> too, or insist on
    <b>DBI</b> v1.33 or later.</p>
<p class="Pp">All it <i>needs</i> to do is turn off the <i>Active</i> flag for
    the <i>sth</i>. It will only be called by <i>Driver.xst</i> code, if the
    driver has set <i>ACTIVE</i> to on for the <i>sth</i>.</p>
<p class="Pp">Outline example:</p>
<p class="Pp"></p>
<pre>  int dbd_st_finish3(SV* sth, imp_sth_t* imp_sth, int from_destroy) {
      if (DBIc_ACTIVE(imp_sth))
      {
          /* close cursor or equivalent action */
          DBIc_ACTIVE_off(imp_sth);
      }
      return 1;
  }
</pre>
<p class="Pp">The from_destroy parameter is true if
    <span class="Li">&quot;dbd_st_finish3()&quot;</span> is being called from
    <span class="Li">&quot;DESTROY()&quot;</span> - and so the statement is
    about to be destroyed. For many drivers there is no point in doing anything
    more than turning off the <i>Active</i> flag in this case.</p>
<p class="Pp">The function returns <i>TRUE</i> for success, <i>FALSE</i>
    otherwise, but there isn't a lot anyone can do to recover if there is an
    error.</p>
<p class="Pp"><i>The dbd_st_destroy method</i></p>
<p class="Pp">This function is the private part of the statement handle
    destructor.</p>
<p class="Pp"></p>
<pre>  void dbd_st_destroy(SV* sth, imp_sth_t* imp_sth) {
      ... /* any clean-up that's needed */
      DBIc_IMPSET_off(imp_sth); /* let DBI know we've done it   */
  }
</pre>
<p class="Pp">The <b>DBI</b> <i>Driver.xst</i> code will call
    <span class="Li">&quot;dbd_st_finish()&quot;</span> for you, if the
    <i>sth</i> has the <i>ACTIVE</i> flag set, before calling
    <span class="Li">&quot;dbd_st_destroy()&quot;</span>.</p>
<p class="Pp"><i>The dbd_st_STORE_attrib and dbd_st_FETCH_attrib methods</i></p>
<p class="Pp">These functions correspond to
    <span class="Li">&quot;dbd_db_STORE()&quot;</span> and
    <span class="Li">&quot;dbd_db_FETCH()&quot;</span> attrib above, except that
    they are for statement handles. See above.</p>
<p class="Pp"></p>
<pre>  int dbd_st_STORE_attrib(SV* sth, imp_sth_t* imp_sth, SV* keysv,
                          SV* valuesv);
  SV* dbd_st_FETCH_attrib(SV* sth, imp_sth_t* imp_sth, SV* keysv);
</pre>
<p class="Pp"><i>The dbd_bind_ph method</i></p>
<p class="Pp">This function is internally used by the
    <span class="Li">&quot;bind_param()&quot;</span> method, the
    <span class="Li">&quot;bind_param_inout()&quot;</span> method and by the
    <b>DBI</b> <i>Driver.xst</i> code if
    <span class="Li">&quot;execute()&quot;</span> is called with any bind
    parameters.</p>
<p class="Pp"></p>
<pre>  int dbd_bind_ph (SV *sth, imp_sth_t *imp_sth, SV *param,
                   SV *value, IV sql_type, SV *attribs,
                   int is_inout, IV maxlen);
</pre>
<p class="Pp">The <i>param</i> argument holds an
    <span class="Li">&quot;IV&quot;</span> with the parameter number (1, 2,
    ...). The <i>value</i> argument is the parameter value and <i>sql_type</i>
    is its type.</p>
<p class="Pp">If your driver does not support
    <span class="Li">&quot;bind_param_inout()&quot;</span> then you should
    ignore <i>maxlen</i> and croak if <i>is_inout</i> is <i>TRUE</i>.</p>
<p class="Pp">If your driver <i>does</i> support
    <span class="Li">&quot;bind_param_inout()&quot;</span> then you should note
    that <i>value</i> is the <span class="Li">&quot;SV&quot;</span> <i>after</i>
    dereferencing the reference passed to
    <span class="Li">&quot;bind_param_inout()&quot;</span>.</p>
<p class="Pp">In drivers of simple databases the function will, for example,
    store the value in a parameter array and use it later in
    <span class="Li">&quot;dbd_st_execute()&quot;</span>. See the
    <b>DBD::mysql</b> driver for an example.</p>
<p class="Pp"><i>Implementing bind_param_inout support</i></p>
<p class="Pp">To provide support for parameters bound by reference rather than
    by value, the driver must do a number of things. First, and most
    importantly, it must note the references and stash them in its own driver
    structure. Secondly, when a value is bound to a column, the driver must
    discard any previous reference bound to the column. On each execute, the
    driver must evaluate the references and internally bind the values resulting
    from the references. This is only applicable if the user writes:</p>
<p class="Pp"></p>
<pre>  $sth-&gt;execute;
</pre>
<p class="Pp">If the user writes:</p>
<p class="Pp"></p>
<pre>  $sth-&gt;execute(@values);
</pre>
<p class="Pp">then <b>DBI</b> automatically calls the binding code for each
    element of <i></i><span class="Li"><i>@values</i></span><i></i>. These calls
    are indistinguishable from explicit user calls to
    <span class="Li">&quot;bind_param()&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="C/XS_version_of_Makefile.PL"><a class="permalink" href="#C/XS_version_of_Makefile.PL">C/XS
  version of Makefile.PL</a></h2>
<p class="Pp">The <i>Makefile.PL</i> file for a C/XS driver is similar to the
    code needed for a pure Perl driver, but there are a number of extra bits of
    information needed by the build system.</p>
<p class="Pp">For example, the attributes list passed to
    <span class="Li">&quot;WriteMakefile()&quot;</span> needs to specify the
    object files that need to be compiled and built into the shared object
    (DLL). This is often, but not necessarily, just <i>dbdimp.o</i> (unless that
    should be <i>dbdimp.obj</i> because you're building on MS Windows).</p>
<p class="Pp">Note that you can reliably determine the extension of the object
    files from the <i></i><span class="Li"><i>$Config</i></span><i>{obj_ext}</i>
    values, and there are many other useful pieces of configuration information
    lurking in that hash. You get access to it with:</p>
<p class="Pp"></p>
<pre>    use Config;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Methods_which_do_not_need_to_be_written"><a class="permalink" href="#Methods_which_do_not_need_to_be_written">Methods
  which do not need to be written</a></h2>
<p class="Pp">The <b>DBI</b> code implements the majority of the methods which
    are accessed using the notation
    <span class="Li">&quot;DBI-&gt;function()&quot;</span>, the only exceptions
    being <span class="Li">&quot;DBI-&gt;connect()&quot;</span> and
    <span class="Li">&quot;DBI-&gt;data_sources()&quot;</span> which require
    support from the driver.</p>
<p class="Pp">The <b>DBI</b> code implements the following documented driver,
    database and statement functions which do not need to be written by the
    <b>DBD</b> driver writer.</p>
<dl class="Bl-tag">
  <dt>$dbh-&gt;<b>do()</b></dt>
  <dd>The default implementation of this function prepares, executes and
      destroys the statement. This can be replaced if there is a better way to
      implement this, such as <span class="Li">&quot;EXECUTE
      IMMEDIATE&quot;</span> which can sometimes be used if there are no
      parameters.</dd>
  <dt>$h-&gt;<b>errstr()</b></dt>
  <dd></dd>
  <dt>$h-&gt;<b>err()</b></dt>
  <dd></dd>
  <dt>$h-&gt;<b>state()</b></dt>
  <dd></dd>
  <dt>$h-&gt;<b>trace()</b></dt>
  <dd>The <b>DBD</b> driver does not need to worry about these routines at
    all.</dd>
  <dt>$h-&gt;{ChopBlanks}</dt>
  <dd>This attribute needs to be honored during
      <span class="Li">&quot;fetch()&quot;</span> operations, but does not need
      to be handled by the attribute handling code.</dd>
  <dt>$h-&gt;{RaiseError}</dt>
  <dd>The <b>DBD</b> driver does not need to worry about this attribute at
    all.</dd>
  <dt>$h-&gt;{PrintError}</dt>
  <dd>The <b>DBD</b> driver does not need to worry about this attribute at
    all.</dd>
  <dt>$sth-&gt;<b>bind_col()</b></dt>
  <dd>Assuming the driver uses the
      <span class="Li">&quot;DBIc_DBISTATE(imp_xxh)-&gt;get_fbav()&quot;</span>
      function (C drivers, see below), or the
      <span class="Li">&quot;$sth-&gt;_set_fbav($data)&quot;</span> method (Perl
      drivers) the driver does not need to do anything about this routine.</dd>
  <dt>$sth-&gt;<b>bind_columns()</b></dt>
  <dd>Regardless of whether the driver uses
      <span class="Li">&quot;DBIc_DBISTATE(imp_xxh)-&gt;get_fbav()&quot;</span>,
      the driver does not need to do anything about this routine as it simply
      iteratively calls
    <span class="Li">&quot;$sth-&gt;bind_col()&quot;</span>.</dd>
</dl>
<p class="Pp">The <b>DBI</b> code implements a default implementation of the
    following functions which do not need to be written by the <b>DBD</b> driver
    writer unless the default implementation is incorrect for the Driver.</p>
<dl class="Bl-tag">
  <dt>$dbh-&gt;<b>quote()</b></dt>
  <dd>This should only be written if the database does not accept the ANSI SQL
      standard for quoting strings, with the string enclosed in single quotes
      and any embedded single quotes replaced by two consecutive single quotes.
    <p class="Pp">For the two argument form of quote, you need to implement the
        <span class="Li">&quot;type_info()&quot;</span> method to provide the
        information that quote needs.</p>
  </dd>
  <dt>$dbh-&gt;<b>ping()</b></dt>
  <dd>This should be implemented as a simple efficient way to determine whether
      the connection to the database is still alive. Typically code like this:
    <p class="Pp"></p>
    <pre>  sub ping {
      my $dbh = shift;
      $sth = $dbh-&gt;prepare_cached(q{
          select * from A_TABLE_NAME where 1=0
      }) or return 0;
      $sth-&gt;execute or return 0;
      $sth-&gt;finish;
      return 1;
  }
    </pre>
    <p class="Pp">where <i>A_TABLE_NAME</i> is the name of a table that always
        exists (such as a database system catalogue).</p>
  </dd>
  <dt>$drh-&gt;default_user</dt>
  <dd>The default implementation of default_user will get the database username
      and password fields from <span class="Li">$ENV{DBI_USER}</span> and
      <span class="Li">$ENV{DBI_PASS}</span>. You can override this method. It
      is called as follows:
    <p class="Pp"></p>
    <pre>  ($user, $pass) = $drh-&gt;default_user($user, $pass, $attr)
    </pre>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METADATA_METHODS"><a class="permalink" href="#METADATA_METHODS">METADATA
  METHODS</a></h1>
<p class="Pp">The exposition above ignores the <b>DBI</b> MetaData methods. The
    metadata methods are all associated with a database handle.</p>
<section class="Ss">
<h2 class="Ss" id="Using_DBI::DBD::Metadata"><a class="permalink" href="#Using_DBI::DBD::Metadata">Using
  DBI::DBD::Metadata</a></h2>
<p class="Pp">The <b>DBI::DBD::Metadata</b> module is a good semi-automatic way
    for the developer of a <b>DBD</b> module to write the
    <span class="Li">&quot;get_info()&quot;</span> and
    <span class="Li">&quot;type_info()&quot;</span> functions quickly and
    accurately.</p>
<p class="Pp"><i>Generating the get_info method</i></p>
<p class="Pp">Prior to <b>DBI</b> v1.33, this existed as the method
    <span class="Li">&quot;write_getinfo_pm()&quot;</span> in the
    <b>DBI::DBD</b> module. From <b>DBI</b> v1.33, it exists as the method
    <span class="Li">&quot;write_getinfo_pm()&quot;</span> in the
    <b>DBI::DBD::Metadata</b> module. This discussion assumes you have
    <b>DBI</b> v1.33 or later.</p>
<p class="Pp">You examine the documentation for
    <span class="Li">&quot;write_getinfo_pm()&quot;</span> using:</p>
<p class="Pp"></p>
<pre>    perldoc DBI::DBD::Metadata
</pre>
<p class="Pp">To use it, you need a Perl <b>DBI</b> driver for your database
    which implements the <span class="Li">&quot;get_info()&quot;</span> method.
    In practice, this means you need to install <b>DBD::ODBC</b>, an ODBC driver
    manager, and an ODBC driver for your database.</p>
<p class="Pp">With the pre-requisites in place, you might type:</p>
<p class="Pp"></p>
<pre>    perl -MDBI::DBD::Metadata -we \
       &quot;write_getinfo_pm (qw{ dbi:ODBC:foo_db username password Driver })&quot;
</pre>
<p class="Pp">The procedure writes to standard output the code that should be
    added to your <i>Driver.pm</i> file and the code that should be written to
    <i>lib/DBD/Driver/GetInfo.pm</i>.</p>
<p class="Pp">You should review the output to ensure that it is sensible.</p>
<p class="Pp"><i>Generating the type_info method</i></p>
<p class="Pp">Given the idea of the
    <span class="Li">&quot;write_getinfo_pm()&quot;</span> method, it was not
    hard to devise a parallel method,
    <span class="Li">&quot;write_typeinfo_pm()&quot;</span>, which does the
    analogous job for the <b>DBI</b>
    <span class="Li">&quot;type_info_all()&quot;</span> metadata method. The
    <span class="Li">&quot;write_typeinfo_pm()&quot;</span> method was added to
    <b>DBI</b> v1.33.</p>
<p class="Pp">You examine the documentation for
    <span class="Li">&quot;write_typeinfo_pm()&quot;</span> using:</p>
<p class="Pp"></p>
<pre>    perldoc DBI::DBD::Metadata
</pre>
<p class="Pp">The setup is exactly analogous to the mechanism described in
    &quot;Generating the get_info method&quot;.</p>
<p class="Pp">With the pre-requisites in place, you might type:</p>
<p class="Pp"></p>
<pre>    perl -MDBI::DBD::Metadata -we \
       &quot;write_typeinfo_pm (qw{ dbi:ODBC:foo_db username password Driver })&quot;
</pre>
<p class="Pp">The procedure writes to standard output the code that should be
    added to your <i>Driver.pm</i> file and the code that should be written to
    <i>lib/DBD/Driver/TypeInfo.pm</i>.</p>
<p class="Pp">You should review the output to ensure that it is sensible.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Writing_DBD::Driver::db::get_info"><a class="permalink" href="#Writing_DBD::Driver::db::get_info">Writing
  DBD::Driver::db::get_info</a></h2>
<p class="Pp">If you use the <b>DBI::DBD::Metadata</b> module, then the code you
    need is generated for you.</p>
<p class="Pp">If you decide not to use the <b>DBI::DBD::Metadata</b> module, you
    should probably borrow the code from a driver that has done so (eg
    <b>DBD::Informix</b> from version 1.05 onwards) and crib the code from
    there, or look at the code that generates that module and follow that. The
    method in <i>Driver.pm</i> will be very simple; the method in
    <i>lib/DBD/Driver/GetInfo.pm</i> is not very much more complex unless your
    DBMS itself is much more complex.</p>
<p class="Pp">Note that some of the <b>DBI</b> utility methods rely on
    information from the <span class="Li">&quot;get_info()&quot;</span> method
    to perform their operations correctly. See, for example, the
    <span class="Li">&quot;quote_identifier()&quot;</span> and quote methods,
    discussed below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Writing_DBD::Driver::db::type_info_all"><a class="permalink" href="#Writing_DBD::Driver::db::type_info_all">Writing
  DBD::Driver::db::type_info_all</a></h2>
<p class="Pp">If you use the
    <span class="Li">&quot;DBI::DBD::Metadata&quot;</span> module, then the code
    you need is generated for you.</p>
<p class="Pp">If you decide not to use the
    <span class="Li">&quot;DBI::DBD::Metadata&quot;</span> module, you should
    probably borrow the code from a driver that has done so (eg
    <span class="Li">&quot;DBD::Informix&quot;</span> from version 1.05 onwards)
    and crib the code from there, or look at the code that generates that module
    and follow that. The method in <i>Driver.pm</i> will be very simple; the
    method in <i>lib/DBD/Driver/TypeInfo.pm</i> is not very much more complex
    unless your DBMS itself is much more complex.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Writing_DBD::Driver::db::type_info"><a class="permalink" href="#Writing_DBD::Driver::db::type_info">Writing
  DBD::Driver::db::type_info</a></h2>
<p class="Pp">The guidelines on writing this method are still not really clear.
    No sample implementation is available.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Writing_DBD::Driver::db::table_info"><a class="permalink" href="#Writing_DBD::Driver::db::table_info">Writing
  DBD::Driver::db::table_info</a></h2>
<pre> *FIX ME* The guidelines on writing this method have not been written yet.
 No sample implementation is available.
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Writing_DBD::Driver::db::column_info"><a class="permalink" href="#Writing_DBD::Driver::db::column_info">Writing
  DBD::Driver::db::column_info</a></h2>
<pre> *FIX ME* The guidelines on writing this method have not been written yet.
 No sample implementation is available.
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Writing_DBD::Driver::db::primary_key_info"><a class="permalink" href="#Writing_DBD::Driver::db::primary_key_info">Writing
  DBD::Driver::db::primary_key_info</a></h2>
<pre> *FIX ME* The guidelines on writing this method have not been written yet.
 No sample implementation is available.
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Writing_DBD::Driver::db::primary_key"><a class="permalink" href="#Writing_DBD::Driver::db::primary_key">Writing
  DBD::Driver::db::primary_key</a></h2>
<pre> *FIX ME* The guidelines on writing this method have not been written yet.
 No sample implementation is available.
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Writing_DBD::Driver::db::foreign_key_info"><a class="permalink" href="#Writing_DBD::Driver::db::foreign_key_info">Writing
  DBD::Driver::db::foreign_key_info</a></h2>
<pre> *FIX ME* The guidelines on writing this method have not been written yet.
 No sample implementation is available.
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Writing_DBD::Driver::db::tables"><a class="permalink" href="#Writing_DBD::Driver::db::tables">Writing
  DBD::Driver::db::tables</a></h2>
<p class="Pp">This method generates an array of names in a format suitable for
    being embedded in SQL statements in places where a table name is
  expected.</p>
<p class="Pp">If your database hews close enough to the SQL standard or if you
    have implemented an appropriate
    <span class="Li">&quot;table_info()&quot;</span> function and and the
    appropriate <span class="Li">&quot;quote_identifier()&quot;</span> function,
    then the <b>DBI</b> default version of this method will work for your driver
    too.</p>
<p class="Pp">Otherwise, you have to write a function yourself, such as:</p>
<p class="Pp"></p>
<pre>    sub tables
    {
        my($dbh, $cat, $sch, $tab, $typ) = @_;
        my(@res);
        my($sth) = $dbh-&gt;table_info($cat, $sch, $tab, $typ);
        my(@arr);
        while (@arr = $sth-&gt;fetchrow_array)
        {
            push @res, $dbh-&gt;quote_identifier($arr[0], $arr[1], $arr[2]);
        }
        return @res;
    }
</pre>
<p class="Pp">See also the default implementation in <i>DBI.pm</i>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Writing_DBD::Driver::db::quote"><a class="permalink" href="#Writing_DBD::Driver::db::quote">Writing
  DBD::Driver::db::quote</a></h2>
<p class="Pp">This method takes a value and converts it into a string suitable
    for embedding in an SQL statement as a string literal.</p>
<p class="Pp">If your DBMS accepts the SQL standard notation for strings (single
    quotes around the string as a whole with any embedded single quotes doubled
    up), then you do not need to write this method as <b>DBI</b> provides a
    default method that does it for you.</p>
<p class="Pp">If your DBMS uses an alternative notation or escape mechanism,
    then you need to provide an equivalent function. For example, suppose your
    DBMS used C notation with double quotes around the string and backslashes
    escaping both double quotes and backslashes themselves. Then you might write
    the function as:</p>
<p class="Pp"></p>
<pre>    sub quote
    {
        my($dbh, $str) = @_;
        $str =~ s/[&quot;\\]/\\$&amp;/gmo;
        return qq{&quot;$str&quot;};
    }
</pre>
<p class="Pp">Handling newlines and other control characters is left as an
    exercise for the reader.</p>
<p class="Pp">This sample method ignores the
    <i></i><span class="Li"><i>$data_type</i></span><i></i> indicator which is
    the optional second argument to the method.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Writing_DBD::Driver::db::quote_identifier"><a class="permalink" href="#Writing_DBD::Driver::db::quote_identifier">Writing
  DBD::Driver::db::quote_identifier</a></h2>
<p class="Pp">This method is called to ensure that the name of the given table
    (or other database object) can be embedded into an SQL statement without
    danger of misinterpretation. The result string should be usable in the text
    of an SQL statement as the identifier for a table.</p>
<p class="Pp">If your DBMS accepts the SQL standard notation for quoted
    identifiers (which uses double quotes around the identifier as a whole, with
    any embedded double quotes doubled up) and accepts
    <i>&quot;schema&quot;.&quot;identifier&quot;</i> (and
    <i>&quot;catalog&quot;.&quot;schema&quot;.&quot;identifier&quot;</i> when a
    catalog is specified), then you do not need to write this method as
    <b>DBI</b> provides a default method that does it for you.</p>
<p class="Pp">In fact, even if your DBMS does not handle exactly that notation
    but you have implemented the <span class="Li">&quot;get_info()&quot;</span>
    method and it gives the correct responses, then it will work for you. If
    your database is fussier, then you need to implement your own version of the
    function.</p>
<p class="Pp">For example, <b>DBD::Informix</b> has to deal with an environment
    variable <i>DELIMIDENT</i>. If it is not set, then the DBMS treats names
    enclosed in double quotes as strings rather than names, which is usually a
    syntax error. Additionally, the catalog portion of the name is separated
    from the schema and table by a different delimiter (colon instead of dot),
    and the catalog portion is never enclosed in quotes. (Fortunately, valid
    strings for the catalog will never contain weird characters that might need
    to be escaped, unless you count dots, dashes, slashes and at-signs as
    weird.) Finally, an Informix database can contain objects that cannot be
    accessed because they were created by a user with the <i>DELIMIDENT</i>
    environment variable set, but the current user does not have it set. By
    design choice, the <span class="Li">&quot;quote_identifier()&quot;</span>
    method encloses those identifiers in double quotes anyway, which generally
    triggers a syntax error, and the metadata methods which generate lists of
    tables etc omit those identifiers from the result sets.</p>
<p class="Pp"></p>
<pre>    sub quote_identifier
    {
        my($dbh, $cat, $sch, $obj) = @_;
        my($rv) = &quot;&quot;;
        my($qq) = (defined $ENV{DELIMIDENT}) ? '&quot;' : '';
        $rv .= qq{$cat:} if (defined $cat);
        if (defined $sch)
        {
            if ($sch !~ m/^\w+$/o)
            {
                $qq = '&quot;';
                $sch =~ s/$qq/$qq$qq/gm;
            }
            $rv .= qq{$qq$sch$qq.};
        }
        if (defined $obj)
        {
            if ($obj !~ m/^\w+$/o)
            {
                $qq = '&quot;';
                $obj =~ s/$qq/$qq$qq/gm;
            }
            $rv .= qq{$qq$obj$qq};
        }
        return $rv;
    }
</pre>
<p class="Pp">Handling newlines and other control characters is left as an
    exercise for the reader.</p>
<p class="Pp">Note that there is an optional fourth parameter to this function
    which is a reference to a hash of attributes; this sample implementation
    ignores that.</p>
<p class="Pp">This sample implementation also ignores the single-argument
    variant of the method.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TRACING"><a class="permalink" href="#TRACING">TRACING</a></h1>
<p class="Pp">Tracing in DBI is controlled with a combination of a trace level
    and a set of flags which together are known as the trace settings. The trace
    settings are stored in a single integer and divided into levels and flags by
    a set of masks (<span class="Li">&quot;DBIc_TRACE_LEVEL_MASK&quot;</span>
    and <span class="Li">&quot;DBIc_TRACE_FLAGS_MASK&quot;</span>).</p>
<p class="Pp">Each handle has it's own trace settings and so does the DBI. When
    you call a method the DBI merges the handles settings into its own for the
    duration of the call: the trace flags of the handle are OR'd into the trace
    flags of the DBI, and if the handle has a higher trace level then the DBI
    trace level is raised to match it. The previous DBI trace settings are
    restored when the called method returns.</p>
<section class="Ss">
<h2 class="Ss" id="Trace_Level"><a class="permalink" href="#Trace_Level">Trace
  Level</a></h2>
<p class="Pp">The trace level is the first 4 bits of the trace settings (masked
    by <span class="Li">&quot;DBIc_TRACE_FLAGS_MASK&quot;</span>) and represents
    trace levels of 1 to 15. Do not output anything at trace levels less than 3
    as they are reserved for DBI.</p>
<p class="Pp">For advice on what to output at each level see &quot;Trace
    Levels&quot; in DBI.</p>
<p class="Pp">To test for a trace level you can use the
    <span class="Li">&quot;DBIc_TRACE_LEVEL&quot;</span> macro like this:</p>
<p class="Pp"></p>
<pre>  if (DBIc_TRACE_LEVEL(imp_xxh) &gt;= 2) {
      PerlIO_printf(DBIc_LOGPIO(imp_xxh), &quot;foobar&quot;);
  }
</pre>
<p class="Pp">Also <b>note</b> the use of PerlIO_printf which you should always
    use for tracing and never the C <span class="Li">&quot;stdio.h&quot;</span>
    I/O functions.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Trace_Flags"><a class="permalink" href="#Trace_Flags">Trace
  Flags</a></h2>
<p class="Pp">Trace flags are used to enable tracing of specific activities
    within the DBI and drivers. The DBI defines some trace flags and drivers can
    define others. DBI trace flag names begin with a capital letter and driver
    specific names begin with a lowercase letter. For a list of DBI defined
    trace flags see &quot;Trace Flags&quot; in DBI.</p>
<p class="Pp">If you want to use private trace flags you'll probably want to be
    able to set them by name. Drivers are expected to override the
    parse_trace_flag (note the singular) and check if
    <span class="Li">$trace_flag_name</span> is a driver specific trace flags
    and, if not, then call the DBIs default <b>parse_trace_flag()</b>. To do
    that you'll need to define a <b>parse_trace_flag()</b> method like this:</p>
<p class="Pp"></p>
<pre>  sub parse_trace_flag {
      my ($h, $name) = @_;
      return 0x01000000 if $name eq 'foo';
      return 0x02000000 if $name eq 'bar';
      return 0x04000000 if $name eq 'baz';
      return 0x08000000 if $name eq 'boo';
      return 0x10000000 if $name eq 'bop';
      return $h-&gt;SUPER::parse_trace_flag($name);
  }
</pre>
<p class="Pp">All private flag names must be lowercase, and all private flags
    must be in the top 8 of the 32 bits of
    <span class="Li">&quot;DBIc_TRACE_FLAGS(imp)&quot;</span> i.e.,
  0xFF000000.</p>
<p class="Pp">If you've defined a <b>parse_trace_flag()</b> method in ::db
    you'll also want it in ::st, so just alias it in:</p>
<p class="Pp"></p>
<pre>  *parse_trace_flag = \&amp;DBD::foo:db::parse_trace_flag;
</pre>
<p class="Pp">You may want to act on the current 'SQL' trace flag that DBI
    defines to output SQL prepared/executed as DBI currently does not do SQL
    tracing.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Trace_Macros"><a class="permalink" href="#Trace_Macros">Trace
  Macros</a></h2>
<p class="Pp">Access to the trace level and trace flags is via a set of
  macros.</p>
<p class="Pp"></p>
<pre>  DBIc_TRACE_SETTINGS(imp) returns the trace settings
  DBIc_TRACE_LEVEL(imp) returns the trace level
  DBIc_TRACE_FLAGS(imp) returns the trace flags
  DBIc_TRACE(imp, flags, flaglevel, level)
  e.g.,
  DBIc_TRACE(imp, 0, 0, 4)
    if level &gt;= 4
  DBIc_TRACE(imp, DBDtf_FOO, 2, 4)
    if tracing DBDtf_FOO &amp; level&gt;=2 or level&gt;=4
  DBIc_TRACE(imp, DBDtf_FOO, 2, 0)
    as above but never trace just due to level
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="WRITING_AN_EMULATION_LAYER_FOR_AN_OLD_PERL_INTERFACE"><a class="permalink" href="#WRITING_AN_EMULATION_LAYER_FOR_AN_OLD_PERL_INTERFACE">WRITING
  AN EMULATION LAYER FOR AN OLD PERL INTERFACE</a></h1>
<p class="Pp">Study <i>Oraperl.pm</i> (supplied with <b>DBD::Oracle</b>) and
    <i>Ingperl.pm</i> (supplied with <b>DBD::Ingres</b>) and the corresponding
    <i>dbdimp.c</i> files for ideas.</p>
<p class="Pp">Note that the emulation code sets
    <span class="Li">&quot;$dbh-&gt;{CompatMode} = 1;&quot;</span> for each
    connection so that the internals of the driver can implement behaviour
    compatible with the old interface when dealing with those handles.</p>
<section class="Ss">
<h2 class="Ss" id="Setting_emulation_perl_variables"><a class="permalink" href="#Setting_emulation_perl_variables">Setting
  emulation perl variables</a></h2>
<p class="Pp">For example, ingperl has a
    <i></i><span class="Li"><i>$sql_rowcount</i></span><i></i> variable. Rather
    than try to manually update this in <i>Ingperl.pm</i> it can be done faster
    in C code. In <span class="Li">&quot;dbd_init()&quot;</span>:</p>
<p class="Pp"></p>
<pre>  sql_rowcount = perl_get_sv(&quot;Ingperl::sql_rowcount&quot;, GV_ADDMULTI);
</pre>
<p class="Pp">In the relevant places do:</p>
<p class="Pp"></p>
<pre>  if (DBIc_COMPAT(imp_sth))     /* only do this for compatibility mode handles */
      sv_setiv(sql_rowcount, the_row_count);
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="OTHER_MISCELLANEOUS_INFORMATION"><a class="permalink" href="#OTHER_MISCELLANEOUS_INFORMATION">OTHER
  MISCELLANEOUS INFORMATION</a></h1>
<section class="Ss">
<h2 class="Ss" id="The_imp_xyz_t_types"><a class="permalink" href="#The_imp_xyz_t_types">The
  imp_xyz_t types</a></h2>
<p class="Pp">Any handle has a corresponding C structure filled with private
    data. Some of this data is reserved for use by <b>DBI</b> (except for using
    the DBIc macros below), some is for you. See the description of the
    <i>dbdimp.h</i> file above for examples. Most functions in <i>dbdimp.c</i>
    are passed both the handle <span class="Li">&quot;xyz&quot;</span> and a
    pointer to <span class="Li">&quot;imp_xyz&quot;</span>. In rare cases,
    however, you may use the following macros:</p>
<dl class="Bl-tag">
  <dt id="D_imp_dbh(dbh)"><a class="permalink" href="#D_imp_dbh(dbh)">D_imp_dbh(dbh)</a></dt>
  <dd>Given a function argument <i>dbh</i>, declare a variable <i>imp_dbh</i>
      and initialize it with a pointer to the handles private data. Note: This
      must be a part of the function header, because it declares a
    variable.</dd>
  <dt id="D_imp_sth(sth)"><a class="permalink" href="#D_imp_sth(sth)">D_imp_sth(sth)</a></dt>
  <dd>Likewise for statement handles.</dd>
  <dt id="D_imp_xxx(h)"><a class="permalink" href="#D_imp_xxx(h)">D_imp_xxx(h)</a></dt>
  <dd>Given any handle, declare a variable <i>imp_xxx</i> and initialize it with
      a pointer to the handles private data. It is safe, for example, to cast
      <i>imp_xxx</i> to <span class="Li">&quot;imp_dbh_t*&quot;</span>, if
      <span class="Li">&quot;DBIc_TYPE(imp_xxx) == DBIt_DB&quot;</span>. (You
      can also call <span class="Li">&quot;sv_derived_from(h,
      &quot;DBI::db&quot;)&quot;</span>, but that's much slower.)</dd>
  <dt id="D_imp_dbh_from_sth"><a class="permalink" href="#D_imp_dbh_from_sth">D_imp_dbh_from_sth</a></dt>
  <dd>Given a <i>imp_sth</i>, declare a variable <i>imp_dbh</i> and initialize
      it with a pointer to the parent database handle's implementors
    structure.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_DBIc_IMPSET_on"><a class="permalink" href="#Using_DBIc_IMPSET_on">Using
  DBIc_IMPSET_on</a></h2>
<p class="Pp">The driver code which initializes a handle should use
    <span class="Li">&quot;DBIc_IMPSET_on()&quot;</span> as soon as its state is
    such that the cleanup code must be called. When this happens is determined
    by your driver code.</p>
<p class="Pp"><b>Failure to call this can lead to corruption of data
    structures.</b></p>
<p class="Pp">For example, <b>DBD::Informix</b> maintains a linked list of
    database handles in the driver, and within each handle, a linked list of
    statements. Once a statement is added to the linked list, it is crucial that
    it is cleaned up (removed from the list). When
    <i></i><b><i>DBIc_IMPSET_on()</i></b><i></i> was being called too late, it
    was able to cause all sorts of problems.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_"><a class="permalink" href="#Using_">Using
  <b>DBIc_is()</b>, <b>DBIc_has()</b>, <b>DBIc_on()</b> and
  <b>DBIc_off()</b></a></h2>
<p class="Pp">Once upon a long time ago, the only way of handling the internal
    <b>DBI</b> boolean flags/attributes was through macros such as:</p>
<p class="Pp"></p>
<pre>  DBIc_WARN       DBIc_WARN_on        DBIc_WARN_off
  DBIc_COMPAT     DBIc_COMPAT_on      DBIc_COMPAT_off
</pre>
<p class="Pp">Each of these took an <i>imp_xxh</i> pointer as an argument.</p>
<p class="Pp">Since then, new attributes have been added such as
    <i>ChopBlanks</i>, <i>RaiseError</i> and <i>PrintError</i>, and these do not
    have the full set of macros. The approved method for handling these is now
    the four macros:</p>
<p class="Pp"></p>
<pre>  DBIc_is(imp, flag)
  DBIc_has(imp, flag)       an alias for DBIc_is
  DBIc_on(imp, flag)
  DBIc_off(imp, flag)
  DBIc_set(imp, flag, on)   set if on is true, else clear
</pre>
<p class="Pp">Consequently, the <span class="Li">&quot;DBIc_XXXXX&quot;</span>
    family of macros is now mostly deprecated and new drivers should avoid using
    them, even though the older drivers will probably continue to do so for
    quite a while yet. However...</p>
<p class="Pp">There is an <i>important exception</i> to that. The <i>ACTIVE</i>
    and <i>IMPSET</i> flags should be set via the
    <span class="Li">&quot;DBIc_ACTIVE_on()&quot;</span> and
    <span class="Li">&quot;DBIc_IMPSET_on()&quot;</span> macros, and unset via
    the <span class="Li">&quot;DBIc_ACTIVE_off()&quot;</span> and
    <span class="Li">&quot;DBIc_IMPSET_off()&quot;</span> macros.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_the_"><a class="permalink" href="#Using_the_">Using the
  <b>get_fbav()</b> method</a></h2>
<p class="Pp"><b>THIS IS CRITICAL for C/XS drivers</b>.</p>
<p class="Pp">The <span class="Li">&quot;$sth-&gt;bind_col()&quot;</span> and
    <span class="Li">&quot;$sth-&gt;bind_columns()&quot;</span> documented in
    the <b>DBI</b> specification do not have to be implemented by the driver
    writer because <b>DBI</b> takes care of the details for you.</p>
<p class="Pp">However, the key to ensuring that bound columns work is to call
    the function
    <span class="Li">&quot;DBIc_DBISTATE(imp_xxh)-&gt;get_fbav()&quot;</span> in
    the code which fetches a row of data.</p>
<p class="Pp">This returns an <span class="Li">&quot;AV&quot;</span>, and each
    element of the <span class="Li">&quot;AV&quot;</span> contains the
    <span class="Li">&quot;SV&quot;</span> which should be set to contain the
    returned data.</p>
<p class="Pp">The pure Perl equivalent is the
    <span class="Li">&quot;$sth-&gt;_set_fbav($data)&quot;</span> method, as
    described in the part on pure Perl drivers.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Casting_strings_to_Perl_types_based_on_a_"><a class="permalink" href="#Casting_strings_to_Perl_types_based_on_a_">Casting
  strings to Perl types based on a SQL type</a></h2>
<p class="Pp">DBI from 1.611 (and DBIXS_REVISION 13606) defines the
    sql_type_cast_svpv method which may be used to cast a string representation
    of a value to a more specific Perl type based on a SQL type. You should
    consider using this method when processing bound column data as it provides
    some support for the TYPE bind_col attribute which is rarely used in
    drivers.</p>
<p class="Pp"></p>
<pre>  int sql_type_cast_svpv(pTHX_ SV *sv, int sql_type, U32 flags, void *v)
</pre>
<p class="Pp"><span class="Li">&quot;sv&quot;</span> is what you would like
    cast, <span class="Li">&quot;sql_type&quot;</span> is one of the DBI defined
    SQL types (e.g., <span class="Li">&quot;SQL_INTEGER&quot;</span>) and
    <span class="Li">&quot;flags&quot;</span> is a bitmask as follows:</p>
<dl class="Bl-tag">
  <dt id="DBIstcf_STRICT"><a class="permalink" href="#DBIstcf_STRICT">DBIstcf_STRICT</a></dt>
  <dd>If set this indicates you want an error state returned if the cast cannot
      be performed.</dd>
  <dt id="DBIstcf_DISCARD_STRING"><a class="permalink" href="#DBIstcf_DISCARD_STRING">DBIstcf_DISCARD_STRING</a></dt>
  <dd>If set and the pv portion of the <span class="Li">&quot;sv&quot;</span> is
      cast then this will cause sv's pv to be freed up.</dd>
</dl>
<p class="Pp">sql_type_cast_svpv returns the following states:</p>
<p class="Pp"></p>
<pre> -2 sql_type is not handled - sv not changed
 -1 sv is undef, sv not changed
  0 sv could not be cast cleanly and DBIstcf_STRICT was specified
  1 sv could not be case cleanly and DBIstcf_STRICT was not specified
  2 sv was cast ok
</pre>
<p class="Pp">The current implementation of sql_type_cast_svpv supports
    <span class="Li">&quot;SQL_INTEGER&quot;</span>,
    <span class="Li">&quot;SQL_DOUBLE&quot;</span> and
    <span class="Li">&quot;SQL_NUMERIC&quot;</span>.
    <span class="Li">&quot;SQL_INTEGER&quot;</span> uses sv_2iv and hence may
    set IV, UV or NV depending on the number.
    <span class="Li">&quot;SQL_DOUBLE&quot;</span> uses sv_2nv so may set NV and
    <span class="Li">&quot;SQL_NUMERIC&quot;</span> will set IV or UV or NV.</p>
<p class="Pp">DBIstcf_STRICT should be implemented as the StrictlyTyped
    attribute and DBIstcf_DISCARD_STRING implemented as the DiscardString
    attribute to the bind_col method and both default to off.</p>
<p class="Pp">See DBD::Oracle for an example of how this is used.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SUBCLASSING_DBI_DRIVERS"><a class="permalink" href="#SUBCLASSING_DBI_DRIVERS">SUBCLASSING
  DBI DRIVERS</a></h1>
<p class="Pp">This is definitely an open subject. It can be done, as
    demonstrated by the <b>DBD::File</b> driver, but it is not as simple as one
    might think.</p>
<p class="Pp">(Note that this topic is different from subclassing the
    <b>DBI</b>. For an example of that, see the <i>t/subclass.t</i> file
    supplied with the <b>DBI</b>.)</p>
<p class="Pp">The main problem is that the <i>dbh</i>'s and <i>sth</i>'s that
    your <span class="Li">&quot;connect()&quot;</span> and
    <span class="Li">&quot;prepare()&quot;</span> methods return are not
    instances of your <b>DBD::Driver::db</b> or <b>DBD::Driver::st</b> packages,
    they are not even derived from it. Instead they are instances of the
    <b>DBI::db</b> or <b>DBI::st</b> classes or a derived subclass. Thus, if you
    write a method <span class="Li">&quot;mymethod()&quot;</span> and do a</p>
<p class="Pp"></p>
<pre>  $dbh-&gt;mymethod()
</pre>
<p class="Pp">then the autoloader will search for that method in the package
    <b>DBI::db</b>. Of course you can instead to a</p>
<p class="Pp"></p>
<pre>  $dbh-&gt;func('mymethod')
</pre>
<p class="Pp">and that will indeed work, even if
    <span class="Li">&quot;mymethod()&quot;</span> is inherited, but not without
    additional work. Setting <i></i><span class="Li"><i>@ISA</i></span><i></i>
    is not sufficient.</p>
<section class="Ss">
<h2 class="Ss" id="Overwriting_methods"><a class="permalink" href="#Overwriting_methods">Overwriting
  methods</a></h2>
<p class="Pp">The first problem is, that the
    <span class="Li">&quot;connect()&quot;</span> method has no idea of
    subclasses. For example, you cannot implement base class and subclass in the
    same file: The <span class="Li">&quot;install_driver()&quot;</span> method
    wants to do a</p>
<p class="Pp"></p>
<pre>  require DBD::Driver;
</pre>
<p class="Pp">In particular, your subclass <b>has</b> to be a separate driver,
    from the view of <b>DBI</b>, and you cannot share driver handles.</p>
<p class="Pp">Of course that's not much of a problem. You should even be able to
    inherit the base classes <span class="Li">&quot;connect()&quot;</span>
    method. But you cannot simply overwrite the method, unless you do something
    like this, quoted from <b>DBD::CSV</b>:</p>
<p class="Pp"></p>
<pre>  sub connect ($$;$$$) {
      my ($drh, $dbname, $user, $auth, $attr) = @_;
      my $this = $drh-&gt;DBD::File::dr::connect($dbname, $user, $auth, $attr);
      if (!exists($this-&gt;{csv_tables})) {
          $this-&gt;{csv_tables} = {};
      }
      $this;
  }
</pre>
<p class="Pp">Note that we cannot do a</p>
<p class="Pp"></p>
<pre>  $drh-&gt;SUPER::connect($dbname, $user, $auth, $attr);
</pre>
<p class="Pp">as we would usually do in a an OO environment, because
    <i></i><span class="Li"><i>$drh</i></span><i></i> is an instance of
    <b>DBI::dr</b>. And note, that the
    <span class="Li">&quot;connect()&quot;</span> method of <b>DBD::File</b> is
    able to handle subclass attributes. See the description of Pure Perl drivers
    above.</p>
<p class="Pp">It is essential that you always call superclass method in the
    above manner. However, that should do.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Attribute_handling"><a class="permalink" href="#Attribute_handling">Attribute
  handling</a></h2>
<p class="Pp">Fortunately the <b>DBI</b> specifications allow a simple, but
    still performant way of handling attributes. The idea is based on the
    convention that any driver uses a prefix <i>driver_</i> for its private
    methods. Thus it's always clear whether to pass attributes to the super
    class or not. For example, consider this
    <span class="Li">&quot;STORE()&quot;</span> method from the <b>DBD::CSV</b>
    class:</p>
<p class="Pp"></p>
<pre>  sub STORE {
      my ($dbh, $attr, $val) = @_;
      if ($attr !~ /^driver_/) {
          return $dbh-&gt;DBD::File::db::STORE($attr, $val);
      }
      if ($attr eq 'driver_foo') {
      ...
  }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp">Jonathan Leffler &lt;jleffler@us.ibm.com&gt; (previously
    &lt;jleffler@informix.com&gt;), Jochen Wiedmann &lt;joe@ispsoft.de&gt;,
    Steffen Goeldner &lt;sgoeldner@cpan.org&gt;, and Tim Bunce
    &lt;dbi-users@perl.org&gt;.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2016-04-21</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

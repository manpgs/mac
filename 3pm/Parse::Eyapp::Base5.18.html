<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Parse::Eyapp::Base(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Parse::Eyapp::Base(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Parse::Eyapp::Base(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Parse::Eyapp::Base - Miscellaneous support functions for
    Parse::Eyapp</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
  use Parse::Eyapp::Base qw(:all)
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="INTRODUCTION"><a class="permalink" href="#INTRODUCTION">INTRODUCTION</a></h1>
<p class="Pp"><span class="Li">&quot;Parse::Eyapp::Base&quot;</span> holds a set
    of utility functions that give support to the other modules that made
    <span class="Li">&quot;Parse::Eyapp&quot;</span>. Several of them are
    related to the dynamic use of methods and subroutines.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUBROUTINES"><a class="permalink" href="#SUBROUTINES">SUBROUTINES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Function__insert_method_"><a class="permalink" href="#Function__insert_method_">Function
  &quot;insert_method&quot;</a></h2>
<p class="Pp">Function <span class="Li">&quot;insert_method&quot;</span>
    receives as arguments a list of class names, the name of the method that
    will be inserted in such classes and a reference to the code implementing
    such method.</p>
<p class="Pp"></p>
<pre>
          insert_method( qw{CLASS1 CLASS2 ... }, 'subname', sub { ... } )
</pre>
<p class="Pp">It inserts the method in the specified classes. A second way to
    call it is without the last argument, the handler:</p>
<p class="Pp"></p>
<pre>
          insert_method( qw{CLASS1 CLASS2 ... }, 'subname' )
</pre>
<p class="Pp">In such case the function is deleted from all the specified
    classes and it no longer exists.</p>
<p class="Pp">The caller class is assumed if no classes are specified:</p>
<p class="Pp"></p>
<pre>
          insert_method('subname', sub { ... } )
</pre>
<p class="Pp">See the following session with the debugger:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/src/perl/YappWithDefaultAction/lib/Parse/Eyapp$ perl -wde 0
  main::(-e:1):   0
    DB&lt;1&gt; use Parse::Eyapp::Base qw(:all)
    DB&lt;2&gt; insert_method( qw{PLUS MINUS TIMES }, 'printclass', sub { print &quot;$_[0]\n&quot; } )
    DB&lt;3&gt; $_-&gt;printclass for qw{PLUS MINUS TIMES }
  PLUS
  MINUS
  TIMES

    DB&lt;4&gt; insert_method( qw{PLUS MINUS TIMES }, 'printclass')
    DB&lt;5&gt; print $_-&gt;can('printclass')?&quot;Yes\n&quot;:&quot;No\n&quot;  for qw{PLUS MINUS TIMES }
  No
  No
  No
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Function__insert_function_"><a class="permalink" href="#Function__insert_function_">Function
  &quot;insert_function&quot;</a></h2>
<p class="Pp">It works as <span class="Li">&quot;insert_method&quot;</span> (see
    section &quot;Function insert_method&quot;), only that instead of classes
    receives the full names of the functions to install and a reference to the
    code implementing such function. See an example of call:</p>
<p class="Pp"></p>
<pre>
  insert_function(
    qw{ FUNCTIONCALL::type_info VARARRAY::type_info VAR::type_info },
    \&amp;type_info
  );
</pre>
<p class="Pp">When the package is unspecified the caller package is assumed. See
    the following example:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/src/perl/YappWithDefaultAction/lib/Parse/Eyapp$ perl -wde 0
  main::(-e:1):   0
    DB&lt;1&gt; use Parse::Eyapp::Base qw(:all)
    DB&lt;2&gt; insert_function('Tutu::tata', 'titi', sub{ print &quot;Inside titi\n&quot;})
    DB&lt;3&gt; titi()
  Inside titi

    DB&lt;4&gt; Tutu::tata()
  Inside titi
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Function__empty_method_"><a class="permalink" href="#Function__empty_method_">Function
  &quot;empty_method&quot;</a></h2>
<p class="Pp">The call to</p>
<p class="Pp"></p>
<pre>
                           empty_method(qw{CLASSES ... }, 'subname')
</pre>
<p class="Pp">is equivalent to</p>
<p class="Pp"></p>
<pre>
                          insert_method(qw{CLASSES ... }, 'subname', sub {})
</pre>
<p class="Pp">Consequently <span class="Li">&quot;empty_method&quot;</span>
    replaces the current <span class="Li">&quot;CODE&quot;</span> for function
    <span class="Li">&quot;subname&quot;</span> by an empty subroutine</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Function__push_method_"><a class="permalink" href="#Function__push_method_">Function
  &quot;push_method&quot;</a></h2>
<p class="Pp">The call</p>
<p class="Pp"></p>
<pre>
      push_method( qw{CLASS1 CLASS2 ... }, 'subname', sub { ... } )
</pre>
<p class="Pp">saves the current methods
    <span class="Li">&quot;CLASS1::subname&quot;</span>,
    <span class="Li">&quot;CLASS2::subname&quot;</span>, etc. in a stack and
    proceeds to install the new handler specified through the last argument. See
    an example:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/src/perl/YappWithDefaultAction/lib/Parse/Eyapp$ perl -wde 0
  main::(-e:1):   0
    DB&lt;1&gt; use Parse::Eyapp::Base qw(:all)
    DB&lt;2&gt; sub Tutu::titi { print &quot;Inside first Tutu::titi!\n&quot; }
    DB&lt;3&gt; push_method('Tutu', 'titi', sub { print &quot;New titi!\n&quot; })
    DB&lt;4&gt; Tutu::titi()
  New titi!

    DB&lt;5&gt; pop_method('Tutu', 'titi')
    DB&lt;6&gt; Tutu::titi()
  Inside first Tutu::titi!

    DB&lt;7&gt; push_method('Tutu', 'titi') # No handler: sub Tutu::titi no longer exists
    DB&lt;8&gt; print &quot;Can't titi\n&quot; unless Tutu-&gt;can('titi')
  Can't titi

    DB&lt;9&gt; pop_method('Tutu', 'titi') # Give me the old sub
    DB&lt;10&gt; Tutu::titi()
  Inside first Tutu::titi!
</pre>
<p class="Pp">The caller class is assumed if no classes are specified.</p>
<p class="Pp">In list context the
    <span class="Li">&quot;push_method&quot;</span> function returns an array of
    pointers to the old versions of the function. In a scalar context returns
    the first <span class="Li">&quot;CODE&quot;</span> reference. See the
    following example:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/src/perl/YappWithDefaultAction/examples$ cat -n returnedbypushmethod.pl
     1  #!/usr/local/bin/perl -w
     2  use strict;
     3  use Parse::Eyapp::Base qw(:all);
     4
     5  sub tutu { &quot;tutu&quot; }
     6  sub Chum::tutu { &quot;chum&quot; }
     7
     8  my @classes = qw{main Cham Chum};
     9
    10  my %oldf;
    11  our $tutu = 5;
    12  our @tutu = 9..12;
    13  $Cham::tutu = 8;
    14  @Cham::tutu = 1..3;
    15
    16  @oldf{@classes} = push_method(@classes, 'tutu', sub { &quot;titi&quot; });
    17
    18  print &quot;Calling new function 'tutu':&quot;.&amp;tutu().&quot;\n&quot;;
    19
    20  for (@classes) {
    21    if (defined($oldf{$_})) {
    22      print &quot;Old function 'tutu' in $_ gives: &quot;.$oldf{$_}-&gt;().&quot;\n&quot;;
    23    }
    24    else {
    25       print &quot;Function 'tutu' wasn't defined in $_\n&quot;;
    26    }
    27  }
</pre>
<p class="Pp">The following session with the debugger shows that:</p>
<ul class="Bl-bullet">
  <li>Package variables with the same name like <span class="Li">$tutu</span> or
      <span class="Li">@tutu</span> aren't changed by
      <span class="Li">&quot;insert_method&quot;</span></li>
  <li>References to the old versions of function
      <span class="Li">&quot;tutu&quot;</span> are returned by
      <span class="Li">&quot;insert_method&quot;</span></li>
</ul>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ perl -wd returnedbypushmethod.pl
  main::(returnedbypushmethod.pl:8):
  8:      my @classes = qw{main Cham Chum};
    DB&lt;1&gt; c 18
  main::(returnedbypushmethod.pl:18):
  18:     print &quot;Calling new function 'tutu':&quot;.&amp;tutu().&quot;\n&quot;;
    DB&lt;2&gt; n
  Calling new function 'tutu':titi
  main::(returnedbypushmethod.pl:20):
  20:     for (@classes) {
    DB&lt;2&gt; x @tutu
  0  9
  1  10
  2  11
  3  12
    DB&lt;3&gt; x @Cham::tutu
  0  1
  1  2
  2  3
    DB&lt;4&gt; p $Cham::tutu
  8
    DB&lt;5&gt; c
  Old function 'tutu' in main gives: tutu
  Function 'tutu' wasn't defined in Cham
  Old function 'tutu' in Chum gives: chum
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Function__pop_method_"><a class="permalink" href="#Function__pop_method_">Function
  &quot;pop_method&quot;</a></h2>
<p class="Pp">The call</p>
<p class="Pp"></p>
<pre>
                     pop_method(qw{CLASS1 CLASS2 ... }, 'subname' )
</pre>
<p class="Pp">pops the methods in the tops of the stacks associated with
    <span class="Li">&quot;CLASS1::subname&quot;</span>,
    <span class="Li">&quot;CLASS2::subname&quot;</span>, etc. See the example in
    the section push_method above.</p>
<ul class="Bl-bullet">
  <li>The caller class is assumed if no classes are specified.</li>
  <li>If the stack for <span class="Li">&quot;CLASS::subname&quot;</span> is
      empty the old specification of <span class="Li">&quot;subname&quot;</span>
      will remain.
    <p class="Pp"></p>
    <pre>
  pl@nereida:~/LEyapp/examples$ cat returnedbypopmethod.pl
  #!/usr/local/bin/perl -w
  use strict;
  use Parse::Eyapp::Base qw(:all);

  sub tutu { &quot;tutu&quot; }

  my $old = pop_method('tutu');

  print &quot;Function 'tutu' is available\n&quot; if main-&gt;can('tutu');
  print &quot;Old function 'tutu' gives: &quot;.$old-&gt;().&quot;\n&quot;;
    </pre>
    <p class="Pp">When executed gives the following output:</p>
    <p class="Pp"></p>
    <pre>
  pl@nereida:~/LEyapp/examples$ returnedbypopmethod.pl
  Function 'tutu' is available
  Old function 'tutu' gives: tutu
    </pre>
  </li>
  <li>In list context the <span class="Li">&quot;pop_method&quot;</span>
      function returns an array of pointers to the old versions of the function.
      In a scalar context returns the first function reference. When the stack
      is empty the function(s) are deleted.</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Examples_of__push_method__and__pop_method_"><a class="permalink" href="#Examples_of__push_method__and__pop_method_">Examples
  of &quot;push_method&quot; and &quot;pop_method&quot;</a></h2>
<p class="Pp"><i>Hiding functions</i></p>
<p class="Pp">See the following example:</p>
<p class="Pp"></p>
<pre>
  package Tutu;
  use Parse::Eyapp::Base qw(:all);

  sub tutu {
    print &quot;Inside tutu\n&quot;
  }

  sub plim {

    # When the stack is empty the old 'tutu' remains ...
    pop_method('tutu');

    &amp;tutu(); # Inside tutu

    push_method('tutu'); # Tutu disapears
  }

  package main;

  Tutu::plim(); 
  # main can't call 'tutu'
  print &quot;Can't tutu\n&quot; unless Tutu-&gt;can('tutu');
  Tutu::plim();
</pre>
<p class="Pp">When executed the former program produces this output:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ localsubbase.pl
  Inside tutu
  Can't tutu
  Inside tutu
</pre>
<p class="Pp"><i>Changing the Behavior of Method-parametric Methods</i></p>
<p class="Pp">A common situation where I need the couple
    (<span class="Li">&quot;push_method&quot;</span>,
    <span class="Li">&quot;pop_method&quot;</span>) is to control the behavior
    of method <span class="Li">&quot;str&quot;</span> when debugging:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/Lbook/code/Simple-Types/script$ perl -wd usetypes.pl prueba26.c 2
  Loading DB routines from perl5db.pl version 1.28
  Editor support available.
  main::(usetypes.pl:5):  my $filename = shift || die &quot;Usage:\n$0 file.c\n&quot;;
    DB&lt;1&gt; c Parse::Eyapp::Node::str
  1 int f() {
  2   int a[30];
  3
  4   return;
  5 }
  Parse::Eyapp::Node::str(/home/pl/src/perl/YappWithDefaultAction/lib//Parse/Eyapp/Node.pm:716):
  716:      my @terms;
</pre>
<p class="Pp">Let us assume I want to see the syntax tree for this program. I
    can see it using <span class="Li">&quot;$_[0]-&gt;str&quot;</span> but the
    problem is that nodes <span class="Li">&quot;PROGRAM&quot;</span> and
    <span class="Li">&quot;FUNCTION&quot;</span> have defined a
    <span class="Li">&quot;footnote&quot;</span> method that will dump their
    symbol and type tables producing hundred of lines of output and making
    difficult to see the shape of the tree. This is because method
    <span class="Li">&quot;str&quot;</span> calls method
    <span class="Li">&quot;footnote&quot;</span> wherever the node being visited
    <i>can</i> do <span class="Li">&quot;footnote&quot;</span>. The solution is
    to use <span class="Li">&quot;push_method&quot;</span> to make the
    <span class="Li">&quot;footnote&quot;</span> methods disappear:</p>
<p class="Pp"></p>
<pre>
    DB&lt;2&gt; use Parse::Eyapp::Base qw(:all)
    DB&lt;3&gt; push_method(qw{PROGRAM FUNCTION}, 'footnote')
</pre>
<p class="Pp">The use of <span class="Li">&quot;push_method&quot;</span> without
    an explicit code handler eliminates the CODE entry for
    <span class="Li">&quot;footnote&quot;</span>:</p>
<p class="Pp"></p>
<pre>
    DB&lt;4&gt; p $_-&gt;can('footnote')? &quot;1\n&quot; : &quot;0\n&quot; for (qw{PROGRAM FUNCTION})
  0
  0
</pre>
<p class="Pp">Now I can see the shape of the tree:</p>
<p class="Pp"></p>
<pre>
    DB&lt;5&gt; p $_[0]-&gt;str

  PROGRAM(
    FUNCTION[f](
      EMPTYRETURN
    )
  ) # PROGRAM
</pre>
<p class="Pp">If I want back the <span class="Li">&quot;footnote&quot;</span>
    methods I can use <span class="Li">&quot;pop_method&quot;</span>:</p>
<p class="Pp"></p>
<pre>
    DB&lt;6&gt; pop_method(qw{PROGRAM FUNCTION}, 'footnote')
    DB&lt;7&gt; p $_-&gt;can('footnote')? &quot;1\n&quot; : &quot;0\n&quot; for (qw{PROGRAM FUNCTION})
    1
    1
</pre>
<p class="Pp">Now the information will be profuse:</p>
<p class="Pp"></p>
<pre>
    DB&lt;8&gt; p $_[0]-&gt;str

  PROGRAM^{0}(
    FUNCTION[f]^{1}(
      EMPTYRETURN
    )
  ) # PROGRAM
  ---------------------------
  0)
  Types:
  $VAR1 = {
    'CHAR' =&gt; bless( {
      'children' =&gt; []
    }, 'CHAR' ),
    ..... etc, etc.
    'A_30(INT)' =&gt; bless( {
      'children' =&gt; [
        $VAR1-&gt;{'INT'}
      ]
    }, 'A_30' )
  };
  Symbol Table:
  $VAR1 = {
    'f' =&gt; {
      'type' =&gt; 'F(X_0(),INT)',
      'line' =&gt; 1
    }
  };

  ---------------------------
  1)
  $VAR1 = {
    'a' =&gt; {
      'type' =&gt; 'A_30(INT)',
      'line' =&gt; 2
    }
  };
</pre>
<p class="Pp">You can still do something like this to achieve a similar
  effect:</p>
<p class="Pp"></p>
<pre>
  DB&lt;9&gt; p eval { local (*PROGRAM::footnote, *FUNCTION::footnote) = (sub {}, sub {}); $_[0]-&gt;str }

  PROGRAM(
    FUNCTION[f](
      EMPTYRETURN
    )
  ) # PROGRAM
</pre>
<p class="Pp">but is certainly more verbose and does not eliminate function
    <span class="Li">&quot;footnote&quot;</span> from the
    <span class="Li">&quot;PROGRAM&quot;</span> and
    <span class="Li">&quot;FUNCTION&quot;</span> classes.</p>
<p class="Pp">Therefore the usefulness of
    <span class="Li">&quot;push_method&quot;</span> is when you either want to
    temporarily delete your function/methods or localize them not necessarily in
    a scope basis.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Function__compute_lines_"><a class="permalink" href="#Function__compute_lines_">Function
  &quot;compute_lines&quot;</a></h2>
<p class="Pp">The call</p>
<p class="Pp"></p>
<pre>
                compute_lines(\$text, $filename, $pattern)
</pre>
<p class="Pp">Substitutes all the occurrences of
    <span class="Li">$pattern</span> by <span class="Li">&quot;#line $number
    $filename&quot;</span> in string <span class="Li">$text</span>. where
    <span class="Li">$number</span> is the line number.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Function__slurp_file_"><a class="permalink" href="#Function__slurp_file_">Function
  &quot;slurp_file&quot;</a></h2>
<p class="Pp">The call</p>
<p class="Pp"></p>
<pre>
                my $input = slurp_file($filename, &quot;c&quot;);
</pre>
<p class="Pp">returns a string with the contents of the file
    <span class="Li">$filename</span> assuming extension
    <span class="Li">&quot;c&quot;</span>.</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/src/perl/YappWithDefaultAction/lib/Parse/Eyapp$ perl -wde 0
  main::(-e:1):   0
    DB&lt;1&gt; use Parse::Eyapp::Base qw(:all)
    DB&lt;2&gt; !!ls *yp # There are two files with extension .yp in this directory
  Parse.yp  Treeregexp.yp
    DB&lt;3&gt; $x = slurp_file('Parse', 'yp') # read the whole file
    DB&lt;4&gt; p $x =~ tr/\n// # file Parse.yp has 1038 lines
  1038
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Function__valid_keys_"><a class="permalink" href="#Function__valid_keys_">Function
  &quot;valid_keys&quot;</a></h2>
<p class="Pp">The call</p>
<p class="Pp"></p>
<pre>
              valid_keys(%hash)
</pre>
<p class="Pp">Returns a string with the keys of the
    <span class="Li">%hash</span> separated by commas:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/src/perl/YappWithDefaultAction/lib/Parse/Eyapp$ perl -wde 0
  main::(-e:1):   0
    DB&lt;1&gt; use Parse::Eyapp::Base qw(:all)
    DB&lt;2&gt; %h = ( SCOPE_NAME =&gt; 'STRING', ENTRY_NAME =&gt; 'STRING', SCOPE_DEPTH =&gt; 'STRING')
    DB&lt;3&gt; $x = valid_keys(%h)
    DB&lt;4&gt; p $x
  ENTRY_NAME, SCOPE_DEPTH, SCOPE_NAME
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Function__invalid_keys_"><a class="permalink" href="#Function__invalid_keys_">Function
  &quot;invalid_keys&quot;</a></h2>
<p class="Pp">It is called with two hash references:</p>
<p class="Pp"></p>
<pre>
    DB&lt;5&gt; p invalid_keys(\%h, { SCOPE_NAME =&gt; 'a', ENTRY_NAMe =&gt; 'b', SCOPE_DEPTH =&gt; 'c'})
  ENTRY_NAMe
</pre>
<p class="Pp">It returns the first key in the second hash that does not appear
    in the first hash. See a more complete example:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/src/perl/YappWithDefaultAction/lib/Parse/Eyapp$ head -31 Scope.pm | cat -n
     1  package Parse::Eyapp::Scope;
     2  use strict;
     3  use warnings;
     4  use Carp;
     5  use List::MoreUtils qw(part);
     6  use Parse::Eyapp::Base qw(valid_keys invalid_keys);
     7
     8  my %_new_scope = (
     9    SCOPE_NAME      =&gt; 'STRING',
    10    ENTRY_NAME      =&gt; 'STRING',
    11    SCOPE_DEPTH     =&gt; 'STRING',
    12  );
    13  my $valid_scope_keys = valid_keys(%_new_scope);
    14
    15  sub new {
    16   my $class = shift;
    17    my %args = @_;
    18
    19    if (defined($a = invalid_keys(\%_new_scope, \%args))) {
    20      croak(&quot;Parse::Eyapp::Scope::new Error!:\n&quot;
    21           .&quot;unknown argument $a. Valid arguments for new are:\n  $valid_scope_keys&quot;)
    22    }
    23    $args{ENTRY_NAME}      = 'entry' unless defined($args{ENTRY_NAME});
    24    $args{SCOPE_NAME}      = 'scope' unless defined($args{SCOPE_NAME});
    25    $args{SCOPE_DEPTH}     = ''      unless defined($args{SCOPE_DEPTH});
    26    $args{PENDING_DECL}    = [];
    27    $args{SCOPE_MARK}      = 0;
    28    $args{DEPTH}           = -1; # first depth is 0
    29
    30    bless \%args, $class;
    31  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Function__write_file_"><a class="permalink" href="#Function__write_file_">Function
  &quot;write_file&quot;</a></h2>
<p class="Pp">The call</p>
<p class="Pp"></p>
<pre>
              write_file($filename, $textref)
</pre>
<p class="Pp">simply opens a file with name <span class="Li">$filename</span>
    writes in it the text referenced by <span class="Li">$texterf</span> and
    closes the file</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Function__numbered_"><a class="permalink" href="#Function__numbered_">Function
  &quot;numbered&quot;</a></h2>
<p class="Pp">The call</p>
<p class="Pp"></p>
<pre>
                numbered($input)
</pre>
<p class="Pp">Returns a string like <span class="Li">$input</span> but with
    lines numbered and the numbers correctly indented. See an example:</p>
<p class="Pp"></p>
<pre>
    DB&lt;1&gt; use Parse::Eyapp::Base qw(:all)
    DB&lt;2&gt; $input = &quot;Another line!\n&quot;x12
    DB&lt;3&gt; $output = numbered($input)
    DB&lt;4&gt; p $output
   1 Another line!
   2 Another line!
   3 Another line!
   4 Another line!
   5 Another line!
   6 Another line!
   7 Another line!
   8 Another line!
   9 Another line!
  10 Another line!
  11 Another line!
  12 Another line!
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>Parse::Eyapp,</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<ul class="Bl-bullet">
  <li>Hal Finkel &lt;http://www.halssoftware.com/&gt;</li>
  <li>G. Williams &lt;http://kasei.us/&gt;</li>
  <li>Thomas L. Shinnick &lt;http://search.cpan.org/~tshinnic/&gt;</li>
  <li>Frank Leray</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Casiano Rodriguez-Leon (casiano@ull.es)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGMENTS"><a class="permalink" href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a></h1>
<p class="Pp">This work has been supported by CEE (FEDER) and the Spanish
    Ministry of <i>Educacion y Ciencia</i> through <i>Plan Nacional I+D+I</i>
    number TIN2005-08818-C04-04 (ULL::OPLINK project
    &lt;http://www.oplink.ull.es/&gt;). Support from Gobierno de Canarias was
    through GC02210601 (<i>Grupos Consolidados</i>). The University of La Laguna
    has also supported my work in many ways and for many years.</p>
<p class="Pp">A large percentage of code is verbatim taken from Parse::Yapp
    1.05. The author of Parse::Yapp is Francois Desarmenien.</p>
<p class="Pp">I wish to thank Francois Desarmenien for his Parse::Yapp module,
    to my students at La Laguna and to the Perl Community. Thanks to the people
    who have contributed to improve the module (see &quot;CONTRIBUTORS&quot; in
    Parse::Eyapp). Thanks to Larry Wall for giving us Perl. Special thanks to
    Juana.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENCE_AND_COPYRIGHT"><a class="permalink" href="#LICENCE_AND_COPYRIGHT">LICENCE
  AND COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 2006-2008 Casiano Rodriguez-Leon (casiano@ull.es).
    All rights reserved.</p>
<p class="Pp">Parse::Yapp copyright is of Francois Desarmenien, all rights
    reserved. 1998-2001</p>
<p class="Pp">These modules are free software; you can redistribute it and/or
    modify it under the same terms as Perl itself. See perlartistic.</p>
<p class="Pp">This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. </p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2012-03-23</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

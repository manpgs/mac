<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Moose::Manual::Delta(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Moose::Manual::Delta(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Moose::Manual::Delta(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Moose::Manual::Delta - Important Changes in Moose</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 2.2012</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This documents any important or noteworthy changes in Moose, with
    a focus on things that affect backwards compatibility. This does duplicate
    data from the <i>Changes</i> file, but aims to provide more details and when
    possible workarounds.</p>
<p class="Pp">Besides helping keep up with changes, you can also use this
    document for finding the lowest version of Moose that supported a given
    feature. If you encounter a problem and have a solution but don't see it
    documented here, or think we missed an important feature, please send us a
    patch.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="2.1400"><a class="permalink" href="#2.1400">2.1400</a></h1>
<dl class="Bl-tag">
  <dt id="Overloading"><a class="permalink" href="#Overloading">Overloading
    implementation has changed</a></dt>
  <dd>Overloading meta information used to be implemented by a
      <span class="Li">&quot;Class::MOP::Method::Overload&quot;</span> class.
      This class has been removed, and overloading is now implemented by
      Class::MOP::Overload. Overloading is not really equivalent to a method, so
      the former implementation didn't work properly for various cases.
    <p class="Pp">All of the overloading-related methods for classes and roles
        have the same names, but those methods now return Class::MOP::Overload
        objects.</p>
  </dd>
  <dt id="Core"><a class="permalink" href="#Core">Core support for overloading
    in roles</a></dt>
  <dd>Roles which use overloading now pass that overloading onto other classes
      (and roles) which consume that role.
    <p class="Pp">This works much like MooseX::Role::WithOverloading, except
        that we properly detect overloading conflicts during role summation and
        when applying one role to another. MooseX::Role::WithOverloading did not
        do any conflict detection.</p>
    <p class="Pp">If you want to write code that uses overloading and works with
        previous versions of Moose and this one, upgrade to
        MooseX::Role::WithOverloading version 0.15 or greater. That version will
        detect when Moose itself handles overloading and get out of the way.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="2.1200"><a class="permalink" href="#2.1200">2.1200</a></h1>
<dl class="Bl-tag">
  <dt id="Classes"><a class="permalink" href="#Classes">Classes created by Moose
    are now registered in %INC</a></dt>
  <dd>This means that this will no longer die (and will also no longer try to
      load <span class="Li">&quot;Foo.pm&quot;</span>):
    <p class="Pp"></p>
    <pre>  {
      package Foo;
      use Moose;
  }
  # ...
  use Foo;
    </pre>
    <p class="Pp">If you're using the MOP, this behavior will occur when the
        <span class="Li">&quot;create&quot;</span> (or
        <span class="Li">&quot;create_anon_class&quot;</span>) method is used,
        but not when the <span class="Li">&quot;initialize&quot;</span> method
        is used.</p>
  </dd>
  <dt id="Moose"><a class="permalink" href="#Moose">Moose now uses
    Module::Runtime instead of Class::Load to load classes</a></dt>
  <dd>Class::Load has always had some weird issues with the ways that it tries
      to figure out if a class is loaded. For instance, extending an empty
      package was previously impossible, because Class::Load would think that
      the class failed to load, even though that is a perfectly valid thing to
      do. It was also difficult to deal with modules like IO::Handle, which
      partially populate several other packages when they are loaded (so calling
      <span class="Li">&quot;load_class&quot;</span> on
      <span class="Li">'IO::Handle'</span> followed by
      <span class="Li">'IO::File'</span> could end up with a broken
      <span class="Li">&quot;IO::File&quot;</span>, in some cases).
    <p class="Pp">Now, Moose uses the same mechanisms as perl itself to figure
        out if a class is loaded. A class is considered to be loaded if its
        entry in <span class="Li">%INC</span> is set. Perl sets the
        <span class="Li">%INC</span> entry for you automatically whenever a file
        is loaded via <span class="Li">&quot;use&quot;</span> or
        <span class="Li">&quot;require&quot;</span>. Also, as mentioned above,
        Moose also now sets the <span class="Li">%INC</span> entry for any
        classes defined with it, even if they aren't loaded from a separate
        file. This does however mean that if you are trying to use Moose with
        non-Moose classes defined in the same file, then you will need to set
        <span class="Li">%INC</span> manually now, where it may have worked in
        the past. For instance:</p>
    <p class="Pp"></p>
    <pre>  {
      package My::NonMoose;
      sub new { bless {}, shift }
      $INC{'My/NonMoose.pm'} = __FILE__;
      # alternatively:
      # use Module::Runtime 'module_notional_filename';
      # $INC{module_notional_filename(__PACKAGE__)} = __FILE__;
  }
  {
      package My::Moose;
      use Moose;
      extends 'My::NonMoose';
  }
    </pre>
    <p class="Pp">If you don't do this, you will get an error message about not
        being able to locate <span class="Li">&quot;My::NonMoose&quot;</span> in
        <span class="Li">@INC</span>. We hope that this case will be fairly
        rare.</p>
  </dd>
  <dt id="The"><a class="permalink" href="#The">The Class::Load wrapper
    functions in Class::MOP have been deprecated</a></dt>
  <dd><span class="Li">&quot;Class::MOP::load_class&quot;</span>,
      <span class="Li">&quot;Class::MOP::is_class_loaded&quot;</span>, and
      <span class="Li">&quot;Class::MOP::load_first_existing_class&quot;</span>
      have been deprecated. They have been undocumented and discouraged since
      version 2.0200. You should replace their use with the corresponding
      functions in Class::Load, or just use Module::Runtime directly.</dd>
  <dt id="The~2"><a class="permalink" href="#The~2">The non-arrayref forms of
    &quot;enum&quot; and &quot;duck_type&quot; have been deprecated</a></dt>
  <dd>Originally, <span class="Li">&quot;enum&quot;</span> could be called like
      this:
    <p class="Pp"></p>
    <pre>  enum('MyType' =&gt; qw(foo bar baz))
    </pre>
    <p class="Pp">This was confusing, however (since it was different from the
        syntax for anonymous enum types), and it makes error checking more
        difficult (since you can't tell just by looking whether
        <span class="Li">&quot;enum('Foo', 'Bar', 'Baz')&quot;</span> was
        intended to be a type named <span class="Li">&quot;Foo&quot;</span> with
        elements of <span class="Li">&quot;Bar&quot;</span> and
        <span class="Li">&quot;Baz&quot;</span>, or if this was actually a
        mistake where someone got the syntax for an anonymous enum type wrong).
        This all also applies to
      <span class="Li">&quot;duck_type&quot;</span>.</p>
    <p class="Pp">Calling <span class="Li">&quot;enum&quot;</span> and
        <span class="Li">&quot;duck_type&quot;</span> with a list of arguments
        as described above has been undocumented since version 0.93, and is now
        deprecated. You should replace</p>
    <p class="Pp"></p>
    <pre>  enum MyType =&gt; qw(foo bar baz);
    </pre>
    <p class="Pp">in your code with</p>
    <p class="Pp"></p>
    <pre>  enum MyType =&gt; [qw(foo bar baz)];
    </pre>
  </dd>
  <dt id="Moose~2"><a class="permalink" href="#Moose~2">Moose string exceptions
    have been replaced by Moose exception objects</a></dt>
  <dd>Previously, Moose threw string exceptions on error conditions, which were
      not so verbose. All those string exceptions have now been converted to
      exception objects, which provide very detailed information about the
      exceptions. These exception objects provide a string overload that matches
      the previous exception message, so in most cases you should not have to
      change your code.
    <p class="Pp">For learning about the usage of Moose exception objects, read
        Moose::Manual::Exceptions. Individual exceptions are documented in
        Moose::Manual::Exceptions::Manifest.</p>
    <p class="Pp">This work was funded as part of the GNOME Outreach Program for
        Women.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="2.1000"><a class="permalink" href="#2.1000">2.1000</a></h1>
<dl class="Bl-tag">
  <dt id="The~3"><a class="permalink" href="#The~3">The Num type is now
    stricter</a></dt>
  <dd>The <span class="Li">&quot;Num&quot;</span> type used to accept anything
      that fits Perl's notion of a number, which included Inf, NaN, and strings
      like <span class="Li">&quot; 1234 \n&quot;</span>. We believe that the
      type constraint should indicate &quot;this is a number&quot;, not
      &quot;this coerces to a number&quot;. Therefore, Num now only accepts
      integers, floating point numbers (both in decimal notation and exponential
      notation), 0, .0, 0.0, etc.
    <p class="Pp">If you want the old behavior you can use the
        <span class="Li">&quot;LaxNum&quot;</span> type in
        MooseX::Types::LaxNum.</p>
  </dd>
  <dt id="You"><a class="permalink" href="#You">You can use Specio instead of
    core Moose types</a></dt>
  <dd>The Specio distribution is an experimental new type system intended to
      eventually replace the core Moose types, but yet also work with things
      like Moo and Mouse and anything else. Right now this is all speculative,
      but at least you can use Specio with Moose.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="2.0600"><a class="permalink" href="#2.0600">2.0600</a></h1>
<dl class="Bl-tag">
  <dt>&quot;-&gt;init_meta&quot; is even less reliable at loading
    extensions</dt>
  <dd>Previously, calling
      <span class="Li">&quot;MooseX::Foo-&gt;init_meta(@_)&quot;</span> (and
      nothing else) from within your own
      <span class="Li">&quot;init_meta&quot;</span> had a decent chance of doing
      something useful. This was never supported behavior, and didn't always
      work anyway. Due to some implementation adjustments, this now has a
      smaller chance of doing something useful, which could break code that was
      expecting it to continue doing useful things. Code that does this should
      instead just call <span class="Li">&quot;MooseX::Foo-&gt;import({ into
      =&gt; $into })&quot;</span>.</dd>
  <dt id="All"><a class="permalink" href="#All">All the Cookbook recipes have
    been renamed</a></dt>
  <dd>We've given them all descriptive names, rather than numbers. This makes it
      easier to talk about them, and eliminates the need to renumber recipes in
      order to reorder them or delete one.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="2.0400"><a class="permalink" href="#2.0400">2.0400</a></h1>
<dl class="Bl-tag">
  <dt id="The~4"><a class="permalink" href="#The~4">The parent of a union type
    is its components' nearest common ancestor</a></dt>
  <dd>Previously, union types considered all of their component types their
      parent types. This was incorrect because parent types are defined as types
      that must be satisfied in order for the child type to be satisfied, but in
      a union, validating as any parent type will validate against the entire
      union. This has been changed to find the nearest common ancestor for all
      of its components. For example, a union of &quot;Int|ArrayRef[Int]&quot;
      now has a parent of &quot;Defined&quot;.</dd>
  <dt id="Union"><a class="permalink" href="#Union">Union types consider all
    members in the &quot;is_subtype_of&quot; and &quot;is_a_type_of&quot;
    methods</a></dt>
  <dd>Previously, a union type would report itself as being of a subtype of a
      type if <i>any</i> of its member types were subtypes of that type. This
      was incorrect because any value that passes a subtype constraint must also
      pass a parent constraint. This has changed so that <i>all</i> of its
      member types must be a subtype of the specified type.</dd>
  <dt id="Enum"><a class="permalink" href="#Enum">Enum types now work with just
    one value</a></dt>
  <dd>Previously, an <span class="Li">&quot;enum&quot;</span> type needed to
      have two or more values. Nobody knew why, so we fixed it.</dd>
  <dt id="Methods"><a class="permalink" href="#Methods">Methods defined in
    UNIVERSAL now appear in the MOP</a></dt>
  <dd>Any method introspection methods that look at methods from parent classes
      now find methods defined in UNIVERSAL. This includes methods like
      <span class="Li">&quot;$class-&gt;get_all_methods&quot;</span> and
      <span class="Li">&quot;$class-&gt;find_method_by_name&quot;</span>.
    <p class="Pp">This also means that you can now apply method modifiers to
        these methods.</p>
  </dd>
  <dt id="Hand-optimized"><a class="permalink" href="#Hand-optimized">Hand-optimized
    type constraint code causes a deprecation warning</a></dt>
  <dd>If you provide an optimized sub ref for a type constraint, this now causes
      a deprecation warning. Typically, this comes from passing an
      <span class="Li">&quot;optimize_as&quot;</span> parameter to
      <span class="Li">&quot;subtype&quot;</span>, but it could also happen if
      you create a Moose::Meta::TypeConstraint object directly.
    <p class="Pp">Use the inlining feature
        (<span class="Li">&quot;inline_as&quot;</span>) added in 2.0100
      instead.</p>
  </dd>
  <dt>&quot;Class::Load::load_class&quot; and &quot;is_class_loaded&quot; have
    been removed</dt>
  <dd>The <span class="Li">&quot;Class::MOP::load_class&quot;</span> and
      <span class="Li">&quot;Class::MOP::is_class_loaded&quot;</span>
      subroutines are no longer documented, and will cause a deprecation warning
      in the future. Moose now uses Class::Load to provide this functionality,
      and you should do so as well.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="2.0205"><a class="permalink" href="#2.0205">2.0205</a></h1>
<dl class="Bl-tag">
  <dt id="Array"><a class="permalink" href="#Array">Array and Hash native traits
    provide a &quot;shallow_clone&quot; method</a></dt>
  <dd>The Array and Hash native traits now provide a &quot;shallow_clone&quot;
      method, which will return a reference to a new container with the same
      contents as the attribute's reference.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="2.0200"><a class="permalink" href="#2.0200">2.0200</a></h1>
<dl class="Bl-tag">
  <dt id="Hand-optimized~2"><a class="permalink" href="#Hand-optimized~2">Hand-optimized
    type constraint code is deprecated in favor of inlining</a></dt>
  <dd>Moose allows you to provide a hand-optimized version of a type
      constraint's subroutine reference. This version allows type constraints to
      generate inline code, and you should use this inlining instead of
      providing a hand-optimized subroutine reference.
    <p class="Pp">This affects the
        <span class="Li">&quot;optimize_as&quot;</span> sub exported by
        Moose::Util::TypeConstraints. Use
        <span class="Li">&quot;inline_as&quot;</span> instead.</p>
    <p class="Pp">This will start warning in the 2.0300 release.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="2.0002"><a class="permalink" href="#2.0002">2.0002</a></h1>
<dl class="Bl-tag">
  <dt id="More"><a class="permalink" href="#More">More useful type constraint
    error messages</a></dt>
  <dd>If you have Devel::PartialDump version 0.14 or higher installed, Moose's
      type constraint error messages will use it to display the invalid value,
      rather than just displaying it directly. This will generally be much more
      useful. For instance, instead of this:
    <p class="Pp"></p>
    <pre>  Attribute (foo) does not pass the type constraint because: Validation failed for 'ArrayRef[Int]' with value ARRAY(0x275eed8)
    </pre>
    <p class="Pp">the error message will instead look like</p>
    <p class="Pp"></p>
    <pre>  Attribute (foo) does not pass the type constraint because: Validation failed for 'ArrayRef[Int]' with value [ &quot;a&quot; ]
    </pre>
    <p class="Pp">Note that Devel::PartialDump can't be made a direct dependency
        at the moment, because it uses Moose itself, but we're considering
        options to make this easier.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="2.0000"><a class="permalink" href="#2.0000">2.0000</a></h1>
<dl class="Bl-tag">
  <dt id="Roles"><a class="permalink" href="#Roles">Roles have their own default
    attribute metaclass</a></dt>
  <dd>Previously, when a role was applied to a class, it would use the attribute
      metaclass defined in the class when copying over the attributes in the
      role. This was wrong, because for instance, using MooseX::FollowPBP in the
      class would end up renaming all of the accessors generated by the role,
      some of which may be being called in the role, causing it to break. Roles
      now keep track of their own attribute metaclass to use by default when
      being applied to a class (defaulting to Moose::Meta::Attribute). This is
      modifiable using Moose::Util::MetaRole by passing the
      <span class="Li">&quot;applied_attribute&quot;</span> key to the
      <span class="Li">&quot;role_metaroles&quot;</span> option, as in:
    <p class="Pp"></p>
    <pre>    Moose::Util::MetaRole::apply_metaroles(
        for =&gt; __PACKAGE__,
        class_metaroles =&gt; {
            attribute =&gt; ['My::Meta::Role::Attribute'],
        },
        role_metaroles =&gt; {
            applied_attribute =&gt; ['My::Meta::Role::Attribute'],
        },
    );
    </pre>
  </dd>
  <dt id="Class::MOP"><a class="permalink" href="#Class::MOP">Class::MOP has
    been folded into the Moose dist</a></dt>
  <dd>Moose and Class::MOP are tightly related enough that they have always had
      to be kept pretty closely in step in terms of versions. Making them into a
      single dist should simplify the upgrade process for users, as it should no
      longer be possible to upgrade one without the other and potentially cause
      issues. No functionality has changed, and this should be entirely
      transparent.</dd>
  <dt id="Moose's"><a class="permalink" href="#Moose's">Moose's conflict
    checking is more robust and useful</a></dt>
  <dd>There are two parts to this. The most useful one right now is that Moose
      will ship with a <span class="Li">&quot;moose-outdated&quot;</span>
      script, which can be run at any point to list the modules which are
      installed that conflict with the installed version of Moose. After
      upgrading Moose, running <span class="Li">&quot;moose-outdated |
      cpanm&quot;</span> should be sufficient to ensure that all of the Moose
      extensions you use will continue to work.
    <p class="Pp">The other part is that Moose's
        <span class="Li">&quot;META.json&quot;</span> file will also specify the
        conflicts under the <span class="Li">&quot;x_conflicts&quot;</span> (now
        <span class="Li">&quot;x_breaks&quot;</span>) key. We are working with
        the Perl tool chain developers to try to get conflicts support added to
        CPAN clients, and if/when that happens, the metadata already exists, and
        so the conflict checking will become automatic.</p>
  </dd>
  <dt id="The~5"><a class="permalink" href="#The~5">The lazy_build attribute
    feature is discouraged</a></dt>
  <dd>While not deprecated, we strongly discourage you from using this
    feature.</dd>
  <dt id="Most"><a class="permalink" href="#Most">Most deprecated APIs/features
    are slated for removal in Moose 2.0200</a></dt>
  <dd>Most of the deprecated APIs and features in Moose will start throwing an
      error in Moose 2.0200. Some of the features will go away entirely, and
      some will simply throw an error.
    <p class="Pp">The things on the chopping block are:</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>Old public methods in Class::MOP and Moose
    <p class="Pp">This includes things like
        <span class="Li">&quot;Class::MOP::Class-&gt;get_attribute_map&quot;</span>,
        <span class="Li">&quot;Class::MOP::Class-&gt;construct_instance&quot;</span>,
        and many others. These were deprecated in Class::MOP 0.80_01, released
        on April 5, 2009.</p>
    <p class="Pp">These methods will be removed entirely in Moose 2.0200.</p>
  </li>
  <li>Old public functions in Class::MOP
    <p class="Pp">This include
        <span class="Li">&quot;Class::MOP::subname&quot;</span>,
        <span class="Li">&quot;Class::MOP::in_global_destruction&quot;</span>,
        and the <span class="Li">&quot;Class::MOP::HAS_ISAREV&quot;</span>
        constant. The first two were deprecated in 0.84, and the last in 0.80.
        Class::MOP 0.84 was released on May 12, 2009.</p>
    <p class="Pp">These functions will be removed entirely in Moose 2.0200.</p>
  </li>
  <li>The <span class="Li">&quot;alias&quot;</span> and
      <span class="Li">&quot;excludes&quot;</span> option for role composition
    <p class="Pp">These were renamed to
        <span class="Li">&quot;-alias&quot;</span> and
        <span class="Li">&quot;-excludes&quot;</span> in Moose 0.89, released on
        August 13, 2009.</p>
    <p class="Pp">Passing these will throw an error in Moose 2.0200.</p>
  </li>
  <li>The old Moose::Util::MetaRole API
    <p class="Pp">This include the
        <span class="Li">&quot;apply_metaclass_roles()&quot;</span> function, as
        well as passing the <span class="Li">&quot;for_class&quot;</span> or any
        key ending in <span class="Li">&quot;_roles&quot;</span> to
        <span class="Li">&quot;apply_metaroles()&quot;</span>. This was
        deprecated in Moose 0.93_01, released on January 4, 2010.</p>
    <p class="Pp">These will all throw an error in Moose 2.0200.</p>
  </li>
  <li>Passing plain lists to <span class="Li">&quot;type()&quot;</span> or
      <span class="Li">&quot;subtype()&quot;</span>
    <p class="Pp">The old API for these functions allowed you to pass a plain
        list of parameter, rather than a list of hash references (which is what
        <span class="Li">&quot;as()&quot;</span>,
        <span class="Li">&quot;where&quot;</span>, etc. return). This was
        deprecated in Moose 0.71_01, released on February 22, 2009.</p>
    <p class="Pp">This will throw an error in Moose 2.0200.</p>
  </li>
  <li>The Role subtype
    <p class="Pp">This subtype was deprecated in Moose 0.84, released on June
        26, 2009.</p>
    <p class="Pp">This will be removed entirely in Moose 2.0200.</p>
  </li>
</ul>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="1.21"><a class="permalink" href="#1.21">1.21</a></h1>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>New release policy
    <p class="Pp">As of the 2.0 release, Moose now has an official release and
        support policy, documented in Moose::Manual::Support. All API changes
        will now go through a deprecation cycle of at least one year, after
        which the deprecated API can be removed. Deprecations and removals will
        only happen in major releases.</p>
    <p class="Pp">In between major releases, we will still make minor releases
        to add new features, fix bugs, update documentation, etc.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="1.16"><a class="permalink" href="#1.16">1.16</a></h1>
<dl class="Bl-tag">
  <dt id="Configurable"><a class="permalink" href="#Configurable">Configurable
    stacktraces</a></dt>
  <dd>Classes which use the Moose::Error::Default error class can now have
      stacktraces disabled by setting the
      <span class="Li">&quot;MOOSE_ERROR_STYLE&quot;</span> env var to
      <span class="Li">&quot;croak&quot;</span>. This is experimental, fairly
      incomplete, and won't work in all cases (because Moose's error system in
      general is all of these things), but this should allow for reducing at
      least some of the verbosity in most cases.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="1.15"><a class="permalink" href="#1.15">1.15</a></h1>
<dl class="Bl-tag">
  <dt id="Native"><a class="permalink" href="#Native">Native
    Delegations</a></dt>
  <dd>In previous versions of Moose, the Native delegations were created as
      closures. The generated code was often quite slow compared to doing the
      same thing by hand. For example, the Array's push delegation ended up
      doing something like this:
    <p class="Pp"></p>
    <pre>  push @{ $self-&gt;$reader() }, @_;
    </pre>
    <p class="Pp">If the attribute was created without a reader, the
        <span class="Li">$reader</span> sub reference followed a very slow code
        path. Even with a reader, this is still slower than it needs to be.</p>
    <p class="Pp">Native delegations are now generated as inline code, just like
        other accessors, so we can access the slot directly.</p>
    <p class="Pp">In addition, native traits now do proper constraint checking
        in all cases. In particular, constraint checking has been improved for
        array and hash references. Previously, only the <i>contained</i> type
        (the <span class="Li">&quot;Str&quot;</span> in
        <span class="Li">&quot;HashRef[Str]&quot;</span>) would be checked when
        a new value was added to the collection. However, if there was a
        constraint that applied to the whole value, this was never checked.</p>
    <p class="Pp">In addition, coercions are now called on the whole value.</p>
    <p class="Pp">The delegation methods now do more argument checking. All of
        the methods check that a valid number of arguments were passed to the
        method. In addition, the delegation methods check that the arguments are
        sane (array indexes, hash keys, numbers, etc.) when applicable. We have
        tried to emulate the behavior of Perl builtins as much as possible.</p>
    <p class="Pp">Finally, triggers are called whenever the value of the
        attribute is changed by a Native delegation.</p>
    <p class="Pp">These changes are only likely to break code in a few
      cases.</p>
    <p class="Pp">The inlining code may or may not preserve the original
        reference when changes are made. In some cases, methods which change the
        value may replace it entirely. This will break tied values.</p>
    <p class="Pp">If you have a typed arrayref or hashref attribute where the
        type enforces a constraint on the whole collection, this constraint will
        now be checked. It's possible that code which previously ran without
        errors will now cause the constraint to fail. However, presumably this
        is a good thing ;)</p>
    <p class="Pp">If you are passing invalid arguments to a delegation which
        were previously being ignored, these calls will now fail.</p>
    <p class="Pp">If your code relied on the trigger only being called for a
        regular writer, that may cause problems.</p>
    <p class="Pp">As always, you are encouraged to test before deploying the
        latest version of Moose to production.</p>
  </dd>
  <dt id="Defaults"><a class="permalink" href="#Defaults">Defaults is and
    default for String, Counter, and Bool</a></dt>
  <dd>A few native traits (String, Counter, Bool) provide default values of
      &quot;is&quot; and &quot;default&quot; when you created an attribute.
      Allowing them to provide these values is now deprecated. Supply the value
      yourself when creating the attribute.</dd>
  <dt id="The~6"><a class="permalink" href="#The~6">The &quot;meta&quot;
    method</a></dt>
  <dd>Moose and Class::MOP have been cleaned up internally enough to make the
      <span class="Li">&quot;meta&quot;</span> method that you get by default
      optional. <span class="Li">&quot;use Moose&quot;</span> and
      <span class="Li">&quot;use Moose::Role&quot;</span> now can take an
      additional <span class="Li">&quot;-meta_name&quot;</span> option, which
      tells Moose what name to use when installing the
      <span class="Li">&quot;meta&quot;</span> method. Passing
      <span class="Li">&quot;undef&quot;</span> to this option suppresses
      generation of the <span class="Li">&quot;meta&quot;</span> method
      entirely. This should be useful for users of modules which also use a
      <span class="Li">&quot;meta&quot;</span> method or function, such as
      Curses or Rose::DB::Object.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="1.09"><a class="permalink" href="#1.09">1.09</a></h1>
<dl class="Bl-tag">
  <dt id="All~2"><a class="permalink" href="#All~2">All deprecated features now
    warn</a></dt>
  <dd>Previously, deprecation mostly consisted of simply saying &quot;X is
      deprecated&quot; in the Changes file. We were not very consistent about
      actually warning. Now, all deprecated features still present in Moose
      actually give a warning. The warning is issued once per calling package.
      See Moose::Deprecated for more details.</dd>
  <dt id="You~2"><a class="permalink" href="#You~2">You cannot pass &quot;coerce
    =&gt; 1&quot; unless the attribute's type constraint has a coercion</a></dt>
  <dd>Previously, this was accepted, and it sort of worked, except that if you
      attempted to set the attribute after the object was created, you would get
      a runtime error.
    <p class="Pp">Now you will get a warning when you attempt to define the
        attribute.</p>
  </dd>
  <dt>&quot;no Moose&quot;, &quot;no Moose::Role&quot;, and &quot;no
    Moose::Exporter&quot; no longer unimport strict and warnings</dt>
  <dd>This change was made in 1.05, and has now been reverted. We don't know if
      the user has explicitly loaded strict or warnings on their own, and
      unimporting them is just broken in that case.</dd>
  <dt id="Reversed"><a class="permalink" href="#Reversed">Reversed logic when
    defining which options can be changed</a></dt>
  <dd>Moose::Meta::Attribute now allows all options to be changed in an
      overridden attribute. The previous behaviour required each option to be
      whitelisted using the
      <span class="Li">&quot;legal_options_for_inheritance&quot;</span> method.
      This method has been removed, and there is a new method,
      <span class="Li">&quot;illegal_options_for_inheritance&quot;</span>, which
      can now be used to prevent certain options from being changeable.
    <p class="Pp">In addition, we only throw an error if the illegal option is
        actually changed. If the superclass didn't specify this option at all
        when defining the attribute, the subclass version can still add it as an
        option.</p>
    <p class="Pp">Example of overriding this in an attribute trait:</p>
    <p class="Pp"></p>
    <pre>  package Bar::Meta::Attribute;
  use Moose::Role;
  has 'my_illegal_option' =&gt; (
      isa =&gt; 'CodeRef',
      is  =&gt; 'rw',
  );
  around illegal_options_for_inheritance =&gt; sub {
      return ( shift-&gt;(@_), qw/my_illegal_option/ );
  };
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="1.05"><a class="permalink" href="#1.05">1.05</a></h1>
<dl class="Bl-tag">
  <dt>&quot;BUILD&quot; in Moose::Object methods are now called when calling
    &quot;new_object&quot;</dt>
  <dd>Previously, <span class="Li">&quot;BUILD&quot;</span> methods would only
      be called from <span class="Li">&quot;Moose::Object::new&quot;</span>, but
      now they are also called when constructing an object via
      <span class="Li">&quot;Moose::Meta::Class::new_object&quot;</span>.
      <span class="Li">&quot;BUILD&quot;</span> methods are an inherent part of
      the object construction process, and this should make
      <span class="Li">&quot;$meta-&gt;new_object&quot;</span> actually usable
      without forcing people to use
      <span class="Li">&quot;$meta-&gt;name-&gt;new&quot;</span>.</dd>
  <dt>&quot;no Moose&quot;, &quot;no Moose::Role&quot;, and &quot;no
    Moose::Exporter&quot; now unimport strict and warnings</dt>
  <dd>In the interest of having <span class="Li">&quot;no Moose&quot;</span>
      clean up everything that <span class="Li">&quot;use Moose&quot;</span>
      does in the calling scope, <span class="Li">&quot;no Moose&quot;</span>
      (as well as all other Moose::Exporter-using modules) now unimports strict
      and warnings.</dd>
  <dt id="Metaclass"><a class="permalink" href="#Metaclass">Metaclass
    compatibility checking and fixing should be much more robust</a></dt>
  <dd>The metaclass compatibility checking and fixing algorithms have been
      completely rewritten, in both Class::MOP and Moose. This should resolve
      many confusing errors when dealing with non-Moose inheritance and with
      custom metaclasses for things like attributes, constructors, etc. For
      correct code, the only thing that should require a change is that custom
      error metaclasses must now inherit from Moose::Error::Default.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="1.02"><a class="permalink" href="#1.02">1.02</a></h1>
<dl class="Bl-tag">
  <dt id="Moose::Meta::TypeConstraint::Class"><a class="permalink" href="#Moose::Meta::TypeConstraint::Class">Moose::Meta::TypeConstraint::Class
    is_subtype_of behavior</a></dt>
  <dd>Earlier versions of is_subtype_of would incorrectly return true when
      called with itself, its own TC name or its class name as an argument.
      (i.e. <span class="Li">$foo_tc</span>-&gt;is_subtype_of('Foo') == 1) This
      behavior was a caused by <span class="Li">&quot;isa&quot;</span> being
      checked before the class name. The old behavior can be accessed with
      is_type_of</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="1.00"><a class="permalink" href="#1.00">1.00</a></h1>
<dl class="Bl-tag">
  <dt id="Moose::Meta::Attribute::Native::Trait::Code"><a class="permalink" href="#Moose::Meta::Attribute::Native::Trait::Code">Moose::Meta::Attribute::Native::Trait::Code
    no longer creates reader methods by default</a></dt>
  <dd>Earlier versions of Moose::Meta::Attribute::Native::Trait::Code created
      read-only accessors for the attributes it's been applied to, even if you
      didn't ask for it with <span class="Li">&quot;is =&gt; 'ro'&quot;</span>.
      This incorrect behaviour has now been fixed.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="0.95"><a class="permalink" href="#0.95">0.95</a></h1>
<dl class="Bl-tag">
  <dt id="Moose::Util"><a class="permalink" href="#Moose::Util">Moose::Util
    add_method_modifier behavior</a></dt>
  <dd>add_method_modifier (and subsequently the sugar functions Moose::before,
      Moose::after, and Moose::around) can now accept arrayrefs, with the same
      behavior as lists. Types other than arrayref and regexp result in an
      error.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="0.93_01_and_0.94"><a class="permalink" href="#0.93_01_and_0.94">0.93_01
  and 0.94</a></h1>
<dl class="Bl-tag">
  <dt id="Moose::Util::MetaRole"><a class="permalink" href="#Moose::Util::MetaRole">Moose::Util::MetaRole
    API has changed</a></dt>
  <dd>The <span class="Li">&quot;apply_metaclass_roles&quot;</span> function is
      now called <span class="Li">&quot;apply_metaroles&quot;</span>. The way
      arguments are supplied has been changed to force you to distinguish
      between metaroles applied to Moose::Meta::Class (and helpers) versus
      Moose::Meta::Role.
    <p class="Pp">The old API still works, but will warn in a future release,
        and eventually be removed.</p>
  </dd>
  <dt id="Moose::Meta::Role"><a class="permalink" href="#Moose::Meta::Role">Moose::Meta::Role
    has real attributes</a></dt>
  <dd>The attributes returned by Moose::Meta::Role are now instances of the
      Moose::Meta::Role::Attribute class, instead of bare hash references.</dd>
  <dt>&quot;no Moose&quot; now removes &quot;blessed&quot; and
    &quot;confess&quot;</dt>
  <dd>Moose is now smart enough to know exactly what it exported, even when it
      re-exports functions from other packages. When you unimport Moose, it will
      remove these functions from your namespace unless you <i>also</i> imported
      them directly from their respective packages.
    <p class="Pp">If you have a <span class="Li">&quot;no Moose&quot;</span> in
        your code <i>before</i> you call
        <span class="Li">&quot;blessed&quot;</span> or
        <span class="Li">&quot;confess&quot;</span>, your code will break. You
        can either move the <span class="Li">&quot;no Moose&quot;</span> call
        later in your code, or explicitly import the relevant functions from the
        packages that provide them.</p>
  </dd>
  <dt id="Moose::Exporter"><a class="permalink" href="#Moose::Exporter">Moose::Exporter
    is smarter about unimporting re-exports</a></dt>
  <dd>The change above comes from a general improvement to Moose::Exporter. It
      will now unimport any function it exports, even if that function is a
      re-export from another package.</dd>
  <dt id="Attributes"><a class="permalink" href="#Attributes">Attributes in
    roles can no longer override class attributes with &quot;+foo&quot;</a></dt>
  <dd>Previously, this worked more or less accidentally, because role attributes
      weren't objects. This was never documented, but a few MooseX modules took
      advantage of this.</dd>
  <dt id="The~7"><a class="permalink" href="#The~7">The composition_class_roles
    attribute in Moose::Meta::Role is now a method</a></dt>
  <dd>This was done to make it possible for roles to alter the list of
      composition class roles by applying a method modifiers. Previously, this
      was an attribute and MooseX modules override it. Since that no longer
      works, this was made a method.
    <p class="Pp">This <i>should</i> be an attribute, so this may switch back to
        being an attribute in the future if we can figure out how to make this
        work.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="0.93"><a class="permalink" href="#0.93">0.93</a></h1>
<dl class="Bl-tag">
  <dt id="Calling"><a class="permalink" href="#Calling">Calling
    $object-&gt;<b>new()</b> is no longer deprecated</a></dt>
  <dd>We decided to undeprecate this. Now it just works.</dd>
  <dt id="Both"><a class="permalink" href="#Both">Both
    &quot;get_method_map&quot; and &quot;get_attribute_map&quot; is
    deprecated</a></dt>
  <dd>These metaclass methods were never meant to be public, and they are both
      now deprecated. The work around if you still need the functionality they
      provided is to iterate over the list of names manually.
    <p class="Pp"></p>
    <pre>    my %fields = map { $_ =&gt; $meta-&gt;get_attribute($_) } $meta-&gt;get_attribute_list;
    </pre>
    <p class="Pp">This was actually a change in Class::MOP, but this version of
        Moose requires a version of Class::MOP that includes said change.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="0.90"><a class="permalink" href="#0.90">0.90</a></h1>
<dl class="Bl-tag">
  <dt id="Added"><a class="permalink" href="#Added">Added Native delegation for
    Code refs</a></dt>
  <dd>See Moose::Meta::Attribute::Native::Trait::Code for details.</dd>
  <dt id="Calling~2"><a class="permalink" href="#Calling~2">Calling
    $object-&gt;<b>new()</b> is deprecated</a></dt>
  <dd>Moose has long supported this, but it's never really been documented, and
      we don't think this is a good practice. If you want to construct an object
      from an existing object, you should provide some sort of alternate
      constructor like <span class="Li">&quot;$object-&gt;clone&quot;</span>.
    <p class="Pp">Calling <span class="Li">&quot;$object-&gt;new&quot;</span>
        now issues a warning, and will be an error in a future release.</p>
  </dd>
  <dt id="Moose~3"><a class="permalink" href="#Moose~3">Moose no longer warns if
    you call &quot;make_immutable&quot; for a class with mutable
    ancestors</a></dt>
  <dd>While in theory this is a good thing to warn about, we found so many
      exceptions to this that doing this properly became quite problematic.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="0.89_02"><a class="permalink" href="#0.89_02">0.89_02</a></h1>
<dl class="Bl-tag">
  <dt id="New"><a class="permalink" href="#New">New Native delegation methods
    from List::Util and List::MoreUtils</a></dt>
  <dd>In particular, we now have <span class="Li">&quot;reduce&quot;</span>,
      <span class="Li">&quot;shuffle&quot;</span>,
      <span class="Li">&quot;uniq&quot;</span>, and
      <span class="Li">&quot;natatime&quot;</span>.</dd>
  <dt id="The~8"><a class="permalink" href="#The~8">The Moose::Exporter
    with_caller feature is now deprecated</a></dt>
  <dd>Use <span class="Li">&quot;with_meta&quot;</span> instead. The
      <span class="Li">&quot;with_caller&quot;</span> option will start warning
      in a future release.</dd>
  <dt id="Moose~4"><a class="permalink" href="#Moose~4">Moose now warns if you
    call &quot;make_immutable&quot; for a class with mutable ancestors</a></dt>
  <dd>This is dangerous because modifying a class after a subclass has been
      immutabilized will lead to incorrect results in the subclass, due to
      inlining, caching, etc. This occasionally happens accidentally, when a
      class loads one of its subclasses in the middle of its class definition,
      so pointing out that this may cause issues should be helpful. Metaclasses
      (classes that inherit from Class::MOP::Object) are currently exempt from
      this check, since at the moment we aren't very consistent about which
      metaclasses we immutabilize.</dd>
  <dt>&quot;enum&quot; and &quot;duck_type&quot; now take arrayrefs for all
    forms</dt>
  <dd>Previously, calling these functions with a list would take the first
      element of the list as the type constraint name, and use the remainder as
      the enum values or method names. This makes the interface inconsistent
      with the anon-type forms of these functions (which must take an arrayref),
      and a free-form list where the first value is sometimes special is hard to
      validate (and harder to give reasonable error messages for). These
      functions have been changed to take arrayrefs in all their forms - so,
      <span class="Li">&quot;enum 'My::Type' =&gt; [qw(foo bar)]&quot;</span> is
      now the preferred way to create an enum type constraint. The old syntax
      still works for now, but it will hopefully be deprecated and removed in a
      future release.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="0.89_01"><a class="permalink" href="#0.89_01">0.89_01</a></h1>
<p class="Pp">Moose::Meta::Attribute::Native has been moved into the Moose core
    from MooseX::AttributeHelpers. Major changes include:</p>
<dl class="Bl-tag">
  <dt>&quot;traits&quot;, not &quot;metaclass&quot;</dt>
  <dd>Method providers are only available via traits.</dd>
  <dt>&quot;handles&quot;, not &quot;provides&quot; or &quot;curries&quot;</dt>
  <dd>The <span class="Li">&quot;provides&quot;</span> syntax was like core
      Moose <span class="Li">&quot;handles =&gt; HASHREF&quot;</span> syntax,
      but with the keys and values reversed. This was confusing, and
      AttributeHelpers now uses <span class="Li">&quot;handles =&gt;
      HASHREF&quot;</span> in a way that should be intuitive to anyone already
      familiar with how it is used for other attributes.
    <p class="Pp">The <span class="Li">&quot;curries&quot;</span> functionality
        provided by AttributeHelpers has been generalized to apply to all cases
        of <span class="Li">&quot;handles =&gt; HASHREF&quot;</span>, though not
        every piece of functionality has been ported (currying with a CODEREF is
        not supported).</p>
  </dd>
  <dt>&quot;empty&quot; is now &quot;is_empty&quot;, and means empty, not
    non-empty</dt>
  <dd>Previously, the <span class="Li">&quot;empty&quot;</span> method provided
      by Arrays and Hashes returned true if the attribute was <b>not</b> empty
      (no elements). Now it returns true if the attribute <b>is</b> empty. It
      was also renamed to <span class="Li">&quot;is_empty&quot;</span>, to
      reflect this.</dd>
  <dt>&quot;find&quot; was renamed to &quot;first&quot;, and &quot;first&quot;
    and &quot;last&quot; were removed</dt>
  <dd>List::Util refers to the functionality that we used to provide under
      <span class="Li">&quot;find&quot;</span> as first, so that will likely be
      more familiar (and will fit in better if we decide to add more List::Util
      functions). <span class="Li">&quot;first&quot;</span> and
      <span class="Li">&quot;last&quot;</span> were removed, since their
      functionality is easily duplicated with curries of
      <span class="Li">&quot;get&quot;</span>.</dd>
  <dt id="Helpers"><a class="permalink" href="#Helpers">Helpers that take a
    coderef of one argument now use $_</a></dt>
  <dd>Subroutines passed as the first argument to
      <span class="Li">&quot;first&quot;</span>,
      <span class="Li">&quot;map&quot;</span>, and
      <span class="Li">&quot;grep&quot;</span> now receive their argument in
      <span class="Li">$_</span> rather than as a parameter to the subroutine.
      Helpers that take a coderef of two or more arguments remain using the
      argument list (there are technical limitations to using
      <span class="Li">$a</span> and <span class="Li">$b</span> like
      <span class="Li">&quot;sort&quot;</span> does).
    <p class="Pp">See Moose::Meta::Attribute::Native for the new
      documentation.</p>
  </dd>
</dl>
<p class="Pp">The <span class="Li">&quot;alias&quot;</span> and
    <span class="Li">&quot;excludes&quot;</span> role parameters have been
    renamed to <span class="Li">&quot;-alias&quot;</span> and
    <span class="Li">&quot;-excludes&quot;</span>. The old names still work, but
    new code should use the new names, and eventually the old ones will be
    deprecated and removed.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="0.89"><a class="permalink" href="#0.89">0.89</a></h1>
<p class="Pp"><span class="Li">&quot;use Moose -metaclass =&gt;
    'Foo'&quot;</span> now does alias resolution, just like
    <span class="Li">&quot;-traits&quot;</span> (and the
    <span class="Li">&quot;metaclass&quot;</span> and
    <span class="Li">&quot;traits&quot;</span> options to
    <span class="Li">&quot;has&quot;</span>).</p>
<p class="Pp">Added two functions
    <span class="Li">&quot;meta_class_alias&quot;</span> and
    <span class="Li">&quot;meta_attribute_alias&quot;</span> to Moose::Util, to
    simplify aliasing metaclasses and metatraits. This is a wrapper around the
    old</p>
<p class="Pp"></p>
<pre>  package Moose::Meta::Class::Custom::Trait::FooTrait;
  sub register_implementation { 'My::Meta::Trait' }
</pre>
<p class="Pp">way of doing this.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="0.84"><a class="permalink" href="#0.84">0.84</a></h1>
<p class="Pp">When an attribute generates <i>no</i> accessors, we now warn. This
    is to help users who forget the <span class="Li">&quot;is&quot;</span>
    option. If you really do not want any accessors, you can use
    <span class="Li">&quot;is =&gt; 'bare'&quot;</span>. You can maintain back
    compat with older versions of Moose by using something like:</p>
<p class="Pp"></p>
<pre>    ($Moose::VERSION &gt;= 0.84 ? is =&gt; 'bare' : ())
</pre>
<p class="Pp">When an accessor overwrites an existing method, we now warn. To
    work around this warning (if you really must have this behavior), you can
    explicitly remove the method before creating it as an accessor:</p>
<p class="Pp"></p>
<pre>    sub foo {}
    __PACKAGE__-&gt;meta-&gt;remove_method('foo');
    has foo =&gt; (
        is =&gt; 'ro',
    );
</pre>
<p class="Pp">When an unknown option is passed to
    <span class="Li">&quot;has&quot;</span>, we now warn. You can silence the
    warning by fixing your code. :)</p>
<p class="Pp">The <span class="Li">&quot;Role&quot;</span> type has been
    deprecated. On its own, it was useless, since it just checked
    <span class="Li">&quot;$object-&gt;can('does')&quot;</span>. If you were
    using it as a parent type, just call
    <span class="Li">&quot;role_type('Role::Name')&quot;</span> to create an
    appropriate type instead.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="0.78"><a class="permalink" href="#0.78">0.78</a></h1>
<p class="Pp"><span class="Li">&quot;use Moose::Exporter;&quot;</span> now
    imports <span class="Li">&quot;strict&quot;</span> and
    <span class="Li">&quot;warnings&quot;</span> into packages that use it.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="0.77"><a class="permalink" href="#0.77">0.77</a></h1>
<p class="Pp"><span class="Li">&quot;DEMOLISHALL&quot;</span> and
    <span class="Li">&quot;DEMOLISH&quot;</span> now receive an argument
    indicating whether or not we are in global destruction.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="0.76"><a class="permalink" href="#0.76">0.76</a></h1>
<p class="Pp">Type constraints no longer run coercions for a value that already
    matches the constraint. This may affect some (arguably buggy) edge case
    coercions that rely on side effects in the
    <span class="Li">&quot;via&quot;</span> clause.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="0.75"><a class="permalink" href="#0.75">0.75</a></h1>
<p class="Pp">Moose::Exporter now accepts the
    <span class="Li">&quot;-metaclass&quot;</span> option for easily overriding
    the metaclass (without metaclass). This works for classes and roles.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="0.74"><a class="permalink" href="#0.74">0.74</a></h1>
<p class="Pp">Added a <span class="Li">&quot;duck_type&quot;</span> sugar
    function to Moose::Util::TypeConstraints to make integration with non-Moose
    classes easier. It simply checks if
    <span class="Li">&quot;$obj-&gt;can()&quot;</span> a list of methods.</p>
<p class="Pp">A number of methods (mostly inherited from Class::MOP) have been
    renamed with a leading underscore to indicate their internal-ness. The old
    method names will still work for a while, but will warn that the method has
    been renamed. In a few cases, the method will be removed entirely in the
    future. This may affect MooseX authors who were using these methods.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="0.73"><a class="permalink" href="#0.73">0.73</a></h1>
<p class="Pp">Calling <span class="Li">&quot;subtype&quot;</span> with a name as
    the only argument now throws an exception. If you want an anonymous subtype
    do:</p>
<p class="Pp"></p>
<pre>    my $subtype = subtype as 'Foo';
</pre>
<p class="Pp">This is related to the changes in version 0.71_01.</p>
<p class="Pp">The <span class="Li">&quot;is_needed&quot;</span> method in
    Moose::Meta::Method::Destructor is now only usable as a class method.
    Previously, it worked as a class or object method, with a different internal
    implementation for each version.</p>
<p class="Pp">The internals of making a class immutable changed a lot in
    Class::MOP 0.78_02, and Moose's internals have changed along with it. The
    external <span class="Li">&quot;$metaclass-&gt;make_immutable&quot;</span>
    method still works the same way.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="0.72"><a class="permalink" href="#0.72">0.72</a></h1>
<p class="Pp">A mutable class accepted
    <span class="Li">&quot;Foo-&gt;new(undef)&quot;</span> without complaint,
    while an immutable class would blow up with an unhelpful error. Now, in both
    cases we throw a helpful error instead.</p>
<p class="Pp">This &quot;feature&quot; was originally added to allow for cases
    such as this:</p>
<p class="Pp"></p>
<pre>  my $args;
  if ( something() ) {
      $args = {...};
  }
  return My::Class-&gt;new($args);
</pre>
<p class="Pp">But we decided this is a bad idea and a little too magical,
    because it can easily mask real errors.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="0.71_01"><a class="permalink" href="#0.71_01">0.71_01</a></h1>
<p class="Pp">Calling <span class="Li">&quot;type&quot;</span> or
    <span class="Li">&quot;subtype&quot;</span> without the sugar helpers
    (<span class="Li">&quot;as&quot;</span>,
    <span class="Li">&quot;where&quot;</span>,
    <span class="Li">&quot;message&quot;</span>) is now deprecated.</p>
<p class="Pp">As a side effect, this meant we ended up using Perl prototypes on
    <span class="Li">&quot;as&quot;</span>, and code like this will no longer
    work:</p>
<p class="Pp"></p>
<pre>  use Moose::Util::TypeConstraints;
  use Declare::Constraints::Simple -All;
  subtype 'ArrayOfInts'
      =&gt; as 'ArrayRef'
      =&gt; IsArrayRef(IsInt);
</pre>
<p class="Pp">Instead it must be changed to this:</p>
<p class="Pp"></p>
<pre>  subtype(
      'ArrayOfInts' =&gt; {
          as    =&gt; 'ArrayRef',
          where =&gt; IsArrayRef(IsInt)
      }
  );
</pre>
<p class="Pp">If you want to maintain backwards compat with older versions of
    Moose, you must explicitly test Moose's
    <span class="Li">&quot;VERSION&quot;</span>:</p>
<p class="Pp"></p>
<pre>  if ( Moose-&gt;VERSION &lt; 0.71_01 ) {
      subtype 'ArrayOfInts'
          =&gt; as 'ArrayRef'
          =&gt; IsArrayRef(IsInt);
  }
  else {
      subtype(
          'ArrayOfInts' =&gt; {
              as    =&gt; 'ArrayRef',
              where =&gt; IsArrayRef(IsInt)
          }
      );
  }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="0.70"><a class="permalink" href="#0.70">0.70</a></h1>
<p class="Pp">We no longer pass the meta-attribute object as a final argument to
    triggers. This actually changed for inlined code a while back, but the
    non-inlined version and the docs were still out of date.</p>
<p class="Pp">If by some chance you actually used this feature, the workaround
    is simple. You fetch the attribute object from out of the
    <span class="Li">$self</span> that is passed as the first argument to
    trigger, like so:</p>
<p class="Pp"></p>
<pre>  has 'foo' =&gt; (
      is      =&gt; 'ro',
      isa     =&gt; 'Any',
      trigger =&gt; sub {
          my ( $self, $value ) = @_;
          my $attr = $self-&gt;meta-&gt;find_attribute_by_name('foo');
          # ...
      }
  );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="0.66"><a class="permalink" href="#0.66">0.66</a></h1>
<p class="Pp">If you created a subtype and passed a parent that Moose didn't
    know about, it simply ignored the parent. Now it automatically creates the
    parent as a class type. This may not be what you want, but is less broken
    than before.</p>
<p class="Pp">You could declare a name with subtype such as &quot;Foo!Bar&quot;.
    Moose would accept this allowed, but if you used it in a parameterized type
    such as &quot;ArrayRef[Foo!Bar]&quot; it wouldn't work. We now do some
    vetting on names created via the sugar functions, so that they can only
    contain alphanumerics, &quot;:&quot;, and &quot;.&quot;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="0.65"><a class="permalink" href="#0.65">0.65</a></h1>
<p class="Pp">Methods created via an attribute can now fulfill a
    <span class="Li">&quot;requires&quot;</span> declaration for a role.
    Honestly we don't know why Stevan didn't make this work originally, he was
    just insane or something.</p>
<p class="Pp">Stack traces from inlined code will now report the line and file
    as being in your class, as opposed to in Moose guts.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="0.62_02"><a class="permalink" href="#0.62_02">0.62_02</a></h1>
<p class="Pp">When a class does not provide all of a role's required methods,
    the error thrown now mentions all of the missing methods, as opposed to just
    the first missing method.</p>
<p class="Pp">Moose will no longer inline a constructor for your class unless it
    inherits its constructor from Moose::Object, and will warn when it doesn't
    inline. If you want to force inlining anyway, pass
    <span class="Li">&quot;replace_constructor =&gt; 1&quot;</span> to
    <span class="Li">&quot;make_immutable&quot;</span>.</p>
<p class="Pp">If you want to get rid of the warning, pass
    <span class="Li">&quot;inline_constructor =&gt;</span>
    <span class="Li">0&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="0.62"><a class="permalink" href="#0.62">0.62</a></h1>
<p class="Pp">Removed the (deprecated)
    <span class="Li">&quot;make_immutable&quot;</span> keyword.</p>
<p class="Pp">Removing an attribute from a class now also removes delegation
    (<span class="Li">&quot;handles&quot;</span>) methods installed for that
    attribute. This is correct behavior, but if you were wrongly relying on it
    you might get bit.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="0.58"><a class="permalink" href="#0.58">0.58</a></h1>
<p class="Pp">Roles now add methods by calling
    <span class="Li">&quot;add_method&quot;</span>, not
    <span class="Li">&quot;alias_method&quot;</span>. They make sure to always
    provide a method object, which will be cloned internally. This means that it
    is now possible to track the source of a method provided by a role, and even
    follow its history through intermediate roles. This means that methods added
    by a role now show up when looking at a class's method list/map.</p>
<p class="Pp">Parameter and Union args are now sorted, this makes Int|Str the
    same constraint as Str|Int. Also, incoming type constraint strings are
    normalized to remove all whitespace differences. This is mostly for
    internals and should not affect outside code.</p>
<p class="Pp">Moose::Exporter will no longer remove a subroutine that the
    exporting package re-exports. Moose re-exports the Carp::confess function,
    among others. The reasoning is that we cannot know whether you have also
    explicitly imported those functions for your own use, so we err on the safe
    side and always keep them.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="0.56"><a class="permalink" href="#0.56">0.56</a></h1>
<p class="Pp"><span class="Li">&quot;Moose::init_meta&quot;</span> should now be
    called as a method.</p>
<p class="Pp">New modules for extension writers, Moose::Exporter and
    Moose::Util::MetaRole.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="0.55_01"><a class="permalink" href="#0.55_01">0.55_01</a></h1>
<p class="Pp">Implemented metaclass traits (and wrote a recipe for it):</p>
<p class="Pp"></p>
<pre>  use Moose -traits =&gt; 'Foo'
</pre>
<p class="Pp">This should make writing small Moose extensions a little
  easier.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="0.55"><a class="permalink" href="#0.55">0.55</a></h1>
<p class="Pp">Fixed <span class="Li">&quot;coerce&quot;</span> to accept anon
    types just like <span class="Li">&quot;subtype&quot;</span> can. So that you
    can do:</p>
<p class="Pp"></p>
<pre>  coerce $some_anon_type =&gt; from 'Str' =&gt; via { ... };
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="0.51"><a class="permalink" href="#0.51">0.51</a></h1>
<p class="Pp">Added <span class="Li">&quot;BUILDARGS&quot;</span>, a new step in
    <span class="Li">&quot;Moose::Object-&gt;new()&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="0.49"><a class="permalink" href="#0.49">0.49</a></h1>
<p class="Pp">Fixed how the <span class="Li">&quot;is =&gt; (ro|rw)&quot;</span>
    works with custom defined <span class="Li">&quot;reader&quot;</span>,
    <span class="Li">&quot;writer&quot;</span> and
    <span class="Li">&quot;accessor&quot;</span> options. See the below table
    for details:</p>
<p class="Pp"></p>
<pre>  is =&gt; ro, writer =&gt; _foo    # turns into (reader =&gt; foo, writer =&gt; _foo)
  is =&gt; rw, writer =&gt; _foo    # turns into (reader =&gt; foo, writer =&gt; _foo)
  is =&gt; rw, accessor =&gt; _foo  # turns into (accessor =&gt; _foo)
  is =&gt; ro, accessor =&gt; _foo  # error, accesor is rw
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="0.45"><a class="permalink" href="#0.45">0.45</a></h1>
<p class="Pp">The <span class="Li">&quot;before/around/after&quot;</span> method
    modifiers now support regexp matching of method names. NOTE: this only works
    for classes, it is currently not supported in roles, but, ... patches
    welcome.</p>
<p class="Pp">The <span class="Li">&quot;has&quot;</span> keyword for roles now
    accepts the same array ref form that Moose.pm does for classes.</p>
<p class="Pp">A trigger on a read-only attribute is no longer an error, as it's
    useful to trigger off of the constructor.</p>
<p class="Pp">Subtypes of parameterizable types now are parameterizable types
    themselves.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="0.44"><a class="permalink" href="#0.44">0.44</a></h1>
<p class="Pp">Fixed issue where <span class="Li">&quot;DEMOLISHALL&quot;</span>
    was eating the value in <span class="Li">$@</span>, and so not working
    correctly. It still kind of eats them, but so does vanilla perl.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="0.41"><a class="permalink" href="#0.41">0.41</a></h1>
<p class="Pp">Inherited attributes may now be extended without restriction on
    the type ('isa', 'does').</p>
<p class="Pp">The entire set of Moose::Meta::TypeConstraint::* classes were
    refactored in this release. If you were relying on their internals you
    should test your code carefully.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="0.40"><a class="permalink" href="#0.40">0.40</a></h1>
<p class="Pp">Documenting the use of '+name' with attributes that come from
    recently composed roles. It makes sense, people are using it, and so why not
    just officially support it.</p>
<p class="Pp">The
    <span class="Li">&quot;Moose::Meta::Class-&gt;create&quot;</span> method now
    supports roles.</p>
<p class="Pp">It is now possible to make anonymous enum types by passing
    <span class="Li">&quot;enum&quot;</span> an array reference instead of the
    <span class="Li">&quot;enum $name =&gt; @values&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="0.37"><a class="permalink" href="#0.37">0.37</a></h1>
<p class="Pp">Added the <span class="Li">&quot;make_immutable&quot;</span>
    keyword as a shortcut to calling
    <span class="Li">&quot;make_immutable&quot;</span> on the meta object. This
    eventually got removed!</p>
<p class="Pp">Made <span class="Li">&quot;init_arg =&gt; undef&quot;</span> work
    in Moose. This means &quot;do not accept a constructor parameter for this
    attribute&quot;.</p>
<p class="Pp">Type errors now use the provided message. Prior to this release
    they didn't.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="0.34"><a class="permalink" href="#0.34">0.34</a></h1>
<p class="Pp">Moose is now a postmodern object system :)</p>
<p class="Pp">The Role system was completely refactored. It is 100% backwards
    compat, but the internals were totally changed. If you relied on the
    internals then you are advised to test carefully.</p>
<p class="Pp">Added method exclusion and aliasing for Roles in this release.</p>
<p class="Pp">Added the Moose::Util::TypeConstraints::OptimizedConstraints
    module.</p>
<p class="Pp">Passing a list of values to an accessor (which is only expecting
    one value) used to be silently ignored, now it throws an error.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="0.26"><a class="permalink" href="#0.26">0.26</a></h1>
<p class="Pp">Added parameterized types and did a pretty heavy refactoring of
    the type constraint system.</p>
<p class="Pp">Better framework extensibility and better support for &quot;making
    your own Moose&quot;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="0.25_or_before"><a class="permalink" href="#0.25_or_before">0.25
  or before</a></h1>
<p class="Pp">Honestly, you shouldn't be using versions of Moose that are this
    old, so many bug fixes and speed improvements have been made you would be
    crazy to not upgrade.</p>
<p class="Pp">Also, I am tired of going through the Changelog so I am stopping
    here, if anyone would like to continue this please feel free.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Stevan Little &lt;stevan.little@iinteractive.com&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
  <li>Shawn M Moore &lt;code@sartak.org&gt;</li>
  <li>&#x05D9;&#x05D5;&#x05D1;&#x05DC; &#x05E7;&#x05D5;&#x05D2;'&#x05DE;&#x05DF;
      (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Florian Ragwitz &lt;rafl@debian.org&gt;</li>
  <li>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</li>
  <li>Chris Prather &lt;chris@prather.org&gt;</li>
  <li>Matt S Trout &lt;mst@shadowcat.co.uk&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2006 by Infinity Interactive,
  Inc.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-11-22</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

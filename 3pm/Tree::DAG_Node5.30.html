<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Tree::DAG_Node(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Tree::DAG_Node(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Tree::DAG_Node(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Tree::DAG_Node - An N-ary tree</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Using_as_a_base_class"><a class="permalink" href="#Using_as_a_base_class">Using
  as a base class</a></h2>
<pre>        package Game::Tree::Node;
        use parent 'Tree::DAG_Node';
        # Now add your own methods overriding/extending the methods in C&lt;Tree::DAG_Node&gt;...
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_as_a_class_on_its_own"><a class="permalink" href="#Using_as_a_class_on_its_own">Using
  as a class on its own</a></h2>
<pre>        use Tree::DAG_Node;
        my($root) = Tree::DAG_Node -&gt; new({name =&gt; 'root', attributes =&gt; {uid =&gt; 0} });
        $root -&gt; add_daughter(Tree::DAG_Node -&gt; new({name =&gt; 'one', attributes =&gt; {uid =&gt; 1} }) );
        $root -&gt; add_daughter(Tree::DAG_Node -&gt; new({name =&gt; 'two', attributes =&gt; {} }) );
        $root -&gt; add_daughter(Tree::DAG_Node -&gt; new({name =&gt; 'three'}) ); # Attrs default to {}.
</pre>
<p class="Pp">Or:</p>
<p class="Pp"></p>
<pre>        my($count) = 0;
        my($tree)  = Tree::DAG_Node -&gt; new({name =&gt; 'Root', attributes =&gt; {'uid' =&gt; $count} });
</pre>
<p class="Pp">Or:</p>
<p class="Pp"></p>
<pre>        my $root = Tree::DAG_Node -&gt; new();
        $root -&gt; name(&quot;I'm the tops&quot;);
        $root -&gt; attributes({uid =&gt; 0});
        my $new_daughter = $root -&gt; new_daughter;
        $new_daughter -&gt; name('Another node');
        $new_daughter -&gt; attributes({uid =&gt; 1});
        ...
</pre>
<p class="Pp">Lastly, for fancy wrappers - called <b>_add_daughter()</b> -
    around <span class="Li">&quot;new()&quot;</span>, see these modules:
    Marpa::Demo::StringParser and GraphViz2::Marpa. Both of these modules use
    Moo.</p>
<p class="Pp">See scripts/*.pl for other samples.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_with_utf"><a class="permalink" href="#Using_with_utf">Using
  with utf-8 data</a></h2>
<p class="Pp">read_tree($file_name) works with utf-8 data. See t/read.tree.t and
    t/tree.utf8.attributes.txt. Such a file can be created by redirecting the
    output of <b>tree2string()</b> to a file of type utf-8.</p>
<p class="Pp">See the docs for Encode for the difference between utf8 and utf-8.
    In brief, use utf-8.</p>
<p class="Pp">See also scripts/write_tree.pl and scripts/read.tree.pl and
    scripts/read.tree.log.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This class encapsulates/makes/manipulates objects that represent
    nodes in a tree structure. The tree structure is not an object itself, but
    is emergent from the linkages you create between nodes. This class provides
    the methods for making linkages that can be used to build up a tree, while
    preventing you from ever making any kinds of linkages which are not allowed
    in a tree (such as having a node be its own mother or ancestor, or having a
    node have two mothers).</p>
<p class="Pp">This is what I mean by a &quot;tree structure&quot;, a bit
    redundantly stated:</p>
<dl class="Bl-tag">
  <dt id="o"><a class="permalink" href="#o">o A tree is a special case of an
    acyclic directed graph</a></dt>
  <dd></dd>
  <dt id="o~2"><a class="permalink" href="#o~2">o A tree is a network of nodes
    where there's exactly one root node</a></dt>
  <dd>Also, the only primary relationship between nodes is the mother-daughter
      relationship.</dd>
  <dt id="o~3"><a class="permalink" href="#o~3">o No node can be its own mother,
    or its mother's mother, etc</a></dt>
  <dd></dd>
  <dt id="o~4"><a class="permalink" href="#o~4">o Each node in the tree has
    exactly one parent</a></dt>
  <dd>Except for the root of course, which is parentless.</dd>
  <dt id="o~5"><a class="permalink" href="#o~5">o Each node can have any number
    (0 .. N) daughter nodes</a></dt>
  <dd>A given node's daughter nodes constitute an <i>ordered</i> list.
    <p class="Pp">However, you are free to consider this ordering irrelevant.
        Some applications do need daughters to be ordered, so I chose to
        consider this the general case.</p>
  </dd>
  <dt id="o~6"><a class="permalink" href="#o~6">o A node can appear in only one
    tree, and only once in that tree</a></dt>
  <dd>Notably (notable because it doesn't follow from the two above points), a
      node cannot appear twice in its mother's daughter list.</dd>
  <dt id="o~7"><a class="permalink" href="#o~7">o There's an idea of up versus
    down</a></dt>
  <dd>Up means towards to the root, and down means away from the root (and
      towards the leaves).</dd>
  <dt id="o~8"><a class="permalink" href="#o~8">o There's an idea of left versus
    right</a></dt>
  <dd>Left is toward the start (index 0) of a given node's daughter list, and
      right is toward the end of a given node's daughter list.</dd>
</dl>
<p class="Pp">Trees as described above have various applications, among them:
    representing syntactic constituency, in formal linguistics; representing
    contingencies in a game tree; representing abstract syntax in the parsing of
    any computer language -- whether in expression trees for programming
    languages, or constituency in the parse of a markup language document. (Some
    of these might not use the fact that daughters are ordered.)</p>
<p class="Pp">(Note: B-Trees are a very special case of the above kinds of
    trees, and are best treated with their own class. Check CPAN for modules
    encapsulating B-Trees; or if you actually want a database, and for some
    reason ended up looking here, go look at AnyDBM_File.)</p>
<p class="Pp">Many base classes are not usable except as such -- but
    <span class="Li">&quot;Tree::DAG_Node&quot;</span> can be used as a normal
    class. You can go ahead and say:</p>
<p class="Pp"></p>
<pre>        use Tree::DAG_Node;
        my $root = Tree::DAG_Node-&gt;new();
        $root-&gt;name(&quot;I'm the tops&quot;);
        $new_daughter = Tree::DAG_Node-&gt;new();
        $new_daughter-&gt;name(&quot;More&quot;);
        $root-&gt;add_daughter($new_daughter);
</pre>
<p class="Pp">and so on, constructing and linking objects from
    <span class="Li">&quot;Tree::DAG_Node&quot;</span> and making useful tree
    structures out of them.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="A_NOTE_TO_THE_READER"><a class="permalink" href="#A_NOTE_TO_THE_READER">A
  NOTE TO THE READER</a></h1>
<p class="Pp">This class is big and provides lots of methods. If your problem is
    simple (say, just representing a simple parse tree), this class might seem
    like using an atomic sledgehammer to swat a fly. But the complexity of this
    module's bells and whistles shouldn't detract from the efficiency of using
    this class for a simple purpose. In fact, I'd be very surprised if any one
    user ever had use for more that even a third of the methods in this class.
    And remember: an atomic sledgehammer <b>will</b> kill that fly.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OBJECT_CONTENTS"><a class="permalink" href="#OBJECT_CONTENTS">OBJECT
  CONTENTS</a></h1>
<p class="Pp">Implementationally, each node in a tree is an object, in the sense
    of being an arbitrarily complex data structure that belongs to a class
    (presumably <span class="Li">&quot;Tree::DAG_Node&quot;</span>, or ones
    derived from it) that provides methods.</p>
<p class="Pp">The attributes of a node-object are:</p>
<dl class="Bl-tag">
  <dt id="o~9"><a class="permalink" href="#o~9">o mother -- this node's mother.
    undef if this is a root</a></dt>
  <dd></dd>
  <dt id="o~10"><a class="permalink" href="#o~10">o daughters -- the (possibly
    empty) list of daughters of this node</a></dt>
  <dd></dd>
  <dt id="o~11"><a class="permalink" href="#o~11">o name -- the name for this
    node</a></dt>
  <dd>Need not be unique, or even printable. This is printed in some of the
      various dumper methods, but it's up to you if you don't put anything
      meaningful or printable here.</dd>
  <dt id="o~12"><a class="permalink" href="#o~12">o attributes -- whatever the
    user wants to use it for</a></dt>
  <dd>Presumably a hashref to whatever other attributes the user wants to store
      without risk of colliding with the object's real attributes. (Example
      usage: attributes to an SGML tag -- you definitely wouldn't want the
      existence of a &quot;mother=foo&quot; pair in such a tag to collide with a
      node object's 'mother' attribute.)
    <p class="Pp">Aside from (by default) initializing it to {}, and having the
        access method called &quot;attributes&quot; (described a ways below), I
        don't do anything with the &quot;attributes&quot; in this module. I
        basically intended this so that users who don't want/need to bother
        deriving a class from
        <span class="Li">&quot;Tree::DAG_Node&quot;</span>, could still attach
        whatever data they wanted in a node.</p>
  </dd>
</dl>
<p class="Pp">&quot;mother&quot; and &quot;daughters&quot; are attributes that
    relate to linkage -- they are never written to directly, but are changed as
    appropriate by the &quot;linkage methods&quot;, discussed below.</p>
<p class="Pp">The other two (and whatever others you may add in derived classes)
    are simply accessed thru the same-named methods, discussed further
  below.</p>
<section class="Ss">
<h2 class="Ss" id="About_The_Documented_Interface"><a class="permalink" href="#About_The_Documented_Interface">About
  The Documented Interface</a></h2>
<p class="Pp">Stick to the documented interface (and comments in the source --
    especially ones saying &quot;undocumented!&quot; and/or
    &quot;disfavored!&quot; -- do not count as documentation!), and don't rely
    on any behavior that's not in the documented interface.</p>
<p class="Pp">Specifically, unless the documentation for a particular method
    says &quot;this method returns thus-and-such a value&quot;, then you should
    not rely on it returning anything meaningful.</p>
<p class="Pp">A <i>passing</i> acquaintance with at least the broader details of
    the source code for this class is assumed for anyone using this class as a
    base class -- especially if you're overriding existing methods, and
    <b>definitely</b> if you're overriding linkage methods.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="MAIN_CONSTRUCTOR,_AND_INITIALIZER"><a class="permalink" href="#MAIN_CONSTRUCTOR,_AND_INITIALIZER">MAIN
  CONSTRUCTOR, AND INITIALIZER</a></h1>
<dl class="Bl-tag">
  <dt id="the"><a class="permalink" href="#the">the constructor
    CLASS-&gt;<b>new()</b> or CLASS-&gt;new($options)</a></dt>
  <dd>This creates a new node object, calls
      <span class="Li">$object</span>-&gt;_init($options) to provide it sane
      defaults (like: undef name, undef mother, no daughters, 'attributes'
      setting of a new empty hashref), and returns the object created. (If you
      just said &quot;CLASS-&gt;<b>new()</b>&quot; or &quot;CLASS-&gt;new&quot;,
      then it pretends you called &quot;CLASS-&gt;new({})&quot;.)
    <p class="Pp">See also the comments under &quot;new($hashref)&quot; for
        options supported in the call to <b>new()</b>.</p>
    <p class="Pp">If you use <span class="Li">&quot;Tree::DAG_Node&quot;</span>
        as a superclass, and you add attributes that need to be initialized,
        what you need to do is provide an _init method that calls
        <span class="Li">$this</span>-&gt;SUPER::_init($options) to use its
        superclass's _init method, and then initializes the new attributes:</p>
    <p class="Pp"></p>
    <pre>  sub _init {
    my($this, $options) = @_[0,1];
    $this-&gt;SUPER::_init($options); # call my superclass's _init to
      # init all the attributes I'm inheriting
    # Now init /my/ new attributes:
    $this-&gt;{'amigos'} = []; # for example
  }
    </pre>
  </dd>
  <dt id="the~2"><a class="permalink" href="#the~2">the constructor
    $obj-&gt;<b>new()</b> or $obj-&gt;new($options)</a></dt>
  <dd>Just another way to get at the &quot;new($hashref)&quot; method. This
      <b>does not copy</b> <span class="Li">$obj</span>, but merely constructs a
      new object of the same class as it. Saves you the bother of going
      <span class="Li">$class</span> = ref <span class="Li">$obj</span>;
      <span class="Li">$obj2</span> =
    <span class="Li">$class</span>-&gt;new;</dd>
  <dt id="the~3"><a class="permalink" href="#the~3">the method
    $node-&gt;_init($options)</a></dt>
  <dd>Initialize the object's attribute values. See the discussion above.
      Presumably this should be called only by the guts of the
      &quot;new($hashref)&quot; constructor -- never by the end user.
    <p class="Pp">Currently there are no documented options for putting in the
        <span class="Li">$options</span> hashref, but (in case you want to
        disregard the above rant) the option exists for you to use
        <span class="Li">$options</span> for something useful in a derived
        class.</p>
    <p class="Pp">Please see the source for more information.</p>
  </dd>
  <dt id="see"><a class="permalink" href="#see">see also (below) the
    constructors &quot;new_daughter&quot; and
    &quot;new_daughter_left&quot;</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="add_daughter("><a class="permalink" href="#add_daughter(">add_daughter(LIST)</a></h2>
<p class="Pp">An exact synonym for &quot;add_daughters(LIST)&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="add_daughters("><a class="permalink" href="#add_daughters(">add_daughters(LIST)</a></h2>
<p class="Pp">This method adds the node objects in LIST to the (right) end of
    <span class="Li">$mother</span>'s <i>daughter</i> list. Making a node N1 the
    daughter of another node N2 also means that N1's <i>mother</i> attribute is
    &quot;automatically&quot; set to N2; it also means that N1 stops being
    anything else's daughter as it becomes N2's daughter.</p>
<p class="Pp">If you try to make a node its own mother, a fatal error results.
    If you try to take one of a node N1's ancestors and make it also a daughter
    of N1, a fatal error results. A fatal error results if anything in LIST
    isn't a node object.</p>
<p class="Pp">If you try to make N1 a daughter of N2, but it's <b>already</b> a
    daughter of N2, then this is a no-operation -- it won't move such nodes to
    the end of the list or anything; it just skips doing anything with them.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="add_daughter_left("><a class="permalink" href="#add_daughter_left(">add_daughter_left(LIST)</a></h2>
<p class="Pp">An exact synonym for &quot;add_daughters_left(LIST)&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="add_daughters_left("><a class="permalink" href="#add_daughters_left(">add_daughters_left(LIST)</a></h2>
<p class="Pp">This method is just like &quot;add_daughters(LIST)&quot;, except
    that it adds the node objects in LIST to the (left) beginning of
    <span class="Li">$mother</span>'s daughter list, instead of the (right) end
    of it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="add_left_sister("><a class="permalink" href="#add_left_sister(">add_left_sister(LIST)</a></h2>
<p class="Pp">An exact synonym for &quot;add_left_sisters(LIST)&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="add_left_sisters("><a class="permalink" href="#add_left_sisters(">add_left_sisters(LIST)</a></h2>
<p class="Pp">This adds the elements in LIST (in that order) as immediate left
    sisters of <span class="Li">$node</span>. In other words, given that B's
    mother's daughter-list is (A,B,C,D), calling B-&gt;add_left_sisters(X,Y)
    makes B's mother's daughter-list (A,X,Y,B,C,D).</p>
<p class="Pp">If LIST is empty, this is a no-op, and returns empty-list.</p>
<p class="Pp">This is basically implemented as a call to
    <span class="Li">$node</span>-&gt;replace_with(LIST,
    <span class="Li">$node</span>), and so all replace_with's limitations and
    caveats apply.</p>
<p class="Pp">The return value of
    <span class="Li">$node</span>-&gt;add_left_sisters(LIST) is the elements of
    LIST that got added, as returned by replace_with -- minus the copies of
    <span class="Li">$node</span> you'd get from a straight call to
    <span class="Li">$node</span>-&gt;replace_with(LIST,
    <span class="Li">$node</span>).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="add_right_sister("><a class="permalink" href="#add_right_sister(">add_right_sister(LIST)</a></h2>
<p class="Pp">An exact synonym for &quot;add_right_sisters(LIST)&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="add_right_sisters("><a class="permalink" href="#add_right_sisters(">add_right_sisters(LIST)</a></h2>
<p class="Pp">Just like add_left_sisters (which see), except that the elements
    in LIST (in that order) as immediate <b>right</b> sisters of
    <span class="Li">$node</span>;</p>
<p class="Pp">In other words, given that B's mother's daughter-list is
    (A,B,C,D), calling B-&gt;add_right_sisters(X,Y) makes B's mother's
    daughter-list (A,B,X,Y,C,D).</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>address()</b></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="address("><a class="permalink" href="#address(">address(ADDRESS)</a></h2>
<p class="Pp">With the first syntax, returns the address of
    <span class="Li">$node</span> within its tree, based on its position within
    the tree. An address is formed by noting the path between the root and
    <span class="Li">$node</span>, and concatenating the daughter-indices of the
    nodes this passes thru (starting with 0 for the root, and ending with
    <span class="Li">$node</span>).</p>
<p class="Pp">For example, if to get from node ROOT to node
    <span class="Li">$node</span>, you pass thru ROOT, A, B, and
    <span class="Li">$node</span>, then the address is determined as:</p>
<dl class="Bl-tag">
  <dt id="o~13"><a class="permalink" href="#o~13">o ROOT's my_daughter_index is
    0</a></dt>
  <dd></dd>
  <dt id="o~14"><a class="permalink" href="#o~14">o A's my_daughter_index is,
    suppose, 2</a></dt>
  <dd>A is index 2 in ROOT's daughter list.</dd>
  <dt id="o~15"><a class="permalink" href="#o~15">o B's my_daughter_index is,
    suppose, 0</a></dt>
  <dd>B is index 0 in A's daughter list.</dd>
  <dt id="o~16"><a class="permalink" href="#o~16">o $node's my_daughter_index
    is, suppose, 4</a></dt>
  <dd><span class="Li">$node</span> is index 4 in B's daughter list.</dd>
</dl>
<p class="Pp">The address of the above-described <span class="Li">$node</span>
    is, therefore, &quot;0:2:0:4&quot;.</p>
<p class="Pp">(As a somewhat special case, the address of the root is always
    &quot;0&quot;; and since addresses start from the root, all addresses start
    with a &quot;0&quot;.)</p>
<p class="Pp">The second syntax, where you provide an address, starts from the
    root of the tree <span class="Li">$anynode</span> belongs to, and returns
    the node corresponding to that address. Returns undef if no node corresponds
    to that address. Note that this routine may be somewhat liberal in its
    interpretation of what can constitute an address; i.e., it accepts
    &quot;0.2.0.4&quot;, besides &quot;0:2:0:4&quot;.</p>
<p class="Pp">Also note that the address of a node in a tree is meaningful only
    in that tree as currently structured.</p>
<p class="Pp">(Consider how ($address1 cmp <span class="Li">$address2</span>)
    may be magically meaningful to you, if you meant to figure out what nodes
    are to the right of what other nodes.)</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>ancestors()</b></h2>
<p class="Pp">Returns the list of this node's ancestors, starting with its
    mother, then grandmother, and ending at the root. It does this by simply
    following the 'mother' attributes up as far as it can. So if
    <span class="Li">$item</span> IS the root, this returns an empty list.</p>
<p class="Pp">Consider that scalar($node-&gt;ancestors) returns the ply of this
    node within the tree -- 2 for a granddaughter of the root, etc., and 0 for
    root itself.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>attribute()</b></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="attribute("><a class="permalink" href="#attribute(">attribute(SCALAR)</a></h2>
<p class="Pp">Exact synonyms for &quot;<b>attributes()</b>&quot; and
    &quot;attributes(SCALAR)&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>attributes()</b></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="attributes("><a class="permalink" href="#attributes(">attributes(SCALAR)</a></h2>
<p class="Pp">In the first form, returns the value of the node object's
    &quot;attributes&quot; attribute. In the second form, sets it to the value
    of SCALAR. I intend this to be used to store a reference to a (presumably
    anonymous) hash the user can use to store whatever attributes he doesn't
    want to have to store as object attributes. In this case, you needn't ever
    set the value of this. (_init has already initialized it to {}.) Instead you
    can just do...</p>
<p class="Pp"></p>
<pre>  $node-&gt;attributes-&gt;{'foo'} = 'bar';
</pre>
<p class="Pp">...to write foo =&gt; bar.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>clear_daughters()</b></h2>
<p class="Pp">This unlinks all <span class="Li">$mother</span>'s daughters.
    Returns the list of what used to be <span class="Li">$mother</span>'s
    daughters.</p>
<p class="Pp">Not to be confused with &quot;remove_daughters(LIST)&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="common("><a class="permalink" href="#common(">common(LIST)</a></h2>
<p class="Pp">Returns the lowest node in the tree that is ancestor-or-self to
    the nodes <span class="Li">$node</span> and LIST.</p>
<p class="Pp">If the nodes are far enough apart in the tree, the answer is just
    the root.</p>
<p class="Pp">If the nodes aren't all in the same tree, the answer is undef.</p>
<p class="Pp">As a degenerate case, if LIST is empty, returns
    <span class="Li">$node</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="common_ancestor("><a class="permalink" href="#common_ancestor(">common_ancestor(LIST)</a></h2>
<p class="Pp">Returns the lowest node that is ancestor to all the nodes given
    (in nodes <span class="Li">$node</span> and LIST). In other words, it
    answers the question: &quot;What node in the tree, as low as possible, is
    ancestor to the nodes given ($node and LIST)?&quot;</p>
<p class="Pp">If the nodes are far enough apart, the answer is just the root --
    except if any of the nodes are the root itself, in which case the answer is
    undef (since the root has no ancestor).</p>
<p class="Pp">If the nodes aren't all in the same tree, the answer is undef.</p>
<p class="Pp">As a degenerate case, if LIST is empty, returns
    <span class="Li">$node</span>'s mother; that'll be undef if
    <span class="Li">$node</span> is root.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="copy($option)"><a class="permalink" href="#copy($option)">copy($option)</a></h2>
<p class="Pp">Returns a copy of the calling node (the invocant). E.g.: my($copy)
    = <span class="Li">$node</span> -&gt; copy;</p>
<p class="Pp"><span class="Li">$option</span> is a hashref of options, with
    these (key =&gt; value) pairs:</p>
<dl class="Bl-tag">
  <dt id="o~17"><a class="permalink" href="#o~17">o no_attribute_copy =&gt;
    $Boolean</a></dt>
  <dd>If set to 1, do not copy the node's attributes.
    <p class="Pp">If not specified, defaults to 0, which copies attributes.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss"><b>copy_at_and_under()</b></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="copy_at_and_under($options)"><a class="permalink" href="#copy_at_and_under($options)">copy_at_and_under($options)</a></h2>
<p class="Pp">This returns a copy of the subtree consisting of
    <span class="Li">$node</span> and everything under it.</p>
<p class="Pp">If you pass no options, copy_at_and_under pretends you've passed
    {}.</p>
<p class="Pp">This works by recursively building up the new tree from the
    leaves, duplicating nodes using
    <span class="Li">$orig_node</span>-&gt;copy($options_ref) and then linking
    them up into a new tree of the same shape.</p>
<p class="Pp">Options you specify are passed down to calls to
    <span class="Li">$node</span>-&gt;copy.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>copy_tree()</b></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="copy_tree($options)"><a class="permalink" href="#copy_tree($options)">copy_tree($options)</a></h2>
<p class="Pp">This returns the root of a copy of the tree that
    <span class="Li">$node</span> is a member of. If you pass no options,
    copy_tree pretends you've passed {}.</p>
<p class="Pp">This method is currently implemented as just a call to
    <span class="Li">$this</span>-&gt;root-&gt;copy_at_and_under($options), but
    magic may be added in the future.</p>
<p class="Pp">Options you specify are passed down to calls to
    <span class="Li">$node</span>-&gt;copy.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>daughters()</b></h2>
<p class="Pp">This returns the (possibly empty) list of daughters for
    <span class="Li">$node</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="decode_lol($lol)"><a class="permalink" href="#decode_lol($lol)">decode_lol($lol)</a></h2>
<p class="Pp">Returns an arrayref having decoded the deeply nested structure
    <span class="Li">$lol</span>.</p>
<p class="Pp"><span class="Li">$lol</span> will be the output of either
    <b>tree_to_lol()</b> or <b>tree_to_simple_lol()</b>.</p>
<p class="Pp">See scripts/read.tree.pl, and it's output file
    scripts/read.tree.log.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>delete_tree()</b></h2>
<p class="Pp">Destroys the entire tree that <span class="Li">$node</span> is a
    member of (starting at the root), by nulling out each node-object's
    attributes (including, most importantly, its linkage attributes -- hopefully
    this is more than sufficient to eliminate all circularity in the data
    structure), and then moving it into the class DEADNODE.</p>
<p class="Pp">Use this when you're finished with the tree in question, and want
    to free up its memory. (If you don't do this, it'll get freed up anyway when
    your program ends.)</p>
<p class="Pp">If you try calling any methods on any of the node objects in the
    tree you've destroyed, you'll get an error like:</p>
<p class="Pp"></p>
<pre>  Can't locate object method &quot;leaves_under&quot;
    via package &quot;DEADNODE&quot;.
</pre>
<p class="Pp">So if you see that, that's what you've done wrong. (Actually, the
    class DEADNODE does provide one method: a no-op method
    &quot;delete_tree&quot;. So if you want to delete a tree, but think you may
    have deleted it already, it's safe to call
    <span class="Li">$node</span>-&gt;delete_tree on it (again).)</p>
<p class="Pp">The &quot;<b>delete_tree()</b>&quot; method is needed because
    Perl's garbage collector would never (as currently implemented) see that it
    was time to de-allocate the memory the tree uses -- until either you call
    <span class="Li">$node</span>-&gt;delete_tree, or until the program stops
    (at &quot;global destruction&quot; time, when <b>everything</b> is
    unallocated).</p>
<p class="Pp">Incidentally, there are better ways to do garbage-collecting on a
    tree, ways which don't require the user to explicitly call a method like
    &quot;<b>delete_tree()</b>&quot; -- they involve dummy classes, as explained
    at &lt;http://mox.perl.com/misc/circle-destroy.pod&gt;</p>
<p class="Pp">However, introducing a dummy class concept into
    <span class="Li">&quot;Tree::DAG_Node&quot;</span> would be rather a
    distraction. If you want to do this with your derived classes, via a DESTROY
    in a dummy class (or in a tree-metainformation class, maybe), then feel free
    to.</p>
<p class="Pp">The only case where I can imagine &quot;<b>delete_tree()</b>&quot;
    failing to totally void the tree, is if you use the hashref in the
    &quot;attributes&quot; attribute to store (presumably among other things)
    references to other nodes' &quot;attributes&quot; hashrefs -- which 1) is
    maybe a bit odd, and 2) is your problem, because it's your hash structure
    that's circular, not the tree's. Anyway, consider:</p>
<p class="Pp"></p>
<pre>      # null out all my &quot;attributes&quot; hashes
      $anywhere-&gt;root-&gt;walk_down({
        'callback' =&gt; sub {
          $hr = $_[0]-&gt;attributes; %$hr = (); return 1;
        }
      });
      # And then:
      $anywhere-&gt;delete_tree;
</pre>
<p class="Pp">(I suppose &quot;<b>delete_tree()</b>&quot; is a
    &quot;destructor&quot;, or as close as you can meaningfully come for a
    circularity-rich data structure in Perl.)</p>
<p class="Pp">See also &quot;WHEN AND HOW TO DESTROY THE TREE&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>depth_under()</b></h2>
<p class="Pp">Returns an integer representing the number of branches between
    this <span class="Li">$node</span> and the most distant leaf under it. (In
    other words, this returns the ply of subtree starting of
    <span class="Li">$node</span>. Consider scalar($it-&gt;ancestors) if you
    want the ply of a node within the whole tree.)</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>descendants()</b></h2>
<p class="Pp">Returns a list consisting of all the descendants of
    <span class="Li">$node</span>. Returns empty-list if
    <span class="Li">$node</span> is a terminal_node.</p>
<p class="Pp">(Note that it's spelled &quot;descendants&quot;, not
    &quot;descendents&quot;.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="draw_ascii_tree(_$options_)"><a class="permalink" href="#draw_ascii_tree(_$options_)">draw_ascii_tree([$options])</a></h2>
<p class="Pp">Here, the [] refer to an optional parameter.</p>
<p class="Pp">Returns an arrayref of lines suitable for printing.</p>
<p class="Pp">Draws a nice ASCII-art representation of the tree structure.</p>
<p class="Pp">The tree looks like:</p>
<p class="Pp"></p>
<pre>                     |
                  &lt;Root&gt;
           /-------+-----+---+---\
           |       |     |   |   |
          &lt;I&gt;     &lt;H&gt;   &lt;D&gt; &lt;E&gt; &lt;B&gt;
         /---\   /---\   |   |   |
         |   |   |   |  &lt;F&gt; &lt;F&gt; &lt;C&gt;
        &lt;J&gt; &lt;J&gt; &lt;J&gt; &lt;J&gt;  |   |
         |   |   |   |  &lt;G&gt; &lt;G&gt;
        &lt;K&gt; &lt;L&gt; &lt;K&gt; &lt;L&gt;
             |       |
            &lt;M&gt;     &lt;M&gt;
             |       |
            &lt;N&gt;     &lt;N&gt;
             |       |
            &lt;O&gt;     &lt;O&gt;
</pre>
<p class="Pp">See scripts/cut.and.paste.subtrees.pl.</p>
<p class="Pp">Example usage:</p>
<p class="Pp"></p>
<pre>  print map(&quot;$_\n&quot;, @{$tree-&gt;draw_ascii_tree});
</pre>
<p class="Pp"><i></i><b><i>draw_ascii_tree()</i></b><i></i> takes parameters you
    set in the <span class="Li">$options</span> hashref:</p>
<dl class="Bl-tag">
  <dt id="o~18"><a class="permalink" href="#o~18">o h_compact</a></dt>
  <dd>Takes 0 or 1. Sets the extent to which
      <i></i><b><i>draw_ascii_tree()</i></b><i></i> tries to save horizontal
      space.
    <p class="Pp">If I think of a better scrunching algorithm, there'll be a
        &quot;2&quot; setting for this.</p>
    <p class="Pp">Default: 1.</p>
  </dd>
  <dt id="o~19"><a class="permalink" href="#o~19">o h_spacing</a></dt>
  <dd>Takes a number 0 or greater. Sets the number of spaces inserted
      horizontally between nodes (and groups of nodes) in a tree.
    <p class="Pp">Default: 1.</p>
  </dd>
  <dt id="o~20"><a class="permalink" href="#o~20">o no_name</a></dt>
  <dd>If true, <i></i><b><i>draw_ascii_tree()</i></b><i></i> doesn't print the
      name of the node; it simply prints a &quot;*&quot;.
    <p class="Pp">Default: 0 (i.e., print the node name.)</p>
  </dd>
  <dt id="o~21"><a class="permalink" href="#o~21">o v_compact</a></dt>
  <dd>Takes a number 0, 1, or 2. Sets the degree to which
      <i></i><b><i>draw_ascii_tree()</i></b><i></i> tries to save vertical
      space. Defaults to 1.</dd>
</dl>
<p class="Pp">The code occasionally returns trees that are a bit cock-eyed in
    parts; if anyone can suggest a better drawing algorithm, I'd be
    appreciative.</p>
<p class="Pp">See also &quot;tree2string($options, [$some_tree])&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="dump_names($options)"><a class="permalink" href="#dump_names($options)">dump_names($options)</a></h2>
<p class="Pp">Returns an array.</p>
<p class="Pp">Dumps, as an indented list, the names of the nodes starting at
    <span class="Li">$node</span>, and continuing under it. Options are:</p>
<dl class="Bl-tag">
  <dt id="o~22"><a class="permalink" href="#o~22">o _depth -- A nonnegative
    number</a></dt>
  <dd>Indicating the depth to consider <span class="Li">$node</span> as being at
      (and so the generation under that is that plus one, etc.). You may choose
      to use set _depth =&gt; scalar($node-&gt;ancestors).
    <p class="Pp">Default: 0.</p>
  </dd>
  <dt id="o~23"><a class="permalink" href="#o~23">o tick -- a string to preface
    each entry with</a></dt>
  <dd>This string goes between the indenting-spacing and the node's name. You
      may prefer &quot;*&quot; or &quot;-&gt; &quot; or something.
    <p class="Pp">Default: ''.</p>
  </dd>
  <dt id="o~24"><a class="permalink" href="#o~24">o indent -- the string used to
    indent with</a></dt>
  <dd>Another sane value might be '. ' (period, space). Setting it to
      empty-string suppresses indenting.
    <p class="Pp">Default: ' ' x 2.</p>
  </dd>
</dl>
<p class="Pp">The output is not printed, but is returned as a list, where each
    item is a line, with a &quot;\n&quot; at the end.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="format_node($options,_$node)"><a class="permalink" href="#format_node($options,_$node)">format_node($options,
  $node)</a></h2>
<p class="Pp">Returns a string consisting of the node's name and, optionally,
    it's attributes.</p>
<p class="Pp">Possible keys in the <span class="Li">$options</span> hashref:</p>
<dl class="Bl-tag">
  <dt id="o~25"><a class="permalink" href="#o~25">o no_attributes =&gt;
    $Boolean</a></dt>
  <dd>If 1, the node's attributes are not included in the string returned.
    <p class="Pp">Default: 0 (include attributes).</p>
  </dd>
</dl>
<p class="Pp">Calls &quot;hashref2string($hashref)&quot;.</p>
<p class="Pp">Called by &quot;node2string($options,
    <span class="Li">$node</span>,
  <span class="Li">$vert_dashes</span>)&quot;.</p>
<p class="Pp">You would not normally call this method.</p>
<p class="Pp">If you don't wish to supply options, use format_node({},
    <span class="Li">$node</span>).</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>generation()</b></h2>
<p class="Pp">Returns a list of all nodes (going left-to-right) that are in
    <span class="Li">$node</span>'s generation -- i.e., that are the some number
    of nodes down from the root.
    <span class="Li">$root</span>-&gt;<b>generation()</b> is just
    <span class="Li">$root</span>.</p>
<p class="Pp">Of course, <span class="Li">$node</span> is always in its own
    generation.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="generation_under($node)"><a class="permalink" href="#generation_under($node)">generation_under($node)</a></h2>
<p class="Pp">Like &quot;<b>generation()</b>&quot;, but returns only the nodes
    in <span class="Li">$node</span>'s generation that are also descendants of
    <span class="Li">$node</span> -- in other words,</p>
<p class="Pp"></p>
<pre>    @us = $node-&gt;generation_under( $node-&gt;mother-&gt;mother );
</pre>
<p class="Pp">is all <span class="Li">$node</span>'s first cousins (to borrow
    yet more kinship terminology) -- assuming <span class="Li">$node</span> does
    indeed have a grandmother. Actually &quot;cousins&quot; isn't quite an apt
    word, because <span class="Li">@us</span> ends up including
    <span class="Li">$node</span>'s siblings and
  <span class="Li">$node</span>.</p>
<p class="Pp">Actually, &quot;generation_under($node)&quot; is just an alias to
    &quot;<b>generation()</b>&quot;, but I figure that this:</p>
<p class="Pp"></p>
<pre>   @us = $node-&gt;generation_under($way_upline);
</pre>
<p class="Pp">is a bit more readable than this:</p>
<p class="Pp"></p>
<pre>   @us = $node-&gt;generation($way_upline);
</pre>
<p class="Pp">But it's up to you.</p>
<p class="Pp"><span class="Li">$node</span>-&gt;generation_under($node) returns
    just <span class="Li">$node</span>.</p>
<p class="Pp">If you call
    <span class="Li">$node</span>-&gt;generation_under($node) but NODE2 is not
    <span class="Li">$node</span> or an ancestor of
    <span class="Li">$node</span>, it behaves as if you called just
    <span class="Li">$node</span>-&gt;<b>generation()</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="hashref2string($hashref)"><a class="permalink" href="#hashref2string($hashref)">hashref2string($hashref)</a></h2>
<p class="Pp">Returns the given hashref as a string.</p>
<p class="Pp">Called by &quot;format_node($options,
    <span class="Li">$node</span>)&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="is_daughter_of($node2)"><a class="permalink" href="#is_daughter_of($node2)">is_daughter_of($node2)</a></h2>
<p class="Pp">Returns true iff <span class="Li">$node</span> is a daughter of
    <span class="Li">$node2</span>. Currently implemented as just a test of
    ($it-&gt;mother eq <span class="Li">$node2</span>).</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>is_node()</b></h2>
<p class="Pp">This always returns true. More pertinently,
    <span class="Li">$object</span>-&gt;can('is_node') is true (regardless of
    what &quot;<b>is_node()</b>&quot; would do if called) for objects belonging
    to this class or for any class derived from it.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>is_root()</b></h2>
<p class="Pp">Returns 1 if the caller is the root, and 0 if it is not.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>leaves_under()</b></h2>
<p class="Pp">Returns a list (going left-to-right) of all the leaf nodes under
    <span class="Li">$node</span>. (&quot;Leaf nodes&quot; are also called
    &quot;terminal nodes&quot; -- i.e., nodes that have no daughters.) Returns
    <span class="Li">$node</span> in the degenerate case of
    <span class="Li">$node</span> being a leaf itself.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>left_sister()</b></h2>
<p class="Pp">Returns the node that's the immediate left sister of
    <span class="Li">$node</span>. If <span class="Li">$node</span> is the
    leftmost (or only) daughter of its mother (or has no mother), then this
    returns undef.</p>
<p class="Pp">See also &quot;add_left_sisters(LIST)&quot; and
    &quot;add_right_sisters(LIST)&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>left_sisters()</b></h2>
<p class="Pp">Returns a list of nodes that're sisters to the left of
    <span class="Li">$node</span>. If <span class="Li">$node</span> is the
    leftmost (or only) daughter of its mother (or has no mother), then this
    returns an empty list.</p>
<p class="Pp">See also &quot;add_left_sisters(LIST)&quot; and
    &quot;add_right_sisters(LIST)&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="lol_to_tree($lol)"><a class="permalink" href="#lol_to_tree($lol)">lol_to_tree($lol)</a></h2>
<p class="Pp">This must be called as a class method.</p>
<p class="Pp">Converts something like bracket-notation for &quot;Chomsky
    trees&quot; (or rather, the closest you can come with Perl
    list-of-lists(-of-lists(-of-lists))) into a tree structure. Returns the root
    of the tree converted.</p>
<p class="Pp">The conversion rules are that: 1) if the last (possibly the only)
    item in a given list is a scalar, then that is used as the &quot;name&quot;
    attribute for the node based on this list. 2) All other items in the list
    represent daughter nodes of the current node -- recursively so, if they are
    list references; otherwise, (non-terminal) scalars are considered to denote
    nodes with that name. So ['Foo', 'Bar', 'N'] is an alternate way to
    represent [['Foo'], ['Bar'], 'N'].</p>
<p class="Pp">An example will illustrate:</p>
<p class="Pp"></p>
<pre>  use Tree::DAG_Node;
  $lol =
    [
      [
        [ [ 'Det:The' ],
          [ [ 'dog' ], 'N'], 'NP'],
        [ '/with rabies\\', 'PP'],
        'NP'
      ],
      [ 'died', 'VP'],
      'S'
    ];
   $tree = Tree::DAG_Node-&gt;lol_to_tree($lol);
   $diagram = $tree-&gt;draw_ascii_tree;
   print map &quot;$_\n&quot;, @$diagram;
</pre>
<p class="Pp">...returns this tree:</p>
<p class="Pp"></p>
<pre>                   |
                  &lt;S&gt;
                   |
                /------------------\
                |                  |
              &lt;NP&gt;                &lt;VP&gt;
                |                  |
        /---------------\        &lt;died&gt;
        |               |
      &lt;NP&gt;            &lt;PP&gt;
        |               |
     /-------\   &lt;/with rabies\&gt;
     |       |
 &lt;Det:The&gt;  &lt;N&gt;
             |
           &lt;dog&gt;
</pre>
<p class="Pp">By the way (and this rather follows from the above rules), when
    denoting a LoL tree consisting of just one node, this:</p>
<p class="Pp"></p>
<pre>  $tree = Tree::DAG_Node-&gt;lol_to_tree( 'Lonely' );
</pre>
<p class="Pp">is okay, although it'd probably occur to you to denote it only
  as:</p>
<p class="Pp"></p>
<pre>  $tree = Tree::DAG_Node-&gt;lol_to_tree( ['Lonely'] );
</pre>
<p class="Pp">which is of course fine, too.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>mother()</b></h2>
<p class="Pp">This returns what node is <span class="Li">$node</span>'s mother.
    This is undef if <span class="Li">$node</span> has no mother -- i.e., if it
    is a root.</p>
<p class="Pp">See also &quot;<b>is_root()</b>&quot; and
    &quot;<b>root()</b>&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>my_daughter_index()</b></h2>
<p class="Pp">Returns what index this daughter is, in its mother's
    <span class="Li">&quot;daughter&quot;</span> list. In other words, if
    <span class="Li">$node</span> is ($node-&gt;mother-&gt;daughters)[3], then
    <span class="Li">$node</span>-&gt;my_daughter_index returns 3.</p>
<p class="Pp">As a special case, returns 0 if <span class="Li">$node</span> has
    no mother.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>name()</b></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="name("><a class="permalink" href="#name(">name(SCALAR)</a></h2>
<p class="Pp">In the first form, returns the value of the node object's
    &quot;name&quot; attribute. In the second form, sets it to the value of
    SCALAR.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="new($hashref)"><a class="permalink" href="#new($hashref)">new($hashref)</a></h2>
<p class="Pp">These options are supported in
  <span class="Li">$hashref:</span></p>
<dl class="Bl-tag">
  <dt id="o~26"><a class="permalink" href="#o~26">o attributes =&gt; A hashref
    of attributes</a></dt>
  <dd></dd>
  <dt id="o~27"><a class="permalink" href="#o~27">o daughters =&gt; An arrayref
    of nodes</a></dt>
  <dd></dd>
  <dt id="o~28"><a class="permalink" href="#o~28">o mother =&gt; A node</a></dt>
  <dd></dd>
  <dt id="o~29"><a class="permalink" href="#o~29">o name =&gt; A string</a></dt>
  <dd></dd>
</dl>
<p class="Pp">See also &quot;MAIN CONSTRUCTOR, AND INITIALIZER&quot; for a long
    discussion on object creation.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>new_daughter()</b></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="new_daughter($options)"><a class="permalink" href="#new_daughter($options)">new_daughter($options)</a></h2>
<p class="Pp">This <b>constructs</b> a <b>new</b> node (of the same class as
    <span class="Li">$mother</span>), and adds it to the (right) end of the
    daughter list of <span class="Li">$mother</span>. This is essentially the
    same as going</p>
<p class="Pp"></p>
<pre>      $daughter = $mother-&gt;new;
      $mother-&gt;add_daughter($daughter);
</pre>
<p class="Pp">but is rather more efficient because (since
    <span class="Li">$daughter</span> is guaranteed new and isn't linked to/from
    anything), it doesn't have to check that <span class="Li">$daughter</span>
    isn't an ancestor of <span class="Li">$mother</span>, isn't already daughter
    to a mother it needs to be unlinked from, isn't already in
    <span class="Li">$mother</span>'s daughter list, etc.</p>
<p class="Pp">As you'd expect for a constructor, it returns the node-object
    created.</p>
<p class="Pp">Note that if you radically change 'mother'/'daughters'
    bookkeeping, you may have to change this routine, since it's one of the
    places that directly writes to 'daughters' and 'mother'.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>new_daughter_left()</b></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="new_daughter_left($options)"><a class="permalink" href="#new_daughter_left($options)">new_daughter_left($options)</a></h2>
<p class="Pp">This is just like
    <span class="Li">$mother</span>-&gt;new_daughter, but adds the new daughter
    to the left (start) of <span class="Li">$mother</span>'s daughter list.</p>
<p class="Pp">Note that if you radically change 'mother'/'daughters'
    bookkeeping, you may have to change this routine, since it's one of the
    places that directly writes to 'daughters' and 'mother'.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="node2string($options,_$node,_$vert_dashes)"><a class="permalink" href="#node2string($options,_$node,_$vert_dashes)">node2string($options,
  $node, $vert_dashes)</a></h2>
<p class="Pp">Returns a string of the node's name and attributes, with a leading
    indent, suitable for printing.</p>
<p class="Pp">Possible keys in the <span class="Li">$options</span> hashref:</p>
<dl class="Bl-tag">
  <dt id="o~30"><a class="permalink" href="#o~30">o no_attributes =&gt;
    $Boolean</a></dt>
  <dd>If 1, the node's attributes are not included in the string returned.
    <p class="Pp">Default: 0 (include attributes).</p>
  </dd>
</dl>
<p class="Pp">Ignore the parameter <span class="Li">$vert_dashes</span>. The
    code uses it as temporary storage.</p>
<p class="Pp">Calls &quot;format_node($options,
    <span class="Li">$node</span>)&quot;.</p>
<p class="Pp">Called by &quot;tree2string($options, [$some_tree])&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="quote_name($name)"><a class="permalink" href="#quote_name($name)">quote_name($name)</a></h2>
<p class="Pp">Returns the string &quot;'$name'&quot;, which is used in various
    methods for outputting node names.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="random_network($options)"><a class="permalink" href="#random_network($options)">random_network($options)</a></h2>
<p class="Pp">This method can be called as a class method or as an object
    method.</p>
<p class="Pp">In the first case, constructs a randomly arranged network under a
    new node, and returns the root node of that tree. In the latter case,
    constructs the network under <span class="Li">$node</span>.</p>
<p class="Pp">Currently, this is implemented a bit half-heartedly, and
    half-wittedly. I basically needed to make up random-looking networks to
    stress-test the various tree-dumper methods, and so wrote this. If you
    actually want to rely on this for any application more serious than that, I
    suggest examining the source code and seeing if this does really what you
    need (say, in reliability of randomness); and feel totally free to suggest
    changes to me (especially in the form of &quot;I rewrote
    &quot;random_network($options)&quot;, here's the code...&quot;)</p>
<p class="Pp">It takes four options:</p>
<dl class="Bl-tag">
  <dt id="o~31"><a class="permalink" href="#o~31">o max_node_count -- maximum
    number of nodes this tree will be allowed to have (counting the
    root)</a></dt>
  <dd>Default: 25.</dd>
  <dt id="o~32"><a class="permalink" href="#o~32">o min_depth -- minimum depth
    for the tree</a></dt>
  <dd>Leaves can be generated only after this depth is reached, so the tree will
      be at least this deep -- unless max_node_count is hit first.
    <p class="Pp">Default: 2.</p>
  </dd>
  <dt id="o~33"><a class="permalink" href="#o~33">o max_depth -- maximum depth
    for the tree</a></dt>
  <dd>The tree will not be deeper than this.
    <p class="Pp">Default: 3 plus min_depth.</p>
  </dd>
  <dt id="o~34"><a class="permalink" href="#o~34">o max_children -- maximum
    number of children any mother in the tree can have.</a></dt>
  <dd>Default: 4.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="read_attributes($s)"><a class="permalink" href="#read_attributes($s)">read_attributes($s)</a></h2>
<p class="Pp">Parses the string <span class="Li">$s</span> and extracts the name
    and attributes, assuming the format is as generated by
    &quot;tree2string($options, [$some_tree])&quot;.</p>
<p class="Pp">This bascially means the attribute string was generated by
    &quot;hashref2string($hashref)&quot;.</p>
<p class="Pp">Attributes may be absent, in which case they default to {}.</p>
<p class="Pp">Returns a new node with this name and these attributes.</p>
<p class="Pp">This method is for use by &quot;read_tree($file_name)&quot;.</p>
<p class="Pp">See t/tree.without.attributes.txt and t/tree.with.attributes.txt
    for sample data.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="read_tree($file_name)"><a class="permalink" href="#read_tree($file_name)">read_tree($file_name)</a></h2>
<p class="Pp">Returns the root of the tree read from
    <span class="Li">$file_name</span>.</p>
<p class="Pp">The file must have been written by re-directing the output of
    &quot;tree2string($options, [$some_tree])&quot; to a file, since it makes
    assumptions about the format of the stringified attributes.</p>
<p class="Pp"><b>read_tree()</b> works with utf-8 data. See t/read.tree.t and
    t/tree.utf8.attributes.txt.</p>
<p class="Pp">Note: To call this method you need a caller. It'll be a tree of 1
    node. The reason is that inside this method it calls various other methods,
    and for these calls it needs <span class="Li">$self</span>. That way, those
    methods can be called from anywhere, and not just from within
    <b>read_tree()</b>.</p>
<p class="Pp">For reading and writing trees to databases, see
    Tree::DAG_Node::Persist.</p>
<p class="Pp">Calls &quot;string2hashref($s)&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="remove_daughter("><a class="permalink" href="#remove_daughter(">remove_daughter(LIST)</a></h2>
<p class="Pp">An exact synonym for &quot;remove_daughters(LIST)&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="remove_daughters("><a class="permalink" href="#remove_daughters(">remove_daughters(LIST)</a></h2>
<p class="Pp">This removes the nodes listed in LIST from
    <span class="Li">$mother</span>'s daughter list. This is a no-operation if
    LIST is empty. If there are things in LIST that aren't a current daughter of
    <span class="Li">$mother</span>, they are ignored.</p>
<p class="Pp">Not to be confused with &quot;<b>clear_daughters()</b>&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="replace_with("><a class="permalink" href="#replace_with(">replace_with(LIST)</a></h2>
<p class="Pp">This replaces <span class="Li">$node</span> in its mother's
    daughter list, by unlinking <span class="Li">$node</span> and replacing it
    with the items in LIST. This returns a list consisting of
    <span class="Li">$node</span> followed by LIST, i.e., the nodes that
    replaced it.</p>
<p class="Pp">LIST can include <span class="Li">$node</span> itself (presumably
    at most once). LIST can also be the empty list. However, if any items in
    LIST are sisters to <span class="Li">$node</span>, they are ignored, and are
    not in the copy of LIST passed as the return value.</p>
<p class="Pp">As you might expect for any linking operation, the items in LIST
    cannot be <span class="Li">$node</span>'s mother, or any ancestor to it; and
    items in LIST are, of course, unlinked from their mothers (if they have any)
    as they're linked to <span class="Li">$node</span>'s mother.</p>
<p class="Pp">(In the special (and bizarre) case where
    <span class="Li">$node</span> is root, this simply calls
    <span class="Li">$this</span>-&gt;unlink_from_mother on all the items in
    LIST, making them roots of their own trees.)</p>
<p class="Pp">Note that the daughter-list of <span class="Li">$node</span> is
    not necessarily affected; nor are the daughter-lists of the items in LIST. I
    mention this in case you think replace_with switches one node for another,
    with respect to its mother list <b>and</b> its daughter list, leaving the
    rest of the tree unchanged. If that's what you want, replacing
    <span class="Li">$Old</span> with <span class="Li">$New</span>, then you
    want:</p>
<p class="Pp"></p>
<pre>  $New-&gt;set_daughters($Old-&gt;clear_daughters);
  $Old-&gt;replace_with($New);
</pre>
<p class="Pp">(I can't say <span class="Li">$node</span>'s and LIST-items'
    daughter lists are <b>never</b> affected my replace_with -- they can be
    affected in this case:</p>
<p class="Pp"></p>
<pre>  $N1 = ($node-&gt;daughters)[0]; # first daughter of $node
  $N2 = ($N1-&gt;daughters)[0];   # first daughter of $N1;
  $N3 = Tree::DAG_Node-&gt;random_network; # or whatever
  $node-&gt;replace_with($N1, $N2, $N3);
</pre>
<p class="Pp">As a side affect of attaching <span class="Li">$N1</span> and
    <span class="Li">$N2</span> to <span class="Li">$node</span>'s mother,
    they're unlinked from their parents ($node, and <span class="Li">$N1</span>,
    respectively). But N3's daughter list is unaffected.</p>
<p class="Pp">In other words, this method does what it has to, as you'd expect
    it to.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>replace_with_daughters()</b></h2>
<p class="Pp">This replaces <span class="Li">$node</span> in its mother's
    daughter list, by unlinking <span class="Li">$node</span> and replacing it
    with its daughters. In other words, <span class="Li">$node</span> becomes
    motherless and daughterless as its daughters move up and take its place.
    This returns a list consisting of <span class="Li">$node</span> followed by
    the nodes that were its daughters.</p>
<p class="Pp">In the special (and bizarre) case where
    <span class="Li">$node</span> is root, this simply unlinks its daughters
    from it, making them roots of their own trees.</p>
<p class="Pp">Effectively the same as
    <span class="Li">$node</span>-&gt;replace_with($node-&gt;daughters), but
    more efficient, since less checking has to be done. (And I also think
    <span class="Li">$node</span>-&gt;replace_with_daughters is a more common
    operation in tree-wrangling than
    <span class="Li">$node</span>-&gt;replace_with(LIST), so deserves a named
    method of its own, but that's just me.)</p>
<p class="Pp">Note that if you radically change 'mother'/'daughters'
    bookkeeping, you may have to change this routine, since it's one of the
    places that directly writes to 'daughters' and 'mother'.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>right_sister()</b></h2>
<p class="Pp">Returns the node that's the immediate right sister of
    <span class="Li">$node</span>. If <span class="Li">$node</span> is the
    rightmost (or only) daughter of its mother (or has no mother), then this
    returns undef.</p>
<p class="Pp">See also &quot;add_left_sisters(LIST)&quot; and
    &quot;add_right_sisters(LIST)&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>right_sisters()</b></h2>
<p class="Pp">Returns a list of nodes that're sisters to the right of
    <span class="Li">$node</span>. If <span class="Li">$node</span> is the
    rightmost (or only) daughter of its mother (or has no mother), then this
    returns an empty list.</p>
<p class="Pp">See also &quot;add_left_sisters(LIST)&quot; and
    &quot;add_right_sisters(LIST)&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>root()</b></h2>
<p class="Pp">Returns the root of whatever tree <span class="Li">$node</span> is
    a member of. If <span class="Li">$node</span> is the root, then the result
    is <span class="Li">$node</span> itself.</p>
<p class="Pp">Not to be confused with &quot;<b>is_root()</b>&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>self_and_descendants()</b></h2>
<p class="Pp">Returns a list consisting of itself (as element 0) and all the
    descendants of <span class="Li">$node</span>. Returns just itself if
    <span class="Li">$node</span> is a terminal_node.</p>
<p class="Pp">(Note that it's spelled &quot;descendants&quot;, not
    &quot;descendents&quot;.)</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>self_and_sisters()</b></h2>
<p class="Pp">Returns a list of all nodes (going left-to-right) that have the
    same mother as <span class="Li">$node</span> -- including
    <span class="Li">$node</span> itself. This is just like
    <span class="Li">$node</span>-&gt;mother-&gt;daughters, except that that
    fails where <span class="Li">$node</span> is root, whereas
    <span class="Li">$root</span>-&gt;self_and_siblings, as a special case,
    returns <span class="Li">$root</span>.</p>
<p class="Pp">(Contrary to how you may interpret how this method is named,
    &quot;self&quot; is not (necessarily) the first element of what's
  returned.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="set_daughters("><a class="permalink" href="#set_daughters(">set_daughters(LIST)</a></h2>
<p class="Pp">This unlinks all <span class="Li">$mother</span>'s daughters, and
    replaces them with the daughters in LIST.</p>
<p class="Pp">Currently implemented as just
    <span class="Li">$mother</span>-&gt;clear_daughters followed by
    <span class="Li">$mother</span>-&gt;add_daughters(LIST).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="simple_lol_to_tree($simple_lol)"><a class="permalink" href="#simple_lol_to_tree($simple_lol)">simple_lol_to_tree($simple_lol)</a></h2>
<p class="Pp">This must be called as a class method.</p>
<p class="Pp">This is like lol_to_tree, except that rule 1 doesn't apply --
    i.e., all scalars (or really, anything not a listref) in the LoL-structure
    end up as named terminal nodes, and only terminal nodes get names (and, of
    course, that name comes from that scalar value). This method is useful for
    making things like expression trees, or at least starting them off. Consider
    that this:</p>
<p class="Pp"></p>
<pre>    $tree = Tree::DAG_Node-&gt;simple_lol_to_tree(
      [ 'foo', ['bar', ['baz'], 'quux'], 'zaz', 'pati' ]
    );
</pre>
<p class="Pp">converts from something like a Lispish or Iconish tree, if you
    pretend the brackets are parentheses.</p>
<p class="Pp">Note that there is a (possibly surprising) degenerate case of what
    I'm calling a &quot;simple-LoL&quot;, and it's like this:</p>
<p class="Pp"></p>
<pre>  $tree = Tree::DAG_Node-&gt;simple_lol_to_tree('Lonely');
</pre>
<p class="Pp">This is the (only) way you can specify a tree consisting of only a
    single node, which here gets the name 'Lonely'.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>sisters()</b></h2>
<p class="Pp">Returns a list of all nodes (going left-to-right) that have the
    same mother as <span class="Li">$node</span> -- <b>not including</b>
    <span class="Li">$node</span> itself. If <span class="Li">$node</span> is
    root, this returns empty-list.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="string2hashref($s)"><a class="permalink" href="#string2hashref($s)">string2hashref($s)</a></h2>
<p class="Pp">Returns the hashref built from the string.</p>
<p class="Pp">The string is expected to be something like '{AutoCommit =&gt;
    '1', PrintError =&gt; &quot;0&quot;, ReportError =&gt; 1}'.</p>
<p class="Pp">The empty string is returned as {}.</p>
<p class="Pp">Called by &quot;read_tree($file_name)&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>tree_to_lol()</b></h2>
<p class="Pp">Returns that tree (starting at <span class="Li">$node</span>)
    represented as a LoL, like what <span class="Li">$lol</span>, above, holds.
    (This is as opposed to &quot;tree_to_lol_notation($options)&quot;, which
    returns the viewable code like what gets evaluated and stored in
    <span class="Li">$lol</span>, above.)</p>
<p class="Pp">Undefined node names are returned as the string 'undef'.</p>
<p class="Pp">See also &quot;decode_lol($lol)&quot;.</p>
<p class="Pp">Lord only knows what you use this for -- maybe for feeding to
    Data::Dumper, in case &quot;tree_to_lol_notation($options)&quot; doesn't do
    just what you want?</p>
</section>
<section class="Ss">
<h2 class="Ss" id="tree_to_lol_notation($options)"><a class="permalink" href="#tree_to_lol_notation($options)">tree_to_lol_notation($options)</a></h2>
<p class="Pp">Dumps a tree (starting at <span class="Li">$node</span>) as the
    sort of LoL-like bracket notation you see in the above example code. Returns
    just one big block of text. The only option is &quot;multiline&quot; -- if
    true, it dumps the text as the sort of indented structure as seen above; if
    false (and it defaults to false), dumps it all on one line (with no
    indenting, of course).</p>
<p class="Pp">For example, starting with the tree from the above example,
  this:</p>
<p class="Pp"></p>
<pre>  print $tree-&gt;tree_to_lol_notation, &quot;\n&quot;;
</pre>
<p class="Pp">prints the following (which I've broken over two lines for sake of
    printability of documentation):</p>
<p class="Pp"></p>
<pre>  [[[['Det:The'], [['dog'], 'N'], 'NP'], [[&quot;/with rabies\x5c&quot;],
  'PP'], 'NP'], [['died'], 'VP'], 'S'],
</pre>
<p class="Pp">Doing this:</p>
<p class="Pp"></p>
<pre>  print $tree-&gt;tree_to_lol_notation({ multiline =&gt; 1 });
</pre>
<p class="Pp">prints the same content, just spread over many lines, and prettily
    indented.</p>
<p class="Pp">Undefined node names are returned as the string 'undef'.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>tree_to_simple_lol()</b></h2>
<p class="Pp">Returns that tree (starting at <span class="Li">$node</span>)
    represented as a simple-LoL -- i.e., one where non-terminal nodes are
    represented as listrefs, and terminal nodes are gotten from the contents of
    those nodes' &quot;name' attributes.</p>
<p class="Pp">Note that in the case of <span class="Li">$node</span> being
    terminal, what you get back is the same as
    <span class="Li">$node</span>-&gt;name.</p>
<p class="Pp">Compare to tree_to_simple_lol_notation.</p>
<p class="Pp">Undefined node names are returned as the string 'undef'.</p>
<p class="Pp">See also &quot;decode_lol($lol)&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="tree_to_simple_lol_notation($options)"><a class="permalink" href="#tree_to_simple_lol_notation($options)">tree_to_simple_lol_notation($options)</a></h2>
<p class="Pp">A simple-LoL version of tree_to_lol_notation (which see); takes
    the same options.</p>
<p class="Pp">Undefined node names are returned as the string 'undef'.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="tree2string($options,__$some_tree_)"><a class="permalink" href="#tree2string($options,__$some_tree_)">tree2string($options,
  [$some_tree])</a></h2>
<p class="Pp">Here, the [] represent an optional parameter.</p>
<p class="Pp">Returns an arrayref of lines, suitable for printing.</p>
<p class="Pp">Draws a nice ASCII-art representation of the tree structure.</p>
<p class="Pp">The tree looks like:</p>
<p class="Pp"></p>
<pre>        Root. Attributes: {}
            |--- &#x00C2;. Attributes: {# =&gt; &quot;&#x00C2;&#x00C2;&quot;}
            |    |--- &#x00E2;. Attributes: {# =&gt; &quot;&#x00E2;&#x00E2;&quot;}
            |    |    |--- &#x00C9;. Attributes: {# =&gt; &quot;&#x00C9;&#x00C9;&quot;}
            |    |--- &#x00E4;. Attributes: {# =&gt; &quot;&#x00E4;&#x00E4;&quot;}
            |    |--- &#x00E9;. Attributes: {# =&gt; &quot;&#x00E9;&#x00E9;&quot;}
            |         |--- &#x00D1;. Attributes: {# =&gt; &quot;&#x00D1;&#x00D1;&quot;}
            |              |--- &#x00F1;. Attributes: {# =&gt; &quot;&#x00F1;&#x00F1;&quot;}
            |                   |--- &#x00D4;. Attributes: {# =&gt; &quot;&#x00D4;&#x00D4;&quot;}
            |                        |--- &#x00F4;. Attributes: {# =&gt; &quot;&#x00F4;&#x00F4;&quot;}
            |                        |--- &#x00F4;. Attributes: {# =&gt; &quot;&#x00F4;&#x00F4;&quot;}
            |--- &#x00DF;. Attributes: {# =&gt; &quot;&#x00DF;&#x00DF;&quot;}
                 |--- &#x00AE;. Attributes: {# =&gt; &quot;&#x00AE;&#x00AE;&quot;}
                 |    |--- &#x00A9;. Attributes: {# =&gt; &quot;&#x00A9;&#x00A9;&quot;}
                 |--- &#x00A3;. Attributes: {# =&gt; &quot;&#x00A3;&#x00A3;&quot;}
                 |--- &#x20AC;. Attributes: {# =&gt; &quot;&#x20AC;&#x20AC;&quot;}
                 |--- &#x221A;. Attributes: {# =&gt; &quot;&#x221A;&#x221A;&quot;}
                 |--- &#x00D7;xX. Attributes: {# =&gt; &quot;&#x00D7;xX&#x00D7;xX&quot;}
                      |--- &#x00ED;. Attributes: {# =&gt; &quot;&#x00ED;&#x00ED;&quot;}
                      |--- &#x00FA;. Attributes: {# =&gt; &quot;&#x00FA;&#x00FA;&quot;}
                      |--- &#x00AB;. Attributes: {# =&gt; &quot;&#x00AB;&#x00AB;&quot;}
                      |--- &#x00BB;. Attributes: {# =&gt; &quot;&#x00BB;&#x00BB;&quot;}
</pre>
<p class="Pp">Or, without attributes:</p>
<p class="Pp"></p>
<pre>        Root
            |--- &#x00C2;
            |    |--- &#x00E2;
            |    |    |--- &#x00C9;
            |    |--- &#x00E4;
            |    |--- &#x00E9;
            |         |--- &#x00D1;
            |              |--- &#x00F1;
            |                   |--- &#x00D4;
            |                        |--- &#x00F4;
            |                        |--- &#x00F4;
            |--- &#x00DF;
                 |--- &#x00AE;
                 |    |--- &#x00A9;
                 |--- &#x00A3;
                 |--- &#x20AC;
                 |--- &#x221A;
                 |--- &#x00D7;xX
                      |--- &#x00ED;
                      |--- &#x00FA;
                      |--- &#x00AB;
                      |--- &#x00BB;
</pre>
<p class="Pp">See scripts/cut.and.paste.subtrees.pl.</p>
<p class="Pp">Example usage:</p>
<p class="Pp"></p>
<pre>  print map(&quot;$_\n&quot;, @{$tree-&gt;tree2string});
</pre>
<p class="Pp">Can be called with <span class="Li">$some_tree</span> set to any
    <span class="Li">$node</span>, and will print the tree assuming
    <span class="Li">$node</span> is the root.</p>
<p class="Pp">If you don't wish to supply options, use tree2string({},
    <span class="Li">$node</span>).</p>
<p class="Pp">Possible keys in the <span class="Li">$options</span> hashref
    (which defaults to {}):</p>
<dl class="Bl-tag">
  <dt id="o~35"><a class="permalink" href="#o~35">o no_attributes =&gt;
    $Boolean</a></dt>
  <dd>If 1, the node's attributes are not included in the string returned.
    <p class="Pp">Default: 0 (include attributes).</p>
  </dd>
</dl>
<p class="Pp">Calls &quot;node2string($options, <span class="Li">$node</span>,
    <span class="Li">$vert_dashes</span>)&quot;.</p>
<p class="Pp">See also &quot;draw_ascii_tree([$options])&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>unlink_from_mother()</b></h2>
<p class="Pp">This removes node from the daughter list of its mother. If it has
    no mother, this is a no-operation.</p>
<p class="Pp">Returns the mother unlinked from (if any).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="walk_down($options)"><a class="permalink" href="#walk_down($options)">walk_down($options)</a></h2>
<p class="Pp">Performs a depth-first traversal of the structure at and under
    <span class="Li">$node</span>. What it does at each node depends on the
    value of the options hashref, which you must provide. There are three
    options, &quot;callback&quot; and &quot;callbackback&quot; (at least one of
    which must be defined, as a sub reference), and &quot;_depth&quot;.</p>
<p class="Pp">This is what <i></i><b><i>walk_down()</i></b><i></i> does, in
    pseudocode form:</p>
<dl class="Bl-tag">
  <dt id="o~36"><a class="permalink" href="#o~36">o Starting point</a></dt>
  <dd>Start at the <span class="Li">$node</span> given.</dd>
  <dt id="o~37"><a class="permalink" href="#o~37">o Callback</a></dt>
  <dd>If there's a <i>callback</i>, call it with <span class="Li">$node</span>
      as the first argument, and the options hashref as the second argument
      (which contains the potentially useful <i>_depth</i>, remember). This
      function must return true or false -- if false, it will block the next
      step:</dd>
  <dt id="o~38"><a class="permalink" href="#o~38">o Daughters</a></dt>
  <dd>If <span class="Li">$node</span> has any daughter nodes, increment
      <i>_depth</i>, and call
      <span class="Li">$daughter</span>-&gt;walk_down($options) for each
      daughter (in order, of course), where options_hashref is the same hashref
      it was called with. When this returns, decrements <i>_depth</i>.</dd>
  <dt id="Callbackback"><a class="permalink" href="#Callbackback">Callbackback</a></dt>
  <dd>If there's a <i>callbackback</i>, call just it as with <i>callback</i>
      (but tossing out the return value). Note that <i>callback</i> returning
      false blocks traversal below <span class="Li">$node</span>, but doesn't
      block calling callbackback for <span class="Li">$node</span>.
      (Incidentally, in the unlikely case that <span class="Li">$node</span> has
      stopped being a node object, <i>callbackback</i> won't get called.)</dd>
  <dt id="o~39"><a class="permalink" href="#o~39">o Return</a></dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li">$node</span>-&gt;walk_down($options) is the way
    to recursively do things to a tree (if you start at the root) or part of a
    tree; if what you're doing is best done via pre-pre order traversal, use
    <i>callback</i>; if what you're doing is best done with post-order
    traversal, use <i>callbackback</i>. <i></i><b><i>walk_down()</i></b><i></i>
    is even the basis for plenty of the methods in this class. See the source
    code for examples both simple and horrific.</p>
<p class="Pp">Note that if you don't specify <i>_depth</i>, it effectively
    defaults to 0. You should set it to scalar($node-&gt;ancestors) if you want
    <i>_depth</i> to reflect the true depth-in-the-tree for the nodes called,
    instead of just the depth below <span class="Li">$node</span>. (If
    <span class="Li">$node</span> is the root, there's no difference, of
    course.)</p>
<p class="Pp">And <b>by the way</b>, it's a bad idea to modify the tree from the
    callback. Unpredictable things may happen. I instead suggest having your
    callback add to a stack of things that need changing, and then, once
    <i></i><b><i>walk_down()</i></b><i></i> is all finished, changing those
    nodes from that stack.</p>
<p class="Pp">Note that the existence of <i></i><b><i>walk_down()</i></b><i></i>
    doesn't mean you can't write you own special-use traversers.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="WHEN_AND_HOW_TO_DESTROY_THE_TREE"><a class="permalink" href="#WHEN_AND_HOW_TO_DESTROY_THE_TREE">WHEN
  AND HOW TO DESTROY THE TREE</a></h1>
<p class="Pp">It should be clear to you that if you've built a big parse tree or
    something, and then you're finished with it, you should call
    <span class="Li">$some_node</span>-&gt;delete_tree on it if you want the
    memory back.</p>
<p class="Pp">But consider this case: you've got this tree:</p>
<p class="Pp"></p>
<pre>      A
    / | \
   B  C  D
   |     | \
   E     X  Y
</pre>
<p class="Pp">Let's say you decide you don't want D or any of its descendants in
    the tree, so you call D-&gt;unlink_from_mother. This does NOT automagically
    destroy the tree D-X-Y. Instead it merely splits the tree into two:</p>
<p class="Pp"></p>
<pre>     A                        D
    / \                      / \
   B   C                    X   Y
   |
   E
</pre>
<p class="Pp">To destroy D and its little tree, you have to explicitly call
    delete_tree on it.</p>
<p class="Pp">Note, however, that if you call C-&gt;unlink_from_mother, and if
    you don't have a link to C anywhere, then it <b>does</b> magically go away.
    This is because nothing links to C -- whereas with the D-X-Y tree, D links
    to X and Y, and X and Y each link back to D. Note that calling
    C-&gt;delete_tree is harmless -- after all, a tree of only one node is still
    a tree.</p>
<p class="Pp">So, this is a surefire way of getting rid of all
    <span class="Li">$node</span>'s children and freeing up the memory
    associated with them and their descendants:</p>
<p class="Pp"></p>
<pre>  foreach my $it ($node-&gt;clear_daughters) { $it-&gt;delete_tree }
</pre>
<p class="Pp">Just be sure not to do this:</p>
<p class="Pp"></p>
<pre>  foreach my $it ($node-&gt;daughters) { $it-&gt;delete_tree }
  $node-&gt;clear_daughters;
</pre>
<p class="Pp">That's bad; the first call to
    <span class="Li">$_</span>-&gt;delete_tree will climb to the root of
    <span class="Li">$node</span>'s tree, and nuke the whole tree, not just the
    bits under <span class="Li">$node</span>. You might as well have just called
    <span class="Li">$node</span>-&gt;delete_tree. (Moreavor, once
    <span class="Li">$node</span> is dead, you can't call clear_daughters on it,
    so you'll get an error there.)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUG_REPORTS"><a class="permalink" href="#BUG_REPORTS">BUG
  REPORTS</a></h1>
<p class="Pp">If you find a bug in this library, report it to me as soon as
    possible, at the address listed in the MAINTAINER section, below. Please try
    to be as specific as possible about how you got the bug to occur.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="HELP!"><a class="permalink" href="#HELP!">HELP!</a></h1>
<p class="Pp">If you develop a given routine for dealing with trees in some way,
    and use it a lot, then if you think it'd be of use to anyone else, do email
    me about it; it might be helpful to others to include that routine, or
    something based on it, in a later version of this module.</p>
<p class="Pp">It's occurred to me that you might like to (and might yourself
    develop routines to) draw trees in something other than ASCII art. If you do
    so -- say, for PostScript output, or for output interpretable by some
    external plotting program -- I'd be most interested in the results.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="RAMBLINGS"><a class="permalink" href="#RAMBLINGS">RAMBLINGS</a></h1>
<p class="Pp">This module uses &quot;strict&quot;, but I never wrote it with -w
    warnings in mind -- so if you use -w, do not be surprised if you see
    complaints from the guts of DAG_Node. As long as there is no way to turn off
    -w for a given module (instead of having to do it in every single subroutine
    with a &quot;local $^W&quot;), I'm not going to change this. However, I do,
    at points, get bursts of ambition, and I try to fix code in DAG_Node that
    generates warnings, <i>as I come across them</i> -- which is only
    occasionally. Feel free to email me any patches for any such fixes you come
    up with, tho.</p>
<p class="Pp">Currently I don't assume (or enforce) anything about the class
    membership of nodes being manipulated, other than by testing whether each
    one provides a method &quot;<b>is_node()</b>&quot;, a la:</p>
<p class="Pp"></p>
<pre>  die &quot;Not a node!!!&quot; unless UNIVERSAL::can($node, &quot;is_node&quot;);
</pre>
<p class="Pp">So, as far as I'm concerned, a given tree's nodes are free to
    belong to different classes, just so long as they provide/inherit
    &quot;<b>is_node()</b>&quot;, the few methods that this class relies on to
    navigate the tree, and have the same internal object structure, or a
    superset of it. Presumably this would be the case for any object belonging
    to a class derived from <span class="Li">&quot;Tree::DAG_Node&quot;</span>,
    or belonging to <span class="Li">&quot;Tree::DAG_Node&quot;</span>
  itself.</p>
<p class="Pp">When routines in this class access a node's &quot;mother&quot;
    attribute, or its &quot;daughters&quot; attribute, they (generally) do so
    directly (via <span class="Li">$node</span>-&gt;{'mother'}, etc.), for sake
    of efficiency. But classes derived from this class should probably do this
    instead thru a method (via <span class="Li">$node</span>-&gt;mother, etc.),
    for sake of portability, abstraction, and general goodness.</p>
<p class="Pp">However, no routines in this class (aside from, necessarily,
    <i></i><b><i>_init()</i></b><i></i>,
    <i></i><b><i>_init_name()</i></b><i></i>, and &quot;<b>name()</b>&quot;)
    access the &quot;name&quot; attribute directly; routines (like the various
    tree draw/dump methods) get the &quot;name&quot; value thru a call to
    <span class="Li">$obj</span>-&gt;<b>name()</b>. So if you want the object's
    name to not be a real attribute, but instead have it derived dynamically
    from some feature of the object (say, based on some of its other attributes,
    or based on its address), you can to override the &quot;<b>name()</b>&quot;
    method, without causing problems. (Be sure to consider the case of
    <span class="Li">$obj</span>-&gt;name as a write method, as it's used in
    <i>/lol_to_tree($lol)</i> and &quot;random_network($options)&quot;.)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FAQ"><a class="permalink" href="#FAQ">FAQ</a></h1>
<section class="Ss">
<h2 class="Ss" id="Which_is_the_best_tree_processing_module?"><a class="permalink" href="#Which_is_the_best_tree_processing_module?">Which
  is the best tree processing module?</a></h2>
<p class="Pp"><span class="Li">&quot;Tree::DAG_Node&quot;</span>, as it happens.
    More details: &quot;SEE ALSO&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_to_process_every_node_in_tree?"><a class="permalink" href="#How_to_process_every_node_in_tree?">How
  to process every node in tree?</a></h2>
<p class="Pp">See &quot;walk_down($options)&quot;.
    <span class="Li">$options</span> normally looks like this, assuming we wish
    to pass in an arrayref as a stack:</p>
<p class="Pp"></p>
<pre>        my(@stack);
        $tree -&gt; walk_down
        ({
                callback =&gt;
                sub
                {
                        my(@node, $options) = @_;
                        # Process $node, using $options...
                        push @{$$options{stack} }, $node -&gt; name;
                        return 1; # Keep walking.
                },
                _depth =&gt; 0,
                stack  =&gt; \@stack,
        });
        # Process @stack...
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_switch_from_Tree_to_Tree::DAG_Node?"><a class="permalink" href="#How_do_I_switch_from_Tree_to_Tree::DAG_Node?">How
  do I switch from Tree to Tree::DAG_Node?</a></h2>
<dl class="Bl-tag">
  <dt id="o~40"><a class="permalink" href="#o~40">o The node's name</a></dt>
  <dd>In <span class="Li">&quot;Tree&quot;</span> you use
      <span class="Li">$node</span> -&gt; value and in
      <span class="Li">&quot;Tree::DAG_Node&quot;</span> it's
      <span class="Li">$node</span> -&gt; name.</dd>
  <dt id="o~41"><a class="permalink" href="#o~41">o The node's
    attributes</a></dt>
  <dd>In <span class="Li">&quot;Tree&quot;</span> you use
      <span class="Li">$node</span> -&gt; meta and in
      <span class="Li">&quot;Tree::DAG_Node&quot;</span> it's
      <span class="Li">$node</span> -&gt; attributes.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Are_there_techniques_for_processing_lists_of_nodes?"><a class="permalink" href="#Are_there_techniques_for_processing_lists_of_nodes?">Are
  there techniques for processing lists of nodes?</a></h2>
<dl class="Bl-tag">
  <dt id="o~42"><a class="permalink" href="#o~42">o Copy the daughter list, and
    change it</a></dt>
  <dd>
    <pre>        @them    = $mother-&gt;daughters;
        @removed = splice(@them, 0, 2, @new_nodes);
        $mother-&gt;set_daughters(@them);
    </pre>
  </dd>
  <dt id="o~43"><a class="permalink" href="#o~43">o Select a sub-set of
    nodes</a></dt>
  <dd>
    <pre>        $mother-&gt;set_daughters
        (
                grep($_-&gt;name =~ /wanted/, $mother-&gt;daughters)
        );
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Why_did_you_break_up_the_sections_of_methods_in_the_"><a class="permalink" href="#Why_did_you_break_up_the_sections_of_methods_in_the_">Why
  did you break up the sections of methods in the POD?</a></h2>
<p class="Pp">Because I want to list the methods in alphabetical order.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Why_did_you_move_the_"><a class="permalink" href="#Why_did_you_move_the_">Why
  did you move the POD to the end?</a></h2>
<p class="Pp">Because the apostrophes in the text confused the syntax
    hightlighter in my editor UltraEdit.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<dl class="Bl-tag">
  <dt id="o~44"><a class="permalink" href="#o~44">o HTML::Element, HTML::Tree
    and HTML::TreeBuilder</a></dt>
  <dd>Sean is also the author of these modules.</dd>
  <dt id="o~45"><a class="permalink" href="#o~45">o Tree</a></dt>
  <dd>Lightweight.</dd>
  <dt id="o~46"><a class="permalink" href="#o~46">o Tree::Binary</a></dt>
  <dd>Lightweight.</dd>
  <dt id="o~47"><a class="permalink" href="#o~47">o
    Tree::DAG_Node::Persist</a></dt>
  <dd>Lightweight.</dd>
  <dt id="o~48"><a class="permalink" href="#o~48">o Tree::Persist</a></dt>
  <dd>Lightweight.</dd>
  <dt id="o~49"><a class="permalink" href="#o~49">o Forest</a></dt>
  <dd>Uses Moose.</dd>
</dl>
<p class="Pp"><span class="Li">&quot;Tree::DAG_Node&quot;</span> itself is also
    lightweight.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="REFERENCES"><a class="permalink" href="#REFERENCES">REFERENCES</a></h1>
<p class="Pp">Wirth, Niklaus. 1976. <i>Algorithms + Data Structures =
    Programs</i> Prentice-Hall, Englewood Cliffs, NJ.</p>
<p class="Pp">Knuth, Donald Ervin. 1997. <i>Art of Computer Programming, Volume
    1,</i> <i>Third Edition: Fundamental Algorithms</i>. Addison-Wesley,
    Reading, MA.</p>
<p class="Pp">Wirth's classic, currently and lamentably out of print, has a good
    section on trees. I find it clearer than Knuth's (if not quite as
    encyclopedic), probably because Wirth's example code is in a
    block-structured high-level language (basically Pascal), instead of in
    assembler (MIX).</p>
<p class="Pp">Until some kind publisher brings out a new printing of Wirth's
    book, try poking around used bookstores (or
    <span class="Li">&quot;www.abebooks.com&quot;</span>) for a copy. I think it
    was also republished in the 1980s under the title <i>Algorithms and Data
    Structures</i>, and in a German edition called <i>Algorithmen und
    Datenstrukturen</i>. (That is, I'm sure books by Knuth were published under
    those titles, but I'm <i>assuming</i> that they're just later
    printings/editions of <i>Algorithms + Data Structures =</i>
    <i>Programs</i>.)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MACHINE-READABLE_CHANGE_LOG"><a class="permalink" href="#MACHINE-READABLE_CHANGE_LOG">MACHINE-READABLE
  CHANGE LOG</a></h1>
<p class="Pp">The file Changes was converted into Changelog.ini by
    Module::Metadata::Changes.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="REPOSITORY"><a class="permalink" href="#REPOSITORY">REPOSITORY</a></h1>
<p class="Pp">&lt;https://github.com/ronsavage/Tree-DAG_Node&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
<p class="Pp">Email the author, or log a bug on RT:</p>
<p class="Pp">&lt;https://rt.cpan.org/Public/Dist/Display.html?Name=Tree-DAG_Node&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGEMENTS"><a class="permalink" href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></h1>
<p class="Pp">The code to print the tree, in <b>tree2string()</b>, was adapted
    from Forest::Tree::Writer::ASCIIWithBranches by the dread Stevan Little.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MAINTAINER"><a class="permalink" href="#MAINTAINER">MAINTAINER</a></h1>
<p class="Pp">David Hand,
    <span class="Li">&quot;&lt;cogent@cpan.org&gt;&quot;</span> up to V
  1.06.</p>
<p class="Pp">Ron Savage
    <span class="Li">&quot;&lt;rsavage@cpan.org&gt;&quot;</span> from V
  1.07.</p>
<p class="Pp">In this POD, usage of 'I' refers to Sean, up until V 1.07.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Sean M. Burke,
    <span class="Li">&quot;&lt;sburke@cpan.org&gt;&quot;</span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT,_LICENSE,_AND_DISCLAIMER"><a class="permalink" href="#COPYRIGHT,_LICENSE,_AND_DISCLAIMER">COPYRIGHT,
  LICENSE, AND DISCLAIMER</a></h1>
<p class="Pp">Copyright 1998-2001, 2004, 2007 by Sean M. Burke and David
  Hand.</p>
<p class="Pp">This Program of ours is 'OSI Certified Open Source Software'; you
    can redistribute it and/or modify it under the terms of The Perl License, a
    copy of which is available at: http://dev.perl.org/licenses/</p>
<p class="Pp">This program is distributed in the hope that it will be useful,
    but without any warranty; without even the implied warranty of
    merchantability or fitness for a particular purpose.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-02-13</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Importer(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Importer(3)</td>
    <td class="head-vol"><a href=".">User Contributed Perl Documentation</a></td>
    <td class="head-rtitle">Importer(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Importer - Alternative but compatible interface to modules that
    export symbols.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module acts as a layer between Exporter and modules which
    consume exports. It is feature-compatible with Exporter, plus some much
    needed extras. You can use this to import symbols from any exporter that
    follows Exporters specification. The exporter modules themselves do not need
    to use or inherit from the Exporter module, they just need to set
    <span class="Li">@EXPORT</span> and/or other variables.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    # Import defaults
    use Importer 'Some::Module';
    # Import a list
    use Importer 'Another::Module' =&gt; qw/foo bar baz/;
    # Import a specific version:
    use Importer 'That::Module' =&gt; '1.00';
    # Require a sepcific version of Importer
    use Importer 0.001, 'Foo::Bar' =&gt; qw/a b c/;
    foo()
    bar()
    baz()
    # Remove all subroutines imported by Importer
    no Importer;
    # Import symbols into variables
    my $croak = Importer-&gt;get_one(Carp =&gt; qw/croak/);
    $croak-&gt;(&quot;This will croak&quot;);
    my $CARP = Importer-&gt;get(Carp =&gt; qw/croak confess cluck/);
    $CARP-&gt;{croak}-&gt;(&quot;This will croak&quot;);
    $CARP-&gt;{cluck}-&gt;(&quot;This will cluck&quot;);
    $CARP-&gt;{confess}-&gt;(&quot;This will confess&quot;);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="WHY?"><a class="permalink" href="#WHY?">WHY?</a></h1>
<p class="Pp">There was recently a discussion on p5p about adding features to
    Exporter. This conversation raised some significant concerns, those are
    listed here, in addition to others.</p>
<dl class="Bl-tag">
  <dt id="The"><a class="permalink" href="#The">The burden is on export
    consumers to specify a version of Exporter</a></dt>
  <dd>Adding a feature to Exporter means that any consumer module that relies on
      the new features must depend on a specific version of Exporter. This seems
      somewhat backwards since Exporter is used by the module you are importing
      from.</dd>
  <dt id="Exporter.pm"><a class="permalink" href="#Exporter.pm">Exporter.pm is
    really old/crazy code</a></dt>
  <dd>Not much more to say here. It is very old, it is very crazy, and if you
      break it you break EVERYTHING.</dd>
  <dt id="Using"><a class="permalink" href="#Using">Using a modules
    <b>import()</b> for exporting makes it hard to give it other
    purposes</a></dt>
  <dd>It is not unusual for a module to want to export symbols and provide
      import behaviors. It is also not unusual for a consumer to only want 1 or
      the other. Using this module you can import symbols without also getting
      the <span class="Li">&quot;import()&quot;</span> side effects.
    <p class="Pp">In addition, moving forward, modules can specify exports and
        have a custom <span class="Li">&quot;import()&quot;</span> without
        conflating the two. A module can tell you to use Importer to get the
        symbols, and to use the module directly for behaviors. A module could
        also use Importer within its own
        <span class="Li">&quot;import()&quot;</span> method without the need to
        subclass Exporter, or bring in its
        <span class="Li">&quot;import()&quot;</span> method.</p>
  </dd>
  <dt id="There"><a class="permalink" href="#There">There are other exporter
    modules on cpan</a></dt>
  <dd>This module normally assumes an exporter uses Exporter, so it looks for
      the variables and methods Exporter expects. However, other exporters on
      cpan can override this using the
      <span class="Li">&quot;IMPORTER_MENU()&quot;</span> hook.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="COMPATIBILITY"><a class="permalink" href="#COMPATIBILITY">COMPATIBILITY</a></h1>
<p class="Pp">This module aims for 100% compatibility with every feature of
    Exporter, plus added features such as import renaming.</p>
<p class="Pp">If you find something that works differently, or not at all when
    compared to Exporter please report it as a bug, unless it is noted as an
    intentional feature (like import renaming).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="IMPORT_PARAMETERS"><a class="permalink" href="#IMPORT_PARAMETERS">IMPORT
  PARAMETERS</a></h1>
<pre>    use Importer $IMPORTER_VERSION, $FROM_MODULE, $FROM_MODULE_VERSION, \&amp;SET_SYMBOL, @SYMBOLS;
</pre>
<dl class="Bl-tag">
  <dt>$IMPORTER_VERSION (optional)</dt>
  <dd>If you provide a numeric argument as the first argument it will be treated
      as a version number. Importer will do a version check to make sure it is
      at least at the requested version.</dd>
  <dt>$FROM_MODULE (required)</dt>
  <dd>This is the only required argument. This is the name of the module to
      import symbols from.</dd>
  <dt>$FROM_MODULE_VERSION (optional)</dt>
  <dd>Any numeric argument following the <span class="Li">$FROM_MODULE</span>
      will be treated as a version check against
      <span class="Li">$FROM_MODULE</span>.</dd>
  <dt>\&amp;SET_SYMBOL (optional)</dt>
  <dd>Normally Importer will put the exports into your namespace. This is
      usually done via a more complex form of <span class="Li">&quot;*name =
      $ref&quot;</span>. If you do NOT want this to happen then you can provide
      a custom sub to handle the assignment.
    <p class="Pp">This is an example that uses this feature to put all the
        exports into a lexical hash instead of modifying the namespace (This is
        how the <span class="Li">&quot;get()&quot;</span> method is
        implemented).</p>
    <p class="Pp"></p>
    <pre>    my %CARP;
    use Importer Carp =&gt; sub {
        my ($name, $ref) = @_;
        $CARP{$name} = $ref;
    };
    $CARP{cluck}-&gt;(&quot;This will cluck&quot;);
    $CARP{croak}-&gt;(&quot;This will croak&quot;);
    </pre>
    <p class="Pp">The first two arguments to the custom sub are the name (no
        sigil), and the reference. The additional arguments are key/value
      pairs:</p>
    <p class="Pp"></p>
    <pre>    sub set_symbol {
        my ($name, $ref, %info) = @_;
    }
    </pre>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>$info{from}</dt>
  <dd>Package the symbol comes from.</dd>
  <dt>$info{into}</dt>
  <dd>Package to which the symbol should be added.</dd>
  <dt>$info{sig}</dt>
  <dd>The sigil that should be used.</dd>
  <dt>$info{spec}</dt>
  <dd>Extra details.</dd>
  <dt>$info{symbol}</dt>
  <dd>The original symbol name (with sigil) from the original package.</dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>@SYMBOLS (optional)</dt>
  <dd>Symbols you wish to import. If no symbols are specified then the defaults
      will be used. You may also specify tags using the ':' prefix.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORTED_FEATURES"><a class="permalink" href="#SUPPORTED_FEATURES">SUPPORTED
  FEATURES</a></h1>
<section class="Ss">
<h2 class="Ss">TAGS</h2>
<p class="Pp">You can define/import subsets of symbols using predefined
  tags.</p>
<p class="Pp"></p>
<pre>    use Importer 'Some::Thing' =&gt; ':tag';
</pre>
<p class="Pp">Importer will automatically populate the
    <span class="Li">&quot;:DEFAULT&quot;</span> tag for you. Importer will also
    give you an <span class="Li">&quot;:ALL&quot;</span> tag with ALL exports so
    long as the exporter does not define a
    <span class="Li">&quot;:ALL&quot;</span> tag already.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="/PATTERN/_or_qr/PATTERN/"><a class="permalink" href="#/PATTERN/_or_qr/PATTERN/">/PATTERN/
  or qr/PATTERN/</a></h2>
<p class="Pp">You can import all symbols that match a pattern. The pattern can
    be supplied a string starting and ending with '/', or you can provide a
    <span class="Li">&quot;qr/../&quot;</span> reference.</p>
<p class="Pp"></p>
<pre>    use Importer 'Some::Thing' =&gt; '/oo/';
    use Importer 'Some::Thing' =&gt; qr/oo/;
</pre>
</section>
<section class="Ss">
<h2 class="Ss">EXCLUDING SYMBOLS</h2>
<p class="Pp">You can exclude symbols by prefixing them with '!'.</p>
<p class="Pp"></p>
<pre>    use Importer 'Some::Thing'
        '!foo',         # Exclude one specific symbol
        '!/pattern/',   # Exclude all matching symbols
        '!' =&gt; qr/oo/,  # Exclude all that match the following arg
        '!:tag';        # Exclude all in tag
</pre>
</section>
<section class="Ss">
<h2 class="Ss">RENAMING SYMBOLS AT IMPORT</h2>
<p class="Pp"><i>This is a new feature,</i> Exporter <i>does not support this on
    its own.</i></p>
<p class="Pp">You can rename symbols at import time using a specification hash
    following the import name:</p>
<p class="Pp"></p>
<pre>    use Importer 'Some::Thing' =&gt; (
        foo =&gt; { -as =&gt; 'my_foo' },
    );
</pre>
<p class="Pp">You can also add a prefix and/or postfix:</p>
<p class="Pp"></p>
<pre>    use Importer 'Some::Thing' =&gt; (
        foo =&gt; { -prefix =&gt; 'my_' },
    );
</pre>
<p class="Pp">Using this syntax to set prefix and/or postfix also works on tags
    and patterns that are specified for import, in which case the prefix/postfix
    is applied to all symbols from the tag/patterm.</p>
</section>
<section class="Ss">
<h2 class="Ss">CUSTOM EXPORT ASSIGNMENT</h2>
<p class="Pp">This lets you provide an alternative to the
    <span class="Li">&quot;*name = $ref&quot;</span> export assignment. See the
    list of parameters to <span class="Li">&quot;import()&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss">UNIMPORTING</h2>
<p class="Pp">See &quot;UNIMPORT PARAMETERS&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss">ANONYMOUS EXPORTS</h2>
<p class="Pp">See &quot;%EXPORT_ANON&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss">GENERATED EXPORTS</h2>
<p class="Pp">See &quot;%EXPORT_GEN&quot;.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="UNIMPORT_PARAMETERS"><a class="permalink" href="#UNIMPORT_PARAMETERS">UNIMPORT
  PARAMETERS</a></h1>
<pre>    no Importer;    # Remove all subs brought in with Importer
    no Importer qw/foo bar/;    # Remove only the specified subs
</pre>
<p class="Pp"><b>Only subs can be unimported</b>.</p>
<p class="Pp"><b>You can only unimport subs imported using Importer</b>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORTED_VARIABLES"><a class="permalink" href="#SUPPORTED_VARIABLES">SUPPORTED
  VARIABLES</a></h1>
<section class="Ss">
<h2 class="Ss" id="@EXPORT"><a class="permalink" href="#@EXPORT">@EXPORT</a></h2>
<p class="Pp">This is used exactly the way Exporter uses it.</p>
<p class="Pp">List of symbols to export. Sigil is optional for subs. Symbols
    listed here are exported by default. If possible you should put symbols in
    <span class="Li">@EXPORT_OK</span> instead.</p>
<p class="Pp"></p>
<pre>    our @EXPORT = qw/foo bar &amp;baz $BAT/;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="@EXPORT_OK"><a class="permalink" href="#@EXPORT_OK">@EXPORT_OK</a></h2>
<p class="Pp">This is used exactly the way Exporter uses it.</p>
<p class="Pp">List of symbols that can be imported. Sigil is optional for subs.
    Symbols listed here are not exported by default. This is preferred over
    <span class="Li">@EXPORT</span>.</p>
<p class="Pp"></p>
<pre>    our @EXPORT_OK = qw/foo bar &amp;baz $BAT/;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_EXPORT_TAGS"><a class="permalink" href="#_EXPORT_TAGS">%EXPORT_TAGS</a></h2>
<p class="Pp">This module supports tags exactly the way Exporter does.</p>
<p class="Pp"></p>
<pre>    use Importer 'Some::Thing'  =&gt; ':DEFAULT';
    use Importer 'Other::Thing' =&gt; ':some_tag';
</pre>
<p class="Pp">Tags can be specified this way:</p>
<p class="Pp"></p>
<pre>    our %EXPORT_TAGS = (
        oos =&gt; [qw/foo boo zoo/],
        ees =&gt; [qw/fee bee zee/],
    );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="@EXPORT_FAIL"><a class="permalink" href="#@EXPORT_FAIL">@EXPORT_FAIL</a></h2>
<p class="Pp">This is used exactly the way Exporter uses it.</p>
<p class="Pp">Use this to list subs that are not available on all platforms. If
    someone tries to import one of these, Importer will hit your
    <span class="Li">&quot;$from-&gt;export_fail(@items)&quot;</span> callback
    to try to resolve the issue. See Exporter for documentation of this
  feature.</p>
<p class="Pp"></p>
<pre>    our @EXPORT_FAIL = qw/maybe_bad/;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_EXPORT_ANON"><a class="permalink" href="#_EXPORT_ANON">%EXPORT_ANON</a></h2>
<p class="Pp">This is new to this module, Exporter does not support it.</p>
<p class="Pp">This allows you to export symbols that are not actually in your
    package symbol table. The keys should be the symbol names, the values are
    the references for the symbols.</p>
<p class="Pp"></p>
<pre>    our %EXPORT_ANON = (
        '&amp;foo' =&gt; sub { 'foo' }
        '$foo' =&gt; \$foo,
        ...
    );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_EXPORT_GEN"><a class="permalink" href="#_EXPORT_GEN">%EXPORT_GEN</a></h2>
<p class="Pp">This is new to this module, Exporter does not support it.</p>
<p class="Pp">This allows you to export symbols that are generated on export.
    The key should be the name of a symbol. The value should be a coderef that
    produces a reference that will be exported.</p>
<p class="Pp">When the generators are called they will receive 2 arguments, the
    package the symbol is being exported into, and the symbol being imported
    (name may or may not include sigil for subs).</p>
<p class="Pp"></p>
<pre>    our %EXPORT_GEN = (
        '&amp;foo' =&gt; sub {
            my $from_package = shift;
            my ($into_package, $symbol_name) = @_;
            ...
            return sub { ... };
        },
        ...
    );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_EXPORT_MAGIC"><a class="permalink" href="#_EXPORT_MAGIC">%EXPORT_MAGIC</a></h2>
<p class="Pp">This is new to this module. Exporter does not support it.</p>
<p class="Pp">This allows you to define custom actions to run AFTER an export
    has been injected into the consumers namespace. This is a good place to
    enable parser hooks like with Devel::Declare. These will NOT be run if a
    consumer uses a custom assignment callback.</p>
<p class="Pp"></p>
<pre>    our %EXPORT_MAGIC = (
        foo =&gt; sub {
            my $from = shift;    # Should be the package doing the exporting
            my %args = @_;
            my $into      = $args{into};         # Package symbol was exported into
            my $orig_name = $args{orig_name};    # Original name of the export (in the exporter)
            my $new_name  = $args{new_name};     # Name the symbol was imported as
            my $ref       = $args{ref};          # The reference to the symbol
            ...; # whatever you want, return is ignored.
        },
    );
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CLASS_METHODS"><a class="permalink" href="#CLASS_METHODS">CLASS
  METHODS</a></h1>
<dl class="Bl-tag">
  <dt id="Importer"><a class="permalink" href="#Importer">Importer-&gt;import($from)</a></dt>
  <dd></dd>
  <dt id="Importer~2"><a class="permalink" href="#Importer~2">Importer-&gt;import($from,
    $version)</a></dt>
  <dd></dd>
  <dt id="Importer~3"><a class="permalink" href="#Importer~3">Importer-&gt;import($from,
    @imports)</a></dt>
  <dd></dd>
  <dt id="Importer~4"><a class="permalink" href="#Importer~4">Importer-&gt;import($from,
    $from_version, @imports)</a></dt>
  <dd></dd>
  <dt id="Importer~5"><a class="permalink" href="#Importer~5">Importer-&gt;import($importer_version,
    $from, ...)</a></dt>
  <dd>This is the magic behind <span class="Li">&quot;use Importer
      ...&quot;</span>.</dd>
  <dt id="Importer~6"><a class="permalink" href="#Importer~6">Importer-&gt;import_into($from,
    $into, @imports)</a></dt>
  <dd></dd>
  <dt id="Importer~7"><a class="permalink" href="#Importer~7">Importer-&gt;import_into($from,
    $level, @imports)</a></dt>
  <dd>You can use this to import symbols from <span class="Li">$from</span> into
      <span class="Li">$into</span>. <span class="Li">$into</span> may either be
      a package name, or a caller level to get the name from.</dd>
  <dt id="Importer~8"><a class="permalink" href="#Importer~8">Importer-&gt;<b>unimport()</b></a></dt>
  <dd></dd>
  <dt id="Importer~9"><a class="permalink" href="#Importer~9">Importer-&gt;unimport(@sub_name)</a></dt>
  <dd>This is the magic behind <span class="Li">&quot;no Importer
      ...&quot;</span>.</dd>
  <dt id="Importer~10"><a class="permalink" href="#Importer~10">Importer-&gt;unimport_from($from,
    @sub_names)</a></dt>
  <dd></dd>
  <dt id="Importer~11"><a class="permalink" href="#Importer~11">Importer-&gt;unimport_from($level,
    @sub_names)</a></dt>
  <dd>This lets you remove imported symbols from <span class="Li">$from</span>.
      <span class="Li">$from</span> my be a package name, or a caller
    level.</dd>
  <dt id="my"><a class="permalink" href="#my">my $exports =
    Importer-&gt;get($from, @imports)</a></dt>
  <dd>This returns hashref of <span class="Li">&quot;{ $name =&gt; $ref
      }&quot;</span> for all the specified imports.
    <p class="Pp"><span class="Li">$from</span> should be the package from which
        to get the exports.</p>
  </dd>
  <dt id="my~2"><a class="permalink" href="#my~2">my @export_refs =
    Importer-&gt;get_list($from, @imports)</a></dt>
  <dd>This returns a list of references for each import specified. Only the
      export references are returned, the names are not.
    <p class="Pp"><span class="Li">$from</span> should be the package from which
        to get the exports.</p>
  </dd>
  <dt>$export_ref = Importer-&gt;get_one($from, $import)</dt>
  <dd>This returns a single reference to a single export. If you provide
      multiple imports then only the LAST one will be used.
    <p class="Pp"><span class="Li">$from</span> should be the package from which
        to get the exports.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="USING_WITH_OTHER_EXPORTER_IMPLEMENTATIONS"><a class="permalink" href="#USING_WITH_OTHER_EXPORTER_IMPLEMENTATIONS">USING
  WITH OTHER EXPORTER IMPLEMENTATIONS</a></h1>
<p class="Pp">If you want your module to work with Importer, but you use
    something other than Exporter to define your exports, you can make it work
    be defining the <span class="Li">&quot;IMPORTER_MENU&quot;</span> method in
    your package. As well other exporters can be updated to support Importer by
    putting this sub in your package. <b></b><b>IMPORTER_MENU()</b><b> must be
    defined in your package, not a base class!</b></p>
<p class="Pp"></p>
<pre>    sub IMPORTER_MENU {
        my $class = shift;
        my ($into, $caller) = @_;
        return (
            export       =&gt; \@EXPORT,          # Default exports
            export_ok    =&gt; \@EXPORT_OK,       # Other allowed exports
            export_tags  =&gt; \%EXPORT_TAGS,     # Define tags
            export_fail  =&gt; \@EXPORT_FAIL,     # For subs that may not always be available
            export_anon  =&gt; \%EXPORT_ANON,     # Anonymous symbols to export
            export_magic =&gt; \%EXPORT_MAGIC,    # Magic to apply after a symbol is exported
            generate   =&gt; \&amp;GENERATE,          # Sub to generate dynamic exports
                                               # OR
            export_gen =&gt; \%EXPORT_GEN,        # Hash of builders, key is symbol
                                               # name, value is sub that generates
                                               # the symbol ref.
        );
    }
    sub GENERATE {
        my ($symbol) = @_;
        ...
        return $ref;
    }
</pre>
<p class="Pp">All exports must be listed in either
    <span class="Li">@EXPORT</span> or <span class="Li">@EXPORT_OK</span>, or be
    keys in <span class="Li">%EXPORT_GEN</span> or
    <span class="Li">%EXPORT_ANON</span> to be allowed. 'export_tags',
    'export_fail', 'export_anon', 'export_gen', and 'generate' are optional. You
    cannot combine 'generate' and 'export_gen'.</p>
<p class="Pp"><b>Note:</b> If your GENERATE sub needs the
    <span class="Li">$class</span>, <span class="Li">$into</span>, or
    <span class="Li">$caller</span> then your
    <span class="Li">&quot;IMPORTER_MENU()&quot;</span> method will need to
    build an anonymous sub that closes over them:</p>
<p class="Pp"></p>
<pre>    sub IMPORTER_MENU {
        my $class = shift;
        my ($into, $caller) = @_;
        return (
            ...
            generate =&gt; sub { $class-&gt;GENERATE($into, $caller, @_) },
        );
    }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="OO_Interface"><a class="permalink" href="#OO_Interface">OO
  Interface</a></h1>
<pre>    use Importer;
    my $imp = Importer-&gt;new(from =&gt; 'Some::Exporter');
    $imp-&gt;do_import('Destination::Package');
    $imp-&gt;do_import('Another::Destination', @symbols);
</pre>
<p class="Pp">Or, maybe more useful:</p>
<p class="Pp"></p>
<pre>    my $imp = Importer-&gt;new(from =&gt; 'Carp');
    my $croak = $imp-&gt;get_one('croak');
    $croak-&gt;(&quot;This will croak&quot;);
</pre>
<section class="Ss">
<h2 class="Ss">OBJECT CONSTRUCTION</h2>
<dl class="Bl-tag">
  <dt>$imp = Importer-&gt;new(from =&gt; 'Some::Exporter')</dt>
  <dd></dd>
  <dt>$imp = Importer-&gt;new(from =&gt; 'Some::Exporter', caller =&gt;
    [$package, $file, $line])</dt>
  <dd>This is how you create a new Importer instance.
      <span class="Li">&quot;from =&gt; 'Some::Exporter'&quot;</span> is the
      only required argument. You may also specify the
      <span class="Li">&quot;caller =&gt; [...]&quot;</span> arrayref, which
      will be used only for error reporting. If you do not specify a caller then
      Importer will attempt to find the caller dynamically every time it needs
      it (this is slow and expensive, but necessary if you intend to re-use the
      object.)</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">OBJECT METHODS</h2>
<dl class="Bl-tag">
  <dt>$imp-&gt;do_import($into)</dt>
  <dd></dd>
  <dt>$imp-&gt;do_import($into, @symbols)</dt>
  <dd>This will import from the objects <span class="Li">&quot;from&quot;</span>
      package into the <span class="Li">$into</span> package. You can provide a
      list of <span class="Li">@symbols</span>, or you can leave it empty for
      the defaults.</dd>
  <dt>$imp-&gt;<b>do_unimport()</b></dt>
  <dd></dd>
  <dt>$imp-&gt;do_unimport(@symbols)</dt>
  <dd>This will remove imported symbols from the objects
      <span class="Li">&quot;from&quot;</span> package. If you specify a list of
      <span class="Li">@symbols</span> then only the specified symbols will be
      removed, otherwise all symbols imported using Importer will be removed.
    <p class="Pp"><b>Note:</b> Please be aware of the difference between
        <span class="Li">&quot;do_import()&quot;</span> and
        <span class="Li">&quot;do_unimport()&quot;</span>. For import 'from' us
        used as the origin, in unimport it is used as the target. This means you
        cannot re-use an instance to import and then unimport.</p>
  </dd>
  <dt>($into, $versions, $exclude, $symbols, $set) =
    $imp-&gt;parse_args('Dest::Package')</dt>
  <dd></dd>
  <dt>($into, $versions, $exclude, $symbols, $set) =
    $imp-&gt;parse_args('Dest::Package', @symbols)</dt>
  <dd>This parses arguments. The first argument must be the destination package.
      Other arguments can be a mix of symbol names, tags, patterns, version
      numbers, and exclusions.</dd>
  <dt>$caller_ref = $imp-&gt;<b>get_caller()</b></dt>
  <dd>This will find the caller. This is mainly used for error reporting. IF the
      object was constructed with a caller then that is what is returned,
      otherwise this will scan the stack looking for the first call that does
      not originate from a package that ISA Importer.</dd>
  <dt>$imp-&gt;carp($warning)</dt>
  <dd>Warn at the callers level.</dd>
  <dt>$imp-&gt;croak($exception)</dt>
  <dd>Die at the callers level.</dd>
  <dt>$from_package = $imp-&gt;<b>from()</b></dt>
  <dd>Get the <span class="Li">&quot;from&quot;</span> package that was
      specified at construction.</dd>
  <dt>$file = $imp-&gt;<b>from_file()</b></dt>
  <dd>Get the filename for the <span class="Li">&quot;from&quot;</span>
    package.</dd>
  <dt>$imp-&gt;<b>load_from()</b></dt>
  <dd>This will load the <span class="Li">&quot;from&quot;</span> package if it
      has not been loaded already. This uses some magic to ensure errors in the
      load process are reported to the
      <span class="Li">&quot;caller&quot;</span>.</dd>
  <dt>$menu_hr = $imp-&gt;menu($into)</dt>
  <dd>Get the export menu built from, or provided by the
      <span class="Li">&quot;from&quot;</span> package. This is cached after the
      first time it is called. Use
      <span class="Li">&quot;$imp-&gt;reload_menu()&quot;</span> to refresh it.
    <p class="Pp">The menu structure looks like this:</p>
    <p class="Pp"></p>
    <pre>    $menu = {
        # every valid export has a key in the lookup hashref, value is always
        # 1, key always includes the sigil
        lookup =&gt; {'&amp;symbol_a' =&gt; 1, '$symbol_b' =&gt; 1, ...},
        # most exports are listed here, symbol name with sigil is key, value is
        # a reference to the symbol. If a symbol is missing it may be generated.
        exports =&gt; {'&amp;symbol_a' =&gt; \&amp;symbol_a, '$symbol_b' =&gt; \$symbol_b, ...},
        # Hashref of tags, tag name (without ':' prefix) is key, value is an
        # arrayref of symbol names, subs may have a sigil, but are not required
        # to.
        tags =&gt; { DEFAULT =&gt; [...], foo =&gt; [...], ... },
        # Magic to apply
        magic =&gt; { foo =&gt; sub { ... }, ... },
        # This is a hashref just like 'lookup'. Keys are symbols which may not
        # always be available. If there are no symbols in this category then
        # the value of the 'fail' key will be undef instead of a hashref.
        fail =&gt; { '&amp;iffy_symbol' =&gt; 1, '\&amp;only_on_linux' =&gt; 1 },
        # OR fail =&gt; undef,
        # If present, this subroutine knows how to generate references for the
        # symbols listed in 'lookup', but missing from 'exports'. References
        # this returns are NEVER cached.
        generate =&gt; sub { my $sym_name = shift; ...; return $symbol_ref },
    };
    </pre>
  </dd>
  <dt>$imp-&gt;reload_menu($into)</dt>
  <dd>This will reload the export menu from the
      <span class="Li">&quot;from&quot;</span> package.</dd>
  <dt id="my~3"><a class="permalink" href="#my~3">my $exports =
    $imp-&gt;get(@imports)</a></dt>
  <dd>This returns hashref of <span class="Li">&quot;{ $name =&gt; $ref
      }&quot;</span> for all the specified imports.</dd>
  <dt id="my~4"><a class="permalink" href="#my~4">my @export_refs =
    $imp-&gt;get_list(@imports)</a></dt>
  <dd>This returns a list of references for each import specified. Only the
      export references are returned, the names are not.</dd>
  <dt>$export_ref = $imp-&gt;get_one($import)</dt>
  <dd>This returns a single reference to a single export. If you provide
      multiple imports then only the LAST one will be used.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTIONS"><a class="permalink" href="#FUNCTIONS">FUNCTIONS</a></h1>
<p class="Pp">These can be imported:</p>
<p class="Pp"></p>
<pre>    use Importer 'Importer' =&gt; qw/import optimal_import/;
</pre>
<dl class="Bl-tag">
  <dt>$bool = optimal_import($from, $into, \@caller, @imports)</dt>
  <dd>This function will attempt to import <span class="Li">@imports</span> from
      the <span class="Li">$from</span> package into the
      <span class="Li">$into</span> package. <span class="Li">@caller</span>
      needs to have a package name, filename, and line number. If this function
      fails then no exporting will actually happen.
    <p class="Pp">If the import is successful this will return true.</p>
    <p class="Pp">If the import is unsuccessful this will return false, and no
        modifications to the symbol table will occur.</p>
  </dd>
  <dt>$class-&gt;import(@imports)</dt>
  <dd>If you write class intended to be used with Importer, but also need to
      provide a legacy <span class="Li">&quot;import()&quot;</span> method for
      direct consumers of your class, you can import this
      <span class="Li">&quot;import()&quot;</span> method.
    <p class="Pp"></p>
    <pre>    package My::Exporter;
    # This will give you 'import()' much like 'use base &quot;Exporter&quot;;'
    use Importer 'Importer' =&gt; qw/import/;
    ...
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SOURCE"><a class="permalink" href="#SOURCE">SOURCE</a></h1>
<p class="Pp">The source code repository for Importer can be found at
    &lt;http://github.com/exodist/Importer&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MAINTAINERS"><a class="permalink" href="#MAINTAINERS">MAINTAINERS</a></h1>
<dl class="Bl-tag">
  <dt id="Chad"><a class="permalink" href="#Chad">Chad Granum
    &lt;exodist@cpan.org&gt;</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<dl class="Bl-tag">
  <dt id="Chad~2"><a class="permalink" href="#Chad~2">Chad Granum
    &lt;exodist@cpan.org&gt;</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 2015 Chad Granum &lt;exodist7@gmail.com&gt;.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">See &lt;http://dev.perl.org/licenses/&gt;</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-08-16</td>
    <td class="foot-os"><a href="..">perl v5.34.0</a></td>
  </tr>
</table>
</body>
</html>

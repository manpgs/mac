<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Parse::Eyapp::Scope(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Parse::Eyapp::Scope(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Parse::Eyapp::Scope(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Parse::Eyapp::Scope - Support for Scope Analysis</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
  # Fragment of the grammar lib/Simple/Types.eyp
  # in examples/typechecking/Simple-Types-XXX.tar.gz 
  funcDef:
      $ID 
         { 
           $ids-&gt;begin_scope(); 
         }
      '('  $params  ')' 
        $block
      {
         my $st = $block-&gt;{symboltable}; 
         my @decs = $params-&gt;children(); 
         $block-&gt;{parameters} = [];
         while (my ($bt, $id, $arrspec) = splice(@decs, 0, 3)) {
             $bt = ref($bt); # The string 'INT', 'CHAR', etc.
             my $name = $id-&gt;{attr}[0];
             my $type = build_type($bt, $arrspec);
             $type{$type} = Parse::Eyapp::Node-&gt;hnew($type); 

             # control duplicated declarations
               die &quot;Duplicated declaration of $name at line $id-&gt;{attr}[1]\n&quot; 
             if exists($st-&gt;{$name});

             $st-&gt;{$name}-&gt;{type} = $type;
             $st-&gt;{$name}-&gt;{param} = 1;
             $st-&gt;{$name}-&gt;{line} = $id-&gt;{attr}[1];
             push @{$block-&gt;{parameters}}, $name;
         }
         $block-&gt;{function_name} = $ID;
         $block-&gt;type(&quot;FUNCTION&quot;);

         my ($nodec, $dec) = $ids-&gt;end_scope($st, $block, 'type');

         # Type checking: add a direct pointer to the data-structure
         # describing the type
         $_-&gt;{t} = $type{$_-&gt;{type}} for @$dec;

         return $block;
      }
  ;
 
  ...

  Primary:
      %name INUM
      INUM 
    | %name CHARCONSTANT
      CHARCONSTANT
    | $Variable 
        { 
          $ids-&gt;scope_instance($Variable); 
          return $Variable 
        }
    | '(' expression ')' { $_[2] }
    | $function_call 
        { 
          $ids-&gt;scope_instance($function_call); 
          return $function_call  # bypass
        }
  ;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="INTRODUCTION"><a class="permalink" href="#INTRODUCTION">INTRODUCTION</a></h1>
<p class="Pp">The examples used in this document can be found in the file
    <span class="Li">&quot;examples/typechecking/Simple-Types-XXX.tar.gz&quot;</span>.
    This distribution contains the front-end of a compiler (lexical analysis,
    syntax analysis, scope analysis and type checking) for a small subset of the
    C language. The language has characters, integers, arrays and functions.
    Here is a small example:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/Lbook/code/Simple-Types/script$ cat prueba03.c
  int a,b,e[10];

  g() {}

  int f(char c) {
  char d;
   c = 'X';
   e[d] = 'A'+c;
   {
     int d;
     d = a + b;
   }
   a = b * 2;
   return c;
  }
</pre>
<p class="Pp">You can find more examples in the
    <span class="Li">&quot;script/&quot;</span> directory. The front-end
    provided analyzes the input program</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/Lbook/code/Simple-Types/script$ usetypes.pl prueba03.c
</pre>
<p class="Pp">and produces the decorated abstract tree, i.e. s.t. like:</p>
<p class="Pp"></p>
<pre>
  PROGRAM^{0}(
    FUNCTION[g]^{1},
    FUNCTION[f]^{2}(
      ASSIGNCHAR(
        VAR( TERMINAL[c:7]),
        CHARCONSTANT( TERMINAL['X':7])
      ),
      ASSIGNINT(
        VARARRAY( TERMINAL[e:8], INDEXSPEC(CHAR2INT(VAR(TERMINAL[d:8])))),
        PLUS(
          CHAR2INT(CHARCONSTANT(TERMINAL['A':8])),
          CHAR2INT(VAR(TERMINAL[c:8]))
        )
      ),
      BLOCK[9:3:f]^{3}(
        ASSIGNINT(
          VAR(TERMINAL[d:11]),
          PLUS(VAR(TERMINAL[a:11]),VAR( TERMINAL[b:11])))
      ),
      ASSIGNINT(
        VAR(TERMINAL[a:13]),
        TIMES(VAR(TERMINAL[b:13]),INUM(TERMINAL[2:13]))),
      RETURNINT(CHAR2INT(VAR(TERMINAL[c:14])))
    )
  )
  ...... # More descriptions
</pre>
<p class="Pp">A scope manager helps to compute the mapping function that maps
    the uses (instances) of source objects to their definitions. For
  instance,</p>
<ul class="Bl-bullet">
  <li>When dealing with <i>identifier scope analysis</i> the problem is to
      associate each occurrence of an identifier with the declaration that
      applies to it.</li>
  <li>Another example is <i>loop scope analysis</i> where the problem is to
      associate each occurrence of a
      <span class="Li">&quot;CONTINUE&quot;</span> or
      <span class="Li">&quot;BREAK&quot;</span> node with the shallowest
      <span class="Li">&quot;LOOP&quot;</span> that encloses it.</li>
  <li>Or <i>label scope analysis</i>, the problem to associate a
      <span class="Li">&quot;GOTO&quot;</span> node with the node to jump to,
      that is, the one with the <span class="Li">&quot;STATEMENT&quot;</span>
      associated with the label.</li>
</ul>
<p class="Pp">The scope analysis start by creating the
    <span class="Li">&quot;Parse::Eyapp::Scope&quot;</span> objects:</p>
<p class="Pp"></p>
<pre>
  program:
        {
          reset_file_scope_vars();
        }
      definition&lt;%name PROGRAM +&gt;.program
        {
          ..........  # Semantic actions 
        }
  ;
</pre>
<p class="Pp">Before the analysis of the whole program we call
    <span class="Li">&quot;reset_file_scope_vars&quot;</span> which is in charge
    to create the scope analyzers for <i>identifier scope analysis</i> and
    <i>loop scope analysis</i>:</p>
<p class="Pp"></p>
<pre>
  sub reset_file_scope_vars {
    %st = (); # reset symbol table
    ($tokenbegin, $tokenend) = (1, 1);
    %type = ( INT  =&gt; Parse::Eyapp::Node-&gt;hnew('INT'),
              CHAR =&gt; Parse::Eyapp::Node-&gt;hnew('CHAR'),
              VOID =&gt; Parse::Eyapp::Node-&gt;hnew('VOID'),
            );
    $depth = 0;
    $ids = Parse::Eyapp::Scope-&gt;new(
             SCOPE_NAME =&gt; 'block',
             ENTRY_NAME =&gt; 'info',
             SCOPE_DEPTH =&gt; 'depth',
    );
    $loops = Parse::Eyapp::Scope-&gt;new(
             SCOPE_NAME =&gt; 'exits',
    );
    $ids-&gt;begin_scope();
    $loops-&gt;begin_scope(); # just for checking
  }
</pre>
<p class="Pp">To take advantage of
    <span class="Li">&quot;Parse::Eyapp::Scope&quot;</span>, the compiler writer
    must mark at the appropriate time (for example a new block or new subroutine
    for <i>identifier scope analysis</i>, a new loop for <i>loop scope
    analysis</i>, etc.) the <i>beginning of a new scope</i> calling the method
    <span class="Li">&quot;begin_scope&quot;</span>. For example, the following
    code deals with the declaration of functions</p>
<p class="Pp"></p>
<pre>
  funcDef:
      $ID 
         { 
           $ids-&gt;begin_scope(); 
         }
      '('  $params  ')' 
        $block
      {
         ........ # semantic action code
      }
  ;
</pre>
<p class="Pp">The call</p>
<p class="Pp"></p>
<pre>
            $ids-&gt;begin_scope
</pre>
<p class="Pp">marks the beginning of a new identifier scope.</p>
<p class="Pp">From that point on, any <i>ocurring instance</i> of an object (for
    example, variables in expressions for <i>identifier scope analysis</i>,
    breaks and continues for <i>loop scope analysis</i>, etc.) must be declared
    calling the method <span class="Li">&quot;scope_instance&quot;</span>. For
    example, the following rules deal with the use of of variables and functions
    inside expressions:</p>
<p class="Pp"></p>
<pre>
  Primary:
      ........... # Other production rules
    | $Variable 
        { 
          $ids-&gt;scope_instance($Variable); 
          return $Variable 
        }
    | $function_call 
        { 
          $ids-&gt;scope_instance($function_call); 
          return $function_call  # bypass
        }
  ;
</pre>
<p class="Pp">The programmer must also mark the <i>end of the current scope</i>
    at the appropriate time. After the processing of the
    <span class="Li">&quot;block&quot;</span> following a function declaration
    an <i>identifier scope</i> has finished and we call
    <span class="Li">&quot;end_scope&quot;</span>:</p>
<p class="Pp"></p>
<pre>
  funcDef:
      $ID 
         { 
           $ids-&gt;begin_scope(); 
         }
      '('  $params  ')' 
        $block
      {
         ............................... 

         my ($nodec, $dec) = $ids-&gt;end_scope($st, $block, 'type');

         # Type checking: add a direct pointer to the data-structure
         # describing the type
         $_-&gt;{t} = $type{$_-&gt;{type}} for @$dec;

         return $block;
      }
  ;
</pre>
<p class="Pp">This call is made after each end of scope, including the end of
    the program:</p>
<p class="Pp"></p>
<pre>
  program:
        {
          reset_file_scope_vars();
        }
      definition&lt;%name PROGRAM +&gt;.program
        {
          $program-&gt;{symboltable} = { %st };  # creates a copy of the s.t.
          $program-&gt;{depth} = 0;
          $program-&gt;{line}  = 1;
          $program-&gt;{types} = { %type };
          $program-&gt;{lines} = $tokenend;

          my ($nondec, $declared) = $ids-&gt;end_scope($program-&gt;{symboltable}, $program, 'type');

          if (@$nondec) {
            warn &quot;Identifier &quot;.$_-&gt;key.&quot; not declared at line &quot;.$_-&gt;line.&quot;\n&quot; for @$nondec;
            die &quot;\n&quot;;
          }

          # Type checking: add a direct pointer to the data-structure
          # describing the type
          $_-&gt;{t} = $type{$_-&gt;{type}} for @$declared;

          my $out_of_loops = $loops-&gt;end_scope($program);
          if (@$out_of_loops) {
            warn &quot;Error: &quot;.ref($_).&quot; outside of loop at line $_-&gt;{line}\n&quot; for @$out_of_loops;
            die &quot;\n&quot;;
          }

          # Check that are not dangling breaks
          reset_file_scope_vars();

          $program;
        }
  ;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="The__end_scope__method"><a class="permalink" href="#The__end_scope__method">The
  &quot;end_scope&quot; method</a></h2>
<p class="Pp">There are three ways of calling
    <span class="Li">&quot;$scope-&gt;end_scope&quot;</span>. The first one is
    for Scope Analysis Problems where a symbol table is needed (for example in
    <i>identifier scope analysis</i> and <i>label scope analysis</i> and there
    is a <span class="Li">&quot;Parse::Eyapp::Node&quot;</span> node that owns
    the scope.</p>
<p class="Pp"><i>The </i><i>&quot;end_scope&quot;</i><i> with first Argument a
    Symbol Table and Second Argument a Node</i></p>
<p class="Pp">For each <i>ocurring instance</i> of an object
    <span class="Li">$x</span> that occurred since the last call to
    <span class="Li">&quot;begin_scope&quot;</span> the call to</p>
<p class="Pp"></p>
<pre>
  $scope-&gt;end_scope(\%symboltable, $definition_node, 'attr1', 'attr2', ... )
</pre>
<p class="Pp">decorates the <i>ocurring instance</i> <span class="Li">$x</span>
    with several attributes:</p>
<ul class="Bl-bullet">
  <li>An entry <span class="Li">&quot;$x-&gt;{SCOPE_NAME}&quot;</span> is built
      that will reference <span class="Li">$definition_node</span>.</li>
  <li>An entry <span class="Li">&quot;$x-&gt;{ENTRY_NAME}&quot;</span> is built.
      That entry references <span class="Li">$symboltable{$x-&gt;key}</span> (to
      have a faster access from the instance to the attributes of the object).
      The instantiated nodes must have a
      <span class="Li">&quot;$x-&gt;key&quot;</span> method which provides the
      entry for the node in the symbol table:
    <p class="Pp"></p>
    <pre>
  pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed -ne '651,657p' Types.eyp
  sub VAR::key {
    my $self = shift;

    return $self-&gt;child(0)-&gt;{attr}[0];
  }

  *VARARRAY::key = *FUNCTIONCALL::key = \&amp;VAR::key;
    </pre>
  </li>
  <li>For each aditional arguments <span class="Li">&quot;attr#k&quot;</span> an
      entry <span class="Li">&quot;$x-&gt;{attr#k&quot;</span>} will be built.
      That entry references
      <span class="Li">$symboltable{$x-&gt;key}{attr#k}</span>. Therefore the
      entry for <span class="Li">$x</span> in the symbol table must already have
      a field named <span class="Li">&quot;attr#k&quot;</span>. If the hash
      referenced by <span class="Li">$symboltable{$x-&gt;key}</span> does not
      have a key <span class="Li">&quot;attr#k&quot;</span> no reference is
      built.</li>
</ul>
<p class="Pp">In a list context
    <span class="Li">&quot;$scope&gt;end_scope&quot;</span> returns two
    references. The first one is a reference to a list of node instantiated that
    weren't defined in the current scope. The second is a reference to a list of
    nodes that were defined in this scope. In a scalar context returns the first
    of these two. An instance <span class="Li">$x</span> is <i>defined</i> if,
    and only if, <span class="Li">&quot;exists
    $symboltable{$_-&gt;key}&quot;</span>.</p>
<p class="Pp"><i>The </i><i>&quot;end_scope&quot;</i><i> Method with first
    Argument a Symbol Table and Remaining Arguments strings</i></p>
<p class="Pp">For each <i>ocurring instance</i> of an object
    <span class="Li">$x</span> that occurred since the last call to
    <span class="Li">&quot;begin_scope&quot;</span> the call to</p>
<p class="Pp"></p>
<pre>
  $scope-&gt;end_scope(\%symboltable, 'attr1', 'attr2', ... )
</pre>
<p class="Pp">decorates the <i>ocurring instance</i> <span class="Li">$x</span>
    with several attributes:</p>
<ul class="Bl-bullet">
  <li>An entry <span class="Li">&quot;$x-&gt;{ENTRY_NAME}&quot;</span> is built.
      That entry references <span class="Li">$symboltable{$x-&gt;key}</span> (to
      have a faster access from the instance to the attributes of the object).
      The instantiated nodes must have a
      <span class="Li">&quot;$x-&gt;key&quot;</span> method which provides the
      entry for the node in the symbol table.</li>
  <li>For each aditional arguments <span class="Li">&quot;attr#k&quot;</span> an
      entry <span class="Li">&quot;$x-&gt;{attr#k&quot;</span>} will be built.
      That entry references
      <span class="Li">$symboltable{$x-&gt;key}{attr#k}</span>. Therefore the
      entry for <span class="Li">$x</span> in the symbol table must already have
      a field named <span class="Li">&quot;attr#k&quot;</span>. If the hash
      referenced by <span class="Li">$symboltable{$x-&gt;key}</span> does not
      have a key <span class="Li">&quot;attr#k&quot;</span> no reference is
      built.</li>
</ul>
<p class="Pp"><i>The </i><i>&quot;end_scope&quot;</i><i> method for Simple Scope
    Analysis</i></p>
<p class="Pp">Some scope analysis problems do not require the existence of a
    symbol table (for instance, the problem of associating a
    <span class="Li">&quot;RETURN&quot;</span> node with the
    <span class="Li">&quot;FUNCTION&quot;</span> that encloses it). For such
    kind of problems <span class="Li">&quot;$scope&gt;end_scope&quot;</span>
    provides a second form of call.</p>
<p class="Pp">The second way to call
    <span class="Li">&quot;$scope&gt;end_scope&quot;</span> is</p>
<p class="Pp"></p>
<pre>
                 $declared = $scopemanager-&gt;end_scope($definition_node);
</pre>
<p class="Pp">The only argument is the reference to the node that
    controls/defines the scope. The method returns a reference to the declared
    nodes. Any node instanced with
    <span class="Li">&quot;scope_instance&quot;</span> since the last call to
    <span class="Li">&quot;begin_scope&quot;</span> is considered
    <i>declared</i>.</p>
<p class="Pp">The scope node <span class="Li">$definition_node</span> is
    decorated with an attribute with name the value of the attribute
    <span class="Li">&quot;SCOPE_NAME&quot;</span> of the scope manager
    <span class="Li">$scopemanager</span>. The value of the attribute is the
    anonymous list of references to the instances declared in the scope of
    <span class="Li">$definition_node</span> (i.e. the same list referenced by
    <span class="Li">$declared</span>).</p>
<p class="Pp">The scope instances in <span class="Li">@$declared</span> are
    decorated with an attribute with name the value of the attribute
    <span class="Li">&quot;SCOPE_NAME&quot;</span> of the scope manager. The
    value is a reference to the scope node
    <span class="Li">$definition_node</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The__begin_scope__method"><a class="permalink" href="#The__begin_scope__method">The
  &quot;begin_scope&quot; method</a></h2>
<p class="Pp">Marks the beginning of an scope. Example (file
    <span class="Li">&quot;Types.eyp&quot;</span> in
    <span class="Li">&quot;examples/typechecking/Simple-Types-XXX.tar.gz&quot;</span>):</p>
<p class="Pp"></p>
<pre>
   loopPrefix:
       $WHILE '(' expression ')'
         {
           $loops-&gt;begin_scope;
           $_[3]-&gt;{line} = $WHILE-&gt;[1]; # Save the line for error diagostic
           $_[3]
         }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The__scope_instance__method"><a class="permalink" href="#The__scope_instance__method">The
  &quot;scope_instance&quot; method</a></h2>
<p class="Pp">Declares the node argument to be an occurring instance of the
    scope:</p>
<p class="Pp"></p>
<pre>
   nereida:~/doc/casiano/PLBOOK/PLBOOK/code&gt; \
       sed -ne '375,380p' Simple6.eyp | cat -n
    1      $Variable '=' binary
    2        {
    3          my $parser = shift;
    4          $ids-&gt;scope_instance($Variable);
    5          $parser-&gt;YYBuildAST(@_); # &quot;Manually&quot; build the node
    6        }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The_constructor__new_"><a class="permalink" href="#The_constructor__new_">The
  constructor &quot;new&quot;</a></h2>
<p class="Pp"><span class="Li">&quot;Parse::Eyapp::Scope-&gt;new&quot;</span>
    returns a scope management object. The scope mapping function is implemented
    by <span class="Li">&quot;Parse::Eyapp::Scope&quot;</span> through a set of
    attributes that are added to the nodes involved in the scope analysis. The
    names of these attributes can be specified using the parameters of
    <span class="Li">&quot;Parse::Eyapp::Scope-&gt;new&quot;</span>. The
    arguments of <span class="Li">&quot;new&quot;</span> are:</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;SCOPE_NAME&quot;</span> is the name chosen for the
      attribute of the <i>node instance</i> which will held the reference to the
      <i>definition node</i>. If not specified it will take the value
      <span class="Li">&quot;scope&quot;</span>.</li>
  <li><span class="Li">&quot;ENTRY_NAME&quot;</span> is the name of the
      attribute of the <i>node instance</i> which will held the reference to the
      symbol table entry. By default takes the value
      <span class="Li">&quot;entry&quot;</span>.</li>
  <li><span class="Li">&quot;SCOPE_DEPTH&quot;</span> is the name for an
      attribute of the <i>definition node</i>. Optional. If not specified it
      will not be defined.</li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<ul class="Bl-bullet">
  <li>The project home is at &lt;http://code.google.com/p/parse-eyapp/&gt;. Use
      a subversion client to anonymously check out the latest project source
      code:
    <p class="Pp"></p>
    <pre>
   svn checkout http://parse-eyapp.googlecode.com/svn/trunk/ parse-eyapp-read-only
    </pre>
  </li>
  <li>The tutorial <i>Parsing Strings and Trees with</i>
      <span class="Li">&quot;Parse::Eyapp&quot;</span> (An Introduction to
      Compiler Construction in seven pages) in
      &lt;http://nereida.deioc.ull.es/~pl/eyapsimple/&gt;</li>
  <li>Parse::Eyapp, Parse::Eyapp::eyapplanguageref, Parse::Eyapp::debuggingtut,
      Parse::Eyapp::defaultactionsintro, Parse::Eyapp::translationschemestut,
      Parse::Eyapp::Driver, Parse::Eyapp::Node, Parse::Eyapp::YATW,
      Parse::Eyapp::Treeregexp, Parse::Eyapp::Scope, Parse::Eyapp::Base,
      Parse::Eyapp::datagenerationtut</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf&gt;</li>
  <li>perldoc eyapp,</li>
  <li>perldoc treereg,</li>
  <li>perldoc vgg,</li>
  <li>The Syntax Highlight file for vim at
      &lt;http://www.vim.org/scripts/script.php?script_id=2453&gt; and
      &lt;http://nereida.deioc.ull.es/~vim/&gt;</li>
  <li><i>Analisis Lexico y Sintactico</i>, (Notes for a course in compiler
      construction) by Casiano Rodriguez-Leon. Available at
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/&gt; Is the more complete
      and reliable source for Parse::Eyapp. However is in Spanish.</li>
  <li>Parse::Yapp,</li>
  <li>Man pages of <i>yacc</i>(1) and <i>bison</i>(1),
      &lt;http://www.delorie.com/gnu/docs/bison/bison.html&gt;</li>
  <li>Language::AttributeGrammar</li>
  <li>Parse::RecDescent.</li>
  <li>HOP::Parser</li>
  <li>HOP::Lexer</li>
  <li>ocamlyacc tutorial at
      &lt;http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex-ocamlyacc/ocamlyacc-tutorial/ocamlyacc-tutorial.html&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="REFERENCES"><a class="permalink" href="#REFERENCES">REFERENCES</a></h1>
<ul class="Bl-bullet">
  <li>The classic Dragon's book <i>Compilers: Principles, Techniques, and
      Tools</i> by Alfred V. Aho, Ravi Sethi and Jeffrey D. Ullman
      (Addison-Wesley 1986)</li>
  <li><i>CS2121: The Implementation and Power of Programming Languages</i> (See
      &lt;http://www.cs.man.ac.uk/~pjj&gt;,
      &lt;http://www.cs.man.ac.uk/~pjj/complang/g2lr.html&gt; and
      &lt;http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html&gt;) by Pete Jinks</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<ul class="Bl-bullet">
  <li>Hal Finkel &lt;http://www.halssoftware.com/&gt;</li>
  <li>G. Williams &lt;http://kasei.us/&gt;</li>
  <li>Thomas L. Shinnick &lt;http://search.cpan.org/~tshinnic/&gt;</li>
  <li>Frank Leray</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Casiano Rodriguez-Leon (casiano@ull.es)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGMENTS"><a class="permalink" href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a></h1>
<p class="Pp">This work has been supported by CEE (FEDER) and the Spanish
    Ministry of <i>Educacion y Ciencia</i> through <i>Plan Nacional I+D+I</i>
    number TIN2005-08818-C04-04 (ULL::OPLINK project
    &lt;http://www.oplink.ull.es/&gt;). Support from Gobierno de Canarias was
    through GC02210601 (<i>Grupos Consolidados</i>). The University of La Laguna
    has also supported my work in many ways and for many years.</p>
<p class="Pp">A large percentage of code is verbatim taken from Parse::Yapp
    1.05. The author of Parse::Yapp is Francois Desarmenien.</p>
<p class="Pp">I wish to thank Francois Desarmenien for his Parse::Yapp module,
    to my students at La Laguna and to the Perl Community. Thanks to the people
    who have contributed to improve the module (see &quot;CONTRIBUTORS&quot; in
    Parse::Eyapp). Thanks to Larry Wall for giving us Perl. Special thanks to
    Juana.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENCE_AND_COPYRIGHT"><a class="permalink" href="#LICENCE_AND_COPYRIGHT">LICENCE
  AND COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 2006-2008 Casiano Rodriguez-Leon (casiano@ull.es).
    All rights reserved.</p>
<p class="Pp">Parse::Yapp copyright is of Francois Desarmenien, all rights
    reserved. 1998-2001</p>
<p class="Pp">These modules are free software; you can redistribute it and/or
    modify it under the same terms as Perl itself. See perlartistic.</p>
<p class="Pp">This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. </p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2012-03-23</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

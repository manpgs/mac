<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Test2::API::Instance(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Test2::API::Instance(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Test2::API::Instance(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Test2::API::Instance - Object used by Test2::API under the
  hood</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This object encapsulates the global shared state tracked by Test2.
    A single global instance of this package is stored (and obscured) by the
    Test2::API package.</p>
<p class="Pp">There is no reason to directly use this package. This package is
    documented for completeness. This package can change, or go away completely
    at any time. Directly using, or monkeypatching this package is not supported
    in any way shape or form.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
    use Test2::API::Instance;

    my $obj = Test2::API::Instance-&gt;new;
</pre>
<dl class="Bl-tag">
  <dt>$pid = $obj-&gt;pid</dt>
  <dd>PID of this instance.</dd>
  <dt>$obj-&gt;tid</dt>
  <dd>Thread ID of this instance.</dd>
  <dt>$obj-&gt;<b>reset()</b></dt>
  <dd>Reset the object to defaults.</dd>
  <dt>$obj-&gt;<b>load()</b></dt>
  <dd>Set the internal state to loaded, and run and stored post-load
    callbacks.</dd>
  <dt>$bool = $obj-&gt;loaded</dt>
  <dd>Check if the state is set to loaded.</dd>
  <dt>$arrayref = $obj-&gt;post_load_callbacks</dt>
  <dd>Get the post-load callbacks.</dd>
  <dt>$obj-&gt;add_post_load_callback(sub { ... })</dt>
  <dd>Add a post-load callback. If <span class="Li">&quot;load()&quot;</span>
      has already been called then the callback will be immediately executed. If
      <span class="Li">&quot;load()&quot;</span> has not been called then the
      callback will be stored and executed later when
      <span class="Li">&quot;load()&quot;</span> is called.</dd>
  <dt>$hashref = $obj-&gt;<b>contexts()</b></dt>
  <dd>Get a hashref of all active contexts keyed by hub id.</dd>
  <dt>$arrayref = $obj-&gt;context_acquire_callbacks</dt>
  <dd>Get all context acquire callbacks.</dd>
  <dt>$arrayref = $obj-&gt;context_init_callbacks</dt>
  <dd>Get all context init callbacks.</dd>
  <dt>$arrayref = $obj-&gt;context_release_callbacks</dt>
  <dd>Get all context release callbacks.</dd>
  <dt>$arrayref = $obj-&gt;pre_subtest_callbacks</dt>
  <dd>Get all pre-subtest callbacks.</dd>
  <dt>$obj-&gt;add_context_init_callback(sub { ... })</dt>
  <dd>Add a context init callback. Subs are called every time a context is
      created. Subs get the newly created context as their only argument.</dd>
  <dt>$obj-&gt;add_context_release_callback(sub { ... })</dt>
  <dd>Add a context release callback. Subs are called every time a context is
      released. Subs get the released context as their only argument. These
      callbacks should not call release on the context.</dd>
  <dt>$obj-&gt;add_pre_subtest_callback(sub { ... })</dt>
  <dd>Add a pre-subtest callback. Subs are called every time a subtest is going
      to be run. Subs get the subtest name, coderef, and any arguments.</dd>
  <dt>$obj-&gt;<b>set_exit()</b></dt>
  <dd>This is intended to be called in an <span class="Li">&quot;END { ...
      }&quot;</span> block. This will look at test state and set $?. This will
      also call any end callbacks, and wait on child processes/threads.</dd>
  <dt>$obj-&gt;set_ipc_pending($val)</dt>
  <dd>Tell other processes and threads there is a pending event.
      <span class="Li">$val</span> should be a unique value no other
      thread/process will generate.
    <p class="Pp"><b>Note:</b> This will also make the current process see a
        pending event.</p>
  </dd>
  <dt>$pending = $obj-&gt;<b>get_ipc_pending()</b></dt>
  <dd>This returns -1 if it is not possible to know.
    <p class="Pp">This returns 0 if there are no pending events.</p>
    <p class="Pp">This returns 1 if there are pending events.</p>
  </dd>
  <dt>$timeout = $obj-&gt;ipc_timeout;</dt>
  <dd></dd>
  <dt>$obj-&gt;set_ipc_timeout($timeout);</dt>
  <dd>How long to wait for child processes and threads before aborting.</dd>
  <dt>$drivers = $obj-&gt;ipc_drivers</dt>
  <dd>Get the list of IPC drivers.</dd>
  <dt>$obj-&gt;add_ipc_driver($DRIVER_CLASS)</dt>
  <dd>Add an IPC driver to the list. The most recently added IPC driver will
      become the global one during initialization. If a driver is added after
      initialization has occurred a warning will be generated:
    <p class="Pp"></p>
    <pre>
    &quot;IPC driver $driver loaded too late to be used as the global ipc driver&quot;
    </pre>
  </dd>
  <dt>$bool = $obj-&gt;ipc_polling</dt>
  <dd>Check if polling is enabled.</dd>
  <dt>$obj-&gt;enable_ipc_polling</dt>
  <dd>Turn on polling. This will cull events from other processes and threads
      every time a context is created.</dd>
  <dt>$obj-&gt;disable_ipc_polling</dt>
  <dd>Turn off IPC polling.</dd>
  <dt>$bool = $obj-&gt;no_wait</dt>
  <dd></dd>
  <dt>$bool = $obj-&gt;set_no_wait($bool)</dt>
  <dd>Get/Set no_wait. This option is used to turn off process/thread waiting at
      exit.</dd>
  <dt>$arrayref = $obj-&gt;exit_callbacks</dt>
  <dd>Get the exit callbacks.</dd>
  <dt>$obj-&gt;add_exit_callback(sub { ... })</dt>
  <dd>Add an exit callback. This callback will be called by
      <span class="Li">&quot;set_exit()&quot;</span>.</dd>
  <dt>$bool = $obj-&gt;finalized</dt>
  <dd>Check if the object is finalized. Finalization happens when either
      <span class="Li">&quot;ipc()&quot;</span>,
      <span class="Li">&quot;stack()&quot;</span>, or
      <span class="Li">&quot;format()&quot;</span> are called on the object.
      Once finalization happens these fields are considered unchangeable (not
      enforced here, enforced by Test2).</dd>
  <dt>$ipc = $obj-&gt;ipc</dt>
  <dd>Get the one true IPC instance.</dd>
  <dt>$obj-&gt;ipc_disable</dt>
  <dd>Turn IPC off</dd>
  <dt>$bool = $obj-&gt;ipc_disabled</dt>
  <dd>Check if IPC is disabled</dd>
  <dt>$stack = $obj-&gt;stack</dt>
  <dd>Get the one true hub stack.</dd>
  <dt>$formatter = $obj-&gt;formatter</dt>
  <dd>Get the global formatter. By default this is the
      <span class="Li">'Test2::Formatter::TAP'</span> package. This could be any
      package that implements the <span class="Li">&quot;write()&quot;</span>
      method. This can also be an instantiated object.</dd>
  <dt>$bool = $obj-&gt;<b>formatter_set()</b></dt>
  <dd>Check if a formatter has been set.</dd>
  <dt>$obj-&gt;add_formatter($class)</dt>
  <dd></dd>
  <dt>$obj-&gt;add_formatter($obj)</dt>
  <dd>Add a formatter. The most recently added formatter will become the global
      one during initialization. If a formatter is added after initialization
      has occurred a warning will be generated:
    <p class="Pp"></p>
    <pre>
    &quot;Formatter $formatter loaded too late to be used as the global formatter&quot;
    </pre>
  </dd>
  <dt>$obj-&gt;set_add_uuid_via(sub { ... })</dt>
  <dd></dd>
  <dt>$sub = $obj-&gt;<b>add_uuid_via()</b></dt>
  <dd>This allows you to provide a UUID generator. If provided UUIDs will be
      attached to all events, hubs, and contexts. This is useful for storing,
      tracking, and linking these objects.
    <p class="Pp">The sub you provide should always return a unique identifier.
        Most things will expect a proper UUID string, however nothing in
        Test2::API enforces this.</p>
    <p class="Pp">The sub will receive exactly 1 argument, the type of thing
        being tagged 'context', 'hub', or 'event'. In the future additional
        things may be tagged, in which case new strings will be passed in. These
        are purely informative, you can (and usually should) ignore them.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SOURCE"><a class="permalink" href="#SOURCE">SOURCE</a></h1>
<p class="Pp">The source code repository for Test2 can be found at
    <i>http://github.com/Test-More/test-more/</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MAINTAINERS"><a class="permalink" href="#MAINTAINERS">MAINTAINERS</a></h1>
<dl class="Bl-tag">
  <dt id="Chad"><a class="permalink" href="#Chad">Chad Granum
    &lt;exodist@cpan.org&gt;</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<dl class="Bl-tag">
  <dt id="Chad~2"><a class="permalink" href="#Chad~2">Chad Granum
    &lt;exodist@cpan.org&gt;</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 2020 Chad Granum &lt;exodist@cpan.org&gt;.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">See <i>http://dev.perl.org/licenses/</i></p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-10-22</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

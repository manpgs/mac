<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>File::Path(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">File::Path(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">File::Path(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">File::Path - Create or remove directory trees</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">2.16 - released August 31 2018.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use File::Path qw(make_path remove_tree);
    @created = make_path('foo/bar/baz', '/zug/zwang');
    @created = make_path('foo/bar/baz', '/zug/zwang', {
        verbose =&gt; 1,
        mode =&gt; 0711,
    });
    make_path('foo/bar/baz', '/zug/zwang', {
        chmod =&gt; 0777,
    });
    $removed_count = remove_tree('foo/bar/baz', '/zug/zwang', {
        verbose =&gt; 1,
        error  =&gt; \my $err_list,
        safe =&gt; 1,
    });
    # legacy (interface promoted before v2.00)
    @created = mkpath('/foo/bar/baz');
    @created = mkpath('/foo/bar/baz', 1, 0711);
    @created = mkpath(['/foo/bar/baz', 'blurfl/quux'], 1, 0711);
    $removed_count = rmtree('foo/bar/baz', 1, 1);
    $removed_count = rmtree(['foo/bar/baz', 'blurfl/quux'], 1, 1);
    # legacy (interface promoted before v2.06)
    @created = mkpath('foo/bar/baz', '/zug/zwang', { verbose =&gt; 1, mode =&gt; 0711 });
    $removed_count = rmtree('foo/bar/baz', '/zug/zwang', { verbose =&gt; 1, mode =&gt; 0711 });
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module provides a convenient way to create directories of
    arbitrary depth and to delete an entire directory subtree from the
    filesystem.</p>
<p class="Pp">The following functions are provided:</p>
<dl class="Bl-tag">
  <dt id="make_path("><a class="permalink" href="#make_path(">make_path( $dir1,
    $dir2, .... )</a></dt>
  <dd></dd>
  <dt id="make_path(~2"><a class="permalink" href="#make_path(~2">make_path(
    $dir1, $dir2, ...., \%opts )</a></dt>
  <dd>The <span class="Li">&quot;make_path&quot;</span> function creates the
      given directories if they don't exist before, much like the Unix command
      <span class="Li">&quot;mkdir -p&quot;</span>.
    <p class="Pp">The function accepts a list of directories to be created. Its
        behaviour may be tuned by an optional hashref appearing as the last
        parameter on the call.</p>
    <p class="Pp">The function returns the list of directories actually created
        during the call; in scalar context the number of directories
      created.</p>
    <p class="Pp">The following keys are recognised in the option hash:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="mode"><a class="permalink" href="#mode">mode =&gt; $num</a></dt>
  <dd>The numeric permissions mode to apply to each created directory (defaults
      to <span class="Li">0777</span>), to be modified by the current
      <span class="Li">&quot;umask&quot;</span>. If the directory already exists
      (and thus does not need to be created), the permissions will not be
      modified.
    <p class="Pp"><span class="Li">&quot;mask&quot;</span> is recognised as an
        alias for this parameter.</p>
  </dd>
  <dt id="chmod"><a class="permalink" href="#chmod">chmod =&gt; $num</a></dt>
  <dd>Takes a numeric mode to apply to each created directory (not modified by
      the current <span class="Li">&quot;umask&quot;</span>). If the directory
      already exists (and thus does not need to be created), the permissions
      will not be modified.</dd>
  <dt id="verbose"><a class="permalink" href="#verbose">verbose =&gt;
    $bool</a></dt>
  <dd>If present, will cause <span class="Li">&quot;make_path&quot;</span> to
      print the name of each directory as it is created. By default nothing is
      printed.</dd>
  <dt id="error"><a class="permalink" href="#error">error =&gt; \$err</a></dt>
  <dd>If present, it should be a reference to a scalar. This scalar will be made
      to reference an array, which will be used to store any errors that are
      encountered. See the &quot;ERROR HANDLING&quot; section for more
      information.
    <p class="Pp">If this parameter is not used, certain error conditions may
        raise a fatal error that will cause the program to halt, unless trapped
        in an <span class="Li">&quot;eval&quot;</span> block.</p>
  </dd>
  <dt id="owner"><a class="permalink" href="#owner">owner =&gt; $owner</a></dt>
  <dd></dd>
  <dt id="user"><a class="permalink" href="#user">user =&gt; $owner</a></dt>
  <dd></dd>
  <dt id="uid"><a class="permalink" href="#uid">uid =&gt; $owner</a></dt>
  <dd>If present, will cause any created directory to be owned by
      <span class="Li">$owner</span>. If the value is numeric, it will be
      interpreted as a uid; otherwise a username is assumed. An error will be
      issued if the username cannot be mapped to a uid, the uid does not exist
      or the process lacks the privileges to change ownership.
    <p class="Pp">Ownership of directories that already exist will not be
        changed.</p>
    <p class="Pp"><span class="Li">&quot;user&quot;</span> and
        <span class="Li">&quot;uid&quot;</span> are aliases of
        <span class="Li">&quot;owner&quot;</span>.</p>
  </dd>
  <dt id="group"><a class="permalink" href="#group">group =&gt; $group</a></dt>
  <dd>If present, will cause any created directory to be owned by the group
      <span class="Li">$group</span>. If the value is numeric, it will be
      interpreted as a gid; otherwise a group name is assumed. An error will be
      issued if the group name cannot be mapped to a gid, the gid does not exist
      or the process lacks the privileges to change group ownership.
    <p class="Pp">Group ownership of directories that already exist will not be
        changed.</p>
    <p class="Pp"></p>
    <pre>    make_path '/var/tmp/webcache', {owner=&gt;'nobody', group=&gt;'nogroup'};
    </pre>
  </dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="mkpath("><a class="permalink" href="#mkpath(">mkpath( $dir )</a></dt>
  <dd></dd>
  <dt id="mkpath(~2"><a class="permalink" href="#mkpath(~2">mkpath( $dir,
    $verbose, $mode )</a></dt>
  <dd></dd>
  <dt id="mkpath(~3"><a class="permalink" href="#mkpath(~3">mkpath( [$dir1,
    $dir2,...], $verbose, $mode )</a></dt>
  <dd></dd>
  <dt id="mkpath(~4"><a class="permalink" href="#mkpath(~4">mkpath( $dir1,
    $dir2,..., \%opt )</a></dt>
  <dd>The <span class="Li">&quot;mkpath()&quot;</span> function provide the
      legacy interface of <span class="Li">&quot;make_path()&quot;</span> with a
      different interpretation of the arguments passed. The behaviour and return
      value of the function is otherwise identical to
      <span class="Li">&quot;make_path()&quot;</span>.</dd>
  <dt id="remove_tree("><a class="permalink" href="#remove_tree(">remove_tree(
    $dir1, $dir2, .... )</a></dt>
  <dd></dd>
  <dt id="remove_tree(~2"><a class="permalink" href="#remove_tree(~2">remove_tree(
    $dir1, $dir2, ...., \%opts )</a></dt>
  <dd>The <span class="Li">&quot;remove_tree&quot;</span> function deletes the
      given directories and any files and subdirectories they might contain,
      much like the Unix command <span class="Li">&quot;rm -rf&quot;</span> or
      the Windows commands <span class="Li">&quot;rmdir /s&quot;</span> and
      <span class="Li">&quot;rd /s&quot;</span>.
    <p class="Pp">The function accepts a list of directories to be removed. (In
        point of fact, it will also accept filesystem entries which are not
        directories, such as regular files and symlinks. But, as its name
        suggests, its intent is to remove trees rather than individual
      files.)</p>
    <p class="Pp"><span class="Li">&quot;remove_tree()&quot;</span>'s behaviour
        may be tuned by an optional hashref appearing as the last parameter on
        the call. If an empty string is passed to
        <span class="Li">&quot;remove_tree&quot;</span>, an error will
      occur.</p>
    <p class="Pp"><b>NOTE:</b> For security reasons, we strongly advise use of
        the hashref-as-final-argument syntax -- specifically, with a setting of
        the <span class="Li">&quot;safe&quot;</span> element to a true
      value.</p>
    <p class="Pp"></p>
    <pre>    remove_tree( $dir1, $dir2, ....,
        {
            safe =&gt; 1,
            ...         # other key-value pairs
        },
    );
    </pre>
    <p class="Pp">The function returns the number of files successfully
      deleted.</p>
    <p class="Pp">The following keys are recognised in the option hash:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="verbose~2"><a class="permalink" href="#verbose~2">verbose =&gt;
    $bool</a></dt>
  <dd>If present, will cause <span class="Li">&quot;remove_tree&quot;</span> to
      print the name of each file as it is unlinked. By default nothing is
      printed.</dd>
  <dt id="safe"><a class="permalink" href="#safe">safe =&gt; $bool</a></dt>
  <dd>When set to a true value, will cause
      <span class="Li">&quot;remove_tree&quot;</span> to skip the files for
      which the process lacks the required privileges needed to delete files,
      such as delete privileges on VMS. In other words, the code will make no
      attempt to alter file permissions. Thus, if the process is interrupted, no
      filesystem object will be left in a more permissive mode.</dd>
  <dt id="keep_root"><a class="permalink" href="#keep_root">keep_root =&gt;
    $bool</a></dt>
  <dd>When set to a true value, will cause all files and subdirectories to be
      removed, except the initially specified directories. This comes in handy
      when cleaning out an application's scratch directory.
    <p class="Pp"></p>
    <pre>    remove_tree( '/tmp', {keep_root =&gt; 1} );
    </pre>
  </dd>
  <dt id="result"><a class="permalink" href="#result">result =&gt;
    \$res</a></dt>
  <dd>If present, it should be a reference to a scalar. This scalar will be made
      to reference an array, which will be used to store all files and
      directories unlinked during the call. If nothing is unlinked, the array
      will be empty.
    <p class="Pp"></p>
    <pre>    remove_tree( '/tmp', {result =&gt; \my $list} );
    print &quot;unlinked $_\n&quot; for @$list;
    </pre>
    <p class="Pp">This is a useful alternative to the
        <span class="Li">&quot;verbose&quot;</span> key.</p>
  </dd>
  <dt id="error~2"><a class="permalink" href="#error~2">error =&gt;
    \$err</a></dt>
  <dd>If present, it should be a reference to a scalar. This scalar will be made
      to reference an array, which will be used to store any errors that are
      encountered. See the &quot;ERROR HANDLING&quot; section for more
      information.
    <p class="Pp">Removing things is a much more dangerous proposition than
        creating things. As such, there are certain conditions that
        <span class="Li">&quot;remove_tree&quot;</span> may encounter that are
        so dangerous that the only sane action left is to kill the program.</p>
    <p class="Pp">Use <span class="Li">&quot;error&quot;</span> to trap all that
        is reasonable (problems with permissions and the like), and let it die
        if things get out of hand. This is the safest course of action.</p>
  </dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="rmtree("><a class="permalink" href="#rmtree(">rmtree( $dir )</a></dt>
  <dd></dd>
  <dt id="rmtree(~2"><a class="permalink" href="#rmtree(~2">rmtree( $dir,
    $verbose, $safe )</a></dt>
  <dd></dd>
  <dt id="rmtree(~3"><a class="permalink" href="#rmtree(~3">rmtree( [$dir1,
    $dir2,...], $verbose, $safe )</a></dt>
  <dd></dd>
  <dt id="rmtree(~4"><a class="permalink" href="#rmtree(~4">rmtree( $dir1,
    $dir2,..., \%opt )</a></dt>
  <dd>The <span class="Li">&quot;rmtree()&quot;</span> function provide the
      legacy interface of <span class="Li">&quot;remove_tree()&quot;</span> with
      a different interpretation of the arguments passed. The behaviour and
      return value of the function is otherwise identical to
      <span class="Li">&quot;remove_tree()&quot;</span>.
    <p class="Pp"><b>NOTE:</b> For security reasons, we strongly advise use of
        the hashref-as-final-argument syntax, specifically with a setting of the
        <span class="Li">&quot;safe&quot;</span> element to a true value.</p>
    <p class="Pp"></p>
    <pre>    rmtree( $dir1, $dir2, ....,
        {
            safe =&gt; 1,
            ...         # other key-value pairs
        },
    );
    </pre>
  </dd>
</dl>
<section class="Ss">
<h2 class="Ss">ERROR HANDLING</h2>
<dl class="Bl-tag">
  <dt id="NOTE:"><a class="permalink" href="#NOTE:"><b>NOTE:</b></a></dt>
  <dd>The following error handling mechanism is consistent throughout all code
      paths EXCEPT in cases where the ROOT node is nonexistent. In version 2.11
      the maintainers attempted to rectify this inconsistency but too many
      downstream modules encountered problems. In such case, if you require root
      node evaluation or error checking prior to calling
      <span class="Li">&quot;make_path&quot;</span> or
      <span class="Li">&quot;remove_tree&quot;</span>, you should take
      additional precautions.</dd>
</dl>
<p class="Pp">If <span class="Li">&quot;make_path&quot;</span> or
    <span class="Li">&quot;remove_tree&quot;</span> encounters an error, a
    diagnostic message will be printed to
    <span class="Li">&quot;STDERR&quot;</span> via
    <span class="Li">&quot;carp&quot;</span> (for non-fatal errors) or via
    <span class="Li">&quot;croak&quot;</span> (for fatal errors).</p>
<p class="Pp">If this behaviour is not desirable, the
    <span class="Li">&quot;error&quot;</span> attribute may be used to hold a
    reference to a variable, which will be used to store the diagnostics. The
    variable is made a reference to an array of hash references. Each hash
    contain a single key/value pair where the key is the name of the file, and
    the value is the error message (including the contents of
    <span class="Li">$!</span> when appropriate). If a general error is
    encountered the diagnostic key will be empty.</p>
<p class="Pp">An example usage looks like:</p>
<p class="Pp"></p>
<pre>  remove_tree( 'foo/bar', 'bar/rat', {error =&gt; \my $err} );
  if ($err &amp;&amp; @$err) {
      for my $diag (@$err) {
          my ($file, $message) = %$diag;
          if ($file eq '') {
              print &quot;general error: $message\n&quot;;
          }
          else {
              print &quot;problem unlinking $file: $message\n&quot;;
          }
      }
  }
  else {
      print &quot;No error encountered\n&quot;;
  }
</pre>
<p class="Pp">Note that if no errors are encountered,
    <span class="Li">$err</span> will reference an empty array. This means that
    <span class="Li">$err</span> will always end up TRUE; so you need to test
    <span class="Li">@$err</span> to determine if errors occurred.</p>
</section>
<section class="Ss">
<h2 class="Ss">NOTES</h2>
<p class="Pp"><span class="Li">&quot;File::Path&quot;</span> blindly exports
    <span class="Li">&quot;mkpath&quot;</span> and
    <span class="Li">&quot;rmtree&quot;</span> into the current namespace. These
    days, this is considered bad style, but to change it now would break too
    much code. Nonetheless, you are invited to specify what it is you are
    expecting to use:</p>
<p class="Pp"></p>
<pre>  use File::Path 'rmtree';
</pre>
<p class="Pp">The routines <span class="Li">&quot;make_path&quot;</span> and
    <span class="Li">&quot;remove_tree&quot;</span> are <b>not</b> exported by
    default. You must specify which ones you want to use.</p>
<p class="Pp"></p>
<pre>  use File::Path 'remove_tree';
</pre>
<p class="Pp">Note that a side-effect of the above is that
    <span class="Li">&quot;mkpath&quot;</span> and
    <span class="Li">&quot;rmtree&quot;</span> are no longer exported at all.
    This is due to the way the <span class="Li">&quot;Exporter&quot;</span>
    module works. If you are migrating a codebase to use the new interface, you
    will have to list everything explicitly. But that's just good practice
    anyway.</p>
<p class="Pp"></p>
<pre>  use File::Path qw(remove_tree rmtree);
</pre>
<p class="Pp"><i>API CHANGES</i></p>
<p class="Pp">The API was changed in the 2.0 branch. For a time,
    <span class="Li">&quot;mkpath&quot;</span> and
    <span class="Li">&quot;rmtree&quot;</span> tried, unsuccessfully, to deal
    with the two different calling mechanisms. This approach was considered a
    failure.</p>
<p class="Pp">The new semantics are now only available with
    <span class="Li">&quot;make_path&quot;</span> and
    <span class="Li">&quot;remove_tree&quot;</span>. The old semantics are only
    available through <span class="Li">&quot;mkpath&quot;</span> and
    <span class="Li">&quot;rmtree&quot;</span>. Users are strongly encouraged to
    upgrade to at least 2.08 in order to avoid surprises.</p>
<p class="Pp"><i>SECURITY CONSIDERATIONS</i></p>
<p class="Pp">There were race conditions in the 1.x implementations of
    File::Path's <span class="Li">&quot;rmtree&quot;</span> function (although
    sometimes patched depending on the OS distribution or platform). The 2.0
    version contains code to avoid the problem mentioned in CVE-2002-0435.</p>
<p class="Pp">See the following pages for more information:</p>
<p class="Pp"></p>
<pre>    http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=286905
    http://www.nntp.perl.org/group/perl.perl5.porters/2005/01/msg97623.html
    http://www.debian.org/security/2005/dsa-696
</pre>
<p class="Pp">Additionally, unless the <span class="Li">&quot;safe&quot;</span>
    parameter is set (or the third parameter in the traditional interface is
    TRUE), should a <span class="Li">&quot;remove_tree&quot;</span> be
    interrupted, files that were originally in read-only mode may now have their
    permissions set to a read-write (or &quot;delete OK&quot;) mode.</p>
<p class="Pp">The following CVE reports were previously filed against File-Path
    and are believed to have been addressed:</p>
<ul class="Bl-bullet">
  <li>&lt;http://cve.circl.lu/cve/CVE-2004-0452&gt;</li>
  <li>&lt;http://cve.circl.lu/cve/CVE-2005-0448&gt;</li>
</ul>
<p class="Pp">In February 2017 the cPanel Security Team reported an additional
    vulnerability in File-Path. The <span class="Li">&quot;chmod()&quot;</span>
    logic to make directories traversable can be abused to set the mode on an
    attacker-chosen file to an attacker-chosen value. This is due to the
    time-of-check-to-time-of-use (TOCTTOU) race condition
    (&lt;https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use&gt;) between
    the <span class="Li">&quot;stat()&quot;</span> that decides the inode is a
    directory and the <span class="Li">&quot;chmod()&quot;</span> that tries to
    make it user-rwx. CPAN versions 2.13 and later incorporate a patch provided
    by John Lightsey to address this problem. This vulnerability has been
    reported as CVE-2017-6512.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DIAGNOSTICS"><a class="permalink" href="#DIAGNOSTICS">DIAGNOSTICS</a></h1>
<p class="Pp">FATAL errors will cause the program to halt
    (<span class="Li">&quot;croak&quot;</span>), since the problem is so severe
    that it would be dangerous to continue. (This can always be trapped with
    <span class="Li">&quot;eval&quot;</span>, but it's not a good idea. Under
    the circumstances, dying is the best thing to do).</p>
<p class="Pp">SEVERE errors may be trapped using the modern interface. If the
    they are not trapped, or if the old interface is used, such an error will
    cause the program will halt.</p>
<p class="Pp">All other errors may be trapped using the modern interface,
    otherwise they will be <span class="Li">&quot;carp&quot;</span>ed about.
    Program execution will not be halted.</p>
<dl class="Bl-tag">
  <dt id="mkdir"><a class="permalink" href="#mkdir">mkdir [path]: [errmsg]
    (SEVERE)</a></dt>
  <dd><span class="Li">&quot;make_path&quot;</span> was unable to create the
      path. Probably some sort of permissions error at the point of departure or
      insufficient resources (such as free inodes on Unix).</dd>
  <dt id="No"><a class="permalink" href="#No">No root path(s) specified</a></dt>
  <dd><span class="Li">&quot;make_path&quot;</span> was not given any paths to
      create. This message is only emitted if the routine is called with the
      traditional interface. The modern interface will remain silent if given
      nothing to do.</dd>
  <dt id="No~2"><a class="permalink" href="#No~2">No such file or
    directory</a></dt>
  <dd>On Windows, if <span class="Li">&quot;make_path&quot;</span> gives you
      this warning, it may mean that you have exceeded your filesystem's maximum
      path length.</dd>
  <dt id="cannot"><a class="permalink" href="#cannot">cannot fetch initial
    working directory: [errmsg]</a></dt>
  <dd><span class="Li">&quot;remove_tree&quot;</span> attempted to determine the
      initial directory by calling
      <span class="Li">&quot;Cwd::getcwd&quot;</span>, but the call failed for
      some reason. No attempt will be made to delete anything.</dd>
  <dt id="cannot~2"><a class="permalink" href="#cannot~2">cannot stat initial
    working directory: [errmsg]</a></dt>
  <dd><span class="Li">&quot;remove_tree&quot;</span> attempted to stat the
      initial directory (after having successfully obtained its name via
      <span class="Li">&quot;getcwd&quot;</span>), however, the call failed for
      some reason. No attempt will be made to delete anything.</dd>
  <dt id="cannot~3"><a class="permalink" href="#cannot~3">cannot chdir to [dir]:
    [errmsg]</a></dt>
  <dd><span class="Li">&quot;remove_tree&quot;</span> attempted to set the
      working directory in order to begin deleting the objects therein, but was
      unsuccessful. This is usually a permissions issue. The routine will
      continue to delete other things, but this directory will be left
    intact.</dd>
  <dt id="directory"><a class="permalink" href="#directory">directory [dir]
    changed before chdir, expected dev=[n] ino=[n], actual dev=[n] ino=[n],
    aborting. (FATAL)</a></dt>
  <dd><span class="Li">&quot;remove_tree&quot;</span> recorded the device and
      inode of a directory, and then moved into it. It then performed a
      <span class="Li">&quot;stat&quot;</span> on the current directory and
      detected that the device and inode were no longer the same. As this is at
      the heart of the race condition problem, the program will die at this
      point.</dd>
  <dt id="cannot~4"><a class="permalink" href="#cannot~4">cannot make directory
    [dir] read+writeable: [errmsg]</a></dt>
  <dd><span class="Li">&quot;remove_tree&quot;</span> attempted to change the
      permissions on the current directory to ensure that subsequent unlinkings
      would not run into problems, but was unable to do so. The permissions
      remain as they were, and the program will carry on, doing the best it
    can.</dd>
  <dt id="cannot~5"><a class="permalink" href="#cannot~5">cannot read [dir]:
    [errmsg]</a></dt>
  <dd><span class="Li">&quot;remove_tree&quot;</span> tried to read the contents
      of the directory in order to acquire the names of the directory entries to
      be unlinked, but was unsuccessful. This is usually a permissions issue.
      The program will continue, but the files in this directory will remain
      after the call.</dd>
  <dt id="cannot~6"><a class="permalink" href="#cannot~6">cannot reset chmod
    [dir]: [errmsg]</a></dt>
  <dd><span class="Li">&quot;remove_tree&quot;</span>, after having deleted
      everything in a directory, attempted to restore its permissions to the
      original state but failed. The directory may wind up being left
    behind.</dd>
  <dt id="cannot~7"><a class="permalink" href="#cannot~7">cannot remove [dir]
    when cwd is [dir]</a></dt>
  <dd>The current working directory of the program is <i>/some/path/to/here</i>
      and you are attempting to remove an ancestor, such as <i>/some/path</i>.
      The directory tree is left untouched.
    <p class="Pp">The solution is to <span class="Li">&quot;chdir&quot;</span>
        out of the child directory to a place outside the directory tree to be
        removed.</p>
  </dd>
  <dt id="cannot~8"><a class="permalink" href="#cannot~8">cannot chdir to
    [parent-dir] from [child-dir]: [errmsg], aborting. (FATAL)</a></dt>
  <dd><span class="Li">&quot;remove_tree&quot;</span>, after having deleted
      everything and restored the permissions of a directory, was unable to
      chdir back to the parent. The program halts to avoid a race condition from
      occurring.</dd>
  <dt id="cannot~9"><a class="permalink" href="#cannot~9">cannot stat prior
    working directory [dir]: [errmsg], aborting. (FATAL)</a></dt>
  <dd><span class="Li">&quot;remove_tree&quot;</span> was unable to stat the
      parent directory after having returned from the child. Since there is no
      way of knowing if we returned to where we think we should be (by comparing
      device and inode) the only way out is to
      <span class="Li">&quot;croak&quot;</span>.</dd>
  <dt id="previous"><a class="permalink" href="#previous">previous directory
    [parent-dir] changed before entering [child-dir], expected dev=[n] ino=[n],
    actual dev=[n] ino=[n], aborting. (FATAL)</a></dt>
  <dd>When <span class="Li">&quot;remove_tree&quot;</span> returned from
      deleting files in a child directory, a check revealed that the parent
      directory it returned to wasn't the one it started out from. This is
      considered a sign of malicious activity.</dd>
  <dt id="cannot~10"><a class="permalink" href="#cannot~10">cannot make
    directory [dir] writeable: [errmsg]</a></dt>
  <dd>Just before removing a directory (after having successfully removed
      everything it contained), <span class="Li">&quot;remove_tree&quot;</span>
      attempted to set the permissions on the directory to ensure it could be
      removed and failed. Program execution continues, but the directory may
      possibly not be deleted.</dd>
  <dt id="cannot~11"><a class="permalink" href="#cannot~11">cannot remove
    directory [dir]: [errmsg]</a></dt>
  <dd><span class="Li">&quot;remove_tree&quot;</span> attempted to remove a
      directory, but failed. This may be because some objects that were unable
      to be removed remain in the directory, or it could be a permissions issue.
      The directory will be left behind.</dd>
  <dt id="cannot~12"><a class="permalink" href="#cannot~12">cannot restore
    permissions of [dir] to [0nnn]: [errmsg]</a></dt>
  <dd>After having failed to remove a directory,
      <span class="Li">&quot;remove_tree&quot;</span> was unable to restore its
      permissions from a permissive state back to a possibly more restrictive
      setting. (Permissions given in octal).</dd>
  <dt id="cannot~13"><a class="permalink" href="#cannot~13">cannot make file
    [file] writeable: [errmsg]</a></dt>
  <dd><span class="Li">&quot;remove_tree&quot;</span> attempted to force the
      permissions of a file to ensure it could be deleted, but failed to do so.
      It will, however, still attempt to unlink the file.</dd>
  <dt id="cannot~14"><a class="permalink" href="#cannot~14">cannot unlink file
    [file]: [errmsg]</a></dt>
  <dd><span class="Li">&quot;remove_tree&quot;</span> failed to remove a file.
      Probably a permissions issue.</dd>
  <dt id="cannot~15"><a class="permalink" href="#cannot~15">cannot restore
    permissions of [file] to [0nnn]: [errmsg]</a></dt>
  <dd>After having failed to remove a file,
      <span class="Li">&quot;remove_tree&quot;</span> was also unable to restore
      the permissions on the file to a possibly less permissive setting.
      (Permissions given in octal).</dd>
  <dt id="unable"><a class="permalink" href="#unable">unable to map [owner] to a
    uid, ownership not changed&quot;);</a></dt>
  <dd><span class="Li">&quot;make_path&quot;</span> was instructed to give the
      ownership of created directories to the symbolic name [owner], but
      <span class="Li">&quot;getpwnam&quot;</span> did not return the
      corresponding numeric uid. The directory will be created, but ownership
      will not be changed.</dd>
  <dt id="unable~2"><a class="permalink" href="#unable~2">unable to map [group]
    to a gid, group ownership not changed</a></dt>
  <dd><span class="Li">&quot;make_path&quot;</span> was instructed to give the
      group ownership of created directories to the symbolic name [group], but
      <span class="Li">&quot;getgrnam&quot;</span> did not return the
      corresponding numeric gid. The directory will be created, but group
      ownership will not be changed.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<ul class="Bl-bullet">
  <li>File::Remove
    <p class="Pp">Allows files and directories to be moved to the
        Trashcan/Recycle Bin (where they may later be restored if necessary) if
        the operating system supports such functionality. This feature may one
        day be made available directly in
        <span class="Li">&quot;File::Path&quot;</span>.</p>
  </li>
  <li>File::Find::Rule
    <p class="Pp">When removing directory trees, if you want to examine each
        file to decide whether to delete it (and possibly leaving large swathes
        alone), <i>File::Find::Rule</i> offers a convenient and flexible
        approach to examining directory trees.</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS_AND_LIMITATIONS"><a class="permalink" href="#BUGS_AND_LIMITATIONS">BUGS
  AND LIMITATIONS</a></h1>
<p class="Pp">The following describes <i>File::Path</i> limitations and how to
    report bugs.</p>
<section class="Ss">
<h2 class="Ss">MULTITHREADED APPLICATIONS</h2>
<p class="Pp"><i>File::Path</i> <span class="Li">&quot;rmtree&quot;</span> and
    <span class="Li">&quot;remove_tree&quot;</span> will not work with
    multithreaded applications due to its use of
    <span class="Li">&quot;chdir&quot;</span>. At this time, no warning or error
    is generated in this situation. You will certainly encounter unexpected
    results.</p>
<p class="Pp">The implementation that surfaces this limitation will not be
    changed. See the <i>File::Path::Tiny</i> module for functionality similar to
    <i>File::Path</i> but which does not
    <span class="Li">&quot;chdir&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss">NFS Mount Points</h2>
<p class="Pp"><i>File::Path</i> is not responsible for triggering the
    automounts, mirror mounts, and the contents of network mounted filesystems.
    If your NFS implementation requires an action to be performed on the
    filesystem in order for <i>File::Path</i> to perform operations, it is
    strongly suggested you assure filesystem availability by reading the root of
    the mounted filesystem.</p>
</section>
<section class="Ss">
<h2 class="Ss">REPORTING BUGS</h2>
<p class="Pp">Please report all bugs on the RT queue, either via the web
    interface:</p>
<p class="Pp">&lt;http://rt.cpan.org/NoAuth/Bugs.html?Dist=File-Path&gt;</p>
<p class="Pp">or by email:</p>
<p class="Pp"></p>
<pre>    bug-File-Path@rt.cpan.org
</pre>
<p class="Pp">In either case, please <b>attach</b> patches to the bug report
    rather than including them inline in the web post or the body of the
  email.</p>
<p class="Pp">You can also send pull requests to the Github repository:</p>
<p class="Pp">&lt;https://github.com/rpcme/File-Path&gt;</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGEMENTS"><a class="permalink" href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></h1>
<p class="Pp">Paul Szabo identified the race condition originally, and Brendan
    O'Dea wrote an implementation for Debian that addressed the problem. That
    code was used as a basis for the current code. Their efforts are greatly
    appreciated.</p>
<p class="Pp">Gisle Aas made a number of improvements to the documentation for
    2.07 and his advice and assistance is also greatly appreciated.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp">Prior authors and maintainers: Tim Bunce, Charles Bailey, and
    David Landgren &lt;<i>david@landgren.net</i>&gt;.</p>
<p class="Pp">Current maintainers are Richard Elberger
    &lt;<i>riche@cpan.org</i>&gt; and James (Jim) Keenan
    &lt;<i>jkeenan@cpan.org</i>&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<p class="Pp">Contributors to File::Path, in alphabetical order by first
  name.</p>
<dl class="Bl-tag">
  <dt>&lt;<i>bulkdd@cpan.org</i>&gt;</dt>
  <dd></dd>
  <dt id="Charlie"><a class="permalink" href="#Charlie">Charlie Gonzalez
    &lt;<i>itcharlie@cpan.org</i>&gt;</a></dt>
  <dd></dd>
  <dt id="Craig"><a class="permalink" href="#Craig">Craig A. Berry
    &lt;<i>craigberry@mac.com</i>&gt;</a></dt>
  <dd></dd>
  <dt id="James"><a class="permalink" href="#James">James E Keenan
    &lt;<i>jkeenan@cpan.org</i>&gt;</a></dt>
  <dd></dd>
  <dt id="John"><a class="permalink" href="#John">John Lightsey
    &lt;<i>john@perlsec.org</i>&gt;</a></dt>
  <dd></dd>
  <dt id="Nigel"><a class="permalink" href="#Nigel">Nigel Horne
    &lt;<i>njh@bandsman.co.uk</i>&gt;</a></dt>
  <dd></dd>
  <dt id="Richard"><a class="permalink" href="#Richard">Richard Elberger
    &lt;<i>riche@cpan.org</i>&gt;</a></dt>
  <dd></dd>
  <dt id="Ryan"><a class="permalink" href="#Ryan">Ryan Yee
    &lt;<i>ryee@cpan.org</i>&gt;</a></dt>
  <dd></dd>
  <dt id="Skye"><a class="permalink" href="#Skye">Skye Shaw
    &lt;<i>shaw@cpan.org</i>&gt;</a></dt>
  <dd></dd>
  <dt id="Tom"><a class="permalink" href="#Tom">Tom Lutz
    &lt;<i>tommylutz@gmail.com</i>&gt;</a></dt>
  <dd></dd>
  <dt id="Will"><a class="permalink" href="#Will">Will Sheppard
    &lt;<i>willsheppard@github</i>&gt;</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">This module is copyright (C) Charles Bailey, Tim Bunce, David
    Landgren, James Keenan and Richard Elberger 1995-2018. All rights
  reserved.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>XML::LibXML::InputCallback(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">XML::LibXML::InputCallback(3)</td>
    <td class="head-vol"><a href=".">User Contributed Perl Documentation</a></td>
    <td class="head-rtitle">XML::LibXML::InputCallback(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">XML::LibXML::InputCallback - XML::LibXML Class for Input
  Callbacks</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  use XML::LibXML;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">You may get unexpected results if you are trying to load external
    documents during libxml2 parsing if the location of the resource is not a
    HTTP, FTP or relative location but a absolute path for example. To get
    around this limitation, you may add your own input handler to open, read and
    close particular types of locations or URI classes. Using this input
    callback handlers, you can handle your own custom URI schemes for
  example.</p>
<p class="Pp">The input callbacks are used whenever LibXML has to get something
    other than externally parsed entities from somewhere. They are implemented
    using a callback stack on the Perl layer in analogy to libxml2's native
    callback stack.</p>
<p class="Pp">The XML::LibXML::InputCallback class transparently registers the
    input callbacks for the libxml2's parser processes.</p>
<section class="Ss">
<h2 class="Ss" id="How_does_XML::LibXML::InputCallback_work?"><a class="permalink" href="#How_does_XML::LibXML::InputCallback_work?">How
  does XML::LibXML::InputCallback work?</a></h2>
<p class="Pp">The libxml2 library offers a callback implementation as global
    functions only. To work-around the troubles resulting in having only global
    callbacks - for example, if the same global callback stack is manipulated by
    different applications running together in a single Apache Web-server
    environment -, XML::LibXML::InputCallback comes with a object-oriented and a
    function-oriented part.</p>
<p class="Pp">Using the function-oriented part the global callback stack of
    libxml2 can be manipulated. Those functions can be used as interface to the
    callbacks on the C- and XS Layer. At the object-oriented part, operations
    for working with the &quot;pseudo-localized&quot; callback stack are
    implemented. Currently, you can register and de-register callbacks on the
    Perl layer and initialize them on a per parser basis.</p>
<p class="Pp"><i>Callback Groups</i></p>
<p class="Pp">The libxml2 input callbacks come in groups. One group contains a
    URI matcher (<i>match</i>), a data stream constructor (<i>open</i>), a data
    stream reader (<i>read</i>), and a data stream destructor (<i>close</i>).
    The callbacks can be manipulated on a per group basis only.</p>
<p class="Pp"><i>The Parser Process</i></p>
<p class="Pp">The parser process works on an XML data stream, along which, links
    to other resources can be embedded. This can be links to external DTDs or
    XIncludes for example. Those resources are identified by URIs. The callback
    implementation of libxml2 assumes that one callback group can handle a
    certain amount of URIs and a certain URI scheme. Per default, callback
    handlers for <i>file://*</i>, <i>file:://*.gz</i>, <i>http://*</i> and
    <i>ftp://*</i> are registered.</p>
<p class="Pp">Callback groups in the callback stack are processed from top to
    bottom, meaning that callback groups registered later will be processed
    before the earlier registered ones.</p>
<p class="Pp">While parsing the data stream, the libxml2 parser checks if a
    registered callback group will handle a URI - if they will not, the URI will
    be interpreted as <i>file://URI</i>. To handle a URI, the <i>match</i>
    callback will have to return '1'. If that happens, the handling of the URI
    will be passed to that callback group. Next, the URI will be passed to the
    <i>open</i> callback, which should return a <i>reference</i> to the data
    stream if it successfully opened the file, '0' otherwise. If opening the
    stream was successful, the <i>read</i> callback will be called repeatedly
    until it returns an empty string. After the read callback, the <i>close</i>
    callback will be called to close the stream.</p>
<p class="Pp"><i>Organisation of callback groups in
    XML::LibXML::InputCallback</i></p>
<p class="Pp">Callback groups are implemented as a stack (Array), each entry
    holds a reference to an array of the callbacks. For the libxml2 library, the
    XML::LibXML::InputCallback callback implementation appears as one single
    callback group. The Perl implementation however allows one to manage
    different callback stacks on a per libxml2-parser basis.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_XML::LibXML::InputCallback"><a class="permalink" href="#Using_XML::LibXML::InputCallback">Using
  XML::LibXML::InputCallback</a></h2>
<p class="Pp">After object instantiation using the parameter-less constructor,
    you can register callback groups.</p>
<p class="Pp"></p>
<pre>  my $input_callbacks = XML::LibXML::InputCallback-&gt;new();
  $input_callbacks-&gt;register_callbacks([ $match_cb1, $open_cb1,
                                         $read_cb1, $close_cb1 ] );
  $input_callbacks-&gt;register_callbacks([ $match_cb2, $open_cb2,
                                         $read_cb2, $close_cb2 ] );
  $input_callbacks-&gt;register_callbacks( [ $match_cb3, $open_cb3,
                                          $read_cb3, $close_cb3 ] );
  $parser-&gt;input_callbacks( $input_callbacks );
  $parser-&gt;parse_file( $some_xml_file );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="What_about_the_old_callback_system_prior_to_XML::LibXML::InputCallback?"><a class="permalink" href="#What_about_the_old_callback_system_prior_to_XML::LibXML::InputCallback?">What
  about the old callback system prior to XML::LibXML::InputCallback?</a></h2>
<p class="Pp">In XML::LibXML versions prior to 1.59 - i.e. without the
    XML::LibXML::InputCallback module - you could define your callbacks either
    using globally or locally. You still can do that using
    XML::LibXML::InputCallback, and in addition to that you can define the
    callbacks on a per parser basis!</p>
<p class="Pp">If you use the old callback interface through global callbacks,
    XML::LibXML::InputCallback will treat them with a lower priority as the ones
    registered using the new interface. The global callbacks will not override
    the callback groups registered using the new interface. Local callbacks are
    attached to a specific parser instance, therefore they are treated with
    highest priority. If the <i>match</i> callback of the callback group
    registered as local variable is identical to one of the callback groups
    registered using the new interface, that callback group will be
  replaced.</p>
<p class="Pp">Users of the old callback implementation whose <i>open</i>
    callback returned a plain string, will have to adapt their code to return a
    reference to that string after upgrading to version &gt;= 1.59. The new
    callback system can only deal with the <i>open</i> callback returning a
    reference!</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="INTERFACE_DESCRIPTION"><a class="permalink" href="#INTERFACE_DESCRIPTION">INTERFACE
  DESCRIPTION</a></h1>
<section class="Ss">
<h2 class="Ss" id="Global_Variables"><a class="permalink" href="#Global_Variables">Global
  Variables</a></h2>
<dl class="Bl-tag">
  <dt>$_CUR_CB</dt>
  <dd>Stores the current callback and can be used as shortcut to access the
      callback stack.</dd>
  <dt>@_GLOBAL_CALLBACKS</dt>
  <dd>Stores all callback groups for the current parser process.</dd>
  <dt>@_CB_STACK</dt>
  <dd>Stores the currently used callback group. Used to prevent parser errors
      when dealing with nested XML data.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Global_Callbacks"><a class="permalink" href="#Global_Callbacks">Global
  Callbacks</a></h2>
<dl class="Bl-tag">
  <dt>_callback_match</dt>
  <dd>Implements the interface for the <i>match</i> callback at C-level and for
      the selection of the callback group from the callbacks defined at the
      Perl-level.</dd>
  <dt>_callback_open</dt>
  <dd>Forwards the <i>open</i> callback from libxml2 to the corresponding
      callback function at the Perl-level.</dd>
  <dt>_callback_read</dt>
  <dd>Forwards the read request to the corresponding callback function at the
      Perl-level and returns the result to libxml2.</dd>
  <dt>_callback_close</dt>
  <dd>Forwards the <i>close</i> callback from libxml2 to the corresponding
      callback function at the Perl-level..</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Class_methods"><a class="permalink" href="#Class_methods">Class
  methods</a></h2>
<dl class="Bl-tag">
  <dt id="new()"><a class="permalink" href="#new()"><b>new()</b></a></dt>
  <dd>A simple constructor.</dd>
  <dt id="register_callbacks("><a class="permalink" href="#register_callbacks(">register_callbacks(
    [ $match_cb, $open_cb, $read_cb, $close_cb ])</a></dt>
  <dd>The four callbacks <i>have</i> to be given as array reference in the above
      order <i>match</i>, <i>open</i>, <i>read</i>, <i>close</i>!</dd>
  <dt id="unregister_callbacks("><a class="permalink" href="#unregister_callbacks(">unregister_callbacks(
    [ $match_cb, $open_cb, $read_cb, $close_cb ])</a></dt>
  <dd>With no arguments given,
      <span class="Li">&quot;unregister_callbacks()&quot;</span> will delete the
      last registered callback group from the stack. If four callbacks are
      passed as array reference, the callback group to unregister will be
      identified by the <i>match</i> callback and deleted from the callback
      stack. Note that if several identical <i>match</i> callbacks are defined
      in different callback groups, ALL of them will be deleted from the
    stack.</dd>
  <dt id="init_callbacks("><a class="permalink" href="#init_callbacks(">init_callbacks(
    $parser )</a></dt>
  <dd>Initializes the callback system for the provided parser before starting a
      parsing process.</dd>
  <dt id="cleanup_callbacks()"><a class="permalink" href="#cleanup_callbacks()"><b>cleanup_callbacks()</b></a></dt>
  <dd>Resets global variables and the libxml2 callback stack.</dd>
  <dt id="lib_init_callbacks()"><a class="permalink" href="#lib_init_callbacks()"><b>lib_init_callbacks()</b></a></dt>
  <dd>Used internally for callback registration at C-level.</dd>
  <dt id="lib_cleanup_callbacks()"><a class="permalink" href="#lib_cleanup_callbacks()"><b>lib_cleanup_callbacks()</b></a></dt>
  <dd>Used internally for callback resetting at the C-level.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLE_CALLBACKS"><a class="permalink" href="#EXAMPLE_CALLBACKS">EXAMPLE
  CALLBACKS</a></h1>
<p class="Pp">The following example is a purely fictitious example that uses a
    MyScheme::Handler object that responds to methods similar to an
  IO::Handle.</p>
<p class="Pp"></p>
<pre>  # Define the four callback functions
  sub match_uri {
      my $uri = shift;
      return $uri =~ /^myscheme:/; # trigger our callback group at a 'myscheme' URIs
  }
  sub open_uri {
      my $uri = shift;
      my $handler = MyScheme::Handler-&gt;new($uri);
      return $handler;
  }
  # The returned $buffer will be parsed by the libxml2 parser
  sub read_uri {
      my $handler = shift;
      my $length = shift;
      my $buffer;
      read($handler, $buffer, $length);
      return $buffer; # $buffer will be an empty string '' if read() is done
  }
  # Close the handle associated with the resource.
  sub close_uri {
      my $handler = shift;
      close($handler);
  }
  # Register them with a instance of XML::LibXML::InputCallback
  my $input_callbacks = XML::LibXML::InputCallback-&gt;new();
  $input_callbacks-&gt;register_callbacks([ \&amp;match_uri, \&amp;open_uri,
                                         \&amp;read_uri, \&amp;close_uri ] );
  # Register the callback group at a parser instance
  $parser-&gt;input_callbacks( $input_callbacks );
  # $some_xml_file will be parsed using our callbacks
  $parser-&gt;parse_file( $some_xml_file );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp">Matt Sergeant, Christian Glahn, Petr Pajas</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">2.0110</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">2001-2007, AxKit.com Ltd.</p>
<p class="Pp">2002-2006, Christian Glahn.</p>
<p class="Pp">2006-2009, Petr Pajas.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-02-01</td>
    <td class="foot-os"><a href="..">perl v5.34.0</a></td>
  </tr>
</table>
</body>
</html>

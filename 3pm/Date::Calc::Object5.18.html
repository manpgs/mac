<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Date::Calc::Object(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Date::Calc::Object(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Date::Calc::Object(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Date::Calc::Object - Object-oriented add-on for Date::Calc with
    overloaded operators</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MOTTO"><a class="permalink" href="#MOTTO">MOTTO</a></h1>
<p class="Pp">Make frequent things easy and infrequent or hard things
  possible</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PREFACE"><a class="permalink" href="#PREFACE">PREFACE</a></h1>
<p class="Pp">Note that you do <b>NOT</b> need to
    &quot;<span class="Li">&quot;use Date::Calc qw(...);&quot;</span>&quot; in
    addition to this module.</p>
<p class="Pp">Simply</p>
<p class="Pp"></p>
<pre>
  use Date::Calc::Object qw(...);
</pre>
<p class="Pp"><b>INSTEAD OF</b></p>
<p class="Pp"></p>
<pre>
  use Date::Calc qw(...);
</pre>
<p class="Pp">with the same
    &quot;<span class="Li">&quot;qw(...)&quot;</span>&quot; as you would with
    the &quot;Date::Calc&quot; module, and then forget about
    &quot;Date::Calc::Object&quot; altogether.</p>
<p class="Pp">The rest of your existing code doesn't change at all.</p>
<p class="Pp">Note also that in order to create a new date object, you do not
    need to use</p>
<p class="Pp"></p>
<pre>
  $date_object = Date::Calc::Object-&gt;new(...);
</pre>
<p class="Pp">(but you may), and should use</p>
<p class="Pp"></p>
<pre>
  $date_object = Date::Calc-&gt;new(...);
</pre>
<p class="Pp">instead (saves you some typing and is a trifle faster).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Export_tags"><a class="permalink" href="#Export_tags">Export
  tags</a></h2>
<pre>
  :all  -  all functions from Date::Calc
  :aux  -  auxiliary functions shift_*
  :ALL  -  both :all and :aux
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Functions"><a class="permalink" href="#Functions">Functions</a></h2>
<p class="Pp">See <i>Date::Calc</i>(3) for a list of available functions.</p>
<p class="Pp"></p>
<pre>
  $year                          = shift_year(\@_);
  ($year,$mm,$dd)                = shift_date(\@_);
  ($hrs,$min,$sec)               = shift_time(\@_);
  ($year,$mm,$dd,$hrs,$min,$sec) = shift_datetime(\@_);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Methods"><a class="permalink" href="#Methods">Methods</a></h2>
<pre>
  $old = Date::Calc-&gt;accurate_mode([FLAG]);
  $old = Date::Calc-&gt;normalized_mode([FLAG]);
  $old = Date::Calc-&gt;number_format([NUMBER|CODEREF]);
  $old = Date::Calc-&gt;delta_format([NUMBER|CODEREF]);  # global default
  $old = Date::Calc-&gt;date_format([NUMBER|CODEREF]);   # global default
  $old = Date::Calc-&gt;language([LANGUAGE]);            # global default - DEPRECATED

  $old = $date-&gt;accurate_mode([FLAG]);           # is global nevertheless!
  $old = $date-&gt;normalized_mode([FLAG]);         # is global nevertheless!
  $old = $date-&gt;number_format([NUMBER|CODEREF]); # is global nevertheless!
  $old = $date-&gt;delta_format([NUMBER|CODEREF]);  # individual override
  $old = $date-&gt;date_format([NUMBER|CODEREF]);   # individual override
  $old = $date-&gt;language([LANGUAGE]);            # individual override

  $flag = $date-&gt;is_delta();
  $flag = $date-&gt;is_date();
  $flag = $date-&gt;is_short(); # i.e., has no time part
  $flag = $date-&gt;is_long();  # i.e., has time part
  $flag = $date-&gt;is_valid();

  $date = Date::Calc-&gt;new([TYPE]);
  $date = Date::Calc-&gt;new([TYPE,]YEAR,MONTH,DAY[,HRS,MIN,SEC]);
  $date = Date::Calc-&gt;new($arrayref);
  $newdate = $somedate-&gt;new([TYPE]);
  $newdate = $somedate-&gt;new([TYPE,]YEAR,MONTH,DAY[,HRS,MIN,SEC]);
  $newdate = $somedate-&gt;new($arrayref);

  $datecopy = $date-&gt;clone();
  $targetdate-&gt;copy($sourcedate);
  $targetdate-&gt;copy($arrayref);
  $targetdate-&gt;copy(@list);

  ($year,$month,$day) = $date-&gt;date([TYPE]);
  ($year,$month,$day) = $date-&gt;date([TYPE,]YEAR,MONTH,DAY[,HRS,MIN,SEC]);
  ($year,$month,$day) = $date-&gt;date($arrayref);
  ([$hrs,$min,$sec])  = $date-&gt;time([TYPE]);
  ($hrs,$min,$sec)    = $date-&gt;time([TYPE,]HRS,MIN,SEC);
  ([$hrs,$min,$sec])  = $date-&gt;time($arrayref);

  ($year,$month,$day,$hrs,$min,$sec) =
      $date-&gt;datetime([TYPE]);
  ($year,$month,$day,$hrs,$min,$sec) =
      $date-&gt;datetime([TYPE,]YEAR,MONTH,DAY[,HRS,MIN,SEC]);

  $date  = Date::Calc-&gt;today([FLAG]);
  $date  = Date::Calc-&gt;now([FLAG]); # shorthand for --+
  $date  = Date::Calc-&gt;today_and_now([FLAG]); # &lt;-----+
  $date  = Date::Calc-&gt;gmtime([time]);    # UTC/GMT
  $date  = Date::Calc-&gt;localtime([time]); # local time
  $delta = Date::Calc-&gt;tzoffset([time]);
  $date  = Date::Calc-&gt;time2date([time]); # UTC/GMT

  $date-&gt;today([FLAG]);         # updates the date part only
  $date-&gt;now([FLAG]);           # updates the time part only
  $date-&gt;today_and_now([FLAG]); # updates both date and time
  $date-&gt;gmtime([time]);        # updates both date and time (UTC/GMT)
  $date-&gt;localtime([time]);     # updates both date and time (local time)
  $delta-&gt;tzoffset([time]);     # updates both date and time
  $date-&gt;time2date([time]);     # updates both date and time (UTC/GMT)

  $time = Date::Calc-&gt;mktime();    # same as &quot;$time = CORE::time();&quot;
  $time = Date::Calc-&gt;date2time(); # same as &quot;$time = CORE::time();&quot;

  $time = $date-&gt;mktime();      # converts into Unix time (local time)
  $time = $date-&gt;date2time();   # converts into Unix time (UTC/GMT)

  $year    = $date-&gt;year([YEAR]);
  $month   = $date-&gt;month([MONTH]);
  $day     = $date-&gt;day([DAY]);
  $hours   = $date-&gt;hours([HRS]);
  $minutes = $date-&gt;minutes([MIN]);
  $seconds = $date-&gt;seconds([SEC]);

  $number = $date-&gt;number([NUMBER|CODEREF]);
  $string = $date-&gt;string([NUMBER|CODEREF][,LANGUAGE]);

  $delta-&gt;normalize(); # renormalizes a delta vector
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Overloaded_Operators"><a class="permalink" href="#Overloaded_Operators">Overloaded
  Operators</a></h2>
<pre>
  #####################################################
  # Scalar operands are always converted into a delta #
  # vector with that many days, i.e., [1,0,0,SCALAR]  #
  #####################################################
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Comparison_Operators:"><a class="permalink" href="#Comparison_Operators:">Comparison
  Operators:</a></h2>
<pre>
  if ($date1 &lt;  $date2) { # compares date part only
  if ($date1 &lt;= $date2) { # compares date part only
  if ($date1 &gt;  $date2) { # compares date part only
  if ($date1 &gt;= $date2) { # compares date part only
  if ($date1 == $date2) { # compares date part only
  if ($date1 != $date2) { # compares date part only

  $comp = $date1 &lt;=&gt; $date2; # compares date part only

  if ($date1 lt $date2) { # compares both date and time
  if ($date1 le $date2) { # compares both date and time
  if ($date1 gt $date2) { # compares both date and time
  if ($date1 ge $date2) { # compares both date and time
  if ($date1 eq $date2) { # compares both date and time
  if ($date1 ne $date2) { # compares both date and time

  $comp = $date1 cmp $date2; # compares both date and time
</pre>
<p class="Pp">Note that you can of course also compare two deltas, but not a
    date and a delta!</p>
<p class="Pp"></p>
<pre>
  ##################################################
  # Default TYPE for array refs in comparisons is: #
  # Same as other operand                          #
  ##################################################

  if ([2000,4,1] == $date) {
  if ($today &gt; [2000,4,1]) {

  if ($now ge [2000,3,26,2,0,0]) {

  if ($delta == [18,0,0]) {
  if ($delta == -1) {
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Plus:"><a class="permalink" href="#Plus:">Plus:</a></h2>
<pre>
  $date2 = $date1 + $delta;
  $date2 = $delta + $date1;
  $date += $delta;
  $this = $date++;
  $next = ++$date;

  $delta3 = $delta1 + $delta2;
  $delta1 += $delta2;
  $delta += $date; # beware of implicit type change!
  $delta++;
  ++$delta;

  #####################################################
  # Default TYPE for array refs in '+' operations is: #
  # Opposite of other operand                         #
  #####################################################

  $date2 = [2000,3,26] + $delta;
  $date2 = $date1 + [+1,0,0];
  $date2 = [0,0,-1] + $date1;
  $date2 = $date1 + 1;
  $date += [0,0,+1];
  $date += 2;

  $delta3 = [1,+1,0,-1] + $delta2;
  $delta3 = $delta1 + [1,0,0,+1];
  $delta3 = $delta1 + 1;
  $delta += [1,0,+1,0];
  $delta += [2000,3,26]; # beware of implicit type change!
  $delta += 7;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Unary_Minus:"><a class="permalink" href="#Unary_Minus:">Unary
  Minus:</a></h2>
<pre>
  $delta2 = -$delta1;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Minus:"><a class="permalink" href="#Minus:">Minus:</a></h2>
<pre>
  $delta = $date2 - $date1;
  $date2 = $date1 - $delta;
  $date -= $delta;
  $date2 -= $date1; # beware of implicit type change!
  $this = $date--;
  $prev = --$date;

  $delta3 = $delta2 - $delta1;
  $delta2 -= $delta1;
  $delta--;
  --$delta;

  #####################################################
  # Default TYPE for array refs in '-' operations is: #
  # Always a date                                     #
  #####################################################

  $delta = $today - [2000,3,26];
  $delta = [2000,4,1] - $date;
  $date2 = [2000,3,26] - $delta;
  $date2 = $date1 - [1,0,0,+7];
  $date2 = $date1 - 7;
  $date -= [1,0,0,+1]; # better add [0,0,-1] instead!
  $date2 -= [2000,3,26]; # beware of implicit type change!
  $date2 -= 1;

  $delta3 = [1,0,+1,0] - $delta1;
  $delta3 = $delta2 - [1,0,0,-1];
  $delta -= [1,0,0,+1];
  $delta -= 7;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Miscellaneous_Operators:"><a class="permalink" href="#Miscellaneous_Operators:">Miscellaneous
  Operators:</a></h2>
<pre>
  $string = &quot;$date&quot;;
  $string = &quot;$delta&quot;;

  print &quot;$date\n&quot;;
  print &quot;$delta\n&quot;;

  if ($date) { # date is valid
  if ($delta) { # delta is valid

  $days = abs($date);
  $diff = abs($delta); # can be negative!

  $diff = abs(abs($delta)); # always positive
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<ul class="Bl-bullet">
  <li>FLAG
    <p class="Pp">&quot;FLAG&quot; is either 0 (for &quot;false&quot;) or 1 (for
        &quot;true&quot;).</p>
    <p class="Pp">In the case of
        &quot;<span class="Li">&quot;accurate_mode()&quot;</span>&quot; and
        &quot;<span class="Li">&quot;normalized_mode()&quot;</span>&quot;, this
        switches the corresponding mode on and off (see further below for an
        explanation of what these are).</p>
    <p class="Pp">In the case of
        &quot;<span class="Li">&quot;today()&quot;</span>&quot;,
        &quot;<span class="Li">&quot;now()&quot;</span>&quot; and
        &quot;<span class="Li">&quot;today_and_now()&quot;</span>&quot;, a
        &quot;true&quot; value indicates &quot;GMT&quot; (Greenwich Mean Time),
        as opposed to local time, which is the default.</p>
  </li>
  <li>NUMBER
    <p class="Pp">&quot;NUMBER&quot; is a number between 0 and 2 (for
        &quot;<i>number_format()</i>&quot; and &quot;<i>number()</i>&quot;) or
        between 0 and 4 (for &quot;<i>delta_format()</i>&quot;,
        &quot;<i>date_format()</i>&quot; and &quot;<i>string()</i>&quot;),
        indicating which of the three/five predefined formats, respectively,
        should be used for converting a date into numeric representation (needed
        for comparing dates, for instance) or string representation.</p>
    <p class="Pp">Format #0 is the default at startup and the simplest of all
        (and should be fastest to calculate, too).</p>
    <p class="Pp">The string representation of dates in format #0 also has the
        advantage of being sortable in chronological order (and of complying
        with ISO&#x00A0;8601).</p>
    <p class="Pp">(The numeric formats are (trivially) always sortable in
        chronological order of course.)</p>
    <p class="Pp">The other formats are (mostly) increasingly more sophisticated
        (in terms of esthetics and computation time) with increasing number
        (except for format #4):</p>
    <p class="Pp"></p>
    <pre>
  Delta number formats (short):

      0    13603
      1    13603
      2    13603

  Delta string formats (short):

      0    '+0+0+13603'
      1    '+0 +0 +13603'
      2    '+0Y +0M +13603D'
      3    '+0 Y +0 M +13603 D'
      4    '(0,0,13603)'

  Date number formats (short):

      0    20010401
      1    730576
      2    730576

  Date string formats (short):

      0    '20010401'
      1    '01-Apr-2001'
      2    'Sun 1-Apr-2001'
      3    'Sunday, April 1st 2001'
      4    '[2001,4,1]'

  Delta number formats (long):

      0    13603.012959
      1    13603.012959
      2    13603.0624884259

  Delta string formats (long):

      0    '+0+0+13603+1+29+59'
      1    '+0 +0 +13603 +1 +29 +59'
      2    '+0Y +0M +13603D +1h +29m +59s'
      3    '+0 Y +0 M +13603 D +1 h +29 m +59 s'
      4    '(0,0,13603,1,29,59)'

  Date number formats (long):

      0    20010401.082959
      1    730576.082959
      2    730576.354155093

  Date string formats (long):

      0    '20010401082959'
      1    '01-Apr-2001 08:29:59'
      2    'Sun 1-Apr-2001 08:29:59'
      3    'Sunday, April 1st 2001 08:29:59'
      4    '[2001,4,1,8,29,59]'
    </pre>
    <p class="Pp">If a number outside of the permitted range is specified, or if
        the value is not a code reference (see also the next section below for
        more details), the default format #0 is used instead.</p>
  </li>
  <li>CODEREF
    <p class="Pp">&quot;CODEREF&quot; is the reference of a subroutine which can
        be passed to the methods &quot;<i>number_format()</i>&quot;,
        &quot;<i>delta_format()</i>&quot; and &quot;<i>date_format()</i>&quot;
        in order to install a callback function which will be called
        subsequently whenever a date (or delta) object needs to be (implicitly)
        converted into a number or string.</p>
    <p class="Pp">This happens for instance when you compare two date objects,
        or when you put a date object reference in a string between double
        quotes.</p>
    <p class="Pp">Such a &quot;CODEREF&quot; can also be passed to the methods
        &quot;<i>number()</i>&quot; and &quot;<i>string()</i>&quot; for
        explicitly converting a date object as desired.</p>
  </li>
  <li>LANGUAGE
    <p class="Pp">&quot;LANGUAGE&quot; is either a number in the range
        <span class="Li">&quot;[1..Languages()]&quot;</span>, or one of the
        strings
        &quot;<span class="Li">&quot;Language_to_Text(1..Languages())&quot;</span>&quot;
        (see also <i>Date::Calc</i>(3)).</p>
  </li>
  <li>TYPE
    <p class="Pp">&quot;TYPE&quot; is 0 for a regular date and 1 for a delta
        vector (a list of year, month, day and optionally hours, minutes and
        seconds offsets).</p>
  </li>
  <li>Storage
    <p class="Pp">&quot;Date::Calc&quot; objects are implemented as two nested
        arrays.</p>
    <p class="Pp">The &quot;blessed&quot; array (whose reference is the object
        reference you receive when calling the &quot;<i>new()</i>&quot; method)
        contains an anonymous array at position zero and the object's data in
        its remaining fields.</p>
    <p class="Pp">The embedded anonymous array is used for storing the object's
        attributes (flags).</p>
    <p class="Pp">Dates and delta vectors always comprise either 3 or 6 data
        values: Year, month, day plus (optionally) hours, minutes and
      seconds.</p>
    <p class="Pp">These values are stored in the &quot;blessed&quot; array at
        positions 1..3 or 1..6, respectively.</p>
    <p class="Pp">An object without the time values is therefore called
        &quot;short&quot;, and an object having time values is called
        &quot;long&quot; throughout this manual.</p>
    <p class="Pp">Hint: Whenever possible, if you do not need the time values,
        omit them, i.e., always use the &quot;short&quot; form of the object if
        possible, this will speed up calculations a little (the short form uses
        different (faster) functions for all calculations internally).</p>
    <p class="Pp">The embedded anonymous array contains various flags:</p>
    <p class="Pp">At position zero, it contains the &quot;TYPE&quot; indicator
        which determines whether the object is a date or a delta vector.</p>
    <p class="Pp">At position 1, the object stores the &quot;NUMBER&quot; of one
        of the delta vector formats, or the reference of a callback function
        which converts the contents of the object into string representation if
        it's a delta vector, or &quot;undef&quot; if the global settings
      apply.</p>
    <p class="Pp">At position 2, the object stores the &quot;NUMBER&quot; of one
        of the date formats, or the reference of a callback function which
        converts the contents of the object into string representation if it's a
        date, or &quot;undef&quot; if the global settings apply.</p>
    <p class="Pp">At position 3, the object stores the &quot;LANGUAGE&quot; to
        be used for all conversions into strings (where applicable), or
        &quot;undef&quot; if the global language setting applies.</p>
    <p class="Pp">Note that your callback functions (see the section
        &quot;Callback Functions&quot; further below for more details) should
        not pay attention to this value at position 3, because they get a
        parameter which tells them which language to use (this is necessary in
        order to allow temporary overrides).</p>
    <p class="Pp">If your callback handlers use the &quot;*_to_Text*&quot;
        functions (or any other language-dependent function) from the
        &quot;Date::Calc&quot; module, your handlers should pass on this
        language parameter to these functions (and not the value from position
        3).</p>
    <p class="Pp">Be reminded though that you should <b>NEVER</b> access the
        object's internal data directly, i.e., through their positional numbers,
        but <b>ALWAYS</b> through their respective accessor methods, e.g.:</p>
    <p class="Pp"></p>
    <pre>
        year()
        month()
        day()
        hours()
        minutes()
        seconds()
        date()
        time()
        datetime()
        is_delta()
        is_date()
        is_short()
        is_long()
        delta_format()
        date_format()
        language()
    </pre>
    <p class="Pp">And although position 4 and onward in the embedded anonymous
        array is currently unused, it might not stay so in future releases of
        this module.</p>
    <p class="Pp">Therefore, in case you need more attributes in a subclass of
        the &quot;Date::Calc[::Object]&quot; class, I suggest using values
        starting at positions a bit further up, e.g. 6, 8 or 10.</p>
  </li>
  <li>Invalid Dates
    <p class="Pp">Only &quot;<i>new()</i>&quot; allows to create objects
        containing possibly invalid dates (needed for reading in and evaluating
        user input, for example).</p>
  </li>
  <li>Usage
    <p class="Pp">The methods</p>
    <p class="Pp"></p>
    <pre>
        accurate_mode()
        normalized_mode()
        number_format()
        delta_format()
        date_format()
        language()
        date()
        time()
        datetime()
        year()
        month()
        day()
        hours()
        minutes()
        seconds()
    </pre>
    <p class="Pp">are used for reading as well as for setting attributes. They
        simply return the values in question if they are called without
        parameters.</p>
    <p class="Pp">The methods</p>
    <p class="Pp"></p>
    <pre>
        accurate_mode()
        normalized_mode()
        number_format()
        delta_format()
        date_format()
        language()
    </pre>
    <p class="Pp">always return the previous value if a new value is set. This
        allows you to change these values temporarily and to restore their old
        value afterwards more easily (but you can also override the
        &quot;format&quot; and &quot;language&quot; settings directly when
        calling the &quot;<i>number()</i>&quot; or &quot;<i>string()</i>&quot;
        method).</p>
    <p class="Pp">The methods</p>
    <p class="Pp"></p>
    <pre>
        date()
        time()
        datetime()
        year()
        month()
        day()
        hours()
        minutes()
        seconds()
    </pre>
    <p class="Pp">always return the new values when the corresponding values
        have been changed.</p>
    <p class="Pp">The method &quot;<i>date()</i>&quot; NEVER returns the time
        values (hours, minutes, seconds) even if they have just been set using
        this method (which the method optionally allows). Otherwise it would be
        very hard to predict the exact number of values it returns, which might
        lead to errors (wrong number of parameters) elsewhere in your
      program.</p>
    <p class="Pp">The method &quot;<i>datetime()</i>&quot; ALWAYS returns the
        time values (hours, minutes, seconds) even if the object in question
        lacks a time part. In that case, zeros are returned for hours, minutes
        and seconds instead (but the stored time part is left unchanged, whether
        it exists or not).</p>
    <p class="Pp">If you do not provide values for hours, minutes and seconds
        when using the method &quot;<i>date()</i>&quot; to set the values for
        year, month and day, the time part will not be changed (whether it
        exists or not).</p>
    <p class="Pp">If you do not provide values for hours, minutes and seconds
        when using the method &quot;<i>datetime()</i>&quot; to set the values
        for year, month and day, the time part will be filled with zeros (the
        time part will be created if necessary).</p>
    <p class="Pp">If the object is short, i.e., if it does not have any time
        values, the method &quot;<i>time()</i>&quot; returns an empty list.</p>
    <p class="Pp">If the object is short and the methods
        &quot;<i>hours()</i>&quot;, &quot;<i>minutes()</i>&quot; or
        &quot;<i>seconds()</i>&quot; are used to set any of these time values,
        the object is automatically promoted to the &quot;long&quot; form, and
        the other two time values are filled with zeros.</p>
    <p class="Pp">The following methods can also return &quot;undef&quot; under
        certain circumstances:</p>
    <p class="Pp"></p>
    <pre>
        delta_format()
        date_format()
        language()
        is_delta()
        is_date()
        is_short()
        is_long()
        is_valid()
        hours()
        minutes()
        seconds()
        number()
        string()
    </pre>
    <p class="Pp">The methods &quot;<i>delta_format()</i>&quot;,
        &quot;<i>date_format()</i>&quot; and &quot;<i>language()</i>&quot;
        return &quot;undef&quot; when they are called as object methods and no
        individual override has been defined for the object in question.</p>
    <p class="Pp">The &quot;is_*()&quot; predicate methods return
        &quot;undef&quot; if the object in question does not have the expected
        internal structure. This can happen for instance when you create an
        empty object with &quot;<i>new()</i>&quot;.</p>
    <p class="Pp">When called without parameters, the methods
        &quot;<i>hours()</i>&quot;, &quot;<i>minutes()</i>&quot; and
        &quot;<i>seconds()</i>&quot; return &quot;undef&quot; if the object in
        question does not have a time part.</p>
    <p class="Pp">The methods &quot;<i>number()</i>&quot; and
        &quot;<i>string()</i>&quot; return &quot;undef&quot; if the object in
        question is not valid (i.e., if &quot;<i>is_valid()</i>&quot; returns
        &quot;undef&quot; or false).</p>
    <p class="Pp">And finally, the methods</p>
    <p class="Pp"></p>
    <pre>
        copy()
        today()
        now()
        today_and_now()
        gmtime()
        localtime()
        tzoffset()
        time2date()
        normalize()
    </pre>
    <p class="Pp">return the object reference of the (target) object in question
        for convenience.</p>
  </li>
  <li>Import/Export
    <p class="Pp">Note that you can import and export Unix &quot;time&quot;
        values using the methods &quot;<i>gmtime()</i>&quot;,
        &quot;<i>localtime()</i>&quot;, &quot;<i>mktime()</i>&quot;,
        &quot;<i>date2time()</i>&quot; and &quot;<i>time2date()</i>&quot;, both
        as local time or as UTC/GMT.</p>
  </li>
  <li>Accurate Mode and Normalized Mode
    <p class="Pp">The method &quot;<i>accurate_mode()</i>&quot; controls the
        internal flag which determines which of two fundamental modes of
        operation is used.</p>
    <p class="Pp">When set to true (the default at startup), delta vectors are
        calculated to give the exact difference in days between two dates. The
        &quot;year&quot; and &quot;month&quot; entries in the resulting delta
        vector are always zero in that case.</p>
    <p class="Pp">If &quot;accurate mode&quot; is switched off (when the
        corresponding flag is set to false), delta vectors are calculated with
        year and month differences.</p>
    <p class="Pp">E.g., the difference between
        <span class="Li">&quot;[1999,12,6]&quot;</span> and
        <span class="Li">&quot;[2000,6,24]&quot;</span> is
        <span class="Li">&quot;[+0 +0 +201]&quot;</span> (plus 201 days) in
        accurate mode and <span class="Li">&quot;[+1 -6 +18]&quot;</span> (plus
        one year, minus 6 months, plus 18 days) when accurate mode is switched
        off, and is <span class="Li">&quot;[+0 +6 +18]&quot;</span> (plus 6
        months, plus 18 days) if additionally, &quot;normalized mode&quot; is
        switched on.</p>
    <p class="Pp">The delta vector is calculated by simply taking the difference
        in years, the difference in months and the difference in days (if
        &quot;accurate mode&quot; is switched off and if &quot;normalized
        mode&quot; has not been switched on). This is called
        &quot;one-by-one&quot; semantics or &quot;year-month-day mode&quot;;
        &quot;YMD mode&quot; for short.</p>
    <p class="Pp">When &quot;normalized mode&quot; is switched on (while
        &quot;accurate mode&quot; is switched off), the delta vector is
        calculated in a more complex way involving the functions
        &quot;<span class="Li">&quot;Add_Delta_YM()&quot;</span>&quot; (for
        &quot;truncation&quot;) and
        &quot;<span class="Li">&quot;Delta_Days()&quot;</span>&quot;.</p>
    <p class="Pp">Moreover, the result is normalized, i.e., the return values
        are guaranteed to all have the same sign (or to be zero), and to all be
        &quot;minimal&quot;, i.e., not to exceed the ranges
        <span class="Li">&quot;[-11..+11]&quot;</span> for months,
        <span class="Li">&quot;[-30..+30]&quot;</span> for days,
        <span class="Li">&quot;[-23..+23]&quot;</span> for hours and
        <span class="Li">&quot;[-59..+59]&quot;</span> for minutes and
      seconds.</p>
    <p class="Pp">The rule is to add these result values to a date in a
        left-to-right order, and to truncate invalid intermediate dates, such as
        e.g. <span class="Li">&quot;[2009,2,29]&quot;</span>, to the last valid
        day of that same month, e.g.
        <span class="Li">&quot;[2009,2,28]&quot;</span>. This is called
        &quot;left-to-right with truncation&quot; semantics or &quot;normalized
        mode&quot;; &quot;N_YMD mode&quot; for short.</p>
    <p class="Pp">The method &quot;<i>normalized_mode()</i>&quot; controls the
        internal flag which determines whether &quot;YMD mode&quot; is used (the
        default at startup, for reasons of backward compatibility) or
        &quot;N_YMD mode&quot;.</p>
    <p class="Pp">Note that also for reasons of backward compatibility, this
        flag only has effect when &quot;accurate mode&quot; is switched off.</p>
    <p class="Pp">Both flags can be set and reset independently from each other,
        however.</p>
    <p class="Pp">Therefore, at startup, you can for instance switch
        &quot;normalized mode&quot; on, without having any immediate effect, and
        switch off &quot;accurate mode&quot; later, which instantly also causes
        &quot;normalized mode&quot; to spring into effect.</p>
    <p class="Pp">Because years and months have varying lengths in terms of
        days, the &quot;YMD&quot; and &quot;N_YMD&quot; modes are less accurate
        than &quot;accurate mode&quot;, because these modes depend on the
        context of the two dates of which the delta vector is the difference.
        Added to a different date, a delta vector calculated in &quot;YMD
        mode&quot; or &quot;N_YMD mode&quot; may yield a different offset in
        terms of days, i.e., the final result may sometimes vary seemingly
        unpredictably (or in other situations may give you the expected result,
        at the expense of actually representing a varying difference in days,
        determined exclusively by context).</p>
    <p class="Pp">Beware also that - for the same reason - the absolute value
        (&quot;<span class="Li">&quot;abs()&quot;</span>&quot;) of a delta
        vector returns a fictitious number of days if the delta vector contains
        non-zero values for &quot;year&quot; and/or &quot;month&quot; (see also
        the next section &quot;Absolute Value&quot; below for more details).</p>
    <p class="Pp">Example:</p>
    <p class="Pp">The difference between
        <span class="Li">&quot;[2000,1,1]&quot;</span> and
        <span class="Li">&quot;[2000,3,1]&quot;</span> is
        <span class="Li">&quot;[+0 +0 +60]&quot;</span> in &quot;accurate
        mode&quot; and <span class="Li">&quot;[+0 +2 +0]&quot;</span> in
        &quot;YMD mode&quot; (in this &quot;benign&quot; example, the result is
        the same in &quot;YMD mode&quot; and in &quot;N_YMD mode&quot;).</p>
    <p class="Pp">When added to the date
        <span class="Li">&quot;[2000,4,1]&quot;</span>, the &quot;accurate&quot;
        delta vector yields the date
        <span class="Li">&quot;[2000,5,31]&quot;</span>, whereas the &quot;YMD
        mode&quot; delta vector yields the date
        <span class="Li">&quot;[2000,6,1]&quot;</span> (which is actually a
        difference of 61 days).</p>
    <p class="Pp">Moreover, when added to the date
        <span class="Li">&quot;[1999,1,1]&quot;</span>, the &quot;accurate&quot;
        delta vector yields the date
        <span class="Li">&quot;[1999,3,2]&quot;</span>, whereas the
        &quot;inaccurate&quot; &quot;YMD Mode&quot; delta vector yields the date
        <span class="Li">&quot;[1999,3,1]&quot;</span> (which is actually a
        difference of 59 days).</p>
    <p class="Pp">Depending on what you want, either mode may suit you
      better.</p>
  </li>
  <li>Absolute Value
    <p class="Pp">Note that
        &quot;<span class="Li">&quot;abs($date)&quot;</span>&quot; and
        &quot;<span class="Li">&quot;abs($delta)&quot;</span>&quot; are just
        shorthands for
        &quot;<span class="Li">&quot;$date-&gt;number()&quot;</span>&quot; and
        &quot;<span class="Li">&quot;$delta-&gt;number()&quot;</span>&quot;.</p>
    <p class="Pp">The operator
        &quot;<span class="Li">&quot;abs()&quot;</span>&quot;, when applied to a
        date or delta vector, returns the corresponding number of days (see
        below for an exception to this), with the time part (if available)
        represented by a fraction after the decimal point.</p>
    <p class="Pp">In the case of dates, the absolute value (to the left of the
        decimal point) is the number of days since the 1st of January
        1&#x00A0;A.D. (by extrapolating the Gregorian calendar back beyond its
        &quot;natural&quot; limit of 1582 A.D.) <b>PLUS ONE</b>.</p>
    <p class="Pp">(I.e., the absolute value of the 1st of January 1 A.D. is
      1.)</p>
    <p class="Pp">Exception:</p>
    <p class="Pp">If the &quot;NUMBER&quot; or
        &quot;<i>number_format()</i>&quot; is set to 0 (the default setting),
        the absolute value of a date to the left of the decimal point is
        &quot;yyyymmdd&quot;, i.e., the number in which the uppermost four
        digits correspond to the year, the next lower two digits to the month
        and the lowermost two digits to the day.</p>
    <p class="Pp">In the case of delta vectors, the absolute value (to the left
        of the decimal point) is simply the difference in days (but see also
        below).</p>
    <p class="Pp">Note that the absolute value of a delta vector can be
        negative!</p>
    <p class="Pp">If you want a positive value in all cases, apply the
        &quot;<span class="Li">&quot;abs()&quot;</span>&quot; operator again,
        i.e., &quot;<span class="Li">&quot;$posdiff =
        abs(abs($delta));&quot;</span>&quot;.</p>
    <p class="Pp">If the delta vector contains non-zero values for
        &quot;year&quot; and/or &quot;month&quot; (see also the discussion of
        &quot;Accurate Mode&quot; in the section above), an exact representation
        in days cannot be calculated, because years and months do not have fixed
        equivalents in days.</p>
    <p class="Pp">If nevertheless you attempt to calculate the absolute value of
        such a delta vector, a fictitious value is returned, which is calculated
        by simply multiplying the year difference with 12, adding the month
        difference, multiplying this sum with 31 and finally adding the day
        difference.</p>
    <p class="Pp">Beware that because of this, the absolute values of delta
        vectors are not necessarily contiguous.</p>
    <p class="Pp">Moreover, since there is more than one way to express the
        difference between two dates, comparisons of delta vectors may not
        always yield the expected result.</p>
    <p class="Pp">Example:</p>
    <p class="Pp">The difference between the two dates
        <span class="Li">&quot;[2000,4,30]&quot;</span> and
        <span class="Li">&quot;[2001,5,1]&quot;</span> can be expressed as
        <span class="Li">&quot;[+1 +1 -29]&quot;</span>, or as
        <span class="Li">&quot;[+1 +0 +1]&quot;</span>.</p>
    <p class="Pp">The first delta vector has an absolute value of 374, whereas
        the latter delta vector has an absolute value of only 373 (while the
        true difference in days between the two dates is 366).</p>
    <p class="Pp">If the date or delta vector has a time part, the time is
        returned as a fraction of a full day after the decimal point as
      follows:</p>
    <p class="Pp">If the &quot;NUMBER&quot; or
        &quot;<i>number_format()</i>&quot; is set to 0 (the default setting) or
        1, this fraction is simply &quot;.hhmmss&quot;, i.e., the two digits
        after the decimal point represent the hours, the next two digits the
        minutes and the last two digits the seconds.</p>
    <p class="Pp">Note that you cannot simply add and subtract these values to
        yield meaningful dates or deltas again, you can only use them for
        comparisons (equal, not equal, less than, greater than, etc.). If you
        want to add/subtract, read on:</p>
    <p class="Pp">Only when the &quot;NUMBER&quot; or
        &quot;<i>number_format()</i>&quot; is set to 2, this fraction will be
        the equivalent number of seconds (i.e., <span class="Li">&quot;(((hours
        * 60) + minutes) * 60) + seconds&quot;</span>) divided by the number of
        seconds in a full day (i.e., <span class="Li">&quot;24*60*60 =
        86400&quot;</span>), or <span class="Li">&quot;0/86400&quot;</span>,
        <span class="Li">&quot;1/86400&quot;</span>, ... ,
        <span class="Li">&quot;86399/86400&quot;</span>.</p>
    <p class="Pp">In other words, the (mathematically correct) fraction of a
        day.</p>
    <p class="Pp">You can safely perform arithmetics with these values as far as
        the internal precision of your vendor's implementation of the C run-time
        library (on which Perl depends) will permit.</p>
  </li>
  <li>Renormalizing Delta Vectors
    <p class="Pp">When adding or subtracting delta vectors to/from one another,
        the addition or subtraction takes place component by component.</p>
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>
  [+0 +0 +0 +3 +29 +50] + [+0 +0 +0 +0 +55 +5] = [+0 +0 +0 +3 +84 +55]
  [+0 +0 +0 +3 +29 +50] - [+0 +0 +0 +0 +55 +5] = [+0 +0 +0 +3 -26 +45]
    </pre>
    <p class="Pp">This may result in time values outside the usual ranges
        (<span class="Li">&quot;[-23..+23]&quot;</span> for hours and
        <span class="Li">&quot;[-59..+59]&quot;</span> for minutes and
      seconds).</p>
    <p class="Pp">Note that even though the delta value for days will often
        become quite large, it is impossible to renormalize this value because
        there is no constant conversion factor from days to months (should it be
        28, 29, 30 or 31?).</p>
    <p class="Pp">If accurate mode (see further above for what that is) is
        switched off, delta vectors can also contain non-zero values for years
        and months. If you add or subtract these, the value for months can lie
        outside the range <span class="Li">&quot;[-11..11]&quot;</span>, which
        isn't wrong, but may seem funny.</p>
    <p class="Pp">Therefore, the &quot;<i>normalize()</i>&quot; method will also
        renormalize the &quot;months&quot; value, if and only if accurate mode
        has been switched off. (!)</p>
    <p class="Pp">(Hence, switch accurate mode <b>ON</b> temporarily if you
        <b>DON'T</b> want the renormalization of the &quot;months&quot; value to
        happen.)</p>
    <p class="Pp">If you want to force the time values from the example above
        back into their proper ranges, use the &quot;<i>normalize()</i>&quot;
        method as follows:</p>
    <p class="Pp"></p>
    <pre>
  print &quot;[$delta]\n&quot;;
  $delta-&gt;normalize();
  print &quot;[$delta]\n&quot;;
    </pre>
    <p class="Pp">This will print</p>
    <p class="Pp"></p>
    <pre>
  [+0 +0 +0 +3 +84 +55]
  [+0 +0 +0 +4 +24 +55]
    </pre>
    <p class="Pp">for the first and</p>
    <p class="Pp"></p>
    <pre>
  [+0 +0 +0 +3 -26 +45]
  [+0 +0 +0 +2 +34 +45]
    </pre>
    <p class="Pp">for the second delta vector from the example further
      above.</p>
    <p class="Pp">Note that the values for days, hours, minutes and seconds are
        guaranteed to have the same sign after the renormalization.</p>
    <p class="Pp">Under &quot;normal&quot; circumstances, i.e., when accurate
        mode is on (the default), this method only has an effect on the time
        part of the delta vector.</p>
    <p class="Pp">If the delta vector in question does not have a time part,
        nothing happens.</p>
    <p class="Pp">If accurate mode is off, the &quot;months&quot; value is also
        normalized, i.e., if it lies outside of the range
        <span class="Li">&quot;[-11..11]&quot;</span>, integer multiples of 12
        are added to the &quot;years&quot; value and subtracted from the
        &quot;months&quot; value. Moreover, the &quot;months&quot; value is
        guaranteed to have the same sign as the values for days, hours, minutes
        and seconds, unless the &quot;months&quot; value is zero or the values
        for days, hours, minutes and seconds are all zero.</p>
    <p class="Pp">If the object in question is a date and if warnings are
        enabled, the message &quot;normalizing a date is a no-op&quot; will be
        printed to STDERR.</p>
    <p class="Pp">If the object in question is not a valid
        &quot;Date::Calc&quot; object, nothing happens.</p>
    <p class="Pp">The method returns its object's reference, which allows
        chaining of method calls, as in the following example:</p>
    <p class="Pp"></p>
    <pre>
  @time = $delta-&gt;normalize()-&gt;time();
    </pre>
  </li>
  <li>Callback Functions
    <p class="Pp">Note that you are not restricted to the built-in formats
        (numbered from 0 to 2 for &quot;<i>number_format()</i>&quot; and
        &quot;<i>number()</i>&quot; and from 0 to 4 for
        &quot;<i>delta_format()</i>&quot;, &quot;<i>date_format()</i>&quot; and
        &quot;<i>string()</i>&quot;) for converting a date or delta object into
        a number or string.</p>
    <p class="Pp">You can also provide your own function(s) for doing so, in
        order to suit your own taste or needs, by passing a subroutine reference
        to the appropriate method, i.e., &quot;<i>number_format()</i>&quot;,
        &quot;<i>number()</i>&quot;, &quot;<i>delta_format()</i>&quot;,
        &quot;<i>date_format()</i>&quot; and &quot;<i>string()</i>&quot;.</p>
    <p class="Pp">You can pass a handler to only one or more of these methods,
        or to all of them, as you like. You can use different callback
        functions, or the same for all.</p>
    <p class="Pp">In order to facilitate the latter, and in order to make the
        decoding of the various cases easier for you, the callback function
        receives a uniquely identifying function code as its second
      parameter:</p>
    <p class="Pp"></p>
    <pre>
  0  =  TO_NUMBER | IS_DATE  | IS_SHORT  (number[_format])
  1  =  TO_NUMBER | IS_DATE  | IS_LONG   (number[_format])
  2  =  TO_NUMBER | IS_DELTA | IS_SHORT  (number[_format])
  3  =  TO_NUMBER | IS_DELTA | IS_LONG   (number[_format])
  4  =  TO_STRING | IS_DATE  | IS_SHORT  (string|date_format)
  5  =  TO_STRING | IS_DATE  | IS_LONG   (string|date_format)
  6  =  TO_STRING | IS_DELTA | IS_SHORT  (string|delta_format)
  7  =  TO_STRING | IS_DELTA | IS_LONG   (string|delta_format)
    </pre>
    <p class="Pp">The first parameter of the callback function is of course the
        reference of the object in question itself (therefore, the callback
        function can actually be an object method - but not a class method, for
        obvious reasons).</p>
    <p class="Pp">The third parameter is the number of the language (in the
        range <span class="Li">&quot;[1..Languages()]&quot;</span>) which you
        should always pass along when using any of the following functions from
        the &quot;Date::Calc&quot; module in your handler:</p>
    <p class="Pp">&quot;<i>Decode_Month()</i>&quot;,
        &quot;<i>Decode_Day_of_Week()</i>&quot;,
        &quot;<i>Compressed_to_Text()</i>&quot;,
        &quot;<i>Date_to_Text()</i>&quot;,
        &quot;<i>Date_to_Text_Long()</i>&quot;, &quot;<i>Calendar()</i>&quot;,
        &quot;<i>Month_to_Text()</i>&quot;,
        &quot;<i>Day_of_Week_to_Text()</i>&quot;,
        &quot;<i>Day_of_Week_Abbreviation()</i>&quot;,
        &quot;<i>Decode_Date_EU()</i>&quot;,
        &quot;<i>Decode_Date_US()</i>&quot;,
        &quot;<i>Decode_Date_EU2()</i>&quot;,
        &quot;<i>Decode_Date_US2()</i>&quot;,
      &quot;<i>Parse_Date()</i>&quot;.</p>
    <p class="Pp">The callback handler should return the resulting number or
        string, as requested.</p>
    <p class="Pp">BEWARE that you should NEVER rely upon any knowledge of the
        object's internal structure, as this may be subject to change!</p>
    <p class="Pp">ALWAYS use the test and access methods provided by this
        module!</p>
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>
  sub handler
  {
      my($self,$code,$lang) = @_;

      if    ($code == 0) # TO_NUMBER | IS_DATE  | IS_SHORT
      {
          return Date_to_Days( $self-&gt;date() );
      }
      elsif ($code == 1) # TO_NUMBER | IS_DATE  | IS_LONG
      {
          return Date_to_Days( $self-&gt;date() ) +
                           ( ( $self-&gt;hours() * 60 +
                               $self-&gt;minutes() ) * 60 +
                               $self-&gt;seconds() ) / 86400;
      }
      elsif ($code == 2) # TO_NUMBER | IS_DELTA | IS_SHORT
      {
          return ( $self-&gt;year() * 12 +
                   $self-&gt;month() ) * 31 +
                   $self-&gt;day();
      }
      elsif ($code == 3) # TO_NUMBER | IS_DELTA | IS_LONG
      {
          return ( $self-&gt;year() * 12 +
                   $self-&gt;month() ) * 31 +
                   $self-&gt;day() +
               ( ( $self-&gt;hours() * 60 +
                   $self-&gt;minutes() ) * 60 +
                   $self-&gt;seconds() ) / 86400;
      }
      elsif ($code == 4) # TO_STRING | IS_DATE  | IS_SHORT
      {
          return join( &quot;/&quot;, $self-&gt;date() );
      }
      elsif ($code == 5) # TO_STRING | IS_DATE  | IS_LONG
      {
          return join( &quot;/&quot;, $self-&gt;date() ) . &quot; &quot; .
                 join( &quot;:&quot;, $self-&gt;time() );
      }
      elsif ($code == 6) # TO_STRING | IS_DELTA | IS_SHORT
      {
          return join( &quot;|&quot;, $self-&gt;date() );
      }
      elsif ($code == 7) # TO_STRING | IS_DELTA | IS_LONG
      {
          return join( &quot;|&quot;, $self-&gt;datetime() );
      }
      else
      {
          die &quot;internal error&quot;;
      }
  }

  Date::Calc-&gt;number_format(\&amp;handler);
  Date::Calc-&gt;delta_format(\&amp;handler);
  Date::Calc-&gt;date_format(\&amp;handler);
    </pre>
    <p class="Pp">This sets our handler to take care of all automatic
        conversions, such as needed when comparing dates or when interpolating a
        string in double quotes which contains a date object.</p>
    <p class="Pp">To deactivate a handler, simply pass a valid format number to
        the method in question, e.g.:</p>
    <p class="Pp"></p>
    <pre>
  Date::Calc-&gt;number_format(0);
  Date::Calc-&gt;delta_format(2);
  Date::Calc-&gt;date_format(3);
    </pre>
    <p class="Pp">When calling the &quot;<i>number()</i>&quot; or
        &quot;<i>string()</i>&quot; method explicitly, you can pass a different
        format number (than the global setting), like this:</p>
    <p class="Pp"></p>
    <pre>
  $number = $date-&gt;number(2);
  $string = $date-&gt;string(1);
    </pre>
    <p class="Pp">You can also pass a handler's reference, like so:</p>
    <p class="Pp"></p>
    <pre>
  $number = $date-&gt;number(\&amp;handler);
  $string = $date-&gt;string(\&amp;handler);
    </pre>
    <p class="Pp">This overrides the global setting and the individual object's
        local setting for the duration of the call of
        &quot;<i>number()</i>&quot; or &quot;<i>string()</i>&quot; (but doesn't
        change the global or local settings themselves).</p>
    <p class="Pp">Moreover, you can also define individual overrides for the
        date and the delta vector formats (but not the number format) for
        individual objects, e.g.:</p>
    <p class="Pp"></p>
    <pre>
  $date-&gt;delta_format(1);
  $date-&gt;date_format(2);

  $date-&gt;delta_format(\&amp;handler);
  $date-&gt;date_format(\&amp;handler);
    </pre>
    <p class="Pp">In order to deactivate an individual handler for an object,
        and/or in order to deactivate any override altogether (so that the
        global settings apply again), you have to pass &quot;undef&quot;
        explicitly to the method in question:</p>
    <p class="Pp"></p>
    <pre>
  $date-&gt;delta_format(undef);
  $date-&gt;date_format(undef);
    </pre>
    <p class="Pp">You can also define a language for individual objects (see the
        next section immediately below for more details).</p>
    <p class="Pp">If such an individual language override has been set, it will
        be passed to your callback handlers as the third parameter (in the case
        of &quot;string&quot; conversions, but not in the case of
        &quot;number&quot; conversions).</p>
    <p class="Pp">Otherwise, the global settings as defined by
        <span class="Li">&quot;Language($lang);&quot;</span> or
        <span class="Li">&quot;Date::Calc-&quot;</span>language($lang);&gt; will
        be passed to your handler.</p>
  </li>
  <li>Languages
    <p class="Pp">Note that this module is completely transparent to the setting
        of a language in &quot;Date::Calc&quot;. This means that you can choose
        a language in &quot;Date::Calc&quot; (with the
        &quot;<i>Language()</i>&quot; function) and all dates subsequently
        printed by this module will automatically be in that language - provided
        that you use the built-in formats of this module, or that you pass the
        third parameter of the callback funtion to the funtions of the
        &quot;Date::Calc&quot; module which accept it.</p>
    <p class="Pp">However, this global language setting can be overridden for
        individual date (or delta) objects by using the <b>OBJECT</b> method</p>
    <p class="Pp"></p>
    <pre>
    $oldlang = $date-&gt;language($newlang);
    </pre>
    <p class="Pp">(The global setting is not altered by this in any way.)</p>
    <p class="Pp">In order to deactivate such an individual language setting (so
        that the global setting applies again), simply pass the value
        &quot;undef&quot; explicitly to the &quot;<i>language()</i>&quot; object
        method:</p>
    <p class="Pp"></p>
    <pre>
  $date-&gt;language(undef);
    </pre>
    <p class="Pp">The <b>CLASS</b> method</p>
    <p class="Pp"></p>
    <pre>
    $oldlang = Date::Calc-&gt;language($newlang);
    </pre>
    <p class="Pp">is just a convenient wrapper around the
        &quot;<i>Language()</i>&quot; function, which allows you to enter
        language numbers (as returned by the
        &quot;<i>Decode_Language()</i>&quot; function) or strings (as returned
        by the &quot;<i>Language_to_Text()</i>&quot; function), whatever you
        prefer.</p>
    <p class="Pp">The &quot;<i>language()</i>&quot; method (both class and
        object) always returns the <b>NAME</b> (one of
        &quot;<span class="Li">&quot;Language_to_Text(1..Languages())&quot;</span>&quot;)
        of the current setting (and never its number).</p>
    <p class="Pp">BEWARE that in order to avoid possible conflicts between
        threads or modules running concurrently, you should NEVER use the global
        function <span class="Li">&quot;Language($lang);&quot;</span> or the
        class method
        <span class="Li">&quot;Date::Calc-&quot;</span>language($lang);&gt; in
        this module!</p>
    <p class="Pp">The class method is retained only for backward compatibility
        and for convenience in stand-alone applications when it is guaranteed
        that no such conflicts can arise.</p>
    <p class="Pp">But you should probably avoid to use global settings anyway,
        because it may be especially troublesome to fix your code later when
        suddenly the need arises to use your code with threads or when your code
        needs to use other modules which also use &quot;Date::Calc&quot; (with
        different settings!).</p>
    <p class="Pp">By exclusively using local settings, you are making your code
        invulnerable against other, concurrent modules also using
        &quot;Date::Calc&quot; which still use global settings.</p>
  </li>
  <li>Exported Functions
    <p class="Pp">The &quot;Date::Calc::Object&quot; package imports
        &quot;:all&quot; functions exported by the &quot;Date::Calc&quot; module
        and re-exports them, for conveniency.</p>
    <p class="Pp">This allows you to write</p>
    <p class="Pp"></p>
    <pre>
  use Date::Calc::Object qw(...);
    </pre>
    <p class="Pp">instead of</p>
    <p class="Pp"></p>
    <pre>
  use Date::Calc qw(...);
    </pre>
    <p class="Pp">but with exactly the same semantics. The difference is that
        the object-oriented frontend is loaded additionally in the first
      case.</p>
    <p class="Pp">As with &quot;Date::Calc&quot; you can use the
        &quot;:all&quot; tag to import all of &quot;Date::Calc&quot;'s
        functions:</p>
    <p class="Pp"></p>
    <pre>
  use Date::Calc::Object qw(:all);
    </pre>
    <p class="Pp">In addition to the functions exported by
        &quot;Date::Calc&quot;, the &quot;Date::Calc::Object&quot; package
        offers some utility functions of its own for export:</p>
    <p class="Pp"></p>
    <pre>
    $year                          = shift_year(\@_);
    ($year,$mm,$dd)                = shift_date(\@_);
    ($hrs,$min,$sec)               = shift_time(\@_);
    ($year,$mm,$dd,$hrs,$min,$sec) = shift_datetime(\@_);
    </pre>
    <p class="Pp">These functions enable your subroutines or methods to accept a
        &quot;Date::Calc&quot; (or subclass) date object, an (anonymous) array
        or a list (containing the necessary values) as parameters
        <b>INTERCHANGEABLY</b>.</p>
    <p class="Pp">You can import all of these auxiliary functions by using an
        &quot;:aux&quot; tag:</p>
    <p class="Pp"></p>
    <pre>
  use Date::Calc::Object qw(:aux);
    </pre>
    <p class="Pp">If you want to import both all of the &quot;Date::Calc&quot;
        functions as well as all these auxiliary functions, use the
        &quot;:ALL&quot; tag:</p>
    <p class="Pp"></p>
    <pre>
  use Date::Calc::Object qw(:ALL);
    </pre>
  </li>
  <li>Subclassing
    <p class="Pp">In case you want to subclass &quot;Date::Calc&quot; objects
        and to add new attributes of your own, it is recommended that you
        proceed as follows (the following will be considered as a part of the
        module's &quot;contract of use&quot; - which might be subject to change
        in the future, however):</p>
    <p class="Pp">Define a constant for the index of each attribute you want to
        add, currently starting no lower than &quot;4&quot;, at the top of your
        subclass:</p>
    <p class="Pp"></p>
    <pre>
    use constant ATTRIB1 =&gt; 4;
    use constant ATTRIB2 =&gt; 5;
    use constant ATTRIB3 =&gt; 6;
    ...
    </pre>
    <p class="Pp">It is recommended that you use constants (which are easy to
        change), because I someday might want to require the element with index
        &quot;4&quot; for a new attribute of my own...
        <span class="Li">&quot;:-)&quot;</span></p>
    <p class="Pp">Then access your attributes like so (e.g. after calling
        &quot;<span class="Li">&quot;$self = SUPER-&gt;new();&quot;</span>&quot;
        in your constructor method):</p>
    <p class="Pp"></p>
    <pre>
    $self-&gt;[0][ATTRIB1] = 'value1';
    $self-&gt;[0][ATTRIB2] = 'value2';
    $self-&gt;[0][ATTRIB3] = 'value3';
    ...
    </pre>
    <p class="Pp">Beware that if you put anything other than numbers or strings
        into your attributes, the methods &quot;<i>clone()</i>&quot; and
        &quot;<i>copy()</i>&quot; might not work as expected anymore!</p>
    <p class="Pp">Especially if your attributes contain references to other data
        structures, only the references will be copied, but not the data
        structures themselves.</p>
    <p class="Pp">This may not be what you want.</p>
    <p class="Pp">(You will have to override these two methods and write some of
        your own if not.)</p>
    <p class="Pp">In order for the overloaded operators and the
        &quot;shift_*()&quot; auxiliary functions from the
        &quot;Date::Calc::Object&quot; package to work properly (the latter of
        which are heavily used in the &quot;Date::Calendar[::Year]&quot;
        modules, for instance), the package name of your subclass (= the one
        your objects will be blessed into) is <b>REQUIRED</b> to contain a
        &quot;::&quot;.</p>
    <p class="Pp">Note that you should <b>ONLY</b> subclass
        &quot;Date::Calc&quot;, <b>NEVER</b> &quot;Date::Calc::Object&quot;,
        since subclassing the latter is less efficient (because
        &quot;Date::Calc::Object&quot; is just an empty class which inherits
        from &quot;Date::Calc&quot; - subclassing &quot;Date::Calc::Object&quot;
        would thus just introduce an additional name space layer to search
        during Perl's runtime method binding process).</p>
    <p class="Pp">If you give your subclass a package name below/inside the
        &quot;Date::&quot; namespace, you will also benefit from the fact that
        all error messages produced by the &quot;Date::Calc[::Object]&quot;
        module (and also the &quot;Date::Calendar[::Year]&quot; modules, by the
        way) will appear to have originated from the place outside of all
        &quot;<span class="Li">&quot;/^Date::/&quot;</span>&quot; modules
        (including yours) where one of the &quot;Date::&quot; modules was first
        called - i.e., all errors are always blamed on the user, no matter how
        deeply nested inside the &quot;Date::&quot; modules they occur, and do
        not usually refer to places inside any of the &quot;Date::&quot; modules
        (this assumes that there are no bugs in the &quot;Date::&quot; modules,
        and that all errors are always the user's fault
        <span class="Li">&quot;:-)&quot;</span>).</p>
    <p class="Pp">Moreover, your module's own error messages will behave in the
        same way if you &quot;<span class="Li">&quot;use Carp::Clan
        qw(^Date::);&quot;</span>&quot; at the top of your module and if you
        produce all error messages using &quot;<i>carp()</i>&quot; and
        &quot;<i>croak()</i>&quot; (instead of &quot;<i>warn()</i>&quot; and
        &quot;<i>die()</i>&quot;, respectively).</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<dl class="Bl-tag">
  <dt>1)</dt>
  <dd>
    <pre>
  # Switch to summer time:
  $now = Date::Calc-&gt;now();
  if (($now ge [2000,3,26,2,0,0]) and
      ($now lt [2000,3,26,3,0,0]))
  {
      $now += [0,0,0,1,0,0];
  }
    </pre>
  </dd>
  <dt>2)</dt>
  <dd>
    <pre>
  use Date::Calc::Object qw(:all);

  Date::Calc-&gt;date_format(3);

  $date = 0;
  while (!$date)
  {
      print &quot;Please enter the date of your birthday (day-month-year): &quot;;
      $date = Date::Calc-&gt;new( Decode_Date_EU( scalar(&lt;STDIN&gt;) ) );
      if ($date)
      {
          $resp = 0;
          while ($resp !~ /^\s*[YyNn]/)
          {
              print &quot;Your birthday is: $date\n&quot;;
              print &quot;Is that correct? (yes/no) &quot;;
              $resp = &lt;STDIN&gt;;
          }
          $date = 0 unless ($resp =~ /^\s*[Yy]/)
      }
      else
      {
          print &quot;Unable to parse your birthday. Please try again.\n&quot;;
      }
  }

  if ($date + [18,0,0] &lt;= [Today()])
      { print &quot;Ok, you are over 18.\n&quot;; }
  else
      { print &quot;Sorry, you are under 18!\n&quot;; }
    </pre>
  </dd>
</dl>
<p class="Pp">For more examples, see the &quot;examples&quot; subdirectory in
    this distribution, and their descriptions in the file
    &quot;EXAMPLES.txt&quot;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><i>Date::Calc</i>(3), <i>Date::Calc::Util</i>(3),
    <i>Date::Calendar</i>(3), <i>Date::Calendar::Year</i>(3),
    <i>Date::Calendar::Profiles</i>(3).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">This man page documents &quot;Date::Calc::Object&quot; version
    6.3.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<pre>
  Steffen Beyer
  mailto:STBEY@cpan.org
  http://www.engelschall.com/u/sb/download/
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 2000 - 2009 by Steffen Beyer. All rights
  reserved.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">This package is free software; you can use, modify and
    redistribute it under the same terms as Perl itself, i.e., at your option,
    under the terms either of the &quot;Artistic License&quot; or the &quot;GNU
    General Public License&quot;.</p>
<p class="Pp">The C library at the core of the module &quot;Date::Calc::XS&quot;
    can, at your discretion, also be used, modified and redistributed under the
    terms of the &quot;GNU Library General Public License&quot;.</p>
<p class="Pp">Please refer to the files &quot;Artistic.txt&quot;,
    &quot;GNU_GPL.txt&quot; and &quot;GNU_LGPL.txt&quot; in the
    &quot;license&quot; subdirectory of this distribution for any details!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DISCLAIMER"><a class="permalink" href="#DISCLAIMER">DISCLAIMER</a></h1>
<p class="Pp">This package is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</p>
<p class="Pp">See the &quot;GNU General Public License&quot; for more
  details.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2009-10-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>DBD::File::Developers(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBD::File::Developers(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBD::File::Developers(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">DBD::File::Developers - Developers documentation for DBD::File</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
    package DBD::myDriver;

    use base qw( DBD::File );

    sub driver
    {
        ...
        my $drh = $proto-&gt;SUPER::driver ($attr);
        ...
        return $drh-&gt;{class};
        }

    sub CLONE { ... }

    package DBD::myDriver::dr;

    @ISA = qw( DBD::File::dr );

    sub data_sources { ... }
    ...

    package DBD::myDriver::db;

    @ISA = qw( DBD::File::db );

    sub init_valid_attributes { ... }
    sub init_default_attributes { ... }
    sub set_versions { ... }
    sub validate_STORE_attr { my ($dbh, $attrib, $value) = @_; ... }
    sub validate_FETCH_attr { my ($dbh, $attrib) = @_; ... }
    sub get_myd_versions { ... }

    package DBD::myDriver::st;

    @ISA = qw( DBD::File::st );

    sub FETCH { ... }
    sub STORE { ... }

    package DBD::myDriver::Statement;

    @ISA = qw( DBD::File::Statement );

    package DBD::myDriver::Table;

    @ISA = qw( DBD::File::Table );

    my %reset_on_modify = (
        myd_abc =&gt; &quot;myd_foo&quot;,
        myd_mno =&gt; &quot;myd_bar&quot;,
        );
    __PACKAGE__-&gt;register_reset_on_modify (\%reset_on_modify);
    my %compat_map = (
        abc =&gt; 'foo_abc',
        xyz =&gt; 'foo_xyz',
        );
    __PACKAGE__-&gt;register_compat_map (\%compat_map);

    sub bootstrap_table_meta { ... }
    sub init_table_meta { ... }
    sub table_meta_attr_changed { ... }
    sub open_data { ... }

    sub fetch_row { ... }
    sub push_row { ... }
    sub push_names { ... }

    # optimize the SQL engine by add one or more of
    sub update_current_row { ... }
    # or
    sub update_specific_row { ... }
    # or
    sub update_one_row { ... }
    # or
    sub insert_new_row { ... }
    # or
    sub delete_current_row { ... }
    # or
    sub delete_one_row { ... }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This document describes how DBD developers can write DBD::File
    based DBI drivers. It supplements DBI::DBD and
    DBI::DBD::SqlEngine::Developers, which you should read first.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CLASSES"><a class="permalink" href="#CLASSES">CLASSES</a></h1>
<p class="Pp">Each DBI driver must provide a package global
    <span class="Li">&quot;driver&quot;</span> method and three DBI related
    classes:</p>
<dl class="Bl-tag">
  <dt id="DBD::File::dr"><a class="permalink" href="#DBD::File::dr">DBD::File::dr</a></dt>
  <dd>Driver package, contains the methods DBI calls indirectly via DBI
      interface:
    <p class="Pp"></p>
    <pre>
  DBI-&gt;connect ('DBI:DBM:', undef, undef, {})

  # invokes
  package DBD::DBM::dr;
  @DBD::DBM::dr::ISA = qw( DBD::File::dr );

  sub connect ($$;$$$)
  {
      ...
      }
    </pre>
    <p class="Pp">Similar for <span class="Li">&quot;data_sources&quot;</span>
        and <span class="Li">&quot;disconnect_all&quot;</span>.</p>
    <p class="Pp">Pure Perl DBI drivers derived from DBD::File do not usually
        need to override any of the methods provided through the DBD::XXX::dr
        package however if you need additional initialization in the connect
        method you may need to.</p>
  </dd>
  <dt id="DBD::File::db"><a class="permalink" href="#DBD::File::db">DBD::File::db</a></dt>
  <dd>Contains the methods which are called through DBI database handles
      (<span class="Li">$dbh</span>). e.g.,
    <p class="Pp"></p>
    <pre>
  $sth = $dbh-&gt;prepare (&quot;select * from foo&quot;);
  # returns the f_encoding setting for table foo
  $dbh-&gt;csv_get_meta (&quot;foo&quot;, &quot;f_encoding&quot;);
    </pre>
    <p class="Pp">DBD::File provides the typical methods required here.
        Developers who write DBI drivers based on DBD::File need to override the
        methods <span class="Li">&quot;set_versions&quot;</span> and
        <span class="Li">&quot;init_valid_attributes&quot;</span>.</p>
  </dd>
  <dt id="DBD::File::st"><a class="permalink" href="#DBD::File::st">DBD::File::st</a></dt>
  <dd>Contains the methods to deal with prepared statement handles. e.g.,
    <p class="Pp"></p>
    <pre>
  $sth-&gt;execute () or die $sth-&gt;errstr;
    </pre>
  </dd>
</dl>
<section class="Ss">
<h2 class="Ss" id="DBD::File"><a class="permalink" href="#DBD::File">DBD::File</a></h2>
<p class="Pp">This is the main package containing the routines to initialize
    DBD::File based DBI drivers. Primarily the
    <span class="Li">&quot;DBD::File::driver&quot;</span> method is invoked,
    either directly from DBI when the driver is initialized or from the derived
    class.</p>
<p class="Pp"></p>
<pre>
  package DBD::DBM;

  use base qw( DBD::File );

  sub driver
  {
      my ($class, $attr) = @_;
      ...
      my $drh = $class-&gt;SUPER::driver ($attr);
      ...
      return $drh;
      }
</pre>
<p class="Pp">It is not necessary to implement your own driver method as long as
    additional initialization (e.g. installing more private driver methods) is
    not required. You do not need to call
    <span class="Li">&quot;setup_driver&quot;</span> as DBD::File takes care of
    it.</p>
</section>
<section class="Ss">
<h2 class="Ss">DBD::File::dr</h2>
<p class="Pp">The driver package contains the methods DBI calls indirectly via
    the DBI interface (see &quot;DBI Class Methods&quot; in DBI).</p>
<p class="Pp">DBD::File based DBI drivers usually do not need to implement
    anything here, it is enough to do the basic initialization:</p>
<p class="Pp"></p>
<pre>
  package DBD:XXX::dr;

  @DBD::XXX::dr::ISA = qw (DBD::File::dr);
  $DBD::XXX::dr::imp_data_size     = 0;
  $DBD::XXX::dr::data_sources_attr = undef;
  $DBD::XXX::ATTRIBUTION = &quot;DBD::XXX $DBD::XXX::VERSION by Hans Mustermann&quot;;
</pre>
</section>
<section class="Ss">
<h2 class="Ss">DBD::File::db</h2>
<p class="Pp">This package defines the database methods, which are called via
    the DBI database handle <span class="Li">$dbh</span>.</p>
<p class="Pp">Methods provided by DBD::File:</p>
<dl class="Bl-tag">
  <dt id="ping"><a class="permalink" href="#ping">ping</a></dt>
  <dd>Simply returns the content of the
      <span class="Li">&quot;Active&quot;</span> attribute. Override when your
      driver needs more complicated actions here.</dd>
  <dt id="prepare"><a class="permalink" href="#prepare">prepare</a></dt>
  <dd>Prepares a new SQL statement to execute. Returns a statement handle,
      <span class="Li">$sth</span> - instance of the DBD:XXX::st. It is neither
      required nor recommended to override this method.</dd>
  <dt id="FETCH"><a class="permalink" href="#FETCH">FETCH</a></dt>
  <dd>Fetches an attribute of a DBI database object. Private handle attributes
      must have a prefix (this is mandatory). If a requested attribute is
      detected as a private attribute without a valid prefix, the driver prefix
      (written as <span class="Li">$drv_prefix</span>) is added.
    <p class="Pp">The driver prefix is extracted from the attribute name and
        verified against <span class="Li">&quot;$dbh-&gt;{$drv_prefix .
        &quot;valid_attrs&quot;}&quot;</span> (when it exists). If the requested
        attribute value is not listed as a valid attribute, this method croaks.
        If the attribute is valid and readonly (listed in
        <span class="Li">&quot;$dbh-&gt;{</span> <span class="Li">$drv_prefix .
        &quot;readonly_attrs&quot; }&quot;</span> when it exists), a real copy
        of the attribute value is returned. So it's not possible to modify
        <span class="Li">&quot;f_valid_attrs&quot;</span> from outside of
        DBD::File::db or a derived class.</p>
  </dd>
  <dt id="STORE"><a class="permalink" href="#STORE">STORE</a></dt>
  <dd>Stores a database private attribute. Private handle attributes must have a
      prefix (this is mandatory). If a requested attribute is detected as a
      private attribute without a valid prefix, the driver prefix (written as
      <span class="Li">$drv_prefix</span>) is added. If the database handle has
      an attribute <span class="Li">&quot;${drv_prefix}_valid_attrs&quot;</span>
      - for attribute names which are not listed in that hash, this method
      croaks. If the database handle has an attribute
      <span class="Li">&quot;${drv_prefix}_readonly_attrs&quot;</span>, only
      attributes which are not listed there can be stored (once they are
      initialized). Trying to overwrite such an immutable attribute forces this
      method to croak.
    <p class="Pp">An example of a valid attributes list can be found in
        <span class="Li">&quot;DBD::File::db::init_valid_attributes&quot;</span>.</p>
  </dd>
  <dt id="set_versions"><a class="permalink" href="#set_versions">set_versions</a></dt>
  <dd>This method sets the attribute
      <span class="Li">&quot;f_version&quot;</span> with the version of
      DBD::File.
    <p class="Pp">This method is called at the begin of the
        <span class="Li">&quot;connect ()&quot;</span> phase.</p>
    <p class="Pp">When overriding this method, do not forget to invoke the
        superior one.</p>
  </dd>
  <dt id="init_valid_attributes"><a class="permalink" href="#init_valid_attributes">init_valid_attributes</a></dt>
  <dd>This method is called after the database handle is instantiated as the
      first attribute initialization.
    <p class="Pp"><span class="Li">&quot;DBD::File::db::init_valid_attributes&quot;</span>
        initializes the attributes
        <span class="Li">&quot;f_valid_attrs&quot;</span> and
        <span class="Li">&quot;f_readonly_attrs&quot;</span>.</p>
    <p class="Pp">When overriding this method, do not forget to invoke the
        superior one, preferably before doing anything else. Compatibility table
        attribute access must be initialized here to allow DBD::File to
        instantiate the map tie:</p>
    <p class="Pp"></p>
    <pre>
    # for DBD::CSV
    $dbh-&gt;{csv_meta} = &quot;csv_tables&quot;;
    # for DBD::DBM
    $dbh-&gt;{dbm_meta} = &quot;dbm_tables&quot;;
    # for DBD::AnyData
    $dbh-&gt;{ad_meta}  = &quot;ad_tables&quot;;
    </pre>
  </dd>
  <dt id="init_default_attributes"><a class="permalink" href="#init_default_attributes">init_default_attributes</a></dt>
  <dd>This method is called after the database handle is instantiated to
      initialize the default attributes.
    <p class="Pp"><span class="Li">&quot;DBD::File::db::init_default_attributes&quot;</span>
        initializes the attributes <span class="Li">&quot;f_dir&quot;</span>,
        <span class="Li">&quot;f_meta&quot;</span>,
        <span class="Li">&quot;f_meta_map&quot;</span>,
        <span class="Li">&quot;f_version&quot;</span>.</p>
    <p class="Pp">When the derived implementor class provides the attribute to
        validate attributes (e.g.
        <span class="Li">&quot;$dbh-&gt;{dbm_valid_attrs} = {...};&quot;</span>)
        or the attribute containing the immutable attributes (e.g.
        <span class="Li">&quot;$dbh-&gt;{dbm_readonly_attrs} =
        {...};&quot;</span>), the attributes
        <span class="Li">&quot;drv_valid_attrs&quot;</span>,
        <span class="Li">&quot;drv_readonly_attrs&quot;</span>,
        <span class="Li">&quot;drv_version&quot;</span> and
        <span class="Li">&quot;drv_meta&quot;</span> are added (when available)
        to the list of valid and immutable attributes (where
        <span class="Li">&quot;drv_&quot;</span> is interpreted as the driver
        prefix).</p>
    <p class="Pp">If <span class="Li">&quot;drv_meta&quot;</span> is set, an
        attribute with the name in <span class="Li">&quot;drv_meta&quot;</span>
        is initialized providing restricted read/write access to the meta data
        of the tables using
        <span class="Li">&quot;DBD::File::TieTables&quot;</span> in the first
        (table) level and <span class="Li">&quot;DBD::File::TieMeta&quot;</span>
        for the meta attribute level.
        <span class="Li">&quot;DBD::File::TieTables&quot;</span> uses
        <span class="Li">&quot;DBD::DRV::Table::get_table_meta&quot;</span> to
        initialize the second level tied hash on FETCH/STORE. The
        <span class="Li">&quot;DBD::File::TieMeta&quot;</span> class uses
        <span class="Li">&quot;DBD::DRV::Table::get_table_meta_attr&quot;</span>
        to FETCH attribute values and
        <span class="Li">&quot;DBD::DRV::Table::set_table_meta_attr&quot;</span>
        to STORE attribute values. This allows it to map meta attributes for
        compatibility reasons.</p>
  </dd>
  <dt id="get_single_table_meta"><a class="permalink" href="#get_single_table_meta">get_single_table_meta</a></dt>
  <dd></dd>
  <dt id="get_file_meta"><a class="permalink" href="#get_file_meta">get_file_meta</a></dt>
  <dd>Retrieve an attribute from a table's meta information. The method
      signature is <span class="Li">&quot;get_file_meta ($dbh, $table,
      $attr)&quot;</span>. This method is called by the injected db handle
      method <span class="Li">&quot;${drv_prefix}get_meta&quot;</span>.
    <p class="Pp">While get_file_meta allows <span class="Li">$table</span> or
        <span class="Li">$attr</span> to be a list of tables or attributes to
        retrieve, get_single_table_meta allows only one table name and only one
        attribute name. A table name of <span class="Li">'.'</span> (single dot)
        is interpreted as the default table and this will retrieve the
        appropriate attribute globally from the dbh. This has the same
        restrictions as
      <span class="Li">&quot;$dbh-&gt;{$attrib}&quot;</span>.</p>
    <p class="Pp">get_file_meta allows <span class="Li">'+'</span> and
        <span class="Li">'*'</span> as wildcards for table names and
        <span class="Li">$table</span> being a regular expression matching
        against the table names (evaluated without the default table). The table
        name <span class="Li">'*'</span> is <i>all currently known tables,
        including the default one</i>. The table name
        <span class="Li">'+'</span> is <i>all table names which conform to</i>
        <i>ANSI file name restrictions</i> (/^[_A-Za-z0-9]+$/).</p>
    <p class="Pp">The table meta information is retrieved using the
        get_table_meta and get_table_meta_attr methods of the table class of the
        implementation.</p>
  </dd>
  <dt id="set_single_table_meta"><a class="permalink" href="#set_single_table_meta">set_single_table_meta</a></dt>
  <dd></dd>
  <dt id="set_file_meta"><a class="permalink" href="#set_file_meta">set_file_meta</a></dt>
  <dd>Sets an attribute in a table's meta information. The method signature is
      <span class="Li">&quot;set_file_meta ($dbh, $table, $attr,
      $value)&quot;</span>. This method is called by the injected db handle
      method <span class="Li">&quot;${drv_prefix}set_meta&quot;</span>.
    <p class="Pp">While set_file_meta allows <span class="Li">$table</span> to
        be a list of tables and <span class="Li">$attr</span> to be a hash of
        several attributes to set, set_single_table_meta allows only one table
        name and only one attribute name/value pair.</p>
    <p class="Pp">The wildcard characters for the table name are the same as for
        get_file_meta.</p>
    <p class="Pp">The table meta information is updated using the get_table_meta
        and set_table_meta_attr methods of the table class of the
        implementation.</p>
  </dd>
  <dt id="clear_file_meta"><a class="permalink" href="#clear_file_meta">clear_file_meta</a></dt>
  <dd>Clears all meta information cached about a table. The method signature is
      <span class="Li">&quot;clear_file_meta ($dbh, $table)&quot;</span>. This
      method is called by the injected db handle method
      <span class="Li">&quot;${drv_prefix}clear_meta&quot;</span>.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">DBD::File::st</h2>
<p class="Pp">Contains the methods to deal with prepared statement handles:</p>
<dl class="Bl-tag">
  <dt id="FETCH~2"><a class="permalink" href="#FETCH~2">FETCH</a></dt>
  <dd>Fetches statement handle attributes. Supported attributes (for full
      overview see &quot;Statement Handle Attributes&quot; in DBI) are
      <span class="Li">&quot;NAME&quot;</span>,
      <span class="Li">&quot;TYPE&quot;</span>,
      <span class="Li">&quot;PRECISION&quot;</span> and
      <span class="Li">&quot;NULLABLE&quot;</span> in case that SQL::Statement
      is used as SQL execution engine and a statement is successful prepared.
      When SQL::Statement has additional information about a table, those
      information are returned. Otherwise, the same defaults as in
      DBI::DBD::SqlEngine are used.
    <p class="Pp">This method usually requires extending in a derived
        implementation. See DBD::CSV or DBD::DBM for some example.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="DBD::File::TableSource::FileSystem"><a class="permalink" href="#DBD::File::TableSource::FileSystem">DBD::File::TableSource::FileSystem</a></h2>
<p class="Pp">Provides data sources and table information on database driver and
    database handle level.</p>
<p class="Pp"></p>
<pre>
  package DBD::File::TableSource::FileSystem;

  sub data_sources ($;$)
  {
      my ($class, $drh, $attrs) = @_;
      ...
      }

  sub avail_tables
  {
      my ($class, $drh) = @_;
      ...
      }
</pre>
<p class="Pp">The <span class="Li">&quot;data_sources&quot;</span> method is
    called when the user invokes any of the following:</p>
<p class="Pp"></p>
<pre>
  @ary = DBI-&gt;data_sources ($driver);
  @ary = DBI-&gt;data_sources ($driver, \%attr);
  
  @ary = $dbh-&gt;data_sources ();
  @ary = $dbh-&gt;data_sources (\%attr);
</pre>
<p class="Pp">The <span class="Li">&quot;avail_tables&quot;</span> method is
    called when the user invokes any of the following:</p>
<p class="Pp"></p>
<pre>
  @names = $dbh-&gt;tables ($catalog, $schema, $table, $type);
  
  $sth   = $dbh-&gt;table_info ($catalog, $schema, $table, $type);
  $sth   = $dbh-&gt;table_info ($catalog, $schema, $table, $type, \%attr);

  $dbh-&gt;func (&quot;list_tables&quot;);
</pre>
<p class="Pp">Every time where an <span class="Li">&quot;\%attr&quot;</span>
    argument can be specified, this <span class="Li">&quot;\%attr&quot;</span>
    object's <span class="Li">&quot;sql_table_source&quot;</span> attribute is
    preferred over the <span class="Li">$dbh</span> attribute or the driver
    default.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="DBD::File::DataSource::Stream"><a class="permalink" href="#DBD::File::DataSource::Stream">DBD::File::DataSource::Stream</a></h2>
<pre>
  package DBD::File::DataSource::Stream;

  @DBD::File::DataSource::Stream::ISA = 'DBI::DBD::SqlEngine::DataSource';

  sub complete_table_name
  {
      my ($self, $meta, $file, $respect_case) = @_;
      ...
      }
</pre>
<p class="Pp">Clears all meta attributes identifying a file:
    <span class="Li">&quot;f_fqfn&quot;</span>,
    <span class="Li">&quot;f_fqbn&quot;</span> and
    <span class="Li">&quot;f_fqln&quot;</span>. The table name is set according
    to <span class="Li">$respect_case</span> and
    <span class="Li">&quot;$meta-&gt;{sql_identifier_case}&quot;</span>
    (SQL_IC_LOWER, SQL_IC_UPPER).</p>
<p class="Pp"></p>
<pre>
  package DBD::File::DataSource::Stream;

  sub apply_encoding
  {
      my ($self, $meta, $fn) = @_;
      ...
      }
</pre>
<p class="Pp">Applies the encoding from <i>meta information</i>
    (<span class="Li">&quot;$meta-&gt;{f_encoding}&quot;</span>) to the file
    handled opened in <span class="Li">&quot;open_data&quot;</span>.</p>
<p class="Pp"></p>
<pre>
  package DBD::File::DataSource::Stream;

  sub open_data
  {
      my ($self, $meta, $attrs, $flags) = @_;
      ...
      }
</pre>
<p class="Pp">Opens (<span class="Li">&quot;dup (2)&quot;</span>) the file
    handle provided in
  <span class="Li">&quot;$meta-&gt;{f_file}&quot;</span>.</p>
<p class="Pp"></p>
<pre>
  package DBD::File::DataSource::Stream;

  sub can_flock { ... }
</pre>
<p class="Pp">Returns whether <span class="Li">&quot;flock (2)&quot;</span> is
    available or not (avoids retesting in subclasses).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="DBD::File::DataSource::File"><a class="permalink" href="#DBD::File::DataSource::File">DBD::File::DataSource::File</a></h2>
<pre>
  package DBD::File::DataSource::File;

  sub complete_table_name ($$;$)
  {
      my ($self, $meta, $table, $respect_case) = @_;
      ...
      }
</pre>
<p class="Pp">The method <span class="Li">&quot;complete_table_name&quot;</span>
    tries to map a filename to the associated table name. It is called with a
    partially filled meta structure for the resulting table containing at least
    the following attributes: <span class="Li">&quot;f_ext&quot;</span>,
    <span class="Li">&quot;f_dir&quot;</span>,
    <span class="Li">&quot;f_lockfile&quot;</span> and
    <span class="Li">&quot;sql_identifier_case&quot;</span>.</p>
<p class="Pp">If a file/table map can be found then this method sets the
    <span class="Li">&quot;f_fqfn&quot;</span>,
    <span class="Li">&quot;f_fqbn&quot;</span>,
    <span class="Li">&quot;f_fqln&quot;</span> and
    <span class="Li">&quot;table_name&quot;</span> attributes in the meta
    structure. If a map cannot be found the table name will be undef.</p>
<p class="Pp"></p>
<pre>
  package DBD::File::DataSource::File;

  sub open_data ($)
  {
      my ($self, $meta, $attrs, $flags) = @_;
      ...
      }
</pre>
<p class="Pp">Depending on the attributes set in the table's meta data, the
    following steps are performed. Unless
    <span class="Li">&quot;f_dontopen&quot;</span> is set to a true value,
    <span class="Li">&quot;f_fqfn&quot;</span> must contain the full qualified
    file name for the table to work on (file2table ensures this). The encoding
    in <span class="Li">&quot;f_encoding&quot;</span> is applied if set and the
    file is opened. If <span class="Li">&quot;&lt;f_fqln &quot;</span>&gt; (full
    qualified lock name) is set, this file is opened, too. Depending on the
    value in <span class="Li">&quot;f_lock&quot;</span>, the appropriate lock is
    set on the opened data file or lock file.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="DBD::File::Statement"><a class="permalink" href="#DBD::File::Statement">DBD::File::Statement</a></h2>
<p class="Pp">Derives from DBI::SQL::Nano::Statement to provide following
    method:</p>
<dl class="Bl-tag">
  <dt id="open_table"><a class="permalink" href="#open_table">open_table</a></dt>
  <dd>Implements the open_table method required by SQL::Statement and
      DBI::SQL::Nano. All the work for opening the file(s) belonging to the
      table is handled and parametrized in DBD::File::Table. Unless you intend
      to add anything to the following implementation, an empty
      DBD::XXX::Statement package satisfies DBD::File.
    <p class="Pp"></p>
    <pre>
  sub open_table ($$$$$)
  {
      my ($self, $data, $table, $createMode, $lockMode) = @_;

      my $class = ref $self;
      $class =~ s/::Statement/::Table/;

      my $flags = {
          createMode =&gt; $createMode,
          lockMode   =&gt; $lockMode,
          };
      $self-&gt;{command} eq &quot;DROP&quot; and $flags-&gt;{dropMode} = 1;

      return $class-&gt;new ($data, { table =&gt; $table }, $flags);
      } # open_table
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="DBD::File::Table"><a class="permalink" href="#DBD::File::Table">DBD::File::Table</a></h2>
<p class="Pp">Derives from DBI::SQL::Nano::Table and provides physical file
    access for the table data which are stored in the files.</p>
<dl class="Bl-tag">
  <dt id="bootstrap_table_meta"><a class="permalink" href="#bootstrap_table_meta">bootstrap_table_meta</a></dt>
  <dd>Initializes a table meta structure. Can be safely overridden in a derived
      class, as long as the <span class="Li">&quot;SUPER&quot;</span> method is
      called at the end of the overridden method.
    <p class="Pp">It copies the following attributes from the database into the
        table meta data <span class="Li">&quot;f_dir&quot;</span>,
        <span class="Li">&quot;f_ext&quot;</span>,
        <span class="Li">&quot;f_encoding&quot;</span>,
        <span class="Li">&quot;f_lock&quot;</span>,
        <span class="Li">&quot;f_schema&quot;</span> and
        <span class="Li">&quot;f_lockfile&quot;</span> and makes them sticky to
        the table.</p>
    <p class="Pp">This method should be called before you attempt to map between
        file name and table name to ensure the correct directory, extension etc.
        are used.</p>
  </dd>
  <dt id="init_table_meta"><a class="permalink" href="#init_table_meta">init_table_meta</a></dt>
  <dd>Initializes more attributes of the table meta data - usually more
      expensive ones (e.g. those which require class instantiations) - when the
      file name and the table name could mapped.</dd>
  <dt id="get_table_meta"><a class="permalink" href="#get_table_meta">get_table_meta</a></dt>
  <dd>Returns the table meta data. If there are none for the required table, a
      new one is initialized. When it fails, nothing is returned. On success,
      the name of the table and the meta data structure is returned.</dd>
  <dt id="get_table_meta_attr"><a class="permalink" href="#get_table_meta_attr">get_table_meta_attr</a></dt>
  <dd>Returns a single attribute from the table meta data. If the attribute name
      appears in <span class="Li">%compat_map</span>, the attribute name is
      updated from there.</dd>
  <dt id="set_table_meta_attr"><a class="permalink" href="#set_table_meta_attr">set_table_meta_attr</a></dt>
  <dd>Sets a single attribute in the table meta data. If the attribute name
      appears in <span class="Li">%compat_map</span>, the attribute name is
      updated from there.</dd>
  <dt id="table_meta_attr_changed"><a class="permalink" href="#table_meta_attr_changed">table_meta_attr_changed</a></dt>
  <dd>Called when an attribute of the meta data is modified.
    <p class="Pp">If the modified attribute requires to reset a calculated
        attribute, the calculated attribute is reset (deleted from meta data
        structure) and the <i>initialized</i> flag is removed, too. The decision
        is made based on <span class="Li">%register_reset_on_modify</span>.</p>
  </dd>
  <dt id="register_reset_on_modify"><a class="permalink" href="#register_reset_on_modify">register_reset_on_modify</a></dt>
  <dd>Allows <span class="Li">&quot;set_table_meta_attr&quot;</span> to reset
      meta attributes when special attributes are modified. For DBD::File,
      modifying one of <span class="Li">&quot;f_file&quot;</span>,
      <span class="Li">&quot;f_dir&quot;</span>,
      <span class="Li">&quot;f_ext&quot;</span> or
      <span class="Li">&quot;f_lockfile&quot;</span> will reset
      <span class="Li">&quot;f_fqfn&quot;</span>. DBD::DBM extends the list for
      <span class="Li">&quot;dbm_type&quot;</span> and
      <span class="Li">&quot;dbm_mldbm&quot;</span> to reset the value of
      <span class="Li">&quot;dbm_tietype&quot;</span>.
    <p class="Pp">If your DBD has calculated values in the meta data area, then
        call <span class="Li">&quot;register_reset_on_modify&quot;</span>:</p>
    <p class="Pp"></p>
    <pre>
  my %reset_on_modify = (xxx_foo =&gt; &quot;xxx_bar&quot;);
  __PACKAGE__-&gt;register_reset_on_modify (\%reset_on_modify);
    </pre>
  </dd>
  <dt id="register_compat_map"><a class="permalink" href="#register_compat_map">register_compat_map</a></dt>
  <dd>Allows <span class="Li">&quot;get_table_meta_attr&quot;</span> and
      <span class="Li">&quot;set_table_meta_attr&quot;</span> to update the
      attribute name to the current favored one:
    <p class="Pp"></p>
    <pre>
  # from DBD::DBM
  my %compat_map = (dbm_ext =&gt; &quot;f_ext&quot;);
  __PACKAGE__-&gt;register_compat_map (\%compat_map);
    </pre>
  </dd>
  <dt id="open_file"><a class="permalink" href="#open_file">open_file</a></dt>
  <dd>Called to open the table's data file.
    <p class="Pp">Depending on the attributes set in the table's meta data, the
        following steps are performed. Unless
        <span class="Li">&quot;f_dontopen&quot;</span> is set to a true value,
        <span class="Li">&quot;f_fqfn&quot;</span> must contain the full
        qualified file name for the table to work on (file2table ensures this).
        The encoding in <span class="Li">&quot;f_encoding&quot;</span> is
        applied if set and the file is opened. If
        <span class="Li">&quot;&lt;f_fqln &quot;</span>&gt; (full qualified lock
        name) is set, this file is opened, too. Depending on the value in
        <span class="Li">&quot;f_lock&quot;</span>, the appropriate lock is set
        on the opened data file or lock file.</p>
    <p class="Pp">After this is done, a derived class might add more steps in an
        overridden <span class="Li">&quot;open_file&quot;</span> method.</p>
  </dd>
  <dt id="new"><a class="permalink" href="#new">new</a></dt>
  <dd>Instantiates the table. This is done in 3 steps:
    <p class="Pp"></p>
    <pre>
 1. get the table meta data
 2. open the data file
 3. bless the table data structure using inherited constructor new
    </pre>
    <p class="Pp">It is not recommended to override the constructor of the table
        class. Find a reasonable place to add you extensions in one of the above
        four methods.</p>
  </dd>
  <dt id="drop"><a class="permalink" href="#drop">drop</a></dt>
  <dd>Implements the abstract table method for the
      <span class="Li">&quot;DROP&quot;</span> command. Discards table meta data
      after all files belonging to the table are closed and unlinked.
    <p class="Pp">Overriding this method might be reasonable in very rare
      cases.</p>
  </dd>
  <dt id="seek"><a class="permalink" href="#seek">seek</a></dt>
  <dd>Implements the abstract table method used when accessing the table from
      the engine. <span class="Li">&quot;seek&quot;</span> is called every time
      the engine uses dumb algorithms for iterating over the table content.</dd>
  <dt id="truncate"><a class="permalink" href="#truncate">truncate</a></dt>
  <dd>Implements the abstract table method used when dumb table algorithms for
      <span class="Li">&quot;UPDATE&quot;</span> or
      <span class="Li">&quot;DELETE&quot;</span> need to truncate the table
      storage after the last written row.</dd>
</dl>
<p class="Pp">You should consult the documentation of
    <span class="Li">&quot;SQL::Eval::Table&quot;</span> (see SQL::Eval) to get
    more information about the abstract methods of the table's base class you
    have to override and a description of the table meta information expected by
    the SQL engines.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">The module DBD::File is currently maintained by</p>
<p class="Pp">H.Merijn Brand &lt; h.m.brand at xs4all.nl &gt; and Jens Rehsack
    &lt; rehsack at googlemail.com &gt;</p>
<p class="Pp">The original author is Jochen Wiedmann.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">Copyright (C) 2010-2013 by H.Merijn Brand &amp; Jens Rehsack</p>
<p class="Pp">All rights reserved.</p>
<p class="Pp">You may freely distribute and/or modify this module under the
    terms of either the GNU General Public License (GPL) or the Artistic
    License, as specified in the Perl README file.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-04-04</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

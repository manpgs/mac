<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>DB_File(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DB_File(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">DB_File(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">DB_File - Perl5 access to Berkeley DB version 1.x</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre> use DB_File;
 [$X =] tie %hash,  'DB_File', [$filename, $flags, $mode, $DB_HASH] ;
 [$X =] tie %hash,  'DB_File', $filename, $flags, $mode, $DB_BTREE ;
 [$X =] tie @array, 'DB_File', $filename, $flags, $mode, $DB_RECNO ;
 $status = $X-&gt;del($key [, $flags]) ;
 $status = $X-&gt;put($key, $value [, $flags]) ;
 $status = $X-&gt;get($key, $value [, $flags]) ;
 $status = $X-&gt;seq($key, $value, $flags) ;
 $status = $X-&gt;sync([$flags]) ;
 $status = $X-&gt;fd ;
 # BTREE only
 $count = $X-&gt;get_dup($key) ;
 @list  = $X-&gt;get_dup($key) ;
 %list  = $X-&gt;get_dup($key, 1) ;
 $status = $X-&gt;find_dup($key, $value) ;
 $status = $X-&gt;del_dup($key, $value) ;
 # RECNO only
 $a = $X-&gt;length;
 $a = $X-&gt;pop ;
 $X-&gt;push(list);
 $a = $X-&gt;shift;
 $X-&gt;unshift(list);
 @r = $X-&gt;splice(offset, length, elements);
 # DBM Filters
 $old_filter = $db-&gt;filter_store_key  ( sub { ... } ) ;
 $old_filter = $db-&gt;filter_store_value( sub { ... } ) ;
 $old_filter = $db-&gt;filter_fetch_key  ( sub { ... } ) ;
 $old_filter = $db-&gt;filter_fetch_value( sub { ... } ) ;
 untie %hash ;
 untie @array ;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><b>DB_File</b> is a module which allows Perl programs to make use
    of the facilities provided by Berkeley DB version 1.x (if you have a newer
    version of DB, see &quot;Using DB_File with Berkeley DB version 2 or
    greater&quot;). It is assumed that you have a copy of the Berkeley DB manual
    pages at hand when reading this documentation. The interface defined here
    mirrors the Berkeley DB interface closely.</p>
<p class="Pp">Berkeley DB is a C library which provides a consistent interface
    to a number of database formats. <b>DB_File</b> provides an interface to all
    three of the database types currently supported by Berkeley DB.</p>
<p class="Pp">The file types are:</p>
<dl class="Bl-tag">
  <dt><b>DB_HASH</b></dt>
  <dd>This database type allows arbitrary key/value pairs to be stored in data
      files. This is equivalent to the functionality provided by other hashing
      packages like DBM, NDBM, ODBM, GDBM, and SDBM. Remember though, the files
      created using DB_HASH are not compatible with any of the other packages
      mentioned.
    <p class="Pp">A default hashing algorithm, which will be adequate for most
        applications, is built into Berkeley DB. If you do need to use your own
        hashing algorithm it is possible to write your own in Perl and have
        <b>DB_File</b> use it instead.</p>
  </dd>
  <dt><b>DB_BTREE</b></dt>
  <dd>The btree format allows arbitrary key/value pairs to be stored in a
      sorted, balanced binary tree.
    <p class="Pp">As with the DB_HASH format, it is possible to provide a user
        defined Perl routine to perform the comparison of keys. By default,
        though, the keys are stored in lexical order.</p>
  </dd>
  <dt><b>DB_RECNO</b></dt>
  <dd>DB_RECNO allows both fixed-length and variable-length flat text files to
      be manipulated using the same key/value pair interface as in DB_HASH and
      DB_BTREE. In this case the key will consist of a record (line)
    number.</dd>
</dl>
<section class="Ss">
<h2 class="Ss" id="Using_DB_File_with_Berkeley_"><a class="permalink" href="#Using_DB_File_with_Berkeley_">Using
  DB_File with Berkeley DB version 2 or greater</a></h2>
<p class="Pp">Although <b>DB_File</b> is intended to be used with Berkeley DB
    version 1, it can also be used with version 2, 3 or 4. In this case the
    interface is limited to the functionality provided by Berkeley DB 1.x.
    Anywhere the version 2 or greater interface differs, <b>DB_File</b> arranges
    for it to work like version 1. This feature allows <b>DB_File</b> scripts
    that were built with version 1 to be migrated to version 2 or greater
    without any changes.</p>
<p class="Pp">If you want to make use of the new features available in Berkeley
    DB 2.x or greater, use the Perl module BerkeleyDB
    &lt;https://metacpan.org/pod/BerkeleyDB&gt; instead.</p>
<p class="Pp"><b>Note:</b> The database file format has changed multiple times
    in Berkeley DB version 2, 3 and 4. If you cannot recreate your databases,
    you must dump any existing databases with either the
    <span class="Li">&quot;db_dump&quot;</span> or the
    <span class="Li">&quot;db_dump185&quot;</span> utility that comes with
    Berkeley DB. Once you have rebuilt DB_File to use Berkeley DB version 2 or
    greater, your databases can be recreated using
    <span class="Li">&quot;db_load&quot;</span>. Refer to the Berkeley DB
    documentation for further details.</p>
<p class="Pp">Please read &quot;COPYRIGHT&quot; before using version 2.x or
    greater of Berkeley DB with DB_File.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Interface_to_Berkeley_"><a class="permalink" href="#Interface_to_Berkeley_">Interface
  to Berkeley DB</a></h2>
<p class="Pp"><b>DB_File</b> allows access to Berkeley DB files using the
    <b>tie()</b> mechanism in Perl 5 (for full details, see
    &quot;<b>tie()</b>&quot; in perlfunc). This facility allows <b>DB_File</b>
    to access Berkeley DB files using either an associative array (for DB_HASH
    &amp; DB_BTREE file types) or an ordinary array (for the DB_RECNO file
    type).</p>
<p class="Pp">In addition to the <b>tie()</b> interface, it is also possible to
    access most of the functions provided in the Berkeley DB API directly. See
    &quot;THE API INTERFACE&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Opening_a_Berkeley_"><a class="permalink" href="#Opening_a_Berkeley_">Opening
  a Berkeley DB Database File</a></h2>
<p class="Pp">Berkeley DB uses the function <b>dbopen()</b> to open or create a
    database. Here is the C prototype for <b>dbopen()</b>:</p>
<p class="Pp"></p>
<pre>      DB*
      dbopen (const char * file, int flags, int mode,
              DBTYPE type, const void * openinfo)
</pre>
<p class="Pp">The parameter <span class="Li">&quot;type&quot;</span> is an
    enumeration which specifies which of the 3 interface methods (DB_HASH,
    DB_BTREE or DB_RECNO) is to be used. Depending on which of these is actually
    chosen, the final parameter, <i>openinfo</i> points to a data structure
    which allows tailoring of the specific interface method.</p>
<p class="Pp">This interface is handled slightly differently in <b>DB_File</b>.
    Here is an equivalent call using <b>DB_File</b>:</p>
<p class="Pp"></p>
<pre>        tie %array, 'DB_File', $filename, $flags, $mode, $DB_HASH ;
</pre>
<p class="Pp">The <span class="Li">&quot;filename&quot;</span>,
    <span class="Li">&quot;flags&quot;</span> and
    <span class="Li">&quot;mode&quot;</span> parameters are the direct
    equivalent of their <b>dbopen()</b> counterparts. The final parameter
    <span class="Li">$DB_HASH</span> performs the function of both the
    <span class="Li">&quot;type&quot;</span> and
    <span class="Li">&quot;openinfo&quot;</span> parameters in
  <b>dbopen()</b>.</p>
<p class="Pp">In the example above <span class="Li">$DB_HASH</span> is actually
    a pre-defined reference to a hash object. <b>DB_File</b> has three of these
    pre-defined references. Apart from <span class="Li">$DB_HASH</span>, there
    is also <span class="Li">$DB_BTREE</span> and
    <span class="Li">$DB_RECNO</span>.</p>
<p class="Pp">The keys allowed in each of these pre-defined references is
    limited to the names used in the equivalent C structure. So, for example,
    the <span class="Li">$DB_HASH</span> reference will only allow keys called
    <span class="Li">&quot;bsize&quot;</span>,
    <span class="Li">&quot;cachesize&quot;</span>,
    <span class="Li">&quot;ffactor&quot;</span>,
    <span class="Li">&quot;hash&quot;</span>,
    <span class="Li">&quot;lorder&quot;</span> and
    <span class="Li">&quot;nelem&quot;</span>.</p>
<p class="Pp">To change one of these elements, just assign to it like this:</p>
<p class="Pp"></p>
<pre>        $DB_HASH-&gt;{'cachesize'} = 10000 ;
</pre>
<p class="Pp">The three predefined variables <span class="Li">$DB_HASH</span>,
    <span class="Li">$DB_BTREE</span> and <span class="Li">$DB_RECNO</span> are
    usually adequate for most applications. If you do need to create extra
    instances of these objects, constructors are available for each file
  type.</p>
<p class="Pp">Here are examples of the constructors and the valid options
    available for DB_HASH, DB_BTREE and DB_RECNO respectively.</p>
<p class="Pp"></p>
<pre>     $a = DB_File::HASHINFO-&gt;new();
     $a-&gt;{'bsize'} ;
     $a-&gt;{'cachesize'} ;
     $a-&gt;{'ffactor'};
     $a-&gt;{'hash'} ;
     $a-&gt;{'lorder'} ;
     $a-&gt;{'nelem'} ;
     $b = DB_File::BTREEINFO-&gt;new();
     $b-&gt;{'flags'} ;
     $b-&gt;{'cachesize'} ;
     $b-&gt;{'maxkeypage'} ;
     $b-&gt;{'minkeypage'} ;
     $b-&gt;{'psize'} ;
     $b-&gt;{'compare'} ;
     $b-&gt;{'prefix'} ;
     $b-&gt;{'lorder'} ;
     $c = DB_File::RECNOINFO-&gt;new();
     $c-&gt;{'bval'} ;
     $c-&gt;{'cachesize'} ;
     $c-&gt;{'psize'} ;
     $c-&gt;{'flags'} ;
     $c-&gt;{'lorder'} ;
     $c-&gt;{'reclen'} ;
     $c-&gt;{'bfname'} ;
</pre>
<p class="Pp">The values stored in the hashes above are mostly the direct
    equivalent of their C counterpart. Like their C counterparts, all are set to
    a default values - that means you don't have to set <i>all</i> of the values
    when you only want to change one. Here is an example:</p>
<p class="Pp"></p>
<pre>     $a = DB_File::HASHINFO-&gt;new();
     $a-&gt;{'cachesize'} =  12345 ;
     tie %y, 'DB_File', &quot;filename&quot;, $flags, 0777, $a ;
</pre>
<p class="Pp">A few of the options need extra discussion here. When used, the C
    equivalent of the keys <span class="Li">&quot;hash&quot;</span>,
    <span class="Li">&quot;compare&quot;</span> and
    <span class="Li">&quot;prefix&quot;</span> store pointers to C functions. In
    <b>DB_File</b> these keys are used to store references to Perl subs. Below
    are templates for each of the subs:</p>
<p class="Pp"></p>
<pre>    sub hash
    {
        my ($data) = @_ ;
        ...
        # return the hash value for $data
        return $hash ;
    }
    sub compare
    {
        my ($key, $key2) = @_ ;
        ...
        # return  0 if $key1 eq $key2
        #        -1 if $key1 lt $key2
        #         1 if $key1 gt $key2
        return (-1 , 0 or 1) ;
    }
    sub prefix
    {
        my ($key, $key2) = @_ ;
        ...
        # return number of bytes of $key2 which are
        # necessary to determine that it is greater than $key1
        return $bytes ;
    }
</pre>
<p class="Pp">See &quot;Changing the BTREE sort order&quot; for an example of
    using the <span class="Li">&quot;compare&quot;</span> template.</p>
<p class="Pp">If you are using the DB_RECNO interface and you intend making use
    of <span class="Li">&quot;bval&quot;</span>, you should check out &quot;The
    'bval' Option&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Default_Parameters"><a class="permalink" href="#Default_Parameters">Default
  Parameters</a></h2>
<p class="Pp">It is possible to omit some or all of the final 4 parameters in
    the call to <span class="Li">&quot;tie&quot;</span> and let them take
    default values. As DB_HASH is the most common file format used, the
  call:</p>
<p class="Pp"></p>
<pre>    tie %A, &quot;DB_File&quot;, &quot;filename&quot; ;
</pre>
<p class="Pp">is equivalent to:</p>
<p class="Pp"></p>
<pre>    tie %A, &quot;DB_File&quot;, &quot;filename&quot;, O_CREAT|O_RDWR, 0666, $DB_HASH ;
</pre>
<p class="Pp">It is also possible to omit the filename parameter as well, so the
    call:</p>
<p class="Pp"></p>
<pre>    tie %A, &quot;DB_File&quot; ;
</pre>
<p class="Pp">is equivalent to:</p>
<p class="Pp"></p>
<pre>    tie %A, &quot;DB_File&quot;, undef, O_CREAT|O_RDWR, 0666, $DB_HASH ;
</pre>
<p class="Pp">See &quot;In Memory Databases&quot; for a discussion on the use of
    <span class="Li">&quot;undef&quot;</span> in place of a filename.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="In_Memory_Databases"><a class="permalink" href="#In_Memory_Databases">In
  Memory Databases</a></h2>
<p class="Pp">Berkeley DB allows the creation of in-memory databases by using
    NULL (that is, a <span class="Li">&quot;(char *)0&quot;</span> in C) in
    place of the filename. <b>DB_File</b> uses
    <span class="Li">&quot;undef&quot;</span> instead of NULL to provide this
    functionality.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DB_HASH"><a class="permalink" href="#DB_HASH">DB_HASH</a></h1>
<p class="Pp">The DB_HASH file format is probably the most commonly used of the
    three file formats that <b>DB_File</b> supports. It is also very
    straightforward to use.</p>
<section class="Ss">
<h2 class="Ss">A Simple Example</h2>
<p class="Pp">This example shows how to create a database, add key/value pairs
    to the database, delete keys/value pairs and finally how to enumerate the
    contents of the database.</p>
<p class="Pp"></p>
<pre>    use warnings ;
    use strict ;
    use DB_File ;
    our (%h, $k, $v) ;
    unlink &quot;fruit&quot; ;
    tie %h, &quot;DB_File&quot;, &quot;fruit&quot;, O_RDWR|O_CREAT, 0666, $DB_HASH
        or die &quot;Cannot open file 'fruit': $!\n&quot;;
    # Add a few key/value pairs to the file
    $h{&quot;apple&quot;} = &quot;red&quot; ;
    $h{&quot;orange&quot;} = &quot;orange&quot; ;
    $h{&quot;banana&quot;} = &quot;yellow&quot; ;
    $h{&quot;tomato&quot;} = &quot;red&quot; ;
    # Check for existence of a key
    print &quot;Banana Exists\n\n&quot; if $h{&quot;banana&quot;} ;
    # Delete a key/value pair.
    delete $h{&quot;apple&quot;} ;
    # print the contents of the file
    while (($k, $v) = each %h)
      { print &quot;$k -&gt; $v\n&quot; }
    untie %h ;
</pre>
<p class="Pp">here is the output:</p>
<p class="Pp"></p>
<pre>    Banana Exists
    orange -&gt; orange
    tomato -&gt; red
    banana -&gt; yellow
</pre>
<p class="Pp">Note that the like ordinary associative arrays, the order of the
    keys retrieved is in an apparently random order.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DB_BTREE"><a class="permalink" href="#DB_BTREE">DB_BTREE</a></h1>
<p class="Pp">The DB_BTREE format is useful when you want to store data in a
    given order. By default the keys will be stored in lexical order, but as you
    will see from the example shown in the next section, it is very easy to
    define your own sorting function.</p>
<section class="Ss">
<h2 class="Ss" id="Changing_the_"><a class="permalink" href="#Changing_the_">Changing
  the BTREE sort order</a></h2>
<p class="Pp">This script shows how to override the default sorting algorithm
    that BTREE uses. Instead of using the normal lexical ordering, a case
    insensitive compare function will be used.</p>
<p class="Pp"></p>
<pre>    use warnings ;
    use strict ;
    use DB_File ;
    my %h ;
    sub Compare
    {
        my ($key1, $key2) = @_ ;
        &quot;\L$key1&quot; cmp &quot;\L$key2&quot; ;
    }
    # specify the Perl sub that will do the comparison
    $DB_BTREE-&gt;{'compare'} = \&amp;Compare ;
    unlink &quot;tree&quot; ;
    tie %h, &quot;DB_File&quot;, &quot;tree&quot;, O_RDWR|O_CREAT, 0666, $DB_BTREE
        or die &quot;Cannot open file 'tree': $!\n&quot; ;
    # Add a key/value pair to the file
    $h{'Wall'} = 'Larry' ;
    $h{'Smith'} = 'John' ;
    $h{'mouse'} = 'mickey' ;
    $h{'duck'}  = 'donald' ;
    # Delete
    delete $h{&quot;duck&quot;} ;
    # Cycle through the keys printing them in order.
    # Note it is not necessary to sort the keys as
    # the btree will have kept them in order automatically.
    foreach (keys %h)
      { print &quot;$_\n&quot; }
    untie %h ;
</pre>
<p class="Pp">Here is the output from the code above.</p>
<p class="Pp"></p>
<pre>    mouse
    Smith
    Wall
</pre>
<p class="Pp">There are a few point to bear in mind if you want to change the
    ordering in a BTREE database:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>The new compare function must be specified when you create the
    database.</dd>
  <dt>2.</dt>
  <dd>You cannot change the ordering once the database has been created. Thus
      you must use the same compare function every time you access the
    database.</dd>
  <dt>3.</dt>
  <dd>Duplicate keys are entirely defined by the comparison function. In the
      case-insensitive example above, the keys: 'KEY' and 'key' would be
      considered duplicates, and assigning to the second one would overwrite the
      first. If duplicates are allowed for (with the R_DUP flag discussed
      below), only a single copy of duplicate keys is stored in the database ---
      so (again with example above) assigning three values to the keys: 'KEY',
      'Key', and 'key' would leave just the first key: 'KEY' in the database
      with three values. For some situations this results in information loss,
      so care should be taken to provide fully qualified comparison functions
      when necessary. For example, the above comparison routine could be
      modified to additionally compare case-sensitively if two keys are equal in
      the case insensitive comparison:
    <p class="Pp"></p>
    <pre>    sub compare {
        my($key1, $key2) = @_;
        lc $key1 cmp lc $key2 ||
        $key1 cmp $key2;
    }
    </pre>
    <p class="Pp">And now you will only have duplicates when the keys themselves
        are truly the same. (note: in versions of the db library prior to about
        November 1996, such duplicate keys were retained so it was possible to
        recover the original keys in sets of keys that compared as equal).</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Handling_Duplicate_Keys"><a class="permalink" href="#Handling_Duplicate_Keys">Handling
  Duplicate Keys</a></h2>
<p class="Pp">The BTREE file type optionally allows a single key to be
    associated with an arbitrary number of values. This option is enabled by
    setting the flags element of <span class="Li">$DB_BTREE</span> to R_DUP when
    creating the database.</p>
<p class="Pp">There are some difficulties in using the tied hash interface if
    you want to manipulate a BTREE database with duplicate keys. Consider this
    code:</p>
<p class="Pp"></p>
<pre>    use warnings ;
    use strict ;
    use DB_File ;
    my ($filename, %h) ;
    $filename = &quot;tree&quot; ;
    unlink $filename ;
    # Enable duplicate records
    $DB_BTREE-&gt;{'flags'} = R_DUP ;
    tie %h, &quot;DB_File&quot;, $filename, O_RDWR|O_CREAT, 0666, $DB_BTREE
        or die &quot;Cannot open $filename: $!\n&quot;;
    # Add some key/value pairs to the file
    $h{'Wall'} = 'Larry' ;
    $h{'Wall'} = 'Brick' ; # Note the duplicate key
    $h{'Wall'} = 'Brick' ; # Note the duplicate key and value
    $h{'Smith'} = 'John' ;
    $h{'mouse'} = 'mickey' ;
    # iterate through the associative array
    # and print each key/value pair.
    foreach (sort keys %h)
      { print &quot;$_  -&gt; $h{$_}\n&quot; }
    untie %h ;
</pre>
<p class="Pp">Here is the output:</p>
<p class="Pp"></p>
<pre>    Smith   -&gt; John
    Wall    -&gt; Larry
    Wall    -&gt; Larry
    Wall    -&gt; Larry
    mouse   -&gt; mickey
</pre>
<p class="Pp">As you can see 3 records have been successfully created with key
    <span class="Li">&quot;Wall&quot;</span> - the only thing is, when they are
    retrieved from the database they <i>seem</i> to have the same value, namely
    <span class="Li">&quot;Larry&quot;</span>. The problem is caused by the way
    that the associative array interface works. Basically, when the associative
    array interface is used to fetch the value associated with a given key, it
    will only ever retrieve the first value.</p>
<p class="Pp">Although it may not be immediately obvious from the code above,
    the associative array interface can be used to write values with duplicate
    keys, but it cannot be used to read them back from the database.</p>
<p class="Pp">The way to get around this problem is to use the Berkeley DB API
    method called <span class="Li">&quot;seq&quot;</span>. This method allows
    sequential access to key/value pairs. See &quot;THE API INTERFACE&quot; for
    details of both the <span class="Li">&quot;seq&quot;</span> method and the
    API in general.</p>
<p class="Pp">Here is the script above rewritten using the
    <span class="Li">&quot;seq&quot;</span> API method.</p>
<p class="Pp"></p>
<pre>    use warnings ;
    use strict ;
    use DB_File ;
    my ($filename, $x, %h, $status, $key, $value) ;
    $filename = &quot;tree&quot; ;
    unlink $filename ;
    # Enable duplicate records
    $DB_BTREE-&gt;{'flags'} = R_DUP ;
    $x = tie %h, &quot;DB_File&quot;, $filename, O_RDWR|O_CREAT, 0666, $DB_BTREE
        or die &quot;Cannot open $filename: $!\n&quot;;
    # Add some key/value pairs to the file
    $h{'Wall'} = 'Larry' ;
    $h{'Wall'} = 'Brick' ; # Note the duplicate key
    $h{'Wall'} = 'Brick' ; # Note the duplicate key and value
    $h{'Smith'} = 'John' ;
    $h{'mouse'} = 'mickey' ;
    # iterate through the btree using seq
    # and print each key/value pair.
    $key = $value = 0 ;
    for ($status = $x-&gt;seq($key, $value, R_FIRST) ;
         $status == 0 ;
         $status = $x-&gt;seq($key, $value, R_NEXT) )
      {  print &quot;$key -&gt; $value\n&quot; }
    undef $x ;
    untie %h ;
</pre>
<p class="Pp">that prints:</p>
<p class="Pp"></p>
<pre>    Smith   -&gt; John
    Wall    -&gt; Brick
    Wall    -&gt; Brick
    Wall    -&gt; Larry
    mouse   -&gt; mickey
</pre>
<p class="Pp">This time we have got all the key/value pairs, including the
    multiple values associated with the key
    <span class="Li">&quot;Wall&quot;</span>.</p>
<p class="Pp">To make life easier when dealing with duplicate keys,
    <b>DB_File</b> comes with a few utility methods.</p>
</section>
<section class="Ss">
<h2 class="Ss">The <b>get_dup()</b> Method</h2>
<p class="Pp">The <span class="Li">&quot;get_dup&quot;</span> method assists in
    reading duplicate values from BTREE databases. The method can take the
    following forms:</p>
<p class="Pp"></p>
<pre>    $count = $x-&gt;get_dup($key) ;
    @list  = $x-&gt;get_dup($key) ;
    %list  = $x-&gt;get_dup($key, 1) ;
</pre>
<p class="Pp">In a scalar context the method returns the number of values
    associated with the key, <span class="Li">$key</span>.</p>
<p class="Pp">In list context, it returns all the values which match
    <span class="Li">$key</span>. Note that the values will be returned in an
    apparently random order.</p>
<p class="Pp">In list context, if the second parameter is present and evaluates
    TRUE, the method returns an associative array. The keys of the associative
    array correspond to the values that matched in the BTREE and the values of
    the array are a count of the number of times that particular value occurred
    in the BTREE.</p>
<p class="Pp">So assuming the database created above, we can use
    <span class="Li">&quot;get_dup&quot;</span> like this:</p>
<p class="Pp"></p>
<pre>    use warnings ;
    use strict ;
    use DB_File ;
    my ($filename, $x, %h) ;
    $filename = &quot;tree&quot; ;
    # Enable duplicate records
    $DB_BTREE-&gt;{'flags'} = R_DUP ;
    $x = tie %h, &quot;DB_File&quot;, $filename, O_RDWR|O_CREAT, 0666, $DB_BTREE
        or die &quot;Cannot open $filename: $!\n&quot;;
    my $cnt  = $x-&gt;get_dup(&quot;Wall&quot;) ;
    print &quot;Wall occurred $cnt times\n&quot; ;
    my %hash = $x-&gt;get_dup(&quot;Wall&quot;, 1) ;
    print &quot;Larry is there\n&quot; if $hash{'Larry'} ;
    print &quot;There are $hash{'Brick'} Brick Walls\n&quot; ;
    my @list = sort $x-&gt;get_dup(&quot;Wall&quot;) ;
    print &quot;Wall =&gt;      [@list]\n&quot; ;
    @list = $x-&gt;get_dup(&quot;Smith&quot;) ;
    print &quot;Smith =&gt;     [@list]\n&quot; ;
    @list = $x-&gt;get_dup(&quot;Dog&quot;) ;
    print &quot;Dog =&gt;       [@list]\n&quot; ;
</pre>
<p class="Pp">and it will print:</p>
<p class="Pp"></p>
<pre>    Wall occurred 3 times
    Larry is there
    There are 2 Brick Walls
    Wall =&gt;     [Brick Brick Larry]
    Smith =&gt;    [John]
    Dog =&gt;      []
</pre>
</section>
<section class="Ss">
<h2 class="Ss">The <b>find_dup()</b> Method</h2>
<pre>    $status = $X-&gt;find_dup($key, $value) ;
</pre>
<p class="Pp">This method checks for the existence of a specific key/value pair.
    If the pair exists, the cursor is left pointing to the pair and the method
    returns 0. Otherwise the method returns a non-zero value.</p>
<p class="Pp">Assuming the database from the previous example:</p>
<p class="Pp"></p>
<pre>    use warnings ;
    use strict ;
    use DB_File ;
    my ($filename, $x, %h, $found) ;
    $filename = &quot;tree&quot; ;
    # Enable duplicate records
    $DB_BTREE-&gt;{'flags'} = R_DUP ;
    $x = tie %h, &quot;DB_File&quot;, $filename, O_RDWR|O_CREAT, 0666, $DB_BTREE
        or die &quot;Cannot open $filename: $!\n&quot;;
    $found = ( $x-&gt;find_dup(&quot;Wall&quot;, &quot;Larry&quot;) == 0 ? &quot;&quot; : &quot;not&quot;) ;
    print &quot;Larry Wall is $found there\n&quot; ;
    $found = ( $x-&gt;find_dup(&quot;Wall&quot;, &quot;Harry&quot;) == 0 ? &quot;&quot; : &quot;not&quot;) ;
    print &quot;Harry Wall is $found there\n&quot; ;
    undef $x ;
    untie %h ;
</pre>
<p class="Pp">prints this</p>
<p class="Pp"></p>
<pre>    Larry Wall is  there
    Harry Wall is not there
</pre>
</section>
<section class="Ss">
<h2 class="Ss">The <b>del_dup()</b> Method</h2>
<pre>    $status = $X-&gt;del_dup($key, $value) ;
</pre>
<p class="Pp">This method deletes a specific key/value pair. It returns 0 if
    they exist and have been deleted successfully. Otherwise the method returns
    a non-zero value.</p>
<p class="Pp">Again assuming the existence of the
    <span class="Li">&quot;tree&quot;</span> database</p>
<p class="Pp"></p>
<pre>    use warnings ;
    use strict ;
    use DB_File ;
    my ($filename, $x, %h, $found) ;
    $filename = &quot;tree&quot; ;
    # Enable duplicate records
    $DB_BTREE-&gt;{'flags'} = R_DUP ;
    $x = tie %h, &quot;DB_File&quot;, $filename, O_RDWR|O_CREAT, 0666, $DB_BTREE
        or die &quot;Cannot open $filename: $!\n&quot;;
    $x-&gt;del_dup(&quot;Wall&quot;, &quot;Larry&quot;) ;
    $found = ( $x-&gt;find_dup(&quot;Wall&quot;, &quot;Larry&quot;) == 0 ? &quot;&quot; : &quot;not&quot;) ;
    print &quot;Larry Wall is $found there\n&quot; ;
    undef $x ;
    untie %h ;
</pre>
<p class="Pp">prints this</p>
<p class="Pp"></p>
<pre>    Larry Wall is not there
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Matching_Partial_Keys"><a class="permalink" href="#Matching_Partial_Keys">Matching
  Partial Keys</a></h2>
<p class="Pp">The BTREE interface has a feature which allows partial keys to be
    matched. This functionality is <i>only</i> available when the
    <span class="Li">&quot;seq&quot;</span> method is used along with the
    R_CURSOR flag.</p>
<p class="Pp"></p>
<pre>    $x-&gt;seq($key, $value, R_CURSOR) ;
</pre>
<p class="Pp">Here is the relevant quote from the dbopen man page where it
    defines the use of the R_CURSOR flag with seq:</p>
<p class="Pp"></p>
<pre>    Note, for the DB_BTREE access method, the returned key is not
    necessarily an exact match for the specified key. The returned key
    is the smallest key greater than or equal to the specified key,
    permitting partial key matches and range searches.
</pre>
<p class="Pp">In the example script below, the
    <span class="Li">&quot;match&quot;</span> sub uses this feature to find and
    print the first matching key/value pair given a partial key.</p>
<p class="Pp"></p>
<pre>    use warnings ;
    use strict ;
    use DB_File ;
    use Fcntl ;
    my ($filename, $x, %h, $st, $key, $value) ;
    sub match
    {
        my $key = shift ;
        my $value = 0;
        my $orig_key = $key ;
        $x-&gt;seq($key, $value, R_CURSOR) ;
        print &quot;$orig_key\t-&gt; $key\t-&gt; $value\n&quot; ;
    }
    $filename = &quot;tree&quot; ;
    unlink $filename ;
    $x = tie %h, &quot;DB_File&quot;, $filename, O_RDWR|O_CREAT, 0666, $DB_BTREE
        or die &quot;Cannot open $filename: $!\n&quot;;
    # Add some key/value pairs to the file
    $h{'mouse'} = 'mickey' ;
    $h{'Wall'} = 'Larry' ;
    $h{'Walls'} = 'Brick' ;
    $h{'Smith'} = 'John' ;
    $key = $value = 0 ;
    print &quot;IN ORDER\n&quot; ;
    for ($st = $x-&gt;seq($key, $value, R_FIRST) ;
         $st == 0 ;
         $st = $x-&gt;seq($key, $value, R_NEXT) )
      {  print &quot;$key    -&gt; $value\n&quot; }
    print &quot;\nPARTIAL MATCH\n&quot; ;
    match &quot;Wa&quot; ;
    match &quot;A&quot; ;
    match &quot;a&quot; ;
    undef $x ;
    untie %h ;
</pre>
<p class="Pp">Here is the output:</p>
<p class="Pp"></p>
<pre>    IN ORDER
    Smith -&gt; John
    Wall  -&gt; Larry
    Walls -&gt; Brick
    mouse -&gt; mickey
    PARTIAL MATCH
    Wa -&gt; Wall  -&gt; Larry
    A  -&gt; Smith -&gt; John
    a  -&gt; mouse -&gt; mickey
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DB_RECNO"><a class="permalink" href="#DB_RECNO">DB_RECNO</a></h1>
<p class="Pp">DB_RECNO provides an interface to flat text files. Both variable
    and fixed length records are supported.</p>
<p class="Pp">In order to make RECNO more compatible with Perl, the array offset
    for all RECNO arrays begins at 0 rather than 1 as in Berkeley DB.</p>
<p class="Pp">As with normal Perl arrays, a RECNO array can be accessed using
    negative indexes. The index -1 refers to the last element of the array, -2
    the second last, and so on. Attempting to access an element before the start
    of the array will raise a fatal run-time error.</p>
<section class="Ss">
<h2 class="Ss" id="The_'bval'_Option"><a class="permalink" href="#The_'bval'_Option">The
  'bval' Option</a></h2>
<p class="Pp">The operation of the bval option warrants some discussion. Here is
    the definition of bval from the Berkeley DB 1.85 recno manual page:</p>
<p class="Pp"></p>
<pre>    The delimiting byte to be used to mark  the  end  of  a
    record for variable-length records, and the pad charac-
    ter for fixed-length records.  If no  value  is  speci-
    fied,  newlines  (``\n'')  are  used to mark the end of
    variable-length records and  fixed-length  records  are
    padded with spaces.
</pre>
<p class="Pp">The second sentence is wrong. In actual fact bval will only
    default to <span class="Li">&quot;\n&quot;</span> when the openinfo
    parameter in dbopen is NULL. If a non-NULL openinfo parameter is used at
    all, the value that happens to be in bval will be used. That means you
    always have to specify bval when making use of any of the options in the
    openinfo parameter. This documentation error will be fixed in the next
    release of Berkeley DB.</p>
<p class="Pp">That clarifies the situation with regards Berkeley DB itself. What
    about <b>DB_File</b>? Well, the behavior defined in the quote above is quite
    useful, so <b>DB_File</b> conforms to it.</p>
<p class="Pp">That means that you can specify other options (e.g. cachesize) and
    still have bval default to <span class="Li">&quot;\n&quot;</span> for
    variable length records, and space for fixed length records.</p>
<p class="Pp">Also note that the bval option only allows you to specify a single
    byte as a delimiter.</p>
</section>
<section class="Ss">
<h2 class="Ss">A Simple Example</h2>
<p class="Pp">Here is a simple example that uses RECNO (if you are using a
    version of Perl earlier than 5.004_57 this example won't work -- see
    &quot;Extra RECNO Methods&quot; for a workaround).</p>
<p class="Pp"></p>
<pre>    use warnings ;
    use strict ;
    use DB_File ;
    my $filename = &quot;text&quot; ;
    unlink $filename ;
    my @h ;
    tie @h, &quot;DB_File&quot;, $filename, O_RDWR|O_CREAT, 0666, $DB_RECNO
        or die &quot;Cannot open file 'text': $!\n&quot; ;
    # Add a few key/value pairs to the file
    $h[0] = &quot;orange&quot; ;
    $h[1] = &quot;blue&quot; ;
    $h[2] = &quot;yellow&quot; ;
    push @h, &quot;green&quot;, &quot;black&quot; ;
    my $elements = scalar @h ;
    print &quot;The array contains $elements entries\n&quot; ;
    my $last = pop @h ;
    print &quot;popped $last\n&quot; ;
    unshift @h, &quot;white&quot; ;
    my $first = shift @h ;
    print &quot;shifted $first\n&quot; ;
    # Check for existence of a key
    print &quot;Element 1 Exists with value $h[1]\n&quot; if $h[1] ;
    # use a negative index
    print &quot;The last element is $h[-1]\n&quot; ;
    print &quot;The 2nd last element is $h[-2]\n&quot; ;
    untie @h ;
</pre>
<p class="Pp">Here is the output from the script:</p>
<p class="Pp"></p>
<pre>    The array contains 5 entries
    popped black
    shifted white
    Element 1 Exists with value blue
    The last element is green
    The 2nd last element is yellow
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Extra_"><a class="permalink" href="#Extra_">Extra RECNO
  Methods</a></h2>
<p class="Pp">If you are using a version of Perl earlier than 5.004_57, the tied
    array interface is quite limited. In the example script above
    <span class="Li">&quot;push&quot;</span>,
    <span class="Li">&quot;pop&quot;</span>,
    <span class="Li">&quot;shift&quot;</span>,
    <span class="Li">&quot;unshift&quot;</span> or determining the array length
    will not work with a tied array.</p>
<p class="Pp">To make the interface more useful for older versions of Perl, a
    number of methods are supplied with <b>DB_File</b> to simulate the missing
    array operations. All these methods are accessed via the object returned
    from the tie call.</p>
<p class="Pp">Here are the methods:</p>
<dl class="Bl-tag">
  <dt><b></b><span class="Li"><b>$X</b></span><b>-&gt;push(list) ;</b></dt>
  <dd>Pushes the elements of <span class="Li">&quot;list&quot;</span> to the end
      of the array.</dd>
  <dt><b></b><span class="Li"><b>$value</b></span><b> =
    </b><span class="Li"><b>$X</b></span><b>-&gt;pop ;</b></dt>
  <dd>Removes and returns the last element of the array.</dd>
  <dt><b></b><span class="Li"><b>$X</b></span><b>-&gt;shift</b></dt>
  <dd>Removes and returns the first element of the array.</dd>
  <dt><b></b><span class="Li"><b>$X</b></span><b>-&gt;unshift(list) ;</b></dt>
  <dd>Pushes the elements of <span class="Li">&quot;list&quot;</span> to the
      start of the array.</dd>
  <dt><b></b><span class="Li"><b>$X</b></span><b>-&gt;length</b></dt>
  <dd>Returns the number of elements in the array.</dd>
  <dt><b></b><span class="Li"><b>$X</b></span><b>-&gt;splice(offset, length,
    elements);</b></dt>
  <dd>Returns a splice of the array.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Another_Example"><a class="permalink" href="#Another_Example">Another
  Example</a></h2>
<p class="Pp">Here is a more complete example that makes use of some of the
    methods described above. It also makes use of the API interface directly
    (see &quot;THE API INTERFACE&quot;).</p>
<p class="Pp"></p>
<pre>    use warnings ;
    use strict ;
    my (@h, $H, $file, $i) ;
    use DB_File ;
    use Fcntl ;
    $file = &quot;text&quot; ;
    unlink $file ;
    $H = tie @h, &quot;DB_File&quot;, $file, O_RDWR|O_CREAT, 0666, $DB_RECNO
        or die &quot;Cannot open file $file: $!\n&quot; ;
    # first create a text file to play with
    $h[0] = &quot;zero&quot; ;
    $h[1] = &quot;one&quot; ;
    $h[2] = &quot;two&quot; ;
    $h[3] = &quot;three&quot; ;
    $h[4] = &quot;four&quot; ;
    # Print the records in order.
    #
    # The length method is needed here because evaluating a tied
    # array in a scalar context does not return the number of
    # elements in the array.
    print &quot;\nORIGINAL\n&quot; ;
    foreach $i (0 .. $H-&gt;length - 1) {
        print &quot;$i: $h[$i]\n&quot; ;
    }
    # use the push &amp; pop methods
    $a = $H-&gt;pop ;
    $H-&gt;push(&quot;last&quot;) ;
    print &quot;\nThe last record was [$a]\n&quot; ;
    # and the shift &amp; unshift methods
    $a = $H-&gt;shift ;
    $H-&gt;unshift(&quot;first&quot;) ;
    print &quot;The first record was [$a]\n&quot; ;
    # Use the API to add a new record after record 2.
    $i = 2 ;
    $H-&gt;put($i, &quot;Newbie&quot;, R_IAFTER) ;
    # and a new record before record 1.
    $i = 1 ;
    $H-&gt;put($i, &quot;New One&quot;, R_IBEFORE) ;
    # delete record 3
    $H-&gt;del(3) ;
    # now print the records in reverse order
    print &quot;\nREVERSE\n&quot; ;
    for ($i = $H-&gt;length - 1 ; $i &gt;= 0 ; -- $i)
      { print &quot;$i: $h[$i]\n&quot; }
    # same again, but use the API functions instead
    print &quot;\nREVERSE again\n&quot; ;
    my ($s, $k, $v)  = (0, 0, 0) ;
    for ($s = $H-&gt;seq($k, $v, R_LAST) ;
             $s == 0 ;
             $s = $H-&gt;seq($k, $v, R_PREV))
      { print &quot;$k: $v\n&quot; }
    undef $H ;
    untie @h ;
</pre>
<p class="Pp">and this is what it outputs:</p>
<p class="Pp"></p>
<pre>    ORIGINAL
    0: zero
    1: one
    2: two
    3: three
    4: four
    The last record was [four]
    The first record was [zero]
    REVERSE
    5: last
    4: three
    3: Newbie
    2: one
    1: New One
    0: first
    REVERSE again
    5: last
    4: three
    3: Newbie
    2: one
    1: New One
    0: first
</pre>
<p class="Pp">Notes:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>Rather than iterating through the array, <span class="Li">@h</span> like
      this:
    <p class="Pp"></p>
    <pre>    foreach $i (@h)
    </pre>
    <p class="Pp">it is necessary to use either this:</p>
    <p class="Pp"></p>
    <pre>    foreach $i (0 .. $H-&gt;length - 1)
    </pre>
    <p class="Pp">or this:</p>
    <p class="Pp"></p>
    <pre>    for ($a = $H-&gt;get($k, $v, R_FIRST) ;
         $a == 0 ;
         $a = $H-&gt;get($k, $v, R_NEXT) )
    </pre>
  </dd>
  <dt>2.</dt>
  <dd>Notice that both times the <span class="Li">&quot;put&quot;</span> method
      was used the record index was specified using a variable,
      <span class="Li">$i</span>, rather than the literal value itself. This is
      because <span class="Li">&quot;put&quot;</span> will return the record
      number of the inserted line via that parameter.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="THE_API_INTERFACE"><a class="permalink" href="#THE_API_INTERFACE">THE
  API INTERFACE</a></h1>
<p class="Pp">As well as accessing Berkeley DB using a tied hash or array, it is
    also possible to make direct use of most of the API functions defined in the
    Berkeley DB documentation.</p>
<p class="Pp">To do this you need to store a copy of the object returned from
    the tie.</p>
<p class="Pp"></p>
<pre>        $db = tie %hash, &quot;DB_File&quot;, &quot;filename&quot; ;
</pre>
<p class="Pp">Once you have done that, you can access the Berkeley DB API
    functions as <b>DB_File</b> methods directly like this:</p>
<p class="Pp"></p>
<pre>        $db-&gt;put($key, $value, R_NOOVERWRITE) ;
</pre>
<p class="Pp"><b>Important:</b> If you have saved a copy of the object returned
    from <span class="Li">&quot;tie&quot;</span>, the underlying database file
    will <i>not</i> be closed until both the tied variable is untied and all
    copies of the saved object are destroyed.</p>
<p class="Pp"></p>
<pre>    use DB_File ;
    $db = tie %hash, &quot;DB_File&quot;, &quot;filename&quot;
        or die &quot;Cannot tie filename: $!&quot; ;
    ...
    undef $db ;
    untie %hash ;
</pre>
<p class="Pp">See &quot;The <b>untie()</b> Gotcha&quot; for more details.</p>
<p class="Pp">All the functions defined in dbopen are available except for
    <b>close()</b> and <b>dbopen()</b> itself. The <b>DB_File</b> method
    interface to the supported functions have been implemented to mirror the way
    Berkeley DB works whenever possible. In particular note that:</p>
<ul class="Bl-bullet">
  <li>The methods return a status value. All return 0 on success. All return -1
      to signify an error and set <span class="Li">$!</span> to the exact error
      code. The return code 1 generally (but not always) means that the key
      specified did not exist in the database.
    <p class="Pp">Other return codes are defined. See below and in the Berkeley
        DB documentation for details. The Berkeley DB documentation should be
        used as the definitive source.</p>
  </li>
  <li>Whenever a Berkeley DB function returns data via one of its parameters,
      the equivalent <b>DB_File</b> method does exactly the same.</li>
  <li>If you are careful, it is possible to mix API calls with the tied
      hash/array interface in the same piece of code. Although only a few of the
      methods used to implement the tied interface currently make use of the
      cursor, you should always assume that the cursor has been changed any time
      the tied hash/array interface is used. As an example, this code will
      probably not do what you expect:
    <p class="Pp"></p>
    <pre>    $X = tie %x, 'DB_File', $filename, O_RDWR|O_CREAT, 0777, $DB_BTREE
        or die &quot;Cannot tie $filename: $!&quot; ;
    # Get the first key/value pair and set  the cursor
    $X-&gt;seq($key, $value, R_FIRST) ;
    # this line will modify the cursor
    $count = scalar keys %x ;
    # Get the second key/value pair.
    # oops, it didn't, it got the last key/value pair!
    $X-&gt;seq($key, $value, R_NEXT) ;
    </pre>
    <p class="Pp">The code above can be rearranged to get around the problem,
        like this:</p>
    <p class="Pp"></p>
    <pre>    $X = tie %x, 'DB_File', $filename, O_RDWR|O_CREAT, 0777, $DB_BTREE
        or die &quot;Cannot tie $filename: $!&quot; ;
    # this line will modify the cursor
    $count = scalar keys %x ;
    # Get the first key/value pair and set  the cursor
    $X-&gt;seq($key, $value, R_FIRST) ;
    # Get the second key/value pair.
    # worked this time.
    $X-&gt;seq($key, $value, R_NEXT) ;
    </pre>
  </li>
</ul>
<p class="Pp">All the constants defined in dbopen for use in the flags
    parameters in the methods defined below are also available. Refer to the
    Berkeley DB documentation for the precise meaning of the flags values.</p>
<p class="Pp">Below is a list of the methods available.</p>
<dl class="Bl-tag">
  <dt><b></b><span class="Li"><b>$status</b></span><b> =
    </b><span class="Li"><b>$X</b></span><b>-&gt;get($key,
    </b><span class="Li"><b>$value</b></span><b> [,
    </b><span class="Li"><b>$flags</b></span><b>]) ;</b></dt>
  <dd>Given a key (<span class="Li">$key</span>) this method reads the value
      associated with it from the database. The value read from the database is
      returned in the <span class="Li">$value</span> parameter.
    <p class="Pp">If the key does not exist the method returns 1.</p>
    <p class="Pp">No flags are currently defined for this method.</p>
  </dd>
  <dt><b></b><span class="Li"><b>$status</b></span><b> =
    </b><span class="Li"><b>$X</b></span><b>-&gt;put($key,
    </b><span class="Li"><b>$value</b></span><b> [,
    </b><span class="Li"><b>$flags</b></span><b>]) ;</b></dt>
  <dd>Stores the key/value pair in the database.
    <p class="Pp">If you use either the R_IAFTER or R_IBEFORE flags, the
        <span class="Li">$key</span> parameter will have the record number of
        the inserted key/value pair set.</p>
    <p class="Pp">Valid flags are R_CURSOR, R_IAFTER, R_IBEFORE, R_NOOVERWRITE
        and R_SETCURSOR.</p>
  </dd>
  <dt><b></b><span class="Li"><b>$status</b></span><b> =
    </b><span class="Li"><b>$X</b></span><b>-&gt;del($key [,
    </b><span class="Li"><b>$flags</b></span><b>]) ;</b></dt>
  <dd>Removes all key/value pairs with key <span class="Li">$key</span> from the
      database.
    <p class="Pp">A return code of 1 means that the requested key was not in the
        database.</p>
    <p class="Pp">R_CURSOR is the only valid flag at present.</p>
  </dd>
  <dt><b></b><span class="Li"><b>$status</b></span><b> =
    </b><span class="Li"><b>$X</b></span><b>-&gt;fd ;</b></dt>
  <dd>Returns the file descriptor for the underlying database.
    <p class="Pp">See &quot;Locking: The Trouble with fd&quot; for an
        explanation for why you should not use
        <span class="Li">&quot;fd&quot;</span> to lock your database.</p>
  </dd>
  <dt><b></b><span class="Li"><b>$status</b></span><b> =
    </b><span class="Li"><b>$X</b></span><b>-&gt;seq($key,
    </b><span class="Li"><b>$value</b></span><b>,
    </b><span class="Li"><b>$flags</b></span><b>) ;</b></dt>
  <dd>This interface allows sequential retrieval from the database. See dbopen
      for full details.
    <p class="Pp">Both the <span class="Li">$key</span> and
        <span class="Li">$value</span> parameters will be set to the key/value
        pair read from the database.</p>
    <p class="Pp">The flags parameter is mandatory. The valid flag values are
        R_CURSOR, R_FIRST, R_LAST, R_NEXT and R_PREV.</p>
  </dd>
  <dt><b></b><span class="Li"><b>$status</b></span><b> =
    </b><span class="Li"><b>$X</b></span><b>-&gt;sync([$flags]) ;</b></dt>
  <dd>Flushes any cached buffers to disk.
    <p class="Pp">R_RECNOSYNC is the only valid flag at present.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="DBM_FILTERS"><a class="permalink" href="#DBM_FILTERS">DBM
  FILTERS</a></h1>
<p class="Pp">A DBM Filter is a piece of code that is be used when you
    <i>always</i> want to make the same transformation to all keys and/or values
    in a DBM database. An example is when you need to encode your data in UTF-8
    before writing to the database and then decode the UTF-8 when reading from
    the database file.</p>
<p class="Pp">There are two ways to use a DBM Filter.</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>Using the low-level API defined below.</dd>
  <dt>2.</dt>
  <dd>Using the DBM_Filter module. This module hides the complexity of the API
      defined below and comes with a number of &quot;canned&quot; filters that
      cover some of the common use-cases.</dd>
</dl>
<p class="Pp">Use of the DBM_Filter module is recommended.</p>
<section class="Ss">
<h2 class="Ss">DBM Filter Low-level API</h2>
<p class="Pp">There are four methods associated with DBM Filters. All work
    identically, and each is used to install (or uninstall) a single DBM Filter.
    Each expects a single parameter, namely a reference to a sub. The only
    difference between them is the place that the filter is installed.</p>
<p class="Pp">To summarise:</p>
<dl class="Bl-tag">
  <dt id="filter_store_key"><a class="permalink" href="#filter_store_key"><b>filter_store_key</b></a></dt>
  <dd>If a filter has been installed with this method, it will be invoked every
      time you write a key to a DBM database.</dd>
  <dt id="filter_store_value"><a class="permalink" href="#filter_store_value"><b>filter_store_value</b></a></dt>
  <dd>If a filter has been installed with this method, it will be invoked every
      time you write a value to a DBM database.</dd>
  <dt id="filter_fetch_key"><a class="permalink" href="#filter_fetch_key"><b>filter_fetch_key</b></a></dt>
  <dd>If a filter has been installed with this method, it will be invoked every
      time you read a key from a DBM database.</dd>
  <dt id="filter_fetch_value"><a class="permalink" href="#filter_fetch_value"><b>filter_fetch_value</b></a></dt>
  <dd>If a filter has been installed with this method, it will be invoked every
      time you read a value from a DBM database.</dd>
</dl>
<p class="Pp">You can use any combination of the methods, from none, to all
    four.</p>
<p class="Pp">All filter methods return the existing filter, if present, or
    <span class="Li">&quot;undef&quot;</span> in not.</p>
<p class="Pp">To delete a filter pass <span class="Li">&quot;undef&quot;</span>
    to it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Filter"><a class="permalink" href="#The_Filter">The
  Filter</a></h2>
<p class="Pp">When each filter is called by Perl, a local copy of
    <span class="Li">$_</span> will contain the key or value to be filtered.
    Filtering is achieved by modifying the contents of
    <span class="Li">$_</span>. The return code from the filter is ignored.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="An_Example_--_the_"><a class="permalink" href="#An_Example_--_the_">An
  Example -- the NULL termination problem.</a></h2>
<p class="Pp">Consider the following scenario. You have a DBM database that you
    need to share with a third-party C application. The C application assumes
    that <i>all</i> keys and values are NULL terminated. Unfortunately when Perl
    writes to DBM databases it doesn't use NULL termination, so your Perl
    application will have to manage NULL termination itself. When you write to
    the database you will have to use something like this:</p>
<p class="Pp"></p>
<pre>    $hash{&quot;$key\0&quot;} = &quot;$value\0&quot; ;
</pre>
<p class="Pp">Similarly the NULL needs to be taken into account when you are
    considering the length of existing keys/values.</p>
<p class="Pp">It would be much better if you could ignore the NULL terminations
    issue in the main application code and have a mechanism that automatically
    added the terminating NULL to all keys and values whenever you write to the
    database and have them removed when you read from the database. As I'm sure
    you have already guessed, this is a problem that DBM Filters can fix very
    easily.</p>
<p class="Pp"></p>
<pre>    use warnings ;
    use strict ;
    use DB_File ;
    my %hash ;
    my $filename = &quot;filt&quot; ;
    unlink $filename ;
    my $db = tie %hash, 'DB_File', $filename, O_CREAT|O_RDWR, 0666, $DB_HASH
      or die &quot;Cannot open $filename: $!\n&quot; ;
    # Install DBM Filters
    $db-&gt;filter_fetch_key  ( sub { s/\0$//    } ) ;
    $db-&gt;filter_store_key  ( sub { $_ .= &quot;\0&quot; } ) ;
    $db-&gt;filter_fetch_value( sub { s/\0$//    } ) ;
    $db-&gt;filter_store_value( sub { $_ .= &quot;\0&quot; } ) ;
    $hash{&quot;abc&quot;} = &quot;def&quot; ;
    my $a = $hash{&quot;ABC&quot;} ;
    # ...
    undef $db ;
    untie %hash ;
</pre>
<p class="Pp">Hopefully the contents of each of the filters should be
    self-explanatory. Both &quot;fetch&quot; filters remove the terminating
    NULL, and both &quot;store&quot; filters add a terminating NULL.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Another_Example_--_Key_is_a_C_int."><a class="permalink" href="#Another_Example_--_Key_is_a_C_int.">Another
  Example -- Key is a C int.</a></h2>
<p class="Pp">Here is another real-life example. By default, whenever Perl
    writes to a DBM database it always writes the key and value as strings. So
    when you use this:</p>
<p class="Pp"></p>
<pre>    $hash{12345} = &quot;something&quot; ;
</pre>
<p class="Pp">the key 12345 will get stored in the DBM database as the 5 byte
    string &quot;12345&quot;. If you actually want the key to be stored in the
    DBM database as a C int, you will have to use
    <span class="Li">&quot;pack&quot;</span> when writing, and
    <span class="Li">&quot;unpack&quot;</span> when reading.</p>
<p class="Pp">Here is a DBM Filter that does it:</p>
<p class="Pp"></p>
<pre>    use warnings ;
    use strict ;
    use DB_File ;
    my %hash ;
    my $filename = &quot;filt&quot; ;
    unlink $filename ;
    my $db = tie %hash, 'DB_File', $filename, O_CREAT|O_RDWR, 0666, $DB_HASH
      or die &quot;Cannot open $filename: $!\n&quot; ;
    $db-&gt;filter_fetch_key  ( sub { $_ = unpack(&quot;i&quot;, $_) } ) ;
    $db-&gt;filter_store_key  ( sub { $_ = pack (&quot;i&quot;, $_) } ) ;
    $hash{123} = &quot;def&quot; ;
    # ...
    undef $db ;
    untie %hash ;
</pre>
<p class="Pp">This time only two filters have been used -- we only need to
    manipulate the contents of the key, so it wasn't necessary to install any
    value filters.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="HINTS_AND_TIPS"><a class="permalink" href="#HINTS_AND_TIPS">HINTS
  AND TIPS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Locking:_The_Trouble_with_fd"><a class="permalink" href="#Locking:_The_Trouble_with_fd">Locking:
  The Trouble with fd</a></h2>
<p class="Pp">Until version 1.72 of this module, the recommended technique for
    locking <b>DB_File</b> databases was to flock the filehandle returned from
    the &quot;fd&quot; function. Unfortunately this technique has been shown to
    be fundamentally flawed (Kudos to David Harris for tracking this down). Use
    it at your own peril!</p>
<p class="Pp">The locking technique went like this.</p>
<p class="Pp"></p>
<pre>    $db = tie(%db, 'DB_File', 'foo.db', O_CREAT|O_RDWR, 0644)
        || die &quot;dbcreat foo.db $!&quot;;
    $fd = $db-&gt;fd;
    open(DB_FH, &quot;+&lt;&amp;=$fd&quot;) || die &quot;dup $!&quot;;
    flock (DB_FH, LOCK_EX) || die &quot;flock: $!&quot;;
    ...
    $db{&quot;Tom&quot;} = &quot;Jerry&quot; ;
    ...
    flock(DB_FH, LOCK_UN);
    undef $db;
    untie %db;
    close(DB_FH);
</pre>
<p class="Pp">In simple terms, this is what happens:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>Use &quot;tie&quot; to open the database.</dd>
  <dt>2.</dt>
  <dd>Lock the database with fd &amp; flock.</dd>
  <dt>3.</dt>
  <dd>Read &amp; Write to the database.</dd>
  <dt>4.</dt>
  <dd>Unlock and close the database.</dd>
</dl>
<p class="Pp">Here is the crux of the problem. A side-effect of opening the
    <b>DB_File</b> database in step 2 is that an initial block from the database
    will get read from disk and cached in memory.</p>
<p class="Pp">To see why this is a problem, consider what can happen when two
    processes, say &quot;A&quot; and &quot;B&quot;, both want to update the same
    <b>DB_File</b> database using the locking steps outlined above. Assume
    process &quot;A&quot; has already opened the database and has a write lock,
    but it hasn't actually updated the database yet (it has finished step 2, but
    not started step 3 yet). Now process &quot;B&quot; tries to open the same
    database - step 1 will succeed, but it will block on step 2 until process
    &quot;A&quot; releases the lock. The important thing to notice here is that
    at this point in time both processes will have cached identical initial
    blocks from the database.</p>
<p class="Pp">Now process &quot;A&quot; updates the database and happens to
    change some of the data held in the initial buffer. Process &quot;A&quot;
    terminates, flushing all cached data to disk and releasing the database
    lock. At this point the database on disk will correctly reflect the changes
    made by process &quot;A&quot;.</p>
<p class="Pp">With the lock released, process &quot;B&quot; can now continue. It
    also updates the database and unfortunately it too modifies the data that
    was in its initial buffer. Once that data gets flushed to disk it will
    overwrite some/all of the changes process &quot;A&quot; made to the
    database.</p>
<p class="Pp">The result of this scenario is at best a database that doesn't
    contain what you expect. At worst the database will corrupt.</p>
<p class="Pp">The above won't happen every time competing process update the
    same <b>DB_File</b> database, but it does illustrate why the technique
    should not be used.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Safe_ways_to_lock_a_database"><a class="permalink" href="#Safe_ways_to_lock_a_database">Safe
  ways to lock a database</a></h2>
<p class="Pp">Starting with version 2.x, Berkeley DB has internal support for
    locking. The companion module to this one, BerkeleyDB
    &lt;https://metacpan.org/pod/BerkeleyDB&gt;, provides an interface to this
    locking functionality. If you are serious about locking Berkeley DB
    databases, I strongly recommend using BerkeleyDB
    &lt;https://metacpan.org/pod/BerkeleyDB&gt;.</p>
<p class="Pp">If using BerkeleyDB &lt;https://metacpan.org/pod/BerkeleyDB&gt;
    isn't an option, there are a number of modules available on CPAN that can be
    used to implement locking. Each one implements locking differently and has
    different goals in mind. It is therefore worth knowing the difference, so
    that you can pick the right one for your application. Here are the three
    locking wrappers:</p>
<dl class="Bl-tag">
  <dt id="Tie::DB_Lock"><a class="permalink" href="#Tie::DB_Lock"><b>Tie::DB_Lock</b></a></dt>
  <dd>A <b>DB_File</b> wrapper which creates copies of the database file for
      read access, so that you have a kind of a multiversioning concurrent read
      system. However, updates are still serial. Use for databases where reads
      may be lengthy and consistency problems may occur.</dd>
  <dt id="Tie::DB_LockFile"><a class="permalink" href="#Tie::DB_LockFile"><b>Tie::DB_LockFile</b></a></dt>
  <dd>A <b>DB_File</b> wrapper that has the ability to lock and unlock the
      database while it is being used. Avoids the tie-before-flock problem by
      simply re-tie-ing the database when you get or drop a lock. Because of the
      flexibility in dropping and re-acquiring the lock in the middle of a
      session, this can be massaged into a system that will work with long
      updates and/or reads if the application follows the hints in the POD
      documentation.</dd>
  <dt id="DB_File::Lock"><a class="permalink" href="#DB_File::Lock"><b>DB_File::Lock</b></a></dt>
  <dd>An extremely lightweight <b>DB_File</b> wrapper that simply flocks a
      lockfile before tie-ing the database and drops the lock after the untie.
      Allows one to use the same lockfile for multiple databases to avoid
      deadlock problems, if desired. Use for databases where updates are reads
      are quick and simple flock locking semantics are enough.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Sharing_Databases_With_C_Applications"><a class="permalink" href="#Sharing_Databases_With_C_Applications">Sharing
  Databases With C Applications</a></h2>
<p class="Pp">There is no technical reason why a Berkeley DB database cannot be
    shared by both a Perl and a C application.</p>
<p class="Pp">The vast majority of problems that are reported in this area boil
    down to the fact that C strings are NULL terminated, whilst Perl strings are
    not. See &quot;DBM FILTERS&quot; for a generic way to work around this
    problem.</p>
<p class="Pp">Here is a real example. Netscape 2.0 keeps a record of the
    locations you visit along with the time you last visited them in a DB_HASH
    database. This is usually stored in the file <i>~/.netscape/history.db</i>.
    The key field in the database is the location string and the value field is
    the time the location was last visited stored as a 4 byte binary value.</p>
<p class="Pp">If you haven't already guessed, the location string is stored with
    a terminating NULL. This means you need to be careful when accessing the
    database.</p>
<p class="Pp">Here is a snippet of code that is loosely based on Tom
    Christiansen's <i>ggh</i> script (available from your nearest CPAN archive
    in <i>authors/id/TOMC/scripts/nshist.gz</i>).</p>
<p class="Pp"></p>
<pre>    use warnings ;
    use strict ;
    use DB_File ;
    use Fcntl ;
    my ($dotdir, $HISTORY, %hist_db, $href, $binary_time, $date) ;
    $dotdir = $ENV{HOME} || $ENV{LOGNAME};
    $HISTORY = &quot;$dotdir/.netscape/history.db&quot;;
    tie %hist_db, 'DB_File', $HISTORY
        or die &quot;Cannot open $HISTORY: $!\n&quot; ;;
    # Dump the complete database
    while ( ($href, $binary_time) = each %hist_db ) {
        # remove the terminating NULL
        $href =~ s/\x00$// ;
        # convert the binary time into a user friendly string
        $date = localtime unpack(&quot;V&quot;, $binary_time);
        print &quot;$date $href\n&quot; ;
    }
    # check for the existence of a specific key
    # remember to add the NULL
    if ( $binary_time = $hist_db{&quot;http://mox.perl.com/\x00&quot;} ) {
        $date = localtime unpack(&quot;V&quot;, $binary_time) ;
        print &quot;Last visited mox.perl.com on $date\n&quot; ;
    }
    else {
        print &quot;Never visited mox.perl.com\n&quot;
    }
    untie %hist_db ;
</pre>
</section>
<section class="Ss">
<h2 class="Ss">The <b>untie()</b> Gotcha</h2>
<p class="Pp">If you make use of the Berkeley DB API, it is <i>very</i> strongly
    recommended that you read &quot;The untie Gotcha&quot; in perltie.</p>
<p class="Pp">Even if you don't currently make use of the API interface, it is
    still worth reading it.</p>
<p class="Pp">Here is an example which illustrates the problem from a
    <b>DB_File</b> perspective:</p>
<p class="Pp"></p>
<pre>    use DB_File ;
    use Fcntl ;
    my %x ;
    my $X ;
    $X = tie %x, 'DB_File', 'tst.fil' , O_RDWR|O_TRUNC
        or die &quot;Cannot tie first time: $!&quot; ;
    $x{123} = 456 ;
    untie %x ;
    tie %x, 'DB_File', 'tst.fil' , O_RDWR|O_CREAT
        or die &quot;Cannot tie second time: $!&quot; ;
    untie %x ;
</pre>
<p class="Pp">When run, the script will produce this error message:</p>
<p class="Pp"></p>
<pre>    Cannot tie second time: Invalid argument at bad.file line 14.
</pre>
<p class="Pp">Although the error message above refers to the second <b>tie()</b>
    statement in the script, the source of the problem is really with the
    <b>untie()</b> statement that precedes it.</p>
<p class="Pp">Having read perltie you will probably have already guessed that
    the error is caused by the extra copy of the tied object stored in
    <span class="Li">$X</span>. If you haven't, then the problem boils down to
    the fact that the <b>DB_File</b> destructor, DESTROY, will not be called
    until <i>all</i> references to the tied object are destroyed. Both the tied
    variable, <span class="Li">%x</span>, and <span class="Li">$X</span> above
    hold a reference to the object. The call to <b>untie()</b> will destroy the
    first, but <span class="Li">$X</span> still holds a valid reference, so the
    destructor will not get called and the database file <i>tst.fil</i> will
    remain open. The fact that Berkeley DB then reports the attempt to open a
    database that is already open via the catch-all &quot;Invalid argument&quot;
    doesn't help.</p>
<p class="Pp">If you run the script with the
    <span class="Li">&quot;-w&quot;</span> flag the error message becomes:</p>
<p class="Pp"></p>
<pre>    untie attempted while 1 inner references still exist at bad.file line 12.
    Cannot tie second time: Invalid argument at bad.file line 14.
</pre>
<p class="Pp">which pinpoints the real problem. Finally the script can now be
    modified to fix the original problem by destroying the API object before the
    untie:</p>
<p class="Pp"></p>
<pre>    ...
    $x{123} = 456 ;
    undef $X ;
    untie %x ;
    $X = tie %x, 'DB_File', 'tst.fil' , O_RDWR|O_CREAT
    ...
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="COMMON_QUESTIONS"><a class="permalink" href="#COMMON_QUESTIONS">COMMON
  QUESTIONS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Why_is_there_Perl_source_in_my_database?"><a class="permalink" href="#Why_is_there_Perl_source_in_my_database?">Why
  is there Perl source in my database?</a></h2>
<p class="Pp">If you look at the contents of a database file created by DB_File,
    there can sometimes be part of a Perl script included in it.</p>
<p class="Pp">This happens because Berkeley DB uses dynamic memory to allocate
    buffers which will subsequently be written to the database file. Being
    dynamic, the memory could have been used for anything before DB malloced it.
    As Berkeley DB doesn't clear the memory once it has been allocated, the
    unused portions will contain random junk. In the case where a Perl script
    gets written to the database, the random junk will correspond to an area of
    dynamic memory that happened to be used during the compilation of the
    script.</p>
<p class="Pp">Unless you don't like the possibility of there being part of your
    Perl scripts embedded in a database file, this is nothing to worry
  about.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_store_complex_data_structures_with_DB_File?"><a class="permalink" href="#How_do_I_store_complex_data_structures_with_DB_File?">How
  do I store complex data structures with DB_File?</a></h2>
<p class="Pp">Although <b>DB_File</b> cannot do this directly, there is a module
    which can layer transparently over <b>DB_File</b> to accomplish this
  feat.</p>
<p class="Pp">Check out the MLDBM module, available on CPAN in the directory
    <i>modules/by-module/MLDBM</i>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="What_does__wide_character_in_subroutine_entry__mean?"><a class="permalink" href="#What_does__wide_character_in_subroutine_entry__mean?">What
  does &quot;wide character in subroutine entry&quot; mean?</a></h2>
<p class="Pp">You will usually get this message if you are working with UTF-8
    data and want to read/write it from/to a Berkeley DB database file.</p>
<p class="Pp">The easist way to deal with this issue is to use the pre-defined
    &quot;utf8&quot; <b>DBM_Filter</b> (see DBM_Filter) that was designed to
    deal with this situation.</p>
<p class="Pp">The example below shows what you need if <i>both</i> the key and
    value are expected to be in UTF-8.</p>
<p class="Pp"></p>
<pre>    use DB_File;
    use DBM_Filter;
    my $db = tie %h, 'DB_File', '/tmp/try.db', O_CREAT|O_RDWR, 0666, $DB_BTREE;
    $db-&gt;Filter_Key_Push('utf8');
    $db-&gt;Filter_Value_Push('utf8');
    my $key = &quot;\N{LATIN SMALL LETTER A WITH ACUTE}&quot;;
    my $value = &quot;\N{LATIN SMALL LETTER E WITH ACUTE}&quot;;
    $h{ $key } = $value;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="What_does__Invalid_Argument__mean?"><a class="permalink" href="#What_does__Invalid_Argument__mean?">What
  does &quot;Invalid Argument&quot; mean?</a></h2>
<p class="Pp">You will get this error message when one of the parameters in the
    <span class="Li">&quot;tie&quot;</span> call is wrong. Unfortunately there
    are quite a few parameters to get wrong, so it can be difficult to figure
    out which one it is.</p>
<p class="Pp">Here are a couple of possibilities:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>Attempting to reopen a database without closing it.</dd>
  <dt>2.</dt>
  <dd>Using the O_WRONLY flag.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="What_does__Bareword_'DB_File'_not_allowed__mean?"><a class="permalink" href="#What_does__Bareword_'DB_File'_not_allowed__mean?">What
  does &quot;Bareword 'DB_File' not allowed&quot; mean?</a></h2>
<p class="Pp">You will encounter this particular error message when you have the
    <span class="Li">&quot;strict 'subs'&quot;</span> pragma (or the full strict
    pragma) in your script. Consider this script:</p>
<p class="Pp"></p>
<pre>    use warnings ;
    use strict ;
    use DB_File ;
    my %x ;
    tie %x, DB_File, &quot;filename&quot; ;
</pre>
<p class="Pp">Running it produces the error in question:</p>
<p class="Pp"></p>
<pre>    Bareword &quot;DB_File&quot; not allowed while &quot;strict subs&quot; in use
</pre>
<p class="Pp">To get around the error, place the word
    <span class="Li">&quot;DB_File&quot;</span> in either single or double
    quotes, like this:</p>
<p class="Pp"></p>
<pre>    tie %x, &quot;DB_File&quot;, &quot;filename&quot; ;
</pre>
<p class="Pp">Although it might seem like a real pain, it is really worth the
    effort of having a <span class="Li">&quot;use strict&quot;</span> in all
    your scripts.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="REFERENCES"><a class="permalink" href="#REFERENCES">REFERENCES</a></h1>
<p class="Pp">Articles that are either about <b>DB_File</b> or make use of
  it.</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd><i>Full-Text Searching in Perl</i>, Tim Kientzle (tkientzle@ddj.com), Dr.
      Dobb's Journal, Issue 295, January 1999, pp 34-41</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
<p class="Pp">Moved to the Changes file.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">Some older versions of Berkeley DB had problems with fixed length
    records using the RECNO file format. This problem has been fixed since
    version 1.85 of Berkeley DB.</p>
<p class="Pp">I am sure there are bugs in the code. If you do find any, or can
    suggest any enhancements, I would welcome your comments.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
<p class="Pp">General feedback/questions/bug reports should be sent to
    &lt;https://github.com/pmqs/DB_File/issues&gt; (preferred) or
    &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=DB_File&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AVAILABILITY"><a class="permalink" href="#AVAILABILITY">AVAILABILITY</a></h1>
<p class="Pp"><b>DB_File</b> comes with the standard Perl source distribution.
    Look in the directory <i>ext/DB_File</i>. Given the amount of time between
    releases of Perl the version that ships with Perl is quite likely to be out
    of date, so the most recent version can always be found on CPAN (see
    &quot;CPAN&quot; in perlmodlib for details), in the directory
    <i>modules/by-module/DB_File</i>.</p>
<p class="Pp"><b>DB_File</b> is designed to work with any version of Berkeley
    DB, but is limited to the functionality provided by version 1. If you want
    to make use of the new features available in Berkeley DB 2.x, or greater,
    use the Perl module BerkeleyDB &lt;https://metacpan.org/pod/BerkeleyDB&gt;
    instead.</p>
<p class="Pp">The official web site for Berkeley DB is
    &lt;http://www.oracle.com/technology/products/berkeley-db/db/index.html&gt;.
    All versions of Berkeley DB are available there.</p>
<p class="Pp">Alternatively, Berkeley DB version 1 is available at your nearest
    CPAN archive in <i>src/misc/db.1.85.tar.gz</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 1995-2020 Paul Marquess. All rights reserved. This
    program is free software; you can redistribute it and/or modify it under the
    same terms as Perl itself.</p>
<p class="Pp">Although <b>DB_File</b> is covered by the Perl license, the
    library it makes use of, namely Berkeley DB, is not. Berkeley DB has its own
    copyright and its own license. Please take the time to read it.</p>
<p class="Pp">Here are a few words taken from the Berkeley DB FAQ (at
    &lt;http://www.oracle.com/technology/products/berkeley-db/db/index.html&gt;)
    regarding the license:</p>
<p class="Pp"></p>
<pre>    Do I have to license DB to use it in Perl scripts?
    No. The Berkeley DB license requires that software that uses
    Berkeley DB be freely redistributable. In the case of Perl, that
    software is Perl, and not your scripts. Any Perl scripts that you
    write are your property, including scripts that make use of
    Berkeley DB. Neither the Perl license nor the Berkeley DB license
    place any restriction on what you may do with them.
</pre>
<p class="Pp">If you are in any doubt about the license situation, contact
    either the Berkeley DB authors or the author of DB_File. See
    &quot;AUTHOR&quot; for details.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">perl, <b>dbopen</b>(3), <b>hash</b>(3), <b>recno</b>(3),
    <b>btree</b>(3), perldbmfilter, DBM_Filter</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">The DB_File interface was written by Paul Marquess
    &lt;pmqs@cpan.org&gt;.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2023-08-05</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

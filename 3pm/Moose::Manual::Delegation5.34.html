<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Moose::Manual::Delegation(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Moose::Manual::Delegation(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Moose::Manual::Delegation(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Moose::Manual::Delegation - Attribute delegation</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 2.2012</p>
</section>
<section class="Sh">
<h1 class="Sh" id="WHAT_IS_DELEGATION?"><a class="permalink" href="#WHAT_IS_DELEGATION?">WHAT
  IS DELEGATION?</a></h1>
<p class="Pp">Delegation is a feature that lets you create &quot;proxy&quot;
    methods that do nothing more than call some other method on an attribute.
    This lets you simplify a complex set of &quot;has-a&quot; relationships and
    present a single unified API from one class.</p>
<p class="Pp">With delegation, consumers of a class don't need to know about all
    the objects it contains, reducing the amount of API they need to learn.</p>
<p class="Pp">Delegations are defined as a mapping between one or more methods
    provided by the &quot;real&quot; class (the delegatee), and a set of
    corresponding methods in the delegating class. The delegating class can
    re-use the method names provided by the delegatee or provide its own
  names.</p>
<p class="Pp">Delegation is also a great way to wrap an existing class,
    especially a non-Moose class or one that is somehow hard (or impossible) to
    subclass.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DEFINING_A_MAPPING"><a class="permalink" href="#DEFINING_A_MAPPING">DEFINING
  A MAPPING</a></h1>
<p class="Pp">Moose offers a number of options for defining a delegation's
    mapping, ranging from simple to complex.</p>
<p class="Pp">The simplest form is to simply specify a list of methods:</p>
<p class="Pp"></p>
<pre>  package Website;
  use Moose;
  has 'uri' =&gt; (
      is      =&gt; 'ro',
      isa     =&gt; 'URI',
      handles =&gt; [qw( host path )],
  );
</pre>
<p class="Pp">Using an arrayref tells Moose to create methods in your class that
    match the method names in the delegated class.</p>
<p class="Pp">With this definition, we can call
    <span class="Li">&quot;$website-&gt;host&quot;</span> and it &quot;just
    works&quot;. Under the hood, Moose will call
    <span class="Li">&quot;$website-&gt;uri-&gt;host&quot;</span> for you. Note
    that <span class="Li">$website</span> is <i>not</i> automatically passed to
    the <span class="Li">&quot;host&quot;</span> method; the invocant is
    <span class="Li">&quot;$website-&gt;uri&quot;</span>.</p>
<p class="Pp">We can also define a mapping as a hash reference. This allows you
    to rename methods as part of the mapping:</p>
<p class="Pp"></p>
<pre>  package Website;
  use Moose;
  has 'uri' =&gt; (
      is      =&gt; 'ro',
      isa     =&gt; 'URI',
      handles =&gt; {
          hostname =&gt; 'host',
          path     =&gt; 'path',
      },
  );
</pre>
<p class="Pp">Using a hash tells Moose to create method names (specified on the
    left) which invoke the delegated class methods (specified on the right).</p>
<p class="Pp">In this example, we've created a
    <span class="Li">&quot;$website-&gt;hostname&quot;</span> method, rather
    than simply using <span class="Li">&quot;URI.pm&quot;</span>'s name,
    <span class="Li">&quot;host&quot;</span> in the Website class.</p>
<p class="Pp">These two mapping forms are the ones you will use most often. The
    remaining methods are a bit more complex.</p>
<p class="Pp"></p>
<pre>  has 'uri' =&gt; (
      is      =&gt; 'ro',
      isa     =&gt; 'URI',
      handles =&gt; qr/^(?:host|path|query.*)/,
  );
</pre>
<p class="Pp">This is similar to the array version, except it uses the regex to
    match against all the methods provided by the delegatee. In order for this
    to work, you must provide an <span class="Li">&quot;isa&quot;</span>
    parameter for the attribute, and it must be a class. Moose uses this to
    introspect the delegatee class and determine what methods it provides.</p>
<p class="Pp">You can use a role name as the value of
    <span class="Li">&quot;handles&quot;</span>:</p>
<p class="Pp"></p>
<pre>  has 'uri' =&gt; (
      is      =&gt; 'ro',
      isa     =&gt; 'URI',
      handles =&gt; 'HasURI',
  );
</pre>
<p class="Pp">Moose will introspect the role to determine what methods it
    provides and create a name-for-name mapping for each of those methods.</p>
<p class="Pp">Finally, you can provide a sub reference to <i>generate</i> a
    mapping that behaves like the hash example above. You probably won't need
    this version often (if ever). See the Moose docs for more details on exactly
    how this works.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NATIVE_DELEGATION"><a class="permalink" href="#NATIVE_DELEGATION">NATIVE
  DELEGATION</a></h1>
<p class="Pp">Native delegations allow you to delegate to standard Perl data
    structures as if they were objects.</p>
<p class="Pp"></p>
<pre>  has 'queue' =&gt; (
      traits  =&gt; ['Array'],
      isa     =&gt; 'ArrayRef[Item]',
      default =&gt; sub { [ ] },
      handles =&gt; {
          add_item  =&gt; 'push',
          next_item =&gt; 'shift',
      },
  )
</pre>
<p class="Pp">The <span class="Li">&quot;Array&quot;</span> trait in the
    <span class="Li">&quot;traits&quot;</span> parameter tells Moose that you
    would like to use the set of Array helpers. Moose will then create
    <span class="Li">&quot;add_item&quot;</span> and
    <span class="Li">&quot;next_item&quot;</span> methods that &quot;just
    work&quot;. Behind the scenes <span class="Li">&quot;add_item&quot;</span>
    is something like</p>
<p class="Pp"></p>
<pre>  sub add_item {
      my ($self, @items) = @_;
      for my $item (@items) {
          $Item_TC-&gt;validate($item);
      }
      push @{ $self-&gt;queue }, @items;
  }
</pre>
<p class="Pp">For example, you might use Array helpers to add
    <span class="Li">&quot;add_task&quot;</span> and
    <span class="Li">&quot;add_appointment&quot;</span> methods to a Calendar
    class:</p>
<p class="Pp"></p>
<pre>  has 'tasks' =&gt; (
      traits =&gt; ['Array'],
      isa =&gt; 'ArrayRef[Task]',
      default =&gt; sub { [ ] },
      handles =&gt; {
          add_task  =&gt; 'push',
          next_task =&gt; 'shift',
      },
  );
  has 'appointments' =&gt; (
      traits  =&gt; ['Array'],
      isa =&gt; 'ArrayRef[Appointment]',
      default =&gt; sub { [ ] },
      handles =&gt; {
          add_appointment  =&gt; 'push',
          next_appointment =&gt; 'shift',
      },
  );
</pre>
<p class="Pp">Which you would call as:</p>
<p class="Pp"></p>
<pre>  $calendar-&gt;add_task( $task_obj );
  $calendar-&gt;add_appointment( $appointment_obj );
</pre>
<p class="Pp">As mentioned above, each trait provides a number of methods which
    are summarized below. For more information about each of these provided
    methods see the documentation for that specific trait.</p>
<p class="Pp">Moose includes the following traits for native delegation.</p>
<ul class="Bl-bullet">
  <li>Array
    <p class="Pp">The following methods are provided by the native Array
      trait:</p>
    <p class="Pp">count, is_empty, elements, get, pop, push, shift, unshift,
        splice, first, first_index, grep, map, reduce, sort, sort_in_place,
        shuffle, uniq, join, set, delete, insert, clear, accessor, natatime,
        shallow_clone</p>
  </li>
  <li>Bool
    <p class="Pp">The following methods are provided by the native Bool
      trait:</p>
    <p class="Pp">set, unset, toggle, not</p>
  </li>
  <li>Code
    <p class="Pp">The following methods are provided by the native Code
      trait:</p>
    <p class="Pp">execute, execute_method</p>
  </li>
  <li>Counter
    <p class="Pp">The following methods are provided by the native Counter
        trait:</p>
    <p class="Pp">set, inc, dec, reset</p>
  </li>
  <li>Hash
    <p class="Pp">The following methods are provided by the native Hash
      trait:</p>
    <p class="Pp">get, set, delete, keys, exists, defined, values, kv, elements,
        clear, count, is_empty, accessor, shallow_clone</p>
  </li>
  <li>Number
    <p class="Pp">The following methods are provided by the native Number
      trait:</p>
    <p class="Pp">add, sub, mul, div, mod, abs</p>
  </li>
  <li>String
    <p class="Pp">The following methods are provided by the native String
      trait:</p>
    <p class="Pp">inc, append, prepend, replace, match, chop, chomp, clear,
        length, substr</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="CURRYING"><a class="permalink" href="#CURRYING">CURRYING</a></h1>
<p class="Pp">Currying allows you to create a method with some pre-set
    parameters. You can create a curried delegation method:</p>
<p class="Pp"></p>
<pre>    package Spider;
    use Moose;
    has request =&gt; (
        is      =&gt; 'ro'
        isa     =&gt; 'HTTP::Request',
        handles =&gt; {
            set_user_agent =&gt; [ header =&gt; 'UserAgent' ],
        },
    )
</pre>
<p class="Pp">With this definition, calling
    <span class="Li">&quot;$spider-&gt;set_user_agent('MyClient')&quot;</span>
    will call <span class="Li">&quot;$spider-&gt;request-&gt;header('UserAgent',
    'MyClient')&quot;</span> behind the scenes.</p>
<p class="Pp">Note that with currying, the currying always starts with the first
    parameter to a method (<span class="Li">$_[0]</span>). Any arguments you
    pass to the delegation come after the curried arguments.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MISSING_ATTRIBUTES"><a class="permalink" href="#MISSING_ATTRIBUTES">MISSING
  ATTRIBUTES</a></h1>
<p class="Pp">It is perfectly valid to delegate methods to an attribute which is
    not required or can be undefined. When a delegated method is called, Moose
    will throw a runtime error if the attribute does not contain an object.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Stevan Little &lt;stevan.little@iinteractive.com&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
  <li>Shawn M Moore &lt;code@sartak.org&gt;</li>
  <li>&#x05D9;&#x05D5;&#x05D1;&#x05DC; &#x05E7;&#x05D5;&#x05D2;'&#x05DE;&#x05DF;
      (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Florian Ragwitz &lt;rafl@debian.org&gt;</li>
  <li>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</li>
  <li>Chris Prather &lt;chris@prather.org&gt;</li>
  <li>Matt S Trout &lt;mst@shadowcat.co.uk&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2006 by Infinity Interactive,
  Inc.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-11-22</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Class::Autouse(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Class::Autouse(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Class::Autouse(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Class::Autouse - Run-time load a class the first time you call a
    method in it.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    ##################################################################
    # SAFE FEATURES
    # Debugging (if you go that way) must be set before the first use
    BEGIN {
        $Class::Autouse::DEBUG = 1;
    }
    # Turn on developer mode (always load immediately)
    use Class::Autouse qw{:devel};
    # Load a class on method call
    use Class::Autouse;
    Class::Autouse-&gt;autouse( 'CGI' );
    print CGI-&gt;b('Wow!');
    # Use as a pragma
    use Class::Autouse qw{CGI};
    # Use a whole module tree
    Class::Autouse-&gt;autouse_recursive('Acme');
    # Disable module-existance check, and thus one additional 'stat'
    # per module, at autouse-time if loading modules off a remote
    # network drive such as NFS or SMB.
    # (See below for other performance optimizations.)
    use Class::Autouse qw{:nostat};
    ##################################################################
    # UNSAFE FEATURES
    # Turn on the Super Loader (load all classes on demand)
    use Class::Autouse qw{:superloader};
    # Autouse classes matching a given regular expression
    use Class::Autouse qr/::Test$/;
    # Install a class generator (instead of overriding UNIVERSAL::AUTOLOAD)
    # (See below for a detailed example)
    use Class::Autouse \&amp;my_class_generator;
    # Add a manual callback to UNIVERSAL::AUTOLOAD for syntactic sugar
    Class::Autouse-&gt;sugar(\&amp;my_magic);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><b>Class::Autouse</b> is a runtime class loader that allows you to
    specify classes that will only load when a method of that class is
  called.</p>
<p class="Pp">For large classes or class trees that might not be used during the
    running of a program, such as Date::Manip, this can save you large amounts
    of memory, and decrease the script load time a great deal.</p>
<p class="Pp"><b>Class::Autouse</b> also provides a number of &quot;unsafe&quot;
    features for runtime generation of classes and implementation of syntactic
    sugar. These features make use of (evil) UNIVERSAL::AUTOLOAD hooking, and
    are implemented in this class because these hooks can only be done by a one
    module, and Class::Autouse serves as a useful place to centralise this kind
    of evil :)</p>
<section class="Ss">
<h2 class="Ss" id="Class,_not_Module"><a class="permalink" href="#Class,_not_Module">Class,
  not Module</a></h2>
<p class="Pp">The terminology &quot;class loading&quot; instead of &quot;module
    loading&quot; is used intentionally. Modules will only be loaded if they are
    acting as a class.</p>
<p class="Pp">That is, they will only be loaded during a Class-&gt;method call.
    If you try to use a subroutine directly, say with
    <span class="Li">&quot;Class::method()&quot;</span>, the class will not be
    loaded and a fatal error will mostly likely occur.</p>
<p class="Pp">This limitation is made to allow more powerfull features in other
    areas, because we can focus on just loading the modules, and not have to
    deal with importing.</p>
<p class="Pp">And really, if you are doing OO Perl, you should be avoiding
    importing wherever possible.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Use_as_a_pragma"><a class="permalink" href="#Use_as_a_pragma">Use
  as a pragma</a></h2>
<p class="Pp">Class::Autouse can be used as a pragma, specifying a list of
    classes to load as the arguments. For example</p>
<p class="Pp"></p>
<pre>   use Class::Autouse qw{CGI Data::Manip This::That};
</pre>
<p class="Pp">is equivalent to</p>
<p class="Pp"></p>
<pre>   use Class::Autouse;
   Class::Autouse-&gt;autouse( 'CGI'         );
   Class::Autouse-&gt;autouse( 'Data::Manip' );
   Class::Autouse-&gt;autouse( 'This::That'  );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Developer_Mode"><a class="permalink" href="#Developer_Mode">Developer
  Mode</a></h2>
<p class="Pp"><span class="Li">&quot;Class::Autouse&quot;</span> features a
    developer mode. In developer mode, classes are loaded immediately, just like
    they would be with a normal 'use' statement (although the import sub isn't
    called).</p>
<p class="Pp">This allows error checking to be done while developing, at the
    expense of a larger memory overhead. Developer mode is turned on either with
    the <span class="Li">&quot;devel&quot;</span> method, or using :devel in any
    of the pragma arguments. For example, this would load CGI.pm immediately</p>
<p class="Pp"></p>
<pre>    use Class::Autouse qw{:devel CGI};
</pre>
<p class="Pp">While developer mode is roughly equivalent to just using a normal
    use command, for a large number of modules it lets you use autoloading
    notation, and just comment or uncomment a single line to turn developer mode
    on or off. You can leave it on during development, and turn it off for speed
    reasons when deploying.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Recursive_Loading"><a class="permalink" href="#Recursive_Loading">Recursive
  Loading</a></h2>
<p class="Pp">As an alternative to the super loader, the
    <span class="Li">&quot;autouse_recursive&quot;</span> and
    <span class="Li">&quot;load_recursive&quot;</span> methods can be used to
    autouse or load an entire tree of classes.</p>
<p class="Pp">For example, the following would give you access to all the URI
    related classes installed on the machine.</p>
<p class="Pp"></p>
<pre>    Class::Autouse-&gt;autouse_recursive( 'URI' );
</pre>
<p class="Pp">Please note that the loadings will only occur down a single branch
    of the include path, whichever the top class is located in.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="No-Stat_Mode"><a class="permalink" href="#No-Stat_Mode">No-Stat
  Mode</a></h2>
<p class="Pp">For situations where a module exists on a remote disk or another
    relatively expensive location, you can call
    <span class="Li">&quot;Class::Autouse&quot;</span> with the :nostat param to
    disable initial file existance checking at hook time.</p>
<p class="Pp"></p>
<pre>  # Disable autoload-time file existance checking
  use Class::Autouse qw{:nostat};
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Super_Loader_Mode"><a class="permalink" href="#Super_Loader_Mode">Super
  Loader Mode</a></h2>
<p class="Pp">Turning on the <span class="Li">&quot;Class::Autouse&quot;</span>
    super loader allows you to automatically load <b>ANY</b> class without
    specifying it first. Thus, the following will work and is completely
  legal.</p>
<p class="Pp"></p>
<pre>    use Class::Autouse qw{:superloader};
    print CGI-&gt;b('Wow!');
</pre>
<p class="Pp">The super loader can be turned on with either the
    <span class="Li">&quot;Class::Autouse-&gt;&quot;</span>superloader&gt;
    method, or the <span class="Li">&quot;:superloader&quot;</span> pragma
    argument.</p>
<p class="Pp">Please note that unlike the normal one-at-a-time autoloading, the
    super-loader makes global changes, and so is not completely
  self-contained.</p>
<p class="Pp">It has the potential to cause unintended effects at a distance. If
    you encounter unusual behaviour, revert to autousing one-at-a-time, or use
    the recursive loading.</p>
<p class="Pp">Use of the Super Loader is highly discouraged for widely
    distributed public applications or modules unless unavoidable. <b>Do not
    use</b> just to be lazy and save a few lines of code.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Loading_with_Regular_Expressions"><a class="permalink" href="#Loading_with_Regular_Expressions">Loading
  with Regular Expressions</a></h2>
<p class="Pp">As another alternative to the superloader and recursive loading, a
    compiled regular expression (qr//) can be supplied as a loader. Note that
    this loader implements UNIVERSAL::AUTOLOAD, and has the same side effects as
    the superloader.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Registering_a_Callback_for_Dynamic_Class_Creation"><a class="permalink" href="#Registering_a_Callback_for_Dynamic_Class_Creation">Registering
  a Callback for Dynamic Class Creation</a></h2>
<p class="Pp">If none of the above are sufficient, a CODE reference can be given
    to Class::Autouse. Any attempt to call a method on a missing class will
    launch each registered callback until one returns true.</p>
<p class="Pp">Since overriding UNIVERSAL::AUTOLOAD can be done only once in a
    given Perl application, this feature allows UNIVERSAL::AUTOLOAD to be
    shared. Please use this instead of implementing your own
    UNIVERSAL::AUTOLOAD.</p>
<p class="Pp">See the warnings under the &quot;Super Loader Module&quot; above
    which apply to all of the features which override UNIVERSAL::AUTOLOAD.</p>
<p class="Pp">It is up to the callback to define the class, the details of which
    are beyond the scope of this document. See the example below for a quick
    reference:</p>
<p class="Pp"><i>Callback Example</i></p>
<p class="Pp">Any use of a class like Foo::Wrapper autogenerates that class as a
    proxy around Foo.</p>
<p class="Pp"></p>
<pre>    use Class::Autouse sub {
        my ($class) = @_;
        if ($class =~ /(^.*)::Wrapper/) {
            my $wrapped_class = $1;
            eval &quot;package $class; use Class::AutoloadCAN;&quot;;
            die $@ if $@;
            no strict 'refs';
            *{$class . '::new' } = sub {
                my $class = shift;
                my $proxy = $wrapped_class-&gt;new(@_);
                my $self = bless({proxy =&gt; $proxy},$class);
                return $self;
            };
            *{$class . '::CAN' } = sub {
                my ($obj,$method) = @_;
                my $delegate = $wrapped_class-&gt;can($method);
                return unless $delegate;
                my $delegator = sub {
                    my $self = shift;
                    if (ref($self)) {
                        return $self-&gt;{proxy}-&gt;$method(@_);
                    }
                    else {
                        return $wrapped_class-&gt;$method(@_);
                    }
                };
                return *{ $class . '::' . $method } = $delegator;
            };
            return 1;
        }
        return;
    };
    package Foo;
    sub new { my $class = shift; bless({@_},$class); }
    sub class_method { 123 }
    sub instance_method {
        my ($self,$v) = @_;
        return $v * $self-&gt;some_property
    }
    sub some_property { shift-&gt;{some_property} }
    package main;
    my $x = Foo::Wrapper-&gt;new(
        some_property =&gt; 111,
    );
    print $x-&gt;some_property,&quot;\n&quot;;
    print $x-&gt;instance_method(5),&quot;\n&quot;;
    print Foo::Wrapper-&gt;class_method,&quot;\n&quot;;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="sugar"><a class="permalink" href="#sugar">sugar</a></h2>
<p class="Pp">This method is provided to support &quot;syntactic sugar&quot;:
    allowing the developer to put things into Perl which do not look like
    regular Perl. There are several ways to do this in Perl. Strategies which
    require overriding UNIVERSAL::AUTOLOAD can use this interface instead to
    share that method with the superloader, and with class gnerators.</p>
<p class="Pp">When Perl is unable to find a subroutine/method, and all of the
    class loaders are exhausted, callbacks registered via <b>sugar()</b> are
    called. The callbacks recieve the class name, method name, and parameters of
    the call.</p>
<p class="Pp">If the callback returns nothing, Class::Autouse will continue to
    iterate through other callbacks. The first callback which returns a true
    value will end iteration. That value is expected to be a CODE reference
    which will respond to the AUTOLOAD call.</p>
<p class="Pp">Note: The sugar callback(s) will only be fired by
    UNIVERSAL::AUTOLOAD after all other attempts at loading the class are done,
    and after attempts to use regular AUTOLOAD to handle the method call. It is
    never fired by <b>isa()</b> or <b>can()</b>. It will fire repatedly for the
    same class. To generate classes, use the regular CODE ref support in
    <b>autouse()</b>.</p>
<p class="Pp"><i>Syntactic Sugar Example</i></p>
<p class="Pp"></p>
<pre>    use Class::Autouse;
    Class::Autouse-&gt;sugar(
        sub {
            my $caller = caller(1);
            my ($class,$method,@params) = @_;
            shift @params;
            my @words = ($method,$class,@params);
            my $sentence = join(&quot; &quot;,@words);
            return sub { $sentence };
        }
    );
    $x = trolls have big ugly hairy feet;
    print $x,&quot;\n&quot;;
    # trolls have big ugly hairy feet
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="mod_perl"><a class="permalink" href="#mod_perl">mod_perl</a></h2>
<p class="Pp">The mechanism that
    <span class="Li">&quot;Class::Autouse&quot;</span> uses is not compatible
    with mod_perl. In particular with reloader modules like Apache::Reload.
    <span class="Li">&quot;Class::Autouse&quot;</span> detects the presence of
    mod_perl and acts as normal, but will always load all classes immediately,
    equivalent to having developer mode enabled.</p>
<p class="Pp">This is actually beneficial, as under mod_perl classes should be
    preloaded in the parent mod_perl process anyway, to prevent them having to
    be loaded by the Apache child classes. It also saves HUGE amounts of
  memory.</p>
<p class="Pp">Note that dynamically generated classes and classes loaded via
    regex CANNOT be pre-loaded automatically before forking child processes.
    They will still be loaded on demand, often in the child process. See prefork
    below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="prefork"><a class="permalink" href="#prefork">prefork</a></h2>
<p class="Pp">As with mod_perl,
    <span class="Li">&quot;Class::Autouse&quot;</span> is compatible with the
    prefork module, and all modules specifically autoloaded will be loaded
    before forking correctly, when requested by prefork.</p>
<p class="Pp">Since modules generated via callback or regex cannot be loaded
    automatically by prefork in a generic way, it's advised to use prefork
    directly to load/generate classes when using mod_perl.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Performance_Optimizatons"><a class="permalink" href="#Performance_Optimizatons">Performance
  Optimizatons</a></h2>
<dl class="Bl-tag">
  <dt>:nostat</dt>
  <dd>Described above, this option is useful when the module in question is on
      remote disk.</dd>
  <dt>:noprebless</dt>
  <dd>When set, Class::Autouse presumes that objects which are already blessed
      have their class loaded.
    <p class="Pp">This is true in most cases, but will break if the developer
        intends to reconstitute serialized objects from Data::Dumper, FreezeThaw
        or its cousins, and has configured Class::Autouse to load the involved
        classes just-in-time.</p>
  </dd>
  <dt>:staticisa</dt>
  <dd>When set, presumes that <span class="Li">@ISA</span> will not change for a
      class once it is loaded. The greatest grandparent of a class will be given
      back the original can/isa implementations which are faster than those
      Class::Autouse installs into UNIVERSAL. This is a performance tweak useful
      in most cases, but is left off by default to prevent obscure bugs.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Internal_Debugger"><a class="permalink" href="#The_Internal_Debugger">The
  Internal Debugger</a></h2>
<p class="Pp">Class::Autouse provides an internal debugger, which can be used to
    debug any weird edge cases you might encounter when using it.</p>
<p class="Pp">If the <span class="Li">$Class::Autouse::DEBUG</span> variable is
    true when <span class="Li">&quot;Class::Autouse&quot;</span> is first
    loaded, debugging will be compiled in. This debugging prints output like the
    following to STDOUT.</p>
<p class="Pp"></p>
<pre>    Class::Autouse::autouse_recursive( 'Foo' )
        Class::Autouse::_recursive( 'Foo', 'load' )
            Class::Autouse::load( 'Foo' )
            Class::Autouse::_children( 'Foo' )
            Class::Autouse::load( 'Foo::Bar' )
                Class::Autouse::_file_exists( 'Foo/Bar.pm' )
                Class::Autouse::load -&gt; Loading in Foo/Bar.pm
            Class::Autouse::load( 'Foo::More' )
                etc...
</pre>
<p class="Pp">Please note that because this is optimised out if not used, you
    can no longer (since 1.20) enable debugging at run-time. This decision was
    made to remove a large number of unneeded branching and speed up
  loading.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="autouse_$class,_..."><a class="permalink" href="#autouse_$class,_...">autouse
  $class, ...</a></h2>
<p class="Pp">The autouse method sets one or more classes to be loaded as
    required.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="load_$class"><a class="permalink" href="#load_$class">load
  $class</a></h2>
<p class="Pp">The load method loads one or more classes into memory. This is
    functionally equivalent to using require to load the class list in, except
    that load will detect and remove the autoloading hook from a previously
    autoused class, whereas as use effectively ignore the class, and not load
    it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="devel"><a class="permalink" href="#devel">devel</a></h2>
<p class="Pp">The devel method sets development mode on (argument of 1) or off
    (argument of 0).</p>
<p class="Pp">If any classes have previously been autouse'd and not loaded when
    this method is called, they will be loaded immediately.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="superloader"><a class="permalink" href="#superloader">superloader</a></h2>
<p class="Pp">The superloader method turns on the super loader.</p>
<p class="Pp">Please note that once you have turned the superloader on, it
    cannot be turned off. This is due to code that might be relying on it being
    there not being able to autoload its classes when another piece of code
    decides they don't want it any more, and turns the superloader off.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="class_exists_$class"><a class="permalink" href="#class_exists_$class">class_exists
  $class</a></h2>
<p class="Pp">Handy method when doing the sort of jobs that
    <span class="Li">&quot;Class::Autouse&quot;</span> does. Given a class name,
    it will return true if the class can be loaded ( i.e. in
    <span class="Li">@INC</span> ), false if the class can't be loaded, and
    undef if the class name is invalid.</p>
<p class="Pp">Note that this does not actually load the class, just tests to see
    if it can be loaded. Loading can still fail. For a more comprehensive set of
    methods of this nature, see Class::Inspector.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="autouse_recursive_$class"><a class="permalink" href="#autouse_recursive_$class">autouse_recursive
  $class</a></h2>
<p class="Pp">The same as the <span class="Li">&quot;autouse&quot;</span>
    method, but autouses recursively.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="load_recursive_$class"><a class="permalink" href="#load_recursive_$class">load_recursive
  $class</a></h2>
<p class="Pp">The same as the <span class="Li">&quot;load&quot;</span> method,
    but loads recursively. Great for checking that a large class tree that might
    not always be loaded will load correctly.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
<p class="Pp">Bugs should be always be reported via the CPAN bug tracker at</p>
<p class="Pp">&lt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Class-Autouse&gt;</p>
<p class="Pp">For other issues, or commercial enhancement or support, contact
    the author.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp">Adam Kennedy &lt;cpan@ali.as&gt;</p>
<p class="Pp">Scott Smith &lt;sakoht@cpan.org&gt;</p>
<p class="Pp">Rob Napier &lt;rnapier@employees.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">autoload, autoclass</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 2002 - 2012 Adam Kennedy.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">The full text of the license can be found in the LICENSE file
    included with this module.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2012-02-03</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

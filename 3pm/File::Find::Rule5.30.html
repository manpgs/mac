<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>File::Find::Rule(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">File::Find::Rule(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">File::Find::Rule(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">File::Find::Rule - Alternative interface to File::Find</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
  use File::Find::Rule;
  # find all the subdirectories of a given directory
  my @subdirs = File::Find::Rule-&gt;directory-&gt;in( $directory );

  # find all the .pm files in @INC
  my @files = File::Find::Rule-&gt;file()
                              -&gt;name( '*.pm' )
                              -&gt;in( @INC );

  # as above, but without method chaining
  my $rule =  File::Find::Rule-&gt;new;
  $rule-&gt;file;
  $rule-&gt;name( '*.pm' );
  my @files = $rule-&gt;in( @INC );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">File::Find::Rule is a friendlier interface to File::Find. It
    allows you to build rules which specify the desired files and
  directories.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<dl class="Bl-tag">
  <dt>&quot;new&quot;</dt>
  <dd>A constructor. You need not invoke <span class="Li">&quot;new&quot;</span>
      manually unless you wish to, as each of the rule-making methods will
      auto-create a suitable object if called as class methods.</dd>
</dl>
<section class="Ss">
<h2 class="Ss" id="Matching_Rules"><a class="permalink" href="#Matching_Rules">Matching
  Rules</a></h2>
<dl class="Bl-tag">
  <dt>&quot;name( @patterns )&quot;</dt>
  <dd>Specifies names that should match. May be globs or regular expressions.
    <p class="Pp"></p>
    <pre>
 $set-&gt;name( '*.mp3', '*.ogg' ); # mp3s or oggs
 $set-&gt;name( qr/\.(mp3|ogg)$/ ); # the same as a regex
 $set-&gt;name( 'foo.bar' );        # just things named foo.bar
    </pre>
  </dd>
  <dt id="X"><a class="permalink" href="#X">-X tests</a></dt>
  <dd>Synonyms are provided for each of the -X tests. See &quot;-X&quot; in
      perlfunc for details. None of these methods take arguments.
    <p class="Pp"></p>
    <pre>
  Test | Method               Test |  Method
 ------|-------------        ------|----------------
   -r  |  readable             -R  |  r_readable
   -w  |  writeable            -W  |  r_writeable
   -w  |  writable             -W  |  r_writable
   -x  |  executable           -X  |  r_executable
   -o  |  owned                -O  |  r_owned
       |                           |
   -e  |  exists               -f  |  file
   -z  |  empty                -d  |  directory
   -s  |  nonempty             -l  |  symlink
       |                       -p  |  fifo
   -u  |  setuid               -S  |  socket
   -g  |  setgid               -b  |  block
   -k  |  sticky               -c  |  character
       |                       -t  |  tty
   -M  |  modified                 |
   -A  |  accessed             -T  |  ascii
   -C  |  changed              -B  |  binary
    </pre>
    <p class="Pp">Though some tests are fairly meaningless as binary flags
        (<span class="Li">&quot;modified&quot;</span>,
        <span class="Li">&quot;accessed&quot;</span>,
        <span class="Li">&quot;changed&quot;</span>), they have been included
        for completeness.</p>
    <p class="Pp"></p>
    <pre>
 # find nonempty files
 $rule-&gt;file,
      -&gt;nonempty;
    </pre>
  </dd>
  <dt id="stat"><a class="permalink" href="#stat">stat tests</a></dt>
  <dd>The following <span class="Li">&quot;stat&quot;</span> based methods are
      provided: <span class="Li">&quot;dev&quot;</span>,
      <span class="Li">&quot;ino&quot;</span>,
      <span class="Li">&quot;mode&quot;</span>,
      <span class="Li">&quot;nlink&quot;</span>,
      <span class="Li">&quot;uid&quot;</span>,
      <span class="Li">&quot;gid&quot;</span>,
      <span class="Li">&quot;rdev&quot;</span>,
      <span class="Li">&quot;size&quot;</span>,
      <span class="Li">&quot;atime&quot;</span>,
      <span class="Li">&quot;mtime&quot;</span>,
      <span class="Li">&quot;ctime&quot;</span>,
      <span class="Li">&quot;blksize&quot;</span>, and
      <span class="Li">&quot;blocks&quot;</span>. See &quot;stat&quot; in
      perlfunc for details.
    <p class="Pp">Each of these can take a number of targets, which will follow
        Number::Compare semantics.</p>
    <p class="Pp"></p>
    <pre>
 $rule-&gt;size( 7 );         # exactly 7
 $rule-&gt;size( &quot;&gt;7Ki&quot; );    # larger than 7 * 1024 * 1024 bytes
 $rule-&gt;size( &quot;&gt;=7&quot; )
      -&gt;size( &quot;&lt;=90&quot; );    # between 7 and 90, inclusive
 $rule-&gt;size( 7, 9, 42 );  # 7, 9 or 42
    </pre>
  </dd>
  <dt>&quot;any( @rules )&quot;</dt>
  <dd></dd>
  <dt>&quot;or( @rules )&quot;</dt>
  <dd>Allows shortcircuiting boolean evaluation as an alternative to the default
      and-like nature of combined rules. <span class="Li">&quot;any&quot;</span>
      and <span class="Li">&quot;or&quot;</span> are interchangeable.
    <p class="Pp"></p>
    <pre>
 # find avis, movs, things over 200M and empty files
 $rule-&gt;any( File::Find::Rule-&gt;name( '*.avi', '*.mov' ),
             File::Find::Rule-&gt;size( '&gt;200M' ),
             File::Find::Rule-&gt;file-&gt;empty,
           );
    </pre>
  </dd>
  <dt>&quot;none( @rules )&quot;</dt>
  <dd></dd>
  <dt>&quot;not( @rules )&quot;</dt>
  <dd>Negates a rule. (The inverse of <span class="Li">&quot;any&quot;</span>.)
      <span class="Li">&quot;none&quot;</span> and
      <span class="Li">&quot;not&quot;</span> are interchangeable.
    <p class="Pp"></p>
    <pre>
  # files that aren't 8.3 safe
  $rule-&gt;file
       -&gt;not( $rule-&gt;new-&gt;name( qr/^[^.]{1,8}(\.[^.]{0,3})?$/ ) );
    </pre>
  </dd>
  <dt>&quot;prune&quot;</dt>
  <dd>Traverse no further. This rule always matches.</dd>
  <dt>&quot;discard&quot;</dt>
  <dd>Don't keep this file. This rule always matches.</dd>
  <dt>&quot;exec( \&amp;subroutine( $shortname, $path, $fullname ) )&quot;</dt>
  <dd>Allows user-defined rules. Your subroutine will be invoked with
      <span class="Li">$_</span> set to the current short name, and with
      parameters of the name, the path you're in, and the full relative
      filename.
    <p class="Pp">Return a true value if your rule matched.</p>
    <p class="Pp"></p>
    <pre>
 # get things with long names
 $rules-&gt;exec( sub { length &gt; 20 } );
    </pre>
  </dd>
  <dt>&quot;grep( @specifiers )&quot;</dt>
  <dd>Opens a file and tests it each line at a time.
    <p class="Pp">For each line it evaluates each of the specifiers, stopping at
        the first successful match. A specifier may be a regular expression or a
        subroutine. The subroutine will be invoked with the same parameters as
        an -&gt;exec subroutine.</p>
    <p class="Pp">It is possible to provide a set of negative specifiers by
        enclosing them in anonymous arrays. Should a negative specifier match
        the iteration is aborted and the clause is failed. For example:</p>
    <p class="Pp"></p>
    <pre>
 $rule-&gt;grep( qr/^#!.*\bperl/, [ sub { 1 } ] );
    </pre>
    <p class="Pp">Is a passing clause if the first line of a file looks like a
        perl shebang line.</p>
  </dd>
  <dt>&quot;maxdepth( $level )&quot;</dt>
  <dd>Descend at most <span class="Li">$level</span> (a non-negative integer)
      levels of directories below the starting point.
    <p class="Pp">May be invoked many times per rule, but only the most recent
        value is used.</p>
  </dd>
  <dt>&quot;mindepth( $level )&quot;</dt>
  <dd>Do not apply any tests at levels less than <span class="Li">$level</span>
      (a non-negative integer).</dd>
  <dt>&quot;extras( \%extras )&quot;</dt>
  <dd>Specifies extra values to pass through to
      <span class="Li">&quot;File::File::find&quot;</span> as part of the
      options hash.
    <p class="Pp">For example this allows you to specify following of symlinks
        like so:</p>
    <p class="Pp"></p>
    <pre>
 my $rule = File::Find::Rule-&gt;extras({ follow =&gt; 1 });
    </pre>
    <p class="Pp">May be invoked many times per rule, but only the most recent
        value is used.</p>
  </dd>
  <dt>&quot;relative&quot;</dt>
  <dd>Trim the leading portion of any path found</dd>
  <dt>&quot;canonpath&quot;</dt>
  <dd>Normalize paths found using
      <span class="Li">&quot;File::Spec-&quot;</span>canonpath&gt;. This will
      return paths with a file-seperator that is native to your OS (as
      determined by File::Spec),
    <br/>
     instead of the default <span class="Li">&quot;/&quot;</span>.
    <p class="Pp">For example, this will return
        <span class="Li">&quot;tmp/foobar&quot;</span> on Unix-ish OSes and
        <span class="Li">&quot;tmp\foobar&quot;</span> on Win32.</p>
  </dd>
  <dt>&quot;not_*&quot;</dt>
  <dd>Negated version of the rule. An effective shortand related to ! in the
      procedural interface.
    <p class="Pp"></p>
    <pre>
 $foo-&gt;not_name('*.pl');

 $foo-&gt;not( $foo-&gt;new-&gt;name('*.pl' ) );
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Query_Methods"><a class="permalink" href="#Query_Methods">Query
  Methods</a></h2>
<dl class="Bl-tag">
  <dt>&quot;in( @directories )&quot;</dt>
  <dd>Evaluates the rule, returns a list of paths to matching files and
      directories.</dd>
  <dt>&quot;start( @directories )&quot;</dt>
  <dd>Starts a find across the specified directories. Matching items may then be
      queried using &quot;match&quot;. This allows you to use a rule as an
      iterator.
    <p class="Pp"></p>
    <pre>
 my $rule = File::Find::Rule-&gt;file-&gt;name(&quot;*.jpeg&quot;)-&gt;start( &quot;/web&quot; );
 while ( defined ( my $image = $rule-&gt;match ) ) {
     ...
 }
    </pre>
  </dd>
  <dt>&quot;match&quot;</dt>
  <dd>Returns the next file which matches, false if there are no more.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Extensions"><a class="permalink" href="#Extensions">Extensions</a></h2>
<p class="Pp">Extension modules are available from CPAN in the File::Find::Rule
    namespace. In order to use these extensions either use them directly:</p>
<p class="Pp"></p>
<pre>
 use File::Find::Rule::ImageSize;
 use File::Find::Rule::MMagic;

 # now your rules can use the clauses supplied by the ImageSize and
 # MMagic extension
</pre>
<p class="Pp">or, specify that File::Find::Rule should load them for you:</p>
<p class="Pp"></p>
<pre>
 use File::Find::Rule qw( :ImageSize :MMagic );
</pre>
<p class="Pp">For notes on implementing your own extensions, consult
    File::Find::Rule::Extending</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Further_examples"><a class="permalink" href="#Further_examples">Further
  examples</a></h2>
<dl class="Bl-tag">
  <dt id="Finding"><a class="permalink" href="#Finding">Finding perl
    scripts</a></dt>
  <dd>
    <pre>
 my $finder = File::Find::Rule-&gt;or
  (
   File::Find::Rule-&gt;name( '*.pl' ),
   File::Find::Rule-&gt;exec(
                          sub {
                              if (open my $fh, $_) {
                                  my $shebang = &lt;$fh&gt;;
                                  close $fh;
                                  return $shebang =~ /^#!.*\bperl/;
                              }
                              return 0;
                          } ),
  );
    </pre>
    <p class="Pp">Based upon this message
        http://use.perl.org/comments.pl?sid=7052&amp;cid=10842</p>
  </dd>
  <dt id="ignore"><a class="permalink" href="#ignore">ignore CVS
    directories</a></dt>
  <dd>
    <pre>
 my $rule = File::Find::Rule-&gt;new;
 $rule-&gt;or($rule-&gt;new
                -&gt;directory
                -&gt;name('CVS')
                -&gt;prune
                -&gt;discard,
           $rule-&gt;new);
    </pre>
    <p class="Pp">Note here the use of a null rule. Null rules match anything
        they see, so the effect is to match (and discard) directories called
        'CVS' or to match anything.</p>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TWO_FOR_THE_PRICE_OF_ONE"><a class="permalink" href="#TWO_FOR_THE_PRICE_OF_ONE">TWO
  FOR THE PRICE OF ONE</a></h1>
<p class="Pp">File::Find::Rule also gives you a procedural interface. This is
    documented in File::Find::Rule::Procedural</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTS"><a class="permalink" href="#EXPORTS">EXPORTS</a></h1>
<p class="Pp">&quot;find&quot;, &quot;rule&quot;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="TAINT_MODE_INTERACTION"><a class="permalink" href="#TAINT_MODE_INTERACTION">TAINT
  MODE INTERACTION</a></h1>
<p class="Pp">As of 0.32 File::Find::Rule doesn't capture the current working
    directory in a taint-unsafe manner. File::Find itself still does operations
    that the taint system will flag as insecure but you can use the
    &quot;extras&quot; feature to ask File::Find to internally
    <span class="Li">&quot;untaint&quot;</span> file paths with a regex like
  so:</p>
<p class="Pp"></p>
<pre>
    my $rule = File::Find::Rule-&gt;extras({ untaint =&gt; 1 });
</pre>
<p class="Pp">Please consult File::Find's documentation for
    <span class="Li">&quot;untaint&quot;</span>,
    <span class="Li">&quot;untaint_pattern&quot;</span>, and
    <span class="Li">&quot;untaint_skip&quot;</span> for more information.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">The code makes use of the <span class="Li">&quot;our&quot;</span>
    keyword and as such requires perl version 5.6.0 or newer.</p>
<p class="Pp">Currently it isn't possible to remove a clause from a rule object.
    If this becomes a significant issue it will be addressed.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Richard Clamp &lt;richardc@unixbeard.net&gt; with input gained
    from this use.perl discussion:
  http://use.perl.org/~richardc/journal/6467</p>
<p class="Pp">Additional proofreading and input provided by Kake, Greg
    McCarroll, and Andy Lester andy@petdance.com.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (C) 2002, 2003, 2004, 2006, 2009, 2011 Richard Clamp.
    All Rights Reserved.</p>
<p class="Pp">This module is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">File::Find, Text::Glob, Number::Compare, <b>find</b>(1)</p>
<p class="Pp">If you want to know about the procedural interface, see
    File::Find::Rule::Procedural, and if you have an idea for a neat extension
    File::Find::Rule::Extending</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2015-12-03</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

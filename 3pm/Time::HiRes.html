<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Time::HiRes(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Time::HiRes(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Time::HiRes(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Time::HiRes - High resolution alarm, sleep, gettimeofday, interval
    timers</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
  use Time::HiRes qw( usleep ualarm gettimeofday tv_interval nanosleep
                      clock_gettime clock_getres clock_nanosleep clock
                      stat lstat utime);

  usleep ($microseconds);
  nanosleep ($nanoseconds);

  ualarm ($microseconds);
  ualarm ($microseconds, $interval_microseconds);

  $t0 = [gettimeofday];
  ($seconds, $microseconds) = gettimeofday;

  $elapsed = tv_interval ( $t0, [$seconds, $microseconds]);
  $elapsed = tv_interval ( $t0, [gettimeofday]);
  $elapsed = tv_interval ( $t0 );

  use Time::HiRes qw ( time alarm sleep );

  $now_fractions = time;
  sleep ($floating_seconds);
  alarm ($floating_seconds);
  alarm ($floating_seconds, $floating_interval);

  use Time::HiRes qw( setitimer getitimer );

  setitimer ($which, $floating_seconds, $floating_interval );
  getitimer ($which);

  use Time::HiRes qw( clock_gettime clock_getres clock_nanosleep
                      ITIMER_REAL ITIMER_VIRTUAL ITIMER_PROF
                      ITIMER_REALPROF );

  $realtime   = clock_gettime(CLOCK_REALTIME);
  $resolution = clock_getres(CLOCK_REALTIME);

  clock_nanosleep(CLOCK_REALTIME, 1.5e9);
  clock_nanosleep(CLOCK_REALTIME, time()*1e9 + 10e9, TIMER_ABSTIME);

  my $ticktock = clock();

  use Time::HiRes qw( stat lstat );

  my @stat = stat(&quot;file&quot;);
  my @stat = stat(FH);
  my @stat = lstat(&quot;file&quot;);

  use Time::HiRes qw( utime );
  utime $floating_seconds, $floating_seconds, file...;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The <span class="Li">&quot;Time::HiRes&quot;</span> module
    implements a Perl interface to the
    <span class="Li">&quot;usleep&quot;</span>,
    <span class="Li">&quot;nanosleep&quot;</span>,
    <span class="Li">&quot;ualarm&quot;</span>,
    <span class="Li">&quot;gettimeofday&quot;</span>, and
    <span class="Li">&quot;setitimer&quot;</span>/<span class="Li">&quot;getitimer&quot;</span>
    system calls, in other words, high resolution time and timers. See the
    &quot;EXAMPLES&quot; section below and the test scripts for usage; see your
    system documentation for the description of the underlying
    <span class="Li">&quot;nanosleep&quot;</span> or
    <span class="Li">&quot;usleep&quot;</span>,
    <span class="Li">&quot;ualarm&quot;</span>,
    <span class="Li">&quot;gettimeofday&quot;</span>, and
    <span class="Li">&quot;setitimer&quot;</span>/<span class="Li">&quot;getitimer&quot;</span>
    calls.</p>
<p class="Pp">If your system lacks
    <span class="Li">&quot;gettimeofday()&quot;</span> or an emulation of it you
    don't get <span class="Li">&quot;gettimeofday()&quot;</span> or the
    one-argument form of <span class="Li">&quot;tv_interval()&quot;</span>. If
    your system lacks all of <span class="Li">&quot;nanosleep()&quot;</span>,
    <span class="Li">&quot;usleep()&quot;</span>,
    <span class="Li">&quot;select()&quot;</span>, and
    <span class="Li">&quot;poll&quot;</span>, you don't get
    <span class="Li">&quot;Time::HiRes::usleep()&quot;</span>,
    <span class="Li">&quot;Time::HiRes::nanosleep()&quot;</span>, or
    <span class="Li">&quot;Time::HiRes::sleep()&quot;</span>. If your system
    lacks both <span class="Li">&quot;ualarm()&quot;</span> and
    <span class="Li">&quot;setitimer()&quot;</span> you don't get
    <span class="Li">&quot;Time::HiRes::ualarm()&quot;</span> or
    <span class="Li">&quot;Time::HiRes::alarm()&quot;</span>.</p>
<p class="Pp">If you try to import an unimplemented function in the
    <span class="Li">&quot;use&quot;</span> statement it will fail at compile
    time.</p>
<p class="Pp">If your subsecond sleeping is implemented with
    <span class="Li">&quot;nanosleep()&quot;</span> instead of
    <span class="Li">&quot;usleep()&quot;</span>, you can mix subsecond sleeping
    with signals since <span class="Li">&quot;nanosleep()&quot;</span> does not
    use signals. This, however, is not portable, and you should first check for
    the truth value of <span class="Li">&amp;Time::HiRes::d_nanosleep</span> to
    see whether you have nanosleep, and then carefully read your
    <span class="Li">&quot;nanosleep()&quot;</span> C API documentation for any
    peculiarities.</p>
<p class="Pp">If you are using <span class="Li">&quot;nanosleep&quot;</span> for
    something else than mixing sleeping with signals, give some thought to
    whether Perl is the tool you should be using for work requiring nanosecond
    accuracies.</p>
<p class="Pp">Remember that unless you are working on a <i>hard realtime</i>
    system, any clocks and timers will be imprecise, especially so if you are
    working in a pre-emptive multiuser system. Understand the difference between
    <i>wallclock time</i> and process time (in UNIX-like systems the sum of
    <i>user</i> and <i>system</i> times). Any attempt to sleep for X seconds
    will most probably end up sleeping <b>more</b> than that, but don't be
    surprised if you end up sleeping slightly <b>less</b>.</p>
<p class="Pp">The following functions can be imported from this module. No
    functions are exported by default.</p>
<dl class="Bl-tag">
  <dt id="gettimeofday"><a class="permalink" href="#gettimeofday">gettimeofday
    ()</a></dt>
  <dd>In array context returns a two-element array with the seconds and
      microseconds since the epoch. In scalar context returns floating seconds
      like <span class="Li">&quot;Time::HiRes::time()&quot;</span> (see
    below).</dd>
  <dt id="usleep"><a class="permalink" href="#usleep">usleep ( $useconds
    )</a></dt>
  <dd>Sleeps for the number of microseconds (millionths of a second) specified.
      Returns the number of microseconds actually slept. Can sleep for more than
      one second, unlike the <span class="Li">&quot;usleep&quot;</span> system
      call. Can also sleep for zero seconds, which often works like a <i>thread
      yield</i>. See also
      <span class="Li">&quot;Time::HiRes::usleep()&quot;</span>,
      <span class="Li">&quot;Time::HiRes::sleep()&quot;</span>, and
      <span class="Li">&quot;Time::HiRes::clock_nanosleep()&quot;</span>.
    <p class="Pp">Do not expect <b>usleep()</b> to be exact down to one
        microsecond.</p>
  </dd>
  <dt id="nanosleep"><a class="permalink" href="#nanosleep">nanosleep (
    $nanoseconds )</a></dt>
  <dd>Sleeps for the number of nanoseconds (1e9ths of a second) specified.
      Returns the number of nanoseconds actually slept (accurate only to
      microseconds, the nearest thousand of them). Can sleep for more than one
      second. Can also sleep for zero seconds, which often works like a
      <i>thread yield</i>. See also
      <span class="Li">&quot;Time::HiRes::sleep()&quot;</span>,
      <span class="Li">&quot;Time::HiRes::usleep()&quot;</span>, and
      <span class="Li">&quot;Time::HiRes::clock_nanosleep()&quot;</span>.
    <p class="Pp">Do not expect <b>nanosleep()</b> to be exact down to one
        nanosecond. Getting even accuracy of one thousand nanoseconds is
      good.</p>
  </dd>
  <dt id="ualarm"><a class="permalink" href="#ualarm">ualarm ( $useconds [,
    $interval_useconds ] )</a></dt>
  <dd>Issues a <span class="Li">&quot;ualarm&quot;</span> call; the
      <span class="Li">$interval_useconds</span> is optional and will be zero if
      unspecified, resulting in <span class="Li">&quot;alarm&quot;</span>-like
      behaviour.
    <p class="Pp">Returns the remaining time in the alarm in microseconds, or
        <span class="Li">&quot;undef&quot;</span> if an error occurred.</p>
    <p class="Pp"><b>ualarm</b>(0) will cancel an outstanding
      <b>ualarm()</b>.</p>
    <p class="Pp">Note that the interaction between alarms and sleeps is
        unspecified.</p>
  </dd>
  <dt id="tv_interval"><a class="permalink" href="#tv_interval">tv_interval</a></dt>
  <dd>tv_interval ( <span class="Li">$ref_to_gettimeofday</span> [,
      <span class="Li">$ref_to_later_gettimeofday</span>] )
    <p class="Pp">Returns the floating seconds between the two times, which
        should have been returned by
        <span class="Li">&quot;gettimeofday()&quot;</span>. If the second
        argument is omitted, then the current time is used.</p>
  </dd>
  <dt id="time"><a class="permalink" href="#time">time ()</a></dt>
  <dd>Returns a floating seconds since the epoch. This function can be imported,
      resulting in a nice drop-in replacement for the
      <span class="Li">&quot;time&quot;</span> provided with core Perl; see the
      &quot;EXAMPLES&quot; below.
    <p class="Pp"><b>NOTE 1</b>: This higher resolution timer can return values
        either less or more than the core
        <span class="Li">&quot;time()&quot;</span>, depending on whether your
        platform rounds the higher resolution timer values up, down, or to the
        nearest second to get the core
        <span class="Li">&quot;time()&quot;</span>, but naturally the difference
        should be never more than half a second. See also
        &quot;clock_getres&quot;, if available in your system.</p>
    <p class="Pp"><b>NOTE 2</b>: Since Sunday, September 9th, 2001 at 01:46:40
        AM GMT, when the <span class="Li">&quot;time()&quot;</span> seconds
        since epoch rolled over to 1_000_000_000, the default floating point
        format of Perl and the seconds since epoch have conspired to produce an
        apparent bug: if you print the value of
        <span class="Li">&quot;Time::HiRes::time()&quot;</span> you seem to be
        getting only five decimals, not six as promised (microseconds). Not to
        worry, the microseconds are there (assuming your platform supports such
        granularity in the first place). What is going on is that the default
        floating point format of Perl only outputs 15 digits. In this case that
        means ten digits before the decimal separator and five after. To see the
        microseconds you can use either
        <span class="Li">&quot;printf&quot;</span>/<span class="Li">&quot;sprintf&quot;</span>
        with <span class="Li">&quot;%.6f&quot;</span>, or the
        <span class="Li">&quot;gettimeofday()&quot;</span> function in list
        context, which will give you the seconds and microseconds as two
        separate values.</p>
  </dd>
  <dt id="sleep"><a class="permalink" href="#sleep">sleep ( $floating_seconds
    )</a></dt>
  <dd>Sleeps for the specified amount of seconds. Returns the number of seconds
      actually slept (a floating point value). This function can be imported,
      resulting in a nice drop-in replacement for the
      <span class="Li">&quot;sleep&quot;</span> provided with perl, see the
      &quot;EXAMPLES&quot; below.
    <p class="Pp">Note that the interaction between alarms and sleeps is
        unspecified.</p>
  </dd>
  <dt id="alarm"><a class="permalink" href="#alarm">alarm ( $floating_seconds [,
    $interval_floating_seconds ] )</a></dt>
  <dd>The <span class="Li">&quot;SIGALRM&quot;</span> signal is sent after the
      specified number of seconds. Implemented using
      <span class="Li">&quot;setitimer()&quot;</span> if available,
      <span class="Li">&quot;ualarm()&quot;</span> if not. The
      <span class="Li">$interval_floating_seconds</span> argument is optional
      and will be zero if unspecified, resulting in
      <span class="Li">&quot;alarm()&quot;</span>-like behaviour. This function
      can be imported, resulting in a nice drop-in replacement for the
      <span class="Li">&quot;alarm&quot;</span> provided with perl, see the
      &quot;EXAMPLES&quot; below.
    <p class="Pp">Returns the remaining time in the alarm in seconds, or
        <span class="Li">&quot;undef&quot;</span> if an error occurred.</p>
    <p class="Pp"><b>NOTE 1</b>: With some combinations of operating systems and
        Perl releases <span class="Li">&quot;SIGALRM&quot;</span> restarts
        <span class="Li">&quot;select()&quot;</span>, instead of interrupting
        it. This means that an <span class="Li">&quot;alarm()&quot;</span>
        followed by a <span class="Li">&quot;select()&quot;</span> may together
        take the sum of the times specified for the
        <span class="Li">&quot;alarm()&quot;</span> and the
        <span class="Li">&quot;select()&quot;</span>, not just the time of the
        <span class="Li">&quot;alarm()&quot;</span>.</p>
    <p class="Pp">Note that the interaction between alarms and sleeps is
        unspecified.</p>
  </dd>
  <dt id="setitimer"><a class="permalink" href="#setitimer">setitimer ( $which,
    $floating_seconds [, $interval_floating_seconds ] )</a></dt>
  <dd>Start up an interval timer: after a certain time, a signal ($which)
      arrives, and more signals may keep arriving at certain intervals. To
      disable an &quot;itimer&quot;, use
      <span class="Li">$floating_seconds</span> of zero. If the
      <span class="Li">$interval_floating_seconds</span> is set to zero (or
      unspecified), the timer is disabled <b>after</b> the next delivered
      signal.
    <p class="Pp">Use of interval timers may interfere with
        <span class="Li">&quot;alarm()&quot;</span>,
        <span class="Li">&quot;sleep()&quot;</span>, and
        <span class="Li">&quot;usleep()&quot;</span>. In standard-speak the
        &quot;interaction is unspecified&quot;, which means that <i>anything</i>
        may happen: it may work, it may not.</p>
    <p class="Pp">In scalar context, the remaining time in the timer is
        returned.</p>
    <p class="Pp">In list context, both the remaining time and the interval are
        returned.</p>
    <p class="Pp">There are usually three or four interval timers (signals)
        available: the <span class="Li">$which</span> can be
        <span class="Li">&quot;ITIMER_REAL&quot;</span>,
        <span class="Li">&quot;ITIMER_VIRTUAL&quot;</span>,
        <span class="Li">&quot;ITIMER_PROF&quot;</span>, or
        <span class="Li">&quot;ITIMER_REALPROF&quot;</span>. Note that which
        ones are available depends: true UNIX platforms usually have the first
        three, but only Solaris seems to have
        <span class="Li">&quot;ITIMER_REALPROF&quot;</span> (which is used to
        profile multithreaded programs). Win32 unfortunately does not have
        interval timers.</p>
    <p class="Pp"><span class="Li">&quot;ITIMER_REAL&quot;</span> results in
        <span class="Li">&quot;alarm()&quot;</span>-like behaviour. Time is
        counted in <i>real time</i>; that is, wallclock time.
        <span class="Li">&quot;SIGALRM&quot;</span> is delivered when the timer
        expires.</p>
    <p class="Pp"><span class="Li">&quot;ITIMER_VIRTUAL&quot;</span> counts time
        in (process) <i>virtual time</i>; that is, only when the process is
        running. In multiprocessor/user/CPU systems this may be more or less
        than real or wallclock time. (This time is also known as the <i>user
        time</i>.) <span class="Li">&quot;SIGVTALRM&quot;</span> is delivered
        when the timer expires.</p>
    <p class="Pp"><span class="Li">&quot;ITIMER_PROF&quot;</span> counts time
        when either the process virtual time or when the operating system is
        running on behalf of the process (such as I/O). (This time is also known
        as the <i>system time</i>.) (The sum of user time and system time is
        known as the <i>CPU time</i>.)
        <span class="Li">&quot;SIGPROF&quot;</span> is delivered when the timer
        expires. <span class="Li">&quot;SIGPROF&quot;</span> can interrupt
        system calls.</p>
    <p class="Pp">The semantics of interval timers for multithreaded programs
        are system-specific, and some systems may support additional interval
        timers. For example, it is unspecified which thread gets the signals.
        See your <span class="Li">&quot;setitimer()&quot;</span>
      documentation.</p>
  </dd>
  <dt id="getitimer"><a class="permalink" href="#getitimer">getitimer ( $which
    )</a></dt>
  <dd>Return the remaining time in the interval timer specified by
      <span class="Li">$which</span>.
    <p class="Pp">In scalar context, the remaining time is returned.</p>
    <p class="Pp">In list context, both the remaining time and the interval are
        returned. The interval is always what you put in using
        <span class="Li">&quot;setitimer()&quot;</span>.</p>
  </dd>
  <dt id="clock_gettime"><a class="permalink" href="#clock_gettime">clock_gettime
    ( $which )</a></dt>
  <dd>Return as seconds the current value of the POSIX high resolution timer
      specified by <span class="Li">$which</span>. All implementations that
      support POSIX high resolution timers are supposed to support at least the
      <span class="Li">$which</span> value of
      <span class="Li">&quot;CLOCK_REALTIME&quot;</span>, which is supposed to
      return results close to the results of
      <span class="Li">&quot;gettimeofday&quot;</span>, or the number of seconds
      since 00:00:00:00 January 1, 1970 Greenwich Mean Time (GMT). Do not assume
      that CLOCK_REALTIME is zero, it might be one, or something else. Another
      potentially useful (but not available everywhere) value is
      <span class="Li">&quot;CLOCK_MONOTONIC&quot;</span>, which guarantees a
      monotonically increasing time value (unlike <b>time()</b> or
      <b>gettimeofday()</b>, which can be adjusted). See your system
      documentation for other possibly supported values.</dd>
  <dt id="clock_getres"><a class="permalink" href="#clock_getres">clock_getres (
    $which )</a></dt>
  <dd>Return as seconds the resolution of the POSIX high resolution timer
      specified by <span class="Li">$which</span>. All implementations that
      support POSIX high resolution timers are supposed to support at least the
      <span class="Li">$which</span> value of
      <span class="Li">&quot;CLOCK_REALTIME&quot;</span>, see
      &quot;clock_gettime&quot;.
    <p class="Pp"><b>NOTE</b>: the resolution returned may be highly optimistic.
        Even if the resolution is high (a small number), all it means is that
        you'll be able to specify the arguments to <b>clock_gettime()</b> and
        <b>clock_nanosleep()</b> with that resolution. The system might not
        actually be able to measure events at that resolution, and the various
        overheads and the overall system load are certain to affect any
      timings.</p>
  </dd>
  <dt id="clock_nanosleep"><a class="permalink" href="#clock_nanosleep">clock_nanosleep
    ( $which, $nanoseconds, $flags = 0)</a></dt>
  <dd>Sleeps for the number of nanoseconds (1e9ths of a second) specified.
      Returns the number of nanoseconds actually slept. The
      <span class="Li">$which</span> is the &quot;clock id&quot;, as with
      <b>clock_gettime()</b> and <b>clock_getres()</b>. The flags default to
      zero but <span class="Li">&quot;TIMER_ABSTIME&quot;</span> can specified
      (must be exported explicitly) which means that
      <span class="Li">$nanoseconds</span> is not a time interval (as is the
      default) but instead an absolute time. Can sleep for more than one second.
      Can also sleep for zero seconds, which often works like a <i>thread
      yield</i>. See also
      <span class="Li">&quot;Time::HiRes::sleep()&quot;</span>,
      <span class="Li">&quot;Time::HiRes::usleep()&quot;</span>, and
      <span class="Li">&quot;Time::HiRes::nanosleep()&quot;</span>.
    <p class="Pp">Do not expect <b>clock_nanosleep()</b> to be exact down to one
        nanosecond. Getting even accuracy of one thousand nanoseconds is
      good.</p>
  </dd>
  <dt id="clock()"><a class="permalink" href="#clock()"><b>clock()</b></a></dt>
  <dd>Return as seconds the <i>process time</i> (user + system time) spent by
      the process since the first call to <b>clock()</b> (the definition is
      <b>not</b> &quot;since the start of the process&quot;, though if you are
      lucky these times may be quite close to each other, depending on the
      system). What this means is that you probably need to store the result of
      your first call to <b>clock()</b>, and subtract that value from the
      following results of <b>clock()</b>.
    <p class="Pp">The time returned also includes the process times of the
        terminated child processes for which <b>wait()</b> has been executed.
        This value is somewhat like the second value returned by the
        <b>times()</b> of core Perl, but not necessarily identical. Note that
        due to backward compatibility limitations the returned value may wrap
        around at about 2147 seconds or at about 36 minutes.</p>
  </dd>
  <dt id="stat"><a class="permalink" href="#stat">stat</a></dt>
  <dd></dd>
  <dt>stat FH</dt>
  <dd></dd>
  <dt>stat EXPR</dt>
  <dd></dd>
  <dt id="lstat"><a class="permalink" href="#lstat">lstat</a></dt>
  <dd></dd>
  <dt>lstat FH</dt>
  <dd></dd>
  <dt>lstat EXPR</dt>
  <dd>As &quot;stat&quot; in perlfunc or &quot;lstat&quot; in perlfunc but with
      the access/modify/change file timestamps in subsecond resolution, if the
      operating system and the filesystem both support such timestamps. To
      override the standard <b>stat()</b>:
    <p class="Pp"></p>
    <pre>
    use Time::HiRes qw(stat);
    </pre>
    <p class="Pp">Test for the value of &amp;Time::HiRes::d_hires_stat to find
        out whether the operating system supports subsecond file timestamps: a
        value larger than zero means yes. There are unfortunately no easy ways
        to find out whether the filesystem supports such timestamps. UNIX
        filesystems often do; NTFS does; FAT doesn't (FAT timestamp granularity
        is <b>two</b> seconds).</p>
    <p class="Pp">A zero return value of &amp;Time::HiRes::d_hires_stat means
        that Time::HiRes::stat is a no-op passthrough for <b>CORE::stat()</b>
        (and likewise for lstat), and therefore the timestamps will stay
        integers. The same thing will happen if the filesystem does not do
        subsecond timestamps, even if the &amp;Time::HiRes::d_hires_stat is
        non-zero.</p>
    <p class="Pp">In any case do not expect nanosecond resolution, or even a
        microsecond resolution. Also note that the modify/access timestamps
        might have different resolutions, and that they need not be
        synchronized, e.g. if the operations are</p>
    <p class="Pp"></p>
    <pre>
    write
    stat # t1
    read
    stat # t2
    </pre>
    <p class="Pp">the access time stamp from t2 need not be greater-than the
        modify time stamp from t1: it may be equal or <i>less</i>.</p>
  </dd>
  <dt id="utime"><a class="permalink" href="#utime">utime LIST</a></dt>
  <dd>As &quot;utime&quot; in perlfunc but with the ability to set the
      access/modify file timestamps in subsecond resolution, if the operating
      system and the filesystem, and the mount options of the filesystem, all
      support such timestamps.
    <p class="Pp">To override the standard <b>utime()</b>:</p>
    <p class="Pp"></p>
    <pre>
    use Time::HiRes qw(utime);
    </pre>
    <p class="Pp">Test for the value of &amp;Time::HiRes::d_hires_utime to find
        out whether the operating system supports setting subsecond file
        timestamps.</p>
    <p class="Pp">As with <b>CORE::utime()</b>, passing undef as both the atime
        and mtime will call the syscall with a NULL argument.</p>
    <p class="Pp">The actual achievable subsecond resolution depends on the
        combination of the operating system and the filesystem.</p>
    <p class="Pp">Modifying the timestamps may not be possible at all: for
        example, the <span class="Li">&quot;noatime&quot;</span> filesystem
        mount option may prohibit you from changing the access time
      timestamp.</p>
    <p class="Pp">Returns the number of files successfully changed.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<pre>
  use Time::HiRes qw(usleep ualarm gettimeofday tv_interval);

  $microseconds = 750_000;
  usleep($microseconds);

  # signal alarm in 2.5s &amp; every .1s thereafter
  ualarm(2_500_000, 100_000);
  # cancel that ualarm
  ualarm(0);

  # get seconds and microseconds since the epoch
  ($s, $usec) = gettimeofday();

  # measure elapsed time 
  # (could also do by subtracting 2 gettimeofday return values)
  $t0 = [gettimeofday];
  # do bunch of stuff here
  $t1 = [gettimeofday];
  # do more stuff here
  $t0_t1 = tv_interval $t0, $t1;

  $elapsed = tv_interval ($t0, [gettimeofday]);
  $elapsed = tv_interval ($t0); # equivalent code

  #
  # replacements for time, alarm and sleep that know about
  # floating seconds
  #
  use Time::HiRes;
  $now_fractions = Time::HiRes::time;
  Time::HiRes::sleep (2.5);
  Time::HiRes::alarm (10.6666666);

  use Time::HiRes qw ( time alarm sleep );
  $now_fractions = time;
  sleep (2.5);
  alarm (10.6666666);

  # Arm an interval timer to go off first at 10 seconds and
  # after that every 2.5 seconds, in process virtual time

  use Time::HiRes qw ( setitimer ITIMER_VIRTUAL time );

  $SIG{VTALRM} = sub { print time, &quot;\n&quot; };
  setitimer(ITIMER_VIRTUAL, 10, 2.5);

  use Time::HiRes qw( clock_gettime clock_getres CLOCK_REALTIME );
  # Read the POSIX high resolution timer.
  my $high = clock_gettime(CLOCK_REALTIME);
  # But how accurate we can be, really?
  my $reso = clock_getres(CLOCK_REALTIME);

  use Time::HiRes qw( clock_nanosleep TIMER_ABSTIME );
  clock_nanosleep(CLOCK_REALTIME, 1e6);
  clock_nanosleep(CLOCK_REALTIME, 2e9, TIMER_ABSTIME);

  use Time::HiRes qw( clock );
  my $clock0 = clock();
  ... # Do something.
  my $clock1 = clock();
  my $clockd = $clock1 - $clock0;

  use Time::HiRes qw( stat );
  my ($atime, $mtime, $ctime) = (stat(&quot;istics&quot;))[8, 9, 10];
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="C_API"><a class="permalink" href="#C_API">C API</a></h1>
<p class="Pp">In addition to the perl API described above, a C API is available
    for extension writers. The following C functions are available in the
    modglobal hash:</p>
<p class="Pp"></p>
<pre>
  name             C prototype
  ---------------  ----------------------
  Time::NVtime     NV (*)()
  Time::U2time     void (*)(pTHX_ UV ret[2])
</pre>
<p class="Pp">Both functions return equivalent information (like
    <span class="Li">&quot;gettimeofday&quot;</span>) but with different
    representations. The names <span class="Li">&quot;NVtime&quot;</span> and
    <span class="Li">&quot;U2time&quot;</span> were selected mainly because they
    are operating system independent.
    (<span class="Li">&quot;gettimeofday&quot;</span> is Unix-centric, though
    some platforms like Win32 and VMS have emulations for it.)</p>
<p class="Pp">Here is an example of using
    <span class="Li">&quot;NVtime&quot;</span> from C:</p>
<p class="Pp"></p>
<pre>
  NV (*myNVtime)(); /* Returns -1 on failure. */
  SV **svp = hv_fetchs(PL_modglobal, &quot;Time::NVtime&quot;, 0);
  if (!svp)         croak(&quot;Time::HiRes is required&quot;);
  if (!SvIOK(*svp)) croak(&quot;Time::NVtime isn't a function pointer&quot;);
  myNVtime = INT2PTR(NV(*)(), SvIV(*svp));
  printf(&quot;The current time is: %&quot; NVff &quot;\n&quot;, (*myNVtime)());
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DIAGNOSTICS"><a class="permalink" href="#DIAGNOSTICS">DIAGNOSTICS</a></h1>
<section class="Ss">
<h2 class="Ss" id="useconds_or_interval_more_than_..."><a class="permalink" href="#useconds_or_interval_more_than_...">useconds
  or interval more than ...</a></h2>
<p class="Pp">In <b>ualarm()</b> you tried to use number of microseconds or
    interval (also in microseconds) more than 1_000_000 and <b>setitimer()</b>
    is not available in your system to emulate that case.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="negative_time_not_invented_yet"><a class="permalink" href="#negative_time_not_invented_yet">negative
  time not invented yet</a></h2>
<p class="Pp">You tried to use a negative time argument.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="internal_error:_useconds___0_(unsigned_..._signed_...)"><a class="permalink" href="#internal_error:_useconds___0_(unsigned_..._signed_...)">internal
  error: useconds &lt; 0 (unsigned ... signed ...)</a></h2>
<p class="Pp">Something went horribly wrong-- the number of microseconds that
    cannot become negative just became negative. Maybe your compiler is
  broken?</p>
</section>
<section class="Ss">
<h2 class="Ss" id="useconds_or_uinterval_equal_to_or_more_than_1000000"><a class="permalink" href="#useconds_or_uinterval_equal_to_or_more_than_1000000">useconds
  or uinterval equal to or more than 1000000</a></h2>
<p class="Pp">In some platforms it is not possible to get an alarm with
    subsecond resolution and later than one second.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="unimplemented_in_this_platform"><a class="permalink" href="#unimplemented_in_this_platform">unimplemented
  in this platform</a></h2>
<p class="Pp">Some calls simply aren't available, real or emulated, on every
    platform.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<p class="Pp">Notice that the core <span class="Li">&quot;time()&quot;</span>
    maybe rounding rather than truncating. What this means is that the core
    <span class="Li">&quot;time()&quot;</span> may be reporting the time as one
    second later than <span class="Li">&quot;gettimeofday()&quot;</span> and
    <span class="Li">&quot;Time::HiRes::time()&quot;</span>.</p>
<p class="Pp">Adjusting the system clock (either manually or by services like
    ntp) may cause problems, especially for long running programs that assume a
    monotonously increasing time (note that all platforms do not adjust time as
    gracefully as UNIX ntp does). For example in Win32 (and derived platforms
    like Cygwin and MinGW) the <b>Time::HiRes::time()</b> may temporarily drift
    off from the system clock (and the original <b>time()</b>) by up to 0.5
    seconds. Time::HiRes will notice this eventually and recalibrate. Note that
    since Time::HiRes 1.77 the clock_gettime(CLOCK_MONOTONIC) might help in this
    (in case your system supports CLOCK_MONOTONIC).</p>
<p class="Pp">Some systems have APIs but not implementations: for example QNX
    and Haiku have the interval timer APIs but not the functionality.</p>
<p class="Pp">In pre-Sierra macOS (pre-10.12, OS X) <b>clock_getres()</b>,
    <b>clock_gettime()</b> and <b>clock_nanosleep()</b> are emulated using the
    Mach timers; as a side effect of being emulated the CLOCK_REALTIME and
    CLOCK_MONOTONIC are the same timer.</p>
<p class="Pp">gnukfreebsd seems to have non-functional <b>futimens()</b> and
    <b>utimensat()</b> (at least as of 10.1): therefore the hires <b>utime()</b>
    does not work.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Perl modules BSD::Resource, Time::TAI64.</p>
<p class="Pp">Your system documentation for
    <span class="Li">&quot;clock&quot;</span>,
    <span class="Li">&quot;clock_gettime&quot;</span>,
    <span class="Li">&quot;clock_getres&quot;</span>,
    <span class="Li">&quot;clock_nanosleep&quot;</span>,
    <span class="Li">&quot;clock_settime&quot;</span>,
    <span class="Li">&quot;getitimer&quot;</span>,
    <span class="Li">&quot;gettimeofday&quot;</span>,
    <span class="Li">&quot;setitimer&quot;</span>,
    <span class="Li">&quot;sleep&quot;</span>,
    <span class="Li">&quot;stat&quot;</span>,
    <span class="Li">&quot;ualarm&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp">D. Wegscheid &lt;wegscd@whirlpool.com&gt; R. Schertler
    &lt;roderick@argon.org&gt; J. Hietaniemi &lt;jhi@iki.fi&gt; G. Aas
    &lt;gisle@aas.no&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">Copyright (c) 1996-2002 Douglas E. Wegscheid. All rights
  reserved.</p>
<p class="Pp">Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007, 2008 Jarkko
    Hietaniemi. All rights reserved.</p>
<p class="Pp">Copyright (C) 2011, 2012, 2013 Andrew Main (Zefram)
    &lt;zefram@fysh.org&gt;</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>DBI::ProxyServer(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBI::ProxyServer(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBI::ProxyServer(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">DBI::ProxyServer - a server for the DBD::Proxy driver</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
    use DBI::ProxyServer;
    DBI::ProxyServer::main(@ARGV);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">DBI::Proxy Server is a module for implementing a proxy for the DBI
    proxy driver, DBD::Proxy. It allows access to databases over the network if
    the DBMS does not offer networked operations. But the proxy server might be
    useful for you, even if you have a DBMS with integrated network
    functionality: It can be used as a DBI proxy in a firewalled
  environment.</p>
<p class="Pp">DBI::ProxyServer runs as a daemon on the machine with the DBMS or
    on the firewall. The client connects to the agent using the DBI driver
    DBD::Proxy, thus in the exactly same way than using DBD::mysql, DBD::mSQL or
    any other DBI driver.</p>
<p class="Pp">The agent is implemented as a RPC::PlServer application. Thus you
    have access to all the possibilities of this module, in particular
    encryption and a similar configuration file. DBI::ProxyServer adds the
    possibility of query restrictions: You can define a set of queries that a
    client may execute and restrict access to those. (Requires a DBI driver that
    supports parameter binding.) See &quot;CONFIGURATION FILE&quot;.</p>
<p class="Pp">The provided driver script, dbiproxy, may either be used as it is
    or used as the basis for a local version modified to meet your needs.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OPTIONS"><a class="permalink" href="#OPTIONS">OPTIONS</a></h1>
<p class="Pp">When calling the <i>DBI::ProxyServer::main()</i> function, you
    supply an array of options. These options are parsed by the Getopt::Long
    module. The ProxyServer inherits all of RPC::PlServer's and hence
    Net::Daemon's options and option handling, in particular the ability to read
    options from either the command line or a config file. See RPC::PlServer.
    See Net::Daemon. Available options include</p>
<dl class="Bl-tag">
  <dt id="chroot"><a class="permalink" href="#chroot"><i>chroot</i>
    (<b>--chroot=dir</b>)</a></dt>
  <dd>(UNIX only) After doing a <i>bind()</i>, change root directory to the
      given directory by doing a <i>chroot()</i>. This is useful for security,
      but it restricts the environment a lot. For example, you need to load DBI
      drivers in the config file or you have to create hard links to Unix
      sockets, if your drivers are using them. For example, with MySQL, a config
      file might contain the following lines:
    <p class="Pp"></p>
    <pre>
    my $rootdir = '/var/dbiproxy';
    my $unixsockdir = '/tmp';
    my $unixsockfile = 'mysql.sock';
    foreach $dir ($rootdir, &quot;$rootdir$unixsockdir&quot;) {
        mkdir 0755, $dir;
    }
    link(&quot;$unixsockdir/$unixsockfile&quot;,
         &quot;$rootdir$unixsockdir/$unixsockfile&quot;);
    require DBD::mysql;

    {
        'chroot' =&gt; $rootdir,
        ...
    }
    </pre>
    <p class="Pp">If you don't know <i>chroot()</i>, think of an FTP server
        where you can see a certain directory tree only after logging in. See
        also the --group and --user options.</p>
  </dd>
  <dt id="clients"><a class="permalink" href="#clients"><i>clients</i></a></dt>
  <dd>An array ref with a list of clients. Clients are hash refs, the attributes
      <i>accept</i> (0 for denying access and 1 for permitting) and <i>mask</i>,
      a Perl regular expression for the clients IP number or its host name.</dd>
  <dt id="configfile"><a class="permalink" href="#configfile"><i>configfile</i>
    (<b>--configfile=file</b>)</a></dt>
  <dd>Config files are assumed to return a single hash ref that overrides the
      arguments of the new method. However, command line arguments in turn take
      precedence over the config file. See the &quot;CONFIGURATION FILE&quot;
      section below for details on the config file.</dd>
  <dt id="debug"><a class="permalink" href="#debug"><i>debug</i>
    (<b>--debug</b>)</a></dt>
  <dd>Turn debugging mode on. Mainly this asserts that logging messages of level
      &quot;debug&quot; are created.</dd>
  <dt id="facility"><a class="permalink" href="#facility"><i>facility</i>
    (<b>--facility=mode</b>)</a></dt>
  <dd>(UNIX only) Facility to use for Sys::Syslog. The default is
    <b>daemon</b>.</dd>
  <dt id="group"><a class="permalink" href="#group"><i>group</i>
    (<b>--group=gid</b>)</a></dt>
  <dd>After doing a <i>bind()</i>, change the real and effective GID to the
      given. This is useful, if you want your server to bind to a privileged
      port (&lt;1024), but don't want the server to execute as root. See also
      the --user option.
    <p class="Pp">GID's can be passed as group names or numeric values.</p>
  </dd>
  <dt id="localaddr"><a class="permalink" href="#localaddr"><i>localaddr</i>
    (<b>--localaddr=ip</b>)</a></dt>
  <dd>By default a daemon is listening to any IP number that a machine has. This
      attribute allows to restrict the server to the given IP number.</dd>
  <dt id="localport"><a class="permalink" href="#localport"><i>localport</i>
    (<b>--localport=port</b>)</a></dt>
  <dd>This attribute sets the port on which the daemon is listening. It must be
      given somehow, as there's no default.</dd>
  <dt id="logfile"><a class="permalink" href="#logfile"><i>logfile</i>
    (<b>--logfile=file</b>)</a></dt>
  <dd>Be default logging messages will be written to the syslog (Unix) or to the
      event log (Windows NT). On other operating systems you need to specify a
      log file. The special value &quot;STDERR&quot; forces logging to stderr.
      See Net::Daemon::Log for details.</dd>
  <dt id="mode"><a class="permalink" href="#mode"><i>mode</i>
    (<b>--mode=modename</b>)</a></dt>
  <dd>The server can run in three different modes, depending on the environment.
    <p class="Pp">If you are running Perl 5.005 and did compile it for threads,
        then the server will create a new thread for each connection. The thread
        will execute the server's <i>Run()</i> method and then terminate. This
        mode is the default, you can force it with
      &quot;--mode=threads&quot;.</p>
    <p class="Pp">If threads are not available, but you have a working
        <i>fork()</i>, then the server will behave similar by creating a new
        process for each connection. This mode will be used automatically in the
        absence of threads or if you use the &quot;--mode=fork&quot; option.</p>
    <p class="Pp">Finally there's a single-connection mode: If the server has
        accepted a connection, he will enter the <i>Run()</i> method. No other
        connections are accepted until the <i>Run()</i> method returns (if the
        client disconnects). This operation mode is useful if you have neither
        threads nor <i>fork()</i>, for example on the Macintosh. For debugging
        purposes you can force this mode with &quot;--mode=single&quot;.</p>
  </dd>
  <dt id="pidfile"><a class="permalink" href="#pidfile"><i>pidfile</i>
    (<b>--pidfile=file</b>)</a></dt>
  <dd>(UNIX only) If this option is present, a PID file will be created at the
      given location. Default is to not create a pidfile.</dd>
  <dt id="user"><a class="permalink" href="#user"><i>user</i>
    (<b>--user=uid</b>)</a></dt>
  <dd>After doing a <i>bind()</i>, change the real and effective UID to the
      given. This is useful, if you want your server to bind to a privileged
      port (&lt;1024), but don't want the server to execute as root. See also
      the --group and the --chroot options.
    <p class="Pp">UID's can be passed as group names or numeric values.</p>
  </dd>
  <dt id="version"><a class="permalink" href="#version"><i>version</i>
    (<b>--version</b>)</a></dt>
  <dd>Suppresses startup of the server; instead the version string will be
      printed and the program exits immediately.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SHUTDOWN"><a class="permalink" href="#SHUTDOWN">SHUTDOWN</a></h1>
<p class="Pp">DBI::ProxyServer is built on RPC::PlServer which is, in turn,
    built on Net::Daemon.</p>
<p class="Pp">You should refer to Net::Daemon for how to shutdown the server,
    except that you can't because it's not currently documented there (as of
    v0.43). The bottom-line is that it seems that there's no support for
    graceful shutdown.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONFIGURATION_FILE"><a class="permalink" href="#CONFIGURATION_FILE">CONFIGURATION
  FILE</a></h1>
<p class="Pp">The configuration file is just that of <i>RPC::PlServer</i> or
    <i>Net::Daemon</i> with some additional attributes in the client list.</p>
<p class="Pp">The config file is a Perl script. At the top of the file you may
    include arbitrary Perl source, for example load drivers at the start (useful
    to enhance performance), prepare a chroot environment and so on.</p>
<p class="Pp">The important thing is that you finally return a hash ref of
    option name/value pairs. The possible options are listed above.</p>
<p class="Pp">All possibilities of Net::Daemon and RPC::PlServer apply, in
    particular</p>
<dl class="Bl-tag">
  <dt id="Host"><a class="permalink" href="#Host">Host and/or User dependent
    access control</a></dt>
  <dd></dd>
  <dt id="Host~2"><a class="permalink" href="#Host~2">Host and/or User dependent
    encryption</a></dt>
  <dd></dd>
  <dt id="Changing"><a class="permalink" href="#Changing">Changing UID and/or
    GID after binding to the port</a></dt>
  <dd></dd>
  <dt id="Running"><a class="permalink" href="#Running">Running in a
    <i>chroot()</i> environment</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Additionally the server offers you query restrictions. Suggest the
    following client list:</p>
<p class="Pp"></p>
<pre>
    'clients' =&gt; [
        { 'mask' =&gt; '^admin\.company\.com$',
          'accept' =&gt; 1,
          'users' =&gt; [ 'root', 'wwwrun' ],
        },
        {
          'mask' =&gt; '^admin\.company\.com$',
          'accept' =&gt; 1,
          'users' =&gt; [ 'root', 'wwwrun' ],
          'sql' =&gt; {
               'select' =&gt; 'SELECT * FROM foo',
               'insert' =&gt; 'INSERT INTO foo VALUES (?, ?, ?)'
               }
        }
</pre>
<p class="Pp">then only the users root and wwwrun may connect from
    admin.company.com, executing arbitrary queries, but only wwwrun may connect
    from other hosts and is restricted to</p>
<p class="Pp"></p>
<pre>
    $sth-&gt;prepare(&quot;select&quot;);
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre>
    $sth-&gt;prepare(&quot;insert&quot;);
</pre>
<p class="Pp">which in fact are &quot;SELECT * FROM foo&quot; or &quot;INSERT
    INTO foo VALUES (?, ?, ?)&quot;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Proxyserver_Configuration_file_(bigger_example)"><a class="permalink" href="#Proxyserver_Configuration_file_(bigger_example)">Proxyserver
  Configuration file (bigger example)</a></h1>
<p class="Pp">This section tells you how to restrict a DBI-Proxy: Not every user
    from every workstation shall be able to execute every query.</p>
<p class="Pp">There is a perl program &quot;dbiproxy&quot; which runs on a
    machine which is able to connect to all the databases we wish to reach. All
    Perl-DBD-drivers must be installed on this machine. You can also reach
    databases for which drivers are not available on the machine where you run
    the program querying the database, e.g. ask MS-Access-database from
  Linux.</p>
<p class="Pp">Create a configuration file &quot;proxy_oracle.cfg&quot; at the
    dbproxy-server:</p>
<p class="Pp"></p>
<pre>
    {
        # This shall run in a shell or a DOS-window 
        # facility =&gt; 'daemon',
        pidfile =&gt; 'your_dbiproxy.pid',
        logfile =&gt; 1,
        debug =&gt; 0,
        mode =&gt; 'single',
        localport =&gt; '12400',

        # Access control, the first match in this list wins!
        # So the order is important
        clients =&gt; [
                # hint to organize:
                # the most specialized rules for single machines/users are 1st
                # then the denying rules
                # then the rules about whole networks

                # rule: internal_webserver
                # desc: to get statistical information
                {
                        # this IP-address only is meant
                        mask =&gt; '^10\.95\.81\.243$',
                        # accept (not defer) connections like this
                        accept =&gt; 1,
                        # only users from this list 
                        # are allowed to log on
                        users =&gt; [ 'informationdesk' ],
                        # only this statistical query is allowed
                        # to get results for a web-query
                        sql =&gt; {
                                alive =&gt; 'select count(*) from dual',
                                statistic_area =&gt; 'select count(*) from e01admin.e01e203 where geb_bezei like ?',
                        }
                },

                # rule: internal_bad_guy_1
                {
                        mask =&gt; '^10\.95\.81\.1$',
                        accept =&gt; 0,
                },

                # rule: employee_workplace
                # desc: get detailed information
                {
                        # any IP-address is meant here
                        mask =&gt; '^10\.95\.81\.(\d+)$',
                        # accept (not defer) connections like this
                        accept =&gt; 1,
                        # only users from this list 
                        # are allowed to log on
                        users =&gt; [ 'informationdesk', 'lippmann' ],
                        # all these queries are allowed:
                        sql =&gt; {
                                search_city =&gt; 'select ort_nr, plz, ort from e01admin.e01e200 where plz like ?',
                                search_area =&gt; 'select gebiettyp, geb_bezei from e01admin.e01e203 where geb_bezei like ? or geb_bezei like ?',
                        }
                },

                # rule: internal_bad_guy_2 
                # This does NOT work, because rule &quot;employee_workplace&quot; hits
                # with its ip-address-mask of the whole network
                {
                        # don't accept connection from this ip-address
                        mask =&gt; '^10\.95\.81\.5$',
                        accept =&gt; 0,
                }
        ]
    }
</pre>
<p class="Pp">Start the proxyserver like this:</p>
<p class="Pp"></p>
<pre>
        rem well-set Oracle_home needed for Oracle
        set ORACLE_HOME=d:\oracle\ora81
        dbiproxy --configfile proxy_oracle.cfg
</pre>
<section class="Ss">
<h2 class="Ss" id="Testing_the_connection_from_a_remote_machine"><a class="permalink" href="#Testing_the_connection_from_a_remote_machine">Testing
  the connection from a remote machine</a></h2>
<p class="Pp">Call a program &quot;dbish&quot; from your commandline. I take the
    machine from rule &quot;internal_webserver&quot;</p>
<p class="Pp"></p>
<pre>
        dbish &quot;dbi:Proxy:hostname=oracle.zdf;port=12400;dsn=dbi:Oracle:e01&quot; informationdesk xxx
</pre>
<p class="Pp">There will be a shell-prompt:</p>
<p class="Pp"></p>
<pre>
        informationdesk@dbi...&gt; alive

        Current statement buffer (enter '/'...):
        alive

        informationdesk@dbi...&gt; /
        COUNT(*)
        '1'
        [1 rows of 1 fields returned]
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Testing_the_connection_with_a_perl-script"><a class="permalink" href="#Testing_the_connection_with_a_perl-script">Testing
  the connection with a perl-script</a></h2>
<p class="Pp">Create a perl-script like this:</p>
<p class="Pp"></p>
<pre>
        # file: oratest.pl
        # call me like this: perl oratest.pl user password

        use strict;
        use DBI;

        my $user = shift || die &quot;Usage: $0 user password&quot;;
        my $pass = shift || die &quot;Usage: $0 user password&quot;;
        my $config = {
                dsn_at_proxy =&gt; &quot;dbi:Oracle:e01&quot;,
                proxy =&gt; &quot;hostname=oechsle.zdf;port=12400&quot;,
        };
        my $dsn = sprintf &quot;dbi:Proxy:%s;dsn=%s&quot;,
                $config-&gt;{proxy},
                $config-&gt;{dsn_at_proxy};

        my $dbh = DBI-&gt;connect( $dsn, $user, $pass )
                || die &quot;connect did not work: $DBI::errstr&quot;;

        my $sql = &quot;search_city&quot;;
        printf &quot;%s\n%s\n%s\n&quot;, &quot;=&quot;x40, $sql, &quot;=&quot;x40;
        my $cur = $dbh-&gt;prepare($sql);
        $cur-&gt;bind_param(1,'905%');
        &amp;show_result ($cur);

        my $sql = &quot;search_area&quot;;
        printf &quot;%s\n%s\n%s\n&quot;, &quot;=&quot;x40, $sql, &quot;=&quot;x40;
        my $cur = $dbh-&gt;prepare($sql);
        $cur-&gt;bind_param(1,'Pfarr%');
        $cur-&gt;bind_param(2,'Bronnamberg%');
        &amp;show_result ($cur);

        my $sql = &quot;statistic_area&quot;;
        printf &quot;%s\n%s\n%s\n&quot;, &quot;=&quot;x40, $sql, &quot;=&quot;x40;
        my $cur = $dbh-&gt;prepare($sql);
        $cur-&gt;bind_param(1,'Pfarr%');
        &amp;show_result ($cur);

        $dbh-&gt;disconnect;
        exit;


        sub show_result {
                my $cur = shift;
                unless ($cur-&gt;execute()) {
                        print &quot;Could not execute\n&quot;; 
                        return; 
                }

                my $rownum = 0;
                while (my @row = $cur-&gt;fetchrow_array()) {
                        printf &quot;Row is: %s\n&quot;, join(&quot;, &quot;,@row);
                        if ($rownum++ &gt; 5) {
                                print &quot;... and so on\n&quot;;
                                last;
                        }       
                }
                $cur-&gt;finish;
        }
</pre>
<p class="Pp">The result</p>
<p class="Pp"></p>
<pre>
        C:\&gt;perl oratest.pl informationdesk xxx
        ========================================
        search_city
        ========================================
        Row is: 3322, 9050, Chemnitz
        Row is: 3678, 9051, Chemnitz
        Row is: 10447, 9051, Chemnitz
        Row is: 12128, 9051, Chemnitz
        Row is: 10954, 90513, Zirndorf
        Row is: 5808, 90513, Zirndorf
        Row is: 5715, 90513, Zirndorf
        ... and so on
        ========================================
        search_area
        ========================================
        Row is: 101, Bronnamberg
        Row is: 400, Pfarramt Zirndorf
        Row is: 400, Pfarramt Rosstal
        Row is: 400, Pfarramt Oberasbach
        Row is: 401, Pfarramt Zirndorf
        Row is: 401, Pfarramt Rosstal
        ========================================
        statistic_area
        ========================================
        DBD::Proxy::st execute failed: Server returned error: Failed to execute method CallMethod: Unknown SQL query: statistic_area at E:/Perl/site/lib/DBI/ProxyServer.pm line 258.
        Could not execute
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="How_the_configuration_works"><a class="permalink" href="#How_the_configuration_works">How
  the configuration works</a></h2>
<p class="Pp">The most important section to control access to your dbi-proxy is
    &quot;client=&gt;&quot; in the file &quot;proxy_oracle.cfg&quot;:</p>
<p class="Pp">Controlling which person at which machine is allowed to access</p>
<ul class="Bl-bullet">
  <li>&quot;mask&quot; is a perl regular expression against the plain ip-address
      of the machine which wishes to connect _or_ the reverse-lookup from a
      nameserver.</li>
  <li>&quot;accept&quot; tells the dbiproxy-server whether ip-adresse like in
      &quot;mask&quot; are allowed to connect or not (0/1)</li>
  <li>&quot;users&quot; is a reference to a list of usernames which must be
      matched, this is NOT a regular expression.</li>
</ul>
<p class="Pp">Controlling which SQL-statements are allowed</p>
<p class="Pp">You can put every SQL-statement you like in simply omitting
    &quot;sql =&gt; ...&quot;, but the more important thing is to restrict the
    connection so that only allowed queries are possible.</p>
<p class="Pp">If you include an sql-section in your config-file like this:</p>
<p class="Pp"></p>
<pre>
        sql =&gt; {
                alive =&gt; 'select count(*) from dual',
                statistic_area =&gt; 'select count(*) from e01admin.e01e203 where geb_bezei like ?',
        }
</pre>
<p class="Pp">The user is allowed to put two queries against the dbi-proxy. The
    queries are _not_ &quot;select count(*)...&quot;, the queries are
    &quot;alive&quot; and &quot;statistic_area&quot;! These keywords are
    replaced by the real query. So you can run a query for
  &quot;alive&quot;:</p>
<p class="Pp"></p>
<pre>
        my $sql = &quot;alive&quot;;
        my $cur = $dbh-&gt;prepare($sql);
        ...
</pre>
<p class="Pp">The flexibility is that you can put parameters in the where-part
    of the query so the query are not static. Simply replace a value in the
    where-part of the query through a question mark and bind it as a parameter
    to the query.</p>
<p class="Pp"></p>
<pre>
        my $sql = &quot;statistic_area&quot;;
        my $cur = $dbh-&gt;prepare($sql);
        $cur-&gt;bind_param(1,'905%');
        # A second parameter would be called like this:
        # $cur-&gt;bind_param(2,'98%');
</pre>
<p class="Pp">The result is this query:</p>
<p class="Pp"></p>
<pre>
        select count(*) from e01admin.e01e203 
        where geb_bezei like '905%'
</pre>
<p class="Pp">Don't try to put parameters into the sql-query like this:</p>
<p class="Pp"></p>
<pre>
        # Does not work like you think.
        # Only the first word of the query is parsed,
        # so it's changed to &quot;statistic_area&quot;, the rest is omitted.
        # You _have_ to work with $cur-&gt;bind_param.
        my $sql = &quot;statistic_area 905%&quot;;
        my $cur = $dbh-&gt;prepare($sql);
        ...
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Problems"><a class="permalink" href="#Problems">Problems</a></h2>
<ul class="Bl-bullet">
  <li>I don't know how to restrict users to special databases.</li>
  <li>I don't know how to pass query-parameters via dbish</li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<pre>
    Copyright (c) 1997    Jochen Wiedmann
                          Am Eisteich 9
                          72555 Metzingen
                          Germany

                          Email: joe@ispsoft.de
                          Phone: +49 7123 14881
</pre>
<p class="Pp">The DBI::ProxyServer module is free software; you can redistribute
    it and/or modify it under the same terms as Perl itself. In particular
    permission is granted to Tim Bunce for distributing this as a part of the
    DBI.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">dbiproxy, DBD::Proxy, DBI, RPC::PlServer, RPC::PlClient,
    Net::Daemon, Net::Daemon::Log, Sys::Syslog, Win32::EventLog, syslog</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-06-24</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

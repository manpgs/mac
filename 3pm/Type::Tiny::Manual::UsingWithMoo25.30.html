<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Type::Tiny::Manual::UsingWithMoo2(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Type::Tiny::Manual::UsingWithMoo2(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Type::Tiny::Manual::UsingWithMoo2(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Type::Tiny::Manual::UsingWithMoo2 - advanced use of Type::Tiny
    with Moo</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MANUAL"><a class="permalink" href="#MANUAL">MANUAL</a></h1>
<section class="Ss">
<h2 class="Ss" id="What_is_a_Type?"><a class="permalink" href="#What_is_a_Type?">What
  is a Type?</a></h2>
<p class="Pp">So far all the examples have shown you how to work with types, but
    we haven't looked at what a type actually <i>is</i>.</p>
<p class="Pp"></p>
<pre>
  use Types::Standard qw( Int );
  my $type = Int;
</pre>
<p class="Pp"><span class="Li">&quot;Int&quot;</span> in the above code is just
    a function called with zero arguments which returns a blessed Perl object.
    It is this object that defines what the <b>Int</b> type is and is
    responsible for checking values meet its definition.</p>
<p class="Pp"></p>
<pre>
  use Types::Standard qw( HashRef Int );
  my $type = HashRef[Int];
</pre>
<p class="Pp">The <span class="Li">&quot;HashRef&quot;</span> function, if
    called with no parameters returns the object defining the <b>HashRef</b>
    type, just like the <span class="Li">&quot;Int&quot;</span> function did
    before. But the difference here is that it's called with a parameter, an
    arrayref containing the <b>Int</b> type object. It uses this to make the
    <b>HashRef[Int]</b> type and returns that.</p>
<p class="Pp">Like any object, you can call methods on it. The most important
    methods to know about are:</p>
<p class="Pp"></p>
<pre>
  # check the value and return a boolean
  #
  $type-&gt;check($value);
  
  # return an error message about $value failing the type check
  # but don't actually check the value
  #
  $type-&gt;get_message($value);
  
  # coerce the value
  #
  my $coerced = $type-&gt;coerce($value);
</pre>
<p class="Pp">We've already seen some other methods earlier in the tutorial.</p>
<p class="Pp"></p>
<pre>
  # create a new type, same as the old type, but that has coercions
  #
  my $new_type = $type-&gt;plus_coercions( ... );
  
  # different syntax for parameterized types
  #
  my $href = HashRef;
  my $int = Int;
  my $href_of_int = $href-&gt;of($int);
</pre>
<p class="Pp">So now you should understand this:</p>
<p class="Pp"></p>
<pre>
  use Types::Standard qw( ArrayRef Dict Optional );
  use Types::Common::Numeric qw( PositiveInt );
  use Types::Common::String qw( NonEmptyStr );
  
  my $RaceInfo = Dict[
    year    =&gt; PositiveInt,
    race    =&gt; NonEmptyStr,
    jockey  =&gt; Optional[NonEmptyStr],
  ];
  
  has latest_event  =&gt; ( is =&gt; 'rw', isa =&gt; $RaceInfo );
  has wins          =&gt; ( is =&gt; 'rw', isa =&gt; ArrayRef[$RaceInfo] );
  has losses        =&gt; ( is =&gt; 'rw', isa =&gt; ArrayRef[$RaceInfo] );
</pre>
<p class="Pp">This can help you avoid repetition if you have a complex
    parameterized type that you need to reuse a few times.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_where_"><a class="permalink" href="#_where_">&quot;where&quot;</a></h2>
<p class="Pp">One of the most useful methods you can call on a type object is
    <span class="Li">&quot;where&quot;</span>.</p>
<p class="Pp"></p>
<pre>
  use Types::Standard qw( Int );
  
  has lucky_number =&gt; (
    is   =&gt; 'ro',
    isa  =&gt; Int-&gt;where(sub { $_ != 13 }),
  );
</pre>
<p class="Pp">I think you already understand what it does. It creates a new type
    constraint on the fly, restricting the original type.</p>
<p class="Pp">Like with coercions, these restrictions can be expressed as a
    coderef or as a string of Perl code, operating on the
    <span class="Li">$_</span> variable. And like with coercions, using a string
    of code will result in better performance.</p>
<p class="Pp"></p>
<pre>
  use Types::Standard qw( Int );
  
  has lucky_number =&gt; (
    is   =&gt; 'ro',
    isa  =&gt; Int-&gt;where(q{ $_ != 13 }),
  );
</pre>
<p class="Pp">Let's coerce a hashref of strings from an even-sized arrayref of
    strings:</p>
<p class="Pp"></p>
<pre>
  use Types::Standard qw( HashRef ArrayRef Str );
  
  has stringhash =&gt; (
    is   =&gt; 'ro',
    isa  =&gt; HashRef-&gt;of(Str)-&gt;plus_coercions(
      ArrayRef-&gt;of(Str)-&gt;where(q{ @$_ % 2 == 0 }), q{
        my %h = @$_;
        \%h;
      },
    ),
    coerce =&gt; 1,  # never forget!
  );
</pre>
<p class="Pp">If you understand that, you really are in the advanced class.
    Congratulations!</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Unions"><a class="permalink" href="#Unions">Unions</a></h2>
<p class="Pp">Sometimes you want to accept one thing or another thing. This is
    pretty easy with Type::Tiny.</p>
<p class="Pp"></p>
<pre>
  use Types::Standard qw( HashRef ArrayRef Str );
  
  has strings =&gt; (
    is    =&gt; 'ro',
    isa   =&gt; ArrayRef[Str] | HashRef[Str],
  );
</pre>
<p class="Pp">Type::Tiny overloads the bitwise or operator so stuff like this
    should &quot;just work&quot;.</p>
<p class="Pp">That said, now any code that calls
    <span class="Li">&quot;$self-&gt;strings&quot;</span> will probably need to
    check if the value is an arrayref or a hashref before doing anything with
    it. So it may be simpler overall if you just choose one of the options and
    coerce the other one into it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Intersections"><a class="permalink" href="#Intersections">Intersections</a></h2>
<p class="Pp">Similar to a union is an intersection.</p>
<p class="Pp"></p>
<pre>
  package MyAPI::Client {
    use Moo;
    use Types::Standard qw( HasMethods InstanceOf );
  
    has ua =&gt; (
      is    =&gt; 'ro',
      isa   =&gt; (InstanceOf[&quot;MyUA&quot;]) &amp; (HasMethods[&quot;store_cookie&quot;]),
    );
  }
</pre>
<p class="Pp">Here we are checking that the UA is an instance of the MyUA class
    and also offers the <span class="Li">&quot;store_cookie&quot;</span> method.
    Perhaps <span class="Li">&quot;store_cookie&quot;</span> isn't provided by
    the MyUA class itself, but several subclasses of MyUA provide it.</p>
<p class="Pp">Intersections are not useful as often as unions are. This is
    because they often make no sense. <span class="Li">&quot;(ArrayRef) &amp;
    (HashRef)&quot;</span> would be a reference which was simultaneously
    pointing to an array and a hash, which is impossible.</p>
<p class="Pp">Note that when using intersections, it is good practice to put
    parentheses around each type. This is to disambiguate the meaning of
    <span class="Li">&quot;&amp;&quot;</span> for Perl, because Perl uses it as
    the bitwise and operator but also as the sigil for subs.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Complements"><a class="permalink" href="#Complements">Complements</a></h2>
<p class="Pp">For any type <b>Foo</b> there is a complementary type <b>~Foo</b>
    (pronounced &quot;not Foo&quot;).</p>
<p class="Pp"></p>
<pre>
  package My::Class {
    use Moo;
    use Types::Standard qw( ArrayRef CodeRef );
    
    has things =&gt; ( is =&gt; 'ro', isa =&gt; ArrayRef[~CodeRef] );
  }
</pre>
<p class="Pp"><span class="Li">&quot;things&quot;</span> is now an arrayref of
    anything except coderefs.</p>
<p class="Pp">If you need a number that is <i>not</i> an integer:</p>
<p class="Pp"></p>
<pre>
  Num &amp; ~Int
</pre>
<p class="Pp">Types::Standard includes two types which are complements of each
    other: <b>Undef</b> and <b>Defined</b>.</p>
<p class="Pp"><b>NegativeInt</b> might seem to be the complement of
    <b>PositiveOrZeroInt</b> but when you think about it, it is not. There are
    values that fall into neither category, such as non-integers, non-numeric
    strings, references, undef, etc.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_stringifies_to__and__numifies_to_"><a class="permalink" href="#_stringifies_to__and__numifies_to_">&quot;stringifies_to&quot;
  and &quot;numifies_to&quot;</a></h2>
<p class="Pp">The <b>Object</b> type constraint provides
    <span class="Li">&quot;stringifies_to&quot;</span> and
    <span class="Li">&quot;numifies_to&quot;</span> methods which are probably
    best explained by examples.</p>
<p class="Pp"><span class="Li">&quot;Object-&gt;numifies_to(Int)&quot;</span>
    means any object where <span class="Li">&quot;0 + $object&quot;</span> is an
    integer.</p>
<p class="Pp"><span class="Li">&quot;Object-&gt;stringifies_to(StrMatch[$re])&quot;</span>
    means any object where <span class="Li">&quot;$object&quot;</span> matches
    the regular expression.</p>
<p class="Pp"><span class="Li">&quot;Object-&gt;stringifies_to($re)&quot;</span>
    also works as a shortcut.</p>
<p class="Pp"><span class="Li">&quot;Object-&gt;numifies_to($coderef)&quot;</span>
    and <span class="Li">&quot;Object-&gt;stringifies_to($coderef)&quot;</span>
    also work, where the coderef checks <span class="Li">$_</span> and returns a
    boolean.</p>
<p class="Pp">Other types which are also logically objects, such as
    parameterized <b>HasMethods</b>, <b>InstanceOf</b>, and <b>ConsumerOf</b>
    should also provide <span class="Li">&quot;stringifies_to&quot;</span> and
    <span class="Li">&quot;numifies_to&quot;</span> methods.</p>
<p class="Pp"><span class="Li">&quot;stringifies_to&quot;</span> and
    <span class="Li">&quot;numifies_to&quot;</span> work on unions if <i>all</i>
    of the type constraints in the union offer the method.</p>
<p class="Pp"><span class="Li">&quot;stringifies_to&quot;</span> and
    <span class="Li">&quot;numifies_to&quot;</span> work on intersections if
    <i>at least one of</i> of the type constraints in the intersection offers
    the method.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_with_attribute_values_"><a class="permalink" href="#_with_attribute_values_">&quot;with_attribute_values&quot;</a></h2>
<p class="Pp">Another one that is probably best explained using an example:</p>
<p class="Pp"></p>
<pre>
  package Horse {
    use Types::Standard qw( Enum Object );
    
    has gender  =&gt; (
      is  =&gt; 'ro',
      isa =&gt; Enum['m', 'f'],
    );
    has father  =&gt; (
      is  =&gt; 'ro',
      isa =&gt; Object-&gt;with_attribute_values(gender =&gt; Enum['m']),
    );
    has mother  =&gt; (
      is  =&gt; 'ro',
      isa =&gt; Object-&gt;with_attribute_values(gender =&gt; Enum['f']),
    );
  }
</pre>
<p class="Pp">In this example when you set a horse's father, it will call
    <span class="Li">&quot;$father-&gt;gender&quot;</span> and check that it
    matches <b>Enum['m']</b>.</p>
<p class="Pp">This method is in the same family as
    <span class="Li">&quot;stringifies_as&quot;</span> and
    <span class="Li">&quot;numifies_as&quot;</span>, so like those, it only
    applies to <b>Object</b> and similar type constraints, can work on
    unions/intersections under the same circumstances, and will also accept
    coderefs and regexps.</p>
<p class="Pp"></p>
<pre>
  has father  =&gt; (
    is  =&gt; 'ro',
    isa =&gt; Object-&gt;with_attribute_values(gender =&gt; sub { $_ eq 'm' }),
  );
  has mother  =&gt; (
    is  =&gt; 'ro',
    isa =&gt; Object-&gt;with_attribute_values(gender =&gt; qr/^f/i),
  );
</pre>
<p class="Pp">All of <span class="Li">&quot;stringifies_as&quot;</span>,
    <span class="Li">&quot;numifies_as&quot;</span>, and
    <span class="Li">&quot;with_attributes_as&quot;</span> are really just
    wrappers around <span class="Li">&quot;where&quot;</span>. The following two
    are roughly equivalent:</p>
<p class="Pp"></p>
<pre>
  my $type1 = Object-&gt;with_attribute_values(foo =&gt; Int, bar =&gt; Num);
  
  my $type2 = Object-&gt;where(sub {
    Int-&gt;check( $_-&gt;foo ) and Num-&gt;check( $_-&gt;bar )
  });
</pre>
<p class="Pp">The first will result in better performing code though.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Tied_Variables"><a class="permalink" href="#Tied_Variables">Tied
  Variables</a></h2>
<p class="Pp">It is possible to tie variables to a type constraint.</p>
<p class="Pp"></p>
<pre>
  use Types::Standard qw(Int);
  
  tie my $n, Int, 4;
  
  print &quot;$n\n&quot;;   # says &quot;4&quot;
  $n = 5;         # ok
  $n = &quot;foo&quot;;     # dies
</pre>
<p class="Pp">This feature requires Type::Tie which is a separate thing to
    install. Type::Tiny will automatically load Type::Tie in the background if
    it detects you're trying to tie a variable to a type.</p>
<p class="Pp">You can also tie arrays:</p>
<p class="Pp"></p>
<pre>
  tie my @numbers, Int;
  push @numbers, 1 .. 10;
</pre>
<p class="Pp">And hashes:</p>
<p class="Pp"></p>
<pre>
  tie my %numbers, Int;
  $numbers{lucky}   = 7;
  $numbers{unlucky} = 13;
</pre>
<p class="Pp">Earlier in the manual, it was mentioned that there is a problem
    with code like this:</p>
<p class="Pp"></p>
<pre>
  push @{ $horse-&gt;children }, $non_horse;
</pre>
<p class="Pp">This can be solved using tied variables.</p>
<p class="Pp"></p>
<pre>
  tie @{ $horse-&gt;children }, InstanceOf[&quot;Horse&quot;];
</pre>
<p class="Pp">Here is a longer example using builders and triggers.</p>
<p class="Pp"></p>
<pre>
  package Horse {
    use Moo;
    use Types::Standard qw( Str Num ArrayRef InstanceOf );
    use Type::Params qw(compile);
    use namespace::autoclean;
    
    my $ThisClass = InstanceOf[ __PACKAGE__ ];
    
    has name       =&gt; ( is =&gt; 'ro',    isa =&gt; Str );
    has gender     =&gt; ( is =&gt; 'ro',    isa =&gt; Str );
    has age        =&gt; ( is =&gt; 'rw',    isa =&gt; Num );
    has children   =&gt; (
      is        =&gt; 'rw', 
      isa       =&gt; ArrayRef[$ThisClass],
      builder   =&gt; &quot;_build_children&quot;,
      trigger   =&gt; sub { shift-&gt;_trigger_children(@_) },
    );
    
    # tie a default arrayref 
    sub _build_children {
      my $self = shift;
      tie my @kids, $ThisClass;
      \@kids;
    }
    
    # this method will tie an arrayref provided by the caller
    sub _trigger_children {
      my $self = shift;
      my ($new) = @_;
      tie @$new, $ThisClass;
    }
    
    sub add_child {
      state $check = compile($ThisClass, $ThisClass);
      my ($self, $kid) = &amp;$check;
      push @{ $self-&gt;children }, $kid;
      return $self;
    }
  }
</pre>
<p class="Pp">Now it's pretty much impossible for the caller to make a mess by
    adding a non-horse as a child.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="NEXT_STEPS"><a class="permalink" href="#NEXT_STEPS">NEXT
  STEPS</a></h1>
<p class="Pp">Here's your next step:</p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>Type::Tiny::Manual::UsingWithMoo3
    <p class="Pp">There's more than one way to do it! Alternative ways of using
        Type::Tiny, including type registries, exported functions, and
        <span class="Li">&quot;dwim_type&quot;</span>.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Toby Inkster &lt;tobyink@cpan.org&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENCE"><a class="permalink" href="#COPYRIGHT_AND_LICENCE">COPYRIGHT
  AND LICENCE</a></h1>
<p class="Pp">This software is copyright (c) 2013-2014, 2017-2020 by Toby
    Inkster.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DISCLAIMER_OF_WARRANTIES"><a class="permalink" href="#DISCLAIMER_OF_WARRANTIES">DISCLAIMER
  OF WARRANTIES</a></h1>
<p class="Pp">THIS PACKAGE IS PROVIDED &quot;AS IS&quot; AND WITHOUT ANY EXPRESS
    OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES
    OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-10-28</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

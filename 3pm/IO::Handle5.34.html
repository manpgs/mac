<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>IO::Handle(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">IO::Handle(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">IO::Handle(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">IO::Handle - supply object methods for I/O handles</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use IO::Handle;
    $io = IO::Handle-&gt;new();
    if ($io-&gt;fdopen(fileno(STDIN),&quot;r&quot;)) {
        print $io-&gt;getline;
        $io-&gt;close;
    }
    $io = IO::Handle-&gt;new();
    if ($io-&gt;fdopen(fileno(STDOUT),&quot;w&quot;)) {
        $io-&gt;print(&quot;Some text\n&quot;);
    }
    # setvbuf is not available by default on Perls 5.8.0 and later.
    use IO::Handle '_IOLBF';
    $io-&gt;setvbuf($buffer_var, _IOLBF, 1024);
    undef $io;       # automatically closes the file if it's open
    autoflush STDOUT 1;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><span class="Li">&quot;IO::Handle&quot;</span> is the base class
    for all other IO handle classes. It is not intended that objects of
    <span class="Li">&quot;IO::Handle&quot;</span> would be created directly,
    but instead <span class="Li">&quot;IO::Handle&quot;</span> is inherited from
    by several other classes in the IO hierarchy.</p>
<p class="Pp">If you are reading this documentation, looking for a replacement
    for the <span class="Li">&quot;FileHandle&quot;</span> package, then I
    suggest you read the documentation for
    <span class="Li">&quot;IO::File&quot;</span> too.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONSTRUCTOR"><a class="permalink" href="#CONSTRUCTOR">CONSTRUCTOR</a></h1>
<dl class="Bl-tag">
  <dt id="new"><a class="permalink" href="#new">new ()</a></dt>
  <dd>Creates a new <span class="Li">&quot;IO::Handle&quot;</span> object.</dd>
  <dt id="new_from_fd"><a class="permalink" href="#new_from_fd">new_from_fd (
    FD, MODE )</a></dt>
  <dd>Creates an <span class="Li">&quot;IO::Handle&quot;</span> like
      <span class="Li">&quot;new&quot;</span> does. It requires two parameters,
      which are passed to the method <span class="Li">&quot;fdopen&quot;</span>;
      if the fdopen fails, the object is destroyed. Otherwise, it is returned to
      the caller.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<p class="Pp">See perlfunc for complete descriptions of each of the following
    supported <span class="Li">&quot;IO::Handle&quot;</span> methods, which are
    just front ends for the corresponding built-in functions:</p>
<p class="Pp"></p>
<pre>    $io-&gt;close
    $io-&gt;eof
    $io-&gt;fcntl( FUNCTION, SCALAR )
    $io-&gt;fileno
    $io-&gt;format_write( [FORMAT_NAME] )
    $io-&gt;getc
    $io-&gt;ioctl( FUNCTION, SCALAR )
    $io-&gt;read ( BUF, LEN, [OFFSET] )
    $io-&gt;print ( ARGS )
    $io-&gt;printf ( FMT, [ARGS] )
    $io-&gt;say ( ARGS )
    $io-&gt;stat
    $io-&gt;sysread ( BUF, LEN, [OFFSET] )
    $io-&gt;syswrite ( BUF, [LEN, [OFFSET]] )
    $io-&gt;truncate ( LEN )
</pre>
<p class="Pp">See perlvar for complete descriptions of each of the following
    supported <span class="Li">&quot;IO::Handle&quot;</span> methods. All of
    them return the previous value of the attribute and takes an optional single
    argument that when given will set the value. If no argument is given the
    previous value is unchanged (except for
    <span class="Li">$io</span>-&gt;autoflush will actually turn ON autoflush by
    default).</p>
<p class="Pp"></p>
<pre>    $io-&gt;autoflush ( [BOOL] )                         $|
    $io-&gt;format_page_number( [NUM] )                  $%
    $io-&gt;format_lines_per_page( [NUM] )               $=
    $io-&gt;format_lines_left( [NUM] )                   $-
    $io-&gt;format_name( [STR] )                         $~
    $io-&gt;format_top_name( [STR] )                     $^
    $io-&gt;input_line_number( [NUM])                    $.
</pre>
<p class="Pp">The following methods are not supported on a per-filehandle
  basis.</p>
<p class="Pp"></p>
<pre>    IO::Handle-&gt;format_line_break_characters( [STR] ) $:
    IO::Handle-&gt;format_formfeed( [STR])               $^L
    IO::Handle-&gt;output_field_separator( [STR] )       $,
    IO::Handle-&gt;output_record_separator( [STR] )      $\
    IO::Handle-&gt;input_record_separator( [STR] )       $/
</pre>
<p class="Pp">Furthermore, for doing normal I/O you might need these:</p>
<dl class="Bl-tag">
  <dt>$io-&gt;fdopen ( FD, MODE )</dt>
  <dd><span class="Li">&quot;fdopen&quot;</span> is like an ordinary
      <span class="Li">&quot;open&quot;</span> except that its first parameter
      is not a filename but rather a file handle name, an IO::Handle object, or
      a file descriptor number. (For the documentation of the
      <span class="Li">&quot;open&quot;</span> method, see IO::File.)</dd>
  <dt>$io-&gt;opened</dt>
  <dd>Returns true if the object is currently a valid file descriptor, false
      otherwise.</dd>
  <dt>$io-&gt;getline</dt>
  <dd>This works like &lt;$io&gt; described in &quot;I/O Operators&quot; in
      perlop except that it's more readable and can be safely called in a list
      context but still returns just one line. If used as the conditional within
      a <span class="Li">&quot;while&quot;</span> or C-style
      <span class="Li">&quot;for&quot;</span> loop, however, you will need to
      emulate the functionality of &lt;$io&gt; with
      <span class="Li">&quot;defined($_ = $io-&gt;getline)&quot;</span>.</dd>
  <dt>$io-&gt;getlines</dt>
  <dd>This works like &lt;$io&gt; when called in a list context to read all the
      remaining lines in a file, except that it's more readable. It will also
      <b>croak()</b> if accidentally called in a scalar context.</dd>
  <dt>$io-&gt;ungetc ( ORD )</dt>
  <dd>Pushes a character with the given ordinal value back onto the given
      handle's input stream. Only one character of pushback per handle is
      guaranteed.</dd>
  <dt>$io-&gt;write ( BUF, LEN [, OFFSET ] )</dt>
  <dd>This <span class="Li">&quot;write&quot;</span> is somewhat like
      <span class="Li">&quot;write&quot;</span> found in C, in that it is the
      opposite of read. The wrapper for the perl
      <span class="Li">&quot;write&quot;</span> function is called
      <span class="Li">&quot;format_write&quot;</span>. However, whilst the C
      <span class="Li">&quot;write&quot;</span> function returns the number of
      bytes written, this <span class="Li">&quot;write&quot;</span> function
      simply returns true if successful (like
      <span class="Li">&quot;print&quot;</span>). A more C-like
      <span class="Li">&quot;write&quot;</span> is
      <span class="Li">&quot;syswrite&quot;</span> (see above).</dd>
  <dt>$io-&gt;error</dt>
  <dd>Returns a true value if the given handle has experienced any errors since
      it was opened or since the last call to
      <span class="Li">&quot;clearerr&quot;</span>, or if the handle is invalid.
      It only returns false for a valid handle with no outstanding errors.</dd>
  <dt>$io-&gt;clearerr</dt>
  <dd>Clear the given handle's error indicator. Returns -1 if the handle is
      invalid, 0 otherwise.</dd>
  <dt>$io-&gt;sync</dt>
  <dd><span class="Li">&quot;sync&quot;</span> synchronizes a file's in-memory
      state with that on the physical medium.
      <span class="Li">&quot;sync&quot;</span> does not operate at the perlio
      api level, but operates on the file descriptor (similar to sysread,
      sysseek and systell). This means that any data held at the perlio api
      level will not be synchronized. To synchronize data that is buffered at
      the perlio api level you must use the flush method.
      <span class="Li">&quot;sync&quot;</span> is not implemented on all
      platforms. Returns &quot;0 but true&quot; on success,
      <span class="Li">&quot;undef&quot;</span> on error,
      <span class="Li">&quot;undef&quot;</span> for an invalid handle. See
      <b>fsync</b>(3c).</dd>
  <dt>$io-&gt;flush</dt>
  <dd><span class="Li">&quot;flush&quot;</span> causes perl to flush any
      buffered data at the perlio api level. Any unread data in the buffer will
      be discarded, and any unwritten data will be written to the underlying
      file descriptor. Returns &quot;0 but true&quot; on success,
      <span class="Li">&quot;undef&quot;</span> on error.</dd>
  <dt>$io-&gt;printflush ( ARGS )</dt>
  <dd>Turns on autoflush, print ARGS and then restores the autoflush status of
      the <span class="Li">&quot;IO::Handle&quot;</span> object. Returns the
      return value from print.</dd>
  <dt>$io-&gt;blocking ( [ BOOL ] )</dt>
  <dd>If called with an argument <span class="Li">&quot;blocking&quot;</span>
      will turn on non-blocking IO if <span class="Li">&quot;BOOL&quot;</span>
      is false, and turn it off if <span class="Li">&quot;BOOL&quot;</span> is
      true.
    <p class="Pp"><span class="Li">&quot;blocking&quot;</span> will return the
        value of the previous setting, or the current setting if
        <span class="Li">&quot;BOOL&quot;</span> is not given.</p>
    <p class="Pp">If an error occurs
        <span class="Li">&quot;blocking&quot;</span> will return undef and
        <span class="Li">$!</span> will be set.</p>
  </dd>
</dl>
<p class="Pp">If the C functions <b>setbuf()</b> and/or <b>setvbuf()</b> are
    available, then <span class="Li">&quot;IO::Handle::setbuf&quot;</span> and
    <span class="Li">&quot;IO::Handle::setvbuf&quot;</span> set the buffering
    policy for an IO::Handle. The calling sequences for the Perl functions are
    the same as their C counterparts--including the constants
    <span class="Li">&quot;_IOFBF&quot;</span>,
    <span class="Li">&quot;_IOLBF&quot;</span>, and
    <span class="Li">&quot;_IONBF&quot;</span> for <b>setvbuf()</b>--except that
    the buffer parameter specifies a scalar variable to use as a buffer. You
    should only change the buffer before any I/O, or immediately after calling
    flush.</p>
<p class="Pp">WARNING: The <b>IO::Handle::setvbuf()</b> is not available by
    default on Perls 5.8.0 and later because <b>setvbuf()</b> is rather specific
    to using the stdio library, while Perl prefers the new perlio subsystem
    instead.</p>
<p class="Pp">WARNING: A variable used as a buffer by
    <span class="Li">&quot;setbuf&quot;</span> or
    <span class="Li">&quot;setvbuf&quot;</span> <b>must not</b> <b>be
    modified</b> in any way until the IO::Handle is closed or
    <span class="Li">&quot;setbuf&quot;</span> or
    <span class="Li">&quot;setvbuf&quot;</span> is called again, or memory
    corruption may result! Remember that the order of global destruction is
    undefined, so even if your buffer variable remains in scope until program
    termination, it may be undefined before the file IO::Handle is closed. Note
    that you need to import the constants
    <span class="Li">&quot;_IOFBF&quot;</span>,
    <span class="Li">&quot;_IOLBF&quot;</span>, and
    <span class="Li">&quot;_IONBF&quot;</span> explicitly. Like C, setbuf
    returns nothing. setvbuf returns &quot;0 but true&quot;, on success,
    <span class="Li">&quot;undef&quot;</span> on failure.</p>
<p class="Pp">Lastly, there is a special method for working under <b>-T</b> and
    setuid/gid scripts:</p>
<dl class="Bl-tag">
  <dt>$io-&gt;untaint</dt>
  <dd>Marks the object as taint-clean, and as such data read from it will also
      be considered taint-clean. Note that this is a very trusting action to
      take, and appropriate consideration for the data source and potential
      vulnerability should be kept in mind. Returns 0 on success, -1 if setting
      the taint-clean flag failed. (eg invalid handle)</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTE"><a class="permalink" href="#NOTE">NOTE</a></h1>
<p class="Pp">An <span class="Li">&quot;IO::Handle&quot;</span> object is a
    reference to a symbol/GLOB reference (see the
    <span class="Li">&quot;Symbol&quot;</span> package). Some modules that
    inherit from <span class="Li">&quot;IO::Handle&quot;</span> may want to keep
    object related variables in the hash table part of the GLOB. In an attempt
    to prevent modules trampling on each other I propose the that any such
    module should prefix its variables with its own name separated by _'s. For
    example the IO::Socket module keeps a
    <span class="Li">&quot;timeout&quot;</span> variable in
  'io_socket_timeout'.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">perlfunc, &quot;I/O Operators&quot; in perlop, IO::File</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">Due to backwards compatibility, all filehandles resemble objects
    of class <span class="Li">&quot;IO::Handle&quot;</span>, or actually classes
    derived from that class. They actually aren't. Which means you can't derive
    your own class from <span class="Li">&quot;IO::Handle&quot;</span> and
    inherit those methods.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
<p class="Pp">Derived from FileHandle.pm by Graham Barr
    &lt;<i>gbarr@pobox.com</i>&gt;</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2021-02-21</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

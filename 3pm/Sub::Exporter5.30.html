<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Sub::Exporter(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Sub::Exporter(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Sub::Exporter(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Sub::Exporter - a sophisticated exporter for custom-built
  routines</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 0.987</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">Sub::Exporter must be used in two places. First, in an exporting
    module:</p>
<p class="Pp"></p>
<pre>  # in the exporting module:
  package Text::Tweaker;
  use Sub::Exporter -setup =&gt; {
    exports =&gt; [
      qw(squish titlecase), # always works the same way
      reformat =&gt; \&amp;build_reformatter, # generator to build exported function
      trim     =&gt; \&amp;build_trimmer,
      indent   =&gt; \&amp;build_indenter,
    ],
    collectors =&gt; [ 'defaults' ],
  };
</pre>
<p class="Pp">Then, in an importing module:</p>
<p class="Pp"></p>
<pre>  # in the importing module:
  use Text::Tweaker
    'squish',
    indent   =&gt; { margin =&gt; 5 },
    reformat =&gt; { width =&gt; 79, justify =&gt; 'full', -as =&gt; 'prettify_text' },
    defaults =&gt; { eol =&gt; 'CRLF' };
</pre>
<p class="Pp">With this setup, the importing module ends up with three routines:
    <span class="Li">&quot;squish&quot;</span>,
    <span class="Li">&quot;indent&quot;</span>, and
    <span class="Li">&quot;prettify_text&quot;</span>. The latter two have been
    built to the specifications of the importer -- they are not just copies of
    the code in the exporting package.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><b>ACHTUNG!</b> If you're not familiar with Exporter or exporting,
    read Sub::Exporter::Tutorial first!</p>
<section class="Ss">
<h2 class="Ss" id="Why_Generators?"><a class="permalink" href="#Why_Generators?">Why
  Generators?</a></h2>
<p class="Pp">The biggest benefit of Sub::Exporter over existing exporters
    (including the ubiquitous Exporter.pm) is its ability to build new coderefs
    for export, rather than to simply export code identical to that found in the
    exporting package.</p>
<p class="Pp">If your module's consumers get a routine that works like this:</p>
<p class="Pp"></p>
<pre>  use Data::Analyze qw(analyze);
  my $value = analyze($data, $tolerance, $passes);
</pre>
<p class="Pp">and they constantly pass only one or two different set of values
    for the non-<span class="Li">$data</span> arguments, your code can benefit
    from Sub::Exporter. By writing a simple generator, you can let them do this,
    instead:</p>
<p class="Pp"></p>
<pre>  use Data::Analyze
    analyze =&gt; { tolerance =&gt; 0.10, passes =&gt; 10, -as =&gt; analyze10 },
    analyze =&gt; { tolerance =&gt; 0.15, passes =&gt; 50, -as =&gt; analyze50 };
  my $value = analyze10($data);
</pre>
<p class="Pp">The package with the generator for that would look something like
    this:</p>
<p class="Pp"></p>
<pre>  package Data::Analyze;
  use Sub::Exporter -setup =&gt; {
    exports =&gt; [
      analyze =&gt; \&amp;build_analyzer,
    ],
  };
  sub build_analyzer {
    my ($class, $name, $arg) = @_;
    return sub {
      my $data      = shift;
      my $tolerance = shift || $arg-&gt;{tolerance}; 
      my $passes    = shift || $arg-&gt;{passes}; 
      analyze($data, $tolerance, $passes);
    }
  }
</pre>
<p class="Pp">Your module's user now has to do less work to benefit from it --
    and remember, you're often your own user! Investing in customized
    subroutines is an investment in future laziness.</p>
<p class="Pp">This also avoids a common form of ugliness seen in many modules:
    package-level configuration. That is, you might have seen something like the
    above implemented like so:</p>
<p class="Pp"></p>
<pre>  use Data::Analyze qw(analyze);
  $Data::Analyze::default_tolerance = 0.10;
  $Data::Analyze::default_passes    = 10;
</pre>
<p class="Pp">This might save time, until you have multiple modules using
    Data::Analyze. Because there is only one global configuration, they step on
    each other's toes and your code begins to have mysterious errors.</p>
<p class="Pp">Generators can also allow you to export class methods to be called
    as subroutines:</p>
<p class="Pp"></p>
<pre>  package Data::Methodical;
  use Sub::Exporter -setup =&gt; { exports =&gt; { some_method =&gt; \&amp;_curry_class } };
  sub _curry_class {
    my ($class, $name) = @_;
    sub { $class-&gt;$name(@_); };
  }
</pre>
<p class="Pp">Because of the way that exporters and Sub::Exporter work, any
    package that inherits from Data::Methodical can inherit its exporter and
    override its <span class="Li">&quot;some_method&quot;</span>. If a user
    imports <span class="Li">&quot;some_method&quot;</span> from that package,
    he'll receive a subroutine that calls the method on the subclass, rather
    than on Data::Methodical itself.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Other_Customizations"><a class="permalink" href="#Other_Customizations">Other
  Customizations</a></h2>
<p class="Pp">Building custom routines with generators isn't the only way that
    Sub::Exporters allows the importing code to refine its use of the exported
    routines. They may also be renamed to avoid naming collisions.</p>
<p class="Pp">Consider the following code:</p>
<p class="Pp"></p>
<pre>  # this program determines to which circle of Hell you will be condemned
  use Morality qw(sin virtue); # for calculating viciousness
  use Math::Trig qw(:all);     # for dealing with circles
</pre>
<p class="Pp">The programmer has inadvertently imported two
    <span class="Li">&quot;sin&quot;</span> routines. The solution, in
    Exporter.pm-based modules, would be to import only one and then call the
    other by its fully-qualified name. Alternately, the importer could write a
    routine that did so, or could mess about with typeglobs.</p>
<p class="Pp">How much easier to write:</p>
<p class="Pp"></p>
<pre>  # this program determines to which circle of Hell you will be condemned
  use Morality qw(virtue), sin =&gt; { -as =&gt; 'offense' };
  use Math::Trig -all =&gt; { -prefix =&gt; 'trig_' };
</pre>
<p class="Pp">and to have at one's disposal
    <span class="Li">&quot;offense&quot;</span> and
    <span class="Li">&quot;trig_sin&quot;</span> -- not to mention
    <span class="Li">&quot;trig_cos&quot;</span> and
    <span class="Li">&quot;trig_tan&quot;</span>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTER_CONFIGURATION"><a class="permalink" href="#EXPORTER_CONFIGURATION">EXPORTER
  CONFIGURATION</a></h1>
<p class="Pp">You can configure an exporter for your package by using
    Sub::Exporter like so:</p>
<p class="Pp"></p>
<pre>  package Tools;
  use Sub::Exporter
    -setup =&gt; { exports =&gt; [ qw(function1 function2 function3) ] };
</pre>
<p class="Pp">This is the simplest way to use the exporter, and is basically
    equivalent to this:</p>
<p class="Pp"></p>
<pre>  package Tools;
  use base qw(Exporter);
  our @EXPORT_OK = qw(function1 function2 function3);
</pre>
<p class="Pp">Any basic use of Sub::Exporter will look like this:</p>
<p class="Pp"></p>
<pre>  package Tools;
  use Sub::Exporter -setup =&gt; \%config;
</pre>
<p class="Pp">The following keys are valid in
  <span class="Li">%config</span>:</p>
<p class="Pp"></p>
<pre>  exports - a list of routines to provide for exporting; each routine may be
            followed by generator
  groups  - a list of groups to provide for exporting; each must be followed by
            either (a) a list of exports, possibly with arguments for each
            export, or (b) a generator
  collectors - a list of names into which values are collected for use in
               routine generation; each name may be followed by a validator
</pre>
<p class="Pp">In addition to the basic options above, a few more advanced
    options may be passed:</p>
<p class="Pp"></p>
<pre>  into_level - how far up the caller stack to look for a target (default 0)
  into       - an explicit target (package) into which to export routines
</pre>
<p class="Pp">In other words: Sub::Exporter installs a
    <span class="Li">&quot;import&quot;</span> routine which, when called,
    exports routines to the calling namespace. The
    <span class="Li">&quot;into&quot;</span> and
    <span class="Li">&quot;into_level&quot;</span> options change where those
    exported routines are installed.</p>
<p class="Pp"></p>
<pre>  generator  - a callback used to produce the code that will be installed
               default: Sub::Exporter::default_generator
  installer  - a callback used to install the code produced by the generator
               default: Sub::Exporter::default_installer
</pre>
<p class="Pp">For information on how these callbacks are used, see the
    documentation for <span class="Li">&quot;default_generator&quot;</span> and
    <span class="Li">&quot;default_installer&quot;</span>.</p>
<section class="Ss">
<h2 class="Ss" id="Export_Configuration"><a class="permalink" href="#Export_Configuration">Export
  Configuration</a></h2>
<p class="Pp">The <span class="Li">&quot;exports&quot;</span> list may be
    provided as an array reference or a hash reference. The list is processed in
    such a way that the following are equivalent:</p>
<p class="Pp"></p>
<pre>  { exports =&gt; [ qw(foo bar baz), quux =&gt; \&amp;quux_generator ] }
  { exports =&gt;
    { foo =&gt; undef, bar =&gt; undef, baz =&gt; undef, quux =&gt; \&amp;quux_generator } }
</pre>
<p class="Pp">Generators are code that return coderefs. They are called with
    four parameters:</p>
<p class="Pp"></p>
<pre>  $class - the class whose exporter has been called (the exporting class)
  $name  - the name of the export for which the routine is being build
 \%arg   - the arguments passed for this export
 \%col   - the collections for this import
</pre>
<p class="Pp">Given the configuration in the &quot;SYNOPSIS&quot;, the following
    <span class="Li">&quot;use&quot;</span> statement:</p>
<p class="Pp"></p>
<pre>  use Text::Tweaker
    reformat =&gt; { -as =&gt; 'make_narrow', width =&gt; 33 },
    defaults =&gt; { eol =&gt; 'CR' };
</pre>
<p class="Pp">would result in the following call to
    <span class="Li">&amp;build_reformatter</span>:</p>
<p class="Pp"></p>
<pre>  my $code = build_reformatter(
    'Text::Tweaker',
    'reformat',
    { width =&gt; 33 }, # note that -as is not passed in
    { defaults =&gt; { eol =&gt; 'CR' } },
  );
</pre>
<p class="Pp">The returned coderef (<span class="Li">$code</span>) would then be
    installed as <span class="Li">&quot;make_narrow&quot;</span> in the calling
    package.</p>
<p class="Pp">Instead of providing a coderef in the configuration, a reference
    to a method name may be provided. This method will then be called on the
    invocant of the <span class="Li">&quot;import&quot;</span> method. (In this
    case, we do not pass the <span class="Li">$class</span> parameter, as it
    would be redundant.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Group_Configuration"><a class="permalink" href="#Group_Configuration">Group
  Configuration</a></h2>
<p class="Pp">The <span class="Li">&quot;groups&quot;</span> list can be passed
    in the same forms as <span class="Li">&quot;exports&quot;</span>. Groups
    must have values to be meaningful, which may either list exports that make
    up the group (optionally with arguments) or may provide a way to build the
    group.</p>
<p class="Pp">The simpler case is the first: a group definition is a list of
    exports. Here's the example that could go in exporter in the
    &quot;SYNOPSIS&quot;.</p>
<p class="Pp"></p>
<pre>  groups  =&gt; {
    default    =&gt; [ qw(reformat) ],
    shorteners =&gt; [ qw(squish trim) ],
    email_safe =&gt; [
      'indent',
      reformat =&gt; { -as =&gt; 'email_format', width =&gt; 72 }
    ],
  },
</pre>
<p class="Pp">Groups are imported by specifying their name prefixed be either a
    dash or a colon. This line of code would import the
    <span class="Li">&quot;shorteners&quot;</span> group:</p>
<p class="Pp"></p>
<pre>  use Text::Tweaker qw(-shorteners);
</pre>
<p class="Pp">Arguments passed to a group when importing are merged into the
    groups options and passed to any relevant generators. Groups can contain
    other groups, but looping group structures are ignored.</p>
<p class="Pp">The other possible value for a group definition, a coderef, allows
    one generator to build several exportable routines simultaneously. This is
    useful when many routines must share enclosed lexical variables. The coderef
    must return a hash reference. The keys will be used as export names and the
    values are the subs that will be exported.</p>
<p class="Pp">This example shows a simple use of the group generator.</p>
<p class="Pp"></p>
<pre>  package Data::Crypto;
  use Sub::Exporter -setup =&gt; { groups =&gt; { cipher =&gt; \&amp;build_cipher_group } };
  sub build_cipher_group {
    my ($class, $group, $arg) = @_;
    my ($encode, $decode) = build_codec($arg-&gt;{secret});
    return { cipher =&gt; $encode, decipher =&gt; $decode };
  }
</pre>
<p class="Pp">The <span class="Li">&quot;cipher&quot;</span> and
    <span class="Li">&quot;decipher&quot;</span> routines are built in a group
    because they are built together by code which encloses their secret in their
    environment.</p>
<p class="Pp"><i>Default Groups</i></p>
<p class="Pp">If a module that uses Sub::Exporter is
    <span class="Li">&quot;use&quot;</span>d with no arguments, it will try to
    export the group named <span class="Li">&quot;default&quot;</span>. If that
    group has not been specifically configured, it will be empty, and nothing
    will happen.</p>
<p class="Pp">Another group is also created if not defined:
    <span class="Li">&quot;all&quot;</span>. The
    <span class="Li">&quot;all&quot;</span> group contains all the exports from
    the exports list.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Collector_Configuration"><a class="permalink" href="#Collector_Configuration">Collector
  Configuration</a></h2>
<p class="Pp">The <span class="Li">&quot;collectors&quot;</span> entry in the
    exporter configuration gives names which, when found in the import call,
    have their values collected and passed to every generator.</p>
<p class="Pp">For example, the
    <span class="Li">&quot;build_analyzer&quot;</span> generator that we saw
    above could be rewritten as:</p>
<p class="Pp"></p>
<pre> sub build_analyzer {
   my ($class, $name, $arg, $col) = @_;
   return sub {
     my $data      = shift;
     my $tolerance = shift || $arg-&gt;{tolerance} || $col-&gt;{defaults}{tolerance}; 
     my $passes    = shift || $arg-&gt;{passes}    || $col-&gt;{defaults}{passes}; 
     analyze($data, $tolerance, $passes);
   }
 }
</pre>
<p class="Pp">That would allow the importer to specify global defaults for his
    imports:</p>
<p class="Pp"></p>
<pre>  use Data::Analyze
    'analyze',
    analyze  =&gt; { tolerance =&gt; 0.10, -as =&gt; analyze10 },
    analyze  =&gt; { tolerance =&gt; 0.15, passes =&gt; 50, -as =&gt; analyze50 },
    defaults =&gt; { passes =&gt; 10 };
  my $A = analyze10($data);     # equivalent to analyze($data, 0.10, 10);
  my $C = analyze50($data);     # equivalent to analyze($data, 0.15, 50);
  my $B = analyze($data, 0.20); # equivalent to analyze($data, 0.20, 10);
</pre>
<p class="Pp">If values are provided in the
    <span class="Li">&quot;collectors&quot;</span> list during exporter setup,
    they must be code references, and are used to validate the importer's
    values. The validator is called when the collection is found, and if it
    returns false, an exception is thrown. We could ensure that no one tries to
    set a global data default easily:</p>
<p class="Pp"></p>
<pre>  collectors =&gt; { defaults =&gt; sub { return (exists $_[0]-&gt;{data}) ? 0 : 1 } }
</pre>
<p class="Pp">Collector coderefs can also be used as hooks to perform arbitrary
    actions before anything is exported.</p>
<p class="Pp">When the coderef is called, it is passed the value of the
    collection and a hashref containing the following entries:</p>
<p class="Pp"></p>
<pre>  name        - the name of the collector
  config      - the exporter configuration (hashref)
  import_args - the arguments passed to the exporter, sans collections (aref)
  class       - the package on which the importer was called
  into        - the package into which exports will be exported
</pre>
<p class="Pp">Collectors with all-caps names (that is, made up of underscore or
    capital A through Z) are reserved for special use. The only currently
    implemented special collector is <span class="Li">&quot;INIT&quot;</span>,
    whose hook (if present in the exporter configuration) is always run before
    any other hook.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CALLING_THE_EXPORTER"><a class="permalink" href="#CALLING_THE_EXPORTER">CALLING
  THE EXPORTER</a></h1>
<p class="Pp">Arguments to the exporter (that is, the arguments after the module
    name in a <span class="Li">&quot;use&quot;</span> statement) are parsed as
    follows:</p>
<p class="Pp">First, the collectors gather any collections found in the
    arguments. Any reference type may be given as the value for a collector. For
    each collection given in the arguments, its validator (if any) is
  called.</p>
<p class="Pp">Next, groups are expanded. If the group is implemented by a group
    generator, the generator is called. There are two special arguments which,
    if given to a group, have special meaning:</p>
<p class="Pp"></p>
<pre>  -prefix - a string to prepend to any export imported from this group
  -suffix - a string to append to any export imported from this group
</pre>
<p class="Pp">Finally, individual export generators are called and all subs,
    generated or otherwise, are installed in the calling package. There is only
    one special argument for export generators:</p>
<p class="Pp"></p>
<pre>  -as     - where to install the exported sub
</pre>
<p class="Pp">Normally, <span class="Li">&quot;-as&quot;</span> will contain an
    alternate name for the routine. It may, however, contain a reference to a
    scalar. If that is the case, a reference the generated routine will be
    placed in the scalar referenced by <span class="Li">&quot;-as&quot;</span>.
    It will not be installed into the calling package.</p>
<section class="Ss">
<h2 class="Ss" id="Special_Exporter_Arguments"><a class="permalink" href="#Special_Exporter_Arguments">Special
  Exporter Arguments</a></h2>
<p class="Pp">The generated exporter accept some special options, which may be
    passed as the first argument, in a hashref.</p>
<p class="Pp">These options are:</p>
<p class="Pp"></p>
<pre>  into_level
  into
  generator
  installer
</pre>
<p class="Pp">These override the same-named configuration options described in
    &quot;EXPORTER CONFIGURATION&quot;.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SUBROUTINES"><a class="permalink" href="#SUBROUTINES">SUBROUTINES</a></h1>
<section class="Ss">
<h2 class="Ss" id="setup_exporter"><a class="permalink" href="#setup_exporter">setup_exporter</a></h2>
<p class="Pp">This routine builds and installs an
    <span class="Li">&quot;import&quot;</span> routine. It is called with one
    argument, a hashref containing the exporter configuration. Using this, it
    builds an exporter and installs it into the calling package with the name
    &quot;import.&quot; In addition to the normal exporter configuration, a few
    named arguments may be passed in the hashref:</p>
<p class="Pp"></p>
<pre>  into       - into what package should the exporter be installed
  into_level - into what level up the stack should the exporter be installed
  as         - what name should the installed exporter be given
</pre>
<p class="Pp">By default the exporter is installed with the name
    <span class="Li">&quot;import&quot;</span> into the immediate caller of
    <span class="Li">&quot;setup_exporter&quot;</span>. In other words, if your
    package calls <span class="Li">&quot;setup_exporter&quot;</span> without
    providing any of the three above arguments, it will have an
    <span class="Li">&quot;import&quot;</span> routine installed.</p>
<p class="Pp">Providing both <span class="Li">&quot;into&quot;</span> and
    <span class="Li">&quot;into_level&quot;</span> will cause an exception to be
    thrown.</p>
<p class="Pp">The exporter is built by
    <span class="Li">&quot;build_exporter&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="build_exporter"><a class="permalink" href="#build_exporter">build_exporter</a></h2>
<p class="Pp">Given a standard exporter configuration, this routine builds and
    returns an exporter -- that is, a subroutine that can be installed as a
    class method to perform exporting on request.</p>
<p class="Pp">Usually, this method is called by
    <span class="Li">&quot;setup_exporter&quot;</span>, which then installs the
    exporter as a package's import routine.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="default_generator"><a class="permalink" href="#default_generator">default_generator</a></h2>
<p class="Pp">This is Sub::Exporter's default generator. It takes bits of
    configuration that have been gathered during the import and turns them into
    a coderef that can be installed.</p>
<p class="Pp"></p>
<pre>  my $code = default_generator(\%arg);
</pre>
<p class="Pp">Passed arguments are:</p>
<p class="Pp"></p>
<pre>  class - the class on which the import method was called
  name  - the name of the export being generated
  arg   - the arguments to the generator
  col   - the collections
  generator - the generator to be used to build the export (code or scalar ref)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="default_installer"><a class="permalink" href="#default_installer">default_installer</a></h2>
<p class="Pp">This is Sub::Exporter's default installer. It does what
    Sub::Exporter promises: it installs code into the target package.</p>
<p class="Pp"></p>
<pre>  default_installer(\%arg, \@to_export);
</pre>
<p class="Pp">Passed arguments are:</p>
<p class="Pp"></p>
<pre>  into - the package into which exports should be delivered
</pre>
<p class="Pp"><span class="Li">@to_export</span> is a list of name/value pairs.
    The default exporter assigns code (the values) to named slots (the names) in
    the given package. If the name is a scalar reference, the scalar reference
    is made to point to the code reference instead.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTS"><a class="permalink" href="#EXPORTS">EXPORTS</a></h1>
<p class="Pp">Sub::Exporter also offers its own exports: the
    <span class="Li">&quot;setup_exporter&quot;</span> and
    <span class="Li">&quot;build_exporter&quot;</span> routines described above.
    It also provides a special &quot;setup&quot; collector, which will set up an
    exporter using the parameters passed to it.</p>
<p class="Pp">Note that the &quot;setup&quot; collector (seen in examples like
    the &quot;SYNOPSIS&quot; above) uses
    <span class="Li">&quot;build_exporter&quot;</span>, not
    <span class="Li">&quot;setup_exporter&quot;</span>. This means that the
    special arguments like &quot;into&quot; and &quot;as&quot; for
    <span class="Li">&quot;setup_exporter&quot;</span> are not accepted here.
    Instead, you may write something like:</p>
<p class="Pp"></p>
<pre>  use Sub::Exporter
    { into =&gt; 'Target::Package' },
    -setup =&gt; {
      -as     =&gt; 'do_import',
      exports =&gt; [ ... ],
    }
  ;
</pre>
<p class="Pp">Finding a good reason for wanting to do this is left as an
    exercise for the reader.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COMPARISONS"><a class="permalink" href="#COMPARISONS">COMPARISONS</a></h1>
<p class="Pp">There are a whole mess of exporters on the CPAN. The features
    included in Sub::Exporter set it apart from any existing Exporter. Here's a
    summary of some other exporters and how they compare.</p>
<ul class="Bl-bullet">
  <li>Exporter and co.
    <p class="Pp">This is the standard Perl exporter. Its interface is a little
        clunky, but it's fast and ubiquitous. It can do some things that
        Sub::Exporter can't: it can export things other than routines, it can
        import &quot;everything in this group except this symbol,&quot; and some
        other more esoteric things. These features seem to go nearly entirely
        unused.</p>
    <p class="Pp">It always exports things exactly as they appear in the
        exporting module; it can't rename or customize routines. Its groups
        (&quot;tags&quot;) can't be nested.</p>
    <p class="Pp">Exporter::Lite is a whole lot like Exporter, but it does
        significantly less: it supports exporting symbols, but not groups,
        pattern matching, or negation.</p>
    <p class="Pp">The fact that Sub::Exporter can't export symbols other than
        subroutines is a good idea, not a missing feature.</p>
    <p class="Pp">For simple uses, setting up Sub::Exporter is about as easy as
        Exporter. For complex uses, Sub::Exporter makes hard things possible,
        which would not be possible with Exporter.</p>
    <p class="Pp">When using a module that uses Sub::Exporter, users familiar
        with Exporter will probably see no difference in the basics. These two
        lines do about the same thing in whether the exporting module uses
        Exporter or Sub::Exporter.</p>
    <p class="Pp"></p>
    <pre>  use Some::Module qw(foo bar baz);
  use Some::Module qw(foo :bar baz);
    </pre>
    <p class="Pp">The definition for exporting in Exporter.pm might look like
        this:</p>
    <p class="Pp"></p>
    <pre>  package Some::Module;
  use base qw(Exporter);
  our @EXPORT_OK   = qw(foo bar baz quux);
  our %EXPORT_TAGS = (bar =&gt; [ qw(bar baz) ]);
    </pre>
    <p class="Pp">Using Sub::Exporter, it would look like this:</p>
    <p class="Pp"></p>
    <pre>  package Some::Module;
  use Sub::Exporter -setup =&gt; {
    exports =&gt; [ qw(foo bar baz quux) ],
    groups  =&gt; { bar =&gt; [ qw(bar baz) ]}
  };
    </pre>
    <p class="Pp">Sub::Exporter respects inheritance, so that a package may
        export inherited routines, and will export the most inherited version.
        Exporting methods without currying away the invocant is a bad idea, but
        Sub::Exporter allows you to do just that -- and anyway, there are other
        uses for this feature, like packages of exported subroutines which use
        inheritance specifically to allow more specialized, but similar,
        packages.</p>
    <p class="Pp">Exporter::Easy provides a wrapper around the standard
        Exporter. It makes it simpler to build groups, but doesn't provide any
        more functionality. Because it is a front-end to Exporter, it will store
        your exporter's configuration in global package variables.</p>
  </li>
  <li>Attribute-Based Exporters
    <p class="Pp">Some exporters use attributes to mark variables to export.
        Exporter::Simple supports exporting any kind of symbol, and supports
        groups. Using a module like Exporter or Sub::Exporter, it's easy to look
        at one place and see what is exported, but it's impossible to look at a
        variable definition and see whether it is exported by that alone.
        Exporter::Simple makes this trade in reverse: each variable's
        declaration includes its export definition, but there is no one place to
        look to find a manifest of exports.</p>
    <p class="Pp">More importantly, Exporter::Simple does not add any new
        features to those of Exporter. In fact, like Exporter::Easy, it is just
        a front-end to Exporter, so it ends up storing its configuration in
        global package variables. (This means that there is one place to look
        for your exporter's manifest, actually. You can inspect the
        <span class="Li">@EXPORT</span> package variables, and other related
        package variables, at runtime.)</p>
    <p class="Pp">Perl6::Export isn't actually attribute based, but looks
        similar. Its syntax is borrowed from Perl 6, and implemented by a source
        filter. It is a prototype of an interface that is still being designed.
        It should probably be avoided for production work. On the other hand,
        Perl6::Export::Attrs implements Perl 6-like exporting, but translates it
        into Perl 5 by providing attributes.</p>
  </li>
  <li>Other Exporters
    <p class="Pp">Exporter::Renaming wraps the standard Exporter to allow it to
        export symbols with changed names.</p>
    <p class="Pp">Class::Exporter performs a special kind of routine generation,
        giving each importing package an instance of your class, and then
        exporting the instance's methods as normal routines. (Sub::Exporter, of
        course, can easily emulate this behavior, as shown above.)</p>
    <p class="Pp">Exporter::Tidy implements a form of renaming (using its
        <span class="Li">&quot;_map&quot;</span> argument) and of prefixing, and
        implements groups. It also avoids using package variables for its
        configuration.</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="TODO"><a class="permalink" href="#TODO">TODO</a></h1>
<ul class="Bl-bullet">
  <li>write a set of longer, more demonstrative examples</li>
  <li>solidify the &quot;custom exporter&quot; interface (see
      <span class="Li">&amp;default_exporter</span>)</li>
  <li>add an &quot;always&quot; group</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="THANKS"><a class="permalink" href="#THANKS">THANKS</a></h1>
<p class="Pp">Hans Dieter Pearcey provided helpful advice while I was writing
    Sub::Exporter. Ian Langworth and Shawn Sorichetti asked some good questions
    and helped me improve my documentation quite a bit. Yuval Kogman helped me
    find a bunch of little problems.</p>
<p class="Pp">Thanks, guys!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">Please report any bugs or feature requests through the web
    interface at &lt;http://rt.cpan.org&gt;. I will be notified, and then you'll
    automatically be notified of progress on your bug as I make changes.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Ricardo Signes &lt;rjbs@cpan.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2007 by Ricardo Signes.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-10-18</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

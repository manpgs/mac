<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Parse::Eyapp::Node(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Parse::Eyapp::Node(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Parse::Eyapp::Node(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Parse::Eyapp::Node - The nodes of the Syntax Trees</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
  use Parse::Eyapp;
  use Parse::Eyapp::Treeregexp;

  sub TERMINAL::info {
    $_[0]{attr}
  }

  my $grammar = q{
    %right  '='     # Lowest precedence
    %left   '-' '+' # + and - have more precedence than = Disambiguate a-b-c as (a-b)-c
    %left   '*' '/' # * and / have more precedence than + Disambiguate a/b/c as (a/b)/c
    %left   NEG     # Disambiguate -a-b as (-a)-b and not as -(a-b)
    %tree           # Let us build an abstract syntax tree ...

    %%
    line:
        exp &lt;%name EXPRESSION_LIST + ';'&gt;
          { $_[1] } /* list of expressions separated by ';' */
    ;

    /* The %name directive defines the name of the class to 
       which the node being built belongs */
    exp:
        %name NUM
        NUM
      | %name VAR
        VAR
      | %name ASSIGN
        VAR '=' exp
      | %name PLUS
        exp '+' exp
      | %name MINUS
        exp '-' exp
      | %name TIMES
        exp '*' exp
      | %name DIV
        exp '/' exp
      | %name UMINUS
        '-' exp %prec NEG
      | '(' exp ')'
          { $_[2] }  /* Let us simplify a bit the tree */
    ;

    %%
    sub _Error { die &quot;Syntax error near &quot;.($_[0]-&gt;YYCurval?$_[0]-&gt;YYCurval:&quot;end of file&quot;).&quot;\n&quot; }

    sub _Lexer {
      my($parser)=shift; # The parser object

      for ($parser-&gt;YYData-&gt;{INPUT}) { # Topicalize
        m{\G\s+}gc;
        $_ eq '' and return('',undef);
        m{\G([0-9]+(?:\.[0-9]+)?)}gc and return('NUM',$1);
        m{\G([A-Za-z][A-Za-z0-9_]*)}gc and return('VAR',$1);
        m{\G(.)}gcs and return($1,$1);
      }
      return('',undef);
    }

    sub Run {
        my($self)=shift;
        $self-&gt;YYParse( yylex =&gt; \&amp;_Lexer, yyerror =&gt; \&amp;_Error, );
    }
  }; # end grammar

  our (@all, $uminus);

  Parse::Eyapp-&gt;new_grammar( # Create the parser package/class
    input=&gt;$grammar,
    classname=&gt;'Calc', # The name of the package containing the parser
    firstline=&gt;7       # String $grammar starts at line 7 (for error diagnostics)
  );
  my $parser = Calc-&gt;new();                # Create a parser
  $parser-&gt;YYData-&gt;{INPUT} = &quot;2*-3+b*0;--2\n&quot;; # Set the input
  my $t = $parser-&gt;Run;                    # Parse it!
  local $Parse::Eyapp::Node::INDENT=2;
  print &quot;Syntax Tree:&quot;,$t-&gt;str;

  # Let us transform the tree. Define the tree-regular expressions ..
  my $p = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
      { #  Example of support code
        my %Op = (PLUS=&gt;'+', MINUS =&gt; '-', TIMES=&gt;'*', DIV =&gt; '/');
      }
      constantfold: /TIMES|PLUS|DIV|MINUS/:bin(NUM($x), NUM($y))
        =&gt; {
          my $op = $Op{ref($bin)};
          $x-&gt;{attr} = eval  &quot;$x-&gt;{attr} $op $y-&gt;{attr}&quot;;
          $_[0] = $NUM[0];
        }
      uminus: UMINUS(NUM($x)) =&gt; { $x-&gt;{attr} = -$x-&gt;{attr}; $_[0] = $NUM }
      zero_times_whatever: TIMES(NUM($x), .) and { $x-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
      whatever_times_zero: TIMES(., NUM($x)) and { $x-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
    },
    OUTPUTFILE=&gt; 'main.pm'
  );
  $p-&gt;generate(); # Create the tranformations

  $t-&gt;s($uminus); # Transform UMINUS nodes
  $t-&gt;s(@all);    # constant folding and mult. by zero

  local $Parse::Eyapp::Node::INDENT=0;
  print &quot;\nSyntax Tree after transformations:\n&quot;,$t-&gt;str,&quot;\n&quot;;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<p class="Pp">The <span class="Li">&quot;Parse::Eyapp::Node&quot;</span> objects
    represent the nodes of the syntax tree. All the node classes build by
    <span class="Li">%tree</span> and <span class="Li">%metatree</span>
    directives inherit from
    <span class="Li">&quot;Parse::Eyapp::Node&quot;</span> and consequently have
    acces to the methods provided in such module.</p>
<p class="Pp">The examples used in this document can be found in the directory
    <span class="Li">&quot;examples/Node&quot;</span> accompanying the
    distribution of Parse::Eyapp.</p>
<section class="Ss">
<h2 class="Ss" id="Parse::Eyapp::Node"><a class="permalink" href="#Parse::Eyapp::Node">Parse::Eyapp::Node-&gt;new</a></h2>
<p class="Pp">Nodes are usually created from a Eyapp grammar using the
    <span class="Li">%tree</span> or <span class="Li">%metatree</span>
    directives. The <span class="Li">&quot;Parse::Eyapp::Node&quot;</span>
    constructor <span class="Li">&quot;new&quot;</span> offers an alternative
    way to create forests.</p>
<p class="Pp">This class method can be used to build multiple nodes on a row. It
    receives a string describing the tree and optionally a reference to a
    subroutine. Such subroutine (called the attribute handler) is in charge to
    initialize the attributes of the just created nodes. The attribute handler
    is called with the array of references to the nodes as they appear in the
    string from left to right.</p>
<p class="Pp"><span class="Li">&quot;Parse::Eyapp::Node-&gt;new&quot;</span>
    returns an array of pointers to the nodes created as they appear in the
    input string from left to right. In scalar context returns a pointer to the
    first of these trees.</p>
<p class="Pp">The following example (see file
    <span class="Li">&quot;examples/Node/28foldwithnewwithvars.pl&quot;</span>)
    of a treeregexp transformation creates a new
    <span class="Li">&quot;NUM(TERMINAL)&quot;</span> node using
    <span class="Li">&quot;Parse::Eyapp::Node-&gt;new&quot;</span>:</p>
<p class="Pp"></p>
<pre>
 my $p = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
   {
     my %Op = (PLUS=&gt;'+', MINUS =&gt; '-', TIMES=&gt;'*', DIV =&gt; '/');
   }
   constantfold: /TIMES|PLUS|MINUS|DIV/(NUM($x), NUM($y))
      =&gt; {
     my $op = $Op{ref($_[0])};

     my $res = Parse::Eyapp::Node-&gt;new(
       q{NUM(TERMINAL)},
       sub {
         my ($NUM, $TERMINAL) = @_;
         $TERMINAL-&gt;{attr} = eval &quot;$x-&gt;{attr} $op $y-&gt;{attr}&quot;;
         $TERMINAL-&gt;{token} = 'NUM';
       },
     );
     $_[0] = $res;
   }
   },
 );
</pre>
<p class="Pp">The call to
    <span class="Li">&quot;Parse::Eyapp::Node-&gt;new&quot;</span> creates a
    tree <span class="Li">&quot;NUM(TERMINAL)&quot;</span> and decorates the
    <span class="Li">&quot;TERMINAL&quot;</span> leaf with attributes
    <span class="Li">&quot;attr&quot;</span> and
    <span class="Li">&quot;token&quot;</span>. The
    <span class="Li">&quot;constantfold&quot;</span> transformation substitutes
    all the binary operation trees whose children are numbers for a
    <span class="Li">&quot;NUM(TERMINAL)&quot;</span> tree holding as attribute
    the number resulting of operating the two numbers.</p>
<p class="Pp">The input string can describe more than one tree. Different trees
    are separated by white spaces. Consider the following example (in
    <span class="Li">&quot;examples/Node/builder.pl&quot;</span>):</p>
<p class="Pp"></p>
<pre>
  $ cat -n builder.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use Parse::Eyapp::Node;
     4
     5  use Data::Dumper;
     6  $Data::Dumper::Indent = 1;
     7  $Data::Dumper::Purity = 1;
     8
     9  my $string = shift || 'ASSIGN(VAR(TERMINAL), TIMES(NUM(TERMINAL),NUM(TERMINAL)))  ';
    10  my @t = Parse::Eyapp::Node-&gt;new(
    11             $string,
    12             sub { my $i = 0; $_-&gt;{n} = $i++ for @_ }
    13          );
    14
    15  print &quot;****************\n&quot;;
    16  print Dumper(\@t);
</pre>
<p class="Pp">When feed with input <span class="Li">'A(C,D) E(F)'</span> the
    following forest is built:</p>
<p class="Pp"></p>
<pre>
  $ builder.pl 'A(C,D) E(F)'
  ****************
  $VAR1 = [
    bless( {
      'n' =&gt; 0,
      'children' =&gt; [
        bless( { 'n' =&gt; 1, 'children' =&gt; [] }, 'C' ),
        bless( { 'n' =&gt; 2, 'children' =&gt; [] }, 'D' )
      ]
    }, 'A' ),
    {},
    {},
    bless( {
      'n' =&gt; 3,
      'children' =&gt; [
        bless( { 'n' =&gt; 4, 'children' =&gt; [] }, 'F' )
      ]
    }, 'E' ),
    {}
  ];
  $VAR1-&gt;[1] = $VAR1-&gt;[0]{'children'}[0];
  $VAR1-&gt;[2] = $VAR1-&gt;[0]{'children'}[1];
  $VAR1-&gt;[4] = $VAR1-&gt;[3]{'children'}[0];
</pre>
<p class="Pp">Thusm, the forest <span class="Li">@t</span> contains 5 subtrees
    <span class="Li">&quot;A(C,D), C, D, E(F)&quot;</span> and
    <span class="Li">&quot;F&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Directed_Acyclic_Graphs_with__Parse::Eyapp::Node"><a class="permalink" href="#Directed_Acyclic_Graphs_with__Parse::Eyapp::Node">Directed
  Acyclic Graphs with &quot;Parse::Eyapp::Node-&gt;hnew&quot;</a></h2>
<p class="Pp"><span class="Li">&quot;Parse::Eyapp&quot;</span> provides the
    method <span class="Li">&quot;Parse::Eyapp::Node-&gt;hnew&quot;</span> to
    build <i>Directed Acyclic Graphs</i> (DAGs) instead of trees. They are built
    using <i>hashed consing</i>, i.e. <i>memoizing</i> the creation of
  nodes.</p>
<p class="Pp">The method
    <span class="Li">&quot;Parse::Eyapp::Node-&gt;hnew&quot;</span> works very
    much like <span class="Li">&quot;Parse::Eyapp::Node-&gt;new&quot;</span> but
    if one of the implied trees was previously built,
    <span class="Li">&quot;hnew&quot;</span> returns a reference to the existing
    one.</p>
<p class="Pp">See the following debugger session where several DAGs describing
    <i>type expressions</i> are built:</p>
<p class="Pp"></p>
<pre>
  DB&lt;2&gt; x $a = Parse::Eyapp::Node-&gt;hnew('F(X_3(A_3(A_5(INT)), CHAR, A_5(INT)),CHAR)')
 0  F=HASH(0x85f6a20)
    'children' =&gt; ARRAY(0x85e92e4)
    |- 0  X_3=HASH(0x83f55fc)
    |     'children' =&gt; ARRAY(0x83f5608)
    |     |- 0  A_3=HASH(0x85a0488)
    |     |     'children' =&gt; ARRAY(0x859fad4)
    |     |        0  A_5=HASH(0x85e5d3c)
    |     |           'children' =&gt; ARRAY(0x83f4120)
    |     |              0  INT=HASH(0x83f5200)
    |     |                 'children' =&gt; ARRAY(0x852ccb4)
    |     |                      empty array
    |     |- 1  CHAR=HASH(0x8513564)
    |     |     'children' =&gt; ARRAY(0x852cad4)
    |     |          empty array
    |     `- 2  A_5=HASH(0x85e5d3c)
    |           -&gt; REUSED_ADDRESS
    `- 1  CHAR=HASH(0x8513564)
          -&gt; REUSED_ADDRESS
  DB&lt;3&gt; x $a-&gt;str
 0  'F(X_3(A_3(A_5(INT)),CHAR,A_5(INT)),CHAR)'
</pre>
<p class="Pp">The second occurrence of
    <span class="Li">&quot;A_5(INT)&quot;</span> is labelled
    <span class="Li">&quot;REUSED_ADDRESS&quot;</span>. The same occurs with the
    second instance of <span class="Li">&quot;CHAR&quot;</span>.</p>
<p class="Pp"><span class="Li">&quot;Parse::Eyapp::Node-&gt;hnew&quot;</span>
    can be more convenient than <span class="Li">&quot;new&quot;</span> in some
    compiler phases and tasks like detecting <i>common subexpressions</i> or
    during <i>type checking</i>. See file
    <span class="Li">&quot;Types.eyp&quot;</span> in
    <span class="Li">&quot;examples/typechecking/Simple-Types-XXX.tar.gz&quot;</span>
    for a more comprehensive example.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Expanding_Directed_Acyclic_Graphs_with__Parse::Eyapp::Node"><a class="permalink" href="#Expanding_Directed_Acyclic_Graphs_with__Parse::Eyapp::Node">Expanding
  Directed Acyclic Graphs with
  &quot;Parse::Eyapp::Node-&gt;hexpand&quot;</a></h2>
<p class="Pp">Calls to
    <span class="Li">&quot;Parse::Eyapp::Node-&gt;hexpand&quot;</span> have the
    syntax</p>
<p class="Pp"></p>
<pre>
    $z = Parse::Eyapp::Node-&gt;hexpand('CLASS', @children, \&amp;handler)
</pre>
<p class="Pp">Creates a dag of type <span class="Li">'CLASS'</span> with
    children <span class="Li">@children</span> in a way compatible with
    <span class="Li">&quot;hnew&quot;</span>. The last optional argument can be
    a reference to a sub. Such sub will be called after the creation of the DAG
    with a reference to the root of the DAG as single argument. The following
    session with the debugger illustrates the use of
  <br/>
   <span class="Li">&quot;Parse::Eyapp::Node-&gt;hexpand&quot;</span>. First we
    create a DAG using <span class="Li">&quot;hnew&quot;</span>:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/Lbook/code/Simple-Types/script$ perl -MParse::Eyapp::Node -wde 0
  main::(-e:1):   0
    DB&lt;1&gt; $x = Parse::Eyapp::Node-&gt;hnew('A(C(B),C(B))')
    DB&lt;2&gt; x $x
  0  A=HASH(0x850c850)
     'children' =&gt; ARRAY(0x850ca30)
        0  C=HASH(0x850c928)
           'children' =&gt; ARRAY(0x850c9e8)
              0  B=HASH(0x850c9a0)
                 'children' =&gt; ARRAY(0x83268c8)
                      empty array
        1  C=HASH(0x850c928)
           -&gt; REUSED_ADDRESS
</pre>
<p class="Pp">We obtain the <span class="Li">&quot;REUSED_ADDRESS&quot;</span>
    for the second child since the <span class="Li">C(B)</span> subtree appears
    twice. Now, suppose we want to expand the exsting tree/DAG
    <span class="Li">C(B)</span> to <span class="Li">&quot;A(C(B))&quot;</span>.
    We can do that using <span class="Li">&quot;hexpand&quot;</span>:</p>
<p class="Pp"></p>
<pre>
    DB&lt;3&gt; $y = Parse::Eyapp::Node-&gt;hexpand('A', $x-&gt;child(0))
    DB&lt;4&gt; x $y
  0  A=HASH(0x8592558)
     'children' =&gt; ARRAY(0x832613c)
        0  C=HASH(0x850c928)
           'children' =&gt; ARRAY(0x850c9e8)
              0  B=HASH(0x850c9a0)
                 'children' =&gt; ARRAY(0x83268c8)
                      empty array
We get new memory for C&lt;$y&gt;: C&lt;HASH(0x8592558)&gt; is anew address.
Assume we want to expand the tree/DAG C&lt;C(B)&gt; to C&lt;A(C(B),C(B))&gt;.
We can do it this way:

    DB&lt;5&gt; $z = Parse::Eyapp::Node-&gt;hexpand('A', $x-&gt;children)
    DB&lt;6&gt; x $z
  0  A=HASH(0x850c850)
     'children' =&gt; ARRAY(0x850ca30)
        0  C=HASH(0x850c928)
           'children' =&gt; ARRAY(0x850c9e8)
              0  B=HASH(0x850c9a0)
                 'children' =&gt; ARRAY(0x83268c8)
                      empty array
        1  C=HASH(0x850c928)
           -&gt; REUSED_ADDRESS
</pre>
<p class="Pp">Notice that the address c&lt;0x850c850&gt; for
    <span class="Li">$z</span> is the same than the address for
    <span class="Li">$x</span>. No new memory has been allocated for
    <span class="Li">$z</span>.</p>
<p class="Pp">The following command illustrates the use of
    <span class="Li">&quot;hexpand&quot;</span> with a handler:</p>
<p class="Pp"></p>
<pre>
    DB&lt;7&gt; $z = Parse::Eyapp::Node-&gt;hexpand('A', $x-&gt;children, sub { $_[0]-&gt;{t} = &quot;X&quot; })
    DB&lt;8&gt; x $z
  0  A=HASH(0x850c850)
     'children' =&gt; ARRAY(0x850ca30)
        0  C=HASH(0x850c928)
           'children' =&gt; ARRAY(0x850c9e8)
              0  B=HASH(0x850c9a0)
                 'children' =&gt; ARRAY(0x83268c8)
                      empty array
        1  C=HASH(0x850c928)
           -&gt; REUSED_ADDRESS
     't' =&gt; 'X'
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$node"><a class="permalink" href="#$node">$node-&gt;type</a></h2>
<p class="Pp">Returns (or sets) the type (class) of the node. It can be called
    as a subroutine when <span class="Li">$node</span> is not a
    <span class="Li">&quot;Parse::Eyapp::Node&quot;</span> like this:</p>
<p class="Pp"></p>
<pre>
                     Parse::Eyapp::Node::type($scalar)
</pre>
<p class="Pp">This is the case when visiting
    <span class="Li">&quot;CODE&quot;</span> nodes.</p>
<p class="Pp">The following session with the debugger illustrates how it
  works:</p>
<p class="Pp"></p>
<pre>
  &gt; perl -MParse::Eyapp::Node -de0
  DB&lt;1&gt; @t = Parse::Eyapp::Node-&gt;new(&quot;A(B,C)&quot;) # Creates a tree
  DB&lt;2&gt; x map { $_-&gt;type } @t # Get the types of the three nodes
  0  'A'
  1  'B'
  2  'C'
  DB&lt;3&gt; x Parse::Eyapp::Node::type(sub {})
  0  'CODE'
  DB&lt;4&gt; x Parse::Eyapp::Node::type(&quot;hola&quot;)
  0  'Parse::Eyapp::Node::STRING'
  DB&lt;5&gt; x Parse::Eyapp::Node::type({ a=&gt; 1})
  0  'HASH'
  DB&lt;6&gt; x Parse::Eyapp::Node::type([ a, 1 ])
  0  'ARRAY'
</pre>
<p class="Pp">As it is shown in the example it can be called as a subroutine
    with a (CODE/HASH/ARRAY) reference or an ordinary scalar.</p>
<p class="Pp">The words HASH, CODE, ARRAY and STRING are reserved for ordinary
    Perl references. Avoid naming a AST node with one of those words.</p>
<p class="Pp">To be used as a setter, be sure Parse::Eyapp::Driver is
  loaded:</p>
<p class="Pp"></p>
<pre>
  $ perl -MParse::Eyapp::Driver -MParse::Eyapp::Node -wde0
  main::(-e:1):   0
    DB&lt;1&gt; x $t = Parse::Eyapp::Node-&gt;new(&quot;A(B,C)&quot;) # Creates a tree
  0  A=HASH(0x8557bdc)
     'children' =&gt; ARRAY(0x8557c90)
        0  B=HASH(0x8557cf0)
           'children' =&gt; ARRAY(0x8325804)
                empty array
        1  C=HASH(0x8557c6c)
           'children' =&gt; ARRAY(0x8557d5c)
                empty array
    DB&lt;2&gt; x $t-&gt;type('FUN') # Change the type of $t to 'FUN'
  0  'FUN'
    DB&lt;3&gt; x $t
  0  FUN=HASH(0x8557bdc)
     'children' =&gt; ARRAY(0x8557c90)
        0  B=HASH(0x8557cf0)
           'children' =&gt; ARRAY(0x8325804)
                empty array
        1  C=HASH(0x8557c6c)
           'children' =&gt; ARRAY(0x8557d5c)
                empty array
    DB&lt;4&gt; x $t-&gt;isa('Parse::Eyapp::Node')
  0  1
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$node~2"><a class="permalink" href="#$node~2">$node-&gt;child</a></h2>
<p class="Pp">Setter-getter to modify a specific child of a node. It is called
    like:</p>
<p class="Pp"></p>
<pre>
                   $node-&gt;child($i)
</pre>
<p class="Pp">Returns the child with index <span class="Li">$i</span>. Returns
    <span class="Li">&quot;undef&quot;</span> if the child does not exists. It
    has two obligatory parameters: the node (since it is a method) and the index
    of the child. Sets the new value if called</p>
<p class="Pp"></p>
<pre>
                    $node-&gt;child($i, $tree)
</pre>
<p class="Pp">The method will croak if the obligatory parameters are not
    provided.</p>
<p class="Pp">In the files
    <span class="Li">&quot;examples/Node/TSwithtreetransformations2.eyp&quot;</span>
    and
    <span class="Li">&quot;examples/node/usetswithtreetransformations2.pl&quot;</span>)
    you can find a somewhat complicated example of call to
    <span class="Li">&quot;child&quot;</span> as a setter. It is inside a
    transformation that swaps the children of a
    <span class="Li">&quot;PLUS&quot;</span> node (remember that the tree is a
    concrete tree including code since it is a translation scheme built under
    the directive <span class="Li">%metatree</span>):</p>
<p class="Pp"></p>
<pre>
  my $transform = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
     ........................................................

     commutative_add: PLUS($x, ., $y, .) # 1st dot correspond to '+' 2nd dot to CODE
       =&gt; { my $t = $x; $_[0]-&gt;child(0, $y); $_[0]-&gt;child(2, $t)}

     ........................................................
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Child_Access_Through___tree_alias_"><a class="permalink" href="#Child_Access_Through___tree_alias_">Child
  Access Through &quot;%tree alias&quot;</a></h2>
<p class="Pp">Remember that when the <span class="Li">&quot;Eyapp&quot;</span>
    program runs under the <span class="Li">&quot;%tree alias&quot;</span>
    directive The <i>dot and dollar notations</i> can be used to generate named
    getter-setters to access the children:</p>
<p class="Pp"></p>
<pre>
  examples/Node$ cat -n alias_and_yyprefix.pl
     1  #!/usr/local/bin/perl
     2  use warnings;
     3  use strict;
     4  use Parse::Eyapp;
     5
     6  my $grammar = q{
     7    %prefix R::S::
     8
     9    %right  '='
    10    %left   '-' '+'
    11    %left   '*' '/'
    12    %left   NEG
    13    %tree bypass alias
    14
    15    %%
    16    line: $exp  { $_[1] }
    17    ;
    18
    19    exp:
    20        %name NUM
    21              $NUM
    22      | %name VAR
    23              $VAR
    24      | %name ASSIGN
    25              $VAR '=' $exp
    26      | %name PLUS
    27              exp.left '+' exp.right
    28      | %name MINUS
    29              exp.left '-' exp.right
    30      | %name TIMES
    31              exp.left '*' exp.right
    32      | %name DIV
    33              exp.left '/' exp.right
    34      | %no bypass UMINUS
    35              '-' $exp %prec NEG
    36      |   '(' exp ')'  { $_[2] } /* Let us simplify a bit the tree */
    37    ;
    38
    39    %%
    40
    .............................
    76  }; # end grammar
    77
    78
    79  Parse::Eyapp-&gt;new_grammar(
    80    input=&gt;$grammar,
    81    classname=&gt;'Alias',
    82    firstline =&gt;7,
    83    outputfile =&gt; 'main',
    84  );
    85  my $parser = Alias-&gt;new();
    86  $parser-&gt;YYData-&gt;{INPUT} = &quot;a = -(2*3+5-1)\n&quot;;
    87  my $t = $parser-&gt;Run;
    88  $Parse::Eyapp::Node::INDENT=0;
    89  print $t-&gt;VAR-&gt;str.&quot;\n&quot;;             # a
    90  print &quot;***************\n&quot;;
    91  print $t-&gt;exp-&gt;exp-&gt;left-&gt;str.&quot;\n&quot;;  # 2*3+5
    92  print &quot;***************\n&quot;;
    93  print $t-&gt;exp-&gt;exp-&gt;right-&gt;str.&quot;\n&quot;; # 1
</pre>
<p class="Pp">Here methods with names <span class="Li">&quot;left&quot;</span>
    and <span class="Li">&quot;right&quot;</span> will be created inside the
    class <span class="Li">&quot;R::S&quot;</span> (see the use of the
    <span class="Li">%prefix</span> directive in line 7) to access the
    corresponding children associated with the two instances of
    <span class="Li">&quot;exp&quot;</span> in the right hand side of the
    production rule. when executed, teh former program produces this output:</p>
<p class="Pp"></p>
<pre>
  examples/Node$ alias_and_yyprefix.pl
  R::S::TERMINAL
  ***************
  R::S::PLUS(R::S::TIMES(R::S::NUM,R::S::NUM),R::S::NUM)
  ***************
  R::S::NUM
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$node~3"><a class="permalink" href="#$node~3">$node-&gt;children</a></h2>
<p class="Pp">Returns the array of children of the node. When the tree is a
    translation scheme the CODE references are also included. See
    <span class="Li">&quot;examples/Node/TSPostfix3.eyp&quot;</span> for an
    example of use inside a Translation Scheme:</p>
<p class="Pp"></p>
<pre>
  examples/Node$ cat TSPostfix3.eyp
  ...................... # precedence declarations

  %metatree

  %defaultaction {
    if (@_==2) {  # NUM and VAR
      $lhs-&gt;{t} = $_[1]-&gt;{attr};
      return
    }
    if (@_==4) { # binary operations
      $lhs-&gt;{t} = &quot;$_[1]-&gt;{t} $_[3]-&gt;{t} $_[2]-&gt;{attr}&quot;;
      return
    }
    die &quot;Fatal Error. Unexpected input. Numargs = &quot;.scalar(@_).&quot;\n&quot;.Parse::Eyapp::Node-&gt;str(@_);
  }

  %%
  line: %name PROG
         exp &lt;%name EXP + ';'&gt;
           { @{$lhs-&gt;{t}} = map { $_-&gt;{t}} ($_[1]-&gt;children()); }

  ;

  exp:        %name NUM NUM
          |   %name VAR VAR
          |   %name ASSIGN VAR '=' exp  {  $lhs-&gt;{t} = &quot;$_[1]-&gt;{attr} $_[3]-&gt;{t} =&quot;; }
          |   %name PLUS   exp '+' exp
          |   %name MINUS  exp '-' exp
          |   %name TIMES  exp '*' exp
          |   %name DIV    exp '/' exp
          |   %name NEG    '-' exp %prec NEG { $_[0]-&gt;{t} = &quot;$_[2]-&gt;{t} NEG&quot; }
          |   '(' exp ')' %begin { $_[2] }
  ;

  %%

  ........................
</pre>
<p class="Pp">The tree in a Translation Scheme contains the references to the
    <span class="Li">&quot;CODE&quot;</span> implementing the semantic actions.
    For example, the syntax tree built by the parser for the input
    <span class="Li">&quot;a=-b*3&quot;</span> in
    <span class="Li">&quot;TSPostfix3.eyp&quot;</span> is:</p>
<p class="Pp"></p>
<pre>
 PROG(EXP(
     ASSIGN(
       TERMINAL[a],
       TERMINAL[=],
       TIMES(
         NEG(TERMINAL[-], VAR(TERMINAL[b], CODE), CODE),
         TERMINAL[*],
         NUM(TERMINAL[3], CODE),
         CODE
       ) # TIMES,
       CODE
     ) # ASSIGN
   ) # EXP,
   CODE
 ) # PROG
</pre>
<p class="Pp"><span class="Li">&quot;$node-&gt;children&quot;</span> can also be
    used as a setter.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$node~4"><a class="permalink" href="#$node~4">$node-&gt;Children</a></h2>
<p class="Pp">Returns the array of children of the node. When dealing with a
    translation scheme, the
    <span class="Li">&quot;$node-&gt;Children&quot;</span> method (Notice the
    case difference with <span class="Li">&quot;$node-&gt;children&quot;</span>,
    first in uppercase) returns the non <span class="Li">&quot;CODE&quot;</span>
    children of the node. The following execution with the debugger of the
    example in <span class="Li">&quot;examples/Node/ts_with_ast.pl&quot;</span>
    illustrates the difference:</p>
<p class="Pp"></p>
<pre>
  examples/Node$ perl -wd ts_with_ast.pl
  main::(ts_with_ast.pl:6):       my $translationscheme = q{
  main::(ts_with_ast.pl:7):       %{
</pre>
<p class="Pp">The <span class="Li">$translationscheme</span> variable contains
    the code of a small calculator:</p>
<p class="Pp"></p>
<pre>
  %metatree

  %left   '-' '+'
  %left   '*'
  %left   NEG

  %%
  line:       %name EXP
                $exp  { $lhs-&gt;{n} = $exp-&gt;{n} }
  ;

  exp:
              %name PLUS
                exp.left '+'  exp.right
                  { $lhs-&gt;{n} .= $left-&gt;{n} + $right-&gt;{n} }
          |   %name TIMES
                exp.left '*' exp.right
                  { $lhs-&gt;{n} = $left-&gt;{n} * $right-&gt;{n} }
          |   %name NUM   $NUM
                  { $lhs-&gt;{n} = $NUM-&gt;{attr} }
          |   '(' $exp ')'  %begin { $exp }
          |   exp.left '-' exp.right
                  { $lhs-&gt;{n} = $left-&gt;{n} - $right-&gt;{n} }

          |   '-' $exp %prec NEG
                  { $lhs-&gt;{n} = -$exp-&gt;{n} }
  ;
</pre>
<p class="Pp">We run the program with input
    <span class="Li">&quot;2+(3)&quot;</span> and stop it at line 88, just after
    the augmented AST (<span class="Li">&quot;CODE&quot;</span> node included)
    has been built:</p>
<p class="Pp"></p>
<pre>
    DB&lt;1&gt; c 88
  main::(ts_with_ast.pl:88):      $t-&gt;translation_scheme;
</pre>
<p class="Pp">Now, let us see the difference between the methods
    <span class="Li">&quot;children&quot;</span> and
    <span class="Li">&quot;Children&quot;</span>:</p>
<p class="Pp"></p>
<pre>
    DB&lt;2&gt; @a = $t-&gt;children; @b = $t-&gt;Children
    DB&lt;3&gt; print Parse::Eyapp::Node::str($_).&quot;\n&quot; for @a
  PLUS(NUM(TERMINAL,CODE),TERMINAL,NUM(TERMINAL,CODE),CODE)
  CODE
    DB&lt;4&gt; print $_-&gt;str.&quot;\n&quot; for @b
  PLUS(NUM(TERMINAL,CODE),TERMINAL,NUM(TERMINAL,CODE),CODE)
    DB&lt;5&gt;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$node~5"><a class="permalink" href="#$node~5">$node-&gt;last_child</a></h2>
<p class="Pp">Return the last child of the node. When dealing with translation
    schemes, the last can be a <span class="Li">&quot;CODE&quot;</span>
  node.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$node~6"><a class="permalink" href="#$node~6">$node-&gt;Last_child</a></h2>
<p class="Pp">The <span class="Li">&quot;$node-&gt;Last_child&quot;</span>
    method returns the last non CODE child of the node. See an example:</p>
<p class="Pp"></p>
<pre>
  examples/Node$ cat -n trans_scheme_default_action.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use Data::Dumper;
     4  use Parse::Eyapp;
     5  use IO::Interactive qw(is_interactive);
     6
     7  my $translationscheme = q{
     8  %{
     9  # head code is available at tree construction time
    10  use Data::Dumper;
    11  our %sym; # symbol table
    12  %}
    13
    14  %prefix Calc::
    15
    16  %defaultaction {
    17     $lhs-&gt;{n} = eval &quot; $left-&gt;{n} $_[2]-&gt;{attr} $right-&gt;{n} &quot;
    18  }
    19
    20  %metatree
    21
    22  %right   '='
    23  %left   '-' '+'
    24  %left   '*' '/'
    25
    26  %%
    27  line:       %name EXP
    28                exp &lt;+ ';'&gt; /* Expressions separated by semicolons */
    29                  { $lhs-&gt;{n} = $_[1]-&gt;Last_child-&gt;{n} }
    30  ;
    31
    32  exp:
    33              %name PLUS
    34                exp.left '+' exp.right
    35          |   %name MINUS
    36                exp.left '-' exp.right
    37          |   %name TIMES
    38                exp.left '*' exp.right
    39          |   %name DIV
    40                exp.left '/' exp.right
    41          |   %name NUM
    42                $NUM
    43                  { $lhs-&gt;{n} = $NUM-&gt;{attr} }
    44          |   '(' $exp ')'  %begin { $exp }
    45          |   %name VAR
    46                $VAR
    47                  { $lhs-&gt;{n} = $sym{$VAR-&gt;{attr}}-&gt;{n} }
    48          |   %name ASSIGN
    49                $VAR '=' $exp
    50                  { $lhs-&gt;{n} = $sym{$VAR-&gt;{attr}}-&gt;{n} = $exp-&gt;{n} }
    51
    52  ;
    53
    54  %%
    55  # tail code is available at tree construction time
    ......................................................
    77  }; # end translation scheme
    78
    ......................................................
</pre>
<p class="Pp">The node associated with <span class="Li">$_[1]</span> in</p>
<p class="Pp"></p>
<pre>
    27  line:       %name EXP
    28                exp &lt;+ ';'&gt; /* Expressions separated by semicolons */
    29                  { $lhs-&gt;{n} = $_[1]-&gt;Last_child-&gt;{n} }
</pre>
<p class="Pp">is associated with the whole expression</p>
<p class="Pp"></p>
<pre>
                               exp &lt;+ ';'&gt;
</pre>
<p class="Pp">and is a <span class="Li">&quot;Calc::_PLUS_LIST&quot;</span>
    node. When feed with input <span class="Li">&quot;a=3;b=4&quot;</span> the
    children are the two <span class="Li">&quot;Calc::ASSIGN&quot;</span>
    subtrees associated with <span class="Li">&quot;a=3&quot;</span> and
    <span class="Li">&quot;b=4&quot;</span> and the
    <span class="Li">&quot;CODE&quot;</span> associated with the semantic
    action:</p>
<p class="Pp"></p>
<pre>
            { $lhs-&gt;{n} = $_[1]-&gt;Last_child-&gt;{n} }
</pre>
<p class="Pp">Using <span class="Li">&quot;Last_child&quot;</span> we are
    avoiding the last <span class="Li">&quot;CODE&quot;</span> child and setting
    the <span class="Li">&quot;n&quot;</span>(umeric) attribute of the
    <span class="Li">&quot;EXP&quot;</span> node to the one associated with
    <span class="Li">&quot;b=4&quot;</span> (i.e.
  <span class="Li">4</span>).</p>
<p class="Pp"></p>
<pre>
  examples/Node$ trans_scheme_default_action.pl
  Write a sequence of arithmetic expressions: a=3;b=4
  ***********Tree*************

  Calc::EXP(
    Calc::_PLUS_LIST(
      Calc::ASSIGN(
        Calc::TERMINAL,
        Calc::TERMINAL,
        Calc::NUM(
          Calc::TERMINAL,
          CODE
        ),
        CODE
      ) # Calc::ASSIGN,
      Calc::ASSIGN(
        Calc::TERMINAL,
        Calc::TERMINAL,
        Calc::NUM(
          Calc::TERMINAL,
          CODE
        ),
        CODE
      ) # Calc::ASSIGN
    ) # Calc::_PLUS_LIST,
    CODE
  ) # Calc::EXP
  ******Symbol table**********
  {
    'a' =&gt; { 'n' =&gt; '3' },
    'b' =&gt; { 'n' =&gt; '4' }
  }

  ************Result**********
  4
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$node~7"><a class="permalink" href="#$node~7">$node-&gt;descendant</a></h2>
<p class="Pp">The <span class="Li">&quot; descendant&quot;</span> method returns
    the descendant of a node given its <i>coordinates</i>. The coordinates of a
    node <span class="Li">$s</span> relative to a tree
    <span class="Li">$t</span> to which it belongs is a string of numbers
    separated by dots like <span class="Li">&quot;.1.3.2&quot;</span> which
    denotes the <i>child path</i> from <span class="Li">$t</span> to
    <span class="Li">$s</span>, i.e. <span class="Li">&quot;$s ==
    $t-&gt;child(1)-&gt;child(3)-&gt;child(2)&quot;</span>.</p>
<p class="Pp">See a session with the debugger:</p>
<p class="Pp"></p>
<pre>
   DB&lt;7&gt; x $t-&gt;child(0)-&gt;child(0)-&gt;child(1)-&gt;child(0)-&gt;child(2)-&gt;child(1)-&gt;str
 0  '
 BLOCK[8:4:test]^{0}(
   CONTINUE[10,10]
 )
   DB&lt;8&gt; x $t-&gt;descendant('.0.0.1.0.2.1')-&gt;str
 0  '
 BLOCK[8:4:test]^{0}(
   CONTINUE[10,10]
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$node~8"><a class="permalink" href="#$node~8">$node-&gt;str</a></h2>
<p class="Pp">The <span class="Li">&quot;str&quot;</span> method returns a
    string representation of the tree. The <i>str</i> method traverses the
    syntax tree dumping the type of the node being visited in a string. To be
    specific the value returned by the function referenced by
    <span class="Li">$CLASS_HANDLER</span> will be dumped. The default value fo
    such function is to return the type of the node. If the node being visited
    has a method <span class="Li">&quot;info&quot;</span> it will be executed
    and its result inserted between <span class="Li">$DELIMITER</span>s into the
    string. Thus, in the &quot;SYNOPSIS&quot; example, by adding the
    <span class="Li">&quot;info&quot;</span> method to the class
    <span class="Li">&quot;TERMINAL&quot;</span>:</p>
<p class="Pp"></p>
<pre>
 sub TERMINAL::info {
   $_[0]{attr}
 }
</pre>
<p class="Pp">we achieve the insertion of attributes in the string being built
    by <span class="Li">&quot;str&quot;</span>.</p>
<p class="Pp">The existence of some methods (like
    <span class="Li">&quot;footnote&quot;</span>) and the values of some package
    variables influence the behavior of <span class="Li">&quot;str&quot;</span>.
    Among the most important are:</p>
<p class="Pp"></p>
<pre>
  @PREFIXES = qw(Parse::Eyapp::Node::);                                # Prefixes to suppress 
  $INDENT = 0; # -1 compact, no info, no footnotes 
               # 0 = compact, 1 = indent, 2 = indent and include Types in closing parenthesis
  $STRSEP = ',';                                # Separator between nodes, by default a comma
  $DELIMITER = '[';                         # The string returned by C&lt;info&gt; will be enclosed 
  $FOOTNOTE_HEADER = &quot;\n---------------------------\n&quot;; 
  $FOOTNOTE_SEP = &quot;)\n&quot;; 
  $FOOTNOTE_LEFT = '^{';                               # Left delimiter for a footnote number
  $FOOTNOTE_RIGHT = '}';                              # Right delimiter for a footnote number
  $LINESEP = 4;                             # When indent=2 the enclosing parenthesis will be
                                            # commented if more than $LINESEP apart
  $CLASS_HANDLER = sub { type($_[0]) }; # What to print to identify the node
</pre>
<p class="Pp">Footnotes and attribute info will not be inserted when
    <span class="Li">$INDENT</span> is -1. A compact representation will be
    obtained. Such representation can be feed to
    <span class="Li">&quot;new&quot;</span> or
    <span class="Li">&quot;hnew&quot;</span> to obtain a copy of the tree. See
    the following session with the debugger:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp$ perl -MParse::Eyapp::Node -wde 0
  main::(-e:1):   0
    DB&lt;1&gt; $x = Parse::Eyapp::Node-&gt;new('A(B(C,D),D)', sub { $_-&gt;{order} = $i++ for @_; })
    DB&lt;2&gt; *A::info = *B::info = *C::info = *D::info = sub { shift()-&gt;{order} }
    DB&lt;3&gt; p $x-&gt;str
  A[0](B[1](C[2],D[3]),D[4])
    DB&lt;4&gt; $Parse::Eyapp::Node::INDENT=-1
    DB&lt;5&gt; p $x-&gt;str
  A(B(C,D),D)
    DB&lt;6&gt; x Parse::Eyapp::Node-&gt;hnew($x-&gt;str)
  0  A=HASH(0x8574704)
     'children' =&gt; ARRAY(0x85745d8)
        0  B=HASH(0x857468c)
           'children' =&gt; ARRAY(0x8574608)
              0  C=HASH(0x85745b4)
                 'children' =&gt; ARRAY(0x8509670)
                      empty array
              1  D=HASH(0x8574638)
                 'children' =&gt; ARRAY(0x857450c)
                      empty array
        1  D=HASH(0x8574638)
           -&gt; REUSED_ADDRESS
  1  B=HASH(0x857468c)
     -&gt; REUSED_ADDRESS
  2  C=HASH(0x85745b4)
     -&gt; REUSED_ADDRESS
  3  D=HASH(0x8574638)
     -&gt; REUSED_ADDRESS
  4  D=HASH(0x8574638)
     -&gt; REUSED_ADDRESS
</pre>
<p class="Pp">The following list defines the <span class="Li">$DELIMITER</span>s
    you can choose for attribute representation:</p>
<p class="Pp"></p>
<pre>
          '[' =&gt; ']', '{' =&gt; '}', '(' =&gt; ')', '&lt;' =&gt; '&gt;'
</pre>
<p class="Pp">If the node being visited has a method
    <span class="Li">&quot;footnote&quot;</span>, the string returned by the
    method will be concatenated at the end of the string as a footnote. The
    variables <span class="Li">$FOOTNOTE_LEFT</span> and
    <span class="Li">$FOOTNOTE_RIGHT</span> govern the displaying of footnote
    numbers.</p>
<p class="Pp">Follows an example of output using
    <span class="Li">&quot;footnotes&quot;</span>.</p>
<p class="Pp"></p>
<pre>
 nereida:~/doc/casiano/PLBOOK/PLBOOK/code/Simple-Types/script&gt; \
                                          usetypes.pl prueba24.c
 PROGRAM^{0}(FUNCTION[f]^{1}(RETURNINT(TIMES(INUM(TERMINAL[2:2]),VAR(TERMINAL[a:2])))))
 ---------------------------
 0)
 Types:
 $VAR1 = {
   'CHAR' =&gt; bless( {
     'children' =&gt; []
   }, 'CHAR' ),
   'VOID' =&gt; bless( {
     'children' =&gt; []
   }, 'VOID' ),
   'INT' =&gt; bless( {
     'children' =&gt; []
   }, 'INT' ),
   'F(X_1(INT),INT)' =&gt; bless( {
     'children' =&gt; [
       bless( {
         'children' =&gt; [
           $VAR1-&gt;{'INT'}
         ]
       }, 'X_1' ),
       $VAR1-&gt;{'INT'}
     ]
   }, 'F' )
 };
 Symbol Table:
 $VAR1 = {
   'f' =&gt; {
     'type' =&gt; 'F(X_1(INT),INT)',
     'line' =&gt; 1
   }
 };

 ---------------------------
 1)
 $VAR1 = {
   'a' =&gt; {
     'type' =&gt; 'INT',
     'param' =&gt; 1,
     'line' =&gt; 1
   }
 };
</pre>
<p class="Pp">The first footnote was due to a call to
    <span class="Li">&quot;PROGRAM:footnote&quot;</span>. The
    <span class="Li">&quot;footnote&quot;</span> method for the
    <span class="Li">&quot;PROGRAM&quot;</span> node was defined as:</p>
<p class="Pp"></p>
<pre>
 nereida:~/doc/casiano/PLBOOK/PLBOOK/code/Simple-Types/lib/Simple&gt; \
                             sed -n -e '691,696p' Types.eyp | cat -n
     1  sub PROGRAM::footnote {
     2    return &quot;Types:\n&quot;
     3           .Dumper($_[0]-&gt;{types}).
     4           &quot;Symbol Table:\n&quot;
     5           .Dumper($_[0]-&gt;{symboltable})
     6  }
</pre>
<p class="Pp">The second footnote was produced by the existence of a
    <span class="Li">&quot;FUNCTION::footnote&quot;</span> method:</p>
<p class="Pp"></p>
<pre>
 nereida:~/doc/casiano/PLBOOK/PLBOOK/code/Simple-Types/lib/Simple&gt; \
                            sed -n -e '702,704p' Types.eyp | cat -n
 1  sub FUNCTION::footnote {
 2    return Dumper($_[0]-&gt;{symboltable})
 3  }
</pre>
<p class="Pp">The source program for the example was:</p>
<p class="Pp"></p>
<pre>
     1  int f(int a) {
     2    return 2*a;
     3  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$node~9"><a class="permalink" href="#$node~9">$node-&gt;equal</a></h2>
<p class="Pp">A call
    <span class="Li">&quot;$tree1-&gt;equal($tree2)&quot;</span> compare the two
    trees <span class="Li">$tree1</span> and <span class="Li">$tree2</span>. Two
    trees are considered equal if their root nodes belong to the same class,
    they have the same number of children and the children are (recursively)
    equal.</p>
<p class="Pp">In Addition to the two trees the programmer can specify pairs
    <span class="Li">&quot;attribute_key =&gt;
  equality_handler&quot;</span>:</p>
<p class="Pp"></p>
<pre>
  $tree1-&gt;equal($tree2, attr1 =&gt; \&amp;handler1, attr2 =&gt; \&amp;handler2, ...)
</pre>
<p class="Pp">In such case the definition of equality is more restrictive: Two
    trees are considered equal if</p>
<ul class="Bl-bullet">
  <li>Their root nodes belong to the same class,</li>
  <li>They have the same number of children</li>
  <li>For each of the specified attributes occur that for both nodes the
      existence and definition of the key is the same</li>
  <li>Assuming the key exists and is defined for both nodes, the equality
      handlers return true for each of its attributes and</li>
  <li>The respective children are (recursively) equal.</li>
</ul>
<p class="Pp">An attribute handler receives as arguments the values of the
    attributes of the two nodes being compared and must return true if, and only
    if, these two attributes are considered equal. Follows an example:</p>
<p class="Pp"></p>
<pre>
  examples/Node$ cat -n equal.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use Parse::Eyapp::Node;
     4
     5  my $string1 = shift || 'ASSIGN(VAR(TERMINAL))';
     6  my $string2 = shift || 'ASSIGN(VAR(TERMINAL))';
     7  my $t1 = Parse::Eyapp::Node-&gt;new($string1, sub { my $i = 0; $_-&gt;{n} = $i++ for @_ });
     8  my $t2 = Parse::Eyapp::Node-&gt;new($string2);
     9
    10  # Without attributes
    11  if ($t1-&gt;equal($t2)) {
    12    print &quot;\nNot considering attributes: Equal\n&quot;;
    13  }
    14  else {
    15    print &quot;\nNot considering attributes: Not Equal\n&quot;;
    16  }
    17
    18  # Equality with attributes
    19  if ($t1-&gt;equal($t2, n =&gt; sub { return $_[0] == $_[1] })) {
    20    print &quot;\nConsidering attributes: Equal\n&quot;;
    21  }
    22  else {
    23    print &quot;\nConsidering attributes: Not Equal\n&quot;;
    24  }
</pre>
<p class="Pp">When the former program is run without arguments produces the
    following output:</p>
<p class="Pp"></p>
<pre>
  examples/Node$ equal.pl

  Not considering attributes: Equal

  Considering attributes: Not Equal
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Using__equal__During_Testing"><a class="permalink" href="#Using__equal__During_Testing">Using
  &quot;equal&quot; During Testing</a></h2>
<p class="Pp">During the development of your compiler you add new stages to the
    existing ones. The consequence is that the AST is decorated with new
    attributes. Unfortunately, this implies that tests you wrote using
    <span class="Li">&quot;is_deeply&quot;</span> and comparisons against
    formerly correct abstract syntax trees are no longer valid. This is due to
    the fact that <span class="Li">&quot;is_deeply&quot;</span> requires both
    tree structures to be equivalent in every detail and that our new code
    produces a tree with new attributes.</p>
<p class="Pp">Instead of <span class="Li">&quot;is_deeply&quot;</span> use the
    <span class="Li">&quot;equal&quot;</span> method to check for partial
    equivalence between abstract syntax trees. You can follow these steps:</p>
<ul class="Bl-bullet">
  <li>Dump the tree for the source inserting
      <span class="Li">&quot;Data::Dumper&quot;</span> statements</li>
  <li>Carefully check that the tree is really correct</li>
  <li>Decide which attributes will be used for comparison</li>
  <li>Write the code for the expected value editing the output produced by
      <span class="Li">&quot;Data::Dumper&quot;</span></li>
  <li>Write the handlers for the attributes you decided. Write the comparison
      using <span class="Li">&quot;equal&quot;</span>.</li>
</ul>
<p class="Pp">Tests using this methodology will not fail even if later code
    decorating the AST with new attributes is introduced.</p>
<p class="Pp">See an example that checks an abstract syntax tree produced by the
    simple compiler (see
    <span class="Li">&quot;examples/typechecking/Simple-Types-XXX.tar.gz&quot;</span>)
    for a really simple source:</p>
<p class="Pp"></p>
<pre>
  Simple-Types/script$ cat prueba27.c
  int f() {
  }
</pre>
<p class="Pp">The first thing is to obtain a description of the tree, that can
    be done executing the compiler under the control of the Perl debugger,
    stopping just after the tree has been built and dumping the tree with
    Data::Dumper:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/Lbook/code/Simple-Types/script$ perl -wd usetypes.pl prueba27.c
  main::(usetypes.pl:5):  my $filename = shift || die &quot;Usage:\n$0 file.c\n&quot;;
    DB&lt;1&gt; c 12
  main::(usetypes.pl:12): Simple::Types::show_trees($t, $debug);
    DB&lt;2&gt; use Data::Dumper
    DB&lt;3&gt; $Data::Dumper::Purity = 1
    DB&lt;4&gt; p Dumper($t)
  $VAR1 = bless( {
                   ..............................................
                 }, 'PROGRAM' );
  ...............................................................
</pre>
<p class="Pp">Once we have the shape of a correct tree we can write our
  tests:</p>
<p class="Pp"></p>
<pre>
  examples/Node$ cat -n testequal.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use Parse::Eyapp::Node;
     4  use Data::Dumper;
     5  use Data::Compare;
     6
     7  my $debugging = 0;
     8
     9  my $handler = sub {
    10    print Dumper($_[0], $_[1]) if $debugging;
    11    Compare($_[0], $_[1])
    12  };
    13
    14  my $t1 = bless( {
    15                   'types' =&gt; {
    16                                'CHAR' =&gt; bless( { 'children' =&gt; [] }, 'CHAR' ),
    17                                'VOID' =&gt; bless( { 'children' =&gt; [] }, 'VOID' ),
    18                                'INT' =&gt; bless( { 'children' =&gt; [] }, 'INT' ),
    19                                'F(X_0(),INT)' =&gt; bless( {
    20                                   'children' =&gt; [
    21                                      bless( { 'children' =&gt; [] }, 'X_0' ),
    22                                      bless( { 'children' =&gt; [] }, 'INT' ) ]
    23                                 }, 'F' )
    24                              },
    25                   'symboltable' =&gt; { 'f' =&gt; { 'type' =&gt; 'F(X_0(),INT)', 'line' =&gt; 1 } },
    26                   'lines' =&gt; 2,
    27                   'children' =&gt; [
    28                                   bless( {
    29                                            'symboltable' =&gt; {},
    30                                            'fatherblock' =&gt; {},
    31                                            'children' =&gt; [],
    32                                            'depth' =&gt; 1,
    33                                            'parameters' =&gt; [],
    34                                            'function_name' =&gt; [ 'f', 1 ],
    35                                            'symboltableLabel' =&gt; {},
    36                                            'line' =&gt; 1
    37                                          }, 'FUNCTION' )
    38                                 ],
    39                   'depth' =&gt; 0,
    40                   'line' =&gt; 1
    41                 }, 'PROGRAM' );
    42  $t1-&gt;{'children'}[0]{'fatherblock'} = $t1;
    43
    44  # Tree similar to $t1 but without some attributes (line, depth, etc.)
    45  my $t2 = bless( {
    46                   'types' =&gt; {
    47                                'CHAR' =&gt; bless( { 'children' =&gt; [] }, 'CHAR' ),
    48                                'VOID' =&gt; bless( { 'children' =&gt; [] }, 'VOID' ),
    49                                'INT' =&gt; bless( { 'children' =&gt; [] }, 'INT' ),
    50                                'F(X_0(),INT)' =&gt; bless( {
    51                                   'children' =&gt; [
    52                                      bless( { 'children' =&gt; [] }, 'X_0' ),
    53                                      bless( { 'children' =&gt; [] }, 'INT' ) ]
    54                                 }, 'F' )
    55                              },
    56                   'symboltable' =&gt; { 'f' =&gt; { 'type' =&gt; 'F(X_0(),INT)', 'line' =&gt; 1 } },
    57                   'children' =&gt; [
    58                                   bless( {
    59                                            'symboltable' =&gt; {},
    60                                            'fatherblock' =&gt; {},
    61                                            'children' =&gt; [],
    62                                            'parameters' =&gt; [],
    63                                            'function_name' =&gt; [ 'f', 1 ],
    64                                          }, 'FUNCTION' )
    65                                 ],
    66                 }, 'PROGRAM' );
    67  $t2-&gt;{'children'}[0]{'fatherblock'} = $t2;
    68
    69  # Tree similar to $t1 but without some attributes (line, depth, etc.)
    70  # and without the symboltable and types attributes used in the comparison
    71  my $t3 = bless( {
    72                   'types' =&gt; {
    73                                'CHAR' =&gt; bless( { 'children' =&gt; [] }, 'CHAR' ),
    74                                'VOID' =&gt; bless( { 'children' =&gt; [] }, 'VOID' ),
    75                                'INT' =&gt; bless( { 'children' =&gt; [] }, 'INT' ),
    76                                'F(X_0(),INT)' =&gt; bless( {
    77                                   'children' =&gt; [
    78                                      bless( { 'children' =&gt; [] }, 'X_0' ),
    79                                      bless( { 'children' =&gt; [] }, 'INT' ) ]
    80                                 }, 'F' )
    81                              },
    82                   'children' =&gt; [
    83                                   bless( {
    84                                            'symboltable' =&gt; {},
    85                                            'fatherblock' =&gt; {},
    86                                            'children' =&gt; [],
    87                                            'parameters' =&gt; [],
    88                                            'function_name' =&gt; [ 'f', 1 ],
    89                                          }, 'FUNCTION' )
    90                                 ],
    91                 }, 'PROGRAM' );
    92
    93  $t3-&gt;{'children'}[0]{'fatherblock'} = $t2;
    94
    95  # Without attributes
    96  if (Parse::Eyapp::Node::equal($t1, $t2)) {
    97    print &quot;\nNot considering attributes: Equal\n&quot;;
    98  }
    99  else {
   100    print &quot;\nNot considering attributes: Not Equal\n&quot;;
   101  }
   102
   103  # Equality with attributes
   104  if (Parse::Eyapp::Node::equal(
   105        $t1, $t2,
   106        symboltable =&gt; $handler,
   107        types =&gt; $handler,
   108      )
   109     ) {
   110        print &quot;\nConsidering attributes: Equal\n&quot;;
   111  }
   112  else {
   113    print &quot;\nConsidering attributes: Not Equal\n&quot;;
   114  }
   115
   116  # Equality with attributes
   117  if (Parse::Eyapp::Node::equal(
   118        $t1, $t3,
   119        symboltable =&gt; $handler,
   120        types =&gt; $handler,
   121      )
   122     ) {
   123        print &quot;\nConsidering attributes: Equal\n&quot;;
   124  }
   125  else {
   126    print &quot;\nConsidering attributes: Not Equal\n&quot;;
   127  }
</pre>
<p class="Pp">The code defining tree <span class="Li">$t1</span> was obtained
    from an output using <span class="Li">&quot;Data::Dumper&quot;</span>. The
    code for trees <span class="Li">$t2</span> and <span class="Li">$t3</span>
    was written using cut-and-paste from <span class="Li">$t1</span>. They have
    the same shape than <span class="Li">$t1</span> but differ in their
    attributes. Tree <span class="Li">$t2</span> shares with
    <span class="Li">$t1</span> the attributes
    <span class="Li">&quot;symboltable&quot;</span> and
    <span class="Li">&quot;types&quot;</span> used in the comparison and so
    <span class="Li">&quot;equal&quot;</span> returns
    <span class="Li">&quot;true&quot;</span> when compared. Since
    <span class="Li">$t3</span> differs from <span class="Li">$t1</span> in the
    attributes <span class="Li">&quot;symboltable&quot;</span> and
    <span class="Li">&quot;types&quot;</span> the call to
    <span class="Li">&quot;equal&quot;</span> returns
    <span class="Li">&quot;false&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$node~10"><a class="permalink" href="#$node~10">$node-&gt;delete</a></h2>
<p class="Pp">The <span class="Li">&quot;$node-&gt;delete($child)&quot;</span>
    method is used to delete the specified child of
    <span class="Li">$node</span>. The child to delete can be specified using
    the index or a reference. It returns the deleted child.</p>
<p class="Pp">Throws an exception if the object can't do
    <span class="Li">&quot;children&quot;</span> or has no
    <span class="Li">&quot;children&quot;</span>. See also the delete method of
    treeregexes (<span class="Li">&quot;Parse::Eyapp:YATW&quot;</span> objects)
    to delete the node being visited.</p>
<p class="Pp">The following example moves out of a loop an assignment statement
    assuming is an invariant of the loop. To do it, it uses the
    <span class="Li">&quot;delete&quot;</span> and
    <span class="Li">&quot;insert_before&quot;</span> methods:</p>
<p class="Pp"></p>
<pre>
  nereida:~/src/perl/YappWithDefaultAction/examples&gt; \
              sed -ne '98,113p' moveinvariantoutofloopcomplexformula.pl
  my $p = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
    moveinvariant: BLOCK(
                     @prests,
                     WHILE(VAR($b), BLOCK(@a, ASSIGN($x, NUM($e)), @c)),
                     @possts
                   )
      =&gt; {
           my $assign = $ASSIGN;
           $BLOCK[1]-&gt;delete($ASSIGN);
           $BLOCK[0]-&gt;insert_before($WHILE, $assign);
         }
    },
    FIRSTLINE =&gt; 99,
  );
  $p-&gt;generate();
  $moveinvariant-&gt;s($t);
</pre>
<p class="Pp">The example below deletes CODE nodes from the tree build for a
    translation scheme:</p>
<p class="Pp"></p>
<pre>
  my $transform = Parse::Eyapp::Treeregexp-&gt;new( 
    STRING=&gt;q{
      delete_code: CODE =&gt; { Parse::Eyapp::Node::delete($CODE) }
    },
  )
</pre>
<p class="Pp">Observe how delete is called as a subroutine.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$node~11"><a class="permalink" href="#$node~11">$node-&gt;unshift($newchild)</a></h2>
<p class="Pp">Inserts <span class="Li">$newchild</span> at the beginning of the
    list of children of <span class="Li">$node</span>. See also the unshift
    method for <span class="Li">&quot;Parse::Eyapp:YATW&quot;</span> treeregexp
    transformation objects</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$node~12"><a class="permalink" href="#$node~12">$node-&gt;push($newchild)</a></h2>
<p class="Pp">Inserts <span class="Li">$newchild</span> at the end of the list
    of children of <span class="Li">$node</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss">$node-&gt;insert_before($position, $new_child)</h2>
<p class="Pp">Inserts <span class="Li">$newchild</span> before
    <span class="Li">$position</span> in the list of children of
    <span class="Li">$node</span>. Variable <span class="Li">$position</span>
    can be an index or a reference.</p>
<p class="Pp">The method throws an exception if
    <span class="Li">$position</span> is an index and is not in range. Also if
    <span class="Li">$node</span> has no children.</p>
<p class="Pp">The method throws a warning if <span class="Li">$position</span>
    is a reference and does not define an actual child. In such case
    <span class="Li">$new_child</span> is not inserted.</p>
<p class="Pp">See also the insert_before method for
    <span class="Li">&quot;Parse::Eyapp:YATW&quot;</span> treeregexp
    transformation objects</p>
</section>
<section class="Ss">
<h2 class="Ss">$node-&gt;insert_after($position, $new_child)</h2>
<p class="Pp">Inserts <span class="Li">$newchild</span> after
    <span class="Li">$position</span> in the list of children of
    <span class="Li">$node</span>. Variable <span class="Li">$position</span>
    can be an index or a reference.</p>
<p class="Pp">The method throws an exception if
    <span class="Li">$position</span> is an index and is not in the range of
    <span class="Li">&quot;$node-&quot;</span>children&gt;.</p>
<p class="Pp">The method throws a warning if <span class="Li">$position</span>
    is a reference and does not exists in the list of children. In such case
    <span class="Li">$new_child</span> is not inserted.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$node~13"><a class="permalink" href="#$node~13">$node-&gt;translation_scheme</a></h2>
<p class="Pp">Traverses <span class="Li">$node</span>. Each time a CODE node is
    visited the subroutine referenced is called with arguments the node and its
    children. Usually the code will decorate the nodes with new attributes or
    will update existing ones. Obviously this method does nothing for an
    ordinary AST. It is used after compiling an Eyapp program that makes use of
    the <span class="Li">%metatree</span> directive. (See
    <span class="Li">&quot;examples/Node/TSPostfix3.eyp&quot;</span> for an
    example).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$node~14"><a class="permalink" href="#$node~14">$node-&gt;bud(@transformations)</a></h2>
<p class="Pp">Bottom-up decorator. The tree is traversed bottom-up. The set of
    transformations in <span class="Li">@transformations</span> is applied to
    each node in the tree referenced by <span class="Li">$node</span> in the
    order supplied by the user. <i>As soon as one succeeds</i> <i>no more
    transformations are applied</i>.</p>
<p class="Pp">For an example see the files
    <span class="Li">&quot;lib/Simple/Types.eyp&quot;</span> and
    <span class="Li">&quot;lib/Simple/Trans.trg&quot;</span> in
    <span class="Li">&quot;examples/typechecking/Simple-Types-XXX.tar.gz&quot;</span>
    shows an extract of the type-checking phase of a toy-example compiler:</p>
<p class="Pp"></p>
<pre>
  examples/typechecking/Simple-Types-0.4/lib/Simple$  sed -ne '600,613p' Types.eyp
   my @typecheck = (     # Check typing transformations for
     our $inum,          # - Numerical constantss
     our $charconstant,  # - Character constants
     our $bin,           # - Binary Operations
     our $arrays,        # - Arrays
     our $assign,        # - Assignments
     our $control,       # - Flow control sentences
     our $functioncall,  # - Function calls
     our $statements,    # - Those nodes with void type
                         #   (STATEMENTS, PROGRAM, etc.)
     our $returntype,    # - Return
   );

   $t-&gt;bud(@typecheck);
</pre>
<p class="Pp">You can find another example of use of
    <span class="Li">&quot;bud&quot;</span> in the file
    <span class="Li">&quot;examples/ParsingStringsAndTrees/infix2pir.pl&quot;</span></p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Parse::Eyapp:YATW__Methods"><a class="permalink" href="#Parse::Eyapp:YATW__Methods">Parse::Eyapp:YATW
  Methods</a></h1>
<p class="Pp"><span class="Li">&quot;Parse::Eyapp:YATW&quot;</span> objects
    represent tree transformations. They carry the information of what nodes
    match and how to modify them.</p>
<section class="Ss">
<h2 class="Ss" id="Parse::Eyapp::YATW"><a class="permalink" href="#Parse::Eyapp::YATW">Parse::Eyapp::YATW-&gt;new</a></h2>
<p class="Pp">Builds a treeregexp transformation object. Though usually you
    build a transformation by means of Treeregexp programs you can directly
    invoke the method to build a tree transformation. A transformation object
    can be built from a function that conforms to the YATW tree transformation
    call protocol (see the section &quot;The YATW Tree Transformation Call
    Protocol&quot;). Follows an example (file
    <span class="Li">&quot;examples/12ts_simplify_with_s.pl&quot;</span>):</p>
<p class="Pp"></p>
<pre>
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; \
        sed -ne '68,$p' 12ts_simplify_with_s.pl | cat -n
  1  sub is_code {
  2    my $self = shift; # tree
  3
  4    # After the shift $_[0] is the father, $_[1] the index
  5    if ((ref($self) eq 'CODE')) {
  6      splice(@{$_[0]-&gt;{children}}, $_[1], 1);
  7      return 1;
  8    }
  9    return 0;
 10  }
 11
 12  Parse::Eyapp-&gt;new_grammar(
 13    input=&gt;$translationscheme,
 14    classname=&gt;'Calc',
 15    firstline =&gt;7,
 16  );
 17  my $parser = Calc-&gt;new();                # Create the parser
 18
 19  $parser-&gt;YYData-&gt;{INPUT} = &quot;2*-3\n&quot;;  print &quot;2*-3\n&quot;; # Set the input
 20  my $t = $parser-&gt;Run;                    # Parse it
 21  print $t-&gt;str.&quot;\n&quot;;
 22  my $p = Parse::Eyapp::YATW-&gt;new(PATTERN =&gt; \&amp;is_code);
 23  $p-&gt;s($t);
 24  { no warnings; # make attr info available only for this display
 25    local *TERMINAL::info = sub { $_[0]{attr} };
 26    print $t-&gt;str.&quot;\n&quot;;
 27  }
</pre>
<p class="Pp">After the <span class="Li">&quot;Parse::Eyapp::YATW&quot;</span>
    object <span class="Li">$p</span> is built at line 22 the call to method
    <span class="Li">&quot;$p-&gt;s($t)&quot;</span> applies the transformation
    <span class="Li">&quot;is_code&quot;</span> using a bottom-up traversing of
    the tree <span class="Li">$t</span>. The achieved effect is the elimination
    of <span class="Li">&quot;CODE&quot;</span> references in the translation
    scheme tree. When executed the former code produces:</p>
<p class="Pp"></p>
<pre>
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; 12ts_simplify_with_s.pl
 2*-3
 EXP(TIMES(NUM(TERMINAL,CODE),TERMINAL,UMINUS(TERMINAL,NUM(TERMINAL,CODE),CODE),CODE),CODE)
 EXP(TIMES(NUM(TERMINAL[2]),TERMINAL[*],UMINUS(TERMINAL[-],NUM(TERMINAL[3]))))
</pre>
<p class="Pp">The file <span class="Li">&quot;foldrule6.pl&quot;</span> in the
    <span class="Li">&quot;examples/&quot;</span> distribution directory gives
    you another example:</p>
<p class="Pp"></p>
<pre>
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; cat -n foldrule6.pl
   1  #!/usr/bin/perl -w
   2  use strict;
   3  use Rule6;
   4  use Parse::Eyapp::YATW;
   5
   6  my %BinaryOperation = (PLUS=&gt;'+', MINUS =&gt; '-', TIMES=&gt;'*', DIV =&gt; '/');
   7
   8  sub set_terminfo {
   9    no warnings;
  10    *TERMINAL::info = sub { $_[0]{attr} };
  11  }
  12  sub is_foldable {
  13    my ($op, $left, $right);
  14    return 0 unless defined($op = $BinaryOperation{ref($_[0])});
  15    return 0 unless ($left = $_[0]-&gt;child(0), $left-&gt;isa('NUM'));
  16    return 0 unless ($right = $_[0]-&gt;child(1), $right-&gt;isa('NUM'));
  17
  18    my $leftnum = $left-&gt;child(0)-&gt;{attr};
  19    my $rightnum = $right-&gt;child(0)-&gt;{attr};
  20    $left-&gt;child(0)-&gt;{attr} = eval &quot;$leftnum $op $rightnum&quot;;
  21    $_[0] = $left;
  22  }
  23
  24  my $parser = new Rule6();
  25  $parser-&gt;YYData-&gt;{INPUT} = &quot;2*3&quot;;
  26  my $t = $parser-&gt;Run;
  27  &amp;set_terminfo;
  28  print &quot;\n***** Before ******\n&quot;;
  29  print $t-&gt;str;
  30  my $p = Parse::Eyapp::YATW-&gt;new(PATTERN =&gt; \&amp;is_foldable);
  31  $p-&gt;s($t);
  32  print &quot;\n***** After ******\n&quot;;
  33  print $t-&gt;str.&quot;\n&quot;;
</pre>
<p class="Pp">when executed produces:</p>
<p class="Pp"></p>
<pre>
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; foldrule6.pl

 ***** Before ******
 TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3]))
 ***** After ******
 NUM(TERMINAL[6])
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The_"><a class="permalink" href="#The_">The YATW Tree
  Transformation Call Protocol</a></h2>
<p class="Pp">For a subroutine <span class="Li">&quot;pattern_sub&quot;</span>
    to work as a YATW tree transformation - as subroutines
    <span class="Li">&quot;is_foldable&quot;</span> and
    <span class="Li">&quot;is_code&quot;</span> above - has to conform to the
    following call description:</p>
<p class="Pp"></p>
<pre>
  pattern_sub(
      $_[0],  # Node being visited
      $_[1],  # Father of this node
      $index, # Index of this node in @Father-&gt;children
      $self,  # The YATW pattern object
  );
</pre>
<p class="Pp">The <span class="Li">&quot;pattern_sub&quot;</span> must return
    TRUE if matched and FALSE otherwise.</p>
<p class="Pp">The protocol may change in the near future. Avoid using other
    information than the fact that the first argument is the node being
  visited.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Parse::Eyapp::YATW~2"><a class="permalink" href="#Parse::Eyapp::YATW~2">Parse::Eyapp::YATW-&gt;buildpatterns</a></h2>
<p class="Pp">Works as <span class="Li">&quot;Parse::Eyapp-&gt;new&quot;</span>
    but receives an array of subs conforming to the YATW Tree Transformation
    Call Protocol.</p>
<p class="Pp"></p>
<pre>
  our @all = Parse::Eyapp::YATW-&gt;buildpatt(\&amp;delete_code, \&amp;delete_tokens);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$yatw"><a class="permalink" href="#$yatw">$yatw-&gt;delete</a></h2>
<p class="Pp">The root of the tree that is currently matched by the YATW
    transformation <span class="Li">$yatw</span> will be deleted from the tree
    as soon as is safe. That usually means when the processing of their siblings
    is finished. The following example (taken from file
    <span class="Li">&quot;examples/13ts_simplify_with_delete.pl&quot;</span> in
    the Parse::Eyapp distribution) illustrates how to eliminate CODE and
    syntactic terminals from the syntax tree:</p>
<p class="Pp"></p>
<pre>
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ \
        sed -ne '62,$p' 13ts_simplify_with_delete.pl | cat -n
  1  sub not_useful {
  2    my $self = shift; # node
  3    my $pat = $_[2];  # get the YATW object
  4
  5    (ref($self) eq 'CODE') or ((ref($self) eq 'TERMINAL') and ($self-&gt;{token} eq $self-&gt;{attr}))
  6      or do { return 0 };
  7    $pat-&gt;delete();
  8    return 1;
  9  }
 10
 11  Parse::Eyapp-&gt;new_grammar(
 12    input=&gt;$translationscheme,
 13    classname=&gt;'Calc',
 14    firstline =&gt;7,
 15  );
 16  my $parser = Calc-&gt;new();                # Create the parser
 17
 18  $parser-&gt;YYData-&gt;{INPUT} = &quot;2*3\n&quot;; print $parser-&gt;YYData-&gt;{INPUT};
 19  my $t = $parser-&gt;Run;                    # Parse it
 20  print $t-&gt;str.&quot;\n&quot;;                      # Show the tree
 21  my $p = Parse::Eyapp::YATW-&gt;new(PATTERN =&gt; \&amp;not_useful); 
 22  $p-&gt;s($t);                               # Delete nodes
 23  print $t-&gt;str.&quot;\n&quot;;                      # Show the tree
</pre>
<p class="Pp">when executed we get the following output:</p>
<p class="Pp"></p>
<pre>
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ 13ts_simplify_with_delete.pl
 2*3
 EXP(TIMES(NUM(TERMINAL[2],CODE),TERMINAL[*],NUM(TERMINAL[3],CODE),CODE))
 EXP(TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$yatw~2"><a class="permalink" href="#$yatw~2">$yatw-&gt;unshift</a></h2>
<p class="Pp">The call <span class="Li">&quot;$yatw-&gt;unshift($b)&quot;</span>
    safely unshifts (inserts at the beginning) the node
    <span class="Li">$b</span> in the list of its siblings of the node that
    matched (i.e in the list of siblings of <span class="Li">$_[0]</span>). The
    following example shows a YATW transformation
    <span class="Li">&quot;insert_child&quot;</span> that illustrates the use of
    <span class="Li">&quot;unshift&quot;</span> (file
    <span class="Li">&quot;examples/26delete_with_trreereg.pl&quot;</span>):</p>
<p class="Pp"></p>
<pre>
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ \
         sed -ne '70,$p' 26delete_with_trreereg.pl | cat -n
  1  my $transform = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
  2
  3      delete_code : CODE =&gt; { $delete_code-&gt;delete() }
  4
  5      {
  6        sub not_semantic {
  7          my $self = shift;
  8          return  1 if ((ref($self) eq 'TERMINAL') and ($self-&gt;{token} eq $self-&gt;{attr}));
  9          return 0;
 10        }
 11      }
 12
 13      delete_tokens : TERMINAL and { not_semantic($TERMINAL) } =&gt; {
 14        $delete_tokens-&gt;delete();
 15      }
 16
 17      insert_child : TIMES(NUM(TERMINAL), NUM(TERMINAL)) =&gt; {
 18        my $b = Parse::Eyapp::Node-&gt;new( 'UMINUS(TERMINAL)',
 19          sub { $_[1]-&gt;{attr} = '4.5' }); # The new node will be a sibling of TIMES
 20
 21        $insert_child-&gt;unshift($b); 
 22      }
 23    },
 24  )-&gt;generate();
 25
 26  Parse::Eyapp-&gt;new_grammar(
 27    input=&gt;$translationscheme,
 28    classname=&gt;'Calc',
 29    firstline =&gt;7,
 30  );
 31  my $parser = Calc-&gt;new();                # Create the parser
 32
 33  $parser-&gt;YYData-&gt;{INPUT} = &quot;2*3\n&quot;; print $parser-&gt;YYData-&gt;{INPUT}; # Set the input
 34  my $t = $parser-&gt;Run;                # Parse it
 35  print $t-&gt;str.&quot;\n&quot;;                        # Show the tree
 36  # Get the AST
 37  our ($delete_tokens, $delete_code);
 38  $t-&gt;s($delete_tokens, $delete_code);
 39  print $t-&gt;str.&quot;\n&quot;;                        # Show the tree
 40  our $insert_child;
 41  $insert_child-&gt;s($t);
 42  print $t-&gt;str.&quot;\n&quot;;                        # Show the tree
</pre>
<p class="Pp">When is executed the program produces the following output:</p>
<p class="Pp"></p>
<pre>
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ 26delete_with_trreereg.pl
 2*3
 EXP(TIMES(NUM(TERMINAL[2],CODE),TERMINAL[*],NUM(TERMINAL[3],CODE),CODE))
 EXP(TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
 EXP(UMINUS(TERMINAL[4.5]),TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
</pre>
<p class="Pp">Don't try to take advantage that the transformation sub receives
    in <span class="Li">$_[1]</span> a reference to the father (see the section
    &quot;The YATW Tree Transformation Call Protocol&quot;) and do something
    like:</p>
<p class="Pp"></p>
<pre>
  unshift $_[1]-&gt;{children}, $b
</pre>
<p class="Pp">it is unsafe.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$yatw~3"><a class="permalink" href="#$yatw~3">$yatw-&gt;insert_before</a></h2>
<p class="Pp">A call to
    <span class="Li">&quot;$yatw-&gt;insert_before($node)&quot;</span> safely
    inserts <span class="Li">$node</span> in the list of siblings of
    <span class="Li">$_[0]</span> just before <span class="Li">$_[0]</span>
    (i.e. the node that matched with <span class="Li">$yatw</span>). The
    following example (see file
    <span class="Li">&quot;examples/YATW/moveinvariantoutofloopcomplexformula.pl&quot;</span>)
    illustrates its use:</p>
<p class="Pp"></p>
<pre>
  my $p = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
    moveinvariant: WHILE(VAR($b), BLOCK(@a, ASSIGN($x, $e), @c)) 
         and { is_invariant($ASSIGN, $WHILE) } =&gt; {
           my $assign = $ASSIGN;
           $BLOCK-&gt;delete($ASSIGN);
           $moveinvariant-&gt;insert_before($assign);
         }
    },
  );
</pre>
<p class="Pp">Here the <span class="Li">&quot;ASSIGN($x, $e)&quot;</span>
    subtree - if is loop invariant - will be moved to the list of siblings of
    <span class="Li">$WHILE</span> just before the
    <span class="Li">$WHILE</span>. Thus a program like</p>
<p class="Pp"></p>
<pre>
  &quot;a =1000; c = 1; while (a) { c = c*a; b = 5; a = a-1 }\n&quot;
</pre>
<p class="Pp">is transformed in s.t. like:</p>
<p class="Pp"></p>
<pre>
  &quot;a =1000; c = 1; b = 5; while (a) { c = c*a; a = a-1 }\n&quot;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TREE_MATCHING_AND_TREE_SUBSTITUTION"><a class="permalink" href="#TREE_MATCHING_AND_TREE_SUBSTITUTION">TREE
  MATCHING AND TREE SUBSTITUTION</a></h1>
<p class="Pp">See the documentation in Parse::Eyapp::treematchingtut</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<ul class="Bl-bullet">
  <li>The project home is at &lt;http://code.google.com/p/parse-eyapp/&gt;. Use
      a subversion client to anonymously check out the latest project source
      code:
    <p class="Pp"></p>
    <pre>
   svn checkout http://parse-eyapp.googlecode.com/svn/trunk/ parse-eyapp-read-only
    </pre>
  </li>
  <li>The tutorial <i>Parsing Strings and Trees with</i>
      <span class="Li">&quot;Parse::Eyapp&quot;</span> (An Introduction to
      Compiler Construction in seven pages) in
      &lt;http://nereida.deioc.ull.es/~pl/eyapsimple/&gt;</li>
  <li>Parse::Eyapp, Parse::Eyapp::eyapplanguageref, Parse::Eyapp::debuggingtut,
      Parse::Eyapp::defaultactionsintro, Parse::Eyapp::translationschemestut,
      Parse::Eyapp::Driver, Parse::Eyapp::Node, Parse::Eyapp::YATW,
      Parse::Eyapp::Treeregexp, Parse::Eyapp::Scope, Parse::Eyapp::Base,
      Parse::Eyapp::datagenerationtut</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf&gt;</li>
  <li>perldoc eyapp,</li>
  <li>perldoc treereg,</li>
  <li>perldoc vgg,</li>
  <li>The Syntax Highlight file for vim at
      &lt;http://www.vim.org/scripts/script.php?script_id=2453&gt; and
      &lt;http://nereida.deioc.ull.es/~vim/&gt;</li>
  <li><i>Analisis Lexico y Sintactico</i>, (Notes for a course in compiler
      construction) by Casiano Rodriguez-Leon. Available at
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/&gt; Is the more complete
      and reliable source for Parse::Eyapp. However is in Spanish.</li>
  <li>Parse::Yapp,</li>
  <li>Man pages of <i>yacc</i>(1) and <i>bison</i>(1),
      &lt;http://www.delorie.com/gnu/docs/bison/bison.html&gt;</li>
  <li>Language::AttributeGrammar</li>
  <li>Parse::RecDescent.</li>
  <li>HOP::Parser</li>
  <li>HOP::Lexer</li>
  <li>ocamlyacc tutorial at
      &lt;http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex-ocamlyacc/ocamlyacc-tutorial/ocamlyacc-tutorial.html&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="REFERENCES"><a class="permalink" href="#REFERENCES">REFERENCES</a></h1>
<ul class="Bl-bullet">
  <li>The classic Dragon's book <i>Compilers: Principles, Techniques, and
      Tools</i> by Alfred V. Aho, Ravi Sethi and Jeffrey D. Ullman
      (Addison-Wesley 1986)</li>
  <li><i>CS2121: The Implementation and Power of Programming Languages</i> (See
      &lt;http://www.cs.man.ac.uk/~pjj&gt;,
      &lt;http://www.cs.man.ac.uk/~pjj/complang/g2lr.html&gt; and
      &lt;http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html&gt;) by Pete Jinks</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<ul class="Bl-bullet">
  <li>Hal Finkel &lt;http://www.halssoftware.com/&gt;</li>
  <li>G. Williams &lt;http://kasei.us/&gt;</li>
  <li>Thomas L. Shinnick &lt;http://search.cpan.org/~tshinnic/&gt;</li>
  <li>Frank Leray</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Casiano Rodriguez-Leon (casiano@ull.es)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGMENTS"><a class="permalink" href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a></h1>
<p class="Pp">This work has been supported by CEE (FEDER) and the Spanish
    Ministry of <i>Educacion y Ciencia</i> through <i>Plan Nacional I+D+I</i>
    number TIN2005-08818-C04-04 (ULL::OPLINK project
    &lt;http://www.oplink.ull.es/&gt;). Support from Gobierno de Canarias was
    through GC02210601 (<i>Grupos Consolidados</i>). The University of La Laguna
    has also supported my work in many ways and for many years.</p>
<p class="Pp">A large percentage of code is verbatim taken from Parse::Yapp
    1.05. The author of Parse::Yapp is Francois Desarmenien.</p>
<p class="Pp">I wish to thank Francois Desarmenien for his Parse::Yapp module,
    to my students at La Laguna and to the Perl Community. Thanks to the people
    who have contributed to improve the module (see &quot;CONTRIBUTORS&quot; in
    Parse::Eyapp). Thanks to Larry Wall for giving us Perl. Special thanks to
    Juana.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENCE_AND_COPYRIGHT"><a class="permalink" href="#LICENCE_AND_COPYRIGHT">LICENCE
  AND COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 2006-2008 Casiano Rodriguez-Leon (casiano@ull.es).
    All rights reserved.</p>
<p class="Pp">Parse::Yapp copyright is of Francois Desarmenien, all rights
    reserved. 1998-2001</p>
<p class="Pp">These modules are free software; you can redistribute it and/or
    modify it under the same terms as Perl itself. See perlartistic.</p>
<p class="Pp">This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. </p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2012-03-23</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

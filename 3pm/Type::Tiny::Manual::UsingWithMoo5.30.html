<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Type::Tiny::Manual::UsingWithMoo(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Type::Tiny::Manual::UsingWithMoo(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Type::Tiny::Manual::UsingWithMoo(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Type::Tiny::Manual::UsingWithMoo - basic use of Type::Tiny with
    Moo</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MANUAL"><a class="permalink" href="#MANUAL">MANUAL</a></h1>
<section class="Ss">
<h2 class="Ss" id="Type_Constraints"><a class="permalink" href="#Type_Constraints">Type
  Constraints</a></h2>
<p class="Pp">Consider the following basic Moo class:</p>
<p class="Pp"></p>
<pre>  package Horse {
    use Moo;
    use namespace::autoclean;
    
    has name       =&gt; ( is =&gt; 'ro' );
    has gender     =&gt; ( is =&gt; 'ro' );
    has age        =&gt; ( is =&gt; 'rw' );
    has children   =&gt; ( is =&gt; 'ro', default =&gt; sub { [] } );
  }
</pre>
<p class="Pp">Code like this seems simple enough:</p>
<p class="Pp"></p>
<pre>  my $br = Horse-&gt;new(name =&gt; &quot;Bold Ruler&quot;, gender =&gt; 'm', age =&gt; 16);
  push @{ $br-&gt;children },
    Horse-&gt;new(name =&gt; 'Secretariat', gender =&gt; 'm', age =&gt; 0);
</pre>
<p class="Pp">However, once you step away from very simple use of the class,
    things can start to go wrong. When we push a new horse onto
    <span class="Li">&quot;@{ $br-&gt;children }&quot;</span>, we are assuming
    that <span class="Li">&quot;$br-&gt;children&quot;</span> returned an
    arrayref.</p>
<p class="Pp">What if the code that created the <span class="Li">$br</span>
    horse had instantiated it like this?</p>
<p class="Pp"></p>
<pre>  my $br = Horse-&gt;new(name =&gt; &quot;Bold Ruler&quot;, children =&gt; 'no');
</pre>
<p class="Pp">It is for this reason that it's useful for the Horse class to
    perform some basic sanity-checking on its own attributes.</p>
<p class="Pp"></p>
<pre>  package Horse {
    use Moo;
    use Types::Standard qw( Str Num ArrayRef );
    use namespace::autoclean;
    
    has name       =&gt; ( is =&gt; 'ro', isa =&gt; Str );
    has gender     =&gt; ( is =&gt; 'ro', isa =&gt; Str );
    has age        =&gt; ( is =&gt; 'rw', isa =&gt; Num );
    has children   =&gt; (
      is      =&gt; 'ro',
      isa     =&gt; ArrayRef,
      default =&gt; sub { return  [] },
    );
  }
</pre>
<p class="Pp">Now, if you instantiate a horse like this, it will throw an
  error:</p>
<p class="Pp"></p>
<pre>  my $br = Horse-&gt;new(name =&gt; &quot;Bold Ruler&quot;, children =&gt; 'no');
</pre>
<p class="Pp">The first type constraint we used here was <b>Str</b>. This is
    type constraint that requires values to be strings.</p>
<p class="Pp">Note that although <span class="Li">&quot;undef&quot;</span> is
    not a string, the empty string is still a string and you will often want to
    check that a string is non-empty. We could have done this:</p>
<p class="Pp"></p>
<pre>  use Types::Common::String qw( NonEmptyStr );
  has name =&gt; ( is =&gt; 'ro', isa =&gt; NonEmptyStr );
</pre>
<p class="Pp">While most of the type constraints we will use in this manual are
    defined in Types::Standard, the Types::Common::String type library also
    defines many useful type constraints.</p>
<p class="Pp">We have required the horse's age to be a number. This is also a
    common, useful type constraint. If we want to make sure it's a whole number,
    we could use:</p>
<p class="Pp"></p>
<pre>  use Types::Standard qw( Int );
  has age =&gt; ( is =&gt; 'rw', isa =&gt; Int );
</pre>
<p class="Pp">Or because negative numbers make little sense as an age:</p>
<p class="Pp"></p>
<pre>  use Types::Common::Numeric qw( PositiveOrZeroInt );
  has age =&gt; ( is =&gt; 'rw', isa =&gt; PositiveOrZeroInt );
</pre>
<p class="Pp">The Types::Common::Numeric library defines many useful subtypes of
    <b>Int</b> and <b>Num</b>, such as <b>PositiveInt</b> and
    <b>PositiveOrZeroInt</b>.</p>
<p class="Pp">The last type constraint we've used in this example is
    <b>ArrayRef</b>. This requires the value to be a reference to an array.</p>
<p class="Pp">Types::Standard also provides <b>HashRef</b> and <b>CodeRef</b>
    type constraints. An example of using the latter:</p>
<p class="Pp"></p>
<pre>  package Task {
    use Moo;
    use Types::Standard qw( CodeRef Bool );
    has on_success =&gt; ( is =&gt; 'ro', isa =&gt; CodeRef );
    has on_failure =&gt; ( is =&gt; 'ro', isa =&gt; CodeRef );
    has finished   =&gt; ( is =&gt; 'ro', isa =&gt; Bool, default =&gt; 0 );
    ...;
  }
  
  my $task = Task-&gt;new(
    on_success =&gt; sub { ... },
    on_failure =&gt; sub { ... },
    ...,
  );
</pre>
<p class="Pp">The <b>Bool</b> type constraint accepts &quot;1&quot; as a true
    value, and &quot;0&quot;, &quot;&quot;, or undef as false values. No other
    values are accepted.</p>
<p class="Pp">There exists an <b>Object</b> type constraint that accepts any
    blessed object.</p>
<p class="Pp"></p>
<pre>  package Horse {
    use Moo;
    use Types::Standard qw( Object );
    use namespace::autoclean;
    
    ...;  # name, gender, age, children
    has father =&gt; ( is =&gt; 'ro', isa =&gt; Object );
    has mother =&gt; ( is =&gt; 'ro', isa =&gt; Object );
  }
</pre>
<p class="Pp">Finally, another useful type constraint to know about is
    <b>Any</b>:</p>
<p class="Pp"></p>
<pre>  use Types::Standard qw( Any );
  has stuff =&gt; ( is =&gt; 'rw', isa =&gt; Any );
</pre>
<p class="Pp">This type constraint allows any value; it is essentially the same
    as not doing any type check, but makes your intent clearer. Where possible,
    Type::Tiny will optimize away this type check, so it should have little (if
    any) impact on performance.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Parameterized_Types"><a class="permalink" href="#Parameterized_Types">Parameterized
  Types</a></h2>
<p class="Pp">Let's imagine we want to keep track of our horse's race wins:</p>
<p class="Pp"></p>
<pre>  package Horse {
    use Moo;
    use Types::Standard qw( Str Num ArrayRef );
    use namespace::autoclean;
    
    ...;  # name, gender, age, children
    has wins =&gt; (
      is      =&gt; 'ro',
      isa     =&gt; ArrayRef,
      default =&gt; sub { return [] },
    );
  }
</pre>
<p class="Pp">We can create a horse like this:</p>
<p class="Pp"></p>
<pre>  my $br = Horse-&gt;new(
    name    =&gt; &quot;Bold Ruler&quot;,
    gender  =&gt; 'm',
    age     =&gt; 4,
    wins    =&gt; [&quot;Futurity Stakes 1956&quot;, &quot;Juvenile Stakes 1956&quot;],
  );
</pre>
<p class="Pp">The list of wins is an arrayref of strings. The <b>ArrayRef</b>
    type constraint prevents it from being set to a hashref, for example, but it
    doesn't ensure that everything in the arrayref is a string. To do that, we
    need to parameterize the type constraint:</p>
<p class="Pp"></p>
<pre>  has wins =&gt; (
    is      =&gt; 'ro',
    isa     =&gt; ArrayRef[Str],
    default =&gt; sub { return [] },
  );
</pre>
<p class="Pp">Thanks to the <b>ArrayRef[Str]</b> parameterized type, the
    constructor will throw an error if the arrayref you pass to it contains
    anything non-string.</p>
<p class="Pp">An alternative way of writing this is:</p>
<p class="Pp"></p>
<pre>  has wins =&gt; (
    is      =&gt; 'ro',
    isa     =&gt; ArrayRef-&gt;of(Str),
    default =&gt; sub { return [] },
  );
</pre>
<p class="Pp">Which way you choose is largely a style preference. TIMTOWTDI!</p>
<p class="Pp">Note that although the constructor and any setter/accessor method
    will perform type checks, it is possible to bypass them using:</p>
<p class="Pp"></p>
<pre>  push @{ $br-&gt;wins }, $not_a_string;
</pre>
<p class="Pp">The constructor isn't being called here, and although the accessor
    <i>is</i> being called, it's being called as a reader, not a writer, so
    never gets an opportunity to inspect the value being added. (It is possible
    to use <span class="Li">&quot;tie&quot;</span> to solve this, but that will
    be covered later.)</p>
<p class="Pp">And of course, if you directly poke at the underlying hashref of
    the object, all bets are off:</p>
<p class="Pp"></p>
<pre>  $br-&gt;{wins} = $not_an_arrayref;
</pre>
<p class="Pp">So type constraints do have limitations. Careful API design (and
    not circumventing the proper API) can help.</p>
<p class="Pp">The <b>HashRef</b> type constraint can also be parameterized:</p>
<p class="Pp"></p>
<pre>  package Design {
    use Moo;
    use Types::Standard qw( HashRef Str );
    has colours =&gt; ( is =&gt; 'ro', isa =&gt; HashRef[Str] );
  }
  
  my $eiffel65 = Design-&gt;new(
    colours =&gt; { house =&gt; &quot;blue&quot;, little_window =&gt; &quot;blue&quot; },
  );
</pre>
<p class="Pp">The <b>HashRef[Str]</b> type constraint ensures the <i>values</i>
    of the hashref are strings; it doesn't check the keys of the hashref because
    keys in Perl hashes are always strings!</p>
<p class="Pp">If you do need to constrain the keys, it is possible to use a
    parameterized <b>Map</b> constraint:</p>
<p class="Pp"></p>
<pre>  use Types::Common::String qw( NonEmptyStr );
  use Types::Standard qw( Map );
  has colours =&gt; ( is =&gt; 'ro', isa =&gt; Map[NonEmptyStr, NonEmptyStr] );
</pre>
<p class="Pp"><b>Map</b> takes two parameters; the first is a type to check keys
    against and the second is a type to check values against.</p>
<p class="Pp">Another useful type constraint is the <b>Tuple</b> type
    constraint.</p>
<p class="Pp"></p>
<pre>  use Types::Standard qw( ArrayRef Tuple );
  use Types::Common::Numeric qw( PositiveInt );
  use Types::Common::String qw( NonEmptyStr );
  
  has wins =&gt; (
    is      =&gt; 'ro',
    isa     =&gt; ArrayRef[ Tuple[PositiveInt, NonEmptyStr] ],
    default =&gt; sub { return [] },
  );
</pre>
<p class="Pp">The <b>Tuple[PositiveInt, NonEmptyStr]</b> type constraint checks
    that a value is a two-element arrayref where the first element is a positive
    integer and the second element is a non-empty string. For example:</p>
<p class="Pp"></p>
<pre>  my $br = Horse-&gt;new(
    name    =&gt; &quot;Bold Ruler&quot;,
    wins    =&gt; [
      [ 1956, &quot;Futurity Stakes&quot; ],
      [ 1956, &quot;Juvenile Stakes&quot; ],
    ],
  );
</pre>
<p class="Pp">As you can see, parameterized type constraints may be nested to
    arbitrary depth, though of course the more detailed your checks become, the
    slower they will perform.</p>
<p class="Pp">It is possible to have tuples with variable length. For example,
    we may wish to include the jockey name in our race wins when it is
  known.</p>
<p class="Pp"></p>
<pre>  use Types::Standard qw( ArrayRef Tuple Optional );
  use Types::Common::Numeric qw( PositiveInt );
  use Types::Common::String qw( NonEmptyStr );
  
  has wins =&gt; (
    is      =&gt; 'ro',
    isa     =&gt; ArrayRef[
      Tuple[ PositiveInt, NonEmptyStr, Optional[NonEmptyStr] ]
    ],
    default =&gt; sub { return [] },
  );
</pre>
<p class="Pp">The third element will be checked if it is present, but forgiven
    if it is absent.</p>
<p class="Pp">Or we could just allow tuples to contain an arbitrary list of
    strings after the year and race name:</p>
<p class="Pp"></p>
<pre>  use Types::Standard qw( ArrayRef Tuple Str slurpy );
  use Types::Common::Numeric qw( PositiveInt );
  use Types::Common::String qw( NonEmptyStr );
  
  has wins =&gt; (
    is      =&gt; 'ro',
    isa     =&gt; ArrayRef[
      Tuple[ PositiveInt, NonEmptyStr, slurpy ArrayRef[Str] ]
    ],
    default =&gt; sub { return [] },
  );
</pre>
<p class="Pp">The <span class="Li">&quot;slurpy&quot;</span> indicator will
    &quot;slurp&quot; all the remaining items in the tuple into an arrayref and
    check it against <b>ArrayRef[Str]</b>.</p>
<p class="Pp">It's even possible to do this:</p>
<p class="Pp"></p>
<pre>  use Types::Standard qw( ArrayRef Tuple Any slurpy );
  use Types::Common::Numeric qw( PositiveInt );
  use Types::Common::String qw( NonEmptyStr );
  
  has wins =&gt; (
    is      =&gt; 'ro',
    isa     =&gt; ArrayRef[ 
      Tuple[ PositiveInt, NonEmptyStr, slurpy Any ]
    ],
    default =&gt; sub { return [] },
  );
</pre>
<p class="Pp">With this type constraint, any elements after the first two will
    be slurped into an arrayref and we don't check that arrayref at all. (In
    fact, the implementation of the <b>Tuple</b> type is smart enough to not
    bother creating the temporary arrayref to check.)</p>
<p class="Pp"><b>Dict</b> is the equivalent of <b>Tuple</b> for checking values
    of hashrefs.</p>
<p class="Pp"></p>
<pre>  use Types::Standard qw( ArrayRef Dict Optional );
  use Types::Common::Numeric qw( PositiveInt );
  use Types::Common::String qw( NonEmptyStr );
  
  has wins =&gt; (
    is      =&gt; 'ro',
    isa     =&gt; ArrayRef[
      Dict[
        year    =&gt; PositiveInt,
        race    =&gt; NonEmptyStr,
        jockey  =&gt; Optional[NonEmptyStr],
      ],
    ],
    default =&gt; sub { return [] },
  );
</pre>
<p class="Pp">An example of using it:</p>
<p class="Pp"></p>
<pre>  my $br = Horse-&gt;new(
    name    =&gt; &quot;Bold Ruler&quot;,
    wins    =&gt; [
      { year =&gt; 1956, race =&gt; &quot;Futurity Stakes&quot;, jockey =&gt; &quot;Eddie&quot; },
      { year =&gt; 1956, race =&gt; &quot;Juvenile Stakes&quot; },
    ],
  );
</pre>
<p class="Pp">The slurpy indicator does work for <b>Dict</b> too:</p>
<p class="Pp"></p>
<pre>  Dict[
    year    =&gt; PositiveInt,
    race    =&gt; NonEmptyStr,
    jockey  =&gt; Optional[NonEmptyStr],
    slurpy HashRef[Str],  # other Str values allowed
  ]
</pre>
<p class="Pp">And <span class="Li">&quot;slurpy Any&quot;</span> means what you
    probably think it means:</p>
<p class="Pp"></p>
<pre>  Dict[
    year    =&gt; PositiveInt,
    race    =&gt; NonEmptyStr,
    jockey  =&gt; Optional[NonEmptyStr],
    slurpy Any,  # allow hashref to contain absolutely anything else
  ]
</pre>
<p class="Pp">Going back to our first example, there's an opportunity to refine
    our <b>ArrayRef</b> constraint:</p>
<p class="Pp"></p>
<pre>  package Horse {
    use Moo;
    use Types::Standard qw( Str Num ArrayRef );
    use namespace::autoclean;
    
    has name       =&gt; ( is =&gt; 'ro', isa =&gt; Str );
    has gender     =&gt; ( is =&gt; 'ro', isa =&gt; Str );
    has age        =&gt; ( is =&gt; 'rw', isa =&gt; Num );
    has children   =&gt; (
      is      =&gt; 'ro',
      isa     =&gt; ArrayRef[ InstanceOf[&quot;Horse&quot;] ],
      default =&gt; sub { return [] },
    );
  }
</pre>
<p class="Pp">The <b>InstanceOf[&quot;Horse&quot;]</b> type constraint checks
    that a value is a blessed object in the Horse class. So the horse's children
    should be an arrayref of other Horse objects.</p>
<p class="Pp">Internally it just checks
    <span class="Li">&quot;$_-&gt;isa(&quot;Horse&quot;)&quot;</span> on each
    item in the arrayref.</p>
<p class="Pp">It is sometimes useful to instead check
    <span class="Li">&quot;$_-&gt;DOES($role)&quot;</span> or
    <span class="Li">&quot;$_-&gt;can($method)&quot;</span> on an object. For
    example:</p>
<p class="Pp"></p>
<pre>  package MyAPI::Client {
    use Moo;
    use Types::Standard qw( HasMethods );
    
    has ua =&gt; (is =&gt; 'ro', isa =&gt; HasMethods[&quot;get&quot;, &quot;post&quot;] );
  }
</pre>
<p class="Pp">The <b>ConsumerOf</b> and <b>HasMethods</b> parameterizable types
    allow you to easily check roles and methods of objects.</p>
<p class="Pp">The <b>Enum</b> parameterizable type allows you to accept a more
    limited set of string values. For example:</p>
<p class="Pp"></p>
<pre>  use Types::Standard qw( Enum );
  has gender =&gt; ( is =&gt; 'ro', isa =&gt; Enum[&quot;m&quot;,&quot;f&quot;] );
</pre>
<p class="Pp">Or if you want a little more flexibility, you can use
    <b>StrMatch</b> which allows you to test strings against a regular
    expression:</p>
<p class="Pp"></p>
<pre>  use Types::Standard qw( StrMatch );
  has gender =&gt; ( is =&gt; 'ro', isa =&gt; StrMatch[qr/^[MF]/i] );
</pre>
<p class="Pp">Or <b>StrLength</b> to check the maximum and minimum length of a
    string:</p>
<p class="Pp"></p>
<pre>  use Types::Common::String qw( StrLength );
  has name =&gt; ( is =&gt; 'ro', isa =&gt; StrLength[3, 100] );
</pre>
<p class="Pp">The maximum can be omitted.</p>
<p class="Pp">Similarly, the maximum and minimum values for a numeric type can
    be expressed using <b>IntRange</b> and <b>NumRange</b>:</p>
<p class="Pp"></p>
<pre>  use Types::Common::Numeric qw( IntRange );
  # values over 200 are probably an input error
  has age =&gt; ( is =&gt; 'ro', isa =&gt; IntRange[0, 200] );
</pre>
<p class="Pp">Parameterized type constraints are one of the most powerful
    features of Type::Tiny, allowing a small set of constraints to be combined
    in useful ways.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Type_Coercions"><a class="permalink" href="#Type_Coercions">Type
  Coercions</a></h2>
<p class="Pp">It is often good practice to be liberal in what you accept.</p>
<p class="Pp"></p>
<pre>  package Horse {
    use Moo;
    use Types::Standard qw( Str Num ArrayRef Bool );
    use namespace::autoclean;
    
    ...;  # name, gender, age, children, wins
    has is_alive =&gt; ( is =&gt; 'rw', isa =&gt; Bool, coerce =&gt; 1 );
  }
</pre>
<p class="Pp">The <span class="Li">&quot;coerce&quot;</span> option indicates
    that if a value is given which <i>does not</i> pass the <b>Bool</b> type
    constraint, then it should be coerced (converted) into something that
  does.</p>
<p class="Pp">The definition of <b>Bool</b> says that to convert a non-boolean
    to a bool, you just do <span class="Li">&quot;!! $non_bool&quot;</span>. So
    all of the following will be living horses:</p>
<p class="Pp"></p>
<pre>  Horse-&gt;new(is_alive =&gt; 42)
  Horse-&gt;new(is_alive =&gt; [])
  Horse-&gt;new(is_alive =&gt; &quot;false&quot;) # in Perl, string &quot;false&quot; is true!
</pre>
<p class="Pp"><b>Bool</b> is the only type constraint in Types::Standard that
    has a coercion defined for it. The <b>NumericCode</b>, <b>UpperCaseStr</b>,
    <b>LowerCaseStr</b>, <b>UpperCaseSimpleStr</b>, and
    <b>LowerCaseSimpleStr</b> types from Types::Common::String also have
    conversions defined.</p>
<p class="Pp">The other built-in constraints do not define any coercions because
    it would be hard to agree on what it means to coerce from, say, a
    <b>HashRef</b> to an <b>ArrayRef</b>. Do we keep the keys? The values?
  Both?</p>
<p class="Pp">But it is pretty simple to add your own coercions!</p>
<p class="Pp"></p>
<pre>  use Types::Standard qw( ArrayRef HashRef Str );
  has things =&gt; (
    is     =&gt; 'rw',
    isa    =&gt; ArrayRef-&gt;plus_coercions(
      HashRef,     sub { [ values %$_ ] },
      Str,         sub { [ split /;/, $_ ] },
    ),
    coerce =&gt; 1,
  );
</pre>
<p class="Pp">(Don't ever forget the <span class="Li">&quot;coerce =&gt;
    1&quot;</span>!)</p>
<p class="Pp">If a hashref is provided, the values will be used, and if a string
    is provided, it will be split on the semicolon. Of course, if an arrayref if
    provided, it already passes the type constraint, so no conversion is
    necessary.</p>
<p class="Pp">The coercions should be pairs of &quot;from types&quot; and code
    to coerce the value. The code can be a coderef (as above) or just string of
    Perl code (as below). Strings of Perl code can usually be optimized better
    by Type::Tiny's internals, so are generally preferred. Thanks to Perl's
    <span class="Li">&quot;q{...}&quot;</span> operator, they can look just as
    clean and pretty as coderefs.</p>
<p class="Pp"></p>
<pre>  use Types::Standard qw( ArrayRef HashRef Str );
  has things =&gt; (
    is     =&gt; 'rw',
    isa    =&gt; ArrayRef-&gt;plus_coercions(
      HashRef,     q{ values %$_ },
      Str,         q{ [ split /;/, $_ ] },
    ),
    coerce =&gt; 1,
  );
</pre>
<p class="Pp">Coercions are deeply applied automatically, so the following will
    do what you expect.</p>
<p class="Pp"></p>
<pre>  has inputs =&gt; (
    is     =&gt; 'ro',
    isa    =&gt; ArrayRef-&gt;of(Bool),
    coerce =&gt; 1
  );
</pre>
<p class="Pp">I am, of course, assuming you expect something like:</p>
<p class="Pp"></p>
<pre>  my $coerced = [ map { !!$_ } @$orig ];
</pre>
<p class="Pp">If you were assuming that, congratulations! We are on the same
    wavelength.</p>
<p class="Pp">And of course you can still add more coercions to the inherited
    ones...</p>
<p class="Pp"></p>
<pre>  has inputs =&gt; (
    is     =&gt; 'ro',
    isa    =&gt; ArrayRef-&gt;of(Bool)-&gt;plus_coercions(Str, sub {...}),
    coerce =&gt; 1
  );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Method_Parameters"><a class="permalink" href="#Method_Parameters">Method
  Parameters</a></h2>
<p class="Pp">So far we have just concentrated on the definition of object
    attributes, but type constraints are also useful to validate method
    parameters.</p>
<p class="Pp">Let's remember our attribute for keeping track of a horse's race
    wins:</p>
<p class="Pp"></p>
<pre>  use Types::Standard qw( ArrayRef Tuple Optional );
  use Types::Common::Numeric qw( PositiveInt );
  use Types::Common::String qw( NonEmptyStr );
  
  has wins =&gt; (
    is      =&gt; 'ro',
    isa     =&gt; ArrayRef[
      Tuple[ PositiveInt, NonEmptyStr, Optional[NonEmptyStr] ]
    ],
    default =&gt; sub { return [] },
  );
</pre>
<p class="Pp">Because we don't trust outside code to push new entries onto this
    array, let's define a method in our class to do it.</p>
<p class="Pp"></p>
<pre>  package Horse {
    ...;
    
    sub add_win {
      my $self = shift;
      my ($year, $race, $jockey) = @_;
      my $win = [
        $year,
        $race,
        $jockey ? $jockey : (),
      ];
      push @{ $self-&gt;wins }, $win;
      return $self;
    }
  }
</pre>
<p class="Pp">This works pretty well, but we're still not actually checking the
    values of <span class="Li">$year</span>, <span class="Li">$race</span>, and
    <span class="Li">$jockey</span>. Let's use Type::Params for that:</p>
<p class="Pp"></p>
<pre>  package Horse {
    use Types::Common::Numeric qw( PositiveInt );
    use Types::Common::String qw( NonEmptyStr );
    use Type::Params qw( compile );
    ...;
    
    sub add_win {
      state $check = compile(
        PositiveInt,
        NonEmptyStr,
        NonEmptyStr, { optional =&gt; 1 },
      );
      
      my $self = shift;
      my ($year, $race, $jockey) = $check-&gt;(@_);
      my $win = [
        $year,
        $race,
        $jockey ? $jockey : (),
      ];
      push @{ $self-&gt;wins }, $win;
      return $self;
    }
  }
</pre>
<p class="Pp">The first time this method is called, it will compile a coderef
    called <span class="Li">$check</span>. Then every time it is run,
    <span class="Li">$check</span> will be called to check the method's
    parameters. It will throw an exception if they fail.
    <span class="Li">$check</span> will also perform coercions if types have
    them (and you don't even need to remember <span class="Li">&quot;coerce
    =&gt; 1&quot;</span>; it's always automatic) and can even add in
  defaults:</p>
<p class="Pp"></p>
<pre>  state $check = compile(
    PositiveInt,
    NonEmptyStr,
    NonEmptyStr, { default =&gt; sub { &quot;Eddie&quot; } },
  );
</pre>
<p class="Pp">On older versions of Perl (prior to 5.10),
    <span class="Li">&quot;state&quot;</span> variables are not available. A
    workaround is to replace this:</p>
<p class="Pp"></p>
<pre>  sub foo {
    state $x = bar();
    ...;
  }
</pre>
<p class="Pp">With this:</p>
<p class="Pp"></p>
<pre>  {         # outer braces prevent other subs seeing $x
    my $x;  # declare $x before sub foo()
    sub foo {
      $x = bar();
      ...;
    }
  }
</pre>
<p class="Pp">(While we're having a general Perl syntax lesson, I'll note that
    <span class="Li">&amp;$check</span> with an ampersand and no parentheses is
    a shortcut for <span class="Li">&quot;$check-&gt;(@_)&quot;</span> and
    actually runs slightly faster because it reuses the
    <span class="Li">@_</span> array for the called coderef. A lot of people
    dislike calling subs with an ampersand, so we will stick to the
    <span class="Li">&quot;$check-&gt;(@_)&quot;</span> syntax in these
    examples. But do consider using the shortcut!)</p>
<p class="Pp">The generalized syntax for
    <span class="Li">&quot;compile&quot;</span> is:</p>
<p class="Pp"></p>
<pre>  state $check = compile(
    \%general_options,
    TypeForFirstParam,  \%options_for_first_param,
    TypeForSecondParam, \%options_for_second_param,
    ...,
  );
</pre>
<p class="Pp">As a shortcut for the <span class="Li">&quot;{ optional =&gt; 1
    }}&quot;</span> option, you can just use <b>Optional</b> like in
    <b>Tuple</b>.</p>
<p class="Pp"></p>
<pre>  state $check = compile(
    PositiveInt,
    NonEmptyStr,
    Optional[NonEmptyStr],
  );
</pre>
<p class="Pp">You can also use <span class="Li">0</span> and
    <span class="Li">1</span> as shortcuts for <b>Optional[Any]</b> and
    <b>Any</b>. The following checks that the first parameter is a positive
    integer, the second parameter is required (but doesn't care what value it
    is) and the third parameter is allowed but not required.</p>
<p class="Pp"></p>
<pre>  state $check = compile(PositiveInt, 1, 0);
</pre>
<p class="Pp">It is possible to accept a variable number of values using
    <span class="Li">&quot;slurpy&quot;</span>:</p>
<p class="Pp"></p>
<pre>  package Horse {
    use Types::Common::Numeric qw( PositiveInt );
    use Types::Common::String qw( NonEmptyStr );
    use Types::Standard qw( ArrayRef slurpy );
    use Type::Params qw( compile );
    ...;
    
    sub add_wins_for_year {
      state $check = compile(
        PositiveInt,
        slurpy ArrayRef[NonEmptyStr],
      );
      
      my $self = shift;
      my ($year, $races) = $check-&gt;(@_);
      for my $race (@$races) {
        push @{ $self-&gt;wins }, [$year, $win];
      }
      return $self;
    }
  }
</pre>
<p class="Pp">It would be called like this:</p>
<p class="Pp"></p>
<pre>  $bold_ruler-&gt;add_wins_for_year(
    1956,
    &quot;Futurity Stakes&quot;,
    &quot;Juvenile Stakes&quot;,
  );
</pre>
<p class="Pp">The additional parameters are slurped into an arrayref and checked
    against <b>ArrayRef[NonEmptyStr]</b>.</p>
<p class="Pp">Optional parameters are only allowed after required parameters,
    and slurpy parameters are only allowed at the end. (And there can only be a
    at most one slurpy parameter!)</p>
<p class="Pp">For methods that accept more than one or two parameters, it is
    often a good idea to provide them as a hash. For example:</p>
<p class="Pp"></p>
<pre>  $horse-&gt;add_win(
    year    =&gt; 1956,
    race    =&gt; &quot;Futurity Stakes&quot;,
    jockey  =&gt; &quot;Eddie&quot;,
  );
</pre>
<p class="Pp">This can make your code more readable.</p>
<p class="Pp">To accept named parameters, use
    <span class="Li">&quot;compile_named&quot;</span> instead of
    <span class="Li">&quot;compile&quot;</span>.</p>
<p class="Pp"></p>
<pre>  package Horse {
    use Types::Common::Numeric qw( PositiveInt );
    use Types::Common::String qw( NonEmptyStr );
    use Type::Params qw( compile_named );
    ...;
    
    sub add_win {
      state $check = compile_named(
        year    =&gt; PositiveInt,
        race    =&gt; NonEmptyStr,
        jockey  =&gt; NonEmptyStr, { optional =&gt; 1 },
      );
      
      my $self = shift;
      my $args = $check-&gt;(@_);
      my $win = [
        $args-&gt;{year},
        $args-&gt;{race},
        exists($args-&gt;{jockey}) ? $args-&gt;{jockey} : (),
      ];
      push @{ $self-&gt;wins }, $win;
      return $self;
    }
  }
</pre>
<p class="Pp"><span class="Li">&quot;compile&quot;</span> and
    <span class="Li">&quot;compile_named&quot;</span> work pretty much the same,
    except the latter accepts named parameters instead of positional, and
    returns a hashref.</p>
<p class="Pp">It will automatically allow for a hashref to be provided instead
    of a full hash. The following both work, but the
    <span class="Li">$args</span> variable will always be given a hashref.</p>
<p class="Pp"></p>
<pre>  $horse-&gt;add_win({
    year    =&gt; 1956,
    race    =&gt; &quot;Juvenile Stakes&quot;,
  });
  $horse-&gt;add_win(
    year    =&gt; 1956,
    race    =&gt; &quot;Futurity Stakes&quot;,
    jockey  =&gt; &quot;Eddie&quot;,
  );
</pre>
<p class="Pp">Well... I say &quot;always&quot; but you can tell
    <span class="Li">&quot;compile_named&quot;</span> to accept named parameters
    but return a positional list of parameters:</p>
<p class="Pp"></p>
<pre>  package Horse {
    use Types::Common::Numeric qw( PositiveInt );
    use Types::Common::String qw( NonEmptyStr );
    use Type::Params qw( compile_named );
    ...;
    
    sub add_win {
      state $check = compile_named(
        { named_to_list =&gt; 1 },
        year    =&gt; PositiveInt,
        race    =&gt; NonEmptyStr,
        jockey  =&gt; NonEmptyStr, { optional =&gt; 1 },
      );
      
      my $self = shift;
      my ($year, $race, $jockey) = $check-&gt;(@_);
      my $win = [
        $year,
        $race,
        $jockey ? $jockey : (),
      ];
      push @{ $self-&gt;wins }, $win;
      return $self;
    }
  }
</pre>
<p class="Pp">Optional and slurpy named parameters are supported as you'd
    expect.</p>
<p class="Pp">With named parameters, it can be easy to misspell keys in your
    method definition. For example:</p>
<p class="Pp"></p>
<pre>  my $win = [
    $args-&gt;{year},
    $args-&gt;{race},
    exists($args-&gt;{jockee}) ? $args-&gt;{jockey} : (),
  ];
</pre>
<p class="Pp">Note &quot;jockee&quot;! This can lead to hard-to-find bugs.
    There's a <span class="Li">&quot;compile_named_oo&quot;</span> function
    which may help and can lead to cleaner code.</p>
<p class="Pp"></p>
<pre>  package Horse {
    use Types::Common::Numeric qw( PositiveInt );
    use Types::Common::String qw( NonEmptyStr );
    use Type::Params qw( compile_named_oo );
    ...;
    
    sub add_win {
      state $check = compile_named_oo(
        year    =&gt; PositiveInt,
        race    =&gt; NonEmptyStr,
        jockey  =&gt; NonEmptyStr, { optional =&gt; 1 },
      );
      
      my $self = shift;
      my $args = $check-&gt;(@_);
      my $win = [
        $args-&gt;year,
        $args-&gt;race,
        $args-&gt;has_jockey ? $args-&gt;jockey : (),
      ];
      push @{ $self-&gt;wins }, $win;
      return $self;
    }
  }
</pre>
<p class="Pp">Now <span class="Li">$args</span> is a blessed object that you can
    call methods on. There is of course a performance penalty for this, but it's
    surprisingly small.</p>
<p class="Pp">For more information on Type::Params, and third-party
    alternatives, see Type::Tiny::Manual::Params.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="NEXT_STEPS"><a class="permalink" href="#NEXT_STEPS">NEXT
  STEPS</a></h1>
<p class="Pp">Congratulations! I know this was probably a lot to take in, but
    you've covered all of the essentials.</p>
<p class="Pp">You can now set type constraints and coercions for attributes and
    method parameters in Moo! You are familiar with a lot of the most important
    and useful type constraints and understand parameterization and how it can
    be used to build more specific type constraints.</p>
<p class="Pp">(And I'll let you in on a secret. Using Type::Tiny with Moose or
    Mouse instead of Moo is exactly the same. You can just replace
    <span class="Li">&quot;use Moo&quot;</span> with <span class="Li">&quot;use
    Moose&quot;</span> in any of these examples and they should work fine!)</p>
<p class="Pp">Here's your next step:</p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>Type::Tiny::Manual::UsingWithMoo2
    <p class="Pp">Advanced use of Type::Tiny with Moo, including unions and
        intersections, <span class="Li">&quot;stringifies_to&quot;</span>,
        <span class="Li">&quot;numifies_to&quot;</span>,
        <span class="Li">&quot;with_attribute_values&quot;</span>, and
        <span class="Li">&quot;where&quot;</span>.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<p class="Pp">On very old versions of Moo <span class="Li">&quot;coerce =&gt;
    1&quot;</span> is not supported. Instead you will need to provide a coderef
    or object overloading <span class="Li">&quot;&amp;{}&quot;</span> to coerce.
    Type::Tiny can provide you with an overloaded object.</p>
<p class="Pp"></p>
<pre>  package Horse {
    use Moo;
    use Types::Standard qw( Str Num ArrayRef Bool );
    use namespace::autoclean;
    
    ...;  # name, gender, age, children, wins
    has is_alive =&gt; (
      is      =&gt; 'rw',
      isa     =&gt; Bool,
      coerce  =&gt; Bool-&gt;coercion,  # overloaded object
    );
  }
</pre>
<p class="Pp">If you have a very old version of Moo, please upgrade to at least
    Moo 1.006000 which was the version that added support for
    <span class="Li">&quot;coerce =&gt; 1&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Toby Inkster &lt;tobyink@cpan.org&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENCE"><a class="permalink" href="#COPYRIGHT_AND_LICENCE">COPYRIGHT
  AND LICENCE</a></h1>
<p class="Pp">This software is copyright (c) 2013-2014, 2017-2020 by Toby
    Inkster.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DISCLAIMER_OF_WARRANTIES"><a class="permalink" href="#DISCLAIMER_OF_WARRANTIES">DISCLAIMER
  OF WARRANTIES</a></h1>
<p class="Pp">THIS PACKAGE IS PROVIDED &quot;AS IS&quot; AND WITHOUT ANY EXPRESS
    OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES
    OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-10-28</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

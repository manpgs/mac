<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>DBI::DBD::SqlEngine::Developers(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBI::DBD::SqlEngine::Developers(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBI::DBD::SqlEngine::Developers(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">DBI::DBD::SqlEngine::Developers - Developers documentation for
    DBI::DBD::SqlEngine</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    package DBD::myDriver;
    use base qw(DBI::DBD::SqlEngine);
    sub driver
    {
        ...
        my $drh = $proto-&gt;SUPER::driver($attr);
        ...
        return $drh-&gt;{class};
    }
    sub CLONE { ... }
    package DBD::myDriver::dr;
    @ISA = qw(DBI::DBD::SqlEngine::dr);
    sub data_sources { ... }
    ...
    package DBD::myDriver::db;
    @ISA = qw(DBI::DBD::SqlEngine::db);
    sub init_valid_attributes { ... }
    sub init_default_attributes { ... }
    sub set_versions { ... }
    sub validate_STORE_attr { my ($dbh, $attrib, $value) = @_; ... }
    sub validate_FETCH_attr { my ($dbh, $attrib) = @_; ... }
    sub get_myd_versions { ... }
    sub get_avail_tables { ... }
    package DBD::myDriver::st;
    @ISA = qw(DBI::DBD::SqlEngine::st);
    sub FETCH { ... }
    sub STORE { ... }
    package DBD::myDriver::Statement;
    @ISA = qw(DBI::DBD::SqlEngine::Statement);
    sub open_table { ... }
    package DBD::myDriver::Table;
    @ISA = qw(DBI::DBD::SqlEngine::Table);
    my %reset_on_modify = (
                            myd_abc =&gt; &quot;myd_foo&quot;,
                            myd_mno =&gt; &quot;myd_bar&quot;,
                          );
    __PACKAGE__-&gt;register_reset_on_modify( \%reset_on_modify );
    my %compat_map = (
                       abc =&gt; 'foo_abc',
                       xyz =&gt; 'foo_xyz',
                     );
    __PACKAGE__-&gt;register_compat_map( \%compat_map );
    sub bootstrap_table_meta { ... }
    sub init_table_meta { ... }
    sub table_meta_attr_changed { ... }
    sub open_data { ... }
    sub new { ... }
    sub fetch_row { ... }
    sub push_row { ... }
    sub push_names { ... }
    sub seek { ... }
    sub truncate { ... }
    sub drop { ... }
    # optimize the SQL engine by add one or more of
    sub update_current_row { ... }
    # or
    sub update_specific_row { ... }
    # or
    sub update_one_row { ... }
    # or
    sub insert_new_row { ... }
    # or
    sub delete_current_row { ... }
    # or
    sub delete_one_row { ... }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This document describes the interface of DBI::DBD::SqlEngine for
    DBD developers who write DBI::DBD::SqlEngine based DBI drivers. It
    supplements DBI::DBD and DBI::DBD::SqlEngine::HowTo, which you should read
    first.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CLASSES"><a class="permalink" href="#CLASSES">CLASSES</a></h1>
<p class="Pp">Each DBI driver must provide a package global
    <span class="Li">&quot;driver&quot;</span> method and three DBI related
    classes:</p>
<dl class="Bl-tag">
  <dt id="DBI::DBD::SqlEngine::dr"><a class="permalink" href="#DBI::DBD::SqlEngine::dr">DBI::DBD::SqlEngine::dr</a></dt>
  <dd>Driver package, contains the methods DBI calls indirectly via DBI
      interface:
    <p class="Pp"></p>
    <pre>  DBI-&gt;connect ('DBI:DBM:', undef, undef, {})
  # invokes
  package DBD::DBM::dr;
  @DBD::DBM::dr::ISA = qw(DBI::DBD::SqlEngine::dr);
  sub connect ($$;$$$)
  {
      ...
  }
    </pre>
    <p class="Pp">Similar for <span class="Li">&quot;data_sources
        ()&quot;</span> and
        <span class="Li">&quot;disconnect_all()&quot;</span>.</p>
    <p class="Pp">Pure Perl DBI drivers derived from DBI::DBD::SqlEngine usually
        don't need to override any of the methods provided through the
        DBD::XXX::dr package. However if you need additional initialization not
        fitting in <span class="Li">&quot;init_valid_attributes()&quot;</span>
        and <span class="Li">&quot;init_default_attributes()&quot;</span> of
        you're ::db class, the connect method might be the final place to be
        modified.</p>
  </dd>
  <dt id="DBI::DBD::SqlEngine::db"><a class="permalink" href="#DBI::DBD::SqlEngine::db">DBI::DBD::SqlEngine::db</a></dt>
  <dd>Contains the methods which are called through DBI database handles
      (<span class="Li">$dbh</span>). e.g.,
    <p class="Pp"></p>
    <pre>  $sth = $dbh-&gt;prepare (&quot;select * from foo&quot;);
  # returns the f_encoding setting for table foo
  $dbh-&gt;csv_get_meta (&quot;foo&quot;, &quot;f_encoding&quot;);
    </pre>
    <p class="Pp">DBI::DBD::SqlEngine provides the typical methods required
        here. Developers who write DBI drivers based on DBI::DBD::SqlEngine need
        to override the methods <span class="Li">&quot;set_versions&quot;</span>
        and <span class="Li">&quot;init_valid_attributes&quot;</span>.</p>
  </dd>
  <dt id="DBI::DBD::SqlEngine::TieMeta;"><a class="permalink" href="#DBI::DBD::SqlEngine::TieMeta;">DBI::DBD::SqlEngine::TieMeta;</a></dt>
  <dd>Provides the tie-magic for <span class="Li">&quot;$dbh-&gt;{$drv_pfx .
      &quot;_meta&quot;}&quot;</span>. Routes
      <span class="Li">&quot;STORE&quot;</span> through
      <span class="Li">&quot;$drv-&gt;set_sql_engine_meta()&quot;</span> and
      <span class="Li">&quot;FETCH&quot;</span> through
      <span class="Li">&quot;$drv-&gt;get_sql_engine_meta()&quot;</span>.
      <span class="Li">&quot;DELETE&quot;</span> is not supported, you have to
      execute a <span class="Li">&quot;DROP TABLE&quot;</span> statement, where
      applicable.</dd>
  <dt id="DBI::DBD::SqlEngine::TieTables;"><a class="permalink" href="#DBI::DBD::SqlEngine::TieTables;">DBI::DBD::SqlEngine::TieTables;</a></dt>
  <dd>Provides the tie-magic for tables in
      <span class="Li">&quot;$dbh-&gt;{$drv_pfx .
      &quot;_meta&quot;}&quot;</span>. Routes
      <span class="Li">&quot;STORE&quot;</span> though
      <span class="Li">&quot;$tblClass-&gt;set_table_meta_attr()&quot;</span>
      and <span class="Li">&quot;FETCH&quot;</span> though
      <span class="Li">&quot;$tblClass-&gt;get_table_meta_attr()&quot;</span>.
      <span class="Li">&quot;DELETE&quot;</span> removes an attribute from the
      <i>meta object</i> retrieved by
      <span class="Li">&quot;$tblClass-&gt;get_table_meta()&quot;</span>.</dd>
  <dt id="DBI::DBD::SqlEngine::st"><a class="permalink" href="#DBI::DBD::SqlEngine::st">DBI::DBD::SqlEngine::st</a></dt>
  <dd>Contains the methods to deal with prepared statement handles. e.g.,
    <p class="Pp"></p>
    <pre>  $sth-&gt;execute () or die $sth-&gt;errstr;
    </pre>
  </dd>
  <dt id="DBI::DBD::SqlEngine::TableSource;"><a class="permalink" href="#DBI::DBD::SqlEngine::TableSource;">DBI::DBD::SqlEngine::TableSource;</a></dt>
  <dd>Base class for 3rd party table sources:
    <p class="Pp"></p>
    <pre>  $dbh-&gt;{sql_table_source} = &quot;DBD::Foo::TableSource&quot;;
    </pre>
  </dd>
  <dt id="DBI::DBD::SqlEngine::DataSource;"><a class="permalink" href="#DBI::DBD::SqlEngine::DataSource;">DBI::DBD::SqlEngine::DataSource;</a></dt>
  <dd>Base class for 3rd party data sources:
    <p class="Pp"></p>
    <pre>  $dbh-&gt;{sql_data_source} = &quot;DBD::Foo::DataSource&quot;;
    </pre>
  </dd>
  <dt id="DBI::DBD::SqlEngine::Statement;"><a class="permalink" href="#DBI::DBD::SqlEngine::Statement;">DBI::DBD::SqlEngine::Statement;</a></dt>
  <dd>Base class for derived drivers statement engine. Implements
      <span class="Li">&quot;open_table&quot;</span>.</dd>
  <dt id="DBI::DBD::SqlEngine::Table;"><a class="permalink" href="#DBI::DBD::SqlEngine::Table;">DBI::DBD::SqlEngine::Table;</a></dt>
  <dd>Contains tailoring between SQL engine's requirements and
      <span class="Li">&quot;DBI::DBD::SqlEngine&quot;</span> magic for finding
      the right tables and storage. Builds bridges between
      <span class="Li">&quot;sql_meta&quot;</span> handling of
      <span class="Li">&quot;DBI::DBD::SqlEngine::db&quot;</span>, table
      initialization for SQL engines and <i>meta object</i>'s attribute
      management for derived drivers.</dd>
</dl>
<section class="Ss">
<h2 class="Ss" id="DBI::DBD::SqlEngine"><a class="permalink" href="#DBI::DBD::SqlEngine">DBI::DBD::SqlEngine</a></h2>
<p class="Pp">This is the main package containing the routines to initialize
    DBI::DBD::SqlEngine based DBI drivers. Primarily the
    <span class="Li">&quot;DBI::DBD::SqlEngine::driver&quot;</span> method is
    invoked, either directly from DBI when the driver is initialized or from the
    derived class.</p>
<p class="Pp"></p>
<pre>  package DBD::DBM;
  use base qw( DBI::DBD::SqlEngine );
  sub driver
  {
      my ( $class, $attr ) = @_;
      ...
      my $drh = $class-&gt;SUPER::driver( $attr );
      ...
      return $drh;
  }
</pre>
<p class="Pp">It is not necessary to implement your own driver method as long as
    additional initialization (e.g. installing more private driver methods) is
    not required. You do not need to call
    <span class="Li">&quot;setup_driver&quot;</span> as DBI::DBD::SqlEngine
    takes care of it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="DBI::DBD::SqlEngine::dr~2"><a class="permalink" href="#DBI::DBD::SqlEngine::dr~2">DBI::DBD::SqlEngine::dr</a></h2>
<p class="Pp">The driver package contains the methods DBI calls indirectly via
    the DBI interface (see &quot;DBI Class Methods&quot; in DBI).</p>
<p class="Pp">DBI::DBD::SqlEngine based DBI drivers usually do not need to
    implement anything here, it is enough to do the basic initialization:</p>
<p class="Pp"></p>
<pre>  package DBD:XXX::dr;
  @DBD::XXX::dr::ISA = qw (DBI::DBD::SqlEngine::dr);
  $DBD::XXX::dr::imp_data_size     = 0;
  $DBD::XXX::dr::data_sources_attr = undef;
  $DBD::XXX::ATTRIBUTION = &quot;DBD::XXX $DBD::XXX::VERSION by Hans Mustermann&quot;;
</pre>
<p class="Pp"><i>Methods provided by
    </i><span class="Li"><i>&quot;DBI::DBD::SqlEngine::dr&quot;</i></span><i>:</i></p>
<dl class="Bl-tag">
  <dt id="connect"><a class="permalink" href="#connect">connect</a></dt>
  <dd>Supervises the driver bootstrap when calling
    <p class="Pp"></p>
    <pre>  DBI-&gt;connect( &quot;dbi:Foo&quot;, , , { ... } );
    </pre>
    <p class="Pp">First it instantiates a new driver using
        <span class="Li">&quot;DBI::_new_dbh&quot;</span>. After that, initial
        bootstrap of the newly instantiated driver is done by</p>
    <p class="Pp"></p>
    <pre>  $dbh-&gt;func( 0, &quot;init_default_attributes&quot; );
    </pre>
    <p class="Pp">The first argument (<span class="Li">0</span>) signals that
        this is the very first call to
        <span class="Li">&quot;init_default_attributes&quot;</span>. Modern
        drivers understand that and do early stage setup here after calling</p>
    <p class="Pp"></p>
    <pre>  package DBD::Foo::db;
  our @DBD::Foo::db::ISA = qw(DBI::DBD::SqlEngine::db);
  
  sub init_default_attributes
  {
    my ($dbh, $phase) = @_;
    $dbh-&gt;SUPER::init_default_attributes($phase);
    ...; # own setup code, maybe separated by phases
  }
    </pre>
    <p class="Pp">When the <span class="Li">$phase</span> argument is passed
        down until
        <span class="Li">&quot;DBI::DBD::SqlEngine::db::init_default_attributes&quot;</span>,
        <span class="Li">&quot;connect()&quot;</span> recognizes a <i>modern</i>
        driver and initializes the attributes from <i>DSN</i> and
        <i></i><span class="Li"><i>$attr</i></span><i></i> arguments passed via
        <span class="Li">&quot;DBI-&gt;connect( $dsn, $user, $pass, \%attr
        )&quot;</span>.</p>
    <p class="Pp">At the end of the attribute initialization after <i>phase
        0</i>, <span class="Li">&quot;connect()&quot;</span> invoked
        <span class="Li">&quot;init_default_attributes&quot;</span> again for
        <i>phase 1</i>:</p>
    <p class="Pp"></p>
    <pre>  $dbh-&gt;func( 1, &quot;init_default_attributes&quot; );
    </pre>
  </dd>
  <dt id="data_sources"><a class="permalink" href="#data_sources">data_sources</a></dt>
  <dd>Returns a list of <i>DSN</i>'s using the
      <span class="Li">&quot;data_sources&quot;</span> method of the class
      specified in
      <span class="Li">&quot;$dbh-&gt;{sql_table_source}&quot;</span> or via
      <span class="Li">&quot;\%attr&quot;</span>:
    <p class="Pp"></p>
    <pre>  @ary = DBI-&gt;data_sources($driver);
  @ary = DBI-&gt;data_sources($driver, \%attr);
    </pre>
  </dd>
  <dt id="disconnect_all"><a class="permalink" href="#disconnect_all">disconnect_all</a></dt>
  <dd><span class="Li">&quot;DBI::DBD::SqlEngine&quot;</span> doesn't have an
      overall driver cache, so nothing happens here at all.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="DBI::DBD::SqlEngine::db~2"><a class="permalink" href="#DBI::DBD::SqlEngine::db~2">DBI::DBD::SqlEngine::db</a></h2>
<p class="Pp">This package defines the database methods, which are called via
    the DBI database handle <span class="Li">$dbh</span>.</p>
<p class="Pp"><i>Methods provided by
    </i><span class="Li"><i>&quot;DBI::DBD::SqlEngine::db&quot;</i></span><i>:</i></p>
<dl class="Bl-tag">
  <dt id="ping"><a class="permalink" href="#ping">ping</a></dt>
  <dd>Simply returns the content of the
      <span class="Li">&quot;Active&quot;</span> attribute. Override when your
      driver needs more complicated actions here.</dd>
  <dt id="prepare"><a class="permalink" href="#prepare">prepare</a></dt>
  <dd>Prepares a new SQL statement to execute. Returns a statement handle,
      <span class="Li">$sth</span> - instance of the DBD:XXX::st. It is neither
      required nor recommended to override this method.</dd>
  <dt id="validate_FETCH_attr"><a class="permalink" href="#validate_FETCH_attr">validate_FETCH_attr</a></dt>
  <dd>Called by <span class="Li">&quot;FETCH&quot;</span> to allow inherited
      drivers do their own attribute name validation. Calling convention is
      similar to <span class="Li">&quot;FETCH&quot;</span> and the return value
      is the approved attribute name.
    <p class="Pp"></p>
    <pre>    return $validated_attribute_name;
    </pre>
    <p class="Pp">In case of validation fails (e.g. accessing private attribute
        or similar), <span class="Li">&quot;validate_FETCH_attr&quot;</span> is
        permitted to throw an exception.</p>
  </dd>
  <dt id="FETCH"><a class="permalink" href="#FETCH">FETCH</a></dt>
  <dd>Fetches an attribute of a DBI database object. Private handle attributes
      must have a prefix (this is mandatory). If a requested attribute is
      detected as a private attribute without a valid prefix, the driver prefix
      (written as <span class="Li">$drv_prefix</span>) is added.
    <p class="Pp">The driver prefix is extracted from the attribute name and
        verified against <span class="Li">&quot;$dbh-&gt;{ $drv_prefix .
        &quot;valid_attrs&quot; }&quot;</span> (when it exists). If the
        requested attribute value is not listed as a valid attribute, this
        method croaks. If the attribute is valid and readonly (listed in
        <span class="Li">&quot;$dbh-&gt;{</span> <span class="Li">$drv_prefix .
        &quot;readonly_attrs&quot; }&quot;</span> when it exists), a real copy
        of the attribute value is returned. So it's not possible to modify
        <span class="Li">&quot;f_valid_attrs&quot;</span> from outside of
        DBI::DBD::SqlEngine::db or a derived class.</p>
  </dd>
  <dt id="validate_STORE_attr"><a class="permalink" href="#validate_STORE_attr">validate_STORE_attr</a></dt>
  <dd>Called by <span class="Li">&quot;STORE&quot;</span> to allow inherited
      drivers do their own attribute name validation. Calling convention is
      similar to <span class="Li">&quot;STORE&quot;</span> and the return value
      is the approved attribute name followed by the approved new value.
    <p class="Pp"></p>
    <pre>    return ($validated_attribute_name, $validated_attribute_value);
    </pre>
    <p class="Pp">In case of validation fails (e.g. accessing private attribute
        or similar), <span class="Li">&quot;validate_STORE_attr&quot;</span> is
        permitted to throw an exception
        (<span class="Li">&quot;DBI::DBD::SqlEngine::db::validate_STORE_attr&quot;</span>
        throws an exception when someone tries to assign value other than
        <span class="Li">&quot;SQL_IC_UPPER .. SQL_IC_MIXED&quot;</span> to
        <span class="Li">&quot;$dbh-&gt;{sql_identifier_case}&quot;</span> or
        <span class="Li">&quot;$dbh-&gt;{sql_quoted_identifier_case}&quot;</span>).</p>
  </dd>
  <dt id="STORE"><a class="permalink" href="#STORE">STORE</a></dt>
  <dd>Stores a database private attribute. Private handle attributes must have a
      prefix (this is mandatory). If a requested attribute is detected as a
      private attribute without a valid prefix, the driver prefix (written as
      <span class="Li">$drv_prefix</span>) is added. If the database handle has
      an attribute <span class="Li">&quot;${drv_prefix}_valid_attrs&quot;</span>
      - for attribute names which are not listed in that hash, this method
      croaks. If the database handle has an attribute
      <span class="Li">&quot;${drv_prefix}_readonly_attrs&quot;</span>, only
      attributes which are not listed there can be stored (once they are
      initialized). Trying to overwrite such an immutable attribute forces this
      method to croak.
    <p class="Pp">An example of a valid attributes list can be found in
        <span class="Li">&quot;DBI::DBD::SqlEngine::db::init_valid_attributes&quot;</span>.</p>
  </dd>
  <dt id="set_versions"><a class="permalink" href="#set_versions">set_versions</a></dt>
  <dd>This method sets the attributes
      <span class="Li">&quot;f_version&quot;</span>,
      <span class="Li">&quot;sql_nano_version&quot;</span>,
      <span class="Li">&quot;sql_statement_version&quot;</span> and (if not
      prohibited by a restrictive
      <span class="Li">&quot;${prefix}_valid_attrs&quot;</span>)
      <span class="Li">&quot;${prefix}_version&quot;</span>.
    <p class="Pp">This method is called at the end of the
        <span class="Li">&quot;connect ()&quot;</span> phase.</p>
    <p class="Pp">When overriding this method, do not forget to invoke the
        superior one.</p>
  </dd>
  <dt id="init_valid_attributes"><a class="permalink" href="#init_valid_attributes">init_valid_attributes</a></dt>
  <dd>This method is called after the database handle is instantiated as the
      first attribute initialization.
    <p class="Pp"><span class="Li">&quot;DBI::DBD::SqlEngine::db::init_valid_attributes&quot;</span>
        initializes the attributes
        <span class="Li">&quot;sql_valid_attrs&quot;</span> and
        <span class="Li">&quot;sql_readonly_attrs&quot;</span>.</p>
    <p class="Pp">When overriding this method, do not forget to invoke the
        superior one, preferably before doing anything else.</p>
  </dd>
  <dt id="init_default_attributes"><a class="permalink" href="#init_default_attributes">init_default_attributes</a></dt>
  <dd>This method is called after the database handle is instantiated to
      initialize the default attributes. It expects one argument:
      <span class="Li">$phase</span>. If <span class="Li">$phase</span> is not
      given, <span class="Li">&quot;connect&quot;</span> of
      <span class="Li">&quot;DBI::DBD::SqlEngine::dr&quot;</span> expects this
      is an old-fashioned driver which isn't capable of multi-phased
      initialization.
    <p class="Pp"><span class="Li">&quot;DBI::DBD::SqlEngine::db::init_default_attributes&quot;</span>
        initializes the attributes
        <span class="Li">&quot;sql_identifier_case&quot;</span>,
        <span class="Li">&quot;sql_quoted_identifier_case&quot;</span>,
        <span class="Li">&quot;sql_handler&quot;</span>,
        <span class="Li">&quot;sql_init_order&quot;</span>,
        <span class="Li">&quot;sql_meta&quot;</span>,
        <span class="Li">&quot;sql_engine_version&quot;</span>,
        <span class="Li">&quot;sql_nano_version&quot;</span> and
        <span class="Li">&quot;sql_statement_version&quot;</span> when
        SQL::Statement is available.</p>
    <p class="Pp">It sets <span class="Li">&quot;sql_init_order&quot;</span> to
        the given <span class="Li">$phase</span>.</p>
    <p class="Pp">When the derived implementor class provides the attribute to
        validate attributes (e.g.
        <span class="Li">&quot;$dbh-&gt;{dbm_valid_attrs} = {...};&quot;</span>)
        or the attribute containing the immutable attributes (e.g.
        <span class="Li">&quot;$dbh-&gt;{dbm_readonly_attrs}</span>
        <span class="Li">= {...};&quot;</span>), the attributes
        <span class="Li">&quot;drv_valid_attrs&quot;</span>,
        <span class="Li">&quot;drv_readonly_attrs&quot;</span> and
        <span class="Li">&quot;drv_version&quot;</span> are added (when
        available) to the list of valid and immutable attributes (where
        <span class="Li">&quot;drv_&quot;</span> is interpreted as the driver
        prefix).</p>
  </dd>
  <dt id="get_versions"><a class="permalink" href="#get_versions">get_versions</a></dt>
  <dd>This method is called by the code injected into the instantiated driver to
      provide the user callable driver method
      <span class="Li">&quot;${prefix}versions&quot;</span> (e.g.
      <span class="Li">&quot;dbm_versions&quot;</span>,
      <span class="Li">&quot;csv_versions&quot;</span>, ...).
    <p class="Pp">The DBI::DBD::SqlEngine implementation returns all version
        information known by DBI::DBD::SqlEngine (e.g. DBI version, Perl
        version, DBI::DBD::SqlEngine version and the SQL handler version).</p>
    <p class="Pp"><span class="Li">&quot;get_versions&quot;</span> takes the
        <span class="Li">$dbh</span> as the first argument and optionally a
        second argument containing a table name. The second argument is not
        evaluated in
        <span class="Li">&quot;DBI::DBD::SqlEngine::db::get_versions&quot;</span>
        itself - but might be in the future.</p>
    <p class="Pp">If the derived implementor class provides a method named
        <span class="Li">&quot;get_${drv_prefix}versions&quot;</span>, this is
        invoked and the return value of it is associated to the derived driver
        name:</p>
    <p class="Pp"></p>
    <pre>    if (my $dgv = $dbh-&gt;{ImplementorClass}-&gt;can (&quot;get_&quot; . $drv_prefix . &quot;versions&quot;) {
        (my $derived_driver = $dbh-&gt;{ImplementorClass}) =~ s/::db$//;
        $versions{$derived_driver} = &amp;$dgv ($dbh, $table);
    }
    </pre>
    <p class="Pp">Override it to add more version information about your module,
        (e.g. some kind of parser version in case of DBD::CSV, ...), if one line
        is not enough room to provide all relevant information.</p>
  </dd>
  <dt id="sql_parser_object"><a class="permalink" href="#sql_parser_object">sql_parser_object</a></dt>
  <dd>Returns a SQL::Parser instance, when
      <span class="Li">&quot;sql_handler&quot;</span> is set to
      &quot;SQL::Statement&quot;. The parser instance is stored in
      <span class="Li">&quot;sql_parser_object&quot;</span>.
    <p class="Pp">It is not recommended to override this method.</p>
  </dd>
  <dt id="disconnect"><a class="permalink" href="#disconnect">disconnect</a></dt>
  <dd>Disconnects from a database. All local table information is discarded and
      the <span class="Li">&quot;Active&quot;</span> attribute is set to 0.</dd>
  <dt id="type_info_all"><a class="permalink" href="#type_info_all">type_info_all</a></dt>
  <dd>Returns information about all the types supported by
    DBI::DBD::SqlEngine.</dd>
  <dt id="table_info"><a class="permalink" href="#table_info">table_info</a></dt>
  <dd>Returns a statement handle which is prepared to deliver information about
      all known tables.</dd>
  <dt id="list_tables"><a class="permalink" href="#list_tables">list_tables</a></dt>
  <dd>Returns a list of all known table names.</dd>
  <dt id="quote"><a class="permalink" href="#quote">quote</a></dt>
  <dd>Quotes a string for use in SQL statements.</dd>
  <dt id="commit"><a class="permalink" href="#commit">commit</a></dt>
  <dd>Warns about a useless call (if warnings enabled) and returns.
      DBI::DBD::SqlEngine is typically a driver which commits every action
      instantly when executed.</dd>
  <dt id="rollback"><a class="permalink" href="#rollback">rollback</a></dt>
  <dd>Warns about a useless call (if warnings enabled) and returns.
      DBI::DBD::SqlEngine is typically a driver which commits every action
      instantly when executed.</dd>
</dl>
<p class="Pp"><i>Attributes used by
    </i><span class="Li"><i>&quot;DBI::DBD::SqlEngine::db&quot;</i></span><i>:</i></p>
<p class="Pp">This section describes attributes which are important to
    developers of DBI Database Drivers derived from
    <span class="Li">&quot;DBI::DBD::SqlEngine&quot;</span>.</p>
<dl class="Bl-tag">
  <dt id="sql_init_order"><a class="permalink" href="#sql_init_order">sql_init_order</a></dt>
  <dd>This attribute contains a hash with priorities as key and an array
      containing the <span class="Li">$dbh</span> attributes to be initialized
      during before/after other attributes.
    <p class="Pp"><span class="Li">&quot;DBI::DBD::SqlEngine&quot;</span>
        initializes following attributes:</p>
    <p class="Pp"></p>
    <pre>  $dbh-&gt;{sql_init_order} = {
       0 =&gt; [qw( Profile RaiseError PrintError AutoCommit )],
      90 =&gt; [ &quot;sql_meta&quot;, $dbh-&gt;{$drv_pfx_meta} ? $dbh-&gt;{$drv_pfx_meta} : () ]
  }
    </pre>
    <p class="Pp">The default priority of not listed attribute keys is
        <span class="Li">50</span>. It is well known that a lot of attributes
        needed to be set before some table settings are initialized. For
        example, for DBD::DBM, when using</p>
    <p class="Pp"></p>
    <pre>  my $dbh = DBI-&gt;connect( &quot;dbi:DBM:&quot;, undef, undef, {
      f_dir =&gt; &quot;/path/to/dbm/databases&quot;,
      dbm_type =&gt; &quot;BerkeleyDB&quot;,
      dbm_mldbm =&gt; &quot;JSON&quot;, # use MLDBM::Serializer::JSON
      dbm_tables =&gt; {
          quick =&gt; {
              dbm_type =&gt; &quot;GDBM_File&quot;,
              dbm_MLDBM =&gt; &quot;FreezeThaw&quot;
          }
      }
  });
    </pre>
    <p class="Pp">This defines a known table
        <span class="Li">&quot;quick&quot;</span> which uses the GDBM_File
        backend and FreezeThaw as serializer instead of the overall default
        BerkeleyDB and JSON. <b>But</b> all files containing the table data have
        to be searched in <span class="Li">&quot;$dbh-&gt;{f_dir}&quot;</span>,
        which requires <span class="Li">&quot;$dbh-&gt;{f_dir}&quot;</span> must
        be initialized before
        <span class="Li">&quot;$dbh-&gt;{sql_meta}-&gt;{quick}&quot;</span> is
        initialized by <span class="Li">&quot;bootstrap_table_meta&quot;</span>
        method of &quot;DBI::DBD::SqlEngine::Table&quot; to get
        <span class="Li">&quot;$dbh-&gt;{sql_meta}-&gt;{quick}-&gt;{f_dir}&quot;</span>
        being initialized properly.</p>
  </dd>
  <dt id="sql_init_phase"><a class="permalink" href="#sql_init_phase">sql_init_phase</a></dt>
  <dd>This attribute is only set during the initialization steps of the DBI
      Database Driver. It contains the value of the currently run initialization
      phase. Currently supported phases are <i>phase 0</i> and <i>phase 1</i>.
      This attribute is set in
      <span class="Li">&quot;init_default_attributes&quot;</span> and removed in
      <span class="Li">&quot;init_done&quot;</span>.</dd>
  <dt id="sql_engine_in_gofer"><a class="permalink" href="#sql_engine_in_gofer">sql_engine_in_gofer</a></dt>
  <dd>This value has a true value in case of this driver is operated via
      DBD::Gofer. The impact of being operated via Gofer is a read-only driver
      (not read-only databases!), so you cannot modify any attributes later -
      neither any table settings. <b>But</b> you won't get an error in cases you
      modify table attributes, so please carefully watch
      <span class="Li">&quot;sql_engine_in_gofer&quot;</span>.</dd>
  <dt id="sql_table_source"><a class="permalink" href="#sql_table_source">sql_table_source</a></dt>
  <dd>Names a class which is responsible for delivering <i>data sources</i> and
      <i>available tables</i> (Database Driver related). <i>data sources</i>
      here refers to &quot;data_sources&quot; in DBI, not
      <span class="Li">&quot;sql_data_source&quot;</span>.
    <p class="Pp">See &quot;DBI::DBD::SqlEngine::TableSource&quot; for
      details.</p>
  </dd>
  <dt id="sql_data_source"><a class="permalink" href="#sql_data_source">sql_data_source</a></dt>
  <dd>Name a class which is responsible for handling table resources open and
      completing table names requested via SQL statements.
    <p class="Pp">See &quot;DBI::DBD::SqlEngine::DataSource&quot; for
      details.</p>
  </dd>
  <dt id="sql_dialect"><a class="permalink" href="#sql_dialect">sql_dialect</a></dt>
  <dd>Controls the dialect understood by SQL::Parser. Possible values (delivery
      state of SQL::Statement):
    <p class="Pp"></p>
    <pre>  * ANSI
  * CSV
  * AnyData
    </pre>
    <p class="Pp">Defaults to &quot;CSV&quot;. Because an SQL::Parser is
        instantiated only once and SQL::Parser doesn't allow one to modify the
        dialect once instantiated, it's strongly recommended to set this flag
        before any statement is executed (best place is connect attribute
      hash).</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="DBI::DBD::SqlEngine::st~2"><a class="permalink" href="#DBI::DBD::SqlEngine::st~2">DBI::DBD::SqlEngine::st</a></h2>
<p class="Pp">Contains the methods to deal with prepared statement handles:</p>
<dl class="Bl-tag">
  <dt id="bind_param"><a class="permalink" href="#bind_param">bind_param</a></dt>
  <dd>Common routine to bind placeholders to a statement for execution. It is
      dangerous to override this method without detailed knowledge about the
      DBI::DBD::SqlEngine internal storage structure.</dd>
  <dt id="execute"><a class="permalink" href="#execute">execute</a></dt>
  <dd>Executes a previously prepared statement (with placeholders, if any).</dd>
  <dt id="finish"><a class="permalink" href="#finish">finish</a></dt>
  <dd>Finishes a statement handle, discards all buffered results. The prepared
      statement is not discarded so the statement can be executed again.</dd>
  <dt id="fetch"><a class="permalink" href="#fetch">fetch</a></dt>
  <dd>Fetches the next row from the result-set. This method may be rewritten in
      a later version and if it's overridden in a derived class, the derived
      implementation should not rely on the storage details.</dd>
  <dt id="fetchrow_arrayref"><a class="permalink" href="#fetchrow_arrayref">fetchrow_arrayref</a></dt>
  <dd>Alias for <span class="Li">&quot;fetch&quot;</span>.</dd>
  <dt id="FETCH~2"><a class="permalink" href="#FETCH~2">FETCH</a></dt>
  <dd>Fetches statement handle attributes. Supported attributes (for full
      overview see &quot;Statement Handle Attributes&quot; in DBI) are
      <span class="Li">&quot;NAME&quot;</span>,
      <span class="Li">&quot;TYPE&quot;</span>,
      <span class="Li">&quot;PRECISION&quot;</span> and
      <span class="Li">&quot;NULLABLE&quot;</span>. Each column is returned as
      <span class="Li">&quot;NULLABLE&quot;</span> which might be wrong
      depending on the derived backend storage. If the statement handle has
      private attributes, they can be fetched using this method, too.
      <b>Note</b> that statement attributes are not associated with any table
      used in this statement.
    <p class="Pp">This method usually requires extending in a derived
        implementation. See DBD::CSV or DBD::DBM for some example.</p>
  </dd>
  <dt id="STORE~2"><a class="permalink" href="#STORE~2">STORE</a></dt>
  <dd>Allows storing of statement private attributes. No special handling is
      currently implemented here.</dd>
  <dt id="rows"><a class="permalink" href="#rows">rows</a></dt>
  <dd>Returns the number of rows affected by the last execute. This method might
      return <span class="Li">&quot;undef&quot;</span>.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="DBI::DBD::SqlEngine::TableSource"><a class="permalink" href="#DBI::DBD::SqlEngine::TableSource">DBI::DBD::SqlEngine::TableSource</a></h2>
<p class="Pp">Provides data sources and table information on database driver and
    database handle level.</p>
<p class="Pp"></p>
<pre>  package DBI::DBD::SqlEngine::TableSource;
  sub data_sources ($;$)
  {
    my ( $class, $drh, $attrs ) = @_;
    ...
  }
  sub avail_tables
  {
    my ( $class, $drh ) = @_;
    ...
  }
</pre>
<p class="Pp">The <span class="Li">&quot;data_sources&quot;</span> method is
    called when the user invokes any of the following:</p>
<p class="Pp"></p>
<pre>  @ary = DBI-&gt;data_sources($driver);
  @ary = DBI-&gt;data_sources($driver, \%attr);
  
  @ary = $dbh-&gt;data_sources();
  @ary = $dbh-&gt;data_sources(\%attr);
</pre>
<p class="Pp">The <span class="Li">&quot;avail_tables&quot;</span> method is
    called when the user invokes any of the following:</p>
<p class="Pp"></p>
<pre>  @names = $dbh-&gt;tables( $catalog, $schema, $table, $type );
  
  $sth = $dbh-&gt;table_info( $catalog, $schema, $table, $type );
  $sth = $dbh-&gt;table_info( $catalog, $schema, $table, $type, \%attr );
  $dbh-&gt;func( &quot;list_tables&quot; );
</pre>
<p class="Pp">Every time where an <span class="Li">&quot;\%attr&quot;</span>
    argument can be specified, this <span class="Li">&quot;\%attr&quot;</span>
    object's <span class="Li">&quot;sql_table_source&quot;</span> attribute is
    preferred over the <span class="Li">$dbh</span> attribute or the driver
    default.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="DBI::DBD::SqlEngine::DataSource"><a class="permalink" href="#DBI::DBD::SqlEngine::DataSource">DBI::DBD::SqlEngine::DataSource</a></h2>
<p class="Pp">Provides base functionality for dealing with tables. It is
    primarily designed for allowing transparent access to files on disk or
    already opened (file-)streams (e.g. for DBD::CSV).</p>
<p class="Pp">Derived classes shall be restricted to similar functionality, too
    (e.g. opening streams from an archive, transparently compress/uncompress log
    files before parsing them,</p>
<p class="Pp"></p>
<pre>  package DBI::DBD::SqlEngine::DataSource;
  sub complete_table_name ($$;$)
  {
    my ( $self, $meta, $table, $respect_case ) = @_;
    ...
  }
</pre>
<p class="Pp">The method <span class="Li">&quot;complete_table_name&quot;</span>
    is called when first setting up the <i>meta information</i> for a table:</p>
<p class="Pp"></p>
<pre>  &quot;SELECT user.id, user.name, user.shell FROM user WHERE ...&quot;
</pre>
<p class="Pp">results in opening the table
    <span class="Li">&quot;user&quot;</span>. First step of the table open
    process is completing the name. Let's imagine you're having a DBD::CSV
    handle with following settings:</p>
<p class="Pp"></p>
<pre>  $dbh-&gt;{sql_identifier_case} = SQL_IC_LOWER;
  $dbh-&gt;{f_ext} = '.lst';
  $dbh-&gt;{f_dir} = '/data/web/adrmgr';
</pre>
<p class="Pp">Those settings will result in looking for files matching
    <span class="Li">&quot;[Uu][Ss][Ee][Rr](\.lst)?$&quot;</span> in
    <span class="Li">&quot;/data/web/adrmgr/&quot;</span>. The scanning of the
    directory <span class="Li">&quot;/data/web/adrmgr/&quot;</span> and the
    pattern match check will be done in
    <span class="Li">&quot;DBD::File::DataSource::File&quot;</span> by the
    <span class="Li">&quot;complete_table_name&quot;</span> method.</p>
<p class="Pp">If you intend to provide other sources of data streams than files,
    in addition to provide an appropriate
    <span class="Li">&quot;complete_table_name&quot;</span> method, a method to
    open the resource is required:</p>
<p class="Pp"></p>
<pre>  package DBI::DBD::SqlEngine::DataSource;
  sub open_data ($)
  {
    my ( $self, $meta, $attrs, $flags ) = @_;
    ...
  }
</pre>
<p class="Pp">After the method <span class="Li">&quot;open_data&quot;</span> has
    been run successfully, the table's meta information are in a state which
    allows the table's data accessor methods will be able to fetch/store row
    information. Implementation details heavily depends on the table
    implementation, whereby the most famous is surely DBD::File::Table.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="DBI::DBD::SqlEngine::Statement"><a class="permalink" href="#DBI::DBD::SqlEngine::Statement">DBI::DBD::SqlEngine::Statement</a></h2>
<p class="Pp">Derives from DBI::SQL::Nano::Statement for unified naming when
    deriving new drivers. No additional feature is provided from here.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="DBI::DBD::SqlEngine::Table"><a class="permalink" href="#DBI::DBD::SqlEngine::Table">DBI::DBD::SqlEngine::Table</a></h2>
<p class="Pp">Derives from DBI::SQL::Nano::Table for unified naming when
    deriving new drivers.</p>
<p class="Pp">You should consult the documentation of
    <span class="Li">&quot;SQL::Eval::Table&quot;</span> (see SQL::Eval) to get
    more information about the abstract methods of the table's base class you
    have to override and a description of the table meta information expected by
    the SQL engines.</p>
<dl class="Bl-tag">
  <dt id="bootstrap_table_meta"><a class="permalink" href="#bootstrap_table_meta">bootstrap_table_meta</a></dt>
  <dd>Initializes a table meta structure. Can be safely overridden in a derived
      class, as long as the <span class="Li">&quot;SUPER&quot;</span> method is
      called at the end of the overridden method.
    <p class="Pp">It copies the following attributes from the database into the
        table meta data <span class="Li">&quot;$dbh-&gt;{ReadOnly}&quot;</span>
        into <span class="Li">&quot;$meta-&gt;{readonly}&quot;</span>,
        <span class="Li">&quot;sql_identifier_case&quot;</span> and
        <span class="Li">&quot;sql_data_source&quot;</span> and makes them
        sticky to the table.</p>
    <p class="Pp">This method should be called before you attempt to map between
        file name and table name to ensure the correct directory, extension etc.
        are used.</p>
  </dd>
  <dt id="init_table_meta"><a class="permalink" href="#init_table_meta">init_table_meta</a></dt>
  <dd>Initializes more attributes of the table meta data - usually more
      expensive ones (e.g. those which require class instantiations) - when the
      file name and the table name could mapped.</dd>
  <dt id="get_table_meta"><a class="permalink" href="#get_table_meta">get_table_meta</a></dt>
  <dd>Returns the table meta data. If there are none for the required table, a
      new one is initialized. When after bootstrapping a new <i>table_meta</i>
      and completing the table name a mapping can be established between an
      existing <i>table_meta</i> and the new bootstrapped one, the already
      existing is used and a mapping shortcut between the recent used table name
      and the already known table name is hold in
      <span class="Li">&quot;$dbh-&gt;{sql_meta_map}&quot;</span>. When it
      fails, nothing is returned. On success, the name of the table and the meta
      data structure is returned.</dd>
  <dt id="get_table_meta_attr"><a class="permalink" href="#get_table_meta_attr">get_table_meta_attr</a></dt>
  <dd>Returns a single attribute from the table meta data. If the attribute name
      appears in <span class="Li">%compat_map</span>, the attribute name is
      updated from there.</dd>
  <dt id="set_table_meta_attr"><a class="permalink" href="#set_table_meta_attr">set_table_meta_attr</a></dt>
  <dd>Sets a single attribute in the table meta data. If the attribute name
      appears in <span class="Li">%compat_map</span>, the attribute name is
      updated from there.</dd>
  <dt id="table_meta_attr_changed"><a class="permalink" href="#table_meta_attr_changed">table_meta_attr_changed</a></dt>
  <dd>Called when an attribute of the meta data is modified.
    <p class="Pp">If the modified attribute requires to reset a calculated
        attribute, the calculated attribute is reset (deleted from meta data
        structure) and the <i>initialized</i> flag is removed, too. The decision
        is made based on <span class="Li">%register_reset_on_modify</span>.</p>
  </dd>
  <dt id="register_reset_on_modify"><a class="permalink" href="#register_reset_on_modify">register_reset_on_modify</a></dt>
  <dd>Allows <span class="Li">&quot;set_table_meta_attr&quot;</span> to reset
      meta attributes when special attributes are modified. For DBD::File,
      modifying one of <span class="Li">&quot;f_file&quot;</span>,
      <span class="Li">&quot;f_dir&quot;</span>,
      <span class="Li">&quot;f_ext&quot;</span> or
      <span class="Li">&quot;f_lockfile&quot;</span> will reset
      <span class="Li">&quot;f_fqfn&quot;</span>. DBD::DBM extends the list for
      <span class="Li">&quot;dbm_type&quot;</span> and
      <span class="Li">&quot;dbm_mldbm&quot;</span> to reset the value of
      <span class="Li">&quot;dbm_tietype&quot;</span>.
    <p class="Pp">If your DBD has calculated values in the meta data area, then
        call <span class="Li">&quot;register_reset_on_modify&quot;</span>:</p>
    <p class="Pp"></p>
    <pre>    my %reset_on_modify = ( &quot;xxx_foo&quot; =&gt; &quot;xxx_bar&quot; );
    __PACKAGE__-&gt;register_reset_on_modify( \%reset_on_modify );
    </pre>
  </dd>
  <dt id="register_compat_map"><a class="permalink" href="#register_compat_map">register_compat_map</a></dt>
  <dd>Allows <span class="Li">&quot;get_table_meta_attr&quot;</span> and
      <span class="Li">&quot;set_table_meta_attr&quot;</span> to update the
      attribute name to the current favored one:
    <p class="Pp"></p>
    <pre>    # from DBD::DBM
    my %compat_map = ( &quot;dbm_ext&quot; =&gt; &quot;f_ext&quot; );
    __PACKAGE__-&gt;register_compat_map( \%compat_map );
    </pre>
  </dd>
  <dt id="open_data"><a class="permalink" href="#open_data">open_data</a></dt>
  <dd>Called to open the table's data storage. This is silently forwarded to
      <span class="Li">&quot;$meta-&gt;{sql_data_source}-&gt;open_data()&quot;</span>.
    <p class="Pp">After this is done, a derived class might add more steps in an
        overridden <span class="Li">&quot;open_file&quot;</span> method.</p>
  </dd>
  <dt id="new"><a class="permalink" href="#new">new</a></dt>
  <dd>Instantiates the table. This is done in 3 steps:
    <p class="Pp"></p>
    <pre> 1. get the table meta data
 2. open the data file
 3. bless the table data structure using inherited constructor new
    </pre>
    <p class="Pp">It is not recommended to override the constructor of the table
        class. Find a reasonable place to add you extensions in one of the above
        four methods.</p>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">The module DBI::DBD::SqlEngine is currently maintained by</p>
<p class="Pp">H.Merijn Brand &lt; h.m.brand at xs4all.nl &gt; and Jens Rehsack
    &lt; rehsack at googlemail.com &gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">Copyright (C) 2010 by H.Merijn Brand &amp; Jens Rehsack</p>
<p class="Pp">All rights reserved.</p>
<p class="Pp">You may freely distribute and/or modify this module under the
    terms of either the GNU General Public License (GPL) or the Artistic
    License, as specified in the Perl README file.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2016-04-21</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Test::Trap(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Test::Trap(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Test::Trap(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Test::Trap - Trap exit codes, exceptions, output, etc.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">Version 0.3.4</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  use Test::More;
  use Test::Trap;
  my @r = trap { some_code(@some_parameters) };
  is ( $trap-&gt;exit, 1, 'Expecting &amp;some_code to exit with 1' );
  is ( $trap-&gt;stdout, '', 'Expecting no STDOUT' );
  like ( $trap-&gt;stderr, qr/^Bad parameters; exiting\b/, 'Expecting warnings.' );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Primarily (but not exclusively) for use in test scripts: A block
    eval on steroids, configurable and extensible, but by default trapping
    (Perl) STDOUT, STDERR, warnings, exceptions, would-be exit codes, and return
    values from boxed blocks of test code.</p>
<p class="Pp">The values collected by the latest trap can then be queried or
    tested through a special trap object.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORT"><a class="permalink" href="#EXPORT">EXPORT</a></h1>
<p class="Pp">A function and a scalar may be exported by any name. The function
    (by default named <span class="Li">&quot;trap&quot;</span>) is an analogue
    to block <b>eval()</b>, and the scalar (by default named
    <span class="Li">$trap</span>) is the corresponding analogue to
    <span class="Li">$@</span>.</p>
<p class="Pp">Optionally, you may specify the layers of the exported trap.
    Layers may be specified by name, with a colon sigil. Multiple layers may be
    given in a list, or just stringed together like
    <span class="Li">&quot;:flow:stderr:warn&quot;</span>.</p>
<p class="Pp">(For the advanced user, you may also specify anonymous layer
    implementations -- i.e. an appropriate subroutine.)</p>
<p class="Pp">See below for a list of the built-in layers, most of which are
    enabled by default. Note, finally, that the ordering of the layers matter:
    The :raw layer is always on the bottom (anything underneath it is ignored),
    and any other &quot;flow control&quot; layers used should be right down
    there with it.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTION"><a class="permalink" href="#FUNCTION">FUNCTION</a></h1>
<section class="Ss">
<h2 class="Ss" id="trap_"><a class="permalink" href="#trap_">trap BLOCK</a></h2>
<p class="Pp">This function may be exported by any name, but defaults to
    <span class="Li">&quot;trap&quot;</span>.</p>
<p class="Pp">By default, traps exceptions (like block eval), but also exits and
    exit codes, returns and return values, context, and (Perl) output on STDOUT
    or STDERR, and warnings. All information trapped can be queried through the
    trap object, which is by default exported as <span class="Li">$trap</span>,
    but can be exported by any name.</p>
<p class="Pp">The value returned from <span class="Li">&quot;trap&quot;</span>
    mimics that returned from <span class="Li">&quot;eval&quot;</span>: If the
    <i>BLOCK</i> would die or exit, it returns an undefined value in scalar
    context or an empty list in list context; otherwise it returns whatever the
    <i>BLOCK</i> would return in the given context (also available as the
    trapped return values).</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TRAP_LAYERS"><a class="permalink" href="#TRAP_LAYERS">TRAP
  LAYERS</a></h1>
<p class="Pp">Exactly what the <span class="Li">&quot;trap&quot;</span> traps
    depends on the layers of the trap. It is possible to register more (see
    Test::Trap::Builder), but the following layers are pre-defined by this
    module:</p>
<section class="Ss">
<h2 class="Ss" id=":raw"><a class="permalink" href="#:raw">:raw</a></h2>
<p class="Pp">The only built-in terminating layer, at which the processing of
    the layers stops, and the actual call to the user code is performed. On
    success, it collects the return value(s) in the appropriate context. Pushing
    the :raw layer on a trap will for most purposes remove all layers below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id=":die"><a class="permalink" href="#:die">:die</a></h2>
<p class="Pp">The layer emulating block eval, trapping normal exceptions.</p>
</section>
<section class="Ss">
<h2 class="Ss" id=":exit"><a class="permalink" href="#:exit">:exit</a></h2>
<p class="Pp">The third &quot;flow control&quot; layer, capturing exit codes if
    anything used in the dynamic scope of the trap calls
    <b>CORE::GLOBAL::exit()</b>. (See CAVEATS below for more.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id=":flow"><a class="permalink" href="#:flow">:flow</a></h2>
<p class="Pp">A shortcut for :raw:die:exit (effectively pushing all three layers
    on the trap). Since this includes :raw, it is also terminating: Pushing
    :flow on a trap will effectively remove all layers below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id=":stdout,_:stderr"><a class="permalink" href="#:stdout,_:stderr">:stdout,
  :stderr</a></h2>
<p class="Pp">Layers trapping Perl output on STDOUT and STDERR,
  respectively.</p>
</section>
<section class="Ss">
<h2 class="Ss" id=":stdout(perlio),_:stderr(perlio)"><a class="permalink" href="#:stdout(perlio),_:stderr(perlio)">:stdout(perlio),
  :stderr(perlio)</a></h2>
<p class="Pp">As above, but specifying a capture strategy using PerlIO::scalar.
    If this strategy is not available (typically if PerlIO is not), this is an
    error. See &quot;CAPTURE STRATEGIES&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id=":stdout(tempfile),_:stderr(tempfile)"><a class="permalink" href="#:stdout(tempfile),_:stderr(tempfile)">:stdout(tempfile),
  :stderr(tempfile)</a></h2>
<p class="Pp">As above, but specifying a capture strategy using File::Temp. Note
    that this is the default strategy, unless the
    <span class="Li">&quot;:output()&quot;</span> layer is used to set another
    default. See &quot;CAPTURE STRATEGIES&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id=":stdout(a;b;c),_:stderr(a,b,c)"><a class="permalink" href="#:stdout(a;b;c),_:stderr(a,b,c)">:stdout(a;b;c),
  :stderr(a,b,c)</a></h2>
<p class="Pp">(Either syntax, commas or semicolons, is permitted, as is any
    number of names in the list.) As above, but specifying the capture strategy
    by the first existing name among <i>a</i>, <i>b</i>, and <i>c</i>. If no
    such strategy is found, this is an error. See &quot;CAPTURE
    STRATEGIES&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id=":warn"><a class="permalink" href="#:warn">:warn</a></h2>
<p class="Pp">A layer trapping warnings, with additional tee: If STDERR is open,
    it will also print the warnings there. (This output may be trapped by the
    :stderr layer, be it above or below the :warn layer.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id=":default"><a class="permalink" href="#:default">:default</a></h2>
<p class="Pp">A short-cut for :raw:die:exit:stdout:stderr:warn (effectively
    pushing all six layers on the trap). Since this includes :raw, it is also
    terminating: Pushing :default on a trap will effectively remove all layers
    below.</p>
<p class="Pp">The other interesting property of :default is that it is what
    every trap starts with: In order not to include the six layers that make up
    :default, you need to push a terminating layer (such as :raw or :flow) on
    the trap.</p>
</section>
<section class="Ss">
<h2 class="Ss" id=":on_fail(m)"><a class="permalink" href="#:on_fail(m)">:on_fail(m)</a></h2>
<p class="Pp">A (non-default, non-trapping) layer that installs a callback
    method (by name) <i>m</i> to be run on test failures. To run the
    &quot;diag_all&quot; method every time a test fails:</p>
<p class="Pp"></p>
<pre>  use Test::Trap qw/ :on_fail(diag_all) /;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id=":void,_:scalar,_:list"><a class="permalink" href="#:void,_:scalar,_:list">:void,
  :scalar, :list</a></h2>
<p class="Pp">These (non-default, non-trapping) layers will cause the trapped
    user code to be run in void, scalar, or list context, respectively. (By
    default, the trap will propagate context, that is, it will run the code in
    whatever context the trap itself is in.)</p>
<p class="Pp">If more than one of these layers are pushed on the trap, the
    deepest (that is, leftmost) takes precedence:</p>
<p class="Pp"></p>
<pre>  use Test::Trap qw/ :scalar:void:list /;
  trap { 42, 13 };
  $trap-&gt;return_is_deeply( [ 13 ], 'Scalar comma.' );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id=":output(a;b;c)"><a class="permalink" href="#:output(a;b;c)">:output(a;b;c)</a></h2>
<p class="Pp">A (non-default, non-trapping) layer that sets the default capture
    strategy for any output trapping
    (<span class="Li">&quot;:stdout&quot;</span>,
    <span class="Li">&quot;:stderr&quot;</span>, or other similarly defined)
    layers below iton the trap.</p>
<p class="Pp"></p>
<pre>  use Test::Trap qw/ :output(systemsafe) /;
  trap { system echo =&gt; 'Hello Unix!' }; # trapped!
  use Test::Trap qw/ :flow:stderr:output(systemsafe):stdout /;
  trap { system echo =&gt; 'Hello Unix!' }; # *not* trapped!
  trap { system q/ echo 'Hello Unix!' &gt;&amp;2 / }; # trapped!
</pre>
<p class="Pp">See &quot;CAPTURE STRATEGIES&quot;.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CAPTURE_STRATEGIES"><a class="permalink" href="#CAPTURE_STRATEGIES">CAPTURE
  STRATEGIES</a></h1>
<p class="Pp">How output is trapped, depends on the capture strategy used. It is
    possible to register more (see Test::Trap::Builder), but the following
    strategies are pre-defined by this module:</p>
<section class="Ss">
<h2 class="Ss" id="tempfile"><a class="permalink" href="#tempfile">tempfile</a></h2>
<p class="Pp">The default capture strategy, provided by
    Test::Trap::Builder::TempFile, in which output is temporarily redirected to
    (and read back from) a tempfile.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="tempfile-preserve"><a class="permalink" href="#tempfile-preserve">tempfile-preserve</a></h2>
<p class="Pp">A variant of the capture strategy provided by
    Test::Trap::Builder::TempFile, in which the handles used to write to and
    read from the tempfile are both binmoded with the same perlio layers as the
    trapped output handle originally had.</p>
<p class="Pp">Caveat emptor: If the handle has perlio custom layers, they may
    (or may not) fail to apply to the tempfile read and write handles.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="systemsafe"><a class="permalink" href="#systemsafe">systemsafe</a></h2>
<p class="Pp">A capture strategy provided by Test::Trap::Builder::SystemSafe,
    like the default strategy, except it outputs on file handles with the same
    file descriptors as the trapped output handle originally had, and so can be
    used to trap output from forked-off processes, including
  <b>system()</b>.</p>
<p class="Pp">This strategy may be &quot;safe&quot; in relation to forked-off
    processes, but it is fragile. For one, it only works with handles that have
    &quot;real&quot; file descriptors. For another, it depends on the original
    file descriptors being available after closing. (If signal handlers or
    threads open files, they may well not be.) And it may fail in other ways.
    But in relation to forked-off processes, the other pre-defined strategies
    will silently fail to trap, as will similarly simple strategies. This one,
    when not crashing, will trap that output.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="systemsafe-preserve"><a class="permalink" href="#systemsafe-preserve">systemsafe-preserve</a></h2>
<p class="Pp">A variant of the capture strategy provided by
    Test::Trap::Builder::SystemSafe, in which the handles used to write to and
    read from the tempfile are both binmoded with the same perlio layers as the
    trapped output handle originally had.</p>
<p class="Pp">Caveat emptor: If the handle has perlio custom layers, they may
    (or may not) fail to apply to the tempfile read and write handles.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="perlio"><a class="permalink" href="#perlio">perlio</a></h2>
<p class="Pp">A capture strategy provided by Test::Trap::Builder::PerlIO, in
    which output is temporarily redirected to an in-memory file via
    PerlIO::scalar.</p>
<p class="Pp">If PerlIO::scalar is not available, neither is this strategy.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="RESULT_ACCESSORS"><a class="permalink" href="#RESULT_ACCESSORS">RESULT
  ACCESSORS</a></h1>
<p class="Pp">The following methods may be called on the trap objects after any
    trap has been sprung, and access the outcome of the run.</p>
<p class="Pp">Any property will be undef if not actually trapped -- whether
    because there is no layer to trap them or because flow control passed them
    by. (If there is an active and successful trap layer, empty strings and
    empty arrays trapped will of course be defined.)</p>
<p class="Pp">When properties are set, their values will be as follows:</p>
<section class="Ss">
<h2 class="Ss" id="leaveby"><a class="permalink" href="#leaveby">leaveby</a></h2>
<p class="Pp">A string indicating how the trap terminated:
    <span class="Li">&quot;return&quot;</span>,
    <span class="Li">&quot;die&quot;</span>, or
    <span class="Li">&quot;exit&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="die"><a class="permalink" href="#die">die</a></h2>
<p class="Pp">The exception, if the latest trap threw one.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="exit"><a class="permalink" href="#exit">exit</a></h2>
<p class="Pp">The exit code, if the latest trap tried to exit (by way of the
    trap's own &amp;CORE::GLOBAL::exit only; see &quot;CAVEATS&quot;).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="return__"><a class="permalink" href="#return__">return [INDEX
  ...]</a></h2>
<p class="Pp">Returns undef if the latest trap did not terminate with a return;
    otherwise returns three different views of the return array:</p>
<ul class="Bl-bullet">
  <li>if no <i>INDEX</i> is passed, returns a reference to the array (NB! an
      empty array of indices qualifies as &quot;no index&quot;)</li>
  <li>if called with at least one <i>INDEX</i> in scalar context, returns the
      array element indexed by the first <i>INDEX</i> (ignoring the rest)</li>
  <li>if called with at least one <i>INDEX</i> in list context, returns the
      slice of the array by these indices</li>
</ul>
<p class="Pp">Note: The array will hold but a single value if the trap was
    sprung in scalar context, and will be empty if it was in void context.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="stdout,_stderr"><a class="permalink" href="#stdout,_stderr">stdout,
  stderr</a></h2>
<p class="Pp">The captured output on the respective file handles.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="warn__"><a class="permalink" href="#warn__">warn
  [INDEX]</a></h2>
<p class="Pp">Returns undef if the latest trap had no warning-trapping layer;
    otherwise returns three different views of the warn array:</p>
<ul class="Bl-bullet">
  <li>if no <i>INDEX</i> is passed, returns a reference to the array (NB! an
      empty array of indices qualifies as &quot;no index&quot;)</li>
  <li>if called with at least one <i>INDEX</i> in scalar context, returns the
      array element indexed by the first <i>INDEX</i> (ignoring the rest)</li>
  <li>if called with at least one <i>INDEX</i> in list context, returns the
      slice of the array by these indices</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="wantarray"><a class="permalink" href="#wantarray">wantarray</a></h2>
<p class="Pp">The context in which the latest code trapped was called. (By
    default a propagated context, but layers can override this.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="list,_scalar,_void"><a class="permalink" href="#list,_scalar,_void">list,
  scalar, void</a></h2>
<p class="Pp">True if the latest code trapped was called in the indicated
    context. (By default the code will be called in a propagated context, but
    layers can override this.)</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="RESULT_TESTS"><a class="permalink" href="#RESULT_TESTS">RESULT
  TESTS</a></h1>
<p class="Pp">For each accessor, a number of convenient standard test methods
    are also available. By default, these are a few standard tests from
    Test::More, plus the <span class="Li">&quot;nok&quot;</span> test (a negated
    <span class="Li">&quot;ok&quot;</span> test). All for convenience:</p>
<section class="Ss">
<h2 class="Ss"><i>ACCESSOR</i>_ok [INDEX,] TEST_NAME</h2>
</section>
<section class="Ss">
<h2 class="Ss"><i>ACCESSOR</i>_nok [INDEX,] TEST_NAME</h2>
</section>
<section class="Ss">
<h2 class="Ss"><i>ACCESSOR</i>_is [INDEX,] SCALAR, TEST_NAME</h2>
</section>
<section class="Ss">
<h2 class="Ss"><i>ACCESSOR</i>_isnt [INDEX,] SCALAR, TEST_NAME</h2>
</section>
<section class="Ss">
<h2 class="Ss"><i>ACCESSOR</i>_isa_ok [INDEX,] SCALAR, INVOCANT_NAME</h2>
</section>
<section class="Ss">
<h2 class="Ss"><i>ACCESSOR</i>_like [INDEX,] REGEX, TEST_NAME</h2>
</section>
<section class="Ss">
<h2 class="Ss"><i>ACCESSOR</i>_unlike [INDEX,] REGEX, TEST_NAME</h2>
</section>
<section class="Ss">
<h2 class="Ss"><i>ACCESSOR</i>_is_deeply STRUCTURE, TEST_NAME</h2>
<p class="Pp"><i>INDEX</i> is not optional: It is required for array accessors
    (like <span class="Li">&quot;return&quot;</span> and
    <span class="Li">&quot;warn&quot;</span>), and disallowed for scalar
    accessors. Note that the <span class="Li">&quot;is_deeply&quot;</span> test
    does not accept an index. Even for array accessors, it operates on the
    entire array.</p>
<p class="Pp">For convenience and clarity, tests against a flow control
    <i>ACCESSOR</i> (<span class="Li">&quot;return&quot;</span>,
    <span class="Li">&quot;die&quot;</span>,
    <span class="Li">&quot;exit&quot;</span>, or any you define yourself) will
    first test whether the trap was left by way of the flow control mechanism in
    question, and fail with appropriate diagnostics otherwise.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="did_die,_did_exit,_did_return"><a class="permalink" href="#did_die,_did_exit,_did_return">did_die,
  did_exit, did_return</a></h2>
<p class="Pp">Conveniences: Tests whether the trap was left by way of the flow
    control mechanism in question. Much like
    <span class="Li">&quot;leaveby_is('die')&quot;</span> etc, but with better
    diagnostics and (run-time) spell checking.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="quiet"><a class="permalink" href="#quiet">quiet</a></h2>
<p class="Pp">Convenience: Passes if zero-length output was trapped on both
    STDOUT and STDERR, and generate better diagnostics otherwise.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="UTILITIES"><a class="permalink" href="#UTILITIES">UTILITIES</a></h1>
<section class="Ss">
<h2 class="Ss" id="diag_all"><a class="permalink" href="#diag_all">diag_all</a></h2>
<p class="Pp">Prints a diagnostic message (as per &quot;diag&quot; in
    Test::More) consisting of a dump (in Perl code, as per Data::Dump) of the
    trap object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="diag_all_once"><a class="permalink" href="#diag_all_once">diag_all_once</a></h2>
<p class="Pp">As &quot;diag_all&quot;, except if this instance of the trap
    object has already been diag_all_once'd, the diagnostic message will instead
    consist of the string <span class="Li">&quot;(as above)&quot;</span>.</p>
<p class="Pp">This could be useful with the
    <span class="Li">&quot;on_fail&quot;</span> layer:</p>
<p class="Pp"></p>
<pre>  use Test::Trap qw/ :on_fail(diag_all_once) /;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<p class="Pp">This module must be loaded before any code containing
    <b>exit()</b>s to be trapped is compiled. Any <b>exit()</b> already compiled
    won't be trappable, and will terminate the program anyway.</p>
<p class="Pp">This module overrides &amp;CORE::GLOBAL::exit, so may not work
    correctly (or even at all) in the presence of other code overriding
    &amp;CORE::GLOBAL::exit. More precisely: This module installs its own
    <b>exit()</b> on entry of the block, and restores the previous one, if any,
    only upon leaving the block.</p>
<p class="Pp">If you use <b>fork()</b> in the dynamic scope of a trap, beware
    that the (default) :exit layer of that trap does not trap <b>exit()</b> in
    the children, but passes them to the outer handler. If you think about it,
    this is what you are likely to want it to do in most cases.</p>
<p class="Pp">Note that the (default) :exit layer only traps
    &amp;CORE::GLOBAL::exit calls (and bare <b>exit()</b> calls that compile to
    that). It makes no attempt to trap <b>CORE::exit()</b>,
    <b>POSIX::_exit()</b>, <b>exec()</b>, untrapped exceptions from
    <b>die()</b>, nor segfault. Nor does it attempt to trap anything else that
    might terminate the program. The trap is a block eval on steroids -- not the
    last block eval of Krypton!</p>
<p class="Pp">This module traps warnings using
    <span class="Li">$SIG{__WARN__}</span>, so may not work correctly (or even
    at all) in the presence of other code setting this handler. More precisely:
    This module installs its own __WARN__ handler on entry of the block, and
    restores the previous one, if any, only upon leaving the block.</p>
<p class="Pp">The (default) :stdout and :stderr handlers will not trap output
    from <b>system()</b> calls.</p>
<p class="Pp">Threads? No idea. It might even work correctly.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">Please report any bugs or feature requests directly to the
  author.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Eirik Berg Hanssen,
    <span class="Li">&quot;&lt;ebhanssen@cpan.org&gt;&quot;</span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_&amp;_LICENSE"><a class="permalink" href="#COPYRIGHT_&amp;_LICENSE">COPYRIGHT
  &amp; LICENSE</a></h1>
<p class="Pp">Copyright 2006-2014 Eirik Berg Hanssen, All Rights Reserved.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2023-08-05</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

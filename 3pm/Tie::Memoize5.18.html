<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Tie::Memoize(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Tie::Memoize(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Tie::Memoize(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Tie::Memoize - add data to hash when needed</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
  require Tie::Memoize;
  tie %hash, 'Tie::Memoize',
      \&amp;fetch,                  # The rest is optional
      $DATA, \&amp;exists,
      {%ini_value}, {%ini_existence};
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This package allows a tied hash to autoload its values on the
    first access, and to use the cached value on the following accesses.</p>
<p class="Pp">Only read-accesses (via fetching the value or
    <span class="Li">&quot;exists&quot;</span>) result in calls to the
    functions; the modify-accesses are performed as on a normal hash.</p>
<p class="Pp">The required arguments during
    <span class="Li">&quot;tie&quot;</span> are the hash, the package, and the
    reference to the <span class="Li">&quot;FETCH&quot;</span>ing function. The
    optional arguments are an arbitrary scalar <span class="Li">$data</span>,
    the reference to the <span class="Li">&quot;EXISTS&quot;</span> function,
    and initial values of the hash and of the existence cache.</p>
<p class="Pp">Both the <span class="Li">&quot;FETCH&quot;</span>ing function and
    the <span class="Li">&quot;EXISTS&quot;</span> functions have the same
    signature: the arguments are <span class="Li">&quot;$key,
    $data&quot;</span>; <span class="Li">$data</span> is the same value as given
    as argument during <i>tie()</i>ing. Both functions should return an empty
    list if the value does not exist. If
    <span class="Li">&quot;EXISTS&quot;</span> function is different from the
    <span class="Li">&quot;FETCH&quot;</span>ing function, it should return a
    TRUE value on success. The <span class="Li">&quot;FETCH&quot;</span>ing
    function should return the intended value if the key is valid.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Inheriting_from_"><a class="permalink" href="#Inheriting_from_">Inheriting
  from <b>Tie::Memoize</b></a></h1>
<p class="Pp">The structure of the <i>tied()</i> data is an array reference with
    elements</p>
<p class="Pp"></p>
<pre>
  0:  cache of known values
  1:  cache of known existence of keys
  2:  FETCH  function
  3:  EXISTS function
  4:  $data
</pre>
<p class="Pp">The rest is for internal usage of this package. In particular, if
    TIEHASH is overwritten, it should call SUPER::TIEHASH.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLE"><a class="permalink" href="#EXAMPLE">EXAMPLE</a></h1>
<pre>
  sub slurp {
    my ($key, $dir) = shift;
    open my $h, '&lt;', &quot;$dir/$key&quot; or return;
    local $/; &lt;$h&gt;                      # slurp it all
  }
  sub exists { my ($key, $dir) = shift; return -f &quot;$dir/$key&quot; }

  tie %hash, 'Tie::Memoize', \&amp;slurp, $directory, \&amp;exists,
      { fake_file1 =&gt; $content1, fake_file2 =&gt; $content2 },
      { pretend_does_not_exists =&gt; 0, known_to_exist =&gt; 1 };
</pre>
<p class="Pp">This example treats the slightly modified contents of
    <span class="Li">$directory</span> as a hash. The modifications are that the
    keys <i>fake_file1</i> and <i>fake_file2</i> fetch values
    <span class="Li">$content1</span> and <span class="Li">$content2</span>, and
    <i>pretend_does_not_exists</i> will never be accessed. Additionally, the
    existence of <i>known_to_exist</i> is never checked (so if it does not
    exists when its content is needed, the user of <span class="Li">%hash</span>
    may be confused).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">FIRSTKEY and NEXTKEY methods go through the keys which were
    already read, not all the possible keys of the hash.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Ilya Zakharevich
    &lt;mailto:perl-module-hash-memoize@ilyaz.org&gt;.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-31</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

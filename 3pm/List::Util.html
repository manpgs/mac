<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>List::Util(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">List::Util(3pm)</td>
    <td class="head-vol"><a href=".">Perl Programmers Reference Guide</a></td>
    <td class="head-rtitle">List::Util(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">List::Util - A selection of general-utility list subroutines</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use List::Util qw(
      reduce any all none notall first reductions
      max maxstr min minstr product sum sum0
      pairs unpairs pairkeys pairvalues pairfirst pairgrep pairmap
      shuffle uniq uniqint uniqnum uniqstr
    );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><span class="Li">&quot;List::Util&quot;</span> contains a
    selection of subroutines that people have expressed would be nice to have in
    the perl core, but the usage would not really be high enough to warrant the
    use of a keyword, and the size so small such that being individual
    extensions would be wasteful.</p>
<p class="Pp">By default <span class="Li">&quot;List::Util&quot;</span> does not
    export any subroutines.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LIST-REDUCTION_FUNCTIONS"><a class="permalink" href="#LIST-REDUCTION_FUNCTIONS">LIST-REDUCTION
  FUNCTIONS</a></h1>
<p class="Pp">The following set of functions all apply a given block of code to
    a list of values.</p>
<section class="Ss">
<h2 class="Ss" id="reduce"><a class="permalink" href="#reduce">reduce</a></h2>
<pre>    $result = reduce { BLOCK } @list
</pre>
<p class="Pp">Reduces <span class="Li">@list</span> by calling
    <span class="Li">&quot;BLOCK&quot;</span> in a scalar context multiple
    times, setting <span class="Li">$a</span> and <span class="Li">$b</span>
    each time. The first call will be with <span class="Li">$a</span> and
    <span class="Li">$b</span> set to the first two elements of the list,
    subsequent calls will be done by setting <span class="Li">$a</span> to the
    result of the previous call and <span class="Li">$b</span> to the next
    element in the list.</p>
<p class="Pp">Returns the result of the last call to the
    <span class="Li">&quot;BLOCK&quot;</span>. If <span class="Li">@list</span>
    is empty then <span class="Li">&quot;undef&quot;</span> is returned. If
    <span class="Li">@list</span> only contains one element then that element is
    returned and <span class="Li">&quot;BLOCK&quot;</span> is not executed.</p>
<p class="Pp">The following examples all demonstrate how
    <span class="Li">&quot;reduce&quot;</span> could be used to implement the
    other list-reduction functions in this module. (They are not in fact
    implemented like this, but instead in a more efficient manner in individual
    C functions).</p>
<p class="Pp"></p>
<pre>    $foo = reduce { defined($a)            ? $a :
                    $code-&gt;(local $_ = $b) ? $b :
                                             undef } undef, @list # first
    $foo = reduce { $a &gt; $b ? $a : $b } 1..10       # max
    $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
    $foo = reduce { $a &lt; $b ? $a : $b } 1..10       # min
    $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
    $foo = reduce { $a + $b } 1 .. 10               # sum
    $foo = reduce { $a . $b } @bar                  # concat
    $foo = reduce { $a || $code-&gt;(local $_ = $b) } 0, @bar   # any
    $foo = reduce { $a &amp;&amp; $code-&gt;(local $_ = $b) } 1, @bar   # all
    $foo = reduce { $a &amp;&amp; !$code-&gt;(local $_ = $b) } 1, @bar  # none
    $foo = reduce { $a || !$code-&gt;(local $_ = $b) } 0, @bar  # notall
       # Note that these implementations do not fully short-circuit
</pre>
<p class="Pp">If your algorithm requires that
    <span class="Li">&quot;reduce&quot;</span> produce an identity value, then
    make sure that you always pass that identity value as the first argument to
    prevent <span class="Li">&quot;undef&quot;</span> being returned</p>
<p class="Pp"></p>
<pre>  $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
</pre>
<p class="Pp">The above example code blocks also suggest how to use
    <span class="Li">&quot;reduce&quot;</span> to build a more efficient
    combined version of one of these basic functions and a
    <span class="Li">&quot;map&quot;</span> block. For example, to find the
    total length of all the strings in a list, we could use</p>
<p class="Pp"></p>
<pre>    $total = sum map { length } @strings;
</pre>
<p class="Pp">However, this produces a list of temporary integer values as long
    as the original list of strings, only to reduce it down to a single value
    again. We can compute the same result more efficiently by using
    <span class="Li">&quot;reduce&quot;</span> with a code block that
    accumulates lengths by writing this instead as:</p>
<p class="Pp"></p>
<pre>    $total = reduce { $a + length $b } 0, @strings
</pre>
<p class="Pp">The other scalar-returning list reduction functions are all
    specialisations of this generic idea.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="reductions"><a class="permalink" href="#reductions">reductions</a></h2>
<pre>    @results = reductions { BLOCK } @list
</pre>
<p class="Pp"><i>Since version 1.54.</i></p>
<p class="Pp">Similar to <span class="Li">&quot;reduce&quot;</span> except that
    it also returns the intermediate values along with the final result. As
    before, <span class="Li">$a</span> is set to the first element of the given
    list, and the <span class="Li">&quot;BLOCK&quot;</span> is then called once
    for remaining item in the list set into <span class="Li">$b</span>, with the
    result being captured for return as well as becoming the new value for
    <span class="Li">$a</span>.</p>
<p class="Pp">The returned list will begin with the initial value for
    <span class="Li">$a</span>, followed by each return value from the block in
    order. The final value of the result will be identical to what the
    <span class="Li">&quot;reduce&quot;</span> function would have returned
    given the same block and list.</p>
<p class="Pp"></p>
<pre>    reduce     { &quot;$a-$b&quot; }  &quot;a&quot;..&quot;d&quot;    # &quot;a-b-c-d&quot;
    reductions { &quot;$a-$b&quot; }  &quot;a&quot;..&quot;d&quot;    # &quot;a&quot;, &quot;a-b&quot;, &quot;a-b-c&quot;, &quot;a-b-c-d&quot;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="any"><a class="permalink" href="#any">any</a></h2>
<pre>    my $bool = any { BLOCK } @list;
</pre>
<p class="Pp"><i>Since version 1.33.</i></p>
<p class="Pp">Similar to <span class="Li">&quot;grep&quot;</span> in that it
    evaluates <span class="Li">&quot;BLOCK&quot;</span> setting
    <span class="Li">$_</span> to each element of <span class="Li">@list</span>
    in turn. <span class="Li">&quot;any&quot;</span> returns true if any element
    makes the <span class="Li">&quot;BLOCK&quot;</span> return a true value. If
    <span class="Li">&quot;BLOCK&quot;</span> never returns true or
    <span class="Li">@list</span> was empty then it returns false.</p>
<p class="Pp">Many cases of using <span class="Li">&quot;grep&quot;</span> in a
    conditional can be written using <span class="Li">&quot;any&quot;</span>
    instead, as it can short-circuit after the first true result.</p>
<p class="Pp"></p>
<pre>    if( any { length &gt; 10 } @strings ) {
        # at least one string has more than 10 characters
    }
</pre>
<p class="Pp">Note: Due to XS issues the block passed may be able to access the
    outer <span class="Li">@_</span> directly. This is not intentional and will
    break under debugger.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="all"><a class="permalink" href="#all">all</a></h2>
<pre>    my $bool = all { BLOCK } @list;
</pre>
<p class="Pp"><i>Since version 1.33.</i></p>
<p class="Pp">Similar to &quot;any&quot;, except that it requires all elements
    of the <span class="Li">@list</span> to make the
    <span class="Li">&quot;BLOCK&quot;</span> return true. If any element
    returns false, then it returns false. If the
    <span class="Li">&quot;BLOCK&quot;</span> never returns false or the
    <span class="Li">@list</span> was empty then it returns true.</p>
<p class="Pp">Note: Due to XS issues the block passed may be able to access the
    outer <span class="Li">@_</span> directly. This is not intentional and will
    break under debugger.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="none"><a class="permalink" href="#none">none</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="notall"><a class="permalink" href="#notall">notall</a></h2>
<pre>    my $bool = none { BLOCK } @list;
    my $bool = notall { BLOCK } @list;
</pre>
<p class="Pp"><i>Since version 1.33.</i></p>
<p class="Pp">Similar to &quot;any&quot; and &quot;all&quot;, but with the
    return sense inverted. <span class="Li">&quot;none&quot;</span> returns true
    only if no value in the <span class="Li">@list</span> causes the
    <span class="Li">&quot;BLOCK&quot;</span> to return true, and
    <span class="Li">&quot;notall&quot;</span> returns true only if not all of
    the values do.</p>
<p class="Pp">Note: Due to XS issues the block passed may be able to access the
    outer <span class="Li">@_</span> directly. This is not intentional and will
    break under debugger.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="first"><a class="permalink" href="#first">first</a></h2>
<pre>    my $val = first { BLOCK } @list;
</pre>
<p class="Pp">Similar to <span class="Li">&quot;grep&quot;</span> in that it
    evaluates <span class="Li">&quot;BLOCK&quot;</span> setting
    <span class="Li">$_</span> to each element of <span class="Li">@list</span>
    in turn. <span class="Li">&quot;first&quot;</span> returns the first element
    where the result from <span class="Li">&quot;BLOCK&quot;</span> is a true
    value. If <span class="Li">&quot;BLOCK&quot;</span> never returns true or
    <span class="Li">@list</span> was empty then
    <span class="Li">&quot;undef&quot;</span> is returned.</p>
<p class="Pp"></p>
<pre>    $foo = first { defined($_) } @list    # first defined value in @list
    $foo = first { $_ &gt; $value } @list    # first value in @list which
                                          # is greater than $value
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="max"><a class="permalink" href="#max">max</a></h2>
<pre>    my $num = max @list;
</pre>
<p class="Pp">Returns the entry in the list with the highest numerical value. If
    the list is empty then <span class="Li">&quot;undef&quot;</span> is
    returned.</p>
<p class="Pp"></p>
<pre>    $foo = max 1..10                # 10
    $foo = max 3,9,12               # 12
    $foo = max @bar, @baz           # whatever
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="maxstr"><a class="permalink" href="#maxstr">maxstr</a></h2>
<pre>    my $str = maxstr @list;
</pre>
<p class="Pp">Similar to &quot;max&quot;, but treats all the entries in the list
    as strings and returns the highest string as defined by the
    <span class="Li">&quot;gt&quot;</span> operator. If the list is empty then
    <span class="Li">&quot;undef&quot;</span> is returned.</p>
<p class="Pp"></p>
<pre>    $foo = maxstr 'A'..'Z'          # 'Z'
    $foo = maxstr &quot;hello&quot;,&quot;world&quot;   # &quot;world&quot;
    $foo = maxstr @bar, @baz        # whatever
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="min"><a class="permalink" href="#min">min</a></h2>
<pre>    my $num = min @list;
</pre>
<p class="Pp">Similar to &quot;max&quot; but returns the entry in the list with
    the lowest numerical value. If the list is empty then
    <span class="Li">&quot;undef&quot;</span> is returned.</p>
<p class="Pp"></p>
<pre>    $foo = min 1..10                # 1
    $foo = min 3,9,12               # 3
    $foo = min @bar, @baz           # whatever
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="minstr"><a class="permalink" href="#minstr">minstr</a></h2>
<pre>    my $str = minstr @list;
</pre>
<p class="Pp">Similar to &quot;min&quot;, but treats all the entries in the list
    as strings and returns the lowest string as defined by the
    <span class="Li">&quot;lt&quot;</span> operator. If the list is empty then
    <span class="Li">&quot;undef&quot;</span> is returned.</p>
<p class="Pp"></p>
<pre>    $foo = minstr 'A'..'Z'          # 'A'
    $foo = minstr &quot;hello&quot;,&quot;world&quot;   # &quot;hello&quot;
    $foo = minstr @bar, @baz        # whatever
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="product"><a class="permalink" href="#product">product</a></h2>
<pre>    my $num = product @list;
</pre>
<p class="Pp"><i>Since version 1.35.</i></p>
<p class="Pp">Returns the numerical product of all the elements in
    <span class="Li">@list</span>. If <span class="Li">@list</span> is empty
    then <span class="Li">1</span> is returned.</p>
<p class="Pp"></p>
<pre>    $foo = product 1..10            # 3628800
    $foo = product 3,9,12           # 324
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="sum"><a class="permalink" href="#sum">sum</a></h2>
<pre>    my $num_or_undef = sum @list;
</pre>
<p class="Pp">Returns the numerical sum of all the elements in
    <span class="Li">@list</span>. For backwards compatibility, if
    <span class="Li">@list</span> is empty then
    <span class="Li">&quot;undef&quot;</span> is returned.</p>
<p class="Pp"></p>
<pre>    $foo = sum 1..10                # 55
    $foo = sum 3,9,12               # 24
    $foo = sum @bar, @baz           # whatever
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="sum0"><a class="permalink" href="#sum0">sum0</a></h2>
<pre>    my $num = sum0 @list;
</pre>
<p class="Pp"><i>Since version 1.26.</i></p>
<p class="Pp">Similar to &quot;sum&quot;, except this returns 0 when given an
    empty list, rather than <span class="Li">&quot;undef&quot;</span>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="KEY/VALUE_PAIR_LIST_FUNCTIONS"><a class="permalink" href="#KEY/VALUE_PAIR_LIST_FUNCTIONS">KEY/VALUE
  PAIR LIST FUNCTIONS</a></h1>
<p class="Pp">The following set of functions, all inspired by List::Pairwise,
    consume an even-sized list of pairs. The pairs may be key/value associations
    from a hash, or just a list of values. The functions will all preserve the
    original ordering of the pairs, and will not be confused by multiple pairs
    having the same &quot;key&quot; value - nor even do they require that the
    first of each pair be a plain string.</p>
<p class="Pp"><b>NOTE</b>: At the time of writing, the following
    <span class="Li">&quot;pair*&quot;</span> functions that take a block do not
    modify the value of <span class="Li">$_</span> within the block, and instead
    operate using the <span class="Li">$a</span> and <span class="Li">$b</span>
    globals instead. This has turned out to be a poor design, as it precludes
    the ability to provide a <span class="Li">&quot;pairsort&quot;</span>
    function. Better would be to pass pair-like objects as 2-element array
    references in <span class="Li">$_</span>, in a style similar to the return
    value of the <span class="Li">&quot;pairs&quot;</span> function. At some
    future version this behaviour may be added.</p>
<p class="Pp">Until then, users are alerted <b>NOT</b> to rely on the value of
    <span class="Li">$_</span> remaining unmodified between the outside and the
    inside of the control block. In particular, the following example is
    <b>UNSAFE</b>:</p>
<p class="Pp"></p>
<pre> my @kvlist = ...
 foreach (qw( some keys here )) {
    my @items = pairgrep { $a eq $_ } @kvlist;
    ...
 }
</pre>
<p class="Pp">Instead, write this using a lexical variable:</p>
<p class="Pp"></p>
<pre> foreach my $key (qw( some keys here )) {
    my @items = pairgrep { $a eq $key } @kvlist;
    ...
 }
</pre>
<section class="Ss">
<h2 class="Ss" id="pairs"><a class="permalink" href="#pairs">pairs</a></h2>
<pre>    my @pairs = pairs @kvlist;
</pre>
<p class="Pp"><i>Since version 1.29.</i></p>
<p class="Pp">A convenient shortcut to operating on even-sized lists of pairs,
    this function returns a list of <span class="Li">&quot;ARRAY&quot;</span>
    references, each containing two items from the given list. It is a more
    efficient version of</p>
<p class="Pp"></p>
<pre>    @pairs = pairmap { [ $a, $b ] } @kvlist
</pre>
<p class="Pp">It is most convenient to use in a
    <span class="Li">&quot;foreach&quot;</span> loop, for example:</p>
<p class="Pp"></p>
<pre>    foreach my $pair ( pairs @kvlist ) {
       my ( $key, $value ) = @$pair;
       ...
    }
</pre>
<p class="Pp">Since version <span class="Li">1.39</span> these
    <span class="Li">&quot;ARRAY&quot;</span> references are blessed objects,
    recognising the two methods <span class="Li">&quot;key&quot;</span> and
    <span class="Li">&quot;value&quot;</span>. The following code is
  equivalent:</p>
<p class="Pp"></p>
<pre>    foreach my $pair ( pairs @kvlist ) {
       my $key   = $pair-&gt;key;
       my $value = $pair-&gt;value;
       ...
    }
</pre>
<p class="Pp">Since version <span class="Li">1.51</span> they also have a
    <span class="Li">&quot;TO_JSON&quot;</span> method to ease
  serialisation.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="unpairs"><a class="permalink" href="#unpairs">unpairs</a></h2>
<pre>    my @kvlist = unpairs @pairs
</pre>
<p class="Pp"><i>Since version 1.42.</i></p>
<p class="Pp">The inverse function to <span class="Li">&quot;pairs&quot;</span>;
    this function takes a list of <span class="Li">&quot;ARRAY&quot;</span>
    references containing two elements each, and returns a flattened list of the
    two values from each of the pairs, in order. This is notionally equivalent
    to</p>
<p class="Pp"></p>
<pre>    my @kvlist = map { @{$_}[0,1] } @pairs
</pre>
<p class="Pp">except that it is implemented more efficiently internally.
    Specifically, for any input item it will extract exactly two values for the
    output list; using <span class="Li">&quot;undef&quot;</span> if the input
    array references are short.</p>
<p class="Pp">Between <span class="Li">&quot;pairs&quot;</span> and
    <span class="Li">&quot;unpairs&quot;</span>, a higher-order list function
    can be used to operate on the pairs as single scalars; such as the following
    near-equivalents of the other <span class="Li">&quot;pair*&quot;</span>
    higher-order functions:</p>
<p class="Pp"></p>
<pre>    @kvlist = unpairs grep { FUNC } pairs @kvlist
    # Like pairgrep, but takes $_ instead of $a and $b
    @kvlist = unpairs map { FUNC } pairs @kvlist
    # Like pairmap, but takes $_ instead of $a and $b
</pre>
<p class="Pp">Note however that these versions will not behave as nicely in
    scalar context.</p>
<p class="Pp">Finally, this technique can be used to implement a sort on a
    keyvalue pair list; e.g.:</p>
<p class="Pp"></p>
<pre>    @kvlist = unpairs sort { $a-&gt;key cmp $b-&gt;key } pairs @kvlist
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="pairkeys"><a class="permalink" href="#pairkeys">pairkeys</a></h2>
<pre>    my @keys = pairkeys @kvlist;
</pre>
<p class="Pp"><i>Since version 1.29.</i></p>
<p class="Pp">A convenient shortcut to operating on even-sized lists of pairs,
    this function returns a list of the the first values of each of the pairs in
    the given list. It is a more efficient version of</p>
<p class="Pp"></p>
<pre>    @keys = pairmap { $a } @kvlist
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="pairvalues"><a class="permalink" href="#pairvalues">pairvalues</a></h2>
<pre>    my @values = pairvalues @kvlist;
</pre>
<p class="Pp"><i>Since version 1.29.</i></p>
<p class="Pp">A convenient shortcut to operating on even-sized lists of pairs,
    this function returns a list of the the second values of each of the pairs
    in the given list. It is a more efficient version of</p>
<p class="Pp"></p>
<pre>    @values = pairmap { $b } @kvlist
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="pairgrep"><a class="permalink" href="#pairgrep">pairgrep</a></h2>
<pre>    my @kvlist = pairgrep { BLOCK } @kvlist;
    my $count = pairgrep { BLOCK } @kvlist;
</pre>
<p class="Pp"><i>Since version 1.29.</i></p>
<p class="Pp">Similar to perl's <span class="Li">&quot;grep&quot;</span>
    keyword, but interprets the given list as an even-sized list of pairs. It
    invokes the <span class="Li">&quot;BLOCK&quot;</span> multiple times, in
    scalar context, with <span class="Li">$a</span> and
    <span class="Li">$b</span> set to successive pairs of values from the
    <span class="Li">@kvlist</span>.</p>
<p class="Pp">Returns an even-sized list of those pairs for which the
    <span class="Li">&quot;BLOCK&quot;</span> returned true in list context, or
    the count of the <b>number of pairs</b> in scalar context. (Note, therefore,
    in scalar context that it returns a number half the size of the count of
    items it would have returned in list context).</p>
<p class="Pp"></p>
<pre>    @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
</pre>
<p class="Pp">As with <span class="Li">&quot;grep&quot;</span> aliasing
    <span class="Li">$_</span> to list elements,
    <span class="Li">&quot;pairgrep&quot;</span> aliases
    <span class="Li">$a</span> and <span class="Li">$b</span> to elements of the
    given list. Any modifications of it by the code block will be visible to the
    caller.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="pairfirst"><a class="permalink" href="#pairfirst">pairfirst</a></h2>
<pre>    my ( $key, $val ) = pairfirst { BLOCK } @kvlist;
    my $found = pairfirst { BLOCK } @kvlist;
</pre>
<p class="Pp"><i>Since version 1.30.</i></p>
<p class="Pp">Similar to the &quot;first&quot; function, but interprets the
    given list as an even-sized list of pairs. It invokes the
    <span class="Li">&quot;BLOCK&quot;</span> multiple times, in scalar context,
    with <span class="Li">$a</span> and <span class="Li">$b</span> set to
    successive pairs of values from the <span class="Li">@kvlist</span>.</p>
<p class="Pp">Returns the first pair of values from the list for which the
    <span class="Li">&quot;BLOCK&quot;</span> returned true in list context, or
    an empty list of no such pair was found. In scalar context it returns a
    simple boolean value, rather than either the key or the value found.</p>
<p class="Pp"></p>
<pre>    ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
</pre>
<p class="Pp">As with <span class="Li">&quot;grep&quot;</span> aliasing
    <span class="Li">$_</span> to list elements,
    <span class="Li">&quot;pairfirst&quot;</span> aliases
    <span class="Li">$a</span> and <span class="Li">$b</span> to elements of the
    given list. Any modifications of it by the code block will be visible to the
    caller.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="pairmap"><a class="permalink" href="#pairmap">pairmap</a></h2>
<pre>    my @list = pairmap { BLOCK } @kvlist;
    my $count = pairmap { BLOCK } @kvlist;
</pre>
<p class="Pp"><i>Since version 1.29.</i></p>
<p class="Pp">Similar to perl's <span class="Li">&quot;map&quot;</span> keyword,
    but interprets the given list as an even-sized list of pairs. It invokes the
    <span class="Li">&quot;BLOCK&quot;</span> multiple times, in list context,
    with <span class="Li">$a</span> and <span class="Li">$b</span> set to
    successive pairs of values from the <span class="Li">@kvlist</span>.</p>
<p class="Pp">Returns the concatenation of all the values returned by the
    <span class="Li">&quot;BLOCK&quot;</span> in list context, or the count of
    the number of items that would have been returned in scalar context.</p>
<p class="Pp"></p>
<pre>    @result = pairmap { &quot;The key $a has value $b&quot; } @kvlist
</pre>
<p class="Pp">As with <span class="Li">&quot;map&quot;</span> aliasing
    <span class="Li">$_</span> to list elements,
    <span class="Li">&quot;pairmap&quot;</span> aliases
    <span class="Li">$a</span> and <span class="Li">$b</span> to elements of the
    given list. Any modifications of it by the code block will be visible to the
    caller.</p>
<p class="Pp">See &quot;KNOWN BUGS&quot; for a known-bug with
    <span class="Li">&quot;pairmap&quot;</span>, and a workaround.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="OTHER_FUNCTIONS"><a class="permalink" href="#OTHER_FUNCTIONS">OTHER
  FUNCTIONS</a></h1>
<section class="Ss">
<h2 class="Ss" id="shuffle"><a class="permalink" href="#shuffle">shuffle</a></h2>
<pre>    my @values = shuffle @values;
</pre>
<p class="Pp">Returns the values of the input in a random order</p>
<p class="Pp"></p>
<pre>    @cards = shuffle 0..51      # 0..51 in a random order
</pre>
<p class="Pp">This function is affected by the <span class="Li">$RAND</span>
    variable.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="sample"><a class="permalink" href="#sample">sample</a></h2>
<pre>    my @items = sample $count, @values
</pre>
<p class="Pp"><i>Since version 1.54.</i></p>
<p class="Pp">Randomly select the given number of elements from the input list.
    Any given position in the input list will be selected at most once.</p>
<p class="Pp">If there are fewer than <span class="Li">$count</span> items in
    the list then the function will return once all of them have been randomly
    selected; effectively the function behaves similarly to
  &quot;shuffle&quot;.</p>
<p class="Pp">This function is affected by the <span class="Li">$RAND</span>
    variable.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="uniq"><a class="permalink" href="#uniq">uniq</a></h2>
<pre>    my @subset = uniq @values
</pre>
<p class="Pp"><i>Since version 1.45.</i></p>
<p class="Pp">Filters a list of values to remove subsequent duplicates, as
    judged by a DWIM-ish string equality or
    <span class="Li">&quot;undef&quot;</span> test. Preserves the order of
    unique elements, and retains the first value of any duplicate set.</p>
<p class="Pp"></p>
<pre>    my $count = uniq @values
</pre>
<p class="Pp">In scalar context, returns the number of elements that would have
    been returned as a list.</p>
<p class="Pp">The <span class="Li">&quot;undef&quot;</span> value is treated by
    this function as distinct from the empty string, and no warning will be
    produced. It is left as-is in the returned list. Subsequent
    <span class="Li">&quot;undef&quot;</span> values are still considered
    identical to the first, and will be removed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="uniqint"><a class="permalink" href="#uniqint">uniqint</a></h2>
<pre>    my @subset = uniqint @values
</pre>
<p class="Pp"><i>Since version 1.55.</i></p>
<p class="Pp">Filters a list of values to remove subsequent duplicates, as
    judged by an integer numerical equality test. Preserves the order of unique
    elements, and retains the first value of any duplicate set. Values in the
    returned list will be coerced into integers.</p>
<p class="Pp"></p>
<pre>    my $count = uniqint @values
</pre>
<p class="Pp">In scalar context, returns the number of elements that would have
    been returned as a list.</p>
<p class="Pp">Note that <span class="Li">&quot;undef&quot;</span> is treated
    much as other numerical operations treat it; it compares equal to zero but
    additionally produces a warning if such warnings are enabled
    (<span class="Li">&quot;use warnings 'uninitialized';&quot;</span>). In
    addition, an <span class="Li">&quot;undef&quot;</span> in the returned list
    is coerced into a numerical zero, so that the entire list of values returned
    by <span class="Li">&quot;uniqint&quot;</span> are well-behaved as
  integers.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="uniqnum"><a class="permalink" href="#uniqnum">uniqnum</a></h2>
<pre>    my @subset = uniqnum @values
</pre>
<p class="Pp"><i>Since version 1.44.</i></p>
<p class="Pp">Filters a list of values to remove subsequent duplicates, as
    judged by a numerical equality test. Preserves the order of unique elements,
    and retains the first value of any duplicate set.</p>
<p class="Pp"></p>
<pre>    my $count = uniqnum @values
</pre>
<p class="Pp">In scalar context, returns the number of elements that would have
    been returned as a list.</p>
<p class="Pp">Note that <span class="Li">&quot;undef&quot;</span> is treated
    much as other numerical operations treat it; it compares equal to zero but
    additionally produces a warning if such warnings are enabled
    (<span class="Li">&quot;use warnings 'uninitialized';&quot;</span>). In
    addition, an <span class="Li">&quot;undef&quot;</span> in the returned list
    is coerced into a numerical zero, so that the entire list of values returned
    by <span class="Li">&quot;uniqnum&quot;</span> are well-behaved as
  numbers.</p>
<p class="Pp">Note also that multiple IEEE
    <span class="Li">&quot;NaN&quot;</span> values are treated as duplicates of
    each other, regardless of any differences in their payloads, and despite the
    fact that <span class="Li">&quot;0+'NaN' == 0+'NaN'&quot;</span> yields
    false.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="uniqstr"><a class="permalink" href="#uniqstr">uniqstr</a></h2>
<pre>    my @subset = uniqstr @values
</pre>
<p class="Pp"><i>Since version 1.45.</i></p>
<p class="Pp">Filters a list of values to remove subsequent duplicates, as
    judged by a string equality test. Preserves the order of unique elements,
    and retains the first value of any duplicate set.</p>
<p class="Pp"></p>
<pre>    my $count = uniqstr @values
</pre>
<p class="Pp">In scalar context, returns the number of elements that would have
    been returned as a list.</p>
<p class="Pp">Note that <span class="Li">&quot;undef&quot;</span> is treated
    much as other string operations treat it; it compares equal to the empty
    string but additionally produces a warning if such warnings are enabled
    (<span class="Li">&quot;use warnings 'uninitialized';&quot;</span>). In
    addition, an <span class="Li">&quot;undef&quot;</span> in the returned list
    is coerced into an empty string, so that the entire list of values returned
    by <span class="Li">&quot;uniqstr&quot;</span> are well-behaved as
  strings.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="head"><a class="permalink" href="#head">head</a></h2>
<pre>    my @values = head $size, @list;
</pre>
<p class="Pp"><i>Since version 1.50.</i></p>
<p class="Pp">Returns the first <span class="Li">$size</span> elements from
    <span class="Li">@list</span>. If <span class="Li">$size</span> is negative,
    returns all but the last <span class="Li">$size</span> elements from
    <span class="Li">@list</span>.</p>
<p class="Pp"></p>
<pre>    @result = head 2, qw( foo bar baz );
    # foo, bar
    @result = head -2, qw( foo bar baz );
    # foo
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="tail"><a class="permalink" href="#tail">tail</a></h2>
<pre>    my @values = tail $size, @list;
</pre>
<p class="Pp"><i>Since version 1.50.</i></p>
<p class="Pp">Returns the last <span class="Li">$size</span> elements from
    <span class="Li">@list</span>. If <span class="Li">$size</span> is negative,
    returns all but the first <span class="Li">$size</span> elements from
    <span class="Li">@list</span>.</p>
<p class="Pp"></p>
<pre>    @result = tail 2, qw( foo bar baz );
    # bar, baz
    @result = tail -2, qw( foo bar baz );
    # baz
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CONFIGURATION_VARIABLES"><a class="permalink" href="#CONFIGURATION_VARIABLES">CONFIGURATION
  VARIABLES</a></h1>
<section class="Ss">
<h2 class="Ss" id="$RAND"><a class="permalink" href="#$RAND">$RAND</a></h2>
<pre>    local $List::Util::RAND = sub { ... };
</pre>
<p class="Pp"><i>Since version 1.54.</i></p>
<p class="Pp">This package variable is used by code which needs to generate
    random numbers (such as the &quot;shuffle&quot; and &quot;sample&quot;
    functions). If set to a CODE reference it provides an alternative to perl's
    builtin <span class="Li">&quot;rand()&quot;</span> function. When a new
    random number is needed this function will be invoked with no arguments and
    is expected to return a floating-point value, of which only the fractional
    part will be used.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="KNOWN_BUGS"><a class="permalink" href="#KNOWN_BUGS">KNOWN
  BUGS</a></h1>
<section class="Ss">
<h2 class="Ss">RT #95409</h2>
<p class="Pp">&lt;https://rt.cpan.org/Ticket/Display.html?id=95409&gt;</p>
<p class="Pp">If the block of code given to &quot;pairmap&quot; contains lexical
    variables that are captured by a returned closure, and the closure is
    executed after the block has been re-used for the next iteration, these
    lexicals will not see the correct values. For example:</p>
<p class="Pp"></p>
<pre> my @subs = pairmap {
    my $var = &quot;$a is $b&quot;;
    sub { print &quot;$var\n&quot; };
 } one =&gt; 1, two =&gt; 2, three =&gt; 3;
 $_-&gt;() for @subs;
</pre>
<p class="Pp">Will incorrectly print</p>
<p class="Pp"></p>
<pre> three is 3
 three is 3
 three is 3
</pre>
<p class="Pp">This is due to the performance optimisation of using
    <span class="Li">&quot;MULTICALL&quot;</span> for the code block, which
    means that fresh SVs do not get allocated for each call to the block.
    Instead, the same SV is re-assigned for each iteration, and all the closures
    will share the value seen on the final iteration.</p>
<p class="Pp">To work around this bug, surround the code with a second set of
    braces. This creates an inner block that defeats the
    <span class="Li">&quot;MULTICALL&quot;</span> logic, and does get fresh SVs
    allocated each time:</p>
<p class="Pp"></p>
<pre> my @subs = pairmap {
    {
       my $var = &quot;$a is $b&quot;;
       sub { print &quot;$var\n&quot;; }
    }
 } one =&gt; 1, two =&gt; 2, three =&gt; 3;
</pre>
<p class="Pp">This bug only affects closures that are generated by the block but
    used afterwards. Lexical variables that are only used during the lifetime of
    the block's execution will take their individual values for each invocation,
    as normal.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>uniqnum()</b> on oversized bignums</h2>
<p class="Pp">Due to the way that <span class="Li">&quot;uniqnum()&quot;</span>
    compares numbers, it cannot distinguish differences between bignums
    (especially bigints) that are too large to fit in the native platform types.
    For example,</p>
<p class="Pp"></p>
<pre> my $x = Math::BigInt-&gt;new( &quot;1&quot; x 100 );
 my $y = $x + 1;
 say for uniqnum( $x, $y );
</pre>
<p class="Pp">Will print just the value of <span class="Li">$x</span>, believing
    that <span class="Li">$y</span> is a numerically- equivalent value. This bug
    does not affect <span class="Li">&quot;uniqstr()&quot;</span>, which will
    correctly observe that the two values stringify to different strings.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SUGGESTED_ADDITIONS"><a class="permalink" href="#SUGGESTED_ADDITIONS">SUGGESTED
  ADDITIONS</a></h1>
<p class="Pp">The following are additions that have been requested, but I have
    been reluctant to add due to them being very simple to implement in perl</p>
<p class="Pp"></p>
<pre>  # How many elements are true
  sub true { scalar grep { $_ } @_ }
  # How many elements are false
  sub false { scalar grep { !$_ } @_ }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Scalar::Util, List::MoreUtils</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 1997-2007 Graham Barr &lt;gbarr@pobox.com&gt;. All
    rights reserved. This program is free software; you can redistribute it
    and/or modify it under the same terms as Perl itself.</p>
<p class="Pp">Recent additions and current maintenance by Paul Evans,
    &lt;leonerd@leonerd.org.uk&gt;.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os"><a href="..">perl v5.34.1</a></td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>ExtUtils::Typemaps(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">ExtUtils::Typemaps(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">ExtUtils::Typemaps(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">ExtUtils::Typemaps - Read/Write/Modify Perl/XS typemap files</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  # read/create file
  my $typemap = ExtUtils::Typemaps-&gt;new(file =&gt; 'typemap');
  # alternatively create an in-memory typemap
  # $typemap = ExtUtils::Typemaps-&gt;new();
  # alternatively create an in-memory typemap by parsing a string
  # $typemap = ExtUtils::Typemaps-&gt;new(string =&gt; $sometypemap);
  # add a mapping
  $typemap-&gt;add_typemap(ctype =&gt; 'NV', xstype =&gt; 'T_NV');
  $typemap-&gt;add_inputmap(
     xstype =&gt; 'T_NV', code =&gt; '$var = ($type)SvNV($arg);'
  );
  $typemap-&gt;add_outputmap(
     xstype =&gt; 'T_NV', code =&gt; 'sv_setnv($arg, (NV)$var);'
  );
  $typemap-&gt;add_string(string =&gt; $typemapstring);
                                           # will be parsed and merged
  # remove a mapping (same for remove_typemap and remove_outputmap...)
  $typemap-&gt;remove_inputmap(xstype =&gt; 'SomeType');
  # save a typemap to a file
  $typemap-&gt;write(file =&gt; 'anotherfile.map');
  # merge the other typemap into this one
  $typemap-&gt;merge(typemap =&gt; $another_typemap);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module can read, modify, create and write Perl XS typemap
    files. If you don't know what a typemap is, please confer the perlxstut and
    perlxs manuals.</p>
<p class="Pp">The module is not entirely round-trip safe: For example it
    currently simply strips all comments. The order of entries in the maps is,
    however, preserved.</p>
<p class="Pp">We check for duplicate entries in the typemap, but do not check
    for missing <span class="Li">&quot;TYPEMAP&quot;</span> entries for
    <span class="Li">&quot;INPUTMAP&quot;</span> or
    <span class="Li">&quot;OUTPUTMAP&quot;</span> entries since these might be
    hidden in a different typemap.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
<p class="Pp">Returns a new typemap object. Takes an optional
    <span class="Li">&quot;file&quot;</span> parameter. If set, the given file
    will be read. If the file doesn't exist, an empty typemap is returned.</p>
<p class="Pp">Alternatively, if the <span class="Li">&quot;string&quot;</span>
    parameter is given, the supplied string will be parsed instead of a
  file.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="file"><a class="permalink" href="#file">file</a></h2>
<p class="Pp">Get/set the file that the typemap is written to when the
    <span class="Li">&quot;write&quot;</span> method is called.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="add_typemap"><a class="permalink" href="#add_typemap">add_typemap</a></h2>
<p class="Pp">Add a <span class="Li">&quot;TYPEMAP&quot;</span> entry to the
    typemap.</p>
<p class="Pp">Required named arguments: The
    <span class="Li">&quot;ctype&quot;</span> (e.g. <span class="Li">&quot;ctype
    =&gt; 'double'&quot;</span>) and the
    <span class="Li">&quot;xstype&quot;</span> (e.g.
    <span class="Li">&quot;xstype =&gt; 'T_NV'&quot;</span>).</p>
<p class="Pp">Optional named arguments: <span class="Li">&quot;replace =&gt;
    1&quot;</span> forces removal/replacement of existing
    <span class="Li">&quot;TYPEMAP&quot;</span> entries of the same
    <span class="Li">&quot;ctype&quot;</span>. <span class="Li">&quot;skip =&gt;
    1&quot;</span> triggers a <i>&quot;first come first serve&quot;</i> logic by
    which new entries that conflict with existing entries are silently
  ignored.</p>
<p class="Pp">As an alternative to the named parameters usage, you may pass in
    an <span class="Li">&quot;ExtUtils::Typemaps::Type&quot;</span> object as
    first argument, a copy of which will be added to the typemap. In that case,
    only the <span class="Li">&quot;replace&quot;</span> or
    <span class="Li">&quot;skip&quot;</span> named parameters may be used after
    the object. Example:</p>
<p class="Pp"></p>
<pre>  $map-&gt;add_typemap($type_obj, replace =&gt; 1);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="add_inputmap"><a class="permalink" href="#add_inputmap">add_inputmap</a></h2>
<p class="Pp">Add an <span class="Li">&quot;INPUT&quot;</span> entry to the
    typemap.</p>
<p class="Pp">Required named arguments: The
    <span class="Li">&quot;xstype&quot;</span> (e.g.
    <span class="Li">&quot;xstype =&gt; 'T_NV'&quot;</span>) and the
    <span class="Li">&quot;code&quot;</span> to associate with it for input.</p>
<p class="Pp">Optional named arguments: <span class="Li">&quot;replace =&gt;
    1&quot;</span> forces removal/replacement of existing
    <span class="Li">&quot;INPUT&quot;</span> entries of the same
    <span class="Li">&quot;xstype&quot;</span>. <span class="Li">&quot;skip
    =&gt; 1&quot;</span> triggers a <i>&quot;first come first serve&quot;</i>
    logic by which new entries that conflict with existing entries are silently
    ignored.</p>
<p class="Pp">As an alternative to the named parameters usage, you may pass in
    an <span class="Li">&quot;ExtUtils::Typemaps::InputMap&quot;</span> object
    as first argument, a copy of which will be added to the typemap. In that
    case, only the <span class="Li">&quot;replace&quot;</span> or
    <span class="Li">&quot;skip&quot;</span> named parameters may be used after
    the object. Example:</p>
<p class="Pp"></p>
<pre>  $map-&gt;add_inputmap($type_obj, replace =&gt; 1);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="add_outputmap"><a class="permalink" href="#add_outputmap">add_outputmap</a></h2>
<p class="Pp">Add an <span class="Li">&quot;OUTPUT&quot;</span> entry to the
    typemap. Works exactly the same as
    <span class="Li">&quot;add_inputmap&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="add_string"><a class="permalink" href="#add_string">add_string</a></h2>
<p class="Pp">Parses a string as a typemap and merge it into the typemap
  object.</p>
<p class="Pp">Required named argument:
    <span class="Li">&quot;string&quot;</span> to specify the string to
  parse.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="remove_typemap"><a class="permalink" href="#remove_typemap">remove_typemap</a></h2>
<p class="Pp">Removes a <span class="Li">&quot;TYPEMAP&quot;</span> entry from
    the typemap.</p>
<p class="Pp">Required named argument: <span class="Li">&quot;ctype&quot;</span>
    to specify the entry to remove from the typemap.</p>
<p class="Pp">Alternatively, you may pass a single
    <span class="Li">&quot;ExtUtils::Typemaps::Type&quot;</span> object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="remove_inputmap"><a class="permalink" href="#remove_inputmap">remove_inputmap</a></h2>
<p class="Pp">Removes an <span class="Li">&quot;INPUT&quot;</span> entry from
    the typemap.</p>
<p class="Pp">Required named argument:
    <span class="Li">&quot;xstype&quot;</span> to specify the entry to remove
    from the typemap.</p>
<p class="Pp">Alternatively, you may pass a single
    <span class="Li">&quot;ExtUtils::Typemaps::InputMap&quot;</span> object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="remove_inputmap~2"><a class="permalink" href="#remove_inputmap~2">remove_inputmap</a></h2>
<p class="Pp">Removes an <span class="Li">&quot;OUTPUT&quot;</span> entry from
    the typemap.</p>
<p class="Pp">Required named argument:
    <span class="Li">&quot;xstype&quot;</span> to specify the entry to remove
    from the typemap.</p>
<p class="Pp">Alternatively, you may pass a single
    <span class="Li">&quot;ExtUtils::Typemaps::OutputMap&quot;</span>
  object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="get_typemap"><a class="permalink" href="#get_typemap">get_typemap</a></h2>
<p class="Pp">Fetches an entry of the TYPEMAP section of the typemap.</p>
<p class="Pp">Mandatory named arguments: The
    <span class="Li">&quot;ctype&quot;</span> of the entry.</p>
<p class="Pp">Returns the
    <span class="Li">&quot;ExtUtils::Typemaps::Type&quot;</span> object for the
    entry if found.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="get_inputmap"><a class="permalink" href="#get_inputmap">get_inputmap</a></h2>
<p class="Pp">Fetches an entry of the INPUT section of the typemap.</p>
<p class="Pp">Mandatory named arguments: The
    <span class="Li">&quot;xstype&quot;</span> of the entry or the
    <span class="Li">&quot;ctype&quot;</span> of the typemap that can be used to
    find the <span class="Li">&quot;xstype&quot;</span>. To wit, the following
    pieces of code are equivalent:</p>
<p class="Pp"></p>
<pre>  my $type = $typemap-&gt;get_typemap(ctype =&gt; $ctype)
  my $input_map = $typemap-&gt;get_inputmap(xstype =&gt; $type-&gt;xstype);
  my $input_map = $typemap-&gt;get_inputmap(ctype =&gt; $ctype);
</pre>
<p class="Pp">Returns the
    <span class="Li">&quot;ExtUtils::Typemaps::InputMap&quot;</span> object for
    the entry if found.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="get_outputmap"><a class="permalink" href="#get_outputmap">get_outputmap</a></h2>
<p class="Pp">Fetches an entry of the OUTPUT section of the typemap.</p>
<p class="Pp">Mandatory named arguments: The
    <span class="Li">&quot;xstype&quot;</span> of the entry or the
    <span class="Li">&quot;ctype&quot;</span> of the typemap that can be used to
    resolve the <span class="Li">&quot;xstype&quot;</span>. (See above for an
    example.)</p>
<p class="Pp">Returns the
    <span class="Li">&quot;ExtUtils::Typemaps::InputMap&quot;</span> object for
    the entry if found.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="write"><a class="permalink" href="#write">write</a></h2>
<p class="Pp">Write the typemap to a file. Optionally takes a
    <span class="Li">&quot;file&quot;</span> argument. If given, the typemap
    will be written to the specified file. If not, the typemap is written to the
    currently stored file name (see &quot;file&quot; above, this defaults to the
    file it was read from if any).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="as_string"><a class="permalink" href="#as_string">as_string</a></h2>
<p class="Pp">Generates and returns the string form of the typemap.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="as_embedded_typemap"><a class="permalink" href="#as_embedded_typemap">as_embedded_typemap</a></h2>
<p class="Pp">Generates and returns the string form of the typemap with the
    appropriate prefix around it for verbatim inclusion into an XS file as an
    embedded typemap. This will return a string like</p>
<p class="Pp"></p>
<pre>  TYPEMAP: &lt;&lt;END_OF_TYPEMAP
  ... typemap here (see as_string) ...
  END_OF_TYPEMAP
</pre>
<p class="Pp">The method takes care not to use a HERE-doc end marker that
    appears in the typemap string itself.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="merge"><a class="permalink" href="#merge">merge</a></h2>
<p class="Pp">Merges a given typemap into the object. Note that a failed merge
    operation leaves the object in an inconsistent state so clone it if
    necessary.</p>
<p class="Pp">Mandatory named arguments: Either <span class="Li">&quot;typemap
    =&gt; $another_typemap_obj&quot;</span> or <span class="Li">&quot;file =&gt;
    $path_to_typemap_file&quot;</span> but not both.</p>
<p class="Pp">Optional arguments: <span class="Li">&quot;replace =&gt;
    1&quot;</span> to force replacement of existing typemap entries without
    warning or <span class="Li">&quot;skip =&gt; 1&quot;</span> to skip entries
    that exist already in the typemap.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="is_empty"><a class="permalink" href="#is_empty">is_empty</a></h2>
<p class="Pp">Returns a bool indicating whether this typemap is entirely
  empty.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="list_mapped_ctypes"><a class="permalink" href="#list_mapped_ctypes">list_mapped_ctypes</a></h2>
<p class="Pp">Returns a list of the C types that are mappable by this typemap
    object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_get_typemap_hash"><a class="permalink" href="#_get_typemap_hash">_get_typemap_hash</a></h2>
<p class="Pp">Returns a hash mapping the C types to the XS types:</p>
<p class="Pp"></p>
<pre>  {
    'char **' =&gt; 'T_PACKEDARRAY',
    'bool_t' =&gt; 'T_IV',
    'AV *' =&gt; 'T_AVREF',
    'InputStream' =&gt; 'T_IN',
    'double' =&gt; 'T_DOUBLE',
    # ...
  }
</pre>
<p class="Pp">This is documented because it is used by
    <span class="Li">&quot;ExtUtils::ParseXS&quot;</span>, but it's not intended
    for general consumption. May be removed at any time.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_get_inputmap_hash"><a class="permalink" href="#_get_inputmap_hash">_get_inputmap_hash</a></h2>
<p class="Pp">Returns a hash mapping the XS types (identifiers) to the
    corresponding INPUT code:</p>
<p class="Pp"></p>
<pre>  {
    'T_CALLBACK' =&gt; '   $var = make_perl_cb_$type($arg)
  ',
    'T_OUT' =&gt; '    $var = IoOFP(sv_2io($arg))
  ',
    'T_REF_IV_PTR' =&gt; '   if (sv_isa($arg, \\&quot;${ntype}\\&quot;)) {
    # ...
  }
</pre>
<p class="Pp">This is documented because it is used by
    <span class="Li">&quot;ExtUtils::ParseXS&quot;</span>, but it's not intended
    for general consumption. May be removed at any time.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_get_outputmap_hash"><a class="permalink" href="#_get_outputmap_hash">_get_outputmap_hash</a></h2>
<p class="Pp">Returns a hash mapping the XS types (identifiers) to the
    corresponding OUTPUT code:</p>
<p class="Pp"></p>
<pre>  {
    'T_CALLBACK' =&gt; '   sv_setpvn($arg, $var.context.value().chp(),
                $var.context.value().size());
  ',
    'T_OUT' =&gt; '    {
            GV *gv = (GV *)sv_newmortal();
            gv_init_pvn(gv, gv_stashpvs(&quot;$Package&quot;,1),
                       &quot;__ANONIO__&quot;,10,0);
            if ( do_open(gv, &quot;+&gt;&amp;&quot;, 3, FALSE, 0, 0, $var) )
                sv_setsv(
                  $arg,
                  sv_bless(newRV((SV*)gv), gv_stashpv(&quot;$Package&quot;,1))
                );
            else
                $arg = &amp;PL_sv_undef;
         }
  ',
    # ...
  }
</pre>
<p class="Pp">This is documented because it is used by
    <span class="Li">&quot;ExtUtils::ParseXS&quot;</span>, but it's not intended
    for general consumption. May be removed at any time.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_get_prototype_hash"><a class="permalink" href="#_get_prototype_hash">_get_prototype_hash</a></h2>
<p class="Pp">Returns a hash mapping the C types of the typemap to their
    corresponding prototypes.</p>
<p class="Pp"></p>
<pre>  {
    'char **' =&gt; '$',
    'bool_t' =&gt; '$',
    'AV *' =&gt; '$',
    'InputStream' =&gt; '$',
    'double' =&gt; '$',
    # ...
  }
</pre>
<p class="Pp">This is documented because it is used by
    <span class="Li">&quot;ExtUtils::ParseXS&quot;</span>, but it's not intended
    for general consumption. May be removed at any time.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="clone"><a class="permalink" href="#clone">clone</a></h2>
<p class="Pp">Creates and returns a clone of a full typemaps object.</p>
<p class="Pp">Takes named parameters: If
    <span class="Li">&quot;shallow&quot;</span> is true, the clone will share
    the actual individual type/input/outputmap objects, but not share their
    storage. Use with caution. Without
    <span class="Li">&quot;shallow&quot;</span>, the clone will be fully
    independent.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="tidy_type"><a class="permalink" href="#tidy_type">tidy_type</a></h2>
<p class="Pp">Function to (heuristically) canonicalize a C type. Works to some
    degree with C++ types.</p>
<p class="Pp"></p>
<pre>    $halfway_canonical_type = tidy_type($ctype);
</pre>
<p class="Pp">Moved from
  <span class="Li">&quot;ExtUtils::ParseXS&quot;</span>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<p class="Pp">Inherits some evil code from
    <span class="Li">&quot;ExtUtils::ParseXS&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">The parser is heavily inspired from the one in
  ExtUtils::ParseXS.</p>
<p class="Pp">For details on typemaps: perlxstut, perlxs.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Steffen Mueller
    <span class="Li">&quot;&lt;smueller@cpan.org&quot;</span>&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_&amp;_LICENSE"><a class="permalink" href="#COPYRIGHT_&amp;_LICENSE">COPYRIGHT
  &amp; LICENSE</a></h1>
<p class="Pp">Copyright 2009, 2010, 2011, 2012, 2013 Steffen Mueller</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2021-05-04</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

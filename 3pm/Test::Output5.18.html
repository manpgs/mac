<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Test::Output(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Test::Output(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Test::Output(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Test::Output - Utilities to test STDOUT and STDERR messages.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">Version 0.16</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
    use Test::More tests =&gt; 4;
    use Test::Output;

    sub writer {
      print &quot;Write out.\n&quot;;
      print STDERR &quot;Error out.\n&quot;;
    }

    stdout_is(\&amp;writer,&quot;Write out.\n&quot;,'Test STDOUT');

    stderr_isnt(\&amp;writer,&quot;No error out.\n&quot;,'Test STDERR');

    combined_is(
                \&amp;writer,
                &quot;Write out.\nError out.\n&quot;,
                'Test STDOUT &amp; STDERR combined'
               );

    output_is(
              \&amp;writer,
              &quot;Write out.\n&quot;,
              &quot;Error out.\n&quot;,
              'Test STDOUT &amp; STDERR'
            );

   # Use bare blocks.

   stdout_is { print &quot;test&quot; } &quot;test&quot;, &quot;Test STDOUT&quot;;
   stderr_isnt { print &quot;bad test&quot; } &quot;test&quot;, &quot;Test STDERR&quot;;
   output_is { print 'STDOUT'; print STDERR 'STDERR' }
     &quot;STDOUT&quot;, &quot;STDERR&quot;, &quot;Test output&quot;;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Test::Output provides a simple interface for testing output sent
    to STDOUT or STDERR. A number of different utilities are included to try and
    be as flexible as possible to the tester.</p>
<p class="Pp">Originally this module was designed not to have external
    requirements, however, the features provided by Sub::Exporter over what
    Exporter provides is just to great to pass up.</p>
<p class="Pp">Likewise, Capture::Tiny provides a much more robust capture
    mechanism without than the original Test::Output::Tie.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="TESTS"><a class="permalink" href="#TESTS">TESTS</a></h1>
<section class="Ss">
<h2 class="Ss">STDOUT</h2>
<dl class="Bl-tag">
  <dt id="stdout_is"><a class="permalink" href="#stdout_is"><b>stdout_is</b></a></dt>
  <dd></dd>
  <dt id="stdout_isnt"><a class="permalink" href="#stdout_isnt"><b>stdout_isnt</b></a></dt>
  <dd>
    <pre>
   stdout_is  ( $coderef, $expected, 'description' );
   stdout_is    { ... } $expected, 'description';
   stdout_isnt( $coderef, $expected, 'description' );
   stdout_isnt  { ... } $expected, 'description';
    </pre>
    <p class="Pp"><i>stdout_is()</i> captures output sent to STDOUT from
        <span class="Li">$coderef</span> and compares it against
        <span class="Li">$expected</span>. The test passes if equal.</p>
    <p class="Pp"><i>stdout_isnt()</i> passes if STDOUT is not equal to
        <span class="Li">$expected</span>.</p>
  </dd>
  <dt id="stdout_like"><a class="permalink" href="#stdout_like"><b>stdout_like</b></a></dt>
  <dd></dd>
  <dt id="stdout_unlike"><a class="permalink" href="#stdout_unlike"><b>stdout_unlike</b></a></dt>
  <dd>
    <pre>
   stdout_like  ( $coderef, qr/$expected/, 'description' );
   stdout_like    { ... } qr/$expected/, 'description';
   stdout_unlike( $coderef, qr/$expected/, 'description' );
   stdout_unlike  { ... } qr/$expected/, 'description';
    </pre>
    <p class="Pp"><i>stdout_like()</i> captures the output sent to STDOUT from
        <span class="Li">$coderef</span> and compares it to the regex in
        <span class="Li">$expected</span>. The test passes if the regex
      matches.</p>
    <p class="Pp"><i>stdout_unlike()</i> passes if STDOUT does not match the
        regex.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">STDERR</h2>
<dl class="Bl-tag">
  <dt id="stderr_is"><a class="permalink" href="#stderr_is"><b>stderr_is</b></a></dt>
  <dd></dd>
  <dt id="stderr_isnt"><a class="permalink" href="#stderr_isnt"><b>stderr_isnt</b></a></dt>
  <dd>
    <pre>
   stderr_is  ( $coderef, $expected, 'description' );
   stderr_is    {... } $expected, 'description';

   stderr_isnt( $coderef, $expected, 'description' );
   stderr_isnt  {... } $expected, 'description';
    </pre>
    <p class="Pp"><i>stderr_is()</i> is similar to stdout_is, except that it
        captures STDERR. The test passes if STDERR from
        <span class="Li">$coderef</span> equals
        <span class="Li">$expected</span>.</p>
    <p class="Pp"><i>stderr_isnt()</i> passes if STDERR is not equal to
        <span class="Li">$expected</span>.</p>
  </dd>
  <dt id="stderr_like"><a class="permalink" href="#stderr_like"><b>stderr_like</b></a></dt>
  <dd></dd>
  <dt id="stderr_unlike"><a class="permalink" href="#stderr_unlike"><b>stderr_unlike</b></a></dt>
  <dd>
    <pre>
   stderr_like  ( $coderef, qr/$expected/, 'description' );
   stderr_like   { ...} qr/$expected/, 'description';
   stderr_unlike( $coderef, qr/$expected/, 'description' );
   stderr_unlike  { ...} qr/$expected/, 'description';
    </pre>
    <p class="Pp"><i>stderr_like()</i> is similar to <i>stdout_like()</i> except
        that it compares the regex <span class="Li">$expected</span> to STDERR
        captured from <span class="Li">$codref</span>. The test passes if the
        regex matches.</p>
    <p class="Pp"><i>stderr_unlike()</i> passes if STDERR does not match the
        regex.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">COMBINED OUTPUT</h2>
<dl class="Bl-tag">
  <dt id="combined_is"><a class="permalink" href="#combined_is"><b>combined_is</b></a></dt>
  <dd></dd>
  <dt id="combined_isnt"><a class="permalink" href="#combined_isnt"><b>combined_isnt</b></a></dt>
  <dd>
    <pre>
   combined_is   ( $coderef, $expected, 'description' );
   combined_is   {... } $expected, 'description';
   combined_isnt ( $coderef, $expected, 'description' );
   combined_isnt {... } $expected, 'description';
    </pre>
    <p class="Pp"><i>combined_is()</i> directs STDERR to STDOUT then captures
        STDOUT. This is equivalent to UNIXs 2&gt;&amp;1. The test passes if the
        combined STDOUT and STDERR from <span class="Li">$coderef</span> equals
        <span class="Li">$expected</span>.</p>
    <p class="Pp"><i>combined_isnt()</i> passes if combined STDOUT and STDERR
        are not equal to <span class="Li">$expected</span>.</p>
  </dd>
  <dt id="combined_like"><a class="permalink" href="#combined_like"><b>combined_like</b></a></dt>
  <dd></dd>
  <dt id="combined_unlike"><a class="permalink" href="#combined_unlike"><b>combined_unlike</b></a></dt>
  <dd>
    <pre>
   combined_like   ( $coderef, qr/$expected/, 'description' );
   combined_like   { ...} qr/$expected/, 'description';
   combined_unlike ( $coderef, qr/$expected/, 'description' );
   combined_unlike { ...} qr/$expected/, 'description';
    </pre>
    <p class="Pp"><i>combined_like()</i> is similar to <i>combined_is()</i>
        except that it compares a regex ($expected) to STDOUT and STDERR
        captured from <span class="Li">$codref</span>. The test passes if the
        regex matches.</p>
    <p class="Pp"><i>combined_unlike()</i> passes if the combined STDOUT and
        STDERR does not match the regex.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">OUTPUT</h2>
<dl class="Bl-tag">
  <dt id="output_is"><a class="permalink" href="#output_is"><b>output_is</b></a></dt>
  <dd></dd>
  <dt id="output_isnt"><a class="permalink" href="#output_isnt"><b>output_isnt</b></a></dt>
  <dd>
    <pre>
   output_is  ( $coderef, $expected_stdout, $expected_stderr, 'description' );
   output_is    {... } $expected_stdout, $expected_stderr, 'description';
   output_isnt( $coderef, $expected_stdout, $expected_stderr, 'description' );
   output_isnt  {... } $expected_stdout, $expected_stderr, 'description';
    </pre>
    <p class="Pp">The <i>output_is()</i> function is a combination of the
        <i>stdout_is()</i> and <i>stderr_is()</i> functions. For example:</p>
    <p class="Pp"></p>
    <pre>
  output_is(sub {print &quot;foo&quot;; print STDERR &quot;bar&quot;;},'foo','bar');
    </pre>
    <p class="Pp">is functionally equivalent to</p>
    <p class="Pp"></p>
    <pre>
  stdout_is(sub {print &quot;foo&quot;;},'foo') 
    &amp;&amp; stderr_is(sub {print STDERR &quot;bar&quot;;'bar');
    </pre>
    <p class="Pp">except that <span class="Li">$coderef</span> is only executed
        once.</p>
    <p class="Pp">Unlike, <i>stdout_is()</i> and <i>stderr_is()</i> which ignore
        STDERR and STDOUT respectively, <i>output_is()</i> requires both STDOUT
        and STDERR to match in order to pass. Setting either
        <span class="Li">$expected_stdout</span> or
        <span class="Li">$expected_stderr</span> to
        <span class="Li">&quot;undef&quot;</span> ignores STDOUT or STDERR
        respectively.</p>
    <p class="Pp"></p>
    <pre>
  output_is(sub {print &quot;foo&quot;; print STDERR &quot;bar&quot;;},'foo',undef);
    </pre>
    <p class="Pp">is the same as</p>
    <p class="Pp"></p>
    <pre>
  stdout_is(sub {print &quot;foo&quot;;},'foo')
    </pre>
    <p class="Pp"><i>output_isnt()</i> provides the opposite function of
        <i>output_is()</i>. It is a combination of <i>stdout_isnt()</i> and
        <i>stderr_isnt()</i>.</p>
    <p class="Pp"></p>
    <pre>
  output_isnt(sub {print &quot;foo&quot;; print STDERR &quot;bar&quot;;},'bar','foo');
    </pre>
    <p class="Pp">is functionally equivalent to</p>
    <p class="Pp"></p>
    <pre>
  stdout_is(sub {print &quot;foo&quot;;},'bar') 
    &amp;&amp; stderr_is(sub {print STDERR &quot;bar&quot;;'foo');
    </pre>
    <p class="Pp">As with <i>output_is()</i>, setting either
        <span class="Li">$expected_stdout</span> or
        <span class="Li">$expected_stderr</span> to
        <span class="Li">&quot;undef&quot;</span> ignores the output to that
        facility.</p>
    <p class="Pp"></p>
    <pre>
  output_isnt(sub {print &quot;foo&quot;; print STDERR &quot;bar&quot;;},undef,'foo');
    </pre>
    <p class="Pp">is the same as</p>
    <p class="Pp"></p>
    <pre>
  stderr_is(sub {print STDERR &quot;bar&quot;;},'foo')
    </pre>
  </dd>
  <dt id="output_like"><a class="permalink" href="#output_like"><b>output_like</b></a></dt>
  <dd></dd>
  <dt id="output_unlike"><a class="permalink" href="#output_unlike"><b>output_unlike</b></a></dt>
  <dd>
    <pre>
  output_like  ( $coderef, $regex_stdout, $regex_stderr, 'description' );
  output_like  { ... } $regex_stdout, $regex_stderr, 'description';
  output_unlike( $coderef, $regex_stdout, $regex_stderr, 'description' );
  output_unlike { ... } $regex_stdout, $regex_stderr, 'description';
    </pre>
    <p class="Pp"><i>output_like()</i> and <i>output_unlike()</i> follow the
        same principles as <i>output_is()</i> and <i>output_isnt()</i> except
        they use a regular expression for matching.</p>
    <p class="Pp"><i>output_like()</i> attempts to match
        <span class="Li">$regex_stdout</span> and
        <span class="Li">$regex_stderr</span> against STDOUT and STDERR produced
        by <span class="Li">$coderef</span>. The test passes if both match.</p>
    <p class="Pp"></p>
    <pre>
  output_like(sub {print &quot;foo&quot;; print STDERR &quot;bar&quot;;},qr/foo/,qr/bar/);
    </pre>
    <p class="Pp">The above test is successful.</p>
    <p class="Pp">Like <i>output_is()</i>, setting either
        <span class="Li">$regex_stdout</span> or
        <span class="Li">$regex_stderr</span> to
        <span class="Li">&quot;undef&quot;</span> ignores the output to that
        facility.</p>
    <p class="Pp"></p>
    <pre>
  output_like(sub {print &quot;foo&quot;; print STDERR &quot;bar&quot;;},qr/foo/,undef);
    </pre>
    <p class="Pp">is the same as</p>
    <p class="Pp"></p>
    <pre>
  stdout_like(sub {print &quot;foo&quot;; print STDERR &quot;bar&quot;;},qr/foo/);
    </pre>
    <p class="Pp"><i>output_unlike()</i> test pass if output from
        <span class="Li">$coderef</span> doesn't match
        <span class="Li">$regex_stdout</span> and
        <span class="Li">$regex_stderr</span>.</p>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTS"><a class="permalink" href="#EXPORTS">EXPORTS</a></h1>
<p class="Pp">By default, all tests are exported, however with the switch to
    Sub::Exporter export groups are now available to better limit imports.</p>
<p class="Pp">To import tests for STDOUT:</p>
<p class="Pp"></p>
<pre>
  use Test::Output qw(:stdout);
</pre>
<p class="Pp">To import tests STDERR:</p>
<p class="Pp"></p>
<pre>
  use Test::Output qw(:stderr);
</pre>
<p class="Pp">To import just the functions:</p>
<p class="Pp"></p>
<pre>
  use Test::Output qw(:functions);
</pre>
<p class="Pp">And to import all tests:</p>
<p class="Pp"></p>
<pre>
  use Test::Output;
</pre>
<p class="Pp">The following is a list of group names and which functions are
    exported:</p>
<dl class="Bl-tag">
  <dt id="stdout"><a class="permalink" href="#stdout">stdout</a></dt>
  <dd>stdout_is stdout_isnt stdout_like stdout_unlike</dd>
  <dt id="stderr"><a class="permalink" href="#stderr">stderr</a></dt>
  <dd>stderr_is stderr_isnt stderr_like stderr_unlike</dd>
  <dt id="output"><a class="permalink" href="#output">output</a></dt>
  <dd>output_is output_isnt output_like output_unlike</dd>
  <dt id="combined"><a class="permalink" href="#combined">combined</a></dt>
  <dd>combined_is combined_isnt combined_like combined_unlike</dd>
  <dt id="tests"><a class="permalink" href="#tests">tests</a></dt>
  <dd>All of the above, this is the default when no options are given.</dd>
</dl>
<p class="Pp">Sub::Exporter allows for many other options, I encourage reading
    its documentation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTIONS"><a class="permalink" href="#FUNCTIONS">FUNCTIONS</a></h1>
<section class="Ss">
<h2 class="Ss" id="stdout_from"><a class="permalink" href="#stdout_from">stdout_from</a></h2>
<pre>
  my $stdout = stdout_from($coderef)
  my $stdout = stdout_from { ... };
</pre>
<p class="Pp"><i>stdout_from()</i> executes <span class="Li">$coderef</span> and
    captures STDOUT.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="stderr_from"><a class="permalink" href="#stderr_from">stderr_from</a></h2>
<pre>
  my $stderr = stderr_from($coderef)
  my $stderr = stderr_from { ... };
</pre>
<p class="Pp"><i>stderr_from()</i> executes <span class="Li">$coderef</span> and
    captures STDERR.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="output_from"><a class="permalink" href="#output_from">output_from</a></h2>
<pre>
  my ($stdout, $stderr) = output_from($coderef)
  my ($stdout, $stderr) = output_from {...};
</pre>
<p class="Pp"><i>output_from()</i> executes <span class="Li">$coderef</span> one
    time capturing both STDOUT and STDERR.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="combined_from"><a class="permalink" href="#combined_from">combined_from</a></h2>
<pre>
  my $combined = combined_from($coderef);
  my $combined = combined_from {...};
</pre>
<p class="Pp"><i>combined_from()</i> executes <span class="Li">$coderef</span>
    one time combines STDOUT and STDERR, and captures them.
    <i>combined_from()</i> is equivalent to using 2&gt;&amp;1 in UNIX.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Currently maintained by brian d foy,
    <span class="Li">&quot;bdfoy@cpan.org&quot;</span>.</p>
<p class="Pp">Shawn Sorichetti,
    <span class="Li">&quot;&lt;ssoriche@cpan.org&gt;&quot;</span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SOURCE_AVAILABILITY"><a class="permalink" href="#SOURCE_AVAILABILITY">SOURCE
  AVAILABILITY</a></h1>
<p class="Pp">This module is in Github:</p>
<p class="Pp"></p>
<pre>
        http://github.com/briandfoy/test-output/tree/master
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">Please report any bugs or feature requests to
    <span class="Li">&quot;bug-test-output@rt.cpan.org&quot;</span>, or through
    the web interface at &lt;http://rt.cpan.org&gt;. I will be notified, and
    then you'll automatically be notified of progress on your bug as I make
    changes.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGEMENTS"><a class="permalink" href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></h1>
<p class="Pp">Thanks to chromatic whose TieOut.pm was the basis for capturing
    output.</p>
<p class="Pp">Also thanks to rjbs for his help cleaning the documentation, and
    pushing me to Sub::Exporter.</p>
<p class="Pp">Thanks to David Wheeler for providing code block support and
    tests.</p>
<p class="Pp">Thanks to Michael G Schwern for the solution to combining STDOUT
    and STDERR.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_&amp;_LICENSE"><a class="permalink" href="#COPYRIGHT_&amp;_LICENSE">COPYRIGHT
  &amp; LICENSE</a></h1>
<p class="Pp">Copyright 2005-2013 Shawn Sorichetti, All Rights Reserved.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-03</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

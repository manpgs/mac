<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Digest::SHA(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Digest::SHA(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Digest::SHA(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Digest::SHA - Perl extension for SHA-1/224/256/384/512</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">In programs:</p>
<p class="Pp"></p>
<pre>
                # Functional interface

        use Digest::SHA qw(sha1 sha1_hex sha1_base64 ...);

        $digest = sha1($data);
        $digest = sha1_hex($data);
        $digest = sha1_base64($data);

        $digest = sha256($data);
        $digest = sha384_hex($data);
        $digest = sha512_base64($data);

                # Object-oriented

        use Digest::SHA;

        $sha = Digest::SHA-&gt;new($alg);

        $sha-&gt;add($data);               # feed data into stream

        $sha-&gt;addfile(*F);
        $sha-&gt;addfile($filename);

        $sha-&gt;add_bits($bits);
        $sha-&gt;add_bits($data, $nbits);

        $sha_copy = $sha-&gt;clone;        # make copy of digest object
        $state = $sha-&gt;getstate;        # save current state to string
        $sha-&gt;putstate($state);         # restore previous $state

        $digest = $sha-&gt;digest;         # compute digest
        $digest = $sha-&gt;hexdigest;
        $digest = $sha-&gt;b64digest;
</pre>
<p class="Pp">From the command line:</p>
<p class="Pp"></p>
<pre>
        $ shasum files

        $ shasum --help
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS_(HMAC-SHA)"><a class="permalink" href="#SYNOPSIS_(HMAC-SHA)">SYNOPSIS
  (HMAC-SHA)</a></h1>
<pre>
                # Functional interface only

        use Digest::SHA qw(hmac_sha1 hmac_sha1_hex ...);

        $digest = hmac_sha1($data, $key);
        $digest = hmac_sha224_hex($data, $key);
        $digest = hmac_sha256_base64($data, $key);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="ABSTRACT"><a class="permalink" href="#ABSTRACT">ABSTRACT</a></h1>
<p class="Pp">Digest::SHA is a complete implementation of the NIST Secure Hash
    Standard. It gives Perl programmers a convenient way to calculate SHA-1,
    SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, and SHA-512/256 message
    digests. The module can handle all types of input, including partial-byte
    data.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Digest::SHA is written in C for speed. If your platform lacks a C
    compiler, you can install the functionally equivalent (but much slower)
    Digest::SHA::PurePerl module.</p>
<p class="Pp">The programming interface is easy to use: it's the same one found
    in CPAN's Digest module. So, if your applications currently use Digest::MD5
    and you'd prefer the stronger security of SHA, it's a simple matter to
    convert them.</p>
<p class="Pp">The interface provides two ways to calculate digests: all-at-once,
    or in stages. To illustrate, the following short program computes the
    SHA-256 digest of &quot;hello world&quot; using each approach:</p>
<p class="Pp"></p>
<pre>
        use Digest::SHA qw(sha256_hex);

        $data = &quot;hello world&quot;;
        @frags = split(//, $data);

        # all-at-once (Functional style)
        $digest1 = sha256_hex($data);

        # in-stages (OOP style)
        $state = Digest::SHA-&gt;new(256);
        for (@frags) { $state-&gt;add($_) }
        $digest2 = $state-&gt;hexdigest;

        print $digest1 eq $digest2 ?
                &quot;whew!\n&quot; : &quot;oops!\n&quot;;
</pre>
<p class="Pp">To calculate the digest of an n-bit message where <i>n</i> is not
    a multiple of 8, use the <i></i><b><i>add_bits()</i></b><i></i> method. For
    example, consider the 446-bit message consisting of the bit-string
    &quot;110&quot; repeated 148 times, followed by &quot;11&quot;. Here's how
    to display its SHA-1 digest:</p>
<p class="Pp"></p>
<pre>
        use Digest::SHA;
        $bits = &quot;110&quot; x 148 . &quot;11&quot;;
        $sha = Digest::SHA-&gt;new(1)-&gt;add_bits($bits);
        print $sha-&gt;hexdigest, &quot;\n&quot;;
</pre>
<p class="Pp">Note that for larger bit-strings, it's more efficient to use the
    two-argument version <i>add_bits($data, </i><i>$nbits</i><i>)</i>, where
    <i></i><i>$data</i><i></i> is in the customary packed binary format used for
    Perl strings.</p>
<p class="Pp">The module also lets you save intermediate SHA states to a string.
    The <i></i><b><i>getstate()</i></b><i></i> method generates portable,
    human-readable text describing the current state of computation. You can
    subsequently restore that state with <i></i><b><i>putstate()</i></b><i></i>
    to resume where the calculation left off.</p>
<p class="Pp">To see what a state description looks like, just run the
    following:</p>
<p class="Pp"></p>
<pre>
        use Digest::SHA;
        print Digest::SHA-&gt;new-&gt;add(&quot;Shaw&quot; x 1962)-&gt;getstate;
</pre>
<p class="Pp">As an added convenience, the Digest::SHA module offers routines to
    calculate keyed hashes using the HMAC-SHA-1/224/256/384/512 algorithms.
    These services exist in functional form only, and mimic the style and
    behavior of the <i></i><b><i>sha()</i></b><i></i>,
    <i></i><b><i>sha_hex()</i></b><i></i>, and
    <i></i><b><i>sha_base64()</i></b><i></i> functions.</p>
<p class="Pp"></p>
<pre>
        # Test vector from draft-ietf-ipsec-ciph-sha-256-01.txt

        use Digest::SHA qw(hmac_sha256_hex);
        print hmac_sha256_hex(&quot;Hi There&quot;, chr(0x0b) x 32), &quot;\n&quot;;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="UNICODE_AND_SIDE_EFFECTS"><a class="permalink" href="#UNICODE_AND_SIDE_EFFECTS">UNICODE
  AND SIDE EFFECTS</a></h1>
<p class="Pp">Perl supports Unicode strings as of version 5.6. Such strings may
    contain wide characters, namely, characters whose ordinal values are greater
    than 255. This can cause problems for digest algorithms such as SHA that are
    specified to operate on sequences of bytes.</p>
<p class="Pp">The rule by which Digest::SHA handles a Unicode string is easy to
    state, but potentially confusing to grasp: the string is interpreted as a
    sequence of byte values, where each byte value is equal to the ordinal value
    (viz. code point) of its corresponding Unicode character. That way, the
    Unicode string 'abc' has exactly the same digest value as the ordinary
    string 'abc'.</p>
<p class="Pp">Since a wide character does not fit into a byte, the Digest::SHA
    routines croak if they encounter one. Whereas if a Unicode string contains
    no wide characters, the module accepts it quite happily. The following code
    illustrates the two cases:</p>
<p class="Pp"></p>
<pre>
        $str1 = pack('U*', (0..255));
        print sha1_hex($str1);          # ok

        $str2 = pack('U*', (0..256));
        print sha1_hex($str2);          # croaks
</pre>
<p class="Pp">Be aware that the digest routines silently convert UTF-8 input
    into its equivalent byte sequence in the native encoding (cf.
    utf8::downgrade). This side effect influences only the way Perl stores the
    data internally, but otherwise leaves the actual value of the data
  intact.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NIST_STATEMENT_ON_SHA"><a class="permalink" href="#NIST_STATEMENT_ON_SHA">NIST
  STATEMENT ON SHA-1</a></h1>
<p class="Pp">NIST acknowledges that the work of Prof. Xiaoyun Wang constitutes
    a practical collision attack on SHA-1. Therefore, NIST encourages the rapid
    adoption of the SHA-2 hash functions (e.g. SHA-256) for applications
    requiring strong collision resistance, such as digital signatures.</p>
<p class="Pp">ref.
  &lt;http://csrc.nist.gov/groups/ST/hash/statement.html&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PADDING_OF_BASE64_DIGESTS"><a class="permalink" href="#PADDING_OF_BASE64_DIGESTS">PADDING
  OF BASE64 DIGESTS</a></h1>
<p class="Pp">By convention, CPAN Digest modules do <b>not</b> pad their Base64
    output. Problems can occur when feeding such digests to other software that
    expects properly padded Base64 encodings.</p>
<p class="Pp">For the time being, any necessary padding must be done by the
    user. Fortunately, this is a simple operation: if the length of a
    Base64-encoded digest isn't a multiple of 4, simply append &quot;=&quot;
    characters to the end of the digest until it is:</p>
<p class="Pp"></p>
<pre>
        while (length($b64_digest) % 4) {
                $b64_digest .= '=';
        }
</pre>
<p class="Pp">To illustrate, <i>sha256_base64(&quot;abc&quot;)</i> is computed
    to be</p>
<p class="Pp"></p>
<pre>
        ungWv48Bz+pBQUDeXa4iI7ADYaOWF3qctBD/YfIAFa0
</pre>
<p class="Pp">which has a length of 43. So, the properly padded version is</p>
<p class="Pp"></p>
<pre>
        ungWv48Bz+pBQUDeXa4iI7ADYaOWF3qctBD/YfIAFa0=
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORT"><a class="permalink" href="#EXPORT">EXPORT</a></h1>
<p class="Pp">None by default.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTABLE_FUNCTIONS"><a class="permalink" href="#EXPORTABLE_FUNCTIONS">EXPORTABLE
  FUNCTIONS</a></h1>
<p class="Pp">Provided your C compiler supports a 64-bit type (e.g. the
    <i>long</i> <i>long</i> of C99, or <i>__int64</i> used by Microsoft C/C++),
    all of these functions will be available for use. Otherwise, you won't be
    able to perform the SHA-384 and SHA-512 transforms, both of which require
    64-bit operations.</p>
<p class="Pp"><i>Functional style</i></p>
<dl class="Bl-tag">
  <dt id="sha1($data,"><a class="permalink" href="#sha1($data,"><b>sha1($data,
    ...)</b></a></dt>
  <dd></dd>
  <dt id="sha224($data,"><a class="permalink" href="#sha224($data,"><b>sha224($data,
    ...)</b></a></dt>
  <dd></dd>
  <dt id="sha256($data,"><a class="permalink" href="#sha256($data,"><b>sha256($data,
    ...)</b></a></dt>
  <dd></dd>
  <dt id="sha384($data,"><a class="permalink" href="#sha384($data,"><b>sha384($data,
    ...)</b></a></dt>
  <dd></dd>
  <dt id="sha512($data,"><a class="permalink" href="#sha512($data,"><b>sha512($data,
    ...)</b></a></dt>
  <dd></dd>
  <dt id="sha512224($data,"><a class="permalink" href="#sha512224($data,"><b>sha512224($data,
    ...)</b></a></dt>
  <dd></dd>
  <dt id="sha512256($data,"><a class="permalink" href="#sha512256($data,"><b>sha512256($data,
    ...)</b></a></dt>
  <dd>Logically joins the arguments into a single string, and returns its
      SHA-1/224/256/384/512 digest encoded as a binary string.</dd>
  <dt id="sha1_hex($data,"><a class="permalink" href="#sha1_hex($data,"><b>sha1_hex($data,
    ...)</b></a></dt>
  <dd></dd>
  <dt id="sha224_hex($data,"><a class="permalink" href="#sha224_hex($data,"><b>sha224_hex($data,
    ...)</b></a></dt>
  <dd></dd>
  <dt id="sha256_hex($data,"><a class="permalink" href="#sha256_hex($data,"><b>sha256_hex($data,
    ...)</b></a></dt>
  <dd></dd>
  <dt id="sha384_hex($data,"><a class="permalink" href="#sha384_hex($data,"><b>sha384_hex($data,
    ...)</b></a></dt>
  <dd></dd>
  <dt id="sha512_hex($data,"><a class="permalink" href="#sha512_hex($data,"><b>sha512_hex($data,
    ...)</b></a></dt>
  <dd></dd>
  <dt id="sha512224_hex($data,"><a class="permalink" href="#sha512224_hex($data,"><b>sha512224_hex($data,
    ...)</b></a></dt>
  <dd></dd>
  <dt id="sha512256_hex($data,"><a class="permalink" href="#sha512256_hex($data,"><b>sha512256_hex($data,
    ...)</b></a></dt>
  <dd>Logically joins the arguments into a single string, and returns its
      SHA-1/224/256/384/512 digest encoded as a hexadecimal string.</dd>
  <dt id="sha1_base64($data,"><a class="permalink" href="#sha1_base64($data,"><b>sha1_base64($data,
    ...)</b></a></dt>
  <dd></dd>
  <dt id="sha224_base64($data,"><a class="permalink" href="#sha224_base64($data,"><b>sha224_base64($data,
    ...)</b></a></dt>
  <dd></dd>
  <dt id="sha256_base64($data,"><a class="permalink" href="#sha256_base64($data,"><b>sha256_base64($data,
    ...)</b></a></dt>
  <dd></dd>
  <dt id="sha384_base64($data,"><a class="permalink" href="#sha384_base64($data,"><b>sha384_base64($data,
    ...)</b></a></dt>
  <dd></dd>
  <dt id="sha512_base64($data,"><a class="permalink" href="#sha512_base64($data,"><b>sha512_base64($data,
    ...)</b></a></dt>
  <dd></dd>
  <dt id="sha512224_base64($data,"><a class="permalink" href="#sha512224_base64($data,"><b>sha512224_base64($data,
    ...)</b></a></dt>
  <dd></dd>
  <dt id="sha512256_base64($data,"><a class="permalink" href="#sha512256_base64($data,"><b>sha512256_base64($data,
    ...)</b></a></dt>
  <dd>Logically joins the arguments into a single string, and returns its
      SHA-1/224/256/384/512 digest encoded as a Base64 string.
    <p class="Pp">It's important to note that the resulting string does
        <b>not</b> contain the padding characters typical of Base64 encodings.
        This omission is deliberate, and is done to maintain compatibility with
        the family of CPAN Digest modules. See &quot;PADDING OF BASE64
        DIGESTS&quot; for details.</p>
  </dd>
</dl>
<p class="Pp"><i>OOP style</i></p>
<dl class="Bl-tag">
  <dt id="new($alg)"><a class="permalink" href="#new($alg)"><b>new($alg)</b></a></dt>
  <dd>Returns a new Digest::SHA object. Allowed values for
      <i></i><i>$alg</i><i></i> are 1, 224, 256, 384, 512, 512224, or 512256.
      It's also possible to use common string representations of the algorithm
      (e.g. &quot;sha256&quot;, &quot;SHA-384&quot;). If the argument is
      missing, SHA-1 will be used by default.
    <p class="Pp">Invoking <i>new</i> as an instance method will reset the
        object to the initial state associated with <i></i><i>$alg</i><i></i>.
        If the argument is missing, the object will continue using the same
        algorithm that was selected at creation.</p>
  </dd>
  <dt id="reset($alg)"><a class="permalink" href="#reset($alg)"><b>reset($alg)</b></a></dt>
  <dd>This method has exactly the same effect as <i>new($alg)</i>. In fact,
      <i>reset</i> is just an alias for <i>new</i>.</dd>
  <dt id="hashsize"><a class="permalink" href="#hashsize"><b>hashsize</b></a></dt>
  <dd>Returns the number of digest bits for this object. The values are 160,
      224, 256, 384, 512, 224, and 256 for SHA-1, SHA-224, SHA-256, SHA-384,
      SHA-512, SHA-512/224 and SHA-512/256, respectively.</dd>
  <dt id="algorithm"><a class="permalink" href="#algorithm"><b>algorithm</b></a></dt>
  <dd>Returns the digest algorithm for this object. The values are 1, 224, 256,
      384, 512, 512224, and 512256 for SHA-1, SHA-224, SHA-256, SHA-384,
      SHA-512, SHA-512/224, and SHA-512/256, respectively.</dd>
  <dt id="clone"><a class="permalink" href="#clone"><b>clone</b></a></dt>
  <dd>Returns a duplicate copy of the object.</dd>
  <dt id="add($data,"><a class="permalink" href="#add($data,"><b>add($data,
    ...)</b></a></dt>
  <dd>Logically joins the arguments into a single string, and uses it to update
      the current digest state. In other words, the following statements have
      the same effect:
    <p class="Pp"></p>
    <pre>
        $sha-&gt;add(&quot;a&quot;); $sha-&gt;add(&quot;b&quot;); $sha-&gt;add(&quot;c&quot;);
        $sha-&gt;add(&quot;a&quot;)-&gt;add(&quot;b&quot;)-&gt;add(&quot;c&quot;);
        $sha-&gt;add(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
        $sha-&gt;add(&quot;abc&quot;);
    </pre>
    <p class="Pp">The return value is the updated object itself.</p>
  </dd>
  <dt id="add_bits($data,"><a class="permalink" href="#add_bits($data,"><b>add_bits($data,
    </b><b>$nbits</b><b>)</b></a></dt>
  <dd></dd>
  <dt id="add_bits($bits)"><a class="permalink" href="#add_bits($bits)"><b>add_bits($bits)</b></a></dt>
  <dd>Updates the current digest state by appending bits to it. The return value
      is the updated object itself.
    <p class="Pp">The first form causes the most-significant
        <i></i><i>$nbits</i><i></i> of <i></i><i>$data</i><i></i> to be appended
        to the stream. The <i></i><i>$data</i><i></i> argument is in the
        customary binary format used for Perl strings.</p>
    <p class="Pp">The second form takes an ASCII string of &quot;0&quot; and
        &quot;1&quot; characters as its argument. It's equivalent to</p>
    <p class="Pp"></p>
    <pre>
        $sha-&gt;add_bits(pack(&quot;B*&quot;, $bits), length($bits));
    </pre>
    <p class="Pp">So, the following two statements do the same thing:</p>
    <p class="Pp"></p>
    <pre>
        $sha-&gt;add_bits(&quot;111100001010&quot;);
        $sha-&gt;add_bits(&quot;\xF0\xA0&quot;, 12);
    </pre>
    <p class="Pp">Note that SHA-1 and SHA-2 use <i>most-significant-bit
        ordering</i> for their internal state. This means that</p>
    <p class="Pp"></p>
    <pre>
        $sha3-&gt;add_bits(&quot;110&quot;);
    </pre>
    <p class="Pp">is equivalent to</p>
    <p class="Pp"></p>
    <pre>
        $sha3-&gt;add_bits(&quot;1&quot;)-&gt;add_bits(&quot;1&quot;)-&gt;add_bits(&quot;0&quot;);
    </pre>
  </dd>
  <dt id="addfile(*FILE)"><a class="permalink" href="#addfile(*FILE)"><b>addfile(*FILE)</b></a></dt>
  <dd>Reads from <i>FILE</i> until EOF, and appends that data to the current
      state. The return value is the updated object itself.</dd>
  <dt id="addfile($filename"><a class="permalink" href="#addfile($filename"><b>addfile($filename
    [, </b><b>$mode</b><b>])</b></a></dt>
  <dd>Reads the contents of <i></i><i>$filename</i><i></i>, and appends that
      data to the current state. The return value is the updated object itself.
    <p class="Pp">By default, <i></i><i>$filename</i><i></i> is simply opened
        and read; no special modes or I/O disciplines are used. To change this,
        set the optional <i></i><i>$mode</i><i></i> argument to one of the
        following values:</p>
    <p class="Pp"></p>
    <pre>
        &quot;b&quot;     read file in binary mode

        &quot;U&quot;     use universal newlines

        &quot;0&quot;     use BITS mode
    </pre>
    <p class="Pp">The &quot;U&quot; mode is modeled on Python's &quot;Universal
        Newlines&quot; concept, whereby DOS and Mac OS line terminators are
        converted internally to UNIX newlines before processing. This ensures
        consistent digest values when working simultaneously across multiple
        file systems. <b>The &quot;U&quot; mode influences</b> <b>only text
        files</b>, namely those passing Perl's <i>-T</i> test; binary files are
        processed with no translation whatsoever.</p>
    <p class="Pp">The BITS mode (&quot;0&quot;) interprets the contents of
        <i></i><i>$filename</i><i></i> as a logical stream of bits, where each
        ASCII '0' or '1' character represents a 0 or 1 bit, respectively. All
        other characters are ignored. This provides a convenient way to
        calculate the digest values of partial-byte data by using files, rather
        than having to write separate programs employing the <i>add_bits</i>
        method.</p>
  </dd>
  <dt id="getstate"><a class="permalink" href="#getstate"><b>getstate</b></a></dt>
  <dd>Returns a string containing a portable, human-readable representation of
      the current SHA state.</dd>
  <dt id="putstate($str)"><a class="permalink" href="#putstate($str)"><b>putstate($str)</b></a></dt>
  <dd>Returns a Digest::SHA object representing the SHA state contained in
      <i></i><i>$str</i><i></i>. The format of <i></i><i>$str</i><i></i> matches
      the format of the output produced by method <i>getstate</i>. If called as
      a class method, a new object is created; if called as an instance method,
      the object is reset to the state contained in
    <i></i><i>$str</i><i></i>.</dd>
  <dt id="dump($filename)"><a class="permalink" href="#dump($filename)"><b>dump($filename)</b></a></dt>
  <dd>Writes the output of <i>getstate</i> to <i></i><i>$filename</i><i></i>. If
      the argument is missing, or equal to the empty string, the state
      information will be written to STDOUT.</dd>
  <dt id="load($filename)"><a class="permalink" href="#load($filename)"><b>load($filename)</b></a></dt>
  <dd>Returns a Digest::SHA object that results from calling <i>putstate</i> on
      the contents of <i></i><i>$filename</i><i></i>. If the argument is
      missing, or equal to the empty string, the state information will be read
      from STDIN.</dd>
  <dt id="digest"><a class="permalink" href="#digest"><b>digest</b></a></dt>
  <dd>Returns the digest encoded as a binary string.
    <p class="Pp">Note that the <i>digest</i> method is a read-once operation.
        Once it has been performed, the Digest::SHA object is automatically
        reset in preparation for calculating another digest value. Call
        <i></i><i>$sha</i><i>-&gt;clone-&gt;digest</i> if it's necessary to
        preserve the original digest state.</p>
  </dd>
  <dt id="hexdigest"><a class="permalink" href="#hexdigest"><b>hexdigest</b></a></dt>
  <dd>Returns the digest encoded as a hexadecimal string.
    <p class="Pp">Like <i>digest</i>, this method is a read-once operation. Call
        <i></i><i>$sha</i><i>-&gt;clone-&gt;hexdigest</i> if it's necessary to
        preserve the original digest state.</p>
  </dd>
  <dt id="b64digest"><a class="permalink" href="#b64digest"><b>b64digest</b></a></dt>
  <dd>Returns the digest encoded as a Base64 string.
    <p class="Pp">Like <i>digest</i>, this method is a read-once operation. Call
        <i></i><i>$sha</i><i>-&gt;clone-&gt;b64digest</i> if it's necessary to
        preserve the original digest state.</p>
    <p class="Pp">It's important to note that the resulting string does
        <b>not</b> contain the padding characters typical of Base64 encodings.
        This omission is deliberate, and is done to maintain compatibility with
        the family of CPAN Digest modules. See &quot;PADDING OF BASE64
        DIGESTS&quot; for details.</p>
  </dd>
</dl>
<p class="Pp"><i>HMAC-SHA-1/224/256/384/512</i></p>
<dl class="Bl-tag">
  <dt id="hmac_sha1($data,"><a class="permalink" href="#hmac_sha1($data,"><b>hmac_sha1($data,
    </b><b>$key</b><b>)</b></a></dt>
  <dd></dd>
  <dt id="hmac_sha224($data,"><a class="permalink" href="#hmac_sha224($data,"><b>hmac_sha224($data,
    </b><b>$key</b><b>)</b></a></dt>
  <dd></dd>
  <dt id="hmac_sha256($data,"><a class="permalink" href="#hmac_sha256($data,"><b>hmac_sha256($data,
    </b><b>$key</b><b>)</b></a></dt>
  <dd></dd>
  <dt id="hmac_sha384($data,"><a class="permalink" href="#hmac_sha384($data,"><b>hmac_sha384($data,
    </b><b>$key</b><b>)</b></a></dt>
  <dd></dd>
  <dt id="hmac_sha512($data,"><a class="permalink" href="#hmac_sha512($data,"><b>hmac_sha512($data,
    </b><b>$key</b><b>)</b></a></dt>
  <dd></dd>
  <dt id="hmac_sha512224($data,"><a class="permalink" href="#hmac_sha512224($data,"><b>hmac_sha512224($data,
    </b><b>$key</b><b>)</b></a></dt>
  <dd></dd>
  <dt id="hmac_sha512256($data,"><a class="permalink" href="#hmac_sha512256($data,"><b>hmac_sha512256($data,
    </b><b>$key</b><b>)</b></a></dt>
  <dd>Returns the HMAC-SHA-1/224/256/384/512 digest of
      <i></i><i>$data</i><i></i>/<i></i><i>$key</i><i></i>, with the result
      encoded as a binary string. Multiple <i></i><i>$data</i><i></i> arguments
      are allowed, provided that <i></i><i>$key</i><i></i> is the last argument
      in the list.</dd>
  <dt id="hmac_sha1_hex($data,"><a class="permalink" href="#hmac_sha1_hex($data,"><b>hmac_sha1_hex($data,
    </b><b>$key</b><b>)</b></a></dt>
  <dd></dd>
  <dt id="hmac_sha224_hex($data,"><a class="permalink" href="#hmac_sha224_hex($data,"><b>hmac_sha224_hex($data,
    </b><b>$key</b><b>)</b></a></dt>
  <dd></dd>
  <dt id="hmac_sha256_hex($data,"><a class="permalink" href="#hmac_sha256_hex($data,"><b>hmac_sha256_hex($data,
    </b><b>$key</b><b>)</b></a></dt>
  <dd></dd>
  <dt id="hmac_sha384_hex($data,"><a class="permalink" href="#hmac_sha384_hex($data,"><b>hmac_sha384_hex($data,
    </b><b>$key</b><b>)</b></a></dt>
  <dd></dd>
  <dt id="hmac_sha512_hex($data,"><a class="permalink" href="#hmac_sha512_hex($data,"><b>hmac_sha512_hex($data,
    </b><b>$key</b><b>)</b></a></dt>
  <dd></dd>
  <dt id="hmac_sha512224_hex($data,"><a class="permalink" href="#hmac_sha512224_hex($data,"><b>hmac_sha512224_hex($data,
    </b><b>$key</b><b>)</b></a></dt>
  <dd></dd>
  <dt id="hmac_sha512256_hex($data,"><a class="permalink" href="#hmac_sha512256_hex($data,"><b>hmac_sha512256_hex($data,
    </b><b>$key</b><b>)</b></a></dt>
  <dd>Returns the HMAC-SHA-1/224/256/384/512 digest of
      <i></i><i>$data</i><i></i>/<i></i><i>$key</i><i></i>, with the result
      encoded as a hexadecimal string. Multiple <i></i><i>$data</i><i></i>
      arguments are allowed, provided that <i></i><i>$key</i><i></i> is the last
      argument in the list.</dd>
  <dt id="hmac_sha1_base64($data,"><a class="permalink" href="#hmac_sha1_base64($data,"><b>hmac_sha1_base64($data,
    </b><b>$key</b><b>)</b></a></dt>
  <dd></dd>
  <dt id="hmac_sha224_base64($data,"><a class="permalink" href="#hmac_sha224_base64($data,"><b>hmac_sha224_base64($data,
    </b><b>$key</b><b>)</b></a></dt>
  <dd></dd>
  <dt id="hmac_sha256_base64($data,"><a class="permalink" href="#hmac_sha256_base64($data,"><b>hmac_sha256_base64($data,
    </b><b>$key</b><b>)</b></a></dt>
  <dd></dd>
  <dt id="hmac_sha384_base64($data,"><a class="permalink" href="#hmac_sha384_base64($data,"><b>hmac_sha384_base64($data,
    </b><b>$key</b><b>)</b></a></dt>
  <dd></dd>
  <dt id="hmac_sha512_base64($data,"><a class="permalink" href="#hmac_sha512_base64($data,"><b>hmac_sha512_base64($data,
    </b><b>$key</b><b>)</b></a></dt>
  <dd></dd>
  <dt id="hmac_sha512224_base64($data,"><a class="permalink" href="#hmac_sha512224_base64($data,"><b>hmac_sha512224_base64($data,
    </b><b>$key</b><b>)</b></a></dt>
  <dd></dd>
  <dt id="hmac_sha512256_base64($data,"><a class="permalink" href="#hmac_sha512256_base64($data,"><b>hmac_sha512256_base64($data,
    </b><b>$key</b><b>)</b></a></dt>
  <dd>Returns the HMAC-SHA-1/224/256/384/512 digest of
      <i></i><i>$data</i><i></i>/<i></i><i>$key</i><i></i>, with the result
      encoded as a Base64 string. Multiple <i></i><i>$data</i><i></i> arguments
      are allowed, provided that <i></i><i>$key</i><i></i> is the last argument
      in the list.
    <p class="Pp">It's important to note that the resulting string does
        <b>not</b> contain the padding characters typical of Base64 encodings.
        This omission is deliberate, and is done to maintain compatibility with
        the family of CPAN Digest modules. See &quot;PADDING OF BASE64
        DIGESTS&quot; for details.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Digest, Digest::SHA::PurePerl</p>
<p class="Pp">The Secure Hash Standard (Draft FIPS PUB 180-4) can be found
  at:</p>
<p class="Pp">&lt;http://csrc.nist.gov/publications/drafts/fips180-4/Draft-FIPS180-4_Feb2011.pdf&gt;</p>
<p class="Pp">The Keyed-Hash Message Authentication Code (HMAC):</p>
<p class="Pp">&lt;http://csrc.nist.gov/publications/fips/fips198/fips-198a.pdf&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<pre>
        Mark Shelor     &lt;mshelor@cpan.org&gt;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGMENTS"><a class="permalink" href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a></h1>
<p class="Pp">The author is particularly grateful to</p>
<p class="Pp"></p>
<pre>
        Gisle Aas
        H. Merijn Brand
        Sean Burke
        Chris Carey
        Alexandr Ciornii
        Chris David
        Jim Doble
        Thomas Drugeon
        Julius Duque
        Jeffrey Friedl
        Robert Gilmour
        Brian Gladman
        Jarkko Hietaniemi
        Adam Kennedy
        Mark Lawrence
        Andy Lester
        Alex Muntada
        Steve Peters
        Chris Skiscim
        Martin Thurn
        Gunnar Wolf
        Adam Woodbury
</pre>
<p class="Pp">&quot;who by trained skill rescued life from such great billows
    and such thick darkness and moored it in so perfect a calm and in so
    brilliant a light&quot; - Lucretius</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">Copyright (C) 2003-2018 Mark Shelor</p>
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">perlartistic</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

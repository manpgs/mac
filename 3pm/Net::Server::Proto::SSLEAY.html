<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Net::Server::Proto::SSLEAY(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Net::Server::Proto::SSLEAY(3)</td>
    <td class="head-vol"><a href=".">User Contributed Perl Documentation</a></td>
    <td class="head-rtitle">Net::Server::Proto::SSLEAY(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Net::Server::Proto::SSLEAY - Custom Net::Server SSL protocol
    handler based on Net::SSLeay.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">See Net::Server::Proto.</p>
<p class="Pp"></p>
<pre>    use base qw(Net::Server::HTTP);
    main-&gt;run(
        proto =&gt; 'ssleay',
        SSL_key_file  =&gt; &quot;/path/to/my/file.key&quot;,
        SSL_cert_file =&gt; &quot;/path/to/my/file.crt&quot;,
    );
    # OR
    sub SSL_key_file  { &quot;/path/to/my/file.key&quot; }
    sub SSL_cert_file { &quot;/path/to/my/file.crt&quot; }
    main-&gt;run(proto =&gt; 'ssleay');
    # OR
    main-&gt;run(
        port =&gt; [443, 8443, &quot;80/tcp&quot;],  # bind to two ssleay ports and one tcp
        proto =&gt; &quot;ssleay&quot;,    # use ssleay as the default
        ipv  =&gt; &quot;*&quot;,          # bind both IPv4 and IPv6 interfaces
        SSL_key_file  =&gt; &quot;/path/to/my/file.key&quot;,
        SSL_cert_file =&gt; &quot;/path/to/my/file.crt&quot;,
    );
    # OR
    main-&gt;run(port =&gt; [{
        port  =&gt; &quot;443&quot;,
        proto =&gt; &quot;ssleay&quot;,
        # ipv =&gt; 4, # default - only do IPv4
        SSL_key_file  =&gt; &quot;/path/to/my/file.key&quot;,
        SSL_cert_file =&gt; &quot;/path/to/my/file.crt&quot;,
    }, {
        port  =&gt; &quot;8443&quot;,
        proto =&gt; &quot;ssleay&quot;,
        ipv   =&gt; &quot;*&quot;, # IPv4 and IPv6
        SSL_key_file  =&gt; &quot;/path/to/my/file2.key&quot;, # separate key
        SSL_cert_file =&gt; &quot;/path/to/my/file2.crt&quot;, # separate cert
    }]);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module has reliably been used in situations receiving
    millions of hits on a single box per day. If anybody has any successes or
    ideas for improvment under SSLEAY, please email
  &lt;paul@seamons.com&gt;.</p>
<p class="Pp">Protocol module for Net::Server. This module implements a secure
    socket layer over tcp (also known as SSL). See Net::Server::Proto.</p>
<p class="Pp">If you need more customization of the SSL layer, you may want to
    investigate using SSL rather than SSLEAY as it uses the venerable(ish)
    IO::Socket::SSL.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PARAMETERS"><a class="permalink" href="#PARAMETERS">PARAMETERS</a></h1>
<p class="Pp">Currently there is support for the following:</p>
<dl class="Bl-tag">
  <dt>&quot;SSL_cert_file&quot;</dt>
  <dd>Full path to the certificate file to be used for this server. Should be in
      PEM format.</dd>
  <dt>&quot;SSL_key_file&quot;</dt>
  <dd>Full path to the key file to be used for this server. Should be in PEM
      format.</dd>
  <dt>&quot;SSL_max_getline_length&quot;</dt>
  <dd>Used during getline to only read until this many bytes are found. Default
      is undef which means unlimited.</dd>
  <dt>&quot;SSL_error_callback&quot;</dt>
  <dd>Should be a code ref that will be called whenever error conditions are
      encountered. It passes a source message and an arrayref of the
    errors.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<p class="Pp">This module implements most of the common file handle operations.
    There are some additions though:</p>
<dl class="Bl-tag">
  <dt>&quot;read_until&quot;</dt>
  <dd>Takes bytes and match qr. If bytes is defined - it will read until that
      many bytes are found. If match qr is defined, it will read until the
      buffer matches that qr. If both are undefined, it will read until there is
      nothing left to read.</dd>
  <dt>&quot;error&quot;</dt>
  <dd>If an error occurred while writing, this method will return that
    error.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">There are probably many.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENCE"><a class="permalink" href="#LICENCE">LICENCE</a></h1>
<p class="Pp">Distributed under the same terms as Net::Server</p>
</section>
<section class="Sh">
<h1 class="Sh" id="THANKS"><a class="permalink" href="#THANKS">THANKS</a></h1>
<p class="Pp">Thanks to Bilbo at
    http://devpit.org/wiki/OpenSSL_with_nonblocking_sockets_%28in_Perl%29 for
    documenting a more reliable way of accepting and reading SSL
  connections.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-08-10</td>
    <td class="foot-os"><a href="..">perl v5.34.0</a></td>
  </tr>
</table>
</body>
</html>

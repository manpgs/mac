<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Moose::Cookbook::Legacy::Labeled_AttributeMetaclass(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Moose::Cookbook::Legacy::Labeled_AttributeMetaclass(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Moose::Cookbook::Legacy::Labeled_AttributeMetaclass(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Moose::Cookbook::Legacy::Labeled_AttributeMetaclass - A
    meta-attribute, attributes with labels</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 2.2012</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  package MyApp::Meta::Attribute::Labeled;
  use Moose;
  extends 'Moose::Meta::Attribute';
  has label =&gt; (
      is        =&gt; 'rw',
      isa       =&gt; 'Str',
      predicate =&gt; 'has_label',
  );
  package Moose::Meta::Attribute::Custom::Labeled;
  sub register_implementation {'MyApp::Meta::Attribute::Labeled'}
  package MyApp::Website;
  use Moose;
  has url =&gt; (
      metaclass =&gt; 'Labeled',
      is        =&gt; 'rw',
      isa       =&gt; 'Str',
      label     =&gt; &quot;The site's URL&quot;,
  );
  has name =&gt; (
      is  =&gt; 'rw',
      isa =&gt; 'Str',
  );
  sub dump {
      my $self = shift;
      my $meta = $self-&gt;meta;
      my $dump = '';
      for my $attribute ( map { $meta-&gt;get_attribute($_) }
          sort $meta-&gt;get_attribute_list ) {
          if (   $attribute-&gt;isa('MyApp::Meta::Attribute::Labeled')
              &amp;&amp; $attribute-&gt;has_label ) {
              $dump .= $attribute-&gt;label;
          }
          else {
              $dump .= $attribute-&gt;name;
          }
          my $reader = $attribute-&gt;get_read_method;
          $dump .= &quot;: &quot; . $self-&gt;$reader . &quot;\n&quot;;
      }
      return $dump;
  }
  package main;
  my $app = MyApp::Website-&gt;new( url =&gt; &quot;http://google.com&quot;, name =&gt; &quot;Google&quot; );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SUMMARY"><a class="permalink" href="#SUMMARY">SUMMARY</a></h1>
<p class="Pp"><b>WARNING: Subclassing metaclasses (as opposed to providing
    metaclass traits)</b> <b>is strongly discouraged. This recipe is provided
    solely for reference when</b> <b>encountering older code that does
  this.</b></p>
<p class="Pp">In this recipe, we begin to delve into the wonder of
    meta-programming. Some readers may scoff and claim that this is the arena of
    only the most twisted Moose developers. Absolutely not! Any sufficiently
    twisted developer can benefit greatly from going more meta.</p>
<p class="Pp">Our goal is to allow each attribute to have a human-readable
    &quot;label&quot; attached to it. Such labels would be used when showing
    data to an end user. In this recipe we label the
    <span class="Li">&quot;url&quot;</span> attribute with &quot;The site's
    URL&quot; and create a simple method showing how to use that label.</p>
<p class="Pp">The proper, modern way to extend attributes (using a role instead
    of a subclass) is described in Moose::Cookbook::Meta::Recipe3, but that
    recipe assumes you've read and at least tried to understand this one.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="META-ATTRIBUTE_OBJECTS"><a class="permalink" href="#META-ATTRIBUTE_OBJECTS">META-ATTRIBUTE
  OBJECTS</a></h1>
<p class="Pp">All the attributes of a Moose-based object are actually objects
    themselves. These objects have methods and attributes. Let's look at a
    concrete example.</p>
<p class="Pp"></p>
<pre>  has 'x' =&gt; ( isa =&gt; 'Int', is =&gt; 'ro' );
  has 'y' =&gt; ( isa =&gt; 'Int', is =&gt; 'rw' );
</pre>
<p class="Pp">Internally, the metaclass for
    <span class="Li">&quot;Point&quot;</span> has two Moose::Meta::Attribute.
    There are several methods for getting meta-attributes out of a metaclass,
    one of which is <span class="Li">&quot;get_attribute_list&quot;</span>. This
    method is called on the metaclass object.</p>
<p class="Pp">The <span class="Li">&quot;get_attribute_list&quot;</span> method
    returns a list of attribute names. You can then use
    <span class="Li">&quot;get_attribute&quot;</span> to get the
    Moose::Meta::Attribute object itself.</p>
<p class="Pp">Once you have this meta-attribute object, you can call methods on
    it like this:</p>
<p class="Pp"></p>
<pre>  print $point-&gt;meta-&gt;get_attribute('x')-&gt;type_constraint;
     =&gt; Int
</pre>
<p class="Pp">To add a label to our attributes there are two steps. First, we
    need a new attribute metaclass that can store a label for an attribute.
    Second, we need to create attributes that use that attribute metaclass.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="RECIPE_REVIEW"><a class="permalink" href="#RECIPE_REVIEW">RECIPE
  REVIEW</a></h1>
<p class="Pp">We start by creating a new attribute metaclass.</p>
<p class="Pp"></p>
<pre>  package MyApp::Meta::Attribute::Labeled;
  use Moose;
  extends 'Moose::Meta::Attribute';
</pre>
<p class="Pp">We can subclass a Moose metaclass in the same way that we subclass
    anything else.</p>
<p class="Pp"></p>
<pre>  has label =&gt; (
      is        =&gt; 'rw',
      isa       =&gt; 'Str',
      predicate =&gt; 'has_label',
  );
</pre>
<p class="Pp">Again, this is standard Moose code.</p>
<p class="Pp">Then we need to register our metaclass with Moose:</p>
<p class="Pp"></p>
<pre>  package Moose::Meta::Attribute::Custom::Labeled;
  sub register_implementation { 'MyApp::Meta::Attribute::Labeled' }
</pre>
<p class="Pp">This is a bit of magic that lets us use a short name,
    &quot;Labeled&quot;, when referring to our new metaclass.</p>
<p class="Pp">That was the whole attribute metaclass.</p>
<p class="Pp">Now we start using it.</p>
<p class="Pp"></p>
<pre>  package MyApp::Website;
  use Moose;
  use MyApp::Meta::Attribute::Labeled;
</pre>
<p class="Pp">We have to load the metaclass to use it, just like any Perl
  class.</p>
<p class="Pp">Finally, we use it for an attribute:</p>
<p class="Pp"></p>
<pre>  has url =&gt; (
      metaclass =&gt; 'Labeled',
      is        =&gt; 'rw',
      isa       =&gt; 'Str',
      label     =&gt; &quot;The site's URL&quot;,
  );
</pre>
<p class="Pp">This looks like a normal attribute declaration, except for two
    things, the <span class="Li">&quot;metaclass&quot;</span> and
    <span class="Li">&quot;label&quot;</span> parameters. The
    <span class="Li">&quot;metaclass&quot;</span> parameter tells Moose we want
    to use a custom metaclass for this (one) attribute. The
    <span class="Li">&quot;label&quot;</span> parameter will be stored in the
    meta-attribute object.</p>
<p class="Pp">The reason that we can pass the name
    <span class="Li">&quot;Labeled&quot;</span>, instead of
    <span class="Li">&quot;MyApp::Meta::Attribute::Labeled&quot;</span>, is
    because of the <span class="Li">&quot;register_implementation&quot;</span>
    code we touched on previously.</p>
<p class="Pp">When you pass a metaclass to
    <span class="Li">&quot;has&quot;</span>, it will take the name you provide
    and prefix it with
    <span class="Li">&quot;Moose::Meta::Attribute::Custom::&quot;</span>. Then
    it calls <span class="Li">&quot;register_implementation&quot;</span> in the
    package. In this case, that means Moose ends up calling
    <span class="Li">&quot;Moose::Meta::Attribute::Custom::Labeled::register_implementation&quot;</span>.</p>
<p class="Pp">If this function exists, it should return the <i>real</i>
    metaclass package name. This is exactly what our code does, returning
    <span class="Li">&quot;MyApp::Meta::Attribute::Labeled&quot;</span>. This is
    a little convoluted, and if you don't like it, you can always use the
    fully-qualified name.</p>
<p class="Pp">We can access this meta-attribute and its label like this:</p>
<p class="Pp"></p>
<pre>  $website-&gt;meta-&gt;get_attribute('url')-&gt;label()
  MyApp::Website-&gt;meta-&gt;get_attribute('url')-&gt;label()
</pre>
<p class="Pp">We also have a regular attribute,
    <span class="Li">&quot;name&quot;</span>:</p>
<p class="Pp"></p>
<pre>  has name =&gt; (
      is  =&gt; 'rw',
      isa =&gt; 'Str',
  );
</pre>
<p class="Pp">This is a regular Moose attribute, because we have not specified a
    new metaclass.</p>
<p class="Pp">Finally, we have a <span class="Li">&quot;dump&quot;</span>
    method, which creates a human-readable representation of a
    <span class="Li">&quot;MyApp::Website&quot;</span> object. It will use an
    attribute's label if it has one.</p>
<p class="Pp"></p>
<pre>  sub dump {
      my $self = shift;
      my $meta = $self-&gt;meta;
      my $dump = '';
      for my $attribute ( map { $meta-&gt;get_attribute($_) }
          sort $meta-&gt;get_attribute_list ) {
          if (   $attribute-&gt;isa('MyApp::Meta::Attribute::Labeled')
              &amp;&amp; $attribute-&gt;has_label ) {
              $dump .= $attribute-&gt;label;
          }
</pre>
<p class="Pp">This is a bit of defensive code. We cannot depend on every
    meta-attribute having a label. Even if we define one for every attribute in
    our class, a subclass may neglect to do so. Or a superclass could add an
    attribute without a label.</p>
<p class="Pp">We also check that the attribute has a label using the predicate
    we defined. We could instead make the label
    <span class="Li">&quot;required&quot;</span>. If we have a label, we use it,
    otherwise we use the attribute name:</p>
<p class="Pp"></p>
<pre>          else {
              $dump .= $attribute-&gt;name;
          }
          my $reader = $attribute-&gt;get_read_method;
          $dump .= &quot;: &quot; . $self-&gt;$reader . &quot;\n&quot;;
      }
      return $dump;
  }
</pre>
<p class="Pp">The <span class="Li">&quot;get_read_method&quot;</span> is part of
    the Moose::Meta::Attribute API. It returns the name of a method that can
    read the attribute's value, <i>when called on the real object</i> (don't
    call this on the meta-attribute).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONCLUSION"><a class="permalink" href="#CONCLUSION">CONCLUSION</a></h1>
<p class="Pp">You might wonder why you'd bother with all this. You could just
    hardcode &quot;The Site's URL&quot; in the
    <span class="Li">&quot;dump&quot;</span> method. But we want to avoid
    repetition. If you need the label once, you may need it elsewhere, maybe in
    the <span class="Li">&quot;as_form&quot;</span> method you write next.</p>
<p class="Pp">Associating a label with an attribute just makes sense! The label
    is a piece of information <i>about</i> the attribute.</p>
<p class="Pp">It's also important to realize that this was a trivial example.
    You can make much more powerful metaclasses that <i>do</i> things, as
    opposed to just storing some more information. For example, you could
    implement a metaclass that expires attributes after a certain amount of
    time:</p>
<p class="Pp"></p>
<pre>   has site_cache =&gt; (
       metaclass     =&gt; 'TimedExpiry',
       expires_after =&gt; { hours =&gt; 1 },
       refresh_with  =&gt; sub { get( $_[0]-&gt;url ) },
       isa           =&gt; 'Str',
       is            =&gt; 'ro',
   );
</pre>
<p class="Pp">The sky's the limit!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Stevan Little &lt;stevan.little@iinteractive.com&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
  <li>Shawn M Moore &lt;code@sartak.org&gt;</li>
  <li>&#x05D9;&#x05D5;&#x05D1;&#x05DC; &#x05E7;&#x05D5;&#x05D2;'&#x05DE;&#x05DF;
      (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Florian Ragwitz &lt;rafl@debian.org&gt;</li>
  <li>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</li>
  <li>Chris Prather &lt;chris@prather.org&gt;</li>
  <li>Matt S Trout &lt;mst@shadowcat.co.uk&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2006 by Infinity Interactive,
  Inc.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-11-22</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

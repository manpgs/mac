<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>C(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">C(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">C(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Inline::C - Write Perl Subroutines in C</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><span class="Li">&quot;Inline::C&quot;</span> is a module that
    allows you to write Perl subroutines in C. Since version 0.30 the Inline
    module supports multiple programming languages and each language has its own
    support module. This document describes how to use Inline with the C
    programming language. It also goes a bit into Perl C internals.</p>
<p class="Pp">If you want to start working with programming examples right away,
    check out Inline::C-Cookbook. For more information on Inline in general, see
    Inline.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Usage"><a class="permalink" href="#Usage">Usage</a></h1>
<p class="Pp">You never actually use
    <span class="Li">&quot;Inline::C&quot;</span> directly. It is just a support
    module for using <span class="Li">&quot;Inline.pm&quot;</span> with C. So
    the usage is always:</p>
<p class="Pp"></p>
<pre>
    use Inline C =&gt; ...;
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre>
    bind Inline C =&gt; ...;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="Function_Definitions"><a class="permalink" href="#Function_Definitions">Function
  Definitions</a></h1>
<p class="Pp">The Inline grammar for C recognizes certain function definitions
    (or signatures) in your C code. If a signature is recognized by Inline, then
    it will be available in Perl-space. That is, Inline will generate the
    &quot;glue&quot; necessary to call that function as if it were a Perl
    subroutine. If the signature is not recognized, Inline will simply ignore
    it, with no complaints. It will not be available from Perl-space, although
    it <i>will</i> be available from C-space.</p>
<p class="Pp">Inline looks for ANSI/prototype style function definitions. They
    must be of the form:</p>
<p class="Pp"></p>
<pre>
    return-type function-name ( type-name-pairs ) { ... }
</pre>
<p class="Pp">The most common types are:
    <span class="Li">&quot;int&quot;</span>,
    <span class="Li">&quot;long&quot;</span>,
    <span class="Li">&quot;double&quot;</span>,
    <span class="Li">&quot;char*&quot;</span>, and
    <span class="Li">&quot;SV*&quot;</span>. But you can use any type for which
    Inline can find a typemap. Inline uses the
    <span class="Li">&quot;typemap&quot;</span> file distributed with Perl as
    the default. You can specify more typemaps with the TYPEMAPS configuration
    option.</p>
<p class="Pp">A return type of <span class="Li">&quot;void&quot;</span> may also
    be used. The following are examples of valid function definitions.</p>
<p class="Pp"></p>
<pre>
    int Foo(double num, char* str) {
    void Foo(double num, char* str) {
    void Foo(SV*, ...) {
    long Foo(int i, int j, ...) {
    SV* Foo(void) { # 'void' arg invalid with the ParseRecDescent parser.
                    # Works only with the ParseRegExp parser.
                    # See the section on USING (below).
    SV* Foo() {  # Alternative to specifying 'void' arg. Is valid with
                 # both the ParseRecDescent and ParseRegExp parsers.
</pre>
<p class="Pp">The following definitions would not be recognized:</p>
<p class="Pp"></p>
<pre>
    Foo(int i) {               # no return type
    int Foo(float f) {         # no (default) typemap for float
    int Foo(num, str) double num; char* str; {
</pre>
<p class="Pp">Notice that Inline only looks for function <i>definitions</i>, not
    function <i>prototypes</i>. Definitions are the syntax directly preceding a
    function body. Also Inline does not scan external files, like headers. Only
    the code passed to Inline is used to create bindings; although other
    libraries can linked in, and called from C-space.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="C_Configuration_Options"><a class="permalink" href="#C_Configuration_Options">C
  Configuration Options</a></h1>
<p class="Pp">For information on how to specify Inline configuration options,
    see Inline. This section describes each of the configuration options
    available for C. Most of the options correspond either to MakeMaker or XS
    options of the same name. See ExtUtils::MakeMaker and perlxs.</p>
<section class="Ss">
<h2 class="Ss">AUTO_INCLUDE</h2>
<p class="Pp">Specifies extra statements to automatically included. They will be
    added onto the defaults. A newline char will be automatically added.</p>
<p class="Pp"></p>
<pre>
    use Inline C =&gt; Config =&gt; AUTO_INCLUDE =&gt; '#include &quot;yourheader.h&quot;';
</pre>
</section>
<section class="Ss">
<h2 class="Ss">AUTOWRAP</h2>
<p class="Pp">If you 'ENABLE =&gt; AUTOWRAP', Inline::C will parse function
    declarations (prototype statements) in your C code. For each declaration it
    can bind to, it will create a dummy wrapper that will call the real function
    which may be in an external library. This is a nice convenience for
    functions that would otherwise just require an empty wrapper function.</p>
<p class="Pp">This is similar to the base functionality you get from
    <span class="Li">&quot;h2xs&quot;</span>. It can be very useful for binding
    to external libraries.</p>
</section>
<section class="Ss">
<h2 class="Ss">BOOT</h2>
<p class="Pp">Specifies C code to be executed in the XS BOOT section.
    Corresponds to the XS parameter.</p>
</section>
<section class="Ss">
<h2 class="Ss">CC</h2>
<p class="Pp">Specify which compiler to use.</p>
</section>
<section class="Ss">
<h2 class="Ss">CCFLAGS</h2>
<p class="Pp">Specify compiler flags - same as ExtUtils::MakeMaker's CCFLAGS
    option. Whatever gets specified here replaces the default
    <span class="Li">$Config</span>{ccflags}. Often, you'll want to add an extra
    flag or two without clobbering the default flags in which case you could
    instead use CCFLAGSEX (see below) or, iff Config.pm has already been
  loaded:</p>
<p class="Pp"></p>
<pre>
  use Inline C =&gt; Config =&gt; CCFLAGS =&gt; $Config{ccflags} . &quot; -DXTRA -DTOO&quot;;
</pre>
</section>
<section class="Ss">
<h2 class="Ss">CCFLAGSEX</h2>
<p class="Pp">Extend compiler flags. Sets CCFLAGS to
    <span class="Li">$Config</span>{ccflags} followed by a space, followed by
    the specified value:</p>
<p class="Pp"></p>
<pre>
  use Inline C =&gt; Config =&gt; CCFLAGSEX =&gt; &quot;-DXTRA -DTOO&quot;;
</pre>
</section>
<section class="Ss">
<h2 class="Ss">FILTERS</h2>
<p class="Pp">Allows you to specify a list of source code filters. If more than
    one is requested, be sure to group them with an array ref. The filters can
    either be subroutine references or names of filters provided by the
    supplementary Inline::Filters module.</p>
<p class="Pp">Your source code will be filtered just before it is parsed by
    Inline. The MD5 fingerprint is generated before filtering. Source code
    filters can be used to do things like stripping out POD documentation,
    pre-expanding #include statements or whatever else you please. For
  example:</p>
<p class="Pp"></p>
<pre>
    use Inline C =&gt; DATA =&gt;
               FILTERS =&gt; [Strip_POD =&gt; \&amp;MyFilter =&gt; Preprocess ];
</pre>
<p class="Pp">Filters are invoked in the order specified. See Inline::Filters
    for more information.</p>
</section>
<section class="Ss">
<h2 class="Ss">INC</h2>
<p class="Pp">Specifies an include path to use. Corresponds to the MakeMaker
    parameter. Expects a fully qualified path.</p>
<p class="Pp"></p>
<pre>
    use Inline C =&gt; Config =&gt; INC =&gt; '-I/inc/path';
</pre>
</section>
<section class="Ss">
<h2 class="Ss">LD</h2>
<p class="Pp">Specify which linker to use.</p>
</section>
<section class="Ss">
<h2 class="Ss">LDDLFLAGS</h2>
<p class="Pp">Specify which linker flags to use.</p>
<p class="Pp">NOTE: These flags will completely override the existing flags,
    instead of just adding to them. So if you need to use those too, you must
    respecify them here.</p>
</section>
<section class="Ss">
<h2 class="Ss">LIBS</h2>
<p class="Pp">Specifies external libraries that should be linked into your code.
    Corresponds to the MakeMaker parameter. Provide a fully qualified path with
    the -L switch if the library is in a location where it won't be found
    automatically.</p>
<p class="Pp"></p>
<pre>
    use Inline C =&gt; Config =&gt; LIBS =&gt; '-lyourlib';
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre>
    use Inline C =&gt; Config =&gt; LIBS =&gt; '-L/your/path -lyourlib';
</pre>
</section>
<section class="Ss">
<h2 class="Ss">MAKE</h2>
<p class="Pp">Specify the name of the 'make' utility to use.</p>
</section>
<section class="Ss">
<h2 class="Ss">MYEXTLIB</h2>
<p class="Pp">Specifies a user compiled object that should be linked in.
    Corresponds to the MakeMaker parameter. Expects a fully qualified path.</p>
<p class="Pp"></p>
<pre>
    use Inline C =&gt; Config =&gt; MYEXTLIB =&gt; '/your/path/yourmodule.so';
</pre>
</section>
<section class="Ss">
<h2 class="Ss">OPTIMIZE</h2>
<p class="Pp">This controls the MakeMaker OPTIMIZE setting. By setting this
    value to <span class="Li">'-g'</span>, you can turn on debugging support for
    your Inline extensions. This will allow you to be able to set breakpoints in
    your C code using a debugger like gdb.</p>
</section>
<section class="Ss">
<h2 class="Ss">PREFIX</h2>
<p class="Pp">Specifies a prefix that will be automatically stripped from C
    functions when they are bound to Perl. Useful for creating wrappers for
    shared library API-s, and binding to the original names in Perl. Also useful
    when names conflict with Perl internals. Corresponds to the XS
  parameter.</p>
<p class="Pp"></p>
<pre>
    use Inline C =&gt; Config =&gt; PREFIX =&gt; 'ZLIB_';
</pre>
</section>
<section class="Ss">
<h2 class="Ss">PRE_HEAD</h2>
<p class="Pp">Specifies code that will precede the inclusion of all files
    specified in AUTO_INCLUDE (ie EXTERN.h, perl.h, XSUB.h, INLINE.h and
    anything else that might have been added to AUTO_INCLUDE by the user). If
    the specified value identifies a file, the contents of that file will be
    inserted, otherwise the specified value is inserted.</p>
<p class="Pp"></p>
<pre>
  use Inline C =&gt; Config =&gt; PRE_HEAD =&gt; $code_or_filename;
</pre>
</section>
<section class="Ss">
<h2 class="Ss">TYPEMAPS</h2>
<p class="Pp">Specifies extra typemap files to use. These types will modify the
    behaviour of the C parsing. Corresponds to the MakeMaker parameter. Specify
    either a fully qualified path or a path relative to the cwd (ie relative to
    what the cwd is at the time the script is loaded).</p>
<p class="Pp"></p>
<pre>
    use Inline C =&gt; Config =&gt; TYPEMAPS =&gt; '/your/path/typemap';
</pre>
</section>
<section class="Ss">
<h2 class="Ss">USING</h2>
<p class="Pp">Specifies which parser to use. Default is 'ParseRecDescent', which
    uses the Parse::RecDescent module. The only other option is 'ParseRegExp',
    which uses the Inline::C::ParseRegExp module that ships with Inline.</p>
<p class="Pp"></p>
<pre>
    use Inline C =&gt; Config =&gt; USING =&gt; 'ParseRegExp';
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="C"><a class="permalink" href="#C">C-Perl Bindings</a></h1>
<p class="Pp">This section describes how the
    <span class="Li">&quot;Perl&quot;</span> variables get mapped to
    <span class="Li">&quot;C&quot;</span> variables and back again.</p>
<p class="Pp">First, you need to know how
    <span class="Li">&quot;Perl&quot;</span> passes arguments back and forth to
    subroutines. Basically it uses a stack (also known as the <b>Stack</b>).
    When a sub is called, all of the parenthesized arguments get expanded into a
    list of scalars and pushed onto the <b>Stack</b>. The subroutine then pops
    all of its parameters off of the <b>Stack</b>. When the sub is done, it
    pushes all of its return values back onto the <b>Stack</b>.</p>
<p class="Pp">The <b>Stack</b> is an array of scalars known internally as
    <span class="Li">&quot;SV&quot;</span>'s. The <b>Stack</b> is actually an
    array of <b>pointers to SV</b> or <span class="Li">&quot;SV*&quot;</span>;
    therefore every element of the <b>Stack</b> is natively a
    <span class="Li">&quot;SV*&quot;</span>. For <i>FMTYEWTK</i> about this,
    read <span class="Li">&quot;perldoc perlguts&quot;</span>.</p>
<p class="Pp">So back to variable mapping. XS uses a thing known as
    &quot;typemaps&quot; to turn each <span class="Li">&quot;SV*&quot;</span>
    into a <span class="Li">&quot;C&quot;</span> type and back again. This is
    done through various XS macro calls, casts and the Perl API. See
    <span class="Li">&quot;perldoc perlapi&quot;</span>. XS allows you to define
    your own typemaps as well for fancier non-standard types such as
    <span class="Li">&quot;typedef&quot;</span>-ed structs.</p>
<p class="Pp">Inline uses the default Perl typemap file for its default types.
    This file is called
    <span class="Li">&quot;/usr/local/lib/perl5/5.6.1/ExtUtils/typemap&quot;</span>,
    or something similar, depending on your Perl installation. It has
    definitions for over 40 types, which are automatically used by Inline. (You
    should probably browse this file at least once, just to get an idea of the
    possibilities.)</p>
<p class="Pp">Inline parses your code for these types and generates the XS code
    to map them. The most commonly used types are:</p>
<p class="Pp"></p>
<pre>
 - int
 - long
 - double
 - char*
 - void
 - SV*
</pre>
<p class="Pp">If you need to deal with a type that is not in the defaults, just
    use the generic <span class="Li">&quot;SV*&quot;</span> type in the function
    definition. Then inside your code, do the mapping yourself. Alternatively,
    you can create your own typemap files and specify them using the
    <span class="Li">&quot;TYPEMAPS&quot;</span> configuration option.</p>
<p class="Pp">A return type of <span class="Li">&quot;void&quot;</span> has a
    special meaning to Inline. It means that you plan to push the values back
    onto the <b>Stack</b> yourself. This is what you need to do to return a list
    of values. If you really don't want to return anything (the traditional
    meaning of <span class="Li">&quot;void&quot;</span>) then simply don't push
    anything back.</p>
<p class="Pp">If ellipsis or <span class="Li">&quot;...&quot;</span> is used at
    the end of an argument list, it means that any number of
    <span class="Li">&quot;SV*&quot;</span>s may follow. Again you will need to
    pop the values off of the <span class="Li">&quot;Stack&quot;</span>
    yourself.</p>
<p class="Pp">See &quot;Examples&quot; below.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="The_Inline_Stack_Macros"><a class="permalink" href="#The_Inline_Stack_Macros">The
  Inline Stack Macros</a></h1>
<p class="Pp">When you write Inline C, the following lines are automatically
    prepended to your code (by default):</p>
<p class="Pp"></p>
<pre>
    #include &quot;EXTERN.h&quot;
    #include &quot;perl.h&quot;
    #include &quot;XSUB.h&quot;
    #include &quot;INLINE.h&quot;
</pre>
<p class="Pp">The file <span class="Li">&quot;INLINE.h&quot;</span> defines a
    set of macros that are useful for handling the Perl Stack from your C
    functions.</p>
<dl class="Bl-tag">
  <dt id="Inline_Stack_Vars"><a class="permalink" href="#Inline_Stack_Vars">Inline_Stack_Vars</a></dt>
  <dd>You'll need to use this one, if you want to use the others. It sets up a
      few local variables: <span class="Li">&quot;sp&quot;</span>,
      <span class="Li">&quot;items&quot;</span>,
      <span class="Li">&quot;ax&quot;</span> and
      <span class="Li">&quot;mark&quot;</span>, for use by the other macros.
      It's not important to know what they do, but I mention them to avoid
      possible name conflicts.
    <p class="Pp">NOTE: Since this macro declares variables, you'll need to put
        it with your other variable declarations at the top of your function. It
        must come before any executable statements and before any other
        <span class="Li">&quot;Inline_Stack&quot;</span> macros.</p>
  </dd>
  <dt id="Inline_Stack_Items"><a class="permalink" href="#Inline_Stack_Items">Inline_Stack_Items</a></dt>
  <dd>Returns the number of arguments passed in on the Stack.</dd>
  <dt id="Inline_Stack_Item(i)"><a class="permalink" href="#Inline_Stack_Item(i)">Inline_Stack_Item(i)</a></dt>
  <dd>Refers to a particular <span class="Li">&quot;SV*&quot;</span> in the
      Stack, where <span class="Li">&quot;i&quot;</span> is an index number
      starting from zero. Can be used to get or set the value.</dd>
  <dt id="Inline_Stack_Reset"><a class="permalink" href="#Inline_Stack_Reset">Inline_Stack_Reset</a></dt>
  <dd>Use this before pushing anything back onto the Stack. It resets the
      internal Stack pointer to the beginning of the Stack.</dd>
  <dt id="Inline_Stack_Push(sv)"><a class="permalink" href="#Inline_Stack_Push(sv)">Inline_Stack_Push(sv)</a></dt>
  <dd>Push a return value back onto the Stack. The value must be of type
      <span class="Li">&quot;SV*&quot;</span>.</dd>
  <dt id="Inline_Stack_Done"><a class="permalink" href="#Inline_Stack_Done">Inline_Stack_Done</a></dt>
  <dd>After you have pushed all of your return values, you must call this
    macro.</dd>
  <dt id="Inline_Stack_Return(n)"><a class="permalink" href="#Inline_Stack_Return(n)">Inline_Stack_Return(n)</a></dt>
  <dd>Return <span class="Li">&quot;n&quot;</span> items on the Stack.</dd>
  <dt id="Inline_Stack_Void"><a class="permalink" href="#Inline_Stack_Void">Inline_Stack_Void</a></dt>
  <dd>A special macro to indicate that you really don't want to return anything.
      Same as:
    <p class="Pp"></p>
    <pre>
    Inline_Stack_Return(0);
    </pre>
    <p class="Pp">Please note that this macro actually <b>returns</b> from your
        function.</p>
  </dd>
</dl>
<p class="Pp">Each of these macros is available in 3 different styles to suit
    your coding tastes. The following macros are equivalent.</p>
<p class="Pp"></p>
<pre>
    Inline_Stack_Vars
    inline_stack_vars
    INLINE_STACK_VARS
</pre>
<p class="Pp">All of this functionality is available through XS macro calls as
    well. So why duplicate the functionality? There are a few reasons why I
    decided to offer this set of macros. First, as a convenient way to access
    the Stack. Second, for consistent, self documenting, non-cryptic coding.
    Third, for future compatibility. It occured to me that if a lot of people
    started using XS macros for their C code, the interface might break under
    Perl6. By using this set, hopefully I will be able to insure future
    compatibility of argument handling.</p>
<p class="Pp">Of course, if you use the rest of the Perl API, your code will
    most likely break under Perl6. So this is not a 100% guarantee. But since
    argument handling is the most common interface you're likely to use, it
    seemed like a wise thing to do.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Writing_C_Subroutines"><a class="permalink" href="#Writing_C_Subroutines">Writing
  C Subroutines</a></h1>
<p class="Pp">The definitions of your C functions will fall into one of the
    following four categories. For each category there are special
    considerations.</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>
    <pre>
    int Foo(int arg1, char* arg2, SV* arg3) {
    </pre>
    <p class="Pp">This is the simplest case. You have a non
        <span class="Li">&quot;void&quot;</span> return type and a fixed length
        argument list. You don't need to worry about much. All the conversions
        will happen automatically.</p>
  </dd>
  <dt>2.</dt>
  <dd>
    <pre>
    void Foo(int arg1, char* arg2, SV* arg3) {
    </pre>
    <p class="Pp">In this category you have a
        <span class="Li">&quot;void&quot;</span> return type. This means that
        either you want to return nothing, or that you want to return a list. In
        the latter case you'll need to push values onto the <b>Stack</b>
        yourself. There are a few Inline macros that make this easy. Code
        something like this:</p>
    <p class="Pp"></p>
    <pre>
    int i, max; SV* my_sv[10];
    Inline_Stack_Vars;
    Inline_Stack_Reset;
    for (i = 0; i &lt; max; i++)
      Inline_Stack_Push(my_sv[i]);
    Inline_Stack_Done;
    </pre>
    <p class="Pp">After resetting the Stack pointer, this code pushes a series
        of return values. At the end it uses
        <span class="Li">&quot;Inline_Stack_Done&quot;</span> to mark the end of
        the return stack.</p>
    <p class="Pp">If you really want to return nothing, then don't use the
        <span class="Li">&quot;Inline_Stack_&quot;</span> macros. If you must
        use them, then set use
        <span class="Li">&quot;Inline_Stack_Void&quot;</span> at the end of your
        function.</p>
  </dd>
  <dt>3.</dt>
  <dd>
    <pre>
    char* Foo(SV* arg1, ...) {
    </pre>
    <p class="Pp">In this category you have an unfixed number of arguments. This
        means that you'll have to pop values off the <b>Stack</b> yourself. Do
        it like this:</p>
    <p class="Pp"></p>
    <pre>
    int i;
    Inline_Stack_Vars;
    for (i = 0; i &lt; Inline_Stack_Items; i++)
      handle_sv(Inline_Stack_Item(i));
    </pre>
    <p class="Pp">The return type of
        <span class="Li">Inline_Stack_Item(i)</span> is
        <span class="Li">&quot;SV*&quot;</span>.</p>
  </dd>
  <dt>4.</dt>
  <dd>
    <pre>
    void* Foo(SV* arg1, ...) {
    </pre>
    <p class="Pp">In this category you have both a
        <span class="Li">&quot;void&quot;</span> return type and an unfixed
        number of arguments. Just combine the techniques from Categories 3 and
        4.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Examples"><a class="permalink" href="#Examples">Examples</a></h1>
<p class="Pp">Here are a few examples. Each one is a complete program that you
    can try running yourself. For many more examples see Inline::C-Cookbook.</p>
<section class="Ss">
<h2 class="Ss" id="Example__1_"><a class="permalink" href="#Example__1_">Example
  #1 - Greetings</a></h2>
<p class="Pp">This example will take one string argument (a name) and print a
    greeting. The function is called with a string and with a number. In the
    second case the number is forced to a string.</p>
<p class="Pp">Notice that you do not need to <span class="Li">&quot;#include
    &lt;stdio.h&quot;</span>&gt;. The <span class="Li">&quot;perl.h&quot;</span>
    header file which gets included by default, automatically loads the standard
    C header files for you.</p>
<p class="Pp"></p>
<pre>
    use Inline C;
    greet('Ingy');
    greet(42);
    __END__
    __C__
    void greet(char* name) {
      printf(&quot;Hello %s!\n&quot;, name);
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Example__2_"><a class="permalink" href="#Example__2_">Example
  #2 - and Salutations</a></h2>
<p class="Pp">This is similar to the last example except that the name is passed
    in as a <span class="Li">&quot;SV*&quot;</span> (pointer to Scalar Value)
    rather than a string (<span class="Li">&quot;char*&quot;</span>). That means
    we need to convert the <span class="Li">&quot;SV&quot;</span> to a string
    ourselves. This is accomplished using the
    <span class="Li">&quot;SvPVX&quot;</span> function which is part of the
    <span class="Li">&quot;Perl&quot;</span> internal API. See
    <span class="Li">&quot;perldoc perlapi&quot;</span> for more info.</p>
<p class="Pp">One problem is that <span class="Li">&quot;SvPVX&quot;</span>
    doesn't automatically convert strings to numbers, so we get a little
    surprise when we try to greet <span class="Li">42</span>. The program
    segfaults, a common occurence when delving into the guts of Perl.</p>
<p class="Pp"></p>
<pre>
    use Inline C;
    greet('Ingy');
    greet(42);
    __END__
    __C__
    void greet(SV* sv_name) {
      printf(&quot;Hello %s!\n&quot;, SvPVX(sv_name));
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Example__3_"><a class="permalink" href="#Example__3_">Example
  #3 - Fixing the problem</a></h2>
<p class="Pp">We can fix the problem in Example #2 by using the
    <span class="Li">&quot;SvPV&quot;</span> function instead. This function
    will stringify the <span class="Li">&quot;SV&quot;</span> if it does not
    contain a string. <span class="Li">&quot;SvPV&quot;</span> returns the
    length of the string as it's second parameter. Since we don't care about the
    length, we can just put <span class="Li">&quot;PL_na&quot;</span> there,
    which is a special variable designed for that purpose.</p>
<p class="Pp"></p>
<pre>
    use Inline C;
    greet('Ingy');
    greet(42);
    __END__
    __C__
    void greet(SV* sv_name) {
      printf(&quot;Hello %s!\n&quot;, SvPV(sv_name, PL_na));
    }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">For general information about Inline see Inline.</p>
<p class="Pp">For sample programs using Inline with C see
  Inline::C-Cookbook.</p>
<p class="Pp">For information on supported languages and platforms see
    Inline-Support.</p>
<p class="Pp">For information on writing your own Inline Language Support
    Module, see Inline-API.</p>
<p class="Pp">Inline's mailing list is inline@perl.org</p>
<p class="Pp">To subscribe, send email to inline-subscribe@perl.org</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS_AND_DEFICIENCIES"><a class="permalink" href="#BUGS_AND_DEFICIENCIES">BUGS
  AND DEFICIENCIES</a></h1>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>If you use C function names that happen to be used internally by Perl, you
      will get a load error at run time. There is currently no functionality to
      prevent this or to warn you. For now, a list of Perl's internal symbols is
      packaged in the Inline module distribution under the filename
      <span class="Li">'symbols.perl'</span>. Avoid using these in your
    code.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Brian Ingerson &lt;INGY@cpan.org&gt;</p>
<p class="Pp">Sisyphus &lt;sisyphus@cpan.org&gt; fixed some bugs and is current
    co-maintainer.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 2000-2002. Brian Ingerson.</p>
<p class="Pp">Copyright (c) 2008, 2010-2012. Sisyphus.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">See http://www.perl.com/perl/misc/Artistic.html</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2012-11-19</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>URI::Escape(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">URI::Escape(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">URI::Escape(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">URI::Escape - Percent-encode and percent-decode unsafe
  characters</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
 use URI::Escape;
 $safe = uri_escape(&quot;10% is enough\n&quot;);
 $verysafe = uri_escape(&quot;foo&quot;, &quot;\0-\377&quot;);
 $str  = uri_unescape($safe);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module provides functions to percent-encode and
    percent-decode URI strings as defined by RFC 3986. Percent-encoding URI's is
    informally called &quot;URI escaping&quot;. This is the terminology used by
    this module, which predates the formalization of the terms by the RFC by
    several years.</p>
<p class="Pp">A URI consists of a restricted set of characters. The restricted
    set of characters consists of digits, letters, and a few graphic symbols
    chosen from those common to most of the character encodings and input
    facilities available to Internet users. They are made up of the
    &quot;unreserved&quot; and &quot;reserved&quot; character sets as defined in
    RFC 3986.</p>
<p class="Pp"></p>
<pre>
   unreserved    = ALPHA / DIGIT / &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot;
   reserved      = &quot;:&quot; / &quot;/&quot; / &quot;?&quot; / &quot;#&quot; / &quot;[&quot; / &quot;]&quot; / &quot;@&quot;
                   &quot;!&quot; / &quot;$&quot; / &quot;&amp;&quot; / &quot;'&quot; / &quot;(&quot; / &quot;)&quot;
                 / &quot;*&quot; / &quot;+&quot; / &quot;,&quot; / &quot;;&quot; / &quot;=&quot;
</pre>
<p class="Pp">In addition, any byte (octet) can be represented in a URI by an
    escape sequence: a triplet consisting of the character &quot;%&quot;
    followed by two hexadecimal digits. A byte can also be represented directly
    by a character, using the US-ASCII character for that octet.</p>
<p class="Pp">Some of the characters are <i>reserved</i> for use as delimiters
    or as part of certain URI components. These must be escaped if they are to
    be treated as ordinary data. Read RFC 3986 for further details.</p>
<p class="Pp">The functions provided (and exported by default) from this module
    are:</p>
<dl class="Bl-tag">
  <dt id="uri_escape("><a class="permalink" href="#uri_escape(">uri_escape(
    $string )</a></dt>
  <dd></dd>
  <dt id="uri_escape(~2"><a class="permalink" href="#uri_escape(~2">uri_escape(
    $string, $unsafe )</a></dt>
  <dd>Replaces each unsafe character in the <span class="Li">$string</span> with
      the corresponding escape sequence and returns the result. The
      <span class="Li">$string</span> argument should be a string of bytes. The
      <b>uri_escape()</b> function will croak if given a characters with code
      above 255. Use <b>uri_escape_utf8()</b> if you know you have such chars
      or/and want chars in the 128 .. 255 range treated as UTF-8.
    <p class="Pp">The <b>uri_escape()</b> function takes an optional second
        argument that overrides the set of characters that are to be escaped.
        The set is specified as a string that can be used in a regular
        expression character class (between [ ]). E.g.:</p>
    <p class="Pp"></p>
    <pre>
  &quot;\x00-\x1f\x7f-\xff&quot;          # all control and hi-bit characters
  &quot;a-z&quot;                         # all lower case characters
  &quot;^A-Za-z&quot;                     # everything not a letter
    </pre>
    <p class="Pp">The default set of characters to be escaped is all those which
        are <i>not</i> part of the
        <span class="Li">&quot;unreserved&quot;</span> character class shown
        above as well as the reserved characters. I.e. the default is:</p>
    <p class="Pp"></p>
    <pre>
    &quot;^A-Za-z0-9\-\._~&quot;
    </pre>
  </dd>
  <dt id="uri_escape_utf8("><a class="permalink" href="#uri_escape_utf8(">uri_escape_utf8(
    $string )</a></dt>
  <dd></dd>
  <dt id="uri_escape_utf8(~2"><a class="permalink" href="#uri_escape_utf8(~2">uri_escape_utf8(
    $string, $unsafe )</a></dt>
  <dd>Works like <b>uri_escape()</b>, but will encode chars as UTF-8 before
      escaping them. This makes this function able to deal with characters with
      code above 255 in <span class="Li">$string</span>. Note that chars in the
      128 .. 255 range will be escaped differently by this function compared to
      what <b>uri_escape()</b> would. For chars in the 0 .. 127 range there is
      no difference.
    <p class="Pp">Equivalent to:</p>
    <p class="Pp"></p>
    <pre>
    utf8::encode($string);
    my $uri = uri_escape($string);
    </pre>
    <p class="Pp">Note: JavaScript has a function called <b>escape()</b> that
        produces the sequence &quot;%uXXXX&quot; for chars in the 256 .. 65535
        range. This function has really nothing to do with URI escaping but some
        folks got confused since it &quot;does the right thing&quot; in the 0 ..
        255 range. Because of this you sometimes see &quot;URIs&quot; with these
        kind of escapes. The JavaScript <b>encodeURIComponent()</b> function is
        similar to <b>uri_escape_utf8()</b>.</p>
  </dd>
  <dt id="uri_unescape($string,...)"><a class="permalink" href="#uri_unescape($string,...)">uri_unescape($string,...)</a></dt>
  <dd>Returns a string with each <span class="Li">%XX</span> sequence replaced
      with the actual byte (octet).
    <p class="Pp">This does the same as:</p>
    <p class="Pp"></p>
    <pre>
   $string =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
    </pre>
    <p class="Pp">but does not modify the string in-place as this RE would.
        Using the <b>uri_unescape()</b> function instead of the RE might make
        the code look cleaner and is a few characters less to type.</p>
    <p class="Pp">In a simple benchmark test I did, calling the function
        (instead of the inline RE above) if a few chars were unescaped was
        something like 40% slower, and something like 700% slower if none were.
        If you are going to unescape a lot of times it might be a good idea to
        inline the RE.</p>
    <p class="Pp">If the <b>uri_unescape()</b> function is passed multiple
        strings, then each one is returned unescaped.</p>
  </dd>
</dl>
<p class="Pp">The module can also export the <span class="Li">%escapes</span>
    hash, which contains the mapping from all 256 bytes to the corresponding
    escape codes. Lookup in this hash is faster than evaluating
    <span class="Li">&quot;sprintf(&quot;%%%02X&quot;, ord($byte))&quot;</span>
    each time.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">URI</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 1995-2004 Gisle Aas.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-01-09</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

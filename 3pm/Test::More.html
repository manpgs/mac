<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Test::More(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Test::More(3pm)</td>
    <td class="head-vol"><a href=".">Perl Programmers Reference Guide</a></td>
    <td class="head-rtitle">Test::More(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Test::More - yet another framework for writing test scripts</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  use Test::More tests =&gt; 23;
  # or
  use Test::More skip_all =&gt; $reason;
  # or
  use Test::More;   # see done_testing()
  require_ok( 'Some::Module' );
  # Various ways to say &quot;ok&quot;
  ok($got eq $expected, $test_name);
  is  ($got, $expected, $test_name);
  isnt($got, $expected, $test_name);
  # Rather than print STDERR &quot;# here's what went wrong\n&quot;
  diag(&quot;here's what went wrong&quot;);
  like  ($got, qr/expected/, $test_name);
  unlike($got, qr/expected/, $test_name);
  cmp_ok($got, '==', $expected, $test_name);
  is_deeply($got_complex_structure, $expected_complex_structure, $test_name);
  SKIP: {
      skip $why, $how_many unless $have_some_feature;
      ok( foo(),       $test_name );
      is( foo(42), 23, $test_name );
  };
  TODO: {
      local $TODO = $why;
      ok( foo(),       $test_name );
      is( foo(42), 23, $test_name );
  };
  can_ok($module, @methods);
  isa_ok($object, $class);
  pass($test_name);
  fail($test_name);
  BAIL_OUT($why);
  # UNIMPLEMENTED!!!
  my @status = Test::More::status;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><b>STOP!</b> If you're just getting started writing tests, have a
    look at Test2::Suite first.</p>
<p class="Pp">This is a drop in replacement for Test::Simple which you can
    switch to once you get the hang of basic testing.</p>
<p class="Pp">The purpose of this module is to provide a wide range of testing
    utilities. Various ways to say &quot;ok&quot; with better diagnostics,
    facilities to skip tests, test future features and compare complicated data
    structures. While you can do almost anything with a simple
    <span class="Li">&quot;ok()&quot;</span> function, it doesn't provide good
    diagnostic output.</p>
<section class="Ss">
<h2 class="Ss" id="I_love_it_when_a_plan_comes_together"><a class="permalink" href="#I_love_it_when_a_plan_comes_together">I
  love it when a plan comes together</a></h2>
<p class="Pp">Before anything else, you need a testing plan. This basically
    declares how many tests your script is going to run to protect against
    premature failure.</p>
<p class="Pp">The preferred way to do this is to declare a plan when you
    <span class="Li">&quot;use Test::More&quot;</span>.</p>
<p class="Pp"></p>
<pre>  use Test::More tests =&gt; 23;
</pre>
<p class="Pp">There are cases when you will not know beforehand how many tests
    your script is going to run. In this case, you can declare your tests at the
    end.</p>
<p class="Pp"></p>
<pre>  use Test::More;
  ... run your tests ...
  done_testing( $number_of_tests_run );
</pre>
<p class="Pp"><b>NOTE</b> <span class="Li">&quot;done_testing()&quot;</span>
    should never be called in an <span class="Li">&quot;END { ... }&quot;</span>
    block.</p>
<p class="Pp">Sometimes you really don't know how many tests were run, or it's
    too difficult to calculate. In which case you can leave off
    <span class="Li">$number_of_tests_run</span>.</p>
<p class="Pp">In some cases, you'll want to completely skip an entire testing
    script.</p>
<p class="Pp"></p>
<pre>  use Test::More skip_all =&gt; $skip_reason;
</pre>
<p class="Pp">Your script will declare a skip with the reason why you skipped
    and exit immediately with a zero (success). See Test::Harness for
  details.</p>
<p class="Pp">If you want to control what functions Test::More will export, you
    have to use the 'import' option. For example, to import everything but
    'fail', you'd do:</p>
<p class="Pp"></p>
<pre>  use Test::More tests =&gt; 23, import =&gt; ['!fail'];
</pre>
<p class="Pp">Alternatively, you can use the
    <span class="Li">&quot;plan()&quot;</span> function. Useful for when you
    have to calculate the number of tests.</p>
<p class="Pp"></p>
<pre>  use Test::More;
  plan tests =&gt; keys %Stuff * 3;
</pre>
<p class="Pp">or for deciding between running the tests at all:</p>
<p class="Pp"></p>
<pre>  use Test::More;
  if( $^O eq 'MacOS' ) {
      plan skip_all =&gt; 'Test irrelevant on MacOS';
  }
  else {
      plan tests =&gt; 42;
  }
</pre>
<dl class="Bl-tag">
  <dt id="done_testing"><a class="permalink" href="#done_testing"><b>done_testing</b></a></dt>
  <dd>
    <pre>    done_testing();
    done_testing($number_of_tests);
    </pre>
    <p class="Pp">If you don't know how many tests you're going to run, you can
        issue the plan when you're done running tests.</p>
    <p class="Pp"><span class="Li">$number_of_tests</span> is the same as
        <span class="Li">&quot;plan()&quot;</span>, it's the number of tests you
        expected to run. You can omit this, in which case the number of tests
        you ran doesn't matter, just the fact that your tests ran to
      conclusion.</p>
    <p class="Pp">This is safer than and replaces the &quot;no_plan&quot;
      plan.</p>
    <p class="Pp"><b>Note:</b> You must never put
        <span class="Li">&quot;done_testing()&quot;</span> inside an
        <span class="Li">&quot;END { ... }&quot;</span> block. The plan is there
        to ensure your test does not exit before testing has completed. If you
        use an END block you completely bypass this protection.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Test_names"><a class="permalink" href="#Test_names">Test
  names</a></h2>
<p class="Pp">By convention, each test is assigned a number in order. This is
    largely done automatically for you. However, it's often very useful to
    assign a name to each test. Which would you rather see:</p>
<p class="Pp"></p>
<pre>  ok 4
  not ok 5
  ok 6
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre>  ok 4 - basic multi-variable
  not ok 5 - simple exponential
  ok 6 - force == mass * acceleration
</pre>
<p class="Pp">The later gives you some idea of what failed. It also makes it
    easier to find the test in your script, simply search for &quot;simple
    exponential&quot;.</p>
<p class="Pp">All test functions take a name argument. It's optional, but highly
    suggested that you use it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="I'm_ok,_you're_not_ok."><a class="permalink" href="#I'm_ok,_you're_not_ok.">I'm
  ok, you're not ok.</a></h2>
<p class="Pp">The basic purpose of this module is to print out either &quot;ok
    #&quot; or &quot;not ok #&quot; depending on if a given test succeeded or
    failed. Everything else is just gravy.</p>
<p class="Pp">All of the following print &quot;ok&quot; or &quot;not ok&quot;
    depending on if the test succeeded or failed. They all also return true or
    false, respectively.</p>
<dl class="Bl-tag">
  <dt id="ok"><a class="permalink" href="#ok"><b>ok</b></a></dt>
  <dd>
    <pre>  ok($got eq $expected, $test_name);
    </pre>
    <p class="Pp">This simply evaluates any expression
        (<span class="Li">&quot;$got eq $expected&quot;</span> is just a simple
        example) and uses that to determine if the test succeeded or failed. A
        true expression passes, a false one fails. Very simple.</p>
    <p class="Pp">For example:</p>
    <p class="Pp"></p>
    <pre>    ok( $exp{9} == 81,                   'simple exponential' );
    ok( Film-&gt;can('db_Main'),            'set_db()' );
    ok( $p-&gt;tests == 4,                  'saw tests' );
    ok( !grep(!defined $_, @items),      'all items defined' );
    </pre>
    <p class="Pp">(Mnemonic: &quot;This is ok.&quot;)</p>
    <p class="Pp"><span class="Li">$test_name</span> is a very short description
        of the test that will be printed out. It makes it very easy to find a
        test in your script when it fails and gives others an idea of your
        intentions. <span class="Li">$test_name</span> is optional, but we
        <b>very</b> strongly encourage its use.</p>
    <p class="Pp">Should an <span class="Li">&quot;ok()&quot;</span> fail, it
        will produce some diagnostics:</p>
    <p class="Pp"></p>
    <pre>    not ok 18 - sufficient mucus
    #   Failed test 'sufficient mucus'
    #   in foo.t at line 42.
    </pre>
    <p class="Pp">This is the same as Test::Simple's
        <span class="Li">&quot;ok()&quot;</span> routine.</p>
  </dd>
  <dt id="is"><a class="permalink" href="#is"><b>is</b></a></dt>
  <dd></dd>
  <dt id="isnt"><a class="permalink" href="#isnt"><b>isnt</b></a></dt>
  <dd>
    <pre>  is  ( $got, $expected, $test_name );
  isnt( $got, $expected, $test_name );
    </pre>
    <p class="Pp">Similar to <span class="Li">&quot;ok()&quot;</span>,
        <span class="Li">&quot;is()&quot;</span> and
        <span class="Li">&quot;isnt()&quot;</span> compare their two arguments
        with <span class="Li">&quot;eq&quot;</span> and
        <span class="Li">&quot;ne&quot;</span> respectively and use the result
        of that to determine if the test succeeded or failed. So these:</p>
    <p class="Pp"></p>
    <pre>    # Is the ultimate answer 42?
    is( ultimate_answer(), 42,          &quot;Meaning of Life&quot; );
    # $foo isn't empty
    isnt( $foo, '',     &quot;Got some foo&quot; );
    </pre>
    <p class="Pp">are similar to these:</p>
    <p class="Pp"></p>
    <pre>    ok( ultimate_answer() eq 42,        &quot;Meaning of Life&quot; );
    ok( $foo ne '',     &quot;Got some foo&quot; );
    </pre>
    <p class="Pp"><span class="Li">&quot;undef&quot;</span> will only ever match
        <span class="Li">&quot;undef&quot;</span>. So you can test a value
        against <span class="Li">&quot;undef&quot;</span> like this:</p>
    <p class="Pp"></p>
    <pre>    is($not_defined, undef, &quot;undefined as expected&quot;);
    </pre>
    <p class="Pp">(Mnemonic: &quot;This is that.&quot; &quot;This isn't
        that.&quot;)</p>
    <p class="Pp">So why use these? They produce better diagnostics on failure.
        <span class="Li">&quot;ok()&quot;</span> cannot know what you are
        testing for (beyond the name), but
        <span class="Li">&quot;is()&quot;</span> and
        <span class="Li">&quot;isnt()&quot;</span> know what the test was and
        why it failed. For example this test:</p>
    <p class="Pp"></p>
    <pre>    my $foo = 'waffle';  my $bar = 'yarblokos';
    is( $foo, $bar,   'Is foo the same as bar?' );
    </pre>
    <p class="Pp">Will produce something like this:</p>
    <p class="Pp"></p>
    <pre>    not ok 17 - Is foo the same as bar?
    #   Failed test 'Is foo the same as bar?'
    #   in foo.t at line 139.
    #          got: 'waffle'
    #     expected: 'yarblokos'
    </pre>
    <p class="Pp">So you can figure out what went wrong without rerunning the
        test.</p>
    <p class="Pp">You are encouraged to use
        <span class="Li">&quot;is()&quot;</span> and
        <span class="Li">&quot;isnt()&quot;</span> over
        <span class="Li">&quot;ok()&quot;</span> where possible, however do not
        be tempted to use them to find out if something is true or false!</p>
    <p class="Pp"></p>
    <pre>  # XXX BAD!
  is( exists $brooklyn{tree}, 1, 'A tree grows in Brooklyn' );
    </pre>
    <p class="Pp">This does not check if <span class="Li">&quot;exists
        $brooklyn{tree}&quot;</span> is true, it checks if it returns 1. Very
        different. Similar caveats exist for false and 0. In these cases, use
        <span class="Li">&quot;ok()&quot;</span>.</p>
    <p class="Pp"></p>
    <pre>  ok( exists $brooklyn{tree},    'A tree grows in Brooklyn' );
    </pre>
    <p class="Pp">A simple call to <span class="Li">&quot;isnt()&quot;</span>
        usually does not provide a strong test but there are cases when you
        cannot say much more about a value than that it is different from some
        other value:</p>
    <p class="Pp"></p>
    <pre>  new_ok $obj, &quot;Foo&quot;;
  my $clone = $obj-&gt;clone;
  isa_ok $obj, &quot;Foo&quot;, &quot;Foo-&gt;clone&quot;;
  isnt $obj, $clone, &quot;clone() produces a different object&quot;;
    </pre>
    <p class="Pp">For those grammatical pedants out there, there's an
        <span class="Li">&quot;isn't()&quot;</span> function which is an alias
        of <span class="Li">&quot;isnt()&quot;</span>.</p>
  </dd>
  <dt id="like"><a class="permalink" href="#like"><b>like</b></a></dt>
  <dd>
    <pre>  like( $got, qr/expected/, $test_name );
    </pre>
    <p class="Pp">Similar to <span class="Li">&quot;ok()&quot;</span>,
        <span class="Li">&quot;like()&quot;</span> matches
        <span class="Li">$got</span> against the regex
        <span class="Li">&quot;qr/expected/&quot;</span>.</p>
    <p class="Pp">So this:</p>
    <p class="Pp"></p>
    <pre>    like($got, qr/expected/, 'this is like that');
    </pre>
    <p class="Pp">is similar to:</p>
    <p class="Pp"></p>
    <pre>    ok( $got =~ m/expected/, 'this is like that');
    </pre>
    <p class="Pp">(Mnemonic &quot;This is like that&quot;.)</p>
    <p class="Pp">The second argument is a regular expression. It may be given
        as a regex reference (i.e. <span class="Li">&quot;qr//&quot;</span>) or
        (for better compatibility with older perls) as a string that looks like
        a regex (alternative delimiters are currently not supported):</p>
    <p class="Pp"></p>
    <pre>    like( $got, '/expected/', 'this is like that' );
    </pre>
    <p class="Pp">Regex options may be placed on the end
        (<span class="Li">'/expected/i'</span>).</p>
    <p class="Pp">Its advantages over <span class="Li">&quot;ok()&quot;</span>
        are similar to that of <span class="Li">&quot;is()&quot;</span> and
        <span class="Li">&quot;isnt()&quot;</span>. Better diagnostics on
        failure.</p>
  </dd>
  <dt id="unlike"><a class="permalink" href="#unlike"><b>unlike</b></a></dt>
  <dd>
    <pre>  unlike( $got, qr/expected/, $test_name );
    </pre>
    <p class="Pp">Works exactly as <span class="Li">&quot;like()&quot;</span>,
        only it checks if <span class="Li">$got</span> <b>does not</b> match the
        given pattern.</p>
  </dd>
  <dt id="cmp_ok"><a class="permalink" href="#cmp_ok"><b>cmp_ok</b></a></dt>
  <dd>
    <pre>  cmp_ok( $got, $op, $expected, $test_name );
    </pre>
    <p class="Pp">Halfway between <span class="Li">&quot;ok()&quot;</span> and
        <span class="Li">&quot;is()&quot;</span> lies
        <span class="Li">&quot;cmp_ok()&quot;</span>. This allows you to compare
        two arguments using any binary perl operator. The test passes if the
        comparison is true and fails otherwise.</p>
    <p class="Pp"></p>
    <pre>    # ok( $got eq $expected );
    cmp_ok( $got, 'eq', $expected, 'this eq that' );
    # ok( $got == $expected );
    cmp_ok( $got, '==', $expected, 'this == that' );
    # ok( $got &amp;&amp; $expected );
    cmp_ok( $got, '&amp;&amp;', $expected, 'this &amp;&amp; that' );
    ...etc...
    </pre>
    <p class="Pp">Its advantage over <span class="Li">&quot;ok()&quot;</span> is
        when the test fails you'll know what <span class="Li">$got</span> and
        <span class="Li">$expected</span> were:</p>
    <p class="Pp"></p>
    <pre>    not ok 1
    #   Failed test in foo.t at line 12.
    #     '23'
    #         &amp;&amp;
    #     undef
    </pre>
    <p class="Pp">It's also useful in those cases where you are comparing
        numbers and <span class="Li">&quot;is()&quot;</span>'s use of
        <span class="Li">&quot;eq&quot;</span> will interfere:</p>
    <p class="Pp"></p>
    <pre>    cmp_ok( $big_hairy_number, '==', $another_big_hairy_number );
    </pre>
    <p class="Pp">It's especially useful when comparing greater-than or
        smaller-than relation between values:</p>
    <p class="Pp"></p>
    <pre>    cmp_ok( $some_value, '&lt;=', $upper_limit );
    </pre>
  </dd>
  <dt id="can_ok"><a class="permalink" href="#can_ok"><b>can_ok</b></a></dt>
  <dd>
    <pre>  can_ok($module, @methods);
  can_ok($object, @methods);
    </pre>
    <p class="Pp">Checks to make sure the <span class="Li">$module</span> or
        <span class="Li">$object</span> can do these
        <span class="Li">@methods</span> (works with functions, too).</p>
    <p class="Pp"></p>
    <pre>    can_ok('Foo', qw(this that whatever));
    </pre>
    <p class="Pp">is almost exactly like saying:</p>
    <p class="Pp"></p>
    <pre>    ok( Foo-&gt;can('this') &amp;&amp; 
        Foo-&gt;can('that') &amp;&amp; 
        Foo-&gt;can('whatever') 
      );
    </pre>
    <p class="Pp">only without all the typing and with a better interface. Handy
        for quickly testing an interface.</p>
    <p class="Pp">No matter how many <span class="Li">@methods</span> you check,
        a single <span class="Li">&quot;can_ok()&quot;</span> call counts as one
        test. If you desire otherwise, use:</p>
    <p class="Pp"></p>
    <pre>    foreach my $meth (@methods) {
        can_ok('Foo', $meth);
    }
    </pre>
  </dd>
  <dt id="isa_ok"><a class="permalink" href="#isa_ok"><b>isa_ok</b></a></dt>
  <dd>
    <pre>  isa_ok($object,   $class, $object_name);
  isa_ok($subclass, $class, $object_name);
  isa_ok($ref,      $type,  $ref_name);
    </pre>
    <p class="Pp">Checks to see if the given
        <span class="Li">&quot;$object-&gt;isa($class)&quot;</span>. Also checks
        to make sure the object was defined in the first place. Handy for this
        sort of thing:</p>
    <p class="Pp"></p>
    <pre>    my $obj = Some::Module-&gt;new;
    isa_ok( $obj, 'Some::Module' );
    </pre>
    <p class="Pp">where you'd otherwise have to write</p>
    <p class="Pp"></p>
    <pre>    my $obj = Some::Module-&gt;new;
    ok( defined $obj &amp;&amp; $obj-&gt;isa('Some::Module') );
    </pre>
    <p class="Pp">to safeguard against your test script blowing up.</p>
    <p class="Pp">You can also test a class, to make sure that it has the right
        ancestor:</p>
    <p class="Pp"></p>
    <pre>    isa_ok( 'Vole', 'Rodent' );
    </pre>
    <p class="Pp">It works on references, too:</p>
    <p class="Pp"></p>
    <pre>    isa_ok( $array_ref, 'ARRAY' );
    </pre>
    <p class="Pp">The diagnostics of this test normally just refer to 'the
        object'. If you'd like them to be more specific, you can supply an
        <span class="Li">$object_name</span> (for example 'Test customer').</p>
  </dd>
  <dt id="new_ok"><a class="permalink" href="#new_ok"><b>new_ok</b></a></dt>
  <dd>
    <pre>  my $obj = new_ok( $class );
  my $obj = new_ok( $class =&gt; \@args );
  my $obj = new_ok( $class =&gt; \@args, $object_name );
    </pre>
    <p class="Pp">A convenience function which combines creating an object and
        calling <span class="Li">&quot;isa_ok()&quot;</span> on that object.</p>
    <p class="Pp">It is basically equivalent to:</p>
    <p class="Pp"></p>
    <pre>    my $obj = $class-&gt;new(@args);
    isa_ok $obj, $class, $object_name;
    </pre>
    <p class="Pp">If <span class="Li">@args</span> is not given, an empty list
        will be used.</p>
    <p class="Pp">This function only works on
        <span class="Li">&quot;new()&quot;</span> and it assumes
        <span class="Li">&quot;new()&quot;</span> will return just a single
        object which isa <span class="Li">$class</span>.</p>
  </dd>
  <dt id="subtest"><a class="permalink" href="#subtest"><b>subtest</b></a></dt>
  <dd>
    <pre>    subtest $name =&gt; \&amp;code, @args;
    </pre>
    <p class="Pp"><span class="Li">&quot;subtest()&quot;</span> runs the
        &amp;code as its own little test with its own plan and its own result.
        The main test counts this as a single test using the result of the whole
        subtest to determine if its ok or not ok.</p>
    <p class="Pp">For example...</p>
    <p class="Pp"></p>
    <pre>  use Test::More tests =&gt; 3;
 
  pass(&quot;First test&quot;);
  subtest 'An example subtest' =&gt; sub {
      plan tests =&gt; 2;
      pass(&quot;This is a subtest&quot;);
      pass(&quot;So is this&quot;);
  };
  pass(&quot;Third test&quot;);
    </pre>
    <p class="Pp">This would produce.</p>
    <p class="Pp"></p>
    <pre>  1..3
  ok 1 - First test
      # Subtest: An example subtest
      1..2
      ok 1 - This is a subtest
      ok 2 - So is this
  ok 2 - An example subtest
  ok 3 - Third test
    </pre>
    <p class="Pp">A subtest may call
        <span class="Li">&quot;skip_all&quot;</span>. No tests will be run, but
        the subtest is considered a skip.</p>
    <p class="Pp"></p>
    <pre>  subtest 'skippy' =&gt; sub {
      plan skip_all =&gt; 'cuz I said so';
      pass('this test will never be run');
  };
    </pre>
    <p class="Pp">Returns true if the subtest passed, false otherwise.</p>
    <p class="Pp">Due to how subtests work, you may omit a plan if you desire.
        This adds an implicit <span class="Li">&quot;done_testing()&quot;</span>
        to the end of your subtest. The following two subtests are
      equivalent:</p>
    <p class="Pp"></p>
    <pre>  subtest 'subtest with implicit done_testing()', sub {
      ok 1, 'subtests with an implicit done testing should work';
      ok 1, '... and support more than one test';
      ok 1, '... no matter how many tests are run';
  };
  subtest 'subtest with explicit done_testing()', sub {
      ok 1, 'subtests with an explicit done testing should work';
      ok 1, '... and support more than one test';
      ok 1, '... no matter how many tests are run';
      done_testing();
  };
    </pre>
    <p class="Pp">Extra arguments given to
        <span class="Li">&quot;subtest&quot;</span> are passed to the callback.
        For example:</p>
    <p class="Pp"></p>
    <pre>    sub my_subtest {
        my $range = shift;
        ...
    }
    for my $range (1, 10, 100, 1000) {
        subtest &quot;testing range $range&quot;, \&amp;my_subtest, $range;
    }
    </pre>
  </dd>
  <dt id="pass"><a class="permalink" href="#pass"><b>pass</b></a></dt>
  <dd></dd>
  <dt id="fail"><a class="permalink" href="#fail"><b>fail</b></a></dt>
  <dd>
    <pre>  pass($test_name);
  fail($test_name);
    </pre>
    <p class="Pp">Sometimes you just want to say that the tests have passed.
        Usually the case is you've got some complicated condition that is
        difficult to wedge into an <span class="Li">&quot;ok()&quot;</span>. In
        this case, you can simply use <span class="Li">&quot;pass()&quot;</span>
        (to declare the test ok) or fail (for not ok). They are synonyms for
        <span class="Li">ok(1)</span> and <span class="Li">ok(0)</span>.</p>
    <p class="Pp">Use these very, very, very sparingly.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Module_tests"><a class="permalink" href="#Module_tests">Module
  tests</a></h2>
<p class="Pp">Sometimes you want to test if a module, or a list of modules, can
    successfully load. For example, you'll often want a first test which simply
    loads all the modules in the distribution to make sure they work before
    going on to do more complicated testing.</p>
<p class="Pp">For such purposes we have
    <span class="Li">&quot;use_ok&quot;</span> and
    <span class="Li">&quot;require_ok&quot;</span>.</p>
<dl class="Bl-tag">
  <dt id="require_ok"><a class="permalink" href="#require_ok"><b>require_ok</b></a></dt>
  <dd>
    <pre>   require_ok($module);
   require_ok($file);
    </pre>
    <p class="Pp">Tries to <span class="Li">&quot;require&quot;</span> the given
        <span class="Li">$module</span> or <span class="Li">$file</span>. If it
        loads successfully, the test will pass. Otherwise it fails and displays
        the load error.</p>
    <p class="Pp"><span class="Li">&quot;require_ok&quot;</span> will guess
        whether the input is a module name or a filename.</p>
    <p class="Pp">No exception will be thrown if the load fails.</p>
    <p class="Pp"></p>
    <pre>    # require Some::Module
    require_ok &quot;Some::Module&quot;;
    # require &quot;Some/File.pl&quot;;
    require_ok &quot;Some/File.pl&quot;;
    # stop testing if any of your modules will not load
    for my $module (@module) {
        require_ok $module or BAIL_OUT &quot;Can't load $module&quot;;
    }
    </pre>
  </dd>
  <dt id="use_ok"><a class="permalink" href="#use_ok"><b>use_ok</b></a></dt>
  <dd>
    <pre>   BEGIN { use_ok($module); }
   BEGIN { use_ok($module, @imports); }
    </pre>
    <p class="Pp">Like <span class="Li">&quot;require_ok&quot;</span>, but it
        will <span class="Li">&quot;use&quot;</span> the
        <span class="Li">$module</span> in question and only loads modules, not
        files.</p>
    <p class="Pp">If you just want to test a module can be loaded, use
        <span class="Li">&quot;require_ok&quot;</span>.</p>
    <p class="Pp">If you just want to load a module in a test, we recommend
        simply using <span class="Li">&quot;use&quot;</span> directly. It will
        cause the test to stop.</p>
    <p class="Pp">It's recommended that you run
        <span class="Li">&quot;use_ok()&quot;</span> inside a BEGIN block so its
        functions are exported at compile-time and prototypes are properly
        honored.</p>
    <p class="Pp">If <span class="Li">@imports</span> are given, they are passed
        through to the use. So this:</p>
    <p class="Pp"></p>
    <pre>   BEGIN { use_ok('Some::Module', qw(foo bar)) }
    </pre>
    <p class="Pp">is like doing this:</p>
    <p class="Pp"></p>
    <pre>   use Some::Module qw(foo bar);
    </pre>
    <p class="Pp">Version numbers can be checked like so:</p>
    <p class="Pp"></p>
    <pre>   # Just like &quot;use Some::Module 1.02&quot;
   BEGIN { use_ok('Some::Module', 1.02) }
    </pre>
    <p class="Pp">Don't try to do this:</p>
    <p class="Pp"></p>
    <pre>   BEGIN {
       use_ok('Some::Module');
       ...some code that depends on the use...
       ...happening at compile time...
   }
    </pre>
    <p class="Pp">because the notion of &quot;compile-time&quot; is relative.
        Instead, you want:</p>
    <p class="Pp"></p>
    <pre>  BEGIN { use_ok('Some::Module') }
  BEGIN { ...some code that depends on the use... }
    </pre>
    <p class="Pp">If you want the equivalent of <span class="Li">&quot;use Foo
        ()&quot;</span>, use a module but not import anything, use
        <span class="Li">&quot;require_ok&quot;</span>.</p>
    <p class="Pp"></p>
    <pre>  BEGIN { require_ok &quot;Foo&quot; }
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Complex_data_structures"><a class="permalink" href="#Complex_data_structures">Complex
  data structures</a></h2>
<p class="Pp">Not everything is a simple eq check or regex. There are times you
    need to see if two data structures are equivalent. For these instances
    Test::More provides a handful of useful functions.</p>
<p class="Pp"><b>NOTE</b> I'm not quite sure what will happen with
  filehandles.</p>
<dl class="Bl-tag">
  <dt id="is_deeply"><a class="permalink" href="#is_deeply"><b>is_deeply</b></a></dt>
  <dd>
    <pre>  is_deeply( $got, $expected, $test_name );
    </pre>
    <p class="Pp">Similar to <span class="Li">&quot;is()&quot;</span>, except
        that if <span class="Li">$got</span> and
        <span class="Li">$expected</span> are references, it does a deep
        comparison walking each data structure to see if they are equivalent. If
        the two structures are different, it will display the place where they
        start differing.</p>
    <p class="Pp"><span class="Li">&quot;is_deeply()&quot;</span> compares the
        dereferenced values of references, the references themselves (except for
        their type) are ignored. This means aspects such as blessing and ties
        are not considered &quot;different&quot;.</p>
    <p class="Pp"><span class="Li">&quot;is_deeply()&quot;</span> currently has
        very limited handling of function reference and globs. It merely checks
        if they have the same referent. This may improve in the future.</p>
    <p class="Pp">Test::Differences and Test::Deep provide more in-depth
        functionality along these lines.</p>
    <p class="Pp"><b>NOTE</b> <b>is_deeply()</b> has limitations when it comes
        to comparing strings and refs:</p>
    <p class="Pp"></p>
    <pre>    my $path = path('.');
    my $hash = {};
    is_deeply( $path, &quot;$path&quot; ); # ok
    is_deeply( $hash, &quot;$hash&quot; ); # fail
    </pre>
    <p class="Pp">This happens because is_deeply will unoverload all arguments
        unconditionally. It is probably best not to use is_deeply with
        overloading. For legacy reasons this is not likely to ever be fixed. If
        you would like a much better tool for this you should see Test2::Suite
        Specifically Test2::Tools::Compare has an
        <span class="Li">&quot;is()&quot;</span> function that works like
        <span class="Li">&quot;is_deeply&quot;</span> with many
      improvements.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Diagnostics"><a class="permalink" href="#Diagnostics">Diagnostics</a></h2>
<p class="Pp">If you pick the right test function, you'll usually get a good
    idea of what went wrong when it failed. But sometimes it doesn't work out
    that way. So here we have ways for you to write your own diagnostic messages
    which are safer than just <span class="Li">&quot;print
  STDERR&quot;</span>.</p>
<dl class="Bl-tag">
  <dt id="diag"><a class="permalink" href="#diag"><b>diag</b></a></dt>
  <dd>
    <pre>  diag(@diagnostic_message);
    </pre>
    <p class="Pp">Prints a diagnostic message which is guaranteed not to
        interfere with test output. Like
        <span class="Li">&quot;print&quot;</span>
        <span class="Li">@diagnostic_message</span> is simply concatenated
        together.</p>
    <p class="Pp">Returns false, so as to preserve failure.</p>
    <p class="Pp">Handy for this sort of thing:</p>
    <p class="Pp"></p>
    <pre>    ok( grep(/foo/, @users), &quot;There's a foo user&quot; ) or
        diag(&quot;Since there's no foo, check that /etc/bar is set up right&quot;);
    </pre>
    <p class="Pp">which would produce:</p>
    <p class="Pp"></p>
    <pre>    not ok 42 - There's a foo user
    #   Failed test 'There's a foo user'
    #   in foo.t at line 52.
    # Since there's no foo, check that /etc/bar is set up right.
    </pre>
    <p class="Pp">You might remember <span class="Li">&quot;ok() or
        diag()&quot;</span> with the mnemonic <span class="Li">&quot;open()
        or</span> <span class="Li">die()&quot;</span>.</p>
    <p class="Pp"><b>NOTE</b> The exact formatting of the diagnostic output is
        still changing, but it is guaranteed that whatever you throw at it won't
        interfere with the test.</p>
  </dd>
  <dt id="note"><a class="permalink" href="#note"><b>note</b></a></dt>
  <dd>
    <pre>  note(@diagnostic_message);
    </pre>
    <p class="Pp">Like <span class="Li">&quot;diag()&quot;</span>, except the
        message will not be seen when the test is run in a harness. It will only
        be visible in the verbose TAP stream.</p>
    <p class="Pp">Handy for putting in notes which might be useful for
        debugging, but don't indicate a problem.</p>
    <p class="Pp"></p>
    <pre>    note(&quot;Tempfile is $tempfile&quot;);
    </pre>
  </dd>
  <dt id="explain"><a class="permalink" href="#explain"><b>explain</b></a></dt>
  <dd>
    <pre>  my @dump = explain @diagnostic_message;
    </pre>
    <p class="Pp">Will dump the contents of any references in a human readable
        format. Usually you want to pass this into
        <span class="Li">&quot;note&quot;</span> or
        <span class="Li">&quot;diag&quot;</span>.</p>
    <p class="Pp">Handy for things like...</p>
    <p class="Pp"></p>
    <pre>    is_deeply($have, $want) || diag explain $have;
    </pre>
    <p class="Pp">or</p>
    <p class="Pp"></p>
    <pre>    note explain \%args;
    Some::Class-&gt;method(%args);
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Conditional_tests"><a class="permalink" href="#Conditional_tests">Conditional
  tests</a></h2>
<p class="Pp">Sometimes running a test under certain conditions will cause the
    test script to die. A certain function or method isn't implemented (such as
    <span class="Li">&quot;fork()&quot;</span> on MacOS), some resource isn't
    available (like a net connection) or a module isn't available. In these
    cases it's necessary to skip tests, or declare that they are supposed to
    fail but will work in the future (a todo test).</p>
<p class="Pp">For more details on the mechanics of skip and todo tests see
    Test::Harness.</p>
<p class="Pp">The way Test::More handles this is with a named block. Basically,
    a block of tests which can be skipped over or made todo. It's best if I just
    show you...</p>
<dl class="Bl-tag">
  <dt id="SKIP:"><a class="permalink" href="#SKIP:"><b>SKIP: BLOCK</b></a></dt>
  <dd>
    <pre>  SKIP: {
      skip $why, $how_many if $condition;
      ...normal testing code goes here...
  }
    </pre>
    <p class="Pp">This declares a block of tests that might be skipped,
        <span class="Li">$how_many</span> tests there are,
        <span class="Li">$why</span> and under what
        <span class="Li">$condition</span> to skip them. An example is the
        easiest way to illustrate:</p>
    <p class="Pp"></p>
    <pre>    SKIP: {
        eval { require HTML::Lint };
        skip &quot;HTML::Lint not installed&quot;, 2 if $@;
        my $lint = new HTML::Lint;
        isa_ok( $lint, &quot;HTML::Lint&quot; );
        $lint-&gt;parse( $html );
        is( $lint-&gt;errors, 0, &quot;No errors found in HTML&quot; );
    }
    </pre>
    <p class="Pp">If the user does not have HTML::Lint installed, the whole
        block of code <i>won't be run at all</i>. Test::More will output special
        ok's which Test::Harness interprets as skipped, but passing, tests.</p>
    <p class="Pp">It's important that <span class="Li">$how_many</span>
        accurately reflects the number of tests in the SKIP block so the # of
        tests run will match up with your plan. If your plan is
        <span class="Li">&quot;no_plan&quot;</span>
        <span class="Li">$how_many</span> is optional and will default to 1.</p>
    <p class="Pp">It's perfectly safe to nest SKIP blocks. Each SKIP block must
        have the label <span class="Li">&quot;SKIP&quot;</span>, or Test::More
        can't work its magic.</p>
    <p class="Pp">You don't skip tests which are failing because there's a bug
        in your program, or for which you don't yet have code written. For that
        you use TODO. Read on.</p>
  </dd>
  <dt id="TODO:"><a class="permalink" href="#TODO:"><b>TODO: BLOCK</b></a></dt>
  <dd>
    <pre>    TODO: {
        local $TODO = $why if $condition;
        ...normal testing code goes here...
    }
    </pre>
    <p class="Pp">Declares a block of tests you expect to fail and
        <span class="Li">$why</span>. Perhaps it's because you haven't fixed a
        bug or haven't finished a new feature:</p>
    <p class="Pp"></p>
    <pre>    TODO: {
        local $TODO = &quot;URI::Geller not finished&quot;;
        my $card = &quot;Eight of clubs&quot;;
        is( URI::Geller-&gt;your_card, $card, 'Is THIS your card?' );
        my $spoon;
        URI::Geller-&gt;bend_spoon;
        is( $spoon, 'bent',    &quot;Spoon bending, that's original&quot; );
    }
    </pre>
    <p class="Pp">With a todo block, the tests inside are expected to fail.
        Test::More will run the tests normally, but print out special flags
        indicating they are &quot;todo&quot;. Test::Harness will interpret
        failures as being ok. Should anything succeed, it will report it as an
        unexpected success. You then know the thing you had todo is done and can
        remove the TODO flag.</p>
    <p class="Pp">The nice part about todo tests, as opposed to simply
        commenting out a block of tests, is that it is like having a
        programmatic todo list. You know how much work is left to be done,
        you're aware of what bugs there are, and you'll know immediately when
        they're fixed.</p>
    <p class="Pp">Once a todo test starts succeeding, simply move it outside the
        block. When the block is empty, delete it.</p>
  </dd>
  <dt id="todo_skip"><a class="permalink" href="#todo_skip"><b>todo_skip</b></a></dt>
  <dd>
    <pre>    TODO: {
        todo_skip $why, $how_many if $condition;
        ...normal testing code...
    }
    </pre>
    <p class="Pp">With todo tests, it's best to have the tests actually run.
        That way you'll know when they start passing. Sometimes this isn't
        possible. Often a failing test will cause the whole program to die or
        hang, even inside an <span class="Li">&quot;eval BLOCK&quot;</span> with
        and using <span class="Li">&quot;alarm&quot;</span>. In these extreme
        cases you have no choice but to skip over the broken tests entirely.</p>
    <p class="Pp">The syntax and behavior is similar to a
        <span class="Li">&quot;SKIP: BLOCK&quot;</span> except the tests will be
        marked as failing but todo. Test::Harness will interpret them as
        passing.</p>
  </dd>
  <dt id="When"><a class="permalink" href="#When">When do I use SKIP vs.
    TODO?</a></dt>
  <dd><b>If it's something the user might not be able to do</b>, use SKIP. This
      includes optional modules that aren't installed, running under an OS that
      doesn't have some feature (like <span class="Li">&quot;fork()&quot;</span>
      or symlinks), or maybe you need an Internet connection and one isn't
      available.
    <p class="Pp"><b>If it's something the programmer hasn't done yet</b>, use
        TODO. This is for any code you haven't written yet, or bugs you have yet
        to fix, but want to put tests in your testing script (always a good
        idea).</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Test_control"><a class="permalink" href="#Test_control">Test
  control</a></h2>
<dl class="Bl-tag">
  <dt id="BAIL_OUT"><a class="permalink" href="#BAIL_OUT"><b>BAIL_OUT</b></a></dt>
  <dd>
    <pre>    BAIL_OUT($reason);
    </pre>
    <p class="Pp">Indicates to the harness that things are going so badly all
        testing should terminate. This includes the running of any additional
        test scripts.</p>
    <p class="Pp">This is typically used when testing cannot continue such as a
        critical module failing to compile or a necessary external utility not
        being available such as a database connection failing.</p>
    <p class="Pp">The test will exit with 255.</p>
    <p class="Pp">For even better control look at Test::Most.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Discouraged_comparison_functions"><a class="permalink" href="#Discouraged_comparison_functions">Discouraged
  comparison functions</a></h2>
<p class="Pp">The use of the following functions is discouraged as they are not
    actually testing functions and produce no diagnostics to help figure out
    what went wrong. They were written before
    <span class="Li">&quot;is_deeply()&quot;</span> existed because I couldn't
    figure out how to display a useful diff of two arbitrary data
  structures.</p>
<p class="Pp">These functions are usually used inside an
    <span class="Li">&quot;ok()&quot;</span>.</p>
<p class="Pp"></p>
<pre>    ok( eq_array(\@got, \@expected) );
</pre>
<p class="Pp"><span class="Li">&quot;is_deeply()&quot;</span> can do that better
    and with diagnostics.</p>
<p class="Pp"></p>
<pre>    is_deeply( \@got, \@expected );
</pre>
<p class="Pp">They may be deprecated in future versions.</p>
<dl class="Bl-tag">
  <dt id="eq_array"><a class="permalink" href="#eq_array"><b>eq_array</b></a></dt>
  <dd>
    <pre>  my $is_eq = eq_array(\@got, \@expected);
    </pre>
    <p class="Pp">Checks if two arrays are equivalent. This is a deep check, so
        multi-level structures are handled correctly.</p>
  </dd>
  <dt id="eq_hash"><a class="permalink" href="#eq_hash"><b>eq_hash</b></a></dt>
  <dd>
    <pre>  my $is_eq = eq_hash(\%got, \%expected);
    </pre>
    <p class="Pp">Determines if the two hashes contain the same keys and values.
        This is a deep check.</p>
  </dd>
  <dt id="eq_set"><a class="permalink" href="#eq_set"><b>eq_set</b></a></dt>
  <dd>
    <pre>  my $is_eq = eq_set(\@got, \@expected);
    </pre>
    <p class="Pp">Similar to <span class="Li">&quot;eq_array()&quot;</span>,
        except the order of the elements is <b>not</b> important. This is a deep
        check, but the irrelevancy of order only applies to the top level.</p>
    <p class="Pp"></p>
    <pre>    ok( eq_set(\@got, \@expected) );
    </pre>
    <p class="Pp">Is better written:</p>
    <p class="Pp"></p>
    <pre>    is_deeply( [sort @got], [sort @expected] );
    </pre>
    <p class="Pp"><b>NOTE</b> By historical accident, this is not a true set
        comparison. While the order of elements does not matter, duplicate
        elements do.</p>
    <p class="Pp"><b>NOTE</b> <span class="Li">&quot;eq_set()&quot;</span> does
        not know how to deal with references at the top level. The following is
        an example of a comparison which might not work:</p>
    <p class="Pp"></p>
    <pre>    eq_set([\1, \2], [\2, \1]);
    </pre>
    <p class="Pp">Test::Deep contains much better set comparison functions.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Extending_and_Embedding_Test::More"><a class="permalink" href="#Extending_and_Embedding_Test::More">Extending
  and Embedding Test::More</a></h2>
<p class="Pp">Sometimes the Test::More interface isn't quite enough.
    Fortunately, Test::More is built on top of Test::Builder which provides a
    single, unified backend for any test library to use. This means two test
    libraries which both use &lt;Test::Builder&gt; <b>can</b> be used together
    in the same program&gt;.</p>
<p class="Pp">If you simply want to do a little tweaking of how the tests
    behave, you can access the underlying Test::Builder object like so:</p>
<dl class="Bl-tag">
  <dt id="builder"><a class="permalink" href="#builder"><b>builder</b></a></dt>
  <dd>
    <pre>    my $test_builder = Test::More-&gt;builder;
    </pre>
    <p class="Pp">Returns the Test::Builder object underlying Test::More for you
        to play with.</p>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXIT_CODES"><a class="permalink" href="#EXIT_CODES">EXIT
  CODES</a></h1>
<p class="Pp">If all your tests passed, Test::Builder will exit with zero (which
    is normal). If anything failed it will exit with how many failed. If you run
    less (or more) tests than you planned, the missing (or extras) will be
    considered failures. If no tests were ever run Test::Builder will throw a
    warning and exit with 255. If the test died, even after having successfully
    completed all its tests, it will still be considered a failure and will exit
    with 255.</p>
<p class="Pp">So the exit codes are...</p>
<p class="Pp"></p>
<pre>    0                   all tests successful
    255                 test died or all passed but wrong # of tests run
    any other number    how many failed (including missing or extras)
</pre>
<p class="Pp">If you fail more than 254 tests, it will be reported as 254.</p>
<p class="Pp"><b>NOTE</b> This behavior may go away in future versions.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COMPATIBILITY"><a class="permalink" href="#COMPATIBILITY">COMPATIBILITY</a></h1>
<p class="Pp">Test::More works with Perls as old as 5.8.1.</p>
<p class="Pp">Thread support is not very reliable before 5.10.1, but that's
    because threads are not very reliable before 5.10.1.</p>
<p class="Pp">Although Test::More has been a core module in versions of Perl
    since 5.6.2, Test::More has evolved since then, and not all of the features
    you're used to will be present in the shipped version of Test::More. If you
    are writing a module, don't forget to indicate in your package metadata the
    minimum version of Test::More that you require. For instance, if you want to
    use <span class="Li">&quot;done_testing()&quot;</span> but want your test
    script to run on Perl 5.10.0, you will need to explicitly require Test::More
    &gt; 0.88.</p>
<p class="Pp">Key feature milestones include:</p>
<dl class="Bl-tag">
  <dt id="subtests"><a class="permalink" href="#subtests">subtests</a></dt>
  <dd>Subtests were released in Test::More 0.94, which came with Perl 5.12.0.
      Subtests did not implicitly call
      <span class="Li">&quot;done_testing()&quot;</span> until 0.96; the first
      Perl with that fix was Perl 5.14.0 with 0.98.</dd>
  <dt>&quot;done_testing()&quot;</dt>
  <dd>This was released in Test::More 0.88 and first shipped with Perl in 5.10.1
      as part of Test::More 0.92.</dd>
  <dt>&quot;cmp_ok()&quot;</dt>
  <dd>Although <span class="Li">&quot;cmp_ok()&quot;</span> was introduced in
      0.40, 0.86 fixed an important bug to make it safe for overloaded objects;
      the fixed first shipped with Perl in 5.10.1 as part of Test::More
    0.92.</dd>
  <dt>&quot;new_ok()&quot; &quot;note()&quot; and &quot;explain()&quot;</dt>
  <dd>These were was released in Test::More 0.82, and first shipped with Perl in
      5.10.1 as part of Test::More 0.92.</dd>
</dl>
<p class="Pp">There is a full version history in the Changes file, and the
    Test::More versions included as core can be found using
  Module::CoreList:</p>
<p class="Pp"></p>
<pre>    $ corelist -a Test::More
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS_and_NOTES"><a class="permalink" href="#CAVEATS_and_NOTES">CAVEATS
  and NOTES</a></h1>
<dl class="Bl-tag">
  <dt id="utf8"><a class="permalink" href="#utf8">utf8 / &quot;Wide character in
    print&quot;</a></dt>
  <dd>If you use utf8 or other non-ASCII characters with Test::More you might
      get a &quot;Wide character in print&quot; warning. Using
      <span class="Li">&quot;binmode STDOUT, &quot;:utf8&quot;&quot;</span> will
      not fix it. Test::Builder (which powers Test::More) duplicates STDOUT and
      STDERR. So any changes to them, including changing their output
      disciplines, will not be seen by Test::More.
    <p class="Pp">One work around is to apply encodings to STDOUT and STDERR as
        early as possible and before Test::More (or any other Test module)
        loads.</p>
    <p class="Pp"></p>
    <pre>    use open ':std', ':encoding(utf8)';
    use Test::More;
    </pre>
    <p class="Pp">A more direct work around is to change the filehandles used by
        Test::Builder.</p>
    <p class="Pp"></p>
    <pre>    my $builder = Test::More-&gt;builder;
    binmode $builder-&gt;output,         &quot;:encoding(utf8)&quot;;
    binmode $builder-&gt;failure_output, &quot;:encoding(utf8)&quot;;
    binmode $builder-&gt;todo_output,    &quot;:encoding(utf8)&quot;;
    </pre>
  </dd>
  <dt id="Overloaded"><a class="permalink" href="#Overloaded">Overloaded
    objects</a></dt>
  <dd>String overloaded objects are compared <b>as strings</b> (or in
      <span class="Li">&quot;cmp_ok()&quot;</span>'s case, strings or numbers as
      appropriate to the comparison op). This prevents Test::More from piercing
      an object's interface allowing better blackbox testing. So if a function
      starts returning overloaded objects instead of bare strings your tests
      won't notice the difference. This is good.
    <p class="Pp">However, it does mean that functions like
        <span class="Li">&quot;is_deeply()&quot;</span> cannot be used to test
        the internals of string overloaded objects. In this case I would suggest
        Test::Deep which contains more flexible testing functions for complex
        data structures.</p>
  </dd>
  <dt id="Threads"><a class="permalink" href="#Threads">Threads</a></dt>
  <dd>Test::More will only be aware of threads if <span class="Li">&quot;use
      threads&quot;</span> has been done <i>before</i> Test::More is loaded.
      This is ok:
    <p class="Pp"></p>
    <pre>    use threads;
    use Test::More;
    </pre>
    <p class="Pp">This may cause problems:</p>
    <p class="Pp"></p>
    <pre>    use Test::More
    use threads;
    </pre>
    <p class="Pp">5.8.1 and above are supported. Anything below that has too
        many bugs.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
<p class="Pp">This is a case of convergent evolution with Joshua Pritikin's Test
    module. I was largely unaware of its existence when I'd first written my own
    <span class="Li">&quot;ok()&quot;</span> routines. This module exists
    because I can't figure out how to easily wedge test names into Test's
    interface (along with a few other problems).</p>
<p class="Pp">The goal here is to have a testing utility that's simple to learn,
    quick to use and difficult to trip yourself up with while still providing
    more flexibility than the existing Test.pm. As such, the names of the most
    common routines are kept tiny, special cases and magic side-effects are kept
    to a minimum. WYSIWYG.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<section class="Ss">
<h2 class="Ss">
</h2>
</section>
<section class="Ss">
<h2 class="Ss">ALTERNATIVES</h2>
<p class="Pp">Test2::Suite is the most recent and modern set of tools for
    testing.</p>
<p class="Pp">Test::Simple if all this confuses you and you just want to write
    some tests. You can upgrade to Test::More later (it's forward
  compatible).</p>
<p class="Pp">Test::Legacy tests written with Test.pm, the original testing
    module, do not play well with other testing libraries. Test::Legacy emulates
    the Test.pm interface and does play well with others.</p>
</section>
<section class="Ss">
<h2 class="Ss">ADDITIONAL LIBRARIES</h2>
<p class="Pp">Test::Differences for more ways to test complex data structures.
    And it plays well with Test::More.</p>
<p class="Pp">Test::Class is like xUnit but more perlish.</p>
<p class="Pp">Test::Deep gives you more powerful complex data structure
  testing.</p>
<p class="Pp">Test::Inline shows the idea of embedded testing.</p>
<p class="Pp">Mock::Quick The ultimate mocking library. Easily spawn objects
    defined on the fly. Can also override, block, or reimplement packages as
    needed.</p>
<p class="Pp">Test::FixtureBuilder Quickly define fixture data for unit
  tests.</p>
</section>
<section class="Ss">
<h2 class="Ss">OTHER COMPONENTS</h2>
<p class="Pp">Test::Harness is the test runner and output interpreter for Perl.
    It's the thing that powers <span class="Li">&quot;make test&quot;</span> and
    where the <span class="Li">&quot;prove&quot;</span> utility comes from.</p>
</section>
<section class="Ss">
<h2 class="Ss">BUNDLES</h2>
<p class="Pp">Test::Most Most commonly needed test functions and features.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp">Michael G Schwern &lt;schwern@pobox.com&gt; with much inspiration
    from Joshua Pritikin's Test module and lots of help from Barrie Slaymaker,
    Tony Bowden, blackstar.co.uk, chromatic, Fergal Daly and the perl-qa
  gang.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MAINTAINERS"><a class="permalink" href="#MAINTAINERS">MAINTAINERS</a></h1>
<dl class="Bl-tag">
  <dt id="Chad"><a class="permalink" href="#Chad">Chad Granum
    &lt;exodist@cpan.org&gt;</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">See <i>https://github.com/Test-More/test-more/issues</i> to report
    and view bugs.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SOURCE"><a class="permalink" href="#SOURCE">SOURCE</a></h1>
<p class="Pp">The source code repository for Test::More can be found at
    <i>http://github.com/Test-More/test-more/</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 2001-2008 by Michael G Schwern
    &lt;schwern@pobox.com&gt;.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">See <i>http://www.perl.com/perl/misc/Artistic.html</i></p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os"><a href="..">perl v5.34.1</a></td>
  </tr>
</table>
</body>
</html>

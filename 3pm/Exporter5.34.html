<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Exporter(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Exporter(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Exporter(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Exporter - Implements default import method for modules</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">In module <i>YourModule.pm</i>:</p>
<p class="Pp"></p>
<pre>  package YourModule;
  require Exporter;
  our @ISA = qw(Exporter);
  our @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre>  package YourModule;
  use Exporter 'import'; # gives you Exporter's import() method directly
  our @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
</pre>
<p class="Pp">In other files which wish to use
    <span class="Li">&quot;YourModule&quot;</span>:</p>
<p class="Pp"></p>
<pre>  use YourModule qw(frobnicate);      # import listed symbols
  frobnicate ($left, $right)          # calls YourModule::frobnicate
</pre>
<p class="Pp">Take a look at &quot;Good Practices&quot; for some variants you
    will like to use in modern Perl code.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The Exporter module implements an
    <span class="Li">&quot;import&quot;</span> method which allows a module to
    export functions and variables to its users' namespaces. Many modules use
    Exporter rather than implementing their own
    <span class="Li">&quot;import&quot;</span> method because Exporter provides
    a highly flexible interface, with an implementation optimised for the common
    case.</p>
<p class="Pp">Perl automatically calls the
    <span class="Li">&quot;import&quot;</span> method when processing a
    <span class="Li">&quot;use&quot;</span> statement for a module. Modules and
    <span class="Li">&quot;use&quot;</span> are documented in perlfunc and
    perlmod. Understanding the concept of modules and how the
    <span class="Li">&quot;use&quot;</span> statement operates is important to
    understanding the Exporter.</p>
<section class="Ss">
<h2 class="Ss" id="How_to_Export"><a class="permalink" href="#How_to_Export">How
  to Export</a></h2>
<p class="Pp">The arrays <span class="Li">@EXPORT</span> and
    <span class="Li">@EXPORT_OK</span> in a module hold lists of symbols that
    are going to be exported into the users name space by default, or which they
    can request to be exported, respectively. The symbols can represent
    functions, scalars, arrays, hashes, or typeglobs. The symbols must be given
    by full name with the exception that the ampersand in front of a function is
    optional, e.g.</p>
<p class="Pp"></p>
<pre>    our @EXPORT    = qw(afunc $scalar @array);   # afunc is a function
    our @EXPORT_OK = qw(&amp;bfunc %hash *typeglob); # explicit prefix on &amp;bfunc
</pre>
<p class="Pp">If you are only exporting function names it is recommended to omit
    the ampersand, as the implementation is faster this way.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Selecting_What_to_Export"><a class="permalink" href="#Selecting_What_to_Export">Selecting
  What to Export</a></h2>
<p class="Pp">Do <b>not</b> export method names!</p>
<p class="Pp">Do <b>not</b> export anything else by default without a good
    reason!</p>
<p class="Pp">Exports pollute the namespace of the module user. If you must
    export try to use <span class="Li">@EXPORT_OK</span> in preference to
    <span class="Li">@EXPORT</span> and avoid short or common symbol names to
    reduce the risk of name clashes.</p>
<p class="Pp">Generally anything not exported is still accessible from outside
    the module using the
    <span class="Li">&quot;YourModule::item_name&quot;</span> (or
    <span class="Li">&quot;$blessed_ref-&gt;method&quot;</span>) syntax. By
    convention you can use a leading underscore on names to informally indicate
    that they are 'internal' and not for public use.</p>
<p class="Pp">(It is actually possible to get private functions by saying:</p>
<p class="Pp"></p>
<pre>  my $subref = sub { ... };
  $subref-&gt;(@args);            # Call it as a function
  $obj-&gt;$subref(@args);        # Use it as a method
</pre>
<p class="Pp">However if you use them for methods it is up to you to figure out
    how to make inheritance work.)</p>
<p class="Pp">As a general rule, if the module is trying to be object oriented
    then export nothing. If it's just a collection of functions then
    <span class="Li">@EXPORT_OK</span> anything but use
    <span class="Li">@EXPORT</span> with caution. For function and method names
    use barewords in preference to names prefixed with ampersands for the export
    lists.</p>
<p class="Pp">Other module design guidelines can be found in perlmod.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_to_Import"><a class="permalink" href="#How_to_Import">How
  to Import</a></h2>
<p class="Pp">In other files which wish to use your module there are three basic
    ways for them to load your module and import its symbols:</p>
<dl class="Bl-tag">
  <dt>&quot;use YourModule;&quot;</dt>
  <dd>This imports all the symbols from YourModule's
      <span class="Li">@EXPORT</span> into the namespace of the
      <span class="Li">&quot;use&quot;</span> statement.</dd>
  <dt>&quot;use YourModule ();&quot;</dt>
  <dd>This causes perl to load your module but does not import any symbols.</dd>
  <dt>&quot;use YourModule qw(...);&quot;</dt>
  <dd>This imports only the symbols listed by the caller into their namespace.
      All listed symbols must be in your <span class="Li">@EXPORT</span> or
      <span class="Li">@EXPORT_OK</span>, else an error occurs. The advanced
      export features of Exporter are accessed like this, but with list entries
      that are syntactically distinct from symbol names.</dd>
</dl>
<p class="Pp">Unless you want to use its advanced features, this is probably all
    you need to know to use Exporter.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Advanced_Features"><a class="permalink" href="#Advanced_Features">Advanced
  Features</a></h1>
<section class="Ss">
<h2 class="Ss" id="Specialised_Import_Lists"><a class="permalink" href="#Specialised_Import_Lists">Specialised
  Import Lists</a></h2>
<p class="Pp">If any of the entries in an import list begins with !, : or / then
    the list is treated as a series of specifications which either add to or
    delete from the list of names to import. They are processed left to right.
    Specifications are in the form:</p>
<p class="Pp"></p>
<pre>    [!]name         This name only
    [!]:DEFAULT     All names in @EXPORT
    [!]:tag         All names in $EXPORT_TAGS{tag} anonymous array
    [!]/pattern/    All names in @EXPORT and @EXPORT_OK which match
</pre>
<p class="Pp">A leading ! indicates that matching names should be deleted from
    the list of names to import. If the first specification is a deletion it is
    treated as though preceded by :DEFAULT. If you just want to import extra
    names in addition to the default set you will still need to include :DEFAULT
    explicitly.</p>
<p class="Pp">e.g., <i>Module.pm</i> defines:</p>
<p class="Pp"></p>
<pre>    our @EXPORT      = qw(A1 A2 A3 A4 A5);
    our @EXPORT_OK   = qw(B1 B2 B3 B4 B5);
    our %EXPORT_TAGS = (T1 =&gt; [qw(A1 A2 B1 B2)], T2 =&gt; [qw(A1 A2 B3 B4)]);
</pre>
<p class="Pp">Note that you cannot use tags in <span class="Li">@EXPORT</span>
    or <span class="Li">@EXPORT_OK</span>.</p>
<p class="Pp">Names in EXPORT_TAGS must also appear in
    <span class="Li">@EXPORT</span> or <span class="Li">@EXPORT_OK</span>.</p>
<p class="Pp">An application using Module can say something like:</p>
<p class="Pp"></p>
<pre>    use Module qw(:DEFAULT :T2 !B3 A3);
</pre>
<p class="Pp">Other examples include:</p>
<p class="Pp"></p>
<pre>    use Socket qw(!/^[AP]F_/ !SOMAXCONN !SOL_SOCKET);
    use POSIX  qw(:errno_h :termios_h !TCSADRAIN !/^EXIT/);
</pre>
<p class="Pp">Remember that most patterns (using //) will need to be anchored
    with a leading ^, e.g., <span class="Li">&quot;/^EXIT/&quot;</span> rather
    than <span class="Li">&quot;/EXIT/&quot;</span>.</p>
<p class="Pp">You can say <span class="Li">&quot;BEGIN { $Exporter::Verbose=1
    }&quot;</span> to see how the specifications are being processed and what is
    actually being imported into modules.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Exporting_Without_Using_Exporter's_import_Method"><a class="permalink" href="#Exporting_Without_Using_Exporter's_import_Method">Exporting
  Without Using Exporter's import Method</a></h2>
<p class="Pp">Exporter has a special method, 'export_to_level' which is used in
    situations where you can't directly call Exporter's import method. The
    export_to_level method looks like:</p>
<p class="Pp"></p>
<pre>    MyPackage-&gt;export_to_level(
        $where_to_export, $package, @what_to_export
    );
</pre>
<p class="Pp">where <span class="Li">$where_to_export</span> is an integer
    telling how far up the calling stack to export your symbols, and
    <span class="Li">@what_to_export</span> is an array telling what symbols
    *to* export (usually this is <span class="Li">@_</span>). The
    <span class="Li">$package</span> argument is currently unused.</p>
<p class="Pp">For example, suppose that you have a module, A, which already has
    an import function:</p>
<p class="Pp"></p>
<pre>    package A;
    our @ISA = qw(Exporter);
    our @EXPORT_OK = qw($b);
    sub import
    {
        $A::b = 1;     # not a very useful import method
    }
</pre>
<p class="Pp">and you want to Export symbol <span class="Li">$A::b</span> back
    to the module that called package A. Since Exporter relies on the import
    method to work, via inheritance, as it stands <b>Exporter::import()</b> will
    never get called. Instead, say the following:</p>
<p class="Pp"></p>
<pre>    package A;
    our @ISA = qw(Exporter);
    our @EXPORT_OK = qw($b);
    sub import
    {
        $A::b = 1;
        A-&gt;export_to_level(1, @_);
    }
</pre>
<p class="Pp">This will export the symbols one level 'above' the current package
    - ie: to the program or module that used package A.</p>
<p class="Pp">Note: Be careful not to modify <span class="Li">@_</span> at all
    before you call export_to_level - or people using your package will get very
    unexplained results!</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Exporting_Without_Inheriting_from_Exporter"><a class="permalink" href="#Exporting_Without_Inheriting_from_Exporter">Exporting
  Without Inheriting from Exporter</a></h2>
<p class="Pp">By including Exporter in your <span class="Li">@ISA</span> you
    inherit an Exporter's <b>import()</b> method but you also inherit several
    other helper methods which you probably don't want. To avoid this you can
    do:</p>
<p class="Pp"></p>
<pre>  package YourModule;
  use Exporter qw(import);
</pre>
<p class="Pp">which will export Exporter's own <b>import()</b> method into
    YourModule. Everything will work as before but you won't need to include
    Exporter in <span class="Li">@YourModule::ISA</span>.</p>
<p class="Pp">Note: This feature was introduced in version 5.57 of Exporter,
    released with perl 5.8.3.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Module_Version_Checking"><a class="permalink" href="#Module_Version_Checking">Module
  Version Checking</a></h2>
<p class="Pp">The Exporter module will convert an attempt to import a number
    from a module into a call to
    <span class="Li">&quot;$module_name-&gt;VERSION($value)&quot;</span>. This
    can be used to validate that the version of the module being used is greater
    than or equal to the required version.</p>
<p class="Pp">For historical reasons, Exporter supplies a
    <span class="Li">&quot;require_version&quot;</span> method that simply
    delegates to <span class="Li">&quot;VERSION&quot;</span>. Originally, before
    <span class="Li">&quot;UNIVERSAL::VERSION&quot;</span> existed, Exporter
    would call <span class="Li">&quot;require_version&quot;</span>.</p>
<p class="Pp">Since the <span class="Li">&quot;UNIVERSAL::VERSION&quot;</span>
    method treats the <span class="Li">$VERSION</span> number as a simple
    numeric value it will regard version 1.10 as lower than 1.9. For this reason
    it is strongly recommended that you use numbers with at least two decimal
    places, e.g., 1.09.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Managing_Unknown_Symbols"><a class="permalink" href="#Managing_Unknown_Symbols">Managing
  Unknown Symbols</a></h2>
<p class="Pp">In some situations you may want to prevent certain symbols from
    being exported. Typically this applies to extensions which have functions or
    constants that may not exist on some systems.</p>
<p class="Pp">The names of any symbols that cannot be exported should be listed
    in the <span class="Li">@EXPORT_FAIL</span> array.</p>
<p class="Pp">If a module attempts to import any of these symbols the Exporter
    will give the module an opportunity to handle the situation before
    generating an error. The Exporter will call an export_fail method with a
    list of the failed symbols:</p>
<p class="Pp"></p>
<pre>  @failed_symbols = $module_name-&gt;export_fail(@failed_symbols);
</pre>
<p class="Pp">If the <span class="Li">&quot;export_fail&quot;</span> method
    returns an empty list then no error is recorded and all the requested
    symbols are exported. If the returned list is not empty then an error is
    generated for each symbol and the export fails. The Exporter provides a
    default <span class="Li">&quot;export_fail&quot;</span> method which simply
    returns the list unchanged.</p>
<p class="Pp">Uses for the <span class="Li">&quot;export_fail&quot;</span>
    method include giving better error messages for some symbols and performing
    lazy architectural checks (put more symbols into
    <span class="Li">@EXPORT_FAIL</span> by default and then take them out if
    someone actually tries to use them and an expensive check shows that they
    are usable on that platform).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Tag_Handling_Utility_Functions"><a class="permalink" href="#Tag_Handling_Utility_Functions">Tag
  Handling Utility Functions</a></h2>
<p class="Pp">Since the symbols listed within
    <span class="Li">%EXPORT_TAGS</span> must also appear in either
    <span class="Li">@EXPORT</span> or <span class="Li">@EXPORT_OK</span>, two
    utility functions are provided which allow you to easily add tagged sets of
    symbols to <span class="Li">@EXPORT</span> or
    <span class="Li">@EXPORT_OK</span>:</p>
<p class="Pp"></p>
<pre>  our %EXPORT_TAGS = (foo =&gt; [qw(aa bb cc)], bar =&gt; [qw(aa cc dd)]);
  Exporter::export_tags('foo');     # add aa, bb and cc to @EXPORT
  Exporter::export_ok_tags('bar');  # add aa, cc and dd to @EXPORT_OK
</pre>
<p class="Pp">Any names which are not tags are added to
    <span class="Li">@EXPORT</span> or <span class="Li">@EXPORT_OK</span>
    unchanged but will trigger a warning (with
    <span class="Li">&quot;-w&quot;</span>) to avoid misspelt tags names being
    silently added to <span class="Li">@EXPORT</span> or
    <span class="Li">@EXPORT_OK</span>. Future versions may make this a fatal
    error.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Generating_Combined_Tags"><a class="permalink" href="#Generating_Combined_Tags">Generating
  Combined Tags</a></h2>
<p class="Pp">If several symbol categories exist in
    <span class="Li">%EXPORT_TAGS</span>, it's usually useful to create the
    utility &quot;:all&quot; to simplify &quot;use&quot; statements.</p>
<p class="Pp">The simplest way to do this is:</p>
<p class="Pp"></p>
<pre> our  %EXPORT_TAGS = (foo =&gt; [qw(aa bb cc)], bar =&gt; [qw(aa cc dd)]);
  # add all the other &quot;:class&quot; tags to the &quot;:all&quot; class,
  # deleting duplicates
  {
    my %seen;
    push @{$EXPORT_TAGS{all}},
      grep {!$seen{$_}++} @{$EXPORT_TAGS{$_}} foreach keys %EXPORT_TAGS;
  }
</pre>
<p class="Pp"><i>CGI.pm</i> creates an &quot;:all&quot; tag which contains some
    (but not really all) of its categories. That could be done with one small
    change:</p>
<p class="Pp"></p>
<pre>  # add some of the other &quot;:class&quot; tags to the &quot;:all&quot; class,
  # deleting duplicates
  {
    my %seen;
    push @{$EXPORT_TAGS{all}},
      grep {!$seen{$_}++} @{$EXPORT_TAGS{$_}}
        foreach qw/html2 html3 netscape form cgi internal/;
  }
</pre>
<p class="Pp">Note that the tag names in <span class="Li">%EXPORT_TAGS</span>
    don't have the leading ':'.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_AUTOLOAD_ed_Constants"><a class="permalink" href="#_AUTOLOAD_ed_Constants">&quot;AUTOLOAD&quot;ed
  Constants</a></h2>
<p class="Pp">Many modules make use of
    <span class="Li">&quot;AUTOLOAD&quot;</span>ing for constant subroutines to
    avoid having to compile and waste memory on rarely used values (see perlsub
    for details on constant subroutines). Calls to such constant subroutines are
    not optimized away at compile time because they can't be checked at compile
    time for constancy.</p>
<p class="Pp">Even if a prototype is available at compile time, the body of the
    subroutine is not (it hasn't been
    <span class="Li">&quot;AUTOLOAD&quot;</span>ed yet). perl needs to examine
    both the <span class="Li">&quot;()&quot;</span> prototype and the body of a
    subroutine at compile time to detect that it can safely replace calls to
    that subroutine with the constant value.</p>
<p class="Pp">A workaround for this is to call the constants once in a
    <span class="Li">&quot;BEGIN&quot;</span> block:</p>
<p class="Pp"></p>
<pre>   package My ;
   use Socket ;
   foo( SO_LINGER );  ## SO_LINGER NOT optimized away; called at runtime
   BEGIN { SO_LINGER }
   foo( SO_LINGER );  ## SO_LINGER optimized away at compile time.
</pre>
<p class="Pp">This forces the <span class="Li">&quot;AUTOLOAD&quot;</span> for
    <span class="Li">&quot;SO_LINGER&quot;</span> to take place before SO_LINGER
    is encountered later in <span class="Li">&quot;My&quot;</span> package.</p>
<p class="Pp">If you are writing a package that
    <span class="Li">&quot;AUTOLOAD&quot;</span>s, consider forcing an
    <span class="Li">&quot;AUTOLOAD&quot;</span> for any constants explicitly
    imported by other packages or which are usually used when your package is
    <span class="Li">&quot;use&quot;</span>d.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Good_Practices"><a class="permalink" href="#Good_Practices">Good
  Practices</a></h1>
<section class="Ss">
<h2 class="Ss" id="Declaring_@EXPORT_OK_and_Friends"><a class="permalink" href="#Declaring_@EXPORT_OK_and_Friends">Declaring
  @EXPORT_OK and Friends</a></h2>
<p class="Pp">When using <span class="Li">&quot;Exporter&quot;</span> with the
    standard <span class="Li">&quot;strict&quot;</span> and
    <span class="Li">&quot;warnings&quot;</span> pragmas, the
    <span class="Li">&quot;our&quot;</span> keyword is needed to declare the
    package variables <span class="Li">@EXPORT_OK</span>,
    <span class="Li">@EXPORT</span>, <span class="Li">@ISA</span>, etc.</p>
<p class="Pp"></p>
<pre>  our @ISA = qw(Exporter);
  our @EXPORT_OK = qw(munge frobnicate);
</pre>
<p class="Pp">If backward compatibility for Perls <b>under</b> 5.6 is important,
    one must write instead a <span class="Li">&quot;use vars&quot;</span>
    statement.</p>
<p class="Pp"></p>
<pre>  use vars qw(@ISA @EXPORT_OK);
  @ISA = qw(Exporter);
  @EXPORT_OK = qw(munge frobnicate);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Playing_Safe"><a class="permalink" href="#Playing_Safe">Playing
  Safe</a></h2>
<p class="Pp">There are some caveats with the use of runtime statements like
    <span class="Li">&quot;require Exporter&quot;</span> and the assignment to
    package variables, which can be very subtle for the unaware programmer. This
    may happen for instance with mutually recursive modules, which are affected
    by the time the relevant constructions are executed.</p>
<p class="Pp">The ideal (but a bit ugly) way to never have to think about that
    is to use <span class="Li">&quot;BEGIN&quot;</span> blocks. So the first
    part of the &quot;SYNOPSIS&quot; code could be rewritten as:</p>
<p class="Pp"></p>
<pre>  package YourModule;
  use strict;
  use warnings;
  our (@ISA, @EXPORT_OK);
  BEGIN {
     require Exporter;
     @ISA = qw(Exporter);
     @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
  }
</pre>
<p class="Pp">The <span class="Li">&quot;BEGIN&quot;</span> will assure that the
    loading of <i>Exporter.pm</i> and the assignments to
    <span class="Li">@ISA</span> and <span class="Li">@EXPORT_OK</span> happen
    immediately, leaving no room for something to get awry or just plain
  wrong.</p>
<p class="Pp">With respect to loading
    <span class="Li">&quot;Exporter&quot;</span> and inheriting, there are
    alternatives with the use of modules like
    <span class="Li">&quot;base&quot;</span> and
    <span class="Li">&quot;parent&quot;</span>.</p>
<p class="Pp"></p>
<pre>  use base qw(Exporter);
  # or
  use parent qw(Exporter);
</pre>
<p class="Pp">Any of these statements are nice replacements for
    <span class="Li">&quot;BEGIN { require Exporter; @ISA = qw(Exporter);
    }&quot;</span> with the same compile-time effect. The basic difference is
    that <span class="Li">&quot;base&quot;</span> code interacts with declared
    <span class="Li">&quot;fields&quot;</span> while
    <span class="Li">&quot;parent&quot;</span> is a streamlined version of the
    older <span class="Li">&quot;base&quot;</span> code to just establish the
    IS-A relationship.</p>
<p class="Pp">For more details, see the documentation and code of base and
    parent.</p>
<p class="Pp">Another thorough remedy to that runtime vs. compile-time trap is
    to use Exporter::Easy, which is a wrapper of Exporter that allows all
    boilerplate code at a single gulp in the use statement.</p>
<p class="Pp"></p>
<pre>   use Exporter::Easy (
       OK =&gt; [ qw(munge frobnicate) ],
   );
   # @ISA setup is automatic
   # all assignments happen at compile time
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="What_Not_to_Export"><a class="permalink" href="#What_Not_to_Export">What
  Not to Export</a></h2>
<p class="Pp">You have been warned already in &quot;Selecting What to
    Export&quot; to not export:</p>
<ul class="Bl-bullet">
  <li>method names (because you don't need to and that's likely to not do what
      you want),</li>
  <li>anything by default (because you don't want to surprise your users...
      badly)</li>
  <li>anything you don't need to (because less is more)</li>
</ul>
<p class="Pp">There's one more item to add to this list. Do <b>not</b> export
    variable names. Just because <span class="Li">&quot;Exporter&quot;</span>
    lets you do that, it does not mean you should.</p>
<p class="Pp"></p>
<pre>  @EXPORT_OK = qw($svar @avar %hvar); # DON'T!
</pre>
<p class="Pp">Exporting variables is not a good idea. They can change under the
    hood, provoking horrible effects at-a-distance that are too hard to track
    and to fix. Trust me: they are not worth it.</p>
<p class="Pp">To provide the capability to set/get class-wide settings, it is
    best instead to provide accessors as subroutines or class methods
  instead.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><span class="Li">&quot;Exporter&quot;</span> is definitely not the
    only module with symbol exporter capabilities. At CPAN, you may find a bunch
    of them. Some are lighter. Some provide improved APIs and features. Pick the
    one that fits your needs. The following is a sample list of such
  modules.</p>
<p class="Pp"></p>
<pre>    Exporter::Easy
    Exporter::Lite
    Exporter::Renaming
    Exporter::Tidy
    Sub::Exporter / Sub::Installer
    Perl6::Export / Perl6::Export::Attrs
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">This library is free software. You can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os">perl v5.34.1</td>
  </tr>
</table>
</body>
</html>

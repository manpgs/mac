<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Locale::Maketext(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Locale::Maketext(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Locale::Maketext(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Locale::Maketext - framework for localization</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  package MyProgram;
  use strict;
  use MyProgram::L10N;
   # ...which inherits from Locale::Maketext
  my $lh = MyProgram::L10N-&gt;get_handle() || die &quot;What language?&quot;;
  ...
  # And then any messages your program emits, like:
  warn $lh-&gt;maketext( &quot;Can't open file [_1]: [_2]\n&quot;, $f, $! );
  ...
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">It is a common feature of applications (whether run directly, or
    via the Web) for them to be &quot;localized&quot; -- i.e., for them to a
    present an English interface to an English-speaker, a German interface to a
    German-speaker, and so on for all languages it's programmed with.
    Locale::Maketext is a framework for software localization; it provides you
    with the tools for organizing and accessing the bits of text and
    text-processing code that you need for producing localized applications.</p>
<p class="Pp">In order to make sense of Maketext and how all its components fit
    together, you should probably go read Locale::Maketext::TPJ13, and
    <i>then</i> read the following documentation.</p>
<p class="Pp">You may also want to read over the source for
    <span class="Li">&quot;File::Findgrep&quot;</span> and its constituent
    modules -- they are a complete (if small) example application that uses
    Maketext.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="QUICK_OVERVIEW"><a class="permalink" href="#QUICK_OVERVIEW">QUICK
  OVERVIEW</a></h1>
<p class="Pp">The basic design of Locale::Maketext is object-oriented, and
    Locale::Maketext is an abstract base class, from which you derive a
    &quot;project class&quot;. The project class (with a name like
    &quot;TkBocciBall::Localize&quot;, which you then use in your module) is in
    turn the base class for all the &quot;language classes&quot; for your
    project (with names &quot;TkBocciBall::Localize::it&quot;,
    &quot;TkBocciBall::Localize::en&quot;,
    &quot;TkBocciBall::Localize::fr&quot;, etc.).</p>
<p class="Pp">A language class is a class containing a lexicon of phrases as
    class data, and possibly also some methods that are of use in interpreting
    phrases in the lexicon, or otherwise dealing with text in that language.</p>
<p class="Pp">An object belonging to a language class is called a &quot;language
    handle&quot;; it's typically a flyweight object.</p>
<p class="Pp">The normal course of action is to call:</p>
<p class="Pp"></p>
<pre>  use TkBocciBall::Localize;  # the localization project class
  $lh = TkBocciBall::Localize-&gt;get_handle();
   # Depending on the user's locale, etc., this will
   # make a language handle from among the classes available,
   # and any defaults that you declare.
  die &quot;Couldn't make a language handle??&quot; unless $lh;
</pre>
<p class="Pp">From then on, you use the
    <span class="Li">&quot;maketext&quot;</span> function to access entries in
    whatever lexicon(s) belong to the language handle you got. So, this:</p>
<p class="Pp"></p>
<pre>  print $lh-&gt;maketext(&quot;You won!&quot;), &quot;\n&quot;;
</pre>
<p class="Pp">...emits the right text for this language. If the object in
    <span class="Li">$lh</span> belongs to class
    &quot;TkBocciBall::Localize::fr&quot; and
    <span class="Li">%TkBocciBall::Localize::fr::Lexicon</span> contains
    <span class="Li">&quot;(&quot;You won!&quot;</span> <span class="Li">=&gt;
    &quot;Tu as gagne!&quot;)&quot;</span>, then the above code happily tells
    the user &quot;Tu as gagne!&quot;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<p class="Pp">Locale::Maketext offers a variety of methods, which fall into
    three categories:</p>
<ul class="Bl-bullet">
  <li>Methods to do with constructing language handles.</li>
  <li><span class="Li">&quot;maketext&quot;</span> and other methods to do with
      accessing <span class="Li">%Lexicon</span> data for a given language
      handle.</li>
  <li>Methods that you may find it handy to use, from routines of yours that you
      put in <span class="Li">%Lexicon</span> entries.</li>
</ul>
<p class="Pp">These are covered in the following section.</p>
<section class="Ss">
<h2 class="Ss" id="Construction_Methods"><a class="permalink" href="#Construction_Methods">Construction
  Methods</a></h2>
<p class="Pp">These are to do with constructing a language handle:</p>
<ul class="Bl-bullet">
  <li><span class="Li">$lh</span> = YourProjClass-&gt;get_handle( ...langtags...
      ) || die &quot;lg-handle?&quot;;
    <p class="Pp">This tries loading classes based on the language-tags you give
        (like <span class="Li">&quot;(&quot;en-US&quot;, &quot;sk&quot;,
        &quot;kon&quot;, &quot;es-MX&quot;, &quot;ja&quot;,
        &quot;i-klingon&quot;)&quot;</span>, and for the first class that
        succeeds, returns YourProjClass::<i>language</i>-&gt;<b>new()</b>.</p>
    <p class="Pp">If it runs thru the entire given list of language-tags, and
        finds no classes for those exact terms, it then tries
        &quot;superordinate&quot; language classes. So if no &quot;en-US&quot;
        class (i.e., YourProjClass::en_us) was found, nor classes for anything
        else in that list, we then try its superordinate, &quot;en&quot; (i.e.,
        YourProjClass::en), and so on thru the other language-tags in the given
        list: &quot;es&quot;. (The other language-tags in our example list:
        happen to have no superordinates.)</p>
    <p class="Pp">If none of those language-tags leads to loadable classes, we
        then try classes derived from
        YourProjClass-&gt;<b>fallback_languages()</b> and then if nothing comes
        of that, we use classes named by
        YourProjClass-&gt;<b>fallback_language_classes()</b>. Then in the
        (probably quite unlikely) event that that fails, we just return
      undef.</p>
  </li>
  <li><span class="Li">$lh</span> = YourProjClass-&gt;get_handle<b>()</b> || die
      &quot;lg-handle?&quot;;
    <p class="Pp">When <span class="Li">&quot;get_handle&quot;</span> is called
        with an empty parameter list, magic happens:</p>
    <p class="Pp">If <span class="Li">&quot;get_handle&quot;</span> senses that
        it's running in program that was invoked as a CGI, then it tries to get
        language-tags out of the environment variable
        &quot;HTTP_ACCEPT_LANGUAGE&quot;, and it pretends that those were the
        languages passed as parameters to
        <span class="Li">&quot;get_handle&quot;</span>.</p>
    <p class="Pp">Otherwise (i.e., if not a CGI), this tries various OS-specific
        ways to get the language-tags for the current locale/language, and then
        pretends that those were the value(s) passed to
        <span class="Li">&quot;get_handle&quot;</span>.</p>
    <p class="Pp">Currently this OS-specific stuff consists of looking in the
        environment variables &quot;LANG&quot; and &quot;LANGUAGE&quot;; and on
        MSWin machines (where those variables are typically unused), this also
        tries using the module Win32::Locale to get a language-tag for whatever
        language/locale is currently selected in the &quot;Regional
        Settings&quot; (or &quot;International&quot;?) Control Panel. I welcome
        further suggestions for making this do the Right Thing under other
        operating systems that support localization.</p>
    <p class="Pp">If you're using localization in an application that keeps a
        configuration file, you might consider something like this in your
        project class:</p>
    <p class="Pp"></p>
    <pre>  sub get_handle_via_config {
    my $class = $_[0];
    my $chosen_language = $Config_settings{'language'};
    my $lh;
    if($chosen_language) {
      $lh = $class-&gt;get_handle($chosen_language)
       || die &quot;No language handle for \&quot;$chosen_language\&quot;&quot;
            . &quot; or the like&quot;;
    } else {
      # Config file missing, maybe?
      $lh = $class-&gt;get_handle()
       || die &quot;Can't get a language handle&quot;;
    }
    return $lh;
  }
    </pre>
  </li>
  <li><span class="Li">$lh</span> = YourProjClass::langname-&gt;<b>new()</b>;
    <p class="Pp">This constructs a language handle. You usually <b>don't</b>
        call this directly, but instead let
        <span class="Li">&quot;get_handle&quot;</span> find a language class to
        <span class="Li">&quot;use&quot;</span> and to then call -&gt;new
      on.</p>
  </li>
  <li><span class="Li">$lh</span>-&gt;<b>init()</b>;
    <p class="Pp">This is called by -&gt;new to initialize newly-constructed
        language handles. If you define an init method in your class, remember
        that it's usually considered a good idea to call
        <span class="Li">$lh</span>-&gt;SUPER::init in it (presumably at the
        beginning), so that all classes get a chance to initialize a new object
        however they see fit.</p>
  </li>
  <li>YourProjClass-&gt;<b>fallback_languages()</b>
    <p class="Pp"><span class="Li">&quot;get_handle&quot;</span> appends the
        return value of this to the end of whatever list of languages you pass
        <span class="Li">&quot;get_handle&quot;</span>. Unless you override this
        method, your project class will inherit Locale::Maketext's
        <span class="Li">&quot;fallback_languages&quot;</span>, which currently
        returns <span class="Li">&quot;('i-default', 'en',
        'en-US')&quot;</span>. (&quot;i-default&quot; is defined in RFC
      2277).</p>
    <p class="Pp">This method (by having it return the name of a language-tag
        that has an existing language class) can be used for making sure that
        <span class="Li">&quot;get_handle&quot;</span> will always manage to
        construct a language handle (assuming your language classes are in an
        appropriate <span class="Li">@INC</span> directory). Or you can use the
        next method:</p>
  </li>
  <li>YourProjClass-&gt;<b>fallback_language_classes()</b>
    <p class="Pp"><span class="Li">&quot;get_handle&quot;</span> appends the
        return value of this to the end of the list of classes it will try
        using. Unless you override this method, your project class will inherit
        Locale::Maketext's
        <span class="Li">&quot;fallback_language_classes&quot;</span>, which
        currently returns an empty list, <span class="Li">&quot;()&quot;</span>.
        By setting this to some value (namely, the name of a loadable language
        class), you can be sure that
        <span class="Li">&quot;get_handle&quot;</span> will always manage to
        construct a language handle.</p>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="The__maketext__Method"><a class="permalink" href="#The__maketext__Method">The
  &quot;maketext&quot; Method</a></h2>
<p class="Pp">This is the most important method in Locale::Maketext:</p>
<p class="Pp"></p>
<pre>    $text = $lh-&gt;maketext(I&lt;key&gt;, ...parameters for this phrase...);
</pre>
<p class="Pp">This looks in the <span class="Li">%Lexicon</span> of the language
    handle <span class="Li">$lh</span> and all its superclasses, looking for an
    entry whose key is the string <i>key</i>. Assuming such an entry is found,
    various things then happen, depending on the value found:</p>
<p class="Pp">If the value is a scalarref, the scalar is dereferenced and
    returned (and any parameters are ignored).</p>
<p class="Pp">If the value is a coderef, we return &amp;$value($lh,
    ...parameters...).</p>
<p class="Pp">If the value is a string that <i>doesn't</i> look like it's in
    Bracket Notation, we return it (after replacing it with a scalarref, in its
    <span class="Li">%Lexicon</span>).</p>
<p class="Pp">If the value <i>does</i> look like it's in Bracket Notation, then
    we compile it into a sub, replace the string in the
    <span class="Li">%Lexicon</span> with the new coderef, and then we return
    &amp;$new_sub($lh, ...parameters...).</p>
<p class="Pp">Bracket Notation is discussed in a later section. Note that trying
    to compile a string into Bracket Notation can throw an exception if the
    string is not syntactically valid (say, by not balancing brackets
  right.)</p>
<p class="Pp">Also, calling &amp;$coderef($lh, ...parameters...) can throw any
    sort of exception (if, say, code in that sub tries to divide by zero). But a
    very common exception occurs when you have Bracket Notation text that says
    to call a method &quot;foo&quot;, but there is no such method. (E.g.,
    &quot;You have [qua<b>tn</b>,_1,ball].&quot; will throw an exception on
    trying to call <span class="Li">$lh</span>-&gt;qua<b>tn</b>($_[1],'ball') --
    you presumably meant &quot;quant&quot;.)
    <span class="Li">&quot;maketext&quot;</span> catches these exceptions, but
    only to make the error message more readable, at which point it rethrows the
    exception.</p>
<p class="Pp">An exception <i>may</i> be thrown if <i>key</i> is not found in
    any of <span class="Li">$lh</span>'s <span class="Li">%Lexicon</span>
    hashes. What happens if a key is not found, is discussed in a later section,
    &quot;Controlling Lookup Failure&quot;.</p>
<p class="Pp">Note that you might find it useful in some cases to override the
    <span class="Li">&quot;maketext&quot;</span> method with an &quot;after
    method&quot;, if you want to translate encodings, or even scripts:</p>
<p class="Pp"></p>
<pre>    package YrProj::zh_cn; # Chinese with PRC-style glyphs
    use base ('YrProj::zh_tw');  # Taiwan-style
    sub maketext {
      my $self = shift(@_);
      my $value = $self-&gt;maketext(@_);
      return Chineeze::taiwan2mainland($value);
    }
</pre>
<p class="Pp">Or you may want to override it with something that traps any
    exceptions, if that's critical to your program:</p>
<p class="Pp"></p>
<pre>  sub maketext {
    my($lh, @stuff) = @_;
    my $out;
    eval { $out = $lh-&gt;SUPER::maketext(@stuff) };
    return $out unless $@;
    ...otherwise deal with the exception...
  }
</pre>
<p class="Pp">Other than those two situations, I don't imagine that it's useful
    to override the <span class="Li">&quot;maketext&quot;</span> method. (If you
    run into a situation where it is useful, I'd be interested in hearing about
    it.)</p>
<dl class="Bl-tag">
  <dt>$lh-&gt;fail_with <i>or</i> $lh-&gt;fail_with(<i>PARAM</i>)</dt>
  <dd></dd>
  <dt>$lh-&gt;failure_handler_auto</dt>
  <dd>These two methods are discussed in the section &quot;Controlling Lookup
      Failure&quot;.</dd>
  <dt>$lh-&gt;blacklist(@list)</dt>
  <dd></dd>
  <dt>$lh-&gt;whitelist(@list)</dt>
  <dd>These methods are discussed in the section &quot;Bracket Notation
      Security&quot;.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Utility_Methods"><a class="permalink" href="#Utility_Methods">Utility
  Methods</a></h2>
<p class="Pp">These are methods that you may find it handy to use, generally
    from <span class="Li">%Lexicon</span> routines of yours (whether expressed
    as Bracket Notation or not).</p>
<dl class="Bl-tag">
  <dt>$language-&gt;quant($number, $singular)</dt>
  <dd></dd>
  <dt>$language-&gt;quant($number, $singular, $plural)</dt>
  <dd></dd>
  <dt>$language-&gt;quant($number, $singular, $plural, $negative)</dt>
  <dd>This is generally meant to be called from inside Bracket Notation (which
      is discussed later), as in
    <p class="Pp"></p>
    <pre>     &quot;Your search matched [quant,_1,document]!&quot;
    </pre>
    <p class="Pp">It's for <i>quantifying</i> a noun (i.e., saying how much of
        it there is, while giving the correct form of it). The behavior of this
        method is handy for English and a few other Western European languages,
        and you should override it for languages where it's not suitable. You
        can feel free to read the source, but the current implementation is
        basically as this pseudocode describes:</p>
    <p class="Pp"></p>
    <pre>     if $number is 0 and there's a $negative,
        return $negative;
     elsif $number is 1,
        return &quot;1 $singular&quot;;
     elsif there's a $plural,
        return &quot;$number $plural&quot;;
     else
        return &quot;$number &quot; . $singular . &quot;s&quot;;
     #
     # ...except that we actually call numf to
     #  stringify $number before returning it.
    </pre>
    <p class="Pp">So for English (with Bracket Notation)
        <span class="Li">&quot;...[quant,_1,file]...&quot;</span> is fine (for 0
        it returns &quot;0 files&quot;, for 1 it returns &quot;1 file&quot;, and
        for more it returns &quot;2 files&quot;, etc.)</p>
    <p class="Pp">But for &quot;directory&quot;, you'd want
        <span class="Li">&quot;[quant,_1,directory,directories]&quot;</span> so
        that our elementary <span class="Li">&quot;quant&quot;</span> method
        doesn't think that the plural of &quot;directory&quot; is
        &quot;directorys&quot;. And you might find that the output may sound
        better if you specify a negative form, as in:</p>
    <p class="Pp"></p>
    <pre>     &quot;[quant,_1,file,files,No files] matched your query.\n&quot;
    </pre>
    <p class="Pp">Remember to keep in mind verb agreement (or adjectives too, in
        other languages), as in:</p>
    <p class="Pp"></p>
    <pre>     &quot;[quant,_1,document] were matched.\n&quot;
    </pre>
    <p class="Pp">Because if _1 is one, you get &quot;1 document <b>were</b>
        matched&quot;. An acceptable hack here is to do something like this:</p>
    <p class="Pp"></p>
    <pre>     &quot;[quant,_1,document was, documents were] matched.\n&quot;
    </pre>
  </dd>
  <dt>$language-&gt;numf($number)</dt>
  <dd>This returns the given number formatted nicely according to this
      language's conventions. Maketext's default method is mostly to just take
      the normal string form of the number (applying sprintf &quot;%G&quot; for
      only very large numbers), and then to add commas as necessary. (Except
      that we apply <span class="Li">&quot;tr/,./.,/&quot;</span> if
      <span class="Li">$language</span>-&gt;{'numf_comma'} is true; that's a bit
      of a hack that's useful for languages that express two million as
      &quot;2.000.000&quot; and not as &quot;2,000,000&quot;).
    <p class="Pp">If you want anything fancier, consider overriding this with
        something that uses Number::Format, or does something else entirely.</p>
    <p class="Pp">Note that numf is called by quant for stringifying all
        quantifying numbers.</p>
  </dd>
  <dt>$language-&gt;numerate($number, $singular, $plural, $negative)</dt>
  <dd>This returns the given noun form which is appropriate for the quantity
      <span class="Li">$number</span> according to this language's conventions.
      <span class="Li">&quot;numerate&quot;</span> is used internally by
      <span class="Li">&quot;quant&quot;</span> to quantify nouns. Use it
      directly -- usually from bracket notation -- to avoid
      <span class="Li">&quot;quant&quot;</span>'s implicit call to
      <span class="Li">&quot;numf&quot;</span> and output of a numeric
    quantity.</dd>
  <dt>$language-&gt;sprintf($format, @items)</dt>
  <dd>This is just a wrapper around Perl's normal
      <span class="Li">&quot;sprintf&quot;</span> function. It's provided so
      that you can use &quot;sprintf&quot; in Bracket Notation:
    <p class="Pp"></p>
    <pre>     &quot;Couldn't access datanode [sprintf,%10x=~[%s~],_1,_2]!\n&quot;
    </pre>
    <p class="Pp">returning...</p>
    <p class="Pp"></p>
    <pre>     Couldn't access datanode      Stuff=[thangamabob]!
    </pre>
  </dd>
  <dt>$language-&gt;<b>language_tag()</b></dt>
  <dd>Currently this just takes the last bit of
      <span class="Li">&quot;ref($language)&quot;</span>, turns underscores to
      dashes, and returns it. So if <span class="Li">$language</span> is an
      object of class Hee::HOO::Haw::en_us,
      <span class="Li">$language</span>-&gt;<b>language_tag()</b> returns
      &quot;en-us&quot;. (Yes, the usual representation for that language tag is
      &quot;en-US&quot;, but case is <i>never</i> considered meaningful in
      language-tag comparison.)
    <p class="Pp">You may override this as you like; Maketext doesn't use it for
        anything.</p>
  </dd>
  <dt>$language-&gt;<b>encoding()</b></dt>
  <dd>Currently this isn't used for anything, but it's provided (with default
      value of <span class="Li">&quot;(ref($language) &amp;&amp;
      $language-&gt;{'encoding'})) or &quot;iso-8859-1&quot;&quot;</span> ) as a
      sort of suggestion that it may be useful/necessary to associate encodings
      with your language handles (whether on a per-class or even per-handle
      basis.)</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Language_Handle_Attributes_and_Internals"><a class="permalink" href="#Language_Handle_Attributes_and_Internals">Language
  Handle Attributes and Internals</a></h2>
<p class="Pp">A language handle is a flyweight object -- i.e., it doesn't
    (necessarily) carry any data of interest, other than just being a member of
    whatever class it belongs to.</p>
<p class="Pp">A language handle is implemented as a blessed hash. Subclasses of
    yours can store whatever data you want in the hash. Currently the only hash
    entry used by any crucial Maketext method is &quot;fail&quot;, so feel free
    to use anything else as you like.</p>
<p class="Pp"><b>Remember: Don't be afraid to read the Maketext source if
    there's</b> <b>any point on which this documentation is unclear.</b> This
    documentation is vastly longer than the module source itself.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="LANGUAGE_CLASS_HIERARCHIES"><a class="permalink" href="#LANGUAGE_CLASS_HIERARCHIES">LANGUAGE
  CLASS HIERARCHIES</a></h1>
<p class="Pp">These are Locale::Maketext's assumptions about the class hierarchy
    formed by all your language classes:</p>
<ul class="Bl-bullet">
  <li>You must have a project base class, which you load, and which you then use
      as the first argument in the call to YourProjClass-&gt;get_handle(...). It
      should derive (whether directly or indirectly) from Locale::Maketext. It
      <b>doesn't matter</b> how you name this class, although assuming this is
      the localization component of your Super Mega Program, good names for your
      project class might be SuperMegaProgram::Localization,
      SuperMegaProgram::L10N, SuperMegaProgram::I18N,
      SuperMegaProgram::International, or even SuperMegaProgram::Languages or
      SuperMegaProgram::Messages.</li>
  <li>Language classes are what YourProjClass-&gt;get_handle will try to load.
      It will look for them by taking each language-tag (<b>skipping</b> it if
      it doesn't look like a language-tag or locale-tag!), turning it to all
      lowercase, turning dashes to underscores, and appending it to
      YourProjClass . &quot;::&quot;. So this:
    <p class="Pp"></p>
    <pre>  $lh = YourProjClass-&gt;get_handle(
    'en-US', 'fr', 'kon', 'i-klingon', 'i-klingon-romanized'
  );
    </pre>
    <p class="Pp">will try loading the classes YourProjClass::en_us (note
        lowercase!), YourProjClass::fr, YourProjClass::kon,
        YourProjClass::i_klingon and YourProjClass::i_klingon_romanized. (And
        it'll stop at the first one that actually loads.)</p>
  </li>
  <li>I assume that each language class derives (directly or indirectly) from
      your project class, and also defines its <span class="Li">@ISA</span>, its
      <span class="Li">%Lexicon</span>, or both. But I anticipate no dire
      consequences if these assumptions do not hold.</li>
  <li>Language classes may derive from other language classes (although they
      should have &quot;use <i>Thatclassname</i>&quot; or &quot;use base
      qw(<i>...classes...</i>)&quot;). They may derive from the project class.
      They may derive from some other class altogether. Or via multiple
      inheritance, it may derive from any mixture of these.</li>
  <li>I foresee no problems with having multiple inheritance in your hierarchy
      of language classes. (As usual, however, Perl will complain bitterly if
      you have a cycle in the hierarchy: i.e., if any class is its own
      ancestor.)</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="ENTRIES_IN_EACH_LEXICON"><a class="permalink" href="#ENTRIES_IN_EACH_LEXICON">ENTRIES
  IN EACH LEXICON</a></h1>
<p class="Pp">A typical <span class="Li">%Lexicon</span> entry is meant to
    signify a phrase, taking some number (0 or more) of parameters. An entry is
    meant to be accessed by via a string <i>key</i> in
    <span class="Li">$lh</span>-&gt;maketext(<i>key</i>, ...parameters...),
    which should return a string that is generally meant for be used for
    &quot;output&quot; to the user -- regardless of whether this actually means
    printing to STDOUT, writing to a file, or putting into a GUI widget.</p>
<p class="Pp">While the key must be a string value (since that's a basic
    restriction that Perl places on hash keys), the value in the lexicon can
    currently be of several types: a defined scalar, scalarref, or coderef. The
    use of these is explained above, in the section 'The &quot;maketext&quot;
    Method', and Bracket Notation for strings is discussed in the next
  section.</p>
<p class="Pp">While you can use arbitrary unique IDs for lexicon keys (like
    &quot;_min_larger_max_error&quot;), it is often useful for if an entry's key
    is itself a valid value, like this example error message:</p>
<p class="Pp"></p>
<pre>  &quot;Minimum ([_1]) is larger than maximum ([_2])!\n&quot;,
</pre>
<p class="Pp">Compare this code that uses an arbitrary ID...</p>
<p class="Pp"></p>
<pre>  die $lh-&gt;maketext( &quot;_min_larger_max_error&quot;, $min, $max )
   if $min &gt; $max;
</pre>
<p class="Pp">...to this code that uses a key-as-value:</p>
<p class="Pp"></p>
<pre>  die $lh-&gt;maketext(
   &quot;Minimum ([_1]) is larger than maximum ([_2])!\n&quot;,
   $min, $max
  ) if $min &gt; $max;
</pre>
<p class="Pp">The second is, in short, more readable. In particular, it's
    obvious that the number of parameters you're feeding to that phrase (two) is
    the number of parameters that it <i>wants</i> to be fed. (Since you see _1
    and a _2 being used in the key there.)</p>
<p class="Pp">Also, once a project is otherwise complete and you start to
    localize it, you can scrape together all the various keys you use, and pass
    it to a translator; and then the translator's work will go faster if what
    he's presented is this:</p>
<p class="Pp"></p>
<pre> &quot;Minimum ([_1]) is larger than maximum ([_2])!\n&quot;,
  =&gt; &quot;&quot;,   # fill in something here, Jacques!
</pre>
<p class="Pp">rather than this more cryptic mess:</p>
<p class="Pp"></p>
<pre> &quot;_min_larger_max_error&quot;
  =&gt; &quot;&quot;,   # fill in something here, Jacques
</pre>
<p class="Pp">I think that keys as lexicon values makes the completed lexicon
    entries more readable:</p>
<p class="Pp"></p>
<pre> &quot;Minimum ([_1]) is larger than maximum ([_2])!\n&quot;,
  =&gt; &quot;Le minimum ([_1]) est plus grand que le maximum ([_2])!\n&quot;,
</pre>
<p class="Pp">Also, having valid values as keys becomes very useful if you set
    up an _AUTO lexicon. _AUTO lexicons are discussed in a later section.</p>
<p class="Pp">I almost always use keys that are themselves valid lexicon values.
    One notable exception is when the value is quite long. For example, to get
    the screenful of data that a command-line program might return when given an
    unknown switch, I often just use a brief, self-explanatory key such as
    &quot;_USAGE_MESSAGE&quot;. At that point I then go and immediately to
    define that lexicon entry in the ProjectClass::L10N::en lexicon (since
    English is always my &quot;project language&quot;):</p>
<p class="Pp"></p>
<pre>  '_USAGE_MESSAGE' =&gt; &lt;&lt;'EOSTUFF',
  ...long long message...
  EOSTUFF
</pre>
<p class="Pp">and then I can use it as:</p>
<p class="Pp"></p>
<pre>  getopt('oDI', \%opts) or die $lh-&gt;maketext('_USAGE_MESSAGE');
</pre>
<p class="Pp">Incidentally, note that each class's
    <span class="Li">%Lexicon</span> inherits-and-extends the lexicons in its
    superclasses. This is not because these are special hashes <i>per se</i>,
    but because you access them via the
    <span class="Li">&quot;maketext&quot;</span> method, which looks for entries
    across all the <span class="Li">%Lexicon</span> hashes in a language class
    <i>and</i> all its ancestor classes. (This is because the idea of
    &quot;class data&quot; isn't directly implemented in Perl, but is instead
    left to individual class-systems to implement as they see fit..)</p>
<p class="Pp">Note that you may have things stored in a lexicon besides just
    phrases for output: for example, if your program takes input from the
    keyboard, asking a &quot;(Y/N)&quot; question, you probably need to know
    what the equivalent of &quot;Y[es]/N[o]&quot; is in whatever language. You
    probably also need to know what the equivalents of the answers &quot;y&quot;
    and &quot;n&quot; are. You can store that information in the lexicon (say,
    under the keys &quot;~answer_y&quot; and &quot;~answer_n&quot;, and the long
    forms as &quot;~answer_yes&quot; and &quot;~answer_no&quot;, where
    &quot;~&quot; is just an ad-hoc character meant to indicate to
    programmers/translators that these are not phrases for output).</p>
<p class="Pp">Or instead of storing this in the language class's lexicon, you
    can (and, in some cases, really should) represent the same bit of knowledge
    as code in a method in the language class. (That leaves a tidy distinction
    between the lexicon as the things we know how to <i>say</i>, and the rest of
    the things in the lexicon class as things that we know how to <i>do</i>.)
    Consider this example of a processor for responses to French
    &quot;oui/non&quot; questions:</p>
<p class="Pp"></p>
<pre>  sub y_or_n {
    return undef unless defined $_[1] and length $_[1];
    my $answer = lc $_[1];  # smash case
    return 1 if $answer eq 'o' or $answer eq 'oui';
    return 0 if $answer eq 'n' or $answer eq 'non';
    return undef;
  }
</pre>
<p class="Pp">...which you'd then call in a construct like this:</p>
<p class="Pp"></p>
<pre>  my $response;
  until(defined $response) {
    print $lh-&gt;maketext(&quot;Open the pod bay door (y/n)? &quot;);
    $response = $lh-&gt;y_or_n( get_input_from_keyboard_somehow() );
  }
  if($response) { $pod_bay_door-&gt;open()         }
  else          { $pod_bay_door-&gt;leave_closed() }
</pre>
<p class="Pp">Other data worth storing in a lexicon might be things like
    filenames for language-targetted resources:</p>
<p class="Pp"></p>
<pre>  ...
  &quot;_main_splash_png&quot;
    =&gt; &quot;/styles/en_us/main_splash.png&quot;,
  &quot;_main_splash_imagemap&quot;
    =&gt; &quot;/styles/en_us/main_splash.incl&quot;,
  &quot;_general_graphics_path&quot;
    =&gt; &quot;/styles/en_us/&quot;,
  &quot;_alert_sound&quot;
    =&gt; &quot;/styles/en_us/hey_there.wav&quot;,
  &quot;_forward_icon&quot;
   =&gt; &quot;left_arrow.png&quot;,
  &quot;_backward_icon&quot;
   =&gt; &quot;right_arrow.png&quot;,
  # In some other languages, left equals
  #  BACKwards, and right is FOREwards.
  ...
</pre>
<p class="Pp">You might want to do the same thing for expressing key bindings or
    the like (since hardwiring &quot;q&quot; as the binding for the function
    that quits a screen/menu/program is useful only if your language happens to
    associate &quot;q&quot; with &quot;quit&quot;!)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BRACKET_NOTATION"><a class="permalink" href="#BRACKET_NOTATION">BRACKET
  NOTATION</a></h1>
<p class="Pp">Bracket Notation is a crucial feature of Locale::Maketext. I mean
    Bracket Notation to provide a replacement for the use of sprintf formatting.
    Everything you do with Bracket Notation could be done with a sub block, but
    bracket notation is meant to be much more concise.</p>
<p class="Pp">Bracket Notation is a like a miniature &quot;template&quot; system
    (in the sense of Text::Template, not in the sense of C++ templates), where
    normal text is passed thru basically as is, but text in special regions is
    specially interpreted. In Bracket Notation, you use square brackets
    (&quot;[...]&quot;), not curly braces (&quot;{...}&quot;) to note sections
    that are specially interpreted.</p>
<p class="Pp">For example, here all the areas that are taken literally are
    underlined with a &quot;^&quot;, and all the in-bracket special regions are
    underlined with an X:</p>
<p class="Pp"></p>
<pre>  &quot;Minimum ([_1]) is larger than maximum ([_2])!\n&quot;,
   ^^^^^^^^^ XX ^^^^^^^^^^^^^^^^^^^^^^^^^^ XX ^^^^
</pre>
<p class="Pp">When that string is compiled from bracket notation into a real
    Perl sub, it's basically turned into:</p>
<p class="Pp"></p>
<pre>  sub {
    my $lh = $_[0];
    my @params = @_;
    return join '',
      &quot;Minimum (&quot;,
      ...some code here...
      &quot;) is larger than maximum (&quot;,
      ...some code here...
      &quot;)!\n&quot;,
  }
  # to be called by $lh-&gt;maketext(KEY, params...)
</pre>
<p class="Pp">In other words, text outside bracket groups is turned into string
    literals. Text in brackets is rather more complex, and currently follows
    these rules:</p>
<ul class="Bl-bullet">
  <li>Bracket groups that are empty, or which consist only of whitespace, are
      ignored. (Examples: &quot;[]&quot;, &quot;[ ]&quot;, or a [ and a ] with
      returns and/or tabs and/or spaces between them.
    <p class="Pp">Otherwise, each group is taken to be a comma-separated group
        of items, and each item is interpreted as follows:</p>
  </li>
  <li>An item that is &quot;_<i>digits</i>&quot; or &quot;_-<i>digits</i>&quot;
      is interpreted as <span class="Li">$_</span>[<i>value</i>]. I.e.,
      &quot;_1&quot; becomes with <span class="Li">$_</span>[1], and
      &quot;_-3&quot; is interpreted as <span class="Li">$_</span>[-3] (in which
      case <span class="Li">@_</span> should have at least three elements in
      it). Note that <span class="Li">$_</span>[0] is the language handle, and
      is typically not named directly.</li>
  <li>An item &quot;_*&quot; is interpreted to mean &quot;all of
      <span class="Li">@_</span> except <span class="Li">$_</span>[0]&quot;.
      I.e., <span class="Li">@_[1..$#_]</span>. Note that this is an empty list
      in the case of calls like
      <span class="Li">$lh</span>-&gt;maketext(<i>key</i>) where there are no
      parameters (except <span class="Li">$_</span>[0], the language
    handle).</li>
  <li>Otherwise, each item is interpreted as a string literal.</li>
</ul>
<p class="Pp">The group as a whole is interpreted as follows:</p>
<ul class="Bl-bullet">
  <li>If the first item in a bracket group looks like a method name, then that
      group is interpreted like this:
    <p class="Pp"></p>
    <pre>  $lh-&gt;that_method_name(
    ...rest of items in this group...
  ),
    </pre>
  </li>
  <li>If the first item in a bracket group is &quot;*&quot;, it's taken as
      shorthand for the so commonly called &quot;quant&quot; method. Similarly,
      if the first item in a bracket group is &quot;#&quot;, it's taken to be
      shorthand for &quot;numf&quot;.</li>
  <li>If the first item in a bracket group is the empty-string, or
      &quot;_*&quot; or &quot;_<i>digits</i>&quot; or
      &quot;_-<i>digits</i>&quot;, then that group is interpreted as just the
      interpolation of all its items:
    <p class="Pp"></p>
    <pre>  join('',
    ...rest of items in this group...
  ),
    </pre>
    <p class="Pp">Examples: &quot;[_1]&quot; and &quot;[,_1]&quot;, which are
        synonymous; and
        &quot;<span class="Li">&quot;[,ID-(,_4,-,_2,)]&quot;</span>&quot;, which
        compiles as <span class="Li">&quot;join &quot;&quot;, &quot;ID-(&quot;,
        $_[4], &quot;-&quot;, $_[2], &quot;)&quot;&quot;</span>.</p>
  </li>
  <li>Otherwise this bracket group is invalid. For example, in the group
      &quot;[!@#,whatever]&quot;, the first item
      <span class="Li">&quot;!@#&quot;</span> is neither the empty-string,
      &quot;_<i>number</i>&quot;, &quot;_-<i>number</i>&quot;, &quot;_*&quot;,
      nor a valid method name; and so Locale::Maketext will throw an exception
      of you try compiling an expression containing this bracket group.</li>
</ul>
<p class="Pp">Note, incidentally, that items in each group are comma-separated,
    not <span class="Li">&quot;/\s*,\s*/&quot;</span>-separated. That is, you
    might expect that this bracket group:</p>
<p class="Pp"></p>
<pre>  &quot;Hoohah [foo, _1 , bar ,baz]!&quot;
</pre>
<p class="Pp">would compile to this:</p>
<p class="Pp"></p>
<pre>  sub {
    my $lh = $_[0];
    return join '',
      &quot;Hoohah &quot;,
      $lh-&gt;foo( $_[1], &quot;bar&quot;, &quot;baz&quot;),
      &quot;!&quot;,
  }
</pre>
<p class="Pp">But it actually compiles as this:</p>
<p class="Pp"></p>
<pre>  sub {
    my $lh = $_[0];
    return join '',
      &quot;Hoohah &quot;,
      $lh-&gt;foo(&quot; _1 &quot;, &quot; bar &quot;, &quot;baz&quot;),  # note the &lt;space&gt; in &quot; bar &quot;
      &quot;!&quot;,
  }
</pre>
<p class="Pp">In the notation discussed so far, the characters &quot;[&quot; and
    &quot;]&quot; are given special meaning, for opening and closing bracket
    groups, and &quot;,&quot; has a special meaning inside bracket groups, where
    it separates items in the group. This begs the question of how you'd express
    a literal &quot;[&quot; or &quot;]&quot; in a Bracket Notation string, and
    how you'd express a literal comma inside a bracket group. For this purpose
    I've adopted &quot;~&quot; (tilde) as an escape character: &quot;~[&quot;
    means a literal '[' character anywhere in Bracket Notation (i.e., regardless
    of whether you're in a bracket group or not), and ditto for &quot;~]&quot;
    meaning a literal ']', and &quot;~,&quot; meaning a literal comma. (Altho
    &quot;,&quot; means a literal comma outside of bracket groups -- it's only
    inside bracket groups that commas are special.)</p>
<p class="Pp">And on the off chance you need a literal tilde in a bracket
    expression, you get it with &quot;~~&quot;.</p>
<p class="Pp">Currently, an unescaped &quot;~&quot; before a character other
    than a bracket or a comma is taken to mean just a &quot;~&quot; and that
    character. I.e., &quot;~X&quot; means the same as &quot;~~X&quot; -- i.e.,
    one literal tilde, and then one literal &quot;X&quot;. However, by using
    &quot;~X&quot;, you are assuming that no future version of Maketext will use
    &quot;~X&quot; as a magic escape sequence. In practice this is not a great
    problem, since first off you can just write &quot;~~X&quot; and not worry
    about it; second off, I doubt I'll add lots of new magic characters to
    bracket notation; and third off, you aren't likely to want literal
    &quot;~&quot; characters in your messages anyway, since it's not a character
    with wide use in natural language text.</p>
<p class="Pp">Brackets must be balanced -- every openbracket must have one
    matching closebracket, and vice versa. So these are all <b>invalid</b>:</p>
<p class="Pp"></p>
<pre>  &quot;I ate [quant,_1,rhubarb pie.&quot;
  &quot;I ate [quant,_1,rhubarb pie[.&quot;
  &quot;I ate quant,_1,rhubarb pie].&quot;
  &quot;I ate quant,_1,rhubarb pie[.&quot;
</pre>
<p class="Pp">Currently, bracket groups do not nest. That is, you <b>cannot</b>
    say:</p>
<p class="Pp"></p>
<pre>  &quot;Foo [bar,baz,[quux,quuux]]\n&quot;;
</pre>
<p class="Pp">If you need a notation that's that powerful, use normal Perl:</p>
<p class="Pp"></p>
<pre>  %Lexicon = (
    ...
    &quot;some_key&quot; =&gt; sub {
      my $lh = $_[0];
      join '',
        &quot;Foo &quot;,
        $lh-&gt;bar('baz', $lh-&gt;quux('quuux')),
        &quot;\n&quot;,
    },
    ...
  );
</pre>
<p class="Pp">Or write the &quot;bar&quot; method so you don't need to pass it
    the output from calling quux.</p>
<p class="Pp">I do not anticipate that you will need (or particularly want) to
    nest bracket groups, but you are welcome to email me with convincing
    (real-life) arguments to the contrary.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BRACKET_NOTATION_SECURITY"><a class="permalink" href="#BRACKET_NOTATION_SECURITY">BRACKET
  NOTATION SECURITY</a></h1>
<p class="Pp">Locale::Maketext does not use any special syntax to differentiate
    bracket notation methods from normal class or object methods. This design
    makes it vulnerable to format string attacks whenever it is used to process
    strings provided by untrusted users.</p>
<p class="Pp">Locale::Maketext does support blacklist and whitelist
    functionality to limit which methods may be called as bracket notation
    methods.</p>
<p class="Pp">By default, Locale::Maketext blacklists all methods in the
    Locale::Maketext namespace that begin with the '_' character, and all
    methods which include Perl's namespace separator characters.</p>
<p class="Pp">The default blacklist for Locale::Maketext also prevents use of
    the following methods in bracket notation:</p>
<p class="Pp"></p>
<pre>  blacklist
  encoding
  fail_with
  failure_handler_auto
  fallback_language_classes
  fallback_languages
  get_handle
  init
  language_tag
  maketext
  new
  whitelist
</pre>
<p class="Pp">This list can be extended by either blacklisting additional
    &quot;known bad&quot; methods, or whitelisting only &quot;known good&quot;
    methods.</p>
<p class="Pp">To prevent specific methods from being called in bracket notation,
    use the <b>blacklist()</b> method:</p>
<p class="Pp"></p>
<pre>  my $lh = MyProgram::L10N-&gt;get_handle();
  $lh-&gt;blacklist(qw{my_internal_method my_other_method});
  $lh-&gt;maketext('[my_internal_method]'); # dies
</pre>
<p class="Pp">To limit the allowed bracked notation methods to a specific list,
    use the <b>whitelist()</b> method:</p>
<p class="Pp"></p>
<pre>  my $lh = MyProgram::L10N-&gt;get_handle();
  $lh-&gt;whitelist('numerate', 'numf');
  $lh-&gt;maketext('[_1] [numerate, _1,shoe,shoes]', 12); # works
  $lh-&gt;maketext('[my_internal_method]'); # dies
</pre>
<p class="Pp">The <b>blacklist()</b> and <b>whitelist()</b> methods extend their
    internal lists whenever they are called. To reset the blacklist or
    whitelist, create a new maketext object.</p>
<p class="Pp"></p>
<pre>  my $lh = MyProgram::L10N-&gt;get_handle();
  $lh-&gt;blacklist('numerate');
  $lh-&gt;blacklist('numf');
  $lh-&gt;maketext('[_1] [numerate,_1,shoe,shoes]', 12); # dies
</pre>
<p class="Pp">For lexicons that use an internal cache, translations which have
    already been cached in their compiled form are not affected by subsequent
    changes to the whitelist or blacklist settings. Lexicons that use an
    external cache will have their cache cleared whenever the whitelist of
    blacklist setings change. The difference between the two types of caching is
    explained in the &quot;Readonly Lexicons&quot; section.</p>
<p class="Pp">Methods disallowed by the blacklist cannot be permitted by the
    whitelist.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTO_LEXICONS"><a class="permalink" href="#AUTO_LEXICONS">AUTO
  LEXICONS</a></h1>
<p class="Pp">If maketext goes to look in an individual
    <span class="Li">%Lexicon</span> for an entry for <i>key</i> (where
    <i>key</i> does not start with an underscore), and sees none, <b>but does
    see</b> an entry of &quot;_AUTO&quot; =&gt; <i>some_true_value</i>, then we
    actually define <span class="Li">$Lexicon</span>{<i>key</i>} = <i>key</i>
    right then and there, and then use that value as if it had been there all
    along. This happens before we even look in any superclass
    <span class="Li">%Lexicons</span>!</p>
<p class="Pp">(This is meant to be somewhat like the AUTOLOAD mechanism in
    Perl's function call system -- or, looked at another way, like the
    AutoLoader module.)</p>
<p class="Pp">I can picture all sorts of circumstances where you just do not
    want lookup to be able to fail (since failing normally means that maketext
    throws a <span class="Li">&quot;die&quot;</span>, although see the next
    section for greater control over that). But here's one circumstance where
    _AUTO lexicons are meant to be <i>especially</i> useful:</p>
<p class="Pp">As you're writing an application, you decide as you go what
    messages you need to emit. Normally you'd go to write this:</p>
<p class="Pp"></p>
<pre>  if(-e $filename) {
    go_process_file($filename)
  } else {
    print qq{Couldn't find file &quot;$filename&quot;!\n};
  }
</pre>
<p class="Pp">but since you anticipate localizing this, you write:</p>
<p class="Pp"></p>
<pre>  use ThisProject::I18N;
  my $lh = ThisProject::I18N-&gt;get_handle();
   # For the moment, assume that things are set up so
   # that we load class ThisProject::I18N::en
   # and that that's the class that $lh belongs to.
  ...
  if(-e $filename) {
    go_process_file($filename)
  } else {
    print $lh-&gt;maketext(
      qq{Couldn't find file &quot;[_1]&quot;!\n}, $filename
    );
  }
</pre>
<p class="Pp">Now, right after you've just written the above lines, you'd
    normally have to go open the file ThisProject/I18N/en.pm, and immediately
    add an entry:</p>
<p class="Pp"></p>
<pre>  &quot;Couldn't find file \&quot;[_1]\&quot;!\n&quot;
  =&gt; &quot;Couldn't find file \&quot;[_1]\&quot;!\n&quot;,
</pre>
<p class="Pp">But I consider that somewhat of a distraction from the work of
    getting the main code working -- to say nothing of the fact that I often
    have to play with the program a few times before I can decide exactly what
    wording I want in the messages (which in this case would require me to go
    changing three lines of code: the call to maketext with that key, and then
    the two lines in ThisProject/I18N/en.pm).</p>
<p class="Pp">However, if you set &quot;_AUTO =&gt; 1&quot; in the
    <span class="Li">%Lexicon</span> in, ThisProject/I18N/en.pm (assuming that
    English (en) is the language that all your programmers will be using for
    this project's internal message keys), then you don't ever have to go adding
    lines like this</p>
<p class="Pp"></p>
<pre>  &quot;Couldn't find file \&quot;[_1]\&quot;!\n&quot;
  =&gt; &quot;Couldn't find file \&quot;[_1]\&quot;!\n&quot;,
</pre>
<p class="Pp">to ThisProject/I18N/en.pm, because if _AUTO is true there, then
    just looking for an entry with the key &quot;Couldn't find file
    \&quot;[_1]\&quot;!\n&quot; in that lexicon will cause it to be added, with
    that value!</p>
<p class="Pp">Note that the reason that keys that start with &quot;_&quot; are
    immune to _AUTO isn't anything generally magical about the underscore
    character -- I just wanted a way to have most lexicon keys be autoable,
    except for possibly a few, and I arbitrarily decided to use a leading
    underscore as a signal to distinguish those few.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="READONLY_LEXICONS"><a class="permalink" href="#READONLY_LEXICONS">READONLY
  LEXICONS</a></h1>
<p class="Pp">If your lexicon is a tied hash the simple act of caching the
    compiled value can be fatal.</p>
<p class="Pp">For example a GDBM_File GDBM_READER tied hash will die with
    something like:</p>
<p class="Pp"></p>
<pre>   gdbm store returned -1, errno 2, key &quot;...&quot; at ...
</pre>
<p class="Pp">All you need to do is turn on caching outside of the lexicon hash
    itself like so:</p>
<p class="Pp"></p>
<pre>   sub init {
       my ($lh) = @_;
       ...
       $lh-&gt;{'use_external_lex_cache'} = 1;
       ...
   }
</pre>
<p class="Pp">And then instead of storing the compiled value in the lexicon hash
    it will store it in
  <span class="Li">$lh</span>-&gt;{'_external_lex_cache'}</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTROLLING_LOOKUP_FAILURE"><a class="permalink" href="#CONTROLLING_LOOKUP_FAILURE">CONTROLLING
  LOOKUP FAILURE</a></h1>
<p class="Pp">If you call <span class="Li">$lh</span>-&gt;maketext(<i>key</i>,
    ...parameters...), and there's no entry <i>key</i> in
    <span class="Li">$lh</span>'s class's <span class="Li">%Lexicon</span>, nor
    in the superclass <span class="Li">%Lexicon</span> hash, <i>and</i> if we
    can't auto-make <i>key</i> (because either it starts with a &quot;_&quot;,
    or because none of its lexicons have <span class="Li">&quot;_AUTO =&gt;
    1,&quot;</span>), then we have failed to find a normal way to maketext
    <i>key</i>. What then happens in these failure conditions, depends on the
    <span class="Li">$lh</span> object's &quot;fail&quot; attribute.</p>
<p class="Pp">If the language handle has no &quot;fail&quot; attribute, maketext
    will simply throw an exception (i.e., it calls
    <span class="Li">&quot;die&quot;</span>, mentioning the <i>key</i> whose
    lookup failed, and naming the line number where the calling
    <span class="Li">$lh</span>-&gt;maketext(<i>key</i>,...) was.</p>
<p class="Pp">If the language handle has a &quot;fail&quot; attribute whose
    value is a coderef, then
    <span class="Li">$lh</span>-&gt;maketext(<i>key</i>,...params...) gives up
    and calls:</p>
<p class="Pp"></p>
<pre>  return $that_subref-&gt;($lh, $key, @params);
</pre>
<p class="Pp">Otherwise, the &quot;fail&quot; attribute's value should be a
    string denoting a method name, so that
    <span class="Li">$lh</span>-&gt;maketext(<i>key</i>,...params...) can give
    up with:</p>
<p class="Pp"></p>
<pre>  return $lh-&gt;$that_method_name($phrase, @params);
</pre>
<p class="Pp">The &quot;fail&quot; attribute can be accessed with the
    <span class="Li">&quot;fail_with&quot;</span> method:</p>
<p class="Pp"></p>
<pre>  # Set to a coderef:
  $lh-&gt;fail_with( \&amp;failure_handler );
  # Set to a method name:
  $lh-&gt;fail_with( 'failure_method' );
  # Set to nothing (i.e., so failure throws a plain exception)
  $lh-&gt;fail_with( undef );
  # Get the current value
  $handler = $lh-&gt;fail_with();
</pre>
<p class="Pp">Now, as to what you may want to do with these handlers: Maybe
    you'd want to log what key failed for what class, and then die. Maybe you
    don't like <span class="Li">&quot;die&quot;</span> and instead you want to
    send the error message to STDOUT (or wherever) and then merely
    <span class="Li">&quot;exit()&quot;</span>.</p>
<p class="Pp">Or maybe you don't want to <span class="Li">&quot;die&quot;</span>
    at all! Maybe you could use a handler like this:</p>
<p class="Pp"></p>
<pre>  # Make all lookups fall back onto an English value,
  #  but only after we log it for later fingerpointing.
  my $lh_backup = ThisProject-&gt;get_handle('en');
  open(LEX_FAIL_LOG, &quot;&gt;&gt;wherever/lex.log&quot;) || die &quot;GNAARGH $!&quot;;
  sub lex_fail {
    my($failing_lh, $key, $params) = @_;
    print LEX_FAIL_LOG scalar(localtime), &quot;\t&quot;,
       ref($failing_lh), &quot;\t&quot;, $key, &quot;\n&quot;;
    return $lh_backup-&gt;maketext($key,@params);
  }
</pre>
<p class="Pp">Some users have expressed that they think this whole mechanism of
    having a &quot;fail&quot; attribute at all, seems a rather pointless
    complication. But I want Locale::Maketext to be usable for software projects
    of <i>any</i> scale and type; and different software projects have different
    ideas of what the right thing is to do in failure conditions. I could simply
    say that failure always throws an exception, and that if you want to be
    careful, you'll just have to wrap every call to
    <span class="Li">$lh</span>-&gt;maketext in an eval&#x00A0;{&#x00A0;}.
    However, I want programmers to reserve the right (via the &quot;fail&quot;
    attribute) to treat lookup failure as something other than an exception of
    the same level of severity as a config file being unreadable, or some
    essential resource being inaccessible.</p>
<p class="Pp">One possibly useful value for the &quot;fail&quot; attribute is
    the method name &quot;failure_handler_auto&quot;. This is a method defined
    in the class Locale::Maketext itself. You set it with:</p>
<p class="Pp"></p>
<pre>  $lh-&gt;fail_with('failure_handler_auto');
</pre>
<p class="Pp">Then when you call
    <span class="Li">$lh</span>-&gt;maketext(<i>key</i>, ...parameters...) and
    there's no <i>key</i> in any of those lexicons, maketext gives up with</p>
<p class="Pp"></p>
<pre>  return $lh-&gt;failure_handler_auto($key, @params);
</pre>
<p class="Pp">But failure_handler_auto, instead of dying or anything, compiles
    <span class="Li">$key</span>, caching it in</p>
<p class="Pp"></p>
<pre>    $lh-&gt;{'failure_lex'}{$key} = $compiled
</pre>
<p class="Pp">and then calls the compiled value, and returns that. (I.e., if
    <span class="Li">$key</span> looks like bracket notation,
    <span class="Li">$compiled</span> is a sub, and we return
    &amp;{$compiled}(@params); but if <span class="Li">$key</span> is just a
    plain string, we just return that.)</p>
<p class="Pp">The effect of using &quot;failure_auto_handler&quot; is like an
    AUTO lexicon, except that it 1) compiles <span class="Li">$key</span> even
    if it starts with &quot;_&quot;, and 2) you have a record in the new hashref
    <span class="Li">$lh</span>-&gt;{'failure_lex'} of all the keys that have
    failed for this object. This should avoid your program dying -- as long as
    your keys aren't actually invalid as bracket code, and as long as they don't
    try calling methods that don't exist.</p>
<p class="Pp">&quot;failure_auto_handler&quot; may not be exactly what you want,
    but I hope it at least shows you that maketext failure can be mitigated in
    any number of very flexible ways. If you can formalize exactly what you
    want, you should be able to express that as a failure handler. You can even
    make it default for every object of a given class, by setting it in that
    class's init:</p>
<p class="Pp"></p>
<pre>  sub init {
    my $lh = $_[0];  # a newborn handle
    $lh-&gt;SUPER::init();
    $lh-&gt;fail_with('my_clever_failure_handler');
    return;
  }
  sub my_clever_failure_handler {
    ...you clever things here...
  }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="HOW_TO_USE_MAKETEXT"><a class="permalink" href="#HOW_TO_USE_MAKETEXT">HOW
  TO USE MAKETEXT</a></h1>
<p class="Pp">Here is a brief checklist on how to use Maketext to localize
    applications:</p>
<ul class="Bl-bullet">
  <li>Decide what system you'll use for lexicon keys. If you insist, you can use
      opaque IDs (if you're nostalgic for
      <span class="Li">&quot;catgets&quot;</span>), but I have better
      suggestions in the section &quot;Entries in Each Lexicon&quot;, above.
      Assuming you opt for meaningful keys that double as values (like
      &quot;Minimum ([_1]) is larger than maximum ([_2])!\n&quot;), you'll have
      to settle on what language those should be in. For the sake of argument,
      I'll call this English, specifically American English,
    &quot;en-US&quot;.</li>
  <li>Create a class for your localization project. This is the name of the
      class that you'll use in the idiom:
    <p class="Pp"></p>
    <pre>  use Projname::L10N;
  my $lh = Projname::L10N-&gt;get_handle(...) || die &quot;Language?&quot;;
    </pre>
    <p class="Pp">Assuming you call your class Projname::L10N, create a class
        consisting minimally of:</p>
    <p class="Pp"></p>
    <pre>  package Projname::L10N;
  use base qw(Locale::Maketext);
  ...any methods you might want all your languages to share...
  # And, assuming you want the base class to be an _AUTO lexicon,
  # as is discussed a few sections up:
  1;
    </pre>
  </li>
  <li>Create a class for the language your internal keys are in. Name the class
      after the language-tag for that language, in lowercase, with dashes
      changed to underscores. Assuming your project's first language is US
      English, you should call this Projname::L10N::en_us. It should consist
      minimally of:
    <p class="Pp"></p>
    <pre>  package Projname::L10N::en_us;
  use base qw(Projname::L10N);
  %Lexicon = (
    '_AUTO' =&gt; 1,
  );
  1;
    </pre>
    <p class="Pp">(For the rest of this section, I'll assume that this
        &quot;first language class&quot; of Projname::L10N::en_us has _AUTO
        lexicon.)</p>
  </li>
  <li>Go and write your program. Everywhere in your program where you would say:
    <p class="Pp"></p>
    <pre>  print &quot;Foobar $thing stuff\n&quot;;
    </pre>
    <p class="Pp">instead do it thru maketext, using no variable interpolation
        in the key:</p>
    <p class="Pp"></p>
    <pre>  print $lh-&gt;maketext(&quot;Foobar [_1] stuff\n&quot;, $thing);
    </pre>
    <p class="Pp">If you get tired of constantly saying
        <span class="Li">&quot;print $lh-&gt;maketext&quot;</span>, consider
        making a functional wrapper for it, like so:</p>
    <p class="Pp"></p>
    <pre>  use Projname::L10N;
  our $lh;
  $lh = Projname::L10N-&gt;get_handle(...) || die &quot;Language?&quot;;
  sub pmt (@) { print( $lh-&gt;maketext(@_)) }
   # &quot;pmt&quot; is short for &quot;Print MakeText&quot;
  $Carp::Verbose = 1;
   # so if maketext fails, we see made the call to pmt
    </pre>
    <p class="Pp">Besides whole phrases meant for output, anything
        language-dependent should be put into the class Projname::L10N::en_us,
        whether as methods, or as lexicon entries -- this is discussed in the
        section &quot;Entries in Each Lexicon&quot;, above.</p>
  </li>
  <li>Once the program is otherwise done, and once its localization for the
      first language works right (via the data and methods in
      Projname::L10N::en_us), you can get together the data for translation. If
      your first language lexicon isn't an _AUTO lexicon, then you already have
      all the messages explicitly in the lexicon (or else you'd be getting
      exceptions thrown when you call <span class="Li">$lh</span>-&gt;maketext
      to get messages that aren't in there). But if you were (advisedly) lazy
      and are using an _AUTO lexicon, then you've got to make a list of all the
      phrases that you've so far been letting _AUTO generate for you. There are
      very many ways to assemble such a list. The most straightforward is to
      simply grep the source for every occurrence of &quot;maketext&quot; (or
      calls to wrappers around it, like the above
      <span class="Li">&quot;pmt&quot;</span> function), and to log the
      following phrase.</li>
  <li>You may at this point want to consider whether your base class
      (Projname::L10N), from which all lexicons inherit from
      (Projname::L10N::en, Projname::L10N::es, etc.), should be an _AUTO
      lexicon. It may be true that in theory, all needed messages will be in
      each language class; but in the presumably unlikely or
      &quot;impossible&quot; case of lookup failure, you should consider whether
      your program should throw an exception, emit text in English (or whatever
      your project's first language is), or some more complex solution as
      described in the section &quot;Controlling Lookup Failure&quot;,
    above.</li>
  <li>Submit all messages/phrases/etc. to translators.
    <p class="Pp">(You may, in fact, want to start with localizing to <i>one</i>
        other language at first, if you're not sure that you've properly
        abstracted the language-dependent parts of your code.)</p>
    <p class="Pp">Translators may request clarification of the situation in
        which a particular phrase is found. For example, in English we are
        entirely happy saying &quot;<i>n</i> files found&quot;, regardless of
        whether we mean &quot;I looked for files, and found <i>n</i> of
        them&quot; or the rather distinct situation of &quot;I looked for
        something else (like lines in files), and along the way I saw <i>n</i>
        files.&quot; This may involve rethinking things that you thought quite
        clear: should &quot;Edit&quot; on a toolbar be a noun
        (&quot;editing&quot;) or a verb (&quot;to edit&quot;)? Is there already
        a conventionalized way to express that menu option, separate from the
        target language's normal word for &quot;to edit&quot;?</p>
    <p class="Pp">In all cases where the very common phenomenon of
        quantification (saying &quot;<i>N</i> files&quot;, for <b>any</b> value
        of N) is involved, each translator should make clear what dependencies
        the number causes in the sentence. In many cases, dependency is limited
        to words adjacent to the number, in places where you might expect them
        (&quot;I found the-?PLURAL <i>N</i> empty-?PLURAL
        directory-?PLURAL&quot;), but in some cases there are unexpected
        dependencies (&quot;I found-?PLURAL ...&quot;!) as well as long-distance
        dependencies &quot;The <i>N</i> directory-?PLURAL could not be
        deleted-?PLURAL&quot;!).</p>
    <p class="Pp">Remind the translators to consider the case where N is 0:
        &quot;0 files found&quot; isn't exactly natural-sounding in any
        language, but it may be unacceptable in many -- or it may condition
        special kinds of agreement (similar to English &quot;I didN'T find ANY
        files&quot;).</p>
    <p class="Pp">Remember to ask your translators about numeral formatting in
        their language, so that you can override the
        <span class="Li">&quot;numf&quot;</span> method as appropriate. Typical
        variables in number formatting are: what to use as a decimal point
        (comma? period?); what to use as a thousands separator (space?
        nonbreaking space? comma? period? small middot? prime? apostrophe?); and
        even whether the so-called &quot;thousands separator&quot; is actually
        for every third digit -- I've heard reports of two hundred thousand
        being expressible as &quot;2,00,000&quot; for some Indian
        (Subcontinental) languages, besides the less surprising
        &quot;200&#x00A0;000&quot;, &quot;200.000&quot;, &quot;200,000&quot;,
        and &quot;200'000&quot;. Also, using a set of numeral glyphs other than
        the usual ASCII &quot;0&quot;-&quot;9&quot; might be appreciated, as via
        <span class="Li">&quot;tr/0-9/\x{0966}-\x{096F}/&quot;</span> for
        getting digits in Devanagari script (for Hindi, Konkani, others).</p>
    <p class="Pp">The basic <span class="Li">&quot;quant&quot;</span> method
        that Locale::Maketext provides should be good for many languages. For
        some languages, it might be useful to modify it (or its constituent
        <span class="Li">&quot;numerate&quot;</span> method) to take a plural
        form in the two-argument call to
        <span class="Li">&quot;quant&quot;</span> (as in
        &quot;[quant,_1,files]&quot;) if it's all-around easier to infer the
        singular form from the plural, than to infer the plural form from the
        singular.</p>
    <p class="Pp">But for other languages (as is discussed at length in
        Locale::Maketext::TPJ13), simple
        <span class="Li">&quot;quant&quot;</span>/<span class="Li">&quot;numf&quot;</span>
        is not enough. For the particularly problematic Slavic languages, what
        you may need is a method which you provide with the number, the citation
        form of the noun to quantify, and the case and gender that the
        sentence's syntax projects onto that noun slot. The method would then be
        responsible for determining what grammatical number that numeral
        projects onto its noun phrase, and what case and gender it may override
        the normal case and gender with; and then it would look up the noun in a
        lexicon providing all needed inflected forms.</p>
  </li>
  <li>You may also wish to discuss with the translators the question of how to
      relate different subforms of the same language tag, considering how this
      reacts with <span class="Li">&quot;get_handle&quot;</span>'s treatment of
      these. For example, if a user accepts interfaces in &quot;en, fr&quot;,
      and you have interfaces available in &quot;en-US&quot; and &quot;fr&quot;,
      what should they get? You may wish to resolve this by establishing that
      &quot;en&quot; and &quot;en-US&quot; are effectively synonymous, by having
      one class zero-derive from the other.
    <p class="Pp">For some languages this issue may never come up (Danish is
        rarely expressed as &quot;da-DK&quot;, but instead is just
        &quot;da&quot;). And for other languages, the whole concept of a
        &quot;generic&quot; form may verge on being uselessly vague,
        particularly for interfaces involving voice media in forms of Arabic or
        Chinese.</p>
  </li>
  <li>Once you've localized your program/site/etc. for all desired languages, be
      sure to show the result (whether live, or via screenshots) to the
      translators. Once they approve, make every effort to have it then checked
      by at least one other speaker of that language. This holds true even when
      (or especially when) the translation is done by one of your own
      programmers. Some kinds of systems may be harder to find testers for than
      others, depending on the amount of domain-specific jargon and concepts
      involved -- it's easier to find people who can tell you whether they
      approve of your translation for &quot;delete this message&quot; in an
      email-via-Web interface, than to find people who can give you an informed
      opinion on your translation for &quot;attribute value&quot; in an XML
      query tool's interface.</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">I recommend reading all of these:</p>
<p class="Pp">Locale::Maketext::TPJ13 -- my <i>The Perl</i> <i>Journal</i>
    article about Maketext. It explains many important concepts underlying
    Locale::Maketext's design, and some insight into why Maketext is better than
    the plain old approach of having message catalogs that are just databases of
    sprintf formats.</p>
<p class="Pp">File::Findgrep is a sample application/module that uses
    Locale::Maketext to localize its messages. For a larger internationalized
    system, see also Apache::MP3.</p>
<p class="Pp">I18N::LangTags.</p>
<p class="Pp">Win32::Locale.</p>
<p class="Pp">RFC 3066, <i>Tags for the Identification of Languages</i>, as at
    http://sunsite.dk/RFC/rfc/rfc3066.html</p>
<p class="Pp">RFC 2277, <i>IETF Policy on Character Sets and Languages</i> is at
    http://sunsite.dk/RFC/rfc/rfc2277.html -- much of it is just things of
    interest to protocol designers, but it explains some basic concepts, like
    the distinction between locales and language-tags.</p>
<p class="Pp">The manual for GNU <span class="Li">&quot;gettext&quot;</span>.
    The gettext dist is available in
    <span class="Li">&quot;ftp://prep.ai.mit.edu/pub/gnu/&quot;</span> -- get a
    recent gettext tarball and look in its &quot;doc/&quot; directory, there's
    an easily browsable HTML version in there. The gettext documentation asks
    lots of questions worth thinking about, even if some of their answers are
    sometimes wonky, particularly where they start talking about
  pluralization.</p>
<p class="Pp">The Locale/Maketext.pm source. Observe that the module is much
    shorter than its documentation!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_DISCLAIMER"><a class="permalink" href="#COPYRIGHT_AND_DISCLAIMER">COPYRIGHT
  AND DISCLAIMER</a></h1>
<p class="Pp">Copyright (c) 1999-2004 Sean M. Burke. All rights reserved.</p>
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">This program is distributed in the hope that it will be useful,
    but without any warranty; without even the implied warranty of
    merchantability or fitness for a particular purpose.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Sean M. Burke
  <span class="Li">&quot;sburke@cpan.org&quot;</span></p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

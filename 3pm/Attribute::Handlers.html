<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Attribute::Handlers(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Attribute::Handlers(3pm)</td>
    <td class="head-vol"><a href=".">Perl Programmers Reference Guide</a></td>
    <td class="head-rtitle">Attribute::Handlers(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Attribute::Handlers - Simpler definition of attribute handlers</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">This document describes version 1.01 of Attribute::Handlers.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    package MyClass;
    require 5.006;
    use Attribute::Handlers;
    no warnings 'redefine';
    sub Good : ATTR(SCALAR) {
        my ($package, $symbol, $referent, $attr, $data) = @_;
        # Invoked for any scalar variable with a :Good attribute,
        # provided the variable was declared in MyClass (or
        # a derived class) or typed to MyClass.
        # Do whatever to $referent here (executed in CHECK phase).
        ...
    }
    sub Bad : ATTR(SCALAR) {
        # Invoked for any scalar variable with a :Bad attribute,
        # provided the variable was declared in MyClass (or
        # a derived class) or typed to MyClass.
        ...
    }
    sub Good : ATTR(ARRAY) {
        # Invoked for any array variable with a :Good attribute,
        # provided the variable was declared in MyClass (or
        # a derived class) or typed to MyClass.
        ...
    }
    sub Good : ATTR(HASH) {
        # Invoked for any hash variable with a :Good attribute,
        # provided the variable was declared in MyClass (or
        # a derived class) or typed to MyClass.
        ...
    }
    sub Ugly : ATTR(CODE) {
        # Invoked for any subroutine declared in MyClass (or a 
        # derived class) with an :Ugly attribute.
        ...
    }
    sub Omni : ATTR {
        # Invoked for any scalar, array, hash, or subroutine
        # with an :Omni attribute, provided the variable or
        # subroutine was declared in MyClass (or a derived class)
        # or the variable was typed to MyClass.
        # Use ref($_[2]) to determine what kind of referent it was.
        ...
    }
    use Attribute::Handlers autotie =&gt; { Cycle =&gt; Tie::Cycle };
    my $next : Cycle(['A'..'Z']);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module, when inherited by a package, allows that package's
    class to define attribute handler subroutines for specific attributes.
    Variables and subroutines subsequently defined in that package, or in
    packages derived from that package may be given attributes with the same
    names as the attribute handler subroutines, which will then be called in one
    of the compilation phases (i.e. in a
    <span class="Li">&quot;BEGIN&quot;</span>,
    <span class="Li">&quot;CHECK&quot;</span>,
    <span class="Li">&quot;INIT&quot;</span>, or
    <span class="Li">&quot;END&quot;</span> block).
    (<span class="Li">&quot;UNITCHECK&quot;</span> blocks don't correspond to a
    global compilation phase, so they can't be specified here.)</p>
<p class="Pp">To create a handler, define it as a subroutine with the same name
    as the desired attribute, and declare the subroutine itself with the
    attribute <span class="Li">&quot;:ATTR&quot;</span>. For example:</p>
<p class="Pp"></p>
<pre>    package LoudDecl;
    use Attribute::Handlers;
    sub Loud :ATTR {
        my ($package, $symbol, $referent, $attr, $data, $phase,
            $filename, $linenum) = @_;
        print STDERR
            ref($referent), &quot; &quot;,
            *{$symbol}{NAME}, &quot; &quot;,
            &quot;($referent) &quot;, &quot;was just declared &quot;,
            &quot;and ascribed the ${attr} attribute &quot;,
            &quot;with data ($data)\n&quot;,
            &quot;in phase $phase\n&quot;,
            &quot;in file $filename at line $linenum\n&quot;;
    }
</pre>
<p class="Pp">This creates a handler for the attribute
    <span class="Li">&quot;:Loud&quot;</span> in the class LoudDecl. Thereafter,
    any subroutine declared with a <span class="Li">&quot;:Loud&quot;</span>
    attribute in the class LoudDecl:</p>
<p class="Pp"></p>
<pre>    package LoudDecl;
    sub foo: Loud {...}
</pre>
<p class="Pp">causes the above handler to be invoked, and passed:</p>
<dl class="Bl-tag">
  <dt>[0]</dt>
  <dd>the name of the package into which it was declared;</dd>
  <dt>[1]</dt>
  <dd>a reference to the symbol table entry (typeglob) containing the
      subroutine;</dd>
  <dt>[2]</dt>
  <dd>a reference to the subroutine;</dd>
  <dt>[3]</dt>
  <dd>the name of the attribute;</dd>
  <dt>[4]</dt>
  <dd>any data associated with that attribute;</dd>
  <dt>[5]</dt>
  <dd>the name of the phase in which the handler is being invoked;</dd>
  <dt>[6]</dt>
  <dd>the filename in which the handler is being invoked;</dd>
  <dt>[7]</dt>
  <dd>the line number in this file.</dd>
</dl>
<p class="Pp">Likewise, declaring any variables with the
    <span class="Li">&quot;:Loud&quot;</span> attribute within the package:</p>
<p class="Pp"></p>
<pre>    package LoudDecl;
    my $foo :Loud;
    my @foo :Loud;
    my %foo :Loud;
</pre>
<p class="Pp">will cause the handler to be called with a similar argument list
    (except, of course, that <span class="Li">$_[2]</span> will be a reference
    to the variable).</p>
<p class="Pp">The package name argument will typically be the name of the class
    into which the subroutine was declared, but it may also be the name of a
    derived class (since handlers are inherited).</p>
<p class="Pp">If a lexical variable is given an attribute, there is no symbol
    table to which it belongs, so the symbol table argument
    (<span class="Li">$_[1]</span>) is set to the string
    <span class="Li">'LEXICAL'</span> in that case. Likewise, ascribing an
    attribute to an anonymous subroutine results in a symbol table argument of
    <span class="Li">'ANON'</span>.</p>
<p class="Pp">The data argument passes in the value (if any) associated with the
    attribute. For example, if <span class="Li">&amp;foo</span> had been
    declared:</p>
<p class="Pp"></p>
<pre>        sub foo :Loud(&quot;turn it up to 11, man!&quot;) {...}
</pre>
<p class="Pp">then a reference to an array containing the string
    <span class="Li">&quot;turn it up to 11, man!&quot;</span> would be passed
    as the last argument.</p>
<p class="Pp">Attribute::Handlers makes strenuous efforts to convert the data
    argument (<span class="Li">$_[4]</span>) to a usable form before passing it
    to the handler (but see &quot;Non-interpretive attribute handlers&quot;). If
    those efforts succeed, the interpreted data is passed in an array reference;
    if they fail, the raw data is passed as a string. For example, all of
  these:</p>
<p class="Pp"></p>
<pre>    sub foo :Loud(till=&gt;ears=&gt;are=&gt;bleeding) {...}
    sub foo :Loud(qw/till ears are bleeding/) {...}
    sub foo :Loud(qw/till, ears, are, bleeding/) {...}
    sub foo :Loud(till,ears,are,bleeding) {...}
</pre>
<p class="Pp">causes it to pass
    <span class="Li">&quot;['till','ears','are','bleeding']&quot;</span> as the
    handler's data argument. While:</p>
<p class="Pp"></p>
<pre>    sub foo :Loud(['till','ears','are','bleeding']) {...}
</pre>
<p class="Pp">causes it to pass <span class="Li">&quot;[
    ['till','ears','are','bleeding'] ]&quot;</span>; the array reference
    specified in the data being passed inside the standard array reference
    indicating successful interpretation.</p>
<p class="Pp">However, if the data can't be parsed as valid Perl, then it is
    passed as an uninterpreted string. For example:</p>
<p class="Pp"></p>
<pre>    sub foo :Loud(my,ears,are,bleeding) {...}
    sub foo :Loud(qw/my ears are bleeding) {...}
</pre>
<p class="Pp">cause the strings <span class="Li">'my,ears,are,bleeding'</span>
    and <span class="Li">'qw/my ears are bleeding'</span> respectively to be
    passed as the data argument.</p>
<p class="Pp">If no value is associated with the attribute,
    <span class="Li">&quot;undef&quot;</span> is passed.</p>
<section class="Ss">
<h2 class="Ss" id="Typed_lexicals"><a class="permalink" href="#Typed_lexicals">Typed
  lexicals</a></h2>
<p class="Pp">Regardless of the package in which it is declared, if a lexical
    variable is ascribed an attribute, the handler that is invoked is the one
    belonging to the package to which it is typed. For example, the following
    declarations:</p>
<p class="Pp"></p>
<pre>    package OtherClass;
    my LoudDecl $loudobj : Loud;
    my LoudDecl @loudobjs : Loud;
    my LoudDecl %loudobjex : Loud;
</pre>
<p class="Pp">causes the LoudDecl::Loud handler to be invoked (even if
    OtherClass also defines a handler for
    <span class="Li">&quot;:Loud&quot;</span> attributes).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Type-specific_attribute_handlers"><a class="permalink" href="#Type-specific_attribute_handlers">Type-specific
  attribute handlers</a></h2>
<p class="Pp">If an attribute handler is declared and the
    <span class="Li">&quot;:ATTR&quot;</span> specifier is given the name of a
    built-in type (<span class="Li">&quot;SCALAR&quot;</span>,
    <span class="Li">&quot;ARRAY&quot;</span>,
    <span class="Li">&quot;HASH&quot;</span>, or
    <span class="Li">&quot;CODE&quot;</span>), the handler is only applied to
    declarations of that type. For example, the following definition:</p>
<p class="Pp"></p>
<pre>    package LoudDecl;
    sub RealLoud :ATTR(SCALAR) { print &quot;Yeeeeow!&quot; }
</pre>
<p class="Pp">creates an attribute handler that applies only to scalars:</p>
<p class="Pp"></p>
<pre>    package Painful;
    use base LoudDecl;
    my $metal : RealLoud;           # invokes &amp;LoudDecl::RealLoud
    my @metal : RealLoud;           # error: unknown attribute
    my %metal : RealLoud;           # error: unknown attribute
    sub metal : RealLoud {...}      # error: unknown attribute
</pre>
<p class="Pp">You can, of course, declare separate handlers for these types as
    well (but you'll need to specify <span class="Li">&quot;no warnings
    'redefine'&quot;</span> to do it quietly):</p>
<p class="Pp"></p>
<pre>    package LoudDecl;
    use Attribute::Handlers;
    no warnings 'redefine';
    sub RealLoud :ATTR(SCALAR) { print &quot;Yeeeeow!&quot; }
    sub RealLoud :ATTR(ARRAY) { print &quot;Urrrrrrrrrr!&quot; }
    sub RealLoud :ATTR(HASH) { print &quot;Arrrrrgggghhhhhh!&quot; }
    sub RealLoud :ATTR(CODE) { croak &quot;Real loud sub torpedoed&quot; }
</pre>
<p class="Pp">You can also explicitly indicate that a single handler is meant to
    be used for all types of referents like so:</p>
<p class="Pp"></p>
<pre>    package LoudDecl;
    use Attribute::Handlers;
    sub SeriousLoud :ATTR(ANY) { warn &quot;Hearing loss imminent&quot; }
</pre>
<p class="Pp">(I.e. <span class="Li">&quot;ATTR(ANY)&quot;</span> is a synonym
    for <span class="Li">&quot;:ATTR&quot;</span>).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Non-interpretive_attribute_handlers"><a class="permalink" href="#Non-interpretive_attribute_handlers">Non-interpretive
  attribute handlers</a></h2>
<p class="Pp">Occasionally the strenuous efforts Attribute::Handlers makes to
    convert the data argument (<span class="Li">$_[4]</span>) to a usable form
    before passing it to the handler get in the way.</p>
<p class="Pp">You can turn off that eagerness-to-help by declaring an attribute
    handler with the keyword <span class="Li">&quot;RAWDATA&quot;</span>. For
    example:</p>
<p class="Pp"></p>
<pre>    sub Raw          : ATTR(RAWDATA) {...}
    sub Nekkid       : ATTR(SCALAR,RAWDATA) {...}
    sub Au::Naturale : ATTR(RAWDATA,ANY) {...}
</pre>
<p class="Pp">Then the handler makes absolutely no attempt to interpret the data
    it receives and simply passes it as a string:</p>
<p class="Pp"></p>
<pre>    my $power : Raw(1..100);        # handlers receives &quot;1..100&quot;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Phase-specific_attribute_handlers"><a class="permalink" href="#Phase-specific_attribute_handlers">Phase-specific
  attribute handlers</a></h2>
<p class="Pp">By default, attribute handlers are called at the end of the
    compilation phase (in a <span class="Li">&quot;CHECK&quot;</span> block).
    This seems to be optimal in most cases because most things that can be
    defined are defined by that point but nothing has been executed.</p>
<p class="Pp">However, it is possible to set up attribute handlers that are
    called at other points in the program's compilation or execution, by
    explicitly stating the phase (or phases) in which you wish the attribute
    handler to be called. For example:</p>
<p class="Pp"></p>
<pre>    sub Early    :ATTR(SCALAR,BEGIN) {...}
    sub Normal   :ATTR(SCALAR,CHECK) {...}
    sub Late     :ATTR(SCALAR,INIT) {...}
    sub Final    :ATTR(SCALAR,END) {...}
    sub Bookends :ATTR(SCALAR,BEGIN,END) {...}
</pre>
<p class="Pp">As the last example indicates, a handler may be set up to be
    (re)called in two or more phases. The phase name is passed as the handler's
    final argument.</p>
<p class="Pp">Note that attribute handlers that are scheduled for the
    <span class="Li">&quot;BEGIN&quot;</span> phase are handled as soon as the
    attribute is detected (i.e. before any subsequently defined
    <span class="Li">&quot;BEGIN&quot;</span> blocks are executed).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Attributes_as__tie__interfaces"><a class="permalink" href="#Attributes_as__tie__interfaces">Attributes
  as &quot;tie&quot; interfaces</a></h2>
<p class="Pp">Attributes make an excellent and intuitive interface through which
    to tie variables. For example:</p>
<p class="Pp"></p>
<pre>    use Attribute::Handlers;
    use Tie::Cycle;
    sub UNIVERSAL::Cycle : ATTR(SCALAR) {
        my ($package, $symbol, $referent, $attr, $data, $phase) = @_;
        $data = [ $data ] unless ref $data eq 'ARRAY';
        tie $$referent, 'Tie::Cycle', $data;
    }
    # and thereafter...
    package main;
    my $next : Cycle('A'..'Z');     # $next is now a tied variable
    while (&lt;&gt;) {
        print $next;
    }
</pre>
<p class="Pp">Note that, because the <span class="Li">&quot;Cycle&quot;</span>
    attribute receives its arguments in the <span class="Li">$data</span>
    variable, if the attribute is given a list of arguments,
    <span class="Li">$data</span> will consist of a single array reference;
    otherwise, it will consist of the single argument directly. Since Tie::Cycle
    requires its cycling values to be passed as an array reference, this means
    that we need to wrap non-array-reference arguments in an array
  constructor:</p>
<p class="Pp"></p>
<pre>    $data = [ $data ] unless ref $data eq 'ARRAY';
</pre>
<p class="Pp">Typically, however, things are the other way around: the tieable
    class expects its arguments as a flattened list, so the attribute looks
    like:</p>
<p class="Pp"></p>
<pre>    sub UNIVERSAL::Cycle : ATTR(SCALAR) {
        my ($package, $symbol, $referent, $attr, $data, $phase) = @_;
        my @data = ref $data eq 'ARRAY' ? @$data : $data;
        tie $$referent, 'Tie::Whatever', @data;
    }
</pre>
<p class="Pp">This software pattern is so widely applicable that
    Attribute::Handlers provides a way to automate it: specifying
    <span class="Li">'autotie'</span> in the <span class="Li">&quot;use
    Attribute::Handlers&quot;</span> statement. So, the cycling example, could
    also be written:</p>
<p class="Pp"></p>
<pre>    use Attribute::Handlers autotie =&gt; { Cycle =&gt; 'Tie::Cycle' };
    # and thereafter...
    package main;
    my $next : Cycle(['A'..'Z']);     # $next is now a tied variable
    while (&lt;&gt;) {
        print $next;
    }
</pre>
<p class="Pp">Note that we now have to pass the cycling values as an array
    reference, since the <span class="Li">&quot;autotie&quot;</span> mechanism
    passes <span class="Li">&quot;tie&quot;</span> a list of arguments as a list
    (as in the Tie::Whatever example), <i>not</i> as an array reference (as in
    the original Tie::Cycle example at the start of this section).</p>
<p class="Pp">The argument after <span class="Li">'autotie'</span> is a
    reference to a hash in which each key is the name of an attribute to be
    created, and each value is the class to which variables ascribed that
    attribute should be tied.</p>
<p class="Pp">Note that there is no longer any need to import the Tie::Cycle
    module -- Attribute::Handlers takes care of that automagically. You can even
    pass arguments to the module's <span class="Li">&quot;import&quot;</span>
    subroutine, by appending them to the class name. For example:</p>
<p class="Pp"></p>
<pre>    use Attribute::Handlers
         autotie =&gt; { Dir =&gt; 'Tie::Dir qw(DIR_UNLINK)' };
</pre>
<p class="Pp">If the attribute name is unqualified, the attribute is installed
    in the current package. Otherwise it is installed in the qualifier's
    package:</p>
<p class="Pp"></p>
<pre>    package Here;
    use Attribute::Handlers autotie =&gt; {
         Other::Good =&gt; Tie::SecureHash, # tie attr installed in Other::
                 Bad =&gt; Tie::Taxes,      # tie attr installed in Here::
     UNIVERSAL::Ugly =&gt; Software::Patent # tie attr installed everywhere
    };
</pre>
<p class="Pp">Autoties are most commonly used in the module to which they
    actually tie, and need to export their attributes to any module that calls
    them. To facilitate this, Attribute::Handlers recognizes a special
    &quot;pseudo-class&quot; -- <span class="Li">&quot;__CALLER__&quot;</span>,
    which may be specified as the qualifier of an attribute:</p>
<p class="Pp"></p>
<pre>    package Tie::Me::Kangaroo:Down::Sport;
    use Attribute::Handlers autotie =&gt;
         { '__CALLER__::Roo' =&gt; __PACKAGE__ };
</pre>
<p class="Pp">This causes Attribute::Handlers to define the
    <span class="Li">&quot;Roo&quot;</span> attribute in the package that
    imports the Tie::Me::Kangaroo:Down::Sport module.</p>
<p class="Pp">Note that it is important to quote the __CALLER__::Roo identifier
    because a bug in perl 5.8 will refuse to parse it and cause an unknown
    error.</p>
<p class="Pp"><i>Passing the tied object to
    </i><span class="Li"><i>&quot;tie&quot;</i></span><i></i></p>
<p class="Pp">Occasionally it is important to pass a reference to the object
    being tied to the TIESCALAR, TIEHASH, etc. that ties it.</p>
<p class="Pp">The <span class="Li">&quot;autotie&quot;</span> mechanism supports
    this too. The following code:</p>
<p class="Pp"></p>
<pre>    use Attribute::Handlers autotieref =&gt; { Selfish =&gt; Tie::Selfish };
    my $var : Selfish(@args);
</pre>
<p class="Pp">has the same effect as:</p>
<p class="Pp"></p>
<pre>    tie my $var, 'Tie::Selfish', @args;
</pre>
<p class="Pp">But when <span class="Li">&quot;autotieref&quot;</span> is used
    instead of <span class="Li">&quot;autotie&quot;</span>:</p>
<p class="Pp"></p>
<pre>    use Attribute::Handlers autotieref =&gt; { Selfish =&gt; Tie::Selfish };
    my $var : Selfish(@args);
</pre>
<p class="Pp">the effect is to pass the <span class="Li">&quot;tie&quot;</span>
    call an extra reference to the variable being tied:</p>
<p class="Pp"></p>
<pre>    tie my $var, 'Tie::Selfish', \$var, @args;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">If the class shown in &quot;SYNOPSIS&quot; were placed in the
    MyClass.pm module, then the following code:</p>
<p class="Pp"></p>
<pre>    package main;
    use MyClass;
    my MyClass $slr :Good :Bad(1**1-1) :Omni(-vorous);
    package SomeOtherClass;
    use base MyClass;
    sub tent { 'acle' }
    sub fn :Ugly(sister) :Omni('po',tent()) {...}
    my @arr :Good :Omni(s/cie/nt/);
    my %hsh :Good(q/bye/) :Omni(q/bus/);
</pre>
<p class="Pp">would cause the following handlers to be invoked:</p>
<p class="Pp"></p>
<pre>    # my MyClass $slr :Good :Bad(1**1-1) :Omni(-vorous);
    MyClass::Good:ATTR(SCALAR)( 'MyClass',          # class
                                'LEXICAL',          # no typeglob
                                \$slr,              # referent
                                'Good',             # attr name
                                undef               # no attr data
                                'CHECK',            # compiler phase
                              );
    MyClass::Bad:ATTR(SCALAR)( 'MyClass',           # class
                               'LEXICAL',           # no typeglob
                               \$slr,               # referent
                               'Bad',               # attr name
                               0                    # eval'd attr data
                               'CHECK',             # compiler phase
                             );
    MyClass::Omni:ATTR(SCALAR)( 'MyClass',          # class
                                'LEXICAL',          # no typeglob
                                \$slr,              # referent
                                'Omni',             # attr name
                                '-vorous'           # eval'd attr data
                                'CHECK',            # compiler phase
                              );
    # sub fn :Ugly(sister) :Omni('po',tent()) {...}
    MyClass::UGLY:ATTR(CODE)( 'SomeOtherClass',     # class
                              \*SomeOtherClass::fn, # typeglob
                              \&amp;SomeOtherClass::fn, # referent
                              'Ugly',               # attr name
                              'sister'              # eval'd attr data
                              'CHECK',              # compiler phase
                            );
    MyClass::Omni:ATTR(CODE)( 'SomeOtherClass',     # class
                              \*SomeOtherClass::fn, # typeglob
                              \&amp;SomeOtherClass::fn, # referent
                              'Omni',               # attr name
                              ['po','acle']         # eval'd attr data
                              'CHECK',              # compiler phase
                            );
    # my @arr :Good :Omni(s/cie/nt/);
    MyClass::Good:ATTR(ARRAY)( 'SomeOtherClass',    # class
                               'LEXICAL',           # no typeglob
                               \@arr,               # referent
                               'Good',              # attr name
                               undef                # no attr data
                               'CHECK',             # compiler phase
                             );
    MyClass::Omni:ATTR(ARRAY)( 'SomeOtherClass',    # class
                               'LEXICAL',           # no typeglob
                               \@arr,               # referent
                               'Omni',              # attr name
                               &quot;&quot;                   # eval'd attr data 
                               'CHECK',             # compiler phase
                             );
    # my %hsh :Good(q/bye) :Omni(q/bus/);
    MyClass::Good:ATTR(HASH)( 'SomeOtherClass',     # class
                              'LEXICAL',            # no typeglob
                              \%hsh,                # referent
                              'Good',               # attr name
                              'q/bye'               # raw attr data
                              'CHECK',              # compiler phase
                            );
    MyClass::Omni:ATTR(HASH)( 'SomeOtherClass',     # class
                              'LEXICAL',            # no typeglob
                              \%hsh,                # referent
                              'Omni',               # attr name
                              'bus'                 # eval'd attr data
                              'CHECK',              # compiler phase
                            );
</pre>
<p class="Pp">Installing handlers into UNIVERSAL, makes them...err..universal.
    For example:</p>
<p class="Pp"></p>
<pre>    package Descriptions;
    use Attribute::Handlers;
    my %name;
    sub name { return $name{$_[2]}||*{$_[1]}{NAME} }
    sub UNIVERSAL::Name :ATTR {
        $name{$_[2]} = $_[4];
    }
    sub UNIVERSAL::Purpose :ATTR {
        print STDERR &quot;Purpose of &quot;, &amp;name, &quot; is $_[4]\n&quot;;
    }
    sub UNIVERSAL::Unit :ATTR {
        print STDERR &amp;name, &quot; measured in $_[4]\n&quot;;
    }
</pre>
<p class="Pp">Let's you write:</p>
<p class="Pp"></p>
<pre>    use Descriptions;
    my $capacity : Name(capacity)
                 : Purpose(to store max storage capacity for files)
                 : Unit(Gb);
    package Other;
    sub foo : Purpose(to foo all data before barring it) { }
    # etc.
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="UTILITY_FUNCTIONS"><a class="permalink" href="#UTILITY_FUNCTIONS">UTILITY
  FUNCTIONS</a></h1>
<p class="Pp">This module offers a single utility function,
    <span class="Li">&quot;findsym()&quot;</span>.</p>
<dl class="Bl-tag">
  <dt id="findsym"><a class="permalink" href="#findsym">findsym</a></dt>
  <dd>
    <pre>    my $symbol = Attribute::Handlers::findsym($package, $referent);
    </pre>
    <p class="Pp">The function looks in the symbol table of
        <span class="Li">$package</span> for the typeglob for
        <span class="Li">$referent</span>, which is a reference to a variable or
        subroutine (SCALAR, ARRAY, HASH, or CODE). If it finds the typeglob, it
        returns it. Otherwise, it returns undef. Note that
        <span class="Li">&quot;findsym&quot;</span> memoizes the typeglobs it
        has previously successfully found, so subsequent calls with the same
        arguments should be much faster.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="DIAGNOSTICS"><a class="permalink" href="#DIAGNOSTICS">DIAGNOSTICS</a></h1>
<dl class="Bl-tag">
  <dt>&quot;Bad attribute type: ATTR(%s)&quot;</dt>
  <dd>An attribute handler was specified with an
      <span class="Li">&quot;:ATTR(</span><span class="Li"><i>ref_type</i></span><span class="Li">)&quot;</span>,
      but the type of referent it was defined to handle wasn't one of the five
      permitted: <span class="Li">&quot;SCALAR&quot;</span>,
      <span class="Li">&quot;ARRAY&quot;</span>,
      <span class="Li">&quot;HASH&quot;</span>,
      <span class="Li">&quot;CODE&quot;</span>, or
      <span class="Li">&quot;ANY&quot;</span>.</dd>
  <dt>&quot;Attribute handler %s doesn't handle %s attributes&quot;</dt>
  <dd>A handler for attributes of the specified name <i>was</i> defined, but not
      for the specified type of declaration. Typically encountered when trying
      to apply a <span class="Li">&quot;VAR&quot;</span> attribute handler to a
      subroutine, or a <span class="Li">&quot;SCALAR&quot;</span> attribute
      handler to some other type of variable.</dd>
  <dt>&quot;Declaration of %s attribute in package %s may clash with future
    reserved word&quot;</dt>
  <dd>A handler for an attributes with an all-lowercase name was declared. An
      attribute with an all-lowercase name might have a meaning to Perl itself
      some day, even though most don't yet. Use a mixed-case attribute name,
      instead.</dd>
  <dt>&quot;Can't have two ATTR specifiers on one subroutine&quot;</dt>
  <dd>You just can't, okay? Instead, put all the specifications together with
      commas between them in a single
      <span class="Li">&quot;ATTR(</span><span class="Li"><i>specification</i></span><span class="Li">)&quot;</span>.</dd>
  <dt>&quot;Can't autotie a %s&quot;</dt>
  <dd>You can only declare autoties for types
      <span class="Li">&quot;SCALAR&quot;</span>,
      <span class="Li">&quot;ARRAY&quot;</span>, and
      <span class="Li">&quot;HASH&quot;</span>. They're the only things (apart
      from typeglobs -- which are not declarable) that Perl can tie.</dd>
  <dt>&quot;Internal error: %s symbol went missing&quot;</dt>
  <dd>Something is rotten in the state of the program. An attributed subroutine
      ceased to exist between the point it was declared and the point at which
      its attribute handler(s) would have been called.</dd>
  <dt>&quot;Won't be able to apply END handler&quot;</dt>
  <dd>You have defined an END handler for an attribute that is being applied to
      a lexical variable. Since the variable may not be available during END
      this won't happen.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Damian Conway (damian@conway.org). The maintainer of this module
    is now Rafael Garcia-Suarez (rgarciasuarez@gmail.com).</p>
<p class="Pp">Maintainer of the CPAN release is Steffen Mueller
    (smueller@cpan.org). Contact him with technical difficulties with respect to
    the packaging of the CPAN module.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">There are undoubtedly serious bugs lurking somewhere in code this
    funky :-) Bug reports and other feedback are most welcome.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<pre>         Copyright (c) 2001-2014, Damian Conway. All Rights Reserved.
       This module is free software. It may be used, redistributed
           and/or modified under the same terms as Perl itself.
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os"><a href="..">perl v5.34.1</a></td>
  </tr>
</table>
</body>
</html>

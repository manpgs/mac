<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Type::Tiny::Manual::Coercions(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Type::Tiny::Manual::Coercions(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Type::Tiny::Manual::Coercions(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Type::Tiny::Manual::Coercions - advanced information on
  coercions</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MANUAL"><a class="permalink" href="#MANUAL">MANUAL</a></h1>
<p class="Pp">This section of the manual assumes you've already read
    Type::Tiny::Manual::UsingWithMoo.</p>
<p class="Pp">Type::Tiny takes a slightly different approach to type constraints
    from Moose. In Moose, there is a single flat namespace for type constraints.
    Moose defines a type constraint called <b>Str</b> for strings and a type
    constraint called <b>ArrayRef</b> for arrayrefs. If you want to define
    strings differently (maybe you think that the empty string doesn't really
    count as a string, or maybe you think objects overloading
    <span class="Li">&quot;q[&quot;&quot;]&quot;</span> should count as strings)
    then you can't call it <b>Str</b>; you need to choose a different name.</p>
<p class="Pp">With Type::Tiny, two type libraries can each offer a string type
    constraint with their own definitions for what counts as a string, and you
    can choose which one to import, or import them both with different
  names:</p>
<p class="Pp"></p>
<pre>  use Some::Types qw( Str );
  use Other::Types &quot;Str&quot; =&gt; { -as =&gt; &quot;Str2&quot; };
</pre>
<p class="Pp">This might seem to be a small advantage of Type::Tiny, but where
    this global-versus-local philosophy really makes a difference is
  coercions.</p>
<p class="Pp">Let's imagine for a part of your application that deals with
    reading username and password data you need to have a
    &quot;username:password&quot; string. You may wish to accept a
    <span class="Li">&quot;[$username, $password]&quot;</span> arrayref and
    coerce it to a string using <span class="Li">&quot;join &quot;:&quot;,
    @$arrayref&quot;</span>. But another part of your application deals with
    slurping log files, and wants to coerce a string from an arrayref using
    <span class="Li">&quot;join &quot;\n&quot;, @$arrayref&quot;</span>. These
    are both perfectly sensible ways to coerce an arrayref. In Moose, a typical
    way to do this would be:</p>
<p class="Pp"></p>
<pre>  package My::UserManager {
    use Moose;
    use Moose::Util::TypeConstraints;
    
    coerce 'Str',
      from 'ArrayRef', via { join &quot;:&quot;, @$_ };
    
    ...;
  }
  
  package My::LogReader {
    use Moose;
    use Moose::Util::TypeConstraints;
    
    coerce 'Str',
      from 'ArrayRef', via { join &quot;\n&quot;, @$_ };
    
    ...;
  }
</pre>
<p class="Pp">However, because in Moose all types and coercions are global, if
    both these classes are loaded, only one of them will work. One class will
    overrule the other's coercion. Which one &quot;wins&quot; will depend on
    load order.</p>
<p class="Pp">It is possible to solve this with Moose native types, but it
    requires extra work. (The solution is for My::UserManager and My::LogReader
    to each create a subtype of <b>Str</b> and define the coercion on that
    subtype instead of on <b>Str</b> directly.)</p>
<p class="Pp">Type::Tiny solves this in two ways:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>Type::Tiny makes it possible for type libraries to &quot;protect&quot;
      their type constraints to prevent external code from adding new coercions
      to them.
    <p class="Pp"></p>
    <pre>  $type-&gt;coercion-&gt;freeze();
    </pre>
    <p class="Pp">You can freeze coercions for your entire type library
      using:</p>
    <p class="Pp"></p>
    <pre>  __PACKAGE__-&gt;make_immutable;
    </pre>
    <p class="Pp">If you try to add coercions to a type constraint that has
        frozen coercions, it will throw an error.</p>
    <p class="Pp"></p>
    <pre>  use Types::Standard qw( Str ArrayRef );
  
  Str-&gt;coercion-&gt;add_type_coercions(
    ArrayRef, sub { join &quot;\n&quot;, @$_ },
  );
    </pre>
  </dd>
  <dt>2.</dt>
  <dd>Type::Tiny makes the above-mentioned pattern of adding coercions to a
      subtype much easier.
    <p class="Pp"></p>
    <pre>  use Types::Standard ( Str ArrayRef );
  
  my $subtype = Str-&gt;plus_coercions(
    ArrayRef, sub { join &quot;\n&quot;, @$_ },
  );
    </pre>
    <p class="Pp">The <span class="Li">&quot;plus_coercions&quot;</span> method
        creates a new child type, adds new coercions to it, copies any existing
        coercions from the parent type, and then freezes coercions for the new
        child type.</p>
    <p class="Pp">The end result is you now have a &quot;copy&quot; of
        <b>Str</b> that can coerce from <b>ArrayRef</b> but other copies of
        <b>Str</b> won't be affected by your coercion.</p>
  </dd>
</dl>
<section class="Ss">
<h2 class="Ss" id="Defining_Coercions_within_Type_Libraries"><a class="permalink" href="#Defining_Coercions_within_Type_Libraries">Defining
  Coercions within Type Libraries</a></h2>
<p class="Pp">Some coercions like joining an arrayref to make a string are not
    going to be coercions that everybody will agree on. Join with a line break
    in between them as above? Or with a colon, a tab, a space, some other
    chanaracter? It depends a lot on your application.</p>
<p class="Pp">Others, like coercing a Path::Tiny object from a string, are
    likely to be very obvious. It is this kind of coercion that it makes sense
    to define within the library itself so it's available to any packages that
    use the library.</p>
<p class="Pp"></p>
<pre>  my $pt = __PACKAGE__-&gt;add_type(
    Type::Tiny::Class-&gt;new(
      name    =&gt; 'Path',
      class   =&gt; 'Path::Tiny',
    ),
  );
  
  $pt-&gt;coercion-&gt;add_type_coercions(
    Str, q{ Path::Tiny::path($_) },
  );
  
  $pt-&gt;coercion-&gt;freeze;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Tweak_Coercions_Outside_Type_Libraries"><a class="permalink" href="#Tweak_Coercions_Outside_Type_Libraries">Tweak
  Coercions Outside Type Libraries</a></h2>
<p class="Pp">The <span class="Li">&quot;plus_coercions&quot;</span> method
    creates a new type constraint with additional coercions. If the original
    type already had coercions, the new coercions have a higher priority.</p>
<p class="Pp">There's also a
    <span class="Li">&quot;plus_fallback_coercions&quot;</span> method which
    does the same as <span class="Li">&quot;plus_coercions&quot;</span> but adds
    the new coercions with a lower priority than any existing ones.</p>
<p class="Pp">Type::Tiny::Class provides a
    <span class="Li">&quot;plus_constructors&quot;</span> method as a shortcut
    for coercing via a constructor method. The following two are the same:</p>
<p class="Pp"></p>
<pre>  Path-&gt;plus_constructors(Str, &quot;new&quot;)
  
  Path-&gt;plus_coercions(Str, q{ Path::Tiny-&gt;new($_) })
</pre>
<p class="Pp">To create a type constraint without particular existing coercions,
    you can use <span class="Li">&quot;minus_coercions&quot;</span>. The
    following uses the <b>Datetime</b> type defined in
    Type::Tiny::Manual::Libraries, removing the coercion from <b>Int</b> but
    keeping the coercions from <b>Undef</b> and <b>Dict</b>.</p>
<p class="Pp"></p>
<pre>  use Types::Standard qw( Int );
  use Example::Types qw( Datetime );
  
  has start_date =&gt; (
    is      =&gt; 'ro',
    isa     =&gt; Datetime-&gt;minus_coercions(Int),
    coerce  =&gt; 1,
  );
</pre>
<p class="Pp">There's also a <span class="Li">&quot;no_coercions&quot;</span>
    method that creates a subtype with no coercions at all. This is most useful
    either to create a &quot;blank slate&quot; for
    <span class="Li">&quot;plus_coercions&quot;</span>:</p>
<p class="Pp"></p>
<pre>  my $Path = Path-&gt;no_coercions-&gt;plus_coercions(Str, sub { ... });
</pre>
<p class="Pp">Or to disable coercions for Type::Params. Type::Params will always
    automatically coerce a parameter if there is a coercion for that type.</p>
<p class="Pp"></p>
<pre>  use Types::Standard qw( Object );
  use Types::Common::String qw( UpperCaseStr );
  use Type::Params;
  
  sub set_account_name {
    state $check = compile( Object, UpperCaseStr-&gt;no_coercions );
    my ($self, $name) = $check-&gt;(@_);
    $self-&gt;_account_name($name);
    $self-&gt;db-&gt;update($self);
    return $self;
  }
  
  # This will die instead of coercing from lowercase
  $robert-&gt;_set_account_name('bob');
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Named_Coercions"><a class="permalink" href="#Named_Coercions">Named
  Coercions</a></h2>
<p class="Pp">A compromise between defining a coercion in the type library or
    defining them in the package that uses the type library is for a type
    library to define a named collection of coercions which can be optionally
    added to a type constraint.</p>
<p class="Pp"></p>
<pre>  {
    package MyApp::Types;
    use Type::Library -base;
    use Type::Utils qw( extends );
    
    BEGIN { extends 'Types::Standard' };
    
    __PACKAGE__-&gt;add_coercion(
      name              =&gt; &quot;FromLines&quot;,
      type_constraint   =&gt; ArrayRef,
      type_coercion_map =&gt; [
        Str,     q{ [split /\n/] },
        Undef,   q{ [] },
      ],
    );
  }
</pre>
<p class="Pp">This set of coercions has a name and can be imported and used:</p>
<p class="Pp"></p>
<pre>  use MyApp::Types qw( ArrayRef FromLines );
  
  has lines =&gt; (
    is      =&gt; 'ro',
    isa     =&gt; ArrayRef-&gt;plus_coercions( FromLines ),
    coerce  =&gt; 1,
  );
</pre>
<p class="Pp">Types::Standard defines a named coercion <b>MkOpt</b> designed to
    be used for <b>OptList</b>.</p>
<p class="Pp"></p>
<pre>  use Types::Standard qw( OptList MkOpt );
  my $OptList = OptList-&gt;plus_coercions(MkOpt);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Parameterized_Coercions"><a class="permalink" href="#Parameterized_Coercions">Parameterized
  Coercions</a></h2>
<p class="Pp">Named coercions can also be parameterizable.</p>
<p class="Pp"></p>
<pre>  my $ArrayOfLines = ArrayRef-&gt;plus_coercions( Split[ qr{\n} ] );
</pre>
<p class="Pp">Types::Standard defines <b>Split</b> and <b>Join</b>
    parameterizable coercions.</p>
<p class="Pp">Viewing the source code for Types::Standard should give you hints
    as to how they are implemented.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_Deep__Coercions"><a class="permalink" href="#_Deep__Coercions">&quot;Deep&quot;
  Coercions</a></h2>
<p class="Pp">Certain parameterized type constraints can automatically acquire
    coercions if their parameters have coercions. For example:</p>
<p class="Pp"></p>
<pre>   ArrayRef[ Int-&gt;plus_coercions(Num, q{int($_)}) ]
</pre>
<p class="Pp">... does what you mean!</p>
<p class="Pp">The parameterized type constraints that do this magic include the
    following ones from Types::Standard:</p>
<ul class="Bl-bullet">
  <li><b>ScalarRef</b></li>
  <li><b>ArrayRef</b></li>
  <li><b>HashRef</b></li>
  <li><b>Map</b></li>
  <li><b>Tuple</b></li>
  <li><b>CycleTuple</b></li>
  <li><b>Dict</b></li>
  <li><b>Optional</b></li>
  <li><b>Maybe</b></li>
</ul>
<p class="Pp">Imagine we're defining a type <b>Paths</b> in a type library:</p>
<p class="Pp"></p>
<pre>  __PACKAGE__-&gt;add_type(
    name      =&gt; 'Paths',
    parent    =&gt; ArrayRef[Path],
  );
</pre>
<p class="Pp">The <b>Path</b> type has a coercion from <b>Str</b>, so
    <b>Paths</b> should be able to coerce from an arrayref of strings,
  right?</p>
<p class="Pp"><i>Wrong!</i> Although <b>ArrayRef[Path]</b> could coerce from an
    arrayref of strings, <b>Paths</b> is a separate type constraint which,
    although it inherits from <b>ArrayRef[Path]</b> has its own (currently
    empty) set of coercions.</p>
<p class="Pp">Because that is often not what you want, Type::Tiny provides a
    shortcut when declaring a subtype to copy the parent type constraint's
    coercions:</p>
<p class="Pp"></p>
<pre>  __PACKAGE__-&gt;add_type(
    name      =&gt; 'Paths',
    parent    =&gt; ArrayRef[Path],
    coercion  =&gt; 1,   # inherit
  );
</pre>
<p class="Pp">Now <b>Paths</b> can coerce from an arrayref of strings.</p>
<p class="Pp"><i>Deep Caveat</i></p>
<p class="Pp">Currently there exists ill-defined behaviour resulting from mixing
    deep coercions and mutable (non-frozen) coercions. Consider the
  following:</p>
<p class="Pp"></p>
<pre>   class_type Path, { class =&gt; &quot;Path::Tiny&quot; };
   coerce Path,
      from Str, via { &quot;Path::Tiny&quot;-&gt;new($_) };
   
   declare Paths, as ArrayRef[Path], coercion =&gt; 1;
   
   coerce Path,
      from InstanceOf[&quot;My::File&quot;], via { $_-&gt;get_path };
</pre>
<p class="Pp">An arrayref of strings can now be coerced to an arrayref of
    Path::Tiny objects, but is it also now possible to coerce an arrayref of
    My::File objects to an arrayref of Path::Tiny objects?</p>
<p class="Pp">Currently the answer is &quot;no&quot;, but this is mostly down to
    implementation details. It's not clear what the best way to behave in this
    situation is, and it could start working at some point in the future.</p>
<p class="Pp">This is why you should freeze coercions.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Chained_Coercions"><a class="permalink" href="#Chained_Coercions">Chained
  Coercions</a></h2>
<p class="Pp">Consider the following type library:</p>
<p class="Pp"></p>
<pre>   package Types::Geometric {
      use Type::Library -base, -declare =&gt; qw(
         VectorArray
         VectorArray3D
         Point
         Point3D
      );
      use Type::Utils;
      use Types::Standard qw( Num Tuple InstanceOf );
      
      declare VectorArray,
         as Tuple[Num, Num];
      
      declare VectorArray3D,
         as Tuple[Num, Num, Num];
      
      coerce VectorArray3D,
         from VectorArray, via {
            [ @$_, 0 ];
         };
      
      class_type Point, { class =&gt; &quot;Point&quot; };
      
      coerce Point,
         from VectorArray, via {
            Point-&gt;new(x =&gt; $_-&gt;[0], y =&gt; $_-&gt;[1]);
         };
      
      class_type Point3D, { class =&gt; &quot;Point3D&quot; };
      
      coerce Point3D,
         from VectorArray3D, via {
            Point3D-&gt;new(x =&gt; $_-&gt;[0], y =&gt; $_-&gt;[1], z =&gt; $_-&gt;[2]);
         },
         from Point, via {
            Point3D-&gt;new(x =&gt; $_-&gt;x, y =&gt; $_-&gt;y, z =&gt; 0);
         };
   }
</pre>
<p class="Pp">Given an arrayref <span class="Li">&quot;[1, 1]&quot;</span> you
    might reasonably expect it to be coercible to a <b>Point3D</b> object; it
    matches the type constraint <b>VectorArray</b> so can be coerced to
    <b>VectorArray3D</b> and thus to <b>Point3D</b>.</p>
<p class="Pp">However, Type::Coercion does not automatically chain coercions
    like this. Firstly, it would be incompatible with Moose's type coercion
    system which does not chain coercions. Secondly, it's ambiguous; in our
    example, the arrayref could be coerced along two different paths (via
    <b>VectorArray3D</b> or via <b>Point</b>); in this case the end result would
    be the same, but in other cases it might not. Thirdly, it runs the risk of
    accidentally creating loops.</p>
<p class="Pp">Doing the chaining manually though is pretty simple. Firstly,
    we'll take note of the <span class="Li">&quot;coercibles&quot;</span> method
    in Type::Tiny. This method called as
    <span class="Li">&quot;VectorArray3D-&gt;coercibles&quot;</span> returns a
    type constraint meaning &quot;anything that can be coerced to a
    <b>VectorArray3D</b>&quot;.</p>
<p class="Pp">So we can define the coercions for <b>Point3D</b> as:</p>
<p class="Pp"></p>
<pre>   coerce Point3D,
      from VectorArray3D-&gt;coercibles, via {
         my $tmp = to_VectorArray3D($_);
         Point3D-&gt;new(x =&gt; $tmp-&gt;[0], y =&gt; $tmp-&gt;[1], z =&gt; $tmp-&gt;[2]);
      },
      from Point, via {
         Point3D-&gt;new(x =&gt; $_-&gt;x, y =&gt; $_-&gt;y, z =&gt; 0);
      };
</pre>
<p class="Pp">... and now coercing from <span class="Li">&quot;[1,
    1]&quot;</span> will work.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Moose::Manual::BestPractices,
    &lt;https://web.archive.org/web/20090624164256/http://www.catalyzed.org/2009/06/keeping-your-coercions-to-yourself.html&gt;,
    MooseX::Types::MoreUtils.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NEXT_STEPS"><a class="permalink" href="#NEXT_STEPS">NEXT
  STEPS</a></h1>
<p class="Pp">After that last example, probably have a little lie down. Once
    you're recovered, here's your next step:</p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>Type::Tiny::Manual::AllTypes
    <p class="Pp">An alphabetical list of all type constraints bundled with
        Type::Tiny.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Toby Inkster &lt;tobyink@cpan.org&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENCE"><a class="permalink" href="#COPYRIGHT_AND_LICENCE">COPYRIGHT
  AND LICENCE</a></h1>
<p class="Pp">This software is copyright (c) 2013-2014, 2017-2020 by Toby
    Inkster.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DISCLAIMER_OF_WARRANTIES"><a class="permalink" href="#DISCLAIMER_OF_WARRANTIES">DISCLAIMER
  OF WARRANTIES</a></h1>
<p class="Pp">THIS PACKAGE IS PROVIDED &quot;AS IS&quot; AND WITHOUT ANY EXPRESS
    OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES
    OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-10-28</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

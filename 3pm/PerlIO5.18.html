<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PerlIO(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PerlIO(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PerlIO(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">PerlIO - On demand loader for PerlIO layers and root of PerlIO::*
    name space</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
  open($fh,&quot;&lt;:crlf&quot;, &quot;my.txt&quot;); # support platform-native and CRLF text files

  open($fh,&quot;&lt;&quot;,&quot;his.jpg&quot;);      # portably open a binary file for reading
  binmode($fh);

  Shell:
    PERLIO=perlio perl ....
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">When an undefined layer 'foo' is encountered in an
    <span class="Li">&quot;open&quot;</span> or
    <span class="Li">&quot;binmode&quot;</span> layer specification then C code
    performs the equivalent of:</p>
<p class="Pp"></p>
<pre>
  use PerlIO 'foo';
</pre>
<p class="Pp">The perl code in PerlIO.pm then attempts to locate a layer by
    doing</p>
<p class="Pp"></p>
<pre>
  require PerlIO::foo;
</pre>
<p class="Pp">Otherwise the <span class="Li">&quot;PerlIO&quot;</span> package
    is a place holder for additional PerlIO related functions.</p>
<p class="Pp">The following layers are currently defined:</p>
<dl class="Bl-tag">
  <dt>:unix</dt>
  <dd>Lowest level layer which provides basic PerlIO operations in terms of
      UNIX/POSIX numeric file descriptor calls (<i>open()</i>, <i>read()</i>,
      <i>write()</i>, <i>lseek()</i>, <i>close()</i>).</dd>
  <dt>:stdio</dt>
  <dd>Layer which calls <span class="Li">&quot;fread&quot;</span>,
      <span class="Li">&quot;fwrite&quot;</span> and
      <span class="Li">&quot;fseek&quot;</span>/<span class="Li">&quot;ftell&quot;</span>
      etc. Note that as this is &quot;real&quot; stdio it will ignore any layers
      beneath it and go straight to the operating system via the C library as
      usual.</dd>
  <dt>:perlio</dt>
  <dd>A from scratch implementation of buffering for PerlIO. Provides fast
      access to the buffer for <span class="Li">&quot;sv_gets&quot;</span> which
      implements perl's readline/&lt;&gt; and in general attempts to minimize
      data copying.
    <p class="Pp"><span class="Li">&quot;:perlio&quot;</span> will insert a
        <span class="Li">&quot;:unix&quot;</span> layer below itself to do low
        level IO.</p>
  </dd>
  <dt>:crlf</dt>
  <dd>A layer that implements DOS/Windows like CRLF line endings. On read
      converts pairs of CR,LF to a single &quot;\n&quot; newline character. On
      write converts each &quot;\n&quot; to a CR,LF pair. Note that this layer
      will silently refuse to be pushed on top of itself.
    <p class="Pp">It currently does <i>not</i> mimic MS-DOS as far as treating
        of Control-Z as being an end-of-file marker.</p>
    <p class="Pp">Based on the <span class="Li">&quot;:perlio&quot;</span>
        layer.</p>
  </dd>
  <dt>:utf8</dt>
  <dd>Declares that the stream accepts perl's <i>internal</i> encoding of
      characters. (Which really is UTF-8 on ASCII machines, but is UTF-EBCDIC on
      EBCDIC machines.) This allows any character perl can represent to be read
      from or written to the stream. The UTF-X encoding is chosen to render
      simple text parts (i.e. non-accented letters, digits and common
      punctuation) human readable in the encoded file.
    <p class="Pp">Here is how to write your native data out using UTF-8 (or
        UTF-EBCDIC) and then read it back in.</p>
    <p class="Pp"></p>
    <pre>
        open(F, &quot;&gt;:utf8&quot;, &quot;data.utf&quot;);
        print F $out;
        close(F);

        open(F, &quot;&lt;:utf8&quot;, &quot;data.utf&quot;);
        $in = &lt;F&gt;;
        close(F);
    </pre>
    <p class="Pp">Note that this layer does not validate byte sequences. For
        reading input, using <span class="Li">&quot;:encoding(utf8)&quot;</span>
        instead of bare <span class="Li">&quot;:utf8&quot;</span> is strongly
        recommended.</p>
  </dd>
  <dt>:bytes</dt>
  <dd>This is the inverse of the <span class="Li">&quot;:utf8&quot;</span>
      layer. It turns off the flag on the layer below so that data read from it
      is considered to be &quot;octets&quot; i.e. characters in the range 0..255
      only. Likewise on output perl will warn if a &quot;wide&quot; character is
      written to a such a stream.</dd>
  <dt>:raw</dt>
  <dd>The <span class="Li">&quot;:raw&quot;</span> layer is <i>defined</i> as
      being identical to calling
      <span class="Li">&quot;binmode($fh)&quot;</span> - the stream is made
      suitable for passing binary data, i.e. each byte is passed as-is. The
      stream will still be buffered.
    <p class="Pp">In Perl 5.6 and some books the
        <span class="Li">&quot;:raw&quot;</span> layer (previously sometimes
        also referred to as a &quot;discipline&quot;) is documented as the
        inverse of the <span class="Li">&quot;:crlf&quot;</span> layer. That is
        no longer the case - other layers which would alter the binary nature of
        the stream are also disabled. If you want UNIX line endings on a
        platform that normally does CRLF translation, but still want UTF-8 or
        encoding defaults, the appropriate thing to do is to add
        <span class="Li">&quot;:perlio&quot;</span> to the PERLIO environment
        variable.</p>
    <p class="Pp">The implementation of <span class="Li">&quot;:raw&quot;</span>
        is as a pseudo-layer which when &quot;pushed&quot; pops itself and then
        any layers which do not declare themselves as suitable for binary data.
        (Undoing :utf8 and :crlf are implemented by clearing flags rather than
        popping layers but that is an implementation detail.)</p>
    <p class="Pp">As a consequence of the fact that
        <span class="Li">&quot;:raw&quot;</span> normally pops layers, it
        usually only makes sense to have it as the only or first element in a
        layer specification. When used as the first element it provides a known
        base on which to build e.g.</p>
    <p class="Pp"></p>
    <pre>
    open($fh,&quot;:raw:utf8&quot;,...)
    </pre>
    <p class="Pp">will construct a &quot;binary&quot; stream, but then enable
        UTF-8 translation.</p>
  </dd>
  <dt>:pop</dt>
  <dd>A pseudo layer that removes the top-most layer. Gives perl code a way to
      manipulate the layer stack. Should be considered as experimental. Note
      that <span class="Li">&quot;:pop&quot;</span> only works on real layers
      and will not undo the effects of pseudo layers like
      <span class="Li">&quot;:utf8&quot;</span>. An example of a possible use
      might be:
    <p class="Pp"></p>
    <pre>
    open($fh,...)
    ...
    binmode($fh,&quot;:encoding(...)&quot;);  # next chunk is encoded
    ...
    binmode($fh,&quot;:pop&quot;);            # back to un-encoded
    </pre>
    <p class="Pp">A more elegant (and safer) interface is needed.</p>
  </dd>
  <dt>:win32</dt>
  <dd>On Win32 platforms this <i>experimental</i> layer uses the native
      &quot;handle&quot; IO rather than the unix-like numeric file descriptor
      layer. Known to be buggy as of perl 5.8.2.</dd>
</dl>
<section class="Ss">
<h2 class="Ss" id="Custom_Layers"><a class="permalink" href="#Custom_Layers">Custom
  Layers</a></h2>
<p class="Pp">It is possible to write custom layers in addition to the above
    builtin ones, both in C/XS and Perl. Two such layers (and one example
    written in Perl using the latter) come with the Perl distribution.</p>
<dl class="Bl-tag">
  <dt>:encoding</dt>
  <dd>Use <span class="Li">&quot;:encoding(ENCODING)&quot;</span> either in
      <i>open()</i> or <i>binmode()</i> to install a layer that transparently
      does character set and encoding transformations, for example from
      Shift-JIS to Unicode. Note that under
      <span class="Li">&quot;stdio&quot;</span> an
      <span class="Li">&quot;:encoding&quot;</span> also enables
      <span class="Li">&quot;:utf8&quot;</span>. See PerlIO::encoding for more
      information.</dd>
  <dt>:mmap</dt>
  <dd>A layer which implements &quot;reading&quot; of files by using
      <span class="Li">&quot;mmap()&quot;</span> to make a (whole) file appear
      in the process's address space, and then using that as PerlIO's
      &quot;buffer&quot;. This <i>may</i> be faster in certain circumstances for
      large files, and may result in less physical memory use when multiple
      processes are reading the same file.
    <p class="Pp">Files which are not
        <span class="Li">&quot;mmap()&quot;</span>-able revert to behaving like
        the <span class="Li">&quot;:perlio&quot;</span> layer. Writes also
        behave like the <span class="Li">&quot;:perlio&quot;</span> layer, as
        <span class="Li">&quot;mmap()&quot;</span> for write needs extra
        house-keeping (to extend the file) which negates any advantage.</p>
    <p class="Pp">The <span class="Li">&quot;:mmap&quot;</span> layer will not
        exist if the platform does not support
        <span class="Li">&quot;mmap()&quot;</span>.</p>
  </dd>
  <dt>:via</dt>
  <dd>Use <span class="Li">&quot;:via(MODULE)&quot;</span> either in
      <i>open()</i> or <i>binmode()</i> to install a layer that does whatever
      transformation (for example compression / decompression, encryption /
      decryption) to the filehandle. See PerlIO::via for more information.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Alternatives_to_raw"><a class="permalink" href="#Alternatives_to_raw">Alternatives
  to raw</a></h2>
<p class="Pp">To get a binary stream an alternate method is to use:</p>
<p class="Pp"></p>
<pre>
    open($fh,&quot;whatever&quot;)
    binmode($fh);
</pre>
<p class="Pp">this has the advantage of being backward compatible with how such
    things have had to be coded on some platforms for years.</p>
<p class="Pp">To get an unbuffered stream specify an unbuffered layer (e.g.
    <span class="Li">&quot;:unix&quot;</span>) in the open call:</p>
<p class="Pp"></p>
<pre>
    open($fh,&quot;&lt;:unix&quot;,$path)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Defaults_and_how_to_override_them"><a class="permalink" href="#Defaults_and_how_to_override_them">Defaults
  and how to override them</a></h2>
<p class="Pp">If the platform is MS-DOS like and normally does CRLF to
    &quot;\n&quot; translation for text files then the default layers are :</p>
<p class="Pp"></p>
<pre>
  unix crlf
</pre>
<p class="Pp">(The low level &quot;unix&quot; layer may be replaced by a
    platform specific low level layer.)</p>
<p class="Pp">Otherwise if <span class="Li">&quot;Configure&quot;</span> found
    out how to do &quot;fast&quot; IO using the system's stdio, then the default
    layers are:</p>
<p class="Pp"></p>
<pre>
  unix stdio
</pre>
<p class="Pp">Otherwise the default layers are</p>
<p class="Pp"></p>
<pre>
  unix perlio
</pre>
<p class="Pp">These defaults may change once perlio has been better tested and
    tuned.</p>
<p class="Pp">The default can be overridden by setting the environment variable
    PERLIO to a space separated list of layers
    (<span class="Li">&quot;unix&quot;</span> or platform low level layer is
    always pushed first).</p>
<p class="Pp">This can be used to see the effect of/bugs in the various layers
    e.g.</p>
<p class="Pp"></p>
<pre>
  cd .../perl/t
  PERLIO=stdio  ./perl harness
  PERLIO=perlio ./perl harness
</pre>
<p class="Pp">For the various values of PERLIO see &quot;PERLIO&quot; in
    perlrun.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Querying_the_layers_of_filehandles"><a class="permalink" href="#Querying_the_layers_of_filehandles">Querying
  the layers of filehandles</a></h2>
<p class="Pp">The following returns the <b>names</b> of the PerlIO layers on a
    filehandle.</p>
<p class="Pp"></p>
<pre>
   my @layers = PerlIO::get_layers($fh); # Or FH, *FH, &quot;FH&quot;.
</pre>
<p class="Pp">The layers are returned in the order an <i>open()</i> or
    <i>binmode()</i> call would use them. Note that the &quot;default
    stack&quot; depends on the operating system and on the Perl version, and
    both the compile-time and runtime configurations of Perl.</p>
<p class="Pp">The following table summarizes the default layers on UNIX-like and
    DOS-like platforms and depending on the setting of
    <span class="Li">$ENV{PERLIO}</span>:</p>
<p class="Pp"></p>
<pre>
 PERLIO     UNIX-like                   DOS-like
 ------     ---------                   --------
 unset / &quot;&quot; unix perlio / stdio [1]     unix crlf
 stdio      unix perlio / stdio [1]     stdio
 perlio     unix perlio                 unix perlio

 # [1] &quot;stdio&quot; if Configure found out how to do &quot;fast stdio&quot; (depends
 # on the stdio implementation) and in Perl 5.8, otherwise &quot;unix perlio&quot;
</pre>
<p class="Pp">By default the layers from the input side of the filehandle are
    returned; to get the output side, use the optional
    <span class="Li">&quot;output&quot;</span> argument:</p>
<p class="Pp"></p>
<pre>
   my @layers = PerlIO::get_layers($fh, output =&gt; 1);
</pre>
<p class="Pp">(Usually the layers are identical on either side of a filehandle
    but for example with sockets there may be differences, or if you have been
    using the <span class="Li">&quot;open&quot;</span> pragma.)</p>
<p class="Pp">There is no <i>set_layers()</i>, nor does <i>get_layers()</i>
    return a tied array mirroring the stack, or anything fancy like that. This
    is not accidental or unintentional. The PerlIO layer stack is a bit more
    complicated than just a stack (see for example the behaviour of
    <span class="Li">&quot;:raw&quot;</span>). You are supposed to use
    <i>open()</i> and <i>binmode()</i> to manipulate the stack.</p>
<p class="Pp"><b>Implementation details follow, please close your eyes.</b></p>
<p class="Pp">The arguments to layers are by default returned in parentheses
    after the name of the layer, and certain layers (like
    <span class="Li">&quot;utf8&quot;</span>) are not real layers but instead
    flags on real layers; to get all of these returned separately, use the
    optional <span class="Li">&quot;details&quot;</span> argument:</p>
<p class="Pp"></p>
<pre>
   my @layer_and_args_and_flags = PerlIO::get_layers($fh, details =&gt; 1);
</pre>
<p class="Pp">The result will be up to be three times the number of layers: the
    first element will be a name, the second element the arguments (unspecified
    arguments will be <span class="Li">&quot;undef&quot;</span>), the third
    element the flags, the fourth element a name again, and so forth.</p>
<p class="Pp"><b>You may open your eyes now.</b></p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Nick Ing-Simmons &lt;nick@ing-simmons.net&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">&quot;binmode&quot; in perlfunc, &quot;open&quot; in perlfunc,
    perlunicode, perliol, Encode</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

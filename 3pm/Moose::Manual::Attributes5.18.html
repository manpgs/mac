<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Moose::Manual::Attributes(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Moose::Manual::Attributes(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Moose::Manual::Attributes(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Moose::Manual::Attributes - Object attributes with Moose</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 2.1202</p>
</section>
<section class="Sh">
<h1 class="Sh" id="INTRODUCTION"><a class="permalink" href="#INTRODUCTION">INTRODUCTION</a></h1>
<p class="Pp">Moose attributes have many properties, and attributes are probably
    the single most powerful and flexible part of Moose. You can create a
    powerful class simply by declaring attributes. In fact, it's possible to
    have classes that consist solely of attribute declarations.</p>
<p class="Pp">An attribute is a property that every member of a class has. For
    example, we might say that &quot;every
    <span class="Li">&quot;Person&quot;</span> object has a first name and last
    name&quot;. Attributes can be optional, so that we can say &quot;some
    <span class="Li">&quot;Person&quot;</span> objects have a social security
    number (and some don't)&quot;.</p>
<p class="Pp">At its simplest, an attribute can be thought of as a named value
    (as in a hash) that can be read and set. However, attributes can also have
    defaults, type constraints, delegation and much more.</p>
<p class="Pp">In other languages, attributes are also referred to as slots or
    properties.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ATTRIBUTE_OPTIONS"><a class="permalink" href="#ATTRIBUTE_OPTIONS">ATTRIBUTE
  OPTIONS</a></h1>
<p class="Pp">Use the <span class="Li">&quot;has&quot;</span> function to
    declare an attribute:</p>
<p class="Pp"></p>
<pre>
  package Person;

  use Moose;

  has 'first_name' =&gt; ( is =&gt; 'rw' );
</pre>
<p class="Pp">This says that all <span class="Li">&quot;Person&quot;</span>
    objects have an optional read-write &quot;first_name&quot; attribute.</p>
<section class="Ss">
<h2 class="Ss" id="Read-write_vs._read-only"><a class="permalink" href="#Read-write_vs._read-only">Read-write
  vs. read-only</a></h2>
<p class="Pp">The options passed to <span class="Li">&quot;has&quot;</span>
    define the properties of the attribute. There are many options, but in the
    simplest form you just need to set <span class="Li">&quot;is&quot;</span>,
    which can be either <span class="Li">&quot;ro&quot;</span> (read-only) or
    <span class="Li">&quot;rw&quot;</span> (read-write). When an attribute is
    <span class="Li">&quot;rw&quot;</span>, you can change it by passing a value
    to its accessor. When an attribute is
    <span class="Li">&quot;ro&quot;</span>, you may only read the current value
    of the attribute.</p>
<p class="Pp">In fact, you could even omit
    <span class="Li">&quot;is&quot;</span>, but that gives you an attribute that
    has no accessor. This can be useful with other attribute options, such as
    <span class="Li">&quot;handles&quot;</span>. However, if your attribute
    generates <i>no</i> accessors, Moose will issue a warning, because that
    usually means the programmer forgot to say the attribute is read-only or
    read-write. If you really mean to have no accessors, you can silence this
    warning by setting <span class="Li">&quot;is&quot;</span> to
    <span class="Li">&quot;bare&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Accessor_methods"><a class="permalink" href="#Accessor_methods">Accessor
  methods</a></h2>
<p class="Pp">Each attribute has one or more accessor methods. An accessor lets
    you read and write the value of that attribute for an object.</p>
<p class="Pp">By default, the accessor method has the same name as the
    attribute. If you declared your attribute as
    <span class="Li">&quot;ro&quot;</span> then your accessor will be read-only.
    If you declared it as <span class="Li">&quot;rw&quot;</span>, you get a
    read-write accessor. Simple.</p>
<p class="Pp">Given our <span class="Li">&quot;Person&quot;</span> example
    above, we now have a single <span class="Li">&quot;first_name&quot;</span>
    accessor that can read or write a <span class="Li">&quot;Person&quot;</span>
    object's <span class="Li">&quot;first_name&quot;</span> attribute's
  value.</p>
<p class="Pp">If you want, you can also explicitly specify the method names to
    be used for reading and writing an attribute's value. This is particularly
    handy when you'd like an attribute to be publicly readable, but only
    privately settable. For example:</p>
<p class="Pp"></p>
<pre>
  has 'weight' =&gt; (
      is     =&gt; 'ro',
      writer =&gt; '_set_weight',
  );
</pre>
<p class="Pp">This might be useful if weight is calculated based on other
    methods. For example, every time the <span class="Li">&quot;eat&quot;</span>
    method is called, we might adjust weight. This lets us hide the
    implementation details of weight changes, but still provide the weight value
    to users of the class.</p>
<p class="Pp">Some people might prefer to have distinct methods for reading and
    writing. In <i>Perl Best Practices</i>, Damian Conway recommends that reader
    methods start with &quot;get_&quot; and writer methods start with
    &quot;set_&quot;.</p>
<p class="Pp">We can do exactly that by providing names for both the
    <span class="Li">&quot;reader&quot;</span> and
    <span class="Li">&quot;writer&quot;</span> methods:</p>
<p class="Pp"></p>
<pre>
  has 'weight' =&gt; (
      is     =&gt; 'rw',
      reader =&gt; 'get_weight',
      writer =&gt; 'set_weight',
  );
</pre>
<p class="Pp">If you're thinking that doing this over and over would be insanely
    tedious, you're right! Fortunately, Moose provides a powerful extension
    system that lets you override the default naming conventions. See
    Moose::Manual::MooseX for more details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Predicate_and_clearer_methods"><a class="permalink" href="#Predicate_and_clearer_methods">Predicate
  and clearer methods</a></h2>
<p class="Pp">Moose allows you to explicitly distinguish between a false or
    undefined attribute value and an attribute which has not been set. If you
    want to access this information, you must define clearer and predicate
    methods for an attribute.</p>
<p class="Pp">A predicate method tells you whether or not a given attribute is
    currently set. Note that an attribute can be explicitly set to
    <span class="Li">&quot;undef&quot;</span> or some other false value, but the
    predicate will return true.</p>
<p class="Pp">The clearer method unsets the attribute. This is <i>not</i> the
    same as setting the value to <span class="Li">&quot;undef&quot;</span>, but
    you can only distinguish between them if you define a predicate method!</p>
<p class="Pp">Here's some code to illustrate the relationship between an
    accessor, predicate, and clearer method.</p>
<p class="Pp"></p>
<pre>
  package Person;

  use Moose;

  has 'ssn' =&gt; (
      is        =&gt; 'rw',
      clearer   =&gt; 'clear_ssn',
      predicate =&gt; 'has_ssn',
  );

  ...

  my $person = Person-&gt;new();
  $person-&gt;has_ssn; # false

  $person-&gt;ssn(undef);
  $person-&gt;ssn; # returns undef
  $person-&gt;has_ssn; # true

  $person-&gt;clear_ssn;
  $person-&gt;ssn; # returns undef
  $person-&gt;has_ssn; # false

  $person-&gt;ssn('123-45-6789');
  $person-&gt;ssn; # returns '123-45-6789'
  $person-&gt;has_ssn; # true

  my $person2 = Person-&gt;new( ssn =&gt; '111-22-3333');
  $person2-&gt;has_ssn; # true
</pre>
<p class="Pp">By default, Moose does not make a predicate or clearer for you.
    You must explicitly provide names for them, and then Moose will create the
    methods for you.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Required_or_not?"><a class="permalink" href="#Required_or_not?">Required
  or not?</a></h2>
<p class="Pp">By default, all attributes are optional, and do not need to be
    provided at object construction time. If you want to make an attribute
    required, simply set the <span class="Li">&quot;required&quot;</span> option
    to true:</p>
<p class="Pp"></p>
<pre>
  has 'name' =&gt; (
      is       =&gt; 'ro',
      required =&gt; 1,
  );
</pre>
<p class="Pp">There are a couple caveats worth mentioning in regards to what
    &quot;required&quot; actually means.</p>
<p class="Pp">Basically, all it says is that this attribute
    (<span class="Li">&quot;name&quot;</span>) must be provided to the
    constructor, or be lazy with either a default or a builder. It does not say
    anything about its value, so it could be
    <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp">If you define a clearer method on a required attribute, the
    clearer <i>will</i> work, so even a required attribute can be unset after
    object construction.</p>
<p class="Pp">This means that if you do make an attribute required, providing a
    clearer doesn't make much sense. In some cases, it might be handy to have a
    <i>private</i> <span class="Li">&quot;clearer&quot;</span> and
    <span class="Li">&quot;predicate&quot;</span> for a required attribute.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Default_and_builder_methods"><a class="permalink" href="#Default_and_builder_methods">Default
  and builder methods</a></h2>
<p class="Pp">Attributes can have default values, and Moose provides two ways to
    specify that default.</p>
<p class="Pp">In the simplest form, you simply provide a non-reference scalar
    value for the <span class="Li">&quot;default&quot;</span> option:</p>
<p class="Pp"></p>
<pre>
  has 'size' =&gt; (
      is        =&gt; 'ro',
      default   =&gt; 'medium',
      predicate =&gt; 'has_size',
  );
</pre>
<p class="Pp">If the size attribute is not provided to the constructor, then it
    ends up being set to <span class="Li">&quot;medium&quot;</span>:</p>
<p class="Pp"></p>
<pre>
  my $person = Person-&gt;new();
  $person-&gt;size; # medium
  $person-&gt;has_size; # true
</pre>
<p class="Pp">You can also provide a subroutine reference for
    <span class="Li">&quot;default&quot;</span>. This reference will be called
    as a method on the object.</p>
<p class="Pp"></p>
<pre>
  has 'size' =&gt; (
      is =&gt; 'ro',
      default =&gt;
          sub { ( 'small', 'medium', 'large' )[ int( rand 3 ) ] },
      predicate =&gt; 'has_size',
  );
</pre>
<p class="Pp">This is a trivial example, but it illustrates the point that the
    subroutine will be called for every new object created.</p>
<p class="Pp">When you provide a <span class="Li">&quot;default&quot;</span>
    subroutine reference, it is called as a method on the object, with no
    additional parameters:</p>
<p class="Pp"></p>
<pre>
  has 'size' =&gt; (
      is      =&gt; 'ro',
      default =&gt; sub {
          my $self = shift;

          return $self-&gt;height &gt; 200 ? 'large' : 'average';
      },
  );
</pre>
<p class="Pp">When the <span class="Li">&quot;default&quot;</span> is called
    during object construction, it may be called before other attributes have
    been set. If your default is dependent on other parts of the object's state,
    you can make the attribute <span class="Li">&quot;lazy&quot;</span>.
    Laziness is covered in the next section.</p>
<p class="Pp">If you want to use a reference of any sort as the default value,
    you must return it from a subroutine.</p>
<p class="Pp"></p>
<pre>
  has 'mapping' =&gt; (
      is      =&gt; 'ro',
      default =&gt; sub { {} },
  );
</pre>
<p class="Pp">This is necessary because otherwise Perl would instantiate the
    reference exactly once, and it would be shared by all objects:</p>
<p class="Pp"></p>
<pre>
  has 'mapping' =&gt; (
      is      =&gt; 'ro',
      default =&gt; {}, # wrong!
  );
</pre>
<p class="Pp">Moose will throw an error if you pass a bare non-subroutine
    reference as the default.</p>
<p class="Pp">If Moose allowed this then the default mapping attribute could
    easily end up shared across many objects. Instead, wrap it in a subroutine
    reference as we saw above.</p>
<p class="Pp">This is a bit awkward, but it's just the way Perl works.</p>
<p class="Pp">As an alternative to using a subroutine reference, you can supply
    a <span class="Li">&quot;builder&quot;</span> method for your attribute:</p>
<p class="Pp"></p>
<pre>
  has 'size' =&gt; (
      is        =&gt; 'ro',
      builder   =&gt; '_build_size',
      predicate =&gt; 'has_size',
  );

  sub _build_size {
      return ( 'small', 'medium', 'large' )[ int( rand 3 ) ];
  }
</pre>
<p class="Pp">This has several advantages. First, it moves a chunk of code to
    its own named method, which improves readability and code organization.
    Second, because this is a <i>named</i> method, it can be subclassed or
    provided by a role.</p>
<p class="Pp">We strongly recommend that you use a
    <span class="Li">&quot;builder&quot;</span> instead of a
    <span class="Li">&quot;default&quot;</span> for anything beyond the most
    trivial default.</p>
<p class="Pp">A <span class="Li">&quot;builder&quot;</span>, just like a
    <span class="Li">&quot;default&quot;</span>, is called as a method on the
    object with no additional parameters.</p>
<p class="Pp"><i>Builders allow subclassing</i></p>
<p class="Pp">Because the <span class="Li">&quot;builder&quot;</span> is called
    <i>by name</i>, it goes through Perl's method resolution. This means that
    builder methods are both inheritable and overridable.</p>
<p class="Pp">If we subclass our <span class="Li">&quot;Person&quot;</span>
    class, we can override <span class="Li">&quot;_build_size&quot;</span>:</p>
<p class="Pp"></p>
<pre>
  package Lilliputian;

  use Moose;
  extends 'Person';

  sub _build_size { return 'small' }
</pre>
<p class="Pp"><i>Builders work well with roles</i></p>
<p class="Pp">Because builders are called by name, they work well with roles.
    For example, a role could provide an attribute but require that the
    consuming class provide the <span class="Li">&quot;builder&quot;</span>:</p>
<p class="Pp"></p>
<pre>
  package HasSize;
  use Moose::Role;

  requires '_build_size';

  has 'size' =&gt; (
      is      =&gt; 'ro',
      lazy    =&gt; 1,
      builder =&gt; '_build_size',
  );

  package Lilliputian;
  use Moose;

  with 'HasSize';

  sub _build_size { return 'small' }
</pre>
<p class="Pp">Roles are covered in Moose::Manual::Roles.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Laziness"><a class="permalink" href="#Laziness">Laziness</a></h2>
<p class="Pp">Moose lets you defer attribute population by making an attribute
    <span class="Li">&quot;lazy&quot;</span>:</p>
<p class="Pp"></p>
<pre>
  has 'size' =&gt; (
      is      =&gt; 'ro',
      lazy    =&gt; 1,
      builder =&gt; '_build_size',
  );
</pre>
<p class="Pp">When <span class="Li">&quot;lazy&quot;</span> is true, the default
    is not generated until the reader method is called, rather than at object
    construction time. There are several reasons you might choose to do
  this.</p>
<p class="Pp">First, if the default value for this attribute depends on some
    other attributes, then the attribute <i>must</i> be
    <span class="Li">&quot;lazy&quot;</span>. During object construction,
    defaults are not generated in a predictable order, so you cannot count on
    some other attribute being populated when generating a default.</p>
<p class="Pp">Second, there's often no reason to calculate a default before it's
    needed. Making an attribute <span class="Li">&quot;lazy&quot;</span> lets
    you defer the cost until the attribute is needed. If the attribute is
    <i>never</i> needed, you save some CPU time.</p>
<p class="Pp">We recommend that you make any attribute with a builder or
    non-trivial default <span class="Li">&quot;lazy&quot;</span> as a matter of
    course.</p>
<p class="Pp"><i>Lazy defaults and </i><i>$_</i><i></i></p>
<p class="Pp">Please note that a lazy default or builder can be called anywhere,
    even inside a <span class="Li">&quot;map&quot;</span> or
    <span class="Li">&quot;grep&quot;</span>. This means that if your default
    sub or builder changes <span class="Li">$_</span>, something weird could
    happen. You can prevent this by adding <span class="Li">&quot;local</span>
    <span class="Li">$_&quot;</span> inside your default or builder.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Constructor_parameters_(_init_arg_)"><a class="permalink" href="#Constructor_parameters_(_init_arg_)">Constructor
  parameters (&quot;init_arg&quot;)</a></h2>
<p class="Pp">By default, each attribute can be passed by name to the class's
    constructor. On occasion, you may want to use a different name for the
    constructor parameter. You may also want to make an attribute unsettable via
    the constructor.</p>
<p class="Pp">You can do either of these things with the
    <span class="Li">&quot;init_arg&quot;</span> option:</p>
<p class="Pp"></p>
<pre>
  has 'bigness' =&gt; (
      is       =&gt; 'ro',
      init_arg =&gt; 'size',
  );
</pre>
<p class="Pp">Now we have an attribute named &quot;bigness&quot;, but we pass
    <span class="Li">&quot;size&quot;</span> to the constructor.</p>
<p class="Pp">Even more useful is the ability to disable setting an attribute
    via the constructor. This is particularly handy for private attributes:</p>
<p class="Pp"></p>
<pre>
  has '_genetic_code' =&gt; (
      is       =&gt; 'ro',
      lazy     =&gt; 1,
      builder  =&gt; '_build_genetic_code',
      init_arg =&gt; undef,
  );
</pre>
<p class="Pp">By setting the <span class="Li">&quot;init_arg&quot;</span> to
    <span class="Li">&quot;undef&quot;</span>, we make it impossible to set this
    attribute when creating a new object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Weak_references"><a class="permalink" href="#Weak_references">Weak
  references</a></h2>
<p class="Pp">Moose has built-in support for weak references. If you set the
    <span class="Li">&quot;weak_ref&quot;</span> option to a true value, then it
    will call <span class="Li">&quot;Scalar::Util::weaken&quot;</span> whenever
    the attribute is set:</p>
<p class="Pp"></p>
<pre>
  has 'parent' =&gt; (
      is       =&gt; 'rw',
      weak_ref =&gt; 1,
  );

  $node-&gt;parent($parent_node);
</pre>
<p class="Pp">This is very useful when you're building objects that may contain
    circular references.</p>
<p class="Pp">When the object in a weak reference goes out of scope, the
    attribute's value will become <span class="Li">&quot;undef&quot;</span>
    &quot;behind the scenes&quot;. This is done by the Perl interpreter
    directly, so Moose does not see this change. This means that triggers don't
    fire, coercions aren't applied, etc.</p>
<p class="Pp">The attribute is not cleared, so a predicate method for that
    attribute will still return true. Similarly, when the attribute is next
    accessed, a default value will not be generated.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Triggers"><a class="permalink" href="#Triggers">Triggers</a></h2>
<p class="Pp">A <span class="Li">&quot;trigger&quot;</span> is a subroutine that
    is called whenever the attribute is set:</p>
<p class="Pp"></p>
<pre>
  has 'size' =&gt; (
      is      =&gt; 'rw',
      trigger =&gt; \&amp;_size_set,
  );

  sub _size_set {
      my ( $self, $size, $old_size ) = @_;

      my $msg = $self-&gt;name;

      if ( @_ &gt; 2 ) {
          $msg .= &quot; - old size was $old_size&quot;;
      }

      $msg .= &quot; - size is now $size&quot;;
      warn $msg;
  }
</pre>
<p class="Pp">The trigger is called <i>after</i> an attribute's value is set. It
    is called as a method on the object, and receives the new and old values as
    its arguments. If the attribute had not previously been set at all, then
    only the new value is passed. This lets you distinguish between the case
    where the attribute had no value versus when the old value was
    <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp">This differs from an <span class="Li">&quot;after&quot;</span>
    method modifier in two ways. First, a trigger is only called when the
    attribute is set, as opposed to whenever the accessor method is called (for
    reading or writing). Second, it is also called when an attribute's value is
    passed to the constructor.</p>
<p class="Pp">However, triggers are <i>not</i> called when an attribute is
    populated from a <span class="Li">&quot;default&quot;</span> or
    <span class="Li">&quot;builder&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Attribute_types"><a class="permalink" href="#Attribute_types">Attribute
  types</a></h2>
<p class="Pp">Attributes can be restricted to only accept certain types:</p>
<p class="Pp"></p>
<pre>
  has 'first_name' =&gt; (
      is  =&gt; 'ro',
      isa =&gt; 'Str',
  );
</pre>
<p class="Pp">This says that the <span class="Li">&quot;first_name&quot;</span>
    attribute must be a string.</p>
<p class="Pp">Moose also provides a shortcut for specifying that an attribute
    only accepts objects that do a certain role:</p>
<p class="Pp"></p>
<pre>
  has 'weapon' =&gt; (
      is   =&gt; 'rw',
      does =&gt; 'MyApp::Weapon',
  );
</pre>
<p class="Pp">See the Moose::Manual::Types documentation for a complete
    discussion of Moose's type system.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Delegation"><a class="permalink" href="#Delegation">Delegation</a></h2>
<p class="Pp">An attribute can define methods which simply delegate to its
    value:</p>
<p class="Pp"></p>
<pre>
  has 'hair_color' =&gt; (
      is      =&gt; 'ro',
      isa     =&gt; 'Graphics::Color::RGB',
      handles =&gt; { hair_color_hex =&gt; 'as_hex_string' },
  );
</pre>
<p class="Pp">This adds a new method,
    <span class="Li">&quot;hair_color_hex&quot;</span>. When someone calls
    <span class="Li">&quot;hair_color_hex&quot;</span>, internally, the object
    just calls
    <span class="Li">&quot;$self-&gt;hair_color-&gt;as_hex_string&quot;</span>.</p>
<p class="Pp">See Moose::Manual::Delegation for documentation on how to set up
    delegation methods.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Attribute_traits_and_metaclasses"><a class="permalink" href="#Attribute_traits_and_metaclasses">Attribute
  traits and metaclasses</a></h2>
<p class="Pp">One of Moose's best features is that it can be extended in all
    sorts of ways through the use of metaclass traits and custom
  metaclasses.</p>
<p class="Pp">You can apply one or more traits to an attribute:</p>
<p class="Pp"></p>
<pre>
  use MooseX::MetaDescription;

  has 'size' =&gt; (
      is          =&gt; 'ro',
      traits      =&gt; ['MooseX::MetaDescription::Meta::Trait'],
      description =&gt; {
          html_widget  =&gt; 'text_input',
          serialize_as =&gt; 'element',
      },
  );
</pre>
<p class="Pp">The advantage of traits is that you can mix more than one of them
    together easily (in fact, a trait is just a role under the hood).</p>
<p class="Pp">There are a number of MooseX modules on CPAN which provide useful
    attribute metaclasses and traits. See Moose::Manual::MooseX for some
    examples. You can also write your own metaclasses and traits. See the
    &quot;Meta&quot; and &quot;Extending&quot; recipes in Moose::Cookbook for
    examples.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Native_Delegations"><a class="permalink" href="#Native_Delegations">Native
  Delegations</a></h2>
<p class="Pp">Native delegations allow you to delegate to standard Perl data
    structures as if they were objects.</p>
<p class="Pp">For example, we can pretend that an array reference has methods
    like <span class="Li">&quot;push()&quot;</span>,
    <span class="Li">&quot;shift()&quot;</span>,
    <span class="Li">&quot;map()&quot;</span>,
    <span class="Li">&quot;count()&quot;</span>, and more.</p>
<p class="Pp"></p>
<pre>
  has 'options' =&gt; (
      traits  =&gt; ['Array'],
      is      =&gt; 'ro',
      isa     =&gt; 'ArrayRef[Str]',
      default =&gt; sub { [] },
      handles =&gt; {
          all_options    =&gt; 'elements',
          add_option     =&gt; 'push',
          map_options    =&gt; 'map',
          option_count   =&gt; 'count',
          sorted_options =&gt; 'sort',
      },
  );
</pre>
<p class="Pp">See Moose::Manual::Delegation for more details.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ATTRIBUTE_INHERITANCE"><a class="permalink" href="#ATTRIBUTE_INHERITANCE">ATTRIBUTE
  INHERITANCE</a></h1>
<p class="Pp">By default, a child inherits all of its parent class(es)'
    attributes as-is. However, you can change most aspects of the inherited
    attribute in the child class. You cannot change any of its associated method
    names (reader, writer, predicate, etc).</p>
<p class="Pp">To override an attribute, you simply prepend its name with a plus
    sign (<span class="Li">&quot;+&quot;</span>):</p>
<p class="Pp"></p>
<pre>
  package LazyPerson;

  use Moose;

  extends 'Person';

  has '+first_name' =&gt; (
      lazy    =&gt; 1,
      default =&gt; 'Bill',
  );
</pre>
<p class="Pp">Now the <span class="Li">&quot;first_name&quot;</span> attribute
    in <span class="Li">&quot;LazyPerson&quot;</span> is lazy, and defaults to
    <span class="Li">'Bill'</span>.</p>
<p class="Pp">We recommend that you exercise caution when changing the type
    (<span class="Li">&quot;isa&quot;</span>) of an inherited attribute.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MULTIPLE_ATTRIBUTE_SHORTCUTS"><a class="permalink" href="#MULTIPLE_ATTRIBUTE_SHORTCUTS">MULTIPLE
  ATTRIBUTE SHORTCUTS</a></h1>
<p class="Pp">If you have a number of attributes that differ only by name, you
    can declare them all at once:</p>
<p class="Pp"></p>
<pre>
  package Point;

  use Moose;

  has [ 'x', 'y' ] =&gt; ( is =&gt; 'ro', isa =&gt; 'Int' );
</pre>
<p class="Pp">Also, because <span class="Li">&quot;has&quot;</span> is just a
    function call, you can call it in a loop:</p>
<p class="Pp"></p>
<pre>
  for my $name ( qw( x y ) ) {
      my $builder = '_build_' . $name;
      has $name =&gt; ( is =&gt; 'ro', isa =&gt; 'Int', builder =&gt; $builder );
  }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="MORE_ON_ATTRIBUTES"><a class="permalink" href="#MORE_ON_ATTRIBUTES">MORE
  ON ATTRIBUTES</a></h1>
<p class="Pp">Moose attributes are a big topic, and this document glosses over a
    few aspects. We recommend that you read the Moose::Manual::Delegation and
    Moose::Manual::Types documents to get a more complete understanding of
    attribute features.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="A_FEW_MORE_OPTIONS"><a class="permalink" href="#A_FEW_MORE_OPTIONS">A
  FEW MORE OPTIONS</a></h1>
<p class="Pp">Moose has lots of attribute options. The ones listed below are
    superseded by some more modern features, but are covered for the sake of
    completeness.</p>
<section class="Ss">
<h2 class="Ss" id="The__documentation__option"><a class="permalink" href="#The__documentation__option">The
  &quot;documentation&quot; option</a></h2>
<p class="Pp">You can provide a piece of documentation as a string for an
    attribute:</p>
<p class="Pp"></p>
<pre>
  has 'first_name' =&gt; (
      is            =&gt; 'rw',
      documentation =&gt; q{The person's first (personal) name},
  );
</pre>
<p class="Pp">Moose does absolutely nothing with this information other than
    store it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The__auto_deref__option"><a class="permalink" href="#The__auto_deref__option">The
  &quot;auto_deref&quot; option</a></h2>
<p class="Pp">If your attribute is an array reference or hash reference, the
    <span class="Li">&quot;auto_deref&quot;</span> option will make Moose
    dereference the value when it is returned from the reader method <i>in list
    context</i>:</p>
<p class="Pp"></p>
<pre>
  my %map = $object-&gt;mapping;
</pre>
<p class="Pp">This option only works if your attribute is explicitly typed as an
    <span class="Li">&quot;ArrayRef&quot;</span> or
    <span class="Li">&quot;HashRef&quot;</span>. When the reader is called in
    <i>scalar</i> context, the reference itself is returned.</p>
<p class="Pp">However, we recommend that you use Moose::Meta::Attribute::Native
    traits for these types of attributes, which gives you much more control over
    how they are accessed and manipulated. See also
    Moose::Manual::BestPractices#Use_Moose::Meta::Attribute::Native_traits_instead_of_auto_deref.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Initializer"><a class="permalink" href="#Initializer">Initializer</a></h2>
<p class="Pp">Moose provides an attribute option called
    <span class="Li">&quot;initializer&quot;</span>. This is called when the
    attribute's value is being set in the constructor, and lets you change the
    value before it is set.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Stevan Little &lt;stevan.little@iinteractive.com&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
  <li>Shawn M Moore &lt;code@sartak.org&gt;</li>
  <li>XXXX XXX'XX (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Florian Ragwitz &lt;rafl@debian.org&gt;</li>
  <li>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</li>
  <li>Chris Prather &lt;chris@prather.org&gt;</li>
  <li>Matt S Trout &lt;mst@shadowcat.co.uk&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2006 by Infinity Interactive,
  Inc..</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-19</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Moose::Spec::Role(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Moose::Spec::Role(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Moose::Spec::Role(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Moose::Spec::Role - Formal spec for Role behavior</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 2.2012</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><b>NOTE:</b> This document is currently incomplete.</p>
<section class="Ss">
<h2 class="Ss" id="Components_of_a_Role"><a class="permalink" href="#Components_of_a_Role">Components
  of a Role</a></h2>
<dl class="Bl-tag">
  <dt id="Excluded"><a class="permalink" href="#Excluded">Excluded
    Roles</a></dt>
  <dd>A role can have a list of excluded roles, these are basically roles that
      they shouldn't be composed with. This is not just direct composition
      either, but also &quot;inherited&quot; composition.
    <p class="Pp">This feature was taken from the Fortress language and is
        really of most use when building a large set of role &quot;building
        blocks&quot; some of which should never be used together.</p>
  </dd>
  <dt id="Attributes"><a class="permalink" href="#Attributes">Attributes</a></dt>
  <dd>A roles attributes are similar to those of a class, except that they are
      not actually applied. This means that methods that are generated by an
      attributes accessor will not be generated in the role, but only created
      once the role is applied to a class.</dd>
  <dt id="Methods"><a class="permalink" href="#Methods">Methods</a></dt>
  <dd>These are the methods defined within the role. Simple as that.</dd>
  <dt id="Required"><a class="permalink" href="#Required">Required
    Methods</a></dt>
  <dd>A role can require a consuming class (or role) to provide a given method.
      Failure to do so for classes is a fatal error, while for roles it simply
      passes on the method requirement to the consuming role.</dd>
  <dt id="Required~2"><a class="permalink" href="#Required~2">Required
    Attributes</a></dt>
  <dd>Just as a role can require methods, it can also require attributes. The
      requirement fulfilling attribute must implement at least as much as is
      required. That means, for instance, that if the role requires that the
      attribute be read-only, then it must at least have a reader and can also
      have a writer. It means that if the role requires that the attribute be an
      ArrayRef, then it must either be an ArrayRef or a subtype of an
    ArrayRef.</dd>
  <dt id="Overridden"><a class="permalink" href="#Overridden">Overridden
    Methods</a></dt>
  <dd>The <span class="Li">&quot;override&quot;</span> and
      <span class="Li">&quot;super&quot;</span> keywords are allowed in roles,
      but their behavior is different from that of its class counterparts. The
      <span class="Li">&quot;super&quot;</span> in a class refers directly to
      that class's superclass, while the
      <span class="Li">&quot;super&quot;</span> in a role is deferred and only
      has meaning once the role is composed into a class. Once that composition
      occurs, <span class="Li">&quot;super&quot;</span> then refers to that
      class's superclass.
    <p class="Pp">It is key to remember that roles do not have hierarchy, so
        they can never have a <i>super</i> role.</p>
  </dd>
  <dt id="Method"><a class="permalink" href="#Method">Method Modifiers</a></dt>
  <dd>These are the <span class="Li">&quot;before&quot;</span>,
      <span class="Li">&quot;around&quot;</span> and
      <span class="Li">&quot;after&quot;</span> modifiers provided in Moose
      classes. The difference here is that the modifiers are not actually
      applied until the role is composed into a class (this is just like
      attributes and the <span class="Li">&quot;override&quot;</span>
    keyword).</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Role_Composition"><a class="permalink" href="#Role_Composition">Role
  Composition</a></h2>
<p class="Pp"><i>Composing into a Class</i></p>
<dl class="Bl-tag">
  <dt id="Excluded~2"><a class="permalink" href="#Excluded~2">Excluded
    Roles</a></dt>
  <dd></dd>
  <dt id="Required~3"><a class="permalink" href="#Required~3">Required
    Methods</a></dt>
  <dd></dd>
  <dt id="Required~4"><a class="permalink" href="#Required~4">Required
    Attributes</a></dt>
  <dd></dd>
  <dt id="Attributes~2"><a class="permalink" href="#Attributes~2">Attributes</a></dt>
  <dd></dd>
  <dt id="Methods~2"><a class="permalink" href="#Methods~2">Methods</a></dt>
  <dd></dd>
  <dt id="Overridden~2"><a class="permalink" href="#Overridden~2">Overridden
    methods</a></dt>
  <dd></dd>
  <dt id="Method~2"><a class="permalink" href="#Method~2">Method Modifiers
    (before, around, after)</a></dt>
  <dd></dd>
</dl>
<p class="Pp"><i>Composing into a Instance</i></p>
<p class="Pp"><i>Composing into a Role</i></p>
<dl class="Bl-tag">
  <dt id="Excluded~3"><a class="permalink" href="#Excluded~3">Excluded
    Roles</a></dt>
  <dd></dd>
  <dt id="Required~5"><a class="permalink" href="#Required~5">Required
    Methods</a></dt>
  <dd></dd>
  <dt id="Required~6"><a class="permalink" href="#Required~6">Required
    Attributes</a></dt>
  <dd></dd>
  <dt id="Attributes~3"><a class="permalink" href="#Attributes~3">Attributes</a></dt>
  <dd></dd>
  <dt id="Methods~3"><a class="permalink" href="#Methods~3">Methods</a></dt>
  <dd></dd>
  <dt id="Overridden~3"><a class="permalink" href="#Overridden~3">Overridden
    methods</a></dt>
  <dd></dd>
  <dt id="Method~3"><a class="permalink" href="#Method~3">Method Modifiers
    (before, around, after)</a></dt>
  <dd></dd>
</dl>
<p class="Pp"><i>Role Summation</i></p>
<p class="Pp">When multiple roles are added to another role (using the
    <span class="Li">&quot;with @roles&quot;</span> keyword) the roles are
    composed symmetrically. The product of the composition is a composite role
    (Moose::Meta::Role::Composite).</p>
<dl class="Bl-tag">
  <dt id="Excluded~4"><a class="permalink" href="#Excluded~4">Excluded
    Roles</a></dt>
  <dd></dd>
  <dt id="Required~7"><a class="permalink" href="#Required~7">Required
    Methods</a></dt>
  <dd></dd>
  <dt id="Required~8"><a class="permalink" href="#Required~8">Required
    Attributes</a></dt>
  <dd></dd>
  <dt id="Attributes~4"><a class="permalink" href="#Attributes~4">Attributes</a></dt>
  <dd>Attributes with the same name will conflict and are considered a
      unrecoverable error. No other aspect of the attribute is examined, it is
      enough that just the attribute names conflict.
    <p class="Pp">The reason for such early and harsh conflicts with attributes
        is because there is so much room for variance between two attributes
        that the problem quickly explodes and rules get very complex. It is my
        opinion that this complexity is not worth the trouble.</p>
  </dd>
  <dt id="Methods~4"><a class="permalink" href="#Methods~4">Methods</a></dt>
  <dd>Methods with the same name will conflict, but no error is thrown, instead
      the method name is added to the list of <i>required</i> methods for the
      new composite role.
    <p class="Pp">To look at this in terms of set theory, each role can be said
        to have a set of methods. The symmetric difference of these two sets is
        the new set of methods for the composite role, while the intersection of
        these two sets are the conflicts. This can be illustrated like so:</p>
    <p class="Pp"></p>
    <pre>   Role A has method set { a, b, c }
   Role B has method set { c, d, e }
   The composite role (A,B) has
       method   set { a, b, d, e }
       conflict set { c }
    </pre>
  </dd>
  <dt id="Overridden~4"><a class="permalink" href="#Overridden~4">Overridden
    methods</a></dt>
  <dd>An overridden method can conflict in one of two ways.
    <p class="Pp">The first way is with another overridden method of the same
        name, and this is considered an unrecoverable error. This is an obvious
        error since you cannot override a method twice in the same class.</p>
    <p class="Pp">The second way for conflict is for an overridden method and a
        regular method to have the same name. This is also an unrecoverable
        error since there is no way to combine these two, nor is it okay for
        both items to be composed into a single class at some point.</p>
    <p class="Pp">The use of override in roles can be tricky, but if used
        carefully they can be a very powerful tool.</p>
  </dd>
  <dt id="Method~4"><a class="permalink" href="#Method~4">Method Modifiers
    (before, around, after)</a></dt>
  <dd>Method modifiers are the only place where the ordering of role composition
      matters. This is due to the nature of method modifiers themselves.
    <p class="Pp">Since a method can have multiple method modifiers, these are
        just collected in order to be later applied to the class in that same
        order.</p>
    <p class="Pp">In general, great care should be taken in using method
        modifiers in roles. The order sensitivity can possibly lead to subtle
        and difficult to find bugs if they are overused. As with all good things
        in life, moderation is the key.</p>
  </dd>
</dl>
<p class="Pp"><i>Composition Edge Cases</i></p>
<p class="Pp">This is a just a set of complex edge cases which can easily get
    confused. This attempts to clarify those cases and provide an explanation of
    what is going on in them.</p>
<dl class="Bl-tag">
  <dt id="Role"><a class="permalink" href="#Role">Role Method
    Overriding</a></dt>
  <dd>Many people want to &quot;override&quot; methods in roles they are
      consuming. This works fine for classes, since the local class method is
      favored over the role method. However in roles it is trickier, this is
      because conflicts result in neither method being chosen and the method
      being &quot;required&quot; instead.
    <p class="Pp">Here is an example of this (incorrect) type of overriding.</p>
    <p class="Pp"></p>
    <pre>    package Role::Foo;
    use Moose::Role;
    sub foo { ... }
    package Role::FooBar;
    use Moose::Role;
    with 'Role::Foo';
    sub foo { ... }
    sub bar { ... }
    </pre>
    <p class="Pp">Here the <span class="Li">&quot;foo&quot;</span> methods
        conflict and the Role::FooBar now requires a class or role consuming it
        to implement <span class="Li">&quot;foo&quot;</span>. This is very often
        not what the user wants.</p>
    <p class="Pp">Now here is an example of the (correct) type of overriding,
        only it is not overriding at all, as is explained in the text below.</p>
    <p class="Pp"></p>
    <pre>    package Role::Foo;
    use Moose::Role;
    sub foo { ... }
    package Role::Bar;
    use Moose::Role;
    sub foo { ... }
    sub bar { ... }
    package Role::FooBar;
    use Moose::Role;
    with 'Role::Foo', 'Role::Bar';
    sub foo { ... }
    </pre>
    <p class="Pp">This works because the combination of Role::Foo and Role::Bar
        produce a conflict with the <span class="Li">&quot;foo&quot;</span>
        method. This conflict results in the composite role (that was created by
        the combination of Role::Foo and Role::Bar using the <i>with</i>
        keyword) having a method requirement of
        <span class="Li">&quot;foo&quot;</span>. The Role::FooBar then fulfills
        this requirement.</p>
    <p class="Pp">It is important to note that Role::FooBar is simply fulfilling
        the required <span class="Li">&quot;foo&quot;</span> method, and **NOT**
        overriding <span class="Li">&quot;foo&quot;</span>. This is an important
        distinction to make.</p>
    <p class="Pp">Now here is another example of a (correct) type of overriding,
        this time using the <i>excludes</i> option.</p>
    <p class="Pp"></p>
    <pre>    package Role::Foo;
    use Moose::Role;
    sub foo { ... }
    package Role::FooBar;
    use Moose::Role;
    with 'Role::Foo' =&gt; { -excludes =&gt; 'foo' };
    sub foo { ... }
    sub bar { ... }
    </pre>
    <p class="Pp">By specifically excluding the
        <span class="Li">&quot;foo&quot;</span> method during composition, we
        allow <b>Role::FooBar</b> to define its own version of
        <span class="Li">&quot;foo&quot;</span>.</p>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<dl class="Bl-tag">
  <dt id="Traits"><a class="permalink" href="#Traits">Traits</a></dt>
  <dd>Roles are based on Traits, which originated in the Smalltalk
    community.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>&lt;http://www.iam.unibe.ch/~scg/Research/Traits/&gt;</dt>
  <dd>This is the main site for the original Traits papers.</dd>
  <dt id="Class::Trait"><a class="permalink" href="#Class::Trait">Class::Trait</a></dt>
  <dd>I created this implementation of traits several years ago, after reading
      the papers linked above. (This module is now maintained by Ovid and I am
      no longer involved with it).</dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="Roles"><a class="permalink" href="#Roles">Roles</a></dt>
  <dd>Since they are relatively new, and the Moose implementation is probably
      the most mature out there, roles don't have much to link to. However, here
      is some bits worth looking at (mostly related to Perl 6)</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>&lt;http://www.oreillynet.com/onlamp/blog/2006/08/roles_composable_units_of_obje.html&gt;</dt>
  <dd>This is chromatic's take on roles, which is worth reading since he was/is
      one of the big proponents of them.</dd>
  <dt>&lt;http://svn.perl.org/perl6/doc/trunk/design/syn/S12.pod&gt;</dt>
  <dd>This is Synopsis 12, which is all about the Perl 6 Object System. Which,
      of course, includes roles.</dd>
</dl>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Stevan Little &lt;stevan.little@iinteractive.com&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
  <li>Shawn M Moore &lt;code@sartak.org&gt;</li>
  <li>&#x05D9;&#x05D5;&#x05D1;&#x05DC; &#x05E7;&#x05D5;&#x05D2;'&#x05DE;&#x05DF;
      (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Florian Ragwitz &lt;rafl@debian.org&gt;</li>
  <li>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</li>
  <li>Chris Prather &lt;chris@prather.org&gt;</li>
  <li>Matt S Trout &lt;mst@shadowcat.co.uk&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2006 by Infinity Interactive,
  Inc.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-11-22</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Parse::Eyapp::Driver(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Parse::Eyapp::Driver(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Parse::Eyapp::Driver(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Parse::Eyapp::Driver - The LR parser</p>
</section>
<section class="Sh">
<h1 class="Sh" id="INTRODUCTION"><a class="permalink" href="#INTRODUCTION">INTRODUCTION</a></h1>
<p class="Pp">This class has the method
    <span class="Li">&quot;YYParse&quot;</span> implementing the LR generic
    parsing algorithm plus the methods that give support to the generated
    parser.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="THE__YYParse__METHOD"><a class="permalink" href="#THE__YYParse__METHOD">THE
  &quot;YYParse&quot; METHOD</a></h1>
<p class="Pp">The <span class="Li">&quot;YYParse&quot;</span> methods implements
    the generic LR parsing algorithm. It very much works
    <span class="Li">&quot;Parse::Yapp::YYParse&quot;</span> and as yacc/bison
    <span class="Li">&quot;yyparse&quot;</span>. It accepts almost the same
    arguments as <span class="Li">&quot;Class-&gt;new&quot;</span> (Being
    <span class="Li">&quot;Class&quot;</span> the name of the generated
  class).</p>
<p class="Pp">The parser uses two tables and a stack. The two tables are called
    the <i>action</i> table and the <i>goto</i> table. The stack is used to keep
    track of the states visited.</p>
<p class="Pp">At each step the generated parser consults the
    <span class="Li">&quot;action&quot;</span> table and takes one decision: To
    shift to a new state consuming one token (and pushing the current state in
    the stack) or to reduce by some production rule. In the last case the parser
    pops from its stack as many states as symbols are on the right hand side of
    the production rule. Here is a Perl/C like pseudocode summarizing the
    activity of <span class="Li">&quot;YYParse&quot;</span>:</p>
<p class="Pp"></p>
<pre>
     1   my $parser = shift; # The parser object
     2   push(@stack, $parser-&gt;{startstate});
     3   $b = $parser-&gt;YYLexer(); # Get the first token
     4   FOREVER: {
     5     $s = top(0);  # Get the state on top of the stack
     6     $a = $b;
     7     switch ($parser-&gt;action[$s-&gt;state][$a]) {
     8       case &quot;shift t&quot; : 
     9         my $t;
    10         $t-&gt;{state} = t;
    11         $t-&gt;{attr}  = $a-&gt;{attr};
    12         push($t); 
    13         $b = $parser-&gt;YYLexer(); # Call the lexical analyzer
    14         break;
    15       case &quot;reduce A-&gt;alpha&quot; : 
    16         # Call the semantic action with the attributes of the rhs as args
    17         my $semantic  = $parser-&gt;Semantic{A -&gt;alpha}; # The semantic action
    18         my $r;
    19         $r-&gt;{attr} = $semantic-&gt;($parser, top(|alpha|-1)-&gt;attr, ... , top(0)-&gt;attr); 
    20  
    21         # Pop as many states as symbols on the rhs of A-&gt;alpha
    22         pop(|alpha|);  
    23  
    24         # Goto next state 
    25         $r-&gt;{state} = $parser-&gt;goto[top(0)][A]; 
    26         push($r); 
    27         break;
    28       case &quot;accept&quot; : return (1); 
    29       default : $parser-&gt;YYError(&quot;syntax error&quot;); 
    30     }
    31     redo FOREVER;
    32   }
</pre>
<p class="Pp">Here <span class="Li">&quot;|alpha|&quot;</span> stands for the
    length of <span class="Li">&quot;alpha&quot;</span>. Function
    <span class="Li">top(k)</span> returns the state in position
    <span class="Li">&quot;k&quot;</span> from the top of the stack, i.e. the
    state at depth <span class="Li">&quot;k&quot;</span>. Function
    <span class="Li">pop(k)</span> extracts
    <span class="Li">&quot;k&quot;</span> states from the stack. The call
    <span class="Li">&quot;$state-&gt;attr&quot;</span> returns the attribute
    associated with <span class="Li">$state</span>. The call
    <span class="Li">&quot;$parser-&gt;Semantic{A -&gt;alpha}&quot;</span>
    returns the semantic action associated with production
    <span class="Li">&quot;A -&gt;alpha&quot;</span>.</p>
<p class="Pp">Let us see a trace for the small grammar in
    <span class="Li">&quot;examples/debuggingtut/aSb.yp&quot;</span>:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ /usr/local/bin/paste.pl aSb.yp aSb.output | head -5
  %%                                             | Rules:
  S:                 { print &quot;S -&gt; epsilon\n&quot; }  | ------
      |   'a' S 'b'  { print &quot;S -&gt; a S b\n&quot; }    | 0:    $start -&gt; S $end
  ;                                              | 1:    S -&gt; /* empty */
  %%                                             | 2:    S -&gt; 'a' S 'b'
</pre>
<p class="Pp">The tables in file <span class="Li">&quot;aSb.output&quot;</span>
    describe the actions and transitions to take:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ cat -n aSb.output
     .  .........................................
     7  States:
     8  -------
     9  State 0:
    10
    11          $start -&gt; . S $end      (Rule 0)
    12
    13          'a'     shift, and go to state 2
    14
    15          $default        reduce using rule 1 (S)
    16
    17          S       go to state 1
    18
    19  State 1:
    20
    21          $start -&gt; S . $end      (Rule 0)
    22
    23          $end    shift, and go to state 3
    24
    25  State 2:
    26
    27          S -&gt; 'a' . S 'b'        (Rule 2)
    28
    29          'a'     shift, and go to state 2
    30
    31          $default        reduce using rule 1 (S)
    32
    33          S       go to state 4
    34
    35  State 3:
    36
    37          $start -&gt; S $end .      (Rule 0)
    38
    39          $default        accept
    40
    41  State 4:
    42
    43          S -&gt; 'a' S . 'b'        (Rule 2)
    44
    45          'b'     shift, and go to state 5
    46
    47  State 5:
    48
    49          S -&gt; 'a' S 'b' .        (Rule 2)
    50
    51          $default        reduce using rule 2 (S)
    52
    53
    54  Summary:
    55  --------
    56  Number of rules         : 3
    57  Number of terminals     : 3
    58  Number of non-terminals : 2
    59  Number of states        : 6
</pre>
<p class="Pp">When executed with <span class="Li">&quot;yydebug&quot;</span> set
    and input <span class="Li">&quot;aabb&quot;</span> we obtain the following
    output:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples/debuggingtut$ eyapp -b '' -o use_aSb.pl aSb
  pl@nereida:~/LEyapp/examples/debuggingtut$ ./use_aSb.pl -d
  Provide a statement like &quot;a a b b&quot; and press &lt;CR&gt;&lt;CTRL-D&gt;: aabb
  ----------------------------------------                       
  In state 0:                                                    
  Stack:[0]                                                      
  Need token. Got &gt;a&lt;                                            
  Shift and go to state 2.                                       
  ----------------------------------------                       
  In state 2:                                                    
  Stack:[0,2]                                                    
  Need token. Got &gt;a&lt;
  Shift and go to state 2.
  ----------------------------------------
  In state 2:
  Stack:[0,2,2]
  Need token. Got &gt;b&lt;
  Reduce using rule 1 (S --&gt; /* empty */): S -&gt; epsilon
  Back to state 2, then go to state 4.
  ----------------------------------------
  In state 4:
  Stack:[0,2,2,4]
  Shift and go to state 5.
  ----------------------------------------
  In state 5:
  Stack:[0,2,2,4,5]
  Don't need token.
  Reduce using rule 2 (S --&gt; a S b): S -&gt; a S b
  Back to state 2, then go to state 4.
  ----------------------------------------
</pre>
<p class="Pp">As a result of reducing by rule 2 the three last visited states
    are popped from the stack, and the stack becomes
    <span class="Li">&quot;[0,2]&quot;</span>. But that means that we are now in
    state 2 seeing a <span class="Li">&quot;S&quot;</span>. If you look at the
    table above being in state 2 and seeing a
    <span class="Li">&quot;S&quot;</span> we go to state 4.</p>
<p class="Pp"></p>
<pre>
  In state 4:
  Stack:[0,2,4]
  Need token. Got &gt;b&lt;
  Shift and go to state 5.
  ----------------------------------------
  In state 5:
  Stack:[0,2,4,5]
  Don't need token.
  Reduce using rule 2 (S --&gt; a S b): S -&gt; a S b
  Back to state 0, then go to state 1.
  ----------------------------------------
  In state 1:
  Stack:[0,1]
  Need token. Got &gt;&lt;
  Shift and go to state 3.
  ----------------------------------------
  In state 3:
  Stack:[0,1,3]
  Don't need token.
  Accept.
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS_IN_THE_GENERATED_CLASS:__Parse::Eyapp::Driver__METHODS"><a class="permalink" href="#METHODS_IN_THE_GENERATED_CLASS:__Parse::Eyapp::Driver__METHODS">METHODS
  IN THE GENERATED CLASS: &quot;Parse::Eyapp::Driver&quot; METHODS</a></h1>
<p class="Pp">The class containing the parser generated by
    <span class="Li">&quot;Parse::Eyapp&quot;</span> inherits from
    <span class="Li">&quot;Parse::Eyapp::Driver&quot;</span>. Therefore all the
    methods in <span class="Li">&quot;Parse::Eyapp::Driver&quot;</span> are
    available in the generated class.</p>
<p class="Pp">This section describes the methods and objects belonging to the
    class generated either using eyapp or
    <span class="Li">&quot;Parse::Eyapp-&gt;new_grammar&quot;</span>. In the
    incoming paragraphs we will assume that
    <span class="Li">&quot;Class&quot;</span> was the value selected for the
    <span class="Li">&quot;classname&quot;</span> argument when
    <span class="Li">&quot;Parse::Eyapp-&gt;new_grammar&quot;</span> was called.
    Objects belonging to <span class="Li">&quot;Class&quot;</span> are the
    actual parsers for the input grammar.</p>
<section class="Ss">
<h2 class="Ss" id="Class"><a class="permalink" href="#Class">Class-&gt;new</a></h2>
<p class="Pp">The method <span class="Li">&quot;Class-&gt;new&quot;</span>
    returns a new LALR parser object. Here
    <span class="Li">&quot;Class&quot;</span> stands for the name of the class
    containing the parser. See an example of call:</p>
<p class="Pp"></p>
<pre>
  my $parser = main-&gt;new(yyprefix =&gt; 'Parse::Eyapp::Node::',
                         yylex    =&gt; \&amp;main::_Lexer,
                         yyerror  =&gt; \&amp;main::_Error,
                         yydebug =&gt; 0x1F,
  );
</pre>
<p class="Pp">The meaning of the arguments used in the example are as
  follows:</p>
<dl class="Bl-tag">
  <dt id="yyprefix"><a class="permalink" href="#yyprefix">- yyprefix</a></dt>
  <dd>Used with <span class="Li">%tree</span> or
      <span class="Li">%metatree</span>. When used, the type names of the nodes
      of the syntax tree will be build prefixing the value associated to
      <span class="Li">&quot;yyprefix&quot;</span> to the name of the production
      rule. The name of the production rule is either explicitly given through a
      <span class="Li">%name</span> directive or the concatenation of the left
      hand side of the rule with the ordinal of the right hand side of the
      production. See section &quot;Compiling with eyapp and treereg&quot; in
      Parse::Eyapp for an example.</dd>
  <dt id="yylex"><a class="permalink" href="#yylex">- yylex</a></dt>
  <dd>Reference to the lexical analyzer subroutine</dd>
  <dt id="yyerror"><a class="permalink" href="#yyerror">- yyerror</a></dt>
  <dd>Reference to the error subroutine. The error subroutine receives as first
      argument the reference to the <span class="Li">&quot;Class&quot;</span>
      parser object. This way it can take advantage of methods like
      <span class="Li">&quot;YYCurval&quot;</span> and YYExpect (see below):
    <p class="Pp"></p>
    <pre>
  sub _Error {
    my($token)=$_[0]-&gt;YYCurval;
    my($what)= $token ? &quot;input: '$token'&quot; : &quot;end of input&quot;;
    my @expected = $_[0]-&gt;YYExpect();

    local $&quot; = ', ';
    die &quot;Syntax error near $what. Expected one of these tokens: @expected\n&quot;;
  }
    </pre>
  </dd>
  <dt id="yydebug"><a class="permalink" href="#yydebug">- yydebug</a></dt>
  <dd>Controls the level of debugging. Must be a number.</dd>
</dl>
<p class="Pp">The package produced from the grammar has several methods.</p>
<p class="Pp">The parser object has the following methods that work at parsing
    time exactly as in Parse::Yapp. These methods can be found in the module
    Parse::Eyapp::Driver. Assume you have in <span class="Li">$parser</span> the
    reference to your parser object:</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser"><a class="permalink" href="#$parser">$parser-&gt;YYAction</a></h2>
<p class="Pp">Receives the name of a production and a subroutine reference
    implementing the new semantic action. If no subroutine reference is set
    returns the reference to the current semantic action. See the tutorial
    Parse::Eyapp::defaultaction and the examples in the
    <span class="Li">&quot;examples/recycle/&quot;</span> directory</p>
</section>
<section class="Ss">
<h2 class="Ss"> $parser-&gt;YYAccept</h2>
<p class="Pp">Works as yacc/bison <span class="Li">&quot;YYACCEPT&quot;</span>.
    The parser finishes returning the current semantic value to indicate
    success.</p>
</section>
<section class="Ss">
<h2 class="Ss"> $parser-&gt;YYAbort</h2>
<p class="Pp">Works as yacc/bison <span class="Li">&quot;YYABORT&quot;</span>.
    The parser finishes returning <span class="Li">&quot;undef&quot;</span> to
    indicate failure.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Parse::Eyapp::Driver::BeANode"><a class="permalink" href="#Parse::Eyapp::Driver::BeANode">Parse::Eyapp::Driver::BeANode</a></h2>
<p class="Pp">Is not a method. Receives as input a
    <span class="Li">&quot;Class&quot;</span> name. Introduces
    <span class="Li">&quot;Parse::Eyapp::Node&quot;</span> as an ancestor class
    of <span class="Li">&quot;Class&quot;</span>. To work correctly, objects
    belonging to <span class="Li">&quot;Class&quot;</span> must be hashes with a
    <span class="Li">&quot;children&quot;</span> key whose value must be a
    reference to the array of children. The children must be also
    <span class="Li">&quot;Parse::Eyapp::Node&quot;</span> nodes. Actually you
    can circumvent this call by directly introducing
    <span class="Li">&quot;Parse::Eyapp::Node&quot;</span> in the ancestors of
    <span class="Li">&quot;Class&quot;</span>:</p>
<p class="Pp"></p>
<pre>
         push @{$class.&quot;::ISA&quot;}, &quot;Parse::Eyapp::Node&quot;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser~2"><a class="permalink" href="#$parser~2">$parser-&gt;YYBuildAST</a></h2>
<p class="Pp">Sometimes the best time to decorate a node with some attributes is
    just after being built. In such cases the programmer can take manual control
    building the node with <span class="Li">&quot;YYBuildAST&quot;</span> to
    immediately proceed to decorate it.</p>
<p class="Pp">The following example from the file
    <span class="Li">&quot;lib/Simple/Types.eyp&quot;</span> in the tarball in
    <span class="Li">&quot;examples/typechecking/Simple-Types-XXX.tar.gz&quot;</span>
    illustrates the idea:</p>
<p class="Pp"></p>
<pre>
 Variable:
     %name  VARARRAY
     $ID ('[' binary ']') &lt;%name INDEXSPEC +&gt;
       {
         my $self = shift;
         my $node =  $self-&gt;YYBuildAST(@_);
         $node-&gt;{line} = $ID-&gt;[1];
         return $node;
       }
</pre>
<p class="Pp">Actually, the <span class="Li">%tree</span> directive is
    semantically equivalent to:</p>
<p class="Pp"></p>
<pre>
  %default action { goto &amp;Parse::Eyapp::Driver::YYBuildAST }
</pre>
</section>
<section class="Ss">
<h2 class="Ss"> $parser-&gt;YYBuildingTree</h2>
<p class="Pp">Influences the semantic of list operators. If true the action
    associated with <span class="Li">&quot;X+&quot;</span> will be to build a
    <span class="Li">&quot;Parse::Eyapp::Node&quot;</span> node with all the
    attributes of the elements in the list as children. This is the appropriate
    semantic when working under the <span class="Li">%tree</span> directive. If
    set to false the semantic action will return an anonymous list with the
    attributes associated with the <span class="Li">&quot;X&quot;</span> in the
    plus list. Same thing with the operators
    <span class="Li">&quot;*&quot;</span> and
    <span class="Li">&quot;?&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser~3"><a class="permalink" href="#$parser~3">$parser-&gt;YYBuildTS</a></h2>
<p class="Pp">Similar to
    <span class="Li">&quot;$parser-&gt;YYBuildAST&quot;</span> but builds nodes
    for translation schemes.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser~4"><a class="permalink" href="#$parser~4">$parser-&gt;YYBypass</a></h2>
<p class="Pp">Returns TRUE if running under the <span class="Li">&quot;%tree
    bypass&quot;</span> clause</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser~5"><a class="permalink" href="#$parser~5">$parser-&gt;YYBypassrule</a></h2>
<p class="Pp">Returns TRUE if the production being used for reduction was marked
    to be bypassed.</p>
</section>
<section class="Ss">
<h2 class="Ss"> $parser-&gt;YYCurtok</h2>
<p class="Pp">Gives the current token</p>
</section>
<section class="Ss">
<h2 class="Ss"> $parser-&gt;YYCurval</h2>
<p class="Pp">Gives the attribute associated with the current token</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser~6"><a class="permalink" href="#$parser~6">$parser-&gt;YYDelegateaction</a></h2>
<p class="Pp">Use it as <span class="Li">&quot;defaultaction&quot;</span> if you
    want to recycle your grammar. It is equivalent to:</p>
<p class="Pp"></p>
<pre>
  sub YYDelegateaction {
    my $self = shift;

    my $action = $self-&gt;YYName;

    $self-&gt;$action(@_);
  }
</pre>
<p class="Pp">For a full example illustrating how to use it, see files
    <span class="Li">&quot;examples/recycle/NoacInh.eyp&quot;</span> and
    <span class="Li">&quot;examples/recycle/icalcu_and_ipost.pl&quot;</span> in
    the Parse::Eyapp distribution</p>
</section>
<section class="Ss">
<h2 class="Ss"> $parser-&gt;YYEndOfInput</h2>
<p class="Pp">True if the <span class="Li">&quot;pos()&quot;</span> of the input
    being scanned in <span class="Li">&quot;${$parser-&gt;input}&quot;</span> is
    at the end</p>
</section>
<section class="Ss">
<h2 class="Ss"> $parser-&gt;YYErrok</h2>
<p class="Pp">Works as yacc/bison <span class="Li">&quot;yyerrok&quot;</span>.
    Modifies the error status so that subsequent error messages will be
  emitted.</p>
</section>
<section class="Ss">
<h2 class="Ss"> $parser-&gt;YYError</h2>
<p class="Pp">Works as yacc/bison <span class="Li">&quot;YYERROR&quot;</span>.
    Pretends that a syntax error has been detected.</p>
</section>
<section class="Ss">
<h2 class="Ss"> $parser-&gt;YYExpect</h2>
<p class="Pp">Returns the list of tokens the parser expected when the failure
    occurred</p>
<p class="Pp"></p>
<pre>
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ \
                            sed -ne '26,33p' Postfix.eyp
 sub _Error {
   my($token)=$_[0]-&gt;YYCurval;
   my($what)= $token ? &quot;input: '$token'&quot; : &quot;end of input&quot;;
   my @expected = $_[0]-&gt;YYExpect();

   local $&quot; = ', ';
   die &quot;Syntax error near $what. Expected one of these tokens: @expected\n&quot;;
 }
</pre>
<p class="Pp">See the tutorial Parse::Eyapp::datagenerationtut and the section
    <i>TOKENS DEPENDING ON THE SYNTACTIC CONTEXT</i> in the tutorial
    Parse::Eyapp::debuggingtut for more detailed examples of use of
    <span class="Li">&quot;YYExpect&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser~7"><a class="permalink" href="#$parser~7">$parser-&gt;YYFirstline</a></h2>
<p class="Pp">First line of the input string describing the grammar</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser~8"><a class="permalink" href="#$parser~8">$parser-&gt;YYGrammar</a></h2>
<p class="Pp">Return the list of grammar items. Each item is an anonymous list
    containing</p>
<ul class="Bl-bullet">
  <li>The name of the production</li>
  <li>The LHS of the production</li>
  <li>An anonymous list containing the symbols in the RHS</li>
</ul>
<p class="Pp">If it receives an index as argument returns the corresponding item
    The following debugger session explain its use:</p>
<p class="Pp"></p>
<pre>
  pl@europa:~/LEyapp/examples/recycle$ perl -wd usepostfix.pl
  main::(usepostfix.pl:5):        my $parser = new Postfix();
    DB&lt;1&gt; n
  main::(usepostfix.pl:6):        $parser-&gt;Run;
    DB&lt;1&gt; x $parser-&gt;YYGrammar
  0  ARRAY(0xde5e20)
     0  '_SUPERSTART'
     1  '$start'
     2  ARRAY(0xc85e80)
        0  'line'
        1  '$end'
     3  0
  1  ARRAY(0xe2b6b0)
     0  'line_1'
     1  'line'
     2  ARRAY(0xe3abc0)
        0  'exp'
     3  0
  2  ARRAY(0xa05530)
     0  'exp_2'
     1  'exp'
     2  ARRAY(0x75bdc0)
        0  'NUM'
     3  0

     ...  etc, etc
</pre>
<p class="Pp">If an index is provided it returns the item for such number:</p>
<p class="Pp"></p>
<pre>
    DB&lt;2&gt; x $parser-&gt;YYGrammar(10)
  0  'exp_10'
  1  'exp'
  2  ARRAY(0xa05f80)
     0  '('
     1  'exp'
     2  ')'
  3  0
</pre>
<p class="Pp">You can also use a production name as argument:</p>
<p class="Pp"></p>
<pre>
    DB&lt;3&gt; x $parser-&gt;YYGrammar('exp_7')
  0  'exp_7'
  1  'exp'
  2  ARRAY(0xa05890)
     0  'exp'
     1  '*'
     2  'exp'
  3  0
</pre>
</section>
<section class="Ss">
<h2 class="Ss">$parser-&gt;YYGetLRAction($state, $token)</h2>
<p class="Pp">Returns the shift-reduce action for state
    <span class="Li">$state</span> and token <span class="Li">$token</span>. A
    positive number must be interpreted as a shift to the state with that
    number. A negative number <span class="Li">&quot;-m&quot;</span> indicates a
    reduction by production with index <span class="Li">&quot;m&quot;</span>.
    Returns <span class="Li">&quot;undef&quot;</span> if no action is defined
    for such combination <span class="Li">&quot;($state,
  $token)&quot;</span>.</p>
<p class="Pp">See example
    <span class="Li">&quot;DynamicallyChangingTheParser.eyp&quot;</span> in the
    directory <span class="Li">&quot;examples/debuggintut&quot;</span> for an
    example of use.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser~9"><a class="permalink" href="#$parser~9">$parser-&gt;YYIssemantic</a></h2>
<p class="Pp">Returns TRUE if the terminal is <i>semantic</i>. <i>Semantics
    token</i> can be declared using the directive
    <span class="Li">&quot;%semantic token&quot;</span>. The opposite of a
    <i>Semantic token</i> is a <i>Syntactic token</i>. <i>Syntactic tokens</i>
    can be declared using the directive <span class="Li">&quot;%syntactic
    token&quot;</span>.</p>
<p class="Pp">When using the <span class="Li">%tree</span> directive all the
    nodes corresponding to syntactic tokens are pruned from the tree. Under this
    directive tokens in the text delimited by simple quotes (like
    <span class="Li">'+'</span>) are, by default, considered syntactic
  tokens.</p>
<p class="Pp">When using the <span class="Li">%metatree</span> directive all the
    tokens are considered, by default, <i>semantic tokens</i>. Thus, no nodes
    will be - by default- pruned when construction the code augmented tree. The
    exception are string tokens used as separators in the definition of lists,
    like in <span class="Li">&quot;S &lt;* ';'&gt;&quot;</span>. If you want the
    separating string token to appear include an explicit semantic declaration
    for it (example <span class="Li">&quot;%semantic token
  ';'&quot;</span>).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser~10"><a class="permalink" href="#$parser~10">$parser-&gt;YYIndex</a></h2>
<p class="Pp">Receives the name of production (right hand side). Returns the
    index in the grammar of the production with such name. When called in a list
    context and without a name return the hash containing the relation</p>
<p class="Pp"></p>
<pre>
           production name =&gt; production index
</pre>
<p class="Pp">The following debugger session illustrates its use:</p>
<p class="Pp"></p>
<pre>
  pl@europa:~/LEyapp/examples/recycle$ perl -wd usepostfix.pl
  main::(usepostfix.pl:5):        my $parser = new Postfix();
  main::(usepostfix.pl:6):        $parser-&gt;Run;
  DB&lt;1&gt; x $parser-&gt;YYIndex
  0  'line_1'
  1  1
  2  'exp_3'
  3  3
  4  'exp_6'
  5  6
  6  'exp_4'
  7  4
  8  'exp_10'
  9  10
  10  'exp_8'
  11  8
  12  'exp_5'
  13  5
  14  'exp_7'
  15  7
  16  'exp_2'
  17  2
  18  '_SUPERSTART'
  19  0
  20  'exp_9'
  21  9
</pre>
<p class="Pp">We can specify a list of names:</p>
<p class="Pp"></p>
<pre>
  DB&lt;2&gt; x $parser-&gt;YYIndex(qw{exp_4 exp_7})
  0  4
  1  7
  DB&lt;3&gt; x $parser-&gt;YYIndex(qw{exp_4})
  0  4
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser~11"><a class="permalink" href="#$parser~11">$parser-&gt;YYInput</a></h2>
<p class="Pp">Alias <span class="Li">&quot;input&quot;</span>. If an argument is
    provided, sets the input for the parser object. The argument is a string or
    a reference to a string. It returns a reference to the input string or
    <span class="Li">&quot;undef&quot;</span> if not set.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser~12"><a class="permalink" href="#$parser~12">$parser-&gt;YYIsterm</a></h2>
<p class="Pp">Returns TRUE if the symbol given as argument is a terminal.
    Example:</p>
<p class="Pp"></p>
<pre>
  DB&lt;0&gt; x $self-&gt;YYIsterm('exp')
 0  ''
  DB&lt;1&gt; x $self-&gt;YYIsterm('*')
 0  1
</pre>
<p class="Pp">An example of combined use of
    <span class="Li">&quot;YYRightside&quot;</span>,
    <span class="Li">&quot;YYRuleindex&quot;</span>,
    <span class="Li">&quot;YYLhs&quot;</span> and
    <span class="Li">&quot;YYIsterm&quot;</span> can be found
    <span class="Li">&quot;examples/Eyapp/Rule3.yp&quot;</span>:</p>
<p class="Pp"></p>
<pre>
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; sed -n -e '4,22p' Rule3.yp | cat -n
  1  sub build_node {
  2    my $self = shift;
  3    my @children = @_;
  4    my @right = $self-&gt;YYRightside();
  5    my $var = $self-&gt;YYLhs;
  6    my $rule = $self-&gt;YYRuleindex();
  7
  8    for(my $i = 0; $i &lt; @right; $i++) {
  9      $_ = $right[$i];
 10      if ($self-&gt;YYIsterm($_)) {
 11        $children[$i] = bless { token =&gt; $_, attr =&gt; $children[$i] },
 12                                            __PACKAGE__.'::TERMINAL';
 13      }
 14    }
 15    bless {
 16            children =&gt; \@children,
 17            info =&gt; &quot;$var -&gt; @right&quot;
 18          }, __PACKAGE__.&quot;::${var}_$rule&quot;
 19  }
</pre>
<p class="Pp">when executed an output similar to this is produced:</p>
<p class="Pp"></p>
<pre>
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; userule3.pl
 2*3
 $VAR1 = bless( {
   'info' =&gt; 'exp -&gt; exp * exp',
   'children' =&gt; [
     bless( {
       'info' =&gt; 'exp -&gt; NUM',
       'children' =&gt; [ bless( { 'attr' =&gt; '2', 'token' =&gt; 'NUM' }, 'Rule3::TERMINAL' ) ]
     }, 'Rule3::exp_6' ),
     bless( { 'attr' =&gt; '*', 'token' =&gt; '*' }, 'Rule3::TERMINAL' ),
     bless( {
       'info' =&gt; 'exp -&gt; NUM',
       'children' =&gt; [ bless( { 'attr' =&gt; '3', 'token' =&gt; 'NUM' }, 'Rule3::TERMINAL' )
       ]
     }, 'Rule3::exp_6' )
   ]
 }, 'Rule3::exp_11' );
</pre>
</section>
<section class="Ss">
<h2 class="Ss"> $parser-&gt;YYLexer</h2>
<p class="Pp">Returns a reference to the lexical analyzer</p>
</section>
<section class="Ss">
<h2 class="Ss"> $parser-&gt;YYLhs</h2>
<p class="Pp">Returns the identifier of the left hand side of the current
    production (the one that is being used for reduction/reverse derivation. An
    example of use can be found in
    <span class="Li">&quot;examples/Eyapp/Lhs1.yp&quot;</span>:</p>
<p class="Pp"></p>
<pre>
  %defaultaction { print $_[0]-&gt;YYLhs,&quot;\n&quot; }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser~13"><a class="permalink" href="#$parser~13">$parser-&gt;YYMain</a></h2>
<p class="Pp">Alias is also <span class="Li">&quot;main&quot;</span>.</p>
<p class="Pp">Other than the package, it has as optional arguments the
    <span class="Li">&quot;prompt&quot;</span> (shown each time it ask for
    input), the name of the input file (if it wasn't specified in the command
    line using <span class="Li">&quot;--file filename&quot;</span>) and also the
    input string.</p>
<p class="Pp">This method provides a default
    <span class="Li">&quot;main&quot;</span> for testing the generated parser.
    It parses the commandline searching for a number of options. See an example
    of use:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples/eyapplanguageref$ cat use_list2.pl
  #!/usr/bin/env perl
  use warnings;
  use strict;
  use List2;

  unshift @ARGV, '--noslurp';
  List2-&gt;new-&gt;main(&quot;Try input 'aacbb': &quot;);
  pl@nereida:~/LEyapp/examples/eyapplanguageref$ ./use_list2.pl --help
  Available options:
      --debug                    sets yydebug on
      --nodebug                  sets yydebug off
      --file filepath            read input from filepath
      --commandinput string      read input from string
      --tree                     prints $tree-&gt;str
      --notree                   does not print $tree-&gt;str
      --info                     When printing $tree-&gt;str shows the value of TERMINALs
      --help                     shows this help
      --slurp                    read until EOF reached
      --noslurp                  read until CR is reached
      --argfile                  main() will take the input string from its @_
      --noargfile                main() will not take the input string from its @_
      --yaml                     dumps YAML for $tree: YAML module must be installed
      --margin=i                 controls the indentation of $tree-&gt;str (i.e. $Parse::Eyapp::Node::INDENT)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser~14"><a class="permalink" href="#$parser~14">$parser-&gt;YYName</a></h2>
<p class="Pp">Returns the name of the current rule (The production whose
    reduction gave place to the execution of the current semantic action).</p>
<p class="Pp"></p>
<pre>
  DB&lt;12&gt; x $self-&gt;YYName
 0  'exp_11'
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser~15"><a class="permalink" href="#$parser~15">$parser-&gt;YYNames</a></h2>
<p class="Pp">Return the list of production names. In a scalar context returns a
    reference to such list.</p>
<p class="Pp"></p>
<pre>
  pl@europa:~/LEyapp/examples/recycle$ eyapp Postfix
  pl@europa:~/LEyapp/examples/recycle$ perl -wd usepostfix.pl
  main::(usepostfix.pl:5):        my $parser = new Postfix();
  main::(usepostfix.pl:6):        $parser-&gt;Run;
  DB&lt;1&gt; x $parser-&gt;YYNames
  0  '_SUPERSTART'
  1  'line_1'
  2  'exp_2'
  3  'exp_3'
  4  'exp_4'
  5  'exp_5'
  6  'exp_6'
  7  'exp_7'
  8  'exp_8'
  9  'exp_9'
  10  'exp_10'
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser~16"><a class="permalink" href="#$parser~16">$parser-&gt;YYNberr</a></h2>
<p class="Pp">The current number of errors</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser~17"><a class="permalink" href="#$parser~17">$parser-&gt;<i>YYNextState()</i>;</a></h2>
<p class="Pp">If called inside a semantic action, returns the state after the
    reduction by the current production.</p>
<p class="Pp">Provide a token if called from any other side:</p>
<p class="Pp"></p>
<pre>
  $parser-&gt;YYNextState($token);
</pre>
<p class="Pp">It will return the state given by the action table for the state
    in the top of the stack and the given token.</p>
<p class="Pp">For an example, see the program
    <span class="Li">&quot;DynamicallyChangingTheParser.eyp&quot;</span> in the
    directory <span class="Li">&quot;examples/debuggintut/&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser~18"><a class="permalink" href="#$parser~18">$parser-&gt;YYPrefix</a></h2>
<p class="Pp">Return and/or sets the
    <span class="Li">&quot;yyprefix&quot;</span> attribute. This a string that
    will be concatenated as a prefix to any
    <span class="Li">&quot;Parse::Eyapp::Node&quot;</span> nodes in the syntax
    tree.</p>
</section>
<section class="Ss">
<h2 class="Ss"> $parser-&gt;<i>YYParse()</i></h2>
<p class="Pp">It very much works
    <span class="Li">&quot;Parse::Yapp::YYParse&quot;</span> and as yacc/bison
    <span class="Li">&quot;yyparse&quot;</span>. It accepts almost the same
    arguments as <span class="Li">&quot;Class-&gt;new&quot;</span> with the
    exception of <span class="Li">&quot;yyprefix&quot;</span> which can be used
    only with <span class="Li">&quot;new&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss"> $parser-&gt;YYRecovering</h2>
<p class="Pp">Works as yacc/bison
    <span class="Li">&quot;YYRECOVERING&quot;</span>. Returns
    <span class="Li">&quot;TRUE&quot;</span> if the parser is recovering from a
    syntax error.</p>
</section>
<section class="Ss">
<h2 class="Ss">$parser-&gt;YYRestoreLRAction('conflictname', $token)</h2>
<p class="Pp">This method has been designed to solve shift-reduce and
    reduce-reduce conflicts at parsing-time using the <i>postponed conflict</i>
    strategy. It has to be called inside the semantic action associated with the
    postponed conflict rule. The LALR table is changed so that the action in the
    presence of the token <span class="Li">$token</span> is restored the one
    before the last call to</p>
<p class="Pp"></p>
<pre>
  $parser-&gt;YYSetReduce($token, $productionname )
</pre>
<p class="Pp">See the examples in
    <span class="Li">&quot;examples/debuggingtut/&quot;</span> in files
    <span class="Li">&quot;DynamicallyChangingTheParser2.eyp&quot;</span> and
    <span class="Li">&quot;Cplusplus.eyp&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser~19"><a class="permalink" href="#$parser~19">$parser-&gt;YYRHSLength($productionindex)</a></h2>
<p class="Pp">Also:</p>
<p class="Pp"></p>
<pre>
  $parser-&gt;YYRHSLength
</pre>
<p class="Pp">returns the length of the right hand side (the number of symbols)
    of <span class="Li">$productionindex</span>. The name of the production can
    be used instead of its index. If no index or name is provided and the method
    is called inside a semantic action, the length of the current production is
    returned.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser~20"><a class="permalink" href="#$parser~20">$parser-&gt;YYRightside</a></h2>
<p class="Pp">Also:</p>
<p class="Pp"></p>
<pre>
  $parser-&gt;YYRightside($index)
</pre>
<p class="Pp">Returns an array of strings describing the right hand side of the
    rule. The name of the production can be given instead of
    <span class="Li">$index</span>. If no <span class="Li">$index</span> is
    provided and the method is called inside a semantic action the right hand
    side of the current production is returned.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser~21"><a class="permalink" href="#$parser~21">$parser-&gt;YYRuleindex</a></h2>
<p class="Pp">To be called inside a semantic action. Returns the index of the
    current production rule, counting the super rule as rule 0.</p>
<p class="Pp">To know the numbers have a look at the
    <span class="Li">&quot;.output&quot;</span> file. To get a
    <span class="Li">&quot;.output&quot;</span> file use the option
    <span class="Li">&quot;-v&quot;</span> of
    <span class="Li">&quot;eyapp&quot;</span> or the
    <span class="Li">&quot;outputfile&quot;</span> parameter when using method
    <span class="Li">&quot;new_grammar&quot;</span> (see the documentation for
    eyapp).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser~22"><a class="permalink" href="#$parser~22">$parser-&gt;YYRule</a></h2>
<p class="Pp">Return the list of rules. The following debugger session
    illustrates its use:</p>
<p class="Pp"></p>
<pre>
  pl@europa:~/LEyapp/examples/recycle$ perl -wd usepostfix.pl
  main::(usepostfix.pl:5):        my $parser = new Postfix();
  main::(usepostfix.pl:6):        $parser-&gt;Run;
  0  ARRAY(0xa068e0)
     0  '$start'
     1  2
     2  undef
  1  ARRAY(0xa06940)
     0  'line'
     1  1
     2  CODE(0xc22360)
        -&gt; &amp;Postfix::__ANON__[Postfix.eyp:10] in Postfix.eyp:227-10
  ... etc, etc.
</pre>
<p class="Pp">Each item has three components: the LHS of the production, the
    number of symbols in the RHS and the CODE reference to the semantic
  action.</p>
<p class="Pp">If an index is specified as argument it returns the corresponding
    item:</p>
<p class="Pp"></p>
<pre>
     DB&lt;2&gt; x $parser-&gt;YYRule(7)
  0  'exp'
  1  3
  2  CODE(0xc1fce0)
     -&gt; &amp;Postfix::__ANON__[Postfix.eyp:7] in Postfix.eyp:276-7
</pre>
<p class="Pp">To know to what production an item is associated we can use the
    <span class="Li">&quot;YYGrammar&quot;</span> method:</p>
<p class="Pp"></p>
<pre>
     DB&lt;3&gt; x $parser-&gt;YYGrammar('exp_7')
  0  'exp_7'
  1  'exp'
  2  ARRAY(0xa05290)
     0  'exp'
     1  '*'
     2  'exp'
  3  0
</pre>
<p class="Pp">We can also use the name of the rule to get the item:</p>
<p class="Pp"></p>
<pre>
   DB&lt;4&gt; x $parser-&gt;YYRule('exp_7')
  0  'exp'
  1  3
  2  CODE(0xc1fce0)
     -&gt; &amp;Postfix::__ANON__[Postfix.eyp:7] in Postfix.eyp:276-7
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser~23"><a class="permalink" href="#$parser~23">$parser-&gt;YYSetaction</a></h2>
<p class="Pp">Receives a hash with keys the names of the production rules (right
    hand sides) and values the new semantic actions. Used to reuse a grammar
    without overwriting all the semantic actions. See section <i>Reusing
    Grammars by Dynamic Substitution of Semantic Actions</i> in
    Parse::Eyapp::defaultactionsintro.</p>
</section>
<section class="Ss">
<h2 class="Ss">$parser-&gt;YYSetLRAction($conflictstate, $token,
  $shiftreduceaction )</h2>
<p class="Pp">It also accepts the syntax:</p>
<p class="Pp"></p>
<pre>
  $parser-&gt;YYSetLRAction($conflictstate, [$token1, ... ], $shiftreduceaction )
</pre>
<p class="Pp">This method has been designed to solve shift-reduce and
    reduce-reduce conflicts at parsing-time (not at parser-generation time).</p>
<p class="Pp">The LR table is changed so that the action in state
    <span class="Li">$conflictstate</span> in the presence of the token
    <span class="Li">$token</span> will be given by
    <span class="Li">$shiftreduceaction</span>. The current shift-reduce action
    isn't saved.</p>
<p class="Pp">See an example in
    <span class="Li">&quot;Cplusplus2.eyp&quot;</span> in the directory
    <span class="Li">&quot;examples/debuggintut&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss">$parser-&gt;YYSetReduce($token, $productionname )</h2>
<p class="Pp">This method has been designed to solve shift-reduce and
    reduce-reduce conflicts at parsing-time using the <i>postponed conflict</i>
    strategy. See the corresponding section in Parse::Eyapp::debuggintut. It has
    to be called inside the semantic action associated with the postponed
    conflict rule <span class="Li">&quot;conflictname&quot;</span>. The LALR
    table is changed so that the action in the presence of the token
    <span class="Li">$token</span> will be to reduce by
    <span class="Li">$productionname</span>. The current shift-reduce action is
    saved to be restored using</p>
<p class="Pp"></p>
<pre>
  $parser-&gt;YYRestoreLRAction('conflictname', $token)
</pre>
<p class="Pp">See the examples in
    <span class="Li">&quot;examples/debuggingtut/&quot;</span> in files</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;DynamicallyChangingTheParser2.eyp&quot;</span></li>
  <li><span class="Li">&quot;confusingsolveddynamic.eyp&quot;</span></li>
  <li><span class="Li">&quot;DebugDynamicResolution.eyp&quot;</span></li>
  <li><span class="Li">&quot;DynamicallyChangingTheParser2.eyp&quot;</span></li>
  <li><span class="Li">&quot;DynamicallyChangingTheParser3.eyp&quot;</span></li>
  <li><span class="Li">&quot;DynamicallyChangingTheParser.eyp&quot;</span></li>
  <li><span class="Li">&quot;DynamicvsTieIns.eyp&quot;</span></li>
  <li><span class="Li">&quot;nolr_k_grammarsolveddynamic.eyp&quot;</span></li>
  <li><span class="Li">&quot;pascalenumeratedvsrangesolvedviadyn.eyp&quot;</span></li>
  <li><span class="Li">&quot;Cplusplus.eyp&quot;</span>.</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser~24"><a class="permalink" href="#$parser~24">$parser-&gt;YYSetShift($token)</a></h2>
<p class="Pp">Also:</p>
<p class="Pp"></p>
<pre>
      $parser-&gt;YYSetShift([$token1, $token2, ... ])
</pre>
<p class="Pp">This method has been designed to solve shift-reduce at
    parsing-time using the <i>postponed conflict</i> strategy. See the
    corresponding section in Parse::Eyapp::debuggintut. It has to be called
    inside the semantic action associated with the postponed conflict rule
    <span class="Li">&quot;conflictname&quot;</span>. The LALR table is changed
    so that the action in the presence of the token
    <span class="Li">$token</span> will be to shift.</p>
<p class="Pp">See the examples in
    <span class="Li">&quot;examples/debuggingtut/&quot;</span> in files</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;DebugDynamicResolution.eyp&quot;</span></li>
  <li><span class="Li">&quot;DynamicallyChangingTheParser.eyp&quot;</span></li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser~25"><a class="permalink" href="#$parser~25">$parser-&gt;YYSlurpFile</a></h2>
<p class="Pp">alias:</p>
<p class="Pp"></p>
<pre>
 $parser-&gt;slurp_file($filename[,$prompt[,$mode]])
</pre>
<p class="Pp">Receives the name of the file, reads its contents and stores it in
    <span class="Li">&quot;$parser-&gt;input&quot;</span>.</p>
<p class="Pp">If the file does not exists, it proceeds to read from
    <span class="Li">&quot;STDIN&quot;</span>. If a prompt was set with
    <span class="Li">&quot;$parser-&gt;YYPrompt&quot;</span>, it will be shown.
    The additional optional parameter <span class="Li">$mode</span> is used in
    such case to set <span class="Li">$/</span>. It can also be used as a class
    method.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser~26"><a class="permalink" href="#$parser~26">$parser-&gt;YYState</a></h2>
<p class="Pp"><span class="Li">&quot;YYState&quot;</span> returns a reference to
    the list of states containing the <i>LALR</i>(1) tables: the action and GOTO
    tables. Each state is an anonymous hash:</p>
<p class="Pp"></p>
<pre>
  DB&lt;4&gt; x $parser-&gt;YYState(2)
  0  HASH(0xfa7120)
     'ACTIONS' =&gt; HASH(0xfa70f0) # token =&gt; state
           ':' =&gt; '-7'
     'DEFAULT' =&gt; '-6'
</pre>
<p class="Pp">A negative number means reduction using the corresponding
    production rule (opposite) number. The former example tells to reduce by
    rule 7 when in state 2 and seeing token <span class="Li">':'</span>. By
    default, the action when in state 2 is to reduce by rule number 6.</p>
<p class="Pp">There are three keys: ACTIONS, GOTOS and DEFAULT</p>
<p class="Pp"></p>
<pre>
  DB&lt;7&gt; x $parser-&gt;YYState(13)
 0  HASH(0xfa8b50)
    'ACTIONS' =&gt; HASH(0xfa7530)
       'VAR' =&gt; 17
    'GOTOS' =&gt; HASH(0xfa8b20)
       'type' =&gt; 19
</pre>
<p class="Pp">The GOTOS tables contains the DFA transition tables for the
    syntactic variables. The former example tells to move to state 19 when in
    state 13 after seeing the syntactic variable
    <span class="Li">&quot;type&quot;</span> (i.e. if after reducing by a rule
    of <span class="Li">&quot;type&quot;</span> we are in state 13).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$parser~27"><a class="permalink" href="#$parser~27">$parser-&gt;YYTopState($length)</a></h2>
<p class="Pp">If <span class="Li">$length</span> is zero or not provided it
    returns the state on top of the stack. Otherwise, returns the state
    <span class="Li">$length</span> units deep in the stack.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<ul class="Bl-bullet">
  <li>Hal Finkel &lt;http://www.halssoftware.com/&gt;</li>
  <li>G. Williams &lt;http://kasei.us/&gt;</li>
  <li>Thomas L. Shinnick &lt;http://search.cpan.org/~tshinnic/&gt;</li>
  <li>Frank Leray</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Casiano Rodriguez-Leon (casiano@ull.es)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGMENTS"><a class="permalink" href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a></h1>
<p class="Pp">This work has been supported by CEE (FEDER) and the Spanish
    Ministry of <i>Educacion y Ciencia</i> through <i>Plan Nacional I+D+I</i>
    number TIN2005-08818-C04-04 (ULL::OPLINK project
    &lt;http://www.oplink.ull.es/&gt;). Support from Gobierno de Canarias was
    through GC02210601 (<i>Grupos Consolidados</i>). The University of La Laguna
    has also supported my work in many ways and for many years.</p>
<p class="Pp">A large percentage of code is verbatim taken from Parse::Yapp
    1.05. The author of Parse::Yapp is Francois Desarmenien.</p>
<p class="Pp">I wish to thank Francois Desarmenien for his Parse::Yapp module,
    to my students at La Laguna and to the Perl Community. Thanks to the people
    who have contributed to improve the module (see &quot;CONTRIBUTORS&quot; in
    Parse::Eyapp). Thanks to Larry Wall for giving us Perl. Special thanks to
    Juana.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENCE_AND_COPYRIGHT"><a class="permalink" href="#LICENCE_AND_COPYRIGHT">LICENCE
  AND COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 2006-2008 Casiano Rodriguez-Leon (casiano@ull.es).
    All rights reserved.</p>
<p class="Pp">Parse::Yapp copyright is of Francois Desarmenien, all rights
    reserved. 1998-2001</p>
<p class="Pp">These modules are free software; you can redistribute it and/or
    modify it under the same terms as Perl itself. See perlartistic.</p>
<p class="Pp">This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. </p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2012-03-23</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>DBIx::Class::Manual::Intro(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBIx::Class::Manual::Intro(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBIx::Class::Manual::Intro(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">DBIx::Class::Manual::Intro - Introduction to DBIx::Class</p>
</section>
<section class="Sh">
<h1 class="Sh" id="INTRODUCTION"><a class="permalink" href="#INTRODUCTION">INTRODUCTION</a></h1>
<p class="Pp">You're bored with SQL, and want a native Perl interface for your
    database? Or you've been doing this for a while with Class::DBI, and think
    there's a better way? You've come to the right place.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="THE_DBIx::Class_WAY"><a class="permalink" href="#THE_DBIx::Class_WAY">THE
  DBIx::Class WAY</a></h1>
<p class="Pp">Here are a few simple tips that will help you get your bearings
    with DBIx::Class.</p>
<section class="Ss">
<h2 class="Ss" id="Tables_become_Result_classes"><a class="permalink" href="#Tables_become_Result_classes">Tables
  become Result classes</a></h2>
<p class="Pp">DBIx::Class needs to know what your Table structure looks like.
    You do that by defining Result classes. Result classes are defined by
    calling methods proxied to DBIx::Class::ResultSource. Each Result class
    defines one Table, which defines the Columns it has, along with any
    Relationships it has to other tables. (And oh, so much more besides) The
    important thing to understand:</p>
<p class="Pp"></p>
<pre>  A Result class == Table
</pre>
<p class="Pp">(most of the time, but just bear with my simplification)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="It's_all_about_the_ResultSet"><a class="permalink" href="#It's_all_about_the_ResultSet">It's
  all about the ResultSet</a></h2>
<p class="Pp">So, we've got some ResultSources defined. Now, we want to actually
    use those definitions to help us translate the queries we need into handy
    perl objects!</p>
<p class="Pp">Let's say we defined a ResultSource for an &quot;album&quot; table
    with three columns: &quot;albumid&quot;, &quot;artist&quot;, and
    &quot;title&quot;. Any time we want to query this table, we'll be creating a
    DBIx::Class::ResultSet from its ResultSource. For example, the results
  of:</p>
<p class="Pp"></p>
<pre>  SELECT albumid, artist, title FROM album;
</pre>
<p class="Pp">Would be retrieved by creating a ResultSet object from the album
    table's ResultSource, likely by using the &quot;search&quot; method.</p>
<p class="Pp">DBIx::Class doesn't limit you to creating only simple ResultSets
    -- if you wanted to do something like:</p>
<p class="Pp"></p>
<pre>  SELECT title FROM album GROUP BY title;
</pre>
<p class="Pp">You could easily achieve it.</p>
<p class="Pp">The important thing to understand:</p>
<p class="Pp"></p>
<pre>  Any time you would reach for a SQL query in DBI, you are
  creating a DBIx::Class::ResultSet.
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Search_is_like__prepare_"><a class="permalink" href="#Search_is_like__prepare_">Search
  is like &quot;prepare&quot;</a></h2>
<p class="Pp">DBIx::Class tends to wait until it absolutely must fetch
    information from the database. If you are returning a ResultSet, the query
    won't execute until you use a method that wants to access the data. (Such as
    &quot;next&quot;, or &quot;first&quot;)</p>
<p class="Pp">The important thing to understand:</p>
<p class="Pp"></p>
<pre>  Setting up a ResultSet does not execute the query; retrieving
  the data does.
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Search_results_are_returned_as_Rows"><a class="permalink" href="#Search_results_are_returned_as_Rows">Search
  results are returned as Rows</a></h2>
<p class="Pp">Rows of the search from the database are blessed into Result
    objects.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SETTING_UP_DBIx::Class"><a class="permalink" href="#SETTING_UP_DBIx::Class">SETTING
  UP DBIx::Class</a></h1>
<p class="Pp">Let's look at how you can set and use your first native
    DBIx::Class tree.</p>
<p class="Pp">First we'll see how you can set up your classes yourself. If you
    want them to be auto-discovered, just skip to the next section, which shows
    you how to use DBIx::Class::Schema::Loader.</p>
<section class="Ss">
<h2 class="Ss" id="Setting_it_up_manually"><a class="permalink" href="#Setting_it_up_manually">Setting
  it up manually</a></h2>
<p class="Pp">First, you should create your base schema class, which inherits
    from DBIx::Class::Schema:</p>
<p class="Pp"></p>
<pre>  package My::Schema;
  use base qw/DBIx::Class::Schema/;
</pre>
<p class="Pp">In this class you load your result_source (&quot;table&quot;,
    &quot;model&quot;) classes, which we will define later, using the
    <b>load_namespaces()</b> method:</p>
<p class="Pp"></p>
<pre>  # load My::Schema::Result::* and their resultset classes
  __PACKAGE__-&gt;load_namespaces();
</pre>
<p class="Pp">By default this loads all the Result (Row) classes in the
    My::Schema::Result:: namespace, and also any resultset classes in the
    My::Schema::ResultSet:: namespace (if missing, the resultsets are defaulted
    to be DBIx::Class::ResultSet objects). You can change the result and
    resultset namespaces by using options to the &quot;load_namespaces&quot; in
    DBIx::Class::Schema call.</p>
<p class="Pp">It is also possible to do the same things manually by calling
    <span class="Li">&quot;load_classes&quot;</span> for the Row classes and
    defining in those classes any required resultset classes.</p>
<p class="Pp">Next, create each of the classes you want to load as specified
    above:</p>
<p class="Pp"></p>
<pre>  package My::Schema::Result::Album;
  use base qw/DBIx::Class::Core/;
</pre>
<p class="Pp">Load any additional components you may need with the
    <b>load_components()</b> method, and provide component configuration if
    required. For example, if you want automatic row ordering:</p>
<p class="Pp"></p>
<pre>  __PACKAGE__-&gt;load_components(qw/ Ordered /);
  __PACKAGE__-&gt;position_column('rank');
</pre>
<p class="Pp">Ordered will refer to a field called 'position' unless otherwise
    directed. Here you are defining the ordering field to be named 'rank'.
    (NOTE: Insert errors may occur if you use the Ordered component, but have
    not defined a position column or have a 'position' field in your row.)</p>
<p class="Pp">Set the table for your class:</p>
<p class="Pp"></p>
<pre>  __PACKAGE__-&gt;table('album');
</pre>
<p class="Pp">Add columns to your class:</p>
<p class="Pp"></p>
<pre>  __PACKAGE__-&gt;add_columns(qw/ albumid artist title rank /);
</pre>
<p class="Pp">Each column can also be set up with its own accessor, data_type
    and other pieces of information that it may be useful to have -- just pass
    <span class="Li">&quot;add_columns&quot;</span> a hash:</p>
<p class="Pp"></p>
<pre>  __PACKAGE__-&gt;add_columns(albumid =&gt;
                            { accessor  =&gt; 'album',
                              data_type =&gt; 'integer',
                              size      =&gt; 16,
                              is_nullable =&gt; 0,
                              is_auto_increment =&gt; 1,
                            },
                          artist =&gt;
                            { data_type =&gt; 'integer',
                              size      =&gt; 16,
                              is_nullable =&gt; 0,
                            },
                          title  =&gt;
                            { data_type =&gt; 'varchar',
                              size      =&gt; 256,
                              is_nullable =&gt; 0,
                            },
                          rank =&gt;
                            { data_type =&gt; 'integer',
                              size      =&gt; 16,
                              is_nullable =&gt; 0,
                              default_value =&gt; 0,
                            }
                         );
</pre>
<p class="Pp">DBIx::Class doesn't directly use most of this data yet, but
    various related modules such as HTML::FormHandler::Model::DBIC make use of
    it. Also it allows you to create your database tables from your Schema,
    instead of the other way around. See &quot;deploy&quot; in
    DBIx::Class::Schema for details.</p>
<p class="Pp">See DBIx::Class::ResultSource for more details of the possible
    column attributes.</p>
<p class="Pp">Accessors are created for each column automatically, so
    My::Schema::Result::Album will have <b>albumid()</b> (or <b>album()</b>,
    when using the accessor), <b>artist()</b> and <b>title()</b> methods.</p>
<p class="Pp">Define a primary key for your class:</p>
<p class="Pp"></p>
<pre>  __PACKAGE__-&gt;set_primary_key('albumid');
</pre>
<p class="Pp">If you have a multi-column primary key, just pass a list
  instead:</p>
<p class="Pp"></p>
<pre>  __PACKAGE__-&gt;set_primary_key( qw/ albumid artistid / );
</pre>
<p class="Pp">Define this class' relationships with other classes using either
    <span class="Li">&quot;belongs_to&quot;</span> to describe a column which
    contains an ID of another Table, or
    <span class="Li">&quot;has_many&quot;</span> to make a predefined accessor
    for fetching objects that contain this Table's foreign key:</p>
<p class="Pp"></p>
<pre>  # in My::Schema::Result::Artist
  __PACKAGE__-&gt;has_many('albums', 'My::Schema::Result::Album', 'artist');
</pre>
<p class="Pp">See DBIx::Class::Relationship for more information about the
    various types of available relationships and how you can design your
  own.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_DBIx::Class::Schema::Loader"><a class="permalink" href="#Using_DBIx::Class::Schema::Loader">Using
  DBIx::Class::Schema::Loader</a></h2>
<p class="Pp">This module (DBIx::Class::Schema::Loader) is an external module,
    and not part of the DBIx::Class distribution. It inspects your database, and
    automatically creates classes for all the tables in your schema.</p>
<p class="Pp">The simplest way to use it is via the dbicdump script from the
    DBIx::Class::Schema::Loader distribution. For example:</p>
<p class="Pp"></p>
<pre>    $ dbicdump -o dump_directory=./lib \
        -o components='[&quot;InflateColumn::DateTime&quot;]' \
        MyApp::Schema dbi:mysql:mydb user pass
</pre>
<p class="Pp">If you have a mixed-case database, use the
    <span class="Li">&quot;preserve_case&quot;</span> option, e.g.:</p>
<p class="Pp"></p>
<pre>    $ dbicdump -o dump_directory=./lib -o preserve_case=1 \
        -o components='[&quot;InflateColumn::DateTime&quot;]' \
        MyApp::Schema dbi:mysql:mydb user pass
</pre>
<p class="Pp">If you are using Catalyst, then you can use the helper that comes
    with Catalyst::Model::DBIC::Schema:</p>
<p class="Pp"></p>
<pre>    $ script/myapp_create.pl model MyModel DBIC::Schema MyApp::Schema \
        create=static moniker_map='{ foo =&gt; &quot;FOO&quot; }' dbi:SQLite:./myapp.db \
        on_connect_do='PRAGMA foreign_keys=ON' quote_char='&quot;'
</pre>
<p class="Pp">See Catalyst::Helper::Model::DBIC::Schema for more information on
    this helper.</p>
<p class="Pp">See the DBIx::Class::Schema::Loader and
    DBIx::Class::Schema::Loader::Base documentation for more information on the
    many loader options.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Connecting"><a class="permalink" href="#Connecting">Connecting</a></h2>
<p class="Pp">To connect to your Schema, you need to provide the connection
    details or a database handle.</p>
<p class="Pp"><i>Via connection details</i></p>
<p class="Pp">The arguments are the same as for &quot;connect&quot; in DBI:</p>
<p class="Pp"></p>
<pre>  my $schema = My::Schema-&gt;connect('dbi:SQLite:/home/me/myapp/my.db');
</pre>
<p class="Pp">You can create as many different schema instances as you need. So
    if you have a second database you want to access:</p>
<p class="Pp"></p>
<pre>  my $other_schema = My::Schema-&gt;connect( $dsn, $user, $password, $attrs );
</pre>
<p class="Pp">Note that DBIx::Class::Schema does not cache connections for you.
    If you use multiple connections, you need to do this manually.</p>
<p class="Pp">To execute some SQL statements on every connect you can add them
    as an option in a special fifth argument to connect:</p>
<p class="Pp"></p>
<pre>  my $another_schema = My::Schema-&gt;connect(
      $dsn,
      $user,
      $password,
      $attrs,
      { on_connect_do =&gt; \@on_connect_sql_statments }
  );
</pre>
<p class="Pp">See &quot;connect_info&quot; in DBIx::Class::Storage::DBI for more
    information about this and other special
    <span class="Li">&quot;connect&quot;</span>-time options.</p>
<p class="Pp"><i>Via a database handle</i></p>
<p class="Pp">The supplied coderef is expected to return a single connected
    database handle (e.g. a DBI <span class="Li">$dbh</span>)</p>
<p class="Pp"></p>
<pre>  my $schema = My::Schema-&gt;connect (
    sub { Some::DBH::Factory-&gt;connect },
    \%extra_attrs,
  );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Basic_usage"><a class="permalink" href="#Basic_usage">Basic
  usage</a></h2>
<p class="Pp">Once you've defined the basic classes, either manually or using
    DBIx::Class::Schema::Loader, you can start interacting with your
  database.</p>
<p class="Pp">To access your database using your <span class="Li">$schema</span>
    object, you can fetch a &quot;ResultSet&quot; in
    DBIx::Class::Manual::Glossary representing each of your tables by calling
    the <span class="Li">&quot;resultset&quot;</span> method.</p>
<p class="Pp">The simplest way to get a record is by primary key:</p>
<p class="Pp"></p>
<pre>  my $album = $schema-&gt;resultset('Album')-&gt;find(14);
</pre>
<p class="Pp">This will run a <span class="Li">&quot;SELECT&quot;</span> with
    <span class="Li">&quot;albumid = 14&quot;</span> in the
    <span class="Li">&quot;WHERE&quot;</span> clause, and return an instance of
    <span class="Li">&quot;My::Schema::Result::Album&quot;</span> that
    represents this row. Once you have that row, you can access and update
    columns:</p>
<p class="Pp"></p>
<pre>  $album-&gt;title('Physical Graffiti');
  my $title = $album-&gt;title; # $title holds 'Physical Graffiti'
</pre>
<p class="Pp">If you prefer, you can use the
    <span class="Li">&quot;set_column&quot;</span> and
    <span class="Li">&quot;get_column&quot;</span> accessors instead:</p>
<p class="Pp"></p>
<pre>  $album-&gt;set_column('title', 'Presence');
  $title = $album-&gt;get_column('title');
</pre>
<p class="Pp">Just like with Class::DBI, you call
    <span class="Li">&quot;update&quot;</span> to save your changes to the
    database (by executing the actual <span class="Li">&quot;UPDATE&quot;</span>
    statement):</p>
<p class="Pp"></p>
<pre>  $album-&gt;update;
</pre>
<p class="Pp">If needed, you can throw away your local changes:</p>
<p class="Pp"></p>
<pre>  $album-&gt;discard_changes if $album-&gt;is_changed;
</pre>
<p class="Pp">As you can see, <span class="Li">&quot;is_changed&quot;</span>
    allows you to check if there are local changes to your object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Adding_and_removing_rows"><a class="permalink" href="#Adding_and_removing_rows">Adding
  and removing rows</a></h2>
<p class="Pp">To create a new record in the database, you can use the
    <span class="Li">&quot;create&quot;</span> method. It returns an instance of
    <span class="Li">&quot;My::Schema::Result::Album&quot;</span> that can be
    used to access the data in the new record:</p>
<p class="Pp"></p>
<pre>  my $new_album = $schema-&gt;resultset('Album')-&gt;create({
    title  =&gt; 'Wish You Were Here',
    artist =&gt; 'Pink Floyd'
  });
</pre>
<p class="Pp">Now you can add data to the new record:</p>
<p class="Pp"></p>
<pre>  $new_album-&gt;label('Capitol');
  $new_album-&gt;year('1975');
  $new_album-&gt;update;
</pre>
<p class="Pp">Likewise, you can remove it from the database:</p>
<p class="Pp"></p>
<pre>  $new_album-&gt;delete;
</pre>
<p class="Pp">You can also remove records without retrieving them first, by
    calling delete directly on a ResultSet object.</p>
<p class="Pp"></p>
<pre>  # Delete all of Falco's albums
  $schema-&gt;resultset('Album')-&gt;search({ artist =&gt; 'Falco' })-&gt;delete;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Finding_your_objects"><a class="permalink" href="#Finding_your_objects">Finding
  your objects</a></h2>
<p class="Pp">DBIx::Class provides a few different ways to retrieve data from
    your database. Here's one example:</p>
<p class="Pp"></p>
<pre>  # Find all of Santana's albums
  my $rs = $schema-&gt;resultset('Album')-&gt;search({ artist =&gt; 'Santana' });
</pre>
<p class="Pp">In scalar context, as above,
    <span class="Li">&quot;search&quot;</span> returns a DBIx::Class::ResultSet
    object. It can be used to peek at the first album returned by the
  database:</p>
<p class="Pp"></p>
<pre>  my $album = $rs-&gt;first;
  print $album-&gt;title;
</pre>
<p class="Pp">You can loop over the albums and update each one:</p>
<p class="Pp"></p>
<pre>  while (my $album = $rs-&gt;next) {
    print $album-&gt;artist . ' - ' . $album-&gt;title;
    $album-&gt;year(2001);
    $album-&gt;update;
  }
</pre>
<p class="Pp">Or, you can update them all at once:</p>
<p class="Pp"></p>
<pre>  $rs-&gt;update({ year =&gt; 2001 });
</pre>
<p class="Pp">In list context, the <span class="Li">&quot;search&quot;</span>
    method returns all of the matching rows:</p>
<p class="Pp"></p>
<pre>  # Fetch immediately all of Carlos Santana's albums
  my @albums = $schema-&gt;resultset('Album')-&gt;search(
    { artist =&gt; 'Carlos Santana' }
  );
  foreach my $album (@albums) {
    print $album-&gt;artist . ' - ' . $album-&gt;title;
  }
</pre>
<p class="Pp">We also provide a handy shortcut for doing a
    <span class="Li">&quot;LIKE&quot;</span> search:</p>
<p class="Pp"></p>
<pre>  # Find albums whose artist starts with 'Jimi'
  my $rs = $schema-&gt;resultset('Album')-&gt;search_like({ artist =&gt; 'Jimi%' });
</pre>
<p class="Pp">Or you can provide your own
    <span class="Li">&quot;WHERE&quot;</span> clause:</p>
<p class="Pp"></p>
<pre>  # Find Peter Frampton albums from the year 1986
  my $where = 'artist = ? AND year = ?';
  my @bind  = ( 'Peter Frampton', 1986 );
  my $rs    = $schema-&gt;resultset('Album')-&gt;search_literal( $where, @bind );
</pre>
<p class="Pp">The preferred way to generate complex queries is to provide a
    SQL::Abstract construct to <span class="Li">&quot;search&quot;</span>:</p>
<p class="Pp"></p>
<pre>  my $rs = $schema-&gt;resultset('Album')-&gt;search({
    artist  =&gt; { '!=', 'Janis Joplin' },
    year    =&gt; { '&lt;' =&gt; 1980 },
    albumid =&gt; { '-in' =&gt; [ 1, 14, 15, 65, 43 ] }
  });
</pre>
<p class="Pp">This results in something like the following
    <span class="Li">&quot;WHERE&quot;</span> clause:</p>
<p class="Pp"></p>
<pre>  WHERE artist != 'Janis Joplin'
    AND year &lt; 1980
    AND albumid IN (1, 14, 15, 65, 43)
</pre>
<p class="Pp">For more examples of complex queries, see
    DBIx::Class::Manual::Cookbook.</p>
<p class="Pp">The search can also be modified by passing another hash with
    attributes:</p>
<p class="Pp"></p>
<pre>  my @albums = My::Schema-&gt;resultset('Album')-&gt;search(
    { artist =&gt; 'Bob Marley' },
    { rows =&gt; 2, order_by =&gt; { -desc =&gt; 'year' } }
  );
</pre>
<p class="Pp"><span class="Li">@albums</span> then holds the two most recent Bob
    Marley albums.</p>
<p class="Pp">For more information on what you can do with a
    DBIx::Class::ResultSet, see &quot;METHODS&quot; in
  DBIx::Class::ResultSet.</p>
<p class="Pp">For a complete overview of the available attributes, see
    &quot;ATTRIBUTES&quot; in DBIx::Class::ResultSet.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<section class="Ss">
<h2 class="Ss" id="The_Significance_and_Importance_of_Primary_Keys"><a class="permalink" href="#The_Significance_and_Importance_of_Primary_Keys">The
  Significance and Importance of Primary Keys</a></h2>
<p class="Pp">The concept of a primary key in DBIx::Class warrants special
    discussion. The formal definition (which somewhat resembles that of a
    classic RDBMS) is <i>a unique constraint that is least</i> <i>likely to
    change after initial row creation</i>. However this is where the similarity
    ends. Any time you call a CRUD operation on a row (e.g. delete, update,
    discard_changes, etc.) DBIx::Class will use the values of the primary key
    columns to populate the <span class="Li">&quot;WHERE&quot;</span> clause
    necessary to accomplish the operation. This is why it is important to
    declare a primary key on all your result sources <b>even if the underlying
    RDBMS does not have one</b>. In a pinch one can always declare each row
    identifiable by all its columns:</p>
<p class="Pp"></p>
<pre> __PACKAGE__-&gt;set_primary_key(__PACKAGE__-&gt;columns);
</pre>
<p class="Pp">Note that DBIx::Class is smart enough to store a copy of the PK
    values before any row-object changes take place, so even if you change the
    values of PK columns the <span class="Li">&quot;WHERE&quot;</span> clause
    will remain correct.</p>
<p class="Pp">If you elect not to declare a <span class="Li">&quot;primary
    key&quot;</span>, DBIx::Class will behave correctly by throwing exceptions
    on any row operation that relies on unique identifiable rows. If you
    inherited datasets with multiple identical rows in them, you can still
    operate with such sets provided you only utilize DBIx::Class::ResultSet CRUD
    methods: search, update, delete</p>
<p class="Pp">For example, the following would not work (assuming
    <span class="Li">&quot;People&quot;</span> does not have a declared PK):</p>
<p class="Pp"></p>
<pre> my $result = $schema-&gt;resultset('People')
                   -&gt;search({ last_name =&gt; 'Dantes' })
                    -&gt;next;
 $result-&gt;update({ children =&gt; 2 }); # &lt;-- exception thrown because $result isn't
                                  # necessarily unique
</pre>
<p class="Pp">So instead the following should be done:</p>
<p class="Pp"></p>
<pre> $schema-&gt;resultset('People')
         -&gt;search({ last_name =&gt; 'Dantes' })
          -&gt;update({ children =&gt; 2 }); # &lt;-- update's ALL Dantes to have children of 2
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Problems_on_RHEL5/CentOS5"><a class="permalink" href="#Problems_on_RHEL5/CentOS5">Problems
  on RHEL5/CentOS5</a></h2>
<p class="Pp">There used to be an issue with the system perl on Red Hat
    Enterprise Linux 5, some versions of Fedora and derived systems. Further
    information on this can be found in DBIx::Class::Manual::Troubleshooting</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>DBIx::Class::Manual::Cookbook</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="FURTHER_QUESTIONS?"><a class="permalink" href="#FURTHER_QUESTIONS?">FURTHER
  QUESTIONS?</a></h1>
<p class="Pp">Check the list of additional DBIC resources.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This module is free software copyright by the DBIx::Class (DBIC)
    authors. You can redistribute it and/or modify it under the same terms as
    the DBIx::Class library.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-12-08</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

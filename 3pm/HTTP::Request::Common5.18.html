<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>HTTP::Request::Common(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">HTTP::Request::Common(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">HTTP::Request::Common(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">HTTP::Request::Common - Construct common HTTP::Request objects</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
  use HTTP::Request::Common;
  $ua = LWP::UserAgent-&gt;new;
  $ua-&gt;request(GET 'http://www.sn.no/');
  $ua-&gt;request(POST 'http://somewhere/foo', [foo =&gt; bar, bar =&gt; foo]);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module provide functions that return newly created
    <span class="Li">&quot;HTTP::Request&quot;</span> objects. These functions
    are usually more convenient to use than the standard
    <span class="Li">&quot;HTTP::Request&quot;</span> constructor for the most
    common requests. The following functions are provided:</p>
<dl class="Bl-tag">
  <dt id="GET"><a class="permalink" href="#GET">GET $url</a></dt>
  <dd></dd>
  <dt id="GET~2"><a class="permalink" href="#GET~2">GET $url, Header =&gt;
    Value,...</a></dt>
  <dd>The <i>GET()</i> function returns an
      <span class="Li">&quot;HTTP::Request&quot;</span> object initialized with
      the &quot;GET&quot; method and the specified URL. It is roughly equivalent
      to the following call
    <p class="Pp"></p>
    <pre>
  HTTP::Request-&gt;new(
     GET =&gt; $url,
     HTTP::Headers-&gt;new(Header =&gt; Value,...),
  )
    </pre>
    <p class="Pp">but is less cluttered. What is different is that a header
        named <span class="Li">&quot;Content&quot;</span> will initialize the
        content part of the request instead of setting a header field. Note that
        GET requests should normally not have a content, so this hack makes more
        sense for the <i>PUT()</i> and <i>POST()</i> functions described
      below.</p>
    <p class="Pp">The get(...) method of
        <span class="Li">&quot;LWP::UserAgent&quot;</span> exists as a shortcut
        for <span class="Li">$ua</span>-&gt;request(GET ...).</p>
  </dd>
  <dt id="HEAD"><a class="permalink" href="#HEAD">HEAD $url</a></dt>
  <dd></dd>
  <dt id="HEAD~2"><a class="permalink" href="#HEAD~2">HEAD $url, Header =&gt;
    Value,...</a></dt>
  <dd>Like <i>GET()</i> but the method in the request is &quot;HEAD&quot;.
    <p class="Pp">The head(...) method of &quot;LWP::UserAgent&quot; exists as a
        shortcut for <span class="Li">$ua</span>-&gt;request(HEAD ...).</p>
  </dd>
  <dt id="PUT"><a class="permalink" href="#PUT">PUT $url</a></dt>
  <dd></dd>
  <dt id="PUT~2"><a class="permalink" href="#PUT~2">PUT $url, Header =&gt;
    Value,...</a></dt>
  <dd></dd>
  <dt id="PUT~3"><a class="permalink" href="#PUT~3">PUT $url, Header =&gt;
    Value,..., Content =&gt; $content</a></dt>
  <dd>Like <i>GET()</i> but the method in the request is &quot;PUT&quot;.
    <p class="Pp">The content of the request can be specified using the
        &quot;Content&quot; pseudo-header. This steals a bit of the header field
        namespace as there is no way to directly specify a header that is
        actually called &quot;Content&quot;. If you really need this you must
        update the request returned in a separate statement.</p>
  </dd>
  <dt id="DELETE"><a class="permalink" href="#DELETE">DELETE $url</a></dt>
  <dd></dd>
  <dt id="DELETE~2"><a class="permalink" href="#DELETE~2">DELETE $url, Header
    =&gt; Value,...</a></dt>
  <dd>Like <i>GET()</i> but the method in the request is &quot;DELETE&quot;.
      This function is not exported by default.</dd>
  <dt id="POST"><a class="permalink" href="#POST">POST $url</a></dt>
  <dd></dd>
  <dt id="POST~2"><a class="permalink" href="#POST~2">POST $url, Header =&gt;
    Value,...</a></dt>
  <dd></dd>
  <dt id="POST~3"><a class="permalink" href="#POST~3">POST $url, $form_ref,
    Header =&gt; Value,...</a></dt>
  <dd></dd>
  <dt id="POST~4"><a class="permalink" href="#POST~4">POST $url, Header =&gt;
    Value,..., Content =&gt; $form_ref</a></dt>
  <dd></dd>
  <dt id="POST~5"><a class="permalink" href="#POST~5">POST $url, Header =&gt;
    Value,..., Content =&gt; $content</a></dt>
  <dd>This works mostly like <i>PUT()</i> with &quot;POST&quot; as the method,
      but this function also takes a second optional array or hash reference
      parameter <span class="Li">$form_ref</span>. As for <i>PUT()</i> the
      content can also be specified directly using the &quot;Content&quot;
      pseudo-header, and you may also provide the
      <span class="Li">$form_ref</span> this way.
    <p class="Pp">The <span class="Li">$form_ref</span> argument can be used to
        pass key/value pairs for the form content. By default we will initialize
        a request using the
        <span class="Li">&quot;application/x-www-form-urlencoded&quot;</span>
        content type. This means that you can emulate an HTML &lt;form&gt;
        POSTing like this:</p>
    <p class="Pp"></p>
    <pre>
  POST 'http://www.perl.org/survey.cgi',
       [ name   =&gt; 'Gisle Aas',
         email  =&gt; 'gisle@aas.no',
         gender =&gt; 'M',
         born   =&gt; '1964',
         perc   =&gt; '3%',
       ];
    </pre>
    <p class="Pp">This will create an HTTP::Request object that looks like
      this:</p>
    <p class="Pp"></p>
    <pre>
  POST http://www.perl.org/survey.cgi
  Content-Length: 66
  Content-Type: application/x-www-form-urlencoded

  name=Gisle%20Aas&amp;email=gisle%40aas.no&amp;gender=M&amp;born=1964&amp;perc=3%25
    </pre>
    <p class="Pp">Multivalued form fields can be specified by either repeating
        the field name or by passing the value as an array reference.</p>
    <p class="Pp">The POST method also supports the
        <span class="Li">&quot;multipart/form-data&quot;</span> content used for
        <i>Form-based File Upload</i> as specified in RFC 1867. You trigger this
        content format by specifying a content type of
        <span class="Li">'form-data'</span> as one of the request headers. If
        one of the values in the <span class="Li">$form_ref</span> is an array
        reference, then it is treated as a file part specification with the
        following interpretation:</p>
    <p class="Pp"></p>
    <pre>
  [ $file, $filename, Header =&gt; Value... ]
  [ undef, $filename, Header =&gt; Value,..., Content =&gt; $content ]
    </pre>
    <p class="Pp">The first value in the array ($file) is the name of a file to
        open. This file will be read and its content placed in the request. The
        routine will croak if the file can't be opened. Use an
        <span class="Li">&quot;undef&quot;</span> as
        <span class="Li">$file</span> value if you want to specify the content
        directly with a <span class="Li">&quot;Content&quot;</span> header. The
        <span class="Li">$filename</span> is the filename to report in the
        request. If this value is undefined, then the basename of the
        <span class="Li">$file</span> will be used. You can specify an empty
        string as <span class="Li">$filename</span> if you want to suppress
        sending the filename when you provide a <span class="Li">$file</span>
        value.</p>
    <p class="Pp">If a <span class="Li">$file</span> is provided by no
        <span class="Li">&quot;Content-Type&quot;</span> header, then
        <span class="Li">&quot;Content-Type&quot;</span> and
        <span class="Li">&quot;Content-Encoding&quot;</span> will be filled in
        automatically with the values returned by
        <i>LWP::MediaTypes::guess_media_type()</i></p>
    <p class="Pp">Sending my <i>~/.profile</i> to the survey used as example
        above can be achieved by this:</p>
    <p class="Pp"></p>
    <pre>
  POST 'http://www.perl.org/survey.cgi',
       Content_Type =&gt; 'form-data',
       Content      =&gt; [ name  =&gt; 'Gisle Aas',
                         email =&gt; 'gisle@aas.no',
                         gender =&gt; 'M',
                         born   =&gt; '1964',
                         init   =&gt; [&quot;$ENV{HOME}/.profile&quot;],
                       ]
    </pre>
    <p class="Pp">This will create an HTTP::Request object that almost looks
        this (the boundary and the content of your <i>~/.profile</i> is likely
        to be different):</p>
    <p class="Pp"></p>
    <pre>
  POST http://www.perl.org/survey.cgi
  Content-Length: 388
  Content-Type: multipart/form-data; boundary=&quot;6G+f&quot;

  --6G+f
  Content-Disposition: form-data; name=&quot;name&quot;

  Gisle Aas
  --6G+f
  Content-Disposition: form-data; name=&quot;email&quot;

  gisle@aas.no
  --6G+f
  Content-Disposition: form-data; name=&quot;gender&quot;

  M
  --6G+f
  Content-Disposition: form-data; name=&quot;born&quot;

  1964
  --6G+f
  Content-Disposition: form-data; name=&quot;init&quot;; filename=&quot;.profile&quot;
  Content-Type: text/plain

  PATH=/local/perl/bin:$PATH
  export PATH

  --6G+f--
    </pre>
    <p class="Pp">If you set the <span class="Li">$DYNAMIC_FILE_UPLOAD</span>
        variable (exportable) to some TRUE value, then you get back a request
        object with a subroutine closure as the content attribute. This
        subroutine will read the content of any files on demand and return it in
        suitable chunks. This allow you to upload arbitrary big files without
        using lots of memory. You can even upload infinite files like
        <i>/dev/audio</i> if you wish; however, if the file is not a plain file,
        there will be no Content-Length header defined for the request. Not all
        servers (or server applications) like this. Also, if the file(s) change
        in size between the time the Content-Length is calculated and the time
        that the last chunk is delivered, the subroutine will
        <span class="Li">&quot;Croak&quot;</span>.</p>
    <p class="Pp">The post(...) method of &quot;LWP::UserAgent&quot; exists as a
        shortcut for <span class="Li">$ua</span>-&gt;request(POST ...).</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">HTTP::Request, LWP::UserAgent</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 1997-2004, Gisle Aas</p>
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2012-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

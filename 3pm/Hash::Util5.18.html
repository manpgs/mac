<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Hash::Util(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Hash::Util(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Hash::Util(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Hash::Util - A selection of general-utility hash subroutines</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
  # Restricted hashes

  use Hash::Util qw(
                     fieldhash fieldhashes

                     all_keys
                     lock_keys unlock_keys
                     lock_value unlock_value
                     lock_hash unlock_hash
                     lock_keys_plus
                     hash_locked hash_unlocked
                     hashref_locked hashref_unlocked
                     hidden_keys legal_keys

                     lock_ref_keys unlock_ref_keys
                     lock_ref_value unlock_ref_value
                     lock_hashref unlock_hashref
                     lock_ref_keys_plus
                     hidden_ref_keys legal_ref_keys

                     hash_seed hash_value hv_store
                     bucket_stats bucket_info bucket_array
                     lock_hash_recurse unlock_hash_recurse

                     hash_traversal_mask
                   );

  %hash = (foo =&gt; 42, bar =&gt; 23);
  # Ways to restrict a hash
  lock_keys(%hash);
  lock_keys(%hash, @keyset);
  lock_keys_plus(%hash, @additional_keys);

  # Ways to inspect the properties of a restricted hash
  my @legal = legal_keys(%hash);
  my @hidden = hidden_keys(%hash);
  my $ref = all_keys(%hash,@keys,@hidden);
  my $is_locked = hash_locked(%hash);

  # Remove restrictions on the hash
  unlock_keys(%hash);

  # Lock individual values in a hash
  lock_value  (%hash, 'foo');
  unlock_value(%hash, 'foo');

  # Ways to change the restrictions on both keys and values
  lock_hash  (%hash);
  unlock_hash(%hash);

  my $hashes_are_randomised = hash_seed() != 0;

  my $int_hash_value = hash_value( 'string' );

  my $mask= hash_traversal_mask(%hash);

  hash_traversal_mask(%hash,1234);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><span class="Li">&quot;Hash::Util&quot;</span> and
    <span class="Li">&quot;Hash::Util::FieldHash&quot;</span> contain special
    functions for manipulating hashes that don't really warrant a keyword.</p>
<p class="Pp"><span class="Li">&quot;Hash::Util&quot;</span> contains a set of
    functions that support restricted hashes. These are described in this
    document. <span class="Li">&quot;Hash::Util::FieldHash&quot;</span> contains
    an (unrelated) set of functions that support the use of hashes in
    <i>inside-out classes</i>, described in Hash::Util::FieldHash.</p>
<p class="Pp">By default <span class="Li">&quot;Hash::Util&quot;</span> does not
    export anything.</p>
<section class="Ss">
<h2 class="Ss" id="Restricted_hashes"><a class="permalink" href="#Restricted_hashes">Restricted
  hashes</a></h2>
<p class="Pp">5.8.0 introduces the ability to restrict a hash to a certain set
    of keys. No keys outside of this set can be added. It also introduces the
    ability to lock an individual key so it cannot be deleted and the ability to
    ensure that an individual value cannot be changed.</p>
<p class="Pp">This is intended to largely replace the deprecated
  pseudo-hashes.</p>
<dl class="Bl-tag">
  <dt id="lock_keys"><a class="permalink" href="#lock_keys"><b>lock_keys</b></a></dt>
  <dd></dd>
  <dt id="unlock_keys"><a class="permalink" href="#unlock_keys"><b>unlock_keys</b></a></dt>
  <dd>
    <pre>
  lock_keys(%hash);
  lock_keys(%hash, @keys);
    </pre>
    <p class="Pp">Restricts the given <span class="Li">%hash</span>'s set of
        keys to <span class="Li">@keys</span>. If <span class="Li">@keys</span>
        is not given it restricts it to its current keyset. No more keys can be
        added. <i>delete()</i> and <i>exists()</i> will still work, but will not
        alter the set of allowed keys. <b>Note</b>: the current implementation
        prevents the hash from being <i>bless()</i>ed while it is in a locked
        state. Any attempt to do so will raise an exception. Of course you can
        still <i>bless()</i> the hash before you call <i>lock_keys()</i> so this
        shouldn't be a problem.</p>
    <p class="Pp"></p>
    <pre>
  unlock_keys(%hash);
    </pre>
    <p class="Pp">Removes the restriction on the <span class="Li">%hash</span>'s
        keyset.</p>
    <p class="Pp"><b>Note</b> that if any of the values of the hash have been
        locked they will not be unlocked after this sub executes.</p>
    <p class="Pp">Both routines return a reference to the hash operated on.</p>
  </dd>
  <dt id="lock_keys_plus"><a class="permalink" href="#lock_keys_plus"><b>lock_keys_plus</b></a></dt>
  <dd>
    <pre>
  lock_keys_plus(%hash,@additional_keys)
    </pre>
    <p class="Pp">Similar to <span class="Li">&quot;lock_keys()&quot;</span>,
        with the difference being that the optional key list specifies keys that
        may or may not be already in the hash. Essentially this is an easier way
        to say</p>
    <p class="Pp"></p>
    <pre>
  lock_keys(%hash,@additional_keys,keys %hash);
    </pre>
    <p class="Pp">Returns a reference to <span class="Li">%hash</span></p>
  </dd>
  <dt id="lock_value"><a class="permalink" href="#lock_value"><b>lock_value</b></a></dt>
  <dd></dd>
  <dt id="unlock_value"><a class="permalink" href="#unlock_value"><b>unlock_value</b></a></dt>
  <dd>
    <pre>
  lock_value  (%hash, $key);
  unlock_value(%hash, $key);
    </pre>
    <p class="Pp">Locks and unlocks the value for an individual key of a hash.
        The value of a locked key cannot be changed.</p>
    <p class="Pp">Unless <span class="Li">%hash</span> has already been locked
        the key/value could be deleted regardless of this setting.</p>
    <p class="Pp">Returns a reference to the <span class="Li">%hash</span>.</p>
  </dd>
  <dt id="lock_hash"><a class="permalink" href="#lock_hash"><b>lock_hash</b></a></dt>
  <dd></dd>
  <dt id="unlock_hash"><a class="permalink" href="#unlock_hash"><b>unlock_hash</b></a></dt>
  <dd>
    <pre>
    lock_hash(%hash);
    </pre>
    <p class="Pp"><i>lock_hash()</i> locks an entire hash, making all keys and
        values read-only. No value can be changed, no keys can be added or
        deleted.</p>
    <p class="Pp"></p>
    <pre>
    unlock_hash(%hash);
    </pre>
    <p class="Pp"><i>unlock_hash()</i> does the opposite of <i>lock_hash()</i>.
        All keys and values are made writable. All values can be changed and
        keys can be added and deleted.</p>
    <p class="Pp">Returns a reference to the <span class="Li">%hash</span>.</p>
  </dd>
  <dt id="lock_hash_recurse"><a class="permalink" href="#lock_hash_recurse"><b>lock_hash_recurse</b></a></dt>
  <dd></dd>
  <dt id="unlock_hash_recurse"><a class="permalink" href="#unlock_hash_recurse"><b>unlock_hash_recurse</b></a></dt>
  <dd>
    <pre>
    lock_hash_recurse(%hash);
    </pre>
    <p class="Pp"><i>lock_hash()</i> locks an entire hash and any hashes it
        references recursively, making all keys and values read-only. No value
        can be changed, no keys can be added or deleted.</p>
    <p class="Pp">This method <b>only</b> recurses into hashes that are
        referenced by another hash. Thus a Hash of Hashes (HoH) will all be
        restricted, but a Hash of Arrays of Hashes (HoAoH) will only have the
        top hash restricted.</p>
    <p class="Pp"></p>
    <pre>
    unlock_hash_recurse(%hash);
    </pre>
    <p class="Pp"><i>unlock_hash_recurse()</i> does the opposite of
        <i>lock_hash_recurse()</i>. All keys and values are made writable. All
        values can be changed and keys can be added and deleted. Identical
        recursion restrictions apply as to <i>lock_hash_recurse()</i>.</p>
    <p class="Pp">Returns a reference to the <span class="Li">%hash</span>.</p>
  </dd>
  <dt id="hashref_locked"><a class="permalink" href="#hashref_locked"><b>hashref_locked</b></a></dt>
  <dd></dd>
  <dt id="hash_locked"><a class="permalink" href="#hash_locked"><b>hash_locked</b></a></dt>
  <dd>
    <pre>
  hashref_locked(\%hash) and print &quot;Hash is locked!\n&quot;;
  hash_locked(%hash) and print &quot;Hash is locked!\n&quot;;
    </pre>
    <p class="Pp">Returns true if the hash and its keys are locked.</p>
  </dd>
  <dt id="hashref_unlocked"><a class="permalink" href="#hashref_unlocked"><b>hashref_unlocked</b></a></dt>
  <dd></dd>
  <dt id="hash_unlocked"><a class="permalink" href="#hash_unlocked"><b>hash_unlocked</b></a></dt>
  <dd>
    <pre>
  hashref_unlocked(\%hash) and print &quot;Hash is unlocked!\n&quot;;
  hash_unlocked(%hash) and print &quot;Hash is unlocked!\n&quot;;
    </pre>
    <p class="Pp">Returns true if the hash and its keys are unlocked.</p>
  </dd>
  <dt id="legal_keys"><a class="permalink" href="#legal_keys"><b>legal_keys</b></a></dt>
  <dd>
    <pre>
  my @keys = legal_keys(%hash);
    </pre>
    <p class="Pp">Returns the list of the keys that are legal in a restricted
        hash. In the case of an unrestricted hash this is identical to calling
        keys(%hash).</p>
  </dd>
  <dt id="hidden_keys"><a class="permalink" href="#hidden_keys"><b>hidden_keys</b></a></dt>
  <dd>
    <pre>
  my @keys = hidden_keys(%hash);
    </pre>
    <p class="Pp">Returns the list of the keys that are legal in a restricted
        hash but do not have a value associated to them. Thus if 'foo' is a
        &quot;hidden&quot; key of the <span class="Li">%hash</span> it will
        return false for both <span class="Li">&quot;defined&quot;</span> and
        <span class="Li">&quot;exists&quot;</span> tests.</p>
    <p class="Pp">In the case of an unrestricted hash this will return an empty
        list.</p>
    <p class="Pp"><b>NOTE</b> this is an experimental feature that is heavily
        dependent on the current implementation of restricted hashes. Should the
        implementation change, this routine may become meaningless, in which
        case it will return an empty list.</p>
  </dd>
  <dt id="all_keys"><a class="permalink" href="#all_keys"><b>all_keys</b></a></dt>
  <dd>
    <pre>
  all_keys(%hash,@keys,@hidden);
    </pre>
    <p class="Pp">Populates the arrays <span class="Li">@keys</span> with the
        all the keys that would pass an
        <span class="Li">&quot;exists&quot;</span> tests, and populates
        <span class="Li">@hidden</span> with the remaining legal keys that have
        not been utilized.</p>
    <p class="Pp">Returns a reference to the hash.</p>
    <p class="Pp">In the case of an unrestricted hash this will be equivalent
      to</p>
    <p class="Pp"></p>
    <pre>
  $ref = do {
      @keys = keys %hash;
      @hidden = ();
      \%hash
  };
    </pre>
    <p class="Pp"><b>NOTE</b> this is an experimental feature that is heavily
        dependent on the current implementation of restricted hashes. Should the
        implementation change this routine may become meaningless in which case
        it will behave identically to how it would behave on an unrestricted
        hash.</p>
  </dd>
  <dt id="hash_seed"><a class="permalink" href="#hash_seed"><b>hash_seed</b></a></dt>
  <dd>
    <pre>
    my $hash_seed = hash_seed();
    </pre>
    <p class="Pp"><i>hash_seed()</i> returns the seed bytes used to randomise
        hash ordering.</p>
    <p class="Pp"><b>Note that the hash seed is sensitive information</b>: by
        knowing it one can craft a denial-of-service attack against Perl code,
        even remotely, see &quot;Algorithmic Complexity Attacks&quot; in perlsec
        for more information. <b>Do not disclose the hash seed</b> to people who
        don't need to know it. See also &quot;PERL_HASH_SEED_DEBUG&quot; in
        perlrun.</p>
    <p class="Pp">Prior to Perl 5.17.6 this function returned a UV, it now
        returns a string, which may be of nearly any size as determined by the
        hash function your Perl has been built with. Possible sizes may be but
        are not limited to 4 bytes (for most hash algorithms) and 16 bytes (for
        siphash).</p>
  </dd>
  <dt id="hash_value"><a class="permalink" href="#hash_value"><b>hash_value</b></a></dt>
  <dd>
    <pre>
    my $hash_value = hash_value($string);
    </pre>
    <p class="Pp"><i>hash_value()</i> returns the current perl's internal hash
        value for a given string.</p>
    <p class="Pp">Returns a 32 bit integer representing the hash value of the
        string passed in. This value is only reliable for the lifetime of the
        process. It may be different depending on invocation, environment
        variables, perl version, architectures, and build options.</p>
    <p class="Pp"><b>Note that the hash value of a given string is sensitive
        information</b>: by knowing it one can deduce the hash seed which in
        turn can allow one to craft a denial-of-service attack against Perl
        code, even remotely, see &quot;Algorithmic Complexity Attacks&quot; in
        perlsec for more information. <b>Do not disclose the hash value of a
        string</b> to people who don't need to know it. See also
        &quot;PERL_HASH_SEED_DEBUG&quot; in perlrun.</p>
  </dd>
  <dt id="bucket_info"><a class="permalink" href="#bucket_info"><b>bucket_info</b></a></dt>
  <dd>Return a set of basic information about a hash.
    <p class="Pp"></p>
    <pre>
    my ($keys, $buckets, $used, @length_counts)= bucket_info($hash);
    </pre>
    <p class="Pp">Fields are as follows:</p>
    <p class="Pp"></p>
    <pre>
    0: Number of keys in the hash
    1: Number of buckets in the hash
    2: Number of used buckets in the hash
    rest : list of counts, Kth element is the number of buckets
           with K keys in it.
    </pre>
    <p class="Pp">See also <i>bucket_stats()</i> and <i>bucket_array()</i>.</p>
  </dd>
  <dt id="bucket_stats"><a class="permalink" href="#bucket_stats"><b>bucket_stats</b></a></dt>
  <dd>Returns a list of statistics about a hash.
    <p class="Pp"></p>
    <pre>
    my ($keys, buckets, $used, $utilization_ratio, $collision_pct,
        $mean, $stddev, @length_counts) = bucket_info($hashref);
    </pre>
    <p class="Pp">Fields are as follows:</p>
    <p class="Pp"></p>
    <pre>
    0: Number of keys in the hash
    1: Number of buckets in the hash
    2: Number of used buckets in the hash
    3: Hash Quality Score
    4: Percent of buckets used
    5: Percent of keys which are in collision
    6: Average bucket length
    7: Standard Deviation of bucket lengths.
    rest : list of counts, Kth element is the number of buckets
           with K keys in it.
    </pre>
    <p class="Pp">See also <i>bucket_info()</i> and <i>bucket_array()</i>.</p>
    <p class="Pp">Note that Hash Quality Score would be 1 for an ideal hash,
        numbers close to and below 1 indicate good hashing, and number
        significantly above indicate a poor score. In practice it should be
        around 0.95 to 1.05. It is defined as:</p>
    <p class="Pp"></p>
    <pre>
 $score= sum( $count[$length] * ($length * ($length + 1) / 2) )
            /
            ( ( $keys / 2 * $buckets ) *
              ( $keys + ( 2 * $buckets ) - 1 ) )
    </pre>
    <p class="Pp">The formula is from the Red Dragon book (reformulated to use
        the data available) and is documented at
        &lt;http://www.strchr.com/hash_functions&gt;</p>
  </dd>
  <dt id="bucket_array"><a class="permalink" href="#bucket_array"><b>bucket_array</b></a></dt>
  <dd>
    <pre>
    my $array= bucket_array(\%hash);
    </pre>
    <p class="Pp">Returns a packed representation of the bucket array associated
        with a hash. Each element of the array is either an integer K, in which
        case it represents K empty buckets, or a reference to another array
        which contains the keys that are in that bucket.</p>
    <p class="Pp"><b>Note that the information returned by bucket_array is
        sensitive information</b>: by knowing it one can directly attack perl's
        hash function which in turn may allow one to craft a denial-of-service
        attack against Perl code, even remotely, see &quot;Algorithmic
        Complexity Attacks&quot; in perlsec for more information. <b>Do not
        disclose the output of this function</b> to people who don't need to
        know it. See also &quot;PERL_HASH_SEED_DEBUG&quot; in perlrun. This
        function is provided strictly for debugging and diagnostics purposes
        only, it is hard to imagine a reason why it would be used in production
        code.</p>
  </dd>
  <dt id="hv_store"><a class="permalink" href="#hv_store"><b>hv_store</b></a></dt>
  <dd>
    <pre>
  my $sv = 0;
  hv_store(%hash,$key,$sv) or die &quot;Failed to alias!&quot;;
  $hash{$key} = 1;
  print $sv; # prints 1
    </pre>
    <p class="Pp">Stores an alias to a variable in a hash instead of copying the
        value.</p>
  </dd>
  <dt id="hash_traversal_mask"><a class="permalink" href="#hash_traversal_mask"><b>hash_traversal_mask</b></a></dt>
  <dd>As of Perl 5.18 every hash has its own hash traversal order, and this
      order changes every time a new element is inserted into the hash. This
      functionality is provided by maintaining an unsigned integer mask (U32)
      which is xor'ed with the actual bucket id during a traversal of the hash
      buckets using <i>keys()</i>, <i>values()</i> or <i>each()</i>.
    <p class="Pp">You can use this subroutine to get and set the traversal mask
        for a specific hash. Setting the mask ensures that a given hash will
        produce the same key order. <b>Note</b> that this does <b>not</b>
        guarantee that <b>two</b> hashes will produce the same key order for the
        same hash seed and traversal mask, items that collide into one bucket
        may have different orders regardless of this setting.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Operating_on_references_to_hashes."><a class="permalink" href="#Operating_on_references_to_hashes.">Operating
  on references to hashes.</a></h2>
<p class="Pp">Most subroutines documented in this module have equivalent
    versions that operate on references to hashes instead of native hashes. The
    following is a list of these subs. They are identical except in name and in
    that instead of taking a <span class="Li">%hash</span> they take a
    <span class="Li">$hashref</span>, and additionally are not prototyped.</p>
<dl class="Bl-tag">
  <dt id="lock_ref_keys"><a class="permalink" href="#lock_ref_keys">lock_ref_keys</a></dt>
  <dd></dd>
  <dt id="unlock_ref_keys"><a class="permalink" href="#unlock_ref_keys">unlock_ref_keys</a></dt>
  <dd></dd>
  <dt id="lock_ref_keys_plus"><a class="permalink" href="#lock_ref_keys_plus">lock_ref_keys_plus</a></dt>
  <dd></dd>
  <dt id="lock_ref_value"><a class="permalink" href="#lock_ref_value">lock_ref_value</a></dt>
  <dd></dd>
  <dt id="unlock_ref_value"><a class="permalink" href="#unlock_ref_value">unlock_ref_value</a></dt>
  <dd></dd>
  <dt id="lock_hashref"><a class="permalink" href="#lock_hashref">lock_hashref</a></dt>
  <dd></dd>
  <dt id="unlock_hashref"><a class="permalink" href="#unlock_hashref">unlock_hashref</a></dt>
  <dd></dd>
  <dt id="lock_hashref_recurse"><a class="permalink" href="#lock_hashref_recurse">lock_hashref_recurse</a></dt>
  <dd></dd>
  <dt id="unlock_hashref_recurse"><a class="permalink" href="#unlock_hashref_recurse">unlock_hashref_recurse</a></dt>
  <dd></dd>
  <dt id="hash_ref_unlocked"><a class="permalink" href="#hash_ref_unlocked">hash_ref_unlocked</a></dt>
  <dd></dd>
  <dt id="legal_ref_keys"><a class="permalink" href="#legal_ref_keys">legal_ref_keys</a></dt>
  <dd></dd>
  <dt id="hidden_ref_keys"><a class="permalink" href="#hidden_ref_keys">hidden_ref_keys</a></dt>
  <dd></dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<p class="Pp">Note that the trapping of the restricted operations is not atomic:
    for example</p>
<p class="Pp"></p>
<pre>
    eval { %hash = (illegal_key =&gt; 1) }
</pre>
<p class="Pp">leaves the <span class="Li">%hash</span> empty rather than with
    its original contents.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">The interface exposed by this module is very close to the current
    implementation of restricted hashes. Over time it is expected that this
    behavior will be extended and the interface abstracted further.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Michael G Schwern &lt;schwern@pobox.com&gt; on top of code by Nick
    Ing-Simmons and Jeffrey Friedl.</p>
<p class="Pp"><i>hv_store()</i> is from Array::RefElem, Copyright 2000 Gisle
    Aas.</p>
<p class="Pp">Additional code by Yves Orton.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Scalar::Util, List::Util and &quot;Algorithmic Complexity
    Attacks&quot; in perlsec.</p>
<p class="Pp">Hash::Util::FieldHash.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

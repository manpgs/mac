<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Parse::Eyapp::defaultactionsintro(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Parse::Eyapp::defaultactionsintro(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Parse::Eyapp::defaultactionsintro(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Parse::Eyapp::defaultactionsintro - Introduction to Default
    Actions and Grammar Reuse</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Introduction"><a class="permalink" href="#Introduction">Introduction</a></h1>
<p class="Pp">The examples used in this tutorial can be found in the directory
    <span class="Li">&quot;examples/recycle&quot;</span> accompanying this
    distribution</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Default_Actions"><a class="permalink" href="#Default_Actions">Default
  Actions</a></h1>
<section class="Ss">
<h2 class="Ss" id="Default_actions"><a class="permalink" href="#Default_actions">Default
  actions</a></h2>
<p class="Pp">When no action is specified both
    <span class="Li">&quot;yapp&quot;</span> and
    <span class="Li">&quot;eyapp&quot;</span> implicitly insert the semantic
    action <span class="Li">&quot;{ $_[1] }&quot;</span>. In
    <span class="Li">&quot;Parse::Eyapp&quot;</span> you can modify such
    behavior using the <span class="Li">&quot;%defaultaction { Perl code
    }&quot;</span> directive. The <span class="Li">&quot;{ Perl code
    }&quot;</span> clause that follows the
    <span class="Li">%defaultaction</span> directive is executed when reducing
    by any production for which no explicit action was specified.</p>
<p class="Pp"><i>Translator from Infix to Postfix</i></p>
<p class="Pp">See the example in
    <span class="Li">&quot;examples/eyapplanguageref/Postfix.eyp&quot;</span>
    that translates an infix expression like
    <span class="Li">&quot;a=b*-3&quot;</span> into a postfix expression like
    <span class="Li">&quot;a b 3 NEG * = &quot;</span>:</p>
<p class="Pp"></p>
<pre>
  Parse-Eyapp/examples/eyapplanguageref$ cat -n Postfix.eyp
     1  # File Postfix.eyp
     2  %right  '='
     3  %left   '-' '+'
     4  %left   '*' '/'
     5  %left   NEG
     6
     7  %defaultaction { return  &quot;$left $right $op&quot;; }
     8
     9  %%
    10  line: $exp  { print &quot;$exp\n&quot; }
    11  ;
    12
    13  exp:        $NUM  { $NUM }
    14          |   $VAR  { $VAR }
    15          |   VAR.left '='.op exp.right
    16          |   exp.left '+'.op exp.right
    17          |   exp.left '-'.op exp.right
    18          |   exp.left '*'.op exp.right
    19          |   exp.left '/'.op exp.right
    20          |   '-' $exp %prec NEG { &quot;$exp NEG&quot; }
    21          |   '(' $exp ')' { $exp }
    22  ;
    23
    24  %%
    25
    26  sub _Error {
    27    my($token)=$_[0]-&gt;YYCurval;
    28    my($what)= $token ? &quot;input: '$token'&quot; : &quot;end of input&quot;;
    29    my @expected = $_[0]-&gt;YYExpect();
    30
    31    local $&quot; = ', ';
    32    die &quot;Syntax error near $what. Expected one of these tokens: @expected\n&quot;;
    33  }
    34
    35  my $x;
    36
    37  sub _Lexer {
    38    my($parser)=shift;
    39
    40    for ($x) {
    41      s/^\s+//;
    42      $_ eq '' and return('',undef);
    43
    44      s/^([0-9]+(?:\.[0-9]+)?)//   and return('NUM',$1);
    45      s/^([A-Za-z][A-Za-z0-9_]*)// and return('VAR',$1);
    46      s/^(.)//s                    and return($1,$1);
    47    }
    48  }
    49
    50  sub Run {
    51    my($self)=shift;
    52    my $debug = shift @ARGV;
    53    $debug = 0x1F if $debug;
    54    print &quot;Infix to postfix translator. Write an arithmetic expression: &quot;;
    55    $x = &lt;STDIN&gt;;
    56    $self-&gt;YYParse(
    57      yylex =&gt; \&amp;_Lexer,
    58      yyerror =&gt; \&amp;_Error,
    59      yydebug =&gt; $debug,
    60    );
    61  }
    62
    63   # Modulino
    64   __PACKAGE__-&gt;new()-&gt;Run unless caller();
</pre>
<p class="Pp">The file containing the <span class="Li">&quot;Eyapp&quot;</span>
    program must be compiled with <span class="Li">&quot;eyapp&quot;</span>:</p>
<p class="Pp"></p>
<pre>
 Parse-Eyapp/examples/eyapplanguageref$ eyapp Postfix.eyp
</pre>
<p class="Pp">Next, you have to write a client program:</p>
<p class="Pp"></p>
<pre>
  Parse-Eyapp/examples/eyapplanguageref$ cat -n usepostfix.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use Postfix;
     4
     5  my $parser = new Postfix();
     6  $parser-&gt;Run;
</pre>
<p class="Pp">Now we can run the client program:</p>
<p class="Pp"></p>
<pre>
 Parse-Eyapp/examples/eyapplanguageref$ usepostfix.pl
 Infix to postfix translator. Write an arithmetic expression: -(2*a-b*-3)
 2 a * b 3 NEG * - NEG
</pre>
<p class="Pp">An alternative is to use the generated module as a modulino,
    compiling the grammar using option
  <span class="Li">&quot;-b&quot;</span>:</p>
<p class="Pp"></p>
<pre>
  Parse-Eyapp/examples/eyapplanguageref$ eyapp -b '' Postfix.eyp
</pre>
<p class="Pp">This way, we can directly use the modulo as a script:</p>
<p class="Pp"></p>
<pre>
  Parse-Eyapp/examples/eyapplanguageref$ ./Postfix.pm
  Infix to postfix translator. Write an arithmetic expression: 2*3+b
  2 3 * b +
</pre>
<p class="Pp"><i>Default Actions, </i><i>%name</i><i> and
    </i><i>&quot;YYName&quot;</i><i></i></p>
<p class="Pp">In <span class="Li">&quot;eyapp&quot;</span> each production rule
    has a name. The name of a rule can be explicitly given by the programmer
    using the <span class="Li">%name</span> directive. For example, in the piece
    of code that follows the name <span class="Li">&quot;ASSIGN&quot;</span> is
    given to the rule <span class="Li">&quot;exp: VAR '=' exp&quot;</span>.</p>
<p class="Pp">When no explicit name is given the rule has an implicit name. The
    implicit name of a rule is shaped by concatenating the name of the syntactic
    variable on its left, an underscore and the ordinal number of the production
    rule <span class="Li">&quot;Lhs_#&quot;</span> as it appears in the
    <span class="Li">&quot;.output&quot;</span> file. Avoid giving names
    matching such pattern to production rules. The patterns
    <span class="Li">&quot;/${lhs}_\d+$/&quot;</span> where
    <span class="Li">&quot;${lhs}&quot;</span> is the name of the syntactic
    variable are reserved for internal use by
    <span class="Li">&quot;eyapp&quot;</span>.</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ cat -n Lhs.eyp
   1  # Lhs.eyp
   2
   3  %right  '='
   4  %left   '-' '+'
   5  %left   '*' '/'
   6  %left   NEG
   7
   8  %defaultaction {
   9    my $self = shift;
  10    my $name = $self-&gt;YYName();
  11    bless { children =&gt; [ grep {ref($_)} @_] }, $name;
  12  }
  13
  14  %%
  15  input:
  16              /* empty */
  17                { [] }
  18          |   input line
  19                {
  20                  push @{$_[1]}, $_[2] if defined($_[2]);
  21                  $_[1]
  22                }
  23  ;
  24
  25  line:     '\n'       { }
  26          | exp '\n'   {  $_[1] }
  27  ;
  28
  29  exp:
  30              NUM   { $_[1] }
  31          |   VAR   { $_[1] }
  32          |   %name ASSIGN
  33              VAR '=' exp
  34          |   %name PLUS
  35              exp '+' exp
  36          |   %name MINUS
  37              exp '-' exp
  38          |   %name TIMES
  39              exp '*' exp
  40          |   %name DIV
  41              exp '/' exp
  42          |   %name UMINUS
  43              '-' exp %prec NEG
  44          |  '(' exp ')'  { $_[2] }
  45  ;
</pre>
<p class="Pp">Inside a semantic action the name of the current rule can be
    recovered using the method <span class="Li">&quot;YYName&quot;</span> of the
    parser object.</p>
<p class="Pp">The default action (lines 8-12) computes as attribute of the left
    hand side a reference to an object blessed in the name of the rule. The
    object has an attribute <span class="Li">&quot;children&quot;</span> which
    is a reference to the list of children of the node. The call to
    <span class="Li">&quot;grep&quot;</span></p>
<p class="Pp"></p>
<pre>
  11    bless { children =&gt; [ grep {ref($_)} @_] }, $name;
</pre>
<p class="Pp">excludes children that aren't references. Notice that the lexical
    analyzer only returns references for the
    <span class="Li">&quot;NUM&quot;</span> and
    <span class="Li">&quot;VAR&quot;</span> terminals:</p>
<p class="Pp"></p>
<pre>
  59  sub _Lexer {
  60      my($parser)=shift;
  61
  62      for ($parser-&gt;YYData-&gt;{INPUT}) {
  63          s/^[ \t]+//;
  64          return('',undef) unless $_;
  65          s/^([0-9]+(?:\.[0-9]+)?)//
  66                  and return('NUM', bless { attr =&gt; $1}, 'NUM');
  67          s/^([A-Za-z][A-Za-z0-9_]*)//
  68                  and return('VAR',bless {attr =&gt; $1}, 'VAR');
  69          s/^(.)//s
  70                  and return($1, $1);
  71      }
  72      return('',undef);
  73  }
</pre>
<p class="Pp">follows the client program:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ cat -n uselhs.pl
       1  #!/usr/bin/perl -w
       2  use Lhs;
       3  use Data::Dumper;
       4
       5  $parser = new Lhs();
       6  my $tree = $parser-&gt;Run;
       7  $Data::Dumper::Indent = 1;
       8  if (defined($tree)) { print Dumper($tree); }
       9  else { print &quot;Cadena no valida\n&quot;; }
</pre>
<p class="Pp">When executed with input
    <span class="Li">&quot;a=(2+3)*b&quot;</span> the parser produces the
    following tree:</p>
<p class="Pp"></p>
<pre>
  ASSIGN(TIMES(PLUS(NUM[2],NUM[3]), VAR[b]))
</pre>
<p class="Pp">See the result of an execution:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ uselhs.pl
  a=(2+3)*b
  $VAR1 = [
    bless( {
      'children' =&gt; [
        bless( { 'attr' =&gt; 'a' }, 'VAR' ),
        bless( {
          'children' =&gt; [
            bless( {
              'children' =&gt; [
                bless( { 'attr' =&gt; '2' }, 'NUM' ),
                bless( { 'attr' =&gt; '3' }, 'NUM' )
              ]
            }, 'PLUS' ),
            bless( { 'attr' =&gt; 'b' }, 'VAR' )
          ]
        }, 'TIMES' )
      ]
    }, 'ASSIGN' )
  ];
</pre>
<p class="Pp">The name of a production rule can be changed at execution time.
    See the following example:</p>
<p class="Pp"></p>
<pre>
  29  exp:
  30              NUM   { $_[1] }
  31          |   VAR   { $_[1] }
  32          |   %name ASSIGN
  33              VAR '=' exp
  34          |   %name PLUS
  35              exp '+' exp
  36          |   %name MINUS
  37              exp '-' exp
  38                {
  39                  my $self = shift;
  40                  $self-&gt;YYName('SUBTRACT'); # rename it
  41                  $self-&gt;YYBuildAST(@_); # build the node
  42                }
  43          |   %name TIMES
  44              exp '*' exp
  45          |   %name DIV
  46              exp '/' exp
  47          |   %name UMINUS
  48              '-' exp %prec NEG
  49          |  '(' exp ')'  { $_[2] }
  50  ;
</pre>
<p class="Pp">When the client program is executed we can see the presence of the
    <span class="Li">&quot;SUBTRACT&quot;</span> nodes:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ useyynamedynamic.pl
  2-b
  $VAR1 = [
    bless( {
      'children' =&gt; [
        bless( {
          'attr' =&gt; '2'
        }, 'NUM' ),
        bless( {
          'attr' =&gt; 'b'
        }, 'VAR' )
      ]
    }, 'SUBTRACT' )
  ];
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Grammar_Reuse"><a class="permalink" href="#Grammar_Reuse">Grammar
  Reuse</a></h1>
<p class="Pp">Terence Parr in his talk &quot;Reuse of Grammars with Embedded
    Semantic Actions&quot; (see
    &lt;http://www.cs.vu.nl/icpc2008/docs/Parr.pdf&gt;) explains the
  problem:</p>
<p class="Pp"></p>
<pre>
 &quot;Because many applications deal with the same language, the reuse of a common
syntax specification with different semantics provides a number of advantages.
While the advantages are obvious, the mechanism for grammar reuse is not so
clear.  To go beyond syntax checking, grammars must have some way to specify
the translation or interpretation logic (the semantics). Unfortunately, the act
of specifying the semantics can lock a grammar into one specific application
since the grammar is often modified to suit (e.g., programmers often want to
embed unrestricted semantic actions).&quot;
</pre>
<p class="Pp">The incoming sections deal with different solutions to the
    problem.</p>
<section class="Ss">
<h2 class="Ss" id="An_Action_Method_for_each_Production"><a class="permalink" href="#An_Action_Method_for_each_Production">An
  Action Method for each Production</a></h2>
<p class="Pp">Default actions provide a way to write reusable grammars. Here is
    one solution:</p>
<p class="Pp"></p>
<pre>
  pl@europa:~/LEyapp/examples/recycle$ cat -n Noactions.eyp
     1  %left   '+'
     2  %left   '*'
     3
     4  %defaultaction {
     5    my $self = shift;
     6
     7    my $class = $self-&gt;YYPrefix;
     8    $class .=  $self-&gt;YYName;
     9
    10    $class-&gt;action(@_);
    11  }
    12
    13  %%
    14  exp:        %name NUM
    15                NUM
    16          |   %name PLUS
    17                exp '+' exp
    18          |   %name TIMES
    19                exp '*' exp
    20          |   '(' exp ')'
    21                { $_[2] }
    22  ;
    23
    24  %%
    25
    26  sub _Error {
    27    my($token)=$_[0]-&gt;YYCurval;
    28    my($what)= $token ? &quot;input: '$token'&quot; : &quot;end of input&quot;;
    29    my @expected = $_[0]-&gt;YYExpect();
    30
    31    local $&quot; = ', ';
    32    die &quot;Syntax error near $what. Expected one of these tokens: @expected\n&quot;;
    33  }
    34
    35
    36  my $x = '';
    37
    38  sub _Lexer {
    39    my($parser)=shift;
    40
    41    for ($x) {
    42      s/^\s+//;
    43      $_ eq '' and return('',undef);
    44
    45      s/^([0-9]+(?:\.[0-9]+)?)//   and return('NUM',$1);
    46      s/^([A-Za-z][A-Za-z0-9_]*)// and return('VAR',$1);
    47      s/^(.)//s                    and return($1,$1);
    48    }
    49  }
    50
    51  sub Run {
    52    my($self)=shift;
    53    $x = shift;
    54    my $debug = shift;
    55
    56    $self-&gt;YYParse(
    57      yylex    =&gt; \&amp;_Lexer,
    58      yyerror  =&gt; \&amp;_Error,
    59      yydebug  =&gt; $debug,
    60    );
    61  }
</pre>
<p class="Pp">This grammar is reused by the following program to implement a
    calculator: and a translator from infix to postfix:</p>
<p class="Pp"></p>
<pre>
  pl@europa:~/LEyapp/examples/recycle$ cat -n calcu_and_post.pl
     1  #!/usr/bin/perl
     2  use warnings;
     3  use Noactions;
     4
     5  sub Calc::NUM::action {
     6    return $_[1];
     7  }
     8
     9  sub Calc::PLUS::action {
    10    $_[1]+$_[3];
    11  }
    12
    13  sub Calc::TIMES::action {
    14    $_[1]*$_[3];
    15  }
    16
    17  sub Post::NUM::action {
    18    return $_[1];
    19  }
    20
    21  sub Post::PLUS::action {
    22    &quot;$_[1] $_[3] +&quot;;
    23  }
    24
    25  sub Post::TIMES::action {
    26    &quot;$_[1] $_[3] *&quot;;
    27  }
    28
    29  my $debug = shift || 0;
    30  my $pparser = Noactions-&gt;new( yyprefix =&gt; 'Post::');
    31  print &quot;Write an expression: &quot;;
    32  my $x = &lt;STDIN&gt;;
    33  my $t = $pparser-&gt;Run($x, $debug);
    34
    35  print &quot;$t\n&quot;;
    36
    37  my $cparser = Noactions-&gt;new(yyprefix =&gt; 'Calc::');
    38  my $e = $cparser-&gt;Run($x, $debug);
    39
    40  print &quot;$e\n&quot;;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Reusing_Grammars_Using_Inheritance"><a class="permalink" href="#Reusing_Grammars_Using_Inheritance">Reusing
  Grammars Using Inheritance</a></h2>
<p class="Pp">An method to reuse a grammar is via inheritance. The client
    inherits the generated parser module and expands it with methods that
    inherit or overwrite the actions. Here is an example. Initially we have this
    Eyapp grammar:</p>
<p class="Pp"></p>
<pre>
  pl@europa:~/LEyapp/examples/recycle$ cat -n NoacInh.eyp
     1  %left   '+'
     2  %left   '*'
     3
     4  %defaultaction {
     5    my $self = shift;
     6
     7    my $action = $self-&gt;YYName;
     8
     9    $self-&gt;$action(@_);
    10  }
    11
    12  %%
    13  exp:        %name NUM
    14                NUM
    15          |   %name PLUS
    16                exp '+' exp
    17          |   %name TIMES
    18                exp '*' exp
    19          |   '(' exp ')'
    20                { $_[2] }
    21  ;
    22
    23  %%
    24
    25  sub _Error {
    26    my($token)=$_[0]-&gt;YYCurval;
    27    my($what)= $token ? &quot;input: '$token'&quot; : &quot;end of input&quot;;
    28    my @expected = $_[0]-&gt;YYExpect();
    29
    30    local $&quot; = ', ';
    31    die &quot;Syntax error near $what. Expected one of these tokens: @expected\n&quot;;
    32  }
    33
    34
    35  my $x = '';
    36
    37  sub _Lexer {
    38    my($parser)=shift;
    39
    40    for ($x) {
    41      s/^\s+//;
    42      $_ eq '' and return('',undef);
    43
    44      s/^([0-9]+(?:\.[0-9]+)?)//   and return('NUM',$1);
    45      s/^([A-Za-z][A-Za-z0-9_]*)// and return('VAR',$1);
    46      s/^(.)//s                    and return($1,$1);
    47    }
    48  }
    49
    50  sub Run {
    51    my($self)=shift;
    52    $x = shift;
    53    my $debug = shift;
    54
    55    $self-&gt;YYParse(
    56      yylex =&gt; \&amp;_Lexer,
    57      yyerror =&gt; \&amp;_Error,
    58      yydebug =&gt; $debug,
    59    );
    60  }
</pre>
<p class="Pp">The following program defines two classes:
    <span class="Li">&quot;CalcActions&quot;</span> that implements the actions
    for the calculator and package
    <span class="Li">&quot;PostActions&quot;</span> that implements the actions
    for the infix to postfix translation. This way we have an example that
    reuses the former grammar twice:</p>
<p class="Pp"></p>
<pre>
  pl@europa:~/LEyapp/examples/recycle$ cat -n icalcu_and_ipost.pl
     1  #!/usr/bin/perl -w
     2  package CalcActions;
     3  use strict;
     4  use base qw{NoacInh};
     5
     6  sub NUM {
     7    return $_[1];
     8  }
     9
    10  sub PLUS {
    11    $_[1]+$_[3];
    12  }
    13
    14  sub TIMES {
    15    $_[1]*$_[3];
    16  }
    17
    18  package PostActions;
    19  use strict;
    20  use base qw{NoacInh};
    21
    22  sub NUM {
    23    return $_[1];
    24  }
    25
    26  sub PLUS {
    27    &quot;$_[1] $_[3] +&quot;;
    28  }
    29
    30  sub TIMES {
    31    &quot;$_[1] $_[3] *&quot;;
    32  }
    33
    34  package main;
    35  use strict;
    36
    37  my $calcparser = CalcActions-&gt;new();
    38  print &quot;Write an expression: &quot;;
    39  my $x = &lt;STDIN&gt;;
    40  my $e = $calcparser-&gt;Run($x);
    41
    42  print &quot;$e\n&quot;;
    43
    44  my $postparser = PostActions-&gt;new();
    45  my $p = $postparser-&gt;Run($x);
    46
    47  print &quot;$p\n&quot;;
</pre>
<p class="Pp">The subroutine used as default action in
    <span class="Li">&quot;NoacInh.eyp&quot;</span> is so useful that is packed
    as the Parse::Eyapp::Driver method
    <span class="Li">&quot;YYDelegateaction&quot;</span>.</p>
<p class="Pp">See files
    <span class="Li">&quot;examples/recycle/NoacYYDelegateaction.eyp&quot;</span>
    and
    <span class="Li">&quot;examples/recycle/icalcu_and_ipost_yydel.pl&quot;</span>
    for an example of use of
    <span class="Li">&quot;YYDelegateaction&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Reusing_Grammars_by_Dynamic_Substitution_of_Semantic_Actions"><a class="permalink" href="#Reusing_Grammars_by_Dynamic_Substitution_of_Semantic_Actions">Reusing
  Grammars by Dynamic Substitution of Semantic Actions</a></h2>
<p class="Pp">The methods <span class="Li">&quot;YYSetaction&quot;</span> and
    <span class="Li">&quot;YYAction&quot;</span> of the parser object provide a
    way to selectively substitute some actions of a given grammar. Let us
    consider once more a postfix to infix translator:</p>
<p class="Pp"></p>
<pre>
  pl@europa:~/LEyapp/examples/recycle$ cat -n PostfixWithActions.eyp
     1  # File PostfixWithActions.eyp
     2  %right  '='
     3  %left   '-' '+'
     4  %left   '*' '/'
     5  %left   NEG
     6
     7  %%
     8  line: $exp  { print &quot;$exp\n&quot; }
     9  ;
    10
    11  exp:        $NUM
    12                  { $NUM }
    13          |   $VAR
    14                  { $VAR }
    15          |   %name ASSIGN
    16                VAR.left '='exp.right
    17                  { &quot;$_[3] &amp;$_[1] ASSIGN&quot;; }
    18          |   %name PLUS
    19                exp.left '+'exp.right
    20                  { &quot;$_[1] $_[3] PLUS&quot;; }
    21          |   %name MINUS
    22                exp.left '-'exp.right
    23                  { &quot;$_[1] $_[3] MINUS&quot;; }
    24          |   %name TIMES
    25                exp.left '*'exp.right
    26                  { &quot;$_[1] $_[3] TIMES&quot;; }
    27          |   %name DIV
    28                exp.left '/'exp.right
    29                  { &quot;$_[1] $_[3] DIV&quot;; }
    30          |   %name NEG '-' $exp %prec NEG
    31                  { &quot;$exp NEG&quot; }
    32          |   '(' $exp ')'
    33                  { $exp }
    34  ;
    35
    36  %%
    37
    38  sub _Error {
    39    my($token)=$_[0]-&gt;YYCurval;
    40    my($what)= $token ? &quot;input: '$token'&quot; : &quot;end of input&quot;;
    41    my @expected = $_[0]-&gt;YYExpect();
    42
    43    local $&quot; = ', ';
    44    die &quot;Syntax error near $what. Expected one of these tokens: @expected\n&quot;;
    45  }
    46
    47  my $x;
    48
    49  sub _Lexer {
    50    my($parser)=shift;
    51
    52    for ($x) {
    53      s/^\s+//;
    54      $_ eq '' and return('',undef);
    55
    56      s/^([0-9]+(?:\.[0-9]+)?)//   and return('NUM',$1);
    57      s/^([A-Za-z][A-Za-z0-9_]*)// and return('VAR',$1);
    58      s/^(.)//s                    and return($1,$1);
    59    }
    60  }
    61
    62  sub Run {
    63    my($self)=shift;
    64    $x = shift;
    65    $self-&gt;YYParse( yylex =&gt; \&amp;_Lexer, yyerror =&gt; \&amp;_Error,
    66      #yydebug =&gt; 0xFF
    67    );
    68  }
</pre>
<p class="Pp">The program
    <span class="Li">&quot;rewritepostfixwithactions.pl&quot;</span> uses the
    former grammar to translate infix expressions to postfix expressions. It
    also implements a calculator reusing the grammar in
    <span class="Li">&quot;PostfixWithActions.eyp&quot;</span>. It does so using
    the <span class="Li">&quot;YYSetaction&quot;</span> method. The semantic
    actions for the productions named</p>
<ul class="Bl-bullet">
  <li>ASSIGN</li>
  <li>PLUS</li>
  <li>TIMES</li>
  <li>DIV</li>
  <li>NEG</li>
</ul>
<p class="Pp">are selectively substituted by the appropriate actions, while the
    other semantic actions remain unchanged:</p>
<p class="Pp"></p>
<pre>
  pl@europa:~/LEyapp/examples/recycle$ cat -n rewritepostfixwithactions.pl
     1  #!/usr/bin/perl
     2  use warnings;
     3  use PostfixWithActions;
     4
     5  my $debug = shift || 0;
     6  my $pparser = PostfixWithActions-&gt;new();
     7  print &quot;Write an expression: &quot;;
     8  my $x = &lt;STDIN&gt;;
     9
    10  # First, trasnlate to postfix ...
    11  $pparser-&gt;Run($x, $debug);
    12
    13  # And then selectively substitute
    14  # some semantic actions
    15  # to obtain an infix calculator ...
    16  my %s;            # symbol table
    17  $pparser-&gt;YYSetaction(
    18    ASSIGN =&gt; sub { $s{$_[1]} = $_[3] },
    19    PLUS   =&gt; sub { $_[1] + $_[3] },
    20    TIMES  =&gt; sub { $_[1] * $_[3] },
    21    DIV    =&gt; sub { $_[1] / $_[3] },
    22    NEG    =&gt; sub { -$_[2] },
    23  );
    24
    25  $pparser-&gt;Run($x, $debug);
</pre>
<p class="Pp">When running this program the output is:</p>
<p class="Pp"></p>
<pre>
  examples/recycle$ ./rewritepostfixwithactions.pl
  Write an expression: 2*3+4
  2 3 TIMES 4 PLUS
  10
  examples/recycle$ rewritepostfixwithactions.pl
  Write an expression: a = 2*(b = 3+5)
  2 3 5 PLUS &amp;b ASSIGN TIMES &amp;a ASSIGN
  16
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<ul class="Bl-bullet">
  <li>The project home is at &lt;http://code.google.com/p/parse-eyapp/&gt;. Use
      a subversion client to anonymously check out the latest project source
      code:
    <p class="Pp"></p>
    <pre>
   svn checkout http://parse-eyapp.googlecode.com/svn/trunk/ parse-eyapp-read-only
    </pre>
  </li>
  <li>The tutorial <i>Parsing Strings and Trees with</i>
      <span class="Li">&quot;Parse::Eyapp&quot;</span> (An Introduction to
      Compiler Construction in seven pages) in
      &lt;http://nereida.deioc.ull.es/~pl/eyapsimple/&gt;</li>
  <li>Parse::Eyapp, Parse::Eyapp::eyapplanguageref, Parse::Eyapp::debuggingtut,
      Parse::Eyapp::defaultactionsintro, Parse::Eyapp::translationschemestut,
      Parse::Eyapp::Driver, Parse::Eyapp::Node, Parse::Eyapp::YATW,
      Parse::Eyapp::Treeregexp, Parse::Eyapp::Scope, Parse::Eyapp::Base,
      Parse::Eyapp::datagenerationtut</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf&gt;</li>
  <li>perldoc eyapp,</li>
  <li>perldoc treereg,</li>
  <li>perldoc vgg,</li>
  <li>The Syntax Highlight file for vim at
      &lt;http://www.vim.org/scripts/script.php?script_id=2453&gt; and
      &lt;http://nereida.deioc.ull.es/~vim/&gt;</li>
  <li><i>Analisis Lexico y Sintactico</i>, (Notes for a course in compiler
      construction) by Casiano Rodriguez-Leon. Available at
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/&gt; Is the more complete
      and reliable source for Parse::Eyapp. However is in Spanish.</li>
  <li>Parse::Yapp,</li>
  <li>Man pages of <i>yacc</i>(1) and <i>bison</i>(1),
      &lt;http://www.delorie.com/gnu/docs/bison/bison.html&gt;</li>
  <li>Language::AttributeGrammar</li>
  <li>Parse::RecDescent.</li>
  <li>HOP::Parser</li>
  <li>HOP::Lexer</li>
  <li>ocamlyacc tutorial at
      &lt;http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex-ocamlyacc/ocamlyacc-tutorial/ocamlyacc-tutorial.html&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="REFERENCES"><a class="permalink" href="#REFERENCES">REFERENCES</a></h1>
<ul class="Bl-bullet">
  <li>The classic Dragon's book <i>Compilers: Principles, Techniques, and
      Tools</i> by Alfred V. Aho, Ravi Sethi and Jeffrey D. Ullman
      (Addison-Wesley 1986)</li>
  <li><i>CS2121: The Implementation and Power of Programming Languages</i> (See
      &lt;http://www.cs.man.ac.uk/~pjj&gt;,
      &lt;http://www.cs.man.ac.uk/~pjj/complang/g2lr.html&gt; and
      &lt;http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html&gt;) by Pete Jinks</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<ul class="Bl-bullet">
  <li>Hal Finkel &lt;http://www.halssoftware.com/&gt;</li>
  <li>G. Williams &lt;http://kasei.us/&gt;</li>
  <li>Thomas L. Shinnick &lt;http://search.cpan.org/~tshinnic/&gt;</li>
  <li>Frank Leray</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Casiano Rodriguez-Leon (casiano@ull.es)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGMENTS"><a class="permalink" href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a></h1>
<p class="Pp">This work has been supported by CEE (FEDER) and the Spanish
    Ministry of <i>Educacion y Ciencia</i> through <i>Plan Nacional I+D+I</i>
    number TIN2005-08818-C04-04 (ULL::OPLINK project
    &lt;http://www.oplink.ull.es/&gt;). Support from Gobierno de Canarias was
    through GC02210601 (<i>Grupos Consolidados</i>). The University of La Laguna
    has also supported my work in many ways and for many years.</p>
<p class="Pp">A large percentage of code is verbatim taken from Parse::Yapp
    1.05. The author of Parse::Yapp is Francois Desarmenien.</p>
<p class="Pp">I wish to thank Francois Desarmenien for his Parse::Yapp module,
    to my students at La Laguna and to the Perl Community. Thanks to the people
    who have contributed to improve the module (see &quot;CONTRIBUTORS&quot; in
    Parse::Eyapp). Thanks to Larry Wall for giving us Perl. Special thanks to
    Juana.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENCE_AND_COPYRIGHT"><a class="permalink" href="#LICENCE_AND_COPYRIGHT">LICENCE
  AND COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 2006-2008 Casiano Rodriguez-Leon (casiano@ull.es).
    All rights reserved.</p>
<p class="Pp">Parse::Yapp copyright is of Francois Desarmenien, all rights
    reserved. 1998-2001</p>
<p class="Pp">These modules are free software; you can redistribute it and/or
    modify it under the same terms as Perl itself. See perlartistic.</p>
<p class="Pp">This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. </p>
</section>
<section class="Sh">
<h1 class="Sh" id="POD_ERRORS"><a class="permalink" href="#POD_ERRORS">POD
  ERRORS</a></h1>
<p class="Pp">Hey! <b>The above document had some coding errors, which are
    explained below:</b></p>
<dl class="Bl-tag">
  <dt id="Around"><a class="permalink" href="#Around">Around line 232:</a></dt>
  <dd>Non-ASCII character seen before =encoding in 'valida\n&quot;;'. Assuming
      UTF-8</dd>
</dl>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2012-03-23</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Moose::Manual::MethodModifiers(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Moose::Manual::MethodModifiers(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Moose::Manual::MethodModifiers(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Moose::Manual::MethodModifiers - Moose's method modifiers</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 2.2012</p>
</section>
<section class="Sh">
<h1 class="Sh" id="WHAT_IS_A_METHOD_MODIFIER?"><a class="permalink" href="#WHAT_IS_A_METHOD_MODIFIER?">WHAT
  IS A METHOD MODIFIER?</a></h1>
<p class="Pp">Moose provides a feature called &quot;method modifiers&quot;. You
    can also think of these as &quot;hooks&quot; or &quot;advice&quot;.</p>
<p class="Pp">It's probably easiest to understand this feature with a few
    examples:</p>
<p class="Pp"></p>
<pre>  package Example;
  use Moose;
  sub foo {
      print &quot;    foo\n&quot;;
  }
  before 'foo' =&gt; sub { print &quot;about to call foo\n&quot;; };
  after 'foo'  =&gt; sub { print &quot;just called foo\n&quot;; };
  around 'foo' =&gt; sub {
      my $orig = shift;
      my $self = shift;
      print &quot;  I'm around foo\n&quot;;
      $self-&gt;$orig(@_);
      print &quot;  I'm still around foo\n&quot;;
  };
</pre>
<p class="Pp">Now if I call
    <span class="Li">&quot;Example-&gt;new-&gt;foo&quot;</span> I'll get the
    following output:</p>
<p class="Pp"></p>
<pre>  about to call foo
    I'm around foo
      foo
    I'm still around foo
  just called foo
</pre>
<p class="Pp">You probably could have figured that out from the names
    &quot;before&quot;, &quot;after&quot;, and &quot;around&quot;.</p>
<p class="Pp">Also, as you can see, the before modifiers come before around
    modifiers, and after modifiers come last.</p>
<p class="Pp">When there are multiple modifiers of the same type, the before and
    around modifiers run from the last added to the first, and after modifiers
    run from first added to last:</p>
<p class="Pp"></p>
<pre>   before 2
    before 1
     around 2
      around 1
       primary
      around 1
     around 2
    after 1
   after 2
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="WHY_USE_THEM?"><a class="permalink" href="#WHY_USE_THEM?">WHY
  USE THEM?</a></h1>
<p class="Pp">Method modifiers have many uses. They are often used in roles to
    alter the behavior of methods in the classes that consume the role. See
    Moose::Manual::Roles for more information about roles.</p>
<p class="Pp">Since modifiers are mostly useful in roles, some of the examples
    below are a bit artificial. They're intended to give you an idea of how
    modifiers work, but may not be the most natural usage.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BEFORE,_AFTER,_AND_AROUND"><a class="permalink" href="#BEFORE,_AFTER,_AND_AROUND">BEFORE,
  AFTER, AND AROUND</a></h1>
<p class="Pp">Method modifiers can be used to add behavior to methods without
    modifying the definition of those methods.</p>
<section class="Ss">
<h2 class="Ss" id="Before_and_after_Modifiers"><a class="permalink" href="#Before_and_after_Modifiers">Before
  and after Modifiers</a></h2>
<p class="Pp">Method modifiers can be used to add behavior to a method that
    Moose generates for you, such as an attribute accessor:</p>
<p class="Pp"></p>
<pre>  has 'size' =&gt; ( is =&gt; 'rw' );
  before 'size' =&gt; sub {
      my $self = shift;
      if (@_) {
          Carp::cluck('Someone is setting size');
      }
  };
</pre>
<p class="Pp">Another use for the before modifier would be to do some sort of
    prechecking on a method call. For example:</p>
<p class="Pp"></p>
<pre>  before 'size' =&gt; sub {
      my $self = shift;
      die 'Cannot set size while the person is growing'
          if @_ &amp;&amp; $self-&gt;is_growing;
  };
</pre>
<p class="Pp">This lets us implement logical checks that don't make sense as
    type constraints. In particular, they're useful for defining logical rules
    about an object's state changes.</p>
<p class="Pp">Similarly, an after modifier could be used for logging an action
    that was taken.</p>
<p class="Pp">Note that the return values of both before and after modifiers are
    ignored.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Around_modifiers"><a class="permalink" href="#Around_modifiers">Around
  modifiers</a></h2>
<p class="Pp">An around modifier is more powerful than either a before or after
    modifier. It can modify the arguments being passed to the original method,
    and you can even decide to simply not call the original method at all. You
    can also modify the return value with an around modifier.</p>
<p class="Pp">An around modifier receives the original method as its first
    argument, <i>then</i> the object, and finally any arguments passed to the
    method.</p>
<p class="Pp"></p>
<pre>  around 'size' =&gt; sub {
      my $orig = shift;
      my $self = shift;
      return $self-&gt;$orig()
          unless @_;
      my $size = shift;
      $size = $size / 2
          if $self-&gt;likes_small_things();
      return $self-&gt;$orig($size);
  };
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Wrapping_multiple_methods_at_once"><a class="permalink" href="#Wrapping_multiple_methods_at_once">Wrapping
  multiple methods at once</a></h2>
<p class="Pp"><span class="Li">&quot;before&quot;</span>,
    <span class="Li">&quot;after&quot;</span>, and
    <span class="Li">&quot;around&quot;</span> can also modify multiple methods
    at once. The simplest example of this is passing them as a list:</p>
<p class="Pp"></p>
<pre>  before [qw(foo bar baz)] =&gt; sub {
      warn &quot;something is being called!&quot;;
  };
</pre>
<p class="Pp">This will add a <span class="Li">&quot;before&quot;</span>
    modifier to each of the <span class="Li">&quot;foo&quot;</span>,
    <span class="Li">&quot;bar&quot;</span>, and
    <span class="Li">&quot;baz&quot;</span> methods in the current class, just
    as though a separate call to <span class="Li">&quot;before&quot;</span> was
    made for each of them. The list can be passed either as a bare list, or as
    an arrayref. Note that the name of the function being modified isn't passed
    in in any way; this syntax is only intended for cases where the function
    being modified doesn't actually matter. If the function name does matter,
    use something like this:</p>
<p class="Pp"></p>
<pre>  for my $func (qw(foo bar baz)) {
      before $func =&gt; sub {
          warn &quot;$func was called!&quot;;
      };
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_regular_expressions_to_select_methods_to_wrap"><a class="permalink" href="#Using_regular_expressions_to_select_methods_to_wrap">Using
  regular expressions to select methods to wrap</a></h2>
<p class="Pp">In addition, you can specify a regular expression to indicate the
    methods to wrap, like so:</p>
<p class="Pp"></p>
<pre>  after qr/^command_/ =&gt; sub {
      warn &quot;got a command&quot;;
  };
</pre>
<p class="Pp">This will match the regular expression against each method name
    returned by &quot;get_method_list&quot; in Class::MOP::Class, and add a
    modifier to each one that matches. The same caveats apply as above.</p>
<p class="Pp">Using regular expressions to determine methods to wrap is quite a
    bit more powerful than the previous alternatives, but it's also quite a bit
    more dangerous. Bear in mind that if your regular expression matches certain
    Perl and Moose reserved method names with a special meaning to Moose or
    Perl, such as <span class="Li">&quot;meta&quot;</span>,
    <span class="Li">&quot;new&quot;</span>,
    <span class="Li">&quot;BUILD&quot;</span>,
    <span class="Li">&quot;DESTROY&quot;</span>,
    <span class="Li">&quot;AUTOLOAD&quot;</span>, etc, this could cause
    unintended (and hard to debug) problems and is best avoided.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Execution_order_of_method_modifiers_and_inheritance"><a class="permalink" href="#Execution_order_of_method_modifiers_and_inheritance">Execution
  order of method modifiers and inheritance</a></h2>
<p class="Pp">When both a superclass and an inheriting class have the same
    method modifiers, the method modifiers of the inheriting class are wrapped
    around the method modifiers of the superclass, as the following example
    illustrates:</p>
<p class="Pp">Here is the parent class:</p>
<p class="Pp"></p>
<pre>  package Superclass;
  use Moose;
  sub rant { printf &quot;        RANTING!\n&quot; }
  before 'rant' =&gt; sub { printf &quot;    In %s before\n&quot;, __PACKAGE__ };
  after 'rant'  =&gt; sub { printf &quot;    In %s after\n&quot;,  __PACKAGE__ };
  around 'rant' =&gt; sub {
      my $orig = shift;
      my $self = shift;
      printf &quot;      In %s around before calling original\n&quot;, __PACKAGE__;
      $self-&gt;$orig;
      printf &quot;      In %s around after calling original\n&quot;, __PACKAGE__;
  };
  1;
</pre>
<p class="Pp">And the child class:</p>
<p class="Pp"></p>
<pre>  package Subclass;
  use Moose;
  extends 'Superclass';
  before 'rant' =&gt; sub { printf &quot;In %s before\n&quot;, __PACKAGE__ };
  after 'rant'  =&gt; sub { printf &quot;In %s after\n&quot;,  __PACKAGE__ };
  around 'rant' =&gt; sub {
      my $orig = shift;
      my $self = shift;
      printf &quot;  In %s around before calling original\n&quot;, __PACKAGE__;
      $self-&gt;$orig;
      printf &quot;  In %s around after calling original\n&quot;, __PACKAGE__;
  };
  1;
</pre>
<p class="Pp">And here's the output when we call the wrapped method
    (<span class="Li">&quot;Child-&gt;rant&quot;</span>):</p>
<p class="Pp"></p>
<pre>  % perl -MSubclass -e 'Subclass-&gt;new-&gt;rant'
  In Subclass before
    In Subclass around before calling original
      In Superclass before
        In Superclass around before calling original
          RANTING!
        In Superclass around after calling original
      In Superclass after
    In Subclass around after calling original
  In Subclass after
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="INNER_AND_AUGMENT"><a class="permalink" href="#INNER_AND_AUGMENT">INNER
  AND AUGMENT</a></h1>
<p class="Pp">Augment and inner are two halves of the same feature. The augment
    modifier provides a sort of inverted subclassing. You provide part of the
    implementation in a superclass, and then document that subclasses are
    expected to provide the rest.</p>
<p class="Pp">The superclass calls <span class="Li">&quot;inner()&quot;</span>,
    which then calls the <span class="Li">&quot;augment&quot;</span> modifier in
    the subclass:</p>
<p class="Pp"></p>
<pre>  package Document;
  use Moose;
  sub as_xml {
      my $self = shift;
      my $xml = &quot;&lt;document&gt;\n&quot;;
      $xml .= inner();
      $xml .= &quot;&lt;/document&gt;\n&quot;;
      return $xml;
  }
</pre>
<p class="Pp">Using <span class="Li">&quot;inner()&quot;</span> in this method
    makes it possible for one or more subclasses to then augment this method
    with their own specific implementation:</p>
<p class="Pp"></p>
<pre>  package Report;
  use Moose;
  extends 'Document';
  augment 'as_xml' =&gt; sub {
      my $self = shift;
      my $xml = &quot;  &lt;report&gt;\n&quot;;
      $xml .= inner();
      $xml .= &quot;  &lt;/report&gt;\n&quot;;
      return $xml;
  };
</pre>
<p class="Pp">When we call <span class="Li">&quot;as_xml&quot;</span> on a
    Report object, we get something like this:</p>
<p class="Pp"></p>
<pre>  &lt;document&gt;
    &lt;report&gt;
    &lt;/report&gt;
  &lt;/document&gt;
</pre>
<p class="Pp">But we also called <span class="Li">&quot;inner()&quot;</span> in
    <span class="Li">&quot;Report&quot;</span>, so we can continue subclassing
    and adding more content inside the document:</p>
<p class="Pp"></p>
<pre>  package Report::IncomeAndExpenses;
  use Moose;
  extends 'Report';
  augment 'as_xml' =&gt; sub {
      my $self = shift;
      my $xml = '    &lt;income&gt;' . $self-&gt;income . '&lt;/income&gt;';
      $xml .= &quot;\n&quot;;
      $xml .= '    &lt;expenses&gt;' . $self-&gt;expenses . '&lt;/expenses&gt;';
      $xml .= &quot;\n&quot;;
      $xml .= inner() || q{};
      return $xml;
  };
</pre>
<p class="Pp">Now our report has some content:</p>
<p class="Pp"></p>
<pre>  &lt;document&gt;
    &lt;report&gt;
      &lt;income&gt;$10&lt;/income&gt;
      &lt;expenses&gt;$8&lt;/expenses&gt;
    &lt;/report&gt;
  &lt;/document&gt;
</pre>
<p class="Pp">What makes this combination of
    <span class="Li">&quot;augment&quot;</span> and
    <span class="Li">&quot;inner()&quot;</span> special is that it allows us to
    have methods which are called from parent (least specific) to child (most
    specific). This inverts the normal inheritance pattern.</p>
<p class="Pp">Note that in
    <span class="Li">&quot;Report::IncomeAndExpenses&quot;</span> we call
    <span class="Li">&quot;inner()&quot;</span> again. If the object is an
    instance of <span class="Li">&quot;Report::IncomeAndExpenses&quot;</span>
    then this call is a no-op, and just returns false. It's a good idea to
    always call <span class="Li">&quot;inner()&quot;</span> to allow for future
    subclassing.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OVERRIDE_AND_SUPER"><a class="permalink" href="#OVERRIDE_AND_SUPER">OVERRIDE
  AND SUPER</a></h1>
<p class="Pp">Finally, Moose provides some simple sugar for Perl's built-in
    method overriding scheme. If you want to override a method from a parent
    class, you can do this with
  <span class="Li">&quot;override&quot;</span>:</p>
<p class="Pp"></p>
<pre>  package Employee;
  use Moose;
  extends 'Person';
  has 'job_title' =&gt; ( is =&gt; 'rw' );
  override 'display_name' =&gt; sub {
      my $self = shift;
      return super() . q{, } . $self-&gt;job_title();
  };
</pre>
<p class="Pp">The call to <span class="Li">&quot;super()&quot;</span> is almost
    the same as calling
    <span class="Li">&quot;$self-&gt;SUPER::display_name&quot;</span>. The
    difference is that the arguments passed to the superclass's method will
    always be the same as the ones passed to the method modifier, and cannot be
    changed.</p>
<p class="Pp">All arguments passed to
    <span class="Li">&quot;super()&quot;</span> are ignored, as are any changes
    made to <span class="Li">@_</span> before
    <span class="Li">&quot;super()&quot;</span> is called.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEMI-COLONS"><a class="permalink" href="#SEMI-COLONS">SEMI-COLONS</a></h1>
<p class="Pp">Because all of these method modifiers are implemented as Perl
    functions, you must always end the modifier declaration with a
  semi-colon:</p>
<p class="Pp"></p>
<pre>  after 'foo' =&gt; sub { };
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="EXCEPTIONS_AND_STACK_TRACES"><a class="permalink" href="#EXCEPTIONS_AND_STACK_TRACES">EXCEPTIONS
  AND STACK TRACES</a></h1>
<p class="Pp">An exception thrown in a
    <span class="Li">&quot;before&quot;</span> modifier will prevent the method
    it modifies from being called at all. An exception in an
    <span class="Li">&quot;around&quot;</span> modifier may prevent the modified
    method from being called, depending on how the
    <span class="Li">&quot;around&quot;</span> modifier is structured. An
    exception in an <span class="Li">&quot;after&quot;</span> modifier obviously
    cannot prevent the method it wraps from being called.</p>
<p class="Pp">Both <span class="Li">&quot;override&quot;</span> and
    <span class="Li">&quot;augment&quot;</span> are similar to
    <span class="Li">&quot;around&quot;</span> in that they can decide whether
    or not to call the method they modify before or after throwing an
  exception.</p>
<p class="Pp">From the caller's perspective, an exception in a method modifier
    will look like the method it called threw an exception. However, method
    modifiers are just standard Perl subroutines. This means that they end up on
    the stack in stack traces as an additional frame.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<p class="Pp">These method modification features do not work well with multiple
    inheritance, due to how method resolution is performed in Perl. Experiment
    with a test program to ensure your class hierarchy works as expected, or
    more preferably, don't use multiple inheritance (roles can help with
  this)!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Stevan Little &lt;stevan.little@iinteractive.com&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
  <li>Shawn M Moore &lt;code@sartak.org&gt;</li>
  <li>&#x05D9;&#x05D5;&#x05D1;&#x05DC; &#x05E7;&#x05D5;&#x05D2;'&#x05DE;&#x05DF;
      (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Florian Ragwitz &lt;rafl@debian.org&gt;</li>
  <li>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</li>
  <li>Chris Prather &lt;chris@prather.org&gt;</li>
  <li>Matt S Trout &lt;mst@shadowcat.co.uk&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2006 by Infinity Interactive,
  Inc.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-11-22</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

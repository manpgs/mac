<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Moose::Util::TypeConstraints(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Moose::Util::TypeConstraints(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Moose::Util::TypeConstraints(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Moose::Util::TypeConstraints - Type constraint system for
  Moose</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 2.1202</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
  use Moose::Util::TypeConstraints;

  subtype 'Natural',
      as 'Int',
      where { $_ &gt; 0 };

  subtype 'NaturalLessThanTen',
      as 'Natural',
      where { $_ &lt; 10 },
      message { &quot;This number ($_) is not less than ten!&quot; };

  coerce 'Num',
      from 'Str',
      via { 0+$_ };

  class_type 'DateTimeClass', { class =&gt; 'DateTime' };

  role_type 'Barks', { role =&gt; 'Some::Library::Role::Barks' };

  enum 'RGBColors', [qw(red green blue)];

  union 'StringOrArray', [qw( String Array )];

  no Moose::Util::TypeConstraints;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module provides Moose with the ability to create custom type
    constraints to be used in attribute definition.</p>
<section class="Ss">
<h2 class="Ss" id="Important_Caveat"><a class="permalink" href="#Important_Caveat">Important
  Caveat</a></h2>
<p class="Pp">This is <b>NOT</b> a type system for Perl 5. These are type
    constraints, and they are not used by Moose unless you tell it to. No type
    inference is performed, expressions are not typed, etc. etc. etc.</p>
<p class="Pp">A type constraint is at heart a small &quot;check if a value is
    valid&quot; function. A constraint can be associated with an attribute. This
    simplifies parameter validation, and makes your code clearer to read,
    because you can refer to constraints by name.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Slightly_Less_Important_Caveat"><a class="permalink" href="#Slightly_Less_Important_Caveat">Slightly
  Less Important Caveat</a></h2>
<p class="Pp">It is <b>always</b> a good idea to quote your type names.</p>
<p class="Pp">This prevents Perl from trying to execute the call as an indirect
    object call. This can be an issue when you have a subtype with the same name
    as a valid class.</p>
<p class="Pp">For instance:</p>
<p class="Pp"></p>
<pre>
  subtype DateTime =&gt; as Object =&gt; where { $_-&gt;isa('DateTime') };
</pre>
<p class="Pp">will <i>just work</i>, while this:</p>
<p class="Pp"></p>
<pre>
  use DateTime;
  subtype DateTime =&gt; as Object =&gt; where { $_-&gt;isa('DateTime') };
</pre>
<p class="Pp">will fail silently and cause many headaches. The simple way to
    solve this, as well as future proof your subtypes from classes which have
    yet to have been created, is to quote the type name:</p>
<p class="Pp"></p>
<pre>
  use DateTime;
  subtype 'DateTime', as 'Object', where { $_-&gt;isa('DateTime') };
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Default_Type_Constraints"><a class="permalink" href="#Default_Type_Constraints">Default
  Type Constraints</a></h2>
<p class="Pp">This module also provides a simple hierarchy for Perl 5 types,
    here is that hierarchy represented visually.</p>
<p class="Pp"></p>
<pre>
  Any
      Item
          Bool
          Maybe[`a]
          Undef
          Defined
              Value
                  Str
                      Num
                          Int
                      ClassName
                      RoleName
              Ref
                  ScalarRef[`a]
                  ArrayRef[`a]
                  HashRef[`a]
                  CodeRef
                  RegexpRef
                  GlobRef
                  FileHandle
                  Object
</pre>
<p class="Pp"><b>NOTE:</b> Any type followed by a type parameter
    <span class="Li">&quot;[`a]&quot;</span> can be parameterized, this means
    you can say:</p>
<p class="Pp"></p>
<pre>
  ArrayRef[Int]    # an array of integers
  HashRef[CodeRef] # a hash of str to CODE ref mappings
  ScalarRef[Int]   # a reference to an integer
  Maybe[Str]       # value may be a string, may be undefined
</pre>
<p class="Pp">If Moose finds a name in brackets that it does not recognize as an
    existing type, it assumes that this is a class name, for example
    <span class="Li">&quot;ArrayRef[DateTime]&quot;</span>.</p>
<p class="Pp"><b>NOTE:</b> Unless you parameterize a type, then it is invalid to
    include the square brackets. I.e.
    <span class="Li">&quot;ArrayRef[]&quot;</span> will be treated as a new type
    name, <i>not</i> as a parameterization of
    <span class="Li">&quot;ArrayRef&quot;</span>.</p>
<p class="Pp"><b>NOTE:</b> The <span class="Li">&quot;Undef&quot;</span> type
    constraint for the most part works correctly now, but edge cases may still
    exist, please use it sparingly.</p>
<p class="Pp"><b>NOTE:</b> The <span class="Li">&quot;ClassName&quot;</span>
    type constraint does a complex package existence check. This means that your
    class <b>must</b> be loaded for this type constraint to pass.</p>
<p class="Pp"><b>NOTE:</b> The <span class="Li">&quot;RoleName&quot;</span>
    constraint checks a string is a <i>package</i> <i>name</i> which is a role,
    like <span class="Li">'MyApp::Role::Comparable'</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Type_Constraint_Naming"><a class="permalink" href="#Type_Constraint_Naming">Type
  Constraint Naming</a></h2>
<p class="Pp">Type name declared via this module can only contain alphanumeric
    characters, colons (:), and periods (.).</p>
<p class="Pp">Since the types created by this module are global, it is suggested
    that you namespace your types just as you would namespace your modules. So
    instead of creating a <i>Color</i> type for your <b>My::Graphics</b> module,
    you would call the type <i>My::Graphics::Types::Color</i> instead.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Use_with_Other_Constraint_Modules"><a class="permalink" href="#Use_with_Other_Constraint_Modules">Use
  with Other Constraint Modules</a></h2>
<p class="Pp">This module can play nicely with other constraint modules with
    some slight tweaking. The <span class="Li">&quot;where&quot;</span> clause
    in types is expected to be a <span class="Li">&quot;CODE&quot;</span>
    reference which checks its first argument and returns a boolean. Since most
    constraint modules work in a similar way, it should be simple to adapt them
    to work with Moose.</p>
<p class="Pp">For instance, this is how you could use it with
    Declare::Constraints::Simple to declare a completely new type.</p>
<p class="Pp"></p>
<pre>
  type 'HashOfArrayOfObjects',
      where {
          IsHashRef(
              -keys   =&gt; HasLength,
              -values =&gt; IsArrayRef(IsObject)
          )-&gt;(@_);
      };
</pre>
<p class="Pp">For more examples see the <i>t/examples/example_w_DCS.t</i> test
    file.</p>
<p class="Pp">Here is an example of using Test::Deep and its non-test related
    <span class="Li">&quot;eq_deeply&quot;</span> function.</p>
<p class="Pp"></p>
<pre>
  type 'ArrayOfHashOfBarsAndRandomNumbers',
      where {
          eq_deeply($_,
              array_each(subhashof({
                  bar           =&gt; isa('Bar'),
                  random_number =&gt; ignore()
              })))
        };
</pre>
<p class="Pp">For a complete example see the
    <i>t/examples/example_w_TestDeep.t</i> test file.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Error_messages"><a class="permalink" href="#Error_messages">Error
  messages</a></h2>
<p class="Pp">Type constraints can also specify custom error messages, for when
    they fail to validate. This is provided as just another coderef, which
    receives the invalid value in <span class="Li">$_</span>, as in:</p>
<p class="Pp"></p>
<pre>
  subtype 'PositiveInt',
       as 'Int',
       where { $_ &gt; 0 },
       message { &quot;$_ is not a positive integer!&quot; };
</pre>
<p class="Pp">If no message is specified, a default message will be used, which
    indicates which type constraint was being used and what value failed. If
    Devel::PartialDump (version 0.14 or higher) is installed, it will be used to
    display the invalid value, otherwise it will just be printed as is.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTIONS"><a class="permalink" href="#FUNCTIONS">FUNCTIONS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Type_Constraint_Constructors"><a class="permalink" href="#Type_Constraint_Constructors">Type
  Constraint Constructors</a></h2>
<p class="Pp">The following functions are used to create type constraints. They
    will also register the type constraints your create in a global registry
    that is used to look types up by name.</p>
<p class="Pp">See the &quot;SYNOPSIS&quot; for an example of how to use
  these.</p>
<dl class="Bl-tag">
  <dt id="subtype"><a class="permalink" href="#subtype"><b>subtype 'Name', as
    'Parent', where { } ...</b></a></dt>
  <dd>This creates a named subtype.
    <p class="Pp">If you provide a parent that Moose does not recognize, it will
        automatically create a new class type constraint for this name.</p>
    <p class="Pp">When creating a named type, the
        <span class="Li">&quot;subtype&quot;</span> function should either be
        called with the sugar helpers
        (<span class="Li">&quot;where&quot;</span>,
        <span class="Li">&quot;message&quot;</span>, etc), or with a name and a
        hashref of parameters:</p>
    <p class="Pp"></p>
    <pre>
 subtype( 'Foo', { where =&gt; ..., message =&gt; ... } );
    </pre>
    <p class="Pp">The valid hashref keys are
        <span class="Li">&quot;as&quot;</span> (the parent),
        <span class="Li">&quot;where&quot;</span>,
        <span class="Li">&quot;message&quot;</span>, and
        <span class="Li">&quot;inline_as&quot;</span>.</p>
  </dd>
  <dt id="subtype~2"><a class="permalink" href="#subtype~2"><b>subtype as
    'Parent', where { } ...</b></a></dt>
  <dd>This creates an unnamed subtype and will return the type constraint
      meta-object, which will be an instance of Moose::Meta::TypeConstraint.
    <p class="Pp">When creating an anonymous type, the
        <span class="Li">&quot;subtype&quot;</span> function should either be
        called with the sugar helpers
        (<span class="Li">&quot;where&quot;</span>,
        <span class="Li">&quot;message&quot;</span>, etc), or with just a
        hashref of parameters:</p>
    <p class="Pp"></p>
    <pre>
 subtype( { where =&gt; ..., message =&gt; ... } );
    </pre>
  </dd>
  <dt id="class_type"><a class="permalink" href="#class_type"><b>class_type
    ($class, ?$options)</b></a></dt>
  <dd>Creates a new subtype of <span class="Li">&quot;Object&quot;</span> with
      the name <span class="Li">$class</span> and the metaclass
      Moose::Meta::TypeConstraint::Class.
    <p class="Pp"></p>
    <pre>
  # Create a type called 'Box' which tests for objects which -&gt;isa('Box')
  class_type 'Box';
    </pre>
    <p class="Pp">By default, the name of the type and the name of the class are
        the same, but you can specify both separately.</p>
    <p class="Pp"></p>
    <pre>
  # Create a type called 'Box' which tests for objects which -&gt;isa('ObjectLibrary::Box');
  class_type 'Box', { class =&gt; 'ObjectLibrary::Box' };
    </pre>
  </dd>
  <dt id="role_type"><a class="permalink" href="#role_type"><b>role_type ($role,
    ?$options)</b></a></dt>
  <dd>Creates a <span class="Li">&quot;Role&quot;</span> type constraint with
      the name <span class="Li">$role</span> and the metaclass
      Moose::Meta::TypeConstraint::Role.
    <p class="Pp"></p>
    <pre>
  # Create a type called 'Walks' which tests for objects which -&gt;does('Walks')
  role_type 'Walks';
    </pre>
    <p class="Pp">By default, the name of the type and the name of the role are
        the same, but you can specify both separately.</p>
    <p class="Pp"></p>
    <pre>
  # Create a type called 'Walks' which tests for objects which -&gt;does('MooseX::Role::Walks');
  role_type 'Walks', { role =&gt; 'MooseX::Role::Walks' };
    </pre>
  </dd>
  <dt id="maybe_type"><a class="permalink" href="#maybe_type"><b>maybe_type
    ($type)</b></a></dt>
  <dd>Creates a type constraint for either
      <span class="Li">&quot;undef&quot;</span> or something of the given
    type.</dd>
  <dt id="duck_type"><a class="permalink" href="#duck_type"><b>duck_type ($name,
    \@methods)</b></a></dt>
  <dd>This will create a subtype of Object and test to make sure the value
      <span class="Li">&quot;can()&quot;</span> do the methods in
      <span class="Li">&quot;\@methods&quot;</span>.
    <p class="Pp">This is intended as an easy way to accept non-Moose objects
        that provide a certain interface. If you're using Moose classes, we
        recommend that you use a
        <span class="Li">&quot;requires&quot;</span>-only Role instead.</p>
  </dd>
  <dt id="duck_type~2"><a class="permalink" href="#duck_type~2"><b>duck_type
    (\@methods)</b></a></dt>
  <dd>If passed an ARRAY reference as the only parameter instead of the
      <span class="Li">$name</span>,
      <span class="Li">&quot;\@methods&quot;</span> pair, this will create an
      unnamed duck type. This can be used in an attribute definition like so:
    <p class="Pp"></p>
    <pre>
  has 'cache' =&gt; (
      is  =&gt; 'ro',
      isa =&gt; duck_type( [qw( get_set )] ),
  );
    </pre>
  </dd>
  <dt id="enum"><a class="permalink" href="#enum"><b>enum ($name,
    \@values)</b></a></dt>
  <dd>This will create a basic subtype for a given set of strings. The resulting
      constraint will be a subtype of <span class="Li">&quot;Str&quot;</span>
      and will match any of the items in
      <span class="Li">&quot;\@values&quot;</span>. It is case sensitive. See
      the &quot;SYNOPSIS&quot; for a simple example.
    <p class="Pp"><b>NOTE:</b> This is not a true proper enum type, it is simply
        a convenient constraint builder.</p>
  </dd>
  <dt id="enum~2"><a class="permalink" href="#enum~2"><b>enum
    (\@values)</b></a></dt>
  <dd>If passed an ARRAY reference as the only parameter instead of the
      <span class="Li">$name</span>,
      <span class="Li">&quot;\@values&quot;</span> pair, this will create an
      unnamed enum. This can then be used in an attribute definition like so:
    <p class="Pp"></p>
    <pre>
  has 'sort_order' =&gt; (
      is  =&gt; 'ro',
      isa =&gt; enum([qw[ ascending descending ]]),
  );
    </pre>
  </dd>
  <dt id="union"><a class="permalink" href="#union"><b>union ($name,
    \@constraints)</b></a></dt>
  <dd>This will create a basic subtype where any of the provided constraints may
      match in order to satisfy this constraint.</dd>
  <dt id="union~2"><a class="permalink" href="#union~2"><b>union
    (\@constraints)</b></a></dt>
  <dd>If passed an ARRAY reference as the only parameter instead of the
      <span class="Li">$name</span>,
      <span class="Li">&quot;\@constraints&quot;</span> pair, this will create
      an unnamed union. This can then be used in an attribute definition like
      so:
    <p class="Pp"></p>
    <pre>
  has 'items' =&gt; (
      is =&gt; 'ro',
      isa =&gt; union([qw[ Str ArrayRef ]]),
  );
    </pre>
    <p class="Pp">This is similar to the existing string union:</p>
    <p class="Pp"></p>
    <pre>
  isa =&gt; 'Str|ArrayRef'
    </pre>
    <p class="Pp">except that it supports anonymous elements as child
        constraints:</p>
    <p class="Pp"></p>
    <pre>
  has 'color' =&gt; (
    isa =&gt; 'ro',
    isa =&gt; union([ 'Int',  enum([qw[ red green blue ]]) ]),
  );
    </pre>
  </dd>
  <dt id="as"><a class="permalink" href="#as"><b>as 'Parent'</b></a></dt>
  <dd>This is just sugar for the type constraint construction syntax.
    <p class="Pp">It takes a single argument, which is the name of a parent
        type.</p>
  </dd>
  <dt id="where"><a class="permalink" href="#where"><b>where { ...
    }</b></a></dt>
  <dd>This is just sugar for the type constraint construction syntax.
    <p class="Pp">It takes a subroutine reference as an argument. When the type
        constraint is tested, the reference is run with the value to be tested
        in <span class="Li">$_</span>. This reference should return true or
        false to indicate whether or not the constraint check passed.</p>
  </dd>
  <dt id="message"><a class="permalink" href="#message"><b>message { ...
    }</b></a></dt>
  <dd>This is just sugar for the type constraint construction syntax.
    <p class="Pp">It takes a subroutine reference as an argument. When the type
        constraint fails, then the code block is run with the value provided in
        <span class="Li">$_</span>. This reference should return a string, which
        will be used in the text of the exception thrown.</p>
  </dd>
  <dt id="inline_as"><a class="permalink" href="#inline_as"><b>inline_as { ...
    }</b></a></dt>
  <dd>This can be used to define a &quot;hand optimized&quot; inlinable version
      of your type constraint.
    <p class="Pp">You provide a subroutine which will be called <i>as a
        method</i> on a Moose::Meta::TypeConstraint object. It will receive a
        single parameter, the name of the variable to check, typically something
        like <span class="Li">&quot;$_&quot;</span> or
        <span class="Li">&quot;$_[0]&quot;</span>.</p>
    <p class="Pp">The subroutine should return a code string suitable for
        inlining. You can assume that the check will be wrapped in parentheses
        when it is inlined.</p>
    <p class="Pp">The inlined code should include any checks that your type's
        parent types do. If your parent type constraint defines its own
        inlining, you can simply use that to avoid repeating code. For example,
        here is the inlining code for the
        <span class="Li">&quot;Value&quot;</span> type, which is a subtype of
        <span class="Li">&quot;Defined&quot;</span>:</p>
    <p class="Pp"></p>
    <pre>
    sub {
        $_[0]-&gt;parent()-&gt;_inline_check($_[1])
        . ' &amp;&amp; !ref(' . $_[1] . ')'
    }
    </pre>
  </dd>
  <dt id="type"><a class="permalink" href="#type"><b>type 'Name', where { }
    ...</b></a></dt>
  <dd>This creates a base type, which has no parent.
    <p class="Pp">The <span class="Li">&quot;type&quot;</span> function should
        either be called with the sugar helpers
        (<span class="Li">&quot;where&quot;</span>,
        <span class="Li">&quot;message&quot;</span>, etc), or with a name and a
        hashref of parameters:</p>
    <p class="Pp"></p>
    <pre>
  type( 'Foo', { where =&gt; ..., message =&gt; ... } );
    </pre>
    <p class="Pp">The valid hashref keys are
        <span class="Li">&quot;where&quot;</span>,
        <span class="Li">&quot;message&quot;</span>, and
        <span class="Li">&quot;inlined_as&quot;</span>.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Type_Constraint_Utilities"><a class="permalink" href="#Type_Constraint_Utilities">Type
  Constraint Utilities</a></h2>
<dl class="Bl-tag">
  <dt id="match_on_type"><a class="permalink" href="#match_on_type"><b>match_on_type
    </b><b>$value</b><b> =&gt; ( </b><b><i>$type</i></b><b> =&gt; \&amp;action,
    ... ?\&amp;default )</b></a></dt>
  <dd>This is a utility function for doing simple type based dispatching similar
      to match/case in OCaml and case/of in Haskell. It is not as featureful as
      those languages, nor does not it support any kind of automatic
      destructuring bind. Here is a simple Perl pretty printer dispatching over
      the core Moose types.
    <p class="Pp"></p>
    <pre>
  sub ppprint {
      my $x = shift;
      match_on_type $x =&gt; (
          HashRef =&gt; sub {
              my $hash = shift;
              '{ '
                  . (
                  join &quot;, &quot; =&gt; map { $_ . ' =&gt; ' . ppprint( $hash-&gt;{$_} ) }
                      sort keys %$hash
                  ) . ' }';
          },
          ArrayRef =&gt; sub {
              my $array = shift;
              '[ ' . ( join &quot;, &quot; =&gt; map { ppprint($_) } @$array ) . ' ]';
          },
          CodeRef   =&gt; sub {'sub { ... }'},
          RegexpRef =&gt; sub { 'qr/' . $_ . '/' },
          GlobRef   =&gt; sub { '*' . B::svref_2object($_)-&gt;NAME },
          Object    =&gt; sub { $_-&gt;can('to_string') ? $_-&gt;to_string : $_ },
          ScalarRef =&gt; sub { '\\' . ppprint( ${$_} ) },
          Num       =&gt; sub {$_},
          Str       =&gt; sub { '&quot;' . $_ . '&quot;' },
          Undef     =&gt; sub {'undef'},
          =&gt; sub { die &quot;I don't know what $_ is&quot; }
      );
  }
    </pre>
    <p class="Pp">Or a simple JSON serializer:</p>
    <p class="Pp"></p>
    <pre>
  sub to_json {
      my $x = shift;
      match_on_type $x =&gt; (
          HashRef =&gt; sub {
              my $hash = shift;
              '{ '
                  . (
                  join &quot;, &quot; =&gt;
                      map { '&quot;' . $_ . '&quot; : ' . to_json( $hash-&gt;{$_} ) }
                      sort keys %$hash
                  ) . ' }';
          },
          ArrayRef =&gt; sub {
              my $array = shift;
              '[ ' . ( join &quot;, &quot; =&gt; map { to_json($_) } @$array ) . ' ]';
          },
          Num   =&gt; sub {$_},
          Str   =&gt; sub { '&quot;' . $_ . '&quot;' },
          Undef =&gt; sub {'null'},
          =&gt; sub { die &quot;$_ is not acceptable json type&quot; }
      );
  }
    </pre>
    <p class="Pp">The matcher is done by mapping a <span class="Li">$type</span>
        to an <span class="Li">&quot;\&amp;action&quot;</span>. The
        <span class="Li">$type</span> can be either a string type or a
        Moose::Meta::TypeConstraint object, and
        <span class="Li">&quot;\&amp;action&quot;</span> is a subroutine
        reference. This function will dispatch on the first match for
        <span class="Li">$value</span>. It is possible to have a catch-all by
        providing an additional subroutine reference as the final argument to
        <span class="Li">&quot;match_on_type&quot;</span>.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Type_Coercion_Constructors"><a class="permalink" href="#Type_Coercion_Constructors">Type
  Coercion Constructors</a></h2>
<p class="Pp">You can define coercions for type constraints, which allow you to
    automatically transform values to something valid for the type constraint.
    If you ask your accessor to coerce, then Moose will run the type-coercion
    code first, followed by the type constraint check. This feature should be
    used carefully as it is very powerful and could easily take off a limb if
    you are not careful.</p>
<p class="Pp">See the &quot;SYNOPSIS&quot; for an example of how to use
  these.</p>
<dl class="Bl-tag">
  <dt id="coerce"><a class="permalink" href="#coerce"><b>coerce 'Name', from
    'OtherName', via { ... }</b></a></dt>
  <dd>This defines a coercion from one type to another. The
      <span class="Li">&quot;Name&quot;</span> argument is the type you are
      coercing <i>to</i>.
    <p class="Pp">To define multiple coercions, supply more sets of from/via
        pairs:</p>
    <p class="Pp"></p>
    <pre>
  coerce 'Name',
    from 'OtherName', via { ... },
    from 'ThirdName', via { ... };
    </pre>
  </dd>
  <dt id="from"><a class="permalink" href="#from"><b>from
    'OtherName'</b></a></dt>
  <dd>This is just sugar for the type coercion construction syntax.
    <p class="Pp">It takes a single type name (or type object), which is the
        type being coerced <i>from</i>.</p>
  </dd>
  <dt id="via"><a class="permalink" href="#via"><b>via { ... }</b></a></dt>
  <dd>This is just sugar for the type coercion construction syntax.
    <p class="Pp">It takes a subroutine reference. This reference will be called
        with the value to be coerced in <span class="Li">$_</span>. It is
        expected to return a new value of the proper type for the coercion.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Creating_and_Finding_Type_Constraints"><a class="permalink" href="#Creating_and_Finding_Type_Constraints">Creating
  and Finding Type Constraints</a></h2>
<p class="Pp">These are additional functions for creating and finding type
    constraints. Most of these functions are not available for importing. The
    ones that are importable as specified.</p>
<dl class="Bl-tag">
  <dt id="find_type_constraint($type_name)"><a class="permalink" href="#find_type_constraint($type_name)"><b>find_type_constraint($type_name)</b></a></dt>
  <dd>This function can be used to locate the Moose::Meta::TypeConstraint object
      for a named type.
    <p class="Pp">This function is importable.</p>
  </dd>
  <dt id="register_type_constraint($type_object)"><a class="permalink" href="#register_type_constraint($type_object)"><b>register_type_constraint($type_object)</b></a></dt>
  <dd>This function will register a Moose::Meta::TypeConstraint with the global
      type registry.
    <p class="Pp">This function is importable.</p>
  </dd>
  <dt id="normalize_type_constraint_name($type_constraint_name)"><a class="permalink" href="#normalize_type_constraint_name($type_constraint_name)"><b>normalize_type_constraint_name($type_constraint_name)</b></a></dt>
  <dd>This method takes a type constraint name and returns the normalized form.
      This removes any whitespace in the string.</dd>
  <dt id="create_type_constraint_union($pipe_separated_types"><a class="permalink" href="#create_type_constraint_union($pipe_separated_types"><b>create_type_constraint_union($pipe_separated_types
    | </b><b>@type_constraint_names</b><b>)</b></a></dt>
  <dd></dd>
  <dt id="create_named_type_constraint_union($name,"><a class="permalink" href="#create_named_type_constraint_union($name,"><b>create_named_type_constraint_union($name,
    </b><b>$pipe_separated_types</b><b> |
    </b><b><i>@type_constraint_names</i></b><b>)</b></a></dt>
  <dd>This can take a union type specification like
      <span class="Li">'Int|ArrayRef[Int]'</span>, or a list of names. It
      returns a new Moose::Meta::TypeConstraint::Union object.</dd>
  <dt id="create_parameterized_type_constraint($type_name)"><a class="permalink" href="#create_parameterized_type_constraint($type_name)"><b>create_parameterized_type_constraint($type_name)</b></a></dt>
  <dd>Given a <span class="Li">$type_name</span> in the form of
      <span class="Li">'BaseType[ContainerType]'</span>, this will create a new
      Moose::Meta::TypeConstraint::Parameterized object. The
      <span class="Li">&quot;BaseType&quot;</span> must already exist as a
      parameterizable type.</dd>
  <dt id="create_class_type_constraint($class,"><a class="permalink" href="#create_class_type_constraint($class,"><b>create_class_type_constraint($class,
    </b><b>$options</b><b>)</b></a></dt>
  <dd>Given a class name this function will create a new
      Moose::Meta::TypeConstraint::Class object for that class name.
    <p class="Pp">The <span class="Li">$options</span> is a hash reference that
        will be passed to the Moose::Meta::TypeConstraint::Class constructor (as
        a hash).</p>
  </dd>
  <dt id="create_role_type_constraint($role,"><a class="permalink" href="#create_role_type_constraint($role,"><b>create_role_type_constraint($role,
    </b><b>$options</b><b>)</b></a></dt>
  <dd>Given a role name this function will create a new
      Moose::Meta::TypeConstraint::Role object for that role name.
    <p class="Pp">The <span class="Li">$options</span> is a hash reference that
        will be passed to the Moose::Meta::TypeConstraint::Role constructor (as
        a hash).</p>
  </dd>
  <dt id="create_enum_type_constraint($name,"><a class="permalink" href="#create_enum_type_constraint($name,"><b>create_enum_type_constraint($name,
    </b><b>$values</b><b>)</b></a></dt>
  <dd>Given a enum name this function will create a new
      Moose::Meta::TypeConstraint::Enum object for that enum name.</dd>
  <dt id="create_duck_type_constraint($name,"><a class="permalink" href="#create_duck_type_constraint($name,"><b>create_duck_type_constraint($name,
    </b><b>$methods</b><b>)</b></a></dt>
  <dd>Given a duck type name this function will create a new
      Moose::Meta::TypeConstraint::DuckType object for that enum name.</dd>
  <dt id="find_or_parse_type_constraint($type_name)"><a class="permalink" href="#find_or_parse_type_constraint($type_name)"><b>find_or_parse_type_constraint($type_name)</b></a></dt>
  <dd>Given a type name, this first attempts to find a matching constraint in
      the global registry.
    <p class="Pp">If the type name is a union or parameterized type, it will
        create a new object of the appropriate, but if given a
        &quot;regular&quot; type that does not yet exist, it simply returns
        false.</p>
    <p class="Pp">When given a union or parameterized type, the member or base
        type must already exist.</p>
    <p class="Pp">If it creates a new union or parameterized type, it will add
        it to the global registry.</p>
  </dd>
  <dt id="find_or_create_isa_type_constraint($type_name)"><a class="permalink" href="#find_or_create_isa_type_constraint($type_name)"><b>find_or_create_isa_type_constraint($type_name)</b></a></dt>
  <dd></dd>
  <dt id="find_or_create_does_type_constraint($type_name)"><a class="permalink" href="#find_or_create_does_type_constraint($type_name)"><b>find_or_create_does_type_constraint($type_name)</b></a></dt>
  <dd>These functions will first call
      <span class="Li">&quot;find_or_parse_type_constraint&quot;</span>. If that
      function does not return a type, a new type object will be created.
    <p class="Pp">The <span class="Li">&quot;isa&quot;</span> variant will use
        <span class="Li">&quot;create_class_type_constraint&quot;</span> and the
        <span class="Li">&quot;does&quot;</span> variant will use
        <span class="Li">&quot;create_role_type_constraint&quot;</span>.</p>
  </dd>
  <dt id="get_type_constraint_registry"><a class="permalink" href="#get_type_constraint_registry"><b>get_type_constraint_registry</b></a></dt>
  <dd>Returns the Moose::Meta::TypeConstraint::Registry object which keeps track
      of all type constraints.</dd>
  <dt id="list_all_type_constraints"><a class="permalink" href="#list_all_type_constraints"><b>list_all_type_constraints</b></a></dt>
  <dd>This will return a list of type constraint names in the global registry.
      You can then fetch the actual type object using
      <span class="Li">&quot;find_type_constraint($type_name)&quot;</span>.</dd>
  <dt id="list_all_builtin_type_constraints"><a class="permalink" href="#list_all_builtin_type_constraints"><b>list_all_builtin_type_constraints</b></a></dt>
  <dd>This will return a list of builtin type constraints, meaning those which
      are defined in this module. See the &quot;Default Type Constraints&quot;
      section for a complete list.</dd>
  <dt id="export_type_constraints_as_functions"><a class="permalink" href="#export_type_constraints_as_functions"><b>export_type_constraints_as_functions</b></a></dt>
  <dd>This will export all the current type constraints as functions into the
      caller's namespace (<span class="Li">&quot;Int()&quot;</span>,
      <span class="Li">&quot;Str()&quot;</span>, etc). Right now, this is mostly
      used for testing, but it might prove useful to others.</dd>
  <dt id="get_all_parameterizable_types"><a class="permalink" href="#get_all_parameterizable_types"><b>get_all_parameterizable_types</b></a></dt>
  <dd>This returns all the parameterizable types that have been registered, as a
      list of type objects.</dd>
  <dt id="add_parameterizable_type($type)"><a class="permalink" href="#add_parameterizable_type($type)"><b>add_parameterizable_type($type)</b></a></dt>
  <dd>Adds <span class="Li">$type</span> to the list of parameterizable
    types</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">See &quot;BUGS&quot; in Moose for details on reporting bugs.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Stevan Little &lt;stevan.little@iinteractive.com&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
  <li>Shawn M Moore &lt;code@sartak.org&gt;</li>
  <li>XXXX XXX'XX (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Florian Ragwitz &lt;rafl@debian.org&gt;</li>
  <li>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</li>
  <li>Chris Prather &lt;chris@prather.org&gt;</li>
  <li>Matt S Trout &lt;mst@shadowcat.co.uk&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2006 by Infinity Interactive,
  Inc..</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-19</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Moose::Cookbook::Basics::Company_Subtypes(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Moose::Cookbook::Basics::Company_Subtypes(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Moose::Cookbook::Basics::Company_Subtypes(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Moose::Cookbook::Basics::Company_Subtypes - Demonstrates the use
    of subtypes and how to model classes related to companies, people,
    employees, etc.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 2.2012</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  package Address;
  use Moose;
  use Moose::Util::TypeConstraints;
  use Locale::US;
  use Regexp::Common 'zip';
  my $STATES = Locale::US-&gt;new;
  subtype 'USState'
      =&gt; as Str
      =&gt; where {
             (    exists $STATES-&gt;{code2state}{ uc($_) }
               || exists $STATES-&gt;{state2code}{ uc($_) } );
         };
  subtype 'USZipCode'
      =&gt; as Value
      =&gt; where {
             /^$RE{zip}{US}{-extended =&gt; 'allow'}$/;
         };
  has 'street'   =&gt; ( is =&gt; 'rw', isa =&gt; 'Str' );
  has 'city'     =&gt; ( is =&gt; 'rw', isa =&gt; 'Str' );
  has 'state'    =&gt; ( is =&gt; 'rw', isa =&gt; 'USState' );
  has 'zip_code' =&gt; ( is =&gt; 'rw', isa =&gt; 'USZipCode' );
  package Company;
  use Moose;
  use Moose::Util::TypeConstraints;
  has 'name' =&gt; ( is =&gt; 'rw', isa =&gt; 'Str', required =&gt; 1 );
  has 'address'   =&gt; ( is =&gt; 'rw', isa =&gt; 'Address' );
  has 'employees' =&gt; (
      is      =&gt; 'rw',
      isa     =&gt; 'ArrayRef[Employee]',
      default =&gt; sub { [] },
  );
  sub BUILD {
      my ( $self, $params ) = @_;
      foreach my $employee ( @{ $self-&gt;employees } ) {
          $employee-&gt;employer($self);
      }
  }
  after 'employees' =&gt; sub {
      my ( $self, $employees ) = @_;
      return unless $employees;
      foreach my $employee ( @$employees ) {
          $employee-&gt;employer($self);
      }
  };
  package Person;
  use Moose;
  has 'first_name' =&gt; ( is =&gt; 'rw', isa =&gt; 'Str', required =&gt; 1 );
  has 'last_name'  =&gt; ( is =&gt; 'rw', isa =&gt; 'Str', required =&gt; 1 );
  has 'middle_initial' =&gt; (
      is        =&gt; 'rw', isa =&gt; 'Str',
      predicate =&gt; 'has_middle_initial'
  );
  has 'address' =&gt; ( is =&gt; 'rw', isa =&gt; 'Address' );
  sub full_name {
      my $self = shift;
      return $self-&gt;first_name
          . (
          $self-&gt;has_middle_initial
          ? ' ' . $self-&gt;middle_initial . '. '
          : ' '
          ) . $self-&gt;last_name;
  }
  package Employee;
  use Moose;
  extends 'Person';
  has 'title'    =&gt; ( is =&gt; 'rw', isa =&gt; 'Str',     required =&gt; 1 );
  has 'employer' =&gt; ( is =&gt; 'rw', isa =&gt; 'Company', weak_ref =&gt; 1 );
  override 'full_name' =&gt; sub {
      my $self = shift;
      super() . ', ' . $self-&gt;title;
  };
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This recipe introduces the
    <span class="Li">&quot;subtype&quot;</span> sugar function from
    Moose::Util::TypeConstraints. The
    <span class="Li">&quot;subtype&quot;</span> function lets you declaratively
    create type constraints without building an entire class.</p>
<p class="Pp">In the recipe we also make use of Locale::US and Regexp::Common to
    build constraints, showing how constraints can make use of existing CPAN
    tools for data validation.</p>
<p class="Pp">Finally, we introduce the
    <span class="Li">&quot;required&quot;</span> attribute option.</p>
<p class="Pp">In the <span class="Li">&quot;Address&quot;</span> class we define
    two subtypes. The first uses the Locale::US module to check the validity of
    a state. It accepts either a state abbreviation of full name.</p>
<p class="Pp">A state will be passed in as a string, so we make our
    <span class="Li">&quot;USState&quot;</span> type a subtype of Moose's
    builtin <span class="Li">&quot;Str&quot;</span> type. This is done using the
    <span class="Li">&quot;as&quot;</span> sugar. The actual constraint is
    defined using <span class="Li">&quot;where&quot;</span>. This function
    accepts a single subroutine reference. That subroutine will be called with
    the value to be checked in <span class="Li">$_</span> (1). It is expected to
    return a true or false value indicating whether the value is valid for the
    type.</p>
<p class="Pp">We can now use the <span class="Li">&quot;USState&quot;</span>
    type just like Moose's builtin types:</p>
<p class="Pp"></p>
<pre>  has 'state'    =&gt; ( is =&gt; 'rw', isa =&gt; 'USState' );
</pre>
<p class="Pp">When the <span class="Li">&quot;state&quot;</span> attribute is
    set, the value is checked against the
    <span class="Li">&quot;USState&quot;</span> constraint. If the value is not
    valid, an exception will be thrown.</p>
<p class="Pp">The next <span class="Li">&quot;subtype&quot;</span>,
    <span class="Li">&quot;USZipCode&quot;</span>, uses Regexp::Common.
    Regexp::Common includes a regex for validating US zip codes. We use this
    constraint for the <span class="Li">&quot;zip_code&quot;</span>
  attribute.</p>
<p class="Pp"></p>
<pre>  subtype 'USZipCode'
      =&gt; as Value
      =&gt; where {
             /^$RE{zip}{US}{-extended =&gt; 'allow'}$/;
         };
</pre>
<p class="Pp">Using a subtype instead of requiring a class for each type greatly
    simplifies the code. We don't really need a class for these types, as
    they're just strings, but we do want to ensure that they're valid.</p>
<p class="Pp">The type constraints we created are reusable. Type constraints are
    stored by name in a global registry, which means that we can refer to them
    in other classes. Because the registry is global, we do recommend that you
    use some sort of namespacing in real applications, like
    <span class="Li">&quot;MyApp::Type::USState&quot;</span> (just as you would
    do with class names).</p>
<p class="Pp">These two subtypes allow us to define a simple
    <span class="Li">&quot;Address&quot;</span> class.</p>
<p class="Pp">Then we define our <span class="Li">&quot;Company&quot;</span>
    class, which has an address. As we saw in earlier recipes, Moose
    automatically creates a type constraint for each our classes, so we can use
    that for the <span class="Li">&quot;Company&quot;</span> class's
    <span class="Li">&quot;address&quot;</span> attribute:</p>
<p class="Pp"></p>
<pre>  has 'address'   =&gt; ( is =&gt; 'rw', isa =&gt; 'Address' );
</pre>
<p class="Pp">A company also needs a name:</p>
<p class="Pp"></p>
<pre>  has 'name' =&gt; ( is =&gt; 'rw', isa =&gt; 'Str', required =&gt; 1 );
</pre>
<p class="Pp">This introduces a new attribute option,
    <span class="Li">&quot;required&quot;</span>. If an attribute is required,
    then it must be passed to the class's constructor, or an exception will be
    thrown. It's important to understand that a
    <span class="Li">&quot;required&quot;</span> attribute can still be false or
    <span class="Li">&quot;undef&quot;</span>, if its type constraint allows
    that.</p>
<p class="Pp">The next attribute, <span class="Li">&quot;employees&quot;</span>,
    uses a <i>parameterized</i> type constraint:</p>
<p class="Pp"></p>
<pre>  has 'employees' =&gt; (
      is      =&gt; 'rw',
      isa     =&gt; 'ArrayRef[Employee]'
      default =&gt; sub { [] },
  );
</pre>
<p class="Pp">This constraint says that
    <span class="Li">&quot;employees&quot;</span> must be an array reference
    where each element of the array is an
    <span class="Li">&quot;Employee&quot;</span> object. It's worth noting that
    an <i>empty</i> array reference also satisfies this constraint, such as the
    value given as the default here.</p>
<p class="Pp">Parameterizable type constraints (or &quot;container types&quot;),
    such as <span class="Li">&quot;ArrayRef[`a]&quot;</span>, can be made more
    specific with a type parameter. In fact, we can arbitrarily nest these
    types, producing something like
    <span class="Li">&quot;HashRef[ArrayRef[Int]]&quot;</span>. However, you can
    also just use the type by itself, so
    <span class="Li">&quot;ArrayRef&quot;</span> is legal. (2)</p>
<p class="Pp">If you jump down to the definition of the
    <span class="Li">&quot;Employee&quot;</span> class, you will see that it has
    an <span class="Li">&quot;employer&quot;</span> attribute.</p>
<p class="Pp">When we set the <span class="Li">&quot;employees&quot;</span> for
    a <span class="Li">&quot;Company&quot;</span> we want to make sure that each
    of these employee objects refers back to the right
    <span class="Li">&quot;Company&quot;</span> in its
    <span class="Li">&quot;employer&quot;</span> attribute.</p>
<p class="Pp">To do that, we need to hook into object construction. Moose lets
    us do this by writing a <span class="Li">&quot;BUILD&quot;</span> method in
    our class. When your class defines a
    <span class="Li">&quot;BUILD&quot;</span> method, it will be called by the
    constructor immediately after object construction, but before the object is
    returned to the caller. Note that all
    <span class="Li">&quot;BUILD&quot;</span> methods in your class hierarchy
    will be called automatically; there is no need to (and you should not) call
    the superclass <span class="Li">&quot;BUILD&quot;</span> method.</p>
<p class="Pp">The <span class="Li">&quot;Company&quot;</span> class uses the
    <span class="Li">&quot;BUILD&quot;</span> method to ensure that each
    employee of a company has the proper
    <span class="Li">&quot;Company&quot;</span> object in its
    <span class="Li">&quot;employer&quot;</span> attribute:</p>
<p class="Pp"></p>
<pre>  sub BUILD {
      my ( $self, $params ) = @_;
      foreach my $employee ( @{ $self-&gt;employees } ) {
          $employee-&gt;employer($self);
      }
  }
</pre>
<p class="Pp">The <span class="Li">&quot;BUILD&quot;</span> method is executed
    after type constraints are checked, so it is safe to assume that if
    <span class="Li">&quot;$self-&gt;employees&quot;</span> has a value, it will
    be an array reference, and that the elements of that array reference will be
    <span class="Li">&quot;Employee&quot;</span> objects.</p>
<p class="Pp">We also want to make sure that whenever the
    <span class="Li">&quot;employees&quot;</span> attribute for a
    <span class="Li">&quot;Company&quot;</span> is changed, we also update the
    <span class="Li">&quot;employer&quot;</span> for each employee.</p>
<p class="Pp">To do this we can use an <span class="Li">&quot;after&quot;</span>
    modifier:</p>
<p class="Pp"></p>
<pre>  after 'employees' =&gt; sub {
      my ( $self, $employees ) = @_;
      return unless $employees;
      foreach my $employee ( @$employees ) {
          $employee-&gt;employer($self);
      }
  };
</pre>
<p class="Pp">Again, as with the <span class="Li">&quot;BUILD&quot;</span>
    method, we know that the type constraint check has already happened, so we
    know that if <span class="Li">$employees</span> is defined it will contain
    an array reference of <span class="Li">&quot;Employee&quot;</span>
  objects.</p>
<p class="Pp">Note that <span class="Li">&quot;employees&quot;</span> is a
    read/write accessor, so we must return early if it's called as a reader.</p>
<p class="Pp">The <b>Person</b> class does not really demonstrate anything new.
    It has several <span class="Li">&quot;required&quot;</span> attributes. It
    also has a <span class="Li">&quot;predicate&quot;</span> method, which we
    first used in Moose::Cookbook::Basics::BinaryTree_AttributeFeatures.</p>
<p class="Pp">The only new feature in the
    <span class="Li">&quot;Employee&quot;</span> class is the
    <span class="Li">&quot;override&quot;</span> method modifier:</p>
<p class="Pp"></p>
<pre>  override 'full_name' =&gt; sub {
      my $self = shift;
      super() . ', ' . $self-&gt;title;
  };
</pre>
<p class="Pp">This is just a sugary alternative to Perl's built in
    <span class="Li">&quot;SUPER::&quot;</span> feature. However, there is one
    difference. You cannot pass any arguments to
    <span class="Li">&quot;super&quot;</span>. Instead, Moose simply passes the
    same parameters that were passed to the method.</p>
<p class="Pp">A more detailed example of usage can be found in
    <i>t/recipes/basics_company_subtypes.t</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONCLUSION"><a class="permalink" href="#CONCLUSION">CONCLUSION</a></h1>
<p class="Pp">This recipe was intentionally longer and more complex. It
    illustrates how Moose classes can be used together with type constraints, as
    well as the density of information that you can get out of a small amount of
    typing when using Moose.</p>
<p class="Pp">This recipe also introduced the
    <span class="Li">&quot;subtype&quot;</span> function, the
    <span class="Li">&quot;required&quot;</span> attribute, and the
    <span class="Li">&quot;override&quot;</span> method modifier.</p>
<p class="Pp">We will revisit type constraints in future recipes, and cover type
    coercion as well.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FOOTNOTES"><a class="permalink" href="#FOOTNOTES">FOOTNOTES</a></h1>
<dl class="Bl-tag">
  <dt>(1)</dt>
  <dd>The value being checked is also passed as the first argument to the
      <span class="Li">&quot;where&quot;</span> block, so it can be accessed as
      <span class="Li">$_[0]</span>.</dd>
  <dt>(2)</dt>
  <dd>Note that <span class="Li">&quot;ArrayRef[]&quot;</span> will not work.
      Moose will not parse this as a container type, and instead you will have a
      new type named &quot;ArrayRef[]&quot;, which doesn't make any sense.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Stevan Little &lt;stevan.little@iinteractive.com&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
  <li>Shawn M Moore &lt;code@sartak.org&gt;</li>
  <li>&#x05D9;&#x05D5;&#x05D1;&#x05DC; &#x05E7;&#x05D5;&#x05D2;'&#x05DE;&#x05DF;
      (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Florian Ragwitz &lt;rafl@debian.org&gt;</li>
  <li>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</li>
  <li>Chris Prather &lt;chris@prather.org&gt;</li>
  <li>Matt S Trout &lt;mst@shadowcat.co.uk&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2006 by Infinity Interactive,
  Inc.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-11-22</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

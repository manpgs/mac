<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>MooseX::Declare::Syntax::NamespaceHandling(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">MooseX::Declare::Syntax::NamespaceHandling(3pm)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">MooseX::Declare::Syntax::NamespaceHandling(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">MooseX::Declare::Syntax::NamespaceHandling - Handle namespaced
    blocks</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 0.43</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Allows the implementation of namespaced blocks like the role and
    class keyword handlers.</p>
<p class="Pp">Namespaces are automatically nested. Meaning that, for example, a
    <span class="Li">&quot;class Bar&quot;</span> declaration inside another
    <span class="Li">&quot;class Foo&quot;</span> block gives the inner one
    actually the name <span class="Li">&quot;Foo::Bar&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="parse"><a class="permalink" href="#parse">parse</a></h2>
<pre>  Any Object-&gt;parse (Object $context)
</pre>
<p class="Pp">This is the main handling routine for namespaces. It will remove
    the namespace name and its options. If the handler was invoked without a
    name, options or a following block, it is assumed that this is an instance
    of an autoquoted bareword like <span class="Li">&quot;class =&gt;
    &quot;Foo&quot;&quot;</span>.</p>
<p class="Pp">The return value of the <span class="Li">&quot;parse&quot;</span>
    method is also the value that is returned to the user of the keyword.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CONSUMES"><a class="permalink" href="#CONSUMES">CONSUMES</a></h1>
<ul class="Bl-bullet">
  <li>MooseX::Declare::Syntax::KeywordHandling</li>
  <li>MooseX::Declare::Syntax::InnerSyntaxHandling</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="REQUIRED_METHODS"><a class="permalink" href="#REQUIRED_METHODS">REQUIRED
  METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="handle_missing_block"><a class="permalink" href="#handle_missing_block">handle_missing_block</a></h2>
<pre>  Object-&gt;handle_missing_block (Object $context, Str $body, %args)
</pre>
<p class="Pp">This must be implemented to decide what to do in case the
    statement is terminated rather than followed by a block. It will receive the
    context object, the produced code that needs to be injected, and all the
    arguments that were passed to the call to &quot;inject_code_parts&quot; in
    MooseX::Declare::Context.</p>
<p class="Pp">The return value will be ignored.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXTENDABLE_STUB_METHODS"><a class="permalink" href="#EXTENDABLE_STUB_METHODS">EXTENDABLE
  STUB METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="add_namespace_customizations"><a class="permalink" href="#add_namespace_customizations">add_namespace_customizations</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="add_optional_customizations"><a class="permalink" href="#add_optional_customizations">add_optional_customizations</a></h2>
<pre>  Object-&gt;add_namespace_customizations (Object $context, Str $package, HashRef $options)
  Object-&gt;add_optional_customizations  (Object $context, Str $package, HashRef $options)
</pre>
<p class="Pp">These will be called (in this order) by the &quot;parse&quot;
    method. They allow specific hooks to attach before/after/around the
    customizations for the namespace and the provided options that are not
    attached to the namespace directly.</p>
<p class="Pp">While this distinction might seem superficial, we advise library
    developers facilitating this role to follow the precedent. This ensures that
    when another component needs to tie between the namespace and any additional
    customizations everything will run in the correct order. An example of this
    separation would be</p>
<p class="Pp"></p>
<pre>  class Foo is mutable ...
</pre>
<p class="Pp">being an option of the namespace generation, while</p>
<p class="Pp"></p>
<pre>  class Foo with Bar ...
</pre>
<p class="Pp">is an additional optional customization.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="handle_post_parsing"><a class="permalink" href="#handle_post_parsing">handle_post_parsing</a></h2>
<pre>  Object-&gt;handle_post_parsing (Object $context, Str $package, Str | Object $name)
</pre>
<p class="Pp">Allows for additional modifications to the namespace after
    everything else has been done. It will receive the context, the fully
    qualified package name, and either a string with the name that was specified
    (might not be fully qualified, since namespaces can be nested) or the
    anonymous metaclass instance if no name was specified.</p>
<p class="Pp">The return value of this method will be the value returned to the
    user of the keyword. If you always return the
    <span class="Li">$package</span> argument like this:</p>
<p class="Pp"></p>
<pre>  sub handle_post_parsing {
      my ($self, $context, $package, $name) = @_;
      return $package;
  }
</pre>
<p class="Pp">and set this up in a <span class="Li">&quot;foo&quot;</span>
    keyword handler, you can use it like this:</p>
<p class="Pp"></p>
<pre>  foo Cthulhu {
      my $fhtagn = foo Fhtagn { }
      my $anon   = foo { };
      say $fhtagn;  # Cthulhu::Fhtagn
      say $anon;    # some autogenerated package name
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="make_anon_metaclass"><a class="permalink" href="#make_anon_metaclass">make_anon_metaclass</a></h2>
<pre>  Class::MOP::Class Object-&gt;make_anon_metaclass ()
</pre>
<p class="Pp">This method should be overridden if you want to provide anonymous
    namespaces.</p>
<p class="Pp">It does not receive any arguments for customization of the
    metaclass, because the configuration and customization will be done by
    MooseX::Declare in the package of the generated class in the same way as in
    those that have specified names. This way ensures that anonymous and named
    namespaces are always handled equally.</p>
<p class="Pp">If you do not extend this method (it will return nothing by
    default), an error will be thrown when a user attempts to declare an
    anonymous namespace.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<ul class="Bl-bullet">
  <li>MooseX::Declare</li>
  <li>MooseX::Declare::Syntax::MooseSetup</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Florian Ragwitz &lt;rafl@debian.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2008 by Florian Ragwitz.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2015-08-16</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

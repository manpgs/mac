<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>ExtUtils::Constant::Base(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">ExtUtils::Constant::Base(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">ExtUtils::Constant::Base(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">ExtUtils::Constant::Base - base class for ExtUtils::Constant
    objects</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
    require ExtUtils::Constant::Base;
    @ISA = 'ExtUtils::Constant::Base';
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">ExtUtils::Constant::Base provides a base implementation of methods
    to generate C code to give fast constant value lookup by named string.
    Currently it's mostly used ExtUtils::Constant::XS, which generates the
    lookup code for the <b>constant()</b> subroutine found in many XS
  modules.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="USAGE"><a class="permalink" href="#USAGE">USAGE</a></h1>
<p class="Pp">ExtUtils::Constant::Base exports no subroutines. The following
    methods are available</p>
<dl class="Bl-tag">
  <dt id="header"><a class="permalink" href="#header">header</a></dt>
  <dd>A method returning a scalar containing definitions needed, typically for a
      C header file.</dd>
  <dt id="memEQ_clause"><a class="permalink" href="#memEQ_clause">memEQ_clause
    args_hashref</a></dt>
  <dd>A method to return a suitable C <span class="Li">&quot;if&quot;</span>
      statement to check whether <i>name</i> is equal to the C variable
      <span class="Li">&quot;name&quot;</span>. If <i>checked_at</i> is defined,
      then it is used to avoid <span class="Li">&quot;memEQ&quot;</span> for
      short names, or to generate a comment to highlight the position of the
      character in the <span class="Li">&quot;switch&quot;</span> statement.
    <p class="Pp">If i&lt;checked_at&gt; is a reference to a scalar, then
        instead it gives the characters pre-checked at the beginning, (and the
        number of chars by which the C variable name has been advanced. These
        need to be chopped from the front of <i>name</i>).</p>
  </dd>
  <dt id="dump_names"><a class="permalink" href="#dump_names">dump_names
    arg_hashref, ITEM...</a></dt>
  <dd>An internal function to generate the embedded perl code that will
      regenerate the constant subroutines. <i>default_type</i>, <i>types</i> and
      <i>ITEM</i>s are the same as for C_constant. <i>indent</i> is treated as
      number of spaces to indent by. If
      <span class="Li">&quot;declare_types&quot;</span> is true a
      <span class="Li">$types</span> is always declared in the perl code
      generated, if defined and false never declared, and if undefined
      <span class="Li">$types</span> is only declared if the values in
      <i>types</i> as passed in cannot be inferred from <i>default_types</i> and
      the <i>ITEM</i>s.</dd>
  <dt id="assign"><a class="permalink" href="#assign">assign arg_hashref,
    VALUE...</a></dt>
  <dd>A method to return a suitable assignment clause. If <i>type</i> is
      aggregate (eg <i>PVN</i> expects both pointer and length) then there
      should be multiple <i>VALUE</i>s for the components. <i>pre</i> and
      <i>post</i> if defined give snippets of C code to proceed and follow the
      assignment. <i>pre</i> will be at the start of a block, so variables may
      be defined in it.</dd>
  <dt id="return_clause"><a class="permalink" href="#return_clause">return_clause
    arg_hashref, ITEM</a></dt>
  <dd>A method to return a suitable <span class="Li">&quot;#ifdef&quot;</span>
      clause. <i>ITEM</i> is a hashref (as passed to
      <span class="Li">&quot;C_constant&quot;</span> and
      <span class="Li">&quot;match_clause&quot;</span>. <i>indent</i> is the
      number of spaces to indent, defaulting to 6.</dd>
  <dt id="switch_clause"><a class="permalink" href="#switch_clause">switch_clause
    arg_hashref, NAMELEN, ITEMHASH, ITEM...</a></dt>
  <dd>An internal method to generate a suitable
      <span class="Li">&quot;switch&quot;</span> clause, called by
      <span class="Li">&quot;C_constant&quot;</span> <i>ITEM</i>s are in the
      hash ref format as given in the description of
      <span class="Li">&quot;C_constant&quot;</span>, and must all have the
      names of the same length, given by <i>NAMELEN</i>. <i>ITEMHASH</i> is a
      reference to a hash, keyed by name, values being the hashrefs in the
      <i>ITEM</i> list. (No parameters are modified, and there can be keys in
      the <i>ITEMHASH</i> that are not in the list of <i>ITEM</i>s without
      causing problems - the hash is passed in to save generating it afresh for
      each call).</dd>
  <dt id="params"><a class="permalink" href="#params">params WHAT</a></dt>
  <dd>An &quot;internal&quot; method, subject to change, currently called to
      allow an overriding class to cache information that will then be passed
      into all the <span class="Li">&quot;*param*&quot;</span> calls. (Yes,
      having to read the source to make sense of this is considered a known
      bug). <i>WHAT</i> is be a hashref of types the constant function will
      return. In ExtUtils::Constant::XS this method is used to returns a hashref
      keyed IV NV PV SV to show which combination of pointers will be needed in
      the C argument list generated by C_constant_other_params_definition and
      C_constant_other_params</dd>
  <dt id="dogfood"><a class="permalink" href="#dogfood">dogfood arg_hashref,
    ITEM...</a></dt>
  <dd>An internal function to generate the embedded perl code that will
      regenerate the constant subroutines. Parameters are the same as for
      C_constant.
    <p class="Pp">Currently the base class does nothing and returns an empty
        string.</p>
  </dd>
  <dt id="normalise_items"><a class="permalink" href="#normalise_items">normalise_items
    args, default_type, seen_types, seen_items, ITEM...</a></dt>
  <dd>Convert the items to a normalised form. For 8 bit and Unicode values
      converts the item to an array of 1 or 2 items, both 8 bit and UTF-8
      encoded.</dd>
  <dt id="C_constant"><a class="permalink" href="#C_constant">C_constant
    arg_hashref, ITEM...</a></dt>
  <dd>A function that returns a <b>list</b> of C subroutine definitions that
      return the value and type of constants when passed the name by the XS
      wrapper. <i>ITEM...</i> gives a list of constant names. Each can either be
      a string, which is taken as a C macro name, or a reference to a hash with
      the following keys</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="name"><a class="permalink" href="#name">name</a></dt>
  <dd>The name of the constant, as seen by the perl code.</dd>
  <dt id="type"><a class="permalink" href="#type">type</a></dt>
  <dd>The type of the constant (<i>IV</i>, <i>NV</i> etc)</dd>
  <dt id="value"><a class="permalink" href="#value">value</a></dt>
  <dd>A C expression for the value of the constant, or a list of C expressions
      if the type is aggregate. This defaults to the <i>name</i> if not
    given.</dd>
  <dt id="macro"><a class="permalink" href="#macro">macro</a></dt>
  <dd>The C pre-processor macro to use in the
      <span class="Li">&quot;#ifdef&quot;</span>. This defaults to the
      <i>name</i>, and is mainly used if <i>value</i> is an
      <span class="Li">&quot;enum&quot;</span>. If a reference an array is
      passed then the first element is used in place of the
      <span class="Li">&quot;#ifdef&quot;</span> line, and the second element in
      place of the <span class="Li">&quot;#endif&quot;</span>. This allows
      pre-processor constructions such as
    <p class="Pp"></p>
    <pre>
    #if defined (foo)
    #if !defined (bar)
    ...
    #endif
    #endif
    </pre>
    <p class="Pp">to be used to determine if a constant is to be defined.</p>
    <p class="Pp">A &quot;macro&quot; 1 signals that the constant is always
        defined, so the
        <span class="Li">&quot;#if&quot;</span>/<span class="Li">&quot;#endif&quot;</span>
        test is omitted.</p>
  </dd>
  <dt id="default"><a class="permalink" href="#default">default</a></dt>
  <dd>Default value to use (instead of
      <span class="Li">&quot;croak&quot;</span>ing with &quot;your vendor has
      not defined...&quot;) to return if the macro isn't defined. Specify a
      reference to an array with type followed by value(s).</dd>
  <dt id="pre"><a class="permalink" href="#pre">pre</a></dt>
  <dd>C code to use before the assignment of the value of the constant. This
      allows you to use temporary variables to extract a value from part of a
      <span class="Li">&quot;struct&quot;</span> and return this as
      <i>value</i>. This C code is places at the start of a block, so you can
      declare variables in it.</dd>
  <dt id="post"><a class="permalink" href="#post">post</a></dt>
  <dd>C code to place between the assignment of value (to a temporary) and the
      return from the function. This allows you to clear up anything in
      <i>pre</i>. Rarely needed.</dd>
  <dt id="def_pre"><a class="permalink" href="#def_pre">def_pre</a></dt>
  <dd></dd>
  <dt id="def_post"><a class="permalink" href="#def_post">def_post</a></dt>
  <dd>Equivalents of <i>pre</i> and <i>post</i> for the default value.</dd>
  <dt id="utf8"><a class="permalink" href="#utf8">utf8</a></dt>
  <dd>Generated internally. Is zero or undefined if name is 7 bit ASCII,
      &quot;no&quot; if the name is 8 bit (and so should only match if
      <b>SvUTF8()</b> is false), &quot;yes&quot; if the name is utf8 encoded.
    <p class="Pp">The internals automatically clone any name with characters
        128-255 but none 256+ (ie one that could be either in bytes or utf8)
        into a second entry which is utf8 encoded.</p>
  </dd>
  <dt id="weight"><a class="permalink" href="#weight">weight</a></dt>
  <dd>Optional sorting weight for names, to determine the order of linear
      testing when multiple names fall in the same case of a switch clause.
      Higher comes earlier, undefined defaults to zero.</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">In the argument hashref, <i>package</i> is the name of the
    package, and is only used in comments inside the generated C code.
    <i>subname</i> defaults to <span class="Li">&quot;constant&quot;</span> if
    undefined.</p>
<p class="Pp"><i>default_type</i> is the type returned by
    <span class="Li">&quot;ITEM&quot;</span>s that don't specify their type. It
    defaults to the value of <span class="Li">&quot;default_type()&quot;</span>.
    <i>types</i> should be given either as a comma separated list of types that
    the C subroutine <i>subname</i> will generate or as a reference to a hash.
    <i>default_type</i> will be added to the list if not present, as will any
    types given in the list of <i>ITEM</i>s. The resultant list should be the
    same list of types that <span class="Li">&quot;XS_constant&quot;</span> is
    given. [Otherwise <span class="Li">&quot;XS_constant&quot;</span> and
    <span class="Li">&quot;C_constant&quot;</span> may differ in the number of
    parameters to the constant function. <i>indent</i> is currently unused and
    ignored. In future it may be used to pass in information used to change the
    C indentation style used.] The best way to maintain consistency is to pass
    in a hash reference and let this function update it.</p>
<p class="Pp"><i>breakout</i> governs when child functions of <i>subname</i> are
    generated. If there are <i>breakout</i> or more <i>ITEM</i>s with the same
    length of name, then the code to switch between them is placed into a
    function named <i>subname</i>_<i>len</i>, for example
    <span class="Li">&quot;constant_5&quot;</span> for names 5 characters long.
    The default <i>breakout</i> is 3. A single
    <span class="Li">&quot;ITEM&quot;</span> is always inlined.</p>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">Not everything is documented yet.</p>
<p class="Pp">Probably others.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Nicholas Clark &lt;nick@ccl4.org&gt; based on the code in
    <span class="Li">&quot;h2xs&quot;</span> by Larry Wall and others</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

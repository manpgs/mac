<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>File::Spec::Mac(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">File::Spec::Mac(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">File::Spec::Mac(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">File::Spec::Mac - File::Spec for Mac OS (Classic)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
 require File::Spec::Mac; # Done internally by File::Spec if needed
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Methods for manipulating file specifications.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<dl class="Bl-tag">
  <dt id="canonpath"><a class="permalink" href="#canonpath">canonpath</a></dt>
  <dd>On Mac OS, there's nothing to be done. Returns what it's given.</dd>
  <dt id="catdir()"><a class="permalink" href="#catdir()"><i>catdir()</i></a></dt>
  <dd>Concatenate two or more directory names to form a path separated by colons
      (&quot;:&quot;) ending with a directory. Resulting paths are
      <b>relative</b> by default, but can be forced to be absolute (but avoid
      this, see below). Automatically puts a trailing &quot;:&quot; on the end
      of the complete path, because that's what's done in MacPerl's environment
      and helps to distinguish a file path from a directory path.
    <p class="Pp"><b>IMPORTANT NOTE:</b> Beginning with version 1.3 of this
        module, the resulting path is relative by default and <i>not</i>
        absolute. This decision was made due to portability reasons. Since
        <span class="Li">&quot;File::Spec-&gt;catdir()&quot;</span> returns
        relative paths on all other operating systems, it will now also follow
        this convention on Mac OS. Note that this may break some existing
        scripts.</p>
    <p class="Pp">The intended purpose of this routine is to concatenate
        <i>directory names</i>. But because of the nature of Macintosh paths,
        some additional possibilities are allowed to make using this routine
        give reasonable results for some common situations. In other words, you
        are also allowed to concatenate <i>paths</i> instead of directory names
        (strictly speaking, a string like &quot;:a&quot; is a path, but not a
        name, since it contains a punctuation character &quot;:&quot;).</p>
    <p class="Pp">So, beside calls like</p>
    <p class="Pp"></p>
    <pre>
    catdir(&quot;a&quot;) = &quot;:a:&quot;
    catdir(&quot;a&quot;,&quot;b&quot;) = &quot;:a:b:&quot;
    catdir() = &quot;&quot;                    (special case)
    </pre>
    <p class="Pp">calls like the following</p>
    <p class="Pp"></p>
    <pre>
    catdir(&quot;:a:&quot;) = &quot;:a:&quot;
    catdir(&quot;:a&quot;,&quot;b&quot;) = &quot;:a:b:&quot;
    catdir(&quot;:a:&quot;,&quot;b&quot;) = &quot;:a:b:&quot;
    catdir(&quot;:a:&quot;,&quot;:b:&quot;) = &quot;:a:b:&quot;
    catdir(&quot;:&quot;) = &quot;:&quot;
    </pre>
    <p class="Pp">are allowed.</p>
    <p class="Pp">Here are the rules that are used in
        <span class="Li">&quot;catdir()&quot;</span>; note that we try to be as
        compatible as possible to Unix:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>The resulting path is relative by default, i.e. the resulting path will
      have a leading colon.</dd>
  <dt>2.</dt>
  <dd>A trailing colon is added automatically to the resulting path, to denote a
      directory.</dd>
  <dt>3.</dt>
  <dd>Generally, each argument has one leading &quot;:&quot; and one trailing
      &quot;:&quot; removed (if any). They are then joined together by a
      &quot;:&quot;. Special treatment applies for arguments denoting updir
      paths like &quot;::lib:&quot;, see (4), or arguments consisting solely of
      colons (&quot;colon paths&quot;), see (5).</dd>
  <dt>4.</dt>
  <dd>When an updir path like &quot;:::lib::&quot; is passed as argument, the
      number of directories to climb up is handled correctly, not removing
      leading or trailing colons when necessary. E.g.
    <p class="Pp"></p>
    <pre>
    catdir(&quot;:::a&quot;,&quot;::b&quot;,&quot;c&quot;)    = &quot;:::a::b:c:&quot;
    catdir(&quot;:::a::&quot;,&quot;::b&quot;,&quot;c&quot;)  = &quot;:::a:::b:c:&quot;
    </pre>
  </dd>
  <dt>5.</dt>
  <dd>Adding a colon &quot;:&quot; or empty string &quot;&quot; to a path at
      <i>any</i> position doesn't alter the path, i.e. these arguments are
      ignored. (When a &quot;&quot; is passed as the first argument, it has a
      special meaning, see (6)). This way, a colon &quot;:&quot; is handled like
      a &quot;.&quot; (curdir) on Unix, while an empty string &quot;&quot; is
      generally ignored (see
      <span class="Li">&quot;Unix-&gt;canonpath()&quot;</span> ). Likewise, a
      &quot;::&quot; is handled like a &quot;..&quot; (updir), and a
      &quot;:::&quot; is handled like a &quot;../..&quot; etc. E.g.
    <p class="Pp"></p>
    <pre>
    catdir(&quot;a&quot;,&quot;:&quot;,&quot;:&quot;,&quot;b&quot;)   = &quot;:a:b:&quot;
    catdir(&quot;a&quot;,&quot;:&quot;,&quot;::&quot;,&quot;:b&quot;) = &quot;:a::b:&quot;
    </pre>
  </dd>
  <dt>6.</dt>
  <dd>If the first argument is an empty string &quot;&quot; or is a volume name,
      i.e. matches the pattern /^[^:]+:/, the resulting path is
    <b>absolute</b>.</dd>
  <dt>7.</dt>
  <dd>Passing an empty string &quot;&quot; as the first argument to
      <span class="Li">&quot;catdir()&quot;</span> is like
      passing<span class="Li">&quot;File::Spec-&gt;rootdir()&quot;</span> as the
      first argument, i.e.
    <p class="Pp"></p>
    <pre>
    catdir(&quot;&quot;,&quot;a&quot;,&quot;b&quot;)          is the same as

    catdir(rootdir(),&quot;a&quot;,&quot;b&quot;).
    </pre>
    <p class="Pp">This is true on Unix, where
        <span class="Li">&quot;catdir(&quot;&quot;,&quot;a&quot;,&quot;b&quot;)&quot;</span>
        yields &quot;/a/b&quot; and
        <span class="Li">&quot;rootdir()&quot;</span> is &quot;/&quot;. Note
        that <span class="Li">&quot;rootdir()&quot;</span> on Mac OS is the
        startup volume, which is the closest in concept to Unix' &quot;/&quot;.
        This should help to run existing scripts originally written for
      Unix.</p>
  </dd>
  <dt>8.</dt>
  <dd>For absolute paths, some cleanup is done, to ensure that the volume name
      isn't immediately followed by updirs. This is invalid, because this would
      go beyond &quot;root&quot;. Generally, these cases are handled like their
      Unix counterparts:
    <p class="Pp"></p>
    <pre>
 Unix:
    Unix-&gt;catdir(&quot;&quot;,&quot;&quot;)                 =  &quot;/&quot;
    Unix-&gt;catdir(&quot;&quot;,&quot;.&quot;)                =  &quot;/&quot;
    Unix-&gt;catdir(&quot;&quot;,&quot;..&quot;)               =  &quot;/&quot;        # can't go
                                                      # beyond root
    Unix-&gt;catdir(&quot;&quot;,&quot;.&quot;,&quot;..&quot;,&quot;..&quot;,&quot;a&quot;)  =  &quot;/a&quot;
 Mac:
    Mac-&gt;catdir(&quot;&quot;,&quot;&quot;)                  =  rootdir()  # (e.g. &quot;HD:&quot;)
    Mac-&gt;catdir(&quot;&quot;,&quot;:&quot;)                 =  rootdir()
    Mac-&gt;catdir(&quot;&quot;,&quot;::&quot;)                =  rootdir()  # can't go
                                                      # beyond root
    Mac-&gt;catdir(&quot;&quot;,&quot;:&quot;,&quot;::&quot;,&quot;::&quot;,&quot;a&quot;)   =  rootdir() . &quot;a:&quot;
                                                    # (e.g. &quot;HD:a:&quot;)
    </pre>
    <p class="Pp">However, this approach is limited to the first arguments
        following &quot;root&quot; (again, see
        <span class="Li">&quot;Unix-&gt;canonpath()&quot;</span> ). If there are
        more arguments that move up the directory tree, an invalid path going
        beyond root can be created.</p>
  </dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">As you've seen, you can force
    <span class="Li">&quot;catdir()&quot;</span> to create an absolute path by
    passing either an empty string or a path that begins with a volume name as
    the first argument. However, you are strongly encouraged not to do so, since
    this is done only for backward compatibility. Newer versions of File::Spec
    come with a method called <span class="Li">&quot;catpath()&quot;</span> (see
    below), that is designed to offer a portable solution for the creation of
    absolute paths. It takes volume, directory and file portions and returns an
    entire path. While <span class="Li">&quot;catdir()&quot;</span> is still
    suitable for the concatenation of <i>directory names</i>, you are encouraged
    to use <span class="Li">&quot;catpath()&quot;</span> to concatenate
    <i>volume names</i> and <i>directory</i> <i>paths</i>. E.g.</p>
<p class="Pp"></p>
<pre>
    $dir      = File::Spec-&gt;catdir(&quot;tmp&quot;,&quot;sources&quot;);
    $abs_path = File::Spec-&gt;catpath(&quot;MacintoshHD:&quot;, $dir,&quot;&quot;);
</pre>
<p class="Pp">yields</p>
<p class="Pp"></p>
<pre>
    &quot;MacintoshHD:tmp:sources:&quot; .
</pre>
</div>
<dl class="Bl-tag">
  <dt id="catfile"><a class="permalink" href="#catfile">catfile</a></dt>
  <dd>Concatenate one or more directory names and a filename to form a complete
      path ending with a filename. Resulting paths are <b>relative</b> by
      default, but can be forced to be absolute (but avoid this).
    <p class="Pp"><b>IMPORTANT NOTE:</b> Beginning with version 1.3 of this
        module, the resulting path is relative by default and <i>not</i>
        absolute. This decision was made due to portability reasons. Since
        <span class="Li">&quot;File::Spec-&gt;catfile()&quot;</span> returns
        relative paths on all other operating systems, it will now also follow
        this convention on Mac OS. Note that this may break some existing
        scripts.</p>
    <p class="Pp">The last argument is always considered to be the file portion.
        Since <span class="Li">&quot;catfile()&quot;</span> uses
        <span class="Li">&quot;catdir()&quot;</span> (see above) for the
        concatenation of the directory portions (if any), the following with
        regard to relative and absolute paths is true:</p>
    <p class="Pp"></p>
    <pre>
    catfile(&quot;&quot;)     = &quot;&quot;
    catfile(&quot;file&quot;) = &quot;file&quot;
    </pre>
    <p class="Pp">but</p>
    <p class="Pp"></p>
    <pre>
    catfile(&quot;&quot;,&quot;&quot;)        = rootdir()         # (e.g. &quot;HD:&quot;)
    catfile(&quot;&quot;,&quot;file&quot;)    = rootdir() . file  # (e.g. &quot;HD:file&quot;)
    catfile(&quot;HD:&quot;,&quot;file&quot;) = &quot;HD:file&quot;
    </pre>
    <p class="Pp">This means that <span class="Li">&quot;catdir()&quot;</span>
        is called only when there are two or more arguments, as one might
        expect.</p>
    <p class="Pp">Note that the leading &quot;:&quot; is removed from the
        filename, so that</p>
    <p class="Pp"></p>
    <pre>
    catfile(&quot;a&quot;,&quot;b&quot;,&quot;file&quot;)  = &quot;:a:b:file&quot;    and

    catfile(&quot;a&quot;,&quot;b&quot;,&quot;:file&quot;) = &quot;:a:b:file&quot;
    </pre>
    <p class="Pp">give the same answer.</p>
    <p class="Pp">To concatenate <i>volume names</i>, <i>directory paths</i> and
        <i>filenames</i>, you are encouraged to use
        <span class="Li">&quot;catpath()&quot;</span> (see below).</p>
  </dd>
  <dt id="curdir"><a class="permalink" href="#curdir">curdir</a></dt>
  <dd>Returns a string representing the current directory. On Mac OS, this is
      &quot;:&quot;.</dd>
  <dt id="devnull"><a class="permalink" href="#devnull">devnull</a></dt>
  <dd>Returns a string representing the null device. On Mac OS, this is
      &quot;Dev:Null&quot;.</dd>
  <dt id="rootdir"><a class="permalink" href="#rootdir">rootdir</a></dt>
  <dd>Returns a string representing the root directory. Under MacPerl, returns
      the name of the startup volume, since that's the closest in concept,
      although other volumes aren't rooted there. The name has a trailing
      &quot;:&quot;, because that's the correct specification for a volume name
      on Mac OS.
    <p class="Pp">If Mac::Files could not be loaded, the empty string is
        returned.</p>
  </dd>
  <dt id="tmpdir"><a class="permalink" href="#tmpdir">tmpdir</a></dt>
  <dd>Returns the contents of <span class="Li">$ENV</span>{TMPDIR}, if that
      directory exits or the current working directory otherwise. Under MacPerl,
      <span class="Li">$ENV</span>{TMPDIR} will contain a path like
      &quot;MacintoshHD:Temporary Items:&quot;, which is a hidden directory on
      your startup volume.</dd>
  <dt id="updir"><a class="permalink" href="#updir">updir</a></dt>
  <dd>Returns a string representing the parent directory. On Mac OS, this is
      &quot;::&quot;.</dd>
  <dt id="file_name_is_absolute"><a class="permalink" href="#file_name_is_absolute">file_name_is_absolute</a></dt>
  <dd>Takes as argument a path and returns true, if it is an absolute path. If
      the path has a leading &quot;:&quot;, it's a relative path. Otherwise,
      it's an absolute path, unless the path doesn't contain any colons, i.e.
      it's a name like &quot;a&quot;. In this particular case, the path is
      considered to be relative (i.e. it is considered to be a filename). Use
      &quot;:&quot; in the appropriate place in the path if you want to
      distinguish unambiguously. As a special case, the filename '' is always
      considered to be absolute. Note that with version 1.2 of File::Spec::Mac,
      this does no longer consult the local filesystem.
    <p class="Pp">E.g.</p>
    <p class="Pp"></p>
    <pre>
    File::Spec-&gt;file_name_is_absolute(&quot;a&quot;);         # false (relative)
    File::Spec-&gt;file_name_is_absolute(&quot;:a:b:&quot;);     # false (relative)
    File::Spec-&gt;file_name_is_absolute(&quot;MacintoshHD:&quot;);
                                                    # true (absolute)
    File::Spec-&gt;file_name_is_absolute(&quot;&quot;);          # true (absolute)
    </pre>
  </dd>
  <dt id="path"><a class="permalink" href="#path">path</a></dt>
  <dd>Returns the null list for the MacPerl application, since the concept is
      usually meaningless under Mac OS. But if you're using the MacPerl tool
      under MPW, it gives back <span class="Li">$ENV</span>{Commands} suitably
      split, as is done in :lib:ExtUtils:MM_Mac.pm.</dd>
  <dt id="splitpath"><a class="permalink" href="#splitpath">splitpath</a></dt>
  <dd>
    <pre>
    ($volume,$directories,$file) = File::Spec-&gt;splitpath( $path );
    ($volume,$directories,$file) = File::Spec-&gt;splitpath( $path,
                                                          $no_file );
    </pre>
    <p class="Pp">Splits a path into volume, directory, and filename
      portions.</p>
    <p class="Pp">On Mac OS, assumes that the last part of the path is a
        filename unless <span class="Li">$no_file</span> is true or a trailing
        separator &quot;:&quot; is present.</p>
    <p class="Pp">The volume portion is always returned with a trailing
        &quot;:&quot;. The directory portion is always returned with a leading
        (to denote a relative path) and a trailing &quot;:&quot; (to denote a
        directory). The file portion is always returned <i>without</i> a leading
        &quot;:&quot;. Empty portions are returned as empty string ''.</p>
    <p class="Pp">The results can be passed to
        <span class="Li">&quot;catpath()&quot;</span> to get back a path
        equivalent to (usually identical to) the original path.</p>
  </dd>
  <dt id="splitdir"><a class="permalink" href="#splitdir">splitdir</a></dt>
  <dd>The opposite of <span class="Li">&quot;catdir()&quot;</span>.
    <p class="Pp"></p>
    <pre>
    @dirs = File::Spec-&gt;splitdir( $directories );
    </pre>
    <p class="Pp"><span class="Li">$directories</span> should be only the
        directory portion of the path on systems that have the concept of a
        volume or that have path syntax that differentiates files from
        directories. Consider using
        <span class="Li">&quot;splitpath()&quot;</span> otherwise.</p>
    <p class="Pp">Unlike just splitting the directories on the separator, empty
        directory names (<span class="Li">&quot;&quot;</span>) can be returned.
        Since <span class="Li">&quot;catdir()&quot;</span> on Mac OS always
        appends a trailing colon to distinguish a directory path from a file
        path, a single trailing colon will be ignored, i.e. there's no empty
        directory name after it.</p>
    <p class="Pp">Hence, on Mac OS, both</p>
    <p class="Pp"></p>
    <pre>
    File::Spec-&gt;splitdir( &quot;:a:b::c:&quot; );    and
    File::Spec-&gt;splitdir( &quot;:a:b::c&quot; );
    </pre>
    <p class="Pp">yield:</p>
    <p class="Pp"></p>
    <pre>
    ( &quot;a&quot;, &quot;b&quot;, &quot;::&quot;, &quot;c&quot;)
    </pre>
    <p class="Pp">while</p>
    <p class="Pp"></p>
    <pre>
    File::Spec-&gt;splitdir( &quot;:a:b::c::&quot; );
    </pre>
    <p class="Pp">yields:</p>
    <p class="Pp"></p>
    <pre>
    ( &quot;a&quot;, &quot;b&quot;, &quot;::&quot;, &quot;c&quot;, &quot;::&quot;)
    </pre>
  </dd>
  <dt id="catpath"><a class="permalink" href="#catpath">catpath</a></dt>
  <dd>
    <pre>
    $path = File::Spec-&gt;catpath($volume,$directory,$file);
    </pre>
    <p class="Pp">Takes volume, directory and file portions and returns an
        entire path. On Mac OS, <span class="Li">$volume</span>,
        <span class="Li">$directory</span> and <span class="Li">$file</span> are
        concatenated. A ':' is inserted if need be. You may pass an empty string
        for each portion. If all portions are empty, the empty string is
        returned. If <span class="Li">$volume</span> is empty, the result will
        be a relative path, beginning with a ':'. If
        <span class="Li">$volume</span> and <span class="Li">$directory</span>
        are empty, a leading &quot;:&quot; (if any) is removed form
        <span class="Li">$file</span> and the remainder is returned. If
        <span class="Li">$file</span> is empty, the resulting path will have a
        trailing ':'.</p>
  </dd>
  <dt id="abs2rel"><a class="permalink" href="#abs2rel">abs2rel</a></dt>
  <dd>Takes a destination path and an optional base path and returns a relative
      path from the base path to the destination path:
    <p class="Pp"></p>
    <pre>
    $rel_path = File::Spec-&gt;abs2rel( $path ) ;
    $rel_path = File::Spec-&gt;abs2rel( $path, $base ) ;
    </pre>
    <p class="Pp">Note that both paths are assumed to have a notation that
        distinguishes a directory path (with trailing ':') from a file path
        (without trailing ':').</p>
    <p class="Pp">If <span class="Li">$base</span> is not present or '', then
        the current working directory is used. If <span class="Li">$base</span>
        is relative, then it is converted to absolute form using
        <span class="Li">&quot;rel2abs()&quot;</span>. This means that it is
        taken to be relative to the current working directory.</p>
    <p class="Pp">If <span class="Li">$path</span> and
        <span class="Li">$base</span> appear to be on two different volumes, we
        will not attempt to resolve the two paths, and we will instead simply
        return <span class="Li">$path</span>. Note that previous versions of
        this module ignored the volume of <span class="Li">$base</span>, which
        resulted in garbage results part of the time.</p>
    <p class="Pp">If <span class="Li">$base</span> doesn't have a trailing
        colon, the last element of <span class="Li">$base</span> is assumed to
        be a filename. This filename is ignored. Otherwise all path components
        are assumed to be directories.</p>
    <p class="Pp">If <span class="Li">$path</span> is relative, it is converted
        to absolute form using <span class="Li">&quot;rel2abs()&quot;</span>.
        This means that it is taken to be relative to the current working
        directory.</p>
    <p class="Pp">Based on code written by Shigio Yamaguchi.</p>
  </dd>
  <dt id="rel2abs"><a class="permalink" href="#rel2abs">rel2abs</a></dt>
  <dd>Converts a relative path to an absolute path:
    <p class="Pp"></p>
    <pre>
    $abs_path = File::Spec-&gt;rel2abs( $path ) ;
    $abs_path = File::Spec-&gt;rel2abs( $path, $base ) ;
    </pre>
    <p class="Pp">Note that both paths are assumed to have a notation that
        distinguishes a directory path (with trailing ':') from a file path
        (without trailing ':').</p>
    <p class="Pp">If <span class="Li">$base</span> is not present or '', then
        <span class="Li">$base</span> is set to the current working directory.
        If <span class="Li">$base</span> is relative, then it is converted to
        absolute form using <span class="Li">&quot;rel2abs()&quot;</span>. This
        means that it is taken to be relative to the current working
      directory.</p>
    <p class="Pp">If <span class="Li">$base</span> doesn't have a trailing
        colon, the last element of <span class="Li">$base</span> is assumed to
        be a filename. This filename is ignored. Otherwise all path components
        are assumed to be directories.</p>
    <p class="Pp">If <span class="Li">$path</span> is already absolute, it is
        returned and <span class="Li">$base</span> is ignored.</p>
    <p class="Pp">Based on code written by Shigio Yamaguchi.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp">See the authors list in <i>File::Spec</i>. Mac OS support by Paul
    Schinder &lt;schinder@pobox.com&gt; and Thomas Wegner
    &lt;wegner_thomas@yahoo.com&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 2004 by the Perl 5 Porters. All rights reserved.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">See File::Spec and File::Spec::Unix. This package overrides the
    implementation of these methods, not the semantics.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

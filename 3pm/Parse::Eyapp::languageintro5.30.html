<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Parse::Eyapp::languageintro(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Parse::Eyapp::languageintro(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Parse::Eyapp::languageintro(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Parse::Eyapp::languageintro - Introduction to the Eyapp
  language</p>
</section>
<section class="Sh">
<h1 class="Sh" id="The_Eyapp_Language"><a class="permalink" href="#The_Eyapp_Language">The
  Eyapp Language</a></h1>
<section class="Ss">
<h2 class="Ss" id="Eyapp_Grammar"><a class="permalink" href="#Eyapp_Grammar">Eyapp
  Grammar</a></h2>
<p class="Pp">This section describes the syntax of the Eyapp language using its
    own notation. The grammar extends yacc and yapp grammars. Semicolons have
    been omitted to save space. Between C-like comments you can find an
    (informal) explanation of the language associated with the token.</p>
<p class="Pp"></p>
<pre>
  eyapp: head body tail ;
  symbol: LITERAL  /* A string literal like 'hello' */
      |   ident   
  ident:  IDENT  /* IDENT is [A-Za-z_][A-Za-z0-9_]* */ 
  head: headsec '%%'
  headsec:  decl *
  decl:  '\n'      
      |   SEMANTIC typedecl symlist '\n'  /* SEMANTIC  is %semantic\s+token      */
      |   SYNTACTIC typedecl symlist '\n' /* SYNTACTIC is %syntactic\s+token     */
      |   TOKEN typedecl symlist '\n'     /* TOKEN     is %token                 */
      |   ASSOC typedecl symlist '\n'     /* ASSOC     is %(left|right|nonassoc) */
      |   START ident '\n'                /* START     is %start                 */
      |   HEADCODE '\n'                   /* HEADCODE  is %{ Perl code ... %}    */
      |   UNION CODE '\n'                 /* UNION CODE  see yacc/bison          */
      |   DEFAULTACTION CODE '\n'         /* DEFAULTACTION is %defaultaction     */
      |   TREE treeclauses? '\n'          /* TREE      is %tree                  */
      |   METATREE '\n'                   /* METATREE  is %metatree              */
      |   TYPE typedecl identlist '\n'    /* TYPE      is %type                  */
      |   EXPECT NUMBER '\n'              /* EXPECT    is %expect                */
                                          /* NUMBER    is \d+                    */
  typedecl:   /* empty */
      |       '&lt;' IDENT '&gt;'
  treeclauses: BYPASS ALIAS? | ALIAS BYPASS?
  symlist:    symbol + 
  identlist:  ident +
  body: rules * '%%'
  rules: IDENT ':' rhss ';'  
  rhss: rule &lt;+ '|'&gt;  
  rule:   optname rhs (prec epscode)?
  rhs:  rhseltwithid *
  rhseltwithid : 
        rhselt '.' IDENT 
      | '$' rhselt  
      | rhselt
  rhselt:     symbol    
      | code    
      | '(' optname rhs ')' 
      | rhselt STAR               /* STAR   is (%name\s*([A-Za-z_]\w*)\s*)?\*  */
      | rhselt '&lt;' STAR symbol '&gt;' 
      | rhselt OPTION             /* OPTION is (%name\s*([A-Za-z_]\w*)\s*)?\?  */
      | rhselt '&lt;' PLUS symbol '&gt;'
      | rhselt PLUS               /* PLUS   is (%name\s*([A-Za-z_]\w*)\s*)?\+  */
  optname: (NAME IDENT)?          /* NAME is %name */
         | NOBYPASS IDENT         /* NOBYPASS is %no\s+bypass */
  prec: PREC symbol               /* PREC is %prec */
  epscode:  code ?   
  code:   
      CODE           /* CODE     is { Perl code ... }         */
    | BEGINCODE      /* BEGINCODE is %begin { Perl code ... } */
  tail:  TAILCODE ?  /* TAILCODE is { Perl code ... } */
</pre>
<p class="Pp">The semantic of <span class="Li">&quot;Eyapp&quot;</span> agrees
    with the semantic of <span class="Li">&quot;yacc&quot;</span> and
    <span class="Li">&quot;yapp&quot;</span> for all the common
  constructions.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Comments"><a class="permalink" href="#Comments">Comments</a></h2>
<p class="Pp">Comments are either Perl style, from
    <span class="Li">&quot;#&quot;</span> up to the end of line, or C style,
    enclosed between <span class="Li">&quot;/*&quot;</span> and
    <span class="Li">&quot;*/&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Syntactic_Variables,_Symbolic_Tokens_and_String_Literals"><a class="permalink" href="#Syntactic_Variables,_Symbolic_Tokens_and_String_Literals">Syntactic
  Variables, Symbolic Tokens and String Literals</a></h2>
<p class="Pp">Two kind of symbols may appear inside a Parse::Eyapp program:
    <i>Non-terminal</i> symbols or <i>syntactic variables</i>, called also
    <i>left-hand-side</i> symbols and <i>Terminal</i> symbols, called also
    <i>Tokens</i>.</p>
<p class="Pp">Tokens are the symbols the lexical analyzer function returns to
    the parser. There are two kinds: <i>symbolic tokens</i> and <i>string</i>
    <i>literals</i>.</p>
<p class="Pp"><i>Syntactic variables</i> and <i>symbolic tokens</i> identifiers
    must conform to the regular expression
    <span class="Li">&quot;[A-Za-z][A-Za-z0-9_]*&quot;</span>.</p>
<p class="Pp">When building the syntax tree (i.e. when running under the
    <span class="Li">%tree</span> directive) <i>symbolic tokens</i> will be
    considered <i>semantic tokens</i> (see section &quot;Syntactic and Semantic
    tokens&quot;).</p>
<p class="Pp">String literals are enclosed in single quotes and can contain
    almost anything. They will be received by the parser as double-quoted
    strings. Any special character as <span class="Li">'&quot;'</span>,
    <span class="Li">'$'</span> and <span class="Li">'@'</span> is escaped. To
    have a single quote inside a literal, escape it with '\'.</p>
<p class="Pp">When building the syntax tree (i.e. when running under the
    <span class="Li">%tree</span> directive) <i>string literals</i> will be
    considered <i>syntactic tokens</i> (see section &quot;Syntactic and Semantic
    tokens&quot;).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Parts_of_an__eyapp__Program"><a class="permalink" href="#Parts_of_an__eyapp__Program">Parts
  of an &quot;eyapp&quot; Program</a></h2>
<p class="Pp">An Eyapp program has three parts called head, body and tail:</p>
<p class="Pp"></p>
<pre>
                                 eyapp: head body tail ;
</pre>
<p class="Pp">Each part is separated from the former by the symbol
    <span class="Li">&quot;%%&quot;</span>:</p>
<p class="Pp"></p>
<pre>
                                 head: headsec '%%'
                                 body: rulesec '%%'
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Head_Section"><a class="permalink" href="#The_Head_Section">The
  Head Section</a></h2>
<p class="Pp">The head section contains a list of declarations</p>
<p class="Pp"></p>
<pre>
                                 headsec:  decl *
</pre>
<p class="Pp">There are different kinds of declarations.</p>
<p class="Pp">This reference does not fully describes all the declarations that
    are shared with yacc and yapp.</p>
<p class="Pp"><i>Example of Head Section</i></p>
<p class="Pp">In this and the next sections we will describe the basics of the
    Eyapp language using the file
    <span class="Li">&quot;examples/Calc.eyp&quot;</span> that accompanies this
    distribution. This file implements a trivial calculator. Here is the header
    section:</p>
<p class="Pp"></p>
<pre>
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed -ne '1,11p' Calc.eyp | cat -n
  1  # examples/Calc.eyp
  2  %right  '='
  3  %left   '-' '+'
  4  %left   '*' '/'
  5  %left   NEG
  6  %right  '^'
  7  %{
  8  my %s; # symbol table
  9  %}
 10
 11  %%
</pre>
<p class="Pp"><i>Declarations and Precedence</i></p>
<p class="Pp">Lines 2-5 declare several tokens. The usual way to declare tokens
    is through the <span class="Li">%token</span> directive. The declarations
    <span class="Li">%nonassoc</span>, <span class="Li">%left</span> and
    <span class="Li">%right</span> not only declare the tokens but also
    associate a <i>priority</i> with them. Tokens declared in the same line have
    the same precedence. Tokens declared with these directives in lines below
    have more precedence than those declared above. Thus, in the example above
    we are saying that <span class="Li">&quot;+&quot;</span> and
    <span class="Li">&quot;-&quot;</span> have the same precedence but higher
    precedence than =. The final effect of <span class="Li">&quot;-&quot;</span>
    having greater precedence than = will be that an expression like:</p>
<p class="Pp"></p>
<pre>
                        a = 4 - 5
</pre>
<p class="Pp">will be interpreted as</p>
<p class="Pp"></p>
<pre>
                        a = (4 - 5)
</pre>
<p class="Pp">and not as</p>
<p class="Pp"></p>
<pre>
                        (a = 4) - 5
</pre>
<p class="Pp">The use of the <span class="Li">%left</span> indicates that - in
    case of ambiguity and a match between precedences - the parser must build
    the tree corresponding to a left parenthesization. Thus, the expression</p>
<p class="Pp"></p>
<pre>
                         4 - 5 - 9
</pre>
<p class="Pp">will be interpreted as</p>
<p class="Pp"></p>
<pre>
                         (4 - 5) - 9
</pre>
<p class="Pp"><i>Header Code</i></p>
<p class="Pp">Perl code surrounded by <span class="Li">&quot;%{&quot;</span> and
    <span class="Li">&quot;%}&quot;</span> can be inserted in the head section.
    Such code will be inserted in the module generated by
    <span class="Li">&quot;eyapp&quot;</span> near the beginning. Therefore,
    declarations like the one of the calculator symbol table
    <span class="Li">%s</span></p>
<p class="Pp"></p>
<pre>
  7  %{
  8  my %s; # symbol table
  9  %}
</pre>
<p class="Pp">will be visible from almost any point in the file.</p>
<p class="Pp"><i>The Start Symbol of the Grammar</i></p>
<p class="Pp"><span class="Li">&quot;%start IDENT&quot;</span> declares
    <span class="Li">&quot;IDENT&quot;</span> as the start symbol of the
    grammar. When <span class="Li">%start</span> is not used, the first rule in
    the body section will be used.</p>
<p class="Pp"><i>Expect</i></p>
<p class="Pp">The <span class="Li">&quot;%expect #NUMBER&quot;</span> directive
    works as in bison and suppress warnings when the number of Shift/Reduce
    conflicts is exactly <span class="Li">&quot;#NUMBER&quot;</span>. See
    section &quot;Solving Ambiguities and Conflicts&quot; to know more about
    Shift/Reduce conflicts.</p>
<p class="Pp"><i>Type and Union</i></p>
<p class="Pp">C oriented declarations like <span class="Li">%type</span> and
    <span class="Li">%union</span> are parsed but ignored.</p>
<p class="Pp"><i>The </i><i>%strict</i><i> Directive</i></p>
<p class="Pp">By default, identifiers appearing in the rule section will be
    classified as terminal if they don't appear in the left hand side of any
    production rules.</p>
<p class="Pp">The directive <span class="Li">%strict</span> forces the
    declaration of all tokens. The following
    <span class="Li">&quot;eyapp&quot;</span> program issues a warning:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ cat -n bugyapp2.eyp
       1  %strict
       2  %%
       3  expr: NUM;
       4  %%
  pl@nereida:~/LEyapp/examples$ eyapp bugyapp2.eyp
  Warning! Non declared token NUM at line 3 of bugyapp2.eyp
</pre>
<p class="Pp">To keep silent the compiler declare all tokens using one of the
    token declaration directives (<span class="Li">%token</span>,
    <span class="Li">%left</span>, etc.)</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ cat -n bugyapp3.eyp
       1  %strict
       2  %token NUM
       3  %%
       4  expr: NUM;
       5  %%
  pl@nereida:~/LEyapp/examples$ eyapp bugyapp3.eyp
  pl@nereida:~/LEyapp/examples$
</pre>
<p class="Pp">It is a good practice to use <span class="Li">%strict</span> at
    the beginning of your grammar.</p>
<p class="Pp"><i>Default Action Directive</i></p>
<p class="Pp">In <span class="Li">&quot;Parse::Eyapp&quot;</span> you can modify
    the default action using the <span class="Li">&quot;%defaultaction { Perl
    code }&quot;</span> directive. See section &quot;Default actions&quot;.</p>
<p class="Pp"><i>Tree Construction Directives</i></p>
<p class="Pp"><span class="Li">&quot;Parse::Eyapp&quot;</span> facilitates the
    construction of concrete syntax trees and abstract syntax trees (abbreviated
    AST from now on) through the <span class="Li">%tree</span>
    <span class="Li">%metatree</span> directives. See section &quot;Abstract
    Syntax Trees : <span class="Li">%tree</span> and
    <span class="Li">%name</span>&quot; and
  Parse::Eyapp::translationschemestut.</p>
<p class="Pp"><i>Syntactic and Semantic Tokens</i></p>
<p class="Pp">The new token declaration directives
    <span class="Li">&quot;%syntactic token&quot;</span> and
    <span class="Li">&quot;%semantic token&quot;</span> can change the way
    <span class="Li">&quot;eyapp&quot;</span> builds the abstract syntax tree.
    See section &quot;Syntactic and Semantic tokens&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Body"><a class="permalink" href="#The_Body">The
  Body</a></h2>
<p class="Pp">The body section contains the rules describing the grammar:</p>
<p class="Pp"></p>
<pre>
                       body:   rules * '%%'
                       rules:  IDENT ':' rhss ';'  
                       rhss:   (optname rhs (prec epscode)?) &lt;+ '|'&gt;
</pre>
<p class="Pp"><i>Rules</i></p>
<p class="Pp">A rule is made of a left-hand-side symbol (the <i>syntactic
    variable</i>), followed by a <span class="Li">':'</span> and one or more
    <i>right-hand-sides</i> (or <i>productions</i>)
  <br/>
   separated by <span class="Li">'|'</span> and terminated by a
    <span class="Li">';'</span> like in:</p>
<p class="Pp"></p>
<pre>
                          exp: 
                               exp '+' exp
                            |  exp '-' exp
                            |  NUM
                          ;
</pre>
<p class="Pp">A <i>production</i> (<i>right hand side</i>) may be empty:</p>
<p class="Pp"></p>
<pre>
                          input:   
                               /* empty */
                            |  input line
                          ;
</pre>
<p class="Pp">The former two productions can be abbreviated as</p>
<p class="Pp"></p>
<pre>
                          input: 
                               line *
                          ;
</pre>
<p class="Pp">The operators <span class="Li">&quot;*&quot;</span>,
    <span class="Li">&quot;+&quot;</span> and
    <span class="Li">&quot;?&quot;</span> are presented in section &quot;Lists
    and Optionals&quot;.</p>
<p class="Pp">A <i>syntactic variable cannot appear more than once as</i> <i>a
    rule name</i> (This differs from yacc).</p>
<p class="Pp"><i>Semantic Values and Semantic Actions</i></p>
<p class="Pp">In <span class="Li">&quot;Parse::Eyapp&quot;</span> a production
    rule</p>
<p class="Pp"></p>
<pre>
                          A -&gt; X_1 X_2 ... X_n
</pre>
<p class="Pp">can be followed by a <i>semantic action</i>:</p>
<p class="Pp"></p>
<pre>
                    A -&gt; X_1 X_2 ... X_n { Perl Code }
</pre>
<p class="Pp">Such semantic action is nothing but Perl code that will be treated
    as an anonymous subroutine. The semantic action associated with production
    rule <span class="Li">&quot;A -&gt; X_1 X_2 ... X_n&quot;</span> is executed
    after any actions associated with the subtrees of
    <span class="Li">&quot;X_1&quot;</span>,
    <span class="Li">&quot;X_2&quot;</span>, ...,
    <span class="Li">&quot;X_n&quot;</span>.
    <span class="Li">&quot;Eyapp&quot;</span> parsers build the syntax tree
    using a left-right bottom-up traverse of the syntax tree. Each times the
    Parser visits the node associated with the production
    <span class="Li">&quot;A -&gt; X_1 X_2 ... X_n&quot;</span> the associated
    semantic action is called. Asociated with each symbol of a Parse::Eyapp
    grammar there is a scalar <i>Semantic Value</i> or <i>Attribute</i>. The
    semantic values of terminals are provided by the lexical analyzer. In the
    calculator example (see file
    <span class="Li">&quot;examples/Calc.yp&quot;</span> in the distribution),
    the semantic value associated with an expression is its numeric value. Thus
    in the rule:</p>
<p class="Pp"></p>
<pre>
                       exp '+' exp { $_[1] + $_[3] }
</pre>
<p class="Pp"><span class="Li">$_[1]</span> refers to the attribute of the first
    <span class="Li">&quot;exp&quot;</span>, <span class="Li">$_[2]</span> is
    the attribute associated with <span class="Li">'+'</span>, which is the
    second component of the pair provided by the lexical analyzer and
    <span class="Li">$_[3]</span> refers to the attribute of the second
    <span class="Li">&quot;exp&quot;</span>.</p>
<p class="Pp">When the semantic action/anonymous subroutine is called, the
    arguments are as follows:</p>
<ul class="Bl-bullet">
  <li><span class="Li">$_[1]</span> to <span class="Li">$_[n]</span> are the
      attributes of the symbols <span class="Li">&quot;X_1&quot;</span>,
      <span class="Li">&quot;X_2&quot;</span>, ...,
      <span class="Li">&quot;X_n&quot;</span>. Just as
      <span class="Li">$1</span> to <span class="Li">$n</span> in yacc,</li>
  <li><span class="Li">$_[0]</span> is the parser object itself. Having
      <span class="Li">$_[0]</span> beeing the parser object itself allows you
      to call parser methods. Most yacc macros have been converted into parser
      methods. See section 'Methods Available in the Generated Class' in
      Parse::Eyapp.</li>
</ul>
<p class="Pp">The returned value will be the attribute associated with the left
    hand side of the production.</p>
<p class="Pp">Names can be given to the attributes using the dot notation (see
    file <span class="Li">&quot;examples/CalcSimple.eyp&quot;</span>):</p>
<p class="Pp"></p>
<pre>
                     exp.left '+' exp.right { $left + $right }
</pre>
<p class="Pp">See section &quot;Names for attributes&quot; for more details
    about the <i>dot</i> and <i>dollar</i> notations.</p>
<p class="Pp">If no action is specified and no
    <span class="Li">%defaultaction</span> is specified the default action</p>
<p class="Pp"></p>
<pre>
                               { $_[1] }
</pre>
<p class="Pp">will be executed instead. See section &quot;Default actions&quot;
    to know more.</p>
<p class="Pp"><i>Actions in Mid-Rule</i></p>
<p class="Pp">Actions can be inserted in the middle of a production like in:</p>
<p class="Pp"></p>
<pre>
 block: '{'.bracket { $ids-&gt;begin_scope(); } declaration*.decs statement*.sts '}' { ... }
</pre>
<p class="Pp">A middle production action is managed by inserting a new rule in
    the grammar and associating the semantic action with it:</p>
<p class="Pp"></p>
<pre>
                     Temp: /* empty */ { $ids-&gt;begin_scope(); }
</pre>
<p class="Pp">Middle production actions can refer to the attributes on its left.
    They count as one of the components of the production. Thus the program:</p>
<p class="Pp"></p>
<pre>
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed -ne '1,4p' intermediateaction2.yp
 %%
 S:  'a' { $_[1]x4 }.mid 'a' { print &quot;$_[2], $mid, $_[3]\n&quot;; }
 ;
 %%
</pre>
<p class="Pp">The auxiliar syntactic variables are named
    <span class="Li">&quot;@#position-#order&quot;</span> where
    <span class="Li">&quot;#position&quot;</span> is the position of the action
    in the rhs and <span class="Li">&quot;order&quot;</span> is an ordinal
    number. See the <span class="Li">&quot;.output&quot;</span> file for the
    former example:</p>
<p class="Pp"></p>
<pre>
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ eyapp -v intermediateaction2.yp
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed -ne '1,5p' intermediateaction2.output
 Rules:
 ------
 0:      $start -&gt; S $end
 1:      S -&gt; 'a' @1-1 'a'
 2:      @1-1 -&gt; /* empty */
</pre>
<p class="Pp">when given input <span class="Li">&quot;aa&quot;</span> the
    execution will produce as output <span class="Li">&quot;aaaa, aaaa,
    a&quot;</span>.</p>
<p class="Pp"><i>Example of Body Section</i></p>
<p class="Pp">Following with the calculator example, the body is:</p>
<p class="Pp"></p>
<pre>
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed -ne '12,48p' Calc.eyp | cat -n
  1  start:
  2      input { \%s }
  3  ;
  4
  5  input: line *
  6  ;
  7
  8  line:
  9    '\n'         { undef }
 10    | exp '\n'   { print &quot;$_[1]\n&quot; if defined($_[1]); $_[1] }
 11    | error  '\n'
 12        {
 13          $_[0]-&gt;YYErrok;
 14          undef
 15        }
 16  ;
 17
 18  exp:
 19      NUM
 20    | $VAR                   { $s{$VAR} }
 21    | $VAR '=' $exp          { $s{$VAR} = $exp }
 22    | exp.left '+' exp.right { $left + $right }
 23    | exp.left '-' exp.right { $left - $right }
 24    | exp.left '*' exp.right { $left * $right }
 25    | exp.left '/' exp.right
 26      {
 27         $_[3] and return($_[1] / $_[3]);
 28         $_[0]-&gt;YYData-&gt;{ERRMSG} = &quot;Illegal division by zero.\n&quot;;
 29         $_[0]-&gt;YYError; # Pretend that a syntactic error ocurred: _Error will be called
 30         undef
 31      }
 32    | '-' $exp %prec NEG     { -$exp }
 33    | exp.left '^' exp.right { $left ** $right }
 34    | '(' $exp ')'           { $exp }
 35  ;
 36
 37  %%
</pre>
<p class="Pp">This example does not uses any of the Eyapp extensions (with the
    exception of the <i>star list</i> at line 5) and the dot and dollar
    notations. Please, see the Parse::Yapp pages and elsewhere documentation on
    yacc and bison for more information.</p>
<p class="Pp"><i>Solving Ambiguities and Conflicts</i></p>
<p class="Pp">When Eyapp analizes a grammar like:</p>
<p class="Pp"></p>
<pre>
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ cat -n ambiguities.eyp
     1  %%
     2  exp:
     3      NUM
     4    | exp '-' exp
     5  ;
     6  %%
</pre>
<p class="Pp">it will produce a warning announcing the existence of
    <i>shift-reduce</i> conflicts:</p>
<p class="Pp"></p>
<pre>
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ eyapp ambiguities.eyp
 1 shift/reduce conflict (see .output file)
 State 5: reduce by rule 2: exp -&gt; exp '-' exp (default action)
 State 5: shifts:
   to state    3 with '-'
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ ls -ltr | tail -1
 -rw-rw----  1 pl users   1082 2007-02-06 08:26 ambiguities.output
</pre>
<p class="Pp">when <span class="Li">&quot;eyapp&quot;</span> finds warnings
    automatically produces a <span class="Li">&quot;.output&quot;</span> file
    describing the conflict.</p>
<p class="Pp">What the warning is saying is that an expression like
    <span class="Li">&quot;exp '-' exp&quot;</span> (rule 2) followed by a minus
    <span class="Li">'-'</span> can be worked in more than one way. If we have
    an input like <span class="Li">&quot;NUM - NUM - NUM&quot;</span> the
    activity of a <b>LALR</b>(1) parser (the family of parsers to which Eyapp
    belongs) consists of a sequence of <i>shift and reduce actions</i>. A
    <i>shift action</i> has as consequence the reading of the next token. A
    <i>reduce action</i> is finding a production rule that matches and
    substituting the rhs of the production by the lhs. For input
    <span class="Li">&quot;NUM - NUM - NUM&quot;</span> the activity will be as
    follows (the dot is used to indicate where the next input token is):</p>
<p class="Pp"></p>
<pre>
                           .NUM - NUM - NUM # shift
                            NUM.- NUM - NUM # reduce exp: NUM 
                            exp.- NUM - NUM # shift
                            exp -.NUM - NUM # shift
                            exp - NUM.- NUM # reduce exp: NUM
                            exp - exp.- NUM # shift/reduce conflict
</pre>
<p class="Pp">up this point two different decisions can be taken: the next
    description can be</p>
<p class="Pp"></p>
<pre>
                                  exp.- NUM # reduce by exp: exp '-' exp (rule 2)
</pre>
<p class="Pp">or:</p>
<p class="Pp"></p>
<pre>
                            exp - exp -.NUM # shift '-' (to state 3)
</pre>
<p class="Pp">that is why it is called a <i>shift-reduce conflict</i>.</p>
<p class="Pp">That is also the reason for the precedence declarations in the
    head section. Another kind of conflicts are <i>reduce-reduce conflicts</i>.
    They arise when more that rhs can be applied for a reduction action.</p>
<p class="Pp">Eyapp solves the conflicts applying the following rules:</p>
<ul class="Bl-bullet">
  <li>In a shift/reduce conflict, the default is the shift.</li>
  <li>In a reduce/reduce conflict, the default is to reduce by the earlier
      grammar production (in the input sequence).</li>
  <li>The precedences and associativities are associated with tokens in the
      declarations section. This is made by a sequence of lines beginning with
      one of the directives: <span class="Li">%left</span>,
      <span class="Li">%right</span>, or <span class="Li">%nonassoc</span>,
      followed by a list of tokens. All the tokens on the same line have the
      same precedence and associativity; the lines are listed in order of
      increasing precedence.</li>
  <li>A precedence and associativity is associated with each grammar production;
      it is the precedence and associativity of the <i>last token</i> or
      <i>literal</i> in the right hand side of the production.</li>
  <li>The <span class="Li">%prec</span> directive can be used when a rhs is
      involved in a conflict and has no tokens inside or it has but the
      precedence of the last token leads to an incorrect interpretation. A rhs
      can be followed by an optional <span class="Li">&quot;%prec
      token&quot;</span> directive giving the production the precedence of the
      <span class="Li">&quot;token&quot;</span>
    <p class="Pp"></p>
    <pre>
                          exp:   '-' exp %prec NEG { -$_[1] }
    </pre>
  </li>
  <li>If there is a shift/reduce conflict, and both the grammar production and
      the input character have precedence and associativity associated with
      them, then the conflict is solved in favor of the action (shift or reduce)
      associated with the higher precedence. If the precedences are the same,
      then the associativity is used; left associative implies reduce, right
      associative implies shift, and nonassociating implies error.</li>
</ul>
<p class="Pp">To solve a shift-reduce conflict between a production
    <span class="Li">&quot;A --&gt; SOMETHING&quot;</span> and a token
    <span class="Li">'a'</span> you can follow this procedure:</p>
<dl class="Bl-tag">
  <dt>1. Edit the &quot;.output&quot; file</dt>
  <dd></dd>
  <dt>2. Search for the state where the conflict between the production and the
    token is. In our example it looks like:</dt>
  <dd>
    <pre>
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed -ne '56,65p' ambiguities.output
 State 5:

        exp -&gt; exp . '-' exp    (Rule 2)
        exp -&gt; exp '-' exp .    (Rule 2)

        '-'     shift, and go to state 3

        '-'     [reduce using rule 2 (exp)]
        $default        reduce using rule 2 (exp)
    </pre>
  </dd>
  <dt>3. Inside the state there has to be a production of the type &quot;A
    --&gt; SOMETHING.&quot; (with the dot at the end) indicating that a
    reduction must take place. There has to be also another production of the
    form &quot;A --&gt; prefix . suffix&quot;, where suffix can <i>start</i>
    with the involved token 'a'.</dt>
  <dd></dd>
  <dt>4. Decide what action shift or reduce matches the kind of trees you want.
    In this example we want &quot;NUM - NUM - NUM&quot; to produce a tree like
    &quot;MINUS(MINUS(NUM, NUM), NUM)&quot; and not &quot;MINUS(NUM, MINUS(NUM,
    NUM))&quot;. We want the conflict in &quot;exp - exp.- NUM&quot; to be
    solved in favor of the reduction by &quot;exp: exp '-' exp&quot;. This is
    achieved by declaring &quot;%left '-'&quot;.</dt>
  <dd></dd>
</dl>
<p class="Pp"><i>Error Recovery</i></p>
<p class="Pp">The token name <span class="Li">&quot;error&quot;</span> is
    reserved for error handling. This name can be used in grammar productions;
    it suggests places where errors are expected, and recovery can take
  place:</p>
<p class="Pp"></p>
<pre>
     line:
       '\n'         { undef }
       | exp '\n'   { print &quot;$_[1]\n&quot; if defined($_[1]); $_[1] }
       | error  '\n'
           {
             $_[0]-&gt;YYErrok;
             undef
           }
</pre>
<p class="Pp">The parser pops its stack until it enters a state where the token
    <span class="Li">&quot;error&quot;</span> is legal. It then shifts the token
    <span class="Li">&quot;error&quot;</span> and proceeds to discard tokens
    until finding one that is acceptable. In the example all the tokens until
    finding a <span class="Li">'\n'</span> will be skipped. If no special error
    productions have been specified, the processing will halt.</p>
<p class="Pp">In order to prevent a cascade of error messages, the parser, after
    detecting an error, remains in error state until three tokens have been
    successfully read and shifted. If an error is detected when the parser is
    already in error state, no message is given, and the input token is quietly
    deleted. The method <span class="Li">&quot;YYErrok&quot;</span> used in the
    example communicates to the parser that a satisfactory recovery has been
    reached and that it can safely emit new error messages.</p>
<p class="Pp">You cannot have a literal <i>'error'</i> in your grammar as it
    would confuse the driver with the <i>error</i> token. Use a symbolic token
    instead.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Tail"><a class="permalink" href="#The_Tail">The
  Tail</a></h2>
<p class="Pp">The tail section contains Perl code. Usually the lexical analyzer
    and the Error management subroutines go there. A better practice however is
    to isolate both subroutines in a module and use them in the grammar. An
    example of this is in files
    <span class="Li">&quot;examples/CalcUsingTail.eyp&quot;</span> and
    <span class="Li">&quot;examples/Tail.pm&quot;</span>.</p>
<p class="Pp"><i>The Lexical Analyzer</i></p>
<p class="Pp">The Lexical Analyzer is called each time the parser needs a new
    token. It is called with only one argument (the parser object) and returns a
    pair containing the next token and its associated attribute.</p>
<p class="Pp">The fact that is a method of the parser object means that the
    parser methods are accesible inside the lexical analyzer. Specially
    interesting is the <span class="Li">&quot;$_[0]-&gt;YYData&quot;</span>
    method which provides access to the user data area.</p>
<p class="Pp"><i>When the lexical analyzer reaches the end of input, it must
    return the</i> <i>pair</i> <span class="Li">&quot;('',
  undef)&quot;</span></p>
<p class="Pp">See below how to write a lexical analyzer (file
    <span class="Li">&quot;examples/Calc.eyp&quot;</span>):</p>
<p class="Pp"></p>
<pre>
  1  sub make_lexer {
  2    my $input = shift;
  3
  4    return sub {
  5      my $parser = shift;
  6
  7      for ($$input) {
  8        m{\G[ \t]*}gc;
  9        m{\G([0-9]+(?:\.[0-9]+)?)}gc   and return ('NUM',$1);
 10        m{\G([A-Za-z][A-Za-z0-9_]*)}gc and return ('VAR',$1);
 11        m{\G\n}gc                      and do { $lineno++; return (&quot;\n&quot;, &quot;\n&quot;) };
 12        m{\G(.)}gc                     and return ($1,$1);
 13
 14        return('',undef);
 15      }
 16    }
 17  }
</pre>
<p class="Pp">The subroutine <span class="Li">&quot;make_lexer&quot;</span>
    creates the lexical analyzer as a closure. The lexer returned by
    <span class="Li">&quot;make_lexer&quot;</span> is used by the
    <span class="Li">&quot;YYParse&quot;</span> method:</p>
<p class="Pp"></p>
<pre>
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed -ne '90,97p' Calc.eyp | cat -n
 1  sub Run {
 2      my($self)=shift;
 3      my $input = shift or die &quot;No input given\n&quot;;
 4
 5      return $self-&gt;YYParse( yylex =&gt; make_lexer($input), yyerror =&gt; \&amp;_Error,
 6        #yydebug =&gt;0x1F
 7      );
 8  }
</pre>
<p class="Pp"><i>The Error Report Subroutine</i></p>
<p class="Pp">The Error Report subroutine is also a parser method, and
    consequently receives as parameter the parser object.</p>
<p class="Pp">See the error report subroutine for the example in
    <span class="Li">&quot;examples/Calc.eyp&quot;</span>:</p>
<p class="Pp"></p>
<pre>
  1  %%
  2
  3  my $lineno = 1;
  4
  5  sub _Error {
  6    my $parser = shift;
  7
  8      exists $parser-&gt;YYData-&gt;{ERRMSG}
  9    and do {
 10        print $parser-&gt;YYData-&gt;{ERRMSG};
 11        delete $parser-&gt;YYData-&gt;{ERRMSG};
 12        return;
 13    };
 14    my($token)=$parser-&gt;YYCurval;
 15    my($what)= $token ? &quot;input: '$token'&quot; : &quot;end of input&quot;;
 16    my @expected = $parser-&gt;YYExpect();
 17    local $&quot; = ', ';
 18    print &lt;&lt; &quot;ERRMSG&quot;;
 19
 20  Syntax error near $what (lin num $lineno).
 21  Expected one of these terminals: @expected
 22  ERRMSG
 23  }
</pre>
<p class="Pp">See the Parse::Yapp pages and elsewhere documentation on yacc and
    bison for more information.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_an_Eyapp_Program"><a class="permalink" href="#Using_an_Eyapp_Program">Using
  an Eyapp Program</a></h2>
<p class="Pp">The following is an example of a program that uses the calculator
    explained in the two previous sections:</p>
<p class="Pp"></p>
<pre>
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ cat -n usecalc.pl
  1  #!/usr/bin/perl -w
  2  use strict;
  3  use Calc;
  4
  5  my $parser = Calc-&gt;new();
  6  my $input = &lt;&lt;'EOI';
  7  a = 2*3
  8  d = 5/(a-6)
  9  b = (a+1)/7
 10  c=a*3+4)-5
 11  a = a+1
 12  EOI
 13  my $t = $parser-&gt;Run(\$input);
 14  print &quot;========= Symbol Table ==============\n&quot;;
 15  print &quot;$_ = $t-&gt;{$_}\n&quot; for sort keys %$t;
</pre>
<p class="Pp">The output for this program is (the input for each output appear
    as a Perl comment on the right):</p>
<p class="Pp"></p>
<pre>
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ eyapp Calc.eyp
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ usecalc.pl
 6                                              # a = 2*3
 Illegal division by zero.                      # d = 5/(a-6)
 1                                              # b = (a+1)/7

 Syntax error near input: ')' (lin num 4).      # c=a*3+4)-5
 Expected one of these terminals: -, /, ^, *, +,

 7                                              # a = a+1
 ========= Symbol Table ==============
 a = 7
 b = 1
 c = 22
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Lists_and_Optionals"><a class="permalink" href="#Lists_and_Optionals">Lists
  and Optionals</a></h2>
<p class="Pp">The elements of a rhs can be one of these:</p>
<p class="Pp"></p>
<pre>
  rhselt:     
        symbol    
      | code    
      | '(' optname rhs ')' 
      | rhselt STAR               /* STAR   is (%name\s*([A-Za-z_]\w*)\s*)?\*  */
      | rhselt '&lt;' STAR symbol '&gt;' 
      | rhselt OPTION             /* OPTION is (%name\s*([A-Za-z_]\w*)\s*)?\?  */
      | rhselt '&lt;' PLUS symbol '&gt;'
      | rhselt PLUS               /* PLUS   is (%name\s*([A-Za-z_]\w*)\s*)?\+  */
</pre>
<p class="Pp">The <span class="Li">&quot;STAR&quot;</span>,
    <span class="Li">&quot;OPTION&quot;</span> and
    <span class="Li">&quot;PLUS&quot;</span> operators provide a simple
    mechanism to express lists:</p>
<ul class="Bl-bullet">
  <li>In Eyapp the <span class="Li">&quot;+&quot;</span> operator indicates one
      or more repetitions of the element to the left of
      <span class="Li">&quot;+&quot;</span>, thus a rule like:
    <p class="Pp"></p>
    <pre>
                        decls:  decl +
    </pre>
    <p class="Pp">is the same as:</p>
    <p class="Pp"></p>
    <pre>
                        decls:  decls decl 
                             |  decl
    </pre>
    <p class="Pp">An additional symbol may be included to indicate lists of
        elements separated by such symbol. Thus</p>
    <p class="Pp"></p>
    <pre>
                       rhss: rule &lt;+ '|'&gt;
    </pre>
    <p class="Pp">is equivalent to:</p>
    <p class="Pp"></p>
    <pre>
                       rhss: rhss '|' rule 
                           | rule
    </pre>
  </li>
  <li>The operators <span class="Li">&quot;*&quot;</span> and
      <span class="Li">&quot;?&quot;</span> have their usual meaning: 0 or more
      for <span class="Li">&quot;*&quot;</span> and optionality for
      <span class="Li">&quot;?&quot;</span>. Is legal to parenthesize a
      <span class="Li">&quot;rhs&quot;</span> expression as in:
    <p class="Pp"></p>
    <pre>
                       optname: (NAME IDENT)?
    </pre>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Semantic_of_Lists_Operators"><a class="permalink" href="#The_Semantic_of_Lists_Operators">The
  Semantic of Lists Operators</a></h2>
<p class="Pp"><i>The </i><i>&quot;+&quot;</i><i> operator</i></p>
<p class="Pp">The grammar:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ head -12 List3.yp | cat -n
   1  # List3.yp
   2  %semantic token 'c'
   3  %{
   4  use Data::Dumper;
   5  %}
   6  %%
   7  S:      'c'+  'd'+
   8             {
   9                print Dumper($_[1]);
  10                print Dumper($_[2]);
  11             }
  12  ;
</pre>
<p class="Pp">Is equivalent to:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ eyapp -v List3.yp | head -9 List3.output
  Rules:
  ------
  0:      $start -&gt; S $end
  1:      PLUS-1 -&gt; PLUS-1 'c'
  2:      PLUS-1 -&gt; 'c'
  3:      PLUS-2 -&gt; PLUS-2 'd'
  4:      PLUS-2 -&gt; 'd'
  5:      S -&gt; PLUS-1 PLUS-2
</pre>
<p class="Pp">By default, the semantic action associated with a
    <span class="Li">&quot;+&quot;</span> returns the lists of attributes to
    which the <span class="Li">&quot;+&quot;</span> applies:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ use_list3.pl
  ccdd
  $VAR1 = [ 'c', 'c' ];
  $VAR1 = [ 'd', 'd' ];
</pre>
<p class="Pp">The semantic associated with a
    <span class="Li">&quot;+&quot;</span> changes when one of the tree creation
    directives is active (for instance <span class="Li">%tree</span> or
    <span class="Li">%metatree</span>) or it has been explicitly requested with
    a call to the <span class="Li">&quot;YYBuildingTree&quot;</span> method:</p>
<p class="Pp"></p>
<pre>
                            $self-&gt;YYBuildingTree(1);
</pre>
<p class="Pp">Other ways to change the associated semantic are to use the
    <span class="Li">&quot;yybuildingtree&quot;</span> option of
    <span class="Li">&quot;YYParse&quot;</span>:</p>
<p class="Pp"></p>
<pre>
         $self-&gt;YYParse( yylex =&gt; \&amp;_Lexer, yyerror =&gt; \&amp;_Error,
                           yybuildingtree =&gt; 1,
                         # yydebug =&gt; 0x1F
         );
</pre>
<p class="Pp">In such case the associated semantic action creates a node
    labelled</p>
<p class="Pp"></p>
<pre>
                     _PLUS_LIST_#number
</pre>
<p class="Pp">whose children are the attributes associated with the items in the
    plus list. The <span class="Li">&quot;#number&quot;</span> in
    <span class="Li">&quot;_PLUS_LIST_#number&quot;</span> is the ordinal of the
    production rule as it appears in the
    <span class="Li">&quot;.output&quot;</span> file. As it happens when using
    the <span class="Li">%tree</span> directive syntactic tokens are
  skipped.</p>
<p class="Pp">When executing the example above but under the
    <span class="Li">%tree</span> directive the ouput changes:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ head -3 List3.yp; eyapp List3.yp
  # List3.yp
  %semantic token 'c'
  %tree

  pl@nereida:~/LEyapp/examples$ use_list3.pl
  ccdd
  $VAR1 = bless( {
           'children' =&gt; [
             bless( { 'children' =&gt; [], 'attr' =&gt; 'c', 'token' =&gt; 'c' }, 'TERMINAL' ),
             bless( { 'children' =&gt; [], 'attr' =&gt; 'c', 'token' =&gt; 'c' }, 'TERMINAL' )
           ]
         }, '_PLUS_LIST_1' );
  $VAR1 = bless( { 'children' =&gt; [] }, '_PLUS_LIST_2' );
</pre>
<p class="Pp">The node associated with the list of
    <span class="Li">&quot;d&quot;</span>s is empty since terminal
    <span class="Li">&quot;d&quot;</span> wasn't declared semantic.</p>
<p class="Pp"><i>When Nodes Dissappear from Lists</i></p>
<p class="Pp">When under the influence of the <span class="Li">%tree</span>
    directive the action associated with a list operator is to <i>flat</i> the
    children in a single list.</p>
<p class="Pp">In the former example, the <span class="Li">&quot;d&quot;</span>
    nodes dont show up since <span class="Li">'d'</span> is a syntactic token.
    However, it may happen that changing the status of
    <span class="Li">'d'</span> to semantic will not suffice.</p>
<p class="Pp">When inserting the children, the tree
    (<span class="Li">%tree</span>) node construction method
    (<span class="Li">&quot;YYBuildAST&quot;</span>) omits any attribute that is
    not a reference. Therefore, when inserting explicit actions, it is necessary
    to guarantee that the returned value is a reference or a semantic token to
    assure the presence of the value in the lists of children of the node.
    Certainly you can use this property to prune parts of the tree. Consider the
    following example:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ head -19 ListWithRefs1.eyp | cat -n
   1  # ListWithRefs.eyp
   2  %semantic token 'c' 'd'
   3  %{
   4  use Data::Dumper;
   5  %}
   6  %%
   7  S:      'c'+  D+
   8             {
   9                print Dumper($_[1]);
  10                print $_[1]-&gt;str.&quot;\n&quot;;
  11                print Dumper($_[2]);
  12                print $_[2]-&gt;str.&quot;\n&quot;;
  13             }
  14  ;
  15
  16  D: 'd'
  17  ;
  18
  19  %%
</pre>
<p class="Pp">To activate the <i>tree semantic</i> for lists we use the
    <span class="Li">&quot;yybuildingtree&quot;</span> option of
    <span class="Li">&quot;YYParse&quot;</span>:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ tail -7 ListWithRefs1.eyp | cat -n
       1  sub Run {
       2      my($self)=shift;
       3      $self-&gt;YYParse( yylex =&gt; \&amp;_Lexer, yyerror =&gt; \&amp;_Error,
       4        yybuildingtree =&gt; 1,
       5        #, yydebug =&gt; 0x1F
       6      );
       7  }
</pre>
<p class="Pp">The execution gives an ouput like this:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ eyapp ListWithRefs1.eyp; use_listwithrefs1.pl
  ccdd
  $VAR1 = bless( {
                   'children' =&gt; [
                                   bless( {
                                            'children' =&gt; [],
                                            'attr' =&gt; 'c',
                                            'token' =&gt; 'c'
                                          }, 'TERMINAL' ),
                                   bless( {
                                            'children' =&gt; [],
                                            'attr' =&gt; 'c',
                                            'token' =&gt; 'c'
                                          }, 'TERMINAL' )
                                 ]
                 }, '_PLUS_LIST_1' );
  _PLUS_LIST_1(TERMINAL,TERMINAL)
  $VAR1 = bless( {
                   'children' =&gt; []
                 }, '_PLUS_LIST_2' );
  _PLUS_LIST_2
</pre>
<p class="Pp">Though <span class="Li">'d'</span> was declared semantic the
    default action assoaciated with the production <span class="Li">&quot;D:
    'd'&quot;</span> in line 16 returns <span class="Li">$_[1]</span> (that is,
    the scalar <span class="Li">'d'</span>). Since it is not a reference it
    won't be inserted in the list of children of
    <span class="Li">&quot;_PLUS_LIST&quot;</span>.</p>
<p class="Pp"><i>Recovering the Missing Nodes</i></p>
<p class="Pp">The solution is to be sure that the attribute is a reference:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ head -22 ListWithRefs.eyp | cat -n
   1  # ListWithRefs.eyp
   2  %semantic token 'c'
   3  %{
   4  use Data::Dumper;
   5  %}
   6  %%
   7  S:      'c'+  D+
   8             {
   9                print Dumper($_[1]);
  10                print $_[1]-&gt;str.&quot;\n&quot;;
  11                print Dumper($_[2]);
  12                print $_[2]-&gt;str.&quot;\n&quot;;
  13             }
  14  ;
  15
  16  D: 'd'
  17       {
  18         bless { attr =&gt; $_[1], children =&gt;[]}, 'DES';
  19       }
  20  ;
  21
  22  %%
</pre>
<p class="Pp">Now the attribute associated with
    <span class="Li">&quot;D&quot;</span> is a reference and appears in the list
    of children of <span class="Li">&quot;_PLUS_LIST&quot;</span>:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ eyapp ListWithRefs.eyp; use_listwithrefs.pl
  ccdd
  $VAR1 = bless( {
                   'children' =&gt; [
                                   bless( {
                                            'children' =&gt; [],
                                            'attr' =&gt; 'c',
                                            'token' =&gt; 'c'
                                          }, 'TERMINAL' ),
                                   bless( {
                                            'children' =&gt; [],
                                            'attr' =&gt; 'c',
                                            'token' =&gt; 'c'
                                          }, 'TERMINAL' )
                                 ]
                 }, '_PLUS_LIST_1' );
  _PLUS_LIST_1(TERMINAL,TERMINAL)
  $VAR1 = bless( {
                   'children' =&gt; [
                                   bless( {
                                            'children' =&gt; [],
                                            'attr' =&gt; 'd'
                                          }, 'DES' ),
                                   bless( {
                                            'children' =&gt; [],
                                            'attr' =&gt; 'd'
                                          }, 'DES' )
                                 ]
                 }, '_PLUS_LIST_2' );
  _PLUS_LIST_2(DES,DES)
</pre>
<p class="Pp"><i>Building a Tree with
    </i><i>&quot;Parse::Eyapp::Node-&gt;new&quot;</i><i></i></p>
<p class="Pp">The former solution consisting on writing <i>by hand</i> the code
    to build the node may suffice when dealing with a single node. Writing by
    hand the code to build a node is a cumbersome task. Even worst: though the
    node built in the former example looks like a
    <span class="Li">&quot;Parse::Eyapp&quot;</span> node actually isn't.
    <span class="Li">&quot;Parse::Eyapp&quot;</span> nodes always inherit from
    <span class="Li">&quot;Parse::Eyapp::Node&quot;</span> and consequently have
    access to the methods in such package. Thefollowing execution using the
    debugger illustrates the point:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ perl -wd use_listwithrefs.pl

  Loading DB routines from perl5db.pl version 1.28
  Editor support available.

  Enter h or `h h' for help, or `man perldebug' for more help.

  main::(use_listwithrefs.pl:4):  $parser = new ListWithRefs();
    DB&lt;1&gt;  f ListWithRefs.eyp
  1       2       #line 3 &quot;ListWithRefs.eyp&quot;
  3
  4:      use Data::Dumper;
  5
  6       #line 7 &quot;ListWithRefs.eyp&quot;
  7       #line 8 &quot;ListWithRefs.eyp&quot;
  8
  9:                    print Dumper($_[1]);
  10:                   print $_[1]-&gt;str.&quot;\n&quot;;
</pre>
<p class="Pp">through the command <span class="Li">&quot;f
    ListWithRefs.eyp&quot;</span> we inform the debugger that subsequent
    commands will refer to such file. Next we execute the program up to the
    semantic action associated with the production rule
    <span class="Li">&quot;S: 'c'+ D+&quot;</span> (line 9)</p>
<p class="Pp"></p>
<pre>
    DB&lt;2&gt; c 9     # Continue up to line 9 of ListWithRefs.eyp
  ccdd
  ListWithRefs::CODE(0x84ebe5c)(ListWithRefs.eyp:9):
  9:                    print Dumper($_[1]);
</pre>
<p class="Pp">Now we are in condition to look at the contents of the
  arguments:</p>
<p class="Pp"></p>
<pre>
    DB&lt;3&gt; x $_[2]-&gt;str
  0  '_PLUS_LIST_2(DES,DES)'
    DB&lt;4&gt; x $_[2]-&gt;child(0)
  0  DES=HASH(0x85c4568)
     'attr' =&gt; 'd'
     'children' =&gt; ARRAY(0x85c458c)
          empty array
</pre>
<p class="Pp">the <span class="Li">&quot;str&quot;</span> method works with the
    object <span class="Li">$_[2]</span> since
    <span class="Li">&quot;_PLUS_LIST_2&quot;</span> nodes inherit from
    <span class="Li">&quot;Parse::Eyapp::Node&quot;</span>. However, when we try
    with the <span class="Li">&quot;DES&quot;</span> node we get an error:</p>
<p class="Pp"></p>
<pre>
    DB&lt;6&gt; x $_[2]-&gt;child(0)-&gt;str
  Can't locate object method &quot;str&quot; via package &quot;DES&quot; at \
    (eval 11)[/usr/share/perl/5.8/perl5db.pl:628] line 2, &lt;STDIN&gt; line 1.
    DB&lt;7&gt;
</pre>
<p class="Pp">More robust than the former solution of building the node <i>by
    hand</i> is to use the constructor
    <span class="Li">&quot;Parse::Eyapp::Node-&gt;new&quot;</span>: The method
    <span class="Li">&quot;Parse::Eyapp::Node-&gt;new&quot;</span> is uset to
    build forests of syntactic trees.</p>
<p class="Pp">It receives a list of terms describing the trees and - optionally
    - a reference to a subroutine used to set up the attributes of the just
    created nodes. After the creation of the trees the sub is called by
    <span class="Li">&quot;Parse::Eyapp::Node-&gt;new&quot;</span> with
    arguments the list of references to the nodes (in the order in which they
    appear in the terms, from left to right).
    <span class="Li">&quot;Parse::Eyapp::Node-&gt;new&quot;</span> returns a
    list of references to the jsut created nodes. In a scalar context returns a
    reference to the first of such trees. See an example:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ perl -MParse::Eyapp -MData::Dumper -wde 0
  main::(-e:1):   0
    DB&lt;1&gt; @t = Parse::Eyapp::Node-&gt;new('A(C,D) E(F)', sub { my $i = 0; $_-&gt;{n} = $i++ for @_ })
    DB&lt;2&gt; $Data::Dumper::Indent = 0
    DB&lt;3&gt; print Dumper($_).&quot;\n&quot; for @t
  $VAR1 = bless( {'n' =&gt; 0,'children' =&gt; [bless( {'n' =&gt; 1,'children' =&gt; []}, 'C' ),
                                          bless( {'n' =&gt; 2,'children' =&gt; []}, 'D' )
                                         ]
                 }, 'A' );
  $VAR1 = bless( {'n' =&gt; 1,'children' =&gt; []}, 'C' );
  $VAR1 = bless( {'n' =&gt; 2,'children' =&gt; []}, 'D' );
  $VAR1 = bless( {'n' =&gt; 3,'children' =&gt; [bless( {'n' =&gt; 4,'children' =&gt; []}, 'F' )]}, 'E' );
  $VAR1 = bless( {'n' =&gt; 4,'children' =&gt; []}, 'F' );
</pre>
<p class="Pp">See the following example in which the nodes associated with
    <span class="Li">'d'</span> are explictly constructed:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ head -28 ListWithRefs2.eyp| cat -n
   1  # ListWithRefs2.eyp
   2  %semantic token 'c'
   3  %{
   4  use Data::Dumper;
   5  %}
   6  %%
   7  S:  'c'+  D+
   8        {
   9           print Dumper($_[1]);
  10           print $_[1]-&gt;str.&quot;\n&quot;;
  11           print Dumper($_[2]);
  12           print $_[2]-&gt;str.&quot;\n&quot;;
  13        }
  14  ;
  15
  16  D: 'd'.d
  17       {
  18         Parse::Eyapp::Node-&gt;new(
  19           'DES(TERMINAL)',
  20            sub {
  21              my ($DES, $TERMINAL) = @_;
  22              $TERMINAL-&gt;{attr} = $d;
  23            }
  24         );
  25       }
  26  ;
  27
  28  %%
</pre>
<p class="Pp">To know more about
    <span class="Li">&quot;Parse::Eyapp::Node-&gt;new&quot;</span> see the
    Parse::Eyapp::Node section about <span class="Li">&quot;new&quot;</span></p>
<p class="Pp">When the former eyapp program is executed produces the following
    output:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ eyapp ListWithRefs2.eyp; use_listwithrefs2.pl
  ccdd
  $VAR1 = bless( {
    'children' =&gt; [
      bless( { 'children' =&gt; [], 'attr' =&gt; 'c', 'token' =&gt; 'c' }, 'TERMINAL' ),
      bless( { 'children' =&gt; [], 'attr' =&gt; 'c', 'token' =&gt; 'c' }, 'TERMINAL' )
    ]
  }, '_PLUS_LIST_1' );
  _PLUS_LIST_1(TERMINAL,TERMINAL)
  $VAR1 = bless( {
    'children' =&gt; [
      bless( {
        'children' =&gt; [
          bless( { 'children' =&gt; [], 'attr' =&gt; 'd' }, 'TERMINAL' )
        ]
      }, 'DES' ),
      bless( {
        'children' =&gt; [
          bless( { 'children' =&gt; [], 'attr' =&gt; 'd' }, 'TERMINAL' )
        ]
      }, 'DES' )
    ]
  }, '_PLUS_LIST_2' );
  _PLUS_LIST_2(DES(TERMINAL),DES(TERMINAL))
</pre>
<p class="Pp"><i>The </i><i>&quot;*&quot;</i><i> operator</i></p>
<p class="Pp">Any list operator operates on the factor to its left. A list in
    the right hand side of a production rule counts as a single symbol.</p>
<p class="Pp">Both operators <span class="Li">&quot;*&quot;</span> and
    <span class="Li">&quot;+&quot;</span> can be used with the format
    <span class="Li">&quot;X &lt;* Separator&gt;&quot;</span>. In such case they
    describe lists of <span class="Li">&quot;X&quot;</span>s separated by
    <span class="Li">&quot;separator&quot;</span>. See an example:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ head -25 CsBetweenCommansAndD.eyp | cat -n
   1  # CsBetweenCommansAndD.eyp
   2
   3  %semantic token 'c' 'd'
   4
   5  %{
   6  sub TERMINAL::info {
   7    $_[0]-&gt;attr;
   8  }
   9  %}
  10  %tree
  11  %%
  12  S:
  13      ('c' &lt;* ','&gt; 'd')*
  14        {
  15           print &quot;\nNode\n&quot;;
  16           print $_[1]-&gt;str.&quot;\n&quot;;
  17           print &quot;\nChild 0\n&quot;;
  18           print $_[1]-&gt;child(0)-&gt;str.&quot;\n&quot;;
  19           print &quot;\nChild 1\n&quot;;
  20           print $_[1]-&gt;child(1)-&gt;str.&quot;\n&quot;;
  21           $_[1]
  22        }
  23  ;
  24
  25  %%
</pre>
<p class="Pp">The rule</p>
<p class="Pp"></p>
<pre>
                            S: ('c' &lt;* ','&gt; 'd')*
</pre>
<p class="Pp">has only two items in its right hand side: the (separated by
    commas) list of <span class="Li">&quot;c&quot;</span>s and the list of
    <span class="Li">&quot;d&quot;</span>s. The production rule is equivalent
    to:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ eyapp -v CsBetweenCommansAndD.eyp
  pl@nereida:~/LEyapp/examples$ head -11 CsBetweenCommansAndD.output | cat -n
   1  Rules:
   2  ------
   3  0:      $start -&gt; S $end
   4  1:      STAR-1 -&gt; STAR-1 ',' 'c'
   5  2:      STAR-1 -&gt; 'c'
   6  3:      STAR-2 -&gt; STAR-1
   7  4:      STAR-2 -&gt; /* empty */
   8  5:      PAREN-3 -&gt; STAR-2 'd'
   9  6:      STAR-4 -&gt; STAR-4 PAREN-3
  10  7:      STAR-4 -&gt; /* empty */
  11  8:      S -&gt; STAR-4
</pre>
<p class="Pp">The semantic action associated with
    <span class="Li">&quot;*&quot;</span> is to return a reference to a list
    with the attributes of the matching items.</p>
<p class="Pp">When working -as in the example - under a tree creation directive
    it returns a node belonging to a class named
    <span class="Li">&quot;_STAR_LIST_#number&quot;</span> whose children are
    the items in the list. The <span class="Li">&quot;#number&quot;</span> is
    the ordinal number of the production rule as it appears in the
    <span class="Li">&quot;.output&quot;</span> file. The attributes must be
    references or associated with semantic tokens to be included in the list.
    Notice -in the execution of the former example that follows - how the node
    for <span class="Li">&quot;PAREN-3&quot;</span> has been eliminated from the
    tree. Parenthesis nodes are - generally - obivated:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ use_csbetweencommansandd.pl
  c,c,cd

  Node
  _STAR_LIST_4(_STAR_LIST_1(TERMINAL[c],TERMINAL[c],TERMINAL[c]),TERMINAL[d])

  Child 0
  _STAR_LIST_1(TERMINAL[c],TERMINAL[c],TERMINAL[c])

  Child 1
  TERMINAL[d]
</pre>
<p class="Pp">Notice that the comma (since it is a syntactic token) has also
    been supressed.</p>
<p class="Pp"><i>Giving Names to Lists</i></p>
<p class="Pp">To set the name of the node associated with a list operator the
    <span class="Li">%name</span> directive must precede the operator as in the
    following example:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ sed -ne '1,27p' CsBetweenCommansAndDWithNames.eyp | cat -n
   1  # CsBetweenCommansAndDWithNames.eyp
   2
   3  %semantic token 'c' 'd'
   4
   5  %{
   6  sub TERMINAL::info {
   7    $_[0]-&gt;attr;
   8  }
   9  %}
  10  %tree
  11  %%
  12  Start: S
  13  ;
  14  S:
  15      ('c' &lt;%name Cs * ','&gt; 'd') %name Cs_and_d *
  16        {
  17           print &quot;\nNode\n&quot;;
  18           print $_[1]-&gt;str.&quot;\n&quot;;
  19           print &quot;\nChild 0\n&quot;;
  20           print $_[1]-&gt;child(0)-&gt;str.&quot;\n&quot;;
  21           print &quot;\nChild 1\n&quot;;
  22           print $_[1]-&gt;child(1)-&gt;str.&quot;\n&quot;;
  23           $_[1]
  24        }
  25  ;
  26
  27  %%
</pre>
<p class="Pp">The execution shows the renamed nodes:</p>
<p class="Pp">pl@nereida:~/LEyapp/examples$ use_csbetweencommansanddwithnames.pl
    c,c,c,cd</p>
<p class="Pp"></p>
<pre>
  Node
  Cs_and_d(Cs(TERMINAL[c],TERMINAL[c],TERMINAL[c],TERMINAL[c]),TERMINAL[d])

  Child 0
  Cs(TERMINAL[c],TERMINAL[c],TERMINAL[c],TERMINAL[c])

  Child 1
  TERMINAL[d]
</pre>
<p class="Pp"><i>Optionals</i></p>
<p class="Pp">The <span class="Li">&quot;X?&quot;</span> operator stands for the
    presence or omission of <span class="Li">&quot;X&quot;</span>.</p>
<p class="Pp">The grammar:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ head -11 List5.yp | cat -n
       1  %semantic token 'c'
       2  %tree
       3  %%
       4  S: 'c' 'c'?
       5       {
       6         print $_[2]-&gt;str.&quot;\n&quot;;
       7         print $_[2]-&gt;child(0)-&gt;attr.&quot;\n&quot; if $_[2]-&gt;children;
       8      }
       9  ;
      10
      11  %%
</pre>
<p class="Pp">is equivalent to:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ eyapp -v List5
  pl@nereida:~/LEyapp/examples$ head -7 List5.output
  Rules:
  ------
  0:      $start -&gt; S $end
  1:      OPTIONAL-1 -&gt; 'c'
  2:      OPTIONAL-1 -&gt; /* empty */
  3:      S -&gt; 'c' OPTIONAL-1
</pre>
<p class="Pp">When <span class="Li">&quot;yybuildingtree&quot;</span> is false
    the associated attribute is a list that will be empty if CX&gt; does not
    show up.</p>
<p class="Pp">Under the <span class="Li">%tree</span> directive the action
    creates an c&lt;_OPTIONAL&gt; node:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ use_list5.pl
  cc
  _OPTIONAL_1(TERMINAL)
  c
  pl@nereida:~/LEyapp/examples$ use_list5.pl
  c
  _OPTIONAL_1
</pre>
<p class="Pp"><i>Parenthesis</i></p>
<p class="Pp">Any substring on the right hand side of a production rule can be
    grouped using a parenthesis. The introduction of a parenthesis implies the
    introduction of an additional syntactic variable whose only production is
    the sequence of symbols between the parenthesis. Thus the grammar:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ head -6 Parenthesis.eyp | cat -n
     1  %%
     2  S:
     3        ('a' S ) 'b'  { shift; [ @_ ] }
     4      | 'c'
     5  ;
     6  %%
</pre>
<p class="Pp">is equivalent to:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ eyapp -v Parenthesis.eyp; head -6 Parenthesis.output
  Rules:
  ------
  0:      $start -&gt; S $end
  1:      PAREN-1 -&gt; 'a' S
  2:      S -&gt; PAREN-1 'b'
  3:      S -&gt; 'c'
</pre>
<p class="Pp">By default the semantic rule associated with a parenthesis returns
    an anonymous list with the attributes of the symbols between the
    parenthesis:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ cat -n use_parenthesis.pl
       1  #!/usr/bin/perl -w
       2  use Parenthesis;
       3  use Data::Dumper;
       4
       5  $Data::Dumper::Indent = 1;
       6  $parser = Parenthesis-&gt;new();
       7  print Dumper($parser-&gt;Run);
  pl@nereida:~/LEyapp/examples$ use_parenthesis.pl
  acb
  $VAR1 = [
    [ 'a', 'c' ], 'b'
  ];
  pl@nereida:~/LEyapp/examples$ use_parenthesis.pl
  aacbb
  $VAR1 = [
    [
      'a',
      [ [ 'a', 'c' ], 'b' ]
    ],
    'b'
  ];
</pre>
<p class="Pp">when working under a tree directive or when the attribute
    <span class="Li">&quot;buildingtree&quot;</span> is set via
    the<span class="Li">&quot;YYBuildingtree&quot;</span> method the semantic
    action returns a node with children the attributes of the symbols between
    parenthesis. As usual attributes which aren't references will be skipped
    from the list of children. See an example:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ head -23 List2.yp | cat -n
   1  %{
   2  use Data::Dumper;
   3  %}
   4  %semantic token 'a' 'b' 'c'
   5  %tree
   6  %%
   7  S:
   8        (%name AS 'a' S )'b'
   9          {
  10            print &quot;S -&gt; ('a' S )'b'\n&quot;;
  11            print &quot;Attribute of the first symbol:\n&quot;.Dumper($_[1]);
  12            print &quot;Attribute of the second symbol: $_[2]\n&quot;;
  13            $_[0]-&gt;YYBuildAST(@_[1..$#_]);
  14          }
  15      | 'c'
  16          {
  17            print &quot;S -&gt; 'c'\n&quot;;
  18            my $r = Parse::Eyapp::Node-&gt;new(qw(C(TERMINAL)), sub { $_[1]-&gt;attr('c') }) ;
  19            print Dumper($r);
  20            $r;
  21          }
  22  ;
  23  %%
</pre>
<p class="Pp">The example shows (line 8) how to rename a
    <span class="Li">&quot;_PAREN&quot;</span> node. The
    <span class="Li">&quot;%name CLASSNAME&quot;</span> goes after the opening
    parenthesis.</p>
<p class="Pp">The call to <span class="Li">&quot;YYBuildAST&quot;</span> at line
    13 with argumetns the attributes of the symbols on the right hand side
    returns the node describing the current production rule. Notice that line 13
    can be rewritten as:</p>
<p class="Pp"></p>
<pre>
                    goto &amp;Parse::Eyapp::Driver::YYBuildAST;
</pre>
<p class="Pp">At line 18 the node for the rule is explictly created using
    <span class="Li">&quot;Parse::Eyapp::Node-&quot;</span>new&gt;. The handler
    passed as second argument is responsible for setting the value of the
    atribute <span class="Li">&quot;attr&quot;</span> of the just created
    <span class="Li">&quot;TERMINAL&quot;</span> node.</p>
<p class="Pp">Let us see an execution:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ use_list2.pl
  aacbb
  S -&gt; 'c'
  $VAR1 = bless( {
    'children' =&gt; [
      bless( {
        'children' =&gt; [],
        'attr' =&gt; 'c'
      }, 'TERMINAL' )
    ]
  }, 'C' );
</pre>
<p class="Pp">the first reduction occurs by the non recursive rule. The
    execution shows the tree built by the call to
    <span class="Li">&quot;Parse::Eyapp::Node-&quot;</span>new&gt; at line
  18.</p>
<p class="Pp">The execution continues with the reduction or antiderivation by
    the rule <span class="Li">&quot;S -&gt; ('a' S )'b'&quot;</span>. The action
    at lines 9-14 dumps the attribute associated with
    <span class="Li">&quot;('a' S)&quot;</span> - or, in other words, the
    attribute associated with the variable
    <span class="Li">&quot;PAREN-1&quot;</span>. It also dumps the attribute of
    <span class="Li">'b'</span>:</p>
<p class="Pp"></p>
<pre>
  S -&gt; ('a' S )'b'
  Attribute of the first symbol:
  $VAR1 = bless( {
      'children' =&gt; [
        bless( { 'children' =&gt; [], 'attr' =&gt; 'a', 'token' =&gt; 'a' }, 'TERMINAL' ),
        bless( { 'children' =&gt; [ bless( { 'children' =&gt; [], 'attr' =&gt; 'c' }, 'TERMINAL' )
       ]
     }, 'C' )
    ]
  }, 'AS' );
Attribute of the second symbol: b
</pre>
<p class="Pp">The last reduction shown is by the rule: <span class="Li">&quot;S
    -&gt; ('a' S )'b'&quot;</span>:</p>
<p class="Pp"></p>
<pre>
  S -&gt; ('a' S )'b'
  Attribute of the first symbol:
  $VAR1 = bless( {
    'children' =&gt; [
      bless( { 'children' =&gt; [], 'attr' =&gt; 'a', 'token' =&gt; 'a' }, 'TERMINAL' ),
      bless( {
        'children' =&gt; [
          bless( {
            'children' =&gt; [
              bless( { 'children' =&gt; [], 'attr' =&gt; 'a', 'token' =&gt; 'a' }, 'TERMINAL' ),
              bless( {
                'children' =&gt; [
                  bless( { 'children' =&gt; [], 'attr' =&gt; 'c' }, 'TERMINAL' )
                ]
              }, 'C' )
            ]
          }, 'AS' ),
          bless( { 'children' =&gt; [], 'attr' =&gt; 'b', 'token' =&gt; 'b' }, 'TERMINAL' )
        ]
      }, 'S_2' )
    ]
  }, 'AS' );
  Attribute of the second symbol: b
</pre>
<p class="Pp"><i>Actions Inside Parenthesis</i></p>
<p class="Pp">Though is a practice to avoid, since it clutters the code, it is
    certainly permitted to introduce actions between the parenthesis, as in the
    example below:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ head -16 ListAndAction.eyp | cat -n
   1  # ListAndAction.eyp
   2  %{
   3  my $num = 0;
   4  %}
   5
   6  %%
   7  S:      'c'
   8              {
   9                print &quot;S -&gt; c\n&quot;
  10              }
  11      |    ('a' {$num++; print &quot;Seen &lt;$num&gt; 'a's\n&quot;; $_[1] }) S 'b'
  12              {
  13                print &quot;S -&gt; (a ) S b\n&quot;
  14              }
  15  ;
  16  %%
</pre>
<p class="Pp">This is the output when executing this program with input
    <span class="Li">&quot;aaacbbb&quot;</span>:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ use_listandaction.pl
  aaacbbb
  Seen &lt;1&gt; 'a's
  Seen &lt;2&gt; 'a's
  Seen &lt;3&gt; 'a's
  S -&gt; c
  S -&gt; (a ) S b
  S -&gt; (a ) S b
  S -&gt; (a ) S b
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Names_for_attributes"><a class="permalink" href="#Names_for_attributes">Names
  for attributes</a></h2>
<p class="Pp">Attributes can be referenced by meaningful names instead of the
    classic error-prone positional approach using the <i>dot notation</i>:</p>
<p class="Pp"></p>
<pre>
                        rhs:  rhseltwithid *
                        rhseltwithid : 
                              rhselt '.' IDENT 
                            | '$' rhselt  
                            | rhselt
</pre>
<p class="Pp">for example:</p>
<p class="Pp"></p>
<pre>
              exp : exp.left '-' exp.right  { $left - $right }
</pre>
<p class="Pp">By qualifying the first appearance of the syntactic variable
    <span class="Li">&quot;exp&quot;</span> with the notation
    <span class="Li">&quot;exp.left&quot;</span> we can later refer inside the
    actions to the associated attribute using the lexical variable
    <span class="Li">$left</span>.</p>
<p class="Pp">The <i>dolar notation</i> <span class="Li">$A</span> can be used
    as an abbreviation of <span class="Li">&quot;A.A&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Default_actions"><a class="permalink" href="#Default_actions">Default
  actions</a></h2>
<p class="Pp">When no action is specified both
    <span class="Li">&quot;yapp&quot;</span> and
    <span class="Li">&quot;eyapp&quot;</span> implicitly insert the semantic
    action <span class="Li">&quot;{ $_[1] }&quot;</span>. In
    <span class="Li">&quot;Parse::Eyapp&quot;</span> you can modify such
    behavior using the <span class="Li">&quot;%defaultaction { Perl code
    }&quot;</span> directive. The <span class="Li">&quot;{ Perl code
    }&quot;</span> clause that follows the
    <span class="Li">%defaultaction</span> directive is executed when reducing
    by any production for which no explicit action was specified.</p>
<p class="Pp"><i>Translator from Infix to Postfix</i></p>
<p class="Pp">See an example that translates an infix expression like
    <span class="Li">&quot;a=b*-3&quot;</span> into a postfix expression like
    <span class="Li">&quot;a b 3 NEG * = &quot;</span>:</p>
<p class="Pp"></p>
<pre>
 # File Postfix.eyp (See the examples/ directory)
 %right  '='
 %left   '-' '+'
 %left   '*' '/'
 %left   NEG

 %defaultaction { return  &quot;$left $right $op&quot;; }

 %%
 line: $exp  { print &quot;$exp\n&quot; }
 ;

 exp:        $NUM  { $NUM }
         |   $VAR  { $VAR }
         |   VAR.left '='.op exp.right
         |   exp.left '+'.op exp.right
         |   exp.left '-'.op exp.right
         |   exp.left '*'.op exp.right
         |   exp.left '/'.op exp.right
         |   '-' $exp %prec NEG { &quot;$exp NEG&quot; }
         |   '(' $exp ')' { $exp }
 ;

 %%

 # Support subroutines as in the Synopsis example
 ...
</pre>
<p class="Pp">The file containing the <span class="Li">&quot;Eyapp&quot;</span>
    program must be compiled with <span class="Li">&quot;eyapp&quot;</span>:</p>
<p class="Pp"></p>
<pre>
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; eyapp Postfix.eyp
</pre>
<p class="Pp">Next, you have to write a client program:</p>
<p class="Pp"></p>
<pre>
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; cat -n usepostfix.pl
      1  #!/usr/bin/perl -w
      2  use strict;
      3  use Postfix;
      4
      5  my $parser = new Postfix();
      6  $parser-&gt;Run;
</pre>
<p class="Pp">Now we can run the client program:</p>
<p class="Pp"></p>
<pre>
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; usepostfix.pl
 Write an expression: -(2*a-b*-3)
 2 a * b 3 NEG * - NEG
</pre>
<p class="Pp"><i>Default Actions, </i><i>%name</i><i> and
    </i><i>&quot;YYName&quot;</i><i></i></p>
<p class="Pp">In <span class="Li">&quot;eyapp&quot;</span> each production rule
    has a name. The name of a rule can be explicitly given by the programmer
    using the <span class="Li">%name</span> directive. For example, in the piece
    of code that follows the name <span class="Li">&quot;ASSIGN&quot;</span> is
    given to the rule <span class="Li">&quot;exp: VAR '=' exp&quot;</span>.</p>
<p class="Pp">When no explicit name is given the rule has an implicit name. The
    implicit name of a rule is shaped by concatenating the name of the syntactic
    variable on its left, an underscore and the ordinal number of the production
    rule <span class="Li">&quot;Lhs_#&quot;</span> as it appears in the
    <span class="Li">&quot;.output&quot;</span> file. Avoid giving names
    matching such pattern to production rules. The patterns
    <span class="Li">&quot;/${lhs}_\d+$/&quot;</span> where
    <span class="Li">&quot;${lhs}&quot;</span> is the name of the syntactic
    variable are reserved for internal use by
    <span class="Li">&quot;eyapp&quot;</span>.</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ cat -n Lhs.eyp
   1  # Lhs.eyp
   2
   3  %right  '='
   4  %left   '-' '+'
   5  %left   '*' '/'
   6  %left   NEG
   7
   8  %defaultaction {
   9    my $self = shift;
  10    my $name = $self-&gt;YYName();
  11    bless { children =&gt; [ grep {ref($_)} @_] }, $name;
  12  }
  13
  14  %%
  15  input:
  16              /* empty */
  17                { [] }
  18          |   input line
  19                {
  20                  push @{$_[1]}, $_[2] if defined($_[2]);
  21                  $_[1]
  22                }
  23  ;
  24
  25  line:     '\n'       { }
  26          | exp '\n'   {  $_[1] }
  27  ;
  28
  29  exp:
  30              NUM   { $_[1] }
  31          |   VAR   { $_[1] }
  32          |   %name ASSIGN
  33              VAR '=' exp
  34          |   %name PLUS
  35              exp '+' exp
  36          |   %name MINUS
  37              exp '-' exp
  38          |   %name TIMES
  39              exp '*' exp
  40          |   %name DIV
  41              exp '/' exp
  42          |   %name UMINUS
  43              '-' exp %prec NEG
  44          |  '(' exp ')'  { $_[2] }
  45  ;
</pre>
<p class="Pp">Inside a semantic action the name of the current rule can be
    recovered using the method <span class="Li">&quot;YYName&quot;</span> of the
    parser object.</p>
<p class="Pp">The default action (lines 8-12) computes as attribute of the left
    hand side a reference to an object blessed in the name of the rule. The
    object has an attribute <span class="Li">&quot;children&quot;</span> which
    is a reference to the list of children of the node. The call to
    <span class="Li">&quot;grep&quot;</span></p>
<p class="Pp"></p>
<pre>
  11    bless { children =&gt; [ grep {ref($_)} @_] }, $name;
</pre>
<p class="Pp">excludes children that aren't references. Notice that the lexical
    analyzer only returns references for the
    <span class="Li">&quot;NUM&quot;</span> and
    <span class="Li">&quot;VAR&quot;</span> terminals:</p>
<p class="Pp"></p>
<pre>
  59  sub _Lexer {
  60      my($parser)=shift;
  61
  62      for ($parser-&gt;YYData-&gt;{INPUT}) {
  63          s/^[ \t]+//;
  64          return('',undef) unless $_;
  65          s/^([0-9]+(?:\.[0-9]+)?)//
  66                  and return('NUM', bless { attr =&gt; $1}, 'NUM');
  67          s/^([A-Za-z][A-Za-z0-9_]*)//
  68                  and return('VAR',bless {attr =&gt; $1}, 'VAR');
  69          s/^(.)//s
  70                  and return($1, $1);
  71      }
  72      return('',undef);
  73  }
</pre>
<p class="Pp">follows the client program:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ cat -n uselhs.pl
       1  #!/usr/bin/perl -w
       2  use Lhs;
       3  use Data::Dumper;
       4
       5  $parser = new Lhs();
       6  my $tree = $parser-&gt;Run;
       7  $Data::Dumper::Indent = 1;
       8  if (defined($tree)) { print Dumper($tree); }
       9  else { print &quot;Cadena no v&#x00E1;lida\n&quot;; }
</pre>
<p class="Pp">When executed with input
    <span class="Li">&quot;a=(2+3)*b&quot;</span> the parser produces the
    following tree:</p>
<p class="Pp"></p>
<pre>
  ASSIGN(TIMES(PLUS(NUM[2],NUM[3]), VAR[b]))
</pre>
<p class="Pp">See the result of an execution:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ uselhs.pl
  a=(2+3)*b
  $VAR1 = [
    bless( {
      'children' =&gt; [
        bless( { 'attr' =&gt; 'a' }, 'VAR' ),
        bless( {
          'children' =&gt; [
            bless( {
              'children' =&gt; [
                bless( { 'attr' =&gt; '2' }, 'NUM' ),
                bless( { 'attr' =&gt; '3' }, 'NUM' )
              ]
            }, 'PLUS' ),
            bless( { 'attr' =&gt; 'b' }, 'VAR' )
          ]
        }, 'TIMES' )
      ]
    }, 'ASSIGN' )
  ];
</pre>
<p class="Pp">The name of a production rule can be changed at execution time.
    See the following example:</p>
<p class="Pp"></p>
<pre>
  29  exp:
  30              NUM   { $_[1] }
  31          |   VAR   { $_[1] }
  32          |   %name ASSIGN
  33              VAR '=' exp
  34          |   %name PLUS
  35              exp '+' exp
  36          |   %name MINUS
  37              exp '-' exp
  38                {
  39                  my $self = shift;
  40                  $self-&gt;YYName('SUBSTRACT'); # rename it
  41                  $self-&gt;YYBuildAST(@_); # build the node
  42                }
  43          |   %name TIMES
  44              exp '*' exp
  45          |   %name DIV
  46              exp '/' exp
  47          |   %name UMINUS
  48              '-' exp %prec NEG
  49          |  '(' exp ')'  { $_[2] }
  50  ;
</pre>
<p class="Pp">When the client program is executed we can see the presence of the
    <span class="Li">&quot;SUBSTRACT&quot;</span> nodes:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ useyynamedynamic.pl
  2-b
  $VAR1 = [
    bless( {
      'children' =&gt; [
        bless( {
          'attr' =&gt; '2'
        }, 'NUM' ),
        bless( {
          'attr' =&gt; 'b'
        }, 'VAR' )
      ]
    }, 'SUBSTRACT' )
  ];
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Abstract_Syntax_Trees_:__tree_and__name"><a class="permalink" href="#Abstract_Syntax_Trees_:__tree_and__name">Abstract
  Syntax Trees : %tree and %name</a></h2>
<p class="Pp"><span class="Li">&quot;Parse::Eyapp&quot;</span> facilitates the
    construction of concrete syntax trees and abstract syntax trees (abbreviated
    AST from now on) through the <span class="Li">%tree</span> directive. Nodes
    in the AST are blessed in the production
    <span class="Li">&quot;name&quot;</span>. By default the name of a
    production is the concatenation of the left hand side and the production
    number. The production number is the ordinal number of the production as
    they appear in the associated <span class="Li">&quot;.output&quot;</span>
    file (see option <span class="Li">&quot;-v&quot;</span> of eyapp). For
    example, given the grammar:</p>
<p class="Pp"></p>
<pre>
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed -ne '9,28p' treewithoutnames.pl
 my $grammar = q{
   %right  '='     # Lowest precedence
   %left   '-' '+' # + and - have more precedence than = Disambiguate a-b-c as (a-b)-c
   %left   '*' '/' # * and / have more precedence than + Disambiguate a/b/c as (a/b)/c
   %left   NEG     # Disambiguate -a-b as (-a)-b and not as -(a-b)
   %tree           # Let us build an abstract syntax tree ...

   %%
   line: exp &lt;+ ';'&gt;  { $_[1] } /* list of expressions separated by ';' */
   ;

   exp:
        NUM           |   VAR       | VAR '=' exp
     | exp '+' exp    | exp '-' exp |  exp '*' exp
     | exp '/' exp
     | '-' exp %prec NEG
     |   '(' exp ')'  { $_[2] }
   ;
</pre>
<p class="Pp">The tree produced by the parser when feed with input
    <span class="Li">&quot;a=2*b&quot;</span> is:</p>
<p class="Pp"></p>
<pre>
 _PLUS_LIST(exp_6(TERMINAL[a],exp_9(exp_4(TERMINAL[2]),exp_5(TERMINAL[b]))))
</pre>
<p class="Pp">If we want to see the correspondence between names and rules we
    can generate and check the corresponding file
    <span class="Li">&quot;.output&quot;</span>:</p>
<p class="Pp"></p>
<pre>
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed -ne '28,42p' treewithoutnames.output
 Rules:
 ------
 0:      $start -&gt; line $end
 1:      PLUS-1 -&gt; PLUS-1 ';' exp
 2:      PLUS-1 -&gt; exp
 3:      line -&gt; PLUS-1
 4:      exp -&gt; NUM
 5:      exp -&gt; VAR
 6:      exp -&gt; VAR '=' exp
 7:      exp -&gt; exp '+' exp
 8:      exp -&gt; exp '-' exp
 9:      exp -&gt; exp '*' exp
 10:     exp -&gt; exp '/' exp
 11:     exp -&gt; '-' exp
 12:     exp -&gt; '(' exp ')'
</pre>
<p class="Pp">We can see now that the node
    <span class="Li">&quot;exp_9&quot;</span> corresponds to the production
    <span class="Li">&quot;exp -&gt; exp '*' exp&quot;</span>. Observe also that
    the Eyapp production:</p>
<p class="Pp"></p>
<pre>
                                line: exp &lt;+ ';'&gt;
actually produces the productions:

                        1:      PLUS-1 -&gt; PLUS-1 ';' exp
                        2:      PLUS-1 -&gt; exp
</pre>
<p class="Pp">and that the name of the class associated with the non empty list
    is <span class="Li">&quot;_PLUS_LIST&quot;</span>.</p>
<p class="Pp">A production rule can be <i>named</i> using the
    <span class="Li">&quot;%name IDENTIFIER&quot;</span> directive. For each
    production rule a namespace/package is created. <i>The</i>
    <span class="Li">&quot;IDENTIFIER&quot;</span> <i>is the name of the
    associated package</i>. Therefore, by modifying the former grammar with
    additional <span class="Li">%name</span> directives:</p>
<p class="Pp"></p>
<pre>
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed -ne '8,26p' treewithnames.pl
 my $grammar = q{
   %right  '='     # Lowest precedence
   %left   '-' '+' # + and - have more precedence than = Disambiguate a-b-c as (a-b)-c
   %left   '*' '/' # * and / have more precedence than + Disambiguate a/b/c as (a/b)/c
   %left   NEG     # Disambiguate -a-b as (-a)-b and not as -(a-b)
   %tree           # Let us build an abstract syntax tree ...

   %%
   line: exp &lt;%name EXPS + ';'&gt;  { $_[1] } /* list of expressions separated by ';' */
   ;

   exp:
       %name NUM    NUM           | %name VAR   VAR         | %name ASSIGN VAR '=' exp
     | %name PLUS   exp '+' exp   | %name MINUS exp '-' exp | %name TIMES  exp '*' exp
     | %name DIV    exp '/' exp
     | %name UMINUS '-' exp %prec NEG
     |   '(' exp ')'  { $_[2] }
   ;
</pre>
<p class="Pp">we are explictly naming the productions. Thus, all the node
    instances corresponding to the production <span class="Li">&quot;exp: VAR
    '=' exp&quot;</span> will belong to the class
    <span class="Li">&quot;ASSIGN&quot;</span>. Now the tree for
    <span class="Li">&quot;a=2*b&quot;</span> becomes:</p>
<p class="Pp"></p>
<pre>
          EXPS(ASSIGN(TERMINAL[a],TIMES(NUM(TERMINAL[2]),VAR(TERMINAL[b]))))
</pre>
<p class="Pp">Observe how the list has been named
    <span class="Li">&quot;EXPS&quot;</span>. The <span class="Li">%name</span>
    directive prefixes the list operator
    (<span class="Li">&quot;[+*?]&quot;</span>).</p>
<p class="Pp"><i>About the Encapsulation of Nodes</i></p>
<p class="Pp">There is no encapsulation of nodes. The user/client knows that
    they are hashes that can be decorated with new keys/attributes. All nodes in
    the AST created by <span class="Li">%tree</span> are
    <span class="Li">&quot;Parse::Eyapp::Node&quot;</span> nodes. The only
    reserved field is <span class="Li">&quot;children&quot;</span> which is a
    reference to the array of children. You can always create a
    <span class="Li">&quot;Node&quot;</span> class <i>by hand</i> by inheriting
    from <span class="Li">&quot;Parse::Eyapp::Node&quot;</span>. See section
    'Compiling with eyapp and treereg' in Parse::Eyapp for an example.</p>
<p class="Pp"><i>TERMINAL Nodes</i></p>
<p class="Pp">Nodes named <span class="Li">&quot;TERMINAL&quot;</span> are built
    from the tokens provided by the lexical analyzer.
    <span class="Li">&quot;Parse::Eyapp&quot;</span> follows the same protocol
    than Parse::Yapp for communication between the parser and the lexical
    analyzer: A couple <span class="Li">&quot;($token, $attribute)&quot;</span>
    is returned by the lexical analyzer. These values are stored under the keys
    <span class="Li">&quot;token&quot;</span> and
    <span class="Li">&quot;attr&quot;</span>.
    <span class="Li">&quot;TERMINAL&quot;</span> nodes as all
    <span class="Li">&quot;Parse::Eyapp::Node&quot;</span> nodes also have the
    attribute <span class="Li">&quot;children&quot;</span> but is - almost
    always - empty.</p>
<p class="Pp"><i>Explicit Actions Inside </i><i>%tree</i><i></i></p>
<p class="Pp">Explicit actions can be specified by the programmer like in this
    line from the Parse::Eyapp <span class="Li">&quot;SYNOPSIS&quot;</span>
    example:</p>
<p class="Pp"></p>
<pre>
      |   '(' exp ')'  { $_[2] }  /* Let us simplify a bit the tree */
</pre>
<p class="Pp">Explicit actions receive as arguments the references to the
    children nodes already built. The programmer can influence the shape of the
    tree by inserting these explicit actions. In this example the programmer has
    decided to simplify the syntax tree: the nodes associated with the
    parenthesis are discarded and the reference to the subtree containing the
    proper expression is returned. Such manoeuvre is called <i>bypassing</i>.
    See section &quot;The bypass clause and the <span class="Li">%no</span>
    bypass directive&quot; to know more about <i>automatic bypassing</i></p>
<p class="Pp"><i>Explicitly Building Nodes With
    </i><i>&quot;YYBuildAST&quot;</i><i></i></p>
<p class="Pp">Sometimes the best time to decorate a node with some attributes is
    just after being built. In such cases the programmer can take <i>manual
    control</i> building the node with
    <span class="Li">&quot;YYBuildAST&quot;</span> to inmediately proceed to
    decorate it.</p>
<p class="Pp">The following example illustrates the situation:</p>
<p class="Pp"></p>
<pre>
 Variable:
     %name  VARARRAY
     $ID ('[' binary ']') &lt;%name INDEXSPEC +&gt;
       {
         my $self = shift;
         my $node =  $self-&gt;YYBuildAST(@_);
         $node-&gt;{line} = $ID-&gt;[1];
         return $node;
       }
</pre>
<p class="Pp">This production rule defines the expression to access an array
    element as an identifier followed by a non empty list of binary expressions
    <span class="Li">&quot; Variable: ID ('[' binary ']')+&quot;</span>.
    Furthermore, the node corresponding to the list of indices has been named
    <span class="Li">&quot;INDEXSPEC&quot;</span>.</p>
<p class="Pp">When no explicit action is inserted a binary node will be built
    having as first child the node corresponding to the identifier
    <span class="Li">$ID</span> and as second child the reference to the list of
    binary expressions. The children corresponding to
    <span class="Li">'['</span> and <span class="Li">']'</span> are discarded
    since they are -by default- <i>syntactic tokens</i> (see section
    &quot;Syntactic and Semantic tokens&quot;). However, the programmer wants to
    decorate the node being built with a
    <span class="Li">&quot;line&quot;</span> attribute holding the line number
    in the source code where the identifier being used appears. The call to the
    <span class="Li">&quot;Parse::Eyapp::Driver&quot;</span> method
    <span class="Li">&quot;YYBuildAST&quot;</span> does the job of building the
    node. After that the node can be decorated and returned.</p>
<p class="Pp">Actually, the <span class="Li">%tree</span> directive is
    semantically equivalent to:</p>
<p class="Pp"></p>
<pre>
                %default action { goto &amp;Parse::Eyapp::Driver::YYBuildAST }
</pre>
<p class="Pp"><i>Returning non References Under </i><i>%tree</i><i></i></p>
<p class="Pp">When a <i>explicit user action returns s.t. that is not a
    reference</i> <i>no node will be inserted</i>. This fact can be used to
    supress nodes in the AST being built. See the following example (file
    <span class="Li">&quot;examples/returnnonode.yp&quot;</span>):</p>
<p class="Pp"></p>
<pre>
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; sed -ne '1,11p' returnnonode.yp | cat -n
  1  %tree
  2  %semantic token 'a' 'b'
  3  %%
  4  S:  /* empty */
  5      | S A
  6      | S B
  7  ;
  8  A : 'a'
  9  ;
 10  B : 'b' { }
 11  ;
</pre>
<p class="Pp">since the action at line 10 returns
    <span class="Li">&quot;undef&quot;</span> the <span class="Li">&quot;B :
    'b'&quot;</span> subtree will not be inserted in the AST:</p>
<p class="Pp"></p>
<pre>
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; usereturnnonode.pl
 ababa
 S_2(S_3(S_2(S_3(S_2(S_1,A_4(TERMINAL[a]))),A_4(TERMINAL[a]))),A_4(TERMINAL[a]))
</pre>
<p class="Pp">Observe the absence of <span class="Li">&quot;B&quot;</span>s and
    <span class="Li">'b'</span>s.</p>
<p class="Pp"><i>Intermediate actions and </i><i>%tree</i><i></i></p>
<p class="Pp">Intermediate actions can be used to change the shape of the AST
    (prune it, decorate it, etc.) but the value returned by them is ignored. The
    grammar below has two intermediate actions. They modify the attributes of
    the node to its left and return a reference <span class="Li">$f</span> to
    such node (lines 5 and 6):</p>
<p class="Pp"></p>
<pre>
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; \
          sed -ne '1,10p' intermediateactiontree.yp | cat -n
  1  %semantic token 'a' 'b'
  2  %tree bypass
  3  %%
  4  S:    /* empty */
  5      | S A.f { $f-&gt;{attr} = &quot;A&quot;; $f; } A
  6      | S B.f { $f-&gt;{attr} = &quot;B&quot;; $f; } B
  7  ;
  8  A : %name A 'a'
  9  ;
 10  B : %name B 'b'
</pre>
<p class="Pp">See the client program running:</p>
<p class="Pp"></p>
<pre>
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; cat -n useintermediateactiontree.pl
  1  #!/usr/bin/perl -w
  2  use strict;
  3  use Parse::Eyapp;
  4  use intermediateactiontree;
  5
  6  { no warnings;
  7  *A::info = *B::info = sub { $_[0]{attr} };
  8  }
  9
 10  my $parser = intermediateactiontree-&gt;new();
 11  my $t = $parser-&gt;Run;
 12  print $t-&gt;str,&quot;\n&quot;;
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; useintermediateactiontree.pl
 aabbaa
 S_2(S_4(S_2(S_1,A[A],A[a]),B[B],B[b]),A[A],A[a])
</pre>
<p class="Pp">The attributes of left <span class="Li">&quot;A&quot;</span>s have
    been effectively changed by the intermediate actions from
    <span class="Li">'a'</span> to <span class="Li">'A'</span>. However no
    further children have been inserted.</p>
<p class="Pp"><i>Syntactic and Semantic tokens</i></p>
<p class="Pp"><span class="Li">&quot;Parse::Eyapp&quot;</span> diferences
    between <span class="Li">&quot;syntactic tokens&quot;</span> and
    <span class="Li">&quot;semantic tokens&quot;</span>. By default all tokens
    declared using string notation (i.e. between quotes like
    <span class="Li">'+'</span>, <span class="Li">'='</span>) are considered
    <i>syntactic tokens</i>. Tokens declared by an identifier (like
    <span class="Li">&quot;NUM&quot;</span> or
    <span class="Li">&quot;VAR&quot;</span>) are by default considered
    <i>semantic tokens</i>. <b>Syntactic tokens do not yield to nodes in the</b>
    <b>syntactic tree</b>. Thus, the first print in the former Parse::Eyapp
    <span class="Li">&quot;/SYNOPSIS&quot;</span> example:</p>
<p class="Pp"></p>
<pre>
              $parser-&gt;YYData-&gt;{INPUT} = &quot;2*-3+b*0;--2\n&quot;; 
              my $t = $parser-&gt;Run;                    
              local $Parse::Eyapp::Node::INDENT=2;
              print &quot;Syntax Tree:&quot;,$t-&gt;str;
</pre>
<p class="Pp">gives as result the following output:</p>
<p class="Pp"></p>
<pre>
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; synopsis.pl
 Syntax Tree:
 EXPRESION_LIST(
   PLUS(
     TIMES(
       NUM(
         TERMINAL[2]
       ),
       UMINUS(
         NUM(
           TERMINAL[3]
         )
       ) # UMINUS
     ) # TIMES,
     TIMES(
       VAR(
         TERMINAL[b]
       ),
       NUM(
         TERMINAL[0]
       )
     ) # TIMES
   ) # PLUS,
   UMINUS(
     UMINUS(
       NUM(
         TERMINAL[2]
       )
     ) # UMINUS
   ) # UMINUS
 ) # EXPRESION_LIST
</pre>
<p class="Pp"><span class="Li">&quot;TERMINAL&quot;</span> nodes corresponding
    to tokens that were defined by strings like <span class="Li">'='</span>,
    <span class="Li">'-'</span>, <span class="Li">'+'</span>,
    <span class="Li">'/'</span>, <span class="Li">'*'</span>,
    <span class="Li">'('</span> and <span class="Li">')'</span> do not appear in
    the tree. <span class="Li">&quot;TERMINAL&quot;</span> nodes corresponding
    to tokens that were defined using an identifer, like
    <span class="Li">&quot;NUM&quot;</span> or
    <span class="Li">&quot;VAR&quot;</span> are, by default, <i>semantic
    tokens</i> and appear in the AST.</p>
<p class="Pp"><i>Changing the Status of a Token</i></p>
<p class="Pp">The new token declaration directives
    <span class="Li">&quot;%syntactic token&quot;</span> and
    <span class="Li">&quot;%semantic token&quot;</span> can change the status of
    a token. For example (file
    <span class="Li">&quot;15treewithsyntactictoken.pl&quot;</span> in the
    <span class="Li">&quot;examples/&quot;</span> directory), given the
  grammar:</p>
<p class="Pp"></p>
<pre>
   %syntactic token b
   %semantic token 'a' 'c'
   %tree

   %%

   S: %name ABC
        A B C
    | %name BC
        B C
   ;

   A: %name A
        'a'
   ;

   B: %name B
        b
   ;

   C: %name C
       'c'
   ;
   %%
</pre>
<p class="Pp">the tree build for input <span class="Li">&quot;abc&quot;</span>
    will be
    <span class="Li">&quot;ABC(A(TERMINAL[a]),B,C(TERMINAL[c]))&quot;</span>.</p>
<p class="Pp"><i>Saving the Information of Syntactic Tokens in their
  Father</i></p>
<p class="Pp">The reason for the adjective <span class="Li">%syntactic</span>
    applied to a token is to state that the token influences the shape of the
    syntax tree but carries no other information. When the syntax tree is built
    the node corresponding to the token is discarded.</p>
<p class="Pp">Sometimes the difference between syntactic and semantic tokens is
    blurred. For example the line number associated with an instance of the
    syntactic token <span class="Li">'+'</span> can be used later -say during
    type checking- to emit a more accurate error diagnostic. But if the node was
    discarded the information about that line number is no longer available.
    When building the syntax tree
    <span class="Li">&quot;Parse::Eyapp&quot;</span> (namely the method
    <span class="Li">&quot;Parse::Eyapp::YYBuildAST&quot;</span>) checks if the
    method <span class="Li">&quot;TERMINAL::save_attributes&quot;</span> exists
    and if so it will be called when dealing with a <i>syntactic token</i>. The
    method receives as argument - additionally to the reference to the attribute
    of the token as it is returned by the lexical analyzer - a reference to the
    node associated with the left hand side of the production. Here is an
    example (file <span class="Li">&quot;examples/Types.eyp&quot;</span>) of
    use:</p>
<p class="Pp"></p>
<pre>
              sub TERMINAL::save_attributes {
                # $_[0] is a syntactic terminal
                # $_[1] is the father.
                push @{$_[1]-&gt;{lines}}, $_[0]-&gt;[1]; # save the line number
              }
</pre>
<p class="Pp"><i>The </i><i>&quot;bypass&quot;</i><i> clause and the
    </i><i>&quot;%no bypass&quot;</i><i> directive</i></p>
<p class="Pp">The shape of the tree can be also modified using some
    <span class="Li">%tree</span> clauses as <span class="Li">&quot;%tree
    bypass&quot;</span> which will produce an automatic <i>bypass</i> of any
    node with only one child at tree-construction-time.</p>
<p class="Pp">A <i>bypass operation</i> consists in <i>returning the only
    child</i> <i>of the node being visited to the father of the node and
    re-typing (re-blessing)</i> <i>the node in the name of the production</i>
    (if a name was provided).</p>
<p class="Pp">A node may have only one child at tree-construction-time for one
    of two reasons.</p>
<ul class="Bl-bullet">
  <li>The first occurs when the right hand side of the production was already
      unary like in:
    <p class="Pp"></p>
    <pre>
                           exp:
                               %name NUM  NUM
    </pre>
    <p class="Pp">Here - if the <span class="Li">&quot;bypass&quot;</span>
        clause is used - the <span class="Li">&quot;NUM&quot;</span> node will
        be bypassed and the child <span class="Li">&quot;TERMINAL&quot;</span>
        built from the information provided by the lexical analyzer will be
        renamed/reblessed as <span class="Li">&quot;NUM&quot;</span>.</p>
  </li>
  <li>Another reason for a node to be <i>bypassed</i> is the fact that though
      the right hand side of the production may have more than one symbol, only
      one of them is not a syntactic token like in:
    <p class="Pp"></p>
    <pre>
                           exp: '(' exp ')'
    </pre>
  </li>
</ul>
<p class="Pp">A consequence of the global scope application of
    <span class="Li">&quot;%tree bypass&quot;</span> is that undesired bypasses
    may occur like in</p>
<p class="Pp"></p>
<pre>
                           exp : %name UMINUS
                                 '-' $exp %prec NEG
</pre>
<p class="Pp">though the right hand side has two symbols, token
    <span class="Li">'-'</span> is a syntactic token and therefore only
    <span class="Li">&quot;exp&quot;</span> is left. The <i>bypass</i> operation
    will be applied when building this node. This <i>bypass</i> can be avoided
    applying the <span class="Li">&quot;no bypass ID&quot;</span> directive to
    the corresponding production:</p>
<p class="Pp"></p>
<pre>
                           exp : %no bypass UMINUS
                                 '-' $exp %prec NEG
</pre>
<p class="Pp">The following example (file
    <span class="Li">&quot;examples/bypass.pl&quot;</span>) is the equivalent of
    the Parse::Eyapp <span class="Li">&quot;/SYNOPSIS&quot;</span> example but
    using the <span class="Li">&quot;bypass&quot;</span> clause instead:</p>
<p class="Pp"></p>
<pre>
 use Parse::Eyapp;
 use Parse::Eyapp::Treeregexp;

 sub TERMINAL::info { $_[0]{attr} }
 { no warnings; *VAR::info = *NUM::info = \&amp;TERMINAL::info; }

 my $grammar = q{
   %right  '='     # Lowest precedence
   %left   '-' '+' 
   %left   '*' '/' 
   %left   NEG     # Disambiguate -a-b as (-a)-b and not as -(a-b)
   %tree bypass    # Let us build an abstract syntax tree ...

   %%
   line: exp &lt;%name EXPRESION_LIST + ';'&gt;  { $_[1] } 
   ;

   exp:
       %name NUM  NUM            | %name VAR   VAR         | %name ASSIGN VAR '=' exp
     | %name PLUS exp '+' exp    | %name MINUS exp '-' exp | %name TIMES  exp '*' exp
     | %name DIV     exp '/' exp
     | %no bypass UMINUS
       '-' $exp %prec NEG
     |   '(' exp ')'
   ;

   %%
   # sub _Error, _Lexer and Run like in the synopsis example
   # ...
 }; # end grammar

 our (@all, $uminus);

 Parse::Eyapp-&gt;new_grammar( # Create the parser package/class
   input=&gt;$grammar,
   classname=&gt;'Calc', # The name of the package containing the parser
   firstline=&gt;7       # String $grammar starts at line 7 (for error diagnostics)
 );
 my $parser = Calc-&gt;new();                # Create a parser
 $parser-&gt;YYData-&gt;{INPUT} = &quot;a=2*-3+b*0\n&quot;; # Set the input
 my $t = $parser-&gt;Run;                    # Parse it!

 print &quot;\n************\n&quot;.$t-&gt;str.&quot;\n************\n&quot;;

 # Let us transform the tree. Define the tree-regular expressions ..
 my $p = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
   { #  Example of support code
     my %Op = (PLUS=&gt;'+', MINUS =&gt; '-', TIMES=&gt;'*', DIV =&gt; '/');
   }
   constantfold: /TIMES|PLUS|DIV|MINUS/:bin(NUM, NUM)
     =&gt; {
       my $op = $Op{ref($_[0])};
       $NUM[0]-&gt;{attr} = eval  &quot;$NUM[0]-&gt;{attr} $op $NUM[1]-&gt;{attr}&quot;;
       $_[0] = $NUM[0];
     }
   zero_times_whatever: TIMES(NUM, .) and { $NUM-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
   whatever_times_zero: TIMES(., NUM) and { $NUM-&gt;{attr} == 0 } =&gt; { $_[0] = $NUM }
   uminus: UMINUS(NUM) =&gt; { $NUM-&gt;{attr} = -$NUM-&gt;{attr}; $_[0] = $NUM }
   },
   OUTPUTFILE=&gt; 'main.pm'
 );
 $p-&gt;generate(); # Create the tranformations

 $t-&gt;s(@all);    # constant folding and mult. by zero

 print $t-&gt;str,&quot;\n&quot;;
</pre>
<p class="Pp">when running this example with input
    <span class="Li">&quot;a=2*-3+b*0\n&quot;</span> we obtain the following
    output:</p>
<p class="Pp"></p>
<pre>
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; bypass.pl

 ************
 EXPRESION_LIST(ASSIGN(TERMINAL[a],PLUS(TIMES(NUM[2],UMINUS(NUM[3])),TIMES(VAR[b],NUM[0]))))
 ************
 EXPRESION_LIST(ASSIGN(TERMINAL[a],NUM[-6]))
</pre>
<p class="Pp">As you can see the trees are more compact when using the
    <span class="Li">&quot;bypass&quot;</span> directive.</p>
<p class="Pp"><i>The </i><i>&quot;alias&quot;</i><i> clause of the
    </i><i>%tree</i><i> directive</i></p>
<p class="Pp">Access to children in Parse::Eyapp is made through the
    <span class="Li">&quot;child&quot;</span> and
    <span class="Li">&quot;children&quot;</span> methods. There are occasions
    however where access by name to the children may be preferable. The use of
    the <span class="Li">&quot;alias&quot;</span> clause with the
    <span class="Li">%tree</span> directive creates accessors to the children
    with names specified by the programmer. The <i>dot and dolar notations</i>
    are used for this. When dealing with a production like:</p>
<p class="Pp"></p>
<pre>
                       A: 
                          %name A_Node
                          Node B.bum N.pum $Chip
</pre>
<p class="Pp">methods <span class="Li">&quot;bum&quot;</span>,
    <span class="Li">&quot;pum&quot;</span> and
    <span class="Li">&quot;Chip&quot;</span> will be created for the class
    <span class="Li">&quot;A_Node&quot;</span>. Those methods wil provide access
    to the respective child (first, second and third in the example). The
    methods are build at compile-time and therefore later transformations of the
    AST modifying the order of the children may invalidate the use of these
    getter-setters.</p>
<p class="Pp">As an example, the CPAN module Language::AttributeGrammar provides
    AST decorators from an attribute grammar specification of the AST. To work
    Language::AttributeGrammar requires named access to the children of the AST
    nodes. Follows an example (file
    <span class="Li">&quot;examples/CalcwithAttributeGrammar.pl&quot;</span>) of
    a small calculator:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ cat -n CalcwithAttributeGrammar.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use Parse::Eyapp;
     4  use Data::Dumper;
     5  use Language::AttributeGrammar;
     6
     7  my $grammar = q{
     8  %{
     9  # use Data::Dumper;
    10  %}
    11  %right  '='
    12  %left   '-' '+'
    13  %left   '*' '/'
    14  %left   NEG
    15  %tree bypass alias
    16
    17  %%
    18  line: $exp  { $_[1] }
    19  ;
    20
    21  exp:
    22      %name NUM
    23            $NUM
    24          | %name VAR
    25            $VAR
    26          | %name ASSIGN
    27            $VAR '=' $exp
    28          | %name PLUS
    29            exp.left '+' exp.right
    30          | %name MINUS
    31            exp.left '-' exp.right
    32          | %name TIMES
    33            exp.left '*' exp.right
    34          | %name DIV
    35            exp.left '/' exp.right
    36          | %no bypass UMINUS
    37            '-' $exp %prec NEG
    38    |   '(' $exp ')'  { $_[2] } /* Let us simplify a bit the tree */
    39  ;
    40
    41  %%
    42
    43  sub _Error {
    44          exists $_[0]-&gt;YYData-&gt;{ERRMSG}
    45      and do {
    46          print $_[0]-&gt;YYData-&gt;{ERRMSG};
    47          delete $_[0]-&gt;YYData-&gt;{ERRMSG};
    48          return;
    49      };
    50      print &quot;Syntax error.\n&quot;;
    51  }
    52
    53  sub _Lexer {
    54      my($parser)=shift;
    55
    56          $parser-&gt;YYData-&gt;{INPUT}
    57      or  $parser-&gt;YYData-&gt;{INPUT} = &lt;STDIN&gt;
    58      or  return('',undef);
    59
    60      $parser-&gt;YYData-&gt;{INPUT}=~s/^\s+//;
    61
    62      for ($parser-&gt;YYData-&gt;{INPUT}) {
    63          s/^([0-9]+(?:\.[0-9]+)?)//
    64                  and return('NUM',$1);
    65          s/^([A-Za-z][A-Za-z0-9_]*)//
    66                  and return('VAR',$1);
    67          s/^(.)//s
    68                  and return($1,$1);
    69      }
    70  }
    71
    72  sub Run {
    73      my($self)=shift;
    74      $self-&gt;YYParse( yylex =&gt; \&amp;_Lexer, yyerror =&gt; \&amp;_Error,
    75                      #yydebug =&gt;0xFF
    76                    );
    77  }
    78  }; # end grammar
    79
    80
    81  $Data::Dumper::Indent = 1;
    82  Parse::Eyapp-&gt;new_grammar(
    83    input=&gt;$grammar,
    84    classname=&gt;'Rule6',
    85    firstline =&gt;7,
    86    outputfile =&gt; 'Calc.pm',
    87  );
    88  my $parser = Rule6-&gt;new();
    89  $parser-&gt;YYData-&gt;{INPUT} = &quot;a = -(2*3+5-1)\n&quot;;
    90  my $t = $parser-&gt;Run;
    91  print &quot;\n***** Before ******\n&quot;;
    92  print Dumper($t);
    93
    94  my $attgram = new Language::AttributeGrammar &lt;&lt;'EOG';
    95
    96  # Compute the expression
    97  NUM:    $/.val = { $&lt;attr&gt; }
    98  TIMES:  $/.val = { $&lt;left&gt;.val * $&lt;right&gt;.val }
    99  PLUS:   $/.val = { $&lt;left&gt;.val + $&lt;right&gt;.val }
   100  MINUS:  $/.val = { $&lt;left&gt;.val - $&lt;right&gt;.val }
   101  UMINUS: $/.val = { -$&lt;exp&gt;.val }
   102  ASSIGN: $/.val = { $&lt;exp&gt;.val }
   103  EOG
   104
   105  my $res = $attgram-&gt;apply($t, 'val');
   106
   107  $Data::Dumper::Indent = 1;
   108  print &quot;\n***** After ******\n&quot;;
   109  print Dumper($t);
   110  print Dumper($res);
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<ul class="Bl-bullet">
  <li>Parse::Eyapp, Parse::Eyapp::eyapplanguageref, Parse::Eyapp::debugingtut,
      Parse::Eyapp::defaultactionsintro, Parse::Eyapp::translationschemestut,
      Parse::Eyapp::Driver, Parse::Eyapp::Node, Parse::Eyapp::YATW,
      Parse::Eyapp::Treeregexp, Parse::Eyapp::Scope, Parse::Eyapp::Base,</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/MatchingTrees.pdf&gt;</li>
  <li>The tutorial <i>Parsing Strings and Trees with</i>
      <span class="Li">&quot;Parse::Eyapp&quot;</span> (An Introduction to
      Compiler Construction in seven pages) in
      &lt;http://nereida.deioc.ull.es/~pl/eyapsimple/&gt;</li>
  <li>perldoc eyapp,</li>
  <li>perldoc treereg,</li>
  <li>perldoc vgg,</li>
  <li>The Syntax Highlight file for vim at
      &lt;http://www.vim.org/scripts/script.php?script_id=2453&gt; and
      &lt;http://nereida.deioc.ull.es/~vim/&gt;</li>
  <li><i>Analisis Lexico y Sintactico</i>, (Notes for a course in compiler
      construction) by Casiano Rodriguez-Leon. Available at
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/&gt; Is the more complete
      and reliable source for Parse::Eyapp. However is in Spanish.</li>
  <li>Parse::Yapp,</li>
  <li>Man pages of <b>yacc</b>(1),</li>
  <li>Man pages of <b>bison</b>(1),</li>
  <li>Language::AttributeGrammar</li>
  <li>Parse::RecDescent.</li>
  <li>HOP::Parser</li>
  <li>HOP::Lexer</li>
  <li>ocamlyacc tutorial at
      &lt;http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex-ocamlyacc/ocamlyacc-tutorial/ocamlyacc-tutorial.html&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="REFERENCES"><a class="permalink" href="#REFERENCES">REFERENCES</a></h1>
<ul class="Bl-bullet">
  <li>The classic Dragon's book <i>Compilers: Principles, Techniques, and
      Tools</i> by Alfred V. Aho, Ravi Sethi and Jeffrey D. Ullman
      (Addison-Wesley 1986)</li>
  <li><i>CS2121: The Implementation and Power of Programming Languages</i> (See
      &lt;http://www.cs.man.ac.uk/~pjj&gt;,
      &lt;http://www.cs.man.ac.uk/~pjj/complang/g2lr.html&gt; and
      &lt;http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html&gt;) by Pete Jinks</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">William N. Braswell, Jr.
    &lt;wbraswell_cpan@NOSPAM.nym.hush.com&gt; (Remove &quot;NOSPAM&quot;.)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGMENTS"><a class="permalink" href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a></h1>
<p class="Pp">This work has been supported by CEE (FEDER) and the Spanish
    Ministry of <i>Educacion y Ciencia</i> through <i>Plan Nacional I+D+I</i>
    number TIN2005-08818-C04-04 (ULL::OPLINK project
    &lt;http://www.oplink.ull.es/&gt;). Support from Gobierno de Canarias was
    through GC02210601 (<i>Grupos Consolidados</i>). The University of La Laguna
    has also supported my work in many ways and for many years.</p>
<p class="Pp">A large percentage of code is verbatim taken from Parse::Yapp
    1.05. The author of Parse::Yapp is Francois Desarmenien.</p>
<p class="Pp">I wish to thank Francois Desarmenien for his Parse::Yapp module,
    to my students at La Laguna and to the Perl Community. Special thanks to my
    family and Larry Wall.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE_AND_COPYRIGHT"><a class="permalink" href="#LICENSE_AND_COPYRIGHT">LICENSE
  AND COPYRIGHT</a></h1>
<p class="Pp">Copyright &#x00A9; 2006, 2007, 2008, 2009, 2010, 2011, 2012
    Casiano Rodriguez-Leon. Copyright &#x00A9; 2017 William N. Braswell, Jr. All
    Rights Reserved.</p>
<p class="Pp">Parse::Yapp is Copyright &#x00A9; 1998, 1999, 2000, 2001, Francois
    Desarmenien. Parse::Yapp is Copyright &#x00A9; 2017 William N. Braswell, Jr.
    All Rights Reserved.</p>
<p class="Pp">These modules are free software; you can redistribute it and/or
    modify it under the same terms as Perl itself. See perlartistic.</p>
<p class="Pp">This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="POD_ERRORS"><a class="permalink" href="#POD_ERRORS">POD
  ERRORS</a></h1>
<p class="Pp">Hey! <b>The above document had some coding errors, which are
    explained below:</b></p>
<dl class="Bl-tag">
  <dt id="Around"><a class="permalink" href="#Around">Around line 1804:</a></dt>
  <dd>Non-ASCII character seen before =encoding in 'v&#x00E1;lida\n&quot;;'.
      Assuming UTF-8</dd>
</dl>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-06-14</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

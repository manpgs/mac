<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Class::Inspector(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Class::Inspector(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Class::Inspector(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Class::Inspector - Get information about a class and its
  structure</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
  use Class::Inspector;
  
  # Is a class installed and/or loaded
  Class::Inspector-&gt;installed( 'Foo::Class' );
  Class::Inspector-&gt;loaded( 'Foo::Class' );
  
  # Filename related information
  Class::Inspector-&gt;filename( 'Foo::Class' );
  Class::Inspector-&gt;resolved_filename( 'Foo::Class' );
  
  # Get subroutine related information
  Class::Inspector-&gt;functions( 'Foo::Class' );
  Class::Inspector-&gt;function_refs( 'Foo::Class' );
  Class::Inspector-&gt;function_exists( 'Foo::Class', 'bar' );
  Class::Inspector-&gt;methods( 'Foo::Class', 'full', 'public' );
  
  # Find all loaded subclasses or something
  Class::Inspector-&gt;subclasses( 'Foo::Class' );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Class::Inspector allows you to get information about a loaded
    class. Most or all of this information can be found in other ways, but they
    aren't always very friendly, and usually involve a relatively high level of
    Perl wizardry, or strange and unusual looking code. Class::Inspector
    attempts to provide an easier, more friendly interface to this
  information.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="installed_$class"><a class="permalink" href="#installed_$class">installed
  $class</a></h2>
<p class="Pp">The <span class="Li">&quot;installed&quot;</span> static method
    tries to determine if a class is installed on the machine, or at least
    available to Perl. It does this by wrapping around
    <span class="Li">&quot;resolved_filename&quot;</span>.</p>
<p class="Pp">Returns true if installed/available, false if the class is not
    installed, or <span class="Li">&quot;undef&quot;</span> if the class name is
    invalid.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="loaded_$class"><a class="permalink" href="#loaded_$class">loaded
  $class</a></h2>
<p class="Pp">The <span class="Li">&quot;loaded&quot;</span> static method tries
    to determine if a class is loaded by looking for symbol table entries.</p>
<p class="Pp">This method it uses to determine this will work even if the class
    does not have its own file, but is contained inside a single file with
    multiple classes in it. Even in the case of some sort of run-time loading
    class being used, these typically leave some trace in the symbol table, so
    an Autoload or Class::Autouse-based class should correctly appear
  loaded.</p>
<p class="Pp">Returns true if the class is loaded, false if not, or
    <span class="Li">&quot;undef&quot;</span> if the class name is invalid.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="filename_$class"><a class="permalink" href="#filename_$class">filename
  $class</a></h2>
<p class="Pp">For a given class, returns the base filename for the class. This
    will NOT be a fully resolved filename, just the part of the filename BELOW
    the <span class="Li">@INC</span> entry.</p>
<p class="Pp"></p>
<pre>
  print Class-&gt;filename( 'Foo::Bar' );
  &gt; Foo/Bar.pm
</pre>
<p class="Pp">This filename will be returned with the right seperator for the
    local platform, and should work on all platforms.</p>
<p class="Pp">Returns the filename on success or
    <span class="Li">&quot;undef&quot;</span> if the class name is invalid.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="resolved_filename_$class,_@try_first"><a class="permalink" href="#resolved_filename_$class,_@try_first">resolved_filename
  $class, @try_first</a></h2>
<p class="Pp">For a given class, the
    <span class="Li">&quot;resolved_filename&quot;</span> static method returns
    the fully resolved filename for a class. That is, the file that the class
    would be loaded from.</p>
<p class="Pp">This is not nescesarily the file that the class WAS loaded from,
    as the value returned is determined each time it runs, and the
    <span class="Li">@INC</span> include path may change.</p>
<p class="Pp">To get the actual file for a loaded class, see the
    <span class="Li">&quot;loaded_filename&quot;</span> method.</p>
<p class="Pp">Returns the filename for the class, or
    <span class="Li">&quot;undef&quot;</span> if the class name is invalid.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="loaded_filename_$class"><a class="permalink" href="#loaded_filename_$class">loaded_filename
  $class</a></h2>
<p class="Pp">For a given loaded class, the
    <span class="Li">&quot;loaded_filename&quot;</span> static method determines
    (via the <span class="Li">%INC</span> hash) the name of the file that it was
    originally loaded from.</p>
<p class="Pp">Returns a resolved file path, or false if the class did not have
    it's own file.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="functions_$class"><a class="permalink" href="#functions_$class">functions
  $class</a></h2>
<p class="Pp">For a loaded class, the
    <span class="Li">&quot;functions&quot;</span> static method returns a list
    of the names of all the functions in the classes immediate namespace.</p>
<p class="Pp">Note that this is not the METHODS of the class, just the
    functions.</p>
<p class="Pp">Returns a reference to an array of the function names on success,
    or <span class="Li">&quot;undef&quot;</span> if the class name is invalid or
    the class is not loaded.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="function_refs_$class"><a class="permalink" href="#function_refs_$class">function_refs
  $class</a></h2>
<p class="Pp">For a loaded class, the
    <span class="Li">&quot;function_refs&quot;</span> static method returns
    references to all the functions in the classes immediate namespace.</p>
<p class="Pp">Note that this is not the METHODS of the class, just the
    functions.</p>
<p class="Pp">Returns a reference to an array of
    <span class="Li">&quot;CODE&quot;</span> refs of the functions on success,
    or <span class="Li">&quot;undef&quot;</span> if the class is not loaded.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="function_exists_$class,_$function"><a class="permalink" href="#function_exists_$class,_$function">function_exists
  $class, $function</a></h2>
<p class="Pp">Given a class and function name the
    <span class="Li">&quot;function_exists&quot;</span> static method will check
    to see if the function exists in the class.</p>
<p class="Pp">Note that this is as a function, not as a method. To see if a
    method exists for a class, use the <span class="Li">&quot;can&quot;</span>
    method for any class or object.</p>
<p class="Pp">Returns true if the function exists, false if not, or
    <span class="Li">&quot;undef&quot;</span> if the class or function name are
    invalid, or the class is not loaded.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="methods_$class,_@options"><a class="permalink" href="#methods_$class,_@options">methods
  $class, @options</a></h2>
<p class="Pp">For a given class name, the
    <span class="Li">&quot;methods&quot;</span> static method will returns ALL
    the methods available to that class. This includes all methods available
    from every class up the class' <span class="Li">@ISA</span> tree.</p>
<p class="Pp">Returns a reference to an array of the names of all the available
    methods on success, or <span class="Li">&quot;undef&quot;</span> if the
    class name is invalid or the class is not loaded.</p>
<p class="Pp">A number of options are available to the
    <span class="Li">&quot;methods&quot;</span> method that will alter the
    results returned. These should be listed after the class name, in any
  order.</p>
<p class="Pp"></p>
<pre>
  # Only get public methods
  my $method = Class::Inspector-&gt;methods( 'My::Class', 'public' );
</pre>
<dl class="Bl-tag">
  <dt id="public"><a class="permalink" href="#public">public</a></dt>
  <dd>The <span class="Li">&quot;public&quot;</span> option will return only
      'public' methods, as defined by the Perl convention of prepending an
      underscore to any 'private' methods. The
      <span class="Li">&quot;public&quot;</span> option will effectively remove
      any methods that start with an underscore.</dd>
  <dt id="private"><a class="permalink" href="#private">private</a></dt>
  <dd>The <span class="Li">&quot;private&quot;</span> options will return only
      'private' methods, as defined by the Perl convention of prepending an
      underscore to an private methods. The
      <span class="Li">&quot;private&quot;</span> option will effectively remove
      an method that do not start with an underscore.
    <p class="Pp"><b>Note: The </b><b>&quot;public&quot;</b><b> and
        </b><b>&quot;private&quot;</b><b> options are mutually exclusive</b></p>
  </dd>
  <dt id="full"><a class="permalink" href="#full">full</a></dt>
  <dd><span class="Li">&quot;methods&quot;</span> normally returns just the
      method name. Supplying the <span class="Li">&quot;full&quot;</span> option
      will cause the methods to be returned as the full names. That is, instead
      of returning <span class="Li">&quot;[ 'method1', 'method2', 'method3'
      ]&quot;</span>, you would instead get <span class="Li">&quot;[
      'Class::method1', 'AnotherClass::method2', 'Class::method3'
      ]&quot;</span>.</dd>
  <dt id="expanded"><a class="permalink" href="#expanded">expanded</a></dt>
  <dd>The <span class="Li">&quot;expanded&quot;</span> option will cause a lot
      more information about method to be returned. Instead of just the method
      name, you will instead get an array reference containing the method name
      as a single combined name, ala <span class="Li">&quot;full&quot;</span>,
      the seperate class and method, and a CODE ref to the actual function ( if
      available ). Please note that the function reference is not guarenteed to
      be available. <span class="Li">&quot;Class::Inspector&quot;</span> is
      intended at some later time, work with modules that have some some of
      common run-time loader in place ( e.g
      <span class="Li">&quot;Autoloader&quot;</span> or
      <span class="Li">&quot;Class::Autouse&quot;</span> for example.
    <p class="Pp">The response from <span class="Li">&quot;methods( 'Class',
        'expanded' )&quot;</span> would look something like the following.</p>
    <p class="Pp"></p>
    <pre>
  [
    [ 'Class::method1',   'Class',   'method1', \&amp;Class::method1   ],
    [ 'Another::method2', 'Another', 'method2', \&amp;Another::method2 ],
    [ 'Foo::bar',         'Foo',     'bar',     \&amp;Foo::bar         ],
  ]
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="subclasses_$class"><a class="permalink" href="#subclasses_$class">subclasses
  $class</a></h2>
<p class="Pp">The <span class="Li">&quot;subclasses&quot;</span> static method
    will search then entire namespace (and thus <b>all</b> currently loaded
    classes) to find all classes that are subclasses of the class provided as a
    the parameter.</p>
<p class="Pp">The actual test will be done by calling
    <span class="Li">&quot;isa&quot;</span> on the class as a static method.
    (i.e. <span class="Li">&quot;My::Class-&gt;isa($class)&quot;</span>.</p>
<p class="Pp">Returns a reference to a list of the loaded classes that match the
    class provided, or false is none match, or
    <span class="Li">&quot;undef&quot;</span> if the class name provided is
    invalid.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
<p class="Pp">Bugs should be reported via the CPAN bug tracker</p>
<p class="Pp">&lt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Class-Inspector&gt;</p>
<p class="Pp">For other issues, or commercial enhancement or support, contact
    the author.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Adam Kennedy &lt;adamk@cpan.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">&lt;http://ali.as/&gt;, Class::Handle</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 2002 - 2012 Adam Kennedy.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">The full text of the license can be found in the LICENSE file
    included with this module.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2012-10-19</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Object::Accessor(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Object::Accessor(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Object::Accessor(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Object::Accessor - interface to create per object accessors</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
    ### using the object
    $obj = Object::Accessor-&gt;new;        # create object
    $obj = Object::Accessor-&gt;new(@list); # create object with accessors
    $obj = Object::Accessor-&gt;new(\%h);   # create object with accessors
                                         # and their allow handlers

    $bool   = $obj-&gt;mk_accessors('foo'); # create accessors
    $bool   = $obj-&gt;mk_accessors(        # create accessors with input
               {foo =&gt; ALLOW_HANDLER} ); # validation

    $bool   = $obj-&gt;mk_aliases(          # create an alias to an existing
                alias_name =&gt; 'method'); # method name

    $clone  = $obj-&gt;mk_clone;            # create a clone of original
                                         # object without data
    $bool   = $obj-&gt;mk_flush;            # clean out all data

    @list   = $obj-&gt;ls_accessors;        # retrieves a list of all
                                         # accessors for this object

    $bar    = $obj-&gt;foo('bar');          # set 'foo' to 'bar'
    $bar    = $obj-&gt;foo();               # retrieve 'bar' again

    $sub    = $obj-&gt;can('foo');          # retrieve coderef for
                                         # 'foo' accessor
    $bar    = $sub-&gt;('bar');             # set 'foo' via coderef
    $bar    = $sub-&gt;();                  # retrieve 'bar' by coderef

    ### using the object as base class
    package My::Class;
    use base 'Object::Accessor';

    $obj    = My::Class-&gt;new;               # create base object
    $bool   = $obj-&gt;mk_accessors('foo');    # create accessors, etc...

    ### make all attempted access to non-existent accessors fatal
    ### (defaults to false)
    $Object::Accessor::FATAL = 1;

    ### enable debugging
    $Object::Accessor::DEBUG = 1;

    ### advanced usage -- callbacks
    {   my $obj = Object::Accessor-&gt;new('foo');
        $obj-&gt;register_callback( sub { ... } );

        $obj-&gt;foo( 1 ); # these calls invoke the callback you registered
        $obj-&gt;foo()     # which allows you to change the get/set
                        # behaviour and what is returned to the caller.
    }

    ### advanced usage -- lvalue attributes
    {   my $obj = Object::Accessor::Lvalue-&gt;new('foo');
        print $obj-&gt;foo = 1;            # will print 1
    }

    ### advanced usage -- scoped attribute values
    {   my $obj = Object::Accessor-&gt;new('foo');

        $obj-&gt;foo( 1 );
        print $obj-&gt;foo;                # will print 1

        ### bind the scope of the value of attribute 'foo'
        ### to the scope of '$x' -- when $x goes out of
        ### scope, 'foo's previous value will be restored
        {   $obj-&gt;foo( 2 =&gt; \my $x );
            print $obj-&gt;foo, ' ', $x;   # will print '2 2'
        }
        print $obj-&gt;foo;                # will print 1
    }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><span class="Li">&quot;Object::Accessor&quot;</span> provides an
    interface to create per object accessors (as opposed to per
    <span class="Li">&quot;Class&quot;</span> accessors, as, for example,
    <span class="Li">&quot;Class::Accessor&quot;</span> provides).</p>
<p class="Pp">You can choose to either subclass this module, and thus using its
    accessors on your own module, or to store an
    <span class="Li">&quot;Object::Accessor&quot;</span> object inside your own
    object, and access the accessors from there. See the
    <span class="Li">&quot;SYNOPSIS&quot;</span> for examples.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="$object_=_Object::Accessor"><a class="permalink" href="#$object_=_Object::Accessor">$object
  = Object::Accessor-&gt;new( [ARGS] );</a></h2>
<p class="Pp">Creates a new (and empty)
    <span class="Li">&quot;Object::Accessor&quot;</span> object. This method is
    inheritable.</p>
<p class="Pp">Any arguments given to <span class="Li">&quot;new&quot;</span> are
    passed straight to <span class="Li">&quot;mk_accessors&quot;</span>.</p>
<p class="Pp">If you want to be able to assign to your accessors as if they were
    <span class="Li">&quot;lvalue&quot;</span>s, you should create your object
    in the <span class="Li">&quot;Object::Accessor::Lvalue&quot;</span>
    namespace instead. See the section on <span class="Li">&quot;LVALUE
    ACCESSORS&quot;</span> below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$bool_=_$object"><a class="permalink" href="#$bool_=_$object">$bool
  = $object-&gt;mk_accessors( @ACCESSORS | \%ACCESSOR_MAP );</a></h2>
<p class="Pp">Creates a list of accessors for this object (and
    <span class="Li">&quot;NOT&quot;</span> for other ones in the same class!).
    Will not clobber existing data, so if an accessor already exists, requesting
    to create again is effectively a
  <span class="Li">&quot;no-op&quot;</span>.</p>
<p class="Pp">When providing a <span class="Li">&quot;hashref&quot;</span> as
    argument, rather than a normal list, you can specify a list of key/value
    pairs of accessors and their respective input validators. The validators can
    be anything that <span class="Li">&quot;Params::Check&quot;</span>'s
    <span class="Li">&quot;allow&quot;</span> function accepts. Please see its
    manpage for details.</p>
<p class="Pp">For example:</p>
<p class="Pp"></p>
<pre>
    $object-&gt;mk_accessors( {
        foo     =&gt; qr/^\d+$/,       # digits only
        bar     =&gt; [0,1],           # booleans
        zot     =&gt; \&amp;my_sub         # a custom verification sub
    } );
</pre>
<p class="Pp">Returns true on success, false on failure.</p>
<p class="Pp">Accessors that are called on an object, that do not exist return
    <span class="Li">&quot;undef&quot;</span> by default, but you can make this
    a fatal error by setting the global variable <span class="Li">$FATAL</span>
    to true. See the section on <span class="Li">&quot;GLOBAL</span>
    <span class="Li">VARIABLES&quot;</span> for details.</p>
<p class="Pp">Note that you can bind the values of attributes to a scope. This
    allows you to <span class="Li">&quot;temporarily&quot;</span> change a value
    of an attribute, and have it's original value restored up on the end of it's
    bound variable's scope;</p>
<p class="Pp">For example, in this snippet of code, the attribute
    <span class="Li">&quot;foo&quot;</span> will temporarily be set to
    <span class="Li">2</span>, until the end of the scope of
    <span class="Li">$x</span>, at which point the original value of
    <span class="Li">1</span> will be restored.</p>
<p class="Pp"></p>
<pre>
    my $obj = Object::Accessor-&gt;new;

    $obj-&gt;mk_accessors('foo');
    $obj-&gt;foo( 1 );
    print $obj-&gt;foo;                # will print 1

    ### bind the scope of the value of attribute 'foo'
    ### to the scope of '$x' -- when $x goes out of
    ### scope, 'foo' previous value will be restored
    {   $obj-&gt;foo( 2 =&gt; \my $x );
        print $obj-&gt;foo, ' ', $x;   # will print '2 2'
    }
    print $obj-&gt;foo;                # will print 1
</pre>
<p class="Pp">Note that all accessors are read/write for everyone. See the
    <span class="Li">&quot;TODO&quot;</span> section for details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="@list_=_$self"><a class="permalink" href="#@list_=_$self">@list
  = $self-&gt;ls_accessors;</a></h2>
<p class="Pp">Returns a list of accessors that are supported by the current
    object. The corresponding coderefs can be retrieved by passing this list one
    by one to the <span class="Li">&quot;can&quot;</span> method.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$ref_=_$self"><a class="permalink" href="#$ref_=_$self">$ref
  = $self-&gt;ls_allow(KEY)</a></h2>
<p class="Pp">Returns the allow handler for the given key, which can be used
    with <span class="Li">&quot;Params::Check&quot;</span>'s
    <span class="Li">&quot;allow()&quot;</span> handler. If there was no allow
    handler specified, an allow handler that always returns true will be
    returned.</p>
</section>
<section class="Ss">
<h2 class="Ss">$bool = $self-&gt;mk_aliases( alias =&gt; method, [alias2 =&gt;
  method2, ...] );</h2>
<p class="Pp">Creates an alias for a given method name. For all intents and
    purposes, these two accessors are now identical for this object. This is
    akin to doing the following on the symbol table level:</p>
<p class="Pp"></p>
<pre>
  *alias = *method
</pre>
<p class="Pp">This allows you to do the following:</p>
<p class="Pp"></p>
<pre>
  $self-&gt;mk_accessors('foo');
  $self-&gt;mk_aliases( bar =&gt; 'foo' );

  $self-&gt;bar( 42 );
  print $self-&gt;foo;     # will print 42
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$clone_=_$self"><a class="permalink" href="#$clone_=_$self">$clone
  = $self-&gt;mk_clone;</a></h2>
<p class="Pp">Makes a clone of the current object, which will have the exact
    same accessors as the current object, but without the data stored in
  them.</p>
</section>
<section class="Ss">
<h2 class="Ss">$bool = $self-&gt;mk_flush;</h2>
<p class="Pp">Flushes all the data from the current object; all accessors will
    be set back to their default state of
    <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp">Returns true on success and false on failure.</p>
</section>
<section class="Ss">
<h2 class="Ss">$bool = $self-&gt;mk_verify;</h2>
<p class="Pp">Checks if all values in the current object are in accordance with
    their own allow handler. Specifically useful to check if an empty
    initialised object has been filled with values satisfying their own allow
    criteria.</p>
</section>
<section class="Ss">
<h2 class="Ss">$bool = $self-&gt;register_callback( sub { ... } );</h2>
<p class="Pp">This method allows you to register a callback, that is invoked
    every time an accessor is called. This allows you to munge input data,
    access external data stores, etc.</p>
<p class="Pp">You are free to return whatever you wish. On a
    <span class="Li">&quot;set&quot;</span> call, the data is even stored in the
    object.</p>
<p class="Pp">Below is an example of the use of a callback.</p>
<p class="Pp"></p>
<pre>
    $object-&gt;some_method( &quot;some_value&quot; );

    my $callback = sub {
        my $self    = shift; # the object
        my $meth    = shift; # &quot;some_method&quot;
        my $val     = shift; # [&quot;some_value&quot;]
                             # could be undef -- check 'exists';
                             # if scalar @$val is empty, it was a 'get'

        # your code here

        return $new_val;     # the value you want to be set/returned
    }
</pre>
<p class="Pp">To access the values stored in the object, circumventing the
    callback structure, you should use the
    <span class="Li">&quot;___get&quot;</span> and
    <span class="Li">&quot;___set&quot;</span> methods documented further
  down.</p>
</section>
<section class="Ss">
<h2 class="Ss">$bool = $self-&gt;can( METHOD_NAME )</h2>
<p class="Pp">This method overrides
    <span class="Li">&quot;UNIVERAL::can&quot;</span> in order to provide
    coderefs to accessors which are loaded on demand. It will behave just like
    <span class="Li">&quot;UNIVERSAL::can&quot;</span> where it can -- returning
    a class method if it exists, or a closure pointing to a valid accessor of
    this particular object.</p>
<p class="Pp">You can use it as follows:</p>
<p class="Pp"></p>
<pre>
    $sub = $object-&gt;can('some_accessor');   # retrieve the coderef
    $sub-&gt;('foo');                          # 'some_accessor' now set
                                            # to 'foo' for $object
    $foo = $sub-&gt;();                        # retrieve the contents
                                            # of 'some_accessor'
</pre>
<p class="Pp">See the <span class="Li">&quot;SYNOPSIS&quot;</span> for more
    examples.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$val_=_$self"><a class="permalink" href="#$val_=_$self">$val
  = $self-&gt;___get( METHOD_NAME );</a></h2>
<p class="Pp">Method to directly access the value of the given accessor in the
    object. It circumvents all calls to allow checks, callbacks, etc.</p>
<p class="Pp">Use only if you <span class="Li">&quot;Know What You Are
    Doing&quot;</span>! General usage for this functionality would be in your
    own custom callbacks.</p>
</section>
<section class="Ss">
<h2 class="Ss">$bool = $self-&gt;___set( METHOD_NAME =&gt; VALUE );</h2>
<p class="Pp">Method to directly set the value of the given accessor in the
    object. It circumvents all calls to allow checks, callbacks, etc.</p>
<p class="Pp">Use only if you <span class="Li">&quot;Know What You Are
    Doing&quot;</span>! General usage for this functionality would be in your
    own custom callbacks.</p>
</section>
<section class="Ss">
<h2 class="Ss">$bool = $self-&gt;___alias( ALIAS =&gt; METHOD );</h2>
<p class="Pp">Method to directly alias one accessor to another for this object.
    It circumvents all sanity checks, etc.</p>
<p class="Pp">Use only if you <span class="Li">&quot;Know What You Are
    Doing&quot;</span>!</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="LVALUE_ACCESSORS"><a class="permalink" href="#LVALUE_ACCESSORS">LVALUE
  ACCESSORS</a></h1>
<p class="Pp"><span class="Li">&quot;Object::Accessor&quot;</span> supports
    <span class="Li">&quot;lvalue&quot;</span> attributes as well. To enable
    these, you should create your objects in the designated namespace,
    <span class="Li">&quot;Object::Accessor::Lvalue&quot;</span>. For
  example:</p>
<p class="Pp"></p>
<pre>
    my $obj = Object::Accessor::Lvalue-&gt;new('foo');
    $obj-&gt;foo += 1;
    print $obj-&gt;foo;
</pre>
<p class="Pp">will actually print <span class="Li">1</span> and work as
    expected. Since this is an optional feature, that's not desirable in all
    cases, we require you to explicitly use the
    <span class="Li">&quot;Object::Accessor::Lvalue&quot;</span> class.</p>
<p class="Pp">Doing the same on the standard
    <span class="Li">&quot;Object&quot;</span>&gt;Accessor&gt; class would
    generate the following code &amp; errors:</p>
<p class="Pp"></p>
<pre>
    my $obj = Object::Accessor-&gt;new('foo');
    $obj-&gt;foo += 1;

    Can't modify non-lvalue subroutine call
</pre>
<p class="Pp">Note that <span class="Li">&quot;lvalue&quot;</span> support on
    <span class="Li">&quot;AUTOLOAD&quot;</span> routines is a
    <span class="Li">&quot;perl 5.8.x&quot;</span> feature. See perldoc
    perl58delta for details.</p>
<section class="Ss">
<h2 class="Ss">CAVEATS</h2>
<ul class="Bl-bullet">
  <li>Allow handlers
    <p class="Pp">Due to the nature of <span class="Li">&quot;lvalue
        subs&quot;</span>, we never get access to the value you are assigning,
        so we can not check it against your allow handler. Allow handlers are
        therefor unsupported under <span class="Li">&quot;lvalue&quot;</span>
        conditions.</p>
    <p class="Pp">See <span class="Li">&quot;perldoc perlsub&quot;</span> for
        details.</p>
  </li>
  <li>Callbacks
    <p class="Pp">Due to the nature of <span class="Li">&quot;lvalue
        subs&quot;</span>, we never get access to the value you are assigning,
        so we can not check provide this value to your callback. Furthermore, we
        can not distinguish between a <span class="Li">&quot;get&quot;</span>
        and a <span class="Li">&quot;set&quot;</span> call. Callbacks are
        therefor unsupported under <span class="Li">&quot;lvalue&quot;</span>
        conditions.</p>
    <p class="Pp">See <span class="Li">&quot;perldoc perlsub&quot;</span> for
        details.</p>
  </li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="GLOBAL_VARIABLES"><a class="permalink" href="#GLOBAL_VARIABLES">GLOBAL
  VARIABLES</a></h1>
<section class="Ss">
<h2 class="Ss" id="$Object::Accessor::FATAL"><a class="permalink" href="#$Object::Accessor::FATAL">$Object::Accessor::FATAL</a></h2>
<p class="Pp">Set this variable to true to make all attempted access to
    non-existent accessors be fatal. This defaults to
    <span class="Li">&quot;false&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$Object::Accessor::DEBUG"><a class="permalink" href="#$Object::Accessor::DEBUG">$Object::Accessor::DEBUG</a></h2>
<p class="Pp">Set this variable to enable debugging output. This defaults to
    <span class="Li">&quot;false&quot;</span>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TODO"><a class="permalink" href="#TODO">TODO</a></h1>
<section class="Ss">
<h2 class="Ss" id="Create_read-only_accessors"><a class="permalink" href="#Create_read-only_accessors">Create
  read-only accessors</a></h2>
<p class="Pp">Currently all accessors are read/write for everyone. Perhaps a
    future release should make it possible to have read-only accessors as
  well.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<p class="Pp">If you use codereferences for your allow handlers, you will not be
    able to freeze the data structures using
    <span class="Li">&quot;Storable&quot;</span>.</p>
<p class="Pp">Due to a bug in storable (until at least version 2.15),
    <span class="Li">&quot;qr//&quot;</span> compiled regexes also don't
    de-serialize properly. Although this bug has been reported, you should be
    aware of this issue when serializing your objects.</p>
<p class="Pp">You can track the bug here:</p>
<p class="Pp"></p>
<pre>
    http://rt.cpan.org/Ticket/Display.html?id=1827
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="BUG_REPORTS"><a class="permalink" href="#BUG_REPORTS">BUG
  REPORTS</a></h1>
<p class="Pp">Please report bugs or other issues to
    &lt;bug-object-accessor@rt.cpan.org&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">This module by Jos Boumans &lt;kane@cpan.org&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">This library is free software; you may redistribute and/or modify
    it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

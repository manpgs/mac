<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>DBIx::Class::ResultSource(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBIx::Class::ResultSource(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBIx::Class::ResultSource(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">DBIx::Class::ResultSource - Result source object</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
  # Create a table based result source, in a result class.

  package MyApp::Schema::Result::Artist;
  use base qw/DBIx::Class::Core/;

  __PACKAGE__-&gt;table('artist');
  __PACKAGE__-&gt;add_columns(qw/ artistid name /);
  __PACKAGE__-&gt;set_primary_key('artistid');
  __PACKAGE__-&gt;has_many(cds =&gt; 'MyApp::Schema::Result::CD');

  1;

  # Create a query (view) based result source, in a result class
  package MyApp::Schema::Result::Year2000CDs;
  use base qw/DBIx::Class::Core/;

  __PACKAGE__-&gt;load_components('InflateColumn::DateTime');
  __PACKAGE__-&gt;table_class('DBIx::Class::ResultSource::View');

  __PACKAGE__-&gt;table('year2000cds');
  __PACKAGE__-&gt;result_source_instance-&gt;is_virtual(1);
  __PACKAGE__-&gt;result_source_instance-&gt;view_definition(
      &quot;SELECT cdid, artist, title FROM cd WHERE year ='2000'&quot;
      );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">A ResultSource is an object that represents a source of data for
    querying.</p>
<p class="Pp">This class is a base class for various specialised types of result
    sources, for example DBIx::Class::ResultSource::Table. Table is the default
    result source type, so one is created for you when defining a result class
    as described in the synopsis above.</p>
<p class="Pp">More specifically, the DBIx::Class::Core base class pulls in the
    DBIx::Class::ResultSourceProxy::Table component, which defines the table
    method. When called, <span class="Li">&quot;table&quot;</span> creates and
    stores an instance of DBIx::Class::ResultSource::Table. Luckily, to use
    tables as result sources, you don't need to remember any of this.</p>
<p class="Pp">Result sources representing select queries, or views, can also be
    created, see DBIx::Class::ResultSource::View for full details.</p>
<section class="Ss">
<h2 class="Ss" id="Finding_result_source_objects"><a class="permalink" href="#Finding_result_source_objects">Finding
  result source objects</a></h2>
<p class="Pp">As mentioned above, a result source instance is created and stored
    for you when you define a Result Class.</p>
<p class="Pp">You can retrieve the result source at runtime in the following
    ways:</p>
<dl class="Bl-tag">
  <dt id="From"><a class="permalink" href="#From">From a Schema object:</a></dt>
  <dd>
    <pre>
   $schema-&gt;source($source_name);
    </pre>
  </dd>
  <dt id="From~2"><a class="permalink" href="#From~2">From a Result
    object:</a></dt>
  <dd>
    <pre>
   $result-&gt;result_source;
    </pre>
  </dd>
  <dt id="From~3"><a class="permalink" href="#From~3">From a ResultSet
    object:</a></dt>
  <dd>
    <pre>
   $rs-&gt;result_source;
    </pre>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
<pre>
  $class-&gt;new();

  $class-&gt;new({attribute_name =&gt; value});
</pre>
<p class="Pp">Creates a new ResultSource object. Not normally called directly by
    end users.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="add_columns"><a class="permalink" href="#add_columns">add_columns</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:"><a class="permalink" href="#Arguments:">Arguments:
    @columns</a></dt>
  <dd></dd>
  <dt id="Return"><a class="permalink" href="#Return">Return Value:
    $result_source</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  $source-&gt;add_columns(qw/col1 col2 col3/);

  $source-&gt;add_columns('col1' =&gt; \%col1_info, 'col2' =&gt; \%col2_info, ...);

  $source-&gt;add_columns(
    'col1' =&gt; { data_type =&gt; 'integer', is_nullable =&gt; 1, ... },
    'col2' =&gt; { data_type =&gt; 'text',    is_auto_increment =&gt; 1, ... },
  );
</pre>
<p class="Pp">Adds columns to the result source. If supplied colname =&gt;
    hashref pairs, uses the hashref as the &quot;column_info&quot; for that
    column. Repeated calls of this method will add more columns, not replace
    them.</p>
<p class="Pp">The column names given will be created as accessor methods on your
    Result objects. You can change the name of the accessor by supplying an
    &quot;accessor&quot; in the column_info hash.</p>
<p class="Pp">If a column name beginning with a plus sign ('+col1') is provided,
    the attributes provided will be merged with any existing attributes for the
    column, with the new attributes taking precedence in the case that an
    attribute already exists. Using this without a hashref
    (<span class="Li">&quot;$source-&gt;add_columns(qw/+col1
    +col2/)&quot;</span>) is legal, but useless -- it does the same thing it
    would do without the plus.</p>
<p class="Pp">The contents of the column_info are not set in stone. The
    following keys are currently recognised/used by DBIx::Class:</p>
<dl class="Bl-tag">
  <dt id="accessor"><a class="permalink" href="#accessor">accessor</a></dt>
  <dd>
    <pre>
   { accessor =&gt; '_name' }

   # example use, replace standard accessor with one of your own:
   sub name {
       my ($self, $value) = @_;

       die &quot;Name cannot contain digits!&quot; if($value =~ /\d/);
       $self-&gt;_name($value);

       return $self-&gt;_name();
   }
    </pre>
    <p class="Pp">Use this to set the name of the accessor method for this
        column. If unset, the name of the column will be used.</p>
  </dd>
  <dt id="data_type"><a class="permalink" href="#data_type">data_type</a></dt>
  <dd>
    <pre>
   { data_type =&gt; 'integer' }
    </pre>
    <p class="Pp">This contains the column type. It is automatically filled if
        you use the SQL::Translator::Producer::DBIx::Class::File producer, or
        the DBIx::Class::Schema::Loader module.</p>
    <p class="Pp">Currently there is no standard set of values for the
        data_type. Use whatever your database supports.</p>
  </dd>
  <dt id="size"><a class="permalink" href="#size">size</a></dt>
  <dd>
    <pre>
   { size =&gt; 20 }
    </pre>
    <p class="Pp">The length of your column, if it is a column type that can
        have a size restriction. This is currently only used to create tables
        from your schema, see &quot;deploy&quot; in DBIx::Class::Schema.</p>
    <p class="Pp"></p>
    <pre>
   { size =&gt; [ 9, 6 ] }
    </pre>
    <p class="Pp">For decimal or float values you can specify an ArrayRef in
        order to control precision, assuming your database's
        SQL::Translator::Producer supports it.</p>
  </dd>
  <dt id="is_nullable"><a class="permalink" href="#is_nullable">is_nullable</a></dt>
  <dd>
    <pre>
   { is_nullable =&gt; 1 }
    </pre>
    <p class="Pp">Set this to a true value for a column that is allowed to
        contain NULL values, default is false. This is currently only used to
        create tables from your schema, see &quot;deploy&quot; in
        DBIx::Class::Schema.</p>
  </dd>
  <dt id="is_auto_increment"><a class="permalink" href="#is_auto_increment">is_auto_increment</a></dt>
  <dd>
    <pre>
   { is_auto_increment =&gt; 1 }
    </pre>
    <p class="Pp">Set this to a true value for a column whose value is somehow
        automatically set, defaults to false. This is used to determine which
        columns to empty when cloning objects using &quot;copy&quot; in
        DBIx::Class::Row. It is also used by &quot;deploy&quot; in
        DBIx::Class::Schema.</p>
  </dd>
  <dt id="is_numeric"><a class="permalink" href="#is_numeric">is_numeric</a></dt>
  <dd>
    <pre>
   { is_numeric =&gt; 1 }
    </pre>
    <p class="Pp">Set this to a true or false value (not
        <span class="Li">&quot;undef&quot;</span>) to explicitly specify if this
        column contains numeric data. This controls how set_column decides
        whether to consider a column dirty after an update: if
        <span class="Li">&quot;is_numeric&quot;</span> is true a numeric
        comparison <span class="Li">&quot;!=&quot;</span> will take place
        instead of the usual <span class="Li">&quot;eq&quot;</span></p>
    <p class="Pp">If not specified the storage class will attempt to figure this
        out on first access to the column, based on the column
        <span class="Li">&quot;data_type&quot;</span>. The result will be cached
        in this attribute.</p>
  </dd>
  <dt id="is_foreign_key"><a class="permalink" href="#is_foreign_key">is_foreign_key</a></dt>
  <dd>
    <pre>
   { is_foreign_key =&gt; 1 }
    </pre>
    <p class="Pp">Set this to a true value for a column that contains a key from
        a foreign table, defaults to false. This is currently only used to
        create tables from your schema, see &quot;deploy&quot; in
        DBIx::Class::Schema.</p>
  </dd>
  <dt id="default_value"><a class="permalink" href="#default_value">default_value</a></dt>
  <dd>
    <pre>
   { default_value =&gt; \'now()' }
    </pre>
    <p class="Pp">Set this to the default value which will be inserted into a
        column by the database. Can contain either a value or a function (use a
        reference to a scalar e.g. <span class="Li">&quot;\'now()'&quot;</span>
        if you want a function). This is currently only used to create tables
        from your schema, see &quot;deploy&quot; in DBIx::Class::Schema.</p>
    <p class="Pp">See the note on &quot;new&quot; in DBIx::Class::Row for more
        information about possible issues related to db-side default values.</p>
  </dd>
  <dt id="sequence"><a class="permalink" href="#sequence">sequence</a></dt>
  <dd>
    <pre>
   { sequence =&gt; 'my_table_seq' }
    </pre>
    <p class="Pp">Set this on a primary key column to the name of the sequence
        used to generate a new key value. If not specified,
        DBIx::Class::PK::Auto will attempt to retrieve the name of the sequence
        from the database automatically.</p>
  </dd>
  <dt id="retrieve_on_insert"><a class="permalink" href="#retrieve_on_insert">retrieve_on_insert</a></dt>
  <dd>
    <pre>
  { retrieve_on_insert =&gt; 1 }
    </pre>
    <p class="Pp">For every column where this is set to true, DBIC will retrieve
        the RDBMS-side value upon a new row insertion (normally only the
        autoincrement PK is retrieved on insert). <span class="Li">&quot;INSERT
        ... RETURNING&quot;</span> is used automatically if supported by the
        underlying storage, otherwise an extra SELECT statement is executed to
        retrieve the missing data.</p>
  </dd>
  <dt id="auto_nextval"><a class="permalink" href="#auto_nextval">auto_nextval</a></dt>
  <dd>
    <pre>
   { auto_nextval =&gt; 1 }
    </pre>
    <p class="Pp">Set this to a true value for a column whose value is retrieved
        automatically from a sequence or function (if supported by your Storage
        driver.) For a sequence, if you do not use a trigger to get the nextval,
        you have to set the &quot;sequence&quot; value as well.</p>
    <p class="Pp">Also set this for MSSQL columns with the 'uniqueidentifier'
        data_type whose values you want to automatically generate using
        <span class="Li">&quot;NEWID()&quot;</span>, unless they are a primary
        key in which case this will be done anyway.</p>
  </dd>
  <dt id="extra"><a class="permalink" href="#extra">extra</a></dt>
  <dd>This is used by &quot;deploy&quot; in DBIx::Class::Schema and
      SQL::Translator to add extra non-generic data to the column. For example:
      <span class="Li">&quot;extra</span> <span class="Li">=&gt; { unsigned
      =&gt; 1}&quot;</span> is used by the MySQL producer to set an integer
      column to unsigned. For more details, see
      SQL::Translator::Producer::MySQL.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="add_column"><a class="permalink" href="#add_column">add_column</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~2"><a class="permalink" href="#Arguments:~2">Arguments:
    $colname, \%columninfo?</a></dt>
  <dd></dd>
  <dt id="Return~2"><a class="permalink" href="#Return~2">Return Value: 1/0
    (true/false)</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  $source-&gt;add_column('col' =&gt; \%info);
</pre>
<p class="Pp">Add a single column and optional column info. Uses the same column
    info keys as &quot;add_columns&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="has_column"><a class="permalink" href="#has_column">has_column</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~3"><a class="permalink" href="#Arguments:~3">Arguments:
    $colname</a></dt>
  <dd></dd>
  <dt id="Return~3"><a class="permalink" href="#Return~3">Return Value: 1/0
    (true/false)</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  if ($source-&gt;has_column($colname)) { ... }
</pre>
<p class="Pp">Returns true if the source has a column of this name, false
    otherwise.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="column_info"><a class="permalink" href="#column_info">column_info</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~4"><a class="permalink" href="#Arguments:~4">Arguments:
    $colname</a></dt>
  <dd></dd>
  <dt id="Return~4"><a class="permalink" href="#Return~4">Return Value: Hashref
    of info</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  my $info = $source-&gt;column_info($col);
</pre>
<p class="Pp">Returns the column metadata hashref for a column, as originally
    passed to &quot;add_columns&quot;. See &quot;add_columns&quot; above for
    information on the contents of the hashref.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="columns"><a class="permalink" href="#columns">columns</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~5"><a class="permalink" href="#Arguments:~5">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~5"><a class="permalink" href="#Return~5">Return Value: Ordered
    list of column names</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  my @column_names = $source-&gt;columns;
</pre>
<p class="Pp">Returns all column names in the order they were declared to
    &quot;add_columns&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="columns_info"><a class="permalink" href="#columns_info">columns_info</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~6"><a class="permalink" href="#Arguments:~6">Arguments:
    \@colnames ?</a></dt>
  <dd></dd>
  <dt id="Return~6"><a class="permalink" href="#Return~6">Return Value: Hashref
    of column name/info pairs</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  my $columns_info = $source-&gt;columns_info;
</pre>
<p class="Pp">Like &quot;column_info&quot; but returns information for the
    requested columns. If the optional column-list arrayref is omitted it
    returns info on all columns currently defined on the ResultSource via
    &quot;add_columns&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="remove_columns"><a class="permalink" href="#remove_columns">remove_columns</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~7"><a class="permalink" href="#Arguments:~7">Arguments:
    @colnames</a></dt>
  <dd></dd>
  <dt id="Return~7"><a class="permalink" href="#Return~7">Return Value: not
    defined</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  $source-&gt;remove_columns(qw/col1 col2 col3/);
</pre>
<p class="Pp">Removes the given list of columns by name, from the result
  source.</p>
<p class="Pp"><b>Warning</b>: Removing a column that is also used in the sources
    primary key, or in one of the sources unique constraints, <b>will</b> result
    in a broken result source.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="remove_column"><a class="permalink" href="#remove_column">remove_column</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~8"><a class="permalink" href="#Arguments:~8">Arguments:
    $colname</a></dt>
  <dd></dd>
  <dt id="Return~8"><a class="permalink" href="#Return~8">Return Value: not
    defined</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  $source-&gt;remove_column('col');
</pre>
<p class="Pp">Remove a single column by name from the result source, similar to
    &quot;remove_columns&quot;.</p>
<p class="Pp"><b>Warning</b>: Removing a column that is also used in the sources
    primary key, or in one of the sources unique constraints, <b>will</b> result
    in a broken result source.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="set_primary_key"><a class="permalink" href="#set_primary_key">set_primary_key</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~9"><a class="permalink" href="#Arguments:~9">Arguments:
    @cols</a></dt>
  <dd></dd>
  <dt id="Return~9"><a class="permalink" href="#Return~9">Return Value: not
    defined</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Defines one or more columns as primary key for this source. Must
    be called after &quot;add_columns&quot;.</p>
<p class="Pp">Additionally, defines a unique constraint named
    <span class="Li">&quot;primary&quot;</span>.</p>
<p class="Pp">Note: you normally do want to define a primary key on your sources
    <b>even if the underlying database table does not have a primary key</b>.
    See &quot;The Significance and Importance of Primary Keys&quot; in
    DBIx::Class::Manual::Intro for more info.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="primary_columns"><a class="permalink" href="#primary_columns">primary_columns</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~10"><a class="permalink" href="#Arguments:~10">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~10"><a class="permalink" href="#Return~10">Return Value:
    Ordered list of primary column names</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Read-only accessor which returns the list of primary keys,
    supplied by &quot;set_primary_key&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss">sequence</h2>
<p class="Pp">Manually define the correct sequence for your table, to avoid the
    overhead associated with looking up the sequence automatically. The supplied
    sequence will be applied to the &quot;column_info&quot; of each
  primary_key</p>
<dl class="Bl-tag">
  <dt id="Arguments:~11"><a class="permalink" href="#Arguments:~11">Arguments:
    $sequence_name</a></dt>
  <dd></dd>
  <dt id="Return~11"><a class="permalink" href="#Return~11">Return Value: not
    defined</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="add_unique_constraint"><a class="permalink" href="#add_unique_constraint">add_unique_constraint</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~12"><a class="permalink" href="#Arguments:~12">Arguments:
    $name?, \@colnames</a></dt>
  <dd></dd>
  <dt id="Return~12"><a class="permalink" href="#Return~12">Return Value: not
    defined</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Declare a unique constraint on this source. Call once for each
    unique constraint.</p>
<p class="Pp"></p>
<pre>
  # For UNIQUE (column1, column2)
  __PACKAGE__-&gt;add_unique_constraint(
    constraint_name =&gt; [ qw/column1 column2/ ],
  );
</pre>
<p class="Pp">Alternatively, you can specify only the columns:</p>
<p class="Pp"></p>
<pre>
  __PACKAGE__-&gt;add_unique_constraint([ qw/column1 column2/ ]);
</pre>
<p class="Pp">This will result in a unique constraint named
    <span class="Li">&quot;table_column1_column2&quot;</span>, where
    <span class="Li">&quot;table&quot;</span> is replaced with the table
  name.</p>
<p class="Pp">Unique constraints are used, for example, when you pass the
    constraint name as the <span class="Li">&quot;key&quot;</span> attribute to
    &quot;find&quot; in DBIx::Class::ResultSet. Then only columns in the
    constraint are searched.</p>
<p class="Pp">Throws an error if any of the given column names do not yet exist
    on the result source.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="add_unique_constraints"><a class="permalink" href="#add_unique_constraints">add_unique_constraints</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~13"><a class="permalink" href="#Arguments:~13">Arguments:
    @constraints</a></dt>
  <dd></dd>
  <dt id="Return~13"><a class="permalink" href="#Return~13">Return Value: not
    defined</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Declare multiple unique constraints on this source.</p>
<p class="Pp"></p>
<pre>
  __PACKAGE__-&gt;add_unique_constraints(
    constraint_name1 =&gt; [ qw/column1 column2/ ],
    constraint_name2 =&gt; [ qw/column2 column3/ ],
  );
</pre>
<p class="Pp">Alternatively, you can specify only the columns:</p>
<p class="Pp"></p>
<pre>
  __PACKAGE__-&gt;add_unique_constraints(
    [ qw/column1 column2/ ],
    [ qw/column3 column4/ ]
  );
</pre>
<p class="Pp">This will result in unique constraints named
    <span class="Li">&quot;table_column1_column2&quot;</span> and
    <span class="Li">&quot;table_column3_column4&quot;</span>, where
    <span class="Li">&quot;table&quot;</span> is replaced with the table
  name.</p>
<p class="Pp">Throws an error if any of the given column names do not yet exist
    on the result source.</p>
<p class="Pp">See also &quot;add_unique_constraint&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="name_unique_constraint"><a class="permalink" href="#name_unique_constraint">name_unique_constraint</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~14"><a class="permalink" href="#Arguments:~14">Arguments:
    \@colnames</a></dt>
  <dd></dd>
  <dt id="Return~14"><a class="permalink" href="#Return~14">Return Value:
    Constraint name</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  $source-&gt;table('mytable');
  $source-&gt;name_unique_constraint(['col1', 'col2']);
  # returns
  'mytable_col1_col2'
</pre>
<p class="Pp">Return a name for a unique constraint containing the specified
    columns. The name is created by joining the table name and each column name,
    using an underscore character.</p>
<p class="Pp">For example, a constraint on a table named
    <span class="Li">&quot;cd&quot;</span> containing the columns
    <span class="Li">&quot;artist&quot;</span> and
    <span class="Li">&quot;title&quot;</span> would result in a constraint name
    of <span class="Li">&quot;cd_artist_title&quot;</span>.</p>
<p class="Pp">This is used by &quot;add_unique_constraint&quot; if you do not
    specify the optional constraint name.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="unique_constraints"><a class="permalink" href="#unique_constraints">unique_constraints</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~15"><a class="permalink" href="#Arguments:~15">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~15"><a class="permalink" href="#Return~15">Return Value: Hash
    of unique constraint data</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  $source-&gt;unique_constraints();
</pre>
<p class="Pp">Read-only accessor which returns a hash of unique constraints on
    this source.</p>
<p class="Pp">The hash is keyed by constraint name, and contains an arrayref of
    column names as values.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="unique_constraint_names"><a class="permalink" href="#unique_constraint_names">unique_constraint_names</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~16"><a class="permalink" href="#Arguments:~16">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~16"><a class="permalink" href="#Return~16">Return Value: Unique
    constraint names</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  $source-&gt;unique_constraint_names();
</pre>
<p class="Pp">Returns the list of unique constraint names defined on this
    source.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="unique_constraint_columns"><a class="permalink" href="#unique_constraint_columns">unique_constraint_columns</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~17"><a class="permalink" href="#Arguments:~17">Arguments:
    $constraintname</a></dt>
  <dd></dd>
  <dt id="Return~17"><a class="permalink" href="#Return~17">Return Value: List
    of constraint columns</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  $source-&gt;unique_constraint_columns('myconstraint');
</pre>
<p class="Pp">Returns the list of columns that make up the specified unique
    constraint.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="sqlt_deploy_callback"><a class="permalink" href="#sqlt_deploy_callback">sqlt_deploy_callback</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~18"><a class="permalink" href="#Arguments:~18">Arguments:
    $callback_name | \&amp;callback_code</a></dt>
  <dd></dd>
  <dt id="Return~18"><a class="permalink" href="#Return~18">Return Value:
    $callback_name | \&amp;callback_code</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  __PACKAGE__-&gt;sqlt_deploy_callback('mycallbackmethod');

   or

  __PACKAGE__-&gt;sqlt_deploy_callback(sub {
    my ($source_instance, $sqlt_table) = @_;
    ...
  } );
</pre>
<p class="Pp">An accessor to set a callback to be called during deployment of
    the schema via &quot;create_ddl_dir&quot; in DBIx::Class::Schema or
    &quot;deploy&quot; in DBIx::Class::Schema.</p>
<p class="Pp">The callback can be set as either a code reference or the name of
    a method in the current result class.</p>
<p class="Pp">Defaults to &quot;default_sqlt_deploy_hook&quot;.</p>
<p class="Pp">Your callback will be passed the <span class="Li">$source</span>
    object representing the ResultSource instance being deployed, and the
    SQL::Translator::Schema::Table object being created from it. The callback
    can be used to manipulate the table object or add your own customised
    indexes. If you need to manipulate a non-table object, use the
    &quot;sqlt_deploy_hook&quot; in DBIx::Class::Schema.</p>
<p class="Pp">See &quot;Adding Indexes And Functions To Your SQL&quot; in
    DBIx::Class::Manual::Cookbook for examples.</p>
<p class="Pp">This sqlt deployment callback can only be used to manipulate
    SQL::Translator objects as they get turned into SQL. To execute post-deploy
    statements which SQL::Translator does not currently handle, override
    &quot;deploy&quot; in DBIx::Class::Schema in your Schema class and call
    dbh_do.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="default_sqlt_deploy_hook"><a class="permalink" href="#default_sqlt_deploy_hook">default_sqlt_deploy_hook</a></h2>
<p class="Pp">This is the default deploy hook implementation which checks if
    your current Result class has a
    <span class="Li">&quot;sqlt_deploy_hook&quot;</span> method, and if present
    invokes it <b>on the Result class directly</b>. This is to preserve the
    semantics of <span class="Li">&quot;sqlt_deploy_hook&quot;</span> which was
    originally designed to expect the Result class name and the
    <span class="Li">$sqlt_table</span> instance of the table being
  deployed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="result_class"><a class="permalink" href="#result_class">result_class</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~19"><a class="permalink" href="#Arguments:~19">Arguments:
    $classname</a></dt>
  <dd></dd>
  <dt id="Return~19"><a class="permalink" href="#Return~19">Return Value:
    $classname</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
 use My::Schema::ResultClass::Inflator;
 ...

 use My::Schema::Artist;
 ...
 __PACKAGE__-&gt;result_class('My::Schema::ResultClass::Inflator');
</pre>
<p class="Pp">Set the default result class for this source. You can use this to
    create and use your own result inflator. See &quot;result_class&quot; in
    DBIx::Class::ResultSet for more details.</p>
<p class="Pp">Please note that setting this to something like
    DBIx::Class::ResultClass::HashRefInflator will make every result unblessed
    and make life more difficult. Inflators like those are better suited to
    temporary usage via &quot;result_class&quot; in DBIx::Class::ResultSet.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="resultset"><a class="permalink" href="#resultset">resultset</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~20"><a class="permalink" href="#Arguments:~20">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~20"><a class="permalink" href="#Return~20">Return Value:
    $resultset</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Returns a resultset for the given source. This will initially be
    created on demand by calling</p>
<p class="Pp"></p>
<pre>
  $self-&gt;resultset_class-&gt;new($self, $self-&gt;resultset_attributes)
</pre>
<p class="Pp">but is cached from then on unless resultset_class changes.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="resultset_class"><a class="permalink" href="#resultset_class">resultset_class</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~21"><a class="permalink" href="#Arguments:~21">Arguments:
    $classname</a></dt>
  <dd></dd>
  <dt id="Return~21"><a class="permalink" href="#Return~21">Return Value:
    $classname</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  package My::Schema::ResultSet::Artist;
  use base 'DBIx::Class::ResultSet';
  ...

  # In the result class
  __PACKAGE__-&gt;resultset_class('My::Schema::ResultSet::Artist');

  # Or in code
  $source-&gt;resultset_class('My::Schema::ResultSet::Artist');
</pre>
<p class="Pp">Set the class of the resultset. This is useful if you want to
    create your own resultset methods. Create your own class derived from
    DBIx::Class::ResultSet, and set it here. If called with no arguments, this
    method returns the name of the existing resultset class, if one exists.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="resultset_attributes"><a class="permalink" href="#resultset_attributes">resultset_attributes</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~22"><a class="permalink" href="#Arguments:~22">Arguments:
    \%attrs</a></dt>
  <dd></dd>
  <dt id="Return~22"><a class="permalink" href="#Return~22">Return Value:
    \%attrs</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  # In the result class
  __PACKAGE__-&gt;resultset_attributes({ order_by =&gt; [ 'id' ] });

  # Or in code
  $source-&gt;resultset_attributes({ order_by =&gt; [ 'id' ] });
</pre>
<p class="Pp">Store a collection of resultset attributes, that will be set on
    every DBIx::Class::ResultSet produced from this result source.</p>
<p class="Pp"><b>CAVEAT</b>:
    <span class="Li">&quot;resultset_attributes&quot;</span> comes with its own
    set of issues and bugs! While
    <span class="Li">&quot;resultset_attributes&quot;</span> isn't deprecated
    per se, its usage is not recommended!</p>
<p class="Pp">Since relationships use attributes to link tables together, the
    &quot;default&quot; attributes you set may cause unpredictable and undesired
    behavior. Furthermore, the defaults cannot be turned off, so you are stuck
    with them.</p>
<p class="Pp">In most cases, what you should actually be using are
    project-specific methods:</p>
<p class="Pp"></p>
<pre>
  package My::Schema::ResultSet::Artist;
  use base 'DBIx::Class::ResultSet';
  ...

  # BAD IDEA!
  #__PACKAGE__-&gt;resultset_attributes({ prefetch =&gt; 'tracks' });

  # GOOD IDEA!
  sub with_tracks { shift-&gt;search({}, { prefetch =&gt; 'tracks' }) }

  # in your code
  $schema-&gt;resultset('Artist')-&gt;with_tracks-&gt;...
</pre>
<p class="Pp">This gives you the flexibility of not using it when you don't need
    it.</p>
<p class="Pp">For more complex situations, another solution would be to use a
    virtual view via DBIx::Class::ResultSource::View.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="name"><a class="permalink" href="#name">name</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~23"><a class="permalink" href="#Arguments:~23">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Result"><a class="permalink" href="#Result">Result value:
    $name</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Returns the name of the result source, which will typically be the
    table name. This may be a scalar reference if the result source has a
    non-standard name.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="source_name"><a class="permalink" href="#source_name">source_name</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~24"><a class="permalink" href="#Arguments:~24">Arguments:
    $source_name</a></dt>
  <dd></dd>
  <dt id="Result~2"><a class="permalink" href="#Result~2">Result value:
    $source_name</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Set an alternate name for the result source when it is loaded into
    a schema. This is useful if you want to refer to a result source by a name
    other than its class name.</p>
<p class="Pp"></p>
<pre>
  package ArchivedBooks;
  use base qw/DBIx::Class/;
  __PACKAGE__-&gt;table('books_archive');
  __PACKAGE__-&gt;source_name('Books');

  # from your schema...
  $schema-&gt;resultset('Books')-&gt;find(1);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="from"><a class="permalink" href="#from">from</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~25"><a class="permalink" href="#Arguments:~25">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~23"><a class="permalink" href="#Return~23">Return Value: FROM
    clause</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  my $from_clause = $source-&gt;from();
</pre>
<p class="Pp">Returns an expression of the source to be supplied to storage to
    specify retrieval from this source. In the case of a database, the required
    FROM clause contents.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="source_info"><a class="permalink" href="#source_info">source_info</a></h2>
<p class="Pp">Stores a hashref of per-source metadata. No specific key names
    have yet been standardized, the examples below are purely hypothetical and
    don't actually accomplish anything on their own:</p>
<p class="Pp"></p>
<pre>
  __PACKAGE__-&gt;source_info({
    &quot;_tablespace&quot; =&gt; 'fast_disk_array_3',
    &quot;_engine&quot; =&gt; 'InnoDB',
  });
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="schema"><a class="permalink" href="#schema">schema</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~26"><a class="permalink" href="#Arguments:~26">Arguments:
    $schema?</a></dt>
  <dd></dd>
  <dt id="Return~24"><a class="permalink" href="#Return~24">Return Value:
    $schema</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  my $schema = $source-&gt;schema();
</pre>
<p class="Pp">Sets and/or returns the DBIx::Class::Schema object to which this
    result source instance has been attached to.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="storage"><a class="permalink" href="#storage">storage</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~27"><a class="permalink" href="#Arguments:~27">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~25"><a class="permalink" href="#Return~25">Return Value:
    $storage</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  $source-&gt;storage-&gt;debug(1);
</pre>
<p class="Pp">Returns the storage handle for the current schema.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="add_relationship"><a class="permalink" href="#add_relationship">add_relationship</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~28"><a class="permalink" href="#Arguments:~28">Arguments:
    $rel_name, $related_source_name, \%cond, \%attrs?</a></dt>
  <dd></dd>
  <dt id="Return~26"><a class="permalink" href="#Return~26">Return Value: 1/true
    if it succeeded</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  $source-&gt;add_relationship('rel_name', 'related_source', $cond, $attrs);
</pre>
<p class="Pp">DBIx::Class::Relationship describes a series of methods which
    create pre-defined useful types of relationships. Look there first before
    using this method directly.</p>
<p class="Pp">The relationship name can be arbitrary, but must be unique for
    each relationship attached to this result source. 'related_source' should be
    the name with which the related result source was registered with the
    current schema. For example:</p>
<p class="Pp"></p>
<pre>
  $schema-&gt;source('Book')-&gt;add_relationship('reviews', 'Review', {
    'foreign.book_id' =&gt; 'self.id',
  });
</pre>
<p class="Pp">The condition <span class="Li">$cond</span> needs to be an
    SQL::Abstract-style representation of the join between the tables. For
    example, if you're creating a relation from Author to Book,</p>
<p class="Pp"></p>
<pre>
  { 'foreign.author_id' =&gt; 'self.id' }
</pre>
<p class="Pp">will result in the JOIN clause</p>
<p class="Pp"></p>
<pre>
  author me JOIN book foreign ON foreign.author_id = me.id
</pre>
<p class="Pp">You can specify as many foreign =&gt; self mappings as
  necessary.</p>
<p class="Pp">Valid attributes are as follows:</p>
<dl class="Bl-tag">
  <dt id="join_type"><a class="permalink" href="#join_type">join_type</a></dt>
  <dd>Explicitly specifies the type of join to use in the relationship. Any SQL
      join type is valid, e.g. <span class="Li">&quot;LEFT&quot;</span> or
      <span class="Li">&quot;RIGHT&quot;</span>. It will be placed in the SQL
      command immediately before <span class="Li">&quot;JOIN&quot;</span>.</dd>
  <dt id="proxy"><a class="permalink" href="#proxy">proxy</a></dt>
  <dd>An arrayref containing a list of accessors in the foreign class to proxy
      in the main class. If, for example, you do the following:
    <p class="Pp"></p>
    <pre>
  CD-&gt;might_have(liner_notes =&gt; 'LinerNotes', undef, {
    proxy =&gt; [ qw/notes/ ],
  });
    </pre>
    <p class="Pp">Then, assuming LinerNotes has an accessor named notes, you can
        do:</p>
    <p class="Pp"></p>
    <pre>
  my $cd = CD-&gt;find(1);
  # set notes -- LinerNotes object is created if it doesn't exist
  $cd-&gt;notes('Notes go here');
    </pre>
  </dd>
  <dt id="accessor~2"><a class="permalink" href="#accessor~2">accessor</a></dt>
  <dd>Specifies the type of accessor that should be created for the
      relationship. Valid values are <span class="Li">&quot;single&quot;</span>
      (for when there is only a single related object),
      <span class="Li">&quot;multi&quot;</span> (when there can be many), and
      <span class="Li">&quot;filter&quot;</span> (for when there is a single
      related object, but you also want the relationship accessor to double as a
      column accessor). For <span class="Li">&quot;multi&quot;</span> accessors,
      an add_to_* method is also created, which calls
      <span class="Li">&quot;create_related&quot;</span> for the
    relationship.</dd>
</dl>
<p class="Pp">Throws an exception if the condition is improperly supplied, or
    cannot be resolved.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="relationships"><a class="permalink" href="#relationships">relationships</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~29"><a class="permalink" href="#Arguments:~29">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~27"><a class="permalink" href="#Return~27">Return Value:
    @rel_names</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  my @rel_names = $source-&gt;relationships();
</pre>
<p class="Pp">Returns all relationship names for this source.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="relationship_info"><a class="permalink" href="#relationship_info">relationship_info</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~30"><a class="permalink" href="#Arguments:~30">Arguments:
    $rel_name</a></dt>
  <dd></dd>
  <dt id="Return~28"><a class="permalink" href="#Return~28">Return Value:
    \%rel_data</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Returns a hash of relationship information for the specified
    relationship name. The keys/values are as specified for
    &quot;add_relationship&quot; in DBIx::Class::Relationship::Base.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="has_relationship"><a class="permalink" href="#has_relationship">has_relationship</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~31"><a class="permalink" href="#Arguments:~31">Arguments:
    $rel_name</a></dt>
  <dd></dd>
  <dt id="Return~29"><a class="permalink" href="#Return~29">Return Value: 1/0
    (true/false)</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Returns true if the source has a relationship of this name, false
    otherwise.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="reverse_relationship_info"><a class="permalink" href="#reverse_relationship_info">reverse_relationship_info</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~32"><a class="permalink" href="#Arguments:~32">Arguments:
    $rel_name</a></dt>
  <dd></dd>
  <dt id="Return~30"><a class="permalink" href="#Return~30">Return Value:
    \%rel_data</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Looks through all the relationships on the source this
    relationship points to, looking for one whose condition is the reverse of
    the condition on this relationship.</p>
<p class="Pp">A common use of this is to find the name of the
    <span class="Li">&quot;belongs_to&quot;</span> relation opposing a
    <span class="Li">&quot;has_many&quot;</span> relation. For definition of
    these look in DBIx::Class::Relationship.</p>
<p class="Pp">The returned hashref is keyed by the name of the opposing
    relationship, and contains its data in the same manner as
    &quot;relationship_info&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="related_source"><a class="permalink" href="#related_source">related_source</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~33"><a class="permalink" href="#Arguments:~33">Arguments:
    $rel_name</a></dt>
  <dd></dd>
  <dt id="Return~31"><a class="permalink" href="#Return~31">Return Value:
    $source</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Returns the result source object for the given relationship.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="related_class"><a class="permalink" href="#related_class">related_class</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~34"><a class="permalink" href="#Arguments:~34">Arguments:
    $rel_name</a></dt>
  <dd></dd>
  <dt id="Return~32"><a class="permalink" href="#Return~32">Return Value:
    $classname</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Returns the class name for objects in the given relationship.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="handle"><a class="permalink" href="#handle">handle</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~35"><a class="permalink" href="#Arguments:~35">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~33"><a class="permalink" href="#Return~33">Return Value:
    $source_handle</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Obtain a new result source handle instance for this source. Used
    as a serializable pointer to this resultsource, as it is not easy (nor
    advisable) to serialize CODErefs which may very well be present in e.g.
    relationship definitions.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="throw_exception"><a class="permalink" href="#throw_exception">throw_exception</a></h2>
<p class="Pp">See &quot;throw_exception&quot; in DBIx::Class::Schema.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="column_info_from_storage"><a class="permalink" href="#column_info_from_storage">column_info_from_storage</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~36"><a class="permalink" href="#Arguments:~36">Arguments:
    1/0 (default: 0)</a></dt>
  <dd></dd>
  <dt id="Return~34"><a class="permalink" href="#Return~34">Return Value:
    1/0</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  __PACKAGE__-&gt;column_info_from_storage(1);
</pre>
<p class="Pp">Enables the on-demand automatic loading of the above column
    metadata from storage as necessary. This is *deprecated*, and should not be
    used. It will be removed before 1.0.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="FURTHER_QUESTIONS?"><a class="permalink" href="#FURTHER_QUESTIONS?">FURTHER
  QUESTIONS?</a></h1>
<p class="Pp">Check the list of additional DBIC resources.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This module is free software copyright by the DBIx::Class (DBIC)
    authors. You can redistribute it and/or modify it under the same terms as
    the DBIx::Class library.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-01-29</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

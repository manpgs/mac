<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>mro(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">mro(3pm)</td>
    <td class="head-vol"><a href=".">Perl Programmers Reference Guide</a></td>
    <td class="head-rtitle">mro(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">mro - Method Resolution Order</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  use mro; # enables next::method and friends globally
  use mro 'dfs'; # enable DFS MRO for this class (Perl default)
  use mro 'c3'; # enable C3 MRO for this class
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The &quot;mro&quot; namespace provides several utilities for
    dealing with method resolution order and method caching in general.</p>
<p class="Pp">These interfaces are only available in Perl 5.9.5 and higher. See
    MRO::Compat on CPAN for a mostly forwards compatible implementation for
    older Perls.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OVERVIEW"><a class="permalink" href="#OVERVIEW">OVERVIEW</a></h1>
<p class="Pp">It's possible to change the MRO of a given class either by using
    <span class="Li">&quot;use</span> <span class="Li">mro&quot;</span> as shown
    in the synopsis, or by using the &quot;mro::set_mro&quot; function
  below.</p>
<p class="Pp">The special methods
    <span class="Li">&quot;next::method&quot;</span>,
    <span class="Li">&quot;next::can&quot;</span>, and
    <span class="Li">&quot;maybe::next::method&quot;</span> are not available
    until this <span class="Li">&quot;mro&quot;</span> module has been loaded
    via <span class="Li">&quot;use&quot;</span> or
    <span class="Li">&quot;require&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="The_C3_MRO"><a class="permalink" href="#The_C3_MRO">The C3
  MRO</a></h1>
<p class="Pp">In addition to the traditional Perl default MRO (depth first
    search, called <span class="Li">&quot;DFS&quot;</span> here), Perl now
    offers the C3 MRO as well. Perl's support for C3 is based on the work done
    in Stevan Little's module Class::C3, and most of the C3-related
    documentation here is ripped directly from there.</p>
<section class="Ss">
<h2 class="Ss" id="What_is_C3?"><a class="permalink" href="#What_is_C3?">What is
  C3?</a></h2>
<p class="Pp">C3 is the name of an algorithm which aims to provide a sane method
    resolution order under multiple inheritance. It was first introduced in the
    language Dylan (see links in the &quot;SEE ALSO&quot; section), and then
    later adopted as the preferred MRO (Method Resolution Order) for the
    new-style classes in Python 2.3. Most recently it has been adopted as the
    &quot;canonical&quot; MRO for Raku classes.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_does_C3_work"><a class="permalink" href="#How_does_C3_work">How
  does C3 work</a></h2>
<p class="Pp">C3 works by always preserving local precedence ordering. This
    essentially means that no class will appear before any of its subclasses.
    Take, for instance, the classic diamond inheritance pattern:</p>
<p class="Pp"></p>
<pre>     &lt;A&gt;
    /   \
  &lt;B&gt;   &lt;C&gt;
    \   /
     &lt;D&gt;
</pre>
<p class="Pp">The standard Perl 5 MRO would be (D, B, A, C). The result being
    that <b>A</b> appears before <b>C</b>, even though <b>C</b> is the subclass
    of <b>A</b>. The C3 MRO algorithm however, produces the following order: (D,
    B, C, A), which does not have this issue.</p>
<p class="Pp">This example is fairly trivial; for more complex cases and a
    deeper explanation, see the links in the &quot;SEE ALSO&quot; section.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Functions"><a class="permalink" href="#Functions">Functions</a></h1>
<section class="Ss">
<h2 class="Ss" id="mro::get_linear_isa($classname_,_$type_)"><a class="permalink" href="#mro::get_linear_isa($classname_,_$type_)">mro::get_linear_isa($classname[,
  $type])</a></h2>
<p class="Pp">Returns an arrayref which is the linearized MRO of the given
    class. Uses whichever MRO is currently in effect for that class by default,
    or the given MRO (either <span class="Li">&quot;c3&quot;</span> or
    <span class="Li">&quot;dfs&quot;</span> if specified as
    <span class="Li">$type</span>).</p>
<p class="Pp">The linearized MRO of a class is an ordered array of all of the
    classes one would search when resolving a method on that class, starting
    with the class itself.</p>
<p class="Pp">If the requested class doesn't yet exist, this function will still
    succeed, and return <span class="Li">&quot;[ $classname ]&quot;</span></p>
<p class="Pp">Note that <span class="Li">&quot;UNIVERSAL&quot;</span> (and any
    members of <span class="Li">&quot;UNIVERSAL&quot;</span>'s MRO) are not part
    of the MRO of a class, even though all classes implicitly inherit methods
    from <span class="Li">&quot;UNIVERSAL&quot;</span> and its parents.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="mro::set_mro_($classname,_$type)"><a class="permalink" href="#mro::set_mro_($classname,_$type)">mro::set_mro
  ($classname, $type)</a></h2>
<p class="Pp">Sets the MRO of the given class to the
    <span class="Li">$type</span> argument (either
    <span class="Li">&quot;c3&quot;</span> or
    <span class="Li">&quot;dfs&quot;</span>).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="mro::get_mro($classname)"><a class="permalink" href="#mro::get_mro($classname)">mro::get_mro($classname)</a></h2>
<p class="Pp">Returns the MRO of the given class (either
    <span class="Li">&quot;c3&quot;</span> or
    <span class="Li">&quot;dfs&quot;</span>).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="mro::get_isarev($classname)"><a class="permalink" href="#mro::get_isarev($classname)">mro::get_isarev($classname)</a></h2>
<p class="Pp">Gets the <span class="Li">&quot;mro_isarev&quot;</span> for this
    class, returned as an arrayref of class names. These are every class that
    &quot;isa&quot; the given class name, even if the isa relationship is
    indirect. This is used internally by the MRO code to keep track of
    method/MRO cache invalidations.</p>
<p class="Pp">As with <span class="Li">&quot;mro::get_linear_isa&quot;</span>
    above, <span class="Li">&quot;UNIVERSAL&quot;</span> is special.
    <span class="Li">&quot;UNIVERSAL&quot;</span> (and parents') isarev lists do
    not include every class in existence, even though all classes are
    effectively descendants for method inheritance purposes.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="mro::is_universal($classname)"><a class="permalink" href="#mro::is_universal($classname)">mro::is_universal($classname)</a></h2>
<p class="Pp">Returns a boolean status indicating whether or not the given
    classname is either <span class="Li">&quot;UNIVERSAL&quot;</span> itself, or
    one of <span class="Li">&quot;UNIVERSAL&quot;</span>'s parents by
    <span class="Li">@ISA</span> inheritance.</p>
<p class="Pp">Any class for which this function returns true is
    &quot;universal&quot; in the sense that all classes potentially inherit
    methods from it.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>mro::invalidate_all_method_caches()</b></h2>
<p class="Pp">Increments <span class="Li">&quot;PL_sub_generation&quot;</span>,
    which invalidates method caching in all packages.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="mro::method_changed_in($classname)"><a class="permalink" href="#mro::method_changed_in($classname)">mro::method_changed_in($classname)</a></h2>
<p class="Pp">Invalidates the method cache of any classes dependent on the given
    class. This is not normally necessary. The only known case where pure perl
    code can confuse the method cache is when you manually install a new
    constant subroutine by using a readonly scalar value, like the internals of
    constant do. If you find another case, please report it so we can either fix
    it or document the exception here.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="mro::get_pkg_gen($classname)"><a class="permalink" href="#mro::get_pkg_gen($classname)">mro::get_pkg_gen($classname)</a></h2>
<p class="Pp">Returns an integer which is incremented every time a real local
    method in the package <span class="Li">$classname</span> changes, or the
    local <span class="Li">@ISA</span> of <span class="Li">$classname</span> is
    modified.</p>
<p class="Pp">This is intended for authors of modules which do lots of class
    introspection, as it allows them to very quickly check if anything important
    about the local properties of a given class have changed since the last time
    they looked. It does not increment on method/<span class="Li">@ISA</span>
    changes in superclasses.</p>
<p class="Pp">It's still up to you to seek out the actual changes, and there
    might not actually be any. Perhaps all of the changes since you last checked
    cancelled each other out and left the package in the state it was in
  before.</p>
<p class="Pp">This integer normally starts off at a value of
    <span class="Li">1</span> when a package stash is instantiated. Calling it
    on packages whose stashes do not exist at all will return
    <span class="Li">0</span>. If a package stash is completely deleted (not a
    normal occurrence, but it can happen if someone does something like
    <span class="Li">&quot;undef %PkgName::&quot;</span>), the number will be
    reset to either <span class="Li">0</span> or <span class="Li">1</span>,
    depending on how completely the package was wiped out.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="next::method"><a class="permalink" href="#next::method">next::method</a></h2>
<p class="Pp">This is somewhat like <span class="Li">&quot;SUPER&quot;</span>,
    but it uses the C3 method resolution order to get better consistency in
    multiple inheritance situations. Note that while inheritance in general
    follows whichever MRO is in effect for the given class,
    <span class="Li">&quot;next::method&quot;</span> only uses the C3 MRO.</p>
<p class="Pp">One generally uses it like so:</p>
<p class="Pp"></p>
<pre>  sub some_method {
    my $self = shift;
    my $superclass_answer = $self-&gt;next::method(@_);
    return $superclass_answer + 1;
  }
</pre>
<p class="Pp">Note that you don't (re-)specify the method name. It forces you to
    always use the same method name as the method you started in.</p>
<p class="Pp">It can be called on an object or a class, of course.</p>
<p class="Pp">The way it resolves which actual method to call is:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>First, it determines the linearized C3 MRO of the object or class it is
      being called on.</dd>
  <dt>2.</dt>
  <dd>Then, it determines the class and method name of the context it was
      invoked from.</dd>
  <dt>3.</dt>
  <dd>Finally, it searches down the C3 MRO list until it reaches the
      contextually enclosing class, then searches further down the MRO list for
      the next method with the same name as the contextually enclosing
    method.</dd>
</dl>
<p class="Pp">Failure to find a next method will result in an exception being
    thrown (see below for alternatives).</p>
<p class="Pp">This is substantially different than the behavior of
    <span class="Li">&quot;SUPER&quot;</span> under complex multiple
    inheritance. (This becomes obvious when one realizes that the common
    superclasses in the C3 linearizations of a given class and one of its
    parents will not always be ordered the same for both.)</p>
<p class="Pp"><b>Caveat</b>: Calling
    <span class="Li">&quot;next::method&quot;</span> from methods defined
    outside the class:</p>
<p class="Pp">There is an edge case when using
    <span class="Li">&quot;next::method&quot;</span> from within a subroutine
    which was created in a different module than the one it is called from. It
    sounds complicated, but it really isn't. Here is an example which will not
    work correctly:</p>
<p class="Pp"></p>
<pre>  *Foo::foo = sub { (shift)-&gt;next::method(@_) };
</pre>
<p class="Pp">The problem exists because the anonymous subroutine being assigned
    to the <span class="Li">*Foo::foo</span> glob will show up in the call stack
    as being called <span class="Li">&quot;__ANON__&quot;</span> and not
    <span class="Li">&quot;foo&quot;</span> as you might expect. Since
    <span class="Li">&quot;next::method&quot;</span> uses
    <span class="Li">&quot;caller&quot;</span> to find the name of the method it
    was called in, it will fail in this case.</p>
<p class="Pp">But fear not, there's a simple solution. The module
    <span class="Li">&quot;Sub::Name&quot;</span> will reach into the perl
    internals and assign a name to an anonymous subroutine for you. Simply do
    this:</p>
<p class="Pp"></p>
<pre>  use Sub::Name 'subname';
  *Foo::foo = subname 'Foo::foo' =&gt; sub { (shift)-&gt;next::method(@_) };
</pre>
<p class="Pp">and things will Just Work.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="next::can"><a class="permalink" href="#next::can">next::can</a></h2>
<p class="Pp">This is similar to
    <span class="Li">&quot;next::method&quot;</span>, but just returns either a
    code reference or <span class="Li">&quot;undef&quot;</span> to indicate that
    no further methods of this name exist.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="maybe::next::method"><a class="permalink" href="#maybe::next::method">maybe::next::method</a></h2>
<p class="Pp">In simple cases, it is equivalent to:</p>
<p class="Pp"></p>
<pre>   $self-&gt;next::method(@_) if $self-&gt;next::can;
</pre>
<p class="Pp">But there are some cases where only this solution works (like
    <span class="Li">&quot;goto &amp;maybe::next::method&quot;</span>);</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<section class="Ss">
<h2 class="Ss" id="The_original_Dylan_paper"><a class="permalink" href="#The_original_Dylan_paper">The
  original Dylan paper</a></h2>
<dl class="Bl-tag">
  <dt>&lt;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.19.3910&amp;rep=rep1&amp;type=pdf&gt;</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Python_2.3_"><a class="permalink" href="#Python_2.3_">Python
  2.3 MRO</a></h2>
<dl class="Bl-tag">
  <dt>&lt;https://www.python.org/download/releases/2.3/mro/&gt;</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Class::C3"><a class="permalink" href="#Class::C3">Class::C3</a></h2>
<dl class="Bl-tag">
  <dt id="Class::C3~2"><a class="permalink" href="#Class::C3~2">Class::C3</a></dt>
  <dd></dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Brandon L. Black, &lt;blblack@gmail.com&gt;</p>
<p class="Pp">Based on Stevan Little's Class::C3</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os"><a href="..">perl v5.34.1</a></td>
  </tr>
</table>
</body>
</html>

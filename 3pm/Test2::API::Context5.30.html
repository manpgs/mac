<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Test2::API::Context(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Test2::API::Context(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Test2::API::Context(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Test2::API::Context - Object to represent a testing context.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The context object is the primary interface for authors of testing
    tools written with Test2. The context object represents the context in which
    a test takes place (File and Line Number), and provides a quick way to
    generate events from that context. The context object also takes care of
    sending events to the correct Test2::Hub instance.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">In general you will not be creating contexts directly. To obtain a
    context you should always use <span class="Li">&quot;context()&quot;</span>
    which is exported by the Test2::API module.</p>
<p class="Pp"></p>
<pre>
    use Test2::API qw/context/;

    sub my_ok {
        my ($bool, $name) = @_;
        my $ctx = context();

        if ($bool) {
            $ctx-&gt;pass($name);
        }
        else {
            $ctx-&gt;fail($name);
        }

        $ctx-&gt;release; # You MUST do this!
        return $bool;
    }
</pre>
<p class="Pp">Context objects make it easy to wrap other tools that also use
    context. Once you grab a context, any tool you call before releasing your
    context will inherit it:</p>
<p class="Pp"></p>
<pre>
    sub wrapper {
        my ($bool, $name) = @_;
        my $ctx = context();
        $ctx-&gt;diag(&quot;wrapping my_ok&quot;);

        my $out = my_ok($bool, $name);
        $ctx-&gt;release; # You MUST do this!
        return $out;
    }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="CRITICAL_DETAILS"><a class="permalink" href="#CRITICAL_DETAILS">CRITICAL
  DETAILS</a></h1>
<dl class="Bl-tag">
  <dt id="you"><a class="permalink" href="#you">you MUST always use the
    <b>context()</b> sub from Test2::API</a></dt>
  <dd>Creating your own context via
      <span class="Li">&quot;Test2::API::Context-&gt;new()&quot;</span> will
      almost never produce a desirable result. Use
      <span class="Li">&quot;context()&quot;</span> which is exported by
      Test2::API.
    <p class="Pp">There are a handful of cases where a tool author may want to
        create a new context by hand, which is why the
        <span class="Li">&quot;new&quot;</span> method exists. Unless you really
        know what you are doing you should avoid this.</p>
  </dd>
  <dt id="You"><a class="permalink" href="#You">You MUST always release the
    context when done with it</a></dt>
  <dd>Releasing the context tells the system you are done with it. This gives it
      a chance to run any necessary callbacks or cleanup tasks. If you forget to
      release the context it will try to detect the problem and warn you about
      it.</dd>
  <dt id="You~2"><a class="permalink" href="#You~2">You MUST NOT pass context
    objects around</a></dt>
  <dd>When you obtain a context object it is made specifically for your tool and
      any tools nested within. If you pass a context around you run the risk of
      polluting other tools with incorrect context information.
    <p class="Pp">If you are certain that you want a different tool to use the
        same context you may pass it a snapshot.
        <span class="Li">&quot;$ctx-&gt;snapshot&quot;</span> will give you a
        shallow clone of the context that is safe to pass around or store.</p>
  </dd>
  <dt id="You~3"><a class="permalink" href="#You~3">You MUST NOT store or cache
    a context for later</a></dt>
  <dd>As long as a context exists for a given hub, all tools that try to get a
      context will get the existing instance. If you try to store the context
      you will pollute other tools with incorrect context information.
    <p class="Pp">If you are certain that you want to save the context for
        later, you can use a snapshot.
        <span class="Li">&quot;$ctx-&gt;snapshot&quot;</span> will give you a
        shallow clone of the context that is safe to pass around or store.</p>
    <p class="Pp"><span class="Li">&quot;context()&quot;</span> has some
        mechanisms to protect you if you do cause a context to persist beyond
        the scope in which it was obtained. In practice you should not rely on
        these protections, and they are fairly noisy with warnings.</p>
  </dd>
  <dt id="You~4"><a class="permalink" href="#You~4">You SHOULD obtain your
    context as soon as possible in a given tool</a></dt>
  <dd>You never know what tools you call from within your own tool will need a
      context. Obtaining the context early ensures that nested tools can find
      the context you want them to find.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<dl class="Bl-tag">
  <dt>$ctx-&gt;done_testing;</dt>
  <dd>Note that testing is finished. If no plan has been set this will generate
      a Plan event.</dd>
  <dt>$clone = $ctx-&gt;<b>snapshot()</b></dt>
  <dd>This will return a shallow clone of the context. The shallow clone is safe
      to store for later.</dd>
  <dt>$ctx-&gt;<b>release()</b></dt>
  <dd>This will release the context. This runs cleanup tasks, and several
      important hooks. It will also restore <span class="Li">$!</span>,
      <span class="Li">$?</span>, and <span class="Li">$@</span> to what they
      were when the context was created.
    <p class="Pp"><b>Note:</b> If a context is acquired more than once an
        internal refcount is kept. <span class="Li">&quot;release()&quot;</span>
        decrements the ref count, none of the other actions of
        <span class="Li">&quot;release()&quot;</span> will occur unless the
        refcount hits 0. This means only the last call to
        <span class="Li">&quot;release()&quot;</span> will reset
        <span class="Li">$?</span>, <span class="Li">$!</span>,
        <span class="Li">$@</span>,and run the cleanup tasks.</p>
  </dd>
  <dt>$ctx-&gt;throw($message)</dt>
  <dd>This will throw an exception reporting to the file and line number of the
      context. This will also release the context for you.</dd>
  <dt>$ctx-&gt;alert($message)</dt>
  <dd>This will issue a warning from the file and line number of the
    context.</dd>
  <dt>$stack = $ctx-&gt;<b>stack()</b></dt>
  <dd>This will return the Test2::API::Stack instance the context used to find
      the current hub.</dd>
  <dt>$hub = $ctx-&gt;<b>hub()</b></dt>
  <dd>This will return the Test2::Hub instance the context recognizes as the
      current one to which all events should be sent.</dd>
  <dt>$dbg = $ctx-&gt;<b>trace()</b></dt>
  <dd>This will return the Test2::EventFacet::Trace instance used by the
      context.</dd>
  <dt>$ctx-&gt;do_in_context(\&amp;code, @args);</dt>
  <dd>Sometimes you have a context that is not current, and you want things to
      use it as the current one. In these cases you can call
      <span class="Li">&quot;$ctx-&gt;do_in_context(sub { ... })&quot;</span>.
      The codeblock will be run, and anything inside of it that looks for a
      context will find the one on which the method was called.
    <p class="Pp">This <b>DOES NOT</b> affect context on other hubs, only the
        hub used by the context will be affected.</p>
    <p class="Pp"></p>
    <pre>
    my $ctx = ...;
    $ctx-&gt;do_in_context(sub {
        my $ctx = context(); # returns the $ctx the sub is called on
    });
    </pre>
    <p class="Pp"><b>Note:</b> The context will actually be cloned, the clone
        will be used instead of the original. This allows the thread id, process
        id, and error variables to be correct without modifying the original
        context.</p>
  </dd>
  <dt>$ctx-&gt;<b>restore_error_vars()</b></dt>
  <dd>This will set <span class="Li">$!</span>, <span class="Li">$?</span>, and
      <span class="Li">$@</span> to what they were when the context was created.
      There is no localization or anything done here, calling this method will
      actually set these vars.</dd>
  <dt>$! = $ctx-&gt;<b>errno()</b></dt>
  <dd>The (numeric) value of <span class="Li">$!</span> when the context was
      created.</dd>
  <dt>$? = $ctx-&gt;<b>child_error()</b></dt>
  <dd>The value of <span class="Li">$?</span> when the context was created.</dd>
  <dt>$@ = $ctx-&gt;<b>eval_error()</b></dt>
  <dd>The value of <span class="Li">$@</span> when the context was created.</dd>
</dl>
<section class="Ss">
<h2 class="Ss">EVENT PRODUCTION METHODS</h2>
<p class="Pp"><b>Which one do I use?</b></p>
<p class="Pp">The <span class="Li">&quot;pass*&quot;</span> and
    <span class="Li">&quot;fail*&quot;</span> are optimal if they meet your
    situation, using one of them will always be the most optimal. That said they
    are optimal by eliminating many features.</p>
<p class="Pp">Method such as <span class="Li">&quot;ok&quot;</span>, and
    <span class="Li">&quot;note&quot;</span> are shortcuts for generating common
    1-task events based on the old API, however they are forward compatible, and
    easy to use. If these meet your needs then go ahead and use them, but please
    check back often for alternatives that may be added.</p>
<p class="Pp">If you want to generate new style events, events that do many
    things at once, then you want the <span class="Li">&quot;*ev2*&quot;</span>
    methods. These let you directly specify which facets you wish to use.</p>
<dl class="Bl-tag">
  <dt>$event = $ctx-&gt;<b>pass()</b></dt>
  <dd></dd>
  <dt>$event = $ctx-&gt;pass($name)</dt>
  <dd>This will send and return an Test2::Event::Pass event. You may optionally
      provide a <span class="Li">$name</span> for the assertion.
    <p class="Pp">The Test2::Event::Pass is a specially crafted and optimized
        event, using this will help the performance of passing tests.</p>
  </dd>
  <dt>$true = $ctx-&gt;<b>pass_and_release()</b></dt>
  <dd></dd>
  <dt>$true = $ctx-&gt;pass_and_release($name)</dt>
  <dd>This is a combination of <span class="Li">&quot;pass()&quot;</span> and
      <span class="Li">&quot;release()&quot;</span>. You can use this if you do
      not plan to do anything with the context after sending the event. This
      helps write more clear and compact code.
    <p class="Pp"></p>
    <pre>
    sub shorthand {
        my ($bool, $name) = @_;
        my $ctx = context();
        return $ctx-&gt;pass_and_release($name) if $bool;

        ... Handle a failure ...
    }

    sub longform {
        my ($bool, $name) = @_;
        my $ctx = context();

        if ($bool) {
            $ctx-&gt;pass($name);
            $ctx-&gt;release;
            return 1;
        }

        ... Handle a failure ...
    }
    </pre>
  </dd>
  <dt id="my"><a class="permalink" href="#my">my $event =
    $ctx-&gt;<b>fail()</b></a></dt>
  <dd></dd>
  <dt id="my~2"><a class="permalink" href="#my~2">my $event =
    $ctx-&gt;fail($name)</a></dt>
  <dd></dd>
  <dt id="my~3"><a class="permalink" href="#my~3">my $event =
    $ctx-&gt;fail($name, @diagnostics)</a></dt>
  <dd>This lets you send an Test2::Event::Fail event. You may optionally provide
      a <span class="Li">$name</span> and <span class="Li">@diagnostics</span>
      messages.
    <p class="Pp">Diagnostics messages can be simple strings, data structures,
        or instances of Test2::EventFacet::Info::Table (which are converted
        inline into the Test2::EventFacet::Info structure).</p>
  </dd>
  <dt id="my~4"><a class="permalink" href="#my~4">my $false =
    $ctx-&gt;<b>fail_and_release()</b></a></dt>
  <dd></dd>
  <dt id="my~5"><a class="permalink" href="#my~5">my $false =
    $ctx-&gt;fail_and_release($name)</a></dt>
  <dd></dd>
  <dt id="my~6"><a class="permalink" href="#my~6">my $false =
    $ctx-&gt;fail_and_release($name, @diagnostics)</a></dt>
  <dd>This is a combination of <span class="Li">&quot;fail()&quot;</span> and
      <span class="Li">&quot;release()&quot;</span>. This can be used to write
      clearer and shorter code.
    <p class="Pp"></p>
    <pre>
    sub shorthand {
        my ($bool, $name) = @_;
        my $ctx = context();
        return $ctx-&gt;fail_and_release($name) unless $bool;

        ... Handle a success ...
    }

    sub longform {
        my ($bool, $name) = @_;
        my $ctx = context();

        unless ($bool) {
            $ctx-&gt;pass($name);
            $ctx-&gt;release;
            return 1;
        }

        ... Handle a success ...
    }
    </pre>
  </dd>
  <dt>$event = $ctx-&gt;ok($bool, $name)</dt>
  <dd></dd>
  <dt>$event = $ctx-&gt;ok($bool, $name, \@on_fail)</dt>
  <dd><b>NOTE:</b> Use of this method is discouraged in favor of
      <span class="Li">&quot;pass()&quot;</span> and
      <span class="Li">&quot;fail()&quot;</span> which produce
      Test2::Event::Pass and Test2::Event::Fail events. These newer event types
      are faster and less crufty.
    <p class="Pp">This will create an Test2::Event::Ok object for you. If
        <span class="Li">$bool</span> is false then an Test2::Event::Diag event
        will be sent as well with details about the failure. If you do not want
        automatic diagnostics you should use the
        <span class="Li">&quot;send_event()&quot;</span> method directly.</p>
    <p class="Pp">The third argument
        <span class="Li">&quot;\@on_fail&quot;</span>) is an optional set of
        diagnostics to be sent in the event of a test failure. Unlike with
        <span class="Li">&quot;fail()&quot;</span> these diagnostics must be
        plain strings, data structures are not supported.</p>
  </dd>
  <dt>$event = $ctx-&gt;note($message)</dt>
  <dd>Send an Test2::Event::Note. This event prints a message to STDOUT.</dd>
  <dt>$event = $ctx-&gt;diag($message)</dt>
  <dd>Send an Test2::Event::Diag. This event prints a message to STDERR.</dd>
  <dt>$event = $ctx-&gt;plan($max)</dt>
  <dd></dd>
  <dt>$event = $ctx-&gt;plan(0, 'SKIP', $reason)</dt>
  <dd>This can be used to send an Test2::Event::Plan event. This event usually
      takes either a number of tests you expect to run. Optionally you can set
      the expected count to 0 and give the 'SKIP' directive with a reason to
      cause all tests to be skipped.</dd>
  <dt>$event = $ctx-&gt;skip($name, $reason);</dt>
  <dd>Send an Test2::Event::Skip event.</dd>
  <dt>$event = $ctx-&gt;bail($reason)</dt>
  <dd>This sends an Test2::Event::Bail event. This event will completely
      terminate all testing.</dd>
  <dt>$event = $ctx-&gt;send_ev2(%facets)</dt>
  <dd>This lets you build and send a V2 event directly from facets. The event is
      returned after it is sent.
    <p class="Pp">This example sends a single assertion, a note (comment for
        stdout in Test::Builder talk) and sets the plan to 1.</p>
    <p class="Pp"></p>
    <pre>
    my $event = $ctx-&gt;send_event(
        plan   =&gt; {count =&gt; 1},
        assert =&gt; {pass  =&gt; 1, details =&gt; &quot;A passing assert&quot;},
        info =&gt; [{tag =&gt; 'NOTE', details =&gt; &quot;This is a note&quot;}],
    );
    </pre>
  </dd>
  <dt>$event = $ctx-&gt;build_e2(%facets)</dt>
  <dd>This is the same as <span class="Li">&quot;send_ev2()&quot;</span>, except
      it builds and returns the event without sending it.</dd>
  <dt>$event = $ctx-&gt;send_ev2_and_release($Type, %parameters)</dt>
  <dd>This is a combination of <span class="Li">&quot;send_ev2()&quot;</span>
      and <span class="Li">&quot;release()&quot;</span>.
    <p class="Pp"></p>
    <pre>
    sub shorthand {
        my $ctx = context();
        return $ctx-&gt;send_ev2_and_release(assert =&gt; {pass =&gt; 1, details =&gt; 'foo'});
    }

    sub longform {
        my $ctx = context();
        my $event = $ctx-&gt;send_ev2(assert =&gt; {pass =&gt; 1, details =&gt; 'foo'});
        $ctx-&gt;release;
        return $event;
    }
    </pre>
  </dd>
  <dt>$event = $ctx-&gt;send_event($Type, %parameters)</dt>
  <dd><b>It is better to use </b><b>send_ev2()</b><b> in new code.</b>
    <p class="Pp">This lets you build and send an event of any type. The
        <span class="Li">$Type</span> argument should be the event package name
        with <span class="Li">&quot;Test2::Event::&quot;</span> left off, or a
        fully qualified package name prefixed with a '+'. The event is returned
        after it is sent.</p>
    <p class="Pp"></p>
    <pre>
    my $event = $ctx-&gt;send_event('Ok', ...);
    </pre>
    <p class="Pp">or</p>
    <p class="Pp"></p>
    <pre>
    my $event = $ctx-&gt;send_event('+Test2::Event::Ok', ...);
    </pre>
  </dd>
  <dt>$event = $ctx-&gt;build_event($Type, %parameters)</dt>
  <dd><b>It is better to use </b><b>build_ev2()</b><b> in new code.</b>
    <p class="Pp">This is the same as
        <span class="Li">&quot;send_event()&quot;</span>, except it builds and
        returns the event without sending it.</p>
  </dd>
  <dt>$event = $ctx-&gt;send_event_and_release($Type, %parameters)</dt>
  <dd><b>It is better to use </b><b>send_ev2_and_release()</b><b> in new
      code.</b>
    <p class="Pp">This is a combination of
        <span class="Li">&quot;send_event()&quot;</span> and
        <span class="Li">&quot;release()&quot;</span>.</p>
    <p class="Pp"></p>
    <pre>
    sub shorthand {
        my $ctx = context();
        return $ctx-&gt;send_event_and_release(Pass =&gt; { name =&gt; 'foo' });
    }

    sub longform {
        my $ctx = context();
        my $event = $ctx-&gt;send_event(Pass =&gt; { name =&gt; 'foo' });
        $ctx-&gt;release;
        return $event;
    }
    </pre>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="HOOKS"><a class="permalink" href="#HOOKS">HOOKS</a></h1>
<p class="Pp">There are 2 types of hooks, init hooks, and release hooks. As the
    names suggest, these hooks are triggered when contexts are created or
    released.</p>
<section class="Ss">
<h2 class="Ss">INIT HOOKS</h2>
<p class="Pp">These are called whenever a context is initialized. That means
    when a new instance is created. These hooks are <b>NOT</b> called every time
    something requests a context, just when a new one is created.</p>
<p class="Pp"><i>GLOBAL</i></p>
<p class="Pp">This is how you add a global init callback. Global callbacks
    happen for every context for any hub or stack.</p>
<p class="Pp"></p>
<pre>
    Test2::API::test2_add_callback_context_init(sub {
        my $ctx = shift;
        ...
    });
</pre>
<p class="Pp"><i>PER HUB</i></p>
<p class="Pp">This is how you add an init callback for all contexts created for
    a given hub. These callbacks will not run for other hubs.</p>
<p class="Pp"></p>
<pre>
    $hub-&gt;add_context_init(sub {
        my $ctx = shift;
        ...
    });
</pre>
<p class="Pp"><i>PER CONTEXT</i></p>
<p class="Pp">This is how you specify an init hook that will only run if your
    call to <span class="Li">&quot;context()&quot;</span> generates a new
    context. The callback will be ignored if
    <span class="Li">&quot;context()&quot;</span> is returning an existing
    context.</p>
<p class="Pp"></p>
<pre>
    my $ctx = context(on_init =&gt; sub {
        my $ctx = shift;
        ...
    });
</pre>
</section>
<section class="Ss">
<h2 class="Ss">RELEASE HOOKS</h2>
<p class="Pp">These are called whenever a context is released. That means when
    the last reference to the instance is about to be destroyed. These hooks are
    <b>NOT</b> called every time
    <span class="Li">&quot;$ctx-&gt;release&quot;</span> is called.</p>
<p class="Pp"><i>GLOBAL</i></p>
<p class="Pp">This is how you add a global release callback. Global callbacks
    happen for every context for any hub or stack.</p>
<p class="Pp"></p>
<pre>
    Test2::API::test2_add_callback_context_release(sub {
        my $ctx = shift;
        ...
    });
</pre>
<p class="Pp"><i>PER HUB</i></p>
<p class="Pp">This is how you add a release callback for all contexts created
    for a given hub. These callbacks will not run for other hubs.</p>
<p class="Pp"></p>
<pre>
    $hub-&gt;add_context_release(sub {
        my $ctx = shift;
        ...
    });
</pre>
<p class="Pp"><i>PER CONTEXT</i></p>
<p class="Pp">This is how you add release callbacks directly to a context. The
    callback will <b>ALWAYS</b> be added to the context that gets returned, it
    does not matter if a new one is generated, or if an existing one is
    returned.</p>
<p class="Pp"></p>
<pre>
    my $ctx = context(on_release =&gt; sub {
        my $ctx = shift;
        ...
    });
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="THIRD_PARTY_META-DATA"><a class="permalink" href="#THIRD_PARTY_META-DATA">THIRD
  PARTY META-DATA</a></h1>
<p class="Pp">This object consumes Test2::Util::ExternalMeta which provides a
    consistent way for you to attach meta-data to instances of this class. This
    is useful for tools, plugins, and other extensions.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SOURCE"><a class="permalink" href="#SOURCE">SOURCE</a></h1>
<p class="Pp">The source code repository for Test2 can be found at
    <i>http://github.com/Test-More/test-more/</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MAINTAINERS"><a class="permalink" href="#MAINTAINERS">MAINTAINERS</a></h1>
<dl class="Bl-tag">
  <dt id="Chad"><a class="permalink" href="#Chad">Chad Granum
    &lt;exodist@cpan.org&gt;</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<dl class="Bl-tag">
  <dt id="Chad~2"><a class="permalink" href="#Chad~2">Chad Granum
    &lt;exodist@cpan.org&gt;</a></dt>
  <dd></dd>
  <dt id="Kent"><a class="permalink" href="#Kent">Kent Fredric
    &lt;kentnl@cpan.org&gt;</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 2020 Chad Granum &lt;exodist@cpan.org&gt;.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">See <i>http://dev.perl.org/licenses/</i></p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-10-22</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

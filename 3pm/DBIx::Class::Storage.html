<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>DBIx::Class::Storage(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBIx::Class::Storage(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBIx::Class::Storage(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">DBIx::Class::Storage - Generic Storage Handler</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">A base implementation of common Storage methods. For specific
    information about DBI-based storage, see DBIx::Class::Storage::DBI.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
<p class="Pp">Arguments: <span class="Li">$schema</span></p>
<p class="Pp">Instantiates the Storage object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="set_schema"><a class="permalink" href="#set_schema">set_schema</a></h2>
<p class="Pp">Used to reset the schema class or object which owns this storage
    object, such as during &quot;clone&quot; in DBIx::Class::Schema.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="connected"><a class="permalink" href="#connected">connected</a></h2>
<p class="Pp">Returns true if we have an open storage connection, false if it is
    not (yet) open.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="disconnect"><a class="permalink" href="#disconnect">disconnect</a></h2>
<p class="Pp">Closes any open storage connection unconditionally.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ensure_connected"><a class="permalink" href="#ensure_connected">ensure_connected</a></h2>
<p class="Pp">Initiate a connection to the storage if one isn't already
  open.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="throw_exception"><a class="permalink" href="#throw_exception">throw_exception</a></h2>
<p class="Pp">Throws an exception - croaks.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="txn_do"><a class="permalink" href="#txn_do">txn_do</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:"><a class="permalink" href="#Arguments:">Arguments:
    $coderef, @coderef_args?</a></dt>
  <dd></dd>
  <dt id="Return"><a class="permalink" href="#Return">Return Value: The return
    value of $coderef</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Executes <span class="Li">$coderef</span> with (optional)
    arguments <span class="Li">@coderef_args</span> atomically, returning its
    result (if any). If an exception is caught, a rollback is issued and the
    exception is rethrown. If the rollback fails, (i.e. throws an exception) an
    exception is thrown that includes a &quot;Rollback failed&quot; message.</p>
<p class="Pp">For example,</p>
<p class="Pp"></p>
<pre>  my $author_rs = $schema-&gt;resultset('Author')-&gt;find(1);
  my @titles = qw/Night Day It/;
  my $coderef = sub {
    # If any one of these fails, the entire transaction fails
    $author_rs-&gt;create_related('books', {
      title =&gt; $_
    }) foreach (@titles);
    return $author-&gt;books;
  };
  my $rs;
  try {
    $rs = $schema-&gt;txn_do($coderef);
  } catch {
    my $error = shift;
    # Transaction failed
    die &quot;something terrible has happened!&quot;
      if ($error =~ /Rollback failed/);          # Rollback failed
    deal_with_failed_transaction();
  };
</pre>
<p class="Pp">In a nested transaction (calling <b>txn_do()</b> from within a
    <b>txn_do()</b> coderef) only the outermost transaction will issue a
    &quot;txn_commit&quot;, and <b>txn_do()</b> can be called in void, scalar
    and list context and it will behave as expected.</p>
<p class="Pp">Please note that all of the code in your coderef, including
    non-DBIx::Class code, is part of a transaction. This transaction may fail
    out halfway, or it may get partially double-executed (in the case that our
    DB connection failed halfway through the transaction, in which case we
    reconnect and restart the txn). Therefore it is best that any side-effects
    in your coderef are idempotent (that is, can be re-executed multiple times
    and get the same result), and that you check up on your side-effects in the
    case of transaction failure.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="txn_begin"><a class="permalink" href="#txn_begin">txn_begin</a></h2>
<p class="Pp">Starts a transaction.</p>
<p class="Pp">See the preferred &quot;txn_do&quot; method, which allows for an
    entire code block to be executed transactionally.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="txn_commit"><a class="permalink" href="#txn_commit">txn_commit</a></h2>
<p class="Pp">Issues a commit of the current transaction.</p>
<p class="Pp">It does <i>not</i> perform an actual storage commit unless there's
    a DBIx::Class transaction currently in effect (i.e. you called
    &quot;txn_begin&quot;).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="txn_rollback"><a class="permalink" href="#txn_rollback">txn_rollback</a></h2>
<p class="Pp">Issues a rollback of the current transaction. A nested rollback
    will throw a DBIx::Class::Storage::NESTED_ROLLBACK_EXCEPTION exception,
    which allows the rollback to propagate to the outermost transaction.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="svp_begin"><a class="permalink" href="#svp_begin">svp_begin</a></h2>
<p class="Pp">Arguments: <span class="Li">$savepoint_name</span>?</p>
<p class="Pp">Created a new savepoint using the name provided as argument. If no
    name is provided, a random name will be used.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="svp_release"><a class="permalink" href="#svp_release">svp_release</a></h2>
<p class="Pp">Arguments: <span class="Li">$savepoint_name</span>?</p>
<p class="Pp">Release the savepoint provided as argument. If none is provided,
    release the savepoint created most recently. This will implicitly release
    all savepoints created after the one explicitly released as well.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="svp_rollback"><a class="permalink" href="#svp_rollback">svp_rollback</a></h2>
<p class="Pp">Arguments: <span class="Li">$savepoint_name</span>?</p>
<p class="Pp">Rollback to the savepoint provided as argument. If none is
    provided, rollback to the savepoint created most recently. This will
    implicitly release all savepoints created after the savepoint we rollback
    to.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="txn_scope_guard"><a class="permalink" href="#txn_scope_guard">txn_scope_guard</a></h2>
<p class="Pp">An alternative way of transaction handling based on
    DBIx::Class::Storage::TxnScopeGuard:</p>
<p class="Pp"></p>
<pre> my $txn_guard = $storage-&gt;txn_scope_guard;
 $result-&gt;col1(&quot;val1&quot;);
 $result-&gt;update;
 $txn_guard-&gt;commit;
</pre>
<p class="Pp">If an exception occurs, or the guard object otherwise leaves the
    scope before <span class="Li">&quot;$txn_guard-&gt;commit&quot;</span> is
    called, the transaction will be rolled back by an explicit
    &quot;txn_rollback&quot; call. In essence this is akin to using a
    &quot;txn_begin&quot;/&quot;txn_commit&quot; pair, without having to worry
    about calling &quot;txn_rollback&quot; at the right places. Note that since
    there is no defined code closure, there will be no retries and other magic
    upon database disconnection. If you need such functionality see
    &quot;txn_do&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="sql_maker"><a class="permalink" href="#sql_maker">sql_maker</a></h2>
<p class="Pp">Returns a <span class="Li">&quot;sql_maker&quot;</span> object -
    normally an object of class
    <span class="Li">&quot;DBIx::Class::SQLMaker&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="debug"><a class="permalink" href="#debug">debug</a></h2>
<p class="Pp">Causes trace information to be emitted on the &quot;debugobj&quot;
    object. (or <span class="Li">&quot;STDERR&quot;</span> if
    &quot;debugobj&quot; has not specifically been set).</p>
<p class="Pp">This is the equivalent to setting &quot;DBIC_TRACE&quot; in your
    shell environment.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="debugfh"><a class="permalink" href="#debugfh">debugfh</a></h2>
<p class="Pp">An opportunistic proxy to -&gt;debugobj-&gt;debugfh(@_)</p>
<p class="Pp">If the currently set &quot;debugobj&quot; does not have a
    &quot;debugfh&quot; method, caling this is a no-op.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="debugobj"><a class="permalink" href="#debugobj">debugobj</a></h2>
<p class="Pp">Sets or retrieves the object used for metric collection. Defaults
    to an instance of DBIx::Class::Storage::Statistics that is compatible with
    the original method of using a coderef as a callback. See the aforementioned
    Statistics class for more information.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="debugcb"><a class="permalink" href="#debugcb">debugcb</a></h2>
<p class="Pp">Sets a callback to be executed each time a statement is run; takes
    a sub reference. Callback is executed as
    <span class="Li">$sub</span>-&gt;($op, <span class="Li">$info</span>) where
    <span class="Li">$op</span> is SELECT/INSERT/UPDATE/DELETE and
    <span class="Li">$info</span> is what would normally be printed.</p>
<p class="Pp">See &quot;debugobj&quot; for a better way.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="cursor_class"><a class="permalink" href="#cursor_class">cursor_class</a></h2>
<p class="Pp">The cursor class for this Storage object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="deploy"><a class="permalink" href="#deploy">deploy</a></h2>
<p class="Pp">Deploy the tables to storage (CREATE TABLE and friends in a
    SQL-based Storage class). This would normally be called through
    &quot;deploy&quot; in DBIx::Class::Schema.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="connect_info"><a class="permalink" href="#connect_info">connect_info</a></h2>
<p class="Pp">The arguments of <span class="Li">&quot;connect_info&quot;</span>
    are always a single array reference, and are Storage-handler specific.</p>
<p class="Pp">This is normally accessed via &quot;connection&quot; in
    DBIx::Class::Schema, which encapsulates its argument list in an arrayref
    before calling <span class="Li">&quot;connect_info&quot;</span> here.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="select"><a class="permalink" href="#select">select</a></h2>
<p class="Pp">Handle a select statement.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="insert"><a class="permalink" href="#insert">insert</a></h2>
<p class="Pp">Handle an insert statement.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="update"><a class="permalink" href="#update">update</a></h2>
<p class="Pp">Handle an update statement.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="delete"><a class="permalink" href="#delete">delete</a></h2>
<p class="Pp">Handle a delete statement.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="select_single"><a class="permalink" href="#select_single">select_single</a></h2>
<p class="Pp">Performs a select, fetch and return of data - handles a single row
    only.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="columns_info_for"><a class="permalink" href="#columns_info_for">columns_info_for</a></h2>
<p class="Pp">Returns metadata for the given source's columns. This is
    *deprecated*, and will be removed before 1.0. You should be specifying the
    metadata yourself if you need it.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ENVIRONMENT_VARIABLES"><a class="permalink" href="#ENVIRONMENT_VARIABLES">ENVIRONMENT
  VARIABLES</a></h1>
<section class="Ss">
<h2 class="Ss">DBIC_TRACE</h2>
<p class="Pp">If <span class="Li">&quot;DBIC_TRACE&quot;</span> is set then
    trace information is produced (as when the &quot;debug&quot; method is
  set).</p>
<p class="Pp">If the value is of the form
    <span class="Li">&quot;1=/path/name&quot;</span> then the trace output is
    written to the file <span class="Li">&quot;/path/name&quot;</span>.</p>
<p class="Pp">This environment variable is checked when the storage object is
    first created (when you call connect on your schema). So, run-time changes
    to this environment variable will not take effect unless you also re-connect
    on your schema.</p>
</section>
<section class="Ss">
<h2 class="Ss">DBIC_TRACE_PROFILE</h2>
<p class="Pp">If <span class="Li">&quot;DBIC_TRACE_PROFILE&quot;</span> is set,
    DBIx::Class::Storage::Debug::PrettyPrint will be used to format the output
    from <span class="Li">&quot;DBIC_TRACE&quot;</span>. The value it is set to
    is the <span class="Li">&quot;profile&quot;</span> that it will be used. If
    the value is a filename the file is read with Config::Any and the results
    are used as the configuration for tracing. See &quot;new&quot; in
    SQL::Abstract::Tree for what that structure should look like.</p>
</section>
<section class="Ss">
<h2 class="Ss">DBIX_CLASS_STORAGE_DBI_DEBUG</h2>
<p class="Pp">Old name for DBIC_TRACE</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">DBIx::Class::Storage::DBI - reference storage implementation using
    SQL::Abstract and DBI.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FURTHER_QUESTIONS?"><a class="permalink" href="#FURTHER_QUESTIONS?">FURTHER
  QUESTIONS?</a></h1>
<p class="Pp">Check the list of additional DBIC resources.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This module is free software copyright by the DBIx::Class (DBIC)
    authors. You can redistribute it and/or modify it under the same terms as
    the DBIx::Class library.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-01-29</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

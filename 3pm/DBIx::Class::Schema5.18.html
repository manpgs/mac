<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>DBIx::Class::Schema(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBIx::Class::Schema(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBIx::Class::Schema(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">DBIx::Class::Schema - composable schemas</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
  package Library::Schema;
  use base qw/DBIx::Class::Schema/;

  # load all Result classes in Library/Schema/Result/
  __PACKAGE__-&gt;load_namespaces();

  package Library::Schema::Result::CD;
  use base qw/DBIx::Class::Core/;

  __PACKAGE__-&gt;load_components(qw/InflateColumn::DateTime/); # for example
  __PACKAGE__-&gt;table('cd');

  # Elsewhere in your code:
  my $schema1 = Library::Schema-&gt;connect(
    $dsn,
    $user,
    $password,
    { AutoCommit =&gt; 1 },
  );

  my $schema2 = Library::Schema-&gt;connect($coderef_returning_dbh);

  # fetch objects using Library::Schema::Result::DVD
  my $resultset = $schema1-&gt;resultset('DVD')-&gt;search( ... );
  my @dvd_objects = $schema2-&gt;resultset('DVD')-&gt;search( ... );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Creates database classes based on a schema. This is the
    recommended way to use DBIx::Class and allows you to use more than one
    concurrent connection with your classes.</p>
<p class="Pp">NB: If you're used to Class::DBI it's worth reading the
    &quot;SYNOPSIS&quot; carefully, as DBIx::Class does things a little
    differently. Note in particular which module inherits off which.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SETUP_METHODS"><a class="permalink" href="#SETUP_METHODS">SETUP
  METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="load_namespaces"><a class="permalink" href="#load_namespaces">load_namespaces</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:"><a class="permalink" href="#Arguments:">Arguments:
    %options?</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  package MyApp::Schema;
  __PACKAGE__-&gt;load_namespaces();

  __PACKAGE__-&gt;load_namespaces(
     result_namespace =&gt; 'Res',
     resultset_namespace =&gt; 'RSet',
     default_resultset_class =&gt; '+MyApp::Othernamespace::RSet',
  );
</pre>
<p class="Pp">With no arguments, this method uses Module::Find to load all of
    the Result and ResultSet classes under the namespace of the schema from
    which it is called. For example,
    <span class="Li">&quot;My::Schema&quot;</span> will by default find and load
    Result classes named
    <span class="Li">&quot;My::Schema::Result::*&quot;</span> and ResultSet
    classes named
  <span class="Li">&quot;My::Schema::ResultSet::*&quot;</span>.</p>
<p class="Pp">ResultSet classes are associated with Result class of the same
    name. For example,
    <span class="Li">&quot;My::Schema::Result::CD&quot;</span> will get the
    ResultSet class
    <span class="Li">&quot;My::Schema::ResultSet::CD&quot;</span> if it is
    present.</p>
<p class="Pp">Both Result and ResultSet namespaces are configurable via the
    <span class="Li">&quot;result_namespace&quot;</span> and
    <span class="Li">&quot;resultset_namespace&quot;</span> options.</p>
<p class="Pp">Another option,
    <span class="Li">&quot;default_resultset_class&quot;</span> specifies a
    custom default ResultSet class for Result classes with no corresponding
    ResultSet.</p>
<p class="Pp">All of the namespace and classname options are by default relative
    to the schema classname. To specify a fully-qualified name, prefix it with a
    literal <span class="Li">&quot;+&quot;</span>. For example,
    <span class="Li">&quot;+Other::NameSpace::Result&quot;</span>.</p>
<p class="Pp"><i>Warnings</i></p>
<p class="Pp">You will be warned if ResultSet classes are discovered for which
    there are no matching Result classes like this:</p>
<p class="Pp"></p>
<pre>
  load_namespaces found ResultSet class $classname with no corresponding Result class
</pre>
<p class="Pp">If a Result class is found to already have a ResultSet class set
    using &quot;resultset_class&quot; to some other class, you will be warned
    like this:</p>
<p class="Pp"></p>
<pre>
  We found ResultSet class '$rs_class' for '$result', but it seems
  that you had already set '$result' to use '$rs_set' instead
</pre>
<p class="Pp"><i>Examples</i></p>
<p class="Pp"></p>
<pre>
  # load My::Schema::Result::CD, My::Schema::Result::Artist,
  #    My::Schema::ResultSet::CD, etc...
  My::Schema-&gt;load_namespaces;

  # Override everything to use ugly names.
  # In this example, if there is a My::Schema::Res::Foo, but no matching
  #   My::Schema::RSets::Foo, then Foo will have its
  #   resultset_class set to My::Schema::RSetBase
  My::Schema-&gt;load_namespaces(
    result_namespace =&gt; 'Res',
    resultset_namespace =&gt; 'RSets',
    default_resultset_class =&gt; 'RSetBase',
  );

  # Put things in other namespaces
  My::Schema-&gt;load_namespaces(
    result_namespace =&gt; '+Some::Place::Results',
    resultset_namespace =&gt; '+Another::Place::RSets',
  );
</pre>
<p class="Pp">To search multiple namespaces for either Result or ResultSet
    classes, use an arrayref of namespaces for that option. In the case that the
    same result (or resultset) class exists in multiple namespaces, later
    entries in the list of namespaces will override earlier ones.</p>
<p class="Pp"></p>
<pre>
  My::Schema-&gt;load_namespaces(
    # My::Schema::Results_C::Foo takes precedence over My::Schema::Results_B::Foo :
    result_namespace =&gt; [ 'Results_A', 'Results_B', 'Results_C' ],
    resultset_namespace =&gt; [ '+Some::Place::RSets', 'RSets' ],
  );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="load_classes"><a class="permalink" href="#load_classes">load_classes</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~2"><a class="permalink" href="#Arguments:~2">Arguments:
    @classes?, { $namespace =&gt; [ @classes ] }+</a></dt>
  <dd></dd>
</dl>
<p class="Pp">&quot;load_classes&quot; is an alternative method to
    &quot;load_namespaces&quot;, both of which serve similar purposes, each with
    different advantages and disadvantages. In the general case you should use
    &quot;load_namespaces&quot;, unless you need to be able to specify that only
    specific classes are loaded at runtime.</p>
<p class="Pp">With no arguments, this method uses Module::Find to find all
    classes under the schema's namespace. Otherwise, this method loads the
    classes you specify (using use), and registers them (using
    &quot;register_class&quot;).</p>
<p class="Pp">It is possible to comment out classes with a leading
    <span class="Li">&quot;#&quot;</span>, but note that perl will think it's a
    mistake (trying to use a comment in a qw list), so you'll need to add
    <span class="Li">&quot;no warnings 'qw';&quot;</span> before your
    load_classes call.</p>
<p class="Pp">If any classes found do not appear to be Result class files, you
    will get the following warning:</p>
<p class="Pp"></p>
<pre>
   Failed to load $comp_class. Can't find source_name method. Is
   $comp_class really a full DBIC result class? Fix it, move it elsewhere,
   or make your load_classes call more specific.
</pre>
<p class="Pp">Example:</p>
<p class="Pp"></p>
<pre>
  My::Schema-&gt;load_classes(); # loads My::Schema::CD, My::Schema::Artist,
                              # etc. (anything under the My::Schema namespace)

  # loads My::Schema::CD, My::Schema::Artist, Other::Namespace::Producer but
  # not Other::Namespace::LinerNotes nor My::Schema::Track
  My::Schema-&gt;load_classes(qw/ CD Artist #Track /, {
    Other::Namespace =&gt; [qw/ Producer #LinerNotes /],
  });
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="storage_type"><a class="permalink" href="#storage_type">storage_type</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~3"><a class="permalink" href="#Arguments:~3">Arguments:
    $storage_type|{$storage_type, \%args}</a></dt>
  <dd></dd>
  <dt id="Return"><a class="permalink" href="#Return">Return Value:
    $storage_type|{$storage_type, \%args}</a></dt>
  <dd></dd>
  <dt id="Default"><a class="permalink" href="#Default">Default value:
    DBIx::Class::Storage::DBI</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Set the storage class that will be instantiated when
    &quot;connect&quot; is called. If the classname starts with
    <span class="Li">&quot;::&quot;</span>, the prefix
    <span class="Li">&quot;DBIx::Class::Storage&quot;</span> is assumed by
    &quot;connect&quot;.</p>
<p class="Pp">You want to use this to set subclasses of
    DBIx::Class::Storage::DBI in cases where the appropriate subclass is not
    autodetected.</p>
<p class="Pp">If your storage type requires instantiation arguments, those are
    defined as a second argument in the form of a hashref and the entire value
    needs to be wrapped into an arrayref or a hashref. We support both types of
    refs here in order to play nice with your Config::[class] or your choice.
    See DBIx::Class::Storage::DBI::Replicated for an example of this.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="exception_action"><a class="permalink" href="#exception_action">exception_action</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~4"><a class="permalink" href="#Arguments:~4">Arguments:
    $code_reference</a></dt>
  <dd></dd>
  <dt id="Return~2"><a class="permalink" href="#Return~2">Return Value:
    $code_reference</a></dt>
  <dd></dd>
  <dt id="Default~2"><a class="permalink" href="#Default~2">Default value:
    None</a></dt>
  <dd></dd>
</dl>
<p class="Pp">When &quot;throw_exception&quot; is invoked and
    &quot;exception_action&quot; is set to a code reference, this reference will
    be called instead of &quot;throw&quot; in DBIx::Class::Exception, with the
    exception message passed as the only argument.</p>
<p class="Pp">Your custom throw code <b>must</b> rethrow the exception, as
    &quot;throw_exception&quot; is an integral part of DBIC's internal execution
    control flow.</p>
<p class="Pp">Example:</p>
<p class="Pp"></p>
<pre>
   package My::Schema;
   use base qw/DBIx::Class::Schema/;
   use My::ExceptionClass;
   __PACKAGE__-&gt;exception_action(sub { My::ExceptionClass-&gt;throw(@_) });
   __PACKAGE__-&gt;load_classes;

   # or:
   my $schema_obj = My::Schema-&gt;connect( .... );
   $schema_obj-&gt;exception_action(sub { My::ExceptionClass-&gt;throw(@_) });
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="stacktrace"><a class="permalink" href="#stacktrace">stacktrace</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~5"><a class="permalink" href="#Arguments:~5">Arguments:
    boolean</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Whether &quot;throw_exception&quot; should include stack trace
    information. Defaults to false normally, but defaults to true if
    <span class="Li">$ENV{DBIC_TRACE}</span> is true.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="sqlt_deploy_hook"><a class="permalink" href="#sqlt_deploy_hook">sqlt_deploy_hook</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~6"><a class="permalink" href="#Arguments:~6">Arguments:
    $sqlt_schema</a></dt>
  <dd></dd>
</dl>
<p class="Pp">An optional sub which you can declare in your own Schema class
    that will get passed the SQL::Translator::Schema object when you deploy the
    schema via &quot;create_ddl_dir&quot; or &quot;deploy&quot;.</p>
<p class="Pp">For an example of what you can do with this, see &quot;Adding
    Indexes And Functions To Your SQL&quot; in
  DBIx::Class::Manual::Cookbook.</p>
<p class="Pp">Note that sqlt_deploy_hook is called by
    &quot;deployment_statements&quot;, which in turn is called before
    &quot;deploy&quot;. Therefore the hook can be used only to manipulate the
    SQL::Translator::Schema object before it is turned into SQL fed to the
    database. If you want to execute post-deploy statements which can not be
    generated by SQL::Translator, the currently suggested method is to overload
    &quot;deploy&quot; and use dbh_do.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="connect"><a class="permalink" href="#connect">connect</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~7"><a class="permalink" href="#Arguments:~7">Arguments:
    @connectinfo</a></dt>
  <dd></dd>
  <dt id="Return~3"><a class="permalink" href="#Return~3">Return Value:
    $new_schema</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Creates and returns a new Schema object. The connection info set
    on it is used to create a new instance of the storage backend and set it on
    the Schema object.</p>
<p class="Pp">See &quot;connect_info&quot; in DBIx::Class::Storage::DBI for
    DBI-specific syntax on the <span class="Li">@connectinfo</span> argument, or
    DBIx::Class::Storage in general.</p>
<p class="Pp">Note that <span class="Li">&quot;connect_info&quot;</span> expects
    an arrayref of arguments, but <span class="Li">&quot;connect&quot;</span>
    does not. <span class="Li">&quot;connect&quot;</span> wraps its arguments in
    an arrayref before passing them to
    <span class="Li">&quot;connect_info&quot;</span>.</p>
<p class="Pp"><i>Overloading</i></p>
<p class="Pp"><span class="Li">&quot;connect&quot;</span> is a convenience
    method. It is equivalent to calling
    <span class="Li">$schema</span>-&gt;clone-&gt;connection(@connectinfo). To
    write your own overloaded version, overload &quot;connection&quot;
  instead.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="resultset"><a class="permalink" href="#resultset">resultset</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~8"><a class="permalink" href="#Arguments:~8">Arguments:
    $source_name</a></dt>
  <dd></dd>
  <dt id="Return~4"><a class="permalink" href="#Return~4">Return Value:
    $resultset</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  my $rs = $schema-&gt;resultset('DVD');
</pre>
<p class="Pp">Returns the DBIx::Class::ResultSet object for the registered
    source name.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="sources"><a class="permalink" href="#sources">sources</a></h2>
<dl class="Bl-tag">
  <dt id="Return~5"><a class="permalink" href="#Return~5">Return Value:
    @source_names</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  my @source_names = $schema-&gt;sources;
</pre>
<p class="Pp">Lists names of all the sources registered on this Schema
  object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="source"><a class="permalink" href="#source">source</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~9"><a class="permalink" href="#Arguments:~9">Arguments:
    $source_name</a></dt>
  <dd></dd>
  <dt id="Return~6"><a class="permalink" href="#Return~6">Return Value:
    $result_source</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  my $source = $schema-&gt;source('Book');
</pre>
<p class="Pp">Returns the DBIx::Class::ResultSource object for the registered
    source name.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="class"><a class="permalink" href="#class">class</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~10"><a class="permalink" href="#Arguments:~10">Arguments:
    $source_name</a></dt>
  <dd></dd>
  <dt id="Return~7"><a class="permalink" href="#Return~7">Return Value:
    $classname</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  my $class = $schema-&gt;class('CD');
</pre>
<p class="Pp">Retrieves the Result class name for the given source name.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="txn_do"><a class="permalink" href="#txn_do">txn_do</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~11"><a class="permalink" href="#Arguments:~11">Arguments:
    $coderef, @coderef_args?</a></dt>
  <dd></dd>
  <dt id="Return~8"><a class="permalink" href="#Return~8">Return Value: The
    return value of $coderef</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Executes <span class="Li">$coderef</span> with (optional)
    arguments <span class="Li">@coderef_args</span> atomically, returning its
    result (if any). Equivalent to calling
    <span class="Li">$schema</span>-&gt;storage-&gt;txn_do. See
    &quot;txn_do&quot; in DBIx::Class::Storage for more information.</p>
<p class="Pp">This interface is preferred over using the individual methods
    &quot;txn_begin&quot;, &quot;txn_commit&quot;, and &quot;txn_rollback&quot;
    below.</p>
<p class="Pp">WARNING: If you are connected with
    <span class="Li">&quot;AutoCommit =&gt; 0&quot;</span> the transaction is
    considered nested, and you will still need to call &quot;txn_commit&quot; to
    write your changes when appropriate. You will also want to connect with
    <span class="Li">&quot;auto_savepoint =&gt;</span>
    <span class="Li">1&quot;</span> to get partial rollback to work, if the
    storage driver for your database supports it.</p>
<p class="Pp">Connecting with <span class="Li">&quot;AutoCommit =&gt;
    1&quot;</span> is recommended.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="txn_scope_guard"><a class="permalink" href="#txn_scope_guard">txn_scope_guard</a></h2>
<p class="Pp">Runs <span class="Li">&quot;txn_scope_guard&quot;</span> on the
    schema's storage. See &quot;txn_scope_guard&quot; in
  DBIx::Class::Storage.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="txn_begin"><a class="permalink" href="#txn_begin">txn_begin</a></h2>
<p class="Pp">Begins a transaction (does nothing if AutoCommit is off).
    Equivalent to calling
    <span class="Li">$schema</span>-&gt;storage-&gt;txn_begin. See
    &quot;txn_begin&quot; in DBIx::Class::Storage for more information.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="txn_commit"><a class="permalink" href="#txn_commit">txn_commit</a></h2>
<p class="Pp">Commits the current transaction. Equivalent to calling
    <span class="Li">$schema</span>-&gt;storage-&gt;txn_commit. See
    &quot;txn_commit&quot; in DBIx::Class::Storage for more information.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="txn_rollback"><a class="permalink" href="#txn_rollback">txn_rollback</a></h2>
<p class="Pp">Rolls back the current transaction. Equivalent to calling
    <span class="Li">$schema</span>-&gt;storage-&gt;txn_rollback. See
    &quot;txn_rollback&quot; in DBIx::Class::Storage for more information.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="storage"><a class="permalink" href="#storage">storage</a></h2>
<pre>
  my $storage = $schema-&gt;storage;
</pre>
<p class="Pp">Returns the DBIx::Class::Storage object for this Schema. Grab this
    if you want to turn on SQL statement debugging at runtime, or set the quote
    character. For the default storage, the documentation can be found in
    DBIx::Class::Storage::DBI.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="populate"><a class="permalink" href="#populate">populate</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~12"><a class="permalink" href="#Arguments:~12">Arguments:
    $source_name, [ \@column_list, \@row_values+ ] | [ \%col_data+ ]</a></dt>
  <dd></dd>
  <dt id="Return~9"><a class="permalink" href="#Return~9">Return Value:
    \@result_objects (scalar context) | @result_objects (list context)</a></dt>
  <dd></dd>
</dl>
<p class="Pp">A convenience shortcut to &quot;populate&quot; in
    DBIx::Class::ResultSet. Equivalent to:</p>
<p class="Pp"></p>
<pre>
 $schema-&gt;resultset($source_name)-&gt;populate([...]);
</pre>
<dl class="Bl-tag">
  <dt id="NOTE"><a class="permalink" href="#NOTE">NOTE</a></dt>
  <dd>The context of this method call has an important effect on what is
      submitted to storage. In void context data is fed directly to fastpath
      insertion routines provided by the underlying storage (most often
      &quot;execute_for_fetch&quot; in DBI), bypassing the new and insert calls
      on the Result class, including any augmentation of these methods provided
      by components. For example if you are using something like
      DBIx::Class::UUIDColumns to create primary keys for you, you will find
      that your PKs are empty. In this case you will have to explicitly force
      scalar or list context in order to create those values.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="connection"><a class="permalink" href="#connection">connection</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~13"><a class="permalink" href="#Arguments:~13">Arguments:
    @args</a></dt>
  <dd></dd>
  <dt id="Return~10"><a class="permalink" href="#Return~10">Return Value:
    $new_schema</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Similar to &quot;connect&quot; except sets the storage object and
    connection data in-place on the Schema class. You should probably be calling
    &quot;connect&quot; to get a proper Schema object instead.</p>
<p class="Pp"><i>Overloading</i></p>
<p class="Pp">Overload <span class="Li">&quot;connection&quot;</span> to change
    the behaviour of <span class="Li">&quot;connect&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="compose_namespace"><a class="permalink" href="#compose_namespace">compose_namespace</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~14"><a class="permalink" href="#Arguments:~14">Arguments:
    $target_namespace, $additional_base_class?</a></dt>
  <dd></dd>
  <dt id="Return~11"><a class="permalink" href="#Return~11">Return Value:
    $new_schema</a></dt>
  <dd></dd>
</dl>
<p class="Pp">For each DBIx::Class::ResultSource in the schema, this method
    creates a class in the target namespace (e.g.
    <span class="Li">$target_namespace::CD</span>,
    <span class="Li">$target_namespace::Artist</span>) that inherits from the
    corresponding classes attached to the current schema.</p>
<p class="Pp">It also attaches a corresponding DBIx::Class::ResultSource object
    to the new <span class="Li">$schema</span> object. If
    <span class="Li">$additional_base_class</span> is given, the new composed
    classes will inherit from first the corresponding class from the current
    schema then the base class.</p>
<p class="Pp">For example, for a schema with My::Schema::CD and
    My::Schema::Artist classes,</p>
<p class="Pp"></p>
<pre>
  $schema-&gt;compose_namespace('My::DB', 'Base::Class');
  print join (', ', @My::DB::CD::ISA) . &quot;\n&quot;;
  print join (', ', @My::DB::Artist::ISA) .&quot;\n&quot;;
</pre>
<p class="Pp">will produce the output</p>
<p class="Pp"></p>
<pre>
  My::Schema::CD, Base::Class
  My::Schema::Artist, Base::Class
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="svp_begin"><a class="permalink" href="#svp_begin">svp_begin</a></h2>
<p class="Pp">Creates a new savepoint (does nothing outside a transaction).
    Equivalent to calling
    <span class="Li">$schema</span>-&gt;storage-&gt;svp_begin. See
    &quot;svp_begin&quot; in DBIx::Class::Storage for more information.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="svp_release"><a class="permalink" href="#svp_release">svp_release</a></h2>
<p class="Pp">Releases a savepoint (does nothing outside a transaction).
    Equivalent to calling
    <span class="Li">$schema</span>-&gt;storage-&gt;svp_release. See
    &quot;svp_release&quot; in DBIx::Class::Storage for more information.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="svp_rollback"><a class="permalink" href="#svp_rollback">svp_rollback</a></h2>
<p class="Pp">Rollback to a savepoint (does nothing outside a transaction).
    Equivalent to calling
    <span class="Li">$schema</span>-&gt;storage-&gt;svp_rollback. See
    &quot;svp_rollback&quot; in DBIx::Class::Storage for more information.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="clone"><a class="permalink" href="#clone">clone</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~15"><a class="permalink" href="#Arguments:~15">Arguments:
    %attrs?</a></dt>
  <dd></dd>
  <dt id="Return~12"><a class="permalink" href="#Return~12">Return Value:
    $new_schema</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Clones the schema and its associated result_source objects and
    returns the copy. The resulting copy will have the same attributes as the
    source schema, except for those attributes explicitly overridden by the
    provided <span class="Li">%attrs</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="throw_exception"><a class="permalink" href="#throw_exception">throw_exception</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~16"><a class="permalink" href="#Arguments:~16">Arguments:
    $message</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Throws an exception. Obeys the exemption rules of
    DBIx::Class::Carp to report errors from outer-user's perspective. See
    &quot;exception_action&quot; for details on overriding this method's
    behavior. If &quot;stacktrace&quot; is turned on,
    <span class="Li">&quot;throw_exception&quot;</span>'s default behavior will
    provide a detailed stack trace.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="deploy"><a class="permalink" href="#deploy">deploy</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~17"><a class="permalink" href="#Arguments:~17">Arguments:
    \%sqlt_args, $dir</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Attempts to deploy the schema to the current storage using
    SQL::Translator.</p>
<p class="Pp">See &quot;METHODS&quot; in SQL::Translator for a list of values
    for <span class="Li">&quot;\%sqlt_args&quot;</span>. The most common value
    for this would be <span class="Li">&quot;{ add_drop_table =&gt; 1
    }&quot;</span> to have the SQL produced include a
    <span class="Li">&quot;DROP TABLE&quot;</span> statement for each table
    created. For quoting purposes supply
    <span class="Li">&quot;quote_identifiers&quot;</span>.</p>
<p class="Pp">Additionally, the DBIx::Class parser accepts a
    <span class="Li">&quot;sources&quot;</span> parameter as a hash ref or an
    array ref, containing a list of source to deploy. If present, then only the
    sources listed will get deployed. Furthermore, you can use the
    <span class="Li">&quot;add_fk_index&quot;</span> parser parameter to prevent
    the parser from creating an index for each FK.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="deployment_statements"><a class="permalink" href="#deployment_statements">deployment_statements</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~18"><a class="permalink" href="#Arguments:~18">Arguments:
    See &quot;deployment_statements&quot; in DBIx::Class::Storage::DBI</a></dt>
  <dd></dd>
  <dt id="Return~13"><a class="permalink" href="#Return~13">Return Value:
    $listofstatements</a></dt>
  <dd></dd>
</dl>
<p class="Pp">A convenient shortcut to
    <span class="Li">&quot;$self-&gt;storage-&gt;deployment_statements($self,
    @args)&quot;</span>. Returns the SQL statements used by &quot;deploy&quot;
    and &quot;deploy&quot; in DBIx::Class::Schema::Storage.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="create_ddl_dir"><a class="permalink" href="#create_ddl_dir">create_ddl_dir</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~19"><a class="permalink" href="#Arguments:~19">Arguments:
    See &quot;create_ddl_dir&quot; in DBIx::Class::Storage::DBI</a></dt>
  <dd></dd>
</dl>
<p class="Pp">A convenient shortcut to
    <span class="Li">&quot;$self-&gt;storage-&gt;create_ddl_dir($self,
    @args)&quot;</span>.</p>
<p class="Pp">Creates an SQL file based on the Schema, for each of the specified
    database types, in the given directory.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ddl_filename"><a class="permalink" href="#ddl_filename">ddl_filename</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~20"><a class="permalink" href="#Arguments:~20">Arguments:
    $database-type, $version, $directory, $preversion</a></dt>
  <dd></dd>
  <dt id="Return~14"><a class="permalink" href="#Return~14">Return Value:
    $normalised_filename</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>
  my $filename = $table-&gt;ddl_filename($type, $version, $dir, $preversion)
</pre>
<p class="Pp">This method is called by
    <span class="Li">&quot;create_ddl_dir&quot;</span> to compose a file name
    out of the supplied directory, database type and version number. The default
    file name format is:
    <span class="Li">&quot;$dir$schema-$version-$type.sql&quot;</span>.</p>
<p class="Pp">You may override this method in your schema if you wish to use a
    different format.</p>
<p class="Pp"></p>
<pre>
 WARNING

 Prior to DBIx::Class version 0.08100 this method had a different signature:

    my $filename = $table-&gt;ddl_filename($type, $dir, $version, $preversion)

 In recent versions variables $dir and $version were reversed in order to
 bring the signature in line with other Schema/Storage methods. If you
 really need to maintain backward compatibility, you can do the following
 in any overriding methods:

    ($dir, $version) = ($version, $dir) if ($DBIx::Class::VERSION &lt; 0.08100);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="thaw"><a class="permalink" href="#thaw">thaw</a></h2>
<p class="Pp">Provided as the recommended way of thawing schema objects. You can
    call <span class="Li">&quot;Storable::thaw&quot;</span> directly if you
    wish, but the thawed objects will not have a reference to any schema, so are
    rather useless.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="freeze"><a class="permalink" href="#freeze">freeze</a></h2>
<p class="Pp">This doesn't actually do anything more than call
    &quot;nfreeze&quot; in Storable, it is just provided here for symmetry.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="dclone"><a class="permalink" href="#dclone">dclone</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~21"><a class="permalink" href="#Arguments:~21">Arguments:
    $object</a></dt>
  <dd></dd>
  <dt id="Return~15"><a class="permalink" href="#Return~15">Return Value:
    dcloned $object</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Recommended way of dcloning DBIx::Class::Row and
    DBIx::Class::ResultSet objects so their references to the schema object
    (which itself is <b>not</b> cloned) are properly maintained.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="schema_version"><a class="permalink" href="#schema_version">schema_version</a></h2>
<p class="Pp">Returns the current schema class' <span class="Li">$VERSION</span>
    in a normalised way.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="register_class"><a class="permalink" href="#register_class">register_class</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~22"><a class="permalink" href="#Arguments:~22">Arguments:
    $source_name, $component_class</a></dt>
  <dd></dd>
</dl>
<p class="Pp">This method is called by &quot;load_namespaces&quot; and
    &quot;load_classes&quot; to install the found classes into your Schema. You
    should be using those instead of this one.</p>
<p class="Pp">You will only need this method if you have your Result classes in
    files which are not named after the packages (or all in the same file). You
    may also need it to register classes at runtime.</p>
<p class="Pp">Registers a class which isa DBIx::Class::ResultSourceProxy.
    Equivalent to calling:</p>
<p class="Pp"></p>
<pre>
  $schema-&gt;register_source($source_name, $component_class-&gt;result_source_instance);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="register_source"><a class="permalink" href="#register_source">register_source</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~23"><a class="permalink" href="#Arguments:~23">Arguments:
    $source_name, $result_source</a></dt>
  <dd></dd>
</dl>
<p class="Pp">This method is called by &quot;register_class&quot;.</p>
<p class="Pp">Registers the DBIx::Class::ResultSource in the schema with the
    given source name.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="unregister_source"><a class="permalink" href="#unregister_source">unregister_source</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~24"><a class="permalink" href="#Arguments:~24">Arguments:
    $source_name</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Removes the DBIx::Class::ResultSource from the schema for the
    given source name.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="register_extra_source"><a class="permalink" href="#register_extra_source">register_extra_source</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~25"><a class="permalink" href="#Arguments:~25">Arguments:
    $source_name, $result_source</a></dt>
  <dd></dd>
</dl>
<p class="Pp">As &quot;register_source&quot; but should be used if the result
    class already has a source and you want to register an extra one.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="compose_connection_("><a class="permalink" href="#compose_connection_(">compose_connection
  (DEPRECATED)</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~26"><a class="permalink" href="#Arguments:~26">Arguments:
    $target_namespace, @db_info</a></dt>
  <dd></dd>
  <dt id="Return~16"><a class="permalink" href="#Return~16">Return Value:
    $new_schema</a></dt>
  <dd></dd>
</dl>
<p class="Pp">DEPRECATED. You probably wanted compose_namespace.</p>
<p class="Pp">Actually, you probably just wanted to call connect.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR_AND_CONTRIBUTORS"><a class="permalink" href="#AUTHOR_AND_CONTRIBUTORS">AUTHOR
  AND CONTRIBUTORS</a></h1>
<p class="Pp">See AUTHOR and CONTRIBUTORS in DBIx::Class</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">You may distribute this code under the same terms as Perl
  itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-22</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

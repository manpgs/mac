<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Math::Complex(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Math::Complex(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Math::Complex(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Math::Complex - complex numbers and associated mathematical
    functions</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>        use Math::Complex;
        $z = Math::Complex-&gt;make(5, 6);
        $t = 4 - 3*i + $z;
        $j = cplxe(1, 2*pi/3);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This package lets you create and manipulate complex numbers. By
    default, <i>Perl</i> limits itself to real numbers, but an extra
    <span class="Li">&quot;use&quot;</span> statement brings full complex
    support, along with a full set of mathematical functions typically
    associated with and/or extended to complex numbers.</p>
<p class="Pp">If you wonder what complex numbers are, they were invented to be
    able to solve the following equation:</p>
<p class="Pp"></p>
<pre>        x*x = -1
</pre>
<p class="Pp">and by definition, the solution is noted <i>i</i> (engineers use
    <i>j</i> instead since <i>i</i> usually denotes an intensity, but the name
    does not matter). The number <i>i</i> is a pure <i>imaginary</i> number.</p>
<p class="Pp">The arithmetics with pure imaginary numbers works just like you
    would expect it with real numbers... you just have to remember that</p>
<p class="Pp"></p>
<pre>        i*i = -1
</pre>
<p class="Pp">so you have:</p>
<p class="Pp"></p>
<pre>        5i + 7i = i * (5 + 7) = 12i
        4i - 3i = i * (4 - 3) = i
        4i * 2i = -8
        6i / 2i = 3
        1 / i = -i
</pre>
<p class="Pp">Complex numbers are numbers that have both a real part and an
    imaginary part, and are usually noted:</p>
<p class="Pp"></p>
<pre>        a + bi
</pre>
<p class="Pp">where <span class="Li">&quot;a&quot;</span> is the <i>real</i>
    part and <span class="Li">&quot;b&quot;</span> is the <i>imaginary</i> part.
    The arithmetic with complex numbers is straightforward. You have to keep
    track of the real and the imaginary parts, but otherwise the rules used for
    real numbers just apply:</p>
<p class="Pp"></p>
<pre>        (4 + 3i) + (5 - 2i) = (4 + 5) + i(3 - 2) = 9 + i
        (2 + i) * (4 - i) = 2*4 + 4i -2i -i*i = 8 + 2i + 1 = 9 + 2i
</pre>
<p class="Pp">A graphical representation of complex numbers is possible in a
    plane (also called the <i>complex plane</i>, but it's really a 2D plane).
    The number</p>
<p class="Pp"></p>
<pre>        z = a + bi
</pre>
<p class="Pp">is the point whose coordinates are (a, b). Actually, it would be
    the vector originating from (0, 0) to (a, b). It follows that the addition
    of two complex numbers is a vectorial addition.</p>
<p class="Pp">Since there is a bijection between a point in the 2D plane and a
    complex number (i.e. the mapping is unique and reciprocal), a complex number
    can also be uniquely identified with polar coordinates:</p>
<p class="Pp"></p>
<pre>        [rho, theta]
</pre>
<p class="Pp">where <span class="Li">&quot;rho&quot;</span> is the distance to
    the origin, and <span class="Li">&quot;theta&quot;</span> the angle between
    the vector and the <i>x</i> axis. There is a notation for this using the
    exponential form, which is:</p>
<p class="Pp"></p>
<pre>        rho * exp(i * theta)
</pre>
<p class="Pp">where <i>i</i> is the famous imaginary number introduced above.
    Conversion between this form and the cartesian form <span class="Li">&quot;a
    + bi&quot;</span> is immediate:</p>
<p class="Pp"></p>
<pre>        a = rho * cos(theta)
        b = rho * sin(theta)
</pre>
<p class="Pp">which is also expressed by this formula:</p>
<p class="Pp"></p>
<pre>        z = rho * exp(i * theta) = rho * (cos theta + i * sin theta)
</pre>
<p class="Pp">In other words, it's the projection of the vector onto the
    <i>x</i> and <i>y</i> axes. Mathematicians call <i>rho</i> the <i>norm</i>
    or <i>modulus</i> and <i>theta</i> the <i>argument</i> of the complex
    number. The <i>norm</i> of <span class="Li">&quot;z&quot;</span> is marked
    here as <span class="Li">abs(z)</span>.</p>
<p class="Pp">The polar notation (also known as the trigonometric
    representation) is much more handy for performing multiplications and
    divisions of complex numbers, whilst the cartesian notation is better suited
    for additions and subtractions. Real numbers are on the <i>x</i> axis, and
    therefore <i>y</i> or <i>theta</i> is zero or <i>pi</i>.</p>
<p class="Pp">All the common operations that can be performed on a real number
    have been defined to work on complex numbers as well, and are merely
    <i>extensions</i> of the operations defined on real numbers. This means they
    keep their natural meaning when there is no imaginary part, provided the
    number is within their definition set.</p>
<p class="Pp">For instance, the <span class="Li">&quot;sqrt&quot;</span> routine
    which computes the square root of its argument is only defined for
    non-negative real numbers and yields a non-negative real number (it is an
    application from <b>R+</b> to <b>R+</b>). If we allow it to return a complex
    number, then it can be extended to negative real numbers to become an
    application from <b>R</b> to <b>C</b> (the set of complex numbers):</p>
<p class="Pp"></p>
<pre>        sqrt(x) = x &gt;= 0 ? sqrt(x) : sqrt(-x)*i
</pre>
<p class="Pp">It can also be extended to be an application from <b>C</b> to
    <b>C</b>, whilst its restriction to <b>R</b> behaves as defined above by
    using the following definition:</p>
<p class="Pp"></p>
<pre>        sqrt(z = [r,t]) = sqrt(r) * exp(i * t/2)
</pre>
<p class="Pp">Indeed, a negative real number can be noted
    <span class="Li">&quot;[x,pi]&quot;</span> (the modulus <i>x</i> is always
    non-negative, so <span class="Li">&quot;[x,pi]&quot;</span> is really
    <span class="Li">&quot;-x&quot;</span>, a negative number) and the above
    definition states that</p>
<p class="Pp"></p>
<pre>        sqrt([x,pi]) = sqrt(x) * exp(i*pi/2) = [sqrt(x),pi/2] = sqrt(x)*i
</pre>
<p class="Pp">which is exactly what we had defined for negative real numbers
    above. The <span class="Li">&quot;sqrt&quot;</span> returns only one of the
    solutions: if you want the both, use the
    <span class="Li">&quot;root&quot;</span> function.</p>
<p class="Pp">All the common mathematical functions defined on real numbers that
    are extended to complex numbers share that same property of working <i>as
    usual</i> when the imaginary part is zero (otherwise, it would not be called
    an extension, would it?).</p>
<p class="Pp">A <i>new</i> operation possible on a complex number that is the
    identity for real numbers is called the <i>conjugate</i>, and is noted with
    a horizontal bar above the number, or <span class="Li">&quot;~z&quot;</span>
    here.</p>
<p class="Pp"></p>
<pre>         z = a + bi
        ~z = a - bi
</pre>
<p class="Pp">Simple... Now look:</p>
<p class="Pp"></p>
<pre>        z * ~z = (a + bi) * (a - bi) = a*a + b*b
</pre>
<p class="Pp">We saw that the norm of <span class="Li">&quot;z&quot;</span> was
    noted <span class="Li">abs(z)</span> and was defined as the distance to the
    origin, also known as:</p>
<p class="Pp"></p>
<pre>        rho = abs(z) = sqrt(a*a + b*b)
</pre>
<p class="Pp">so</p>
<p class="Pp"></p>
<pre>        z * ~z = abs(z) ** 2
</pre>
<p class="Pp">If z is a pure real number (i.e. <span class="Li">&quot;b ==
    0&quot;</span>), then the above yields:</p>
<p class="Pp"></p>
<pre>        a * a = abs(a) ** 2
</pre>
<p class="Pp">which is true (<span class="Li">&quot;abs&quot;</span> has the
    regular meaning for real number, i.e. stands for the absolute value). This
    example explains why the norm of <span class="Li">&quot;z&quot;</span> is
    noted <span class="Li">abs(z)</span>: it extends the
    <span class="Li">&quot;abs&quot;</span> function to complex numbers, yet is
    the regular <span class="Li">&quot;abs&quot;</span> we know when the complex
    number actually has no imaginary part... This justifies <i>a posteriori</i>
    our use of the <span class="Li">&quot;abs&quot;</span> notation for the
    norm.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OPERATIONS"><a class="permalink" href="#OPERATIONS">OPERATIONS</a></h1>
<p class="Pp">Given the following notations:</p>
<p class="Pp"></p>
<pre>        z1 = a + bi = r1 * exp(i * t1)
        z2 = c + di = r2 * exp(i * t2)
        z = &lt;any complex or real number&gt;
</pre>
<p class="Pp">the following (overloaded) operations are supported on complex
    numbers:</p>
<p class="Pp"></p>
<pre>        z1 + z2 = (a + c) + i(b + d)
        z1 - z2 = (a - c) + i(b - d)
        z1 * z2 = (r1 * r2) * exp(i * (t1 + t2))
        z1 / z2 = (r1 / r2) * exp(i * (t1 - t2))
        z1 ** z2 = exp(z2 * log z1)
        ~z = a - bi
        abs(z) = r1 = sqrt(a*a + b*b)
        sqrt(z) = sqrt(r1) * exp(i * t/2)
        exp(z) = exp(a) * exp(i * b)
        log(z) = log(r1) + i*t
        sin(z) = 1/2i (exp(i * z1) - exp(-i * z))
        cos(z) = 1/2 (exp(i * z1) + exp(-i * z))
        atan2(y, x) = atan(y / x) # Minding the right quadrant, note the order.
</pre>
<p class="Pp">The definition used for complex arguments of <b>atan2()</b> is</p>
<p class="Pp"></p>
<pre>       -i log((x + iy)/sqrt(x*x+y*y))
</pre>
<p class="Pp">Note that atan2(0, 0) is not well-defined.</p>
<p class="Pp">The following extra operations are supported on both real and
    complex numbers:</p>
<p class="Pp"></p>
<pre>        Re(z) = a
        Im(z) = b
        arg(z) = t
        abs(z) = r
        cbrt(z) = z ** (1/3)
        log10(z) = log(z) / log(10)
        logn(z, n) = log(z) / log(n)
        tan(z) = sin(z) / cos(z)
        csc(z) = 1 / sin(z)
        sec(z) = 1 / cos(z)
        cot(z) = 1 / tan(z)
        asin(z) = -i * log(i*z + sqrt(1-z*z))
        acos(z) = -i * log(z + i*sqrt(1-z*z))
        atan(z) = i/2 * log((i+z) / (i-z))
        acsc(z) = asin(1 / z)
        asec(z) = acos(1 / z)
        acot(z) = atan(1 / z) = -i/2 * log((i+z) / (z-i))
        sinh(z) = 1/2 (exp(z) - exp(-z))
        cosh(z) = 1/2 (exp(z) + exp(-z))
        tanh(z) = sinh(z) / cosh(z) = (exp(z) - exp(-z)) / (exp(z) + exp(-z))
        csch(z) = 1 / sinh(z)
        sech(z) = 1 / cosh(z)
        coth(z) = 1 / tanh(z)
        asinh(z) = log(z + sqrt(z*z+1))
        acosh(z) = log(z + sqrt(z*z-1))
        atanh(z) = 1/2 * log((1+z) / (1-z))
        acsch(z) = asinh(1 / z)
        asech(z) = acosh(1 / z)
        acoth(z) = atanh(1 / z) = 1/2 * log((1+z) / (z-1))
</pre>
<p class="Pp"><i>arg</i>, <i>abs</i>, <i>log</i>, <i>csc</i>, <i>cot</i>,
    <i>acsc</i>, <i>acot</i>, <i>csch</i>, <i>coth</i>, <i>acosech</i>,
    <i>acotanh</i>, have aliases <i>rho</i>, <i>theta</i>, <i>ln</i>,
    <i>cosec</i>, <i>cotan</i>, <i>acosec</i>, <i>acotan</i>, <i>cosech</i>,
    <i>cotanh</i>, <i>acosech</i>, <i>acotanh</i>, respectively.
    <span class="Li">&quot;Re&quot;</span>,
    <span class="Li">&quot;Im&quot;</span>,
    <span class="Li">&quot;arg&quot;</span>,
    <span class="Li">&quot;abs&quot;</span>,
    <span class="Li">&quot;rho&quot;</span>, and
    <span class="Li">&quot;theta&quot;</span> can be used also as mutators. The
    <span class="Li">&quot;cbrt&quot;</span> returns only one of the solutions:
    if you want all three, use the <span class="Li">&quot;root&quot;</span>
    function.</p>
<p class="Pp">The <i>root</i> function is available to compute all the <i>n</i>
    roots of some complex, where <i>n</i> is a strictly positive integer. There
    are exactly <i>n</i> such roots, returned as a list. Getting the number
    mathematicians call <span class="Li">&quot;j&quot;</span> such that:</p>
<p class="Pp"></p>
<pre>        1 + j + j*j = 0;
</pre>
<p class="Pp">is a simple matter of writing:</p>
<p class="Pp"></p>
<pre>        $j = ((root(1, 3))[1];
</pre>
<p class="Pp">The <i>k</i>th root for <span class="Li">&quot;z =
    [r,t]&quot;</span> is given by:</p>
<p class="Pp"></p>
<pre>        (root(z, n))[k] = r**(1/n) * exp(i * (t + 2*k*pi)/n)
</pre>
<p class="Pp">You can return the <i>k</i>th root directly by
    <span class="Li">&quot;root(z, n, k)&quot;</span>, indexing starting from
    <i>zero</i> and ending at <i>n - 1</i>.</p>
<p class="Pp">The <i>spaceship</i> numeric comparison operator, &lt;=&gt;, is
    also defined. In order to ensure its restriction to real numbers is conform
    to what you would expect, the comparison is run on the real part of the
    complex number first, and imaginary parts are compared only when the real
    parts match.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CREATION"><a class="permalink" href="#CREATION">CREATION</a></h1>
<p class="Pp">To create a complex number, use either:</p>
<p class="Pp"></p>
<pre>        $z = Math::Complex-&gt;make(3, 4);
        $z = cplx(3, 4);
</pre>
<p class="Pp">if you know the cartesian form of the number, or</p>
<p class="Pp"></p>
<pre>        $z = 3 + 4*i;
</pre>
<p class="Pp">if you like. To create a number using the polar form, use
  either:</p>
<p class="Pp"></p>
<pre>        $z = Math::Complex-&gt;emake(5, pi/3);
        $x = cplxe(5, pi/3);
</pre>
<p class="Pp">instead. The first argument is the modulus, the second is the
    angle (in radians, the full circle is 2*pi). (Mnemonic:
    <span class="Li">&quot;e&quot;</span> is used as a notation for complex
    numbers in the polar form).</p>
<p class="Pp">It is possible to write:</p>
<p class="Pp"></p>
<pre>        $x = cplxe(-3, pi/4);
</pre>
<p class="Pp">but that will be silently converted into
    <span class="Li">&quot;[3,-3pi/4]&quot;</span>, since the modulus must be
    non-negative (it represents the distance to the origin in the complex
    plane).</p>
<p class="Pp">It is also possible to have a complex number as either argument of
    the <span class="Li">&quot;make&quot;</span>,
    <span class="Li">&quot;emake&quot;</span>,
    <span class="Li">&quot;cplx&quot;</span>, and
    <span class="Li">&quot;cplxe&quot;</span>: the appropriate component of the
    argument will be used.</p>
<p class="Pp"></p>
<pre>        $z1 = cplx(-2,  1);
        $z2 = cplx($z1, 4);
</pre>
<p class="Pp">The <span class="Li">&quot;new&quot;</span>,
    <span class="Li">&quot;make&quot;</span>,
    <span class="Li">&quot;emake&quot;</span>,
    <span class="Li">&quot;cplx&quot;</span>, and
    <span class="Li">&quot;cplxe&quot;</span> will also understand a single
    (string) argument of the forms</p>
<p class="Pp"></p>
<pre>        2-3i
        -3i
        [2,3]
        [2,-3pi/4]
        [2]
</pre>
<p class="Pp">in which case the appropriate cartesian and exponential components
    will be parsed from the string and used to create new complex numbers. The
    imaginary component and the theta, respectively, will default to zero.</p>
<p class="Pp">The <span class="Li">&quot;new&quot;</span>,
    <span class="Li">&quot;make&quot;</span>,
    <span class="Li">&quot;emake&quot;</span>,
    <span class="Li">&quot;cplx&quot;</span>, and
    <span class="Li">&quot;cplxe&quot;</span> will also understand the case of
    no arguments: this means plain zero or (0, 0).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DISPLAYING"><a class="permalink" href="#DISPLAYING">DISPLAYING</a></h1>
<p class="Pp">When printed, a complex number is usually shown under its
    cartesian style <i>a+bi</i>, but there are legitimate cases where the polar
    style <i>[r,t]</i> is more appropriate. The process of converting the
    complex number into a string that can be displayed is known as
    <i>stringification</i>.</p>
<p class="Pp">By calling the class method
    <span class="Li">&quot;Math::Complex::display_format&quot;</span> and
    supplying either <span class="Li">&quot;polar&quot;</span> or
    <span class="Li">&quot;cartesian&quot;</span> as an argument, you override
    the default display style, which is
    <span class="Li">&quot;cartesian&quot;</span>. Not supplying any argument
    returns the current settings.</p>
<p class="Pp">This default can be overridden on a per-number basis by calling
    the <span class="Li">&quot;display_format&quot;</span> method instead. As
    before, not supplying any argument returns the current display style for
    this number. Otherwise whatever you specify will be the new display style
    for <i>this</i> particular number.</p>
<p class="Pp">For instance:</p>
<p class="Pp"></p>
<pre>        use Math::Complex;
        Math::Complex::display_format('polar');
        $j = (root(1, 3))[1];
        print &quot;j = $j\n&quot;;               # Prints &quot;j = [1,2pi/3]&quot;
        $j-&gt;display_format('cartesian');
        print &quot;j = $j\n&quot;;               # Prints &quot;j = -0.5+0.866025403784439i&quot;
</pre>
<p class="Pp">The polar style attempts to emphasize arguments like <i>k*pi/n</i>
    (where <i>n</i> is a positive integer and <i>k</i> an integer within [-9,
    +9]), this is called <i>polar pretty-printing</i>.</p>
<p class="Pp">For the reverse of stringifying, see the
    <span class="Li">&quot;make&quot;</span> and
    <span class="Li">&quot;emake&quot;</span>.</p>
<section class="Ss">
<h2 class="Ss">CHANGED IN PERL 5.6</h2>
<p class="Pp">The <span class="Li">&quot;display_format&quot;</span> class
    method and the corresponding
    <span class="Li">&quot;display_format&quot;</span> object method can now be
    called using a parameter hash instead of just a one parameter.</p>
<p class="Pp">The old display format style, which can have values
    <span class="Li">&quot;cartesian&quot;</span> or
    <span class="Li">&quot;polar&quot;</span>, can be changed using the
    <span class="Li">&quot;style&quot;</span> parameter.</p>
<p class="Pp"></p>
<pre>        $j-&gt;display_format(style =&gt; &quot;polar&quot;);
</pre>
<p class="Pp">The one parameter calling convention also still works.</p>
<p class="Pp"></p>
<pre>        $j-&gt;display_format(&quot;polar&quot;);
</pre>
<p class="Pp">There are two new display parameters.</p>
<p class="Pp">The first one is <span class="Li">&quot;format&quot;</span>, which
    is a <b>sprintf()</b>-style format string to be used for both numeric parts
    of the complex number(s). The is somewhat system-dependent but most often it
    corresponds to <span class="Li">&quot;%.15g&quot;</span>. You can revert to
    the default by setting the <span class="Li">&quot;format&quot;</span> to
    <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp"></p>
<pre>        # the $j from the above example
        $j-&gt;display_format('format' =&gt; '%.5f');
        print &quot;j = $j\n&quot;;               # Prints &quot;j = -0.50000+0.86603i&quot;
        $j-&gt;display_format('format' =&gt; undef);
        print &quot;j = $j\n&quot;;               # Prints &quot;j = -0.5+0.86603i&quot;
</pre>
<p class="Pp">Notice that this affects also the return values of the
    <span class="Li">&quot;display_format&quot;</span> methods: in list context
    the whole parameter hash will be returned, as opposed to only the style
    parameter value. This is a potential incompatibility with earlier versions
    if you have been calling the
    <span class="Li">&quot;display_format&quot;</span> method in list
  context.</p>
<p class="Pp">The second new display parameter is
    <span class="Li">&quot;polar_pretty_print&quot;</span>, which can be set to
    true or false, the default being true. See the previous section for what
    this means.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="USAGE"><a class="permalink" href="#USAGE">USAGE</a></h1>
<p class="Pp">Thanks to overloading, the handling of arithmetics with complex
    numbers is simple and almost transparent.</p>
<p class="Pp">Here are some examples:</p>
<p class="Pp"></p>
<pre>        use Math::Complex;
        $j = cplxe(1, 2*pi/3);  # $j ** 3 == 1
        print &quot;j = $j, j**3 = &quot;, $j ** 3, &quot;\n&quot;;
        print &quot;1 + j + j**2 = &quot;, 1 + $j + $j**2, &quot;\n&quot;;
        $z = -16 + 0*i;                 # Force it to be a complex
        print &quot;sqrt($z) = &quot;, sqrt($z), &quot;\n&quot;;
        $k = exp(i * 2*pi/3);
        print &quot;$j - $k = &quot;, $j - $k, &quot;\n&quot;;
        $z-&gt;Re(3);                      # Re, Im, arg, abs,
        $j-&gt;arg(2);                     # (the last two aka rho, theta)
                                        # can be used also as mutators.
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="CONSTANTS"><a class="permalink" href="#CONSTANTS">CONSTANTS</a></h1>
<section class="Ss">
<h2 class="Ss">PI</h2>
<p class="Pp">The constant <span class="Li">&quot;pi&quot;</span> and some handy
    multiples of it (pi2, pi4, and pip2 (pi/2) and pip4 (pi/4)) are also
    available if separately exported:</p>
<p class="Pp"></p>
<pre>    use Math::Complex ':pi'; 
    $third_of_circle = pi2 / 3;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Inf"><a class="permalink" href="#Inf">Inf</a></h2>
<p class="Pp">The floating point infinity can be exported as a subroutine
    <b>Inf()</b>:</p>
<p class="Pp"></p>
<pre>    use Math::Complex qw(Inf sinh);
    my $AlsoInf = Inf() + 42;
    my $AnotherInf = sinh(1e42);
    print &quot;$AlsoInf is $AnotherInf\n&quot; if $AlsoInf == $AnotherInf;
</pre>
<p class="Pp">Note that the stringified form of infinity varies between
    platforms: it can be for example any of</p>
<p class="Pp"></p>
<pre>   inf
   infinity
   INF
   1.#INF
</pre>
<p class="Pp">or it can be something else.</p>
<p class="Pp">Also note that in some platforms trying to use the infinity in
    arithmetic operations may result in Perl crashing because using an infinity
    causes SIGFPE or its moral equivalent to be sent. The way to ignore this
  is</p>
<p class="Pp"></p>
<pre>  local $SIG{FPE} = sub { };
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ERRORS_DUE_TO_DIVISION_BY_ZERO_OR_LOGARITHM_OF_ZERO"><a class="permalink" href="#ERRORS_DUE_TO_DIVISION_BY_ZERO_OR_LOGARITHM_OF_ZERO">ERRORS
  DUE TO DIVISION BY ZERO OR LOGARITHM OF ZERO</a></h1>
<p class="Pp">The division (/) and the following functions</p>
<p class="Pp"></p>
<pre>        log     ln      log10   logn
        tan     sec     csc     cot
        atan    asec    acsc    acot
        tanh    sech    csch    coth
        atanh   asech   acsch   acoth
</pre>
<p class="Pp">cannot be computed for all arguments because that would mean
    dividing by zero or taking logarithm of zero. These situations cause fatal
    runtime errors looking like this</p>
<p class="Pp"></p>
<pre>        cot(0): Division by zero.
        (Because in the definition of cot(0), the divisor sin(0) is 0)
        Died at ...
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre>        atanh(-1): Logarithm of zero.
        Died at...
</pre>
<p class="Pp">For the <span class="Li">&quot;csc&quot;</span>,
    <span class="Li">&quot;cot&quot;</span>,
    <span class="Li">&quot;asec&quot;</span>,
    <span class="Li">&quot;acsc&quot;</span>,
    <span class="Li">&quot;acot&quot;</span>,
    <span class="Li">&quot;csch&quot;</span>,
    <span class="Li">&quot;coth&quot;</span>,
    <span class="Li">&quot;asech&quot;</span>,
    <span class="Li">&quot;acsch&quot;</span>, the argument cannot be
    <span class="Li">0</span> (zero). For the logarithmic functions and the
    <span class="Li">&quot;atanh&quot;</span>,
    <span class="Li">&quot;acoth&quot;</span>, the argument cannot be
    <span class="Li">1</span> (one). For the
    <span class="Li">&quot;atanh&quot;</span>,
    <span class="Li">&quot;acoth&quot;</span>, the argument cannot be
    <span class="Li">&quot;-1&quot;</span> (minus one). For the
    <span class="Li">&quot;atan&quot;</span>,
    <span class="Li">&quot;acot&quot;</span>, the argument cannot be
    <span class="Li">&quot;i&quot;</span> (the imaginary unit). For the
    <span class="Li">&quot;atan&quot;</span>,
    <span class="Li">&quot;acoth&quot;</span>, the argument cannot be
    <span class="Li">&quot;-i&quot;</span> (the negative imaginary unit). For
    the <span class="Li">&quot;tan&quot;</span>,
    <span class="Li">&quot;sec&quot;</span>,
    <span class="Li">&quot;tanh&quot;</span>, the argument cannot be <i>pi/2 + k
    * pi</i>, where <i>k</i> is any integer. atan2(0, 0) is undefined, and if
    the complex arguments are used for <b>atan2()</b>, a division by zero will
    happen if z1**2+z2**2 == 0.</p>
<p class="Pp">Note that because we are operating on approximations of real
    numbers, these errors can happen when merely `too close' to the
    singularities listed above.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ERRORS_DUE_TO_INDIGESTIBLE_ARGUMENTS"><a class="permalink" href="#ERRORS_DUE_TO_INDIGESTIBLE_ARGUMENTS">ERRORS
  DUE TO INDIGESTIBLE ARGUMENTS</a></h1>
<p class="Pp">The <span class="Li">&quot;make&quot;</span> and
    <span class="Li">&quot;emake&quot;</span> accept both real and complex
    arguments. When they cannot recognize the arguments they will die with error
    messages like the following</p>
<p class="Pp"></p>
<pre>    Math::Complex::make: Cannot take real part of ...
    Math::Complex::make: Cannot take real part of ...
    Math::Complex::emake: Cannot take rho of ...
    Math::Complex::emake: Cannot take theta of ...
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">Saying <span class="Li">&quot;use Math::Complex;&quot;</span>
    exports many mathematical routines in the caller environment and even
    overrides some (<span class="Li">&quot;sqrt&quot;</span>,
    <span class="Li">&quot;log&quot;</span>,
    <span class="Li">&quot;atan2&quot;</span>). This is construed as a feature
    by the Authors, actually... ;-)</p>
<p class="Pp">All routines expect to be given real or complex numbers. Don't
    attempt to use BigFloat, since Perl has currently no rule to disambiguate a
    '+' operation (for instance) between two overloaded entities.</p>
<p class="Pp">In Cray UNICOS there is some strange numerical instability that
    results in <b>root()</b>, <b>cos()</b>, <b>sin()</b>, <b>cosh()</b>,
    <b>sinh()</b>, losing accuracy fast. Beware. The bug may be in UNICOS math
    libs, in UNICOS C compiler, in Math::Complex. Whatever it is, it does not
    manifest itself anywhere else where Perl runs.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Math::Trig</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp">Daniel S. Lewart &lt;<i>lewart!at!uiuc.edu</i>&gt;, Jarkko
    Hietaniemi &lt;<i>jhi!at!iki.fi</i>&gt;, Raphael Manfredi
    &lt;<i>Raphael_Manfredi!at!pobox.com</i>&gt;, Zefram
  &lt;zefram@fysh.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

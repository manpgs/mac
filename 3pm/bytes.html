<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>bytes(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">bytes(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">bytes(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">bytes - Perl pragma to expose the individual bytes of
  characters</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTICE"><a class="permalink" href="#NOTICE">NOTICE</a></h1>
<p class="Pp">Because the bytes pragma breaks encapsulation (i.e. it exposes the
    innards of how the perl executable currently happens to store a string), the
    byte values that result are in an unspecified encoding.</p>
<p class="Pp"><b>Use of this module for anything other than debugging purposes
    is</b> <b>strongly discouraged.</b> If you feel that the functions here
    within might be useful for your application, this possibly indicates a
    mismatch between your mental model of Perl Unicode and the current reality.
    In that case, you may wish to read some of the perl Unicode documentation:
    perluniintro, perlunitut, perlunifaq and perlunicode.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use bytes;
    ... chr(...);       # or bytes::chr
    ... index(...);     # or bytes::index
    ... length(...);    # or bytes::length
    ... ord(...);       # or bytes::ord
    ... rindex(...);    # or bytes::rindex
    ... substr(...);    # or bytes::substr
    no bytes;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Perl's characters are stored internally as sequences of one or
    more bytes. This pragma allows for the examination of the individual bytes
    that together comprise a character.</p>
<p class="Pp">Originally the pragma was designed for the loftier goal of helping
    incorporate Unicode into Perl, but the approach that used it was found to be
    defective, and the one remaining legitimate use is for debugging when you
    need to non-destructively examine characters' individual bytes. Just insert
    this pragma temporarily, and remove it after the debugging is finished.</p>
<p class="Pp">The original usage can be accomplished by explicit (rather than
    this pragma's implicit) encoding using the Encode module:</p>
<p class="Pp"></p>
<pre>    use Encode qw/encode/;
    my $utf8_byte_string   = encode &quot;UTF8&quot;,   $string;
    my $latin1_byte_string = encode &quot;Latin1&quot;, $string;
</pre>
<p class="Pp">Or, if performance is needed and you are only interested in the
    UTF-8 representation:</p>
<p class="Pp"></p>
<pre>    utf8::encode(my $utf8_byte_string = $string);
</pre>
<p class="Pp"><span class="Li">&quot;no bytes&quot;</span> can be used to
    reverse the effect of <span class="Li">&quot;use bytes&quot;</span> within
    the current lexical scope.</p>
<p class="Pp">As an example, when Perl sees <span class="Li">&quot;$x =
    chr(400)&quot;</span>, it encodes the character in UTF-8 and stores it in
    <span class="Li">$x</span>. Then it is marked as character data, so, for
    instance, <span class="Li">&quot;length $x&quot;</span> returns
    <span class="Li">1</span>. However, in the scope of the
    <span class="Li">&quot;bytes&quot;</span> pragma, <span class="Li">$x</span>
    is treated as a series of bytes - the bytes that make up the UTF8 encoding -
    and <span class="Li">&quot;length $x&quot;</span> returns
    <span class="Li">2</span>:</p>
<p class="Pp"></p>
<pre> $x = chr(400);
 print &quot;Length is &quot;, length $x, &quot;\n&quot;;     # &quot;Length is 1&quot;
 printf &quot;Contents are %vd\n&quot;, $x;         # &quot;Contents are 400&quot;
 {
     use bytes; # or &quot;require bytes; bytes::length()&quot;
     print &quot;Length is &quot;, length $x, &quot;\n&quot;; # &quot;Length is 2&quot;
     printf &quot;Contents are %vd\n&quot;, $x;     # &quot;Contents are 198.144 (on
                                          # ASCII platforms)&quot;
 }
</pre>
<p class="Pp"><span class="Li">&quot;chr()&quot;</span>,
    <span class="Li">&quot;ord()&quot;</span>,
    <span class="Li">&quot;substr()&quot;</span>,
    <span class="Li">&quot;index()&quot;</span> and
    <span class="Li">&quot;rindex()&quot;</span> behave similarly.</p>
<p class="Pp">For more on the implications, see perluniintro and
  perlunicode.</p>
<p class="Pp"><span class="Li">&quot;bytes::length()&quot;</span> is admittedly
    handy if you need to know the <b>byte length</b> of a Perl scalar. But a
    more modern way is:</p>
<p class="Pp"></p>
<pre>   use Encode 'encode';
   length(encode('UTF-8', $scalar))
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="LIMITATIONS"><a class="permalink" href="#LIMITATIONS">LIMITATIONS</a></h1>
<p class="Pp"><span class="Li">&quot;bytes::substr()&quot;</span> does not work
    as an <i></i><b><i>lvalue()</i></b><i></i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">perluniintro, perlunicode, utf8, Encode</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os">perl v5.34.1</td>
  </tr>
</table>
</body>
</html>

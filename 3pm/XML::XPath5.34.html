<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>XML::XPath(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">XML::XPath(3)</td>
    <td class="head-vol"><a href=".">User Contributed Perl Documentation</a></td>
    <td class="head-rtitle">XML::XPath(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">XML::XPath - Parse and evaluate XPath statements.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">Version 1.44</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module aims to comply exactly to the XPath specification at
    http://www.w3.org/TR/xpath and yet allow extensions to be added in the form
    of functions.Modules such as XSLT and XPointer may need to do this as they
    support functionality beyond XPath.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use XML::XPath;
    use XML::XPath::XMLParser;
    my $xp = XML::XPath-&gt;new(filename =&gt; 'test.xhtml');
    my $nodeset = $xp-&gt;find('/html/body/p'); # find all paragraphs
    foreach my $node ($nodeset-&gt;get_nodelist) {
        print &quot;FOUND\n\n&quot;,
            XML::XPath::XMLParser::as_string($node),
            &quot;\n\n&quot;;
    }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DETAILS"><a class="permalink" href="#DETAILS">DETAILS</a></h1>
<p class="Pp">There is an awful lot to all of this, so bear with it - if you
    stick it out it should be worth it. Please get a good understanding of XPath
    by reading the spec before asking me questions. All of the classes and parts
    herein are named to be synonymous with the names in the specification, so
    consult that if you don't understand why I'm doing something in the
  code.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<p class="Pp">The API of XML::XPath itself is extremely simple to allow you to
    get going almost immediately. The deeper API's are more complex, but you
    shouldn't have to touch most of that.</p>
<section class="Ss">
<h2 class="Ss"><b>new()</b></h2>
<p class="Pp">This constructor follows the often seen named parameter method
    call. Parameters you can use are: filename, parser, xml, ioref and context.
    The filename parameter specifies an XML file to parse. The xml parameter
    specifies a string to parse, and the ioref parameter specifies an ioref to
    parse. The context option allows you to specify a context node. The context
    node has to be in the format of a node as specified in
    XML::XPath::XMLParser. The 4 parameters filename, xml, ioref and context are
    mutually exclusive - you should only specify one (if you specify anything
    other than context, the context node is the root of your document). The
    parser option allows you to pass in an already prepared XML::Parser object,
    to save you having to create more than one in your application (if, for
    example, you are doing more than just XPath).</p>
<p class="Pp"></p>
<pre>    my $xp = XML::XPath-&gt;new( context =&gt; $node );
</pre>
<p class="Pp">It is very much recommended that you use only 1 XPath object
    throughout the life of your application. This is because the object (and
    it's sub-objects) maintain certain bits of state information that will be
    useful (such as XPath variables) to later calls to <b>find()</b>. It's also
    a good idea because you'll use less memory this way.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="find($path,__$context_)"><a class="permalink" href="#find($path,__$context_)">find($path,
  [$context])</a></h2>
<p class="Pp">The find function takes an XPath expression (a string) and returns
    either an XML::XPath::NodeSet object containing the nodes it found (or empty
    if no nodes matched the path), or one of XML::XPath::Literal (a string),
    XML::XPath::Number or XML::XPath::Boolean. It should always return something
    - and you can use -&gt;<b>isa()</b> to find out what it returned. If you
    need to check how many nodes it found you should check
    <span class="Li">$nodeset</span>-&gt;size. See XML::XPath::NodeSet. An
    optional second parameter of a context node allows you to use this method
    repeatedly, for example XSLT needs to do this.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="findnodes($path,__$context_)"><a class="permalink" href="#findnodes($path,__$context_)">findnodes($path,
  [$context])</a></h2>
<p class="Pp">Returns a list of nodes found by <span class="Li">$path</span>,
    optionally in context <span class="Li">$context</span>. In scalar context
    returns an XML::XPath::NodeSet object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="matches($node,_$path,__$context_)"><a class="permalink" href="#matches($node,_$path,__$context_)">matches($node,
  $path, [$context])</a></h2>
<p class="Pp">Returns true if the node matches the path (optionally in context
    <span class="Li">$context</span>).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="findnodes_as_string($path,__$context_)"><a class="permalink" href="#findnodes_as_string($path,__$context_)">findnodes_as_string($path,
  [$context])</a></h2>
<p class="Pp">Returns the nodes found reproduced as XML.The result isn't
    guaranteed to be valid XML though.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="findvalue($path,__$context_)"><a class="permalink" href="#findvalue($path,__$context_)">findvalue($path,
  [$context])</a></h2>
<p class="Pp">Returns either a
    <span class="Li">&quot;XML::XPath::Literal&quot;</span>, a
    <span class="Li">&quot;XML::XPath::Boolean&quot;</span> or a
    <span class="Li">&quot;XML::XPath::Number&quot;</span> object.If the path
    returns a NodeSet,$nodeset-&gt;to_literal is called automatically for you
    (and thus a <span class="Li">&quot;XML::XPath::Literal&quot;</span> is
    returned).Note that for each of the objects stringification is overloaded,
    so you can just print the value found, or manipulate it in the ways you
    would a normal perl value (e.g. using regular expressions).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="exists($path,__$context_)"><a class="permalink" href="#exists($path,__$context_)">exists($path,
  [$context])</a></h2>
<p class="Pp">Returns true if the given path exists.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="getNodeText($path)"><a class="permalink" href="#getNodeText($path)">getNodeText($path)</a></h2>
<p class="Pp">Returns the XML::XPath::Literal for a particular XML node. Returns
    a string if exists or '' (empty string) if the node doesn't exist.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="setNodeText($path,_$text)"><a class="permalink" href="#setNodeText($path,_$text)">setNodeText($path,
  $text)</a></h2>
<p class="Pp">Sets the text string for a particular XML node. The node can be an
    element or an attribute. If the node to be set is an attribute, and the
    attribute node does not exist, it will be created automatically.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="createNode($path)"><a class="permalink" href="#createNode($path)">createNode($path)</a></h2>
<p class="Pp">Creates the node matching the <span class="Li">$path</span> given.
    If part of the path given or all of the path do not exist, the necessary
    nodes will be created automatically.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="set_namespace($prefix,_$uri)"><a class="permalink" href="#set_namespace($prefix,_$uri)">set_namespace($prefix,
  $uri)</a></h2>
<p class="Pp">Sets the namespace prefix mapping to the uri.</p>
<p class="Pp">Normally in <span class="Li">&quot;XML::XPath&quot;</span> the
    prefixes in XPath node test take their context from the current node. This
    means that foo:bar will always match an element &lt;foo:bar&gt; regardless
    of the namespace that the prefix foo is mapped to (which might even change
    within the document, resulting in unexpected results). In order to make
    prefixes in XPath node tests actually map to a real URI, you need to enable
    that via a call to the set_namespace method of your
    <span class="Li">&quot;XML::XPath&quot;</span> object.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>clear_namespaces()</b></h2>
<p class="Pp">Clears all previously set namespace mappings.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$XML::XPath::Namespaces"><a class="permalink" href="#$XML::XPath::Namespaces">$XML::XPath::Namespaces</a></h2>
<p class="Pp">Set this to 0 if you <i>don't</i> want namespace processing to
    occur. This will make everything a little (tiny) bit faster, but you'll
    suffer for it, probably.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Node_Object_Model"><a class="permalink" href="#Node_Object_Model">Node
  Object Model</a></h1>
<p class="Pp">See XML::XPath::Node, XML::XPath::Node::Element,
    XML::XPath::Node::Text, XML::XPath::Node::Comment,
    XML::XPath::Node::Attribute, XML::XPath::Node::Namespace, and
    XML::XPath::Node::PI.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="On_Garbage_Collection"><a class="permalink" href="#On_Garbage_Collection">On
  Garbage Collection</a></h1>
<p class="Pp">XPath nodes work in a special way that allows circular references,
    and yet still lets Perl's reference counting garbage collector to clean up
    the nodes after use. This should be totally transparent to the user, with
    one caveat: <b>If you free</b> <b>your tree before letting go of a
    sub-tree,consider that playing with fire and you</b> <b>may get burned</b>.
    What does this mean to the average user? Not much. Provided you don't free
    (or let go out of scope) either the tree you passed to XML::XPath-&gt;new,
    or if you didn't pass a tree, and passed a filename or IO-ref, then provided
    you don't let the XML::XPath object go out of scope before you let results
    of <b>find()</b> and its friends go out of scope, then you'll be fine. Even
    if you <b>do</b> let the tree go out of scope before results, you'll
    probably still be fine. The only case where you may get stung is when the
    last part of your path/query is either an ancestor or parent axis. In that
    case the worst that will happen is you'll end up with a circular reference
    that won't get cleared until interpreter destruction time.You can get around
    that by explicitly calling <span class="Li">$node</span>-&gt;DESTROY on each
    of your result nodes, if you really need to do that.</p>
<p class="Pp">Mail me direct if that's not clear. Note that it's not doom and
    gloom. It's by no means perfect,but the worst that will happen is a long
    running process could leak memory. Most long running processes will
    therefore be able to explicitly be careful not to free the tree (or
    XML::XPath object) before freeing results.AxKit, an application that uses
    XML::XPath, does this and I didn't have to make any changes to the code -
    it's already sensible programming.</p>
<p class="Pp">If you <i>really</i> don't want all this to happen, then set the
    variable <span class="Li">$XML::XPath::SafeMode</span>, and call
    <span class="Li">$xp</span>-&gt;<b>cleanup()</b> on the XML::XPath object
    when you're finished, or <span class="Li">$tree</span>-&gt;<b>dispose()</b>
    if you have a tree instead.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Example"><a class="permalink" href="#Example">Example</a></h1>
<p class="Pp">Please see the test files in t/ for examples on how to use
  XPath.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Original author Matt Sergeant, <span class="Li">&quot;&lt;matt at
    sergeant.org&gt;&quot;</span></p>
<p class="Pp">Currently maintained by Mohammad S Anwar,
    <span class="Li">&quot;&lt;mohammad.anwar at yahoo.com&gt;&quot;</span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">XML::XPath::Literal, XML::XPath::Boolean, XML::XPath::Number,
    XML::XPath::XMLParser, XML::XPath::NodeSet, XML::XPath::PerlSAX,
    XML::XPath::Builder.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE_AND_COPYRIGHT"><a class="permalink" href="#LICENSE_AND_COPYRIGHT">LICENSE
  AND COPYRIGHT</a></h1>
<p class="Pp">This module is copyright 2000 AxKit.com Ltd. This is free
    software, and as such comes with NO WARRANTY. No dates are used in this
    module. You may distribute this module under the terms of either the Gnu
    GPL, or the Artistic License (the same terms as Perl itself).</p>
<p class="Pp">For support, please subscribe to the Perl-XML
    &lt;http://listserv.activestate.com/mailman/listinfo/perl-xml&gt; mailing
    list at the URL</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-10-11</td>
    <td class="foot-os"><a href="..">perl v5.34.0</a></td>
  </tr>
</table>
</body>
</html>

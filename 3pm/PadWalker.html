<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PadWalker(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PadWalker(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">PadWalker(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">PadWalker - play with other peoples' lexical variables</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  use PadWalker qw(peek_my peek_our peek_sub closed_over);
  ...
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">PadWalker is a module which allows you to inspect (and even
    change!) lexical variables in any subroutine which called you. It will only
    show those variables which are in scope at the point of the call.</p>
<p class="Pp">PadWalker is particularly useful for debugging. It's even used by
    Perl's built-in debugger. (It can also be used for evil, of course.)</p>
<p class="Pp">I wouldn't recommend using PadWalker directly in production code,
    but it's your call. Some of the modules that use PadWalker internally are
    certainly safe for and useful in production.</p>
<dl class="Bl-tag">
  <dt id="peek_my"><a class="permalink" href="#peek_my">peek_my LEVEL</a></dt>
  <dd></dd>
  <dt id="peek_our"><a class="permalink" href="#peek_our">peek_our
    LEVEL</a></dt>
  <dd>The LEVEL argument is interpreted just like the argument to
      <span class="Li">&quot;caller&quot;</span>. So
      <span class="Li">peek_my(0)</span> returns a reference to a hash of all
      the <span class="Li">&quot;my&quot;</span> variables that are currently in
      scope; <span class="Li">peek_my(1)</span> returns a reference to a hash of
      all the <span class="Li">&quot;my&quot;</span> variables that are in scope
      at the point where the current sub was called, and so on.
    <p class="Pp"><span class="Li">&quot;peek_our&quot;</span> works in the same
        way, except that it lists the <span class="Li">&quot;our&quot;</span>
        variables rather than the <span class="Li">&quot;my&quot;</span>
        variables.</p>
    <p class="Pp">The hash associates each variable name with a reference to its
        value. The variable names include the sigil, so the variable
        <span class="Li">$x</span> is represented by the string '$x'.</p>
    <p class="Pp">For example:</p>
    <p class="Pp"></p>
    <pre>  my $x = 12;
  my $h = peek_my (0);
  ${$h-&gt;{'$x'}}++;
  print $x;  # prints 13
    </pre>
    <p class="Pp">Or a more complex example:</p>
    <p class="Pp"></p>
    <pre>  sub increment_my_x {
    my $h = peek_my (1);
    ${$h-&gt;{'$x'}}++;
  }
  my $x=5;
  increment_my_x;
  print $x;  # prints 6
    </pre>
  </dd>
  <dt id="peek_sub"><a class="permalink" href="#peek_sub">peek_sub SUB</a></dt>
  <dd>The <span class="Li">&quot;peek_sub&quot;</span> routine takes a coderef
      as its argument, and returns a hash of the
      <span class="Li">&quot;my&quot;</span> variables used in that sub. The
      values will usually be undefined unless the sub is in use (i.e. in the
      call-chain) at the time. On the other hand:
    <p class="Pp"></p>
    <pre>  my $x = &quot;Hello!&quot;;
  my $r = peek_sub(sub {$x})-&gt;{'$x'};
  print &quot;$$r\n&quot;;        # prints 'Hello!'
    </pre>
    <p class="Pp">If the sub defines several
        <span class="Li">&quot;my&quot;</span> variables with the same name,
        you'll get the last one. I don't know of any use for
        <span class="Li">&quot;peek_sub&quot;</span> that isn't broken as a
        result of this, and it will probably be deprecated in a future version
        in favour of some alternative interface.</p>
  </dd>
  <dt id="closed_over"><a class="permalink" href="#closed_over">closed_over
    SUB</a></dt>
  <dd><span class="Li">&quot;closed_over&quot;</span> is similar to
      <span class="Li">&quot;peek_sub&quot;</span>, except that it only lists
      the <span class="Li">&quot;my&quot;</span> variables which are used in the
      subroutine but defined outside: in other words, the variables which it
      closes over. This <i>does</i> have reasonable uses: see
      Data::Dump::Streamer, for example (a future version of which may in fact
      use <span class="Li">&quot;closed_over&quot;</span>).</dd>
  <dt id="set_closed_over"><a class="permalink" href="#set_closed_over">set_closed_over
    SUB, HASH_REF</a></dt>
  <dd><span class="Li">&quot;set_closed_over&quot;</span> reassigns the pad
      variables that are closed over by the subroutine.
    <p class="Pp">The second argument is a hash of references, much like the one
        returned from <span class="Li">&quot;closed_over&quot;</span>.</p>
  </dd>
  <dt id="var_name"><a class="permalink" href="#var_name">var_name LEVEL,
    VAR_REF</a></dt>
  <dd></dd>
  <dt id="var_name~2"><a class="permalink" href="#var_name~2">var_name SUB,
    VAR_REF</a></dt>
  <dd><span class="Li">&quot;var_name(sub, var_ref)&quot;</span> returns the
      name of the variable referred to by
      <span class="Li">&quot;var_ref&quot;</span>, provided it is a
      <span class="Li">&quot;my&quot;</span> variable used in the sub. The
      <span class="Li">&quot;sub&quot;</span> parameter can be either a CODE
      reference or a number. If it's a number, it's treated the same way as the
      argument to <span class="Li">&quot;peek_my&quot;</span>.
    <p class="Pp">For example,</p>
    <p class="Pp"></p>
    <pre>  my $foo;
  print var_name(0, \$foo);    # prints '$foo'
  
  sub my_name {
    return var_name(1, shift);
  }
  print my_name(\$foo);        # ditto
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Robin Houston &lt;robin@cpan.org&gt;</p>
<p class="Pp">With contributions from Richard Soberberg, Jesse Luehrs and Yuval
    Kogman, bug-spotting from Peter Scott, Dave Mitchell and Goro Fuji, and
    suggestions from demerphq.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Devel::LexAlias, Devel::Caller, Sub::Parameters</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 2000-2009, Robin Houston. All Rights Reserved. This
    module is free software. It may be used, redistributed and/or modified under
    the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-11-10</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

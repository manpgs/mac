<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>MooseX::Role::Parameterized::Tutorial(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">MooseX::Role::Parameterized::Tutorial(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">MooseX::Role::Parameterized::Tutorial(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">MooseX::Role::Parameterized::Tutorial - why and how</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MOTIVATION"><a class="permalink" href="#MOTIVATION">MOTIVATION</a></h1>
<p class="Pp">Roles are composable units of behavior. They are useful for
    factoring out functionality common to many classes from any part of your
    class hierarchy. See Moose::Cookbook::Roles::Recipe1 for an introduction to
    Moose::Role.</p>
<p class="Pp">While combining roles affords you a great deal of flexibility,
    individual roles have very little in the way of configurability. Core Moose
    provides <span class="Li">&quot;-alias&quot;</span> for renaming methods and
    <span class="Li">&quot;-excludes&quot;</span> for ignoring methods. These
    options are primarily for resolving role conflicts. Depending on how much of
    a purist you are, these options are <i>solely</i> for resolving role
    conflicts. See Moose::Cookbook::Roles::Recipe2 for more about
    <span class="Li">&quot;-alias&quot;</span> and
    <span class="Li">&quot;-excludes&quot;</span>.</p>
<p class="Pp">Because roles serve many different masters, they usually provide
    only the least common denominator of functionality. To empower roles
    further, more configurability than
    <span class="Li">&quot;-alias&quot;</span> and
    <span class="Li">&quot;-excludes&quot;</span> is required. Perhaps your role
    needs to know which method to call when it is done processing. Or what
    default value to use for its <span class="Li">&quot;url&quot;</span>
    attribute.</p>
<p class="Pp">Parameterized roles offer a solution to these (and other) kinds of
    problems.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="USAGE"><a class="permalink" href="#USAGE">USAGE</a></h1>
<p class="Pp"><i></i><i>&quot;with&quot;</i><i></i></p>
<p class="Pp">The syntax of a class consuming a parameterized role has not
    changed from the standard <span class="Li">&quot;with&quot;</span>. You pass
    in parameters just like you pass in
    <span class="Li">&quot;-alias&quot;</span> and
    <span class="Li">&quot;-excludes&quot;</span> to ordinary roles (though your
    custom parameters do not get hyphens, since these are not core Moose
    composition parameters):</p>
<p class="Pp"></p>
<pre>
    with 'MyRole::InstrumentMethod' =&gt; {
        method_name =&gt; 'dbh_do',
        log_to      =&gt; 'query.log',
    };
</pre>
<p class="Pp">You can still combine parameterized roles. You just need to
    specify parameters immediately after the role they belong to:</p>
<p class="Pp"></p>
<pre>
    with (
        'My::Parameterized::Role' =&gt; {
            needs_better_example =&gt; 1,
        },
        'My::Other::Role',
    );
</pre>
<p class="Pp">We, like Moose itself, use Data::OptList to make sure that a list
    of role names and associated parameters is handled correctly.</p>
<p class="Pp"><i></i><i>&quot;parameter&quot;</i><i></i></p>
<p class="Pp">Inside your parameterized role, you specify a set of parameters.
    This is exactly like specifying the attributes of a class. Instead of
    &quot;has&quot; in Moose you use the keyword
    <span class="Li">&quot;parameter&quot;</span>, but your parameters can use
    any options to <span class="Li">&quot;has&quot;</span>.</p>
<p class="Pp"></p>
<pre>
    parameter 'delegation' =&gt; (
        isa       =&gt; 'HashRef|ArrayRef|RegexpRef',
        predicate =&gt; 'has_delegation',
    );
</pre>
<p class="Pp">You do have to declare what parameters you accept, just like you
    have to declare what attributes you accept for regular Moose objects.</p>
<p class="Pp">One departure from <span class="Li">&quot;has&quot;</span> is that
    we create a reader accessor for you by default. In other words, we assume
    <span class="Li">&quot;is =&gt; 'ro'&quot;</span>. We create this reader for
    convenience because generally the parameterized role is the only consumer of
    the parameters object, so data hiding is not as important than in the
    general case of &quot;has&quot; in Moose. If you do not want an accessor,
    you can use <span class="Li">&quot;is =&gt; 'bare'&quot;</span>.</p>
<p class="Pp"><i></i><i>&quot;role&quot;</i><i></i></p>
<p class="Pp"><span class="Li">&quot;role&quot;</span> takes a block of code
    that will be used to generate your role with its parameters bound. Here is
    where you declare components that depend on parameters. You can declare
    attributes, methods, modifiers, etc. The first argument to the
    <span class="Li">&quot;role&quot;</span> is an object containing the
    parameters specified by <span class="Li">&quot;with&quot;</span>. You can
    access the parameters just like regular attributes on that object.</p>
<p class="Pp">Each time you compose this parameterized role, the
    <span class="Li">&quot;role {}&quot;</span> block will be executed. It will
    receive a new parameter object and produce an entirely new role. That's the
    whole point, after all.</p>
<p class="Pp">Due to limitations inherent in Perl, you must declare methods with
    <span class="Li">&quot;method name =&gt; sub { ... }&quot;</span> instead of
    the usual <span class="Li">&quot;sub name { ... }&quot;</span>. Your methods
    may, of course, close over the parameter object. This means that your
    methods may use parameters however they wish!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="USES"><a class="permalink" href="#USES">USES</a></h1>
<p class="Pp">Ideally these will become fully-explained examples in something
    resembling Moose::Cookbook. But for now, only a braindump.</p>
<dl class="Bl-tag">
  <dt id="Configure"><a class="permalink" href="#Configure">Configure a role's
    attributes</a></dt>
  <dd>You can rename methods with core Moose, but now you can rename attributes.
      You can now also choose type, default value, whether it's required,
      <b>traits</b>, etc.
    <p class="Pp"></p>
    <pre>
    parameter traits =&gt; (
        isa     =&gt; 'ArrayRef',
        default =&gt; sub { [] },
    );

    parameter type =&gt; (
        isa     =&gt; 'Str',
        default =&gt; 'Any',
    );

    role {
        my $p = shift;

        has action =&gt; (
            traits =&gt; $p-&gt;traits,
            isa    =&gt; $p-&gt;type,
            ...
        );
    }
    </pre>
  </dd>
  <dt id="Inform"><a class="permalink" href="#Inform">Inform a role of your
    class' attributes and methods</a></dt>
  <dd>Core roles can only require methods with specific names chosen by the
      role. Now your roles can demand that the class specifies a method name you
      wish the role to instrument, or which attributes to dump to a file.
    <p class="Pp"></p>
    <pre>
    parameter instrument_method =&gt; (
        isa      =&gt; 'Str',
        required =&gt; 1,
    );

    role {
        my $p = shift;
        around $p-&gt;instrument_method =&gt; sub { ... };
    }
    </pre>
  </dd>
  <dt id="Arbitrary"><a class="permalink" href="#Arbitrary">Arbitrary execution
    choices</a></dt>
  <dd>Your role may be able to provide configuration in how the role's methods
      operate. For example, you can tell the role whether to save intermediate
      states.
    <p class="Pp"></p>
    <pre>
    parameter save_intermediate =&gt; (
        isa     =&gt; 'Bool',
        default =&gt; 0,
    );

    role {
        my $p = shift;
        method process =&gt; sub {
            ...
            if ($p-&gt;save_intermediate) { ... }
            ...
        };
    }
    </pre>
  </dd>
  <dt id="Deciding"><a class="permalink" href="#Deciding">Deciding a
    backend</a></dt>
  <dd>Your role may be able to freeze and thaw your instances using YAML, JSON,
      Storable. Which backend to use can be a parameter.
    <p class="Pp"></p>
    <pre>
    parameter format =&gt; (
        isa     =&gt; (enum ['Storable', 'YAML', 'JSON']),
        default =&gt; 'Storable',
    );

    role {
        my $p = shift;
        if ($p-&gt;format eq 'Storable') {
            method freeze =&gt; \&amp;Storable::freeze;
            method thaw   =&gt; \&amp;Storable::thaw;
        }
        elsif ($p-&gt;format eq 'YAML') {
            method freeze =&gt; \&amp;YAML::Dump;
            method thaw   =&gt; \&amp;YAML::Load;
        }
        ...
    }
    </pre>
  </dd>
  <dt id="Additional"><a class="permalink" href="#Additional">Additional
    validation</a></dt>
  <dd>Ordinary roles can require that its consumers have a particular list of
      method names. Since parameterized roles have direct access to its
      consumer, you can inspect it and throw errors if the consumer does not
      meet your needs.
    <p class="Pp"></p>
    <pre>
    role {
        my $p    = shift;
        my %args = @_;
        my $consumer = $args{consumer};

        $consumer-&gt;find_attribute_by_name('stack')
            or confess &quot;You must have a 'stack' attribute&quot;;

        my $push = $consumer-&gt;find_method_by_name('push')
            or confess &quot;You must have a 'push' method&quot;;

        my $params = $push-&gt;parsed_signature-&gt;positional_params-&gt;params;
        @$params == 1
            or confess &quot;Your push method must take a single parameter&quot;;

        $params-&gt;[0]-&gt;sigil eq '$'
            or confess &quot;Your push parameter must be a scalar&quot;;

        ...
    }
    </pre>
  </dd>
</dl>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2012-08-14</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

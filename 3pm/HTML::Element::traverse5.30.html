<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>HTML::Element::traverse(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">HTML::Element::traverse(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">HTML::Element::traverse(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">HTML::Element::traverse - discussion of HTML::Element's traverse
    method</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">This document describes version 5.07 of HTML::Element::traverse,
    released August 31, 2017 as part of HTML-Tree.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  # $element-&gt;traverse is unnecessary and obscure.
  #   Don't use it in new code.
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><span class="Li">&quot;HTML::Element&quot;</span> provides a
    method <span class="Li">&quot;traverse&quot;</span> that traverses the tree
    and calls user-specified callbacks for each node, in pre- or post-order.
    However, use of the method is quite superfluous: if you want to recursively
    visit every node in the tree, it's almost always simpler to write a
    subroutine does just that, than it is to bundle up the pre- and/or
    post-order code in callbacks for the
    <span class="Li">&quot;traverse&quot;</span> method.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">Suppose you want to traverse at/under a node
    <span class="Li">$tree</span> and give elements an 'id' attribute unless
    they already have one.</p>
<p class="Pp">You can use the <span class="Li">&quot;traverse&quot;</span>
    method:</p>
<p class="Pp"></p>
<pre>  {
    my $counter = 'x0000';
    $start_node-&gt;traverse(
      [ # Callbacks;
        # pre-order callback:
        sub {
          my $x = $_[0];
          $x-&gt;attr('id', $counter++) unless defined $x-&gt;attr('id');
          return HTML::Element::OK; # keep traversing
        },
        # post-order callback:
        undef
      ],
      1, # don't call the callbacks for text nodes
    );
  }
</pre>
<p class="Pp">or you can just be simple and clear (and not have to understand
    the calling format for <span class="Li">&quot;traverse&quot;</span>) by
    writing a sub that traverses the tree by just calling itself:</p>
<p class="Pp"></p>
<pre>  {
    my $counter = 'x0000';
    sub give_id {
      my $x = $_[0];
      $x-&gt;attr('id', $counter++) unless defined $x-&gt;attr('id');
      foreach my $c ($x-&gt;content_list) {
        give_id($c) if ref $c; # ignore text nodes
      }
    };
    give_id($start_node);
  }
</pre>
<p class="Pp">See, isn't that nice and clear?</p>
<p class="Pp">But, if you really need to know:</p>
</section>
<section class="Sh">
<h1 class="Sh" id="THE_TRAVERSE_METHOD"><a class="permalink" href="#THE_TRAVERSE_METHOD">THE
  TRAVERSE METHOD</a></h1>
<p class="Pp">The <span class="Li">&quot;traverse()&quot;</span> method is a
    general object-method for traversing a tree or subtree and calling
    user-specified callbacks. It accepts the following syntaxes:</p>
<dl class="Bl-tag">
  <dt>$h-&gt;traverse(\&amp;callback)</dt>
  <dd></dd>
  <dt id="or"><a class="permalink" href="#or">or $h-&gt;traverse(\&amp;callback,
    $ignore_text)</a></dt>
  <dd></dd>
  <dt id="or~2"><a class="permalink" href="#or~2">or $h-&gt;traverse(
    [\&amp;pre_callback,\&amp;post_callback] , $ignore_text)</a></dt>
  <dd></dd>
</dl>
<p class="Pp">These all mean to traverse the element and all of its children.
    That is, this method starts at node <span class="Li">$h</span>,
    &quot;pre-order visits&quot; <span class="Li">$h</span>, traverses its
    children, and then will &quot;post-order visit&quot;
    <span class="Li">$h</span>. &quot;Visiting&quot; means that the callback
    routine is called, with these arguments:</p>
<p class="Pp"></p>
<pre>    $_[0] : the node (element or text segment),
    $_[1] : a startflag, and
    $_[2] : the depth
</pre>
<p class="Pp">If the <span class="Li">$ignore_text</span> parameter is given and
    true, then the pre-order call <i>will not</i> be happen for text
  content.</p>
<p class="Pp">The startflag is 1 when we enter a node (i.e., in pre-order calls)
    and 0 when we leave the node (in post-order calls).</p>
<p class="Pp">Note, however, that post-order calls don't happen for nodes that
    are text segments or are elements that are prototypically empty (like
    &quot;br&quot;, &quot;hr&quot;, etc.).</p>
<p class="Pp">If we visit text nodes (i.e., unless
    <span class="Li">$ignore_text</span> is given and true), then when text
    nodes are visited, we will also pass two extra arguments to the
  callback:</p>
<p class="Pp"></p>
<pre>    $_[3] : the element that's the parent
             of this text node
    $_[4] : the index of this text node
             in its parent's content list
</pre>
<p class="Pp">Note that you can specify that the pre-order routine can be a
    different routine from the post-order one:</p>
<p class="Pp"></p>
<pre>    $h-&gt;traverse( [\&amp;pre_callback,\&amp;post_callback], ...);
</pre>
<p class="Pp">You can also specify that no post-order calls are to be made, by
    providing a false value as the post-order routine:</p>
<p class="Pp"></p>
<pre>    $h-&gt;traverse([ \&amp;pre_callback,0 ], ...);
</pre>
<p class="Pp">And similarly for suppressing pre-order callbacks:</p>
<p class="Pp"></p>
<pre>    $h-&gt;traverse([ 0,\&amp;post_callback ], ...);
</pre>
<p class="Pp">Note that these two syntaxes specify the same operation:</p>
<p class="Pp"></p>
<pre>    $h-&gt;traverse([\&amp;foo,\&amp;foo], ...);
    $h-&gt;traverse( \&amp;foo       , ...);
</pre>
<p class="Pp">The return values from calls to your pre- or post-order routines
    are significant, and are used to control recursion into the tree.</p>
<p class="Pp">These are the values you can return, listed in descending order of
    my estimation of their usefulness:</p>
<dl class="Bl-tag">
  <dt id="HTML::Element::OK,"><a class="permalink" href="#HTML::Element::OK,">HTML::Element::OK,
    1, or any other true value</a></dt>
  <dd>...to keep on traversing.
    <p class="Pp">Note that
        <span class="Li">&quot;HTML::Element::OK&quot;</span> et al are
        constants. So if you're running under <span class="Li">&quot;use
        strict&quot;</span> (as I hope you are), and you say:
        <span class="Li">&quot;return HTML::Element::PRUEN&quot;</span> the
        compiler will flag this as an error (an unallowable bareword,
        specifically), whereas if you spell PRUNE correctly, the compiler will
        not complain.</p>
  </dd>
  <dt id="undef,"><a class="permalink" href="#undef,">undef, 0, '0', '', or
    HTML::Element::PRUNE</a></dt>
  <dd>...to block traversing under the current element's content. (This is
      ignored if received from a post-order callback, since by then the
      recursion has already happened.) If this is returned by a pre-order
      callback, no post-order callback for the current node will happen. (Recall
      that if your callback exits with just
      <span class="Li">&quot;return;&quot;</span>, it is returning undef -- at
      least in scalar context, and <span class="Li">&quot;traverse&quot;</span>
      always calls your callbacks in scalar context.)</dd>
  <dt id="HTML::Element::ABORT"><a class="permalink" href="#HTML::Element::ABORT">HTML::Element::ABORT</a></dt>
  <dd>...to abort the whole traversal immediately. This is often useful when
      you're looking for just the first node in the tree that meets some
      criterion of yours.</dd>
  <dt id="HTML::Element::PRUNE_UP"><a class="permalink" href="#HTML::Element::PRUNE_UP">HTML::Element::PRUNE_UP</a></dt>
  <dd>...to abort continued traversal into this node and its parent node. No
      post-order callback for the current or parent node will happen.</dd>
  <dt id="HTML::Element::PRUNE_SOFTLY"><a class="permalink" href="#HTML::Element::PRUNE_SOFTLY">HTML::Element::PRUNE_SOFTLY</a></dt>
  <dd>Like PRUNE, except that the post-order call for the current node is not
      blocked.</dd>
</dl>
<p class="Pp">Almost every task to do with extracting information from a tree
    can be expressed in terms of traverse operations (usually in only one pass,
    and usually paying attention to only pre-order, or to only post-order), or
    operations based on traversing. (In fact, many of the other methods in this
    class are basically calls to <b>traverse()</b> with particular
  arguments.)</p>
<p class="Pp">The source code for HTML::Element and HTML::TreeBuilder contain
    several examples of the use of the &quot;traverse&quot; method to gather
    information about the content of trees and subtrees.</p>
<p class="Pp">(Note: you should not change the structure of a tree <i>while</i>
    you are traversing it.)</p>
<p class="Pp">[End of documentation for the
    <span class="Li">&quot;traverse()&quot;</span> method]</p>
<section class="Ss">
<h2 class="Ss" id="Traversing_with_Recursive_Anonymous_Routines"><a class="permalink" href="#Traversing_with_Recursive_Anonymous_Routines">Traversing
  with Recursive Anonymous Routines</a></h2>
<p class="Pp">Now, if you've been reading <i>Structure and Interpretation of
    Computer Programs</i> too much, maybe you even want a recursive lambda. Go
    ahead:</p>
<p class="Pp"></p>
<pre>  {
    my $counter = 'x0000';
    my $give_id;
    $give_id = sub {
      my $x = $_[0];
      $x-&gt;attr('id', $counter++) unless defined $x-&gt;attr('id');
      foreach my $c ($x-&gt;content_list) {
        $give_id-&gt;($c) if ref $c; # ignore text nodes
      }
    };
    $give_id-&gt;($start_node);
    undef $give_id;
  }
</pre>
<p class="Pp">It's a bit nutty, and it's <i>still</i> more concise than a call
    to the <span class="Li">&quot;traverse&quot;</span> method!</p>
<p class="Pp">It is left as an exercise to the reader to figure out how to do
    the same thing without using a <span class="Li">$give_id</span> symbol at
    all.</p>
<p class="Pp">It is also left as an exercise to the reader to figure out why I
    undefine <span class="Li">$give_id</span>, above; and why I could achieved
    the same effect with any of:</p>
<p class="Pp"></p>
<pre>    $give_id = 'I like pie!';
   # or...
    $give_id = [];
   # or even;
    $give_id = sub { print &quot;Mmmm pie!\n&quot; };
</pre>
<p class="Pp">But not:</p>
<p class="Pp"></p>
<pre>    $give_id = sub { print &quot;I'm $give_id and I like pie!\n&quot; };
   # nor...
    $give_id = \$give_id;
   # nor...
    $give_id = { 'pie' =&gt; \$give_id, 'mode' =&gt; 'a la' };
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Doing_Recursive_Things_Iteratively"><a class="permalink" href="#Doing_Recursive_Things_Iteratively">Doing
  Recursive Things Iteratively</a></h2>
<p class="Pp">Note that you may at times see an iterative implementation of
    pre-order traversal, like so:</p>
<p class="Pp"></p>
<pre>   {
     my @to_do = ($tree); # start-node
     while(@to_do) {
       my $this = shift @to_do;
       # &quot;Visit&quot; the node:
       $this-&gt;attr('id', $counter++)
        unless defined $this-&gt;attr('id');
       unshift @to_do, grep ref $_, $this-&gt;content_list;
        # Put children on the stack -- they'll be visited next
     }
   }
</pre>
<p class="Pp">This can <i>under certain circumstances</i> be more efficient than
    just a normal recursive routine, but at the cost of being rather obscure. It
    gains efficiency by avoiding the overhead of function-calling, but since
    there are several method dispatches however you do it (to
    <span class="Li">&quot;attr&quot;</span> and
    <span class="Li">&quot;content_list&quot;</span>), the overhead for a simple
    function call is insignificant.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Pruning_and_Whatnot"><a class="permalink" href="#Pruning_and_Whatnot">Pruning
  and Whatnot</a></h2>
<p class="Pp">The <span class="Li">&quot;traverse&quot;</span> method does have
    the fairly neat features of the <span class="Li">&quot;ABORT&quot;</span>,
    <span class="Li">&quot;PRUNE_UP&quot;</span> and
    <span class="Li">&quot;PRUNE_SOFTLY&quot;</span> signals. None of these can
    be implemented <i>totally</i> straightforwardly with recursive routines, but
    it is quite possible. <span class="Li">&quot;ABORT&quot;</span>-like
    behavior can be implemented either with using non-local returning with
    <span class="Li">&quot;eval&quot;</span>/<span class="Li">&quot;die&quot;</span>:</p>
<p class="Pp"></p>
<pre>  my $died_on; # if you need to know where...
  sub thing {
    ... visits $_[0]...
    ... maybe set $died_on to $_[0] and die &quot;ABORT_TRAV&quot; ...
    ... else call thing($child) for each child...
    ...any post-order visiting $_[0]...
  }
  eval { thing($node) };
  if($@) {
    if($@ =~ m&lt;^ABORT_TRAV&gt;) {
      ...it died (aborted) on $died_on...
    } else {
      die $@; # some REAL error happened
    }
  }
</pre>
<p class="Pp">or you can just do it with flags:</p>
<p class="Pp"></p>
<pre>  my($abort_flag, $died_on);
  sub thing {
    ... visits $_[0]...
    ... maybe set $abort_flag = 1; $died_on = $_[0]; return;
    foreach my $c ($_[0]-&gt;content_list) {
      thing($c);
      return if $abort_flag;
    }
    ...any post-order visiting $_[0]...
    return;
  }
  $abort_flag = $died_on = undef;
  thing($node);
  ...if defined $abort_flag, it died on $died_on
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">HTML::Element</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Current maintainers:</p>
<ul class="Bl-bullet">
  <li>Christopher J. Madsen
      <span class="Li">&quot;&lt;perl&#x00A0;AT&#x00A0;cjmweb.net&gt;&quot;</span></li>
  <li>Jeff Fearn
      <span class="Li">&quot;&lt;jfearn&#x00A0;AT&#x00A0;cpan.org&gt;&quot;</span></li>
</ul>
<p class="Pp">Original HTML-Tree author:</p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>Gisle Aas</dd>
</dl>
<p class="Pp">Former maintainers:</p>
<ul class="Bl-bullet">
  <li>Sean M. Burke</li>
  <li>Andy Lester</li>
  <li>Pete Krawczyk
      <span class="Li">&quot;&lt;petek&#x00A0;AT&#x00A0;cpan.org&gt;&quot;</span></li>
</ul>
<p class="Pp">You can follow or contribute to HTML-Tree's development at
    &lt;https://github.com/kentfredric/HTML-Tree&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 2000,2001 Sean M. Burke</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2024-02-10</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

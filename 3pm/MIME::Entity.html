<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>MIME::Entity(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">MIME::Entity(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">MIME::Entity(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">MIME::Entity - class for parsed-and-decoded MIME message</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">Before reading further, you should see MIME::Tools to make sure
    that you understand where this module fits into the grand scheme of things.
    Go on, do it now. I'll wait.</p>
<p class="Pp">Ready? Ok...</p>
<p class="Pp"></p>
<pre>    ### Create an entity:
    $top = MIME::Entity-&gt;build(From    =&gt; 'me@myhost.com',
                               To      =&gt; 'you@yourhost.com',
                               Subject =&gt; &quot;Hello, nurse!&quot;,
                               Data    =&gt; \@my_message);
    ### Attach stuff to it:
    $top-&gt;attach(Path     =&gt; $gif_path,
                 Type     =&gt; &quot;image/gif&quot;,
                 Encoding =&gt; &quot;base64&quot;);
    ### Sign it:
    $top-&gt;sign;
    ### Output it:
    $top-&gt;print(\*STDOUT);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">A subclass of <b>Mail::Internet</b>.</p>
<p class="Pp">This package provides a class for representing MIME message
    entities, as specified in RFCs 2045, 2046, 2047, 2048 and 2049.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Construction_examples"><a class="permalink" href="#Construction_examples">Construction
  examples</a></h2>
<p class="Pp">Create a document for an ordinary 7-bit ASCII text file (lots of
    stuff is defaulted for us):</p>
<p class="Pp"></p>
<pre>    $ent = MIME::Entity-&gt;build(Path=&gt;&quot;english-msg.txt&quot;);
</pre>
<p class="Pp">Create a document for a text file with 8-bit (Latin-1)
  characters:</p>
<p class="Pp"></p>
<pre>    $ent = MIME::Entity-&gt;build(Path     =&gt;&quot;french-msg.txt&quot;,
                               Encoding =&gt;&quot;quoted-printable&quot;,
                               From     =&gt;'jean.luc@inria.fr',
                               Subject  =&gt;&quot;C'est bon!&quot;);
</pre>
<p class="Pp">Create a document for a GIF file (the description is completely
    optional; note that we have to specify content-type and encoding since
    they're not the default values):</p>
<p class="Pp"></p>
<pre>    $ent = MIME::Entity-&gt;build(Description =&gt; &quot;A pretty picture&quot;,
                               Path        =&gt; &quot;./docs/mime-sm.gif&quot;,
                               Type        =&gt; &quot;image/gif&quot;,
                               Encoding    =&gt; &quot;base64&quot;);
</pre>
<p class="Pp">Create a document that you already have the text for, using
    &quot;Data&quot;:</p>
<p class="Pp"></p>
<pre>    $ent = MIME::Entity-&gt;build(Type        =&gt; &quot;text/plain&quot;,
                               Encoding    =&gt; &quot;quoted-printable&quot;,
                               Data        =&gt; [&quot;First line.\n&quot;,
                                              &quot;Second line.\n&quot;,
                                              &quot;Last line.\n&quot;]);
</pre>
<p class="Pp">Create a multipart message, with the entire structure given
    explicitly:</p>
<p class="Pp"></p>
<pre>    ### Create the top-level, and set up the mail headers:
    $top = MIME::Entity-&gt;build(Type     =&gt; &quot;multipart/mixed&quot;,
                               From     =&gt; 'me@myhost.com',
                               To       =&gt; 'you@yourhost.com',
                               Subject  =&gt; &quot;Hello, nurse!&quot;);
    ### Attachment #1: a simple text document:
    $top-&gt;attach(Path=&gt;&quot;./testin/short.txt&quot;);
    ### Attachment #2: a GIF file:
    $top-&gt;attach(Path        =&gt; &quot;./docs/mime-sm.gif&quot;,
                 Type        =&gt; &quot;image/gif&quot;,
                 Encoding    =&gt; &quot;base64&quot;);
    ### Attachment #3: text we'll create with text we have on-hand:
    $top-&gt;attach(Data =&gt; $contents);
</pre>
<p class="Pp">Suppose you don't know ahead of time that you'll have attachments?
    No problem: you can &quot;attach&quot; to singleparts as well:</p>
<p class="Pp"></p>
<pre>    $top = MIME::Entity-&gt;build(From    =&gt; 'me@myhost.com',
                               To      =&gt; 'you@yourhost.com',
                               Subject =&gt; &quot;Hello, nurse!&quot;,
                               Data    =&gt; \@my_message);
    if ($GIF_path) {
        $top-&gt;attach(Path     =&gt; $GIF_path,
                     Type     =&gt; 'image/gif');
    }
</pre>
<p class="Pp">Copy an entity (headers, parts... everything but external body
    data):</p>
<p class="Pp"></p>
<pre>    my $deepcopy = $top-&gt;dup;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Access_examples"><a class="permalink" href="#Access_examples">Access
  examples</a></h2>
<pre>    ### Get the head, a MIME::Head:
    $head = $ent-&gt;head;
    ### Get the body, as a MIME::Body;
    $bodyh = $ent-&gt;bodyhandle;
    ### Get the intended MIME type (as declared in the header):
    $type = $ent-&gt;mime_type;
    ### Get the effective MIME type (in case decoding failed):
    $eff_type = $ent-&gt;effective_type;
    ### Get preamble, parts, and epilogue:
    $preamble   = $ent-&gt;preamble;          ### ref to array of lines
    $num_parts  = $ent-&gt;parts;
    $first_part = $ent-&gt;parts(0);          ### an entity
    $epilogue   = $ent-&gt;epilogue;          ### ref to array of lines
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Manipulation_examples"><a class="permalink" href="#Manipulation_examples">Manipulation
  examples</a></h2>
<p class="Pp">Muck about with the body data:</p>
<p class="Pp"></p>
<pre>    ### Read the (unencoded) body data:
    if ($io = $ent-&gt;open(&quot;r&quot;)) {
        while (defined($_ = $io-&gt;getline)) { print $_ }
        $io-&gt;close;
    }
    ### Write the (unencoded) body data:
    if ($io = $ent-&gt;open(&quot;w&quot;)) {
        foreach (@lines) { $io-&gt;print($_) }
        $io-&gt;close;
    }
    ### Delete the files for any external (on-disk) data:
    $ent-&gt;purge;
</pre>
<p class="Pp">Muck about with the signature:</p>
<p class="Pp"></p>
<pre>    ### Sign it (automatically removes any existing signature):
    $top-&gt;sign(File=&gt;&quot;$ENV{HOME}/.signature&quot;);
    ### Remove any signature within 15 lines of the end:
    $top-&gt;remove_sig(15);
</pre>
<p class="Pp">Muck about with the headers:</p>
<p class="Pp"></p>
<pre>    ### Compute content-lengths for singleparts based on bodies:
    ###   (Do this right before you print!)
    $entity-&gt;sync_headers(Length=&gt;'COMPUTE');
</pre>
<p class="Pp">Muck about with the structure:</p>
<p class="Pp"></p>
<pre>    ### If a 0- or 1-part multipart, collapse to a singlepart:
    $top-&gt;make_singlepart;
    ### If a singlepart, inflate to a multipart with 1 part:
    $top-&gt;make_multipart;
</pre>
<p class="Pp">Delete parts:</p>
<p class="Pp"></p>
<pre>    ### Delete some parts of a multipart message:
    my @keep = grep { keep_part($_) } $msg-&gt;parts;
    $msg-&gt;parts(\@keep);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Output_examples"><a class="permalink" href="#Output_examples">Output
  examples</a></h2>
<p class="Pp">Print to filehandles:</p>
<p class="Pp"></p>
<pre>    ### Print the entire message:
    $top-&gt;print(\*STDOUT);
    ### Print just the header:
    $top-&gt;print_header(\*STDOUT);
    ### Print just the (encoded) body... includes parts as well!
    $top-&gt;print_body(\*STDOUT);
</pre>
<p class="Pp">Stringify... note that
    <span class="Li">&quot;stringify_xx&quot;</span> can also be written
    <span class="Li">&quot;xx_as_string&quot;</span>; the methods are
    synonymous, and neither form will be deprecated.</p>
<p class="Pp">If you set the variable
    <span class="Li">$MIME::Entity::BOUNDARY_DELIMITER</span> to a string, that
    string will be used as the line-end delimiter on output. If it is not set,
    the line ending will be a newline character (\n)</p>
<p class="Pp">NOTE that
    <span class="Li">$MIME::Entity::BOUNDARY_DELIMITER</span> only applies to
    structural parts of the MIME data generated by this package and to the
    Base64 encoded output; if a part internally uses a different line-end
    delimiter and is output as-is, the line-ending is not changed to match
    <span class="Li">$MIME::Entity::BOUNDARY_DELIMITER</span>.</p>
<p class="Pp"></p>
<pre>    ### Stringify the entire message:
    print $top-&gt;stringify;              ### or $top-&gt;as_string
    ### Stringify just the header:
    print $top-&gt;stringify_header;       ### or $top-&gt;header_as_string
    ### Stringify just the (encoded) body... includes parts as well!
    print $top-&gt;stringify_body;         ### or $top-&gt;body_as_string
</pre>
<p class="Pp">Debug:</p>
<p class="Pp"></p>
<pre>    ### Output debugging info:
    $entity-&gt;dump_skeleton(\*STDERR);
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="PUBLIC_INTERFACE"><a class="permalink" href="#PUBLIC_INTERFACE">PUBLIC
  INTERFACE</a></h1>
<section class="Ss">
<h2 class="Ss" id="Construction"><a class="permalink" href="#Construction">Construction</a></h2>
<dl class="Bl-tag">
  <dt id="new"><a class="permalink" href="#new">new [SOURCE]</a></dt>
  <dd><i>Class method.</i> Create a new, empty MIME entity. Basically, this uses
      the Mail::Internet constructor...
    <p class="Pp">If SOURCE is an ARRAYREF, it is assumed to be an array of
        lines that will be used to create both the header and an in-core
      body.</p>
    <p class="Pp">Else, if SOURCE is defined, it is assumed to be a filehandle
        from which the header and in-core body is to be read.</p>
    <p class="Pp"><b>Note:</b> in either case, the body will not be
        <i>parsed:</i> merely read!</p>
  </dd>
  <dt id="add_part"><a class="permalink" href="#add_part">add_part ENTITY,
    [OFFSET]</a></dt>
  <dd><i>Instance method.</i> Assuming we are a multipart message, add a body
      part (a MIME::Entity) to the array of body parts. Returns the part that
      was just added.
    <p class="Pp">If OFFSET is positive, the new part is added at that offset
        from the beginning of the array of parts. If it is negative, it counts
        from the end of the array. (An INDEX of -1 will place the new part at
        the very end of the array, -2 will place it as the penultimate item in
        the array, etc.) If OFFSET is not given, the new part is added to the
        end of the array. <i>Thanks to Jason L Tibbitts III for providing
        support for OFFSET.</i></p>
    <p class="Pp"><b>Warning:</b> in general, you only want to attach parts to
        entities with a content-type of
        <span class="Li">&quot;multipart/*&quot;</span>).</p>
  </dd>
  <dt id="attach"><a class="permalink" href="#attach">attach PARAMHASH</a></dt>
  <dd><i>Instance method.</i> The real quick-and-easy way to create multipart
      messages. The PARAMHASH is used to
      <span class="Li">&quot;build&quot;</span> a new entity; this method is
      basically equivalent to:
    <p class="Pp"></p>
    <pre>    $entity-&gt;add_part(ref($entity)-&gt;build(PARAMHASH, Top=&gt;0));
    </pre>
    <p class="Pp"><b>Note:</b> normally, you attach to multipart entities;
        however, if you attach something to a singlepart (like attaching a GIF
        to a text message), the singlepart will be coerced into a multipart
        automatically.</p>
  </dd>
  <dt id="build"><a class="permalink" href="#build">build PARAMHASH</a></dt>
  <dd><i>Class/instance method.</i> A quick-and-easy catch-all way to create an
      entity. Use it like this to build a &quot;normal&quot; single-part entity:
    <p class="Pp"></p>
    <pre>   $ent = MIME::Entity-&gt;build(Type     =&gt; &quot;image/gif&quot;,
                              Encoding =&gt; &quot;base64&quot;,
                              Path     =&gt; &quot;/path/to/xyz12345.gif&quot;,
                              Filename =&gt; &quot;saveme.gif&quot;,
                              Disposition =&gt; &quot;attachment&quot;);
    </pre>
    <p class="Pp">And like this to build a &quot;multipart&quot; entity:</p>
    <p class="Pp"></p>
    <pre>   $ent = MIME::Entity-&gt;build(Type     =&gt; &quot;multipart/mixed&quot;,
                              Boundary =&gt; &quot;---1234567&quot;);
    </pre>
    <p class="Pp">A minimal MIME header will be created. If you want to add or
        modify any header fields afterwards, you can of course do so via the
        underlying head object... but hey, there's now a prettier syntax!</p>
    <p class="Pp"></p>
    <pre>   $ent = MIME::Entity-&gt;build(Type          =&gt;&quot;multipart/mixed&quot;,
                              From          =&gt; $myaddr,
                              Subject       =&gt; &quot;Hi!&quot;,
                              'X-Certified' =&gt; ['SINED',
                                                'SEELED',
                                                'DELIVERED']);
    </pre>
    <p class="Pp">Normally, an <span class="Li">&quot;X-Mailer&quot;</span>
        header field is output which contains this toolkit's name and version
        (plus this module's RCS version). This will allow any bad MIME we
        generate to be traced back to us. You can of course overwrite that
        header with your own:</p>
    <p class="Pp"></p>
    <pre>   $ent = MIME::Entity-&gt;build(Type        =&gt; &quot;multipart/mixed&quot;,
                              'X-Mailer'  =&gt; &quot;myprog 1.1&quot;);
    </pre>
    <p class="Pp">Or remove it entirely:</p>
    <p class="Pp"></p>
    <pre>   $ent = MIME::Entity-&gt;build(Type       =&gt; &quot;multipart/mixed&quot;,
                              'X-Mailer' =&gt; undef);
    </pre>
    <p class="Pp">OK, enough hype. The parameters are:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>(FIELDNAME)</dt>
  <dd>Any field you want placed in the message header, taken from the standard
      list of header fields (you don't need to worry about case):
    <p class="Pp"></p>
    <pre>    Bcc           Encrypted     Received      Sender
    Cc            From          References    Subject
    Comments      Keywords      Reply-To      To
    Content-*     Message-ID    Resent-*      X-*
    Date          MIME-Version  Return-Path
                  Organization
    </pre>
    <p class="Pp">To give experienced users some veto power, these fields will
        be set <i>after</i> the ones I set... so be careful: <i>don't set any
        MIME fields</i> (like <span class="Li">&quot;Content-type&quot;</span>)
        unless you know what you're doing!</p>
    <p class="Pp">To specify a fieldname that's <i>not</i> in the above list,
        even one that's identical to an option below, just give it with a
        trailing <span class="Li">&quot;:&quot;</span>, like
        <span class="Li">&quot;My-field:&quot;</span>. When in doubt, that
        <i>always</i> signals a mail field (and it sort of looks like one
      too).</p>
  </dd>
  <dt id="Boundary"><a class="permalink" href="#Boundary">Boundary</a></dt>
  <dd><i>Multipart entities only. Optional.</i> The boundary string. As per
      RFC-2046, it must consist only of the characters
      <span class="Li">&quot;[0-9a-zA-Z'()+_,-./:=?]&quot;</span> and space
      (you'll be warned, and your boundary will be ignored, if this is not the
      case). If you omit this, a random string will be chosen... which is
      probably safer.</dd>
  <dt id="Charset"><a class="permalink" href="#Charset">Charset</a></dt>
  <dd><i>Optional.</i> The character set.</dd>
  <dt id="Data"><a class="permalink" href="#Data">Data</a></dt>
  <dd><i>Single-part entities only. Optional.</i> An alternative to Path (q.v.):
      the actual data, either as a scalar or an array reference (whose elements
      are joined together to make the actual scalar). The body is opened on the
      data using MIME::Body::InCore.</dd>
  <dt id="Description"><a class="permalink" href="#Description">Description</a></dt>
  <dd><i>Optional.</i> The text of the content-description. If you don't specify
      it, the field is not put in the header.</dd>
  <dt id="Disposition"><a class="permalink" href="#Disposition">Disposition</a></dt>
  <dd><i>Optional.</i> The basic content-disposition
      (<span class="Li">&quot;attachment&quot;</span> or
      <span class="Li">&quot;inline&quot;</span>). If you don't specify it, it
      defaults to &quot;inline&quot; for backwards compatibility. <i>Thanks to
      Kurt Freytag for suggesting this feature.</i></dd>
  <dt id="Encoding"><a class="permalink" href="#Encoding">Encoding</a></dt>
  <dd><i>Optional.</i> The content-transfer-encoding. If you don't specify it, a
      reasonable default is put in. You can also give the special value
      '-SUGGEST', to have it chosen for you in a heavy-duty fashion which scans
      the data itself.</dd>
  <dt id="Filename"><a class="permalink" href="#Filename">Filename</a></dt>
  <dd><i>Single-part entities only. Optional.</i> The recommended filename.
      Overrides any name extracted from
      <span class="Li">&quot;Path&quot;</span>. The information is stored both
      the deprecated (content-type) and preferred (content-disposition)
      locations. If you explicitly want to <i>avoid</i> a recommended filename
      (even when Path is used), supply this as empty or undef.</dd>
  <dt id="Id"><a class="permalink" href="#Id">Id</a></dt>
  <dd><i>Optional.</i> Set the content-id.</dd>
  <dt id="Path"><a class="permalink" href="#Path">Path</a></dt>
  <dd><i>Single-part entities only. Optional.</i> The path to the file to
      attach. The body is opened on that file using MIME::Body::File.</dd>
  <dt id="Top"><a class="permalink" href="#Top">Top</a></dt>
  <dd><i>Optional.</i> Is this a top-level entity? If so, it must sport a
      MIME-Version. The default is true. (NB: look at how
      <span class="Li">&quot;attach()&quot;</span> uses it.)</dd>
  <dt id="Type"><a class="permalink" href="#Type">Type</a></dt>
  <dd><i>Optional.</i> The basic content-type
      (<span class="Li">&quot;text/plain&quot;</span>, etc.). If you don't
      specify it, it defaults to <span class="Li">&quot;text/plain&quot;</span>
      as per RFC 2045. <i>Do yourself a favor: put it in.</i></dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="dup"><a class="permalink" href="#dup">dup</a></dt>
  <dd><i>Instance method.</i> Duplicate the entity. Does a deep, recursive copy,
      <i>but beware:</i> external data in bodyhandles is <i>not</i> copied to
      new files! Changing the data in one entity's data file, or purging that
      entity, <i>will</i> affect its duplicate. Entities with in-core data
      probably need not worry.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Access"><a class="permalink" href="#Access">Access</a></h2>
<dl class="Bl-tag">
  <dt id="body"><a class="permalink" href="#body">body [VALUE]</a></dt>
  <dd><i>Instance method.</i> Get the <i>encoded</i> (transport-ready) body, as
      an array of lines. Returns an array reference. Each array entry is a
      newline-terminated line.
    <p class="Pp">This is a read-only data structure: changing its contents will
        have no effect. Its contents are identical to what is printed by
        <b>print_body()</b>.</p>
    <p class="Pp">Provided for compatibility with Mail::Internet, so that
        methods like <span class="Li">&quot;smtpsend()&quot;</span> will work.
        Note however that if VALUE is given, a fatal exception is thrown, since
        you cannot use this method to <i>set</i> the lines of the encoded
        message.</p>
    <p class="Pp">If you want the raw (unencoded) body data, use the
        <b>bodyhandle()</b> method to get and use a MIME::Body. The content-type
        of the entity will tell you whether that body is best read as text (via
        <b>getline()</b>) or raw data (via <b>read()</b>).</p>
  </dd>
  <dt id="bodyhandle"><a class="permalink" href="#bodyhandle">bodyhandle
    [VALUE]</a></dt>
  <dd><i>Instance method.</i> Get or set an abstract object representing the
      body of the message. The body holds the decoded message data.
    <p class="Pp"><b>Note that not all entities have bodies!</b> An entity will
        have either a body or parts: not both. This method will <i>only</i>
        return an object if this entity can have a body; otherwise, it will
        return undefined. Whether-or-not a given entity can have a body is
        determined by (1) its content type, and (2) whether-or-not the parser
        was told to extract nested messages:</p>
    <p class="Pp"></p>
    <pre>    Type:        | Extract nested? | bodyhandle() | parts()
    -----------------------------------------------------------------------
    multipart/*  | -               | undef        | 0 or more MIME::Entity
    message/*    | true            | undef        | 0 or 1 MIME::Entity
    message/*    | false           | MIME::Body   | empty list
    (other)      | -               | MIME::Body   | empty list
    </pre>
    <p class="Pp">If <span class="Li">&quot;VALUE&quot;</span> <i>is not</i>
        given, the current bodyhandle is returned, or undef if the entity cannot
        have a body.</p>
    <p class="Pp">If <span class="Li">&quot;VALUE&quot;</span> <i>is</i> given,
        the bodyhandle is set to the new value, and the previous value is
        returned.</p>
    <p class="Pp">See &quot;parts&quot; for more info.</p>
  </dd>
  <dt id="effective_type"><a class="permalink" href="#effective_type">effective_type
    [MIMETYPE]</a></dt>
  <dd><i>Instance method.</i> Set/get the <i>effective</i> MIME type of this
      entity. This is <i>usually</i> identical to the actual (or defaulted) MIME
      type, but in some cases it differs. For example, from RFC-2045:
    <p class="Pp"></p>
    <pre>   Any entity with an unrecognized Content-Transfer-Encoding must be
   treated as if it has a Content-Type of &quot;application/octet-stream&quot;,
   regardless of what the Content-Type header field actually says.
    </pre>
    <p class="Pp">Why? because if we can't decode the message, then we have to
        take the bytes as-is, in their (unrecognized) encoded form. So the
        message ceases to be a &quot;text/foobar&quot; and becomes a bunch of
        undecipherable bytes -- in other words, an
        &quot;application/octet-stream&quot;.</p>
    <p class="Pp">Such an entity, if parsed, would have its
        <b>effective_type()</b> set to
        <span class="Li">&quot;application/octet_stream&quot;</span>, although
        the <b>mime_type()</b> and the contents of the header would remain the
        same.</p>
    <p class="Pp">If there is no effective type, the method just returns what
        <b>mime_type()</b> would.</p>
    <p class="Pp"><b>Warning:</b> the effective type is &quot;sticky&quot;; once
        set, that <b>effective_type()</b> will always be returned even if the
        conditions that necessitated setting the effective type become no longer
        true.</p>
  </dd>
  <dt id="epilogue"><a class="permalink" href="#epilogue">epilogue
    [LINES]</a></dt>
  <dd><i>Instance method.</i> Get/set the text of the epilogue, as an array of
      newline-terminated LINES. Returns a reference to the array of lines, or
      undef if no epilogue exists.
    <p class="Pp">If there is a epilogue, it is output when printing this
        entity; otherwise, a default epilogue is used. Setting the epilogue to
        undef (not []!) causes it to fallback to the default.</p>
  </dd>
  <dt id="head"><a class="permalink" href="#head">head [VALUE]</a></dt>
  <dd><i>Instance method.</i> Get/set the head.
    <p class="Pp">If there is no VALUE given, returns the current head. If none
        exists, an empty instance of MIME::Head is created, set, and
      returned.</p>
    <p class="Pp"><b>Note:</b> This is a patch over a problem in Mail::Internet,
        which doesn't provide a method for setting the head to some given
        object.</p>
  </dd>
  <dt id="is_multipart"><a class="permalink" href="#is_multipart">is_multipart</a></dt>
  <dd><i>Instance method.</i> Does this entity's effective MIME type indicate
      that it's a multipart entity? Returns undef (false) if the answer couldn't
      be determined, 0 (false) if it was determined to be false, and true
      otherwise. Note that this says nothing about whether or not parts were
      extracted.
    <p class="Pp">NOTE: we switched to effective_type so that multiparts with
        bad or missing boundaries could be coerced to an effective type of
        <span class="Li">&quot;application/x-unparseable-multipart&quot;</span>.</p>
  </dd>
  <dt id="mime_type"><a class="permalink" href="#mime_type">mime_type</a></dt>
  <dd><i>Instance method.</i> A purely-for-convenience method. This simply
      relays the request to the associated MIME::Head object. If there is no
      head, returns undef in a scalar context and the empty array in a list
      context.
    <p class="Pp"><b>Before you use this,</b> consider using
        <b>effective_type()</b> instead, especially if you obtained the entity
        from a MIME::Parser.</p>
  </dd>
  <dt id="open"><a class="permalink" href="#open">open READWRITE</a></dt>
  <dd><i>Instance method.</i> A purely-for-convenience method. This simply
      relays the request to the associated MIME::Body object (see
      <b>MIME::Body::open()</b>). READWRITE is either 'r' (open for read) or 'w'
      (open for write).
    <p class="Pp">If there is no body, returns false.</p>
  </dd>
  <dt id="parts"><a class="permalink" href="#parts">parts</a></dt>
  <dd></dd>
  <dt>parts INDEX</dt>
  <dd></dd>
  <dt>parts ARRAYREF</dt>
  <dd><i>Instance method.</i> Return the MIME::Entity objects which are the sub
      parts of this entity (if any).
    <p class="Pp"><i>If no argument is given,</i> returns the array of all sub
        parts, returning the empty array if there are none (e.g., if this is a
        single part message, or a degenerate multipart). In a scalar context,
        this returns you the number of parts.</p>
    <p class="Pp"><i>If an integer INDEX is given,</i> return the INDEXed part,
        or undef if it doesn't exist.</p>
    <p class="Pp"><i>If an ARRAYREF to an array of parts is given,</i> then this
        method <i>sets</i> the parts to a copy of that array, and returns the
        parts. This can be used to delete parts, as follows:</p>
    <p class="Pp"></p>
    <pre>    ### Delete some parts of a multipart message:
    $msg-&gt;parts([ grep { keep_part($_) } $msg-&gt;parts ]);
    </pre>
    <p class="Pp"><b>Note:</b> for multipart messages, the preamble and epilogue
        are <i>not</i> considered parts. If you need them, use the
        <span class="Li">&quot;preamble()&quot;</span> and
        <span class="Li">&quot;epilogue()&quot;</span> methods.</p>
    <p class="Pp"><b>Note:</b> there are ways of parsing with a MIME::Parser
        which cause certain message parts (such as those of type
        <span class="Li">&quot;message/rfc822&quot;</span>) to be
        &quot;reparsed&quot; into pseudo-multipart entities. You should read the
        documentation for those options carefully: it <i>is</i> possible for a
        diddled entity to not be multipart, but still have parts attached to
      it!</p>
    <p class="Pp">See &quot;bodyhandle&quot; for a discussion of parts vs.
        bodies.</p>
  </dd>
  <dt id="parts_DFS"><a class="permalink" href="#parts_DFS">parts_DFS</a></dt>
  <dd><i>Instance method.</i> Return the list of all MIME::Entity objects
      included in the entity, starting with the entity itself, in
      depth-first-search order. If the entity has no parts, it alone will be
      returned.
    <p class="Pp"><i>Thanks to Xavier Armengou for suggesting this
      method.</i></p>
  </dd>
  <dt id="preamble"><a class="permalink" href="#preamble">preamble
    [LINES]</a></dt>
  <dd><i>Instance method.</i> Get/set the text of the preamble, as an array of
      newline-terminated LINES. Returns a reference to the array of lines, or
      undef if no preamble exists (e.g., if this is a single-part entity).
    <p class="Pp">If there is a preamble, it is output when printing this
        entity; otherwise, a default preamble is used. Setting the preamble to
        undef (not []!) causes it to fallback to the default.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Manipulation"><a class="permalink" href="#Manipulation">Manipulation</a></h2>
<dl class="Bl-tag">
  <dt id="make_multipart"><a class="permalink" href="#make_multipart">make_multipart
    [SUBTYPE], OPTSHASH...</a></dt>
  <dd><i>Instance method.</i> Force the entity to be a multipart, if it isn't
      already. We do this by replacing the original [singlepart] entity with a
      new multipart that has the same non-MIME headers (&quot;From&quot;,
      &quot;Subject&quot;, etc.), but all-new MIME headers
      (&quot;Content-type&quot;, etc.). We then create a copy of the original
      singlepart, <i>strip out</i> the non-MIME headers from that, and make it a
      part of the new multipart. So this:
    <p class="Pp"></p>
    <pre>    From: me
    To: you
    Content-type: text/plain
    Content-length: 12
    Hello there!
    </pre>
    <p class="Pp">Becomes something like this:</p>
    <p class="Pp"></p>
    <pre>    From: me
    To: you
    Content-type: multipart/mixed; boundary=&quot;----abc----&quot;
    ------abc----
    Content-type: text/plain
    Content-length: 12
    Hello there!
    ------abc------
    </pre>
    <p class="Pp">The actual type of the new top-level multipart will be
        &quot;multipart/SUBTYPE&quot; (default SUBTYPE is
      &quot;mixed&quot;).</p>
    <p class="Pp">Returns 'DONE' if we really did inflate a singlepart to a
        multipart. Returns 'ALREADY' (and does nothing) if entity is
        <i>already</i> multipart and Force was not chosen.</p>
    <p class="Pp">If OPTSHASH contains Force=&gt;1, then we <i>always</i> bump
        the top-level's content and content-headers down to a subpart of this
        entity, even if this entity is already a multipart. This is apparently
        of use to people who are tweaking messages after parsing them.</p>
  </dd>
  <dt id="make_singlepart"><a class="permalink" href="#make_singlepart">make_singlepart</a></dt>
  <dd><i>Instance method.</i> If the entity is a multipart message with one
      part, this tries hard to rewrite it as a singlepart, by replacing the
      content (and content headers) of the top level with those of the part.
      Also crunches 0-part multiparts into singleparts.
    <p class="Pp">Returns 'DONE' if we really did collapse a multipart to a
        singlepart. Returns 'ALREADY' (and does nothing) if entity is already a
        singlepart. Returns '0' (and does nothing) if it can't be made into a
        singlepart.</p>
  </dd>
  <dt id="purge"><a class="permalink" href="#purge">purge</a></dt>
  <dd><i>Instance method.</i> Recursively purge (e.g., unlink) all external
      (e.g., on-disk) body parts in this message. See <b>MIME::Body::purge()</b>
      for details.
    <p class="Pp"><b>Note:</b> this does <i>not</i> delete the directories that
        those body parts are contained in; only the actual message data files
        are deleted. This is because some parsers may be customized to create
        intermediate directories while others are not, and it's impossible for
        this class to know what directories are safe to remove. Only your
        application program truly knows that.</p>
    <p class="Pp"><b>If you really want to &quot;clean everything up&quot;,</b>
        one good way is to use
        <span class="Li">&quot;MIME::Parser::file_under()&quot;</span>, and then
        do this before parsing your next message:</p>
    <p class="Pp"></p>
    <pre>    $parser-&gt;filer-&gt;purge();
    </pre>
    <p class="Pp">I wouldn't attempt to read those body files after you do this,
        for obvious reasons. As of MIME-tools 4.x, each body's path <i>is</i>
        undefined after this operation. I warned you I might do this; truly I
        did.</p>
    <p class="Pp"><i>Thanks to Jason L. Tibbitts III for suggesting this
        method.</i></p>
  </dd>
  <dt id="remove_sig"><a class="permalink" href="#remove_sig">remove_sig
    [NLINES]</a></dt>
  <dd><i>Instance method, override.</i> Attempts to remove a user's signature
      from the body of a message.
    <p class="Pp">It does this by looking for a line matching
        <span class="Li">&quot;/^-- $/&quot;</span> within the last
        <span class="Li">&quot;NLINES&quot;</span> of the message. If found then
        that line and all lines after it will be removed. If
        <span class="Li">&quot;NLINES&quot;</span> is not given, a default value
        of 10 will be used. This would be of most use in auto-reply scripts.</p>
    <p class="Pp">For MIME entity, this method is reasonably cautious: it will
        only attempt to un-sign a message with a content-type of
        <span class="Li">&quot;text/*&quot;</span>.</p>
    <p class="Pp">If you send <b>remove_sig()</b> to a multipart entity, it will
        relay it to the first part (the others usually being the
        &quot;attachments&quot;).</p>
    <p class="Pp"><b>Warning:</b> currently slurps the whole message-part into
        core as an array of lines, so you probably don't want to use this on
        extremely long messages.</p>
    <p class="Pp">Returns truth on success, false on error.</p>
  </dd>
  <dt id="sign"><a class="permalink" href="#sign">sign PARAMHASH</a></dt>
  <dd><i>Instance method, override.</i> Append a signature to the message. The
      params are:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Attach"><a class="permalink" href="#Attach">Attach</a></dt>
  <dd>Instead of appending the text, add it to the message as an attachment. The
      disposition will be <span class="Li">&quot;inline&quot;</span>, and the
      description will indicate that it is a signature. The default behavior is
      to append the signature to the text of the message (or the text of its
      first part if multipart). <i>MIME-specific; new in this subclass.</i></dd>
  <dt id="File"><a class="permalink" href="#File">File</a></dt>
  <dd>Use the contents of this file as the signature. Fatal error if it can't be
      read. <i>As per superclass method.</i></dd>
  <dt id="Force"><a class="permalink" href="#Force">Force</a></dt>
  <dd>Sign it even if the content-type isn't
      <span class="Li">&quot;text/*&quot;</span>. Useful for non-standard types
      like <span class="Li">&quot;x-foobar&quot;</span>, but be careful!
      <i>MIME-specific; new in this subclass.</i></dd>
  <dt id="Remove"><a class="permalink" href="#Remove">Remove</a></dt>
  <dd>Normally, we attempt to strip out any existing signature. If true, this
      gives us the NLINES parameter of the remove_sig call. If zero but defined,
      tells us <i>not</i> to remove any existing signature. If undefined,
      removal is done with the default of 10 lines. <i>New in this
    subclass.</i></dd>
  <dt id="Signature"><a class="permalink" href="#Signature">Signature</a></dt>
  <dd>Use this text as the signature. You can supply it as either a scalar, or
      as a ref to an array of newline-terminated scalars. <i>As per superclass
      method.</i></dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">For MIME messages, this method is reasonably cautious: it will
    only attempt to sign a message with a content-type of
    <span class="Li">&quot;text/*&quot;</span>, unless
    <span class="Li">&quot;Force&quot;</span> is specified.</p>
<p class="Pp">If you send this message to a multipart entity, it will relay it
    to the first part (the others usually being the
  &quot;attachments&quot;).</p>
<p class="Pp"><b>Warning:</b> currently slurps the whole message-part into core
    as an array of lines, so you probably don't want to use this on extremely
    long messages.</p>
<p class="Pp">Returns true on success, false otherwise.</p>
</div>
<dl class="Bl-tag">
  <dt id="suggest_encoding"><a class="permalink" href="#suggest_encoding">suggest_encoding</a></dt>
  <dd><i>Instance method.</i> Based on the effective content type, return a good
      suggested encoding.
    <p class="Pp"><span class="Li">&quot;text&quot;</span> and
        <span class="Li">&quot;message&quot;</span> types have their bodies
        scanned line-by-line for 8-bit characters and long lines; lack of either
        means that the message is 7bit-ok. Other types are chosen independent of
        their body:</p>
    <p class="Pp"></p>
    <pre>    Major type:      7bit ok?    Suggested encoding:
    -----------------------------------------------------------
    text             yes         7bit
    text             no          quoted-printable
    message          yes         7bit
    message          no          binary
    multipart        *           binary (in case some parts are bad)
    image, etc...    *           base64
    </pre>
  </dd>
  <dt id="sync_headers"><a class="permalink" href="#sync_headers">sync_headers
    OPTIONS</a></dt>
  <dd><i>Instance method.</i> This method does a variety of activities which
      ensure that the MIME headers of an entity &quot;tree&quot; are in-synch
      with the body parts they describe. It can be as expensive an operation as
      printing if it involves pre-encoding the body parts; however, the aim is
      to produce fairly clean MIME. <b>You will usually only need to invoke</b>
      <b>this if processing and re-sending MIME from an outside source.</b>
    <p class="Pp">The OPTIONS is a hash, which describes what is to be done.</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Length"><a class="permalink" href="#Length">Length</a></dt>
  <dd>One of the &quot;official unofficial&quot; MIME fields is
      &quot;Content-Length&quot;. Normally, one doesn't care a whit about this
      field; however, if you are preparing output destined for HTTP, you may.
      The value of this option dictates what will be done:
    <p class="Pp"><b>COMPUTE</b> means to set a
        <span class="Li">&quot;Content-Length&quot;</span> field for every
        non-multipart part in the entity, and to blank that field out for every
        multipart part in the entity.</p>
    <p class="Pp"><b>ERASE</b> means that
        <span class="Li">&quot;Content-Length&quot;</span> fields will all be
        blanked out. This is fast, painless, and safe.</p>
    <p class="Pp"><b>Any false value</b> (the default) means to take no
      action.</p>
  </dd>
  <dt id="Nonstandard"><a class="permalink" href="#Nonstandard">Nonstandard</a></dt>
  <dd>Any header field beginning with &quot;Content-&quot; is, according to the
      RFC, a MIME field. However, some are non-standard, and may cause problems
      with certain MIME readers which interpret them in different ways.
    <p class="Pp"><b>ERASE</b> means that all such fields will be blanked out.
        This is done <i>before</i> the <b>Length</b> option (q.v.) is examined
        and acted upon.</p>
    <p class="Pp"><b>Any false value</b> (the default) means to take no
      action.</p>
  </dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">Returns a true value if everything went okay, a false value
    otherwise.</p>
</div>
<dl class="Bl-tag">
  <dt id="tidy_body"><a class="permalink" href="#tidy_body">tidy_body</a></dt>
  <dd><i>Instance method, override.</i> Currently unimplemented for MIME
      messages. Does nothing, returns false.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Output"><a class="permalink" href="#Output">Output</a></h2>
<dl class="Bl-tag">
  <dt id="dump_skeleton"><a class="permalink" href="#dump_skeleton">dump_skeleton
    [FILEHANDLE]</a></dt>
  <dd><i>Instance method.</i> Dump the skeleton of the entity to the given
      FILEHANDLE, or to the currently-selected one if none given.
    <p class="Pp">Each entity is output with an appropriate indentation level,
        the following selection of attributes:</p>
    <p class="Pp"></p>
    <pre>    Content-type: multipart/mixed
    Effective-type: multipart/mixed
    Body-file: NONE
    Subject: Hey there!
    Num-parts: 2
    </pre>
    <p class="Pp">This is really just useful for debugging purposes; I make no
        guarantees about the consistency of the output format over time.</p>
  </dd>
  <dt id="print"><a class="permalink" href="#print">print [OUTSTREAM]</a></dt>
  <dd><i>Instance method, override.</i> Print the entity to the given OUTSTREAM,
      or to the currently-selected filehandle if none given. OUTSTREAM can be a
      filehandle, or any object that responds to a <b>print()</b> message.
    <p class="Pp">The entity is output as a valid MIME stream! This means that
        the header is always output first, and the body data (if any) will be
        encoded if the header says that it should be. For example, your output
        may look like this:</p>
    <p class="Pp"></p>
    <pre>    Subject: Greetings
    Content-transfer-encoding: base64
    SGkgdGhlcmUhCkJ5ZSB0aGVyZSEK
    </pre>
    <p class="Pp"><i>If this entity has MIME type &quot;multipart/*&quot;,</i>
        the preamble, parts, and epilogue are all output with appropriate
        boundaries separating each. Any bodyhandle is ignored:</p>
    <p class="Pp"></p>
    <pre>    Content-type: multipart/mixed; boundary=&quot;*----*&quot;
    Content-transfer-encoding: 7bit
    [Preamble]
    --*----*
    [Entity: Part 0]
    --*----*
    [Entity: Part 1]
    --*----*--
    [Epilogue]
    </pre>
    <p class="Pp"><i>If this entity has a single-part MIME type with no attached
        parts,</i> then we're looking at a normal singlepart entity: the body is
        output according to the encoding specified by the header. If no body
        exists, a warning is output and the body is treated as empty:</p>
    <p class="Pp"></p>
    <pre>    Content-type: image/gif
    Content-transfer-encoding: base64
    [Encoded body]
    </pre>
    <p class="Pp"><i>If this entity has a single-part MIME type but it also has
        parts,</i> then we're probably looking at a &quot;re-parsed&quot;
        singlepart, usually one of type
        <span class="Li">&quot;message/*&quot;</span> (you can get entities like
        this if you set the
        <span class="Li">&quot;parse_nested_messages(NEST)&quot;</span> option
        on the parser to true). In this case, the parts are output with single
        blank lines separating each, and any bodyhandle is ignored:</p>
    <p class="Pp"></p>
    <pre>    Content-type: message/rfc822
    Content-transfer-encoding: 7bit
    [Entity: Part 0]
    [Entity: Part 1]
    </pre>
    <p class="Pp">In all cases, when outputting a &quot;part&quot; of the
        entity, this method is invoked recursively.</p>
    <p class="Pp"><b>Note:</b> the output is very likely <i>not</i> going to be
        identical to any input you parsed to get this entity. If you're building
        some sort of email handler, it's up to you to save this information.</p>
  </dd>
  <dt id="print_body"><a class="permalink" href="#print_body">print_body
    [OUTSTREAM]</a></dt>
  <dd><i>Instance method, override.</i> Print the body of the entity to the
      given OUTSTREAM, or to the currently-selected filehandle if none given.
      OUTSTREAM can be a filehandle, or any object that responds to a
      <b>print()</b> message.
    <p class="Pp">The body is output for inclusion in a valid MIME stream; this
        means that the body data will be encoded if the header says that it
        should be.</p>
    <p class="Pp"><b>Note:</b> by &quot;body&quot;, we mean &quot;the stuff
        following the header&quot;. A printed multipart body includes the
        printed representations of its subparts.</p>
    <p class="Pp"><b>Note:</b> The body is <i>stored</i> in an un-encoded form;
        however, the idea is that the transfer encoding is used to determine how
        it should be <i>output.</i> This means that the
        <span class="Li">&quot;print()&quot;</span> method is always guaranteed
        to get you a sendmail-ready stream whose body is consistent with its
        head. If you want the <i>raw body data</i> to be output, you can either
        read it from the bodyhandle yourself, or use:</p>
    <p class="Pp"></p>
    <pre>    $ent-&gt;bodyhandle-&gt;print($outstream);
    </pre>
    <p class="Pp">which uses <b>read()</b> calls to extract the information, and
        thus will work with both text and binary bodies.</p>
    <p class="Pp"><b>Warning:</b> Please supply an OUTSTREAM. This override
        method differs from Mail::Internet's behavior, which outputs to the
        STDOUT if no filehandle is given: this may lead to confusion.</p>
  </dd>
  <dt id="print_header"><a class="permalink" href="#print_header">print_header
    [OUTSTREAM]</a></dt>
  <dd><i>Instance method, inherited.</i> Output the header to the given
      OUTSTREAM. You really should supply the OUTSTREAM.</dd>
  <dt id="stringify"><a class="permalink" href="#stringify">stringify</a></dt>
  <dd><i>Instance method.</i> Return the entity as a string, exactly as
      <span class="Li">&quot;print&quot;</span> would print it. The body will be
      encoded as necessary, and will contain any subparts. You can also use
      <span class="Li">&quot;as_string()&quot;</span>.</dd>
  <dt id="stringify_body"><a class="permalink" href="#stringify_body">stringify_body</a></dt>
  <dd><i>Instance method.</i> Return the <i>encoded</i> message body as a
      string, exactly as <span class="Li">&quot;print_body&quot;</span> would
      print it. You can also use
      <span class="Li">&quot;body_as_string()&quot;</span>.
    <p class="Pp">If you want the <i>unencoded</i> body, and you are dealing
        with a singlepart message (like a &quot;text/plain&quot;), use
        <span class="Li">&quot;bodyhandle()&quot;</span> instead:</p>
    <p class="Pp"></p>
    <pre>    if ($ent-&gt;bodyhandle) {
        $unencoded_data = $ent-&gt;bodyhandle-&gt;as_string;
    }
    else {
        ### this message has no body data (but it might have parts!)
    }
    </pre>
  </dd>
  <dt id="stringify_header"><a class="permalink" href="#stringify_header">stringify_header</a></dt>
  <dd><i>Instance method.</i> Return the header as a string, exactly as
      <span class="Li">&quot;print_header&quot;</span> would print it. You can
      also use <span class="Li">&quot;header_as_string()&quot;</span>.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Under_the_hood"><a class="permalink" href="#Under_the_hood">Under
  the hood</a></h2>
<p class="Pp">A <b>MIME::Entity</b> is composed of the following elements:</p>
<ul class="Bl-bullet">
  <li>A <i>head</i>, which is a reference to a MIME::Head object containing the
      header information.</li>
  <li>A <i>bodyhandle</i>, which is a reference to a MIME::Body object
      containing the decoded body data. This is only defined if the message is a
      &quot;singlepart&quot; type:
    <p class="Pp"></p>
    <pre>    application/*
    audio/*
    image/*
    text/*
    video/*
    </pre>
  </li>
  <li>An array of <i>parts</i>, where each part is a MIME::Entity object. The
      number of parts will only be nonzero if the content-type is <i>not</i> one
      of the &quot;singlepart&quot; types:
    <p class="Pp"></p>
    <pre>    message/*        (should have exactly one part)
    multipart/*      (should have one or more parts)
    </pre>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="The__two-body_problem_"><a class="permalink" href="#The__two-body_problem_">The
  &quot;two-body problem&quot;</a></h2>
<p class="Pp">MIME::Entity and Mail::Internet see message bodies differently,
    and this can cause confusion and some inconvenience. Sadly, I can't change
    the behavior of MIME::Entity without breaking lots of code already out
    there. But let's open up the floor for a few questions...</p>
<dl class="Bl-tag">
  <dt id="What"><a class="permalink" href="#What">What is the difference between
    a &quot;message&quot; and an &quot;entity&quot;?</a></dt>
  <dd>A <b>message</b> is the actual data being sent or received; usually this
      means a stream of newline-terminated lines. An <b>entity</b> is the
      representation of a message as an object.
    <p class="Pp">This means that you get a &quot;message&quot; when you print
        an &quot;entity&quot; <i>to</i> a filehandle, and you get an
        &quot;entity&quot; when you parse a message <i>from</i> a
      filehandle.</p>
  </dd>
  <dt id="What~2"><a class="permalink" href="#What~2">What is a message
    body?</a></dt>
  <dd><b>Mail::Internet:</b> The portion of the printed message after the
      header.
    <p class="Pp"><b>MIME::Entity:</b> The portion of the printed message after
        the header.</p>
  </dd>
  <dt id="How"><a class="permalink" href="#How">How is a message body stored in
    an entity?</a></dt>
  <dd><b>Mail::Internet:</b> As an array of lines.
    <p class="Pp"><b>MIME::Entity:</b> It depends on the content-type of the
        message. For &quot;container&quot; types
        (<span class="Li">&quot;multipart/*&quot;</span>,
        <span class="Li">&quot;message/*&quot;</span>), we store the contained
        entities as an array of &quot;parts&quot;, accessed via the
        <span class="Li">&quot;parts()&quot;</span> method, where each part is a
        complete MIME::Entity. For &quot;singlepart&quot; types
        (<span class="Li">&quot;text/*&quot;</span>,
        <span class="Li">&quot;image/*&quot;</span>, etc.), the unencoded body
        data is referenced via a MIME::Body object, accessed via the
        <span class="Li">&quot;bodyhandle()&quot;</span> method:</p>
    <p class="Pp"></p>
    <pre>                      bodyhandle()   parts()
    Content-type:     returns:       returns:
    ------------------------------------------------------------
    application/*     MIME::Body     empty
    audio/*           MIME::Body     empty
    image/*           MIME::Body     empty
    message/*         undef          MIME::Entity list (usually 1)
    multipart/*       undef          MIME::Entity list (usually &gt;0)
    text/*            MIME::Body     empty
    video/*           MIME::Body     empty
    x-*/*             MIME::Body     empty
    </pre>
    <p class="Pp">As a special case,
        <span class="Li">&quot;message/*&quot;</span> is currently ambiguous:
        depending on the parser, a <span class="Li">&quot;message/*&quot;</span>
        might be treated as a singlepart, with a MIME::Body and no parts. Use
        <b>bodyhandle()</b> as the final arbiter.</p>
  </dd>
  <dt id="What~3"><a class="permalink" href="#What~3">What does the
    <b>body()</b> method return?</a></dt>
  <dd><b>Mail::Internet:</b> As an array of lines, ready for sending.
    <p class="Pp"><b>MIME::Entity:</b> As an array of lines, ready for
      sending.</p>
  </dd>
  <dt id="What's"><a class="permalink" href="#What's">What's the best way to get
    at the body data?</a></dt>
  <dd><b>Mail::Internet:</b> Use the <b>body()</b> method.
    <p class="Pp"><b>MIME::Entity:</b> Depends on what you want... the
        <i>encoded</i> data (as it is transported), or the <i>unencoded</i>
        data? Keep reading...</p>
  </dd>
  <dt id="How~2"><a class="permalink" href="#How~2">How do I get the
    &quot;encoded&quot; body data?</a></dt>
  <dd><b>Mail::Internet:</b> Use the <b>body()</b> method.
    <p class="Pp"><b>MIME::Entity:</b> Use the <b>body()</b> method. You can
        also use:</p>
    <p class="Pp"></p>
    <pre>    $entity-&gt;print_body()
    $entity-&gt;stringify_body()   ### a.k.a. $entity-&gt;body_as_string()
    </pre>
  </dd>
  <dt id="How~3"><a class="permalink" href="#How~3">How do I get the
    &quot;unencoded&quot; body data?</a></dt>
  <dd><b>Mail::Internet:</b> Use the <b>body()</b> method.
    <p class="Pp"><b>MIME::Entity:</b> Use the
        <i></i><b><i>bodyhandle()</i></b><i></i> method! If <b>bodyhandle()</b>
        method returns true, then that value is a MIME::Body which can be used
        to access the data via its <b>open()</b> method. If <b>bodyhandle()</b>
        method returns an undefined value, then the entity is probably a
        &quot;container&quot; that has no real body data of its own (e.g., a
        &quot;multipart&quot; message): in this case, you should access the
        components via the <b>parts()</b> method. Like this:</p>
    <p class="Pp"></p>
    <pre>    if ($bh = $entity-&gt;bodyhandle) {
        $io = $bh-&gt;open;
        ...access unencoded data via $io-&gt;getline or $io-&gt;read...
        $io-&gt;close;
    }
    else {
        foreach my $part (@parts) {
            ...do something with the part...
        }
    }
    </pre>
    <p class="Pp">You can also use:</p>
    <p class="Pp"></p>
    <pre>    if ($bh = $entity-&gt;bodyhandle) {
        $unencoded_data = $bh-&gt;as_string;
    }
    else {
        ...do stuff with the parts...
    }
    </pre>
  </dd>
  <dt id="What~4"><a class="permalink" href="#What~4">What does the
    <b>body()</b> method return?</a></dt>
  <dd><b>Mail::Internet:</b> The transport-encoded message body, as an array of
      lines.
    <p class="Pp"><b>MIME::Entity:</b> The transport-encoded message body, as an
        array of lines.</p>
  </dd>
  <dt id="What~5"><a class="permalink" href="#What~5">What does
    <b>print_body()</b> print?</a></dt>
  <dd><b>Mail::Internet:</b> Exactly what <b>body()</b> would return to you.
    <p class="Pp"><b>MIME::Entity:</b> Exactly what <b>body()</b> would return
        to you.</p>
  </dd>
  <dt id="Say"><a class="permalink" href="#Say">Say I have an entity which might
    be either singlepart or multipart. How do I print out just &quot;the stuff
    after the header&quot;?</a></dt>
  <dd><b>Mail::Internet:</b> Use <b>print_body()</b>.
    <p class="Pp"><b>MIME::Entity:</b> Use <b>print_body()</b>.</p>
  </dd>
  <dt id="Why"><a class="permalink" href="#Why">Why is MIME::Entity so different
    from Mail::Internet?</a></dt>
  <dd>Because MIME streams are expected to have non-textual data... possibly,
      quite a lot of it, such as a tar file.
    <p class="Pp">Because MIME messages can consist of multiple parts, which are
        most-easily manipulated as MIME::Entity objects themselves.</p>
    <p class="Pp">Because in the simpler world of Mail::Internet, the data of a
        message and its printed representation are <i>identical</i>... and in
        the MIME world, they're not.</p>
    <p class="Pp">Because parsing multipart bodies on-the-fly, or formatting
        multipart bodies for output, is a non-trivial task.</p>
  </dd>
  <dt id="This"><a class="permalink" href="#This">This is confusing. Can the two
    classes be made more compatible?</a></dt>
  <dd>Not easily; their implementations are necessarily quite different.
      Mail::Internet is a simple, efficient way of dealing with a &quot;black
      box&quot; mail message... one whose internal data you don't care much
      about. MIME::Entity, in contrast, cares <i>very much</i> about the message
      contents: that's its job!</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Design_issues"><a class="permalink" href="#Design_issues">Design
  issues</a></h2>
<dl class="Bl-tag">
  <dt id="Some"><a class="permalink" href="#Some">Some things just can't be
    ignored</a></dt>
  <dd>In multipart messages, the <i>&quot;preamble&quot;</i> is the portion that
      precedes the first encapsulation boundary, and the
      <i>&quot;epilogue&quot;</i> is the portion that follows the last
      encapsulation boundary.
    <p class="Pp">According to RFC 2046:</p>
    <p class="Pp"></p>
    <pre>    There appears to be room for additional information prior
    to the first encapsulation boundary and following the final
    boundary.  These areas should generally be left blank, and
    implementations must ignore anything that appears before the
    first boundary or after the last one.
    NOTE: These &quot;preamble&quot; and &quot;epilogue&quot; areas are generally
    not used because of the lack of proper typing of these parts
    and the lack of clear semantics for handling these areas at
    gateways, particularly X.400 gateways.  However, rather than
    leaving the preamble area blank, many MIME implementations
    have found this to be a convenient place to insert an
    explanatory note for recipients who read the message with
    pre-MIME software, since such notes will be ignored by
    MIME-compliant software.
    </pre>
    <p class="Pp">In the world of standards-and-practices, that's the standard.
        Now for the practice:</p>
    <p class="Pp"><i>Some &quot;MIME&quot; mailers may incorrectly put a
        &quot;part&quot; in the preamble</i>. Since we have to parse over the
        stuff <i>anyway</i>, in the future I <i>may</i> allow the parser option
        of creating special MIME::Entity objects for the preamble and epilogue,
        with bogus MIME::Head objects.</p>
    <p class="Pp">For now, though, we're MIME-compliant, so I probably won't
        change how we work.</p>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">MIME::Tools, MIME::Head, MIME::Body, MIME::Decoder,
  Mail::Internet</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Eryq (<i>eryq@zeegee.com</i>), ZeeGee Software Inc
    (<i>http://www.zeegee.com</i>). Dianne Skoll (dfs@roaringpenguin.com)
    http://www.roaringpenguin.com</p>
<p class="Pp">All rights reserved. This program is free software; you can
    redistribute it and/or modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-04-05</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

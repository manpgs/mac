<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>IO::Socket::SSL(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">IO::Socket::SSL(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">IO::Socket::SSL(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">IO::Socket::SSL - SSL sockets with IO::Socket interface</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use strict;
    use IO::Socket::SSL;
    # simple client
    my $cl = IO::Socket::SSL-&gt;new('www.google.com:443');
    print $cl &quot;GET / HTTP/1.0\r\n\r\n&quot;;
    print &lt;$cl&gt;;
    # simple server
    my $srv = IO::Socket::SSL-&gt;new(
        LocalAddr =&gt; '0.0.0.0:1234',
        Listen =&gt; 10,
        SSL_cert_file =&gt; 'server-cert.pem',
        SSL_key_file =&gt; 'server-key.pem',
    );
    $srv-&gt;accept;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">IO::Socket::SSL makes using SSL/TLS much easier by wrapping the
    necessary functionality into the familiar IO::Socket interface and providing
    secure defaults whenever possible. This way, existing applications can be
    made SSL-aware without much effort, at least if you do blocking I/O and
    don't use select or poll.</p>
<p class="Pp">But, under the hood, SSL is a complex beast. So there are lots of
    methods to make it do what you need if the default behavior is not adequate.
    Because it is easy to inadvertently introduce critical security bugs or just
    hard to debug problems, I would recommend studying the following
    documentation carefully.</p>
<p class="Pp">The documentation consists of the following parts:</p>
<ul class="Bl-bullet">
  <li>&quot;Essential Information About SSL/TLS&quot;</li>
  <li>&quot;Basic SSL Client&quot;</li>
  <li>&quot;Basic SSL Server&quot;</li>
  <li>&quot;Common Usage Errors&quot;</li>
  <li>&quot;Common Problems with SSL&quot;</li>
  <li>&quot;Using Non-Blocking Sockets&quot;</li>
  <li>&quot;Advanced Usage&quot;</li>
  <li>&quot;Integration Into Own Modules&quot;</li>
  <li>&quot;Description Of Methods&quot;</li>
</ul>
<p class="Pp">Additional documentation can be found in</p>
<ul class="Bl-bullet">
  <li>IO::Socket::SSL::Intercept - Doing Man-In-The-Middle with SSL</li>
  <li>IO::Socket::SSL::Utils - Useful functions for certificates etc</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="Essential_Information_About_SSL/TLS"><a class="permalink" href="#Essential_Information_About_SSL/TLS">Essential
  Information About SSL/TLS</a></h1>
<p class="Pp">SSL (Secure Socket Layer) or its successor TLS (Transport Layer
    Security) are protocols to facilitate end-to-end security. These protocols
    are used when accessing web sites (https), delivering or retrieving email,
    and in lots of other use cases. In the following documentation we will refer
    to both SSL and TLS as simply 'SSL'.</p>
<p class="Pp">SSL enables end-to-end security by providing two essential
    functions:</p>
<dl class="Bl-tag">
  <dt id="Encryption"><a class="permalink" href="#Encryption">Encryption</a></dt>
  <dd>This part encrypts the data for transit between the communicating parties,
      so that nobody in between can read them. It also provides tamper
      resistance so that nobody in between can manipulate the data.</dd>
  <dt id="Identification"><a class="permalink" href="#Identification">Identification</a></dt>
  <dd>This part makes sure that you talk to the right peer. If the
      identification is done incorrectly it is easy to mount man-in-the-middle
      attacks, e.g. if Alice wants to talk to Bob it would be possible for
      Mallory to put itself in the middle, so that Alice talks to Mallory and
      Mallory to Bob. All the data would still be encrypted, but not end-to-end
      between Alice and Bob, but only between Alice and Mallory and then between
      Mallory and Bob. Thus Mallory would be able to read and modify all traffic
      between Alice and Bob.</dd>
</dl>
<p class="Pp">Identification is the part which is the hardest to understand and
    the easiest to get wrong.</p>
<p class="Pp">With SSL, the Identification is usually done with
    <b>certificates</b> inside a <b>PKI</b> (Public Key Infrastructure). These
    Certificates are comparable to an identity card, which contains information
    about the owner of the card. The card then is somehow <b>signed</b> by the
    <b>issuer</b> of the card, the <b>CA</b> (Certificate Agency).</p>
<p class="Pp">To verify the identity of the peer the following must be done
    inside SSL:</p>
<ul class="Bl-bullet">
  <li>Get the certificate from the peer. If the peer does not present a
      certificate we cannot verify it.</li>
  <li>Check if we trust the certificate, e.g. make sure it's not a forgery.
    <p class="Pp">We believe that a certificate is not a fake if we either know
        the certificate already or if we <b>trust</b> the issuer (the CA) and
        can verify the issuers signature on the certificate. In reality there is
        often a hierarchy of certificate agencies and we only directly trust the
        root of this hierarchy. In this case the peer not only sends his own
        certificate, but also all <b>intermediate certificates</b>. Verification
        will be done by building a <b>trust path</b> from the trusted root up to
        the peers certificate and checking in each step if the we can verify the
        issuer's signature.</p>
    <p class="Pp">This step often causes problems because the client does not
        know the necessary trusted root certificates. These are usually stored
        in a system dependent CA store, but often the browsers have their own CA
        store.</p>
  </li>
  <li>Check if the certificate is still valid. Each certificate has a lifetime
      and should not be used after that time because it might be compromised or
      the underlying cryptography got broken in the mean time.</li>
  <li>Check if the subject of the certificate matches the peer. This is like
      comparing the picture on the identity card against the person representing
      the identity card.
    <p class="Pp">When connecting to a server this is usually done by comparing
        the hostname used for connecting against the names represented in the
        certificate. A certificate might contain multiple names or wildcards, so
        that it can be used for multiple hosts (e.g. *.example.com and
        *.example.org).</p>
    <p class="Pp">Although nobody sane would accept an identity card where the
        picture does not match the person we see, it is a common implementation
        error with SSL to omit this check or get it wrong.</p>
  </li>
  <li>Check if the certificate was revoked by the issuer. This might be the case
      if the certificate was compromised somehow and now somebody else might use
      it to claim the wrong identity. Such revocations happened a lot after the
      heartbleed attack.
    <p class="Pp">For SSL there are two ways to verify a revocation, CRL and
        OCSP. With CRLs (Certificate Revocation List) the CA provides a list of
        serial numbers for revoked certificates. The client somehow has to
        download the list (which can be huge) and keep it up to date. With OCSP
        (Online Certificate Status Protocol) the client can check a single
        certificate directly by asking the issuer.</p>
    <p class="Pp">Revocation is the hardest part of the verification and none of
        today's browsers get it fully correct. But, they are still better than
        most other implementations which don't implement revocation checks or
        leave the hard parts to the developer.</p>
  </li>
</ul>
<p class="Pp">When accessing a web site with SSL or delivering mail in a secure
    way the identity is usually only checked one way, e.g. the client wants to
    make sure it talks to the right server, but the server usually does not care
    which client it talks to. But, sometimes the server wants to identify the
    client too and will request a certificate from the client which the server
    must verify in a similar way.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Basic_SSL_Client"><a class="permalink" href="#Basic_SSL_Client">Basic
  SSL Client</a></h1>
<p class="Pp">A basic SSL client is simple:</p>
<p class="Pp"></p>
<pre>    my $client = IO::Socket::SSL-&gt;new('www.example.com:443')
        or die &quot;error=$!, ssl_error=$SSL_ERROR&quot;;
</pre>
<p class="Pp">This will take the OpenSSL default CA store as the store for the
    trusted CA. This usually works on UNIX systems. If there are no certificates
    in the store it will try use Mozilla::CA which provides the default CAs of
    Firefox.</p>
<p class="Pp">In the default settings, IO::Socket::SSL will use a safer cipher
    set and SSL version, do a proper hostname check against the certificate, and
    use SNI (server name indication) to send the hostname inside the SSL
    handshake. This is necessary to work with servers which have different
    certificates behind the same IP address. It will also check the revocation
    of the certificate with OCSP, but currently only if the server provides OCSP
    stapling (for deeper checks see
    <span class="Li">&quot;ocsp_resolver&quot;</span> method).</p>
<p class="Pp">Lots of options can be used to change ciphers, SSL version,
    location of CA and much more. See documentation of methods for details.</p>
<p class="Pp">With protocols like SMTP it is necessary to upgrade an existing
    socket to SSL. This can be done like this:</p>
<p class="Pp"></p>
<pre>    my $client = IO::Socket::INET-&gt;new('mx.example.com:25') or die $!;
    # .. read greeting from server
    # .. send EHLO and read response
    # .. send STARTTLS command and read response
    # .. if response was successful we can upgrade the socket to SSL now:
    IO::Socket::SSL-&gt;start_SSL($client,
        # explicitly set hostname we should use for SNI
        SSL_hostname =&gt; 'mx.example.com'
    ) or die $SSL_ERROR;
</pre>
<p class="Pp">A more complete example for a simple HTTP client:</p>
<p class="Pp"></p>
<pre>    my $client = IO::Socket::SSL-&gt;new(
        # where to connect
        PeerHost =&gt; &quot;www.example.com&quot;,
        PeerPort =&gt; &quot;https&quot;,
        # certificate verification - VERIFY_PEER is default
        SSL_verify_mode =&gt; SSL_VERIFY_PEER,
        # location of CA store
        # need only be given if default store should not be used
        SSL_ca_path =&gt; '/etc/ssl/certs', # typical CA path on Linux
        SSL_ca_file =&gt; '/etc/ssl/cert.pem', # typical CA file on BSD
        # or just use default path on system:
        IO::Socket::SSL::default_ca(), # either explicitly
        # or implicitly by not giving SSL_ca_*
        # easy hostname verification
        # It will use PeerHost as default name a verification
        # scheme as default, which is safe enough for most purposes.
        SSL_verifycn_name =&gt; 'foo.bar',
        SSL_verifycn_scheme =&gt; 'http',
        # SNI support - defaults to PeerHost
        SSL_hostname =&gt; 'foo.bar',
    ) or die &quot;failed connect or ssl handshake: $!,$SSL_ERROR&quot;;
    # send and receive over SSL connection
    print $client &quot;GET / HTTP/1.0\r\n\r\n&quot;;
    print &lt;$client&gt;;
</pre>
<p class="Pp">And to do revocation checks with OCSP (only available with OpenSSL
    1.0.0 or higher and Net::SSLeay 1.59 or higher):</p>
<p class="Pp"></p>
<pre>    # default will try OCSP stapling and check only leaf certificate
    my $client = IO::Socket::SSL-&gt;new($dst);
    # better yet: require checking of full chain
    my $client = IO::Socket::SSL-&gt;new(
        PeerAddr =&gt; $dst,
        SSL_ocsp_mode =&gt; SSL_OCSP_FULL_CHAIN,
    );
    # even better: make OCSP errors fatal
    # (this will probably fail with lots of sites because of bad OCSP setups)
    # also use common OCSP response cache
    my $ocsp_cache = IO::Socket::SSL::OCSP_Cache-&gt;new;
    my $client = IO::Socket::SSL-&gt;new(
        PeerAddr =&gt; $dst,
        SSL_ocsp_mode =&gt; SSL_OCSP_FULL_CHAIN|SSL_OCSP_FAIL_HARD,
        SSL_ocsp_cache =&gt; $ocsp_cache,
    );
    # disable OCSP stapling in case server has problems with it
    my $client = IO::Socket::SSL-&gt;new(
        PeerAddr =&gt; $dst,
        SSL_ocsp_mode =&gt; SSL_OCSP_NO_STAPLE,
    );
    # check any certificates which are not yet checked by OCSP stapling or
    # where we have already cached results. For your own resolving combine
    # $ocsp-&gt;requests with $ocsp-&gt;add_response(uri,response).
    my $ocsp = $client-&gt;ocsp_resolver();
    my $errors = $ocsp-&gt;resolve_blocking();
    if ($errors) {
        warn &quot;OCSP verification failed: $errors&quot;;
        close($client);
    }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="Basic_SSL_Server"><a class="permalink" href="#Basic_SSL_Server">Basic
  SSL Server</a></h1>
<p class="Pp">A basic SSL server looks similar to other IO::Socket servers, only
    that it also contains settings for certificate and key:</p>
<p class="Pp"></p>
<pre>    # simple server
    my $server = IO::Socket::SSL-&gt;new(
        # where to listen
        LocalAddr =&gt; '127.0.0.1',
        LocalPort =&gt; 8080,
        Listen =&gt; 10,
        # which certificate to offer
        # with SNI support there can be different certificates per hostname
        SSL_cert_file =&gt; 'cert.pem',
        SSL_key_file =&gt; 'key.pem',
    ) or die &quot;failed to listen: $!&quot;;
    # accept client
    my $client = $server-&gt;accept or die
        &quot;failed to accept or ssl handshake: $!,$SSL_ERROR&quot;;
</pre>
<p class="Pp">This will automatically use a secure set of ciphers and SSL
    version and also supports Forward Secrecy with (Elliptic-Curve)
    Diffie-Hellmann Key Exchange.</p>
<p class="Pp">If you are doing a forking or threading server, we recommend that
    you do the SSL handshake inside the new process/thread so that the master is
    free for new connections. We recommend this because a client with improper
    or slow SSL handshake could make the server block in the handshake which
    would be bad to do on the listening socket:</p>
<p class="Pp"></p>
<pre>    # inet server
    my $server = IO::Socket::INET-&gt;new(
        # where to listen
        LocalAddr =&gt; '127.0.0.1',
        LocalPort =&gt; 8080,
        Listen =&gt; 10,
    );
    # accept client
    my $client = $server-&gt;accept or die;
    # SSL upgrade client (in new process/thread)
    IO::Socket::SSL-&gt;start_SSL($client,
        SSL_server =&gt; 1,
        SSL_cert_file =&gt; 'cert.pem',
        SSL_key_file =&gt; 'key.pem',
    ) or die &quot;failed to ssl handshake: $SSL_ERROR&quot;;
</pre>
<p class="Pp">Like with normal sockets, neither forking nor threading servers
    scale well. It is recommended to use non-blocking sockets instead, see
    &quot;Using Non-Blocking Sockets&quot;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Common_Usage_Errors"><a class="permalink" href="#Common_Usage_Errors">Common
  Usage Errors</a></h1>
<p class="Pp">This is a list of typical errors seen with the use of
    IO::Socket::SSL:</p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>Disabling verification with
      <span class="Li">&quot;SSL_verify_mode&quot;</span>.
    <p class="Pp">As described in &quot;Essential Information About
        SSL/TLS&quot;, a proper identification of the peer is essential and
        failing to verify makes Man-In-The-Middle attacks possible.</p>
    <p class="Pp">Nevertheless, lots of scripts and even public modules or
        applications disable verification, because it is probably the easiest
        way to make the thing work and usually nobody notices any security
        problems anyway.</p>
    <p class="Pp">If the verification does not succeed with the default
        settings, one can do the following:</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>Make sure the needed CAs are in the store, maybe use
      <span class="Li">&quot;SSL_ca_file&quot;</span> or
      <span class="Li">&quot;SSL_ca_path&quot;</span> to specify a different CA
      store.</li>
  <li>If the validation fails because the certificate is self-signed and that's
      what you expect, you can use the
      <span class="Li">&quot;SSL_fingerprint&quot;</span> option to accept
      specific leaf certificates by their certificate or pubkey
    fingerprint.</li>
  <li>If the validation failed because the hostname does not match and you
      cannot access the host with the name given in the certificate, you can use
      <span class="Li">&quot;SSL_verifycn_name&quot;</span> to specify the
      hostname you expect in the certificate.</li>
</ul>
</div>
<div class="Bd-indent">
<p class="Pp">A common error pattern is also to disable verification if they
    found no CA store (different modules look at different &quot;default&quot;
    places). Because IO::Socket::SSL is now able to provide a usable CA store on
    most platforms (UNIX, Mac OSX and Windows) it is better to use the defaults
    provided by IO::Socket::SSL. If necessary these can be checked with the
    <span class="Li">&quot;default_ca&quot;</span> method.</p>
</div>
<ul class="Bl-bullet">
  <li>Polling of SSL sockets (e.g. select, poll and other event loops).
    <p class="Pp">If you sysread one byte on a normal socket it will result in a
        syscall to read one byte. Thus, if more than one byte is available on
        the socket it will be kept in the network stack of your OS and the next
        select or poll call will return the socket as readable. But, with SSL
        you don't deliver single bytes. Multiple data bytes are packaged and
        encrypted together in an SSL frame. Decryption can only be done on the
        whole frame, so a sysread for one byte actually reads the complete SSL
        frame from the socket, decrypts it and returns the first decrypted byte.
        Further sysreads will return more bytes from the same frame until all
        bytes are returned and the next SSL frame will be read from the
      socket.</p>
    <p class="Pp">Thus, in order to decide if you can read more data (e.g. if
        sysread will block) you must check if there are still data in the
        current SSL frame by calling <span class="Li">&quot;pending&quot;</span>
        and if there are no data pending you might check the underlying socket
        with select or poll. Another way might be if you try to sysread at least
        16kByte all the time. 16kByte is the maximum size of an SSL frame and
        because sysread returns data from only a single SSL frame you can
        guarantee that there are no pending data.</p>
    <p class="Pp">Additionally, contrary to plain sockets the data delivered on
        the socket are not necessarily application payload. It might be a TLS
        handshake, it might just be the beginning of a TLS record or it might be
        TLS session tickets which are send after the TLS handshake in TLS 1.3.
        In such situations select will return that data are available for read
        since it only looks at the plain socket. A sysread on the
        IO::Socket::SSL socket will not return any data though since it is an
        abstraction which only returns application data. This causes the sysread
        to hang in case the socket was blocking or to return an error with
        EAGAIN on non-blocking sockets. Applications using select or similar
        should therefore set the socket to non-blocking and also expect that the
        sysread might temporarily fail with EAGAIN.</p>
    <p class="Pp">See also &quot;Using Non-Blocking Sockets&quot;.</p>
  </li>
  <li>Expecting exactly the same behavior as plain sockets.
    <p class="Pp">IO::Socket::SSL tries to emulate the usual socket behavior as
        good as possible, but full emulation can not be done. Specifically a
        read on the SSL socket might also result in a write on the TCP socket or
        a write on the SSL socket might result in a read on the TCP socket. Also
        <span class="Li">&quot;accept&quot;</span> and <b>close</b> on the SSL
        socket will result in writing and reading data to the TCP socket
      too.</p>
    <p class="Pp">Especially the hidden writes might result in a connection
        reset if the underlying TCP socket is already closed by the peer. Unless
        signal PIPE is explicitly handled by the application this will usually
        result in the application crashing. It is thus recommended to explicitly
        IGNORE signal PIPE so that the errors get propagated as EPIPE instead of
        causing a crash of the application.</p>
  </li>
  <li>Set 'SSL_version' or 'SSL_cipher_list' to a &quot;better&quot; value.
    <p class="Pp">IO::Socket::SSL tries to set these values to reasonable,
        secure values which are compatible with the rest of the world. But,
        there are some scripts or modules out there which tried to be smart and
        get more secure or compatible settings. Unfortunately, they did this
        years ago and never updated these values, so they are still forced to do
        only 'TLSv1' (instead of also using TLSv12 or TLSv11). Or they set
        'HIGH' as the cipher list and thought they were secure, but did not
        notice that 'HIGH' includes anonymous ciphers, e.g. without
        identification of the peer.</p>
    <p class="Pp">So it is recommended to leave the settings at the secure
        defaults which IO::Socket::SSL sets and which get updated from time to
        time to better fit the real world.</p>
  </li>
  <li>Make SSL settings inaccessible by the user, together with bad builtin
      settings.
    <p class="Pp">Some modules use IO::Socket::SSL, but don't make the SSL
        settings available to the user. This is often combined with bad builtin
        settings or defaults (like switching verification off).</p>
    <p class="Pp">Thus the user needs to hack around these restrictions by using
        <span class="Li">&quot;set_args_filter_hack&quot;</span> or similar.</p>
  </li>
  <li>Use of constants as strings.
    <p class="Pp">Constants like
        <span class="Li">&quot;SSL_VERIFY_PEER&quot;</span> or
        <span class="Li">&quot;SSL_WANT_READ&quot;</span> should be used as
        constants and not be put inside quotes, because they represent numerical
        values.</p>
  </li>
  <li>Forking and handling the socket in parent and child.
    <p class="Pp">A <b>fork</b> of the process will duplicate the internal user
        space SSL state of the socket. If both master and child interact with
        the socket by using their own SSL state strange error messages will
        happen. Such interaction includes explicit or implicit <b>close</b> of
        the SSL socket. To avoid this the socket should be explicitly closed
        with <b>SSL_no_shutdown</b>.</p>
  </li>
  <li>Forking and executing a new process.
    <p class="Pp">Since the SSL state is stored in user space it will be
        duplicated by a <b>fork</b> but it will be lost when doing <b>exec</b>.
        This means it is not possible to simply redirect stdin and stdout for
        the new process to the SSL socket by duplicating the relevant file
        handles. Instead explicitly exchanging plain data between child-process
        and SSL socket are needed.</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="Common_Problems_with_SSL"><a class="permalink" href="#Common_Problems_with_SSL">Common
  Problems with SSL</a></h1>
<p class="Pp">SSL is a complex protocol with multiple implementations and each
    of these has their own quirks. While most of these implementations work
    together, it often gets problematic with older versions, minimal versions in
    load balancers, or plain wrong setups.</p>
<p class="Pp">Unfortunately these problems are hard to debug. Helpful for
    debugging are a knowledge of SSL internals, wireshark and the use of the
    debug settings of IO::Socket::SSL and Net::SSLeay, which can both be set
    with <span class="Li">$IO::Socket::SSL::DEBUG</span>. The following debugs
    levels are defined, but used not in any consistent way:</p>
<ul class="Bl-bullet">
  <li>0 - No debugging (default).</li>
  <li>1 - Print out errors from IO::Socket::SSL and ciphers from
    Net::SSLeay.</li>
  <li>2 - Print also information about call flow from IO::Socket::SSL and
      progress information from Net::SSLeay.</li>
  <li>3 - Print also some data dumps from IO::Socket::SSL and from
    Net::SSLeay.</li>
</ul>
<p class="Pp">Also, <span class="Li">&quot;analyze-ssl.pl&quot;</span> from the
    ssl-tools repository at &lt;https://github.com/noxxi/p5-ssl-tools&gt; might
    be a helpful tool when debugging SSL problems, as do the
    <span class="Li">&quot;openssl&quot;</span> command line tool and a check
    with a different SSL implementation (e.g. a web browser).</p>
<p class="Pp">The following problems are not uncommon:</p>
<ul class="Bl-bullet">
  <li>Bad server setup: missing intermediate certificates.
    <p class="Pp">It is a regular problem that administrators fail to include
        all necessary certificates into their server setup, e.g. everything
        needed to build the trust chain from the trusted root. If they check the
        setup with the browser everything looks ok, because browsers work around
        these problems by caching any intermediate certificates and apply them
        to new connections if certificates are missing.</p>
    <p class="Pp">But, fresh browser profiles which have never seen these
        intermediates cannot fill in the missing certificates and fail to
        verify; the same is true with IO::Socket::SSL.</p>
  </li>
  <li>Old versions of servers or load balancers which do not understand specific
      TLS versions or croak on specific data.
    <p class="Pp">From time to time one encounters an SSL peer, which just
        closes the connection inside the SSL handshake. This can usually be
        worked around by downgrading the SSL version, e.g. by setting
        <span class="Li">&quot;SSL_version&quot;</span>. Modern Browsers usually
        deal with such servers by automatically downgrading the SSL version and
        repeat the connection attempt until they succeed.</p>
    <p class="Pp">Worse servers do not close the underlying TCP connection but
        instead just drop the relevant packet. This is harder to detect because
        it looks like a stalled connection. But downgrading the SSL version
        often works here too.</p>
    <p class="Pp">A cause of such problems are often load balancers or security
        devices, which have hardware acceleration and only a minimal (and less
        robust) SSL stack. They can often be detected because they support much
        fewer ciphers than other implementations.</p>
  </li>
  <li>Bad or old OpenSSL versions.
    <p class="Pp">IO::Socket::SSL uses OpenSSL with the help of the Net::SSLeay
        library. It is recommend to have a recent version of this library,
        because it has more features and usually fewer known bugs.</p>
  </li>
  <li>Validation of client certificates fail.
    <p class="Pp">Make sure that the purpose of the certificate allows use as
        ssl client (check with <span class="Li">&quot;openssl x509
        -purpose&quot;</span>, that the necessary root certificate is in the
        path specified by <span class="Li">&quot;SSL_ca*&quot;</span> (or the
        default path) and that any intermediate certificates needed to build the
        trust chain are sent by the client.</p>
  </li>
  <li>Validation of self-signed certificate fails even if it is given with
      <span class="Li">&quot;SSL_ca*&quot;</span> argument.
    <p class="Pp">The <span class="Li">&quot;SSL_ca*&quot;</span> arguments do
        not give a general trust store for arbitrary certificates but only
        specify a store for CA certificates which then can be used to verify
        other certificates. This especially means that certificates which are
        not a CA get simply ignored, notably self-signed certificates which do
        not also have the CA-flag set.</p>
    <p class="Pp">This behavior of OpenSSL differs from the more general
        trust-store concept which can be found in browsers and where it is
        possible to simply added arbitrary certificates (CA or not) as
      trusted.</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="Using_Non-Blocking_Sockets"><a class="permalink" href="#Using_Non-Blocking_Sockets">Using
  Non-Blocking Sockets</a></h1>
<p class="Pp">If you have a non-blocking socket, the expected behavior on read,
    write, accept or connect is to set <span class="Li">$!</span> to EWOULDBLOCK
    if the operation cannot be completed immediately. Note that EWOULDBLOCK is
    the same as EAGAIN on UNIX systems, but is different on Windows.</p>
<p class="Pp">With SSL, handshakes might occur at any time, even within an
    established connection. In these cases it is necessary to finish the
    handshake before you can read or write data. This might result in situations
    where you want to read but must first finish the write of a handshake or
    where you want to write but must first finish a read. In these cases
    <span class="Li">$!</span> is set to EAGAIN like expected, and additionally
    <span class="Li">$SSL_ERROR</span> is set to either SSL_WANT_READ or
    SSL_WANT_WRITE. Thus if you get EWOULDBLOCK on a SSL socket you must check
    <span class="Li">$SSL_ERROR</span> for SSL_WANT_* and adapt your event mask
    accordingly.</p>
<p class="Pp">Using readline on non-blocking sockets does not make much sense
    and I would advise against using it. And, while the behavior is not
    documented for other IO::Socket classes, it will try to emulate the behavior
    seen there, e.g. to return the received data instead of blocking, even if
    the line is not complete. If an unrecoverable error occurs it will return
    nothing, even if it already received some data.</p>
<p class="Pp">Also, I would advise against using
    <span class="Li">&quot;accept&quot;</span> with a non-blocking SSL object
    because it might block and this is not what most would expect. The reason
    for this is that <span class="Li">&quot;accept&quot;</span> on a
    non-blocking TCP socket (e.g. IO::Socket::IP, IO::Socket::INET..) results in
    a new TCP socket which does not inherit the non-blocking behavior of the
    master socket. And thus, the initial SSL handshake on the new socket inside
    <span class="Li">&quot;IO::Socket::SSL::accept&quot;</span> will be done in
    a blocking way. To work around this you are safer by doing a TCP accept and
    later upgrade the TCP socket in a non-blocking way with
    <span class="Li">&quot;start_SSL&quot;</span> and
    <span class="Li">&quot;accept_SSL&quot;</span>.</p>
<p class="Pp"></p>
<pre>    my $cl = IO::Socket::SSL-&gt;new($dst);
    $cl-&gt;blocking(0);
    my $sel = IO::Select-&gt;new($cl);
    while (1) {
        # with SSL a call for reading n bytes does not result in reading of n
        # bytes from the socket, but instead it must read at least one full SSL
        # frame. If the socket has no new bytes, but there are unprocessed data
        # from the SSL frame can_read will block!
        # wait for data on socket
        $sel-&gt;can_read();
        # new data on socket or eof
        READ:
        # this does not read only 1 byte from socket, but reads the complete SSL
        # frame and then just returns one byte. On subsequent calls it than
        # returns more byte of the same SSL frame until it needs to read the
        # next frame.
        my $n = sysread( $cl,my $buf,1);
        if ( ! defined $n ) {
            die $! if not $!{EWOULDBLOCK};
            next if $SSL_ERROR == SSL_WANT_READ;
            if ( $SSL_ERROR == SSL_WANT_WRITE ) {
                # need to write data on renegotiation
                $sel-&gt;can_write;
                next;
            }
            die &quot;something went wrong: $SSL_ERROR&quot;;
        } elsif ( ! $n ) {
            last; # eof
        } else {
            # read next bytes
            # we might have still data within the current SSL frame
            # thus first process these data instead of waiting on the underlying
            # socket object
            goto READ if $cl-&gt;pending;    # goto sysread
            next;                         # goto $sel-&gt;can_read
        }
    }
</pre>
<p class="Pp">Additionally there are differences to plain sockets when using
    select, poll, kqueue or similar technologies to get notified if data are
    available. Relying only on these calls is not sufficient in all cases since
    unread data might be internally buffered in the SSL stack. To detect such
    buffering <b></b><b>pending()</b><b></b> need to be used. Alternatively the
    buffering can be avoided by using <b>sysread</b> with the maximum size of an
    SSL frame. See &quot;Common Usage Errors&quot; for details.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Advanced_Usage"><a class="permalink" href="#Advanced_Usage">Advanced
  Usage</a></h1>
<section class="Ss">
<h2 class="Ss">SNI Support</h2>
<p class="Pp">Newer extensions to SSL can distinguish between multiple hostnames
    on the same IP address using Server Name Indication (SNI).</p>
<p class="Pp">Support for SNI on the client side was added somewhere in the
    OpenSSL 0.9.8 series, but with 1.0 a bug was fixed when the server could not
    decide about its hostname. Therefore client side SNI is only supported with
    OpenSSL 1.0 or higher in IO::Socket::SSL. With a supported version, SNI is
    used automatically on the client side, if it can determine the hostname from
    <span class="Li">&quot;PeerAddr&quot;</span> or
    <span class="Li">&quot;PeerHost&quot;</span> (which are synonyms in the
    underlying IO::Socket:: classes and thus should never be set both or at
    least not to different values). On unsupported OpenSSL versions it will
    silently not use SNI. The hostname can also be given explicitly given with
    <span class="Li">&quot;SSL_hostname&quot;</span>, but in this case it will
    throw in error, if SNI is not supported. To check for support you might call
    <span class="Li">&quot;IO::Socket::SSL-&gt;can_client_sni()&quot;</span>.</p>
<p class="Pp">On the server side, earlier versions of OpenSSL are supported, but
    only together with Net::SSLeay version &gt;= 1.50. To check for support you
    might call
    <span class="Li">&quot;IO::Socket::SSL-&gt;can_server_sni()&quot;</span>. If
    server side SNI is supported, you might specify different certificates per
    host with <span class="Li">&quot;SSL_cert*&quot;</span> and
    <span class="Li">&quot;SSL_key*&quot;</span>, and check the requested name
    using <span class="Li">&quot;get_servername&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Talk_Plain_and_"><a class="permalink" href="#Talk_Plain_and_">Talk
  Plain and SSL With The Same Socket</a></h2>
<p class="Pp">It is often required to first exchange some plain data and then
    upgrade the socket to SSL after some kind of STARTTLS command. Protocols
    like FTPS even need a way to downgrade the socket again back to plain.</p>
<p class="Pp">The common way to do this would be to create a normal socket and
    use <span class="Li">&quot;start_SSL&quot;</span> to upgrade and stop_SSL to
    downgrade:</p>
<p class="Pp"></p>
<pre>    my $sock = IO::Socket::INET-&gt;new(...) or die $!;
    ... exchange plain data on $sock until starttls command ...
    IO::Socket::SSL-&gt;start_SSL($sock,%sslargs) or die $SSL_ERROR;
    ... now $sock is an IO::Socket::SSL object ...
    ... exchange data with SSL on $sock until stoptls command ...
    $sock-&gt;stop_SSL or die $SSL_ERROR;
    ... now $sock is again an IO::Socket::INET object ...
</pre>
<p class="Pp">But, lots of modules just derive directly from IO::Socket::INET.
    While this base class can be replaced with IO::Socket::SSL, these modules
    cannot easily support different base classes for SSL and plain data and
    switch between these classes on a starttls command.</p>
<p class="Pp">To help in this case, IO::Socket::SSL can be reduced to a plain
    socket on startup, and connect_SSL/accept_SSL/start_SSL can be used to
    enable SSL and <span class="Li">&quot;stop_SSL&quot;</span> to talk plain
    again:</p>
<p class="Pp"></p>
<pre>    my $sock = IO::Socket::SSL-&gt;new(
        PeerAddr =&gt; ...
        SSL_startHandshake =&gt; 0,
        %sslargs
    ) or die $!;
    ... exchange plain data on $sock until starttls command ...
    $sock-&gt;connect_SSL or die $SSL_ERROR;
    ... now $sock is an IO::Socket::SSL object ...
    ... exchange data with SSL on $sock until stoptls command ...
    $sock-&gt;stop_SSL or die $SSL_ERROR;
    ... $sock is still an IO::Socket::SSL object ...
    ... but data exchanged again in plain ...
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Integration_Into_Own_Modules"><a class="permalink" href="#Integration_Into_Own_Modules">Integration
  Into Own Modules</a></h1>
<p class="Pp">IO::Socket::SSL behaves similarly to other IO::Socket modules and
    thus could be integrated in the same way, but you have to take special care
    when using non-blocking I/O (like for handling timeouts) or using select or
    poll. Please study the documentation on how to deal with these
  differences.</p>
<p class="Pp">Also, it is recommended to not set or touch most of the
    <span class="Li">&quot;SSL_*&quot;</span> options, so that they keep their
    secure defaults. It is also recommended to let the user override these SSL
    specific settings without the need of global settings or hacks like
    <span class="Li">&quot;set_args_filter_hack&quot;</span>.</p>
<p class="Pp">The notable exception is
    <span class="Li">&quot;SSL_verifycn_scheme&quot;</span>. This should be set
    to the hostname verification scheme required by the module or protocol.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Description_Of_Methods"><a class="permalink" href="#Description_Of_Methods">Description
  Of Methods</a></h1>
<p class="Pp">IO::Socket::SSL inherits from another IO::Socket module. The
    choice of the super class depends on the installed modules:</p>
<ul class="Bl-bullet">
  <li>If IO::Socket::IP with at least version 0.20 is installed it will use this
      module as super class, transparently providing IPv6 and IPv4 support.</li>
  <li>If IO::Socket::INET6 is installed it will use this module as super class,
      transparently providing IPv6 and IPv4 support.</li>
  <li>Otherwise it will fall back to IO::Socket::INET, which is a perl core
      module. With IO::Socket::INET you only get IPv4 support.</li>
</ul>
<p class="Pp">Please be aware that with the IPv6 capable super classes, it will
    look first for the IPv6 address of a given hostname. If the resolver
    provides an IPv6 address, but the host cannot be reached by IPv6, there will
    be no automatic fallback to IPv4. To avoid these problems you can enforce
    IPv4 for a specific socket by using the
    <span class="Li">&quot;Domain&quot;</span> or
    <span class="Li">&quot;Family&quot;</span> option with the value AF_INET as
    described in IO::Socket::IP. Alternatively you can enforce IPv4 globally by
    loading IO::Socket::SSL with the option 'inet4', in which case it will use
    the IPv4 only class IO::Socket::INET as the super class.</p>
<p class="Pp">IO::Socket::SSL will provide all of the methods of its super
    class, but sometimes it will override them to match the behavior expected
    from SSL or to provide additional arguments.</p>
<p class="Pp">The new or changed methods are described below, but please also
    read the section about SSL specific error handling.</p>
<dl class="Bl-tag">
  <dt id="Error"><a class="permalink" href="#Error">Error Handling</a></dt>
  <dd>If an SSL specific error occurs, the global variable
      <span class="Li">$SSL_ERROR</span> will be set. If the error occurred on
      an existing SSL socket, the method
      <span class="Li">&quot;errstr&quot;</span> will give access to the latest
      socket specific error. Both <span class="Li">$SSL_ERROR</span> and the
      <span class="Li">&quot;errstr&quot;</span> method give a dualvar similar
      to <span class="Li">$!</span>, e.g. providing an error number in numeric
      context or an error description in string context.</dd>
  <dt id="new(...)"><a class="permalink" href="#new(...)"><b>new(...)</b></a></dt>
  <dd>Creates a new IO::Socket::SSL object. You may use all the friendly options
      that came bundled with the super class (e.g. IO::Socket::IP,
      IO::Socket::INET, ...) plus (optionally) the ones described below. If you
      don't specify any SSL related options it will do its best in using secure
      defaults, e.g. choosing good ciphers, enabling proper verification,
    etc.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="SSL_server"><a class="permalink" href="#SSL_server">SSL_server</a></dt>
  <dd>Set this option to a true value if the socket should be used as a server.
      If this is not explicitly set it is assumed if the
      <span class="Li">&quot;Listen&quot;</span> parameter is given when
      creating the socket.</dd>
  <dt id="SSL_hostname"><a class="permalink" href="#SSL_hostname">SSL_hostname</a></dt>
  <dd>This can be given to specify the hostname used for SNI, which is needed if
      you have multiple SSL hostnames on the same IP address. If not given it
      will try to determine the hostname from
      <span class="Li">&quot;PeerAddr&quot;</span>, which will fail if only an
      IP was given or if this argument is used within
      <span class="Li">&quot;start_SSL&quot;</span>.
    <p class="Pp">If you want to disable SNI, set this argument to ''.</p>
    <p class="Pp">Currently only supported for the client side and will be
        ignored for the server side.</p>
    <p class="Pp">See section &quot;SNI Support&quot; for details of SNI the
        support.</p>
  </dd>
  <dt id="SSL_startHandshake"><a class="permalink" href="#SSL_startHandshake">SSL_startHandshake</a></dt>
  <dd>If this option is set to false (defaults to true) it will not start the
      SSL handshake yet. This has to be done later with
      <span class="Li">&quot;accept_SSL&quot;</span> or
      <span class="Li">&quot;connect_SSL&quot;</span>. Before the handshake is
      started read/write/etc. can be used to exchange plain data.</dd>
  <dt id="SSL_keepSocketOnError"><a class="permalink" href="#SSL_keepSocketOnError">SSL_keepSocketOnError</a></dt>
  <dd>If this option is set to true (defaults to false) it will not close the
      underlying TCP socket on errors. In most cases there is no real use for
      this behavior since both sides of the TCP connection will probably have a
      different idea of the current state of the connection.</dd>
  <dt id="SSL_ca"><a class="permalink" href="#SSL_ca">SSL_ca | SSL_ca_file |
    SSL_ca_path</a></dt>
  <dd>Usually you want to verify that the peer certificate has been signed by a
      trusted certificate authority. In this case you should use this option to
      specify the file (<span class="Li">&quot;SSL_ca_file&quot;</span>) or
      directory (<span class="Li">&quot;SSL_ca_path&quot;</span>) containing the
      certificate(s) of the trusted certificate authorities.
    <p class="Pp"><span class="Li">&quot;SSL_ca_path&quot;</span> can also be an
        array or a string containing multiple path, where the path are separated
        by the platform specific separator. This separator is
        <span class="Li">&quot;;&quot;</span> on DOS, Windows, Netware,
        <span class="Li">&quot;,&quot;</span> on VMS and
        <span class="Li">&quot;:&quot;</span> for all the other systems. If
        multiple path are given at least one of these must be accessible.</p>
    <p class="Pp">You can also give a list of X509* certificate handles (like
        you get from Net::SSLeay or IO::Socket::SSL::Utils::PEM_xxx2cert) with
        <span class="Li">&quot;SSL_ca&quot;</span>. These will be added to the
        CA store before path and file and thus take precedence. If neither
        SSL_ca, nor SSL_ca_file or SSL_ca_path are set it will use
        <span class="Li">&quot;default_ca()&quot;</span> to determine the
        user-set or system defaults. If you really don't want to set a CA set
        SSL_ca_file or SSL_ca_path to <span class="Li">&quot;\undef&quot;</span>
        or SSL_ca to an empty list. (unfortunately <span class="Li">''</span> is
        used by some modules using IO::Socket::SSL when CA is not explicitly
        given).</p>
  </dd>
  <dt id="SSL_client_ca"><a class="permalink" href="#SSL_client_ca">SSL_client_ca
    | SSL_client_ca_file</a></dt>
  <dd>If verify_mode is VERIFY_PEER on the server side these options can be used
      to set the list of acceptable CAs for the client. This way the client can
      select they required certificate from a list of certificates. The value
      for these options is similar to <span class="Li">&quot;SSL_ca&quot;</span>
      and <span class="Li">&quot;SSL_ca_file&quot;</span>.</dd>
  <dt id="SSL_fingerprint"><a class="permalink" href="#SSL_fingerprint">SSL_fingerprint</a></dt>
  <dd>Sometimes you have a self-signed certificate or a certificate issued by an
      unknown CA and you really want to accept it, but don't want to disable
      verification at all. In this case you can specify the fingerprint of the
      certificate as <span class="Li">'algo$hex_fingerprint'</span>.
      <span class="Li">&quot;algo&quot;</span> is a fingerprint algorithm
      supported by OpenSSL, e.g. 'sha1','sha256'... and
      <span class="Li">&quot;hex_fingerprint&quot;</span> is the hexadecimal
      representation of the binary fingerprint. Any colons inside the hex string
      will be ignored.
    <p class="Pp">If you want to use the fingerprint of the pubkey inside the
        certificate instead of the certificate use the syntax
        <span class="Li">'algo$pub$hex_fingerprint'</span> instead. To get the
        fingerprint of an established connection you can use
        <span class="Li">&quot;get_fingerprint&quot;</span>.</p>
    <p class="Pp">It is also possible to skip
        <span class="Li">&quot;algo$&quot;</span>, i.e. only specify the
        fingerprint. In this case the likely algorithms will be automatically
        detected based on the length of the digest string.</p>
    <p class="Pp">You can specify a list of fingerprints in case you have
        several acceptable certificates. If a fingerprint matches the topmost
        (i.e. leaf) certificate no additional validations can make the
        verification fail.</p>
  </dd>
  <dt id="SSL_cert_file"><a class="permalink" href="#SSL_cert_file">SSL_cert_file
    | SSL_cert | SSL_key_file | SSL_key</a></dt>
  <dd>If you create a server you usually need to specify a server certificate
      which should be verified by the client. Same is true for client
      certificates, which should be verified by the server. The certificate can
      be given as a file with SSL_cert_file or as an internal representation of
      an X509* object (like you get from Net::SSLeay or
      IO::Socket::SSL::Utils::PEM_xxx2cert) with SSL_cert. If given as a file it
      will automatically detect the format. Supported file formats are PEM, DER
      and PKCS#12, where PEM and PKCS#12 can contain the certificate and the
      chain to use, while DER can only contain a single certificate.
    <p class="Pp">If given as a list of X509* please note, that the all the
        chain certificates (e.g. all except the first) will be
        &quot;consumed&quot; by openssl and will be freed if the SSL context
        gets destroyed - so you should never free them yourself. But the servers
        certificate (e.g. the first) will not be consumed by openssl and thus
        must be freed by the application.</p>
    <p class="Pp">For each certificate a key is need, which can either be given
        as a file with SSL_key_file or as an internal representation of an
        EVP_PKEY* object with SSL_key (like you get from Net::SSLeay or
        IO::Socket::SSL::Utils::PEM_xxx2key). If a key was already given within
        the PKCS#12 file specified by SSL_cert_file it will ignore any SSL_key
        or SSL_key_file. If no SSL_key or SSL_key_file was given it will try to
        use the PEM file given with SSL_cert_file again, maybe it contains the
        key too.</p>
    <p class="Pp">If your SSL server should be able to use different
        certificates on the same IP address, depending on the name given by SNI,
        you can use a hash reference instead of a file with
        <span class="Li">&quot;&lt;hostname =&quot;</span>
      cert_file&gt;&gt;.</p>
    <p class="Pp">If your SSL server should be able to use both RSA and ECDSA
        certificates for the same domain/IP a similar hash reference like with
        SNI is given. The domain names used to specify the additional
        certificates should be
        <span class="Li">&quot;hostname%whatever&quot;</span>, i.e.
        <span class="Li">&quot;hostname%ecc&quot;</span> or similar. This needs
        at least OpenSSL 1.0.2. To let the server pick the certificate based on
        the clients cipher preference
        <span class="Li">&quot;SSL_honor_cipher_order&quot;</span> should be set
        to false.</p>
    <p class="Pp">In case certs and keys are needed but not given it might fall
        back to builtin defaults, see &quot;Defaults for Cert, Key and
      CA&quot;.</p>
    <p class="Pp">Examples:</p>
    <p class="Pp"></p>
    <pre> SSL_cert_file =&gt; 'mycert.pem',
 SSL_key_file =&gt; 'mykey.pem',
 SSL_cert_file =&gt; {
    &quot;foo.example.org&quot; =&gt; 'foo-cert.pem',
    &quot;foo.example.org%ecc&quot; =&gt; 'foo-ecc-cert.pem',
    &quot;bar.example.org&quot; =&gt; 'bar-cert.pem',
    # used when nothing matches or client does not support SNI
    '' =&gt; 'default-cert.pem',
    '%ecc' =&gt; 'default-ecc-cert.pem',
 },
 SSL_key_file =&gt; {
    &quot;foo.example.org&quot; =&gt; 'foo-key.pem',
    &quot;foo.example.org%ecc&quot; =&gt; 'foo-ecc-key.pem',
    &quot;bar.example.org&quot; =&gt; 'bar-key.pem',
    # used when nothing matches or client does not support SNI
    '' =&gt; 'default-key.pem',
    '%ecc' =&gt; 'default-ecc-key.pem',
 }
    </pre>
  </dd>
  <dt id="SSL_passwd_cb"><a class="permalink" href="#SSL_passwd_cb">SSL_passwd_cb</a></dt>
  <dd>If your private key is encrypted, you might not want the default password
      prompt from Net::SSLeay. This option takes a reference to a subroutine
      that should return the password required to decrypt your private key.</dd>
  <dt id="SSL_use_cert"><a class="permalink" href="#SSL_use_cert">SSL_use_cert</a></dt>
  <dd>If this is true, it forces IO::Socket::SSL to use a certificate and key,
      even if you are setting up an SSL client. If this is set to 0 (the
      default), then you will only need a certificate and key if you are setting
      up a server.
    <p class="Pp">SSL_use_cert will implicitly be set if SSL_server is set. For
        convenience it is also set if it was not given but a cert was given for
        use (SSL_cert_file or similar).</p>
  </dd>
  <dt id="SSL_version"><a class="permalink" href="#SSL_version">SSL_version</a></dt>
  <dd>Sets the version of the SSL protocol used to transmit data. 'SSLv23' uses
      a handshake compatible with SSL2.0, SSL3.0 and TLS1.x, while 'SSLv2',
      'SSLv3', 'TLSv1', 'TLSv1_1', 'TLSv1_2', or 'TLSv1_3' restrict handshake
      and protocol to the specified version. All values are case-insensitive.
      Instead of 'TLSv1_1', 'TLSv1_2', and 'TLSv1_3' one can also use 'TLSv11',
      'TLSv12', and 'TLSv13'. Support for 'TLSv1_1', 'TLSv1_2', and 'TLSv1_3'
      requires recent versions of Net::SSLeay and openssl.
    <p class="Pp">Independent from the handshake format you can limit to set of
        accepted SSL versions by adding !version separated by ':'.</p>
    <p class="Pp">The default SSL_version is 'SSLv23:!SSLv3:!SSLv2' which means,
        that the handshake format is compatible to SSL2.0 and higher, but that
        the successful handshake is limited to TLS1.0 and higher, that is no
        SSL2.0 or SSL3.0 because both of these versions have serious security
        issues and should not be used anymore. You can also use !TLSv1_1 and
        !TLSv1_2 to disable TLS versions 1.1 and 1.2 while still allowing TLS
        version 1.0.</p>
    <p class="Pp">Setting the version instead to 'TLSv1' might break interaction
        with older clients, which need and SSL2.0 compatible handshake. On the
        other side some clients just close the connection when they receive a
        TLS version 1.1 request. In this case setting the version to
        'SSLv23:!SSLv2:!SSLv3:!TLSv1_1:!TLSv1_2' might help.</p>
  </dd>
  <dt id="SSL_cipher_list"><a class="permalink" href="#SSL_cipher_list">SSL_cipher_list</a></dt>
  <dd>If this option is set the cipher list for the connection will be set to
      the given value, e.g. something like 'ALL:!LOW:!EXP:!aNULL'. Look into the
      OpenSSL documentation
      (&lt;https://www.openssl.org/docs/manmaster/man1/openssl-ciphers.html#CIPHER-STRINGS&gt;)
      for more details.
    <p class="Pp">Unless you fail to contact your peer because of no shared
        ciphers it is recommended to leave this option at the default setting.
        The default setting prefers ciphers with forward secrecy, disables
        anonymous authentication and disables known insecure ciphers like MD5,
        DES etc. This gives a grade A result at the tests of SSL Labs. To use
        the less secure OpenSSL builtin default (whatever this is) set
        SSL_cipher_list to ''.</p>
    <p class="Pp">In case different cipher lists are needed for different SNI
        hosts a hash can be given with the host as key and the cipher suite as
        value, similar to <b>SSL_cert*</b>.</p>
  </dd>
  <dt id="SSL_honor_cipher_order"><a class="permalink" href="#SSL_honor_cipher_order">SSL_honor_cipher_order</a></dt>
  <dd>If this option is true the cipher order the server specified is used
      instead of the order proposed by the client. This option defaults to true
      to make use of our secure cipher list setting.</dd>
  <dt id="SSL_dh_file"><a class="permalink" href="#SSL_dh_file">SSL_dh_file</a></dt>
  <dd>To create a server which provides forward secrecy you need to either give
      the DH parameters or (better, because faster) the ECDH curve. This setting
      cares about DH parameters.
    <p class="Pp">To support non-elliptic Diffie-Hellman key exchange a suitable
        file needs to be given here or the SSL_dh should be used with an
        appropriate value. See dhparam command in openssl for more
      information.</p>
    <p class="Pp">If neither <span class="Li">&quot;SSL_dh_file&quot;</span> nor
        <span class="Li">&quot;SSL_dh&quot;</span> are set a builtin DH
        parameter with a length of 2048 bit is used to offer DH key exchange by
        default. If you don't want this (e.g. disable DH key exchange)
        explicitly set this or the <span class="Li">&quot;SSL_dh&quot;</span>
        parameter to undef.</p>
  </dd>
  <dt id="SSL_dh"><a class="permalink" href="#SSL_dh">SSL_dh</a></dt>
  <dd>Like SSL_dh_file, but instead of giving a file you use a preloaded or
      generated DH*.</dd>
  <dt id="SSL_ecdh_curve"><a class="permalink" href="#SSL_ecdh_curve">SSL_ecdh_curve</a></dt>
  <dd>To create a server which provides forward secrecy you need to either give
      the DH parameters or (better, because faster) the ECDH curve. This setting
      cares about the ECDH curve(s).
    <p class="Pp">To support Elliptic Curve Diffie-Hellmann key exchange the OID
        or NID of at least one suitable curve needs to be provided here.</p>
    <p class="Pp">With OpenSSL 1.1.0+ this parameter defaults to
        <span class="Li">&quot;auto&quot;</span>, which means that it lets
        OpenSSL pick the best settings. If support for CTX_set_ecdh_auto is
        implemented in Net::SSLeay (needs at least version 1.86) it will use
        this to implement the same default. Otherwise it will default to
        <span class="Li">&quot;prime256v1&quot;</span> (builtin of OpenSSL) in
        order to offer ECDH key exchange by default.</p>
    <p class="Pp">If setting groups or curves is supported by Net::SSLeay (needs
        at least version 1.86) then multiple curves can be given here in the
        order of the preference, i.e.
        <span class="Li">&quot;P-521:P-384:P-256&quot;</span>. When used at the
        client side this will include the supported curves as extension in the
        TLS handshake.</p>
    <p class="Pp">If you don't want to have ECDH key exchange this could be set
        to undef or set <span class="Li">&quot;SSL_ciphers&quot;</span> to
        exclude all of these ciphers.</p>
    <p class="Pp">You can check if ECDH support is available by calling
        <span class="Li">&quot;IO::Socket::SSL-&gt;can_ecdh&quot;</span>.</p>
  </dd>
  <dt id="SSL_verify_mode"><a class="permalink" href="#SSL_verify_mode">SSL_verify_mode</a></dt>
  <dd>This option sets the verification mode for the peer certificate. You may
      combine SSL_VERIFY_PEER (verify_peer), SSL_VERIFY_FAIL_IF_NO_PEER_CERT
      (fail verification if no peer certificate exists; ignored for clients),
      SSL_VERIFY_CLIENT_ONCE (verify client once; ignored for clients). See
      OpenSSL man page for SSL_CTX_set_verify for more information.
    <p class="Pp">The default is SSL_VERIFY_NONE for server (e.g. no check for
        client certificate) and SSL_VERIFY_PEER for client (check server
        certificate).</p>
  </dd>
  <dt id="SSL_verify_callback"><a class="permalink" href="#SSL_verify_callback">SSL_verify_callback</a></dt>
  <dd>If you want to verify certificates yourself, you can pass a sub reference
      along with this parameter to do so. When the callback is called, it will
      be passed:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>1. a true/false value that indicates what OpenSSL thinks of the
    certificate,</dt>
  <dd></dd>
  <dt>2. a C-style memory address of the certificate store,</dt>
  <dd></dd>
  <dt>3. a string containing the certificate's issuer attributes and owner
    attributes, and</dt>
  <dd></dd>
  <dt>4. a string containing any errors encountered (0 if no errors).</dt>
  <dd></dd>
  <dt>5. a C-style memory address of the peer's own certificate (convertible to
    PEM form with <b>Net::SSLeay::PEM_get_string_X509()</b>).</dt>
  <dd></dd>
  <dt>6. The depth of the certificate in the chain. Depth 0 is the leaf
    certificate.</dt>
  <dd></dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">The function should return 1 or 0, depending on whether it thinks
    the certificate is valid or invalid. The default is to let OpenSSL do all of
    the busy work.</p>
<p class="Pp">The callback will be called for each element in the certificate
    chain.</p>
<p class="Pp">See the OpenSSL documentation for SSL_CTX_set_verify for more
    information.</p>
</div>
<dl class="Bl-tag">
  <dt id="SSL_verifycn_scheme"><a class="permalink" href="#SSL_verifycn_scheme">SSL_verifycn_scheme</a></dt>
  <dd>The scheme is used to correctly verify the identity inside the certificate
      by using the hostname of the peer. See the information about the
      verification schemes in <b>verify_hostname</b>.
    <p class="Pp">If you don't specify a scheme it will use 'default', but only
        complain loudly if the name verification fails instead of letting the
        whole certificate verification fail. THIS WILL CHANGE, e.g. it will let
        the certificate verification fail in the future if the hostname does not
        match the certificate !!!! To override the name used in verification use
        <b>SSL_verifycn_name</b>.</p>
    <p class="Pp">The scheme 'default' is a superset of the usual schemes, which
        will accept the hostname in common name and subjectAltName and allow
        wildcards everywhere. While using this scheme is way more secure than no
        name verification at all you better should use the scheme specific to
        your application protocol, e.g. 'http', 'ftp'...</p>
    <p class="Pp">If you are really sure, that you don't want to verify the
        identity using the hostname you can use 'none' as a scheme. In this case
        you'd better have alternative forms of verification, like a certificate
        fingerprint or do a manual verification later by calling
        <b>verify_hostname</b> yourself.</p>
  </dd>
  <dt id="SSL_verifycn_publicsuffix"><a class="permalink" href="#SSL_verifycn_publicsuffix">SSL_verifycn_publicsuffix</a></dt>
  <dd>This option is used to specify the behavior when checking wildcards
      certificates for public suffixes, e.g. no wildcard certificates for *.com
      or *.co.uk should be accepted, while *.example.com or *.example.co.uk is
      ok.
    <p class="Pp">If not specified it will simply use the builtin default of
        IO::Socket::SSL::PublicSuffix, you can create another object with
        from_string or from_file of this module.</p>
    <p class="Pp">To disable verification of public suffix set this option to
        <span class="Li">''</span>.</p>
  </dd>
  <dt id="SSL_verifycn_name"><a class="permalink" href="#SSL_verifycn_name">SSL_verifycn_name</a></dt>
  <dd>Set the name which is used in verification of hostname. If
      SSL_verifycn_scheme is set and no SSL_verifycn_name is given it will try
      to use SSL_hostname or PeerHost and PeerAddr settings and fail if no name
      can be determined. If SSL_verifycn_scheme is not set it will use a default
      scheme and warn if it cannot determine a hostname, but it will not fail.
    <p class="Pp">Using PeerHost or PeerAddr works only if you create the
        connection directly with
        <span class="Li">&quot;IO::Socket::SSL-&gt;new&quot;</span>, if an
        IO::Socket::INET object is upgraded with <b>start_SSL</b> the name has
        to be given in <b>SSL_verifycn_name</b> or <b>SSL_hostname</b>.</p>
  </dd>
  <dt id="SSL_check_crl"><a class="permalink" href="#SSL_check_crl">SSL_check_crl</a></dt>
  <dd>If you want to verify that the peer certificate has not been revoked by
      the signing authority, set this value to true. OpenSSL will search for the
      CRL in your SSL_ca_path, or use the file specified by SSL_crl_file. See
      the Net::SSLeay documentation for more details. Note that this
      functionality appears to be broken with OpenSSL &lt; v0.9.7b, so its use
      with lower versions will result in an error.</dd>
  <dt id="SSL_crl_file"><a class="permalink" href="#SSL_crl_file">SSL_crl_file</a></dt>
  <dd>If you want to specify the CRL file to be used, set this value to the
      pathname to be used. This must be used in addition to setting
      SSL_check_crl.</dd>
  <dt id="SSL_ocsp_mode"><a class="permalink" href="#SSL_ocsp_mode">SSL_ocsp_mode</a></dt>
  <dd>Defines how certificate revocation is done using OCSP (Online Status
      Revocation Protocol). The default is to send a request for OCSP stapling
      to the server and if the server sends an OCSP response back the result
      will be used.
    <p class="Pp">Any other OCSP checking needs to be done manually with
        <span class="Li">&quot;ocsp_resolver&quot;</span>.</p>
    <p class="Pp">The following flags can be combined with
        <span class="Li">&quot;|&quot;</span>:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="SSL_OCSP_NO_STAPLE"><a class="permalink" href="#SSL_OCSP_NO_STAPLE">SSL_OCSP_NO_STAPLE</a></dt>
  <dd>Don't ask for OCSP stapling. This is the default if SSL_verify_mode is
      VERIFY_NONE.</dd>
  <dt id="SSL_OCSP_TRY_STAPLE"><a class="permalink" href="#SSL_OCSP_TRY_STAPLE">SSL_OCSP_TRY_STAPLE</a></dt>
  <dd>Try OCSP stapling, but don't complain if it gets no stapled response back.
      This is the default if SSL_verify_mode is VERIFY_PEER (the default).</dd>
  <dt id="SSL_OCSP_MUST_STAPLE"><a class="permalink" href="#SSL_OCSP_MUST_STAPLE">SSL_OCSP_MUST_STAPLE</a></dt>
  <dd>Consider it a hard error, if the server does not send a stapled OCSP
      response back. Most servers currently send no stapled OCSP response
    back.</dd>
  <dt id="SSL_OCSP_FAIL_HARD"><a class="permalink" href="#SSL_OCSP_FAIL_HARD">SSL_OCSP_FAIL_HARD</a></dt>
  <dd>Fail hard on response errors, default is to fail soft like the browsers
      do. Soft errors mean, that the OCSP response is not usable, e.g. no
      response, error response, no valid signature etc. Certificate revocations
      inside a verified response are considered hard errors in any case.
    <p class="Pp">Soft errors inside a stapled response are never considered
        hard, e.g. it is expected that in this case an OCSP request will be send
        to the responsible OCSP responder.</p>
  </dd>
  <dt id="SSL_OCSP_FULL_CHAIN"><a class="permalink" href="#SSL_OCSP_FULL_CHAIN">SSL_OCSP_FULL_CHAIN</a></dt>
  <dd>This will set up the <span class="Li">&quot;ocsp_resolver&quot;</span> so
      that all certificates from the peer chain will be checked, otherwise only
      the leaf certificate will be checked against revocation.</dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="SSL_ocsp_staple_callback"><a class="permalink" href="#SSL_ocsp_staple_callback">SSL_ocsp_staple_callback</a></dt>
  <dd>If this callback is defined, it will be called with the SSL object and the
      OCSP response handle obtained from the peer, e.g.
      <span class="Li">&quot;&lt;$cb-&quot;</span>($ssl,$resp)&gt;&gt;. If the
      peer did not provide a stapled OCSP response the function will be called
      with <span class="Li">&quot;$resp=undef&quot;</span>. Because the OCSP
      response handle is no longer valid after leaving this function it should
      not by copied or freed. If access to the response is necessary after
      leaving this function it can be serialized with
      <span class="Li">&quot;Net::SSLeay::i2d_OCSP_RESPONSE&quot;</span>.
    <p class="Pp">If no such callback is provided, it will use the default one,
        which verifies the response and uses it to check if the certificate(s)
        of the connection got revoked.</p>
  </dd>
  <dt id="SSL_ocsp_cache"><a class="permalink" href="#SSL_ocsp_cache">SSL_ocsp_cache</a></dt>
  <dd>With this option a cache can be given for caching OCSP responses, which
      could be shared between different SSL contexts. If not given a cache
      specific to the SSL context only will be used.
    <p class="Pp">You can either create a new cache with
        <span class="Li">&quot;IO::Socket::SSL::OCSP_Cache-&gt;new([size])&quot;</span>
        or implement your own cache, which needs to have methods
        <span class="Li">&quot;put($key,\%entry)&quot;</span> and
        <span class="Li">&quot;get($key)&quot;</span> (returning
        <span class="Li">&quot;\%entry&quot;</span>) where entry is the hash
        representation of the OCSP response with fields like
        <span class="Li">&quot;nextUpdate&quot;</span>. The default
        implementation of the cache will consider responses valid as long as
        <span class="Li">&quot;nextUpdate&quot;</span> is less then the current
        time.</p>
  </dd>
  <dt id="SSL_reuse_ctx"><a class="permalink" href="#SSL_reuse_ctx">SSL_reuse_ctx</a></dt>
  <dd>If you have already set the above options for a previous instance of
      IO::Socket::SSL, then you can reuse the SSL context of that instance by
      passing it as the value for the SSL_reuse_ctx parameter. You may also
      create a new instance of the IO::Socket::SSL::SSL_Context class, using any
      context options that you desire without specifying connection options, and
      pass that here instead.
    <p class="Pp">If you use this option, all other context-related options that
        you pass in the same call to <b>new()</b> will be ignored unless the
        context supplied was invalid. Note that, contrary to versions of
        IO::Socket::SSL below v0.90, a global SSL context will not be implicitly
        used unless you use the <b>set_default_context()</b> function.</p>
  </dd>
  <dt id="SSL_create_ctx_callback"><a class="permalink" href="#SSL_create_ctx_callback">SSL_create_ctx_callback</a></dt>
  <dd>With this callback you can make individual settings to the context after
      it got created and the default setup was done. The callback will be called
      with the CTX object from Net::SSLeay as the single argument.
    <p class="Pp">Example for limiting the server session cache size:</p>
    <p class="Pp"></p>
    <pre>  SSL_create_ctx_callback =&gt; sub {
      my $ctx = shift;
      Net::SSLeay::CTX_sess_set_cache_size($ctx,128);
  }
    </pre>
  </dd>
  <dt id="SSL_session_cache_size"><a class="permalink" href="#SSL_session_cache_size">SSL_session_cache_size</a></dt>
  <dd>If you make repeated connections to the same host/port and the SSL
      renegotiation time is an issue, you can turn on client-side session
      caching with this option by specifying a positive cache size. For
      successive connections, pass the SSL_reuse_ctx option to the <b>new()</b>
      calls (or use <b>set_default_context()</b>) to make use of the cached
      sessions. The session cache size refers to the number of unique host/port
      pairs that can be stored at one time; the oldest sessions in the cache
      will be removed if new ones are added.
    <p class="Pp">This option does not effect the session cache a server has for
        it's clients, e.g. it does not affect SSL objects with SSL_server
      set.</p>
    <p class="Pp">Note that session caching with TLS 1.3 needs at least
        Net::SSLeay 1.86.</p>
  </dd>
  <dt id="SSL_session_cache"><a class="permalink" href="#SSL_session_cache">SSL_session_cache</a></dt>
  <dd>Specifies session cache object which should be used instead of creating a
      new. Overrules SSL_session_cache_size. This option is useful if you want
      to reuse the cache, but not the rest of the context.
    <p class="Pp">A session cache object can be created using
        <span class="Li">&quot;IO::Socket::SSL::Session_Cache-&gt;new( cachesize
        )&quot;</span>.</p>
    <p class="Pp">Use <b>set_default_session_cache()</b> to set a global cache
        object.</p>
  </dd>
  <dt id="SSL_session_key"><a class="permalink" href="#SSL_session_key">SSL_session_key</a></dt>
  <dd>Specifies a key to use for lookups and inserts into client-side session
      cache. Per default ip:port of destination will be used, but sometimes you
      want to share the same session over multiple ports on the same server
      (like with FTPS).</dd>
  <dt id="SSL_session_id_context"><a class="permalink" href="#SSL_session_id_context">SSL_session_id_context</a></dt>
  <dd>This gives an id for the servers session cache. It's necessary if you want
      clients to connect with a client certificate. If not given but
      SSL_verify_mode specifies the need for client certificate a context unique
      id will be picked.</dd>
  <dt id="SSL_error_trap"><a class="permalink" href="#SSL_error_trap">SSL_error_trap</a></dt>
  <dd>When using the <b>accept()</b> or <b>connect()</b> methods, it may be the
      case that the actual socket connection works but the SSL negotiation
      fails, as in the case of an HTTP client connecting to an HTTPS server.
      Passing a subroutine ref attached to this parameter allows you to gain
      control of the orphaned socket instead of having it be closed forcibly.
      The subroutine, if called, will be passed two parameters: a reference to
      the socket on which the SSL negotiation failed and the full text of the
      error message.</dd>
  <dt id="SSL_npn_protocols"><a class="permalink" href="#SSL_npn_protocols">SSL_npn_protocols</a></dt>
  <dd>If used on the server side it specifies list of protocols advertised by
      SSL server as an array ref, e.g. ['spdy/2','http1.1']. On the client side
      it specifies the protocols offered by the client for NPN as an array ref.
      See also method <span class="Li">&quot;next_proto_negotiated&quot;</span>.
    <p class="Pp">Next Protocol Negotiation (NPN) is available with Net::SSLeay
        1.46+ and openssl-1.0.1+. NPN is unavailable in TLSv1.3 protocol. To
        check support you might call
        <span class="Li">&quot;IO::Socket::SSL-&gt;can_npn()&quot;</span>. If
        you use this option with an unsupported Net::SSLeay/OpenSSL it will
        throw an error.</p>
  </dd>
  <dt id="SSL_alpn_protocols"><a class="permalink" href="#SSL_alpn_protocols">SSL_alpn_protocols</a></dt>
  <dd>If used on the server side it specifies list of protocols supported by the
      SSL server as an array ref, e.g. ['http/2.0', 'spdy/3.1','http/1.1']. On
      the client side it specifies the protocols advertised by the client for
      ALPN as an array ref. See also method
      <span class="Li">&quot;alpn_selected&quot;</span>.
    <p class="Pp">Application-Layer Protocol Negotiation (ALPN) is available
        with Net::SSLeay 1.56+ and openssl-1.0.2+. More details about the
        extension are in RFC7301. To check support you might call
        <span class="Li">&quot;IO::Socket::SSL-&gt;can_alpn()&quot;</span>. If
        you use this option with an unsupported Net::SSLeay/OpenSSL it will
        throw an error.</p>
    <p class="Pp">Note that some client implementations may encounter problems
        if both NPN and ALPN are specified. Since ALPN is intended as a
        replacement for NPN, try providing ALPN protocols then fall back to NPN
        if that fails.</p>
  </dd>
  <dt id="SSL_ticket_keycb"><a class="permalink" href="#SSL_ticket_keycb">SSL_ticket_keycb
    =&gt; [$sub,$data] | $sub</a></dt>
  <dd>This is a callback used for stateless session reuse (Session Tickets, RFC
      5077).
    <p class="Pp">This callback will be called as
        <span class="Li">&quot;$sub-&gt;($data,[$key_name])&quot;</span> where
        <span class="Li">$data</span> is the argument given to SSL_ticket_keycb
        (or undef) and <span class="Li">$key_name</span> depends on the
      mode:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="encrypt"><a class="permalink" href="#encrypt">encrypt ticket</a></dt>
  <dd>If a ticket needs to be encrypted the callback will be called without
      <span class="Li">$key_name</span>. In this case it should return
      <span class="Li">&quot;($current_key,$current_key_name&quot;</span>) where
      <span class="Li">$current_key</span> is the current key (32 byte random
      data) and <span class="Li">$current_key_name</span> the name associated
      with this key (exactly 16 byte). This
      <span class="Li">$current_key_name</span> will be incorporated into the
      ticket.</dd>
  <dt id="decrypt"><a class="permalink" href="#decrypt">decrypt ticket</a></dt>
  <dd>If a ticket needs to be decrypted the callback will be called with
      <span class="Li">$key_name</span> as found in the ticket. It should return
      <span class="Li">&quot;($key,$current_key_name&quot;</span>) where
      <span class="Li">$key</span> is the key associated with the given
      <span class="Li">$key_name</span> and
      <span class="Li">$current_key_name</span> the name associated with the
      currently active key. If <span class="Li">$current_key_name</span> is
      different from the given <span class="Li">$key_name</span> the callback
      will be called again to re-encrypt the ticket with the currently active
      key.
    <p class="Pp">If no key can be found which matches the given
        <span class="Li">$key_name</span> then this function should return
        nothing (empty list).</p>
    <p class="Pp">This mechanism should be used to limit the life time for each
        key encrypting the ticket. Compromise of a ticket encryption key might
        lead to decryption of SSL sessions which used session tickets protected
        by this key.</p>
  </dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">Example:</p>
<p class="Pp"></p>
<pre>    Net::SSLeay::RAND_bytes(my $oldkey,32);
    Net::SSLeay::RAND_bytes(my $newkey,32);
    my $oldkey_name = pack(&quot;a16&quot;,'oldsecret');
    my $newkey_name = pack(&quot;a16&quot;,'newsecret');
    my @keys = (
       [ $newkey_name, $newkey ], # current active key
       [ $oldkey_name, $oldkey ], # already expired
    );
    my $keycb = [ sub {
       my ($mykeys,$name) = @_;
       # return (current_key, current_key_name) if no name given
       return ($mykeys-&gt;[0][1],$mykeys-&gt;[0][0]) if ! $name;
       # return (matching_key, current_key_name) if we find a key matching
       # the given name
       for(my $i = 0; $i&lt;@$mykeys; $i++) {
           next if $name ne $mykeys-&gt;[$i][0];
           return ($mykeys-&gt;[$i][1],$mykeys-&gt;[0][0]);
       }
       # no matching key found
       return;
    },\@keys ];
    my $srv = IO::Socket::SSL-&gt;new(..., SSL_ticket_keycb =&gt; $keycb);
</pre>
</div>
<dl class="Bl-tag">
  <dt id="SSL_mode_release_buffers"><a class="permalink" href="#SSL_mode_release_buffers">SSL_mode_release_buffers
    1|0</a></dt>
  <dd>This enables or disables the SSL_MODE_RELEASE_BUFFERS option on the SSL
      object. With this option the read buffer will be released after each
      SSL_read but will need to be reallocated for each new SSL_read. If memory
      usage is a concern this might save lots of memory in the mean time though,
      about 34k per idle SSL connection according to the documentation in
      <b>SSL_CTX_set_mode</b>(3ssl).</dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="accept"><a class="permalink" href="#accept"><b>accept</b></a></dt>
  <dd>This behaves similar to the accept function of the underlying socket
      class, but additionally does the initial SSL handshake. But because the
      underlying socket class does return a blocking file handle even when
      accept is called on a non-blocking socket, the SSL handshake on the new
      file object will be done in a blocking way. Please see the section about
      non-blocking I/O for details. If you don't like this behavior you should
      do accept on the TCP socket and then upgrade it with
      <span class="Li">&quot;start_SSL&quot;</span> later.</dd>
  <dt id="connect(...)"><a class="permalink" href="#connect(...)"><b>connect(...)</b></a></dt>
  <dd>This behaves similar to the connect function but also does an SSL
      handshake. Because you cannot give SSL specific arguments to this
      function, you should better either use
      <span class="Li">&quot;new&quot;</span> to create a connect SSL socket or
      <span class="Li">&quot;start_SSL&quot;</span> to upgrade an established
      TCP socket to SSL.</dd>
  <dt id="close(...)"><a class="permalink" href="#close(...)"><b>close(...)</b></a></dt>
  <dd>Contrary to a close for a simple INET socket a close in SSL also mandates
      a proper shutdown of the SSL part. This is done by sending a close notify
      message by both peers.
    <p class="Pp">A naive implementation would thus wait until it receives the
        close notify message from the peer - which conflicts with the commonly
        expected semantic that a close will not block. The default behavior is
        thus to only send a close notify but not wait for the close notify of
        the peer. If this is required
        <span class="Li">&quot;SSL_fast_shutdown&quot;</span> need to be
        explicitly set to false.</p>
    <p class="Pp">There are also cases where a SSL shutdown should not be done
        at all. This is true for example when forking to let a child deal with
        the socket and closing the socket in the parent process. A naive
        explicit <span class="Li">&quot;close&quot;</span> or an implicit close
        when destroying the socket in the parent would send a close notify to
        the peer which would make the SSL socket in the client process unusable.
        In this case an explicit <span class="Li">&quot;close&quot;</span> with
        <span class="Li">&quot;SSL_no_shutdown&quot;</span> set to true should
        be done in the parent process.</p>
    <p class="Pp">For more details and other arguments see
        <span class="Li">&quot;stop_SSL&quot;</span> which gets called from
        <span class="Li">&quot;close&quot;</span> to shutdown the SSL state of
        the socket.</p>
  </dd>
  <dt id="sysread("><a class="permalink" href="#sysread("><b>sysread( BUF, LEN,
    [ OFFSET ] )</b></a></dt>
  <dd>This function behaves from the outside the same as <b>sysread</b> in other
      IO::Socket objects, e.g. it returns at most LEN bytes of data. But in
      reality it reads not only LEN bytes from the underlying socket, but at a
      single SSL frame. It then returns up to LEN bytes it decrypted from this
      SSL frame. If the frame contained more data than requested it will return
      only LEN data, buffer the rest and return it on further read calls. This
      means, that it might be possible to read data, even if the underlying
      socket is not readable, so using poll or select might not be sufficient.
    <p class="Pp">sysread will only return data from a single SSL frame, e.g.
        either the pending data from the already buffered frame or it will read
        a frame from the underlying socket and return the decrypted data. It
        will not return data spanning several SSL frames in a single call.</p>
    <p class="Pp">Also, calls to sysread might fail, because it must first
        finish an SSL handshake.</p>
    <p class="Pp">To understand these behaviors is essential, if you write
        applications which use event loops and/or non-blocking sockets. Please
        read the specific sections in this documentation.</p>
  </dd>
  <dt id="syswrite("><a class="permalink" href="#syswrite("><b>syswrite( BUF, [
    LEN, [ OFFSET ]] )</b></a></dt>
  <dd>This functions behaves from the outside the same as <b>syswrite</b> in
      other IO::Socket objects, e.g. it will write at most LEN bytes to the
      socket, but there is no guarantee, that all LEN bytes are written. It will
      return the number of bytes written. Because it basically just calls
      SSL_write from OpenSSL syswrite will write at most a single SSL frame.
      This means, that no more than 16.384 bytes, which is the maximum size of
      an SSL frame, will be written at once.
    <p class="Pp">For non-blocking sockets SSL specific behavior applies. Pease
        read the specific section in this documentation.</p>
  </dd>
  <dt id="peek("><a class="permalink" href="#peek("><b>peek( BUF, LEN, [ OFFSET
    ])</b></a></dt>
  <dd>This function has exactly the same syntax as <b>sysread</b>, and performs
      nearly the same task but will not advance the read position so that
      successive calls to <b>peek()</b> with the same arguments will return the
      same results. This function requires OpenSSL 0.9.6a or later to work.</dd>
  <dt id="pending()"><a class="permalink" href="#pending()"><b></b><b>pending()</b><b></b></a></dt>
  <dd>This function gives you the number of bytes available without reading from
      the underlying socket object. This function is essential if you work with
      event loops, please see the section about polling SSL sockets.</dd>
  <dt id="get_fingerprint(_algo,certificate,pubkey_)"><a class="permalink" href="#get_fingerprint(_algo,certificate,pubkey_)"><b>get_fingerprint([algo,certificate,pubkey])</b></a></dt>
  <dd>This methods returns the fingerprint of the given certificate in the form
      <span class="Li">&quot;algo$digest_hex&quot;</span>, where
      <span class="Li">&quot;algo&quot;</span> is the used algorithm, default
      'sha256'. If no certificate is given the peer certificate of the
      connection is used. If <span class="Li">&quot;pubkey&quot;</span> is true
      it will not return the fingerprint of the certificate but instead the
      fingerprint of the pubkey inside the certificate as
      <span class="Li">&quot;algo$pub$digest_hex&quot;</span>.</dd>
  <dt id="get_fingerprint_bin(_algo,certificate,pubkey_)"><a class="permalink" href="#get_fingerprint_bin(_algo,certificate,pubkey_)"><b>get_fingerprint_bin([algo,certificate,pubkey])</b></a></dt>
  <dd>This methods returns the binary fingerprint of the given certificate by
      using the algorithm <span class="Li">&quot;algo&quot;</span>, default
      'sha256'. If no certificate is given the peer certificate of the
      connection is used. If <span class="Li">&quot;pubkey&quot;</span> is true
      it will not return the fingerprint of the certificate but instead the
      fingerprint of the pubkey inside the certificate.</dd>
  <dt id="get_cipher()"><a class="permalink" href="#get_cipher()"><b></b><b>get_cipher()</b><b></b></a></dt>
  <dd>Returns the string form of the cipher that the IO::Socket::SSL object is
      using.</dd>
  <dt id="get_sslversion()"><a class="permalink" href="#get_sslversion()"><b></b><b>get_sslversion()</b><b></b></a></dt>
  <dd>Returns the string representation of the SSL version of an established
      connection.</dd>
  <dt id="get_sslversion_int()"><a class="permalink" href="#get_sslversion_int()"><b></b><b>get_sslversion_int()</b><b></b></a></dt>
  <dd>Returns the integer representation of the SSL version of an established
      connection.</dd>
  <dt id="get_session_reused()"><a class="permalink" href="#get_session_reused()"><b></b><b>get_session_reused()</b><b></b></a></dt>
  <dd>This returns true if the session got reused and false otherwise. Note that
      with a reused session no certificates are send within the handshake and no
      ciphers are offered and thus functions which rely on this might not
    work.</dd>
  <dt id="dump_peer_certificate()"><a class="permalink" href="#dump_peer_certificate()"><b></b><b>dump_peer_certificate()</b><b></b></a></dt>
  <dd>Returns a parsable string with select fields from the peer SSL
      certificate. This method directly returns the result of the
      <b>dump_peer_certificate()</b> method of Net::SSLeay.</dd>
  <dt id="peer_certificate($field;_$refresh_)"><a class="permalink" href="#peer_certificate($field;_$refresh_)"><b>peer_certificate($field;[$refresh])</b></a></dt>
  <dd>If a peer certificate exists, this function can retrieve values from it.
      If no field is given the internal representation of certificate from
      Net::SSLeay is returned. If refresh is true it will not used a cached
      version, but check again in case the certificate of the connection has
      changed due to renegotiation.
    <p class="Pp">The following fields can be queried:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="authority"><a class="permalink" href="#authority">authority (alias
    issuer)</a></dt>
  <dd>The certificate authority which signed the certificate.</dd>
  <dt id="owner"><a class="permalink" href="#owner">owner (alias
    subject)</a></dt>
  <dd>The owner of the certificate.</dd>
  <dt id="commonName"><a class="permalink" href="#commonName">commonName (alias
    cn) - only for Net::SSLeay version &gt;=1.30</a></dt>
  <dd>The common name, usually the server name for SSL certificates.</dd>
  <dt id="subjectAltNames"><a class="permalink" href="#subjectAltNames">subjectAltNames
    - only for Net::SSLeay version &gt;=1.33</a></dt>
  <dd>Alternative names for the subject, usually different names for the same
      server, like example.org, example.com, *.example.com.
    <p class="Pp">It returns a list of (typ,value) with typ GEN_DNS, GEN_IPADD
        etc (these constants are exported from IO::Socket::SSL). See
        Net::SSLeay::X509_get_subjectAltNames.</p>
  </dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="sock_certificate($field)"><a class="permalink" href="#sock_certificate($field)"><b>sock_certificate($field)</b></a></dt>
  <dd>This is similar to <span class="Li">&quot;peer_certificate&quot;</span>
      but will return the sites own certificate. The same arguments for
      <b></b><span class="Li"><b>$field</b></span><b></b> can be used. If no
      <b></b><span class="Li"><b>$field</b></span><b></b> is given the
      certificate handle from the underlying OpenSSL will be returned. This
      handle will only be valid as long as the SSL connection exists and if used
      afterwards it might result in strange crashes of the application.</dd>
  <dt id="peer_certificates"><a class="permalink" href="#peer_certificates"><b>peer_certificates</b></a></dt>
  <dd>This returns all the certificates send by the peer, e.g. first the peers
      own certificate and then the rest of the chain. You might use
      <b>CERT_asHash</b> from IO::Socket::SSL::Utils to inspect each of the
      certificates.
    <p class="Pp">This function depends on a version of Net::SSLeay &gt;= 1.58
      .</p>
  </dd>
  <dt id="get_servername"><a class="permalink" href="#get_servername"><b>get_servername</b></a></dt>
  <dd>This gives the name requested by the client if Server Name Indication
      (SNI) was used.</dd>
  <dt id="verify_hostname($hostname,$scheme,$publicsuffix)"><a class="permalink" href="#verify_hostname($hostname,$scheme,$publicsuffix)"><b>verify_hostname($hostname,$scheme,$publicsuffix)</b></a></dt>
  <dd>This verifies the given hostname against the peer certificate using the
      given scheme. Hostname is usually what you specify within the PeerAddr.
      See the <span class="Li">&quot;SSL_verifycn_publicsuffix&quot;</span>
      parameter for an explanation of suffix checking and for the possible
      values.
    <p class="Pp">Verification of hostname against a certificate is different
        between various applications and RFCs. Some scheme allow wildcards for
        hostnames, some only in subjectAltNames, and even their different
        wildcard schemes are possible. RFC 6125 provides a good overview.</p>
    <p class="Pp">To ease the verification the following schemes are predefined
        (both protocol name and rfcXXXX name can be used):</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="rfc2818,"><a class="permalink" href="#rfc2818,">rfc2818, xmpp
    (rfc3920), ftp (rfc4217)</a></dt>
  <dd>Extended wildcards in subjectAltNames and common name are possible, e.g.
      *.example.org or even www*.example.org. The common name will be only
      checked if no DNS names are given in subjectAltNames.</dd>
  <dt id="http"><a class="permalink" href="#http">http (alias www)</a></dt>
  <dd>While name checking is defined in rfc2818 the current browsers usually
      accept also an IP address (w/o wildcards) within the common name as long
      as no subjectAltNames are defined. Thus this is rfc2818 extended with this
      feature.</dd>
  <dt id="smtp"><a class="permalink" href="#smtp">smtp (rfc2595), imap, pop3,
    acap (rfc4642), netconf (rfc5538), syslog (rfc5425), snmp (rfc5953)</a></dt>
  <dd>Simple wildcards in subjectAltNames are possible, e.g. *.example.org
      matches www.example.org but not lala.www.example.org. If nothing from
      subjectAltNames match it checks against the common name, where wildcards
      are also allowed to match the full leftmost label.</dd>
  <dt id="ldap"><a class="permalink" href="#ldap">ldap (rfc4513)</a></dt>
  <dd>Simple wildcards are allowed in subjectAltNames, but not in common name.
      Common name will be checked even if subjectAltNames exist.</dd>
  <dt id="sip"><a class="permalink" href="#sip">sip (rfc5922)</a></dt>
  <dd>No wildcards are allowed and common name is checked even if
      subjectAltNames exist.</dd>
  <dt id="gist"><a class="permalink" href="#gist">gist (rfc5971)</a></dt>
  <dd>Simple wildcards are allowed in subjectAltNames and common name, but
      common name will only be checked if their are no DNS names in
      subjectAltNames.</dd>
  <dt id="default"><a class="permalink" href="#default">default</a></dt>
  <dd>This is a superset of all the rules and is automatically used if no scheme
      is given but a hostname (instead of IP) is known. Extended wildcards are
      allowed in subjectAltNames and common name and common name is checked
      always.</dd>
  <dt id="none"><a class="permalink" href="#none">none</a></dt>
  <dd>No verification will be done. Actually is does not make any sense to call
      verify_hostname in this case.</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">The scheme can be given either by specifying the name for one of
    the above predefined schemes, or by using a hash which can have the
    following keys and values:</p>
<dl class="Bl-tag">
  <dt id="check_cn:"><a class="permalink" href="#check_cn:">check_cn:
    0|'always'|'when_only'</a></dt>
  <dd>Determines if the common name gets checked. If 'always' it will always be
      checked (like in ldap), if 'when_only' it will only be checked if no names
      are given in subjectAltNames (like in http), for any other values the
      common name will not be checked.</dd>
  <dt id="wildcards_in_alt:"><a class="permalink" href="#wildcards_in_alt:">wildcards_in_alt:
    0|'full_label'|'anywhere'</a></dt>
  <dd>Determines if and where wildcards in subjectAltNames are possible. If
      'full_label' only cases like *.example.org will be possible (like in
      ldap), for 'anywhere' www*.example.org is possible too (like http),
      dangerous things like but www.*.org or even '*' will not be allowed. For
      compatibility with older versions 'leftmost' can be given instead of
      'full_label'.</dd>
  <dt id="wildcards_in_cn:"><a class="permalink" href="#wildcards_in_cn:">wildcards_in_cn:
    0|'full_label'|'anywhere'</a></dt>
  <dd>Similar to wildcards_in_alt, but checks the common name. There is no
      predefined scheme which allows wildcards in common names.</dd>
  <dt id="ip_in_cn:"><a class="permalink" href="#ip_in_cn:">ip_in_cn:
    0|1|4|6</a></dt>
  <dd>Determines if an IP address is allowed in the common name (no wildcards
      are allowed). If set to 4 or 6 it only allows IPv4 or IPv6 addresses, any
      other true value allows both.</dd>
  <dt id="callback:"><a class="permalink" href="#callback:">callback:
    \&amp;coderef</a></dt>
  <dd>If you give a subroutine for verification it will be called with the
      arguments ($hostname,$commonName,@subjectAltNames), where hostname is the
      name given for verification, commonName is the result from
      peer_certificate('cn') and subjectAltNames is the result from
      peer_certificate('subjectAltNames').
    <p class="Pp">All other arguments for the verification scheme will be
        ignored in this case.</p>
  </dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="next_proto_negotiated()"><a class="permalink" href="#next_proto_negotiated()"><b></b><b>next_proto_negotiated()</b><b></b></a></dt>
  <dd>This method returns the name of negotiated protocol - e.g. 'http/1.1'. It
      works for both client and server side of SSL connection.
    <p class="Pp">NPN support is available with Net::SSLeay 1.46+ and
        openssl-1.0.1+. To check support you might call
        <span class="Li">&quot;IO::Socket::SSL-&gt;can_npn()&quot;</span>.</p>
  </dd>
  <dt id="alpn_selected()"><a class="permalink" href="#alpn_selected()"><b></b><b>alpn_selected()</b><b></b></a></dt>
  <dd>Returns the protocol negotiated via ALPN as a string, e.g. 'http/1.1',
      'http/2.0' or 'spdy/3.1'.
    <p class="Pp">ALPN support is available with Net::SSLeay 1.56+ and
        openssl-1.0.2+. To check support, use
        <span class="Li">&quot;IO::Socket::SSL-&gt;can_alpn()&quot;</span>.</p>
  </dd>
  <dt id="errstr()"><a class="permalink" href="#errstr()"><b></b><b>errstr()</b><b></b></a></dt>
  <dd>Returns the last error (in string form) that occurred.	If you do not have
      a real object to perform this method on, call
      <b>IO::Socket::SSL::errstr()</b> instead.
    <p class="Pp">For read and write errors on non-blocking sockets, this method
        may include the string <span class="Li">&quot;SSL wants a read
        first!&quot;</span> or <span class="Li">&quot;SSL wants a write
        first!&quot;</span> meaning that the other side is expecting to read
        from or write to the socket and wants to be satisfied before you get to
        do anything. But with version 0.98 you are better comparing the global
        exported variable <span class="Li">$SSL_ERROR</span> against the
        exported symbols SSL_WANT_READ and SSL_WANT_WRITE.</p>
  </dd>
  <dt id="opened()"><a class="permalink" href="#opened()"><b></b><b>opened()</b><b></b></a></dt>
  <dd>This returns false if the socket could not be opened, 1 if the socket
      could be opened and the SSL handshake was successful done and -1 if the
      underlying IO::Handle is open, but the SSL handshake failed.</dd>
  <dt id="IO::Socket::SSL"><a class="permalink" href="#IO::Socket::SSL"><b>IO::Socket::SSL-&gt;start_SSL($socket,
    ... )</b></a></dt>
  <dd>This will convert a glob reference or a socket that you provide to an
      IO::Socket::SSL object.	 You may also pass parameters to specify context
      or connection options as with a call to <b>new()</b>. If you are using
      this function on an <b>accept()</b>ed socket, you must set the parameter
      &quot;SSL_server&quot; to 1, i.e. IO::Socket::SSL-&gt;start_SSL($socket,
      SSL_server =&gt; 1). If you have a class that inherits from
      IO::Socket::SSL and you want the <span class="Li">$socket</span> to be
      blessed into your own class instead, use MyClass-&gt;start_SSL($socket) to
      achieve the desired effect.
    <p class="Pp">Note that if <b>start_SSL()</b> fails in SSL negotiation,
        <span class="Li">$socket</span> will remain blessed in its original
        class.	 For non-blocking sockets you better just upgrade the socket to
        IO::Socket::SSL and call accept_SSL or connect_SSL and the upgraded
        object. To just upgrade the socket set <b>SSL_startHandshake</b>
        explicitly to 0. If you call start_SSL w/o this parameter it will revert
        to blocking behavior for accept_SSL and connect_SSL.</p>
    <p class="Pp">If given the parameter &quot;Timeout&quot; it will stop if
        after the timeout no SSL connection was established. This parameter is
        only used for blocking sockets, if it is not given the default Timeout
        from the underlying IO::Socket will be used.</p>
  </dd>
  <dt id="stop_SSL(...)"><a class="permalink" href="#stop_SSL(...)"><b>stop_SSL(...)</b></a></dt>
  <dd>This is the opposite of <b>start_SSL()</b>, <b>connect_SSL()</b> and
      <b>accept_SSL()</b>, e.g. it will shutdown the SSL connection and return
      to the class before <b>start_SSL()</b>. It gets the same arguments as
      <b>close()</b>, in fact <b>close()</b> calls <b>stop_SSL()</b> (but
      without downgrading the class).
    <p class="Pp">Will return true if it succeeded and undef if failed. This
        might be the case for non-blocking sockets. In this case $! is set to
        EWOULDBLOCK and the ssl error to SSL_WANT_READ or SSL_WANT_WRITE. In
        this case the call should be retried again with the same arguments once
        the socket is ready.</p>
    <p class="Pp">For calling from <span class="Li">&quot;stop_SSL&quot;</span>
        <span class="Li">&quot;SSL_fast_shutdown&quot;</span> default to false,
        e.g. it waits for the close_notify of the peer. This is necessary in
        case you want to downgrade the socket and continue to use it as a plain
        socket.</p>
    <p class="Pp">After stop_SSL the socket can again be used to exchange plain
        data.</p>
  </dd>
  <dt id="connect_SSL"><a class="permalink" href="#connect_SSL"><b>connect_SSL</b>,
    <b>accept_SSL</b></a></dt>
  <dd>These functions should be used to do the relevant handshake, if the socket
      got created with <span class="Li">&quot;new&quot;</span> or upgraded with
      <span class="Li">&quot;start_SSL&quot;</span> and
      <span class="Li">&quot;SSL_startHandshake&quot;</span> was set to false.
      They will return undef until the handshake succeeded or an error got
      thrown. As long as the function returns undef and $! is set to EWOULDBLOCK
      one could retry the call after the socket got readable (SSL_WANT_READ) or
      writeable (SSL_WANT_WRITE).</dd>
  <dt id="ocsp_resolver"><a class="permalink" href="#ocsp_resolver"><b>ocsp_resolver</b></a></dt>
  <dd>This will create an OCSP resolver object, which can be used to create OCSP
      requests for the certificates of the SSL connection. Which certificates
      are verified depends on the setting of
      <span class="Li">&quot;SSL_ocsp_mode&quot;</span>: by default only the
      leaf certificate will be checked, but with SSL_OCSP_FULL_CHAIN all chain
      certificates will be checked.
    <p class="Pp">Because to create an OCSP request the certificate and its
        issuer certificate need to be known it is not possible to check
        certificates when the trust chain is incomplete or if the certificate is
        self-signed.</p>
    <p class="Pp">The OCSP resolver gets created by calling
        <span class="Li">&quot;$ssl-&gt;ocsp_resolver&quot;</span> and provides
        the following methods:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="hard_error"><a class="permalink" href="#hard_error">hard_error</a></dt>
  <dd>This returns the hard error when checking the OCSP response. Hard errors
      are certificate revocations. With the
      <span class="Li">&quot;SSL_ocsp_mode&quot;</span> of SSL_OCSP_FAIL_HARD
      any soft error (e.g. failures to get signed information about the
      certificates) will be considered a hard error too.
    <p class="Pp">The OCSP resolving will stop on the first hard error.</p>
    <p class="Pp">The method will return undef as long as no hard errors
        occurred and still requests to be resolved. If all requests got resolved
        and no hard errors occurred the method will return
        <span class="Li">''</span>.</p>
  </dd>
  <dt id="soft_error"><a class="permalink" href="#soft_error">soft_error</a></dt>
  <dd>This returns the soft error(s) which occurred when asking the OCSP
      responders.</dd>
  <dt id="requests"><a class="permalink" href="#requests">requests</a></dt>
  <dd>This will return a hash consisting of
      <span class="Li">&quot;(url,request)&quot;</span>-tuples, e.g. which
      contain the OCSP request string and the URL where it should be sent too.
      The usual way to send such a request is as HTTP POST request with a
      content-type of
      <span class="Li">&quot;application/ocsp-request&quot;</span> or as a GET
      request with the base64 and url-encoded request is added to the path of
      the URL.
    <p class="Pp">After you've handled all these requests and added the response
        with <span class="Li">&quot;add_response&quot;</span> you should better
        call this method again to make sure, that no more requests are
        outstanding. IO::Socket::SSL will combine multiple OCSP requests for the
        same server inside a single request, but some server don't give a
        response to all these requests, so that one has to ask again with the
        remaining requests.</p>
  </dd>
  <dt id="add_response($uri,$response)"><a class="permalink" href="#add_response($uri,$response)">add_response($uri,$response)</a></dt>
  <dd>This method takes the HTTP body of the response which got received when
      sending the OCSP request to <span class="Li">$uri</span>. If no response
      was received or an error occurred one should either retry or consider
      <span class="Li">$response</span> as empty which will trigger a soft
      error.
    <p class="Pp">The method returns the current value of
        <span class="Li">&quot;hard_error&quot;</span>, e.g. a defined value
        when no more requests need to be done.</p>
  </dd>
  <dt id="resolve_blocking(_args)"><a class="permalink" href="#resolve_blocking(_args)">resolve_blocking(%args)</a></dt>
  <dd>This combines <span class="Li">&quot;requests&quot;</span> and
      <span class="Li">&quot;add_response&quot;</span> which HTTP::Tiny to do
      all necessary requests in a blocking way. <span class="Li">%args</span>
      will be given to HTTP::Tiny so that you can put proxy settings etc here.
      HTTP::Tiny will be called with
      <span class="Li">&quot;verify_SSL&quot;</span> of false, because the OCSP
      responses have their own signatures so no extra SSL verification is
      needed.
    <p class="Pp">If you don't want to use blocking requests you need to roll
        your own user agent with <span class="Li">&quot;requests&quot;</span>
        and <span class="Li">&quot;add_response&quot;</span>.</p>
  </dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="IO::Socket::SSL~2"><a class="permalink" href="#IO::Socket::SSL~2"><b>IO::Socket::SSL-&gt;new_from_fd($fd,
    [mode], </b><span class="Li"><b>%sslargs</b></span><b>)</b></a></dt>
  <dd>This will convert a socket identified via a file descriptor into an SSL
      socket. Note that the argument list does not include a &quot;MODE&quot;
      argument; if you supply one, it will be thoughtfully ignored (for
      compatibility with IO::Socket::INET). Instead, a mode of '+&lt;' is
      assumed, and the file descriptor passed must be able to handle such I/O
      because the initial SSL handshake requires bidirectional communication.
    <p class="Pp">Internally the given <span class="Li">$fd</span> will be
        upgraded to a socket object using the
        <span class="Li">&quot;new_from_fd&quot;</span> method of the super
        class (IO::Socket::INET or similar) and then
        <span class="Li">&quot;start_SSL&quot;</span> will be called using the
        given <span class="Li">%sslargs</span>. If <span class="Li">$fd</span>
        is already an IO::Socket object you should better call
        <span class="Li">&quot;start_SSL&quot;</span> directly.</p>
  </dd>
  <dt id="IO::Socket::SSL::default_ca(_"><a class="permalink" href="#IO::Socket::SSL::default_ca(_"><b>IO::Socket::SSL::default_ca([
    path|dir| SSL_ca_file =</b> ..., SSL_ca_path =&gt; ... ])&gt;</a></dt>
  <dd>Determines or sets the default CA path. If existing path or dir or a hash
      is given it will set the default CA path to this value and never try to
      detect it automatically. If <span class="Li">&quot;undef&quot;</span> is
      given it will forget any stored defaults and continue with detection of
      system defaults. If no arguments are given it will start detection of
      system defaults, unless it has already stored user-set or previously
      detected values.
    <p class="Pp">The detection of system defaults works similar to OpenSSL,
        e.g. it will check the directory specified in environment variable
        SSL_CERT_DIR or the path OPENSSLDIR/certs (SSLCERTS: on VMS) and the
        file specified in environment variable SSL_CERT_FILE or the path
        OPENSSLDIR/cert.pem (SSLCERTS:cert.pem on VMS). Contrary to OpenSSL it
        will check if the SSL_ca_path contains PEM files with the hash as file
        name and if the SSL_ca_file looks like PEM. If no usable system default
        can be found it will try to load and use Mozilla::CA and if not
        available give up detection. The result of the detection will be saved
        to speed up future calls.</p>
    <p class="Pp">The function returns the saved default CA as hash with
        SSL_ca_file and SSL_ca_path.</p>
  </dd>
  <dt id="IO::Socket::SSL::set_default_context(...)"><a class="permalink" href="#IO::Socket::SSL::set_default_context(...)"><b>IO::Socket::SSL::set_default_context(...)</b></a></dt>
  <dd>You may use this to make IO::Socket::SSL automatically re-use a given
      context (unless specifically overridden in a call to <b>new()</b>). It
      accepts one argument, which should be either an IO::Socket::SSL object or
      an IO::Socket::SSL::SSL_Context object. See the SSL_reuse_ctx option of
      <b>new()</b> for more details. Note that this sets the default context
      globally, so use with caution (esp. in mod_perl scripts).</dd>
  <dt id="IO::Socket::SSL::set_default_session_cache(...)"><a class="permalink" href="#IO::Socket::SSL::set_default_session_cache(...)"><b>IO::Socket::SSL::set_default_session_cache(...)</b></a></dt>
  <dd>You may use this to make IO::Socket::SSL automatically re-use a given
      session cache (unless specifically overridden in a call to <b>new()</b>).
      It accepts one argument, which should be an IO::Socket::SSL::Session_Cache
      object or similar (e.g. something which implements get_session,
      add_session and del_session like IO::Socket::SSL::Session_Cache does). See
      the SSL_session_cache option of <b>new()</b> for more details. Note that
      this sets the default cache globally, so use with caution.</dd>
  <dt id="IO::Socket::SSL::set_defaults(_args)"><a class="permalink" href="#IO::Socket::SSL::set_defaults(_args)"><b>IO::Socket::SSL::set_defaults(%args)</b></a></dt>
  <dd>With this function one can set defaults for all SSL_* parameter used for
      creation of the context, like the SSL_verify* parameter. Any SSL_*
      parameter can be given or the following short versions:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="mode"><a class="permalink" href="#mode">mode -
    SSL_verify_mode</a></dt>
  <dd></dd>
  <dt id="callback"><a class="permalink" href="#callback">callback -
    SSL_verify_callback</a></dt>
  <dd></dd>
  <dt id="scheme"><a class="permalink" href="#scheme">scheme -
    SSL_verifycn_scheme</a></dt>
  <dd></dd>
  <dt id="name"><a class="permalink" href="#name">name -
    SSL_verifycn_name</a></dt>
  <dd></dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="IO::Socket::SSL::set_client_defaults(_args)"><a class="permalink" href="#IO::Socket::SSL::set_client_defaults(_args)"><b>IO::Socket::SSL::set_client_defaults(%args)</b></a></dt>
  <dd>Similar to <span class="Li">&quot;set_defaults&quot;</span>, but only sets
      the defaults for client mode.</dd>
  <dt id="IO::Socket::SSL::set_server_defaults(_args)"><a class="permalink" href="#IO::Socket::SSL::set_server_defaults(_args)"><b>IO::Socket::SSL::set_server_defaults(%args)</b></a></dt>
  <dd>Similar to <span class="Li">&quot;set_defaults&quot;</span>, but only sets
      the defaults for server mode.</dd>
  <dt id="IO::Socket::SSL::set_args_filter_hack("><a class="permalink" href="#IO::Socket::SSL::set_args_filter_hack("><b>IO::Socket::SSL::set_args_filter_hack(\&amp;code|'use_defaults')</b></a></dt>
  <dd>Sometimes one has to use code which uses unwanted or invalid arguments for
      SSL, typically disabling SSL verification or setting wrong ciphers or SSL
      versions. With this hack it is possible to override these settings and
      restore sanity. Example:
    <p class="Pp"></p>
    <pre>    IO::Socket::SSL::set_args_filter_hack( sub {
        my ($is_server,$args) = @_;
        if ( ! $is_server ) {
            # client settings - enable verification with default CA
            # and fallback hostname verification etc
            delete @{$args}{qw(
                SSL_verify_mode
                SSL_ca_file
                SSL_ca_path
                SSL_verifycn_scheme
                SSL_version
            )};
            # and add some fingerprints for known certs which are signed by
            # unknown CAs or are self-signed
            $args-&gt;{SSL_fingerprint} = ...
        }
    });
    </pre>
    <p class="Pp">With the short setting
        <span class="Li">&quot;set_args_filter_hack('use_defaults')&quot;</span>
        it will prefer the default settings in all cases. These default settings
        can be modified with <span class="Li">&quot;set_defaults&quot;</span>,
        <span class="Li">&quot;set_client_defaults&quot;</span> and
        <span class="Li">&quot;set_server_defaults&quot;</span>.</p>
  </dd>
</dl>
<p class="Pp">The following methods are unsupported (not to mention futile!) and
    IO::Socket::SSL will emit a large <b>CROAK()</b> if you are silly enough to
    use them:</p>
<dl class="Bl-tag">
  <dt id="truncate"><a class="permalink" href="#truncate">truncate</a></dt>
  <dd></dd>
  <dt id="stat"><a class="permalink" href="#stat">stat</a></dt>
  <dd></dd>
  <dt id="ungetc"><a class="permalink" href="#ungetc">ungetc</a></dt>
  <dd></dd>
  <dt id="setbuf"><a class="permalink" href="#setbuf">setbuf</a></dt>
  <dd></dd>
  <dt id="setvbuf"><a class="permalink" href="#setvbuf">setvbuf</a></dt>
  <dd></dd>
  <dt id="fdopen"><a class="permalink" href="#fdopen">fdopen</a></dt>
  <dd></dd>
  <dt id="send/recv"><a class="permalink" href="#send/recv">send/recv</a></dt>
  <dd>Note that <b>send()</b> and <b>recv()</b> cannot be reliably trapped by a
      tied filehandle (such as that used by IO::Socket::SSL) and so may send
      unencrypted data over the socket.	 Object-oriented calls to these
      functions will fail, telling you to use the print/printf/syswrite and
      read/sysread families instead.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="DEPRECATIONS"><a class="permalink" href="#DEPRECATIONS">DEPRECATIONS</a></h1>
<p class="Pp">The following functions are deprecated and are only retained for
    compatibility:</p>
<dl class="Bl-tag">
  <dt id="context_init()"><a class="permalink" href="#context_init()"><b>context_init()</b></a></dt>
  <dd>use the SSL_reuse_ctx option if you want to re-use a context</dd>
  <dt id="socketToSSL()"><a class="permalink" href="#socketToSSL()"><b>socketToSSL()</b>
    and <b>socket_to_SSL()</b></a></dt>
  <dd>use IO::Socket::SSL-&gt;<b>start_SSL()</b> instead</dd>
  <dt id="kill_socket()"><a class="permalink" href="#kill_socket()"><b>kill_socket()</b></a></dt>
  <dd>use <b>close()</b> instead</dd>
  <dt id="get_peer_certificate()"><a class="permalink" href="#get_peer_certificate()"><b>get_peer_certificate()</b></a></dt>
  <dd>use the <b>peer_certificate()</b> function instead. Used to return
      X509_Certificate with methods subject_name and issuer_name. Now simply
      returns <span class="Li">$self</span> which has these methods (although
      deprecated).</dd>
  <dt id="issuer_name()"><a class="permalink" href="#issuer_name()"><b>issuer_name()</b></a></dt>
  <dd>use peer_certificate( 'issuer' ) instead</dd>
  <dt id="subject_name()"><a class="permalink" href="#subject_name()"><b>subject_name()</b></a></dt>
  <dd>use peer_certificate( 'subject' ) instead</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">See the 'example' directory, the tests in 't' and also the tools
    in 'util'.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">If you use IO::Socket::SSL together with threads you should load
    it (e.g. use or require) inside the main thread before creating any other
    threads which use it. This way it is much faster because it will be
    initialized only once. Also there are reports that it might crash the other
    way.</p>
<p class="Pp">Creating an IO::Socket::SSL object in one thread and closing it in
    another thread will not work.</p>
<p class="Pp">IO::Socket::SSL does not work together with
    Storable::fd_retrieve/fd_store. See BUGS file for more information and how
    to work around the problem.</p>
<p class="Pp">Non-blocking and timeouts (which are based on non-blocking) are
    not supported on Win32, because the underlying IO::Socket::INET does not
    support non-blocking on this platform.</p>
<p class="Pp">If you have a server and it looks like you have a memory leak you
    might check the size of your session cache. Default for Net::SSLeay seems to
    be 20480, see the example for SSL_create_ctx_callback for how to limit
  it.</p>
<p class="Pp">TLS 1.3 support regarding session reuse is incomplete.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">IO::Socket::INET, IO::Socket::INET6, IO::Socket::IP,
  Net::SSLeay.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="THANKS"><a class="permalink" href="#THANKS">THANKS</a></h1>
<p class="Pp">Many thanks to all who added patches or reported bugs or helped
    IO::Socket::SSL another way. Please keep reporting bugs and help with
    patches, even if they just fix the documentation.</p>
<p class="Pp">Special thanks to the team of Net::SSLeay for the good
    cooperation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp">Steffen Ullrich, &lt;sullr at cpan.org&gt; is the current
    maintainer.</p>
<p class="Pp">Peter Behroozi, &lt;behrooz at fas.harvard.edu&gt; (Note the lack
    of an &quot;i&quot; at the end of &quot;behrooz&quot;)</p>
<p class="Pp">Marko Asplund, &lt;marko.asplund at kronodoc.fi&gt;, was the
    original author of IO::Socket::SSL.</p>
<p class="Pp">Patches incorporated from various people, see file Changes.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">The original versions of this module are Copyright (C) 1999-2002
    Marko Asplund.</p>
<p class="Pp">The rewrite of this module is Copyright (C) 2002-2005 Peter
    Behroozi.</p>
<p class="Pp">Versions 0.98 and newer are Copyright (C) 2006-2014 Steffen
    Ullrich.</p>
<p class="Pp">This module is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-02-19</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

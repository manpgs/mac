<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Hash::Util::FieldHash(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Hash::Util::FieldHash(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Hash::Util::FieldHash(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Hash::Util::FieldHash - Support for Inside-Out Classes</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  ### Create fieldhashes
  use Hash::Util qw(fieldhash fieldhashes);
  # Create a single field hash
  fieldhash my %foo;
  # Create three at once...
  fieldhashes \ my(%foo, %bar, %baz);
  # ...or any number
  fieldhashes @hashrefs;
  ### Create an idhash and register it for garbage collection
  use Hash::Util::FieldHash qw(idhash register);
  idhash my %name;
  my $object = \ do { my $o };
  # register the idhash for garbage collection with $object
  register($object, \ %name);
  # the following entry will be deleted when $object goes out of scope
  $name{$object} = 'John Doe';
  ### Register an ordinary hash for garbage collection
  use Hash::Util::FieldHash qw(id register);
  my %name;
  my $object = \ do { my $o };
  # register the hash %name for garbage collection of $object's id
  register $object, \ %name;
  # the following entry will be deleted when $object goes out of scope
  $name{id $object} = 'John Doe';
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTIONS"><a class="permalink" href="#FUNCTIONS">FUNCTIONS</a></h1>
<p class="Pp"><span class="Li">&quot;Hash::Util::FieldHash&quot;</span> offers a
    number of functions in support of &quot;The Inside-out Technique&quot; of
    class construction.</p>
<dl class="Bl-tag">
  <dt id="id"><a class="permalink" href="#id">id</a></dt>
  <dd>
    <pre>    id($obj)
    </pre>
    <p class="Pp">Returns the reference address of a reference
        <span class="Li">$obj</span>. If <span class="Li">$obj</span> is not a
        reference, returns <span class="Li">$obj</span>.</p>
    <p class="Pp">This function is a stand-in replacement for
        Scalar::Util::refaddr, that is, it returns the reference address of its
        argument as a numeric value. The only difference is that
        <span class="Li">&quot;refaddr()&quot;</span> returns
        <span class="Li">&quot;undef&quot;</span> when given a non-reference
        while <span class="Li">&quot;id()&quot;</span> returns its argument
        unchanged.</p>
    <p class="Pp"><span class="Li">&quot;id()&quot;</span> also uses a caching
        technique that makes it faster when the id of an object is requested
        often, but slower if it is needed only once or twice.</p>
  </dd>
  <dt id="id_2obj"><a class="permalink" href="#id_2obj">id_2obj</a></dt>
  <dd>
    <pre>    $obj = id_2obj($id)
    </pre>
    <p class="Pp">If <span class="Li">$id</span> is the id of a registered
        object (see &quot;register&quot;), returns the object, otherwise an
        undefined value. For registered objects this is the inverse function of
        <span class="Li">&quot;id()&quot;</span>.</p>
  </dd>
  <dt id="register"><a class="permalink" href="#register">register</a></dt>
  <dd>
    <pre>    register($obj)
    register($obj, @hashrefs)
    </pre>
    <p class="Pp">In the first form, registers an object to work with for the
        function <span class="Li">&quot;id_2obj()&quot;</span>. In the second
        form, it additionally marks the given hashrefs down for garbage
        collection. This means that when the object goes out of scope, any
        entries in the given hashes under the key of
        <span class="Li">&quot;id($obj)&quot;</span> will be deleted from the
        hashes.</p>
    <p class="Pp">It is a fatal error to register a non-reference
        <span class="Li">$obj</span>. Any non-hashrefs among the following
        arguments are silently ignored.</p>
    <p class="Pp">It is <i>not</i> an error to register the same object multiple
        times with varying sets of hashrefs. Any hashrefs that are not
        registered yet will be added, others ignored.</p>
    <p class="Pp">Registry also implies thread support. When a new thread is
        created, all references are replaced with new ones, including all
        objects. If a hash uses the reference address of an object as a key,
        that connection would be broken. With a registered object, its id will
        be updated in all hashes registered with it.</p>
  </dd>
  <dt id="idhash"><a class="permalink" href="#idhash">idhash</a></dt>
  <dd>
    <pre>    idhash my %hash
    </pre>
    <p class="Pp">Makes an idhash from the argument, which must be a hash.</p>
    <p class="Pp">An <i>idhash</i> works like a normal hash, except that it
        stringifies a <i>reference used as a key</i> differently. A reference is
        stringified as if the <span class="Li">&quot;id()&quot;</span> function
        had been invoked on it, that is, its reference address in decimal is
        used as the key.</p>
  </dd>
  <dt id="idhashes"><a class="permalink" href="#idhashes">idhashes</a></dt>
  <dd>
    <pre>    idhashes \ my(%hash, %gnash, %trash)
    idhashes \ @hashrefs
    </pre>
    <p class="Pp">Creates many idhashes from its hashref arguments. Returns
        those arguments that could be converted or their number in scalar
        context.</p>
  </dd>
  <dt id="fieldhash"><a class="permalink" href="#fieldhash">fieldhash</a></dt>
  <dd>
    <pre>    fieldhash %hash;
    </pre>
    <p class="Pp">Creates a single fieldhash. The argument must be a hash.
        Returns a reference to the given hash if successful, otherwise
      nothing.</p>
    <p class="Pp">A <i>fieldhash</i> is, in short, an idhash with auto-registry.
        When an object (or, indeed, any reference) is used as a fieldhash key,
        the fieldhash is automatically registered for garbage collection with
        the object, as if <span class="Li">&quot;register $obj, \
        %fieldhash&quot;</span> had been called.</p>
  </dd>
  <dt id="fieldhashes"><a class="permalink" href="#fieldhashes">fieldhashes</a></dt>
  <dd>
    <pre>    fieldhashes @hashrefs;
    </pre>
    <p class="Pp">Creates any number of field hashes. Arguments must be hash
        references. Returns the converted hashrefs in list context, their number
        in scalar context.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">A word on terminology: I shall use the term <i>field</i> for a
    scalar piece of data that a class associates with an object. Other terms
    that have been used for this concept are &quot;object variable&quot;,
    &quot;(object) property&quot;, &quot;(object) attribute&quot; and more.
    Especially &quot;attribute&quot; has some currency among Perl programmer,
    but that clashes with the <span class="Li">&quot;attributes&quot;</span>
    pragma. The term &quot;field&quot; also has some currency in this sense and
    doesn't seem to conflict with other Perl terminology.</p>
<p class="Pp">In Perl, an object is a blessed reference. The standard way of
    associating data with an object is to store the data inside the object's
    body, that is, the piece of data pointed to by the reference.</p>
<p class="Pp">In consequence, if two or more classes want to access an object
    they <i>must</i> agree on the type of reference and also on the organization
    of data within the object body. Failure to agree on the type results in
    immediate death when the wrong method tries to access an object. Failure to
    agree on data organization may lead to one class trampling over the data of
    another.</p>
<p class="Pp">This object model leads to a tight coupling between subclasses. If
    one class wants to inherit from another (and both classes access object
    data), the classes must agree about implementation details. Inheritance can
    only be used among classes that are maintained together, in a single source
    or not.</p>
<p class="Pp">In particular, it is not possible to write general-purpose classes
    in this technique, classes that can advertise themselves as &quot;Put me on
    your <span class="Li">@ISA</span> list and use my methods&quot;. If the
    other class has different ideas about how the object body is used, there is
    trouble.</p>
<p class="Pp">For reference <span class="Li">&quot;Name_hash&quot;</span> in
    &quot;Example 1&quot; shows the standard implementation of a simple class
    <span class="Li">&quot;Name&quot;</span> in the well-known hash based way.
    It also demonstrates the predictable failure to construct a common subclass
    <span class="Li">&quot;NamedFile&quot;</span> of
    <span class="Li">&quot;Name&quot;</span> and the class
    <span class="Li">&quot;IO::File&quot;</span> (whose objects <i>must</i> be
    globrefs).</p>
<p class="Pp">Thus, techniques are of interest that store object data <i>not</i>
    in the object body but some other place.</p>
<section class="Ss">
<h2 class="Ss" id="The_Inside-out_Technique"><a class="permalink" href="#The_Inside-out_Technique">The
  Inside-out Technique</a></h2>
<p class="Pp">With <i>inside-out</i> classes, each class declares a (typically
    lexical) hash for each field it wants to use. The reference address of an
    object is used as the hash key. By definition, the reference address is
    unique to each object so this guarantees a place for each field that is
    private to the class and unique to each object. See
    <span class="Li">&quot;Name_id&quot;</span> in &quot;Example 1&quot; for a
    simple example.</p>
<p class="Pp">In comparison to the standard implementation where the object is a
    hash and the fields correspond to hash keys, here the fields correspond to
    hashes, and the object determines the hash key. Thus the hashes appear to be
    turned <i>inside out</i>.</p>
<p class="Pp">The body of an object is never examined by an inside-out class,
    only its reference address is used. This allows for the body of an actual
    object to be <i>anything at all</i> while the object methods of the class
    still work as designed. This is a key feature of inside-out classes.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Problems_of_Inside-out"><a class="permalink" href="#Problems_of_Inside-out">Problems
  of Inside-out</a></h2>
<p class="Pp">Inside-out classes give us freedom of inheritance, but as usual
    there is a price.</p>
<p class="Pp">Most obviously, there is the necessity of retrieving the reference
    address of an object for each data access. It's a minor inconvenience, but
    it does clutter the code.</p>
<p class="Pp">More important (and less obvious) is the necessity of garbage
    collection. When a normal object dies, anything stored in the object body is
    garbage-collected by perl. With inside-out objects, Perl knows nothing about
    the data stored in field hashes by a class, but these must be deleted when
    the object goes out of scope. Thus the class must provide a
    <span class="Li">&quot;DESTROY&quot;</span> method to take care of that.</p>
<p class="Pp">In the presence of multiple classes it can be non-trivial to make
    sure that every relevant destructor is called for every object. Perl calls
    the first one it finds on the inheritance tree (if any) and that's it.</p>
<p class="Pp">A related issue is thread-safety. When a new thread is created,
    the Perl interpreter is cloned, which implies that all reference addresses
    in use will be replaced with new ones. Thus, if a class tries to access a
    field of a cloned object its (cloned) data will still be stored under the
    now invalid reference address of the original in the parent thread. A
    general <span class="Li">&quot;CLONE&quot;</span> method must be provided to
    re-establish the association.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Solutions"><a class="permalink" href="#Solutions">Solutions</a></h2>
<p class="Pp"><span class="Li">&quot;Hash::Util::FieldHash&quot;</span>
    addresses these issues on several levels.</p>
<p class="Pp">The <span class="Li">&quot;id()&quot;</span> function is provided
    in addition to the existing
    <span class="Li">&quot;Scalar::Util::refaddr()&quot;</span>. Besides its
    short name it can be a little faster under some circumstances (and a bit
    slower under others). Benchmark if it matters. The working of
    <span class="Li">&quot;id()&quot;</span> also allows the use of the class
    name as a <i>generic object</i> as described further down.</p>
<p class="Pp">The <span class="Li">&quot;id()&quot;</span> function is
    incorporated in <i>id hashes</i> in the sense that it is called
    automatically on every key that is used with the hash. No explicit call is
    necessary.</p>
<p class="Pp">The problems of garbage collection and thread safety are both
    addressed by the function <span class="Li">&quot;register()&quot;</span>. It
    registers an object together with any number of hashes. Registry means that
    when the object dies, an entry in any of the hashes under the reference
    address of this object will be deleted. This guarantees garbage collection
    in these hashes. It also means that on thread cloning the object's entries
    in registered hashes will be replaced with updated entries whose key is the
    cloned object's reference address. Thus the object-data association becomes
    thread-safe.</p>
<p class="Pp">Object registry is best done when the object is initialized for
    use with a class. That way, garbage collection and thread safety are
    established for every object and every field that is initialized.</p>
<p class="Pp">Finally, <i>field hashes</i> incorporate all these functions in
    one package. Besides automatically calling the
    <span class="Li">&quot;id()&quot;</span> function on every object used as a
    key, the object is registered with the field hash on first use. Classes
    based on field hashes are fully garbage-collected and thread safe without
    further measures.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="More_Problems"><a class="permalink" href="#More_Problems">More
  Problems</a></h2>
<p class="Pp">Another problem that occurs with inside-out classes is
    serialization. Since the object data is not in its usual place, standard
    routines like <span class="Li">&quot;Storable::freeze()&quot;</span>,
    <span class="Li">&quot;Storable::thaw()&quot;</span> and
    <span class="Li">&quot;Data::Dumper::Dumper()&quot;</span> can't deal with
    it on their own. Both <span class="Li">&quot;Data::Dumper&quot;</span> and
    <span class="Li">&quot;Storable&quot;</span> provide the necessary hooks to
    make things work, but the functions or methods used by the hooks must be
    provided by each inside-out class.</p>
<p class="Pp">A general solution to the serialization problem would require
    another level of registry, one that associates <i>classes</i> and fields. So
    far, the functions of
    <span class="Li">&quot;Hash::Util::FieldHash&quot;</span> are unaware of any
    classes, which I consider a feature. Therefore
    <span class="Li">&quot;Hash::Util::FieldHash&quot;</span> doesn't address
    the serialization problems.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Generic_Object"><a class="permalink" href="#The_Generic_Object">The
  Generic Object</a></h2>
<p class="Pp">Classes based on the <span class="Li">&quot;id()&quot;</span>
    function (and hence classes based on
    <span class="Li">&quot;idhash()&quot;</span> and
    <span class="Li">&quot;fieldhash()&quot;</span>) show a peculiar behavior in
    that the class name can be used like an object. Specifically, methods that
    set or read data associated with an object continue to work as class
    methods, just as if the class name were an object, distinct from all other
    objects, with its own data. This object may be called the <i>generic
    object</i> of the class.</p>
<p class="Pp">This works because field hashes respond to keys that are not
    references like a normal hash would and use the string offered as the hash
    key. Thus, if a method is called as a class method, the field hash is
    presented with the class name instead of an object and blithely uses it as a
    key. Since the keys of real objects are decimal numbers, there is no
    conflict and the slot in the field hash can be used like any other. The
    <span class="Li">&quot;id()&quot;</span> function behaves correspondingly
    with respect to non-reference arguments.</p>
<p class="Pp">Two possible uses (besides ignoring the property) come to mind. A
    singleton class could be implemented this using the generic object. If
    necessary, an <span class="Li">&quot;init()&quot;</span> method could die or
    ignore calls with actual objects (references), so only the generic object
    will ever exist.</p>
<p class="Pp">Another use of the generic object would be as a template. It is a
    convenient place to store class-specific defaults for various fields to be
    used in actual object initialization.</p>
<p class="Pp">Usually, the feature can be entirely ignored. Calling
    <i>object</i> <i>methods</i> as <i>class methods</i> normally leads to an
    error and isn't used routinely anywhere. It may be a problem that this error
    isn't indicated by a class with a generic object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_to_use_Field_Hashes"><a class="permalink" href="#How_to_use_Field_Hashes">How
  to use Field Hashes</a></h2>
<p class="Pp">Traditionally, the definition of an inside-out class contains a
    bare block inside which a number of lexical hashes are declared and the
    basic accessor methods defined, usually through
    <span class="Li">&quot;Scalar::Util::refaddr&quot;</span>. Further methods
    may be defined outside this block. There has to be a DESTROY method and, for
    thread support, a CLONE method.</p>
<p class="Pp">When field hashes are used, the basic structure remains the same.
    Each lexical hash will be made a field hash. The call to
    <span class="Li">&quot;refaddr&quot;</span> can be omitted from the accessor
    methods. DESTROY and CLONE methods are not necessary.</p>
<p class="Pp">If you have an existing inside-out class, simply making all hashes
    field hashes with no other change should make no difference. Through the
    calls to <span class="Li">&quot;refaddr&quot;</span> or equivalent, the
    field hashes never get to see a reference and work like normal hashes. Your
    DESTROY (and CLONE) methods are still needed.</p>
<p class="Pp">To make the field hashes kick in, it is easiest to redefine
    <span class="Li">&quot;refaddr&quot;</span> as</p>
<p class="Pp"></p>
<pre>    sub refaddr { shift }
</pre>
<p class="Pp">instead of importing it from
    <span class="Li">&quot;Scalar::Util&quot;</span>. It should now be possible
    to disable DESTROY and CLONE. Note that while it isn't disabled, DESTROY
    will be called before the garbage collection of field hashes, so it will be
    invoked with a functional object and will continue to function.</p>
<p class="Pp">It is not desirable to import the functions
    <span class="Li">&quot;fieldhash&quot;</span> and/or
    <span class="Li">&quot;fieldhashes&quot;</span> into every class that is
    going to use them. They are only used once to set up the class. When the
    class is up and running, these functions serve no more purpose.</p>
<p class="Pp">If there are only a few field hashes to declare, it is simplest
  to</p>
<p class="Pp"></p>
<pre>    use Hash::Util::FieldHash;
</pre>
<p class="Pp">early and call the functions qualified:</p>
<p class="Pp"></p>
<pre>    Hash::Util::FieldHash::fieldhash my %foo;
</pre>
<p class="Pp">Otherwise, import the functions into a convenient package like
    <span class="Li">&quot;HUF&quot;</span> or, more general,
    <span class="Li">&quot;Aux&quot;</span></p>
<p class="Pp"></p>
<pre>    {
        package Aux;
        use Hash::Util::FieldHash ':all';
    }
</pre>
<p class="Pp">and call</p>
<p class="Pp"></p>
<pre>    Aux::fieldhash my %foo;
</pre>
<p class="Pp">as needed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Garbage-Collected_Hashes"><a class="permalink" href="#Garbage-Collected_Hashes">Garbage-Collected
  Hashes</a></h2>
<p class="Pp">Garbage collection in a field hash means that entries will
    &quot;spontaneously&quot; disappear when the object that created them
    disappears. That must be borne in mind, especially when looping over a field
    hash. If anything you do inside the loop could cause an object to go out of
    scope, a random key may be deleted from the hash you are looping over. That
    can throw the loop iterator, so it's best to cache a consistent snapshot of
    the keys and/or values and loop over that. You will still have to check that
    a cached entry still exists when you get to it.</p>
<p class="Pp">Garbage collection can be confusing when keys are created in a
    field hash from normal scalars as well as references. Once a reference is
    <i>used</i> with a field hash, the entry will be collected, even if it was
    later overwritten with a plain scalar key (every positive integer is a
    candidate). This is true even if the original entry was deleted in the
    meantime. In fact, deletion from a field hash, and also a test for existence
    constitute <i>use</i> in this sense and create a liability to delete the
    entry when the reference goes out of scope. If you happen to create an entry
    with an identical key from a string or integer, that will be collected
    instead. Thus, mixed use of references and plain scalars as field hash keys
    is not entirely supported.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">The examples show a very simple class that implements a
    <i>name</i>, consisting of a first and last name (no middle initial). The
    name class has four methods:</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;init()&quot;</span>
    <p class="Pp">An object method that initializes the first and last name to
        its two arguments. If called as a class method,
        <span class="Li">&quot;init()&quot;</span> creates an object in the
        given class and initializes that.</p>
  </li>
  <li><span class="Li">&quot;first()&quot;</span>
    <p class="Pp">Retrieve the first name</p>
  </li>
  <li><span class="Li">&quot;last()&quot;</span>
    <p class="Pp">Retrieve the last name</p>
  </li>
  <li><span class="Li">&quot;name()&quot;</span>
    <p class="Pp">Retrieve the full name, the first and last name joined by a
        blank.</p>
  </li>
</ul>
<p class="Pp">The examples show this class implemented with different levels of
    support by <span class="Li">&quot;Hash::Util::FieldHash&quot;</span>. All
    supported combinations are shown. The difference between implementations is
    often quite small. The implementations are:</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;Name_hash&quot;</span>
    <p class="Pp">A conventional (not inside-out) implementation where an object
        is a hash that stores the field values, without support by
        <span class="Li">&quot;Hash::Util::FieldHash&quot;</span>. This
        implementation doesn't allow arbitrary inheritance.</p>
  </li>
  <li><span class="Li">&quot;Name_id&quot;</span>
    <p class="Pp">Inside-out implementation based on the
        <span class="Li">&quot;id()&quot;</span> function. It needs a
        <span class="Li">&quot;DESTROY&quot;</span> method. For thread support a
        <span class="Li">&quot;CLONE&quot;</span> method (not shown) would also
        be needed. Instead of
        <span class="Li">&quot;Hash::Util::FieldHash::id()&quot;</span> the
        function <span class="Li">&quot;Scalar::Util::refaddr&quot;</span> could
        be used with very little functional difference. This is the basic
        pattern of an inside-out class.</p>
  </li>
  <li><span class="Li">&quot;Name_idhash&quot;</span>
    <p class="Pp">Idhash-based inside-out implementation. Like
        <span class="Li">&quot;Name_id&quot;</span> it needs a
        <span class="Li">&quot;DESTROY&quot;</span> method and would need
        <span class="Li">&quot;CLONE&quot;</span> for thread support.</p>
  </li>
  <li><span class="Li">&quot;Name_id_reg&quot;</span>
    <p class="Pp">Inside-out implementation based on the
        <span class="Li">&quot;id()&quot;</span> function with explicit object
        registry. No destructor is needed and objects are thread safe.</p>
  </li>
  <li><span class="Li">&quot;Name_idhash_reg&quot;</span>
    <p class="Pp">Idhash-based inside-out implementation with explicit object
        registry. No destructor is needed and objects are thread safe.</p>
  </li>
  <li><span class="Li">&quot;Name_fieldhash&quot;</span>
    <p class="Pp">FieldHash-based inside-out implementation. Object registry
        happens automatically. No destructor is needed and objects are thread
        safe.</p>
  </li>
</ul>
<p class="Pp">These examples are realized in the code below, which could be
    copied to a file <i>Example.pm</i>.</p>
<section class="Ss">
<h2 class="Ss" id="Example_1"><a class="permalink" href="#Example_1">Example
  1</a></h2>
<pre>    use strict; use warnings;
    {
        package Name_hash;  # standard implementation: the
                            # object is a hash
        sub init {
            my $obj = shift;
            my ($first, $last) = @_;
            # create an object if called as class method
            $obj = bless {}, $obj unless ref $obj;
            $obj-&gt;{ first} = $first;
            $obj-&gt;{ last} = $last;
            $obj;
        }
        sub first { shift()-&gt;{ first} }
        sub last { shift()-&gt;{ last} }
        sub name {
            my $n = shift;
            join ' ' =&gt; $n-&gt;first, $n-&gt;last;
        }
    }
    {
        package Name_id;
        use Hash::Util::FieldHash qw(id);
        my (%first, %last);
        sub init {
            my $obj = shift;
            my ($first, $last) = @_;
            # create an object if called as class method
            $obj = bless \ my $o, $obj unless ref $obj;
            $first{ id $obj} = $first;
            $last{ id $obj} = $last;
            $obj;
        }
        sub first { $first{ id shift()} }
        sub last { $last{ id shift()} }
        sub name {
            my $n = shift;
            join ' ' =&gt; $n-&gt;first, $n-&gt;last;
        }
        sub DESTROY {
            my $id = id shift;
            delete $first{ $id};
            delete $last{ $id};
        }
    }
    {
        package Name_idhash;
        use Hash::Util::FieldHash;
        Hash::Util::FieldHash::idhashes( \ my (%first, %last) );
        sub init {
            my $obj = shift;
            my ($first, $last) = @_;
            # create an object if called as class method
            $obj = bless \ my $o, $obj unless ref $obj;
            $first{ $obj} = $first;
            $last{ $obj} = $last;
            $obj;
        }
        sub first { $first{ shift()} }
        sub last { $last{ shift()} }
        sub name {
            my $n = shift;
            join ' ' =&gt; $n-&gt;first, $n-&gt;last;
        }
        sub DESTROY {
            my $n = shift;
            delete $first{ $n};
            delete $last{ $n};
        }
    }
    {
        package Name_id_reg;
        use Hash::Util::FieldHash qw(id register);
        my (%first, %last);
        sub init {
            my $obj = shift;
            my ($first, $last) = @_;
            # create an object if called as class method
            $obj = bless \ my $o, $obj unless ref $obj;
            register( $obj, \ (%first, %last) );
            $first{ id $obj} = $first;
            $last{ id $obj} = $last;
            $obj;
        }
        sub first { $first{ id shift()} }
        sub last { $last{ id shift()} }
        sub name {
            my $n = shift;
            join ' ' =&gt; $n-&gt;first, $n-&gt;last;
        }
    }
    {
        package Name_idhash_reg;
        use Hash::Util::FieldHash qw(register);
        Hash::Util::FieldHash::idhashes \ my (%first, %last);
        sub init {
            my $obj = shift;
            my ($first, $last) = @_;
            # create an object if called as class method
            $obj = bless \ my $o, $obj unless ref $obj;
            register( $obj, \ (%first, %last) );
            $first{ $obj} = $first;
            $last{ $obj} = $last;
            $obj;
        }
        sub first { $first{ shift()} }
        sub last { $last{ shift()} }
        sub name {
            my $n = shift;
            join ' ' =&gt; $n-&gt;first, $n-&gt;last;
        }
    }
    {
        package Name_fieldhash;
        use Hash::Util::FieldHash;
        Hash::Util::FieldHash::fieldhashes \ my (%first, %last);
        sub init {
            my $obj = shift;
            my ($first, $last) = @_;
            # create an object if called as class method
            $obj = bless \ my $o, $obj unless ref $obj;
            $first{ $obj} = $first;
            $last{ $obj} = $last;
            $obj;
        }
        sub first { $first{ shift()} }
        sub last { $last{ shift()} }
        sub name {
            my $n = shift;
            join ' ' =&gt; $n-&gt;first, $n-&gt;last;
        }
    }
    1;
</pre>
<p class="Pp">To exercise the various implementations the script below can be
    used.</p>
<p class="Pp">It sets up a class <span class="Li">&quot;Name&quot;</span> that
    is a mirror of one of the implementation classes
    <span class="Li">&quot;Name_hash&quot;</span>,
    <span class="Li">&quot;Name_id&quot;</span>, ...,
    <span class="Li">&quot;Name_fieldhash&quot;</span>. That determines which
    implementation is run.</p>
<p class="Pp">The script first verifies the function of the
    <span class="Li">&quot;Name&quot;</span> class.</p>
<p class="Pp">In the second step, the free inheritability of the implementation
    (or lack thereof) is demonstrated. For this purpose it constructs a class
    called <span class="Li">&quot;NamedFile&quot;</span> which is a common
    subclass of <span class="Li">&quot;Name&quot;</span> and the standard class
    <span class="Li">&quot;IO::File&quot;</span>. This puts inheritability to
    the test because objects of <span class="Li">&quot;IO::File&quot;</span>
    <i>must</i> be globrefs. Objects of
    <span class="Li">&quot;NamedFile&quot;</span> should behave like a file
    opened for reading and also support the
    <span class="Li">&quot;name()&quot;</span> method. This class juncture works
    with exception of the <span class="Li">&quot;Name_hash&quot;</span>
    implementation, where object initialization fails because of the
    incompatibility of object bodies.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Example_2"><a class="permalink" href="#Example_2">Example
  2</a></h2>
<pre>    use strict; use warnings; $| = 1;
    use Example;
    {
        package Name;
        use parent 'Name_id';  # define here which implementation to run
    }
    # Verify that the base package works
    my $n = Name-&gt;init(qw(Albert Einstein));
    print $n-&gt;name, &quot;\n&quot;;
    print &quot;\n&quot;;
    # Create a named file handle (See definition below)
    my $nf = NamedFile-&gt;init(qw(/tmp/x Filomena File));
    # use as a file handle...
    for ( 1 .. 3 ) {
        my $l = &lt;$nf&gt;;
        print &quot;line $_: $l&quot;;
    }
    # ...and as a Name object
    print &quot;...brought to you by &quot;, $nf-&gt;name, &quot;\n&quot;;
    exit;
    # Definition of NamedFile
    package NamedFile;
    use parent 'Name';
    use parent 'IO::File';
    sub init {
        my $obj = shift;
        my ($file, $first, $last) = @_;
        $obj = $obj-&gt;IO::File::new() unless ref $obj;
        $obj-&gt;open($file) or die &quot;Can't read '$file': $!&quot;;
        $obj-&gt;Name::init($first, $last);
    }
    __END__
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="GUTS"><a class="permalink" href="#GUTS">GUTS</a></h1>
<p class="Pp">To make <span class="Li">&quot;Hash::Util::FieldHash&quot;</span>
    work, there were two changes to <i>perl</i> itself.
    <span class="Li">&quot;PERL_MAGIC_uvar&quot;</span> was made available for
    hashes, and weak references now call uvar
    <span class="Li">&quot;get&quot;</span> magic after a weakref has been
    cleared. The first feature is used to make field hashes intercept their keys
    upon access. The second one triggers garbage collection.</p>
<section class="Ss">
<h2 class="Ss" id="The__PERL_MAGIC_uvar__interface_for_hashes"><a class="permalink" href="#The__PERL_MAGIC_uvar__interface_for_hashes">The
  &quot;PERL_MAGIC_uvar&quot; interface for hashes</a></h2>
<p class="Pp"><span class="Li">&quot;PERL_MAGIC_uvar&quot;</span> <i>get</i>
    magic is called from <span class="Li">&quot;hv_fetch_common&quot;</span> and
    <span class="Li">&quot;hv_delete_common&quot;</span> through the function
    <span class="Li">&quot;hv_magic_uvar_xkey&quot;</span>, which defines the
    interface. The call happens for hashes with &quot;uvar&quot; magic if the
    <span class="Li">&quot;ufuncs&quot;</span> structure has equal values in the
    <span class="Li">&quot;uf_val&quot;</span> and
    <span class="Li">&quot;uf_set&quot;</span> fields. Hashes are unaffected if
    (and as long as) these fields hold different values.</p>
<p class="Pp">Upon the call, the <span class="Li">&quot;mg_obj&quot;</span>
    field will hold the hash key to be accessed. Upon return, the
    <span class="Li">&quot;SV*&quot;</span> value in
    <span class="Li">&quot;mg_obj&quot;</span> will be used in place of the
    original key in the hash access. The integer index value in the first
    parameter will be the <span class="Li">&quot;action&quot;</span> value from
    <span class="Li">&quot;hv_fetch_common&quot;</span>, or -1 if the call is
    from <span class="Li">&quot;hv_delete_common&quot;</span>.</p>
<p class="Pp">This is a template for a function suitable for the
    <span class="Li">&quot;uf_val&quot;</span> field in a
    <span class="Li">&quot;ufuncs&quot;</span> structure for this call. The
    <span class="Li">&quot;uf_set&quot;</span> and
    <span class="Li">&quot;uf_index&quot;</span> fields are irrelevant.</p>
<p class="Pp"></p>
<pre>    IV watch_key(pTHX_ IV action, SV* field) {
        MAGIC* mg = mg_find(field, PERL_MAGIC_uvar);
        SV* keysv = mg-&gt;mg_obj;
        /* Do whatever you need to.  If you decide to
           supply a different key newkey, return it like this
        */
        sv_2mortal(newkey);
        mg-&gt;mg_obj = newkey;
        return 0;
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Weakrefs_call_uvar_magic"><a class="permalink" href="#Weakrefs_call_uvar_magic">Weakrefs
  call uvar magic</a></h2>
<p class="Pp">When a weak reference is stored in an
    <span class="Li">&quot;SV&quot;</span> that has &quot;uvar&quot; magic,
    <span class="Li">&quot;set&quot;</span> magic is called after the reference
    has gone stale. This hook can be used to trigger further garbage-collection
    activities associated with the referenced object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_field_hashes_work"><a class="permalink" href="#How_field_hashes_work">How
  field hashes work</a></h2>
<p class="Pp">The three features of key hashes, <i>key replacement</i>,
    <i>thread support</i>, and <i>garbage collection</i> are supported by a data
    structure called the <i>object registry</i>. This is a private hash where
    every object is stored. An &quot;object&quot; in this sense is any reference
    (blessed or unblessed) that has been used as a field hash key.</p>
<p class="Pp">The object registry keeps track of references that have been used
    as field hash keys. The keys are generated from the reference address like
    in a field hash (though the registry isn't a field hash). Each value is a
    weak copy of the original reference, stored in an
    <span class="Li">&quot;SV&quot;</span> that is itself magical
    (<span class="Li">&quot;PERL_MAGIC_uvar&quot;</span> again). The magical
    structure holds a list (another hash, really) of field hashes that the
    reference has been used with. When the weakref becomes stale, the magic is
    activated and uses the list to delete the reference from all field hashes it
    has been used with. After that, the entry is removed from the object
    registry itself. Implicitly, that frees the magic structure and the storage
    it has been using.</p>
<p class="Pp">Whenever a reference is used as a field hash key, the object
    registry is checked and a new entry is made if necessary. The field hash is
    then added to the list of fields this reference has used.</p>
<p class="Pp">The object registry is also used to repair a field hash after
    thread cloning. Here, the entire object registry is processed. For every
    reference found there, the field hashes it has used are visited and the
    entry is updated.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Internal_function_Hash::Util::FieldHash::_fieldhash"><a class="permalink" href="#Internal_function_Hash::Util::FieldHash::_fieldhash">Internal
  function Hash::Util::FieldHash::_fieldhash</a></h2>
<pre>    # test if %hash is a field hash
    my $result = _fieldhash \ %hash, 0;
    # make %hash a field hash
    my $result = _fieldhash \ %hash, 1;
</pre>
<p class="Pp"><span class="Li">&quot;_fieldhash&quot;</span> is the internal
    function used to create field hashes. It takes two arguments, a hashref and
    a mode. If the mode is boolean false, the hash is not changed but tested if
    it is a field hash. If the hash isn't a field hash the return value is
    boolean false. If it is, the return value indicates the mode of field hash.
    When called with a boolean true mode, it turns the given hash into a field
    hash of this mode, returning the mode of the created field hash.
    <span class="Li">&quot;_fieldhash&quot;</span> does not erase the given
    hash.</p>
<p class="Pp">Currently there is only one type of field hash, and only the
    boolean value of the mode makes a difference, but that may change.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Anno Siegel (ANNO) wrote the xs code and the changes in perl
    proper Jerry Hedden (JDHEDDEN) made it faster</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">Copyright (C) 2006-2007 by (Anno Siegel)</p>
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself, either Perl version 5.8.7 or,
    at your option, any later version of Perl 5 you may have available.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

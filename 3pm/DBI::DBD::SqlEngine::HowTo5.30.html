<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>DBI::DBD::SqlEngine::HowTo(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBI::DBD::SqlEngine::HowTo(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBI::DBD::SqlEngine::HowTo(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">DBI::DBD::SqlEngine::HowTo - Guide to create DBI::DBD::SqlEngine
    based driver</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
  perldoc DBI::DBD::SqlEngine::HowTo
  perldoc DBI
  perldoc DBI::DBD
  perldoc DBI::DBD::SqlEngine::Developers
  perldoc SQL::Eval
  perldoc DBI::DBD::SqlEngine
  perldoc DBI::DBD::SqlEngine::HowTo
  perldoc SQL::Statement::Embed
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This document provides a step-by-step guide, how to create a new
    <span class="Li">&quot;DBI::DBD::SqlEngine&quot;</span> based DBD. It
    expects that you carefully read the DBI documentation and that you're
    familiar with DBI::DBD and had read and understood DBD::ExampleP.</p>
<p class="Pp">This document addresses experienced developers who are really sure
    that they need to invest time when writing a new DBI Driver. Writing a DBI
    Driver is neither a weekend project nor an easy job for hobby coders after
    work. Expect one or two man-month of time for the first start.</p>
<p class="Pp">Those who are still reading, should be able to sing the rules of
    &quot;CREATING A NEW DRIVER&quot; in DBI::DBD.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CREATING_DRIVER_CLASSES"><a class="permalink" href="#CREATING_DRIVER_CLASSES">CREATING
  DRIVER CLASSES</a></h1>
<p class="Pp">Do you have an entry in DBI's DBD registry? DBI::DBD::SqlEngine
    expect having a unique prefix for every driver class in inheritance
  chain.</p>
<p class="Pp">It's easy to get a prefix - just drop the DBI team a note
    (&quot;GETTING_HELP&quot; in DBI). If you want for some reason hide your
    work, take a look at Class::Method::Modifiers how to wrap a private prefix
    method around existing
  <span class="Li">&quot;driver_prefix&quot;</span>.</p>
<p class="Pp">For this guide, a prefix of
    <span class="Li">&quot;foo_&quot;</span> is assumed.</p>
<section class="Ss">
<h2 class="Ss" id="Sample_Skeleton"><a class="permalink" href="#Sample_Skeleton">Sample
  Skeleton</a></h2>
<pre>
    package DBD::Foo;

    use strict;
    use warnings;
    use vars qw($VERSION);
    use base qw(DBI::DBD::SqlEngine);

    use DBI ();

    $VERSION = &quot;0.001&quot;;

    package DBD::Foo::dr;

    use vars qw(@ISA $imp_data_size);

    @ISA = qw(DBI::DBD::SqlEngine::dr);
    $imp_data_size = 0;

    package DBD::Foo::db;

    use vars qw(@ISA $imp_data_size);

    @ISA = qw(DBI::DBD::SqlEngine::db);
    $imp_data_size = 0;

    package DBD::Foo::st;

    use vars qw(@ISA $imp_data_size);

    @ISA = qw(DBI::DBD::SqlEngine::st);
    $imp_data_size = 0;

    package DBD::Foo::Statement;

    use vars qw(@ISA);

    @ISA = qw(DBI::DBD::SqlEngine::Statement);

    package DBD::Foo::Table;

    use vars qw(@ISA);

    @ISA = qw(DBI::DBD::SqlEngine::Table);

    1;
</pre>
<p class="Pp">Tiny, eh? And all you have now is a DBD named foo which will is
    able to deal with temporary tables, as long as you use SQL::Statement. In
    DBI::SQL::Nano environments, this DBD can do nothing.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Deal_with_own_attributes"><a class="permalink" href="#Deal_with_own_attributes">Deal
  with own attributes</a></h2>
<p class="Pp">Before we start doing usable stuff with our DBI driver, we need to
    think about what we want to do and how we want to do it.</p>
<p class="Pp">Do we need tunable knobs accessible by users? Do we need status
    information? All this is handled in attributes of the database handles (be
    careful when your DBD is running &quot;behind&quot; a DBD::Gofer proxy).</p>
<p class="Pp">How come the attributes into the DBD and how are they fetchable by
    the user? Good question, but you should know because you've read the DBI
    documentation.</p>
<p class="Pp"><span class="Li">&quot;DBI::DBD::SqlEngine::db::FETCH&quot;</span>
    and <span class="Li">&quot;DBI::DBD::SqlEngine::db::STORE&quot;</span>
    taking care for you - all they need to know is which attribute names are
    valid and mutable or immutable. Tell them by adding
    <span class="Li">&quot;init_valid_attributes&quot;</span> to your db
  class:</p>
<p class="Pp"></p>
<pre>
    sub init_valid_attributes
    {
        my $dbh = $_[0];

        $dbh-&gt;SUPER::init_valid_attributes ();

        $dbh-&gt;{foo_valid_attrs} = {
            foo_version         =&gt; 1,   # contains version of this driver
            foo_valid_attrs     =&gt; 1,   # contains the valid attributes of foo drivers
            foo_readonly_attrs  =&gt; 1,   # contains immutable attributes of foo drivers
            foo_bar             =&gt; 1,   # contains the bar attribute
            foo_baz             =&gt; 1,   # contains the baz attribute
            foo_manager         =&gt; 1,   # contains the manager of the driver instance
            foo_manager_type    =&gt; 1,   # contains the manager class of the driver instance
        };
        $dbh-&gt;{foo_readonly_attrs} = {
            foo_version         =&gt; 1,   # ensure no-one modifies the driver version
            foo_valid_attrs     =&gt; 1,   # do not permit one to add more valid attributes ...
            foo_readonly_attrs  =&gt; 1,   # ... or make the immutable mutable
            foo_manager         =&gt; 1,   # manager is set internally only
        };

        return $dbh;
    }
</pre>
<p class="Pp">Woooho - but now the user cannot assign new managers? This is
    intended, overwrite <span class="Li">&quot;STORE&quot;</span> to handle
  it!</p>
<p class="Pp"></p>
<pre>
    sub STORE ($$$)
    {
        my ( $dbh, $attrib, $value ) = @_;

        $dbh-&gt;SUPER::STORE( $attrib, $value );

        # we're still alive, so no exception is thrown ...
        # by DBI::DBD::SqlEngine::db::STORE
        if ( $attrib eq &quot;foo_manager_type&quot; )
        {
            $dbh-&gt;{foo_manager} = $dbh-&gt;{foo_manager_type}-&gt;new();
            # ... probably correct some states based on the new
            # foo_manager_type - see DBD::Sys for an example
        }
    }
</pre>
<p class="Pp">But ... my driver runs without a manager until someone first
    assignes a <span class="Li">&quot;foo_manager_type&quot;</span>. Well, no -
    there're two places where you can initialize defaults:</p>
<p class="Pp"></p>
<pre>
    sub init_default_attributes
    {
        my ($dbh, $phase) = @_;

        $dbh-&gt;SUPER::init_default_attributes($phase);

        if( 0 == $phase )
        {
            # init all attributes which have no knowledge about
            # user settings from DSN or the attribute hash
            $dbh-&gt;{foo_manager_type} = &quot;DBD::Foo::Manager&quot;;
        }
        elsif( 1 == $phase )
        {
            # init phase with more knowledge from DSN or attribute
            # hash
            $dbh-&gt;{foo_manager} = $dbh-&gt;{foo_manager_type}-&gt;new();
        }

        return $dbh;
    }
</pre>
<p class="Pp">So far we can prevent the users to use our database driver as data
    storage for anything and everything. We care only about the real important
    stuff for peace on earth and alike attributes. But in fact, the driver still
    can't do anything. It can do less than nothing - meanwhile it's not a stupid
    storage area anymore.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="User_comfort"><a class="permalink" href="#User_comfort">User
  comfort</a></h2>
<p class="Pp"><span class="Li">&quot;DBI::DBD::SqlEngine&quot;</span> since
    <span class="Li">0.05</span> consolidates all persistent meta data of a
    table into a single structure stored in
    <span class="Li">&quot;$dbh-&gt;{sql_meta}&quot;</span>. While
    DBI::DBD::SqlEngine provides only readonly access to this structure,
    modifications are still allowed.</p>
<p class="Pp">Primarily DBI::DBD::SqlEngine provides access via the setters
    <span class="Li">&quot;new_sql_engine_meta&quot;</span>,
    <span class="Li">&quot;get_sql_engine_meta&quot;</span>,
    <span class="Li">&quot;get_single_table_meta&quot;</span>,
    <span class="Li">&quot;set_single_table_meta&quot;</span>,
    <span class="Li">&quot;set_sql_engine_meta&quot;</span> and
    <span class="Li">&quot;clear_sql_engine_meta&quot;</span>. Those methods are
    easily accessible by the users via the <span class="Li">&quot;$dbh-&gt;func
    ()&quot;</span> interface provided by DBI. Well, many users don't feel
    comfortize when calling</p>
<p class="Pp"></p>
<pre>
    # don't require extension for tables cars
    $dbh-&gt;func (&quot;cars&quot;, &quot;f_ext&quot;, &quot;.csv&quot;, &quot;set_sql_engine_meta&quot;);
</pre>
<p class="Pp">DBI::DBD::SqlEngine will inject a method into your driver to
    increase the user comfort to allow:</p>
<p class="Pp"></p>
<pre>
    # don't require extension for tables cars
    $dbh-&gt;foo_set_meta (&quot;cars&quot;, &quot;f_ext&quot;, &quot;.csv&quot;);
</pre>
<p class="Pp">Better, but here and there users likes to do:</p>
<p class="Pp"></p>
<pre>
    # don't require extension for tables cars
    $dbh-&gt;{foo_tables}-&gt;{cars}-&gt;{f_ext} = &quot;.csv&quot;;
</pre>
<p class="Pp">This interface is provided when derived DBD's define following in
    <span class="Li">&quot;init_valid_attributes&quot;</span> (re-capture
    &quot;Deal with own attributes&quot;):</p>
<p class="Pp"></p>
<pre>
    sub init_valid_attributes
    {
        my $dbh = $_[0];

        $dbh-&gt;SUPER::init_valid_attributes ();

        $dbh-&gt;{foo_valid_attrs} = {
            foo_version         =&gt; 1,   # contains version of this driver
            foo_valid_attrs     =&gt; 1,   # contains the valid attributes of foo drivers
            foo_readonly_attrs  =&gt; 1,   # contains immutable attributes of foo drivers
            foo_bar             =&gt; 1,   # contains the bar attribute
            foo_baz             =&gt; 1,   # contains the baz attribute
            foo_manager         =&gt; 1,   # contains the manager of the driver instance
            foo_manager_type    =&gt; 1,   # contains the manager class of the driver instance
            foo_meta            =&gt; 1,   # contains the public interface to modify table meta attributes
        };
        $dbh-&gt;{foo_readonly_attrs} = {
            foo_version         =&gt; 1,   # ensure no-one modifies the driver version
            foo_valid_attrs     =&gt; 1,   # do not permit one to add more valid attributes ...
            foo_readonly_attrs  =&gt; 1,   # ... or make the immutable mutable
            foo_manager         =&gt; 1,   # manager is set internally only
            foo_meta            =&gt; 1,   # ensure public interface to modify table meta attributes are immutable
        };

        $dbh-&gt;{foo_meta} = &quot;foo_tables&quot;;

        return $dbh;
    }
</pre>
<p class="Pp">This provides a tied hash in
    <span class="Li">&quot;$dbh-&gt;{foo_tables}&quot;</span> and a tied hash
    for each table's meta data in
    <span class="Li">&quot;$dbh-&gt;{foo_tables}-&gt;{$table_name}&quot;</span>.
    Modifications on the table meta attributes are done using the table
  methods:</p>
<p class="Pp"></p>
<pre>
    sub get_table_meta_attr { ... }
    sub set_table_meta_attr { ... }
</pre>
<p class="Pp">Both methods can adjust the attribute name for compatibility
    reasons, e.g. when former versions of the DBD allowed different names to be
    used for the same flag:</p>
<p class="Pp"></p>
<pre>
    my %compat_map = (
                       abc =&gt; 'foo_abc',
                       xyz =&gt; 'foo_xyz',
                     );
    __PACKAGE__-&gt;register_compat_map( \%compat_map );
</pre>
<p class="Pp">If any user modification on a meta attribute needs
    reinitialization of the meta structure (in case of
    <span class="Li">&quot;DBI::DBD::SqlEngine&quot;</span> these are the
    attributes <span class="Li">&quot;f_file&quot;</span>,
    <span class="Li">&quot;f_dir&quot;</span>,
    <span class="Li">&quot;f_ext&quot;</span> and
    <span class="Li">&quot;f_lockfile&quot;</span>), inform DBI::DBD::SqlEngine
    by doing</p>
<p class="Pp"></p>
<pre>
    my %reset_on_modify = (
                            foo_xyz =&gt; &quot;foo_bar&quot;,
                            foo_abc =&gt; &quot;foo_bar&quot;,
                          );
    __PACKAGE__-&gt;register_reset_on_modify( \%reset_on_modify );
</pre>
<p class="Pp">The next access to the table meta data will force
    DBI::DBD::SqlEngine to re-do the entire meta initialization process.</p>
<p class="Pp">Any further action which needs to be taken can handled in
    <span class="Li">&quot;table_meta_attr_changed&quot;</span>:</p>
<p class="Pp"></p>
<pre>
    sub table_meta_attr_changed
    {
        my ($class, $meta, $attrib, $value) = @_;
        ...
        $class-&gt;SUPER::table_meta_attr_changed ($meta, $attrib, $value);
    }
</pre>
<p class="Pp">This is done before the new value is set in
    <span class="Li">$meta</span>, so the attribute changed handler can act
    depending on the old value.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Dealing_with_Tables"><a class="permalink" href="#Dealing_with_Tables">Dealing
  with Tables</a></h2>
<p class="Pp">Let's put some life into it - it's going to be time for it.</p>
<p class="Pp">This is a good point where a quick side step to
    SQL::Statement::Embed will help to shorten the next paragraph. The
    documentation in SQL::Statement::Embed regarding embedding in own DBD's
    works pretty fine with SQL::Statement and DBI::SQL::Nano.</p>
<p class="Pp">Second look should go to DBI::DBD::SqlEngine::Developers to get a
    picture over the driver part of the table API. Usually there isn't much to
    do for an easy driver.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Testing"><a class="permalink" href="#Testing">Testing</a></h2>
<p class="Pp">Now you should have your first own DBD. Was easy, wasn't it? But
    does it work well? Prove it by writing tests and remember to use
    dbd_edit_mm_attribs from DBI::DBD to ensure testing even rare cases.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">This guide is written by Jens Rehsack. DBI::DBD::SqlEngine is
    written by Jens Rehsack using code from DBD::File originally written by
    Jochen Wiedmann and Jeff Zucker.</p>
<p class="Pp">The module DBI::DBD::SqlEngine is currently maintained by</p>
<p class="Pp">H.Merijn Brand &lt; h.m.brand at xs4all.nl &gt; and Jens Rehsack
    &lt; rehsack at googlemail.com &gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">Copyright (C) 2010 by H.Merijn Brand &amp; Jens Rehsack</p>
<p class="Pp">All rights reserved.</p>
<p class="Pp">You may freely distribute and/or modify this module under the
    terms of either the GNU General Public License (GPL) or the Artistic
    License, as specified in the Perl README file.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2016-04-21</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

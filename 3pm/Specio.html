<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Specio(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Specio(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Specio(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Specio - Type constraints and coercions for Perl</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 0.46</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
    package MyApp::Type::Library;

    use Specio::Declare;
    use Specio::Library::Builtins;

    declare(
        'PositiveInt',
        parent =&gt; t('Int'),
        inline =&gt; sub {
            $_[0]-&gt;parent-&gt;inline_check( $_[1] )
                . ' &amp;&amp; ( '
                . $_[1]
                . ' &gt; 0 )';
        },
    );

    # or ...

    declare(
        'PositiveInt',
        parent =&gt; t('Int'),
        where  =&gt; sub { $_[0] &gt; 0 },
    );

    declare(
        'ArrayRefOfPositiveInt',
        parent =&gt; t(
            'ArrayRef',
            of =&gt; t('PositiveInt'),
        ),
    );

    coerce(
        'ArrayRefOfPositiveInt',
        from  =&gt; t('PositiveInt'),
        using =&gt; sub { [ $_[0] ] },
    );

    any_can_type(
        'Duck',
        methods =&gt; [ 'duck_walk', 'quack' ],
    );

    object_isa_type('MyApp::Person');
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The <span class="Li">&quot;Specio&quot;</span> distribution
    provides classes for representing type constraints and coercion, along with
    syntax sugar for declaring them.</p>
<p class="Pp">Note that this is not a proper type system for Perl. Nothing in
    this distribution will magically make the Perl interpreter start checking a
    value's type on assignment to a variable. In fact, there's no built-in way
    to apply a type to a variable at all.</p>
<p class="Pp">Instead, you can explicitly check a value against a type, and
    optionally coerce values to that type.</p>
<p class="Pp">My long-term goal is to replace Moose's built-in types and
    MooseX::Types with this module.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="WHAT_IS_A_TYPE?"><a class="permalink" href="#WHAT_IS_A_TYPE?">WHAT
  IS A TYPE?</a></h1>
<p class="Pp">At it's core, a type is simply a constraint. A constraint is code
    that checks a value and returns true or false. Most constraints are
    represented by Specio::Constraint::Simple objects. However, there are other
    type constraint classes for specialized kinds of constraints.</p>
<p class="Pp">Types can be named or anonymous, and each type can have a parent
    type. A type's constraint is optional because sometimes you may want to
    create a named subtype of some existing type without adding additional
    constraints.</p>
<p class="Pp">Constraints can be expressed either in terms of a simple
    subroutine reference or in terms of an inline generator subroutine
    reference. The former is easier to write but the latter is preferred because
    it allow for better optimization.</p>
<p class="Pp">A type can also have an optional message generator subroutine
    reference. You can use this to provide a more intelligent error message when
    a value does not pass the constraint, though the default message should
    suffice for most cases.</p>
<p class="Pp">Finally, you can associate a set of coercions with a type. A
    coercion is a subroutine reference (or inline generator, like constraints),
    that takes a value of one type and turns it into a value that matches the
    type the coercion belongs to.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUILTIN_TYPES"><a class="permalink" href="#BUILTIN_TYPES">BUILTIN
  TYPES</a></h1>
<p class="Pp">This distribution ships with a set of builtin types representing
    the types provided by the Perl interpreter itself. They are arranged in a
    hierarchy as follows:</p>
<p class="Pp"></p>
<pre>
  Item
      Bool
      Maybe (of `a)
      Undef
      Defined
          Value
              Str
                  Num
                      Int
                  ClassName
          Ref
              ScalarRef (of `a)
              ArrayRef (of `a)
              HashRef (of `a)
              CodeRef
              RegexpRef
              GlobRef
              FileHandle
              Object
</pre>
<p class="Pp">The <span class="Li">&quot;Item&quot;</span> type accepts anything
    and everything.</p>
<p class="Pp">The <span class="Li">&quot;Bool&quot;</span> type only accepts
    <span class="Li">&quot;undef&quot;</span>, <span class="Li">0</span>, or
    <span class="Li">1</span>.</p>
<p class="Pp">The <span class="Li">&quot;Undef&quot;</span> type only accepts
    <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp">The <span class="Li">&quot;Defined&quot;</span> type accepts
    anything <i>except</i> <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp">The <span class="Li">&quot;Num&quot;</span> and
    <span class="Li">&quot;Int&quot;</span> types are stricter about numbers
    than Perl is. Specifically, they do not allow any sort of space in the
    number, nor do they accept &quot;Nan&quot;, &quot;Inf&quot;, or
    &quot;Infinity&quot;.</p>
<p class="Pp">The <span class="Li">&quot;ClassName&quot;</span> type constraint
    checks that the name is valid <i>and</i> that the class is loaded.</p>
<p class="Pp">The <span class="Li">&quot;FileHandle&quot;</span> type accepts
    either a glob, a scalar filehandle, or anything that isa IO::Handle.</p>
<p class="Pp">All types accept overloaded objects that support the required
    operation. See below for details.</p>
<section class="Ss">
<h2 class="Ss" id="Overloading"><a class="permalink" href="#Overloading">Overloading</a></h2>
<p class="Pp">Perl's overloading is horribly broken and doesn't make much sense
    at all.</p>
<p class="Pp">However, unlike Moose, all type constraints allow overloaded
    objects where they make sense.</p>
<p class="Pp">For types where overloading makes sense, we explicitly check that
    the object provides the type overloading we expect. We <i>do not</i> simply
    try to use the object as the type in question and hope it works. This means
    that these checks effectively ignore the
    <span class="Li">&quot;fallback&quot;</span> setting for the overloaded
    object. In other words, an object that overloads stringification will not
    pass the <span class="Li">&quot;Bool&quot;</span> type check unless it
    <i>also</i> overloads boolification.</p>
<p class="Pp">Most types do not check that the overloaded method actually
    returns something that matches the constraint. This may change in the
    future.</p>
<p class="Pp">The <span class="Li">&quot;Bool&quot;</span> type accepts an
    object that implements <span class="Li">&quot;bool&quot;</span>
  overloading.</p>
<p class="Pp">The <span class="Li">&quot;Str&quot;</span> type accepts an object
    that implements string (<span class="Li">&quot;q{&quot;&quot;}&quot;</span>)
    overloading.</p>
<p class="Pp">The <span class="Li">&quot;Num&quot;</span> type accepts an object
    that implements numeric (<span class="Li">&quot;'0+'}&quot;</span>)
    overloading. The <span class="Li">&quot;Int&quot;</span> type does as well,
    but it will check that the overloading returns an actual integer.</p>
<p class="Pp">The <span class="Li">&quot;ClassName&quot;</span> type will accept
    an object with string overloading that returns a class name.</p>
<p class="Pp">To make this all more confusing, the
    <span class="Li">&quot;Value&quot;</span> type will <i>never</i> accept an
    object, even though some of its subtypes will.</p>
<p class="Pp">The various reference types all accept objects which provide the
    appropriate overloading. The <span class="Li">&quot;FileHandle&quot;</span>
    type accepts an object which overloads globification as long as the returned
    glob is an open filehandle.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="PARAMETERIZABLE_TYPES"><a class="permalink" href="#PARAMETERIZABLE_TYPES">PARAMETERIZABLE
  TYPES</a></h1>
<p class="Pp">Any type followed by a type parameter <span class="Li">&quot;of
    `a&quot;</span> in the hierarchy above can be parameterized. The parameter
    is itself a type, so you can say you want an &quot;ArrayRef of Int&quot;, or
    even an &quot;ArrayRef of HashRef of ScalarRef of ClassName&quot;.</p>
<p class="Pp">When they are parameterized, the
    <span class="Li">&quot;ScalarRef&quot;</span> and
    <span class="Li">&quot;ArrayRef&quot;</span> types check that the value(s)
    they refer to match the type parameter. For the
    <span class="Li">&quot;HashRef&quot;</span> type, the parameter applies to
    the values (keys are never checked).</p>
<section class="Ss">
<h2 class="Ss" id="Maybe"><a class="permalink" href="#Maybe">Maybe</a></h2>
<p class="Pp">The <span class="Li">&quot;Maybe&quot;</span> type is a special
    parameterized type. It allows for either
    <span class="Li">&quot;undef&quot;</span> or a value. All by itself, it is
    meaningless, since it is equivalent to &quot;Maybe of Item&quot;, which is
    equivalent to Item. When parameterized, it accepts either an
    <span class="Li">&quot;undef&quot;</span> or the type of its parameter.</p>
<p class="Pp">This is useful for optional attributes or parameters. However,
    you're probably better off making your code simply not pass the parameter at
    all This usually makes for a simpler API.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="REGISTRIES_AND_IMPORTING"><a class="permalink" href="#REGISTRIES_AND_IMPORTING">REGISTRIES
  AND IMPORTING</a></h1>
<p class="Pp">Types are local to each package where they are used. When you
    &quot;import&quot; types from some other library, you are actually making a
    copy of that type.</p>
<p class="Pp">This means that a type named &quot;Foo&quot; in one package may
    not be the same as &quot;Foo&quot; in another package. This has potential
    for confusion, but it also avoids the magic action at a distance pollution
    that comes with a global type naming system.</p>
<p class="Pp">The registry is managed internally by the Specio distribution's
    modules, and is not exposed to your code. To access a type, you always call
    <span class="Li">&quot;t('TypeName')&quot;</span>.</p>
<p class="Pp">This returns the named type or dies if no such type exists.</p>
<p class="Pp">Because types are always copied on import, it's safe to create
    coercions on any type. Your coercion from
    <span class="Li">&quot;Str&quot;</span> to
    <span class="Li">&quot;Int&quot;</span> will not be seen by any other
    package, unless that package explicitly imports your
    <span class="Li">&quot;Int&quot;</span> type.</p>
<p class="Pp">When you import types, you import every type defined in the
    package you import from. However, you <i>can</i> overwrite an imported type
    with your own type definition. You <i>cannot</i> define the same type twice
    internally.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CREATING_A_TYPE_LIBRARY"><a class="permalink" href="#CREATING_A_TYPE_LIBRARY">CREATING
  A TYPE LIBRARY</a></h1>
<p class="Pp">By default, all types created inside a package are invisible to
    other packages. If you want to create a type library, you need to inherit
    from Specio::Exporter package:</p>
<p class="Pp"></p>
<pre>
  package MyApp::Type::Library;

  use parent 'Specio::Exporter';

  use Specio::Declare;
  use Specio::Library::Builtins;

  declare(
      'Foo',
      parent =&gt; t('Str'),
      where  =&gt; sub { $_[0] =~ /foo/i },
  );
</pre>
<p class="Pp">Now the MyApp::Type::Library package will export a single type
    named <span class="Li">&quot;Foo&quot;</span>. It <i>does not</i> re-export
    the types provided by Specio::Library::Builtins.</p>
<p class="Pp">If you want to make your library re-export some other libraries
    types, you can ask for this explicitly:</p>
<p class="Pp"></p>
<pre>
  package MyApp::Type::Library;

  use parent 'Specio::Exporter';

  use Specio::Declare;
  use Specio::Library::Builtins -reexport;

  declare( 'Foo, ... );
</pre>
<p class="Pp">Now MyApp::Types::Library exports any types it defines, as well as
    all the types defined in Specio::Library::Builtins.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DECLARING_TYPES"><a class="permalink" href="#DECLARING_TYPES">DECLARING
  TYPES</a></h1>
<p class="Pp">Use the Specio::Declare module to declare types. It exports a set
    of helpers for declaring types. See that module's documentation for more
    details on these helpers.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="USING_SPECIO_WITH_Moose"><a class="permalink" href="#USING_SPECIO_WITH_Moose">USING
  SPECIO WITH Moose</a></h1>
<p class="Pp">This should just work. Use a Specio type anywhere you'd specify a
    type.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="USING_SPECIO_WITH_Moo"><a class="permalink" href="#USING_SPECIO_WITH_Moo">USING
  SPECIO WITH Moo</a></h1>
<p class="Pp">Using Specio with Moo is easy. You can pass Specio constraint
    objects as <span class="Li">&quot;isa&quot;</span> parameters for
    attributes. For coercions, simply call
    <span class="Li">&quot;$type-&gt;coercion_sub&quot;</span>.</p>
<p class="Pp"></p>
<pre>
    package Foo;

    use Specio::Declare;
    use Specio::Library::Builtins;
    use Moo;

    my $str_type = t('Str');
    has string =&gt; (
       is  =&gt; 'ro',
       isa =&gt; $str_type,
    );

    my $ucstr = declare(
        'UCStr',
        parent =&gt; t('Str'),
        where  =&gt; sub { $_[0] =~ /^[A-Z]+$/ },
    );

    coerce(
        $ucstr,
        from  =&gt; t('Str'),
        using =&gt; sub { return uc $_[0] },
    );

    has ucstr =&gt; (
        is     =&gt; 'ro',
        isa    =&gt; $ucstr,
        coerce =&gt; $ucstr-&gt;coercion_sub,
    );
</pre>
<p class="Pp">The subs returned by Specio use Sub::Quote internally and are
    suitable for inlining.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="USING_SPECIO_WITH_OTHER_THINGS"><a class="permalink" href="#USING_SPECIO_WITH_OTHER_THINGS">USING
  SPECIO WITH OTHER THINGS</a></h1>
<p class="Pp">See Specio::Constraint::Simple for the API that all constraint
    objects share.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Moose,_MooseX::Types,_and_Specio"><a class="permalink" href="#Moose,_MooseX::Types,_and_Specio">Moose,
  MooseX::Types, and Specio</a></h1>
<p class="Pp">This module aims to supplant both Moose's built-in type system
    (see Moose::Util::TypeConstraints aka MUTC) and MooseX::Types, which
    attempts to patch some of the holes in the Moose built-in type design.</p>
<p class="Pp">Here are some of the salient differences:</p>
<ul class="Bl-bullet">
  <li>Types names are strings, but they're not global
    <p class="Pp">Unlike Moose and MooseX::Types, type names are always local to
        the current package. There is no possibility of name collision between
        different modules, so you can safely use short type names.</p>
    <p class="Pp">Unlike MooseX::Types, types are strings, so there is no
        possibility of colliding with existing class or subroutine names.</p>
  </li>
  <li>No type auto-creation
    <p class="Pp">Types are always retrieved using the
        <span class="Li">&quot;t()&quot;</span> subroutine. If you pass an
        unknown name to this subroutine it dies. This is different from Moose
        and MooseX::Types, which assume that unknown names are class names.</p>
  </li>
  <li>Anon types are explicit
    <p class="Pp">With Moose and MooseX::Types, you use the same subroutine,
        <span class="Li">&quot;subtype()&quot;</span>, to declare both named and
        anonymous types. With Specio, you use
        <span class="Li">&quot;declare()&quot;</span> for named types and
        <span class="Li">&quot;anon()&quot;</span> for anonymous types.</p>
  </li>
  <li>Class and object types are separate
    <p class="Pp">Moose and MooseX::Types have
        <span class="Li">&quot;class_type&quot;</span> and
        <span class="Li">&quot;duck_type&quot;</span>. The former type requires
        an object, while the latter accepts a class name or object.</p>
    <p class="Pp">With Specio, the distinction between accepting an object
        versus object or class is explicit. There are six declaration helpers,
        <span class="Li">&quot;object_can_type&quot;</span>,
        <span class="Li">&quot;object_does_type&quot;</span>,
        <span class="Li">&quot;object_isa_type&quot;</span>,
        <span class="Li">&quot;any_can_type&quot;</span>,
        <span class="Li">&quot;any_does_type&quot;</span>, and
        <span class="Li">&quot;any_isa_type&quot;</span>.</p>
  </li>
  <li>Overloading support is baked in
    <p class="Pp">Perl's overloading is quite broken but ignoring it makes
        Moose's type system frustrating to use in many cases.</p>
  </li>
  <li>Types can either have a constraint or inline generator, not both
    <p class="Pp">Moose and MooseX::Types types can be defined with a subroutine
        reference as the constraint, an inline generator subroutine, or both.
        This is purely for backwards compatibility, and it makes the internals
        more complicated than they need to be.</p>
    <p class="Pp">With Specio, a constraint can have <i>either</i> a subroutine
        reference or an inline generator, not both.</p>
  </li>
  <li>Coercions can be inlined
    <p class="Pp">I simply never got around to implementing this in Moose.</p>
  </li>
  <li>No crazy coercion features
    <p class="Pp">Moose has some bizarre (and mostly) undocumented features
        relating to coercions and parameterizable types. This is a
      misfeature.</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="OPTIONAL_PREREQS"><a class="permalink" href="#OPTIONAL_PREREQS">OPTIONAL
  PREREQS</a></h1>
<p class="Pp">There are several optional prereqs that if installed will make
    this distribution better in some way.</p>
<ul class="Bl-bullet">
  <li>Ref::Util
    <p class="Pp">Installing this will speed up a number of type checks for
        built-in types.</p>
  </li>
  <li>XString
    <p class="Pp">If this is installed it will be loaded instead of the B module
        if you have Perl 5.10 or greater. This module is much more memory
        efficient than loading all of B.</p>
  </li>
  <li>Sub::Util or Sub::Name
    <p class="Pp">If one of these is installed then stack traces that end up in
        Specio code will have much better subroutine names for any frames.</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="WHY_THE_NAME?"><a class="permalink" href="#WHY_THE_NAME?">WHY
  THE NAME?</a></h1>
<p class="Pp">This distro was originally called &quot;Type&quot;, but that's an
    awfully generic top level namespace. Specio is Latin for for &quot;look
    at&quot; and &quot;spec&quot; is the root for the word &quot;species&quot;.
    It's short, relatively easy to type, and not used by any other distro.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LONG-TERM_PLANS"><a class="permalink" href="#LONG-TERM_PLANS">LONG-TERM
  PLANS</a></h1>
<p class="Pp">Eventually I'd like to see this distro replace Moose's internal
    type system, which would also make MooseX::Types obsolete.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
<p class="Pp">Bugs may be submitted at
    &lt;https://github.com/houseabsolute/Specio/issues&gt;.</p>
<p class="Pp">I am also usually active on IRC as 'autarch' on
    <span class="Li">&quot;irc://irc.perl.org&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SOURCE"><a class="permalink" href="#SOURCE">SOURCE</a></h1>
<p class="Pp">The source code repository for Specio can be found at
    &lt;https://github.com/houseabsolute/Specio&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DONATIONS"><a class="permalink" href="#DONATIONS">DONATIONS</a></h1>
<p class="Pp">If you'd like to thank me for the work I've done on this module,
    please consider making a &quot;donation&quot; to me via PayPal. I spend a
    lot of free time creating free software, and would appreciate any support
    you'd care to offer.</p>
<p class="Pp">Please note that <b>I am not suggesting that you must do this</b>
    in order for me to continue working on this particular software. I will
    continue to do so, inasmuch as I have in the past, for as long as it
    interests me.</p>
<p class="Pp">Similarly, a donation made in this way will probably not make me
    work on this software much more, unless I get so many donations that I can
    consider working on free software full time (let's all have a chuckle at
    that together).</p>
<p class="Pp">To donate, log into PayPal and send money to autarch@urth.org, or
    use the button at &lt;https://www.urth.org/fs-donation.html&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Dave Rolsky &lt;autarch@urth.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<ul class="Bl-bullet">
  <li>Chris White &lt;chrisw@leehayes.com&gt;</li>
  <li>cpansprout &lt;cpansprout@gmail.com&gt;</li>
  <li>Graham Knop &lt;haarg@haarg.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is Copyright (c) 2012 - 2020 by Dave Rolsky.</p>
<p class="Pp">This is free software, licensed under:</p>
<p class="Pp"></p>
<pre>
  The Artistic License 2.0 (GPL Compatible)
</pre>
<p class="Pp">The full text of the license can be found in the <i>LICENSE</i>
    file included with this distribution.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-03-14</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

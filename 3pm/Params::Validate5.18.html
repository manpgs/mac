<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Params::Validate(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Params::Validate(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Params::Validate(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Params::Validate - Validate method/function parameters</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 1.08</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
    use Params::Validate qw(:all);

    # takes named params (hash or hashref)
    sub foo {
        validate(
            @_, {
                foo =&gt; 1,    # mandatory
                bar =&gt; 0,    # optional
            }
        );
    }

    # takes positional params
    sub bar {
        # first two are mandatory, third is optional
        validate_pos( @_, 1, 1, 0 );
    }

    sub foo2 {
        validate(
            @_, {
                foo =&gt;
                    # specify a type
                    { type =&gt; ARRAYREF },
                bar =&gt;
                    # specify an interface
                    { can =&gt; [ 'print', 'flush', 'frobnicate' ] },
                baz =&gt; {
                    type      =&gt; SCALAR,     # a scalar ...
                                             # ... that is a plain integer ...
                    regex     =&gt; qr/^\d+$/,
                    callbacks =&gt; {           # ... and smaller than 90
                        'less than 90' =&gt; sub { shift() &lt; 90 },
                    },
                }
            }
        );
    }

    sub with_defaults {
        my %p = validate(
            @_, {
                # required
                foo =&gt; 1,
                # $p{bar} will be 99 if bar is not given.  bar is now
                # optional.
                bar =&gt; { default =&gt; 99 }
            }
        );
    }

    sub pos_with_defaults {
        my @p = validate_pos( @_, 1, { default =&gt; 99 } );
    }

    sub sets_options_on_call {
        my %p = validate_with(
            params =&gt; \@_,
            spec   =&gt; { foo =&gt; { type =&gt; SCALAR, default =&gt; 2 } },
            normalize_keys =&gt; sub { $_[0] =~ s/^-//; lc $_[0] },
        );
    }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The Params::Validate module allows you to validate method or
    function call parameters to an arbitrary level of specificity. At the
    simplest level, it is capable of validating the required parameters were
    given and that no unspecified additional parameters were passed in.</p>
<p class="Pp">It is also capable of determining that a parameter is of a
    specific type, that it is an object of a certain class hierarchy, that it
    possesses certain methods, or applying validation callbacks to
  arguments.</p>
<section class="Ss">
<h2 class="Ss">EXPORT</h2>
<p class="Pp">The module always exports the
    <span class="Li">&quot;validate()&quot;</span> and
    <span class="Li">&quot;validate_pos()&quot;</span> functions.</p>
<p class="Pp">It also has an additional function available for export,
    <span class="Li">&quot;validate_with&quot;</span>, which can be used to
    validate any type of parameters, and set various options on a per-invocation
    basis.</p>
<p class="Pp">In addition, it can export the following constants, which are used
    as part of the type checking. These are
    <span class="Li">&quot;SCALAR&quot;</span>,
    <span class="Li">&quot;ARRAYREF&quot;</span>,
    <span class="Li">&quot;HASHREF&quot;</span>,
    <span class="Li">&quot;CODEREF&quot;</span>,
    <span class="Li">&quot;GLOB&quot;</span>,
    <span class="Li">&quot;GLOBREF&quot;</span>, and
    <span class="Li">&quot;SCALARREF&quot;</span>,
    <span class="Li">&quot;UNDEF&quot;</span>,
    <span class="Li">&quot;OBJECT&quot;</span>,
    <span class="Li">&quot;BOOLEAN&quot;</span>, and
    <span class="Li">&quot;HANDLE&quot;</span>. These are explained in the
    section on Type Validation.</p>
<p class="Pp">The constants are available via the export tag
    <span class="Li">&quot;:types&quot;</span>. There is also an
    <span class="Li">&quot;:all&quot;</span> tag which includes all of the
    constants as well as the
    <span class="Li">&quot;validation_options()&quot;</span> function.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="PARAMETER_VALIDATION"><a class="permalink" href="#PARAMETER_VALIDATION">PARAMETER
  VALIDATION</a></h1>
<p class="Pp">The validation mechanisms provided by this module can handle both
    named or positional parameters. For the most part, the same features are
    available for each. The biggest difference is the way that the validation
    specification is given to the relevant subroutine. The other difference is
    in the error messages produced when validation checks fail.</p>
<p class="Pp">When handling named parameters, the module will accept either a
    hash or a hash reference.</p>
<p class="Pp">Subroutines expecting named parameters should call the
    <span class="Li">&quot;validate()&quot;</span> subroutine like this:</p>
<p class="Pp"></p>
<pre>
    validate(
        @_, {
            parameter1 =&gt; validation spec,
            parameter2 =&gt; validation spec,
            ...
        }
    );
</pre>
<p class="Pp">Subroutines expecting positional parameters should call the
    <span class="Li">&quot;validate_pos()&quot;</span> subroutine like this:</p>
<p class="Pp"></p>
<pre>
    validate_pos( @_, { validation spec }, { validation spec } );
</pre>
<section class="Ss">
<h2 class="Ss" id="Mandatory/Optional_Parameters"><a class="permalink" href="#Mandatory/Optional_Parameters">Mandatory/Optional
  Parameters</a></h2>
<p class="Pp">If you just want to specify that some parameters are mandatory and
    others are optional, this can be done very simply.</p>
<p class="Pp">For a subroutine expecting named parameters, you would do
  this:</p>
<p class="Pp"></p>
<pre>
    validate( @_, { foo =&gt; 1, bar =&gt; 1, baz =&gt; 0 } );
</pre>
<p class="Pp">This says that the &quot;foo&quot; and &quot;bar&quot; parameters
    are mandatory and that the &quot;baz&quot; parameter is optional. The
    presence of any other parameters will cause an error.</p>
<p class="Pp">For a subroutine expecting positional parameters, you would do
    this:</p>
<p class="Pp"></p>
<pre>
    validate_pos( @_, 1, 1, 0, 0 );
</pre>
<p class="Pp">This says that you expect at least 2 and no more than 4
    parameters. If you have a subroutine that has a minimum number of parameters
    but can take any maximum number, you can do this:</p>
<p class="Pp"></p>
<pre>
    validate_pos( @_, 1, 1, (0) x (@_ - 2) );
</pre>
<p class="Pp">This will always be valid as long as at least two parameters are
    given. A similar construct could be used for the more complex validation
    parameters described further on.</p>
<p class="Pp">Please note that this:</p>
<p class="Pp"></p>
<pre>
    validate_pos( @_, 1, 1, 0, 1, 1 );
</pre>
<p class="Pp">makes absolutely no sense, so don't do it. Any zeros must come at
    the end of the validation specification.</p>
<p class="Pp">In addition, if you specify that a parameter can have a default,
    then it is considered optional.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Type_Validation"><a class="permalink" href="#Type_Validation">Type
  Validation</a></h2>
<p class="Pp">This module supports the following simple types, which can be
    exported as constants:</p>
<ul class="Bl-bullet">
  <li>SCALAR
    <p class="Pp">A scalar which is not a reference, such as
        <span class="Li">10</span> or <span class="Li">'hello'</span>. A
        parameter that is undefined is <b>not</b> treated as a scalar. If you
        want to allow undefined values, you will have to specify
        <span class="Li">&quot;SCALAR |</span>
        <span class="Li">UNDEF&quot;</span>.</p>
  </li>
  <li>ARRAYREF
    <p class="Pp">An array reference such as <span class="Li">&quot;[1, 2,
        3]&quot;</span> or <span class="Li">&quot;\@foo&quot;</span>.</p>
  </li>
  <li>HASHREF
    <p class="Pp">A hash reference such as <span class="Li">&quot;{ a =&gt; 1, b
        =&gt; 2 }&quot;</span> or <span class="Li">&quot;\%bar&quot;</span>.</p>
  </li>
  <li>CODEREF
    <p class="Pp">A subroutine reference such as
        <span class="Li">&quot;\&amp;foo_sub&quot;</span> or
        <span class="Li">&quot;sub { print &quot;hello&quot; }&quot;</span>.</p>
  </li>
  <li>GLOB
    <p class="Pp">This one is a bit tricky. A glob would be something like
        <span class="Li">*FOO</span>, but not
        <span class="Li">&quot;\*FOO&quot;</span>, which is a glob reference. It
        should be noted that this trick:</p>
    <p class="Pp"></p>
    <pre>
    my $fh = do { local *FH; };
    </pre>
    <p class="Pp">makes <span class="Li">$fh</span> a glob, not a glob
        reference. On the other hand, the return value from
        <span class="Li">&quot;Symbol::gensym&quot;</span> is a glob reference.
        Either can be used as a file or directory handle.</p>
  </li>
  <li>GLOBREF
    <p class="Pp">A glob reference such as
        <span class="Li">&quot;\*FOO&quot;</span>. See the GLOB entry above for
        more details.</p>
  </li>
  <li>SCALARREF
    <p class="Pp">A reference to a scalar such as
        <span class="Li">&quot;\$x&quot;</span>.</p>
  </li>
  <li>UNDEF
    <p class="Pp">An undefined value</p>
  </li>
  <li>OBJECT
    <p class="Pp">A blessed reference.</p>
  </li>
  <li>BOOLEAN
    <p class="Pp">This is a special option, and is just a shortcut for
        <span class="Li">&quot;UNDEF | SCALAR&quot;</span>.</p>
  </li>
  <li>HANDLE
    <p class="Pp">This option is also special, and is just a shortcut for
        <span class="Li">&quot;GLOB |</span>
        <span class="Li">GLOBREF&quot;</span>. However, it seems likely that
        most people interested in either globs or glob references are likely to
        really be interested in whether the parameter in question could be a
        valid file or directory handle.</p>
  </li>
</ul>
<p class="Pp">To specify that a parameter must be of a given type when using
    named parameters, do this:</p>
<p class="Pp"></p>
<pre>
    validate(
        @_, {
            foo =&gt; { type =&gt; SCALAR },
            bar =&gt; { type =&gt; HASHREF }
        }
    );
</pre>
<p class="Pp">If a parameter can be of more than one type, just use the bitwise
    or (<span class="Li">&quot;|&quot;</span>) operator to combine them.</p>
<p class="Pp"></p>
<pre>
    validate( @_, { foo =&gt; { type =&gt; GLOB | GLOBREF } );
</pre>
<p class="Pp">For positional parameters, this can be specified as follows:</p>
<p class="Pp"></p>
<pre>
    validate_pos( @_, { type =&gt; SCALAR | ARRAYREF }, { type =&gt; CODEREF } );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Interface_Validation"><a class="permalink" href="#Interface_Validation">Interface
  Validation</a></h2>
<p class="Pp">To specify that a parameter is expected to have a certain set of
    methods, we can do the following:</p>
<p class="Pp"></p>
<pre>
    validate(
        @_, {
            foo =&gt;
                # just has to be able to -&gt;bar
                { can =&gt; 'bar' }
        }
    );

 ... or ...

    validate(
        @_, {
            foo =&gt;
                # must be able to -&gt;bar and -&gt;print
                { can =&gt; [qw( bar print )] }
        }
    );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Class_Validation"><a class="permalink" href="#Class_Validation">Class
  Validation</a></h2>
<p class="Pp">A word of warning. When constructing your external interfaces, it
    is probably better to specify what methods you expect an object to have
    rather than what class it should be of (or a child of). This will make your
    API much more flexible.</p>
<p class="Pp">With that said, if you want to validate that an incoming parameter
    belongs to a class (or child class) or classes, do:</p>
<p class="Pp"></p>
<pre>
    validate(
        @_,
        { foo =&gt; { isa =&gt; 'My::Frobnicator' } }
    );

 ... or ...

    validate(
        @_,
        # must be both, not either!
        { foo =&gt; { isa =&gt; [qw( My::Frobnicator IO::Handle )] } }
    );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Regex_Validation"><a class="permalink" href="#Regex_Validation">Regex
  Validation</a></h2>
<p class="Pp">If you want to specify that a given parameter must match a
    specific regular expression, this can be done with &quot;regex&quot; spec
    key. For example:</p>
<p class="Pp"></p>
<pre>
    validate(
        @_,
        { foo =&gt; { regex =&gt; qr/^\d+$/ } }
    );
</pre>
<p class="Pp">The value of the &quot;regex&quot; key may be either a string or a
    pre-compiled regex created via <span class="Li">&quot;qr&quot;</span>.</p>
<p class="Pp">If the value being checked against a regex is undefined, the regex
    is explicitly checked against the empty string ('') instead, in order to
    avoid &quot;Use of uninitialized value&quot; warnings.</p>
<p class="Pp">The <span class="Li">&quot;Regexp::Common&quot;</span> module on
    CPAN is an excellent source of regular expressions suitable for validating
    input.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Callback_Validation"><a class="permalink" href="#Callback_Validation">Callback
  Validation</a></h2>
<p class="Pp">If none of the above are enough, it is possible to pass in one or
    more callbacks to validate the parameter. The callback will be given the
    <b>value</b> of the parameter as its first argument. Its second argument
    will be all the parameters, as a reference to either a hash or array.
    Callbacks are specified as hash reference. The key is an id for the callback
    (used in error messages) and the value is a subroutine reference, such
  as:</p>
<p class="Pp"></p>
<pre>
    validate(
        @_, {
            foo =&gt; {
                callbacks =&gt; {
                    'smaller than a breadbox' =&gt; sub { shift() &lt; $breadbox },
                    'green or blue' =&gt;
                        sub { $_[0] eq 'green' || $_[0] eq 'blue' }
                }
            }
        );

    validate(
        @_, {
            foo =&gt; {
                callbacks =&gt; {
                    'bigger than baz' =&gt; sub { $_[0] &gt; $_[1]-&gt;{baz} }
                }
            }
        }
    );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Untainting"><a class="permalink" href="#Untainting">Untainting</a></h2>
<p class="Pp">If you want values untainted, set the &quot;untaint&quot; key in a
    spec hashref to a true value, like this:</p>
<p class="Pp"></p>
<pre>
    my %p = validate(
        @_, {
            foo =&gt; { type =&gt; SCALAR, untaint =&gt; 1 },
            bar =&gt; { type =&gt; ARRAYREF }
        }
    );
</pre>
<p class="Pp">This will untaint the &quot;foo&quot; parameter if the parameters
    are valid.</p>
<p class="Pp">Note that untainting is only done if <i>all parameters</i> are
    valid. Also, only the return values are untainted, not the original values
    passed into the validation function.</p>
<p class="Pp">Asking for untainting of a reference value will not do anything,
    as <span class="Li">&quot;Params::Validate&quot;</span> will only attempt to
    untaint the reference itself.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Mandatory/Optional_Revisited"><a class="permalink" href="#Mandatory/Optional_Revisited">Mandatory/Optional
  Revisited</a></h2>
<p class="Pp">If you want to specify something such as type or interface, plus
    the fact that a parameter can be optional, do this:</p>
<p class="Pp"></p>
<pre>
    validate(
        @_, {
            foo =&gt; { type =&gt; SCALAR },
            bar =&gt; { type =&gt; ARRAYREF, optional =&gt; 1 }
        }
    );
</pre>
<p class="Pp">or this for positional parameters:</p>
<p class="Pp"></p>
<pre>
    validate_pos(
        @_,
        { type =&gt; SCALAR },
        { type =&gt; ARRAYREF, optional =&gt; 1 }
    );
</pre>
<p class="Pp">By default, parameters are assumed to be mandatory unless
    specified as optional.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Dependencies"><a class="permalink" href="#Dependencies">Dependencies</a></h2>
<p class="Pp">It also possible to specify that a given optional parameter
    depends on the presence of one or more other optional parameters.</p>
<p class="Pp"></p>
<pre>
    validate(
        @_, {
            cc_number =&gt; {
                type     =&gt; SCALAR,
                optional =&gt; 1,
                depends  =&gt; [ 'cc_expiration', 'cc_holder_name' ],
            },
            cc_expiration  { type =&gt; SCALAR, optional =&gt; 1 },
            cc_holder_name { type =&gt; SCALAR, optional =&gt; 1 },
        }
    );
</pre>
<p class="Pp">In this case, &quot;cc_number&quot;, &quot;cc_expiration&quot;,
    and &quot;cc_holder_name&quot; are all optional. However, if
    &quot;cc_number&quot; is provided, then &quot;cc_expiration&quot; and
    &quot;cc_holder_name&quot; must be provided as well.</p>
<p class="Pp">This allows you to group together sets of parameters that all must
    be provided together.</p>
<p class="Pp">The <span class="Li">&quot;validate_pos()&quot;</span> version of
    dependencies is slightly different, in that you can only depend on one other
    parameter. Also, if for example, the second parameter 2 depends on the
    fourth parameter, then it implies a dependency on the third parameter as
    well. This is because if the fourth parameter is required, then the user
    must also provide a third parameter so that there can be four parameters in
    total.</p>
<p class="Pp"><span class="Li">&quot;Params::Validate&quot;</span> will die if
    you try to depend on a parameter not declared as part of your parameter
    specification.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Specifying_defaults"><a class="permalink" href="#Specifying_defaults">Specifying
  defaults</a></h2>
<p class="Pp">If the <span class="Li">&quot;validate()&quot;</span> or
    <span class="Li">&quot;validate_pos()&quot;</span> functions are called in a
    list context, they will return a hash or containing the original parameters
    plus defaults as indicated by the validation spec.</p>
<p class="Pp">If the function is not called in a list context, providing a
    default in the validation spec still indicates that the parameter is
    optional.</p>
<p class="Pp">The hash or array returned from the function will always be a copy
    of the original parameters, in order to leave <span class="Li">@_</span>
    untouched for the calling function.</p>
<p class="Pp">Simple examples of defaults would be:</p>
<p class="Pp"></p>
<pre>
    my %p = validate( @_, { foo =&gt; 1, bar =&gt; { default =&gt; 99 } } );

    my @p = validate_pos( @_, 1, { default =&gt; 99 } );
</pre>
<p class="Pp">In scalar context, a hash reference or array reference will be
    returned, as appropriate.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="USAGE_NOTES"><a class="permalink" href="#USAGE_NOTES">USAGE
  NOTES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Validation_failure"><a class="permalink" href="#Validation_failure">Validation
  failure</a></h2>
<p class="Pp">By default, when validation fails
    <span class="Li">&quot;Params::Validate&quot;</span> calls
    <span class="Li">&quot;Carp::confess()&quot;</span>. This can be overridden
    by setting the <span class="Li">&quot;on_fail&quot;</span> option, which is
    described in the &quot;GLOBAL&quot; OPTIONS section.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Method_calls"><a class="permalink" href="#Method_calls">Method
  calls</a></h2>
<p class="Pp">When using this module to validate the parameters passed to a
    method call, you will probably want to remove the class/object from the
    parameter list <b>before</b> calling
    <span class="Li">&quot;validate()&quot;</span> or
    <span class="Li">&quot;validate_pos()&quot;</span>. If your method expects
    named parameters, then this is necessary for the
    <span class="Li">&quot;validate()&quot;</span> function to actually work,
    otherwise <span class="Li">@_</span> will not be usable as a hash, because
    it will first have your object (or class) <b>followed</b> by a set of keys
    and values.</p>
<p class="Pp">Thus the idiomatic usage of
    <span class="Li">&quot;validate()&quot;</span> in a method call will look
    something like this:</p>
<p class="Pp"></p>
<pre>
    sub method {
        my $self = shift;

        my %params = validate(
            @_, {
                foo =&gt; 1,
                bar =&gt; { type =&gt; ARRAYREF },
            }
        );
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Speeding_Up_Validation"><a class="permalink" href="#Speeding_Up_Validation">Speeding
  Up Validation</a></h2>
<p class="Pp">In most cases, the validation spec will remain the same for each
    call to a subroutine. In that case, you can speed up validation by defining
    the validation spec just once, rather than on each call to the
  subroutine:</p>
<p class="Pp"></p>
<pre>
    my %spec = ( ... );
    sub foo {
        my %params = validate( @_, \%spec );
    }
</pre>
<p class="Pp">You can also use the <span class="Li">&quot;state&quot;</span>
    feature to do this:</p>
<p class="Pp"></p>
<pre>
    use feature 'state';

    sub foo {
        state $spec = { ... };
        my %params = validate( @_, $spec );
    }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="_GLOBAL__OPTIONS"><a class="permalink" href="#_GLOBAL__OPTIONS">&quot;GLOBAL&quot;
  OPTIONS</a></h1>
<p class="Pp">Because the API for the
    <span class="Li">&quot;validate()&quot;</span> and
    <span class="Li">&quot;validate_pos()&quot;</span> functions does not make
    it possible to specify any options other than the validation spec, it is
    possible to set some options as pseudo-'globals'. These allow you to specify
    such things as whether or not the validation of named parameters should be
    case sensitive, for one example.</p>
<p class="Pp">These options are called pseudo-'globals' because these settings
    are <b>only applied to calls originating from the package that set the</b>
    <b>options</b>.</p>
<p class="Pp">In other words, if I am in package
    <span class="Li">&quot;Foo&quot;</span> and I call
    <span class="Li">&quot;validation_options()&quot;</span>, those options are
    only in effect when I call <span class="Li">&quot;validate()&quot;</span>
    from package <span class="Li">&quot;Foo&quot;</span>.</p>
<p class="Pp">While this is quite different from how most other modules operate,
    I feel that this is necessary in able to make it possible for one
    module/application to use Params::Validate while still using other modules
    that also use Params::Validate, perhaps with different options set.</p>
<p class="Pp">The downside to this is that if you are writing an app with a
    standard calling style for all functions, and your app has ten modules,
    <b>each</b> <b>module must include a call to
    </b><b>&quot;validation_options()&quot;</b><b></b>. You could of course
    write a module that all your modules use which uses various trickery to do
    this when imported.</p>
<section class="Ss">
<h2 class="Ss" id="Options"><a class="permalink" href="#Options">Options</a></h2>
<ul class="Bl-bullet">
  <li>normalize_keys =&gt; <span class="Li">$callback</span>
    <p class="Pp">This option is only relevant when dealing with named
        parameters.</p>
    <p class="Pp">This callback will be used to transform the hash keys of both
        the parameters and the parameter spec when
        <span class="Li">&quot;validate()&quot;</span> or
        <span class="Li">&quot;validate_with()&quot;</span> are called.</p>
    <p class="Pp">Any alterations made by this callback will be reflected in the
        parameter hash that is returned by the validation function. For
      example:</p>
    <p class="Pp"></p>
    <pre>
    sub foo {
        return validate_with(
            params =&gt; \@_,
            spec   =&gt; { foo =&gt; { type =&gt; SCALAR } },
            normalize_keys =&gt;
                sub { my $k = shift; $k =~ s/^-//; return uc $k },
        );

    }

    %p = foo( foo =&gt; 20 );

    # $p{FOO} is now 20

    %p = foo( -fOo =&gt; 50 );

    # $p{FOO} is now 50
    </pre>
    <p class="Pp">The callback must return a defined value.</p>
    <p class="Pp">If a callback is given then the deprecated
        &quot;ignore_case&quot; and &quot;strip_leading&quot; options are
        ignored.</p>
  </li>
  <li>allow_extra =&gt; <span class="Li">$boolean</span>
    <p class="Pp">If true, then the validation routine will allow extra
        parameters not named in the validation specification. In the case of
        positional parameters, this allows an unlimited number of maximum
        parameters (though a minimum may still be set). Defaults to false.</p>
  </li>
  <li>on_fail =&gt; <span class="Li">$callback</span>
    <p class="Pp">If given, this callback will be called whenever a validation
        check fails. It will be called with a single parameter, which will be a
        string describing the failure. This is useful if you wish to have this
        module throw exceptions as objects rather than as strings, for
      example.</p>
    <p class="Pp">This callback is expected to
        <span class="Li">&quot;die()&quot;</span> internally. If it does not,
        the validation will proceed onwards, with unpredictable results.</p>
    <p class="Pp">The default is to simply use the Carp module's
        <span class="Li">&quot;confess()&quot;</span> function.</p>
  </li>
  <li>stack_skip =&gt; <span class="Li">$number</span>
    <p class="Pp">This tells Params::Validate how many stack frames to skip when
        finding a subroutine name to use in error messages. By default, it looks
        one frame back, at the immediate caller to
        <span class="Li">&quot;validate()&quot;</span> or
        <span class="Li">&quot;validate_pos()&quot;</span>. If this option is
        set, then the given number of frames are skipped instead.</p>
  </li>
  <li>ignore_case =&gt; <span class="Li">$boolean</span>
    <p class="Pp">DEPRECATED</p>
    <p class="Pp">This is only relevant when dealing with named parameters. If
        it is true, then the validation code will ignore the case of parameter
        names. Defaults to false.</p>
  </li>
  <li>strip_leading =&gt; <span class="Li">$characters</span>
    <p class="Pp">DEPRECATED</p>
    <p class="Pp">This too is only relevant when dealing with named parameters.
        If this is given then any parameters starting with these characters will
        be considered equivalent to parameters without them entirely. For
        example, if this is specified as '-', then
        <span class="Li">&quot;-foo&quot;</span> and
        <span class="Li">&quot;foo&quot;</span> would be considered
      identical.</p>
  </li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="PER-INVOCATION_OPTIONS"><a class="permalink" href="#PER-INVOCATION_OPTIONS">PER-INVOCATION
  OPTIONS</a></h1>
<p class="Pp">The <span class="Li">&quot;validate_with()&quot;</span> function
    can be used to set the options listed above on a per-invocation basis. For
    example:</p>
<p class="Pp"></p>
<pre>
    my %p = validate_with(
        params =&gt; \@_,
        spec   =&gt; {
            foo =&gt; { type    =&gt; SCALAR },
            bar =&gt; { default =&gt; 10 }
        },
        allow_extra =&gt; 1,
    );
</pre>
<p class="Pp">In addition to the options listed above, it is also possible to
    set the option &quot;called&quot;, which should be a string. This string
    will be used in any error messages caused by a failure to meet the
    validation spec.</p>
<p class="Pp">This subroutine will validate named parameters as a hash if the
    &quot;spec&quot; parameter is a hash reference. If it is an array reference,
    the parameters are assumed to be positional.</p>
<p class="Pp"></p>
<pre>
    my %p = validate_with(
        params =&gt; \@_,
        spec   =&gt; {
            foo =&gt; { type    =&gt; SCALAR },
            bar =&gt; { default =&gt; 10 }
        },
        allow_extra =&gt; 1,
        called      =&gt; 'The Quux::Baz class constructor',
    );

    my @p = validate_with(
        params =&gt; \@_,
        spec   =&gt; [
            { type    =&gt; SCALAR },
            { default =&gt; 10 }
        ],
        allow_extra =&gt; 1,
        called      =&gt; 'The Quux::Baz class constructor',
    );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DISABLING_VALIDATION"><a class="permalink" href="#DISABLING_VALIDATION">DISABLING
  VALIDATION</a></h1>
<p class="Pp">If the environment variable
    <span class="Li">&quot;PERL_NO_VALIDATION&quot;</span> is set to something
    true, then validation is turned off. This may be useful if you only want to
    use this module during development but don't want the speed hit during
    production.</p>
<p class="Pp">The only error that will be caught will be when an odd number of
    parameters are passed into a function/method that expects a hash.</p>
<p class="Pp">If you want to selectively turn validation on and off at runtime,
    you can directly set the
    <span class="Li">$Params::Validate::NO_VALIDATION</span> global variable. It
    is <b>strongly</b> recommended that you <b>localize</b> any changes to this
    variable, because other modules you are using may expect validation to be on
    when they execute. For example:</p>
<p class="Pp"></p>
<pre>
    {
        local $Params::Validate::NO_VALIDATION = 1;

        # no error
        foo( bar =&gt; 2 );
    }

    # error
    foo( bar =&gt; 2 );

    sub foo {
        my %p = validate( @_, { foo =&gt; 1 } );
        ...;
    }
</pre>
<p class="Pp">But if you want to shoot yourself in the foot and just turn it
    off, go ahead!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LIMITATIONS"><a class="permalink" href="#LIMITATIONS">LIMITATIONS</a></h1>
<p class="Pp">Right now there is no way (short of a callback) to specify that
    something must be of one of a list of classes, or that it must possess one
    of a list of methods. If this is desired, it can be added in the future.</p>
<p class="Pp">Ideally, there would be only one validation function. If someone
    figures out how to do this, please let me know.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
<p class="Pp">Please submit bugs and patches to the CPAN RT system at
    http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Params%3A%3AValidate or via
    email at bug-params-validate@rt.cpan.org.</p>
<p class="Pp">Support questions can be sent to Dave at autarch@urth.org.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DONATIONS"><a class="permalink" href="#DONATIONS">DONATIONS</a></h1>
<p class="Pp">If you'd like to thank me for the work I've done on this module,
    please consider making a &quot;donation&quot; to me via PayPal. I spend a
    lot of free time creating free software, and would appreciate any support
    you'd care to offer.</p>
<p class="Pp">Please note that <b>I am not suggesting that you must do this</b>
    in order for me to continue working on this particular software. I will
    continue to do so, inasmuch as I have in the past, for as long as it
    interests me.</p>
<p class="Pp">Similarly, a donation made in this way will probably not make me
    work on this software much more, unless I get so many donations that I can
    consider working on free software full time, which seems unlikely at
  best.</p>
<p class="Pp">To donate, log into PayPal and send money to autarch@urth.org or
    use the button on this page:
    &lt;http://www.urth.org/~autarch/fs-donation.html&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Dave Rolsky, &lt;autarch@urth.org&gt; and Ilya Martynov
    &lt;ilya@martynov.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is Copyright (c) 2013 by Dave Rolsky and Ilya
    Martynov.</p>
<p class="Pp">This is free software, licensed under:</p>
<p class="Pp"></p>
<pre>
  The Artistic License 2.0 (GPL Compatible)
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-12</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

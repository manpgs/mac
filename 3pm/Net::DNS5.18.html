<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Net::DNS(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Net::DNS(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Net::DNS(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Net::DNS - Perl interface to the Domain Name System</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
    use Net::DNS;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Net::DNS is a collection of Perl modules that act as a Domain Name
    System (DNS) resolver. It allows the programmer to perform DNS queries that
    are beyond the capabilities of
    <span class="Li">&quot;gethostbyname&quot;</span> and
    <span class="Li">&quot;gethostbyaddr&quot;</span>.</p>
<p class="Pp">The programmer should be somewhat familiar with the format of a
    DNS packet and its various sections. See RFC 1035 or <i>DNS and BIND</i>
    (Albitz &amp; Liu) for details.</p>
<section class="Ss">
<h2 class="Ss" id="Resolver_Objects"><a class="permalink" href="#Resolver_Objects">Resolver
  Objects</a></h2>
<p class="Pp">A resolver object is an instance of the Net::DNS::Resolver class.
    A program can have multiple resolver objects, each maintaining its own state
    information such as the nameservers to be queried, whether recursion is
    desired, etc.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Packet_Objects"><a class="permalink" href="#Packet_Objects">Packet
  Objects</a></h2>
<p class="Pp">Net::DNS::Resolver queries return Net::DNS::Packet objects. Packet
    objects have five sections:</p>
<ul class="Bl-bullet">
  <li>The header section, a Net::DNS::Header object.</li>
  <li>The question section, a list of Net::DNS::Question objects.</li>
  <li>The answer section, a list of Net::DNS::RR objects.</li>
  <li>The authority section, a list of Net::DNS::RR objects.</li>
  <li>The additional section, a list of Net::DNS::RR objects.</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Update_Objects"><a class="permalink" href="#Update_Objects">Update
  Objects</a></h2>
<p class="Pp">The Net::DNS::Update package is a subclass of Net::DNS::Packet for
    creating packet objects to be used in dynamic updates.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Header_Objects"><a class="permalink" href="#Header_Objects">Header
  Objects</a></h2>
<p class="Pp">Net::DNS::Header objects represent the header section of a DNS
    packet.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Question_Objects"><a class="permalink" href="#Question_Objects">Question
  Objects</a></h2>
<p class="Pp">Net::DNS::Question objects represent the question section of a DNS
    packet.</p>
</section>
<section class="Ss">
<h2 class="Ss">RR Objects</h2>
<p class="Pp">Net::DNS::RR is the base class for DNS resource record (RR)
    objects in the answer, authority, and additional sections of a DNS
  packet.</p>
<p class="Pp">Don't assume that RR objects will be of the type you requested --
    always check an RR object's type before calling any of its methods.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<p class="Pp">See the manual pages listed above for other class-specific
    methods.</p>
<section class="Ss">
<h2 class="Ss" id="version"><a class="permalink" href="#version">version</a></h2>
<pre>
    print Net::DNS-&gt;version, &quot;\n&quot;;
</pre>
<p class="Pp">Returns the version of Net::DNS.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="mx"><a class="permalink" href="#mx">mx</a></h2>
<pre>
    # Use a default resolver -- can't get an error string this way.
    use Net::DNS;
    my @mx = mx(&quot;example.com&quot;);

    # Use your own resolver object.
    use Net::DNS;
    my $res = Net::DNS::Resolver-&gt;new;
    my  @mx = mx($res, &quot;example.com&quot;);
</pre>
<p class="Pp">Returns a list of Net::DNS::RR::MX objects representing the MX
    records for the specified name; the list will be sorted by preference.
    Returns an empty list if the query failed or no MX records were found.</p>
<p class="Pp">This method does not look up A records -- it only performs MX
    queries.</p>
<p class="Pp">See &quot;EXAMPLES&quot; for a more complete example.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="yxrrset"><a class="permalink" href="#yxrrset">yxrrset</a></h2>
<p class="Pp">Use this method to add an &quot;RRset exists&quot; prerequisite to
    a dynamic update packet. There are two forms, value-independent and
    value-dependent:</p>
<p class="Pp"></p>
<pre>
    # RRset exists (value-independent)
    $update-&gt;push(pre =&gt; yxrrset(&quot;host.example.com A&quot;));
</pre>
<p class="Pp">Meaning: At least one RR with the specified name and type must
    exist.</p>
<p class="Pp"></p>
<pre>
    # RRset exists (value-dependent)
    $packet-&gt;push(pre =&gt; yxrrset(&quot;host.example.com A 10.1.2.3&quot;));
</pre>
<p class="Pp">Meaning: At least one RR with the specified name and type must
    exist and must have matching data.</p>
<p class="Pp">Returns a <span class="Li">&quot;Net::DNS::RR&quot;</span> object
    or <span class="Li">&quot;undef&quot;</span> if the object couldn't be
    created.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="nxrrset"><a class="permalink" href="#nxrrset">nxrrset</a></h2>
<p class="Pp">Use this method to add an &quot;RRset does not exist&quot;
    prerequisite to a dynamic update packet.</p>
<p class="Pp"></p>
<pre>
    $packet-&gt;push(pre =&gt; nxrrset(&quot;host.example.com A&quot;));
</pre>
<p class="Pp">Meaning: No RRs with the specified name and type can exist.</p>
<p class="Pp">Returns a <span class="Li">&quot;Net::DNS::RR&quot;</span> object
    or <span class="Li">&quot;undef&quot;</span> if the object couldn't be
    created.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="yxdomain"><a class="permalink" href="#yxdomain">yxdomain</a></h2>
<p class="Pp">Use this method to add a &quot;name is in use&quot; prerequisite
    to a dynamic update packet.</p>
<p class="Pp"></p>
<pre>
    $packet-&gt;push(pre =&gt; yxdomain(&quot;host.example.com&quot;));
</pre>
<p class="Pp">Meaning: At least one RR with the specified name must exist.</p>
<p class="Pp">Returns a <span class="Li">&quot;Net::DNS::RR&quot;</span> object
    or <span class="Li">&quot;undef&quot;</span> if the object couldn't be
    created.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="nxdomain"><a class="permalink" href="#nxdomain">nxdomain</a></h2>
<p class="Pp">Use this method to add a &quot;name is not in use&quot;
    prerequisite to a dynamic update packet.</p>
<p class="Pp"></p>
<pre>
    $packet-&gt;push(pre =&gt; nxdomain(&quot;host.example.com&quot;));
</pre>
<p class="Pp">Meaning: No RR with the specified name can exist.</p>
<p class="Pp">Returns a <span class="Li">&quot;Net::DNS::RR&quot;</span> object
    or <span class="Li">&quot;undef&quot;</span> if the object couldn't be
    created.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="rr_add"><a class="permalink" href="#rr_add">rr_add</a></h2>
<p class="Pp">Use this method to add RRs to a zone.</p>
<p class="Pp"></p>
<pre>
    $packet-&gt;push(update =&gt; rr_add(&quot;host.example.com A 10.1.2.3&quot;));
</pre>
<p class="Pp">Meaning: Add this RR to the zone.</p>
<p class="Pp">RR objects created by this method should be added to the
    &quot;update&quot; section of a dynamic update packet. The TTL defaults to
    86400 seconds (24 hours) if not specified.</p>
<p class="Pp">Returns a <span class="Li">&quot;Net::DNS::RR&quot;</span> object
    or <span class="Li">&quot;undef&quot;</span> if the object couldn't be
    created.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="rr_del"><a class="permalink" href="#rr_del">rr_del</a></h2>
<p class="Pp">Use this method to delete RRs from a zone. There are three forms:
    delete an RRset, delete all RRsets, and delete an RR.</p>
<p class="Pp"></p>
<pre>
    # Delete an RRset.
    $packet-&gt;push(update =&gt; rr_del(&quot;host.example.com A&quot;));
</pre>
<p class="Pp">Meaning: Delete all RRs having the specified name and type.</p>
<p class="Pp"></p>
<pre>
    # Delete all RRsets.
    $packet-&gt;push(update =&gt; rr_del(&quot;host.example.com&quot;));
</pre>
<p class="Pp">Meaning: Delete all RRs having the specified name.</p>
<p class="Pp"></p>
<pre>
    # Delete an RR.
    $packet-&gt;push(update =&gt; rr_del(&quot;host.example.com A 10.1.2.3&quot;));
</pre>
<p class="Pp">Meaning: Delete all RRs having the specified name, type, and
  data.</p>
<p class="Pp">RR objects created by this method should be added to the
    &quot;update&quot; section of a dynamic update packet.</p>
<p class="Pp">Returns a <span class="Li">&quot;Net::DNS::RR&quot;</span> object
    or <span class="Li">&quot;undef&quot;</span> if the object couldn't be
    created.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Zone_Serial_Number_Management"><a class="permalink" href="#Zone_Serial_Number_Management">Zone
  Serial Number Management</a></h1>
<p class="Pp">The Net::DNS module provides auxiliary functions which support
    policy-driven zone serial numbering regimes.</p>
<section class="Ss">
<h2 class="Ss" id="Strictly_Sequential"><a class="permalink" href="#Strictly_Sequential">Strictly
  Sequential</a></h2>
<pre>
    $successor = $soa-&gt;serial( SEQUENTIAL );
</pre>
<p class="Pp">The existing serial number is incremented modulo 2**32.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Time_Encoded"><a class="permalink" href="#Time_Encoded">Time
  Encoded</a></h2>
<pre>
    $successor = $soa-&gt;serial( UNIXTIME );
</pre>
<p class="Pp">The Unix time scale will be used as the basis for zone serial
    numbering. The serial number will be incremented if the time elapsed since
    the previous update is less than one second.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Date_Encoded"><a class="permalink" href="#Date_Encoded">Date
  Encoded</a></h2>
<pre>
    $successor = $soa-&gt;serial( YYYYMMDDxx );
</pre>
<p class="Pp">The 32 bit value returned by the auxiliary <i>YYYYMMDDxx()</i>
    function will be used as the base for the date-coded zone serial number.
    Serial number increments must be limited to 100 per day for the date
    information to remain useful.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Sorting_of_"><a class="permalink" href="#Sorting_of_">Sorting
  of RR arrays</a></h2>
<p class="Pp">As of version 0.55 there is functionality to help you sort RR
    arrays. '<i>rrsort()</i>' is the function that is available to do the
    sorting. In most cases rrsort will give you the answer that you want but you
    can specify your own sorting method by using the
    Net::DNS::RR::FOO-&gt;<i>set_rrsort_func()</i> class method. See
    Net::DNS::RR for details.</p>
<p class="Pp"><i></i><i>rrsort()</i><i></i></p>
<p class="Pp"></p>
<pre>
   use Net::DNS qw(rrsort);

   my @prioritysorted=rrsort(&quot;SRV&quot;,&quot;priority&quot;,@rr_array);
</pre>
<p class="Pp"><i>rrsort()</i> selects all RRs from the input array that are of
    the type that are defined in the first argument. Those RRs are sorted based
    on the attribute that is specified as second argument.</p>
<p class="Pp">There are a number of RRs for which the sorting function is
    specifically defined for certain attributes. If such sorting function is
    defined in the code (it can be set or overwritten using the
    <i>set_rrsort_func()</i> class method) that function is used.</p>
<p class="Pp">For instance:
  <br/>
   my
    <span class="Li">@prioritysorted</span>=rrsort(&quot;SRV&quot;,&quot;priority&quot;,@rr_array);
    returns the SRV records sorted from lowest to heighest priority and for
    equal priorities from heighes to lowes weight.</p>
<p class="Pp">If the function does not exist then a numerical sort on the
    attribute value is performed.
  <br/>
   my
    <span class="Li">@portsorted</span>=rrsort(&quot;SRV&quot;,&quot;port&quot;,@rr_array);</p>
<p class="Pp">If the attribute does not exist for a certain RR than the RRs are
    sorted on string comparrisson of the rdata.</p>
<p class="Pp">If the attribute is not defined than either the default_sort
    function will be defined or &quot;Canonical sorting&quot; (as defined by
    DNSSEC) will be used.</p>
<p class="Pp"><i>rrsort()</i> returns a sorted array with only elements of the
    specified RR type or undef.</p>
<p class="Pp"><i>rrsort()</i> returns undef when arguments are incorrect.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">The following examples show how to use the
    <span class="Li">&quot;Net::DNS&quot;</span> modules. See the other manual
    pages and the demo scripts included with the source code for additional
    examples.</p>
<p class="Pp">See the <span class="Li">&quot;Net::DNS::Update&quot;</span>
    manual page for an example of performing dynamic updates.</p>
<section class="Ss">
<h2 class="Ss" id="Look_up_a_host's_addresses."><a class="permalink" href="#Look_up_a_host's_addresses.">Look
  up a host's addresses.</a></h2>
<pre>
  use Net::DNS;
  my $res   = Net::DNS::Resolver-&gt;new;
  my $query = $res-&gt;search(&quot;host.example.com&quot;);

  if ($query) {
      foreach my $rr ($query-&gt;answer) {
          next unless $rr-&gt;type eq &quot;A&quot;;
          print $rr-&gt;address, &quot;\n&quot;;
      }
  } else {
      warn &quot;query failed: &quot;, $res-&gt;errorstring, &quot;\n&quot;;
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Find_the_nameservers_for_a_domain."><a class="permalink" href="#Find_the_nameservers_for_a_domain.">Find
  the nameservers for a domain.</a></h2>
<pre>
  use Net::DNS;
  my $res   = Net::DNS::Resolver-&gt;new;
  my $query = $res-&gt;query(&quot;example.com&quot;, &quot;NS&quot;);

  if ($query) {
      foreach $rr (grep { $_-&gt;type eq 'NS' } $query-&gt;answer) {
          print $rr-&gt;nsdname, &quot;\n&quot;;
      }
  }
  else {
      warn &quot;query failed: &quot;, $res-&gt;errorstring, &quot;\n&quot;;
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Find_the_"><a class="permalink" href="#Find_the_">Find the MX
  records for a domain.</a></h2>
<pre>
  use Net::DNS;
  my $name = &quot;example.com&quot;;
  my $res  = Net::DNS::Resolver-&gt;new;
  my @mx   = mx($res, $name);

  if (@mx) {
      foreach $rr (@mx) {
          print $rr-&gt;preference, &quot; &quot;, $rr-&gt;exchange, &quot;\n&quot;;
      }
  } else {
      warn &quot;Can't find MX records for $name: &quot;, $res-&gt;errorstring, &quot;\n&quot;;
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Print_a_domain's_"><a class="permalink" href="#Print_a_domain's_">Print
  a domain's SOA record in zone file format.</a></h2>
<pre>
  use Net::DNS;
  my $res   = Net::DNS::Resolver-&gt;new;
  my $query = $res-&gt;query(&quot;example.com&quot;, &quot;SOA&quot;);

  if ($query) {
      ($query-&gt;answer)[0]-&gt;print;
  } else {
      print &quot;query failed: &quot;, $res-&gt;errorstring, &quot;\n&quot;;
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Perform_a_zone_transfer_and_print_all_the_records."><a class="permalink" href="#Perform_a_zone_transfer_and_print_all_the_records.">Perform
  a zone transfer and print all the records.</a></h2>
<pre>
  use Net::DNS;
  my $res  = Net::DNS::Resolver-&gt;new;
  $res-&gt;nameservers(&quot;ns.example.com&quot;);

  my @zone = $res-&gt;axfr(&quot;example.com&quot;);

  foreach $rr (@zone) {
      $rr-&gt;print;
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Perform_a_background_query_and_do_some_other_work_while_waiting_for_the_answer."><a class="permalink" href="#Perform_a_background_query_and_do_some_other_work_while_waiting_for_the_answer.">Perform
  a background query and do some other work while waiting for the
  answer.</a></h2>
<pre>
  use Net::DNS;
  my $res    = Net::DNS::Resolver-&gt;new;
  my $socket = $res-&gt;bgsend(&quot;host.example.com&quot;);

  until ($res-&gt;bgisready($socket)) {
      # do some work here while waiting for the answer
      # ...and some more here
  }

  my $packet = $res-&gt;bgread($socket);
  $packet-&gt;print;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Send_a_background_query_and_use_select_to_determine_when_the_answer_has_arrived."><a class="permalink" href="#Send_a_background_query_and_use_select_to_determine_when_the_answer_has_arrived.">Send
  a background query and use select to determine when the answer has
  arrived.</a></h2>
<pre>
  use Net::DNS;
  use IO::Select;

  my $timeout = 5;
  my $res     = Net::DNS::Resolver-&gt;new;
  my $bgsock  = $res-&gt;bgsend(&quot;host.example.com&quot;);
  my $sel     = IO::Select-&gt;new($bgsock);

  # Add more sockets to $sel if desired.
  my @ready = $sel-&gt;can_read($timeout);
  if (@ready) {
      foreach my $sock (@ready) {
          if ($sock == $bgsock) {
              my $packet = $res-&gt;bgread($bgsock);
              $packet-&gt;print;
              $bgsock = undef;
          }
          # Check for the other sockets.
          $sel-&gt;remove($sock);
          $sock = undef;
      }
  } else {
      warn &quot;timed out after $timeout seconds\n&quot;;
  }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp"><span class="Li">&quot;Net::DNS&quot;</span> is slow.</p>
<p class="Pp">For other items to be fixed, or if you discover a bug in this
    distribution please use the CPAN bug reporting system.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (c)1997-2002 Michael Fuhr. Portions
    Copyright(c)2002-2004 Chris Reinhardt. Portions Copyright(c)2005 Olaf
    Kolkman (RIPE NCC) Portions Copyright(c)2006 Olaf Kolkman (NLnet Labs)</p>
<p class="Pp">All rights reserved.</p>
<p class="Pp">This program is free software; you may redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR_INFORMATION"><a class="permalink" href="#AUTHOR_INFORMATION">AUTHOR
  INFORMATION</a></h1>
<p class="Pp">Net::DNS is currently maintained at NLnet Labs (www.nlnetlabs.nl)
    by:
  <br/>
   Olaf Kolkman 	olaf@net-dns.org</p>
<p class="Pp">Between 2002 and 2004 Net::DNS was maintained by:
  <br/>
   Chris Reinhardt</p>
<p class="Pp">Net::DNS was created by: 	Michael Fuhr 	mike@fuhr.org</p>
<p class="Pp">For more information see:
  <br/>
   http://www.net-dns.org/</p>
<p class="Pp">Stay tuned and syndicate:
  <br/>
   http://www.net-dns.org/blog/</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">perl, Net::DNS::Resolver, Net::DNS::Packet, Net::DNS::Update,
    Net::DNS::Header, Net::DNS::Question, Net::DNS::RR, RFC 1035, <i>DNS and
    BIND</i> by Paul Albitz &amp; Cricket Liu</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-16</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Net::Server(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Net::Server(3)</td>
    <td class="head-vol"><a href=".">User Contributed Perl Documentation</a></td>
    <td class="head-rtitle">Net::Server(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Net::Server - Extensible, general Perl server engine</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    #!/usr/bin/perl -w -T
    package MyPackage;
    use base qw(Net::Server);
    sub process_request {
        my $self = shift;
        while (&lt;STDIN&gt;) {
            s/[\r\n]+$//;
            print &quot;You said '$_'\015\012&quot;; # basic echo
            last if /quit/i;
        }
    }
    MyPackage-&gt;run(port =&gt; 160, ipv =&gt; '*');
    # one liner to get going quickly
    perl -e 'use base qw(Net::Server); main-&gt;run(port =&gt; 20208)'
    NOTE: beginning in Net::Server 2.005, the default value for
          ipv is IPv* meaning that if no host is passed, or
          a hostname is past, any available IPv4 and IPv6 sockets will be
          bound.  You can force IPv4 only by adding an ipv =&gt; 4
          configuration in any of the half dozen ways we let you
          specify it.
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="FEATURES"><a class="permalink" href="#FEATURES">FEATURES</a></h1>
<pre>    * Full IPv6 support
    * Working SSL sockets and https (both with and without IO::Socket::SSL)
    * Single Server Mode
    * Inetd Server Mode
    * Preforking Simple Mode (PreForkSimple)
    * Preforking Managed Mode (PreFork)
    * Forking Mode
    * Multiplexing Mode using a single process
    * Multi port accepts on Single, Preforking, and Forking modes
    * Basic HTTP Daemon (supports IPv6, SSL, full apache style logs)
    * Basic PSGI Daemon
    * Simultaneous accept/recv on tcp/udp/unix, ssl/tcp, and IPv4/IPv6 sockets
    * Safe signal handling in Fork/PreFork avoids perl signal trouble
    * User customizable hooks
    * Chroot ability after bind
    * Change of user and group after bind
    * Basic allow/deny access control
    * Pluggable logging (Sys::Syslog, Log::Log4perl, log_file, STDERR, or your own)
    * HUP able server (clean restarts via sig HUP)
    * Graceful shutdowns (via sig QUIT)
    * Hot deploy in Fork and PreFork modes (via sig TTIN and TTOU)
    * Dequeue ability in all Fork and PreFork modes.
    * Taint clean
    * Written in Perl
    * Protection against buffer overflow
    * Clean process flow
    * Extensibility
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><span class="Li">&quot;Net::Server&quot;</span> is an extensible,
    generic Perl server engine.</p>
<p class="Pp"><span class="Li">&quot;Net::Server&quot;</span> attempts to be a
    generic server as in <span class="Li">&quot;Net::Daemon&quot;</span> and
    <span class="Li">&quot;NetServer::Generic&quot;</span>. It includes with it
    the ability to run as an inetd process
    (<span class="Li">&quot;Net::Server::INET&quot;</span>), a single connection
    server (<span class="Li">&quot;Net::Server&quot;</span> or
    <span class="Li">&quot;Net::Server::Single&quot;</span>), a forking server
    (<span class="Li">&quot;Net::Server::Fork&quot;</span>), a preforking server
    which maintains a constant number of preforked children
    (<span class="Li">&quot;Net::Server::PreForkSimple&quot;</span>), or as a
    managed preforking server which maintains the number of children based on
    server load (<span class="Li">&quot;Net::Server::PreFork&quot;</span>). In
    all but the inetd type, the server provides the ability to connect to one or
    to multiple server ports.</p>
<p class="Pp">The additional server types are made possible via
    &quot;personalities&quot; or sub classes of the
    <span class="Li">&quot;Net::Server&quot;</span>. By moving the multiple
    types of servers out of the main
    <span class="Li">&quot;Net::Server&quot;</span> class, the
    <span class="Li">&quot;Net::Server&quot;</span> concept is easily extended
    to other types (in the near future, we would like to add a
    &quot;Thread&quot; personality).</p>
<p class="Pp"><span class="Li">&quot;Net::Server&quot;</span> borrows several
    concepts from the Apache Webserver.
    <span class="Li">&quot;Net::Server&quot;</span> uses &quot;hooks&quot; to
    allow custom servers such as SMTP, HTTP, POP3, etc. to be layered over the
    base <span class="Li">&quot;Net::Server&quot;</span> class. In addition the
    <span class="Li">&quot;Net::Server::PreFork&quot;</span> class borrows
    concepts of min_start_servers, max_servers, and min_waiting servers.
    <span class="Li">&quot;Net::Server::PreFork&quot;</span> also uses the
    concept of an flock serialized accept when accepting on multiple ports
    (PreFork can choose between flock, IPC::Semaphore, and pipe to control
    serialization).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PERSONALITIES"><a class="permalink" href="#PERSONALITIES">PERSONALITIES</a></h1>
<p class="Pp"><span class="Li">&quot;Net::Server&quot;</span> is built around a
    common class (Net::Server) and is extended using sub classes, or
    <span class="Li">&quot;personalities&quot;</span>. Each personality
    inherits, overrides, or enhances the base methods of the base class.</p>
<p class="Pp">Included with the Net::Server package are several basic
    personalities, each of which has their own use.</p>
<dl class="Bl-tag">
  <dt id="Fork"><a class="permalink" href="#Fork">Fork</a></dt>
  <dd>Found in the module Net/Server/Fork.pm (see Net::Server::Fork). This
      server binds to one or more ports and then waits for a connection. When a
      client request is received, the parent forks a child, which then handles
      the client and exits. This is good for moderately hit services.</dd>
  <dt id="INET"><a class="permalink" href="#INET">INET</a></dt>
  <dd>Found in the module Net/Server/INET.pm (see Net::Server::INET). This
      server is designed to be used with inetd. The
      <span class="Li">&quot;pre_bind&quot;</span>,
      <span class="Li">&quot;bind&quot;</span>,
      <span class="Li">&quot;accept&quot;</span>, and
      <span class="Li">&quot;post_accept&quot;</span> are all overridden as
      these services are taken care of by the INET daemon.</dd>
  <dt id="MultiType"><a class="permalink" href="#MultiType">MultiType</a></dt>
  <dd>Found in the module Net/Server/MultiType.pm (see Net::Server::MultiType).
      This server has no server functionality of its own. It is designed for
      servers which need a simple way to easily switch between different
      personalities. Multiple <span class="Li">&quot;server_type&quot;</span>
      parameters may be given and Net::Server::MultiType will cycle through
      until it finds a class that it can use.</dd>
  <dt id="Multiplex"><a class="permalink" href="#Multiplex">Multiplex</a></dt>
  <dd>Found in the module Net/Server/Multiplex.pm (see Net::Server::Multiplex).
      This server binds to one or more ports. It uses IO::Multiplex to multiplex
      between waiting for new connections and waiting for input on currently
      established connections. This personality is designed to run as one
      process without forking. The
      <span class="Li">&quot;process_request&quot;</span> method is never used
      but the <span class="Li">&quot;mux_input&quot;</span> callback is used
      instead (see also IO::Multiplex). See examples/samplechat.pl for an
      example using most of the features of Net::Server::Multiplex.</dd>
  <dt id="PreForkSimple"><a class="permalink" href="#PreForkSimple">PreForkSimple</a></dt>
  <dd>Found in the module Net/Server/PreFork.pm (see Net::Server::PreFork). This
      server binds to one or more ports and then forks
      <span class="Li">&quot;max_servers&quot;</span> child process. The server
      will make sure that at any given time there are always
      <span class="Li">&quot;max_servers&quot;</span> available to receive a
      client request. Each of these children will process up to
      <span class="Li">&quot;max_requests&quot;</span> client connections. This
      type is good for a heavily hit site that can dedicate max_server processes
      no matter what the load. It should scale well for most applications. Multi
      port accept is accomplished using either flock, IPC::Semaphore, or pipe to
      serialize the children. Serialization may also be switched on for single
      port in order to get around an OS that does not allow multiple children to
      accept at the same time. For a further discussion of serialization see
      Net::Server::PreFork.</dd>
  <dt id="PreFork"><a class="permalink" href="#PreFork">PreFork</a></dt>
  <dd>Found in the module Net/Server/PreFork.pm (see Net::Server::PreFork). This
      server binds to one or more ports and then forks
      <span class="Li">&quot;min_servers&quot;</span> child process. The server
      will make sure that at any given time there are at least
      <span class="Li">&quot;min_spare_servers&quot;</span> but not more than
      <span class="Li">&quot;max_spare_servers&quot;</span> available to receive
      a client request, up to <span class="Li">&quot;max_servers&quot;</span>.
      Each of these children will process up to
      <span class="Li">&quot;max_requests&quot;</span> client connections. This
      type is good for a heavily hit site, and should scale well for most
      applications. Multi port accept is accomplished using either flock,
      IPC::Semaphore, or pipe to serialize the children. Serialization may also
      be switched on for single port in order to get around an OS that does not
      allow multiple children to accept at the same time. For a further
      discussion of serialization see Net::Server::PreFork.</dd>
  <dt id="Single"><a class="permalink" href="#Single">Single</a></dt>
  <dd>All methods fall back to Net::Server. This personality is provided only as
      parallelism for Net::Server::MultiType.</dd>
  <dt id="HTTP"><a class="permalink" href="#HTTP">HTTP</a></dt>
  <dd>Not a distinct personality. Provides a basic HTTP daemon. This can be
      combined with the SSL or SSLEAY proto to provide an HTTPS Daemon. See
      Net::Server::HTTP.</dd>
</dl>
<p class="Pp"><span class="Li">&quot;Net::Server&quot;</span> was partially
    written to make it easy to add new personalities. Using separate modules
    built upon an open architecture allows for easy addition of new features, a
    separate development process, and reduced code bloat in the core module.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SOCKET_ACCESS"><a class="permalink" href="#SOCKET_ACCESS">SOCKET
  ACCESS</a></h1>
<p class="Pp">Once started, the Net::Server will take care of binding to port
    and waiting for connections. Once a connection is received, the Net::Server
    will accept on the socket and will store the result (the client connection)
    in <span class="Li">$self</span>-&gt;{server}-&gt;{client}. This property is
    a Socket blessed into the the IO::Socket classes. UDP servers are slightly
    different in that they will perform a <b>recv</b> instead of an
    <b>accept</b>.</p>
<p class="Pp">To make programming easier, during the post_accept phase, STDIN
    and STDOUT are opened to the client connection. This allows for programs to
    be written using &lt;STDIN&gt; and print &quot;out\n&quot; to print to the
    client connection. UDP will require using a -&gt;send call.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SAMPLE_CODE"><a class="permalink" href="#SAMPLE_CODE">SAMPLE
  CODE</a></h1>
<p class="Pp">The following is a very simple server. The main functionality
    occurs in the process_request method call as shown below. Notice the use of
    timeouts to prevent Denial of Service while reading. (Other examples of
    using <span class="Li">&quot;Net::Server&quot;</span> can, or will, be
    included with this distribution).</p>
<p class="Pp"></p>
<pre>    #!/usr/bin/perl -w -T
    package MyPackage;
    use strict;
    use base qw(Net::Server::PreFork); # any personality will do
    MyPackage-&gt;run;
    # over-ride the default echo handler
    sub process_request {
        my $self = shift;
        eval {
            local $SIG{'ALRM'} = sub { die &quot;Timed Out!\n&quot; };
            my $timeout = 30; # give the user 30 seconds to type some lines
            my $previous_alarm = alarm($timeout);
            while (&lt;STDIN&gt;) {
                s/\r?\n$//;
                print &quot;You said '$_'\r\n&quot;;
                alarm($timeout);
            }
            alarm($previous_alarm);
        };
        if ($@ =~ /timed out/i) {
            print STDOUT &quot;Timed Out.\r\n&quot;;
            return;
        }
    }
    1;
</pre>
<p class="Pp">Playing this file from the command line will invoke a Net::Server
    using the PreFork personality. When building a server layer over the
    Net::Server, it is important to use features such as timeouts to prevent
    Denial Of Service attacks.</p>
<p class="Pp">Net::Server comes with a built in echo server by default. You can
    test it out by simply running the following from the commandline:</p>
<p class="Pp"></p>
<pre>    net-server
</pre>
<p class="Pp">If you wanted to try another flavor you could try</p>
<p class="Pp"></p>
<pre>    net-server PreFork
</pre>
<p class="Pp">If you wanted to try out a basic HTTP server you could use</p>
<p class="Pp"></p>
<pre>    net-server HTTP
</pre>
<p class="Pp">Or if you wanted to test out a CGI you are writing you could
  use</p>
<p class="Pp"></p>
<pre>    net-server HTTP --app ../../mycgi.cgi
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="ARGUMENTS"><a class="permalink" href="#ARGUMENTS">ARGUMENTS</a></h1>
<p class="Pp">There are at least five possible ways to pass arguments to
    Net::Server. They are <i>passing to the new method</i>, <i>passing on</i>
    <i>command line</i>, <i>passing parameters to run</i>, <i>using a conf
    file</i>, <i>returning values in the default_values method</i>, or
    <i>configuring the</i> <i>values in post_configure_hook</i>.</p>
<p class="Pp">The <span class="Li">&quot;options&quot;</span> method is used to
    determine which arguments the server will search for and can be used to
    extend the parsed parameters. Any arguments found from the command line,
    parameters passed to run, and arguments found in the conf_file will be
    matched against the keys of the options template. Any commandline parameters
    that do not match will be left in place and can be further processed by the
    server in the various hooks (by looking at <span class="Li">@ARGV</span>).
    Arguments passed to new will automatically win over any other options (this
    can be used if you would like to disallow a user passing in other
    arguments).</p>
<p class="Pp">Arguments consist of key value pairs. On the commandline these
    pairs follow the POSIX fashion of <span class="Li">&quot;--key
    value&quot;</span> or <span class="Li">&quot;--key=value&quot;</span>, and
    also <span class="Li">&quot;key=value&quot;</span>. In the conf file the
    parameter passing can best be shown by the following regular expression:
    ($key,$val)=~/^(\w+)\s+(\S+?)\s+$/. Passing arguments to the run method is
    done as follows: <span class="Li">&quot;&lt;Net::Server-&gt;run(key1
    =&quot;</span> 'val1')&gt;&gt;. Passing arguments via a prebuilt object can
    best be shown in the following code:</p>
<p class="Pp"></p>
<pre>    #!/usr/bin/perl -w -T
    package MyPackage;
    use strict;
    use base qw(Net::Server);
    my $server = MyPackage-&gt;new({
        key1 =&gt; 'val1',
    });
    $server-&gt;run;
</pre>
<p class="Pp">All five methods for passing arguments may be used at the same
    time. Once an argument has been set, it is not over written if another
    method passes the same argument.
    <span class="Li">&quot;Net::Server&quot;</span> will look for arguments in
    the following order:</p>
<p class="Pp"></p>
<pre>    1) Arguments passed to the C&lt;new&gt; method.
    2) Arguments passed on command line.
    3) Arguments passed to the C&lt;run&gt; method.
    4) Arguments passed via a conf file.
    5) Arguments set in the C&lt;default_values&gt; method.
</pre>
<p class="Pp">Additionally the following hooks are available:</p>
<p class="Pp"></p>
<pre>    1) Arguments set in the configure_hook (occurs after new
       but before any of the other areas are checked).
    2) Arguments set and validated in the post_configure_hook
       (occurs after all of the other areas are checked).
</pre>
<p class="Pp">Each of these levels will override parameters of the same name
    specified in subsequent levels. For example, specifying --setsid=0 on the
    command line will override a value of &quot;setsid 1&quot; in the conf
  file.</p>
<p class="Pp">Note that the configure_hook method doesn't return values to set,
    but is there to allow for setting up configured values before the configure
    method is called.</p>
<p class="Pp">Key/value pairs used by the server are removed by the
    configuration process so that server layers on top of
    <span class="Li">&quot;Net::Server&quot;</span> can pass and read their own
    parameters.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ADDING_CUSTOM_ARGUMENTS"><a class="permalink" href="#ADDING_CUSTOM_ARGUMENTS">ADDING
  CUSTOM ARGUMENTS</a></h1>
<p class="Pp">It is possible to add in your own custom parameters to those
    parsed by Net::Server. The following code shows how this is done:</p>
<p class="Pp"></p>
<pre>    sub options {
        my $self     = shift;
        my $prop     = $self-&gt;{'server'};
        my $template = shift;
        # setup options in the parent classes
        $self-&gt;SUPER::options($template);
        # add a single value option
        $prop-&gt;{'my_option'} ||= undef;
        $template-&gt;{'my_option'} = \ $prop-&gt;{'my_option'};
        # add a multi value option
        $prop-&gt;{'an_arrayref_item'} ||= [];
        $template-&gt;{'an_arrayref_item'} = $prop-&gt;{'an_arrayref_item'};
    }
</pre>
<p class="Pp">Overriding the <span class="Li">&quot;options&quot;</span> method
    allows for adding your own custom fields. A template hashref is passed in,
    that should then be modified to contain an of your custom fields. Fields
    which are intended to receive a single scalar value should have a reference
    to the destination scalar given. Fields which are intended to receive
    multiple values should reference the corresponding destination arrayref.</p>
<p class="Pp">You are responsible for validating your custom options once they
    have been parsed. The post_configure_hook is a good place to do your
    validation.</p>
<p class="Pp">Some emails have asked why we use this &quot;template&quot;
    method. The idea is that you are creating the the data structure to store
    the values in, and you are also creating a way to get the values into the
    data structure. The template is the way to get the values to the servers
    data structure. One of the possibilities (that probably isn't used that
    much) is that by letting you specify the mapping, you could build a nested
    data structure - even though the passed in arguments are flat. It also
    allows you to setup aliases to your names.</p>
<p class="Pp">For example, a basic structure might look like this:</p>
<p class="Pp"></p>
<pre>   $prop = $self-&gt;{'server'}
   $prop-&gt;{'my_custom_option'} ||= undef;
   $prop-&gt;{'my_custom_array'}  ||= [];
   $template = {
       my_custom_option =&gt; \ $prop-&gt;{'my_custom_option'},
       mco              =&gt; \ $prop-&gt;{'my_custom_option'}, # alias
       my_custom_array  =&gt; $prop-&gt;{'my_custom_array'},
       mca              =&gt; $prop-&gt;{'my_custom_array'}, # an alias
   };
   $template-&gt;{'mco2'} = $template-&gt;{'mco'}; # another way to alias
</pre>
<p class="Pp">But you could also have more complex data:</p>
<p class="Pp"></p>
<pre>   $prop = $self-&gt;{'server'};
   $prop-&gt;{'one_layer'} = {
       two_layer =&gt; [
           undef,
           undef,
       ],
   };
   $template = {
       param1 =&gt; \ $prop-&gt;{'one_layer'}-&gt;{'two_layer'}-&gt;[0],
       param2 =&gt; \ $prop-&gt;{'one_layer'}-&gt;{'two_layer'}-&gt;[1],
   };
</pre>
<p class="Pp">This is of course a contrived example - but it does show that you
    can get the data from the flat passed in arguments to whatever type of
    structure you need - with only a little bit of effort.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DEFAULT_ARGUMENTS_FOR_Net::Server"><a class="permalink" href="#DEFAULT_ARGUMENTS_FOR_Net::Server">DEFAULT
  ARGUMENTS FOR Net::Server</a></h1>
<p class="Pp">The following arguments are available in the default
    <span class="Li">&quot;Net::Server&quot;</span> or
    <span class="Li">&quot;Net::Server::Single&quot;</span> modules. (Other
    personalities may use additional parameters and may optionally not use
    parameters from the base class.)</p>
<p class="Pp"></p>
<pre>    Key               Value                    Default
    conf_file         &quot;filename&quot;               undef
    log_level         0-4                      2
    log_file          (filename|Sys::Syslog
                       |Log::Log4perl)         undef
    port              \d+                      20203
    host              &quot;host&quot;                   &quot;*&quot;
    ipv               (4|6|*)                  *
    proto             (tcp|udp|unix)           &quot;tcp&quot;
    listen            \d+                      SOMAXCONN
    ## syslog parameters (if log_file eq Sys::Syslog)
    syslog_logsock    (native|unix|inet|udp
                       |tcp|stream|console)    unix (on Sys::Syslog &lt; 0.15)
    syslog_ident      &quot;identity&quot;               &quot;net_server&quot;
    syslog_logopt     (cons|ndelay|nowait|pid) pid
    syslog_facility   \w+                      daemon
    reverse_lookups   1                        undef
    allow             /regex/                  none
    deny              /regex/                  none
    cidr_allow        CIDR                     none
    cidr_deny         CIDR                     none
    ## daemonization parameters
    pid_file          &quot;filename&quot;               undef
    chroot            &quot;directory&quot;              undef
    user              (uid|username)           &quot;nobody&quot;
    group             (gid|group)              &quot;nobody&quot;
    background        1                        undef
    setsid            1                        undef
    no_close_by_child (1|undef)                undef
    ## See Net::Server::Proto::(TCP|UDP|UNIX|SSL|SSLeay|etc)
    ## for more sample parameters.
</pre>
<dl class="Bl-tag">
  <dt id="conf_file"><a class="permalink" href="#conf_file">conf_file</a></dt>
  <dd>Filename from which to read additional key value pair arguments for
      starting the server. Default is undef.
    <p class="Pp">There are two ways that you can specify a default location for
        a conf_file. The first is to pass the default value to the run method as
        in:</p>
    <p class="Pp"></p>
    <pre>    MyServer-&gt;run({
       conf_file =&gt; '/etc/my_server.conf',
    });
    </pre>
    <p class="Pp">If the end user passes in --conf_file=/etc/their_server.conf
        then the value will be overridden.</p>
    <p class="Pp">The second way to do this was added in the 0.96 version. It
        uses the default_values method as in:</p>
    <p class="Pp"></p>
    <pre>    sub default_values {
        return {
            conf_file =&gt; '/etc/my_server.conf',
        }
    }
    </pre>
    <p class="Pp">This method has the advantage of also being able to be
        overridden in the run method.</p>
    <p class="Pp">If you do not want the user to be able to specify a conf_file
        at all, you can pass conf_file to the new method when creating your
        object:</p>
    <p class="Pp"></p>
    <pre>    MyServer-&gt;new({
       conf_file =&gt; '/etc/my_server.conf',
    })-&gt;run;
    </pre>
    <p class="Pp">If passed this way, the value passed to new will
        &quot;win&quot; over any of the other passed in values.</p>
  </dd>
  <dt id="log_level"><a class="permalink" href="#log_level">log_level</a></dt>
  <dd>Ranges from 0 to 4 in level. Specifies what level of error will be logged.
      &quot;O&quot; means logging is off. &quot;4&quot; means very verbose.
      These levels should be able to correlate to syslog levels. Default is 2.
      These levels correlate to syslog levels as defined by the following
      key/value pairs: 0=&gt;'err', 1=&gt;'warning', 2=&gt;'notice',
      3=&gt;'info', 4=&gt;'debug'.</dd>
  <dt id="log_file"><a class="permalink" href="#log_file">log_file</a></dt>
  <dd>Name of log file or log subsystem to be written to. If no name is given
      and the write_to_log_hook is not overridden, log goes to STDERR. Default
      is undef.
    <p class="Pp">The log_file may also be the name of a Net::Server pluggable
        logging class. Net::Server is packaged with Sys::Syslog and
        Log::Log4perl. If the log_file looks like a module name, it will have
        &quot;Net::Server::Log::&quot; added to the front and it will then be
        required. The package should provide an
        <span class="Li">&quot;initialize&quot;</span> class method that returns
        a single function which will be used for logging. This returned function
        will be passed log_level, and message.</p>
    <p class="Pp">If the magic name &quot;Sys::Syslog&quot; is used, all logging
        will take place via the Net::Server::Log::Sys::Syslog module. If syslog
        is used the parameters
        <span class="Li">&quot;syslog_logsock&quot;</span>,
        <span class="Li">&quot;syslog_ident&quot;</span>, and
        <span class="Li">&quot;syslog_logopt&quot;</span>,and
        <span class="Li">&quot;syslog_facility&quot;</span> may also be defined.
        See Net::Server::Log::Sys::Syslog.</p>
    <p class="Pp">If the magic name &quot;Log::Log4perl&quot; is used, all
        logging will be directed to the Log4perl system. If used, the
        <span class="Li">&quot;log4perl_conf&quot;</span>,
        <span class="Li">&quot;log4perl_poll&quot;</span>,
        <span class="Li">&quot;log4perl_logger&quot;</span> may also be defined.
        See Net::Server::Log::Log::Log4per.</p>
    <p class="Pp">If a <span class="Li">&quot;log_file&quot;</span> is given or
        if <span class="Li">&quot;setsid&quot;</span> is set, STDIN and STDOUT
        will automatically be opened to /dev/null and STDERR will be opened to
        STDOUT. This will prevent any output from ending up at the terminal.</p>
  </dd>
  <dt id="pid_file"><a class="permalink" href="#pid_file">pid_file</a></dt>
  <dd>Filename to store pid of parent process. Generally applies only to forking
      servers. Default is none (undef).</dd>
  <dt id="port"><a class="permalink" href="#port">port</a></dt>
  <dd>See Net::Server::Proto for further examples of configuration.
    <p class="Pp">Local port/socket on which to bind. If it is a low port, the
        process must start as root. If multiple ports are given, all will be
        bound at server startup. May be of the form
        <span class="Li">&quot;host:port/proto&quot;</span>,
        <span class="Li">&quot;host:port/proto/ipv&quot;</span>,
        <span class="Li">&quot;host:port&quot;</span>,
        <span class="Li">&quot;port/proto&quot;</span>, or
        <span class="Li">&quot;port&quot;</span>, where <i>host</i> represents a
        hostname residing on the local box, where <i>port</i> represents either
        the number of the port (eg. &quot;80&quot;) or the service designation
        (eg. &quot;http&quot;), where <i>ipv</i> represents the IP protocol
        version (IPv4 or IPv6 or IPv*) and where <i>proto</i> represents the
        protocol to be used. See Net::Server::Proto. The following are some
        valid port strings:</p>
    <p class="Pp"></p>
    <pre>    20203                            # port only
    localhost:20203                  # host and port
    localhost:http                   # localhost bound to port 80
    localhost:20203/tcp              # host, port, protocol
    localhost:20203/tcp/IPv*         # host, port, protocol and family
    localhost, 20203, tcp, IPv*      # same
    localhost | 20203 | tcp | IPv*   # same
    localhost:20203/IPv*             # bind any configured interfaces for IPv4 or 6 (default)
    localhost:20203/IPv4/IPv6        # bind localhost on IPv4 and 6 (fails if it cannot do both)
    *:20203                          # bind all local interfaces
    </pre>
    <p class="Pp">Additionally, when passed in the code (non-commandline, and
        non-config), the port may be passed as a hashref or array hashrefs of
        information:</p>
    <p class="Pp"></p>
    <pre>    port =&gt; {
        host  =&gt; 'localhost',
        port  =&gt; '20203',
        ipv   =&gt; 6,     # IPv6 only
        proto =&gt; 'udp', # UDP protocol
    }
    port =&gt; [{
        host  =&gt; '*',
        port  =&gt; '20203',
        ipv   =&gt; 4,     # IPv4 only
        proto =&gt; 'tcp', # (default)
    }, {
        host  =&gt; 'localhost',
        port  =&gt; '20204',
        ipv   =&gt; '*',      # default - all IPv4 and IPv6 interfaces tied to localhost
        proto =&gt; 'ssleay', # or ssl - Using SSL
    }],
    </pre>
    <p class="Pp">An explicit <i>host</i> given in a port specification
        overrides a default binding address (a
        <span class="Li">&quot;host&quot;</span> setting, see below). The
        <i>host</i> part may be enclosed in square brackets, but when it is a
        numerical IPv6 address it <b>should</b> be enclosed in square brackets
        to avoid ambiguity in parsing a port number, e.g.: &quot;[::1]:80&quot;.
        However you could also use pipes, white space, or commas to separate
        these. Note that host and port number must come first.</p>
    <p class="Pp">If the protocol is not specified, <i>proto</i> will default to
        the <span class="Li">&quot;proto&quot;</span> specified in the
        arguments. If <span class="Li">&quot;proto&quot;</span> is not specified
        there it will default to &quot;tcp&quot;. If <i>host</i> is not
        specified, <i>host</i> will default to
        <span class="Li">&quot;host&quot;</span> specified in the arguments. If
        <span class="Li">&quot;host&quot;</span> is not specified there it will
        default to &quot;*&quot;. Default port is 20203. Configuration passed to
        new or run may be either a scalar containing a single port number or an
        arrayref of ports. If <span class="Li">&quot;ipv&quot;</span> is not
        specified it will default to &quot;*&quot; (Any resolved addresses under
        IPv4 or IPv6).</p>
    <p class="Pp">If you are working with unix sockets, you may also specify
        <span class="Li">&quot;socket_file|unix&quot;</span> or
        <span class="Li">&quot;socket_file|type|unix&quot;</span> where type is
        SOCK_DGRAM or SOCK_STREAM.</p>
    <p class="Pp">On systems that support it, a port value of 0 may be used to
        ask the OS to auto-assign a port. The value of the auto-assigned port
        will be stored in the NS_port property of the Net::Server::Proto::TCP
        object and is also available in the sockport method. When the server is
        processing a request, the
        <span class="Li">$self</span>-&gt;{server}-&gt;{sockport} property
        contains the port that was connected through.</p>
  </dd>
  <dt id="host"><a class="permalink" href="#host">host</a></dt>
  <dd>Local host or addr upon which to bind port. If a value of '*' is given,
      the server will bind that port on all available addresses on the box. The
      <span class="Li">&quot;host&quot;</span> argument provides a default local
      host address if the <span class="Li">&quot;port&quot;</span> argument
      omits a host specification. See Net::Server::Proto. See IO::Socket.
      Configuration passed to new or run may be either a scalar containing a
      single host or an arrayref of hosts - if the hosts array is shorter than
      the ports array, the last host entry will be used to augment the hosts
      arrary to the size of the ports array.
    <p class="Pp">If an IPv4 address is passed, an IPv4 socket will be created.
        If an IPv6 address is passed, an IPv6 socket will be created. If a
        hostname is given, Net::Server will look at the value of ipv (default
        IPv4) to determine which type of socket to create. Optionally the ipv
        specification can be passed as part of the hostname.</p>
    <p class="Pp"></p>
    <pre>    host =&gt; &quot;127.0.0.1&quot;,  # an IPv4 address
    host =&gt; &quot;::1&quot;,        # an IPv6 address
    host =&gt; 'localhost',  # addresses matched by localhost (default any IPv4 and/or IPv6)
    host =&gt; 'localhost/IPv*',  # same
    ipv  =&gt; 6,
    host =&gt; 'localhost',  # addresses matched by localhost (IPv6)
    ipv  =&gt; 4,
    host =&gt; 'localhost',  # addresses matched by localhost (IPv4)
    ipv  =&gt; 'IPv4 IPv6',
    host =&gt; 'localhost',  # addresses matched by localhost (requires IPv6 and IPv4)
    host =&gt; '*',          # any local interfaces (any IPv6 or IPv4)
    host =&gt; '*/IPv*',     # same (any IPv6 or IPv4)
    ipv  =&gt; 4,
    host =&gt; '*',          # any local IPv4 interfaces interfaces
    </pre>
  </dd>
  <dt id="proto"><a class="permalink" href="#proto">proto</a></dt>
  <dd>See Net::Server::Proto. Protocol to use when binding ports. See
      IO::Socket. As of release 2.0, Net::Server supports tcp, udp, and unix,
      unixdgram, ssl, and ssleay. Other types will need to be added later (or
      custom modules extending the Net::Server::Proto class may be used).
      Configuration passed to new or run may be either a scalar containing a
      single proto or an arrayref of protos - if the protos array is shorter
      than the ports array, the last proto entry will be used to augment the
      protos arrary to the size of the ports array.
    <p class="Pp">Additionally the proto may also contain the ipv
      specification.</p>
  </dd>
  <dt id="ipv"><a class="permalink" href="#ipv">ipv (IPv4 and IPv6)</a></dt>
  <dd>See Net::Server::Proto.
    <p class="Pp">IPv6 is now available under Net::Server. It will be used
        automatically if an IPv6 address is passed, or if the ipv is set
        explicitly to IPv6, or if ipv is left as the default value of IPv*. This
        is a significant change from version 2.004 and earlier where the default
        value was IPv4. However, the previous behavior led to confusion on IPv6
        only hosts, and on hosts that only had IPv6 entries for a local
        hostname. Trying to pass an IPv4 address when ipv is set to 6 (only 6 -
        not * or 4) will result in an error.</p>
    <p class="Pp"></p>
    <pre>    localhost:20203 # will use IPv6 if there is a corresponding entry for localhost
                    # it will also use IPv4 if there is a corresponding v4 entry for localhost
    localhost:20203:IPv*  # same (default)
    localhost:20203:IPv6  # will use IPv6
    [::1]:20203           # will use IPv6 (IPv6 style address)
    localhost:20203:IPv4  # will use IPv4
    127.0.0.1:20203       # will use IPv4 (IPv4 style address
    localhost:20203:IPv4:IPv6 # will bind to both v4 and v6 - fails otherwise
    # or as a hashref as
    port =&gt; {
        host =&gt; &quot;localhost&quot;,
        ipv  =&gt; 6, # only binds IPv6
    }
    port =&gt; {
        host =&gt; &quot;localhost&quot;,
        ipv  =&gt; 4, # only binds IPv4
    }
    port =&gt; {
        host =&gt; &quot;::1&quot;,
        ipv  =&gt; &quot;IPv6&quot;, # same as passing &quot;6&quot;
    }
    port =&gt; {
        host =&gt; &quot;localhost/IPv*&quot;,       # any IPv4 or IPv6
    }
    port =&gt; {
        host =&gt; &quot;localhost IPv4 IPv6&quot;,  # must create both
    }
    </pre>
    <p class="Pp">In many proposed Net::Server solutions, IPv* was enabled by
        default. For versions 2.000 through 2.004, the previous default of IPv4
        was used. We have attempted to make it easy to set IPv4, IPv6, or IPv*.
        If you do not want or need IPv6, simply set ipv to 4, pass IPv4 along in
        the port specification, set <span class="Li">$ENV</span>{'IPV'}=4;
        before running the server, or uninstall IO::Socket::INET6.</p>
    <p class="Pp">On my local box the following command results in the following
        output:</p>
    <p class="Pp"></p>
    <pre>    perl -e 'use base qw(Net::Server); main-&gt;run(host =&gt; &quot;localhost&quot;)'
    Resolved [localhost]:20203 to [::1]:20203, IPv6
    Resolved [localhost]:20203 to [127.0.0.1]:20203, IPv4
    Binding to TCP port 20203 on host ::1 with IPv6
    Binding to TCP port 20203 on host 127.0.0.1 with IPv4
    </pre>
    <p class="Pp">My local box has IPv6 enabled and there are entries for
        localhost on both IPv6 ::1 and IPv4 127.0.0.1. I could also choose to
        explicitly bind ports rather than depending upon ipv =&gt; &quot;*&quot;
        to resolve them for me as in the following:</p>
    <p class="Pp"></p>
    <pre>    perl -e 'use base qw(Net::Server); main-&gt;run(port =&gt; [20203,20203], host =&gt; &quot;localhost&quot;, ipv =&gt; [4,6])'
    Binding to TCP port 20203 on host localhost with IPv4
    Binding to TCP port 20203 on host localhost with IPv6
    </pre>
    <p class="Pp">There is a special case of using host =&gt; &quot;*&quot; as
        well as ipv =&gt; &quot;*&quot;. The Net::Server::Proto::_bindv6only
        method is used to check the system setting for
        <span class="Li">&quot;sysctl -n net.ipv6.bindv6only&quot;</span> (or
        net.inet6.ip6.v6only). If this setting is false, then an IPv6 socket
        will listen for the corresponding IPv4 address. For example the address
        [::] (IPv6 equivalent of INADDR_ANY) will also listen for 0.0.0.0. The
        address ::FFFF:127.0.0.1 (IPv6) would also listen to 127.0.0.1 (IPv4).
        In this case, only one socket will be created because it will handle
        both cases (an error is returned if an attempt is made to listen to both
        addresses when bindv6only is false).</p>
    <p class="Pp">However, if net.ipv6.bindv6only (or equivalent) is true, then
        a hostname (such as *) resolving to both a IPv4 entry as well as an IPv6
        will result in both an IPv4 socket as well as an IPv6 socket.</p>
    <p class="Pp">On my linux box which defaults to net.ipv6.bindv6only=0, the
        following is output.</p>
    <p class="Pp"></p>
    <pre>    perl -e 'use base qw(Net::Server); main-&gt;run(host =&gt; &quot;*&quot;)'
    Resolved [*]:8080 to [::]:8080, IPv6
    Not including resolved host [0.0.0.0] IPv4 because it will be handled by [::] IPv6
    Binding to TCP port 8080 on host :: with IPv6
    </pre>
    <p class="Pp">If I issue a <span class="Li">&quot;sudo /sbin/sysctl -w
        net.ipv6.bindv6only=1&quot;</span>, the following is output.</p>
    <p class="Pp"></p>
    <pre>    perl -e 'use base qw(Net::Server); main-&gt;run(host =&gt; &quot;*&quot;)'
    Resolved [*]:8080 to [0.0.0.0]:8080, IPv4
    Resolved [*]:8080 to [::]:8080, IPv6
    Binding to TCP port 8080 on host 0.0.0.0 with IPv4
    Binding to TCP port 8080 on host :: with IPv6
    </pre>
    <p class="Pp">BSD differs from linux and generally defaults to
        net.inet6.ip6.v6only=0. If it cannot be determined on your OS, it will
        default to false and the log message will change from &quot;it will be
        handled&quot; to &quot;it should be handled&quot; (if you have a
        non-resource intensive way to check on your platform, feel free to email
        me). Be sure to check the logs as you test your server to make sure you
        have bound the ports you desire. You can always pass in individual
        explicit IPv4 and IPv6 port specifications if you need. For example, if
        your system has both IPv4 and IPv6 interfaces but you'd only like to
        bind to IPv6 entries, then you should use a hostname of [::] instead of
        [*].</p>
    <p class="Pp">If bindv6only (or equivalent) is false, and you receive an
        IPv4 connection on a bound IPv6 port, the textual representation of the
        peer's IPv4 address will typically be in a form of an IPv4-mapped IPv6
        addresses, e.g. &quot;::FFFF:127.0.0.1&quot; .</p>
    <p class="Pp">The ipv parameter was chosen because it does not conflict with
        any other existing usage, it is very similar to ipv4 or ipv6, it allows
        for user code to not need to know about Socket::AF_INET or
        Socket6::AF_INET6 or Socket::AF_UNSPEC, and it is short.</p>
  </dd>
  <dt id="listen"><a class="permalink" href="#listen">listen</a></dt>
  <dd>See IO::Socket. Not used with udp protocol (or UNIX SOCK_DGRAM).</dd>
  <dt id="reverse_lookups"><a class="permalink" href="#reverse_lookups">reverse_lookups</a></dt>
  <dd>Specify whether to lookup the hostname of the connected IP. Information is
      cached in server object under <span class="Li">&quot;peerhost&quot;</span>
      property. Default is to not use reverse_lookups (undef).</dd>
  <dt id="allow/deny"><a class="permalink" href="#allow/deny">allow/deny</a></dt>
  <dd>May be specified multiple times. Contains regex to compare to incoming
      peeraddr or peerhost (if reverse_lookups has been enabled). If allow or
      deny options are given, the incoming client must match an allow and not
      match a deny or the client connection will be closed. Defaults to empty
      array refs.</dd>
  <dt id="cidr_allow/cidr_deny"><a class="permalink" href="#cidr_allow/cidr_deny">cidr_allow/cidr_deny</a></dt>
  <dd>May be specified multiple times. Contains a CIDR block to compare to
      incoming peeraddr. If cidr_allow or cidr_deny options are given, the
      incoming client must match a cidr_allow and not match a cidr_deny or the
      client connection will be closed. Defaults to empty array refs.</dd>
  <dt id="chroot"><a class="permalink" href="#chroot">chroot</a></dt>
  <dd>Directory to chroot to after bind process has taken place and the server
      is still running as root. Defaults to undef.</dd>
  <dt id="user"><a class="permalink" href="#user">user</a></dt>
  <dd>Userid or username to become after the bind process has occured. Defaults
      to &quot;nobody.&quot; If you would like the server to run as root, you
      will have to specify <span class="Li">&quot;user&quot;</span> equal to
      &quot;root&quot;.</dd>
  <dt id="group"><a class="permalink" href="#group">group</a></dt>
  <dd>Groupid or groupname to become after the bind process has occured.
      Defaults to &quot;nobody.&quot; If you would like the server to run as
      root, you will have to specify <span class="Li">&quot;group&quot;</span>
      equal to &quot;root&quot;.</dd>
  <dt id="background"><a class="permalink" href="#background">background</a></dt>
  <dd>Specifies whether or not the server should fork after the bind method to
      release itself from the command line. Defaults to undef. Process will also
      background if <span class="Li">&quot;setsid&quot;</span> is set.</dd>
  <dt id="setsid"><a class="permalink" href="#setsid">setsid</a></dt>
  <dd>Specifies whether or not the server should fork after the bind method to
      release itself from the command line and then run the
      <span class="Li">&quot;POSIX::setsid()&quot;</span> command to truly
      daemonize. Defaults to undef. If a
      <span class="Li">&quot;log_file&quot;</span> is given or if
      <span class="Li">&quot;setsid&quot;</span> is set, STDIN and STDOUT will
      automatically be opened to /dev/null and STDERR will be opened to STDOUT.
      This will prevent any output from ending up at the terminal.</dd>
  <dt id="no_close_by_child"><a class="permalink" href="#no_close_by_child">no_close_by_child</a></dt>
  <dd>Boolean. Specifies whether or not a forked child process has permission or
      not to shutdown the entire server process. If set to 1, the child may NOT
      signal the parent to shutdown all children. Default is undef (not
    set).</dd>
  <dt id="no_client_stdout"><a class="permalink" href="#no_client_stdout">no_client_stdout</a></dt>
  <dd>Boolean. Default undef (not set). Specifies that STDIN and STDOUT should
      not be opened on the client handle once a connection has been accepted. By
      default the Net::Server will open STDIN and STDOUT on the client socket
      making it easier for many types of scripts to read directly from and write
      directly to the socket using normal print and read methods. Disabling this
      is useful on clients that may be opening their own connections to STDIN
      and STDOUT.
    <p class="Pp">This option has no affect on STDIN and STDOUT which has a
        magic client property that is tied to the already open STDIN and
      STDOUT.</p>
  </dd>
  <dt id="leave_children_open_on_hup"><a class="permalink" href="#leave_children_open_on_hup">leave_children_open_on_hup</a></dt>
  <dd>Boolean. Default undef (not set). If set, the parent will not attempt to
      close child processes if the parent receives a SIG HUP. The parent will
      rebind the the open port and begin tracking a fresh set of children.
    <p class="Pp">Children of a Fork server will exit after their current
        request. Children of a Prefork type server will finish the current
        request and then exit.</p>
    <p class="Pp">Note - the newly restarted parent will start up a fresh set of
        servers on fork servers. The new parent will attempt to keep track of
        the children from the former parent but custom communication channels
        (open pipes from the child to the old parent) will no longer be
        available to the old child processes. New child processes will still
        connect properly to the new parent.</p>
  </dd>
  <dt id="sig_passthrough"><a class="permalink" href="#sig_passthrough">sig_passthrough</a></dt>
  <dd>Default none. Allow for passing requested signals through to children.
      Takes a single signal name, a comma separated list of names, or an
      arrayref of signal names. It first sends the signals to the children
      before calling any currently registered signal by that name.</dd>
  <dt id="tie_client_stdout"><a class="permalink" href="#tie_client_stdout">tie_client_stdout</a></dt>
  <dd>Default undef. If set will use Net::Server::TiedHandle tied interface for
      STDIN and STDOUT. This interface allows SSL and SSLEAY to work. It also
      allows for intercepting read and write via the tied_stdin_callback and
      tied_stdout_callback.</dd>
  <dt id="tied_stdin_callback"><a class="permalink" href="#tied_stdin_callback">tied_stdin_callback</a></dt>
  <dd>Default undef. Called during a read of STDIN data if tie_client_stdout has
      been set, or if the client handle's tie_stdout method returns true. It is
      passed the client connection, the name of the method that would be called,
      and the arguments that are being passed. The callback is then responsible
      for calling that method on the handle or for performing some other input
      operation.</dd>
  <dt id="tied_stdout_callback"><a class="permalink" href="#tied_stdout_callback">tied_stdout_callback</a></dt>
  <dd>Default undef. Called during a write of data to STDOUT if
      tie_client_stdout has been set, or if the client handle's tie_stdout
      method returns true. It is passed the client connection, the name of the
      method that would be called, and the arguments that are being passed. The
      callback is then responsible for calling that method on the handle or for
      performing some other output operation.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="PROPERTIES"><a class="permalink" href="#PROPERTIES">PROPERTIES</a></h1>
<p class="Pp">All of the <span class="Li">&quot;ARGUMENTS&quot;</span> listed
    above become properties of the server object under the same name. These
    properties, as well as other internal properties, are available during hooks
    and other method calls.</p>
<p class="Pp">The structure of a Net::Server object is shown below:</p>
<p class="Pp"></p>
<pre>    $self = bless({
        server =&gt; {
            key1 =&gt; 'val1',
            # more key/vals
        },
    }, 'Net::Server');
</pre>
<p class="Pp">This structure was chosen so that all server related properties
    are grouped under a single key of the object hashref. This is so that other
    objects could layer on top of the Net::Server object class and still have a
    fairly clean namespace in the hashref.</p>
<p class="Pp">You may get and set properties in two ways. The suggested way is
    to access properties directly via</p>
<p class="Pp"></p>
<pre>    my $val = $self-&gt;{server}-&gt;{key1};
</pre>
<p class="Pp">Accessing the properties directly will speed the server process -
    though some would deem this as bad style. A second way has been provided for
    object oriented types who believe in methods. The second way consists of the
    following methods:</p>
<p class="Pp"></p>
<pre>    my $val = $self-&gt;get_property( 'key1' );
    my $self-&gt;set_property( key1 =&gt; 'val1' );
</pre>
<p class="Pp">Properties are allowed to be changed at any time with caution
    (please do not undef the sock property or you will close the client
    connection).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONFIGURATION_FILE"><a class="permalink" href="#CONFIGURATION_FILE">CONFIGURATION
  FILE</a></h1>
<p class="Pp"><span class="Li">&quot;Net::Server&quot;</span> allows for the use
    of a configuration file to read in server parameters. The format of this
    conf file is simple key value pairs. Comments and blank lines are
  ignored.</p>
<p class="Pp"></p>
<pre>    #-------------- file test.conf --------------
    ### user and group to become
    user        somebody
    group       everybody
    # logging ?
    log_file    /var/log/server.log
    log_level   3
    pid_file    /tmp/server.pid
    # optional syslog directive
    # used in place of log_file above
    #log_file       Sys::Syslog
    #syslog_logsock unix
    #syslog_ident   myserver
    #syslog_logopt  pid|cons
    # access control
    allow       .+\.(net|com)
    allow       domain\.com
    deny        a.+
    cidr_allow  127.0.0.0/8
    cidr_allow  192.0.2.0/24
    cidr_deny   192.0.2.4/30
    # background the process?
    background  1
    # ports to bind (this should bind
    # 127.0.0.1:20205 on IPv6 and
    # localhost:20204 on IPv4)
    # See Net::Server::Proto
    host        127.0.0.1
    ipv         IPv6
    port        localhost:20204/IPv4
    port        20205
    # reverse lookups ?
    # reverse_lookups on
  #-------------- file test.conf --------------
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="PROCESS_FLOW"><a class="permalink" href="#PROCESS_FLOW">PROCESS
  FLOW</a></h1>
<p class="Pp">The process flow is written in an open, easy to override, easy to
    hook, fashion. The basic flow is shown below. This is the flow of the
    <span class="Li">&quot;$self-&gt;run&quot;</span> method.</p>
<p class="Pp"></p>
<pre>    $self-&gt;configure_hook;
    $self-&gt;configure(@_);
    $self-&gt;post_configure;
    $self-&gt;post_configure_hook;
    $self-&gt;pre_bind;
    $self-&gt;bind;
    $self-&gt;post_bind_hook;
    $self-&gt;post_bind;
    $self-&gt;pre_loop_hook;
    $self-&gt;loop;
    ### routines inside a standard $self-&gt;loop
    # $self-&gt;accept;
    # $self-&gt;run_client_connection;
    # $self-&gt;done;
    $self-&gt;pre_server_close_hook;
    $self-&gt;server_close;
</pre>
<p class="Pp">The server then exits.</p>
<p class="Pp">During the client processing phase
    (<span class="Li">&quot;$self-&gt;run_client_connection&quot;</span>), the
    following represents the program flow:</p>
<p class="Pp"></p>
<pre>    $self-&gt;post_accept;
    $self-&gt;get_client_info;
    $self-&gt;post_accept_hook;
    if ($self-&gt;allow_deny
        &amp;&amp; $self-&gt;allow_deny_hook) {
        $self-&gt;process_request;
    } else {
        $self-&gt;request_denied_hook;
    }
    $self-&gt;post_process_request_hook;
    $self-&gt;post_process_request;
    $self-&gt;post_client_connection_hook;
</pre>
<p class="Pp">The process then loops and waits for the next connection. For a
    more in depth discussion, please read the code.</p>
<p class="Pp">During the server shutdown phase
    (<span class="Li">&quot;$self-&gt;server_close&quot;</span>), the following
    represents the program flow:</p>
<p class="Pp"></p>
<pre>    $self-&gt;close_children;  # if any
    $self-&gt;post_child_cleanup_hook;
    if (Restarting server) {
        $self-&gt;restart_close_hook();
        $self-&gt;hup_server;
    }
    $self-&gt;shutdown_sockets;
    $self-&gt;server_exit;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="MAIN_SERVER_METHODS"><a class="permalink" href="#MAIN_SERVER_METHODS">MAIN
  SERVER METHODS</a></h1>
<dl class="Bl-tag">
  <dt>&quot;$self-&gt;run&quot;</dt>
  <dd>This method incorporates the main process flow. This flow is listed above.
    <p class="Pp">The method run may be called in any of the following ways.</p>
    <p class="Pp"></p>
    <pre>     MyPackage-&gt;run(port =&gt; 20201);
     MyPackage-&gt;new({port =&gt; 20201})-&gt;run;
     my $obj = bless {server=&gt;{port =&gt; 20201}}, 'MyPackage';
     $obj-&gt;run;
    </pre>
    <p class="Pp">The -&gt;run method should typically be the last method called
        in a server start script (the server will exit at the end of the
        -&gt;run method).</p>
  </dd>
  <dt>&quot;$self-&gt;configure&quot;</dt>
  <dd>This method attempts to read configurations from the commandline, from the
      run method call, or from a specified conf_file (the conf_file may be
      specified by passed in parameters, or in the default_values). All of the
      configured parameters are then stored in the {&quot;server&quot;} property
      of the Server object.</dd>
  <dt>&quot;$self-&gt;post_configure&quot;</dt>
  <dd>The post_configure hook begins the startup of the server. During this
      method running server instances are checked for, pid_files are created,
      log_files are created, Sys::Syslog is initialized (as needed), process
      backgrounding occurs and the server closes STDIN and STDOUT (as
    needed).</dd>
  <dt>&quot;$self-&gt;pre_bind&quot;</dt>
  <dd>This method is used to initialize all of the socket objects used by the
      server.</dd>
  <dt>&quot;$self-&gt;bind&quot;</dt>
  <dd>This method actually binds to the inialized sockets (or rebinds if the
      server has been HUPed).</dd>
  <dt>&quot;$self-&gt;post_bind&quot;</dt>
  <dd>During this method priveleges are dropped. The INT, TERM, and QUIT signals
      are set to run server_close. Sig PIPE is set to IGNORE. Sig CHLD is set to
      sig_chld. And sig HUP is set to call sig_hup.
    <p class="Pp">Under the Fork, PreFork, and PreFork simple personalities,
        these signals are registered using Net::Server::SIG to allow for safe
        signal handling.</p>
  </dd>
  <dt>&quot;$self-&gt;loop&quot;</dt>
  <dd>During this phase, the server accepts incoming connections. The behavior
      of how the accepting occurs and if a child process handles the connection
      is controlled by what type of Net::Server personality the server is using.
    <p class="Pp">Net::Server and Net::Server single accept only one connection
        at a time.</p>
    <p class="Pp">Net::Server::INET runs one connection and then exits (for use
        by inetd or xinetd daemons).</p>
    <p class="Pp">Net::Server::MultiPlex allows for one process to
        simultaneously handle multiple connections (but requires rewriting the
        process_request code to operate in a more &quot;packet-like&quot;
        manner).</p>
    <p class="Pp">Net::Server::Fork forks off a new child process for each
        incoming connection.</p>
    <p class="Pp">Net::Server::PreForkSimple starts up a fixed number of
        processes that all accept on incoming connections.</p>
    <p class="Pp">Net::Server::PreFork starts up a base number of child
        processes which all accept on incoming connections. The server throttles
        the number of processes running depending upon the number of requests
        coming in (similar to concept to how Apache controls its child processes
        in a PreFork server).</p>
    <p class="Pp">Read the documentation for each of the types for more
        information.</p>
  </dd>
  <dt>&quot;$self-&gt;server_close&quot;</dt>
  <dd>This method is called once the server has been signaled to end, or
      signaled for the server to restart (via HUP), or the loop method has been
      exited.
    <p class="Pp">This method takes care of cleaning up any remaining child
        processes, setting appropriate flags on sockets (for HUPing), closing up
        logging, and then closing open sockets.</p>
    <p class="Pp">Can optionally be passed an exit value that will be passed to
        the server_exit call.</p>
  </dd>
  <dt>&quot;$self-&gt;server_exit&quot;</dt>
  <dd>This method is called at the end of server_close. It calls exit, but may
      be overridden to do other items. At this point all services should be shut
      down.
    <p class="Pp">Can optionally be passed an exit value that will be passed to
        the exit call.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="MAIN_CLIENT_CONNECTION_METHODS"><a class="permalink" href="#MAIN_CLIENT_CONNECTION_METHODS">MAIN
  CLIENT CONNECTION METHODS</a></h1>
<dl class="Bl-tag">
  <dt>&quot;$self-&gt;run_client_connection&quot;</dt>
  <dd>This method is run after the server has accepted and received a client
      connection. The full process flow is listed above under PROCESS FLOWS.
      This method takes care of handling each client connection.</dd>
  <dt>&quot;$self-&gt;post_accept&quot;</dt>
  <dd>This method opens STDIN and STDOUT to the client socket. This allows any
      of the methods during the run_client_connection phase to print directly to
      and read directly from the client socket.</dd>
  <dt>&quot;$self-&gt;get_client_info&quot;</dt>
  <dd>This method looks up information about the client connection such as ip
      address, socket type, and hostname (as needed).</dd>
  <dt>&quot;$self-&gt;allow_deny&quot;</dt>
  <dd>This method uses the rules defined in the allow and deny configuration
      parameters to determine if the ip address should be accepted.</dd>
  <dt>&quot;$self-&gt;process_request&quot;</dt>
  <dd>This method is intended to handle all of the client communication. At this
      point STDIN and STDOUT are opened to the client, the ip address has been
      verified. The server can then interact with the client connection
      according to whatever API or protocol the server is implementing. Note
      that the stub implementation uses STDIN and STDOUT and will not work if
      the no_client_stdout flag is set.
    <p class="Pp">This is the main method to override.</p>
    <p class="Pp">The default method implements a simple echo server that will
        repeat whatever is sent. It will quit the child if &quot;quit&quot; is
        sent, and will exit the server if &quot;exit&quot; is sent.</p>
    <p class="Pp">As of version 2.000, the client handle is passed as an
        argument.</p>
  </dd>
  <dt>&quot;$self-&gt;post_process_request&quot;</dt>
  <dd>This method is used to clean up the client connection and to handle any
      parent/child accounting for the forking servers.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="HOOKS"><a class="permalink" href="#HOOKS">HOOKS</a></h1>
<p class="Pp"><span class="Li">&quot;Net::Server&quot;</span> provides a number
    of &quot;hooks&quot; allowing for servers layered on top of
    <span class="Li">&quot;Net::Server&quot;</span> to respond at different
    levels of execution without having to &quot;SUPER&quot; class the main
    built-in methods. The placement of the hooks can be seen in the PROCESS FLOW
    section.</p>
<p class="Pp">Almost all of the default hook methods do nothing. To use a hook
    you simply need to override the method in your subclass. For example to add
    your own post_configure_hook you could do something like the following:</p>
<p class="Pp"></p>
<pre>    package MyServer;
    sub post_configure_hook {
        my $self = shift;
        my $prop = $self-&gt;{'server'};
        # do some validation here
    }
</pre>
<p class="Pp">The following describes the hooks available in the plain
    Net::Server class (other flavors such as Fork or PreFork have additional
    hooks).</p>
<dl class="Bl-tag">
  <dt>&quot;$self-&gt;configure_hook()&quot;</dt>
  <dd>This hook takes place immediately after the
      <span class="Li">&quot;-&gt;run()&quot;</span> method is called. This hook
      allows for setting up the object before any built in configuration takes
      place. This allows for custom configurability.</dd>
  <dt>&quot;$self-&gt;post_configure_hook()&quot;</dt>
  <dd>This hook occurs just after the reading of configuration parameters and
      initiation of logging and pid_file creation. It also occurs before the
      <span class="Li">&quot;-&gt;pre_bind()&quot;</span> and
      <span class="Li">&quot;-&gt;bind()&quot;</span> methods are called. This
      hook allows for verifying configuration parameters.</dd>
  <dt>&quot;$self-&gt;post_bind_hook()&quot;</dt>
  <dd>This hook occurs just after the bind process and just before any
      chrooting, change of user, or change of group occurs. At this point the
      process will still be running as the user who started the server.</dd>
  <dt>&quot;$self-&gt;pre_loop_hook()&quot;</dt>
  <dd>This hook occurs after chroot, change of user, and change of group has
      occured. It allows for preparation before looping begins.</dd>
  <dt>&quot;$self-&gt;can_read_hook()&quot;</dt>
  <dd>This hook occurs after a socket becomes readible on an accept_multi_port
      request (accept_multi_port is used if there are multiple bound ports to
      accept on, or if the &quot;multi_port&quot; configuration parameter is set
      to true). This hook is intended to allow for processing of arbitrary
      handles added to the IO::Select used for the accept_multi_port. These
      handles could be added during the post_bind_hook. No internal support is
      added for processing these handles or adding them to the IO::Socket. Care
      must be used in how much occurs during the can_read_hook as a long
      response time will result in the server being susceptible to DOS attacks.
      A return value of true indicates that the Server should not pass the
      readible handle on to the post_accept and process_request phases.
    <p class="Pp">It is generally suggested that other avenues be pursued for
        sending messages via sockets not created by the Net::Server.</p>
  </dd>
  <dt>&quot;$self-&gt;post_accept_hook()&quot;</dt>
  <dd>This hook occurs after a client has connected to the server. At this point
      STDIN and STDOUT are mapped to the client socket. This hook occurs before
      the processing of the request.</dd>
  <dt>&quot;$self-&gt;allow_deny_hook()&quot;</dt>
  <dd>This hook allows for the checking of ip and host information beyond the
      <span class="Li">&quot;$self-&gt;allow_deny()&quot;</span> routine. If
      this hook returns 1, the client request will be processed, otherwise, the
      request will be denied processing.
    <p class="Pp">As of version 2.000, the client connection is passed as an
        argument.</p>
  </dd>
  <dt>&quot;$self-&gt;request_denied_hook()&quot;</dt>
  <dd>This hook occurs if either the
      <span class="Li">&quot;$self-&gt;allow_deny()&quot;</span> or
      <span class="Li">&quot;$self-&gt;allow_deny_hook()&quot;</span> have taken
      place.</dd>
  <dt>&quot;$self-&gt;post_process_request_hook()&quot;</dt>
  <dd>This hook occurs after the processing of the request, but before the
      client connection has been closed.</dd>
  <dt>&quot;$self-&gt;post_client_connection_hook&quot;</dt>
  <dd>This is one final hook that occurs at the very end of the
      run_client_connection method. At this point all other methods and hooks
      that will run during the run_client_connection have finished and the
      client connection has already been closed.
    <p class="Pp">item
        <span class="Li">&quot;$self-&gt;other_child_died_hook($pid)&quot;</span></p>
    <p class="Pp">Net::Server takes control of signal handling and child process
        cleanup; this makes it difficult to tell when a child process terminates
        if that child process was not started by Net::Server itself. If
        Net::Server notices another child process dying that it did not start,
        it will fire this hook with the PID of the terminated process.</p>
  </dd>
  <dt>&quot;$self-&gt;pre_server_close_hook()&quot;</dt>
  <dd>This hook occurs before the server begins shutting down.</dd>
  <dt>&quot;$self-&gt;write_to_log_hook&quot;</dt>
  <dd>This hook handles writing to log files. The default hook is to write to
      STDERR, or to the filename contained in the parameter
      <span class="Li">&quot;log_file&quot;</span>. The arguments passed are a
      log level of 0 to 4 (4 being very verbose), and a log line. If log_file is
      equal to &quot;Sys::Syslog&quot;, then logging will go to Sys::Syslog and
      will bypass the write_to_log_hook.</dd>
  <dt>&quot;$self-&gt;fatal_hook&quot;</dt>
  <dd>This hook occurs when the server has encountered an unrecoverable error.
      Arguments passed are the error message, the package, file, and line
      number. The hook may close the server, but it is suggested that it simply
      return and use the built in shut down features.</dd>
  <dt>&quot;$self-&gt;post_child_cleanup_hook&quot;</dt>
  <dd>This hook occurs in the parent server process after all children have been
      shut down and just before the server either restarts or exits. It is
      intended for additional cleanup of information. At this point pid_files
      and lockfiles still exist.</dd>
  <dt>&quot;$self-&gt;restart_open_hook&quot;</dt>
  <dd>This hook occurs if a server has been HUPed (restarted via the HUP signal.
      It occurs just before reopening to the filenos of the sockets that were
      already opened.</dd>
  <dt>&quot;$self-&gt;restart_close_hook&quot;</dt>
  <dd>This hook occurs if a server has been HUPed (restarted via the HUP signal.
      It occurs just before restarting the server via exec.</dd>
  <dt>&quot;$self-&gt;child_init_hook()&quot;</dt>
  <dd>This hook is called during the forking servers. It is also called during
      run_dequeue. It runs just after the fork and after signals have been
      cleaned up. If it is a dequeue process, the string 'dequeue' will be
      passed as an argument.
    <p class="Pp">If your child processes will be needing random numbers, this
        hook is a good location to initialize srand (forked processes maintain
        the same random seed unless changed).</p>
    <p class="Pp"></p>
    <pre>    sub child_init_hook {
        # from perldoc -f srand
        srand(time ^ $$ ^ unpack &quot;%L*&quot;, `ps axww | gzip -f`);
    }
    </pre>
  </dd>
  <dt>&quot;$self-&gt;pre_fork_hook()&quot;</dt>
  <dd>Similar to the child_init_hook, but occurs just before the fork.</dd>
  <dt>&quot;$self-&gt;child_finish_hook()&quot;</dt>
  <dd>Similar to the child_init_hook, but ran when the forked process is about
      to finish up.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="OTHER_METHODS"><a class="permalink" href="#OTHER_METHODS">OTHER
  METHODS</a></h1>
<dl class="Bl-tag">
  <dt>&quot;$self-&gt;default_values&quot;</dt>
  <dd>Allow for returning configuration values that will be used if no other
      value could be found.
    <p class="Pp">Should return a hashref.</p>
    <p class="Pp"></p>
    <pre>    sub default_values {
        return {
            port =&gt; 20201,
        };
    }
    </pre>
  </dd>
  <dt>&quot;$self-&gt;handle_syslog_error&quot;</dt>
  <dd>Called when log_file is set to 'Sys::Syslog' and an error occurs while
      writing to the syslog. It is passed two arguments, the value of $@, and an
      arrayref containing the arguments that were passed to the log method when
      the error occured.</dd>
  <dt>&quot;$self-&gt;log&quot;</dt>
  <dd>Parameters are a log_level and a message.
    <p class="Pp">If log_level is set to 'Sys::Syslog', the parameters may
        alternately be a log_level, a format string, and format string
        parameters. (The second parameter is assumed to be a format string if
        additional arguments are passed along). Passing arbitrary format strings
        to Sys::Syslog will allow the server to be vulnerable to exploit. The
        server maintainer should make sure that any string treated as a format
        string is controlled.</p>
    <p class="Pp"></p>
    <pre>    # assuming log_file = 'Sys::Syslog'
    $self-&gt;log(1, &quot;My Message with %s in it&quot;);
    # sends &quot;%s&quot;, &quot;My Message with %s in it&quot; to syslog
    $self-&gt;log(1, &quot;My Message with %s in it&quot;, &quot;Foo&quot;);
    # sends &quot;My Message with %s in it&quot;, &quot;Foo&quot; to syslog
    </pre>
    <p class="Pp">If log_file is set to a file (other than Sys::Syslog), the
        message will be appended to the log file by calling the
        write_to_log_hook.</p>
    <p class="Pp">If the log_file is Sys::Syslog and an error occurs during
        write, the handle_syslog_error method will be called and passed the
        error exception. The default option of handle_syslog_error is to die -
        but could easily be told to do nothing by using the following code in
        your subclassed server:</p>
    <p class="Pp"></p>
    <pre>    sub handle_syslog_error {}
    </pre>
    <p class="Pp">It the log had been closed, you could attempt to reopen it in
        the error handler with the following code:</p>
    <p class="Pp"></p>
    <pre>    sub handle_syslog_error {
        my $self = shift;
        $self-&gt;open_syslog;
    }
    </pre>
  </dd>
  <dt>&quot;$self-&gt;new&quot;</dt>
  <dd>As of Net::Server 0.91 there is finally a &quot;new&quot; method. This
      method takes a class name and an argument hashref as parameters. The
      argument hashref becomes the &quot;server&quot; property of the object.
    <p class="Pp"></p>
    <pre>    package MyPackage;
    use base qw(Net::Server);
    my $obj = MyPackage-&gt;new({port =&gt; 20201});
    # same as
    my $obj = bless {server =&gt; {port =&gt; 20201}}, 'MyPackage';
    </pre>
  </dd>
  <dt>&quot;$self-&gt;open_syslog&quot;</dt>
  <dd>Called during post_configure when the log_file option is set to
      'Sys::Syslog'. By default it use the parsed configuration options listed
      in this document. If more custom behavior is desired, the method could be
      overridden and Sys::Syslog::openlog should be called with the custom
      parameters.</dd>
  <dt>&quot;$self-&gt;shutdown_sockets&quot;</dt>
  <dd>This method will close any remaining open sockets. This is called at the
      end of the server_close method.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="RESTARTING"><a class="permalink" href="#RESTARTING">RESTARTING</a></h1>
<p class="Pp">Each of the server personalities (except for INET), support
    restarting via a HUP signal (see &quot;kill -l&quot;). When a HUP is
    received, the server will close children (if any), make sure that sockets
    are left open, and re-exec using the same commandline parameters that
    initially started the server. (Note: for this reason it is important that
    <span class="Li">@ARGV</span> is not modified until
    <span class="Li">&quot;-&gt;run&quot;</span> is called).</p>
<p class="Pp">The Net::Server will attempt to find out the commandline used for
    starting the program. The attempt is made before any configuration files or
    other arguments are processed. The outcome of this attempt is stored using
    the method <span class="Li">&quot;-&gt;commandline&quot;</span>. The stored
    commandline may also be retrieved using the same method name. The stored
    contents will undoubtedly contain Tainted items that will cause the server
    to die during a restart when using the -T flag (Taint mode). As it is
    impossible to arbitrarily decide what is taint safe and what is not, the
    individual program must clean up the tainted items before doing a
  restart.</p>
<p class="Pp"></p>
<pre>    sub configure_hook{
        my $self = shift;
        ### see the contents
        my $ref  = $self-&gt;commandline;
        use Data::Dumper;
        print Dumper $ref;
        ### arbitrary untainting - VERY dangerous
        my @untainted = map {/(.+)/;$1} @$ref;
        $self-&gt;commandline(\@untainted)
    }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SHUTDOWN"><a class="permalink" href="#SHUTDOWN">SHUTDOWN</a></h1>
<p class="Pp">Each of the Fork and PreFork personalities support graceful
    shutdowns via the QUIT signal. When a QUIT is received, the parent will
    signal the children and then wait for them to exit.</p>
<p class="Pp">All server personalities support the normal TERM and INT signal
    shutdowns.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="HOT_DEPLOY"><a class="permalink" href="#HOT_DEPLOY">HOT
  DEPLOY</a></h1>
<p class="Pp">Since version 2.000, the Fork and PreFork personalities have
    accepted the TTIN and TTOU signals. When a TTIN is received, the max_servers
    is increased by 1. If a TTOU signal is received the max_servers is decreased
    by 1. This allows for adjusting the number of handling processes without
    having to restart the server.</p>
<p class="Pp">If the log_level is set to at 3, then the new value is displayed
    in the logs.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FILES"><a class="permalink" href="#FILES">FILES</a></h1>
<p class="Pp">The following files are installed as part of this
  distribution.</p>
<p class="Pp"></p>
<pre>    Net/Server.pm
    Net/Server/Fork.pm
    Net/Server/INET.pm
    Net/Server/MultiType.pm
    Net/Server/PreForkSimple.pm
    Net/Server/PreFork.pm
    Net/Server/Single.pm
    Net/Server/Daemonize.pm
    Net/Server/SIG.pm
    Net/Server/Proto.pm
    Net/Server/Proto/*.pm
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="INSTALL"><a class="permalink" href="#INSTALL">INSTALL</a></h1>
<p class="Pp">Download and extract tarball before running these commands in its
    base directory:</p>
<p class="Pp"></p>
<pre>    perl Makefile.PL
    make
    make test
    make install
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Paul Seamons &lt;paul at seamons.com&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="THANKS"><a class="permalink" href="#THANKS">THANKS</a></h1>
<p class="Pp">As we move to a github flow, please be sure to add yourself to the
    credits as patches are passed along (if you'd like to be mentioned).</p>
<p class="Pp">Thanks to Rob Brown (bbb at cpan.org) for help with miscellaneous
    concepts such as tracking down the serialized select via flock ala Apache
    and the reference to IO::Select making multiport servers possible. And for
    researching into allowing sockets to remain open upon exec (making HUP
    possible).</p>
<p class="Pp">Thanks to Jonathan J. Miner &lt;miner at doit.wisc.edu&gt; for
    patching a blatant problem in the reverse lookups.</p>
<p class="Pp">Thanks to Bennett Todd &lt;bet at rahul.net&gt; for pointing out a
    problem in Solaris 2.5.1 which does not allow multiple children to accept on
    the same port at the same time. Also for showing some sample code from
    Viktor Duchovni which now represents the semaphore option of the serialize
    argument in the PreFork server.</p>
<p class="Pp">Thanks to <i>traveler</i> and <i>merlyn</i> from
    http://perlmonks.org for pointing me in the right direction for determining
    the protocol used on a socket connection.</p>
<p class="Pp">Thanks to Jeremy Howard &lt;j+daemonize at howard.fm&gt; for
    numerous suggestions and for work on Net::Server::Daemonize.</p>
<p class="Pp">Thanks to Vadim &lt;vadim at hardison.net&gt; for patches to
    implement parent/child communication on PreFork.pm.</p>
<p class="Pp">Thanks to Carl Lewis for suggesting &quot;-&quot; in user
  names.</p>
<p class="Pp">Thanks to Slaven Rezic for suggesing Reuse =&gt; 1 in
  Proto::UDP.</p>
<p class="Pp">Thanks to Tim Watt for adding udp_broadcast to Proto::UDP.</p>
<p class="Pp">Thanks to Christopher A Bongaarts for pointing out problems with
    the Proto::SSL implementation that currently locks around the socket accept
    and the SSL negotiation. See Net::Server::Proto::SSL.</p>
<p class="Pp">Thanks to Alessandro Zummo for pointing out various bugs including
    some in configuration, commandline args, and cidr_allow.</p>
<p class="Pp">Thanks to various other people for bug fixes over the years. These
    and future thank-you's are available in the Changes file as well as CVS
    comments.</p>
<p class="Pp">Thanks to Ben Cohen and tye (on Permonks) for finding and
    diagnosing more correct behavior for dealing with re-opening STDIN and
    STDOUT on the client handles.</p>
<p class="Pp">Thanks to Mark Martinec for trouble shooting other problems with
    STDIN and STDOUT (he proposed having a flag that is now the no_client_stdout
    flag).</p>
<p class="Pp">Thanks to David (DSCHWEI) on cpan for asking for the nofatal
    option with syslog.</p>
<p class="Pp">Thanks to Andreas Kippnick and Peter Beckman for suggesting
    leaving open child connections open during a HUP (this is now available via
    the leave_children_open_on_hup flag).</p>
<p class="Pp">Thanks to LUPE on cpan for helping patch HUP with taint on.</p>
<p class="Pp">Thanks to Michael Virnstein for fixing a bug in the check_for_dead
    section of PreFork server.</p>
<p class="Pp">Thanks to Rob Mueller for patching PreForkSimple to only open
    lock_file once during parent call. This patch should be portable on systems
    supporting flock. Rob also suggested not closing STDIN/STDOUT but instead
    reopening them to /dev/null to prevent spurious warnings. Also suggested
    short circuit in post_accept if in UDP. Also for cleaning up some of the
    child managment code of PreFork.</p>
<p class="Pp">Thanks to Mark Martinec for suggesting additional log messages for
    failure during accept.</p>
<p class="Pp">Thanks to Bill Nesbitt and Carlos Velasco for pointing out double
    decrement bug in PreFork.pm (rt #21271)</p>
<p class="Pp">Thanks to John W. Krahn for pointing out glaring precended with
    non-parened open and ||.</p>
<p class="Pp">Thanks to Ricardo Signes for pointing out setuid bug for perl
    5.6.1 (rt #21262).</p>
<p class="Pp">Thanks to Carlos Velasco for updating the Syslog options (rt
    #21265). And for additional fixes later.</p>
<p class="Pp">Thanks to Steven Lembark for pointing out that no_client_stdout
    wasn't working with the Multiplex server.</p>
<p class="Pp">Thanks to Peter Beckman for suggesting allowing Sys::SysLog
    keyworks be passed through the -&gt;log method and for suggesting we allow
    more types of characters through in syslog_ident. Also to Peter Beckman for
    pointing out that a poorly setup localhost will cause tests to hang.</p>
<p class="Pp">Thanks to Curtis Wilbar for pointing out that the Fork server
    called post_accept_hook twice. Changed to only let the child process call
    this, but added the pre_fork_hook method.</p>
<p class="Pp">And just a general Thanks You to everybody who is using
    Net::Server or who has contributed fixes over the years.</p>
<p class="Pp">Thanks to Paul Miller for some -&gt;autoflush, FileHandle
  fixes.</p>
<p class="Pp">Thanks to Patrik Wallstrom for suggesting handling syslog errors
    better.</p>
<p class="Pp">Thanks again to Rob Mueller for more logic cleanup for child
    accounting in PreFork server.</p>
<p class="Pp">Thanks to David Schweikert for suggesting handling setlogsock a
    little better on newer versions of Sys::Syslog (&gt;= 0.15).</p>
<p class="Pp">Thanks to Mihail Nasedkin for suggesting adding a hook that is now
    called post_client_connection_hook.</p>
<p class="Pp">Thanks to Graham Barr for adding the ability to set the
    check_for_spawn and min_child_ttl settings of the PreFork server.</p>
<p class="Pp">Thanks to Daniel Kahn Gillmor for adding the
    other_child_died_hook.</p>
<p class="Pp">Thanks to Dominic Humphries for helping not kill pid files on
  HUP.</p>
<p class="Pp">Thanks to Kristoffer M&#x00F8;llerh&#x00F8;j for fixing UDP on
    Multiplex.</p>
<p class="Pp">Thanks to mishikal for patches for helping identify un-cleaned up
    children.</p>
<p class="Pp">Thanks to rpkelly and tim@retout for pointing out error in header
    regex of HTTP.</p>
<p class="Pp">Thanks to dmcbride for some basic HTTP parsing fixes, as well as
    for some broken tied handle fixes.</p>
<p class="Pp">Thanks to Gareth for pointing out glaring bug issues with broken
    pipe and semaphore serialization.</p>
<p class="Pp">Thanks to CATONE for sending the idea for arbitrary signal passing
    to children. (See the sig_passthrough option)</p>
<p class="Pp">Thanks to intrigeri@boum for pointing out and giving code ideas
    for NS_port not functioning after a HUP.</p>
<p class="Pp">Thanks to Sergey Zasenko for adding sysread/syswrite support to
    SSLEAY as well as the base test.</p>
<p class="Pp">Thanks to mbarbon@users. for adding tally dequeue to prefork
    server.</p>
<p class="Pp">Thanks to stefanos@cpan for fixes to PreFork under Win32</p>
<p class="Pp">Thanks to Mark Martinec for much of the initial work towards
    getting IPv6 going.</p>
<p class="Pp">Thanks to the munin developers and Nicolai Langfeldt for hosting
    the development verion of Net::Server for so long and for fixes to the
    allow_deny checking for IPv6 addresses.</p>
<p class="Pp">Thanks to Tatsuhiko Miyagawa for feedback, and for suggesting
    adding graceful shutdowns and hot deploy (max_servers adjustment).</p>
<p class="Pp">Thanks to TONVOON@cpan for submitting a patch adding Log4perl
    functionality.</p>
<p class="Pp">Thanks to Miko O'Sullivan for fixes to HTTP to correct tainting
    issues and passing initial log fixes, and for patches to fix CLOSE on tied
    stdout and various other HTTP issues.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Please see also Net::Server::Fork, Net::Server::INET,
    Net::Server::PreForkSimple, Net::Server::PreFork, Net::Server::MultiType,
    Net::Server::Single Net::Server::HTTP</p>
</section>
<section class="Sh">
<h1 class="Sh" id="TODO"><a class="permalink" href="#TODO">TODO</a></h1>
<p class="Pp">Improve test suite to fully cover code (using Devel::Cover).
    Anybody that wanted to send me patches to the t/*.t tests that improved
    coverage would earn a big thank you.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CODE_REPOSITORY"><a class="permalink" href="#CODE_REPOSITORY">CODE
  REPOSITORY</a></h1>
<p class="Pp">https://github.com/rhandom/perl-net-server</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR~2"><a class="permalink" href="#AUTHOR~2">AUTHOR</a></h1>
<pre>    Paul Seamons &lt;paul at seamons.com&gt;
    http://seamons.com/
    Rob Brown &lt;bbb at cpan.org&gt;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">This package may be distributed under the terms of either the</p>
<p class="Pp"></p>
<pre>  GNU General Public License
    or the
  Perl Artistic License
</pre>
<p class="Pp">All rights reserved.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="POD_ERRORS"><a class="permalink" href="#POD_ERRORS">POD
  ERRORS</a></h1>
<p class="Pp">Hey! <b>The above document had some coding errors, which are
    explained below:</b></p>
<dl class="Bl-tag">
  <dt id="Around"><a class="permalink" href="#Around">Around line 1754:</a></dt>
  <dd>Non-ASCII character seen before =encoding in 'M&#x00F8;llerh&#x00F8;j'.
      Assuming UTF-8</dd>
</dl>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-08-10</td>
    <td class="foot-os"><a href="..">perl v5.34.0</a></td>
  </tr>
</table>
</body>
</html>

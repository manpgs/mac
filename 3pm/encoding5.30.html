<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>encoding(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">encoding(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">encoding(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">encoding - allows you to write your script in non-ASCII and
    non-UTF-8</p>
</section>
<section class="Sh">
<h1 class="Sh" id="WARNING"><a class="permalink" href="#WARNING">WARNING</a></h1>
<p class="Pp">This module has been deprecated since perl v5.18. See
    &quot;DESCRIPTION&quot; and &quot;BUGS&quot;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  use encoding &quot;greek&quot;;  # Perl like Greek to you?
  use encoding &quot;euc-jp&quot;; # Jperl!
  # or you can even do this if your shell supports your native encoding
  perl -Mencoding=latin2 -e'...' # Feeling centrally European?
  perl -Mencoding=euc-kr -e'...' # Or Korean?
  # more control
  # A simple euc-cn =&gt; utf-8 converter
  use encoding &quot;euc-cn&quot;, STDOUT =&gt; &quot;utf8&quot;;  while(&lt;&gt;){print};
  # &quot;no encoding;&quot; supported
  no encoding;
  # an alternate way, Filter
  use encoding &quot;euc-jp&quot;, Filter=&gt;1;
  # now you can use kanji identifiers -- in euc-jp!
  # encode based on the current locale - specialized purposes only;
  # fraught with danger!!
  use encoding ':locale';
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This pragma is used to enable a Perl script to be written in
    encodings that aren't strictly ASCII nor UTF-8. It translates all or
    portions of the Perl program script from a given encoding into UTF-8, and
    changes the PerlIO layers of <span class="Li">&quot;STDIN&quot;</span> and
    <span class="Li">&quot;STDOUT&quot;</span> to the encoding specified.</p>
<p class="Pp">This pragma dates from the days when UTF-8-enabled editors were
    uncommon. But that was long ago, and the need for it is greatly diminished.
    That, coupled with the fact that it doesn't work with threads, along with
    other problems, (see &quot;BUGS&quot;) have led to its being deprecated. It
    is planned to remove this pragma in a future Perl version. New code should
    be written in UTF-8, and the <span class="Li">&quot;use utf8&quot;</span>
    pragma used instead (see perluniintro and utf8 for details). Old code should
    be converted to UTF-8, via something like the recipe in the
    &quot;SYNOPSIS&quot; (though this simple approach may require manual
    adjustments afterwards).</p>
<p class="Pp">If UTF-8 is not an option, it is recommended that one use a simple
    source filter, such as that provided by Filter::Encoding on CPAN or this
    pragma's own <span class="Li">&quot;Filter&quot;</span> option (see
  below).</p>
<p class="Pp">The only legitimate use of this pragma is almost certainly just
    one per file, near the top, with file scope, as the file is likely going to
    only be written in one encoding. Further restrictions apply in Perls before
    v5.22 (see &quot;Prior to Perl v5.22&quot;).</p>
<p class="Pp">There are two basic modes of operation (plus turning if off):</p>
<dl class="Bl-tag">
  <dt>&quot;use encoding ['<i>ENCNAME</i>'] ;&quot;</dt>
  <dd>Please note: This mode of operation is no longer supported as of Perl
      v5.26.
    <p class="Pp">This is the normal operation. It translates various literals
        encountered in the Perl source file from the encoding <i>ENCNAME</i>
        into UTF-8, and similarly converts character code points. This is used
        when the script is a combination of ASCII (for the variable names and
        punctuation, <i>etc</i>), but the literal data is in the specified
        encoding.</p>
    <p class="Pp"><i>ENCNAME</i> is optional. If omitted, the encoding specified
        in the environment variable
        <span class="Li">&quot;PERL_ENCODING&quot;</span> is used. If this isn't
        set, or the resolved-to encoding is not known to
        <span class="Li">&quot;Encode&quot;</span>, the error
        <span class="Li">&quot;Unknown encoding
        '</span><span class="Li"><i>ENCNAME</i></span><span class="Li">'&quot;</span>
        will be thrown.</p>
    <p class="Pp">Starting in Perl v5.8.6
        (<span class="Li">&quot;Encode&quot;</span> version 2.0.1),
        <i>ENCNAME</i> may be the name
        <span class="Li">&quot;:locale&quot;</span>. This is for very
        specialized applications, and is documented in &quot;The
        <span class="Li">&quot;:locale&quot;</span> sub-pragma&quot; below.</p>
    <p class="Pp">The literals that are converted are
        <span class="Li">&quot;q//, qq//, qr//, qw///, qx//&quot;</span>, and
        starting in v5.8.1, <span class="Li">&quot;tr///&quot;</span>.
        Operations that do conversions include
        <span class="Li">&quot;chr&quot;</span>,
        <span class="Li">&quot;ord&quot;</span>,
        <span class="Li">&quot;utf8::upgrade&quot;</span> (but not
        <span class="Li">&quot;utf8::downgrade&quot;</span>), and
        <span class="Li">&quot;chomp&quot;</span>.</p>
    <p class="Pp">Also starting in v5.8.1, the
        <span class="Li">&quot;DATA&quot;</span> pseudo-filehandle is translated
        from the encoding into UTF-8.</p>
    <p class="Pp">For example, you can write code in EUC-JP as follows:</p>
    <p class="Pp"></p>
    <pre>  my $Rakuda = &quot;\xF1\xD1\xF1\xCC&quot;; # Camel in Kanji
               #&lt;-char-&gt;&lt;-char-&gt;   # 4 octets
  s/\bCamel\b/$Rakuda/;
    </pre>
    <p class="Pp">And with <span class="Li">&quot;use encoding
        &quot;euc-jp&quot;&quot;</span> in effect, it is the same thing as that
        code in UTF-8:</p>
    <p class="Pp"></p>
    <pre>  my $Rakuda = &quot;\x{99F1}\x{99DD}&quot;; # two Unicode Characters
  s/\bCamel\b/$Rakuda/;
    </pre>
    <p class="Pp">See &quot;EXAMPLE&quot; below for a more complete example.</p>
    <p class="Pp">Unless <span class="Li">&quot;${^UNICODE}&quot;</span>
        (available starting in v5.8.2) exists and is non-zero, the PerlIO layers
        of <span class="Li">&quot;STDIN&quot;</span> and
        <span class="Li">&quot;STDOUT&quot;</span> are set to
        &quot;<span class="Li">&quot;:encoding(</span><span class="Li"><i>ENCNAME</i></span><span class="Li">)&quot;</span>&quot;.
        Therefore,</p>
    <p class="Pp"></p>
    <pre>  use encoding &quot;euc-jp&quot;;
  my $message = &quot;Camel is the symbol of perl.\n&quot;;
  my $Rakuda = &quot;\xF1\xD1\xF1\xCC&quot;; # Camel in Kanji
  $message =~ s/\bCamel\b/$Rakuda/;
  print $message;
    </pre>
    <p class="Pp">will print</p>
    <p class="Pp"></p>
    <pre> &quot;\xF1\xD1\xF1\xCC is the symbol of perl.\n&quot;
    </pre>
    <p class="Pp">not</p>
    <p class="Pp"></p>
    <pre> &quot;\x{99F1}\x{99DD} is the symbol of perl.\n&quot;
    </pre>
    <p class="Pp">You can override this by giving extra arguments; see
      below.</p>
    <p class="Pp">Note that <span class="Li">&quot;STDERR&quot;</span> WILL NOT
        be changed, regardless.</p>
    <p class="Pp">Also note that non-STD file handles remain unaffected. Use
        <span class="Li">&quot;use</span> <span class="Li">open&quot;</span> or
        <span class="Li">&quot;binmode&quot;</span> to change the layers of
        those.</p>
  </dd>
  <dt>&quot;use encoding <i>ENCNAME</i>, Filter=&gt;1;&quot;</dt>
  <dd>This operates as above, but the <span class="Li">&quot;Filter&quot;</span>
      argument with a non-zero value causes the entire script, and not just
      literals, to be translated from the encoding into UTF-8. This allows
      identifiers in the source to be in that encoding as well. (Problems may
      occur if the encoding is not a superset of ASCII; imagine all your
      semi-colons being translated into something different.) One can use this
      form to make
    <p class="Pp"></p>
    <pre> ${&quot;\x{4eba}&quot;}++
    </pre>
    <p class="Pp">work. (This is equivalent to
        <span class="Li">&quot;$</span><span class="Li"><i>human</i></span><span class="Li">++&quot;</span>,
        where <i>human</i> is a single Han ideograph).</p>
    <p class="Pp">This effectively means that your source code behaves as if it
        were written in UTF-8 with <span class="Li">&quot;'use
        utf8&quot;</span>' in effect. So even if your editor only supports
        Shift_JIS, for example, you can still try examples in Chapter 15 of
        <span class="Li">&quot;Programming Perl, 3rd Ed.&quot;</span>.</p>
    <p class="Pp">This option is significantly slower than the other one.</p>
  </dd>
  <dt>&quot;no encoding;&quot;</dt>
  <dd>Unsets the script encoding. The layers of
      <span class="Li">&quot;STDIN&quot;</span>,
      <span class="Li">&quot;STDOUT&quot;</span> are reset to
      &quot;<span class="Li">&quot;:raw&quot;</span>&quot; (the default
      unprocessed raw stream of bytes).</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="OPTIONS"><a class="permalink" href="#OPTIONS">OPTIONS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Setting__STDIN__and/or__STDOUT__individually"><a class="permalink" href="#Setting__STDIN__and/or__STDOUT__individually">Setting
  &quot;STDIN&quot; and/or &quot;STDOUT&quot; individually</a></h2>
<p class="Pp">The encodings of <span class="Li">&quot;STDIN&quot;</span> and
    <span class="Li">&quot;STDOUT&quot;</span> are individually settable by
    parameters to the pragma:</p>
<p class="Pp"></p>
<pre> use encoding 'euc-tw', STDIN =&gt; 'greek'  ...;
</pre>
<p class="Pp">In this case, you cannot omit the first <i>ENCNAME</i>.
    <span class="Li">&quot;STDIN =&gt; undef&quot;</span> turns the I/O
    transcoding completely off for that filehandle.</p>
<p class="Pp">When <span class="Li">&quot;${^UNICODE}&quot;</span> (available
    starting in v5.8.2) exists and is non-zero, these options will be completely
    ignored. See &quot;<span class="Li">&quot;${^UNICODE}&quot;</span>&quot; in
    perlvar and &quot;<span class="Li">&quot;-C&quot;</span>&quot; in perlrun
    for details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The__:locale__sub-pragma"><a class="permalink" href="#The__:locale__sub-pragma">The
  &quot;:locale&quot; sub-pragma</a></h2>
<p class="Pp">Starting in v5.8.6, the encoding name may be
    <span class="Li">&quot;:locale&quot;</span>. This means that the encoding is
    taken from the current locale, and not hard-coded by the pragma. Since a
    script really can only be encoded in exactly one encoding, this option is
    dangerous. It makes sense only if the script itself is written in ASCII, and
    all the possible locales that will be in use when the script is executed are
    supersets of ASCII. That means that the script itself doesn't get changed,
    but the I/O handles have the specified encoding added, and the operations
    like <span class="Li">&quot;chr&quot;</span> and
    <span class="Li">&quot;ord&quot;</span> use that encoding.</p>
<p class="Pp">The logic of finding which locale
    <span class="Li">&quot;:locale&quot;</span> uses is as follows:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>If the platform supports the
      <span class="Li">&quot;langinfo(CODESET)&quot;</span> interface, the
      codeset returned is used as the default encoding for the open pragma.</dd>
  <dt>2.</dt>
  <dd>If 1. didn't work but we are under the locale pragma, the environment
      variables <span class="Li">&quot;LC_ALL&quot;</span> and
      <span class="Li">&quot;LANG&quot;</span> (in that order) are matched for
      encodings (the part after
      &quot;<span class="Li">&quot;.&quot;</span>&quot;, if any), and if any
      found, that is used as the default encoding for the open pragma.</dd>
  <dt>3.</dt>
  <dd>If 1. and 2. didn't work, the environment variables
      <span class="Li">&quot;LC_ALL&quot;</span> and
      <span class="Li">&quot;LANG&quot;</span> (in that order) are matched for
      anything looking like UTF-8, and if any found,
      <span class="Li">&quot;:utf8&quot;</span> is used as the default encoding
      for the open pragma.</dd>
</dl>
<p class="Pp">If your locale environment variables
    (<span class="Li">&quot;LC_ALL&quot;</span>,
    <span class="Li">&quot;LC_CTYPE&quot;</span>,
    <span class="Li">&quot;LANG&quot;</span>) contain the strings 'UTF-8' or
    'UTF8' (case-insensitive matching), the default encoding of your
    <span class="Li">&quot;STDIN&quot;</span>,
    <span class="Li">&quot;STDOUT&quot;</span>, and
    <span class="Li">&quot;STDERR&quot;</span>, and of <b>any subsequent file
    open</b>, is UTF-8.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<section class="Ss">
<h2 class="Ss">SIDE EFFECTS</h2>
<ul class="Bl-bullet">
  <li>If the <span class="Li">&quot;encoding&quot;</span> pragma is in scope
      then the lengths returned are calculated from the length of
      <span class="Li">$/</span> in Unicode characters, which is not always the
      same as the length of <span class="Li">$/</span> in the native
    encoding.</li>
  <li>Without this pragma, if strings operating under byte semantics and strings
      with Unicode character data are concatenated, the new string will be
      created by decoding the byte strings as <i>ISO 8859-1 (Latin-1)</i>.
    <p class="Pp">The <b>encoding</b> pragma changes this to use the specified
        encoding instead. For example:</p>
    <p class="Pp"></p>
    <pre>    use encoding 'utf8';
    my $string = chr(20000); # a Unicode string
    utf8::encode($string);   # now it's a UTF-8 encoded byte string
    # concatenate with another Unicode string
    print length($string . chr(20000));
    </pre>
    <p class="Pp">Will print <span class="Li">2</span>, because
        <span class="Li">$string</span> is upgraded as UTF-8. Without
        <span class="Li">&quot;use encoding 'utf8';&quot;</span>, it will print
        <span class="Li">4</span> instead, since <span class="Li">$string</span>
        is three octets when interpreted as Latin-1.</p>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss">DO NOT MIX MULTIPLE ENCODINGS</h2>
<p class="Pp">Notice that only literals (string or regular expression) having
    only legacy code points are affected: if you mix data like this</p>
<p class="Pp"></p>
<pre>    \x{100}\xDF
    \xDF\x{100}
</pre>
<p class="Pp">the data is assumed to be in (Latin 1 and) Unicode, not in your
    native encoding. In other words, this will match in &quot;greek&quot;:</p>
<p class="Pp"></p>
<pre>    &quot;\xDF&quot; =~ /\x{3af}/
</pre>
<p class="Pp">but this will not</p>
<p class="Pp"></p>
<pre>    &quot;\xDF\x{100}&quot; =~ /\x{3af}\x{100}/
</pre>
<p class="Pp">since the <span class="Li">&quot;\xDF&quot;</span> (ISO 8859-7
    GREEK SMALL LETTER IOTA WITH TONOS) on the left will <b>not</b> be upgraded
    to <span class="Li">&quot;\x{3af}&quot;</span> (Unicode GREEK SMALL LETTER
    IOTA WITH TONOS) because of the <span class="Li">&quot;\x{100}&quot;</span>
    on the left. You should not be mixing your legacy data and Unicode in the
    same string.</p>
<p class="Pp">This pragma also affects encoding of the 0x80..0xFF code point
    range: normally characters in that range are left as eight-bit bytes (unless
    they are combined with characters with code points 0x100 or larger, in which
    case all characters need to become UTF-8 encoded), but if the
    <span class="Li">&quot;encoding&quot;</span> pragma is present, even the
    0x80..0xFF range always gets UTF-8 encoded.</p>
<p class="Pp">After all, the best thing about this pragma is that you don't have
    to resort to \x{....} just to spell your name in a native encoding. So feel
    free to put your strings in your encoding in quotes and regexes.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Prior_to_Perl_v5.22"><a class="permalink" href="#Prior_to_Perl_v5.22">Prior
  to Perl v5.22</a></h2>
<p class="Pp">The pragma was a per script, not a per block lexical. Only the
    last <span class="Li">&quot;use encoding&quot;</span> or
    <span class="Li">&quot;no encoding&quot;</span> mattered, and it affected
    <b>the whole script</b>. However, the <span class="Li">&quot;no
    encoding&quot;</span> pragma was supported and <span class="Li">&quot;use
    encoding&quot;</span> could appear as many times as you want in a given
    script (though only the last was effective).</p>
<p class="Pp">Since the scope wasn't lexical, other modules' use of
    <span class="Li">&quot;chr&quot;</span>,
    <span class="Li">&quot;ord&quot;</span>, <i>etc.</i> were affected. This
    leads to spooky, incorrect action at a distance that is hard to debug.</p>
<p class="Pp">This means you would have to be very careful of the load
  order:</p>
<p class="Pp"></p>
<pre>  # called module
  package Module_IN_BAR;
  use encoding &quot;bar&quot;;
  # stuff in &quot;bar&quot; encoding here
  1;
  # caller script
  use encoding &quot;foo&quot;
  use Module_IN_BAR;
  # surprise! use encoding &quot;bar&quot; is in effect.
</pre>
<p class="Pp">The best way to avoid this oddity is to use this pragma RIGHT
    AFTER other modules are loaded. i.e.</p>
<p class="Pp"></p>
<pre>  use Module_IN_BAR;
  use encoding &quot;foo&quot;;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Prior_to_Encode_version_1.87"><a class="permalink" href="#Prior_to_Encode_version_1.87">Prior
  to Encode version 1.87</a></h2>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;STDIN&quot;</span> and
      <span class="Li">&quot;STDOUT&quot;</span> were not set under the filter
      option. And
      <span class="Li">&quot;STDIN=&gt;</span><span class="Li"><i>ENCODING</i></span><span class="Li">&quot;</span>
      and
      <span class="Li">&quot;STDOUT=&gt;</span><span class="Li"><i>ENCODING</i></span><span class="Li">&quot;</span>
      didn't work like non-filter version.</li>
  <li><span class="Li">&quot;use utf8&quot;</span> wasn't implicitly declared so
      you have to <span class="Li">&quot;use utf8&quot;</span> to do
    <p class="Pp"></p>
    <pre> ${&quot;\x{4eba}&quot;}++
    </pre>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Prior_to_Perl_v5.8.1"><a class="permalink" href="#Prior_to_Perl_v5.8.1">Prior
  to Perl v5.8.1</a></h2>
<dl class="Bl-tag">
  <dt>&quot;NON-EUC&quot; doublebyte encodings</dt>
  <dd>Because perl needs to parse the script before applying this pragma, such
      encodings as Shift_JIS and Big-5 that may contain
      <span class="Li">'\'</span> (BACKSLASH;
      <span class="Li">&quot;\x5c&quot;</span>) in the second byte fail because
      the second byte may accidentally escape the quoting character that
      follows.</dd>
  <dt>&quot;tr///&quot;</dt>
  <dd>The <b>encoding</b> pragma works by decoding string literals in
      <span class="Li">&quot;q//,qq//,qr//,qw///, qx//&quot;</span> and so
      forth. In perl v5.8.0, this does not apply to
      <span class="Li">&quot;tr///&quot;</span>. Therefore,
    <p class="Pp"></p>
    <pre>  use encoding 'euc-jp';
  #....
  $kana =~ tr/\xA4\xA1-\xA4\xF3/\xA5\xA1-\xA5\xF3/;
  #           -------- -------- -------- --------
    </pre>
    <p class="Pp">Does not work as</p>
    <p class="Pp"></p>
    <pre>  $kana =~ tr/\x{3041}-\x{3093}/\x{30a1}-\x{30f3}/;
    </pre>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Legend"><a class="permalink" href="#Legend">Legend of characters
    above</a></dt>
  <dd>
    <pre>  utf8     euc-jp   charnames::viacode()
  -----------------------------------------
  \x{3041} \xA4\xA1 HIRAGANA LETTER SMALL A
  \x{3093} \xA4\xF3 HIRAGANA LETTER N
  \x{30a1} \xA5\xA1 KATAKANA LETTER SMALL A
  \x{30f3} \xA5\xF3 KATAKANA LETTER N
    </pre>
  </dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">This counterintuitive behavior has been fixed in perl v5.8.1.</p>
<p class="Pp">In perl v5.8.0, you can work around this as follows;</p>
<p class="Pp"></p>
<pre>  use encoding 'euc-jp';
  #  ....
  eval qq{ \$kana =~ tr/\xA4\xA1-\xA4\xF3/\xA5\xA1-\xA5\xF3/ };
</pre>
<p class="Pp">Note the <span class="Li">&quot;tr//&quot;</span> expression is
    surrounded by <span class="Li">&quot;qq{}&quot;</span>. The idea behind this
    is the same as the classic idiom that makes
    <span class="Li">&quot;tr///&quot;</span> 'interpolate':</p>
<p class="Pp"></p>
<pre>   tr/$from/$to/;            # wrong!
   eval qq{ tr/$from/$to/ }; # workaround.
</pre>
</div>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLE_"><a class="permalink" href="#EXAMPLE_">EXAMPLE -
  Greekperl</a></h1>
<pre>    use encoding &quot;iso 8859-7&quot;;
    # \xDF in ISO 8859-7 (Greek) is \x{3af} in Unicode.
    $a = &quot;\xDF&quot;;
    $b = &quot;\x{100}&quot;;
    printf &quot;%#x\n&quot;, ord($a); # will print 0x3af, not 0xdf
    $c = $a . $b;
    # $c will be &quot;\x{3af}\x{100}&quot;, not &quot;\x{df}\x{100}&quot;.
    # chr() is affected, and ...
    print &quot;mega\n&quot;  if ord(chr(0xdf)) == 0x3af;
    # ... ord() is affected by the encoding pragma ...
    print &quot;tera\n&quot; if ord(pack(&quot;C&quot;, 0xdf)) == 0x3af;
    # ... as are eq and cmp ...
    print &quot;peta\n&quot; if &quot;\x{3af}&quot; eq  pack(&quot;C&quot;, 0xdf);
    print &quot;exa\n&quot;  if &quot;\x{3af}&quot; cmp pack(&quot;C&quot;, 0xdf) == 0;
    # ... but pack/unpack C are not affected, in case you still
    # want to go back to your native encoding
    print &quot;zetta\n&quot; if unpack(&quot;C&quot;, (pack(&quot;C&quot;, 0xdf))) == 0xdf;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<dl class="Bl-tag">
  <dt id="Thread"><a class="permalink" href="#Thread">Thread safety</a></dt>
  <dd><span class="Li">&quot;use encoding ...&quot;</span> is not thread-safe
      (i.e., do not use in threaded applications).</dd>
  <dt id="Can't"><a class="permalink" href="#Can't">Can't be used by more than
    one module in a single program.</a></dt>
  <dd>Only one encoding is allowed. If you combine modules in a program that
      have different encodings, only one will be actually used.</dd>
  <dt id="Other"><a class="permalink" href="#Other">Other modules using
    &quot;STDIN&quot; and &quot;STDOUT&quot; get the encoded stream</a></dt>
  <dd>They may be expecting something completely different.</dd>
  <dt id="literals"><a class="permalink" href="#literals">literals in regex that
    are longer than 127 bytes</a></dt>
  <dd>For native multibyte encodings (either fixed or variable length), the
      current implementation of the regular expressions may introduce recoding
      errors for regular expression literals longer than 127 bytes.</dd>
  <dt id="EBCDIC"><a class="permalink" href="#EBCDIC">EBCDIC</a></dt>
  <dd>The encoding pragma is not supported on EBCDIC platforms.</dd>
  <dt>&quot;format&quot;</dt>
  <dd>This pragma doesn't work well with
      <span class="Li">&quot;format&quot;</span> because PerlIO does not get
      along very well with it. When <span class="Li">&quot;format&quot;</span>
      contains non-ASCII characters it prints funny or gets &quot;wide character
      warnings&quot;. To understand it, try the code below.
    <p class="Pp"></p>
    <pre>  # Save this one in utf8
  # replace *non-ascii* with a non-ascii string
  my $camel;
  format STDOUT =
  *non-ascii*@&gt;&gt;&gt;&gt;&gt;&gt;&gt;
  $camel
  .
  $camel = &quot;*non-ascii*&quot;;
  binmode(STDOUT=&gt;':encoding(utf8)'); # bang!
  write;              # funny
  print $camel, &quot;\n&quot;; # fine
    </pre>
    <p class="Pp">Without binmode this happens to work but without binmode,
        <b>print()</b> fails instead of <b>write()</b>.</p>
    <p class="Pp">At any rate, the very use of
        <span class="Li">&quot;format&quot;</span> is questionable when it comes
        to unicode characters since you have to consider such things as
        character width (i.e. double-width for ideographs) and directions (i.e.
        BIDI for Arabic and Hebrew).</p>
  </dd>
  <dt id="See"><a class="permalink" href="#See">See also
    &quot;CAVEATS&quot;</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
<p class="Pp">This pragma first appeared in Perl v5.8.0. It has been enhanced in
    later releases as specified above.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">perlunicode, Encode, open, Filter::Util::Call,</p>
<p class="Pp">Ch. 15 of <span class="Li">&quot;Programming Perl (3rd
    Edition)&quot;</span> by Larry Wall, Tom Christiansen, Jon Orwant; O'Reilly
    &amp; Associates; ISBN 0-596-00027-8</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

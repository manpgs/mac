<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Apache2::Reload(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Apache2::Reload(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Apache2::Reload(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Apache2::Reload - Reload Perl Modules when Changed on Disk</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Synopsis"><a class="permalink" href="#Synopsis">Synopsis</a></h1>
<pre>
  # Monitor and reload all modules in %INC:
  # httpd.conf:
  PerlModule Apache2::Reload
  PerlInitHandler Apache2::Reload

  # when working with protocols and connection filters
  # PerlPreConnectionHandler Apache2::Reload

  # Reload groups of modules:
  # httpd.conf:
  PerlModule Apache2::Reload
  PerlInitHandler Apache2::Reload
  PerlSetVar ReloadAll Off
  PerlSetVar ReloadModules &quot;ModPerl::* Apache2::*&quot;
  #PerlSetVar ReloadDebug On
  #PerlSetVar ReloadByModuleName On
  
  # Reload a single module from within itself:
  package My::Apache2::Module;
  use Apache2::Reload;
  sub handler { ... }
  1;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="Description"><a class="permalink" href="#Description">Description</a></h1>
<p class="Pp"><span class="Li">&quot;Apache2::Reload&quot;</span> reloads
    modules that change on the disk.</p>
<p class="Pp">When Perl pulls a file via
    <span class="Li">&quot;require&quot;</span>, it stores the filename in the
    global hash <span class="Li">%INC</span>. The next time Perl tries to
    <span class="Li">&quot;require&quot;</span> the same file, it sees the file
    in <span class="Li">%INC</span> and does not reload from disk. This module's
    handler can be configured to iterate over the modules in
    <span class="Li">%INC</span> and reload those that have changed on disk or
    only specific modules that have registered themselves with
    <span class="Li">&quot;Apache2::Reload&quot;</span>. It can also do the
    check for modified modules, when a special touch-file has been modified.</p>
<p class="Pp">Require-hooks, i.e., entries in <span class="Li">%INC</span> which
    are references, are ignored. The hook should modify
    <span class="Li">%INC</span> itself, adding the path to the module file, for
    it to be reloaded.</p>
<p class="Pp"><span class="Li">&quot;Apache2::Reload&quot;</span> inspects and
    reloads the <b>file</b> associated with a given module. Changes to
    <span class="Li">@INC</span> are not recognized, as it is the file which is
    being re-required, not the module name.</p>
<p class="Pp">In version 0.10 and earlier the <b>module name</b>, not the file,
    is re-required. Meaning it operated on the the current context of
    <span class="Li">@INC</span>. If you still want this behavior set this
    environment variable in <i>httpd.conf</i>:</p>
<p class="Pp"></p>
<pre>
  PerlSetVar ReloadByModuleName On
</pre>
<p class="Pp">This means, when called as a
    <span class="Li">&quot;Perl*Handler&quot;</span>,
    <span class="Li">&quot;Apache2::Reload&quot;</span> will not see
    <span class="Li">@INC</span> paths added or removed by
    <span class="Li">&quot;ModPerl::Registry&quot;</span> scripts, as the value
    of <span class="Li">@INC</span> is saved on server startup and restored to
    that value after each request. In other words, if you want
    <span class="Li">&quot;Apache2::Reload&quot;</span> to work with modules
    that live in custom <span class="Li">@INC</span> paths, you should modify
    <span class="Li">@INC</span> when the server is started. Besides,
    <span class="Li">'use lib'</span> in the startup script, you can also set
    the <span class="Li">&quot;PERL5LIB&quot;</span> variable in the httpd's
    environment to include any non-standard 'lib' directories that you choose.
    For example, to accomplish that you can include a line:</p>
<p class="Pp"></p>
<pre>
  PERL5LIB=/home/httpd/perl/extra; export PERL5LIB
</pre>
<p class="Pp">in the script that starts Apache. Alternatively, you can set this
    environment variable in <i>httpd.conf</i>:</p>
<p class="Pp"></p>
<pre>
  PerlSetEnv PERL5LIB /home/httpd/perl/extra
</pre>
<section class="Ss">
<h2 class="Ss" id="Monitor_All_Modules_in__INC"><a class="permalink" href="#Monitor_All_Modules_in__INC">Monitor
  All Modules in %INC</a></h2>
<p class="Pp">To monitor and reload all modules in <span class="Li">%INC</span>
    at the beginning of request's processing, simply add the following
    configuration to your <i>httpd.conf</i>:</p>
<p class="Pp"></p>
<pre>
  PerlModule Apache2::Reload
  PerlInitHandler Apache2::Reload
</pre>
<p class="Pp">When working with connection filters and protocol modules
    <span class="Li">&quot;Apache2::Reload&quot;</span> should be invoked in the
    pre_connection stage:</p>
<p class="Pp"></p>
<pre>
  PerlPreConnectionHandler Apache2::Reload
</pre>
<p class="Pp">See also the discussion on
    <span class="Li">&quot;PerlPreConnectionHandler&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Register_Modules_Implicitly"><a class="permalink" href="#Register_Modules_Implicitly">Register
  Modules Implicitly</a></h2>
<p class="Pp">To only reload modules that have registered with
    <span class="Li">&quot;Apache2::Reload&quot;</span>, add the following to
    the <i>httpd.conf</i>:</p>
<p class="Pp"></p>
<pre>
  PerlModule Apache2::Reload
  PerlInitHandler Apache2::Reload
  PerlSetVar ReloadAll Off
  # ReloadAll defaults to On
</pre>
<p class="Pp">Then any modules with the line:</p>
<p class="Pp"></p>
<pre>
  use Apache2::Reload;
</pre>
<p class="Pp">Will be reloaded when they change.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Register_Modules_Explicitly"><a class="permalink" href="#Register_Modules_Explicitly">Register
  Modules Explicitly</a></h2>
<p class="Pp">You can also register modules explicitly in your <i>httpd.conf</i>
    file that you want to be reloaded on change:</p>
<p class="Pp"></p>
<pre>
  PerlModule Apache2::Reload
  PerlInitHandler Apache2::Reload
  PerlSetVar ReloadAll Off
  PerlSetVar ReloadModules &quot;My::Foo My::Bar Foo::Bar::Test&quot;
</pre>
<p class="Pp">Note that these are split on whitespace, but the module list
    <b>must</b> be in quotes, otherwise Apache tries to parse the parameter
    list.</p>
<p class="Pp">The <span class="Li">&quot;*&quot;</span> wild character can be
    used to register groups of files under the same namespace. For example the
    setting:</p>
<p class="Pp"></p>
<pre>
  PerlSetVar ReloadModules &quot;ModPerl::* Apache2::*&quot;
</pre>
<p class="Pp">will monitor all modules under the namespaces
    <span class="Li">&quot;ModPerl::&quot;</span> and
    <span class="Li">&quot;Apache2::&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Monitor_Only_Certain_Sub_Directories"><a class="permalink" href="#Monitor_Only_Certain_Sub_Directories">Monitor
  Only Certain Sub Directories</a></h2>
<p class="Pp">To reload modules only in certain directories (and their
    subdirectories) add the following to the <i>httpd.conf</i>:</p>
<p class="Pp"></p>
<pre>
  PerlModule Apache2::Reload
  PerlInitHandler Apache2::Reload
  PerlSetVar ReloadDirectories &quot;/tmp/project1 /tmp/project2&quot;
</pre>
<p class="Pp">You can further narrow the list of modules to be reloaded from the
    chosen directories with <span class="Li">&quot;ReloadModules&quot;</span> as
    in:</p>
<p class="Pp"></p>
<pre>
  PerlModule Apache2::Reload
  PerlInitHandler Apache2::Reload
  PerlSetVar ReloadDirectories &quot;/tmp/project1 /tmp/project2&quot;
  PerlSetVar ReloadAll Off
  PerlSetVar ReloadModules &quot;MyApache2::*&quot;
</pre>
<p class="Pp">In this configuration example only modules from the namespace
    <span class="Li">&quot;MyApache2::&quot;</span> found in the directories
    <i>/tmp/project1/</i> and <i>/tmp/project2/</i> (and their subdirectories)
    will be reloaded.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Special__Touch__File"><a class="permalink" href="#Special__Touch__File">Special
  &quot;Touch&quot; File</a></h2>
<p class="Pp">You can also declare a file, which when gets
    <span class="Li">touch(1)</span>ed, causes the reloads to be performed. For
    example if you set:</p>
<p class="Pp"></p>
<pre>
  PerlSetVar ReloadTouchFile /tmp/reload_modules
</pre>
<p class="Pp">and don't <span class="Li">touch(1)</span> the file
    <i>/tmp/reload_modules</i>, the reloads won't happen until you go to the
    command line and type:</p>
<p class="Pp"></p>
<pre>
  % touch /tmp/reload_modules
</pre>
<p class="Pp">When you do that, the modules that have been changed, will be
    magically reloaded on the next request. This option works with any mode
    described before.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Unregistering_a_module"><a class="permalink" href="#Unregistering_a_module">Unregistering
  a module</a></h2>
<p class="Pp">In some cases, it might be necessary to explicitly stop reloading
    a module.</p>
<p class="Pp"></p>
<pre>
  Apache2::Reload-&gt;unregister_module('Some::Module');
</pre>
<p class="Pp">But be carefull, since unregistering a module in this way will
    only do so for the current interpreter. This feature should be used with
    care.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Performance_Issues"><a class="permalink" href="#Performance_Issues">Performance
  Issues</a></h1>
<p class="Pp">This module is perfectly suited for a development environment.
    Though it's possible that you would like to use it in a production
    environment, since with <span class="Li">&quot;Apache2::Reload&quot;</span>
    you don't have to restart the server in order to reload changed modules
    during software updates. Though this convenience comes at a price:</p>
<ul class="Bl-bullet">
  <li>If the &quot;touch&quot; file feature is used,
      <span class="Li">&quot;Apache2::Reload&quot;</span> has to <b>stat</b>(2)
      the touch file on each request, which adds a slight but most likely
      insignificant overhead to response times. Otherwise
      <span class="Li">&quot;Apache2::Reload&quot;</span> will <b>stat</b>(2)
      each registered module or even worse--all modules in
      <span class="Li">%INC</span>, which will significantly slow everything
      down.</li>
  <li>Once the child process reloads the modules, the memory used by these
      modules is not shared with the parent process anymore. Therefore the
      memory consumption may grow significantly.</li>
</ul>
<p class="Pp">Therefore doing a full server stop and restart is probably a
    better solution.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Debug"><a class="permalink" href="#Debug">Debug</a></h1>
<p class="Pp">If you aren't sure whether the modules that are supposed to be
    reloaded, are actually getting reloaded, turn the debug mode on:</p>
<p class="Pp"></p>
<pre>
  PerlSetVar ReloadDebug On
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="Caveats"><a class="permalink" href="#Caveats">Caveats</a></h1>
<section class="Ss">
<h2 class="Ss" id="Problems_With_Reloading_Modules_Which_Do_Not_Declare_Their_Package_Name"><a class="permalink" href="#Problems_With_Reloading_Modules_Which_Do_Not_Declare_Their_Package_Name">Problems
  With Reloading Modules Which Do Not Declare Their Package Name</a></h2>
<p class="Pp">If you modify modules, which don't declare their
    <span class="Li">&quot;package&quot;</span>, and rely on
    <span class="Li">&quot;Apache2::Reload&quot;</span> to reload them, you may
    encounter problems: i.e., it'll appear as if the module wasn't reloaded when
    in fact it was. This happens because when
    <span class="Li">&quot;Apache2::Reload&quot;</span>
    <span class="Li">&quot;require()&quot;</span>s such a module all the global
    symbols end up in the <span class="Li">&quot;Apache2::Reload&quot;</span>
    namespace! So the module does get reloaded and you see the compile time
    errors if there are any, but the symbols don't get imported to the right
    namespace. Therefore the old version of the code is running.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Failing_to_Find_a_File_to_Reload"><a class="permalink" href="#Failing_to_Find_a_File_to_Reload">Failing
  to Find a File to Reload</a></h2>
<p class="Pp"><span class="Li">&quot;Apache2::Reload&quot;</span> uses
    <span class="Li">%INC</span> to find the files on the filesystem. If an
    entry for a certain filepath in <span class="Li">%INC</span> is relative,
    <span class="Li">&quot;Apache2::Reload&quot;</span> will use
    <span class="Li">@INC</span> to try to resolve that relative path. Now
    remember that mod_perl freezes the value of <span class="Li">@INC</span> at
    the server startup, and you can modify it only for the duration of one
    request when you need to load some module which is not in on of the
    <span class="Li">@INC</span> directories. So a module gets loaded, and
    registered in <span class="Li">%INC</span> with a relative path. Now when
    <span class="Li">&quot;Apache2::Reload&quot;</span> tries to find that
    module to check whether it has been modified, it can't find since its
    directory is not in <span class="Li">@INC</span>. So
    <span class="Li">&quot;Apache2::Reload&quot;</span> will silently skip that
    module.</p>
<p class="Pp">You can enable the
    <span class="Li">&quot;Debug|/Debug&quot;</span> mode to see what
    <span class="Li">&quot;Apache2::Reload&quot;</span> does behind the
  scenes.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Problems_with_Scripts_Running_with_Registry_Handlers_that_Cache_the_Code"><a class="permalink" href="#Problems_with_Scripts_Running_with_Registry_Handlers_that_Cache_the_Code">Problems
  with Scripts Running with Registry Handlers that Cache the Code</a></h2>
<p class="Pp">The following problem is relevant only to registry handlers that
    cache the compiled script. For example it concerns
    <span class="Li">&quot;ModPerl::Registry&quot;</span> but not
    <span class="Li">&quot;ModPerl::PerlRun&quot;</span>.</p>
<p class="Pp"><i>The Problem</i></p>
<p class="Pp">Let's say that there is a module
    <span class="Li">&quot;My::Utils&quot;</span>:</p>
<p class="Pp"></p>
<pre>
  #file:My/Utils.pm
  #----------------
  package My::Utils;
  BEGIN { warn __PACKAGE__ , &quot; was reloaded\n&quot; }
  use base qw(Exporter);
  @EXPORT = qw(colour);
  sub colour { &quot;white&quot; }
  1;
</pre>
<p class="Pp">And a registry script <i>test.pl</i>:</p>
<p class="Pp"></p>
<pre>
  #file:test.pl
  #------------
  use My::Utils;
  print &quot;Content-type: text/plain\n\n&quot;;
  print &quot;the color is &quot; . colour();
</pre>
<p class="Pp">Assuming that the server is running in a single mode, we request
    the script for the first time and we get the response:</p>
<p class="Pp"></p>
<pre>
  the color is white
</pre>
<p class="Pp">Now we change <i>My/Utils.pm</i>:</p>
<p class="Pp"></p>
<pre>
  -  sub colour { &quot;white&quot; }
  +  sub colour { &quot;red&quot; }
</pre>
<p class="Pp">And issue the request again.
    <span class="Li">&quot;Apache2::Reload&quot;</span> does its job and we can
    see that <span class="Li">&quot;My::Utils&quot;</span> was reloaded (look in
    the <i>error_log</i> file). However the script still returns:</p>
<p class="Pp"></p>
<pre>
  the color is white
</pre>
<p class="Pp"><i>The Explanation</i></p>
<p class="Pp">Even though <i>My/Utils.pm</i> was reloaded,
    <span class="Li">&quot;ModPerl::Registry&quot;</span>'s cached code won't
    run '<span class="Li">&quot;use My::Utils;&quot;</span>' again (since it
    happens only once, i.e. during the compile time). Therefore the script
    doesn't know that the subroutine reference has been changed.</p>
<p class="Pp">This is easy to verify. Let's change the script to be:</p>
<p class="Pp"></p>
<pre>
  #file:test.pl
  #------------
  use My::Utils;
  print &quot;Content-type: text/plain\n\n&quot;;
  my $sub_int = \&amp;colour;
  my $sub_ext = \&amp;My::Utils::colour;
  print &quot;int $sub_int\n&quot;;
  print &quot;ext $sub_ext\n&quot;;
</pre>
<p class="Pp">Issue a request, you will see something similar to:</p>
<p class="Pp"></p>
<pre>
  int CODE(0x8510af8)
  ext CODE(0x8510af8)
</pre>
<p class="Pp">As you can see both point to the same CODE reference (meaning that
    it's the same symbol). After modifying <i>My/Utils.pm</i> again:</p>
<p class="Pp"></p>
<pre>
  -  sub colour { &quot;red&quot; }
  +  sub colour { &quot;blue&quot; }
</pre>
<p class="Pp">and calling the script on the secondnd time, we get:</p>
<p class="Pp"></p>
<pre>
  int CODE(0x8510af8)
  ext CODE(0x851112c)
</pre>
<p class="Pp">You can see that the internal CODE reference is not the same as
    the external one.</p>
<p class="Pp"><i>The Solution</i></p>
<p class="Pp">There are two solutions to this problem:</p>
<p class="Pp">Solution 1: replace <span class="Li">&quot;use()&quot;</span> with
    an explicit <span class="Li">&quot;require()&quot;</span> +
    <span class="Li">&quot;import()&quot;</span>.</p>
<p class="Pp"></p>
<pre>
 - use My::Utils;
 + require My::Utils; My::Utils-&gt;import();
</pre>
<p class="Pp">now the changed functions will be reimported on every request.</p>
<p class="Pp">Solution 2: remember to touch the script itself every time you
    change the module that it requires.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Threaded_MPM_and_Multiple_Perl_Interpreters"><a class="permalink" href="#Threaded_MPM_and_Multiple_Perl_Interpreters">Threaded
  MPM and Multiple Perl Interpreters</a></h1>
<p class="Pp">If you use <span class="Li">&quot;Apache2::Reload&quot;</span>
    with a threaded MPM and multiple Perl interpreters, the modules will be
    reloaded by each interpreter as they are used, not every interpreters at
    once. Similar to mod_perl 1.0 where each child has its own Perl interpreter,
    the modules are reloaded as each child is hit with a request.</p>
<p class="Pp">If a module is loaded at startup, the syntax tree of each
    subroutine is shared between interpreters (big win), but each subroutine has
    its own padlist (where lexical my variables are stored). Once
    <span class="Li">&quot;Apache2::Reload&quot;</span> reloads a module, this
    sharing goes away and each Perl interpreter will have its own copy of the
    syntax tree for the reloaded subroutines.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Pseudo-hashes"><a class="permalink" href="#Pseudo-hashes">Pseudo-hashes</a></h1>
<p class="Pp">The short summary of this is: Don't use pseudo-hashes. They are
    deprecated since Perl 5.8 and are removed in 5.9.</p>
<p class="Pp">Use an array with constant indexes. Its faster in the general
    case, its more guaranteed, and generally, it works.</p>
<p class="Pp">The long summary is that some work has been done to get this
    module working with modules that use pseudo-hashes, but it's still broken in
    the case of a single module that contains multiple packages that all use
    pseudo-hashes.</p>
<p class="Pp">So don't do that.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Copyright"><a class="permalink" href="#Copyright">Copyright</a></h1>
<p class="Pp">mod_perl 2.0 and its core modules are copyrighted under The Apache
    Software License, Version 2.0.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Authors"><a class="permalink" href="#Authors">Authors</a></h1>
<p class="Pp">Matt Sergeant, matt@sergeant.org</p>
<p class="Pp">Stas Bekman (porting to mod_perl 2.0)</p>
<p class="Pp">A few concepts borrowed from
    <span class="Li">&quot;Stonehenge::Reload&quot;</span> by Randal Schwartz
    and <span class="Li">&quot;Apache::StatINC&quot;</span> (mod_perl 1.x) by
    Doug MacEachern and Ask Bjoern Hansen.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MAINTAINERS"><a class="permalink" href="#MAINTAINERS">MAINTAINERS</a></h1>
<p class="Pp">the mod_perl developers, dev@perl.apache.org</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2015-06-18</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

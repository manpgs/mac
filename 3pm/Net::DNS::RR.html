<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Net::DNS::RR(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Net::DNS::RR(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Net::DNS::RR(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Net::DNS::RR - DNS Resource Record base class</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
    use Net::DNS;

    $rr = new Net::DNS::RR('example.com IN A 192.0.2.99');

    $rr = new Net::DNS::RR(
            name    =&gt; 'example.com',
            type    =&gt; 'A',
            address =&gt; '192.0.2.99'
            );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Net::DNS::RR is the base class for DNS Resource Record (RR)
    objects. See also the manual pages for each specific RR type.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<p class="Pp"><b>WARNING!!!</b> Do not assume the RR objects you receive from a
    query are of a particular type -- you must always check the object type
    before calling any of its methods. If you call an unknown method, you will
    get an error message and execution will be terminated.</p>
<section class="Ss">
<h2 class="Ss" id="new_(from_string)"><a class="permalink" href="#new_(from_string)">new
  (from string)</a></h2>
<pre>
    $a     = new Net::DNS::RR('host.example.com. 86400 A 192.0.2.1');
    $mx    = new Net::DNS::RR('example.com. 7200 MX 10 mailhost.example.com.');
    $cname = new Net::DNS::RR('www.example.com 300 IN CNAME host.example.com');
    $txt   = new Net::DNS::RR('txt.example.com 3600 HS TXT &quot;text data&quot;');
</pre>
<p class="Pp">Returns an RR object of the appropriate type, or a
    <span class="Li">&quot;Net::DNS::RR&quot;</span> object if the type is not
    implemented.	The attribute values are extracted from the string passed by
    the user. The syntax of the argument string follows the RFC1035
    specification for zone files, and is compatible with the result returned by
    the string method.</p>
<p class="Pp">The name and RR type are required; all other information is
    optional. If omitted, the TTL defaults to 0 and the RR class defaults to IN.
    Omitting the optional fields is useful for creating the empty RDATA sections
    required for certain dynamic update operations. See the
    <span class="Li">&quot;Net::DNS::Update&quot;</span> manual page for
    additional examples.</p>
<p class="Pp">All names are interpreted as fully qualified domain names. The
    trailing dot (.) is optional.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="new_(from_hash)"><a class="permalink" href="#new_(from_hash)">new
  (from hash)</a></h2>
<pre>
    $rr = new Net::DNS::RR(
            name    =&gt; 'host.example.com',
            ttl     =&gt; 86400,
            class   =&gt; 'IN',
            type    =&gt; 'A',
            address =&gt; '192.0.2.1'
            );
 
    $rr = new Net::DNS::RR(
            name    =&gt; 'txt.example.com',
            type    =&gt; 'TXT',
            txtdata =&gt; [ 'one', 'two' ]
            );
</pre>
<p class="Pp">Returns an RR object of the appropriate type, or a
    <span class="Li">&quot;Net::DNS::RR&quot;</span> object if the type is not
    implemented.	See the manual pages for each RR type to see what fields the
    type requires.</p>
<p class="Pp">The <span class="Li">&quot;name&quot;</span> and
    <span class="Li">&quot;type&quot;</span> fields are required; all others are
    optional. If omitted, <span class="Li">&quot;ttl&quot;</span> defaults to 0
    and <span class="Li">&quot;class&quot;</span> defaults to IN. Omitting the
    optional fields is useful for creating the empty RDATA sections required for
    certain dynamic update operations.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="decode"><a class="permalink" href="#decode">decode</a></h2>
<pre>
    ( $rr, $next ) = decode Net::DNS::RR( \$data, $offset, @opaque );
</pre>
<p class="Pp">Decodes a DNS resource record at the specified location within a
    DNS packet.</p>
<p class="Pp">The argument list consists of a reference to the buffer containing
    the packet data and offset indicating where resource record begins.
    Remaining arguments, if any, are passed as opaque data to subordinate
    decoders.</p>
<p class="Pp">Returns a <span class="Li">&quot;Net::DNS::RR&quot;</span> object
    and the offset of the next record in the packet.</p>
<p class="Pp">An exception is raised if the data buffer contains insufficient or
    corrupt data.</p>
<p class="Pp">Any remaining arguments are passed as opaque data to subordinate
    decoders and do not form part of the published interface.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="encode"><a class="permalink" href="#encode">encode</a></h2>
<pre>
    $data = $rr-&gt;encode( $offset, @opaque );
</pre>
<p class="Pp">Returns the <span class="Li">&quot;Net::DNS::RR&quot;</span> in
    binary format suitable for inclusion in a DNS packet buffer.</p>
<p class="Pp">The offset indicates the intended location within the packet data
    where the <span class="Li">&quot;Net::DNS::RR&quot;</span> is to be
  stored.</p>
<p class="Pp">Any remaining arguments are opaque data which are passed intact to
    subordinate encoders.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="canonical"><a class="permalink" href="#canonical">canonical</a></h2>
<pre>
    $data = $rr-&gt;canonical;
</pre>
<p class="Pp">Returns the <span class="Li">&quot;Net::DNS::RR&quot;</span> in
    canonical binary format suitable for DNSSEC signature validation.</p>
<p class="Pp">The absence of the associative array argument signals to
    subordinate encoders that the canonical uncompressed lower case form of
    embedded domain names is to be used.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="name"><a class="permalink" href="#name">name</a></h2>
<pre>
    $name = $rr-&gt;name;
</pre>
<p class="Pp">Returns the owner name of the record.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="type"><a class="permalink" href="#type">type</a></h2>
<pre>
    $type = $rr-&gt;type;
</pre>
<p class="Pp">Returns the record type.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="class"><a class="permalink" href="#class">class</a></h2>
<pre>
    $class = $rr-&gt;class;
</pre>
<p class="Pp">Resource record class.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ttl"><a class="permalink" href="#ttl">ttl</a></h2>
<pre>
    $ttl = $rr-&gt;ttl;
    $ttl = $rr-&gt;ttl(3600);
</pre>
<p class="Pp">Resource record time to live in seconds.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="rdata"><a class="permalink" href="#rdata">rdata</a></h2>
<pre>
    $rr = new Net::DNS::RR( type =&gt; NULL, rdata =&gt; 'arbitrary' );
</pre>
<p class="Pp">Resource record data section when viewed as opaque octets.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="print"><a class="permalink" href="#print">print</a></h2>
<pre>
    $rr-&gt;print;
</pre>
<p class="Pp">Prints the record to the standard output. Calls the <b>string</b>
    method to get the RR string representation.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="string"><a class="permalink" href="#string">string</a></h2>
<pre>
    print $rr-&gt;string, &quot;\n&quot;;
</pre>
<p class="Pp">Returns a string representation of the RR using the zone file
    format described in RFC1035. All domain names are fully qualified with
    trailing dot. This differs from RR attribute methods, which omit the
    trailing dot.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="rdstring"><a class="permalink" href="#rdstring">rdstring</a></h2>
<pre>
    $rdstring = $rr-&gt;rdstring;
</pre>
<p class="Pp">Returns a string representation of the RR-specific data.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="plain"><a class="permalink" href="#plain">plain</a></h2>
<pre>
    $plain = $rr-&gt;plain;
</pre>
<p class="Pp">Returns a simplified single line representation of the RR using
    the zone file format defined in RFC1035. This facilitates interaction with
    programs like nsupdate which have simplified RR parsers.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="token"><a class="permalink" href="#token">token</a></h2>
<pre>
    @token = $rr-&gt;token;
</pre>
<p class="Pp">Returns a token list representation of the RR zone file
  string.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Sorting_of_RR_arrays"><a class="permalink" href="#Sorting_of_RR_arrays">Sorting
  of RR arrays</a></h1>
<p class="Pp">Sorting of RR arrays is done by <b>Net::DNS::rrsort()</b>, see
    documentation for Net::DNS. This package provides class methods to set the
    sorting functions used for a particular RR based on its attributes.</p>
<section class="Ss">
<h2 class="Ss" id="set_rrsort_func"><a class="permalink" href="#set_rrsort_func">set_rrsort_func</a></h2>
<pre>
    Net::DNS::RR::SRV-&gt;set_rrsort_func(
        'priority',
        sub {
            my ( $a, $b ) = ( $Net::DNS::a, $Net::DNS::b );
            $a-&gt;priority &lt;=&gt; $b-&gt;priority
            || $b-&gt;weight &lt;=&gt; $a-&gt;weight;
            }
        );

    Net::DNS::RR::SRV-&gt;set_rrsort_func(
        'default_sort',
        sub {
            my ( $a, $b ) = ( $Net::DNS::a, $Net::DNS::b );
            $a-&gt;priority &lt;=&gt; $b-&gt;priority
            || $b-&gt;weight &lt;=&gt; $a-&gt;weight;
            }
        );
</pre>
<p class="Pp">set_rrsort_func needs to be called as a class method. The first
    argument is the attribute name on which the sorting will need to take place.
    If you specify &quot;default_sort&quot; then that is the sort algorithm that
    will be used in the case that <b>rrsort()</b> is called without an RR
    attribute as argument.</p>
<p class="Pp">The second argument is a reference to a comparison function that
    uses the global variables <span class="Li">$a</span> and
    <span class="Li">$b</span> in the <span class="Li">&quot;from
    Net::DNS&quot;</span>(!!)package. During sorting, the variables
    <span class="Li">$a</span> and <span class="Li">$b</span> will contain
    references to objects of the class from which you called the set_prop_sort.
    In other words, you can rest assured that the above sorting function will
    only be applied to Net::DNS::RR::SRV objects.</p>
<p class="Pp">The above example is the sorting function implemented in SRV.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (c)1997-2002 Michael Fuhr.</p>
<p class="Pp">Portions Copyright (c)2002-2004 Chris Reinhardt.</p>
<p class="Pp">Portions Copyright (c)2005-2007 Olaf Kolkman.</p>
<p class="Pp">Portions Copyright (c)2007,2012 Dick Franks.</p>
<p class="Pp">All rights reserved.</p>
<p class="Pp">This program is free software; you may redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">perl, Net::DNS, Net::DNS::Question, Net::DNS::Packet,
    Net::DNS::Update, RFC1035 Section 4.1.3, RFC1123, RFC3597</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-16</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Moo(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Moo(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Moo(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Moo - Minimalist Object Orientation (with Moose compatibility)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
 package Cat::Food;

 use Moo;
 use namespace::clean;

 sub feed_lion {
   my $self = shift;
   my $amount = shift || 1;

   $self-&gt;pounds( $self-&gt;pounds - $amount );
 }

 has taste =&gt; (
   is =&gt; 'ro',
 );

 has brand =&gt; (
   is  =&gt; 'ro',
   isa =&gt; sub {
     die &quot;Only SWEET-TREATZ supported!&quot; unless $_[0] eq 'SWEET-TREATZ'
   },
 );

 has pounds =&gt; (
   is  =&gt; 'rw',
   isa =&gt; sub { die &quot;$_[0] is too much cat food!&quot; unless $_[0] &lt; 15 },
 );

 1;
</pre>
<p class="Pp">And elsewhere:</p>
<p class="Pp"></p>
<pre>
 my $full = Cat::Food-&gt;new(
    taste  =&gt; 'DELICIOUS.',
    brand  =&gt; 'SWEET-TREATZ',
    pounds =&gt; 10,
 );

 $full-&gt;feed_lion;

 say $full-&gt;pounds;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module is an extremely light-weight subset of Moose optimised
    for rapid startup and &quot;pay only for what you use&quot;.</p>
<p class="Pp">It also avoids depending on any XS modules to allow simple
    deployments. The name <span class="Li">&quot;Moo&quot;</span> is based on
    the idea that it provides almost -- but not quite -- two thirds of
  Moose.</p>
<p class="Pp">Unlike Mouse this module does not aim at full compatibility with
    Moose's surface syntax, preferring instead of provide full interoperability
    via the metaclass inflation capabilities described in &quot;MOO AND
    MOOSE&quot;.</p>
<p class="Pp">For a full list of the minor differences between Moose and Moo's
    surface syntax, see &quot;INCOMPATIBILITIES WITH MOOSE&quot;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="WHY_MOO_EXISTS"><a class="permalink" href="#WHY_MOO_EXISTS">WHY
  MOO EXISTS</a></h1>
<p class="Pp">If you want a full object system with a rich Metaprotocol, Moose
    is already wonderful.</p>
<p class="Pp">However, sometimes you're writing a command line script or a CGI
    script where fast startup is essential, or code designed to be deployed as a
    single file via App::FatPacker, or you're writing a CPAN module and you want
    it to be usable by people with those constraints.</p>
<p class="Pp">I've tried several times to use Mouse but it's 3x the size of Moo
    and takes longer to load than most of my Moo based CGI scripts take to
  run.</p>
<p class="Pp">If you don't want Moose, you don't want &quot;less
    metaprotocol&quot; like Mouse, you want &quot;as little as possible&quot; --
    which means &quot;no metaprotocol&quot;, which is what Moo provides.</p>
<p class="Pp">Better still, if you install and load Moose, we set up metaclasses
    for your Moo classes and Moo::Role roles, so you can use them in Moose code
    without ever noticing that some of your codebase is using Moo.</p>
<p class="Pp">Hence, Moo exists as its name -- Minimal Object Orientation --
    with a pledge to make it smooth to upgrade to Moose when you need more than
    minimal features.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MOO_AND_MOOSE"><a class="permalink" href="#MOO_AND_MOOSE">MOO
  AND MOOSE</a></h1>
<p class="Pp">If Moo detects Moose being loaded, it will automatically register
    metaclasses for your Moo and Moo::Role packages, so you should be able to
    use them in Moose code without anybody ever noticing you aren't using Moose
    everywhere.</p>
<p class="Pp">Moo will also create Moose type constraints for classes and roles,
    so that <span class="Li">&quot;isa =&gt; 'MyClass'&quot;</span> and
    <span class="Li">&quot;isa =&gt; 'MyRole'&quot;</span> work the same as for
    Moose classes and roles.</p>
<p class="Pp">Extending a Moose class or consuming a Moose::Role will also
  work.</p>
<p class="Pp">So will extending a Mouse class or consuming a Mouse::Role - but
    note that we don't provide Mouse metaclasses or metaroles so the other way
    around doesn't work. This feature exists for Any::Moose users porting to
    Moo; enabling Mouse users to use Moo classes is not a priority for us.</p>
<p class="Pp">This means that there is no need for anything like Any::Moose for
    Moo code - Moo and Moose code should simply interoperate without problem. To
    handle Mouse code, you'll likely need an empty Moo role or class consuming
    or extending the Mouse stuff since it doesn't register true Moose
    metaclasses like Moo does.</p>
<p class="Pp">If you want types to be upgraded to the Moose types, use
    MooX::Types::MooseLike and install the MooseX::Types library to match the
    MooX::Types::MooseLike library you're using - Moo will load the
    MooseX::Types library and use that type for the newly created metaclass.</p>
<p class="Pp">If you need to disable the metaclass creation, add:</p>
<p class="Pp"></p>
<pre>
  no Moo::sification;
</pre>
<p class="Pp">to your code before Moose is loaded, but bear in mind that this
    switch is currently global and turns the mechanism off entirely so don't put
    this in library code.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MOO_AND_CLASS::XSACCESSOR"><a class="permalink" href="#MOO_AND_CLASS::XSACCESSOR">MOO
  AND CLASS::XSACCESSOR</a></h1>
<p class="Pp">If a new enough version of Class::XSAccessor is available, it will
    be used to generate simple accessors, readers, and writers for a speed
    boost. Simple accessors are those without lazy defaults, type
    checks/coercions, or triggers. Readers and writers generated by
    Class::XSAccessor will behave slightly differently: they will reject
    attempts to call them with the incorrect number of parameters.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MOO_VERSUS_ANY::MOOSE"><a class="permalink" href="#MOO_VERSUS_ANY::MOOSE">MOO
  VERSUS ANY::MOOSE</a></h1>
<p class="Pp">Any::Moose will load Mouse normally, and Moose in a program using
    Moose - which theoretically allows you to get the startup time of Mouse
    without disadvantaging Moose users.</p>
<p class="Pp">Sadly, this doesn't entirely work, since the selection is load
    order dependent - Moo's metaclass inflation system explained above in
    &quot;MOO AND MOOSE&quot; is significantly more reliable.</p>
<p class="Pp">So if you want to write a CPAN module that loads fast or has only
    pure perl dependencies but is also fully usable by Moose users, you should
    be using Moo.</p>
<p class="Pp">For a full explanation, see the article
    &lt;http://shadow.cat/blog/matt-s-trout/moo-versus-any-moose&gt; which
    explains the differing strategies in more detail and provides a direct
    example of where Moo succeeds and Any::Moose fails.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="IMPORTED_METHODS"><a class="permalink" href="#IMPORTED_METHODS">IMPORTED
  METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
<pre>
 Foo::Bar-&gt;new( attr1 =&gt; 3 );
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre>
 Foo::Bar-&gt;new({ attr1 =&gt; 3 });
</pre>
</section>
<section class="Ss">
<h2 class="Ss">BUILDARGS</h2>
<pre>
 sub BUILDARGS {
   my ( $class, @args ) = @_;

   unshift @args, &quot;attr1&quot; if @args % 2 == 1;

   return { @args };
 };

 Foo::Bar-&gt;new( 3 );
</pre>
<p class="Pp">The default implementation of this method accepts a hash or hash
    reference of named parameters. If it receives a single argument that isn't a
    hash reference it throws an error.</p>
<p class="Pp">You can override this method in your class to handle other types
    of options passed to the constructor.</p>
<p class="Pp">This method should always return a hash reference of named
    options.</p>
</section>
<section class="Ss">
<h2 class="Ss">FOREIGNBUILDARGS</h2>
<p class="Pp">If you are inheriting from a non-Moo class, the arguments passed
    to the parent class constructor can be manipulated by defining a
    <span class="Li">&quot;FOREIGNBUILDARGS&quot;</span> method. It will receive
    the same arguments as <span class="Li">&quot;BUILDARGS&quot;</span>, and
    should return a list of arguments to pass to the parent class
  constructor.</p>
</section>
<section class="Ss">
<h2 class="Ss">BUILD</h2>
<p class="Pp">Define a <span class="Li">&quot;BUILD&quot;</span> method on your
    class and the constructor will automatically call the
    <span class="Li">&quot;BUILD&quot;</span> method from parent down to child
    after the object has been instantiated. Typically this is used for object
    validation or possibly logging.</p>
</section>
<section class="Ss">
<h2 class="Ss">DEMOLISH</h2>
<p class="Pp">If you have a <span class="Li">&quot;DEMOLISH&quot;</span> method
    anywhere in your inheritance hierarchy, a
    <span class="Li">&quot;DESTROY&quot;</span> method is created on first
    object construction which will call
    <span class="Li">&quot;$instance-&gt;DEMOLISH($in_global_destruction)&quot;</span>
    for each <span class="Li">&quot;DEMOLISH&quot;</span> method from child
    upwards to parents.</p>
<p class="Pp">Note that the <span class="Li">&quot;DESTROY&quot;</span> method
    is created on first construction of an object of your class in order to not
    add overhead to classes without <span class="Li">&quot;DEMOLISH&quot;</span>
    methods; this may prove slightly surprising if you try and define your
  own.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="does"><a class="permalink" href="#does">does</a></h2>
<pre>
 if ($foo-&gt;does('Some::Role1')) {
   ...
 }
</pre>
<p class="Pp">Returns true if the object composes in the passed role.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="IMPORTED_SUBROUTINES"><a class="permalink" href="#IMPORTED_SUBROUTINES">IMPORTED
  SUBROUTINES</a></h1>
<section class="Ss">
<h2 class="Ss" id="extends"><a class="permalink" href="#extends">extends</a></h2>
<pre>
 extends 'Parent::Class';
</pre>
<p class="Pp">Declares base class. Multiple superclasses can be passed for
    multiple inheritance (but please use roles instead). The class will be
    loaded, however no errors will be triggered if it can't be found and there
    are already subs in the class.</p>
<p class="Pp">Calling extends more than once will REPLACE your superclasses, not
    add to them like 'use base' would.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="with"><a class="permalink" href="#with">with</a></h2>
<pre>
 with 'Some::Role1';
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre>
 with 'Some::Role1', 'Some::Role2';
</pre>
<p class="Pp">Composes one or more Moo::Role (or Role::Tiny) roles into the
    current class. An error will be raised if these roles have conflicting
    methods. The roles will be loaded using the same mechansim as
    <span class="Li">&quot;extends&quot;</span> uses.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="has"><a class="permalink" href="#has">has</a></h2>
<pre>
 has attr =&gt; (
   is =&gt; 'ro',
 );
</pre>
<p class="Pp">Declares an attribute for the class.</p>
<p class="Pp"></p>
<pre>
 package Foo;
 use Moo;
 has 'attr' =&gt; (
   is =&gt; 'ro'
 );

 package Bar;
 use Moo;
 extends 'Foo';
 has '+attr' =&gt; (
   default =&gt; sub { &quot;blah&quot; },
 );
</pre>
<p class="Pp">Using the <span class="Li">&quot;+&quot;</span> notation, it's
    possible to override an attribute.</p>
<p class="Pp">The options for <span class="Li">&quot;has&quot;</span> are as
    follows:</p>
<ul class="Bl-bullet">
  <li>is
    <p class="Pp"><b>required</b>, may be
        <span class="Li">&quot;ro&quot;</span>,
        <span class="Li">&quot;lazy&quot;</span>,
        <span class="Li">&quot;rwp&quot;</span> or
        <span class="Li">&quot;rw&quot;</span>.</p>
    <p class="Pp"><span class="Li">&quot;ro&quot;</span> generates an accessor
        that dies if you attempt to write to it - i.e. a getter only - by
        defaulting <span class="Li">&quot;reader&quot;</span> to the name of the
        attribute.</p>
    <p class="Pp"><span class="Li">&quot;lazy&quot;</span> generates a reader
        like <span class="Li">&quot;ro&quot;</span>, but also sets
        <span class="Li">&quot;lazy&quot;</span> to 1 and
        <span class="Li">&quot;builder&quot;</span> to
        <span class="Li">&quot;_build_${attribute_name}&quot;</span> to allow
        on-demand generated attributes. This feature was my attempt to fix my
        incompetence when originally designing
        <span class="Li">&quot;lazy_build&quot;</span>, and is also implemented
        by MooseX::AttributeShortcuts. There is, however, nothing to stop you
        using <span class="Li">&quot;lazy&quot;</span> and
        <span class="Li">&quot;builder&quot;</span> yourself with
        <span class="Li">&quot;rwp&quot;</span> or
        <span class="Li">&quot;rw&quot;</span> - it's just that this isn't
        generally a good idea so we don't provide a shortcut for it.</p>
    <p class="Pp"><span class="Li">&quot;rwp&quot;</span> generates a reader
        like <span class="Li">&quot;ro&quot;</span>, but also sets
        <span class="Li">&quot;writer&quot;</span> to
        <span class="Li">&quot;_set_${attribute_name}&quot;</span> for
        attributes that are designed to be written from inside of the class, but
        read-only from outside. This feature comes from
        MooseX::AttributeShortcuts.</p>
    <p class="Pp"><span class="Li">&quot;rw&quot;</span> generates a normal
        getter/setter by defaulting <span class="Li">&quot;accessor&quot;</span>
        to the name of the attribute.</p>
  </li>
  <li>isa
    <p class="Pp">Takes a coderef which is meant to validate the attribute.
        Unlike Moose, Moo does not include a basic type system, so instead of
        doing <span class="Li">&quot;isa =&gt; 'Num'&quot;</span>, one should
      do</p>
    <p class="Pp"></p>
    <pre>
 isa =&gt; sub {
   die &quot;$_[0] is not a number!&quot; unless looks_like_number $_[0]
 },
    </pre>
    <p class="Pp">Note that the return value is ignored, only whether the sub
        lives or dies matters.</p>
    <p class="Pp">Sub::Quote aware</p>
    <p class="Pp">Since Moo does <b>not</b> run the
        <span class="Li">&quot;isa&quot;</span> check before
        <span class="Li">&quot;coerce&quot;</span> if a coercion subroutine has
        been supplied, <span class="Li">&quot;isa&quot;</span> checks are not
        structural to your code and can, if desired, be omitted on non-debug
        builds (although if this results in an uncaught bug causing your program
        to break, the Moo authors guarantee nothing except that you get to keep
        both halves).</p>
    <p class="Pp">If you want MooseX::Types style named types, look at
        MooX::Types::MooseLike.</p>
    <p class="Pp">To cause your <span class="Li">&quot;isa&quot;</span> entries
        to be automatically mapped to named Moose::Meta::TypeConstraint objects
        (rather than the default behaviour of creating an anonymous type),
      set:</p>
    <p class="Pp"></p>
    <pre>
  $Moo::HandleMoose::TYPE_MAP{$isa_coderef} = sub {
    require MooseX::Types::Something;
    return MooseX::Types::Something::TypeName();
  };
    </pre>
    <p class="Pp">Note that this example is purely illustrative; anything that
        returns a Moose::Meta::TypeConstraint object or something similar enough
        to it to make Moose happy is fine.</p>
  </li>
  <li>coerce
    <p class="Pp">Takes a coderef which is meant to coerce the attribute. The
        basic idea is to do something like the following:</p>
    <p class="Pp"></p>
    <pre>
 coerce =&gt; sub {
   $_[0] % 2 ? $_[0] : $_[0] + 1
 },
    </pre>
    <p class="Pp">Note that Moo will always fire your coercion: this is to
        permit <span class="Li">&quot;isa&quot;</span> entries to be used purely
        for bug trapping, whereas coercions are always structural to your code.
        We do, however, apply any supplied
        <span class="Li">&quot;isa&quot;</span> check after the coercion has run
        to ensure that it returned a valid value.</p>
    <p class="Pp">Sub::Quote aware</p>
  </li>
  <li>handles
    <p class="Pp">Takes a string</p>
    <p class="Pp"></p>
    <pre>
  handles =&gt; 'RobotRole'
    </pre>
    <p class="Pp">Where <span class="Li">&quot;RobotRole&quot;</span> is a role
        (Moo::Role) that defines an interface which becomes the list of methods
        to handle.</p>
    <p class="Pp">Takes a list of methods</p>
    <p class="Pp"></p>
    <pre>
 handles =&gt; [ qw( one two ) ]
    </pre>
    <p class="Pp">Takes a hashref</p>
    <p class="Pp"></p>
    <pre>
 handles =&gt; {
   un =&gt; 'one',
 }
    </pre>
  </li>
  <li><span class="Li">&quot;trigger&quot;</span>
    <p class="Pp">Takes a coderef which will get called any time the attribute
        is set. This includes the constructor, but not default or built values.
        Coderef will be invoked against the object with the new value as an
        argument.</p>
    <p class="Pp">If you set this to just <span class="Li">1</span>, it
        generates a trigger which calls the
        <span class="Li">&quot;_trigger_${attr_name}&quot;</span> method on
        <span class="Li">$self</span>. This feature comes from
        MooseX::AttributeShortcuts.</p>
    <p class="Pp">Note that Moose also passes the old value, if any; this
        feature is not yet supported.</p>
    <p class="Pp">Sub::Quote aware</p>
  </li>
  <li><span class="Li">&quot;default&quot;</span>
    <p class="Pp">Takes a coderef which will get called with
        <span class="Li">$self</span> as its only argument to populate an
        attribute if no value is supplied to the constructor - or if the
        attribute is lazy, when the attribute is first retrieved if no value has
        yet been provided.</p>
    <p class="Pp">If a simple scalar is provided, it will be inlined as a
        string. Any non-code reference (hash, array) will result in an error -
        for that case instead use a code reference that returns the desired
        value.</p>
    <p class="Pp">Note that if your default is fired during <i>new()</i> there
        is no guarantee that other attributes have been populated yet so you
        should not rely on their existence.</p>
    <p class="Pp">Sub::Quote aware</p>
  </li>
  <li><span class="Li">&quot;predicate&quot;</span>
    <p class="Pp">Takes a method name which will return true if an attribute has
        a value.</p>
    <p class="Pp">If you set this to just <span class="Li">1</span>, the
        predicate is automatically named
        <span class="Li">&quot;has_${attr_name}&quot;</span> if your attribute's
        name does not start with an underscore, or
        <span class="Li">&quot;_has_${attr_name_without_the_underscore}&quot;</span>
        if it does. This feature comes from MooseX::AttributeShortcuts.</p>
  </li>
  <li><span class="Li">&quot;builder&quot;</span>
    <p class="Pp">Takes a method name which will be called to create the
        attribute - functions exactly like default except that instead of
        calling</p>
    <p class="Pp"></p>
    <pre>
  $default-&gt;($self);
    </pre>
    <p class="Pp">Moo will call</p>
    <p class="Pp"></p>
    <pre>
  $self-&gt;$builder;
    </pre>
    <p class="Pp">The following features come from
      MooseX::AttributeShortcuts:</p>
    <p class="Pp">If you set this to just <span class="Li">1</span>, the builder
        is automatically named
        <span class="Li">&quot;_build_${attr_name}&quot;</span>.</p>
    <p class="Pp">If you set this to a coderef or code-convertible object, that
        variable will be installed under
        <span class="Li">&quot;$class::_build_${attr_name}&quot;</span> and the
        builder set to the same name.</p>
  </li>
  <li><span class="Li">&quot;clearer&quot;</span>
    <p class="Pp">Takes a method name which will clear the attribute.</p>
    <p class="Pp">If you set this to just <span class="Li">1</span>, the clearer
        is automatically named
        <span class="Li">&quot;clear_${attr_name}&quot;</span> if your
        attribute's name does not start with an underscore, or
        &lt;_clear_${attr_name_without_the_underscore}&gt; if it does. This
        feature comes from MooseX::AttributeShortcuts.</p>
  </li>
  <li><span class="Li">&quot;lazy&quot;</span>
    <p class="Pp"><b>Boolean</b>. Set this if you want values for the attribute
        to be grabbed lazily. This is usually a good idea if you have a
        &quot;builder&quot; which requires another attribute to be set.</p>
  </li>
  <li><span class="Li">&quot;required&quot;</span>
    <p class="Pp"><b>Boolean</b>. Set this if the attribute must be passed on
        instantiation.</p>
  </li>
  <li><span class="Li">&quot;reader&quot;</span>
    <p class="Pp">The value of this attribute will be the name of the method to
        get the value of the attribute. If you like Java style methods, you
        might set this to <span class="Li">&quot;get_foo&quot;</span></p>
  </li>
  <li><span class="Li">&quot;writer&quot;</span>
    <p class="Pp">The value of this attribute will be the name of the method to
        set the value of the attribute. If you like Java style methods, you
        might set this to <span class="Li">&quot;set_foo&quot;</span>.</p>
  </li>
  <li><span class="Li">&quot;weak_ref&quot;</span>
    <p class="Pp"><b>Boolean</b>. Set this if you want the reference that the
        attribute contains to be weakened; use this when circular references are
        possible, which will cause leaks.</p>
  </li>
  <li><span class="Li">&quot;init_arg&quot;</span>
    <p class="Pp">Takes the name of the key to look for at instantiation time of
        the object. A common use of this is to make an underscored attribute
        have a non-underscored initialization name.
        <span class="Li">&quot;undef&quot;</span> means that passing the value
        in on instantiation is ignored.</p>
  </li>
  <li><span class="Li">&quot;moosify&quot;</span>
    <p class="Pp">Takes either a coderef or array of coderefs which is meant to
        transform the given attributes specifications if necessary when
        upgrading to a Moose role or class. You shouldn't need this by default,
        but is provided as a means of possible extensibility.</p>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="before"><a class="permalink" href="#before">before</a></h2>
<pre>
 before foo =&gt; sub { ... };
</pre>
<p class="Pp">See &quot;before method(s) =&gt; sub { ... }&quot; in
    Class::Method::Modifiers for full documentation.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="around"><a class="permalink" href="#around">around</a></h2>
<pre>
 around foo =&gt; sub { ... };
</pre>
<p class="Pp">See &quot;around method(s) =&gt; sub { ... }&quot; in
    Class::Method::Modifiers for full documentation.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="after"><a class="permalink" href="#after">after</a></h2>
<pre>
 after foo =&gt; sub { ... };
</pre>
<p class="Pp">See &quot;after method(s) =&gt; sub { ... }&quot; in
    Class::Method::Modifiers for full documentation.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SUB_QUOTE_AWARE"><a class="permalink" href="#SUB_QUOTE_AWARE">SUB
  QUOTE AWARE</a></h1>
<p class="Pp">&quot;quote_sub&quot; in Sub::Quote allows us to create coderefs
    that are &quot;inlineable,&quot; giving us a handy, XS-free speed boost. Any
    option that is Sub::Quote aware can take advantage of this.</p>
<p class="Pp">To do this, you can write</p>
<p class="Pp"></p>
<pre>
  use Sub::Quote;

  use Moo;
  use namespace::clean;

  has foo =&gt; (
    is =&gt; 'ro',
    isa =&gt; quote_sub(q{ die &quot;Not &lt;3&quot; unless $_[0] &lt; 3 })
  );
</pre>
<p class="Pp">which will be inlined as</p>
<p class="Pp"></p>
<pre>
  do {
    local @_ = ($_[0]-&gt;{foo});
    die &quot;Not &lt;3&quot; unless $_[0] &lt; 3;
  }
</pre>
<p class="Pp">or to avoid localizing <span class="Li">@_</span>,</p>
<p class="Pp"></p>
<pre>
  has foo =&gt; (
    is =&gt; 'ro',
    isa =&gt; quote_sub(q{ my ($val) = @_; die &quot;Not &lt;3&quot; unless $val &lt; 3 })
  );
</pre>
<p class="Pp">which will be inlined as</p>
<p class="Pp"></p>
<pre>
  do {
    my ($val) = ($_[0]-&gt;{foo});
    die &quot;Not &lt;3&quot; unless $val &lt; 3;
  }
</pre>
<p class="Pp">See Sub::Quote for more information, including how to pass lexical
    captures that will also be compiled into the subroutine.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CLEANING_UP_IMPORTS"><a class="permalink" href="#CLEANING_UP_IMPORTS">CLEANING
  UP IMPORTS</a></h1>
<p class="Pp">Moo will not clean up imported subroutines for you; you will have
    to do that manually. The recommended way to do this is to declare your
    imports first, then <span class="Li">&quot;use Moo&quot;</span>, then
    <span class="Li">&quot;use namespace::clean&quot;</span>. Anything imported
    before namespace::clean will be scrubbed. Anything imported or declared
    after will be still be available.</p>
<p class="Pp"></p>
<pre>
 package Record;

 use Digest::MD5 qw(md5_hex);

 use Moo;
 use namespace::clean;

 has name =&gt; (is =&gt; 'ro', required =&gt; 1);
 has id =&gt; (is =&gt; 'lazy');
 sub _build_id {
   my ($self) = @_;
   return md5_hex($self-&gt;name);
 }

 1;
</pre>
<p class="Pp">If you were to import <span class="Li">&quot;md5_hex&quot;</span>
    after namespace::clean you would be able to call
    <span class="Li">&quot;-&gt;md5_hex()&quot;</span> on your
    <span class="Li">&quot;Record&quot;</span> instances (and it probably
    wouldn't do what you expect!).</p>
<p class="Pp">Moo::Roles behave slightly differently. Since their methods are
    composed into the consuming class, they can do a little more for you
    automatically. As long as you declare your imports before calling
    <span class="Li">&quot;use Moo::Role&quot;</span>, those imports and the
    ones Moo::Role itself provides will not be composed into consuming classes,
    so there's usually no need to use namespace::clean.</p>
<p class="Pp"><b>On namespace::autoclean:</b> If you're coming to Moo from the
    Moose world, you may be accustomed to using namespace::autoclean in all your
    packages. This is not recommended for Moo packages, because
    namespace::autoclean will inflate your class to a full Moose class. It'll
    work, but you will lose the benefits of Moo. Instead you are recommended to
    just use namespace::clean.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="INCOMPATIBILITIES_WITH_MOOSE"><a class="permalink" href="#INCOMPATIBILITIES_WITH_MOOSE">INCOMPATIBILITIES
  WITH MOOSE</a></h1>
<p class="Pp">There is no built-in type system.
    <span class="Li">&quot;isa&quot;</span> is verified with a coderef; if you
    need complex types, just make a library of coderefs, or better yet,
    functions that return quoted subs. MooX::Types::MooseLike provides a similar
    API to MooseX::Types::Moose so that you can write</p>
<p class="Pp"></p>
<pre>
  has days_to_live =&gt; (is =&gt; 'ro', isa =&gt; Int);
</pre>
<p class="Pp">and have it work with both; it is hoped that providing only
    subrefs as an API will encourage the use of other type systems as well,
    since it's probably the weakest part of Moose design-wise.</p>
<p class="Pp"><span class="Li">&quot;initializer&quot;</span> is not supported
    in core since the author considers it to be a bad idea and Moose best
    practices recommend avoiding it. Meanwhile
    <span class="Li">&quot;trigger&quot;</span> or
    <span class="Li">&quot;coerce&quot;</span> are more likely to be able to
    fulfill your needs.</p>
<p class="Pp">There is no meta object. If you need this level of complexity you
    wanted Moose - Moo succeeds at being small because it explicitly does not
    provide a metaprotocol. However, if you load Moose, then</p>
<p class="Pp"></p>
<pre>
  Class::MOP::class_of($moo_class_or_role)
</pre>
<p class="Pp">will return an appropriate metaclass pre-populated by Moo.</p>
<p class="Pp">No support for <span class="Li">&quot;super&quot;</span>,
    <span class="Li">&quot;override&quot;</span>,
    <span class="Li">&quot;inner&quot;</span>, or
    <span class="Li">&quot;augment&quot;</span> - the author considers augment
    to be a bad idea, and override can be translated:</p>
<p class="Pp"></p>
<pre>
  override foo =&gt; sub {
    ...
    super();
    ...
  };

  around foo =&gt; sub {
    my ($orig, $self) = (shift, shift);
    ...
    $self-&gt;$orig(@_);
    ...
  };
</pre>
<p class="Pp">The <span class="Li">&quot;dump&quot;</span> method is not
    provided by default. The author suggests loading Devel::Dwarn into
    <span class="Li">&quot;main::&quot;</span> (via <span class="Li">&quot;perl
    -MDevel::Dwarn ...&quot;</span> for example) and using
    <span class="Li">&quot;$obj-&gt;$::Dwarn()&quot;</span> instead.</p>
<p class="Pp">&quot;default&quot; only supports coderefs and plain scalars,
    because passing a hash or array reference as a default is almost always
    incorrect since the value is then shared between all objects using that
    default.</p>
<p class="Pp"><span class="Li">&quot;lazy_build&quot;</span> is not supported;
    you are instead encouraged to use the <span class="Li">&quot;is =&gt;
    'lazy'&quot;</span> option supported by Moo and
  MooseX::AttributeShortcuts.</p>
<p class="Pp"><span class="Li">&quot;auto_deref&quot;</span> is not supported
    since the author considers it a bad idea and it has been considered best
    practice to avoid it for some time.</p>
<p class="Pp"><span class="Li">&quot;documentation&quot;</span> will show up in
    a Moose metaclass created from your class but is otherwise ignored. Then
    again, Moose ignores it as well, so this is arguably not an
  incompatibility.</p>
<p class="Pp">Since <span class="Li">&quot;coerce&quot;</span> does not require
    <span class="Li">&quot;isa&quot;</span> to be defined but Moose does require
    it, the metaclass inflation for coerce alone is a trifle insane and if you
    attempt to subtype the result will almost certainly break.</p>
<p class="Pp"><span class="Li">&quot;BUILDARGS&quot;</span> is not triggered if
    your class does not have any attributes. Without attributes,
    <span class="Li">&quot;BUILDARGS&quot;</span> return value would be ignored,
    so we just skip calling the method instead.</p>
<p class="Pp">Handling of warnings: when you <span class="Li">&quot;use
    Moo&quot;</span> we enable FATAL warnings, and some several extra pragmas
    when used in development: indirect, multidimensional, and
    bareword::filehandles. See the strictures documentation for the details on
    this.</p>
<p class="Pp">A similar invocation for Moose would be:</p>
<p class="Pp"></p>
<pre>
  use Moose;
  use warnings FATAL =&gt; &quot;all&quot;;
</pre>
<p class="Pp">Additionally, Moo supports a set of attribute option shortcuts
    intended to reduce common boilerplate. The set of shortcuts is the same as
    in the Moose module MooseX::AttributeShortcuts as of its version 0.009+. So
    if you:</p>
<p class="Pp"></p>
<pre>
    package MyClass;
    use Moo;
</pre>
<p class="Pp">The nearest Moose invocation would be:</p>
<p class="Pp"></p>
<pre>
    package MyClass;

    use Moose;
    use warnings FATAL =&gt; &quot;all&quot;;
    use MooseX::AttributeShortcuts;
</pre>
<p class="Pp">or, if you're inheriting from a non-Moose class,</p>
<p class="Pp"></p>
<pre>
    package MyClass;

    use Moose;
    use MooseX::NonMoose;
    use warnings FATAL =&gt; &quot;all&quot;;
    use MooseX::AttributeShortcuts;
</pre>
<p class="Pp">Finally, Moose requires you to call</p>
<p class="Pp"></p>
<pre>
    __PACKAGE__-&gt;meta-&gt;make_immutable;
</pre>
<p class="Pp">at the end of your class to get an inlined (i.e. not horribly
    slow) constructor. Moo does it automatically the first time -&gt;new is
    called on your class. (<span class="Li">&quot;make_immutable&quot;</span> is
    a no-op in Moo to ease migration.)</p>
<p class="Pp">An extension MooX::late exists to ease translating Moose packages
    to Moo by providing a more Moose-like interface.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
<p class="Pp">Users' IRC: #moose on irc.perl.org</p>
<p class="Pp">Development and contribution IRC: #web-simple on irc.perl.org</p>
<p class="Pp">Bugtracker:
    &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=Moo&gt;</p>
<p class="Pp">Git repository: &lt;git://github.com/moose/Moo.git&gt;</p>
<p class="Pp">Git browser: &lt;https://github.com/moose/Moo&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">mst - Matt S. Trout (cpan:MSTROUT) &lt;mst@shadowcat.co.uk&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<p class="Pp">dg - David Leadbeater (cpan:DGL) &lt;dgl@dgl.cx&gt;</p>
<p class="Pp">frew - Arthur Axel &quot;fREW&quot; Schmidt (cpan:FREW)
    &lt;frioux@gmail.com&gt;</p>
<p class="Pp">hobbs - Andrew Rodland (cpan:ARODLAND)
  &lt;arodland@cpan.org&gt;</p>
<p class="Pp">jnap - John Napiorkowski (cpan:JJNAPIORK)
    &lt;jjn1056@yahoo.com&gt;</p>
<p class="Pp">ribasushi - Peter Rabbitson (cpan:RIBASUSHI)
    &lt;ribasushi@cpan.org&gt;</p>
<p class="Pp">chip - Chip Salzenberg (cpan:CHIPS) &lt;chip@pobox.com&gt;</p>
<p class="Pp">ajgb - Alex J. G. BurzyXski (cpan:AJGB) &lt;ajgb@cpan.org&gt;</p>
<p class="Pp">doy - Jesse Luehrs (cpan:DOY) &lt;doy at tozt dot net&gt;</p>
<p class="Pp">perigrin - Chris Prather (cpan:PERIGRIN)
  &lt;chris@prather.org&gt;</p>
<p class="Pp">Mithaldu - Christian Walde (cpan:MITHALDU)
    &lt;walde.christian@googlemail.com&gt;</p>
<p class="Pp">ilmari - Dagfinn Ilmari Mannsaaker (cpan:ILMARI)
    &lt;ilmari@ilmari.org&gt;</p>
<p class="Pp">tobyink - Toby Inkster (cpan:TOBYINK) &lt;tobyink@cpan.org&gt;</p>
<p class="Pp">haarg - Graham Knop (cpan:HAARG) &lt;haarg@cpan.org&gt;</p>
<p class="Pp">mattp - Matt Phillips (cpan:MATTP) &lt;mattp@cpan.org&gt;</p>
<p class="Pp">bluefeet - Aran Deltac (cpan:BLUEFEET)
  &lt;bluefeet@gmail.com&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 2010-2011 the Moo &quot;AUTHOR&quot; and
    &quot;CONTRIBUTORS&quot; as listed above.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">This library is free software and may be distributed under the
    same terms as perl itself. See &lt;http://dev.perl.org/licenses/&gt;.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-12-31</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

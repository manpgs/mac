<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>DynaLoader(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DynaLoader(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">DynaLoader(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">DynaLoader - Dynamically load C libraries into Perl code</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    package YourPackage;
    require DynaLoader;
    @ISA = qw(... DynaLoader ...);
    __PACKAGE__-&gt;bootstrap;
    # optional method for 'global' loading
    sub dl_load_flags { 0x01 }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This document defines a standard generic interface to the dynamic
    linking mechanisms available on many platforms. Its primary purpose is to
    implement automatic dynamic loading of Perl modules.</p>
<p class="Pp">This document serves as both a specification for anyone wishing to
    implement the DynaLoader for a new platform and as a guide for anyone
    wishing to use the DynaLoader directly in an application.</p>
<p class="Pp">The DynaLoader is designed to be a very simple high-level
    interface that is sufficiently general to cover the requirements of SunOS,
    HP-UX, Linux, VMS and other platforms.</p>
<p class="Pp">It is also hoped that the interface will cover the needs of OS/2,
    NT etc and also allow pseudo-dynamic linking (using
    <span class="Li">&quot;ld -A&quot;</span> at runtime).</p>
<p class="Pp">It must be stressed that the DynaLoader, by itself, is practically
    useless for accessing non-Perl libraries because it provides almost no
    Perl-to-C 'glue'. There is, for example, no mechanism for calling a C
    library function or supplying arguments. A C::DynaLib module is available
    from CPAN sites which performs that function for some common system types.
    And since the year 2000, there's also Inline::C, a module that allows you to
    write Perl subroutines in C. Also available from your local CPAN site.</p>
<p class="Pp">DynaLoader Interface Summary</p>
<p class="Pp"></p>
<pre>  @dl_library_path
  @dl_resolve_using
  @dl_require_symbols
  $dl_debug
  $dl_dlext
  @dl_librefs
  @dl_modules
  @dl_shared_objects
                                                  Implemented in:
  bootstrap($modulename)                               Perl
  @filepaths = dl_findfile(@names)                     Perl
  $flags = $modulename-&gt;dl_load_flags                  Perl
  $symref  = dl_find_symbol_anywhere($symbol)          Perl
  $libref  = dl_load_file($filename, $flags)           C
  $status  = dl_unload_file($libref)                   C
  $symref  = dl_find_symbol($libref, $symbol)          C
  @symbols = dl_undef_symbols()                        C
  dl_install_xsub($name, $symref [, $filename])        C
  $message = dl_error                                  C
</pre>
<dl class="Bl-tag">
  <dt>@dl_library_path</dt>
  <dd>The standard/default list of directories in which <b>dl_findfile()</b>
      will search for libraries etc. Directories are searched in order:
      <span class="Li">$dl_library_path</span>[0], [1], ... etc
    <p class="Pp"><span class="Li">@dl_library_path</span> is initialised to
        hold the list of 'normal' directories (<i>/usr/lib</i>, etc) determined
        by <b>Configure</b> (<span class="Li">$Config{'libpth'}</span>). This
        should ensure portability across a wide range of platforms.</p>
    <p class="Pp"><span class="Li">@dl_library_path</span> should also be
        initialised with any other directories that can be determined from the
        environment at runtime (such as LD_LIBRARY_PATH for SunOS).</p>
    <p class="Pp">After initialisation <span class="Li">@dl_library_path</span>
        can be manipulated by an application using push and unshift before
        calling <b>dl_findfile()</b>. Unshift can be used to add directories to
        the front of the search order either to save search time or to override
        libraries with the same name in the 'normal' directories.</p>
    <p class="Pp">The load function that <b>dl_load_file()</b> calls may require
        an absolute pathname. The <b>dl_findfile()</b> function and
        <span class="Li">@dl_library_path</span> can be used to search for and
        return the absolute pathname for the library/object that you wish to
        load.</p>
  </dd>
  <dt>@dl_resolve_using</dt>
  <dd>A list of additional libraries or other shared objects which can be used
      to resolve any undefined symbols that might be generated by a later call
      to <b>load_file()</b>.
    <p class="Pp">This is only required on some platforms which do not handle
        dependent libraries automatically. For example the Socket Perl extension
        library (<i>auto/Socket/Socket.so</i>) contains references to many
        socket functions which need to be resolved when it's loaded. Most
        platforms will automatically know where to find the 'dependent' library
        (e.g., <i>/usr/lib/libsocket.so</i>). A few platforms need to be told
        the location of the dependent library explicitly. Use
        <span class="Li">@dl_resolve_using</span> for this.</p>
    <p class="Pp">Example usage:</p>
    <p class="Pp"></p>
    <pre>    @dl_resolve_using = dl_findfile('-lsocket');
    </pre>
  </dd>
  <dt>@dl_require_symbols</dt>
  <dd>A list of one or more symbol names that are in the library/object file to
      be dynamically loaded. This is only required on some platforms.</dd>
  <dt>@dl_librefs</dt>
  <dd>An array of the handles returned by successful calls to
      <b>dl_load_file()</b>, made by bootstrap, in the order in which they were
      loaded. Can be used with <b>dl_find_symbol()</b> to look for a symbol in
      any of the loaded files.</dd>
  <dt>@dl_modules</dt>
  <dd>An array of module (package) names that have been bootstrap'ed.</dd>
  <dt>@dl_shared_objects</dt>
  <dd>An array of file names for the shared objects that were loaded.</dd>
  <dt id="dl_error()"><a class="permalink" href="#dl_error()"><b>dl_error()</b></a></dt>
  <dd>Syntax:
    <p class="Pp"></p>
    <pre>    $message = dl_error();
    </pre>
    <p class="Pp">Error message text from the last failed DynaLoader function.
        Note that, similar to errno in unix, a successful function call does not
        reset this message.</p>
    <p class="Pp">Implementations should detect the error as soon as it occurs
        in any of the other functions and save the corresponding message for
        later retrieval. This will avoid problems on some platforms (such as
        SunOS) where the error message is very temporary (e.g.,
        <b>dlerror()</b>).</p>
  </dd>
  <dt>$dl_debug</dt>
  <dd>Internal debugging messages are enabled when
      <span class="Li">$dl_debug</span> is set true. Currently setting
      <span class="Li">$dl_debug</span> only affects the Perl side of the
      DynaLoader. These messages should help an application developer to resolve
      any DynaLoader usage problems.
    <p class="Pp"><span class="Li">$dl_debug</span> is set to
        <span class="Li">$ENV{'PERL_DL_DEBUG'}</span> if defined.</p>
    <p class="Pp">For the DynaLoader developer/porter there is a similar
        debugging variable added to the C code (see dlutils.c) and enabled if
        Perl was built with the <b>-DDEBUGGING</b> flag. This can also be set
        via the PERL_DL_DEBUG environment variable. Set to 1 for minimal
        information or higher for more.</p>
  </dd>
  <dt>$dl_dlext</dt>
  <dd>When specified (localised) in a module's <i>.pm</i> file, indicates the
      extension which the module's loadable object will have. For example:
    <p class="Pp"></p>
    <pre>    local $DynaLoader::dl_dlext = 'unusual_ext';
    </pre>
    <p class="Pp">would indicate that the module's loadable object has an
        extension of <span class="Li">&quot;unusual_ext&quot;</span> instead of
        the more usual <span class="Li">$Config{dlext}</span>. NOTE: This also
        requires that the module's <i>Makefile.PL</i> specify (in
        <span class="Li">&quot;WriteMakefile()&quot;</span>):</p>
    <p class="Pp"></p>
    <pre>    DLEXT =&gt; 'unusual_ext',
    </pre>
  </dd>
  <dt id="dl_findfile()"><a class="permalink" href="#dl_findfile()"><b>dl_findfile()</b></a></dt>
  <dd>Syntax:
    <p class="Pp"></p>
    <pre>    @filepaths = dl_findfile(@names)
    </pre>
    <p class="Pp">Determine the full paths (including file suffix) of one or
        more loadable files given their generic names and optionally one or more
        directories. Searches directories in
        <span class="Li">@dl_library_path</span> by default and returns an empty
        list if no files were found.</p>
    <p class="Pp">Names can be specified in a variety of platform independent
        forms. Any names in the form <b>-lname</b> are converted into
        <i>libname.*</i>, where <i>.*</i> is an appropriate suffix for the
        platform.</p>
    <p class="Pp">If a name does not already have a suitable prefix and/or
        suffix then the corresponding file will be searched for by trying
        combinations of prefix and suffix appropriate to the platform:
        &quot;$name.o&quot;, &quot;lib$name.*&quot; and &quot;$name&quot;.</p>
    <p class="Pp">If any directories are included in
        <span class="Li">@names</span> they are searched before
        <span class="Li">@dl_library_path</span>. Directories may be specified
        as <b>-Ldir</b>. Any other names are treated as filenames to be searched
        for.</p>
    <p class="Pp">Using arguments of the form
        <span class="Li">&quot;-Ldir&quot;</span> and
        <span class="Li">&quot;-lname&quot;</span> is recommended.</p>
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>    @dl_resolve_using = dl_findfile(qw(-L/usr/5lib -lposix));
    </pre>
  </dd>
  <dt id="dl_expandspec()"><a class="permalink" href="#dl_expandspec()"><b>dl_expandspec()</b></a></dt>
  <dd>Syntax:
    <p class="Pp"></p>
    <pre>    $filepath = dl_expandspec($spec)
    </pre>
    <p class="Pp">Some unusual systems, such as VMS, require special filename
        handling in order to deal with symbolic names for files (i.e., VMS's
        Logical Names).</p>
    <p class="Pp">To support these systems a <b>dl_expandspec()</b> function can
        be implemented either in the <i>dl_*.xs</i> file or code can be added to
        the <b>dl_expandspec()</b> function in <i>DynaLoader.pm</i>. See
        <i>DynaLoader_pm.PL</i> for more information.</p>
  </dd>
  <dt id="dl_load_file()"><a class="permalink" href="#dl_load_file()"><b>dl_load_file()</b></a></dt>
  <dd>Syntax:
    <p class="Pp"></p>
    <pre>    $libref = dl_load_file($filename, $flags)
    </pre>
    <p class="Pp">Dynamically load <span class="Li">$filename</span>, which must
        be the path to a shared object or library. An opaque 'library reference'
        is returned as a handle for the loaded object. Returns undef on
      error.</p>
    <p class="Pp">The <span class="Li">$flags</span> argument to alters
        dl_load_file behaviour. Assigned bits:</p>
    <p class="Pp"></p>
    <pre> 0x01  make symbols available for linking later dl_load_file's.
       (only known to work on Solaris 2 using dlopen(RTLD_GLOBAL))
       (ignored under VMS; this is a normal part of image linking)
    </pre>
    <p class="Pp">(On systems that provide a handle for the loaded object such
        as SunOS and HPUX, <span class="Li">$libref</span> will be that handle.
        On other systems <span class="Li">$libref</span> will typically be
        <span class="Li">$filename</span> or a pointer to a buffer containing
        <span class="Li">$filename</span>. The application should not examine or
        alter <span class="Li">$libref</span> in any way.)</p>
    <p class="Pp">This is the function that does the real work. It should use
        the current values of <span class="Li">@dl_require_symbols</span> and
        <span class="Li">@dl_resolve_using</span> if required.</p>
    <p class="Pp"></p>
    <pre>    SunOS: dlopen($filename)
    HP-UX: shl_load($filename)
    Linux: dld_create_reference(@dl_require_symbols); dld_link($filename)
    VMS:   lib$find_image_symbol($filename,$dl_require_symbols[0])
    </pre>
    <p class="Pp">(The <b>dlopen()</b> function is also used by Solaris and some
        versions of Linux, and is a common choice when providing a
        &quot;wrapper&quot; on other mechanisms as is done in the OS/2
      port.)</p>
  </dd>
  <dt id="dl_unload_file()"><a class="permalink" href="#dl_unload_file()"><b>dl_unload_file()</b></a></dt>
  <dd>Syntax:
    <p class="Pp"></p>
    <pre>    $status = dl_unload_file($libref)
    </pre>
    <p class="Pp">Dynamically unload <span class="Li">$libref</span>, which must
        be an opaque 'library reference' as returned from dl_load_file. Returns
        one on success and zero on failure. This function is optional and may
        not necessarily be provided on all platforms.</p>
    <p class="Pp">If it is defined and perl is compiled with the C macro
        <span class="Li">&quot;DL_UNLOAD_ALL_AT_EXIT&quot;</span> defined, then
        it is called automatically when the interpreter exits for every shared
        object or library loaded by DynaLoader::bootstrap. All such library
        references are stored in <span class="Li">@dl_librefs</span> by
        DynaLoader::Bootstrap as it loads the libraries. The files are unloaded
        in last-in, first-out order.</p>
    <p class="Pp">This unloading is usually necessary when embedding a
        shared-object perl (e.g. one configured with -Duseshrplib) within a
        larger application, and the perl interpreter is created and destroyed
        several times within the lifetime of the application. In this case it is
        possible that the system dynamic linker will unload and then
        subsequently reload the shared libperl without relocating any references
        to it from any files DynaLoaded by the previous incarnation of the
        interpreter. As a result, any shared objects opened by DynaLoader may
        point to a now invalid 'ghost' of the libperl shared object, causing
        apparently random memory corruption and crashes. This behaviour is most
        commonly seen when using Apache and mod_perl built with the APXS
        mechanism.</p>
    <p class="Pp"></p>
    <pre>    SunOS: dlclose($libref)
    HP-UX: ???
    Linux: ???
    VMS:   ???
    </pre>
    <p class="Pp">(The <b>dlclose()</b> function is also used by Solaris and
        some versions of Linux, and is a common choice when providing a
        &quot;wrapper&quot; on other mechanisms as is done in the OS/2
      port.)</p>
  </dd>
  <dt id="dl_load_flags()"><a class="permalink" href="#dl_load_flags()"><b>dl_load_flags()</b></a></dt>
  <dd>Syntax:
    <p class="Pp"></p>
    <pre>    $flags = dl_load_flags $modulename;
    </pre>
    <p class="Pp">Designed to be a method call, and to be overridden by a
        derived class (i.e. a class which has DynaLoader in its
        <span class="Li">@ISA</span>). The definition in DynaLoader itself
        returns 0, which produces standard behavior from
      <b>dl_load_file()</b>.</p>
  </dd>
  <dt id="dl_find_symbol()"><a class="permalink" href="#dl_find_symbol()"><b>dl_find_symbol()</b></a></dt>
  <dd>Syntax:
    <p class="Pp"></p>
    <pre>    $symref = dl_find_symbol($libref, $symbol)
    </pre>
    <p class="Pp">Return the address of the symbol
        <span class="Li">$symbol</span> or
        <span class="Li">&quot;undef&quot;</span> if not found. If the target
        system has separate functions to search for symbols of different types
        then <b>dl_find_symbol()</b> should search for function symbols first
        and then other types.</p>
    <p class="Pp">The exact manner in which the address is returned in
        <span class="Li">$symref</span> is not currently defined. The only
        initial requirement is that <span class="Li">$symref</span> can be
        passed to, and understood by, <b>dl_install_xsub()</b>.</p>
    <p class="Pp"></p>
    <pre>    SunOS: dlsym($libref, $symbol)
    HP-UX: shl_findsym($libref, $symbol)
    Linux: dld_get_func($symbol) and/or dld_get_symbol($symbol)
    VMS:   lib$find_image_symbol($libref,$symbol)
    </pre>
  </dd>
  <dt id="dl_find_symbol_anywhere()"><a class="permalink" href="#dl_find_symbol_anywhere()"><b>dl_find_symbol_anywhere()</b></a></dt>
  <dd>Syntax:
    <p class="Pp"></p>
    <pre>    $symref = dl_find_symbol_anywhere($symbol)
    </pre>
    <p class="Pp">Applies <b>dl_find_symbol()</b> to the members of
        <span class="Li">@dl_librefs</span> and returns the first match
      found.</p>
  </dd>
  <dt id="dl_undef_symbols()"><a class="permalink" href="#dl_undef_symbols()"><b>dl_undef_symbols()</b></a></dt>
  <dd>Example
    <p class="Pp"></p>
    <pre>    @symbols = dl_undef_symbols()
    </pre>
    <p class="Pp">Return a list of symbol names which remain undefined after
        <b>load_file()</b>. Returns <span class="Li">&quot;()&quot;</span> if
        not known. Don't worry if your platform does not provide a mechanism for
        this. Most do not need it and hence do not provide it, they just return
        an empty list.</p>
  </dd>
  <dt id="dl_install_xsub()"><a class="permalink" href="#dl_install_xsub()"><b>dl_install_xsub()</b></a></dt>
  <dd>Syntax:
    <p class="Pp"></p>
    <pre>    dl_install_xsub($perl_name, $symref [, $filename])
    </pre>
    <p class="Pp">Create a new Perl external subroutine named
        <span class="Li">$perl_name</span> using <span class="Li">$symref</span>
        as a pointer to the function which implements the routine. This is
        simply a direct call to <b>newXS()</b>/<b>newXS_flags()</b>. Returns a
        reference to the installed function.</p>
    <p class="Pp">The <span class="Li">$filename</span> parameter is used by
        Perl to identify the source file for the function if required by
        <b>die()</b>, <b>caller()</b> or the debugger. If
        <span class="Li">$filename</span> is not defined then
        &quot;DynaLoader&quot; will be used.</p>
  </dd>
  <dt id="bootstrap()"><a class="permalink" href="#bootstrap()"><b>bootstrap()</b></a></dt>
  <dd>Syntax:
    <p class="Pp">bootstrap($module [...])</p>
    <p class="Pp">This is the normal entry point for automatic dynamic loading
        in Perl.</p>
    <p class="Pp">It performs the following actions:</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>locates an auto/$module directory by searching
      <span class="Li">@INC</span></li>
  <li>uses <b>dl_findfile()</b> to determine the filename to load</li>
  <li>sets <span class="Li">@dl_require_symbols</span> to
      <span class="Li">&quot;(&quot;boot_$module&quot;)&quot;</span></li>
  <li>executes an <i>auto/$module/$module.bs</i> file if it exists (typically
      used to add to <span class="Li">@dl_resolve_using</span> any files which
      are required to load the module on the current platform)</li>
  <li>calls <b>dl_load_flags()</b> to determine how to load the file.</li>
  <li>calls <b>dl_load_file()</b> to load the file</li>
  <li>calls <b>dl_undef_symbols()</b> and warns if any symbols are
    undefined</li>
  <li>calls <b>dl_find_symbol()</b> for &quot;boot_$module&quot;</li>
  <li>calls <b>dl_install_xsub()</b> to install it as
      &quot;${module}::bootstrap&quot;</li>
  <li>calls &amp;{&quot;${module}::bootstrap&quot;} to bootstrap the module
      (actually it uses the function reference returned by dl_install_xsub for
      speed)</li>
</ul>
</div>
<div class="Bd-indent">
<p class="Pp">All arguments to <b>bootstrap()</b> are passed to the module's
    bootstrap function. The default code generated by <i>xsubpp</i> expects
    <span class="Li">$module</span> [, <span class="Li">$version</span>] If the
    optional <span class="Li">$version</span> argument is not given, it defaults
    to <span class="Li">&quot;$XS_VERSION // $VERSION&quot;</span> in the
    module's symbol table. The default code compares the Perl-space version with
    the version of the compiled XS code, and croaks with an error if they do not
    match.</p>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Tim Bunce, 11 August 1994.</p>
<p class="Pp">This interface is based on the work and comments of (in no
    particular order): Larry Wall, Robert Sanders, Dean Roehrich, Jeff Okamoto,
    Anno Siegel, Thomas Neumann, Paul Marquess, Charles Bailey, myself and
    others.</p>
<p class="Pp">Larry Wall designed the elegant inherited bootstrap mechanism and
    implemented the first Perl 5 dynamic loader using it.</p>
<p class="Pp">Solaris global loading added by Nick Ing-Simmons with
    design/coding assistance from Tim Bunce, January 1996.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2023-08-05</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

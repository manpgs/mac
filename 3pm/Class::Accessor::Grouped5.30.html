<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Class::Accessor::Grouped(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Class::Accessor::Grouped(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Class::Accessor::Grouped(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Class::Accessor::Grouped - Lets you build groups of accessors</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre> use base 'Class::Accessor::Grouped';
 # make basic accessors for objects
 __PACKAGE__-&gt;mk_group_accessors(simple =&gt; qw(id name email));
 # make accessor that works for objects and classes
 __PACKAGE__-&gt;mk_group_accessors(inherited =&gt; 'awesome_level');
 # make an accessor which calls a custom pair of getters/setters
 sub get_column { ... this will be called when you do $obj-&gt;name() ... }
 sub set_column { ... this will be called when you do $obj-&gt;name('foo') ... }
 __PACKAGE__-&gt;mk_group_accessors(column =&gt; 'name');
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This class lets you build groups of accessors that will call
    different getters and setters. The documentation of this module still
    requires a lot of work (<b>volunteers welcome &gt;.&gt;</b>), but in the
    meantime you can refer to this post
    &lt;http://lo-f.at/glahn/2009/08/WritingPowerfulAccessorsForPerlClasses.html&gt;
    for more information.</p>
<section class="Ss">
<h2 class="Ss" id="Notes_on_accessor_names"><a class="permalink" href="#Notes_on_accessor_names">Notes
  on accessor names</a></h2>
<p class="Pp">In general method names in Perl are considered identifiers, and as
    such need to conform to the identifier specification of
    <span class="Li">&quot;qr/\A[A-Z_a-z][0-9A-Z_a-z]*\z/&quot;</span>. While it
    is rather easy to invoke methods with non-standard names
    (<span class="Li">&quot;$obj-&gt;${\&quot;anything
    goes&quot;}&quot;</span>), it is not possible to properly declare such
    methods without the use of Sub::Name. Since this module must be able to
    function identically with and without its optional dependencies, starting
    with version <span class="Li">0.10008</span> attempting to declare an
    accessor with a non-standard name is a fatal error (such operations would
    silently succeed since version <span class="Li">0.08004</span>, as long as
    Sub::Name is present, or otherwise would result in a syntax error during a
    string eval).</p>
<p class="Pp">Unfortunately in the years since <span class="Li">0.08004</span> a
    rather large body of code accumulated in the wild that does attempt to
    declare accessors with funny names. One notable perpetrator is
    DBIx::Class::Schema::Loader, which under certain conditions could create
    accessors of the <span class="Li">&quot;column&quot;</span> group which
    start with numbers and/or some other punctuation (the proper way would be to
    declare columns with the <span class="Li">&quot;accessor&quot;</span>
    attribute set to <span class="Li">&quot;undef&quot;</span>).</p>
<p class="Pp">Therefore an escape mechanism is provided via the environment
    variable <span class="Li">&quot;CAG_ILLEGAL_ACCESSOR_NAME_OK&quot;</span>.
    When set to a true value, one warning is issued <b>per class</b> on attempts
    to declare an accessor with a non-conforming name, and as long as Sub::Name
    is available all accessors will be properly created. Regardless of this
    setting, accessor names containing nulls
    <span class="Li">&quot;\0&quot;</span> are disallowed, due to various
    deficiencies in perl itself.</p>
<p class="Pp">If your code base has too many instances of illegal accessor
    declarations, and a fix is not feasible due to time constraints, it is
    possible to disable the warnings altogether by setting
    <span class="Li">$ENV{CAG_ILLEGAL_ACCESSOR_NAME_OK}</span> to
    <span class="Li">&quot;DO_NOT_WARN&quot;</span> (observe
  capitalization).</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="mk_group_accessors"><a class="permalink" href="#mk_group_accessors">mk_group_accessors</a></h2>
<pre> __PACKAGE__-&gt;mk_group_accessors(simple =&gt; 'hair_length', [ hair_color =&gt; 'hc' ]);
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:"><a class="permalink" href="#Arguments:">Arguments: $group,
    @fieldspec</a></dt>
  <dd>Returns: none</dd>
</dl>
<p class="Pp">Creates a set of accessors in a given group.</p>
<p class="Pp"><span class="Li">$group</span> is the name of the accessor group
    for the generated accessors; they will call get_$group($field) on get and
    set_$group($field, <span class="Li">$value</span>) on set.</p>
<p class="Pp">If you want to mimic Class::Accessor's mk_accessors
    <span class="Li">$group</span> has to be 'simple' to tell
    Class::Accessor::Grouped to use its own get_simple and set_simple
  methods.</p>
<p class="Pp"><span class="Li">@fieldspec</span> is a list of field/accessor
    names; if a fieldspec is a scalar this is used as both field and accessor
    name, if a listref it is expected to be of the form [
    <span class="Li">$accessor</span>, <span class="Li">$field</span> ].</p>
</section>
<section class="Ss">
<h2 class="Ss" id="mk_group_ro_accessors"><a class="permalink" href="#mk_group_ro_accessors">mk_group_ro_accessors</a></h2>
<pre> __PACKAGE__-&gt;mk_group_ro_accessors(simple =&gt; 'birthdate', [ social_security_number =&gt; 'ssn' ]);
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:~2"><a class="permalink" href="#Arguments:~2">Arguments:
    $group, @fieldspec</a></dt>
  <dd>Returns: none</dd>
</dl>
<p class="Pp">Creates a set of read only accessors in a given group. Identical
    to &quot;mk_group_accessors&quot; but accessors will throw an error if
    passed a value rather than setting the value.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="mk_group_wo_accessors"><a class="permalink" href="#mk_group_wo_accessors">mk_group_wo_accessors</a></h2>
<pre> __PACKAGE__-&gt;mk_group_wo_accessors(simple =&gt; 'lie', [ subject =&gt; 'subj' ]);
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:~3"><a class="permalink" href="#Arguments:~3">Arguments:
    $group, @fieldspec</a></dt>
  <dd>Returns: none</dd>
</dl>
<p class="Pp">Creates a set of write only accessors in a given group. Identical
    to &quot;mk_group_accessors&quot; but accessors will throw an error if not
    passed a value rather than getting the value.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="get_simple"><a class="permalink" href="#get_simple">get_simple</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~4"><a class="permalink" href="#Arguments:~4">Arguments:
    $field</a></dt>
  <dd>Returns: <span class="Li">$value</span></dd>
</dl>
<p class="Pp">Simple getter for hash-based objects which returns the value for
    the field name passed as an argument.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="set_simple"><a class="permalink" href="#set_simple">set_simple</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~5"><a class="permalink" href="#Arguments:~5">Arguments:
    $field, $new_value</a></dt>
  <dd>Returns: <span class="Li">$new_value</span></dd>
</dl>
<p class="Pp">Simple setter for hash-based objects which sets and then returns
    the value for the field name passed as an argument.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="get_inherited"><a class="permalink" href="#get_inherited">get_inherited</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~6"><a class="permalink" href="#Arguments:~6">Arguments:
    $field</a></dt>
  <dd>Returns: <span class="Li">$value</span></dd>
</dl>
<p class="Pp">Simple getter for Classes and hash-based objects which returns the
    value for the field name passed as an argument. This behaves much like
    Class::Data::Accessor where the field can be set in a base class, inherited
    and changed in subclasses, and inherited and changed for object
  instances.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="set_inherited"><a class="permalink" href="#set_inherited">set_inherited</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~7"><a class="permalink" href="#Arguments:~7">Arguments:
    $field, $new_value</a></dt>
  <dd>Returns: <span class="Li">$new_value</span></dd>
</dl>
<p class="Pp">Simple setter for Classes and hash-based objects which sets and
    then returns the value for the field name passed as an argument. When called
    on a hash-based object it will set the appropriate hash key value. When
    called on a class, it will set a class level variable.</p>
<p class="Pp"><b>Note:</b>: This method will die if you try to set an object
    variable on a non hash-based object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="get_component_class"><a class="permalink" href="#get_component_class">get_component_class</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~8"><a class="permalink" href="#Arguments:~8">Arguments:
    $field</a></dt>
  <dd>Returns: <span class="Li">$value</span></dd>
</dl>
<p class="Pp">Gets the value of the specified component class.</p>
<p class="Pp"></p>
<pre> __PACKAGE__-&gt;mk_group_accessors('component_class' =&gt; 'result_class');
 $self-&gt;result_class-&gt;method();
 ## same as
 $self-&gt;get_component_class('result_class')-&gt;method();
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="set_component_class"><a class="permalink" href="#set_component_class">set_component_class</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~9"><a class="permalink" href="#Arguments:~9">Arguments:
    $field, $class</a></dt>
  <dd>Returns: <span class="Li">$new_value</span></dd>
</dl>
<p class="Pp">Inherited accessor that automatically loads the specified class
    before setting it. This method will die if the specified class could not be
    loaded.</p>
<p class="Pp"></p>
<pre> __PACKAGE__-&gt;mk_group_accessors('component_class' =&gt; 'result_class');
 __PACKAGE__-&gt;result_class('MyClass');
 $self-&gt;result_class-&gt;method();
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="INTERNAL_METHODS"><a class="permalink" href="#INTERNAL_METHODS">INTERNAL
  METHODS</a></h1>
<p class="Pp">These methods are documented for clarity, but are never meant to
    be called directly, and are not really meant for overriding either.</p>
<section class="Ss">
<h2 class="Ss" id="get_super_paths"><a class="permalink" href="#get_super_paths">get_super_paths</a></h2>
<p class="Pp">Returns a list of 'parent' or 'super' class names that the current
    class inherited from. This is what drives the traversal done by
    &quot;get_inherited&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="make_group_accessor"><a class="permalink" href="#make_group_accessor">make_group_accessor</a></h2>
<pre> __PACKAGE__-&gt;make_group_accessor('simple', 'hair_length', 'hair_length');
 __PACKAGE__-&gt;make_group_accessor('simple', 'hc', 'hair_color');
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:~10"><a class="permalink" href="#Arguments:~10">Arguments:
    $group, $field, $accessor</a></dt>
  <dd>Returns: \&amp;accessor_coderef ?</dd>
</dl>
<p class="Pp">Called by mk_group_accessors for each entry in
    <span class="Li">@fieldspec</span>. Either returns a coderef which will be
    installed at
    <span class="Li">&quot;&amp;__PACKAGE__::$accessor&quot;</span>, or returns
    <span class="Li">&quot;undef&quot;</span> if it elects to install the
    coderef on its own.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="make_group_ro_accessor"><a class="permalink" href="#make_group_ro_accessor">make_group_ro_accessor</a></h2>
<pre> __PACKAGE__-&gt;make_group_ro_accessor('simple', 'birthdate', 'birthdate');
 __PACKAGE__-&gt;make_group_ro_accessor('simple', 'ssn', 'social_security_number');
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:~11"><a class="permalink" href="#Arguments:~11">Arguments:
    $group, $field, $accessor</a></dt>
  <dd>Returns: \&amp;accessor_coderef ?</dd>
</dl>
<p class="Pp">Called by mk_group_ro_accessors for each entry in
    <span class="Li">@fieldspec</span>. Either returns a coderef which will be
    installed at
    <span class="Li">&quot;&amp;__PACKAGE__::$accessor&quot;</span>, or returns
    <span class="Li">&quot;undef&quot;</span> if it elects to install the
    coderef on its own.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="make_group_wo_accessor"><a class="permalink" href="#make_group_wo_accessor">make_group_wo_accessor</a></h2>
<pre> __PACKAGE__-&gt;make_group_wo_accessor('simple', 'lie', 'lie');
 __PACKAGE__-&gt;make_group_wo_accessor('simple', 'subj', 'subject');
</pre>
<dl class="Bl-tag">
  <dt id="Arguments:~12"><a class="permalink" href="#Arguments:~12">Arguments:
    $group, $field, $accessor</a></dt>
  <dd>Returns: \&amp;accessor_coderef ?</dd>
</dl>
<p class="Pp">Called by mk_group_wo_accessors for each entry in
    <span class="Li">@fieldspec</span>. Either returns a coderef which will be
    installed at
    <span class="Li">&quot;&amp;__PACKAGE__::$accessor&quot;</span>, or returns
    <span class="Li">&quot;undef&quot;</span> if it elects to install the
    coderef on its own.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="PERFORMANCE"><a class="permalink" href="#PERFORMANCE">PERFORMANCE</a></h1>
<p class="Pp">To provide total flexibility Class::Accessor::Grouped calls
    methods internally while performing get/set actions, which makes it
    noticeably slower than similar modules. To compensate, this module will
    automatically use the insanely fast Class::XSAccessor to generate the
    <span class="Li">&quot;simple&quot;</span>-group accessors if this module is
    available on your system.</p>
<section class="Ss">
<h2 class="Ss" id="Benchmark"><a class="permalink" href="#Benchmark">Benchmark</a></h2>
<p class="Pp">This is the benchmark of 200 get/get/set/get/set cycles on perl
    5.16.2 with thread support, showcasing how this modules simple (CAG_S),
    inherited (CAG_INH) and inherited with parent-class data (CAG_INHP)
    accessors stack up against most popular accessor builders: Moose, Moo, Mo,
    Mouse (both pure-perl and XS variant), Object::Tiny::RW (OTRW),
    Class::Accessor (CA), Class::Accessor::Lite (CAL), Class::Accessor::Fast
    (CAF), Class::Accessor::Fast::XS (CAF_XS) and Class::XSAccessor (XSA)</p>
<p class="Pp"></p>
<pre>                      Rate CAG_INHP CAG_INH     CA  CAG_S    CAF  moOse   OTRW    CAL     mo  moUse HANDMADE    moo CAF_XS moUse_XS    XSA
 CAG_INHP  287.021+-0.02/s       --   -0.3% -10.0% -37.1% -53.1% -53.6% -53.7% -54.1% -56.9% -59.0%   -59.6% -59.8% -78.7%   -81.9% -83.5%
 CAG_INH  288.025+-0.031/s     0.3%      --  -9.7% -36.9% -52.9% -53.5% -53.5% -53.9% -56.7% -58.8%   -59.5% -59.7% -78.6%   -81.9% -83.5%
 CA       318.967+-0.047/s    11.1%   10.7%     -- -30.1% -47.9% -48.5% -48.5% -49.0% -52.1% -54.4%   -55.1% -55.3% -76.3%   -79.9% -81.7%
 CAG_S    456.107+-0.054/s    58.9%   58.4%  43.0%     -- -25.4% -26.3% -26.4% -27.0% -31.5% -34.8%   -35.8% -36.1% -66.1%   -71.3% -73.9%
 CAF      611.745+-0.099/s   113.1%  112.4%  91.8%  34.1%     --  -1.2%  -1.2%  -2.1%  -8.1% -12.6%   -14.0% -14.3% -54.5%   -61.5% -64.9%
 moOse    619.051+-0.059/s   115.7%  114.9%  94.1%  35.7%   1.2%     --  -0.1%  -1.0%  -7.0% -11.6%   -12.9% -13.3% -54.0%   -61.0% -64.5%
 OTRW       619.475+-0.1/s   115.8%  115.1%  94.2%  35.8%   1.3%   0.1%     --  -0.9%  -6.9% -11.5%   -12.9% -13.2% -54.0%   -61.0% -64.5%
 CAL      625.106+-0.085/s   117.8%  117.0%  96.0%  37.1%   2.2%   1.0%   0.9%     --  -6.1% -10.7%   -12.1% -12.5% -53.5%   -60.6% -64.2%
 mo         665.44+-0.12/s   131.8%  131.0% 108.6%  45.9%   8.8%   7.5%   7.4%   6.5%     --  -4.9%    -6.4%  -6.8% -50.5%   -58.1% -61.9%
 moUse       699.9+-0.15/s   143.9%  143.0% 119.4%  53.5%  14.4%  13.1%  13.0%  12.0%   5.2%     --    -1.6%  -2.0% -48.0%   -55.9% -59.9%
 HANDMADE   710.98+-0.16/s   147.7%  146.8% 122.9%  55.9%  16.2%  14.9%  14.8%  13.7%   6.8%   1.6%       --  -0.4% -47.2%   -55.2% -59.2%
 moo        714.04+-0.13/s   148.8%  147.9% 123.9%  56.6%  16.7%  15.3%  15.3%  14.2%   7.3%   2.0%     0.4%     -- -46.9%   -55.0% -59.1%
 CAF_XS   1345.55+-0.051/s   368.8%  367.2% 321.8% 195.0% 120.0% 117.4% 117.2% 115.3% 102.2%  92.2%    89.3%  88.4%     --   -15.3% -22.9%
 moUse_XS    1588+-0.036/s   453.3%  451.3% 397.9% 248.2% 159.6% 156.5% 156.3% 154.0% 138.6% 126.9%   123.4% 122.4%  18.0%       --  -9.0%
 XSA      1744.67+-0.052/s   507.9%  505.7% 447.0% 282.5% 185.2% 181.8% 181.6% 179.1% 162.2% 149.3%   145.4% 144.3%  29.7%     9.9%     --
</pre>
<p class="Pp">Benchmarking program is available in the root of the repository
    &lt;http://search.cpan.org/dist/Class-Accessor-Grouped/&gt;:</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Notes_on_Class::XSAccessor"><a class="permalink" href="#Notes_on_Class::XSAccessor">Notes
  on Class::XSAccessor</a></h2>
<p class="Pp">You can force (or disable) the use of Class::XSAccessor before
    creating a particular <span class="Li">&quot;simple&quot;</span> accessor by
    either manipulating the global variable
    <span class="Li">$Class::Accessor::Grouped::USE_XS</span> to true or false
    (preferably with localization, or you can do so before runtime via the
    <span class="Li">&quot;CAG_USE_XS&quot;</span> environment variable.</p>
<p class="Pp">Since Class::XSAccessor has no knowledge of &quot;get_simple&quot;
    and &quot;set_simple&quot; this module does its best to detect if you are
    overriding one of these methods and will fall back to using the perl version
    of the accessor in order to maintain consistency. However be aware that if
    you enable use of <span class="Li">&quot;Class::XSAccessor&quot;</span>
    (automatically or explicitly), create an object, invoke a simple accessor on
    that object, and <b>then</b> manipulate the symbol table to install a
    <span class="Li">&quot;get/set_simple&quot;</span> override - you get to
    keep all the pieces.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp">Matt S. Trout &lt;mst@shadowcatsystems.co.uk&gt;</p>
<p class="Pp">Christopher H. Laco &lt;claco@chrislaco.com&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<p class="Pp">Caelum: Rafael Kitover &lt;rkitover@cpan.org&gt;</p>
<p class="Pp">frew: Arthur Axel &quot;fREW&quot; Schmidt
    &lt;frioux@gmail.com&gt;</p>
<p class="Pp">groditi: Guillermo Roditi &lt;groditi@cpan.org&gt;</p>
<p class="Pp">Jason Plum &lt;jason.plum@bmmsi.com&gt;</p>
<p class="Pp">ribasushi: Peter Rabbitson &lt;ribasushi@cpan.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_&amp;_LICENSE"><a class="permalink" href="#COPYRIGHT_&amp;_LICENSE">COPYRIGHT
  &amp; LICENSE</a></h1>
<p class="Pp">Copyright (c) 2006-2010 Matt S. Trout
    &lt;mst@shadowcatsystems.co.uk&gt;</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-07-01</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

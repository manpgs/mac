<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>DBIx::Class::Manual::Joining(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBIx::Class::Manual::Joining(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBIx::Class::Manual::Joining(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">DBIx::Class::Manual::Joining - Manual on joining tables with
    DBIx::Class</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This document should help you to use DBIx::Class if you are trying
    to convert your normal SQL queries into DBIx::Class based queries, if you
    use joins extensively (and also probably if you don't).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="WHAT_ARE_JOINS"><a class="permalink" href="#WHAT_ARE_JOINS">WHAT
  ARE JOINS</a></h1>
<p class="Pp">If you ended up here and you don't actually know what joins are
    yet, then you should likely try the DBIx::Class::Manual::Intro instead. Skip
    this part if you know what joins are..</p>
<p class="Pp">But I'll explain anyway. Assuming you have created your database
    in a more or less sensible way, you will end up with several tables that
    contain <span class="Li">&quot;related&quot;</span> information. For
    example, you may have a table containing information about
    <span class="Li">&quot;CD&quot;</span>s, containing the CD title and its
    year of publication, and another table containing all the
    <span class="Li">&quot;Track&quot;</span>s for the CDs, one track per
  row.</p>
<p class="Pp">When you wish to extract information about a particular CD and all
    its tracks, You can either fetch the CD row, then make another query to
    fetch the tracks, or you can use a join. Compare:</p>
<p class="Pp"></p>
<pre>  SELECT ID, Title, Year FROM CD WHERE Title = 'Funky CD';
  # .. Extract the ID, which is 10
  SELECT Name, Artist FROM Tracks WHERE CDID = 10;
  SELECT cd.ID, cd.Title, cd.Year, tracks.Name, tracks.Artist FROM CD JOIN Tracks ON CD.ID = tracks.CDID WHERE cd.Title = 'Funky CD';
</pre>
<p class="Pp">So, joins are a way of extending simple select statements to
    include fields from other, related, tables. There are various types of
    joins, depending on which combination of the data you wish to retrieve, see
    MySQL's doc on JOINs:
    &lt;http://dev.mysql.com/doc/refman/5.0/en/join.html&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DEFINING_JOINS_AND_RELATIONSHIPS"><a class="permalink" href="#DEFINING_JOINS_AND_RELATIONSHIPS">DEFINING
  JOINS AND RELATIONSHIPS</a></h1>
<p class="Pp">In DBIx::Class each relationship between two tables needs to first
    be defined in the ResultSource for the table. If the relationship needs to
    be accessed in both directions (i.e. Fetch all tracks of a CD, and fetch the
    CD data for a Track), then it needs to be defined for both tables.</p>
<p class="Pp">For the CDs/Tracks example, that means writing, in
    <span class="Li">&quot;MySchema::CD&quot;</span>:</p>
<p class="Pp"></p>
<pre>  MySchema::CD-&gt;has_many('tracks', 'MySchema::Tracks');
</pre>
<p class="Pp">And in <span class="Li">&quot;MySchema::Tracks&quot;</span>:</p>
<p class="Pp"></p>
<pre>  MySchema::Tracks-&gt;belongs_to('cd', 'MySchema::CD', 'CDID');
</pre>
<p class="Pp">There are several other types of relationships, they are more
    comprehensively described in DBIx::Class::Relationship.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="USING_JOINS"><a class="permalink" href="#USING_JOINS">USING
  JOINS</a></h1>
<p class="Pp">Once you have defined all your relationships, using them in actual
    joins is fairly simple. The type of relationship that you chose e.g.
    <span class="Li">&quot;has_many&quot;</span>, already indicates what sort of
    join will be performed. <span class="Li">&quot;has_many&quot;</span>
    produces a <span class="Li">&quot;LEFT JOIN&quot;</span> for example, which
    will fetch all the rows on the left side, whether there are matching rows on
    the right (table being joined to), or not. You can force other types of
    joins in your relationship, see the DBIx::Class::Relationship docs.</p>
<p class="Pp">When performing either a search or a find operation, you can
    specify which <span class="Li">&quot;relations&quot;</span> to also refine
    your results based on, using the join attribute, like this:</p>
<p class="Pp"></p>
<pre>  $schema-&gt;resultset('CD')-&gt;search(
    { 'Title' =&gt; 'Funky CD',
      'tracks.Name' =&gt; { like =&gt; 'T%' }
    },
    { join      =&gt; 'tracks',
      order_by  =&gt; ['tracks.id'],
    }
  );
</pre>
<p class="Pp">If you don't recognise most of this syntax, you should probably go
    read &quot;search&quot; in DBIx::Class::ResultSet and &quot;ATTRIBUTES&quot;
    in DBIx::Class::ResultSet, but here's a quick break down:</p>
<p class="Pp">The first argument to search is a hashref of the WHERE attributes,
    in this case a restriction on the Title column in the CD table, and a
    restriction on the name of the track in the Tracks table, but ONLY for
    tracks actually related to the chosen CD(s). The second argument is a
    hashref of attributes to the search, the results will be returned sorted by
    the <span class="Li">&quot;id&quot;</span> of the related tracks.</p>
<p class="Pp">The special 'join' attribute specifies which
    <span class="Li">&quot;relationships&quot;</span> to include in the query.
    The distinction between <span class="Li">&quot;relationships&quot;</span>
    and <span class="Li">&quot;tables&quot;</span> is important here, only the
    <span class="Li">&quot;relationship&quot;</span> names are valid.</p>
<p class="Pp">This slightly nonsense example will produce SQL similar to:</p>
<p class="Pp"></p>
<pre>  SELECT cd.ID, cd.Title, cd.Year FROM CD cd JOIN Tracks tracks ON cd.ID = tracks.CDID WHERE cd.Title = 'Funky CD' AND tracks.Name LIKE 'T%' ORDER BY 'tracks.id';
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="FETCHING_RELATED_DATA"><a class="permalink" href="#FETCHING_RELATED_DATA">FETCHING
  RELATED DATA</a></h1>
<p class="Pp">Another common use for joining to related tables, is to fetch the
    data from both tables in one query, preventing extra round-trips to the
    database. See the example above in &quot;WHAT ARE JOINS&quot;.</p>
<p class="Pp">Three techniques are described here. Of the three, only the
    <span class="Li">&quot;prefetch&quot;</span> technique will deal sanely with
    fetching related objects over a <span class="Li">&quot;has_many&quot;</span>
    relation. The others work fine for 1 to 1 type relationships.</p>
<section class="Ss">
<h2 class="Ss" id="Whole_related_objects"><a class="permalink" href="#Whole_related_objects">Whole
  related objects</a></h2>
<p class="Pp">To fetch entire related objects, e.g. CDs and all Track data, use
    the 'prefetch' attribute:</p>
<p class="Pp"></p>
<pre>  $schema-&gt;resultset('CD')-&gt;search(
    { 'Title' =&gt; 'Funky CD',
    },
    { prefetch      =&gt; 'tracks',
      order_by  =&gt; ['tracks.id'],
    }
  );
</pre>
<p class="Pp">This will produce SQL similar to the following:</p>
<p class="Pp"></p>
<pre>  SELECT cd.ID, cd.Title, cd.Year, tracks.id, tracks.Name, tracks.Artist FROM CD JOIN Tracks ON CD.ID = tracks.CDID WHERE cd.Title = 'Funky CD' ORDER BY 'tracks.id';
</pre>
<p class="Pp">The syntax of 'prefetch' is the same as 'join' and implies the
    joining, so there is no need to use both together.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Subset_of_related_fields"><a class="permalink" href="#Subset_of_related_fields">Subset
  of related fields</a></h2>
<p class="Pp">To fetch a subset or the related fields, the '+select' and '+as'
    attributes can be used. For example, if the CD data is required and just the
    track name from the Tracks table:</p>
<p class="Pp"></p>
<pre>  $schema-&gt;resultset('CD')-&gt;search(
    { 'Title' =&gt; 'Funky CD',
    },
    { join      =&gt; 'tracks',
      '+select' =&gt; ['tracks.Name'],
      '+as'     =&gt; ['track_name'],
      order_by  =&gt; ['tracks.id'],
    }
  );
</pre>
<p class="Pp">Which will produce the query:</p>
<p class="Pp"></p>
<pre>  SELECT cd.ID, cd.Title, cd.Year, tracks.Name FROM CD JOIN Tracks ON CD.ID = tracks.CDID WHERE cd.Title = 'Funky CD' ORDER BY 'tracks.id';
</pre>
<p class="Pp">Note that the '+as' does not produce an SQL 'AS' keyword in the
    output, see the DBIx::Class::Manual::FAQ for an explanation.</p>
<p class="Pp">This type of column restriction has a downside, the returned
    <span class="Li">$result</span> object will have no 'track_name'
  accessor:</p>
<p class="Pp"></p>
<pre>  while(my $result = $search_rs-&gt;next) {
     print $result-&gt;track_name; ## ERROR
  }
</pre>
<p class="Pp">Instead <span class="Li">&quot;get_column&quot;</span> must be
    used:</p>
<p class="Pp"></p>
<pre>  while(my $result = $search_rs-&gt;next) {
     print $result-&gt;get_column('track_name'); ## WORKS
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Incomplete_related_objects"><a class="permalink" href="#Incomplete_related_objects">Incomplete
  related objects</a></h2>
<p class="Pp">In rare circumstances, you may also wish to fetch related data as
    incomplete objects. The usual reason to do is when the related table has a
    very large field you don't need for the current data output. This is better
    solved by storing that field in a separate table which you only join to when
    needed.</p>
<p class="Pp">To fetch an incomplete related object, supply the dotted notation
    to the '+as' attribute:</p>
<p class="Pp"></p>
<pre>  $schema-&gt;resultset('CD')-&gt;search(
    { 'Title' =&gt; 'Funky CD',
    },
    { join      =&gt; 'tracks',
      '+select' =&gt; ['tracks.Name'],
      '+as'     =&gt; ['tracks.Name'],
      order_by  =&gt; ['tracks.id'],
    }
  );
</pre>
<p class="Pp">Which will produce same query as above;</p>
<p class="Pp"></p>
<pre>  SELECT cd.ID, cd.Title, cd.Year, tracks.Name FROM CD JOIN Tracks ON CD.ID = tracks.CDID WHERE cd.Title = 'Funky CD' ORDER BY 'tracks.id';
</pre>
<p class="Pp">Now you can access the result using the relationship accessor:</p>
<p class="Pp"></p>
<pre>  while(my $result = $search_rs-&gt;next) {
     print $result-&gt;tracks-&gt;name; ## WORKS
  }
</pre>
<p class="Pp">However, this will produce broken objects. If the tracks id column
    is not fetched, the object will not be usable for any operation other than
    reading its data. Use the &quot;Whole related objects&quot; method as much
    as possible to avoid confusion in your code later.</p>
<p class="Pp">Broken means: Update will not work. Fetching other related objects
    will not work. Deleting the object will not work.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="COMPLEX_JOINS_AND_STUFF"><a class="permalink" href="#COMPLEX_JOINS_AND_STUFF">COMPLEX
  JOINS AND STUFF</a></h1>
<section class="Ss">
<h2 class="Ss" id="Across_multiple_relations"><a class="permalink" href="#Across_multiple_relations">Across
  multiple relations</a></h2>
<p class="Pp">For simplicity in the example above, the
    <span class="Li">&quot;Artist&quot;</span> was shown as a simple text field
    in the <span class="Li">&quot;Tracks&quot;</span> table, in reality, you'll
    want to have the artists in their own table as well, thus to fetch the
    complete set of data we'll need to join to the Artist table too.</p>
<p class="Pp">In <span class="Li">&quot;MySchema::Tracks&quot;</span>:</p>
<p class="Pp"></p>
<pre>  MySchema::Tracks-&gt;belongs_to('artist', 'MySchema::Artist', 'ArtistID');
</pre>
<p class="Pp">The search:</p>
<p class="Pp"></p>
<pre>  $schema-&gt;resultset('CD')-&gt;search(
    { 'Title' =&gt; 'Funky CD' },
    { join      =&gt; { 'tracks' =&gt; 'artist' },
    }
  );
</pre>
<p class="Pp">Which is:</p>
<p class="Pp"></p>
<pre>  SELECT me.ID, me.Title, me.Year FROM CD me JOIN Tracks tracks ON CD.ID = tracks.CDID JOIN Artists artist ON tracks.ArtistID = artist.ID WHERE me.Title = 'Funky CD';
</pre>
<p class="Pp">To perform joins using relations of the tables you are joining to,
    use a hashref to indicate the join depth. This can theoretically go as deep
    as you like (warning: contrived examples!):</p>
<p class="Pp"></p>
<pre>  join =&gt; { room =&gt; { table =&gt; 'leg' } }
</pre>
<p class="Pp">To join two relations at the same level, use an arrayref
  instead:</p>
<p class="Pp"></p>
<pre>  join =&gt; { room =&gt; [ 'chair', 'table' ] }
</pre>
<p class="Pp">Or combine the two:</p>
<p class="Pp"></p>
<pre>  join =&gt; { room =&gt; [ 'chair', { table =&gt; 'leg' } ] }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Table_aliases"><a class="permalink" href="#Table_aliases">Table
  aliases</a></h2>
<p class="Pp">As an aside to all the discussion on joins, note that DBIx::Class
    uses the <span class="Li">&quot;relation names&quot;</span> as table
    aliases. This is important when you need to add grouping or ordering to your
    queries:</p>
<p class="Pp"></p>
<pre>  $schema-&gt;resultset('CD')-&gt;search(
    { 'Title' =&gt; 'Funky CD' },
    { join      =&gt; { 'tracks' =&gt; 'artist' },
      order_by  =&gt; [ 'tracks.Name', 'artist.Artist' ],
    }
  );
  SELECT me.ID, me.Title, me.Year FROM CD me JOIN Tracks tracks ON CD.ID = tracks.CDID JOIN Artists artist ON tracks.ArtistID = artist.ID WHERE me.Title = 'Funky CD' ORDER BY tracks.Name, artist.Artist;
</pre>
<p class="Pp">This is essential if any of your tables have columns with the same
    names.</p>
<p class="Pp">Note that the table of the resultsource the search was performed
    on, is always aliased to <span class="Li">&quot;me&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Joining_to_the_same_table_twice"><a class="permalink" href="#Joining_to_the_same_table_twice">Joining
  to the same table twice</a></h2>
<p class="Pp">There is no magic to this, just do it. The table aliases will
    automatically be numbered:</p>
<p class="Pp"></p>
<pre>  join =&gt; [ 'room', 'room' ]
</pre>
<p class="Pp">The aliases are: <span class="Li">&quot;room&quot;</span> and
    <span class="Li">&quot;room_2&quot;</span>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="FURTHER_QUESTIONS?"><a class="permalink" href="#FURTHER_QUESTIONS?">FURTHER
  QUESTIONS?</a></h1>
<p class="Pp">Check the list of additional DBIC resources.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This module is free software copyright by the DBIx::Class (DBIC)
    authors. You can redistribute it and/or modify it under the same terms as
    the DBIx::Class library.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-12-08</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

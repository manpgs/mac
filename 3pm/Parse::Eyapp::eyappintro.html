<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Parse::Eyapp::eyappintro(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Parse::Eyapp::eyappintro(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Parse::Eyapp::eyappintro(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Parse::Eyapp::eyappintro - An introduction to Parse::Eyapp</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
  # File 'calc.eyp': translates infix expressions to postfix
  # Compile it with:  eyapp -o calc.pl -C Postfix.eyp
  # Execution:        ./calc.pl -c 'a = 2*3+b'
  %token NUM = /([0-9]+(?:\.[0-9]+)?)/
  %token VAR = /([A-Za-z][A-Za-z0-9_]*)/

  %right  '='
  %left   '-' '+'
  %left   '*' '/'
  %left   NEG

  %defaultaction { &quot;$left $right $op&quot;; }

  %%
  line: $exp  { print &quot;$exp\n&quot; }
  ;

  exp:        $NUM  { $NUM }            
          |   $VAR  { $VAR }            
          |   VAR.left '='.op exp.right         
          |   exp.left '+'.op exp.right         
          |   exp.left '-'.op exp.right        
          |   exp.left '*'.op exp.right       
          |   exp.left '/'.op exp.right      
          |   '-' $exp %prec NEG { &quot;$exp NEG&quot; }
          |   '(' $exp ')' { $exp }      
  ;

  %%
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="INTRODUCTION_TO_PARSING_WITH_Parse::Eyapp"><a class="permalink" href="#INTRODUCTION_TO_PARSING_WITH_Parse::Eyapp">INTRODUCTION
  TO PARSING WITH Parse::Eyapp</a></h1>
<section class="Ss">
<h2 class="Ss" id="Introduction"><a class="permalink" href="#Introduction">Introduction</a></h2>
<p class="Pp">Parsing is the activity of producing a syntax tree from an input
    stream. The program example in the synopsis section shows an example of a
    translation scheme. It translates infix arithmetic expressions like</p>
<p class="Pp"></p>
<pre>
   a = 2 * 3 + 4 * b
</pre>
<p class="Pp">into postfix expressions like</p>
<p class="Pp"></p>
<pre>
   a 2 3 * 4 b * + =
</pre>
<p class="Pp">The program contains a context free eyapp grammar defining the
    language of arithmetic infix expressions. A context free grammar is a
    mathematical device to define languages. To better see the grammar for the
    example above we have to eliminate the semantic actions (We call semantic
    actions to the sections delimited by curly brackets containing Perl code).
    This can be done calling <span class="Li">&quot;eyapp&quot;</span> with
    options <span class="Li">&quot;-vc&quot;</span>:</p>
<p class="Pp"></p>
<pre>
  $ eyapp -vc Postfix.eyp 
  %token NUM =/([0-9]+(?:\.[0-9]+)?)/ 
  %token VAR =/([A-Za-z][A-Za-z0-9_]*)/ 
  %right '=' 
  %left '-' '+' 
  %left '*' '/' 
  %left NEG 

  %%

  line:
        exp 
  ;
  exp:
        NUM
      | VAR
      | VAR '=' exp
      | exp '+' exp
      | exp '-' exp
      | exp '*' exp
      | exp '/' exp
      | '-' exp %prec NEG
      | '(' exp ')'  
  ;

  %%
</pre>
<p class="Pp">A grammar generates a language. A grammar is defined by a set of
    production rules. A production rule has two components: a left hand side
    which is a <i>syntactic variable</i> or <i>non terminal</i> and a right hand
    side which is a phrase made of syntactic variables and terminals. The left
    hand side (<i>lhs</i>) and the right hand side (<i>rhs</i>) are usually
    separated by an arrow like in:</p>
<p class="Pp"></p>
<pre>
                                    exp -&gt; VAR = exp
</pre>
<p class="Pp">A note: when you see a production rule like:</p>
<p class="Pp"></p>
<pre>
                        line: exp &lt;+ ';'&gt;
</pre>
<p class="Pp">is not really a production rule but an abbreviation for two
    productions. It stands for:</p>
<p class="Pp"></p>
<pre>
                        line : exp
                             | line ';' exp
                        ;
</pre>
<p class="Pp">A <i>terminal</i> or <i>token</i> never appears on the left hand
    side of a production rule.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Ambiguity"><a class="permalink" href="#Ambiguity">Ambiguity</a></h2>
<p class="Pp">The phrases of the language are those obtained successively
    applying the production rules of the grammar until no more rules can be
    applied. The successive substitutions must start from the
    <span class="Li">&quot;start&quot;</span> symbol of the grammar
    (<span class="Li">&quot;line&quot;</span> in the example). Such legal
    sequence of substitutions is known as a <i>derivation</i>. The following is
    an example of a legal derivation (the big arrow
    <span class="Li">&quot;=&gt;&quot;</span> is read <i>derives</i>):</p>
<p class="Pp"></p>
<pre>
  line =&gt; exp =&gt; VAR = exp =&gt; VAR = exp + exp =&gt; VAR = exp + NUM =&gt; VAR = VAR + NUM
</pre>
<p class="Pp">thus the phrase <span class="Li">&quot;VAR = VAR +
    NUM&quot;</span> belongs to the language generated by the former grammar. A
    derivation like this can be seen as a tree. For instance, the former
    derivation is equivalent (has the same information) than the following
  tree:</p>
<p class="Pp"></p>
<pre>
                             +----+
                             |line|
                             +----+
                                |
                              +---+
                              |exp|
                              +---+
                    .-----.-----^-----.
                  +---+ +---+        +---+
                  |VAR| | = |        |exp|
                  +---+ +---+        +---+
                                 .-----+-----.
                               +---+ +---+ +---+
                               |exp| | + | |exp|
                               +---+ +---+ +---+
                                 |           |
                               +---+       +---+
                               |VAR|       |NUM|
                               +---+       +---+
</pre>
<p class="Pp">which can be written more succinctly:</p>
<p class="Pp"></p>
<pre>
                        line(exp(VAR, '=', exp(exp(VAR), '+',  exp(NUM))))
</pre>
<p class="Pp">or even more briefly:</p>
<p class="Pp"></p>
<pre>
                                      VAR = (VAR + NUM)
</pre>
<p class="Pp">Such a tree is called a <i>syntax tree</i> for the input
    <span class="Li">&quot;VAR = VAR + NUM&quot;</span>. A grammar is said to be
    <i>ambiguous</i> if there are phrases in the generated language that have
    more than one syntax tree. The grammar in the synopsis example is ambiguous.
    Here is an alternative tree for the same phrase <span class="Li">&quot;VAR =
    VAR + NUM&quot;</span>:</p>
<p class="Pp"></p>
<pre>
                                    +----+
                                    |line|
                                    +----+
                                       |
                                     +---+
                                     |exp|
                                     +---+
                            .----------^-----.-----.
                          +---+            +---+  +---+
                          |exp|            | + |  |exp|
                          +---+            +---+  +---+
                      .-----+-----.                 |
                    +---+ +---+ +---+             +---+
                    |VAR| | = | |exp|             |NUM|
                    +---+ +---+ +---+             +---+
                                  |
                                +---+
                                |VAR|
                                +---+
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre>
                        line(exp(exp(VAR, '=', exp(VAR)), '+', exp(NUM)))
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre>
                                     (VAR = VAR) + NUM
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Semantic_Actions_and_Attributes"><a class="permalink" href="#Semantic_Actions_and_Attributes">Semantic
  Actions and Attributes</a></h2>
<p class="Pp"><span class="Li">&quot;Parse::Eyapp&quot;</span> analyzes your
    grammar and produce a LALR parser. Actually the SYNOPSIS example is more
    than a context free grammar: is a <i>translation scheme</i>. A
    <i>translation scheme</i> scheme is a context free grammar where the right
    hand sides of the productions have been augmented with semantic actions
    (i.e. with chunks of Perl code):</p>
<p class="Pp"></p>
<pre>
                                A -&gt; alpha { action(@_) } beta
</pre>
<p class="Pp">The analyzer generated by Eyapp executes <span class="Li">&quot;{
    action(@_) }&quot;</span> after all the semantic actions associated with
    <span class="Li">&quot;alpha&quot;</span> have been executed and before the
    execution of any of the semantic actions associated with
    <span class="Li">&quot;beta&quot;</span>.</p>
<p class="Pp">In a translation scheme each symbol occurrence has an
    <i>associated attribute</i>. The embedded actions modify the attributes
    associated with the symbols of the grammar:</p>
<p class="Pp"></p>
<pre>
                        A -&gt; alpha { action(@_) } beta
</pre>
<p class="Pp"><i>Each symbol on the right hand side</i> <i>of a production rule
    has an associated scalar attribute</i>. In
    <span class="Li">&quot;eyapp&quot;</span> the attributes of the symbols to
    the left of <span class="Li">&quot;action&quot;</span> are passed as
    arguments to <span class="Li">&quot;action&quot;</span> (in the example,
    those of <span class="Li">&quot;alpha&quot;</span>). These arguments are
    preceded by a reference to the syntax analyzer object. Therefore, you can
    access to the attributes associated with the first, second, etc. symbols in
    the right hand side using the notation:</p>
<p class="Pp"></p>
<pre>
               $_[1], $_[2], ...
</pre>
<p class="Pp">However it is better to refer to the attributes by names. This is
    the purpose of the dot and dollar notations as in:</p>
<p class="Pp"></p>
<pre>
  exp:        $NUM  { $NUM }            
          |   $VAR  { $VAR }            
          |   VAR.left '='.op exp.right         
          |   exp.left '+'.op exp.right         
          |   exp.left '-'.op exp.right        
          |   exp.left '*'.op exp.right       
          |   exp.left '/'.op exp.right      
          |   '-' $exp %prec NEG { &quot;$exp NEG&quot; }
          |   '(' $exp ')' { $exp }      
  ;
</pre>
<p class="Pp">By prefixing the symbol <span class="Li">&quot;NUM&quot;</span> by
    a <span class="Li">&quot;$&quot;</span> we can refer to the associated
    attribute inside the semantic action as <span class="Li">$NUM</span>:</p>
<p class="Pp"></p>
<pre>
  exp:        $NUM  { $NUM }
</pre>
<p class="Pp">By postfixing the two appearances of
    <span class="Li">&quot;expr&quot;</span> with
    <span class="Li">&quot;.left&quot;</span> and
    <span class="Li">&quot;.right&quot;</span> and the appearance of
    <span class="Li">'+'</span> with <span class="Li">&quot;.op&quot;</span> we
    can refer to the associates attributes as <span class="Li">$left</span>,
    <span class="Li">$right</span> and <span class="Li">$op</span> instead of
    <span class="Li">$_[1]</span>, <span class="Li">$_[3]</span> and
    <span class="Li">$_[2]</span>:</p>
<p class="Pp"></p>
<pre>
  %defaultaction { &quot;$left $right $op&quot;; }
</pre>
<p class="Pp">There is no way inside an ordinary
    <span class="Li">&quot;eyapp&quot;</span> program for an intermediate
    <span class="Li">&quot;action&quot;</span> to access the attributes of the
    symbols on its right, i.e. those associated with the symbols of
    <span class="Li">&quot;beta&quot;</span>. This restriction is lifted if you
    use the <span class="Li">%metatree</span> directive to build a <i>full
    translation scheme</i>. See Parse::Eyapp::translationschemestut to know more
    about full translation schemes.</p>
<p class="Pp">Actions on the right hand side counts as symbols and so they can
    be referenced by its positional argument in later actions in the same
    production rule. For intermediate actions, the value returned by the
    <span class="Li">&quot;action&quot;</span> is the attribute associated with
    such action. For an action at the end of the rule:</p>
<p class="Pp"></p>
<pre>
                        A -&gt; alpha { lastaction(@_) }
</pre>
<p class="Pp">the returned value constitutes the attribute of the left hand side
    of the rule (the attribute of <span class="Li">&quot;A&quot;</span> in this
    case). The action at the end of the right hand side is called the <i>action
    associated with the production rule</i>. When no explicit action has been
    associated with a production rule the <i>default action</i> applies. In
    <span class="Li">&quot;Parse::Eyapp&quot;</span> the programmer can define
    what is the default action through the
    <span class="Li">%defaultaction</span> directive:</p>
<p class="Pp"></p>
<pre>
                        %defaultaction { &quot;$left $right $op&quot;; }
</pre>
<p class="Pp">Actually, intermediate actions are implemented via a trick. When
    <span class="Li">&quot;eyapp&quot;</span> sees an intermediate action
  like:</p>
<p class="Pp"></p>
<pre>
                        A -&gt; alpha { action(@_) } beta
</pre>
<p class="Pp">it creates a new auxiliary syntactic variable
    <span class="Li">&quot;Temp&quot;</span>:</p>
<p class="Pp"></p>
<pre>
                      Temp -&gt; /* empty */ { action(@_) }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Solving_Ambiguities_via_Precedence_and_Associativity_Declarations"><a class="permalink" href="#Solving_Ambiguities_via_Precedence_and_Associativity_Declarations">Solving
  Ambiguities via Precedence and Associativity Declarations</a></h2>
<p class="Pp">Notice that ambiguous grammars produce ambiguous translation
    schemes: since a phrase may have two syntactic trees it will be more than
    one tree-traversing and consequently more than one way to execute the
    embedded semantic actions. Certainly different execution orders will usually
    produce different results. Thus, syntactic ambiguities translate onto
    semantic ambiguities. That is why it is so important to resolve all the
    ambiguities and conflicts that may arise in our grammars. This is the
    function of the <span class="Li">%left</span> and
    <span class="Li">%right</span> declarations on the header section:</p>
<p class="Pp"></p>
<pre>
      %right  '='     # Lowest precedence
      %left   '-' '+' # + and - have more precedence than = Disambiguate a-b-c as (a-b)-c
      %left   '*' '/' # * and / have more precedence than + Disambiguate a/b/c as (a/b)/c
      %left   NEG     # Disambiguate -a-b as (-a)-b and not as -(a-b)
</pre>
<p class="Pp">Priority can be assigned to tokens by using the
    <span class="Li">%left</span> and <span class="Li">%right</span>
    declarations. <i>Tokens in</i> <i>lines below have more precedence than
    tokens in line above</i>. The idea behind this notation is this: <i>Any
    ambiguity can be seen as a parenthesizing problem</i>. You can parenthesize
    left (in the jargon this is called <i>reduce</i>) or parenthesize right (in
    the jargon, <i>shift</i>). Recall the main points of yacc-like parsers
    related to priorities:</p>
<ul class="Bl-bullet">
  <li>The directives
    <p class="Pp"></p>
    <pre>
            %left
            %right
            %nonassoc
    </pre>
    <p class="Pp">can be used in the head section to declare the priority of a
        token</p>
  </li>
  <li>The later the declaration line the higher the priority</li>
  <li>Tokens in the same line have the same priority. Ties will be solved using
      the token associativity (whether they were declared
      <span class="Li">%left</span> or <span class="Li">%right</span>)</li>
  <li>The <i>precedence of a production rule (right hand side) is the
      precedence</i> <i>of the last token in the right hand side</i></li>
  <li>If the parser emits a warning announcing a shift-reduce conflict or a
      reduce-reduce conflict in your grammar, it likely means that your grammar
      is ambiguous or not LALR. In such case, recompile the grammar with
      <span class="Li">&quot;eyapp -v&quot;</span> and carefully study the
      <span class="Li">&quot;.output&quot;</span> file generated. <i>Detect
      which token and which rules are involved in the conflict</i>.</li>
  <li>In a shift-reduce conflict the default action is to shift (i.e. associate
      right). This action can be changed if the production and the token
      involved have explicit priorities</li>
  <li>Most of the time the presence of a reduce-reduce conflict means that your
      grammar is ambiguous. Rewrite your grammar. Alternatively, use the
      <span class="Li">%conflict</span> and <span class="Li">%PREC</span>
      directives (see example
      <span class="Li">&quot;debuggintut/pascalenumeratedvsrangesolvedviadyn.eyp&quot;</span>).
      The default action is to reduce by the first production.</li>
  <li>If the precedence of the production rule is higher the shift-reduce
      conflict is solved in favor of the reduction (i.e. associate left)</li>
  <li>If the precedence of the token is higher the shift-reduce conflict is
      solved in favor of the shift (i.e. associate right).</li>
  <li>If the precedence of the token is the same than the precedence of the
      rule, and is left the shift-reduce conflict is solved in favor of the
      reduction (i.e. associate left)</li>
  <li>If the precedence of the token is the same than the precedence of the
      rule, and is right the shift-reduce conflict is solved in favor of the
      shift</li>
  <li>If the precedence of the token is the same than the precedence of the
      rule, and is nonassoc the presence of a shift-reduce conflict means an
      error. This is used to describe operators, like the operator
      <span class="Li">&quot;.LT.&quot;</span> in FORTRAN, that may not
      associate with themselves. That is, because
    <p class="Pp"></p>
    <pre>
                             A .LT. B .LT. C
    </pre>
    <p class="Pp">is invalid in FORTRAN,
        <span class="Li">&quot;.LT.&quot;</span> would be described with the
        keyword <span class="Li">%nonassoc</span> in eyapp.</p>
  </li>
  <li>The default precedence of a production can be changed using the
      <span class="Li">&quot;%prec TOKEN&quot;</span> directive. Now the rule
      has the precedence and <i>associativity</i> of the specified
      <span class="Li">&quot;TOKEN&quot;</span>.</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Examples"><a class="permalink" href="#Examples">Examples</a></h2>
<ul class="Bl-bullet">
  <li>By giving token <span class="Li">'+'</span> more precedence than token
      <span class="Li">'='</span> we solve the ambiguity in
      <span class="Li">&quot;VAR = VAR + NUM&quot;</span> in favor of
      <span class="Li">&quot; VAR = (VAR + NUM)&quot;</span>. The conflict
      occurs between the productions
    <p class="Pp"></p>
    <pre>
                            exp -&gt; exp . '+' exp 
                            exp -&gt; VAR '=' exp .
    </pre>
    <p class="Pp">Where the dot means:</p>
    <p class="Pp"><i>If I have seen</i> <span class="Li">&quot;VAR '='
        exp&quot;</span> <i>and I am in the presence of a token</i>
        <span class="Li">'+'</span> <i>I can associate left, i.e. reduce</i>
        <span class="Li">&quot;VAR '=' exp&quot;</span> <i>to</i>
        <span class="Li">&quot;exp&quot;</span> <i>or to associate right,</i>
        <i>that is, to shift to the right to reduce</i>
        <span class="Li">&quot;exp '+' exp&quot;</span> <i>to</i>
        <span class="Li">&quot;exp&quot;</span> <i>later</i>.</p>
  </li>
  <li>How it works when two tokens are declared in the same line? Consider the
      phrase <span class="Li">&quot;NUM - NUM - NUM&quot;</span>. It will be
      interpreted as <span class="Li">&quot;(NUM - NUM) - NUM&quot;</span> if
      the token <span class="Li">'-'</span> is declared
      <span class="Li">&quot;%left '-'&quot;</span> and will be interpreted as
      <span class="Li">&quot;NUM - (NUM - NUM)&quot;</span> if the token
      <span class="Li">'-'</span> is declared <span class="Li">&quot;%right
      '-'&quot;</span>. By saying <span class="Li">'-'</span> is left we are
      saying we prefer between the two trees in dispute the one that deepens to
      the left:
    <p class="Pp"></p>
    <pre>
                                       +---+
                                       |exp|
                                       +---+
                                .--------^--.-----.
                              +---+       +---+ +---+
                              |exp|       | - | |exp|
                              +---+       +---+ +---+
                          .-----+-----.           |
                        +---+ +---+ +---+       +---+
                        |exp| | - | |exp|       |NUM|
                        +---+ +---+ +---+       +---+
                          |           |
                        +---+       +---+
                        |NUM|       |NUM|
                        +---+       +---+
    </pre>
    <p class="Pp">By saying <span class="Li">'-'</span> is right we are saying
        we prefer between the two trees in dispute the one that deepens to the
        right:</p>
    <p class="Pp"></p>
    <pre>
                                        +---+
                                        |exp|
                                        +---+
                              .-----.-----^-----.
                            +---+ +---+       +---+
                            |exp| |MIN|       |exp|
                            +---+ +---+       +---+
                              |           .-----+-----.
                            +---+       +---+ +---+ +---+
                            |NUM|       |exp| |MIN| |exp|
                            +---+       +---+ +---+ +---+
                                           |           |
                                         +---+       +---+
                                         |NUM|       |NUM|
                                         +---+       +---+
    </pre>
    <p class="Pp">Since <i>priority means earlier evaluation</i> and the
        evaluation by eyapp of semantic actions is bottom up, <i>the deeper the
        associated subtree the higher</i> <i>the priority</i>.</p>
  </li>
  <li>Consider now the phrase <span class="Li">&quot;-NUM-NUM&quot;</span>.
      There are two interpretations: one as
      <span class="Li">&quot;-(NUM-NUM)&quot;</span> and the other as
      <span class="Li">&quot;(-NUM)-NUM&quot;</span>. The conflict occurs
      between the productions
    <p class="Pp"></p>
    <pre>
                            exp -&gt; exp . '-' exp 
                            exp -&gt; '-' exp.
    </pre>
    <p class="Pp">Both productions have the precedence of the token
        <span class="Li">'-'</span>. But we prefer the interpretation
        <span class="Li">&quot;(-NUM)-NUM&quot;</span> to win. We do that by
        explicitly changing the precedence associated with the unary minus
        production via the <span class="Li">%prec</span> directive.</p>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Lexical_Analysis"><a class="permalink" href="#Lexical_Analysis">Lexical
  Analysis</a></h2>
<p class="Pp">Parsers created by <span class="Li">&quot;eyapp&quot;</span> do
    not deal directly with the input. Instead they expect the input to be
    processed by a <i>lexical analyzer</i>. The lexical analyzer parses the
    input and produces the next token. A <i>token</i> is a pair. The first
    component is the name of the token (like
    <span class="Li">&quot;NUM&quot;</span> or
    <span class="Li">&quot;VAR&quot;</span>) and the second is its attribute
    (i.e. the information associated with the token, like that the value is
    <span class="Li">4</span> for a <span class="Li">&quot;NUM&quot;</span> or
    the identifier is <span class="Li">&quot;temperature&quot;</span> for a
    <span class="Li">&quot;VAR&quot;</span>). Tokens are usually defined using
    regular expressions. Thus the token <span class="Li">&quot;NUM&quot;</span>
    is characterized by
    <span class="Li">&quot;/[0-9]+(?:\.[0-9]+)?/&quot;</span> and the token
    <span class="Li">&quot;VAR&quot;</span> by
    <span class="Li">&quot;/[A-Za-z][A-Za-z0-9_]*/&quot;</span>. The eyapp
    compiler automatically generates a lexical analyzer from your token
    definitions. The tokens <span class="Li">&quot;NUM&quot;</span> and
    <span class="Li">&quot;VAR&quot;</span> were defined using the
    <span class="Li">%token</span> directives:</p>
<p class="Pp"></p>
<pre>
  %token NUM = /([0-9]+(?:\.[0-9]+)?)/
  %token VAR = /([A-Za-z][A-Za-z0-9_]*)/
</pre>
<p class="Pp">The order in which the tokens are defined is important. The input
    will be matched against the regular expression for
    <span class="Li">&quot;NUM&quot;</span> before the regular expression for
    <span class="Li">&quot;VAR&quot;</span> is tried, and all the literal tokens
    that appear between quotes inside the body of the grammar, like
    <span class="Li">'+'</span> or <span class="Li">&quot;'-&quot;</span>, are
    tried before any explicitly defined token.</p>
<p class="Pp">You can, alternatively, define the lexical analyzer explicitly.
    There are many ways to do it. Here is an example of a definition of a
    lexical analyzer using the <span class="Li">%lexer</span> directive:</p>
<p class="Pp"></p>
<pre>
  %lexer  {
    m{\G[ \t]*}gc;
    m{\G(\n)+}gc                    and $self-&gt;tokenline($1 =~ tr/\n//);
    m{\G([0-9]+(?:\.[0-9]+)?)}gc    and return ('NUM',   $1);
    m{\G([A-Za-z_][A-Za-z0-9_]*)}gc and return ('VAR',   $1);
    m{\G(.)}gc                      and return ($1,      $1);
  }
</pre>
<p class="Pp">The <span class="Li">%lexer</span> directive is followed by the
    code defining the lexical analyzer. When called, the variable
    <span class="Li">$_</span> is an alias of the input. The input can also be
    set and accessed via the <span class="Li">&quot;input&quot;</span> method of
    the <span class="Li">$parser</span> object.</p>
<p class="Pp">To catch the next pattern we use the anchor
    <span class="Li">&quot;\G&quot;</span>. The
    <span class="Li">&quot;\G&quot;</span> anchor matches at the point where the
    previous <span class="Li">&quot;/g&quot;</span> match left off. Normally,
    when a scalar <span class="Li">&quot;m{}g&quot;</span> match fails, the
    match position is reset and <span class="Li">&quot;\G&quot;</span> will
    start matching at the beginning of the string. The
    <span class="Li">&quot;c&quot;</span> option causes the match position to be
    retained following an unsuccessful match. The couple
    <span class="Li">&quot;('',undef)&quot;</span> which signals the end of the
    input is automatically inserted by
    <span class="Li">&quot;eyapp&quot;</span>.</p>
<p class="Pp">By default, the lexers generated by
    <span class="Li">&quot;eyapp&quot;</span> emit the end-of-input token
    <span class="Li">&quot;('', undef)&quot;</span> when the end of the current
    string is reached. A <i>incremental lexer</i> differs from these behavior:
    when the end is reached it reads more input from the current file, which was
    set by</p>
<p class="Pp"></p>
<pre>
                 $parser-&gt;YYInputFile
</pre>
<p class="Pp">See the following variant of the synopsis example:</p>
<p class="Pp"></p>
<pre>
  ~/LEyapp/examples/eyappintro$ cat InputFromStream.eyp 
  %whites /([ \t]+)/
  %token NUM = /([0-9]+(?:\.[0-9]+)?)/
  %token VAR = /([A-Za-z][A-Za-z0-9_]*)/

  %right '='
  %left   '-' '+'
  %left   '*' '/'
  %left   NEG

  %defaultaction { &quot;$_[1] $_[3] $_[2]&quot; }

  # example of incremental lexer
  %incremental lexer  'Write an arithmetic expression: '

  %%
  input:                  {}
          |   input line  {}
  ;

  line:     '\n'       {}
          | exp '\n'   { print &quot;$_[1]\n&quot; } 
          | error '\n'   {}
  ;

  exp:        NUM                { $_[1] }
          |   VAR                { $_[1] }
          |   VAR '=' exp         
          |   exp '+' exp         
          |   exp '-' exp        
          |   exp '*' exp       
          |   exp '/' exp      
          |   '-' exp %prec NEG  { &quot;$_[2] NEG&quot; }
          |   '(' exp ')'        { $_[2] } 
  ;

  %%
</pre>
<p class="Pp">Now, after the grammar is compiled</p>
<p class="Pp"></p>
<pre>
  ~/LEyapp/examples/eyappintro$ eyapp -C InputFromStream.eyp
</pre>
<p class="Pp">When the generated modulino is executed, each time the end of the
    input string is reached, it asks for more input until we press the
    end-of-file (<span class="Li">&quot;^D&quot;</span> in Unix) key:</p>
<p class="Pp"></p>
<pre>
  ~/LEyapp/examples/eyappintro$ ./InputFromStream.pm -noslurp
  Write an arithmetic expression: a=2+3*b
  a 2 3 b * + =
  Write an arithmetic expression: a=-b*2
  a b NEG 2 * =
  Write an arithmetic expression: ^D
  ~/LEyapp/examples/eyappintro$
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The__main__and__error__subroutines"><a class="permalink" href="#The__main__and__error__subroutines">The
  &quot;main&quot; and &quot;error&quot; subroutines</a></h2>
<p class="Pp">If you compile your grammar with option
    <span class="Li">&quot;-C&quot;</span>,
    <span class="Li">&quot;eyapp&quot;</span> will insert a line like this as
    the first line of the generated <span class="Li">&quot;.pm&quot;</span>
    file:</p>
<p class="Pp"></p>
<pre>
                #!/usr/bin/perl
</pre>
<p class="Pp">It will also append a line like this as the last line of the
    <span class="Li">&quot;.pm&quot;</span> file:</p>
<p class="Pp"></p>
<pre>
          unless (caller) { exit !__PACKAGE__-&gt;main(''); }
</pre>
<p class="Pp">This allows the alternative use of the module as a script. Unless
    a <span class="Li">&quot;main&quot;</span> subroutine was defined, the one
    provided by Parse::Eyapp::Driver will be called. It also provides a default
    subroutine for the handling of error messages.</p>
<p class="Pp">The default main accepts a few arguments from the command line.
    Here are some:</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;-f filename&quot;</span> input from
      <span class="Li">&quot;filename&quot;</span></li>
  <li><span class="Li">&quot;-c 'string'&quot;</span> input from
      <span class="Li">'string'</span></li>
  <li><span class="Li">&quot;-noslurp&quot;</span> when input is from
      <span class="Li">&quot;STDIN&quot;</span> don't wait for end of file</li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<ul class="Bl-bullet">
  <li>The project home is at &lt;http://code.google.com/p/parse-eyapp/&gt;. Use
      a subversion client to anonymously check out the latest project source
      code:
    <p class="Pp"></p>
    <pre>
   svn checkout http://parse-eyapp.googlecode.com/svn/trunk/ parse-eyapp-read-only
    </pre>
  </li>
  <li>The tutorial <i>Parsing Strings and Trees with</i>
      <span class="Li">&quot;Parse::Eyapp&quot;</span> (An Introduction to
      Compiler Construction in seven pages) in
      &lt;http://nereida.deioc.ull.es/~pl/eyapsimple/&gt;</li>
  <li>Parse::Eyapp, Parse::Eyapp::eyapplanguageref, Parse::Eyapp::debuggingtut,
      Parse::Eyapp::defaultactionsintro, Parse::Eyapp::translationschemestut,
      Parse::Eyapp::Driver, Parse::Eyapp::Node, Parse::Eyapp::YATW,
      Parse::Eyapp::Treeregexp, Parse::Eyapp::Scope, Parse::Eyapp::Base,
      Parse::Eyapp::datagenerationtut</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf&gt;</li>
  <li>perldoc eyapp,</li>
  <li>perldoc treereg,</li>
  <li>perldoc vgg,</li>
  <li>The Syntax Highlight file for vim at
      &lt;http://www.vim.org/scripts/script.php?script_id=2453&gt; and
      &lt;http://nereida.deioc.ull.es/~vim/&gt;</li>
  <li><i>Analisis Lexico y Sintactico</i>, (Notes for a course in compiler
      construction) by Casiano Rodriguez-Leon. Available at
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/&gt; Is the more complete
      and reliable source for Parse::Eyapp. However is in Spanish.</li>
  <li>Parse::Yapp,</li>
  <li>Man pages of <i>yacc</i>(1) and <i>bison</i>(1),
      &lt;http://www.delorie.com/gnu/docs/bison/bison.html&gt;</li>
  <li>Language::AttributeGrammar</li>
  <li>Parse::RecDescent.</li>
  <li>HOP::Parser</li>
  <li>HOP::Lexer</li>
  <li>ocamlyacc tutorial at
      &lt;http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex-ocamlyacc/ocamlyacc-tutorial/ocamlyacc-tutorial.html&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="REFERENCES"><a class="permalink" href="#REFERENCES">REFERENCES</a></h1>
<ul class="Bl-bullet">
  <li>The classic Dragon's book <i>Compilers: Principles, Techniques, and
      Tools</i> by Alfred V. Aho, Ravi Sethi and Jeffrey D. Ullman
      (Addison-Wesley 1986)</li>
  <li><i>CS2121: The Implementation and Power of Programming Languages</i> (See
      &lt;http://www.cs.man.ac.uk/~pjj&gt;,
      &lt;http://www.cs.man.ac.uk/~pjj/complang/g2lr.html&gt; and
      &lt;http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html&gt;) by Pete Jinks</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<ul class="Bl-bullet">
  <li>Hal Finkel &lt;http://www.halssoftware.com/&gt;</li>
  <li>G. Williams &lt;http://kasei.us/&gt;</li>
  <li>Thomas L. Shinnick &lt;http://search.cpan.org/~tshinnic/&gt;</li>
  <li>Frank Leray</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Casiano Rodriguez-Leon (casiano@ull.es)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGMENTS"><a class="permalink" href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a></h1>
<p class="Pp">This work has been supported by CEE (FEDER) and the Spanish
    Ministry of <i>Educacion y Ciencia</i> through <i>Plan Nacional I+D+I</i>
    number TIN2005-08818-C04-04 (ULL::OPLINK project
    &lt;http://www.oplink.ull.es/&gt;). Support from Gobierno de Canarias was
    through GC02210601 (<i>Grupos Consolidados</i>). The University of La Laguna
    has also supported my work in many ways and for many years.</p>
<p class="Pp">A large percentage of code is verbatim taken from Parse::Yapp
    1.05. The author of Parse::Yapp is Francois Desarmenien.</p>
<p class="Pp">I wish to thank Francois Desarmenien for his Parse::Yapp module,
    to my students at La Laguna and to the Perl Community. Thanks to the people
    who have contributed to improve the module (see &quot;CONTRIBUTORS&quot; in
    Parse::Eyapp). Thanks to Larry Wall for giving us Perl. Special thanks to
    Juana.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENCE_AND_COPYRIGHT"><a class="permalink" href="#LICENCE_AND_COPYRIGHT">LICENCE
  AND COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 2006-2008 Casiano Rodriguez-Leon (casiano@ull.es).
    All rights reserved.</p>
<p class="Pp">Parse::Yapp copyright is of Francois Desarmenien, all rights
    reserved. 1998-2001</p>
<p class="Pp">These modules are free software; you can redistribute it and/or
    modify it under the same terms as Perl itself. See perlartistic.</p>
<p class="Pp">This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. </p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2012-03-23</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Class::Method::Modifiers(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Class::Method::Modifiers(3)</td>
    <td class="head-vol"><a href=".">User Contributed Perl Documentation</a></td>
    <td class="head-rtitle">Class::Method::Modifiers(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Class::Method::Modifiers - Provides Moose-like method
  modifiers</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 2.13</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    package Child;
    use parent 'MyParent';
    use Class::Method::Modifiers;
    sub new_method { }
    before 'old_method' =&gt; sub {
        carp &quot;old_method is deprecated, use new_method&quot;;
    };
    around 'other_method' =&gt; sub {
        my $orig = shift;
        my $ret = $orig-&gt;(@_);
        return $ret =~ /\d/ ? $ret : lc $ret;
    };
    after 'private', 'protected' =&gt; sub {
        debug &quot;finished calling a dangerous method&quot;;
    };
    use Class::Method::Modifiers qw(fresh);
    fresh 'not_in_hierarchy' =&gt; sub {
        warn &quot;freshly added method\n&quot;;
    };
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Method modifiers are a convenient feature from the CLOS (Common
    Lisp Object System) world.</p>
<p class="Pp">In its most basic form, a method modifier is just a method that
    calls <span class="Li">&quot;$self-&gt;SUPER::foo(@_)&quot;</span>. I for
    one have trouble remembering that exact invocation, so my classes seldom
    re-dispatch to their base classes. Very bad!</p>
<p class="Pp"><span class="Li">&quot;Class::Method::Modifiers&quot;</span>
    provides three modifiers: <span class="Li">&quot;before&quot;</span>,
    <span class="Li">&quot;around&quot;</span>, and
    <span class="Li">&quot;after&quot;</span>.
    <span class="Li">&quot;before&quot;</span> and
    <span class="Li">&quot;after&quot;</span> are run just before and after the
    method they modify, but can not really affect that original method.
    <span class="Li">&quot;around&quot;</span> is run in place of the original
    method, with a hook to easily call that original method. See the
    &quot;MODIFIERS&quot; section for more details on how the particular
    modifiers work.</p>
<p class="Pp">One clear benefit of using
    <span class="Li">&quot;Class::Method::Modifiers&quot;</span> is that you can
    define multiple modifiers in a single namespace. These separate modifiers
    don't need to know about each other. This makes top-down design easy. Have a
    base class that provides the skeleton methods of each operation, and have
    plugins modify those methods to flesh out the specifics.</p>
<p class="Pp">Parent classes need not know about
    <span class="Li">&quot;Class::Method::Modifiers&quot;</span>. This means you
    should be able to modify methods in <i>any</i> subclass. See
    Term::VT102::ZeroBased for an example of subclassing with
    <span class="Li">&quot;Class::Method::Modifiers&quot;</span>.</p>
<p class="Pp">In short,
    <span class="Li">&quot;Class::Method::Modifiers&quot;</span> solves the
    problem of making sure you call
    <span class="Li">&quot;$self-&gt;SUPER::foo(@_)&quot;</span>, and provides a
    cleaner interface for it.</p>
<p class="Pp">As of version 1.00,
    <span class="Li">&quot;Class::Method::Modifiers&quot;</span> is faster in
    some cases than Moose. See <i>benchmark/method_modifiers.pl</i> in the Moose
    distribution.</p>
<p class="Pp"><span class="Li">&quot;Class::Method::Modifiers&quot;</span> also
    provides an additional &quot;modifier&quot; type,
    <span class="Li">&quot;fresh&quot;</span>; see below.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MODIFIERS"><a class="permalink" href="#MODIFIERS">MODIFIERS</a></h1>
<p class="Pp">All modifiers let you modify one or multiple methods at a time.
    The names of multiple methods can be provided as a list or as an
    array-reference. Examples:</p>
<p class="Pp"></p>
<pre> before 'method' =&gt; sub { ... };
 before 'method1', 'method2' =&gt; sub { ... };
 before [ 'method1', 'method2' ] =&gt; sub { ... };
</pre>
<section class="Ss">
<h2 class="Ss" id="before_method(s)_=__sub___...__;"><a class="permalink" href="#before_method(s)_=__sub___...__;">before
  method(s) =&gt; sub { ... };</a></h2>
<p class="Pp"><span class="Li">&quot;before&quot;</span> is called before the
    method it is modifying. Its return value is totally ignored. It receives the
    same <span class="Li">@_</span> as the method it is modifying would have
    received. You can modify the <span class="Li">@_</span> the original method
    will receive by changing <span class="Li">$_[0]</span> and friends (or by
    changing anything inside a reference). This is a feature!</p>
</section>
<section class="Ss">
<h2 class="Ss" id="after_method(s)_=__sub___...__;"><a class="permalink" href="#after_method(s)_=__sub___...__;">after
  method(s) =&gt; sub { ... };</a></h2>
<p class="Pp"><span class="Li">&quot;after&quot;</span> is called after the
    method it is modifying. Its return value is totally ignored. It receives the
    same <span class="Li">@_</span> as the method it is modifying received,
    mostly. The original method can modify <span class="Li">@_</span> (such as
    by changing <span class="Li">$_[0]</span> or references) and
    <span class="Li">&quot;after&quot;</span> will see the modified version. If
    you don't like this behavior, specify both a
    <span class="Li">&quot;before&quot;</span> and
    <span class="Li">&quot;after&quot;</span>, and copy the
    <span class="Li">@_</span> during <span class="Li">&quot;before&quot;</span>
    for <span class="Li">&quot;after&quot;</span> to use.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="around_method(s)_=__sub___...__;"><a class="permalink" href="#around_method(s)_=__sub___...__;">around
  method(s) =&gt; sub { ... };</a></h2>
<p class="Pp"><span class="Li">&quot;around&quot;</span> is called instead of
    the method it is modifying. The method you're overriding is passed in as the
    first argument (called <span class="Li">$orig</span> by convention). Watch
    out for contextual return values of <span class="Li">$orig</span>.</p>
<p class="Pp">You can use <span class="Li">&quot;around&quot;</span> to:</p>
<dl class="Bl-tag">
  <dt id="Pass"><a class="permalink" href="#Pass">Pass $orig a different
    @_</a></dt>
  <dd>
    <pre>    around 'method' =&gt; sub {
        my $orig = shift;
        my $self = shift;
        $orig-&gt;($self, reverse @_);
    };
    </pre>
  </dd>
  <dt id="Munge"><a class="permalink" href="#Munge">Munge the return value of
    $orig</a></dt>
  <dd>
    <pre>    around 'method' =&gt; sub {
        my $orig = shift;
        ucfirst $orig-&gt;(@_);
    };
    </pre>
  </dd>
  <dt id="Avoid"><a class="permalink" href="#Avoid">Avoid calling $orig --
    conditionally</a></dt>
  <dd>
    <pre>    around 'method' =&gt; sub {
        my $orig = shift;
        return $orig-&gt;(@_) if time() % 2;
        return &quot;no dice, captain&quot;;
    };
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="fresh_method(s)_=__sub___...__;"><a class="permalink" href="#fresh_method(s)_=__sub___...__;">fresh
  method(s) =&gt; sub { ... };</a></h2>
<p class="Pp">(Available since version 2.00)</p>
<p class="Pp">Unlike the other modifiers, this does not modify an existing
    method. Ordinarily, <span class="Li">&quot;fresh&quot;</span> merely
    installs the coderef as a method in the appropriate class; but if the class
    hierarchy already contains a method of the same name, an exception is
    thrown. The idea of this &quot;modifier&quot; is to increase safety when
    subclassing. Suppose you're writing a subclass of a class Some::Base, and
    adding a new method:</p>
<p class="Pp"></p>
<pre>    package My::Subclass;
    use base 'Some::Base';
    sub foo { ... }
</pre>
<p class="Pp">If a later version of Some::Base also adds a new method named
    <span class="Li">&quot;foo&quot;</span>, your method will shadow that
    method. Alternatively, you can use <span class="Li">&quot;fresh&quot;</span>
    to install the additional method into your subclass:</p>
<p class="Pp"></p>
<pre>    package My::Subclass;
    use base 'Some::Base';
    use Class::Method::Modifiers 'fresh';
    fresh 'foo' =&gt; sub { ... };
</pre>
<p class="Pp">Now upgrading Some::Base to a version with a conflicting
    <span class="Li">&quot;foo&quot;</span> method will cause an exception to be
    thrown; seeing that error will give you the opportunity to fix the problem
    (perhaps by picking a different method name in your subclass, or
  similar).</p>
<p class="Pp">Creating fresh methods with
    <span class="Li">&quot;install_modifier&quot;</span> (see below) provides a
    way to get similar safety benefits when adding local monkeypatches to
    existing classes; see
    &lt;http://aaroncrane.co.uk/talks/monkey_patching_subclassing/&gt;.</p>
<p class="Pp">For API compatibility reasons, this function is exported only when
    you ask for it specifically, or for
    <span class="Li">&quot;:all&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="install_modifier_$package,_$type,_@names,_sub___...__"><a class="permalink" href="#install_modifier_$package,_$type,_@names,_sub___...__">install_modifier
  $package, $type, @names, sub { ... }</a></h2>
<p class="Pp"><span class="Li">&quot;install_modifier&quot;</span> is like
    <span class="Li">&quot;before&quot;</span>,
    <span class="Li">&quot;after&quot;</span>,
    <span class="Li">&quot;around&quot;</span>, and
    <span class="Li">&quot;fresh&quot;</span> but it also lets you dynamically
    select the modifier type ('before', 'after', 'around', 'fresh') and package
    that the method modifiers are installed into. This expert-level function is
    exported only when you ask for it specifically, or for
    <span class="Li">&quot;:all&quot;</span>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<p class="Pp">All three normal modifiers;
    <span class="Li">&quot;before&quot;</span>,
    <span class="Li">&quot;after&quot;</span>, and
    <span class="Li">&quot;around&quot;</span>; are exported into your namespace
    by default. You may <span class="Li">&quot;use Class::Method::Modifiers
    ()&quot;</span> to avoid modifying your namespace. I may steal more features
    from Moose, namely <span class="Li">&quot;super&quot;</span>,
    <span class="Li">&quot;override&quot;</span>,
    <span class="Li">&quot;inner&quot;</span>,
    <span class="Li">&quot;augment&quot;</span>, and whatever the Moose folks
    come up with next.</p>
<p class="Pp">Note that the syntax and semantics for these modifiers is directly
    borrowed from Moose (the implementations, however, are not).</p>
<p class="Pp">Class::Trigger shares a few similarities with
    <span class="Li">&quot;Class::Method::Modifiers&quot;</span>, and they even
    have some overlap in purpose -- both can be used to implement highly
    pluggable applications. The difference is that Class::Trigger provides a
    mechanism for easily letting parent classes to invoke hooks defined by other
    code. <span class="Li">&quot;Class::Method::Modifiers&quot;</span> provides
    a way of overriding/augmenting methods safely, and the parent class need not
    know about it.</p>
<section class="Ss">
<h2 class="Ss" id=":lvalue_"><a class="permalink" href="#:lvalue_">:lvalue
  METHODS</a></h2>
<p class="Pp">When adding <span class="Li">&quot;before&quot;</span> or
    <span class="Li">&quot;after&quot;</span> modifiers, the wrapper method will
    be an lvalue method if the wrapped sub is, and assigning to the method will
    propagate to the wrapped method as expected. For
    <span class="Li">&quot;around&quot;</span> modifiers, it is the modifier sub
    that determines if the wrapper method is an lvalue method.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<p class="Pp">It is erroneous to modify a method that doesn't exist in your
    class's inheritance hierarchy. If this occurs, an exception will be thrown
    when the modifier is defined.</p>
<p class="Pp">It doesn't yet play well with
    <span class="Li">&quot;caller&quot;</span>. There are some
    <span class="Li">&quot;TODO&quot;</span> tests for this. Don't get your
    hopes up though!</p>
<p class="Pp">Applying modifiers to array lvalue methods is not fully supported.
    Attempting to assign to an array lvalue method that has an
    <span class="Li">&quot;after&quot;</span> modifier applied will result in an
    error. Array lvalue methods are not well supported by perl in general, and
    should be avoided.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MAJOR_VERSION_CHANGES"><a class="permalink" href="#MAJOR_VERSION_CHANGES">MAJOR
  VERSION CHANGES</a></h1>
<p class="Pp">This module was bumped to 1.00 following a complete
    reimplementation, to indicate breaking backwards compatibility. The
    &quot;guard&quot; modifier was removed, and the internals are completely
    different.</p>
<p class="Pp">The new version is a few times faster with half the code. It's now
    even faster than Moose.</p>
<p class="Pp">Any code that just used modifiers should not change in behavior,
    except to become more correct. And, of course, faster. :)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<ul class="Bl-bullet">
  <li>Class::Method::Modifiers::Fast</li>
  <li>Moose</li>
  <li>Class::Trigger</li>
  <li>Class::MOP::Method::Wrapped</li>
  <li>MRO::Compat</li>
  <li>CLOS &lt;https://en.wikipedia.org/wiki/Common_Lisp_Object_System&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGEMENTS"><a class="permalink" href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></h1>
<p class="Pp">Thanks to Stevan Little for Moose, I would never have known about
    method modifiers otherwise.</p>
<p class="Pp">Thanks to Matt Trout and Stevan Little for their advice.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
<p class="Pp">Bugs may be submitted through the RT bug tracker
    &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=Class-Method-Modifiers&gt;
    (or bug-Class-Method-Modifiers@rt.cpan.org
    &lt;mailto:bug-Class-Method-Modifiers@rt.cpan.org&gt;).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Shawn M Moore &lt;sartak@gmail.com&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<ul class="Bl-bullet">
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Shawn M Moore &lt;code@sartak.org&gt;</li>
  <li>Graham Knop &lt;haarg@haarg.org&gt;</li>
  <li>Aaron Crane &lt;arc@cpan.org&gt;</li>
  <li>Peter Rabbitson &lt;ribasushi@cpan.org&gt;</li>
  <li>Justin Hunter &lt;justin.d.hunter@gmail.com&gt;</li>
  <li>David Steinbrunner &lt;dsteinbrunner@pobox.com&gt;</li>
  <li>gfx &lt;gfuji@cpan.org&gt;</li>
  <li>mannih &lt;github@lxxi.org&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2007 by Shawn M Moore.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-08-10</td>
    <td class="foot-os"><a href="..">perl v5.34.0</a></td>
  </tr>
</table>
</body>
</html>

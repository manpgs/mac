<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Parser(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Parser(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Parser(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">HTML::Parser - HTML parser class</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
 use HTML::Parser ();

 # Create parser object
 $p = HTML::Parser-&gt;new( api_version =&gt; 3,
                         start_h =&gt; [\&amp;start, &quot;tagname, attr&quot;],
                         end_h   =&gt; [\&amp;end,   &quot;tagname&quot;],
                         marked_sections =&gt; 1,
                       );

 # Parse document text chunk by chunk
 $p-&gt;parse($chunk1);
 $p-&gt;parse($chunk2);
 #...
 $p-&gt;eof;                 # signal end of document

 # Parse directly from file
 $p-&gt;parse_file(&quot;foo.html&quot;);
 # or
 open(my $fh, &quot;&lt;:utf8&quot;, &quot;foo.html&quot;) || die;
 $p-&gt;parse_file($fh);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Objects of the <span class="Li">&quot;HTML::Parser&quot;</span>
    class will recognize markup and separate it from plain text (alias data
    content) in HTML documents. As different kinds of markup and text are
    recognized, the corresponding event handlers are invoked.</p>
<p class="Pp"><span class="Li">&quot;HTML::Parser&quot;</span> is not a generic
    SGML parser. We have tried to make it able to deal with the HTML that is
    actually &quot;out there&quot;, and it normally parses as closely as
    possible to the way the popular web browsers do it instead of strictly
    following one of the many HTML specifications from W3C. Where there is
    disagreement, there is often an option that you can enable to get the
    official behaviour.</p>
<p class="Pp">The document to be parsed may be supplied in arbitrary chunks.
    This makes on-the-fly parsing as documents are received from the network
    possible.</p>
<p class="Pp">If event driven parsing does not feel right for your application,
    you might want to use <span class="Li">&quot;HTML::PullParser&quot;</span>.
    This is an <span class="Li">&quot;HTML::Parser&quot;</span> subclass that
    allows a more conventional program structure.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<p class="Pp">The following method is used to construct a new
    <span class="Li">&quot;HTML::Parser&quot;</span> object:</p>
<dl class="Bl-tag">
  <dt>$p = HTML::Parser-&gt;new( %options_and_handlers )</dt>
  <dd>This class method creates a new
      <span class="Li">&quot;HTML::Parser&quot;</span> object and returns it.
      Key/value argument pairs may be provided to assign event handlers or
      initialize parser options. The handlers and parser options can also be set
      or modified later by the method calls described below.
    <p class="Pp">If a top level key is in the form &quot;&lt;event&gt;_h&quot;
        (e.g., &quot;text_h&quot;) then it assigns a handler to that event,
        otherwise it initializes a parser option. The event handler
        specification value must be an array reference. Multiple handlers may
        also be assigned with the 'handlers =&gt; [%handlers]' option. See
        examples below.</p>
    <p class="Pp">If <i>new()</i> is called without any arguments, it will
        create a parser that uses callback methods compatible with version 2 of
        <span class="Li">&quot;HTML::Parser&quot;</span>. See the section on
        &quot;version 2 compatibility&quot; below for details.</p>
    <p class="Pp">The special constructor option 'api_version =&gt; 2' can be
        used to initialize version 2 callbacks while still setting other options
        and handlers. The 'api_version =&gt; 3' option can be used if you don't
        want to set any options and don't want to fall back to v2 compatible
        mode.</p>
    <p class="Pp">Examples:</p>
    <p class="Pp"></p>
    <pre>
 $p = HTML::Parser-&gt;new(api_version =&gt; 3,
                        text_h =&gt; [ sub {...}, &quot;dtext&quot; ]);
    </pre>
    <p class="Pp">This creates a new parser object with a text event handler
        subroutine that receives the original text with general entities
        decoded.</p>
    <p class="Pp"></p>
    <pre>
 $p = HTML::Parser-&gt;new(api_version =&gt; 3,
                        start_h =&gt; [ 'my_start', &quot;self,tokens&quot; ]);
    </pre>
    <p class="Pp">This creates a new parser object with a start event handler
        method that receives the <span class="Li">$p</span> and the tokens
        array.</p>
    <p class="Pp"></p>
    <pre>
 $p = HTML::Parser-&gt;new(api_version =&gt; 3,
                        handlers =&gt; { text =&gt; [\@array, &quot;event,text&quot;],
                                      comment =&gt; [\@array, &quot;event,text&quot;],
                                    });
    </pre>
    <p class="Pp">This creates a new parser object that stores the event type
        and the original text in <span class="Li">@array</span> for text and
        comment events.</p>
  </dd>
</dl>
<p class="Pp">The following methods feed the HTML document to the
    <span class="Li">&quot;HTML::Parser&quot;</span> object:</p>
<dl class="Bl-tag">
  <dt>$p-&gt;parse( $string )</dt>
  <dd>Parse <span class="Li">$string</span> as the next chunk of the HTML
      document. Handlers invoked should not attempt to modify the
      <span class="Li">$string</span> in-place until
      <span class="Li">$p</span>-&gt;parse returns.
    <p class="Pp">If an invoked event handler aborts parsing by calling
        <span class="Li">$p</span>-&gt;eof, then
        <span class="Li">$p</span>-&gt;<i>parse()</i> will return a FALSE value.
        Otherwise the return value is a reference to the parser object ($p).</p>
  </dd>
  <dt>$p-&gt;parse( $code_ref )</dt>
  <dd>If a code reference is passed as the argument to be parsed, then the
      chunks to be parsed are obtained by invoking this function repeatedly.
      Parsing continues until the function returns an empty (or undefined)
      result. When this happens <span class="Li">$p</span>-&gt;eof is
      automatically signaled.
    <p class="Pp">Parsing will also abort if one of the event handlers calls
        <span class="Li">$p</span>-&gt;eof.</p>
    <p class="Pp">The effect of this is the same as:</p>
    <p class="Pp"></p>
    <pre>
 while (1) {
    my $chunk = &amp;$code_ref();
    if (!defined($chunk) || !length($chunk)) {
        $p-&gt;eof;
        return $p;
    }
    $p-&gt;parse($chunk) || return undef;
 }
    </pre>
    <p class="Pp">But it is more efficient as this loop runs internally in XS
        code.</p>
  </dd>
  <dt>$p-&gt;parse_file( $file )</dt>
  <dd>Parse text directly from a file. The <span class="Li">$file</span>
      argument can be a filename, an open file handle, or a reference to an open
      file handle.
    <p class="Pp">If <span class="Li">$file</span> contains a filename and the
        file can't be opened, then the method returns an undefined value and $!
        tells why it failed. Otherwise the return value is a reference to the
        parser object.</p>
    <p class="Pp">If a file handle is passed as the
        <span class="Li">$file</span> argument, then the file will normally be
        read until EOF, but not closed.</p>
    <p class="Pp">If an invoked event handler aborts parsing by calling
        <span class="Li">$p</span>-&gt;eof, then
        <span class="Li">$p</span>-&gt;<i>parse_file()</i> may not have read the
        entire file.</p>
    <p class="Pp">On systems with multi-byte line terminators, the values passed
        for the offset and length argspecs may be too low if <i>parse_file()</i>
        is called on a file handle that is not in binary mode.</p>
    <p class="Pp">If a filename is passed in, then <i>parse_file()</i> will open
        the file in binary mode.</p>
  </dd>
  <dt>$p-&gt;eof</dt>
  <dd>Signals the end of the HTML document. Calling the
      <span class="Li">$p</span>-&gt;eof method outside a handler callback will
      flush any remaining buffered text (which triggers the
      <span class="Li">&quot;text&quot;</span> event if there is any remaining
      text).
    <p class="Pp">Calling <span class="Li">$p</span>-&gt;eof inside a handler
        will terminate parsing at that point and cause
        <span class="Li">$p</span>-&gt;parse to return a FALSE value. This also
        terminates parsing by
        <span class="Li">$p</span>-&gt;<i>parse_file()</i>.</p>
    <p class="Pp">After <span class="Li">$p</span>-&gt;eof has been called, the
        <i>parse()</i> and <i>parse_file()</i> methods can be invoked to feed
        new documents with the parser object.</p>
    <p class="Pp">The return value from <i>eof()</i> is a reference to the
        parser object.</p>
  </dd>
</dl>
<p class="Pp">Most parser options are controlled by boolean attributes. Each
    boolean attribute is enabled by calling the corresponding method with a TRUE
    argument and disabled with a FALSE argument. The attribute value is left
    unchanged if no argument is given. The return value from each method is the
    old attribute value.</p>
<p class="Pp">Methods that can be used to get and/or set parser options are:</p>
<dl class="Bl-tag">
  <dt>$p-&gt;attr_encoded</dt>
  <dd></dd>
  <dt>$p-&gt;attr_encoded( $bool )</dt>
  <dd>By default, the <span class="Li">&quot;attr&quot;</span> and
      <span class="Li">@attr</span> argspecs will have general entities for
      attribute values decoded. Enabling this attribute leaves entities
    alone.</dd>
  <dt>$p-&gt;backquote</dt>
  <dd></dd>
  <dt>$p-&gt;backquote( $bool )</dt>
  <dd>By default, only ' and &quot; are recognized as quote characters around
      attribute values. MSIE also recognizes backquotes for some reason.
      Enabling this attribute provides compatibility with this behaviour.</dd>
  <dt>$p-&gt;boolean_attribute_value( $val )</dt>
  <dd>This method sets the value reported for boolean attributes inside HTML
      start tags. By default, the name of the attribute is also used as its
      value. This affects the values reported for
      <span class="Li">&quot;tokens&quot;</span> and
      <span class="Li">&quot;attr&quot;</span> argspecs.</dd>
  <dt>$p-&gt;case_sensitive</dt>
  <dd></dd>
  <dt>$p-&gt;case_sensitive( $bool )</dt>
  <dd>By default, tagnames and attribute names are down-cased. Enabling this
      attribute leaves them as found in the HTML source document.</dd>
  <dt>$p-&gt;closing_plaintext</dt>
  <dd></dd>
  <dt>$p-&gt;closing_plaintext( $bool )</dt>
  <dd>By default, &quot;plaintext&quot; element can never be closed. Everything
      up to the end of the document is parsed in CDATA mode. This historical
      behaviour is what at least MSIE does. Enabling this attribute makes
      closing &quot;&lt;/plaintext&gt;&quot; tag effective and the parsing
      process will resume after seeing this tag. This emulates early gecko-based
      browsers.</dd>
  <dt>$p-&gt;empty_element_tags</dt>
  <dd></dd>
  <dt>$p-&gt;empty_element_tags( $bool )</dt>
  <dd>By default, empty element tags are not recognized as such and the
      &quot;/&quot; before &quot;&gt;&quot; is just treated like a normal name
      character (unless <span class="Li">&quot;strict_names&quot;</span> is
      enabled). Enabling this attribute make
      <span class="Li">&quot;HTML::Parser&quot;</span> recognize these tags.
    <p class="Pp">Empty element tags look like start tags, but end with the
        character sequence &quot;/&gt;&quot; instead of &quot;&gt;&quot;. When
        recognized by <span class="Li">&quot;HTML::Parser&quot;</span> they
        cause an artificial end event in addition to the start event. The
        <span class="Li">&quot;text&quot;</span> for the artificial end event
        will be empty and the <span class="Li">&quot;tokenpos&quot;</span> array
        will be undefined even though the the token array will have one element
        containing the tag name.</p>
  </dd>
  <dt>$p-&gt;marked_sections</dt>
  <dd></dd>
  <dt>$p-&gt;marked_sections( $bool )</dt>
  <dd>By default, section markings like &lt;![CDATA[...]]&gt; are treated like
      ordinary text. When this attribute is enabled section markings are
      honoured.
    <p class="Pp">There are currently no events associated with the marked
        section markup, but the text can be returned as
        <span class="Li">&quot;skipped_text&quot;</span>.</p>
  </dd>
  <dt>$p-&gt;strict_comment</dt>
  <dd></dd>
  <dt>$p-&gt;strict_comment( $bool )</dt>
  <dd>By default, comments are terminated by the first occurrence of
      &quot;--&gt;&quot;. This is the behaviour of most popular browsers (like
      Mozilla, Opera and MSIE), but it is not correct according to the official
      HTML standard. Officially, you need an even number of &quot;--&quot;
      tokens before the closing &quot;&gt;&quot; is recognized and there may not
      be anything but whitespace between an even and an odd &quot;--&quot;.
    <p class="Pp">The official behaviour is enabled by enabling this
      attribute.</p>
    <p class="Pp">Enabling of 'strict_comment' also disables recognizing these
        forms as comments:</p>
    <p class="Pp"></p>
    <pre>
  &lt;/ comment&gt;
  &lt;! comment&gt;
    </pre>
  </dd>
  <dt>$p-&gt;strict_end</dt>
  <dd></dd>
  <dt>$p-&gt;strict_end( $bool )</dt>
  <dd>By default, attributes and other junk are allowed to be present on end
      tags in a manner that emulates MSIE's behaviour.
    <p class="Pp">The official behaviour is enabled with this attribute. If
        enabled, only whitespace is allowed between the tagname and the final
        &quot;&gt;&quot;.</p>
  </dd>
  <dt>$p-&gt;strict_names</dt>
  <dd></dd>
  <dt>$p-&gt;strict_names( $bool )</dt>
  <dd>By default, almost anything is allowed in tag and attribute names. This is
      the behaviour of most popular browsers and allows us to parse some broken
      tags with invalid attribute values like:
    <p class="Pp"></p>
    <pre>
   &lt;IMG SRC=newprevlstGr.gif ALT=[PREV LIST] BORDER=0&gt;
    </pre>
    <p class="Pp">By default, &quot;LIST]&quot; is parsed as a boolean
        attribute, not as part of the ALT value as was clearly intended. This is
        also what Mozilla sees.</p>
    <p class="Pp">The official behaviour is enabled by enabling this attribute.
        If enabled, it will cause the tag above to be reported as text since
        &quot;LIST]&quot; is not a legal attribute name.</p>
  </dd>
  <dt>$p-&gt;unbroken_text</dt>
  <dd></dd>
  <dt>$p-&gt;unbroken_text( $bool )</dt>
  <dd>By default, blocks of text are given to the text handler as soon as
      possible (but the parser takes care always to break text at a boundary
      between whitespace and non-whitespace so single words and entities can
      always be decoded safely). This might create breaks that make it hard to
      do transformations on the text. When this attribute is enabled, blocks of
      text are always reported in one piece. This will delay the text event
      until the following (non-text) event has been recognized by the parser.
    <p class="Pp">Note that the <span class="Li">&quot;offset&quot;</span>
        argspec will give you the offset of the first segment of text and
        <span class="Li">&quot;length&quot;</span> is the combined length of the
        segments. Since there might be ignored tags in between, these numbers
        can't be used to directly index in the original document file.</p>
  </dd>
  <dt>$p-&gt;utf8_mode</dt>
  <dd></dd>
  <dt>$p-&gt;utf8_mode( $bool )</dt>
  <dd>Enable this option when parsing raw undecoded UTF-8. This tells the parser
      that the entities expanded for strings reported by
      <span class="Li">&quot;attr&quot;</span>, <span class="Li">@attr</span>
      and <span class="Li">&quot;dtext&quot;</span> should be expanded as
      decoded UTF-8 so they end up compatible with the surrounding text.
    <p class="Pp">If <span class="Li">&quot;utf8_mode&quot;</span> is enabled
        then it is an error to pass strings containing characters with code
        above 255 to the <i>parse()</i> method, and the <i>parse()</i> method
        will croak if you try.</p>
    <p class="Pp">Example: The Unicode character &quot;\x{2665}&quot; is
        &quot;\xE2\x99\xA5&quot; when UTF-8 encoded. The character can also be
        represented by the entity &quot;&amp;hearts;&quot; or
        &quot;&amp;#x2665&quot;. If we feed the parser:</p>
    <p class="Pp"></p>
    <pre>
  $p-&gt;parse(&quot;\xE2\x99\xA5&amp;hearts;&quot;);
    </pre>
    <p class="Pp">then <span class="Li">&quot;dtext&quot;</span> will be
        reported as &quot;\xE2\x99\xA5\x{2665}&quot; without
        <span class="Li">&quot;utf8_mode&quot;</span> enabled, but as
        &quot;\xE2\x99\xA5\xE2\x99\xA5&quot; when enabled. The later string is
        what you want.</p>
    <p class="Pp">This option is only available with perl-5.8 or better.</p>
  </dd>
  <dt>$p-&gt;xml_mode</dt>
  <dd></dd>
  <dt>$p-&gt;xml_mode( $bool )</dt>
  <dd>Enabling this attribute changes the parser to allow some XML constructs.
      This enables the behaviour controlled by individually by the
      <span class="Li">&quot;case_sensitive&quot;</span>,
      <span class="Li">&quot;empty_element_tags&quot;</span>,
      <span class="Li">&quot;strict_names&quot;</span> and
      <span class="Li">&quot;xml_pic&quot;</span> attributes and also suppresses
      special treatment of elements that are parsed as CDATA for HTML.</dd>
  <dt>$p-&gt;xml_pic</dt>
  <dd></dd>
  <dt>$p-&gt;xml_pic( $bool )</dt>
  <dd>By default, <i>processing instructions</i> are terminated by
      &quot;&gt;&quot;. When this attribute is enabled, processing instructions
      are terminated by &quot;?&gt;&quot; instead.</dd>
</dl>
<p class="Pp">As markup and text is recognized, handlers are invoked. The
    following method is used to set up handlers for different events:</p>
<dl class="Bl-tag">
  <dt>$p-&gt;handler( event =&gt; \&amp;subroutine, $argspec )</dt>
  <dd></dd>
  <dt>$p-&gt;handler( event =&gt; $method_name, $argspec )</dt>
  <dd></dd>
  <dt>$p-&gt;handler( event =&gt; \@accum, $argspec )</dt>
  <dd></dd>
  <dt>$p-&gt;handler( event =&gt; &quot;&quot; );</dt>
  <dd></dd>
  <dt>$p-&gt;handler( event =&gt; undef );</dt>
  <dd></dd>
  <dt>$p-&gt;handler( event );</dt>
  <dd>This method assigns a subroutine, method, or array to handle an event.
    <p class="Pp">Event is one of <span class="Li">&quot;text&quot;</span>,
        <span class="Li">&quot;start&quot;</span>,
        <span class="Li">&quot;end&quot;</span>,
        <span class="Li">&quot;declaration&quot;</span>,
        <span class="Li">&quot;comment&quot;</span>,
        <span class="Li">&quot;process&quot;</span>,
        <span class="Li">&quot;start_document&quot;</span>,
        <span class="Li">&quot;end_document&quot;</span> or
        <span class="Li">&quot;default&quot;</span>.</p>
    <p class="Pp">The <span class="Li">&quot;\&amp;subroutine&quot;</span> is a
        reference to a subroutine which is called to handle the event.</p>
    <p class="Pp">The <span class="Li">$method_name</span> is the name of a
        method of <span class="Li">$p</span> which is called to handle the
        event.</p>
    <p class="Pp">The <span class="Li">@accum</span> is an array that will hold
        the event information as sub-arrays.</p>
    <p class="Pp">If the second argument is &quot;&quot;, the event is ignored.
        If it is undef, the default handler is invoked for the event.</p>
    <p class="Pp">The <span class="Li">$argspec</span> is a string that
        describes the information to be reported for the event. Any requested
        information that does not apply to a specific event is passed as
        <span class="Li">&quot;undef&quot;</span>. If argspec is omitted, then
        it is left unchanged.</p>
    <p class="Pp">The return value from <span class="Li">$p</span>-&gt;handler
        is the old callback routine or a reference to the accumulator array.</p>
    <p class="Pp">Any return values from handler callback routines/methods are
        always ignored. A handler callback can request parsing to be aborted by
        invoking the <span class="Li">$p</span>-&gt;eof method. A handler
        callback is not allowed to invoke the
        <span class="Li">$p</span>-&gt;<i>parse()</i> or
        <span class="Li">$p</span>-&gt;<i>parse_file()</i> method. An exception
        will be raised if it tries.</p>
    <p class="Pp">Examples:</p>
    <p class="Pp"></p>
    <pre>
    $p-&gt;handler(start =&gt;  &quot;start&quot;, 'self, attr, attrseq, text' );
    </pre>
    <p class="Pp">This causes the &quot;start&quot; method of object
        <span class="Li">$p</span> to be called for 'start' events. The callback
        signature is <span class="Li">$p</span>-&gt;start(\%attr, \@attr_seq,
        <span class="Li">$text</span>).</p>
    <p class="Pp"></p>
    <pre>
    $p-&gt;handler(start =&gt;  \&amp;start, 'attr, attrseq, text' );
    </pre>
    <p class="Pp">This causes subroutine <i>start()</i> to be called for 'start'
        events. The callback signature is start(\%attr, \@attr_seq,
        <span class="Li">$text</span>).</p>
    <p class="Pp"></p>
    <pre>
    $p-&gt;handler(start =&gt;  \@accum, '&quot;S&quot;, attr, attrseq, text' );
    </pre>
    <p class="Pp">This causes 'start' event information to be saved in
        <span class="Li">@accum</span>. The array elements will be ['S', \%attr,
        \@attr_seq, <span class="Li">$text</span>].</p>
    <p class="Pp"></p>
    <pre>
   $p-&gt;handler(start =&gt; &quot;&quot;);
    </pre>
    <p class="Pp">This causes 'start' events to be ignored. It also suppresses
        invocations of any default handler for start events. It is in most cases
        equivalent to <span class="Li">$p</span>-&gt;handler(start =&gt; sub
        {}), but is more efficient. It is different from the empty-sub-handler
        in that <span class="Li">&quot;skipped_text&quot;</span> is not reset by
        it.</p>
    <p class="Pp"></p>
    <pre>
   $p-&gt;handler(start =&gt; undef);
    </pre>
    <p class="Pp">This causes no handler to be associated with start events. If
        there is a default handler it will be invoked.</p>
  </dd>
</dl>
<p class="Pp">Filters based on tags can be set up to limit the number of events
    reported. The main bottleneck during parsing is often the huge number of
    callbacks made from the parser. Applying filters can improve performance
    significantly.</p>
<p class="Pp">The following methods control filters:</p>
<dl class="Bl-tag">
  <dt>$p-&gt;ignore_elements( @tags )</dt>
  <dd>Both the <span class="Li">&quot;start&quot;</span> event and the
      <span class="Li">&quot;end&quot;</span> event as well as any events that
      would be reported in between are suppressed. The ignored elements can
      contain nested occurrences of itself. Example:
    <p class="Pp"></p>
    <pre>
   $p-&gt;ignore_elements(qw(script style));
    </pre>
    <p class="Pp">The <span class="Li">&quot;script&quot;</span> and
        <span class="Li">&quot;style&quot;</span> tags will always nest properly
        since their content is parsed in CDATA mode. For most other tags
        <span class="Li">&quot;ignore_elements&quot;</span> must be used with
        caution since HTML is often not <i>well formed</i>.</p>
  </dd>
  <dt>$p-&gt;ignore_tags( @tags )</dt>
  <dd>Any <span class="Li">&quot;start&quot;</span> and
      <span class="Li">&quot;end&quot;</span> events involving any of the tags
      given are suppressed. To reset the filter (i.e. don't suppress any
      <span class="Li">&quot;start&quot;</span> and
      <span class="Li">&quot;end&quot;</span> events), call
      <span class="Li">&quot;ignore_tags&quot;</span> without an argument.</dd>
  <dt>$p-&gt;report_tags( @tags )</dt>
  <dd>Any <span class="Li">&quot;start&quot;</span> and
      <span class="Li">&quot;end&quot;</span> events involving any of the tags
      <i>not</i> given are suppressed. To reset the filter (i.e. report all
      <span class="Li">&quot;start&quot;</span> and
      <span class="Li">&quot;end&quot;</span> events), call
      <span class="Li">&quot;report_tags&quot;</span> without an argument.</dd>
</dl>
<p class="Pp">Internally, the system has two filter lists, one for
    <span class="Li">&quot;report_tags&quot;</span> and one for
    <span class="Li">&quot;ignore_tags&quot;</span>, and both filters are
    applied. This effectively gives
    <span class="Li">&quot;ignore_tags&quot;</span> precedence over
    <span class="Li">&quot;report_tags&quot;</span>.</p>
<p class="Pp">Examples:</p>
<p class="Pp"></p>
<pre>
   $p-&gt;ignore_tags(qw(style));
   $p-&gt;report_tags(qw(script style));
</pre>
<p class="Pp">results in only <span class="Li">&quot;script&quot;</span> events
    being reported.</p>
<section class="Ss">
<h2 class="Ss" id="Argspec"><a class="permalink" href="#Argspec">Argspec</a></h2>
<p class="Pp">Argspec is a string containing a comma-separated list that
    describes the information reported by the event. The following argspec
    identifier names can be used:</p>
<dl class="Bl-tag">
  <dt>&quot;attr&quot;</dt>
  <dd>Attr causes a reference to a hash of attribute name/value pairs to be
      passed.
    <p class="Pp">Boolean attributes' values are either the value set by
        <span class="Li">$p</span>-&gt;boolean_attribute_value, or the attribute
        name if no value has been set by
        <span class="Li">$p</span>-&gt;boolean_attribute_value.</p>
    <p class="Pp">This passes undef except for
        <span class="Li">&quot;start&quot;</span> events.</p>
    <p class="Pp">Unless <span class="Li">&quot;xml_mode&quot;</span> or
        <span class="Li">&quot;case_sensitive&quot;</span> is enabled, the
        attribute names are forced to lower case.</p>
    <p class="Pp">General entities are decoded in the attribute values and one
        layer of matching quotes enclosing the attribute values is removed.</p>
    <p class="Pp">The Unicode character set is assumed for entity decoding.</p>
  </dd>
  <dt>@attr</dt>
  <dd>Basically the same as <span class="Li">&quot;attr&quot;</span>, but keys
      and values are passed as individual arguments and the original sequence of
      the attributes is kept. The parameters passed will be the same as the
      <span class="Li">@attr</span> calculated here:
    <p class="Pp"></p>
    <pre>
   @attr = map { $_ =&gt; $attr-&gt;{$_} } @$attrseq;
    </pre>
    <p class="Pp">assuming <span class="Li">$attr</span> and
        <span class="Li">$attrseq</span> here are the hash and array passed as
        the result of <span class="Li">&quot;attr&quot;</span> and
        <span class="Li">&quot;attrseq&quot;</span> argspecs.</p>
    <p class="Pp">This passes no values for events besides
        <span class="Li">&quot;start&quot;</span>.</p>
  </dd>
  <dt>&quot;attrseq&quot;</dt>
  <dd>Attrseq causes a reference to an array of attribute names to be passed.
      This can be useful if you want to walk the
      <span class="Li">&quot;attr&quot;</span> hash in the original sequence.
    <p class="Pp">This passes undef except for
        <span class="Li">&quot;start&quot;</span> events.</p>
    <p class="Pp">Unless <span class="Li">&quot;xml_mode&quot;</span> or
        <span class="Li">&quot;case_sensitive&quot;</span> is enabled, the
        attribute names are forced to lower case.</p>
  </dd>
  <dt>&quot;column&quot;</dt>
  <dd>Column causes the column number of the start of the event to be passed.
      The first column on a line is 0.</dd>
  <dt>&quot;dtext&quot;</dt>
  <dd>Dtext causes the decoded text to be passed. General entities are
      automatically decoded unless the event was inside a CDATA section or was
      between literal start and end tags
      (<span class="Li">&quot;script&quot;</span>,
      <span class="Li">&quot;style&quot;</span>,
      <span class="Li">&quot;xmp&quot;</span>,
      <span class="Li">&quot;iframe&quot;</span>,
      <span class="Li">&quot;title&quot;</span>,
      <span class="Li">&quot;textarea&quot;</span> and
      <span class="Li">&quot;plaintext&quot;</span>).
    <p class="Pp">The Unicode character set is assumed for entity decoding. With
        Perl version 5.6 or earlier only the Latin-1 range is supported, and
        entities for characters outside the range 0..255 are left unchanged.</p>
    <p class="Pp">This passes undef except for
        <span class="Li">&quot;text&quot;</span> events.</p>
  </dd>
  <dt>&quot;event&quot;</dt>
  <dd>Event causes the event name to be passed.
    <p class="Pp">The event name is one of
        <span class="Li">&quot;text&quot;</span>,
        <span class="Li">&quot;start&quot;</span>,
        <span class="Li">&quot;end&quot;</span>,
        <span class="Li">&quot;declaration&quot;</span>,
        <span class="Li">&quot;comment&quot;</span>,
        <span class="Li">&quot;process&quot;</span>,
        <span class="Li">&quot;start_document&quot;</span> or
        <span class="Li">&quot;end_document&quot;</span>.</p>
  </dd>
  <dt>&quot;is_cdata&quot;</dt>
  <dd>Is_cdata causes a TRUE value to be passed if the event is inside a CDATA
      section or between literal start and end tags
      (<span class="Li">&quot;script&quot;</span>,
      <span class="Li">&quot;style&quot;</span>,
      <span class="Li">&quot;xmp&quot;</span>,
      <span class="Li">&quot;iframe&quot;</span>,
      <span class="Li">&quot;title&quot;</span>,
      <span class="Li">&quot;textarea&quot;</span> and
      <span class="Li">&quot;plaintext&quot;</span>).
    <p class="Pp">if the flag is FALSE for a text event, then you should
        normally either use <span class="Li">&quot;dtext&quot;</span> or decode
        the entities yourself before the text is processed further.</p>
  </dd>
  <dt>&quot;length&quot;</dt>
  <dd>Length causes the number of bytes of the source text of the event to be
      passed.</dd>
  <dt>&quot;line&quot;</dt>
  <dd>Line causes the line number of the start of the event to be passed. The
      first line in the document is 1. Line counting doesn't start until at
      least one handler requests this value to be reported.</dd>
  <dt>&quot;offset&quot;</dt>
  <dd>Offset causes the byte position in the HTML document of the start of the
      event to be passed. The first byte in the document has offset 0.</dd>
  <dt>&quot;offset_end&quot;</dt>
  <dd>Offset_end causes the byte position in the HTML document of the end of the
      event to be passed. This is the same as
      <span class="Li">&quot;offset&quot;</span> +
      <span class="Li">&quot;length&quot;</span>.</dd>
  <dt>&quot;self&quot;</dt>
  <dd>Self causes the current object to be passed to the handler. If the handler
      is a method, this must be the first element in the argspec.
    <p class="Pp">An alternative to passing self as an argspec is to register
        closures that capture <span class="Li">$self</span> by themselves as
        handlers. Unfortunately this creates circular references which prevent
        the HTML::Parser object from being garbage collected. Using the
        <span class="Li">&quot;self&quot;</span> argspec avoids this
      problem.</p>
  </dd>
  <dt>&quot;skipped_text&quot;</dt>
  <dd>Skipped_text returns the concatenated text of all the events that have
      been skipped since the last time an event was reported. Events might be
      skipped because no handler is registered for them or because some filter
      applies. Skipped text also includes marked section markup, since there are
      no events that can catch it.
    <p class="Pp">If an <span class="Li">&quot;&quot;</span>-handler is
        registered for an event, then the text for this event is not included in
        <span class="Li">&quot;skipped_text&quot;</span>. Skipped text both
        before and after the <span class="Li">&quot;&quot;</span>-event is
        included in the next reported
        <span class="Li">&quot;skipped_text&quot;</span>.</p>
  </dd>
  <dt>&quot;tag&quot;</dt>
  <dd>Same as <span class="Li">&quot;tagname&quot;</span>, but prefixed with
      &quot;/&quot; if it belongs to an <span class="Li">&quot;end&quot;</span>
      event and &quot;!&quot; for a declaration. The
      <span class="Li">&quot;tag&quot;</span> does not have any prefix for
      <span class="Li">&quot;start&quot;</span> events, and is in this case
      identical to <span class="Li">&quot;tagname&quot;</span>.</dd>
  <dt>&quot;tagname&quot;</dt>
  <dd>This is the element name (or <i>generic identifier</i> in SGML jargon) for
      start and end tags. Since HTML is case insensitive, this name is forced to
      lower case to ease string matching.
    <p class="Pp">Since XML is case sensitive, the tagname case is not changed
        when <span class="Li">&quot;xml_mode&quot;</span> is enabled. The same
        happens if the <span class="Li">&quot;case_sensitive&quot;</span>
        attribute is set.</p>
    <p class="Pp">The declaration type of declaration elements is also passed as
        a tagname, even if that is a bit strange. In fact, in the current
        implementation tagname is identical to
        <span class="Li">&quot;token0&quot;</span> except that the name may be
        forced to lower case.</p>
  </dd>
  <dt>&quot;token0&quot;</dt>
  <dd>Token0 causes the original text of the first token string to be passed.
      This should always be the same as <span class="Li">$tokens</span>-&gt;[0].
    <p class="Pp">For <span class="Li">&quot;declaration&quot;</span> events,
        this is the declaration type.</p>
    <p class="Pp">For <span class="Li">&quot;start&quot;</span> and
        <span class="Li">&quot;end&quot;</span> events, this is the tag
      name.</p>
    <p class="Pp">For <span class="Li">&quot;process&quot;</span> and non-strict
        <span class="Li">&quot;comment&quot;</span> events, this is everything
        inside the tag.</p>
    <p class="Pp">This passes undef if there are no tokens in the event.</p>
  </dd>
  <dt>&quot;tokenpos&quot;</dt>
  <dd>Tokenpos causes a reference to an array of token positions to be passed.
      For each string that appears in
      <span class="Li">&quot;tokens&quot;</span>, this array contains two
      numbers. The first number is the offset of the start of the token in the
      original <span class="Li">&quot;text&quot;</span> and the second number is
      the length of the token.
    <p class="Pp">Boolean attributes in a
        <span class="Li">&quot;start&quot;</span> event will have (0,0) for the
        attribute value offset and length.</p>
    <p class="Pp">This passes undef if there are no tokens in the event (e.g.,
        <span class="Li">&quot;text&quot;</span>) and for artificial
        <span class="Li">&quot;end&quot;</span> events triggered by empty
        element tags.</p>
    <p class="Pp">If you are using these offsets and lengths to modify
        <span class="Li">&quot;text&quot;</span>, you should either work from
        right to left, or be very careful to calculate the changes to the
        offsets.</p>
  </dd>
  <dt>&quot;tokens&quot;</dt>
  <dd>Tokens causes a reference to an array of token strings to be passed. The
      strings are exactly as they were found in the original text, no decoding
      or case changes are applied.
    <p class="Pp">For <span class="Li">&quot;declaration&quot;</span> events,
        the array contains each word, comment, and delimited string starting
        with the declaration type.</p>
    <p class="Pp">For <span class="Li">&quot;comment&quot;</span> events, this
        contains each sub-comment. If
        <span class="Li">$p</span>-&gt;strict_comments is disabled, there will
        be only one sub-comment.</p>
    <p class="Pp">For <span class="Li">&quot;start&quot;</span> events, this
        contains the original tag name followed by the attribute name/value
        pairs. The values of boolean attributes will be either the value set by
        <span class="Li">$p</span>-&gt;boolean_attribute_value, or the attribute
        name if no value has been set by
        <span class="Li">$p</span>-&gt;boolean_attribute_value.</p>
    <p class="Pp">For <span class="Li">&quot;end&quot;</span> events, this
        contains the original tag name (always one token).</p>
    <p class="Pp">For <span class="Li">&quot;process&quot;</span> events, this
        contains the process instructions (always one token).</p>
    <p class="Pp">This passes <span class="Li">&quot;undef&quot;</span> for
        <span class="Li">&quot;text&quot;</span> events.</p>
  </dd>
  <dt>&quot;text&quot;</dt>
  <dd>Text causes the source text (including markup element delimiters) to be
      passed.</dd>
  <dt>&quot;undef&quot;</dt>
  <dd>Pass an undefined value. Useful as padding where the same handler routine
      is registered for multiple events.</dd>
  <dt>'...'</dt>
  <dd>A literal string of 0 to 255 characters enclosed in single (') or double
      (&quot;) quotes is passed as entered.</dd>
</dl>
<p class="Pp">The whole argspec string can be wrapped up in
    <span class="Li">'@{...}'</span> to signal that the resulting event array
    should be flattened. This only makes a difference if an array reference is
    used as the handler target. Consider this example:</p>
<p class="Pp"></p>
<pre>
   $p-&gt;handler(text =&gt; [], 'text');
   $p-&gt;handler(text =&gt; [], '@{text}']);
</pre>
<p class="Pp">With two text events; <span class="Li">&quot;foo&quot;</span>,
    <span class="Li">&quot;bar&quot;</span>; then the first example will end up
    with [[&quot;foo&quot;], [&quot;bar&quot;]] and the second with
    [&quot;foo&quot;, &quot;bar&quot;] in the handler target array.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Events"><a class="permalink" href="#Events">Events</a></h2>
<p class="Pp">Handlers for the following events can be registered:</p>
<dl class="Bl-tag">
  <dt>&quot;comment&quot;</dt>
  <dd>This event is triggered when a markup comment is recognized.
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>
  &lt;!-- This is a comment -- -- So is this --&gt;
    </pre>
  </dd>
  <dt>&quot;declaration&quot;</dt>
  <dd>This event is triggered when a <i>markup declaration</i> is recognized.
    <p class="Pp">For typical HTML documents, the only declaration you are
        likely to find is &lt;!DOCTYPE ...&gt;.</p>
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>
  &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;
      &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;
    </pre>
    <p class="Pp">DTDs inside &lt;!DOCTYPE ...&gt; will confuse
      HTML::Parser.</p>
  </dd>
  <dt>&quot;default&quot;</dt>
  <dd>This event is triggered for events that do not have a specific handler.
      You can set up a handler for this event to catch stuff you did not want to
      catch explicitly.</dd>
  <dt>&quot;end&quot;</dt>
  <dd>This event is triggered when an end tag is recognized.
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>
  &lt;/A&gt;
    </pre>
  </dd>
  <dt>&quot;end_document&quot;</dt>
  <dd>This event is triggered when <span class="Li">$p</span>-&gt;eof is called
      and after any remaining text is flushed. There is no document text
      associated with this event.</dd>
  <dt>&quot;process&quot;</dt>
  <dd>This event is triggered when a processing instructions markup is
      recognized.
    <p class="Pp">The format and content of processing instructions are system
        and application dependent.</p>
    <p class="Pp">Examples:</p>
    <p class="Pp"></p>
    <pre>
  &lt;? HTML processing instructions &gt;
  &lt;? XML processing instructions ?&gt;
    </pre>
  </dd>
  <dt>&quot;start&quot;</dt>
  <dd>This event is triggered when a start tag is recognized.
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>
  &lt;A HREF=&quot;http://www.perl.com/&quot;&gt;
    </pre>
  </dd>
  <dt>&quot;start_document&quot;</dt>
  <dd>This event is triggered before any other events for a new document. A
      handler for it can be used to initialize stuff. There is no document text
      associated with this event.</dd>
  <dt>&quot;text&quot;</dt>
  <dd>This event is triggered when plain text (characters) is recognized. The
      text may contain multiple lines. A sequence of text may be broken between
      several text events unless <span class="Li">$p</span>-&gt;unbroken_text is
      enabled.
    <p class="Pp">The parser will make sure that it does not break a word or a
        sequence of whitespace between two text events.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Unicode"><a class="permalink" href="#Unicode">Unicode</a></h2>
<p class="Pp"><span class="Li">&quot;HTML::Parser&quot;</span> can parse Unicode
    strings when running under perl-5.8 or better. If Unicode is passed to
    <span class="Li">$p</span>-&gt;<i>parse()</i> then chunks of Unicode will be
    reported to the handlers. The offset and length argspecs will also report
    their position in terms of characters.</p>
<p class="Pp">It is safe to parse raw undecoded UTF-8 if you either avoid
    decoding entities and make sure to not use <i>argspecs</i> that do, or
    enable the <span class="Li">&quot;utf8_mode&quot;</span> for the parser.
    Parsing of undecoded UTF-8 might be useful when parsing from a file where
    you need the reported offsets and lengths to match the byte offsets in the
    file.</p>
<p class="Pp">If a filename is passed to
    <span class="Li">$p</span>-&gt;<i>parse_file()</i> then the file will be
    read in binary mode. This will be fine if the file contains only ASCII or
    Latin-1 characters. If the file contains UTF-8 encoded text then care must
    be taken when decoding entities as described in the previous paragraph, but
    better is to open the file with the UTF-8 layer so that it is decoded
    properly:</p>
<p class="Pp"></p>
<pre>
   open(my $fh, &quot;&lt;:utf8&quot;, &quot;index.html&quot;) || die &quot;...: $!&quot;;
   $p-&gt;parse_file($fh);
</pre>
<p class="Pp">If the file contains text encoded in a charset besides ASCII,
    Latin-1 or UTF-8 then decoding will always be needed.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION_2_COMPATIBILITY"><a class="permalink" href="#VERSION_2_COMPATIBILITY">VERSION
  2 COMPATIBILITY</a></h1>
<p class="Pp">When an <span class="Li">&quot;HTML::Parser&quot;</span> object is
    constructed with no arguments, a set of handlers is automatically provided
    that is compatible with the old HTML::Parser version 2 callback methods.</p>
<p class="Pp">This is equivalent to the following method calls:</p>
<p class="Pp"></p>
<pre>
   $p-&gt;handler(start   =&gt; &quot;start&quot;,   &quot;self, tagname, attr, attrseq, text&quot;);
   $p-&gt;handler(end     =&gt; &quot;end&quot;,     &quot;self, tagname, text&quot;);
   $p-&gt;handler(text    =&gt; &quot;text&quot;,    &quot;self, text, is_cdata&quot;);
   $p-&gt;handler(process =&gt; &quot;process&quot;, &quot;self, token0, text&quot;);
   $p-&gt;handler(comment =&gt;
             sub {
                 my($self, $tokens) = @_;
                 for (@$tokens) {$self-&gt;comment($_);}},
             &quot;self, tokens&quot;);
   $p-&gt;handler(declaration =&gt;
             sub {
                 my $self = shift;
                 $self-&gt;declaration(substr($_[0], 2, -1));},
             &quot;self, text&quot;);
</pre>
<p class="Pp">Setting up these handlers can also be requested with the
    &quot;api_version =&gt; 2&quot; constructor option.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUBCLASSING"><a class="permalink" href="#SUBCLASSING">SUBCLASSING</a></h1>
<p class="Pp">The <span class="Li">&quot;HTML::Parser&quot;</span> class is
    subclassable. Parser objects are plain hashes and
    <span class="Li">&quot;HTML::Parser&quot;</span> reserves only hash keys
    that start with &quot;_hparser&quot;. The parser state can be set up by
    invoking the <i>init()</i> method, which takes the same arguments as
    <i>new()</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">The first simple example shows how you might strip out comments
    from an HTML document. We achieve this by setting up a comment handler that
    does nothing and a default handler that will print out anything else:</p>
<p class="Pp"></p>
<pre>
  use HTML::Parser;
  HTML::Parser-&gt;new(default_h =&gt; [sub { print shift }, 'text'],
                    comment_h =&gt; [&quot;&quot;],
                   )-&gt;parse_file(shift || die) || die $!;
</pre>
<p class="Pp">An alternative implementation is:</p>
<p class="Pp"></p>
<pre>
  use HTML::Parser;
  HTML::Parser-&gt;new(end_document_h =&gt; [sub { print shift },
                                       'skipped_text'],
                    comment_h      =&gt; [&quot;&quot;],
                   )-&gt;parse_file(shift || die) || die $!;
</pre>
<p class="Pp">This will in most cases be much more efficient since only a single
    callback will be made.</p>
<p class="Pp">The next example prints out the text that is inside the
    &lt;title&gt; element of an HTML document. Here we start by setting up a
    start handler. When it sees the title start tag it enables a text handler
    that prints any text found and an end handler that will terminate parsing as
    soon as the title end tag is seen:</p>
<p class="Pp"></p>
<pre>
  use HTML::Parser ();

  sub start_handler
  {
    return if shift ne &quot;title&quot;;
    my $self = shift;
    $self-&gt;handler(text =&gt; sub { print shift }, &quot;dtext&quot;);
    $self-&gt;handler(end  =&gt; sub { shift-&gt;eof if shift eq &quot;title&quot;; },
                           &quot;tagname,self&quot;);
  }

  my $p = HTML::Parser-&gt;new(api_version =&gt; 3);
  $p-&gt;handler( start =&gt; \&amp;start_handler, &quot;tagname,self&quot;);
  $p-&gt;parse_file(shift || die) || die $!;
  print &quot;\n&quot;;
</pre>
<p class="Pp">More examples are found in the <i>eg/</i> directory of the
    <span class="Li">&quot;HTML-Parser&quot;</span> distribution: the program
    <span class="Li">&quot;hrefsub&quot;</span> shows how you can edit all links
    found in a document; the program
    <span class="Li">&quot;htextsub&quot;</span> shows how to edit the text
    only; the program <span class="Li">&quot;hstrip&quot;</span> shows how you
    can strip out certain tags/elements and/or attributes; and the program
    <span class="Li">&quot;htext&quot;</span> show how to obtain the plain text,
    but not any script/style content.</p>
<p class="Pp">You can browse the <i>eg/</i> directory online from the
    <i>[Browse]</i> link on the http://search.cpan.org/~gaas/HTML-Parser/
  page.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">The &lt;style&gt; and &lt;script&gt; sections do not end with the
    first &quot;&lt;/&quot;, but need the complete corresponding end tag. The
    standard behaviour is not really practical.</p>
<p class="Pp">When the <i>strict_comment</i> option is enabled, we still
    recognize comments where there is something other than whitespace between
    even and odd &quot;--&quot; markers.</p>
<p class="Pp">Once <span class="Li">$p</span>-&gt;boolean_attribute_value has
    been set, there is no way to restore the default behaviour.</p>
<p class="Pp">There is currently no way to get both quote characters into the
    same literal argspec.</p>
<p class="Pp">Empty tags, e.g. &quot;&lt;&gt;&quot; and &quot;&lt;/&gt;&quot;,
    are not recognized. SGML allows them to repeat the previous start tag or
    close the previous start tag respectively.</p>
<p class="Pp">NET tags, e.g. &quot;code/.../&quot; are not recognized. This is
    SGML shorthand for &quot;&lt;code&gt;...&lt;/code&gt;&quot;.</p>
<p class="Pp">Unclosed start or end tags, e.g.
    &quot;&lt;tt&lt;b&gt;...&lt;/b&lt;/tt&gt;&quot; are not recognized.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DIAGNOSTICS"><a class="permalink" href="#DIAGNOSTICS">DIAGNOSTICS</a></h1>
<p class="Pp">The following messages may be produced by HTML::Parser. The
    notation in this listing is the same as used in perldiag:</p>
<dl class="Bl-tag">
  <dt id="Not"><a class="permalink" href="#Not">Not a reference to a
    hash</a></dt>
  <dd>(F) The object blessed into or subclassed from HTML::Parser is not a hash
      as required by the HTML::Parser methods.</dd>
  <dt id="Bad"><a class="permalink" href="#Bad">Bad signature in parser state
    object at %p</a></dt>
  <dd>(F) The _hparser_xs_state element does not refer to a valid state
      structure. Something must have changed the internal value stored in this
      hash element, or the memory has been overwritten.</dd>
  <dt>_hparser_xs_state element is not a reference</dt>
  <dd>(F) The _hparser_xs_state element has been destroyed.</dd>
  <dt id="Can't"><a class="permalink" href="#Can't">Can't find
    '_hparser_xs_state' element in HTML::Parser hash</a></dt>
  <dd>(F) The _hparser_xs_state element is missing from the parser hash. It was
      either deleted, or not created when the object was created.</dd>
  <dt id="API"><a class="permalink" href="#API">API version %s not supported by
    HTML::Parser %s</a></dt>
  <dd>(F) The constructor option 'api_version' with an argument greater than or
      equal to 4 is reserved for future extensions.</dd>
  <dt id="Bad~2"><a class="permalink" href="#Bad~2">Bad constructor option
    '%s'</a></dt>
  <dd>(F) An unknown constructor option key was passed to the <i>new()</i> or
      <i>init()</i> methods.</dd>
  <dt id="Parse"><a class="permalink" href="#Parse">Parse loop not
    allowed</a></dt>
  <dd>(F) A handler invoked the <i>parse()</i> or <i>parse_file()</i> method.
      This is not permitted.</dd>
  <dt id="marked"><a class="permalink" href="#marked">marked sections not
    supported</a></dt>
  <dd>(F) The <span class="Li">$p</span>-&gt;<i>marked_sections()</i> method was
      invoked in a HTML::Parser module that was compiled without support for
      marked sections.</dd>
  <dt id="Unknown"><a class="permalink" href="#Unknown">Unknown boolean
    attribute (%d)</a></dt>
  <dd>(F) Something is wrong with the internal logic that set up aliases for
      boolean attributes.</dd>
  <dt id="Only"><a class="permalink" href="#Only">Only code or array references
    allowed as handler</a></dt>
  <dd>(F) The second argument for <span class="Li">$p</span>-&gt;handler must be
      either a subroutine reference, then name of a subroutine or method, or a
      reference to an array.</dd>
  <dt id="No"><a class="permalink" href="#No">No handler for %s events</a></dt>
  <dd>(F) The first argument to <span class="Li">$p</span>-&gt;handler must be a
      valid event name; i.e. one of &quot;start&quot;, &quot;end&quot;,
      &quot;text&quot;, &quot;process&quot;, &quot;declaration&quot; or
      &quot;comment&quot;.</dd>
  <dt id="Unrecognized"><a class="permalink" href="#Unrecognized">Unrecognized
    identifier %s in argspec</a></dt>
  <dd>(F) The identifier is not a known argspec name. Use one of the names
      mentioned in the argspec section above.</dd>
  <dt id="Literal"><a class="permalink" href="#Literal">Literal string is longer
    than 255 chars in argspec</a></dt>
  <dd>(F) The current implementation limits the length of literals in an argspec
      to 255 characters. Make the literal shorter.</dd>
  <dt id="Backslash"><a class="permalink" href="#Backslash">Backslash reserved
    for literal string in argspec</a></dt>
  <dd>(F) The backslash character &quot;\&quot; is not allowed in argspec
      literals. It is reserved to permit quoting inside a literal in a later
      version.</dd>
  <dt id="Unterminated"><a class="permalink" href="#Unterminated">Unterminated
    literal string in argspec</a></dt>
  <dd>(F) The terminating quote character for a literal was not found.</dd>
  <dt id="Bad~3"><a class="permalink" href="#Bad~3">Bad argspec (%s)</a></dt>
  <dd>(F) Only identifier names, literals, spaces and commas are allowed in
      argspecs.</dd>
  <dt id="Missing"><a class="permalink" href="#Missing">Missing comma separator
    in argspec</a></dt>
  <dd>(F) Identifiers in an argspec must be separated with &quot;,&quot;.</dd>
  <dt id="Parsing"><a class="permalink" href="#Parsing">Parsing of undecoded
    UTF-8 will give garbage when decoding entities</a></dt>
  <dd>(W) The first chunk parsed appears to contain undecoded UTF-8 and one or
      more argspecs that decode entities are used for the callback handlers.
    <p class="Pp">The result of decoding will be a mix of encoded and decoded
        characters for any entities that expand to characters with code above
        127. This is not a good thing.</p>
    <p class="Pp">The recommened solution is to apply
        <i>Encode::decode_utf8()</i> on the data before feeding it to the
        <span class="Li">$p</span>-&gt;<i>parse()</i>. For
        <span class="Li">$p</span>-&gt;<i>parse_file()</i> pass a file that has
        been opened in &quot;:utf8&quot; mode.</p>
    <p class="Pp">The alternative solution is to enable the
        <span class="Li">&quot;utf8_mode&quot;</span> and not decode before
        passing strings to <span class="Li">$p</span>-&gt;<i>parse()</i>. The
        parser can process raw undecoded UTF-8 sanely if the
        <span class="Li">&quot;utf8_mode&quot;</span> is enabled, or if the
        &quot;attr&quot;, &quot;@attr&quot; or &quot;dtext&quot; argspecs are
        avoided.</p>
  </dd>
  <dt id="Parsing~2"><a class="permalink" href="#Parsing~2">Parsing string
    decoded with wrong endianness</a></dt>
  <dd>(W) The first character in the document is U+FFFE. This is not a legal
      Unicode character but a byte swapped BOM. The result of parsing will
      likely be garbage.</dd>
  <dt id="Parsing~3"><a class="permalink" href="#Parsing~3">Parsing of undecoded
    UTF-32</a></dt>
  <dd>(W) The parser found the Unicode UTF-32 BOM signature at the start of the
      document. The result of parsing will likely be garbage.</dd>
  <dt id="Parsing~4"><a class="permalink" href="#Parsing~4">Parsing of undecoded
    UTF-16</a></dt>
  <dd>(W) The parser found the Unicode UTF-16 BOM signature at the start of the
      document. The result of parsing will likely be garbage.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">HTML::Entities, HTML::PullParser, HTML::TokeParser,
    HTML::HeadParser, HTML::LinkExtor, HTML::Form</p>
<p class="Pp">HTML::TreeBuilder (part of the <i>HTML-Tree</i> distribution)</p>
<p class="Pp">&lt;http://www.w3.org/TR/html4/&gt;</p>
<p class="Pp">More information about marked sections and processing instructions
    may be found at &lt;http://www.is-thought.co.uk/book/sgml-8.htm&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<pre>
 Copyright 1996-2008 Gisle Aas. All rights reserved.
 Copyright 1999-2000 Michael A. Chase.  All rights reserved.
</pre>
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-05-08</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

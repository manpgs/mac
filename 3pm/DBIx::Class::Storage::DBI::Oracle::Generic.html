<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>DBIx::Class::Storage::DBI::Oracle::Generic(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBIx::Class::Storage::DBI::Oracle::Generic(3)</td>
    <td class="head-vol"><a href=".">User Contributed Perl Documentation</a></td>
    <td class="head-rtitle">DBIx::Class::Storage::DBI::Oracle::Generic(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">DBIx::Class::Storage::DBI::Oracle::Generic - Oracle Support for
    DBIx::Class</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  # In your result (table) classes
  use base 'DBIx::Class::Core';
  __PACKAGE__-&gt;add_columns({ id =&gt; { sequence =&gt; 'mysequence', auto_nextval =&gt; 1 } });
  __PACKAGE__-&gt;set_primary_key('id');
  # Somewhere in your Code
  # add some data to a table with a hierarchical relationship
  $schema-&gt;resultset('Person')-&gt;create ({
        firstname =&gt; 'foo',
        lastname =&gt; 'bar',
        children =&gt; [
            {
                firstname =&gt; 'child1',
                lastname =&gt; 'bar',
                children =&gt; [
                    {
                        firstname =&gt; 'grandchild',
                        lastname =&gt; 'bar',
                    }
                ],
            },
            {
                firstname =&gt; 'child2',
                lastname =&gt; 'bar',
            },
        ],
    });
  # select from the hierarchical relationship
  my $rs = $schema-&gt;resultset('Person')-&gt;search({},
    {
      'start_with' =&gt; { 'firstname' =&gt; 'foo', 'lastname' =&gt; 'bar' },
      'connect_by' =&gt; { 'parentid' =&gt; { '-prior' =&gt; { -ident =&gt; 'personid' } },
      'order_siblings_by' =&gt; { -asc =&gt; 'name' },
    };
  );
  # this will select the whole tree starting from person &quot;foo bar&quot;, creating
  # following query:
  # SELECT
  #     me.persionid me.firstname, me.lastname, me.parentid
  # FROM
  #     person me
  # START WITH
  #     firstname = 'foo' and lastname = 'bar'
  # CONNECT BY
  #     parentid = prior personid
  # ORDER SIBLINGS BY
  #     firstname ASC
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This class implements base Oracle support. The subclass
    DBIx::Class::Storage::DBI::Oracle::WhereJoins is for
    <span class="Li">&quot;(+)&quot;</span> joins in Oracle versions before
  9.0.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="get_autoinc_seq"><a class="permalink" href="#get_autoinc_seq">get_autoinc_seq</a></h2>
<p class="Pp">Returns the sequence name for an autoincrement column</p>
</section>
<section class="Ss">
<h2 class="Ss" id="datetime_parser_type"><a class="permalink" href="#datetime_parser_type">datetime_parser_type</a></h2>
<p class="Pp">This sets the proper DateTime::Format module for use with
    DBIx::Class::InflateColumn::DateTime.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="connect_call_datetime_setup"><a class="permalink" href="#connect_call_datetime_setup">connect_call_datetime_setup</a></h2>
<p class="Pp">Used as:</p>
<p class="Pp"></p>
<pre>    on_connect_call =&gt; 'datetime_setup'
</pre>
<p class="Pp">In connect_info to set the session nls date, and timestamp values
    for use with DBIx::Class::InflateColumn::DateTime and the necessary
    environment variables for DateTime::Format::Oracle, which is used by it.</p>
<p class="Pp">Maximum allowable precision is used, unless the environment
    variables have already been set.</p>
<p class="Pp">These are the defaults used:</p>
<p class="Pp"></p>
<pre>  $ENV{NLS_DATE_FORMAT}         ||= 'YYYY-MM-DD HH24:MI:SS';
  $ENV{NLS_TIMESTAMP_FORMAT}    ||= 'YYYY-MM-DD HH24:MI:SS.FF';
  $ENV{NLS_TIMESTAMP_TZ_FORMAT} ||= 'YYYY-MM-DD HH24:MI:SS.FF TZHTZM';
</pre>
<p class="Pp">To get more than second precision with
    DBIx::Class::InflateColumn::DateTime for your timestamps, use something like
    this:</p>
<p class="Pp"></p>
<pre>  use Time::HiRes 'time';
  my $ts = DateTime-&gt;from_epoch(epoch =&gt; time);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="relname_to_table_alias"><a class="permalink" href="#relname_to_table_alias">relname_to_table_alias</a></h2>
<p class="Pp">DBIx::Class uses DBIx::Class::Relationship names as table aliases
    in queries.</p>
<p class="Pp">Unfortunately, Oracle doesn't support identifiers over 30 chars in
    length, so the DBIx::Class::Relationship name is shortened and appended with
    half of an MD5 hash.</p>
<p class="Pp">See &quot;relname_to_table_alias&quot; in
    DBIx::Class::Storage::DBI.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="with_deferred_fk_checks"><a class="permalink" href="#with_deferred_fk_checks">with_deferred_fk_checks</a></h2>
<p class="Pp">Runs a coderef between:</p>
<p class="Pp"></p>
<pre>  alter session set constraints = deferred
  ...
  alter session set constraints = immediate
</pre>
<p class="Pp">to defer foreign key checks.</p>
<p class="Pp">Constraints must be declared
    <span class="Li">&quot;DEFERRABLE&quot;</span> for this to work.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ATTRIBUTES"><a class="permalink" href="#ATTRIBUTES">ATTRIBUTES</a></h1>
<p class="Pp">Following additional attributes can be used in resultsets.</p>
<section class="Ss">
<h2 class="Ss" id="connect_by_or_connect_by_nocycle"><a class="permalink" href="#connect_by_or_connect_by_nocycle">connect_by
  or connect_by_nocycle</a></h2>
<dl class="Bl-tag">
  <dt id="Value:"><a class="permalink" href="#Value:">Value:
    \%connect_by</a></dt>
  <dd></dd>
</dl>
<p class="Pp">A hashref of conditions used to specify the relationship between
    parent rows and child rows of the hierarchy.</p>
<p class="Pp"></p>
<pre>  connect_by =&gt; { parentid =&gt; 'prior personid' }
  # adds a connect by statement to the query:
  # SELECT
  #     me.persionid me.firstname, me.lastname, me.parentid
  # FROM
  #     person me
  # CONNECT BY
  #     parentid = prior persionid
  connect_by_nocycle =&gt; { parentid =&gt; 'prior personid' }
  # adds a connect by statement to the query:
  # SELECT
  #     me.persionid me.firstname, me.lastname, me.parentid
  # FROM
  #     person me
  # CONNECT BY NOCYCLE
  #     parentid = prior persionid
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="start_with"><a class="permalink" href="#start_with">start_with</a></h2>
<dl class="Bl-tag">
  <dt id="Value:~2"><a class="permalink" href="#Value:~2">Value:
    \%condition</a></dt>
  <dd></dd>
</dl>
<p class="Pp">A hashref of conditions which specify the root row(s) of the
    hierarchy.</p>
<p class="Pp">It uses the same syntax as &quot;search&quot; in
    DBIx::Class::ResultSet</p>
<p class="Pp"></p>
<pre>  start_with =&gt; { firstname =&gt; 'Foo', lastname =&gt; 'Bar' }
  # SELECT
  #     me.persionid me.firstname, me.lastname, me.parentid
  # FROM
  #     person me
  # START WITH
  #     firstname = 'foo' and lastname = 'bar'
  # CONNECT BY
  #     parentid = prior persionid
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="order_siblings_by"><a class="permalink" href="#order_siblings_by">order_siblings_by</a></h2>
<dl class="Bl-tag">
  <dt id="Value:~3"><a class="permalink" href="#Value:~3">Value:
    ($order_siblings_by | \@order_siblings_by)</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Which column(s) to order the siblings by.</p>
<p class="Pp">It uses the same syntax as &quot;order_by&quot; in
    DBIx::Class::ResultSet</p>
<p class="Pp"></p>
<pre>  'order_siblings_by' =&gt; 'firstname ASC'
  # SELECT
  #     me.persionid me.firstname, me.lastname, me.parentid
  # FROM
  #     person me
  # CONNECT BY
  #     parentid = prior persionid
  # ORDER SIBLINGS BY
  #     firstname ASC
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="FURTHER_QUESTIONS?"><a class="permalink" href="#FURTHER_QUESTIONS?">FURTHER
  QUESTIONS?</a></h1>
<p class="Pp">Check the list of additional DBIC resources.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This module is free software copyright by the DBIx::Class (DBIC)
    authors. You can redistribute it and/or modify it under the same terms as
    the DBIx::Class library.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-01-29</td>
    <td class="foot-os"><a href="..">perl v5.34.0</a></td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Test2::Manual::Anatomy::Event(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Test2::Manual::Anatomy::Event(3)</td>
    <td class="head-vol"><a href=".">User Contributed Perl Documentation</a></td>
    <td class="head-rtitle">Test2::Manual::Anatomy::Event(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Test2::Manual::Anatomy::Event - The internals of events</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Events are how tools effect global state, and pass information
    along to the harness, or the human running the tests.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
<p class="Pp">Before proceeding it is important that you know some history of
    events. Initially there was an event API, and an event would implement the
    API to produce an effect. This API proved to be lossy and inflexible.
    Recently the 'facet' system was introduced, and makes up for the shortcoming
    and inflexibility of the old API.</p>
<p class="Pp">All events must still implement the old API, but that can be
    largely automated if you use the facet system effectively. Likewise
    essential facets can often be deduced from events that only implement the
    old API, though their information maybe less complete.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="THE_EVENT_OBJECT"><a class="permalink" href="#THE_EVENT_OBJECT">THE
  EVENT OBJECT</a></h1>
<p class="Pp">All event objects must subclass Test2::Event. If you inherit from
    this base class, and implement the old API properly, facets will be
    generated for you for free. On the other hand you can inherit from this, and
    also import Test2::Util::Facets2Legacy which will instead rely on your facet
    data, and deduce the old API from them.</p>
<p class="Pp">All new events <span class="Li">&quot;MUST&quot;</span> implement
    both APIs one way or the other. A common way to do this is to simply
    implement both APIs directly in your event.</p>
<p class="Pp">Here is a good template for a new event:</p>
<p class="Pp"></p>
<pre>    package Test2::Event::Mine;
    use strict;
    use warnings;
    use parent 'Test2::Event';
    use Test2::Util::Facets2Legacy ':ALL';
    sub facet_data {
        my $self = shift;
        # Adds 'about', 'amnesty', and 'trace' facets
        my $out = $self-&gt;common_facet_data;
        # Add any additional facets to the $out hashref
        ...
        return $out;
    }
    1;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="THE_FACET_API"><a class="permalink" href="#THE_FACET_API">THE
  FACET API</a></h1>
<p class="Pp">The new API is a single method:
    <span class="Li">&quot;facet_data()&quot;</span>. This method must return a
    hashref where each key is specific to a facet type, and the value is either
    a facet hashref, or an array of hashrefs. Some facets
    <span class="Li">&quot;MUST&quot;</span> be lone hashrefs, others
    <span class="Li">&quot;MUST&quot;</span> be hashrefs inside an arrayref.</p>
<p class="Pp">The <i>standard</i> facet types are as follows:</p>
<dl class="Bl-tag">
  <dt id="assert"><a class="permalink" href="#assert">assert =&gt; {details
    =&gt; $name, pass =&gt; $bool, no_debug =&gt; $bool, number =&gt;
    $maybe_int}</a></dt>
  <dd>Documented in Test2::EventFacet::Assert. An event may only have one.
    <p class="Pp">The 'details' key is the name of the assertion.</p>
    <p class="Pp">The 'pass' key denotes a passing or failing assertion.</p>
    <p class="Pp">The 'no_debug' key tells any harness or formatter that
        diagnostics should not be added automatically to a failing assertion
        (used when there are custom diagnostics instead).</p>
    <p class="Pp">The 'number' key is for harness use, never set it
      yourself.</p>
  </dd>
  <dt id="about"><a class="permalink" href="#about">about =&gt; {details =&gt;
    $string, no_display =&gt; $bool, package =&gt; $pkg}</a></dt>
  <dd>Documented in Test2::EventFacet::About. An event may only have one.
    <p class="Pp">'details' is a human readable string describing the overall
        event.</p>
    <p class="Pp">'no_display' means that a formatter/harness should hide the
        event.</p>
    <p class="Pp">'package' is the package of the event the facet describes (IE:
        Test2::Event::Ok)</p>
  </dd>
  <dt id="amnesty"><a class="permalink" href="#amnesty">amnesty =&gt; [{details
    =&gt; $string, tag =&gt; $short_string, inherited =&gt; $bool}]</a></dt>
  <dd>Documented in Test2::EventFacet::Amnesty. An event may have multiple.
    <p class="Pp">This event is how things like 'todo' are implemented. Amnesty
        prevents a failing assertion from causing a global test failure.</p>
    <p class="Pp">'details' is a human readable description of why the failure
        is being granted amnesty (IE The 'todo' reason)</p>
    <p class="Pp">'tag' is a short human readable string, or category for the
        amnesty. This is typically 'TODO' or 'SKIP'.</p>
    <p class="Pp">'inherited' is true if the amnesty was applied in a parent
        context (true if this test is run in a subtest that is marked todo).</p>
  </dd>
  <dt id="control"><a class="permalink" href="#control">control =&gt; {details
    =&gt; $string, global =&gt; $bool, terminate =&gt; $maybe_int, halt =&gt;
    $bool, has_callback =&gt; $bool, encoding =&gt; $enc}</a></dt>
  <dd>Documented in Test2::EventFacet::Control. An event may have one.
    <p class="Pp">This facet is used to apply extra behavior when the event is
        processed.</p>
    <p class="Pp">'details' is a human readable explanation for the
      behavior.</p>
    <p class="Pp">'global' true if this event should be forwarded to, and
        processed by, all hubs everywhere. (bail-out uses this)</p>
    <p class="Pp">'terminate' this should either be undef, or an integer. When
        defined this will cause the test to exit with the specific exit
      code.</p>
    <p class="Pp">'halt' is used to signal any harness that no further test
        files should be run (bail-out uses this).</p>
    <p class="Pp">'has_callback' is set to true if the event has a callback sub
        defined.</p>
    <p class="Pp">'encoding' used to tell the formatter what encoding to
      use.</p>
  </dd>
  <dt id="errors"><a class="permalink" href="#errors">errors =&gt; [{details
    =&gt; $string, tag =&gt; $short_string, fail =&gt; $bool}]</a></dt>
  <dd>Documented in Test2::EventFacet::Error. An event may have multiple.
    <p class="Pp">'details' is a human readable explanation of the error.</p>
    <p class="Pp">'tag' is a short human readable category for the error.</p>
    <p class="Pp">'fail' is true if the error should cause test failure. If this
        is false the error is simply informative, but not fatal.</p>
  </dd>
  <dt id="info"><a class="permalink" href="#info">info =&gt; [{details =&gt;
    $string, tag =&gt; $short_string, debug =&gt; $bool, important =&gt;
    $bool}]</a></dt>
  <dd>Documented in Test2::EventFacet::Info. An event may have multiple.
    <p class="Pp">This is how diag and note are implemented.</p>
    <p class="Pp">'details' human readable message.</p>
    <p class="Pp">'tag' short category for the message, such as 'diag' or
        'note'.</p>
    <p class="Pp">'debug' is true if the message is diagnostics in nature, this
        is the main difference between a note and a diag.</p>
    <p class="Pp">'important' is true if the message is not diagnostics, but is
        important to have it shown anyway. This is primarily used to communicate
        with a harness.</p>
  </dd>
  <dt id="parent"><a class="permalink" href="#parent">parent =&gt; {details
    =&gt; $string, hid =&gt; $hid, children =&gt; [...], buffered =&gt;
    1}</a></dt>
  <dd>Documented in Test2::EventFacet::Parent. An event may have one.
    <p class="Pp">This is used by subtests.</p>
    <p class="Pp">'details' human readable name of the subtest.</p>
    <p class="Pp">'hid' subtest hub id.</p>
    <p class="Pp">'children' an arrayref containing facet_data instances from
        all child events.</p>
    <p class="Pp">'buffered' true if it was a buffered subtest.</p>
  </dd>
  <dt id="plan"><a class="permalink" href="#plan">plan =&gt; {details =&gt;
    $string, count =&gt; $int, skip =&gt; $bool, none =&gt; $bool}</a></dt>
  <dd>Documented in Test2::EventFacet::Plan. An event may have one.
    <p class="Pp">'details' is a human readable string describing the plan (for
        instance, why a test is skipped)</p>
    <p class="Pp">'count' is the number of expected assertions (0 for skip)</p>
    <p class="Pp">'skip' is true if the plan is to skip the test.</p>
    <p class="Pp">'none' used for Test::More's 'no_plan' plan.</p>
  </dd>
  <dt id="trace"><a class="permalink" href="#trace">trace =&gt; {details =&gt;
    $string, frame =&gt; [$pkg, $file, $line, $sub], pid =&gt; $int, tid =&gt;
    $int, cid =&gt; $cid, hid =&gt; $hid, nested =&gt; $int, buffered =&gt;
    $bool}</a></dt>
  <dd>Documented in Test2::EventFacet::Trace. An event may have one.
    <p class="Pp">This is how debugging information is tracked. This is taken
        from the context object at event creation.</p>
    <p class="Pp">'details' human readable debug message (otherwise generated
        from frame)</p>
    <p class="Pp">'frame' first 4 fields returned by caller:
        <span class="Li">&quot;[$package, $file, $line,
      $subname]&quot;</span>.</p>
    <p class="Pp">'pid' the process id in which the event was created.</p>
    <p class="Pp">'tid' the thread is in which the event was created.</p>
    <p class="Pp">'cid' the id of the context used to create the event.</p>
    <p class="Pp">'hid' the id of the hub to which the event was sent.</p>
    <p class="Pp">'nest' subtest nesting depth of the event.</p>
    <p class="Pp">'buffered' is true if the event was generated inside a
        buffered subtest.</p>
  </dd>
</dl>
<p class="Pp">Note that ALL facet types have a 'details' key that may have a
    string. This string should always be human readable, and should be an
    explanation for the facet. For an assertion this is the test name. For a
    plan this is the reason for the plan (such as skip reason). For info it is
    the human readable diagnostics message.</p>
<section class="Ss">
<h2 class="Ss">CUSTOM FACETS</h2>
<p class="Pp">You can write custom facet types as well, simply add a new key to
    the hash and populated it. The general rule is that any code looking at the
    facets should ignore any it does not understand.</p>
<p class="Pp">Optionally you can also create a package to document your custom
    facet. The package should be proper object, and may have additional methods
    to help work with your facet.</p>
<p class="Pp"></p>
<pre>    package Test2::EventFacet::MyFacet;
    use parent 'Test2::EventFacet';
    sub facet_key { 'myfacet' }
    sub is_list { 0 }
    1;
</pre>
<p class="Pp">Your facet package should always be under the Test2::EventFacet::
    namespace if you want any tools to automatically find it. The last part of
    the namespace should be the non-plural name of your facet with only the
    first word capitalized.</p>
<dl class="Bl-tag">
  <dt>$string = $facet_class-&gt;facet_key</dt>
  <dd>The key for your facet should be the same as the last section of the
      namespace, but all lowercase. You <i>may</i> append 's' to the key if your
      facet is a list type.</dd>
  <dt>$bool = $facet_class-&gt;is_list</dt>
  <dd>True if an event should put these facets in a list:
    <p class="Pp"></p>
    <pre>    { myfacet =&gt; [{}, {}] }
    </pre>
    <p class="Pp">False if an event may only have one of this type of facet at a
        time:</p>
    <p class="Pp"></p>
    <pre>    { myfacet =&gt; {} }
    </pre>
  </dd>
</dl>
<p class="Pp"><i>EXAMPLES</i></p>
<p class="Pp">The assert facet is not a list type, so its implementation would
    look like this:</p>
<p class="Pp"></p>
<pre>    package Test2::EventFacet::Assert;
    sub facet_key { 'assert' }
    sub is_list { 0 }
</pre>
<p class="Pp">The amnesty facet is a list type, but amnesty does not need 's'
    appended to make it plural:</p>
<p class="Pp"></p>
<pre>    package Test2::EventFacet::Amnesty;
    sub facet_key { 'amnesty' }
    sub is_list { 1 }
</pre>
<p class="Pp">The error facet is a list type, and appending 's' makes error
    plural as errors. This means the package name is '::Error', but the key is
    'errors'.</p>
<p class="Pp"></p>
<pre>    package Test2::EventFacet::Error;
    sub facet_key { 'errors' }
    sub is_list { 1 }
</pre>
<p class="Pp"><b>Note</b> Do not worry too much about getting the
    key/pluralization wrong. Most tools will use Module::Pluggable to load all
    facet types and build a hash linking keys to packages and so on, working
    backwards. This means, in general, that even if you get it wrong any tool
    that NEEDS the package for the facet will find it.</p>
<p class="Pp"><b>Note2:</b> In practice most tools completely ignore the facet
    packages, and work with the facet data directly in its raw structure. This
    is by design and recommended. The facet data is intended to be serialized
    frequently and passed around. When facets are concerned, data is important,
    classes and methods are not.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="THE_OLD_API"><a class="permalink" href="#THE_OLD_API">THE OLD
  API</a></h1>
<p class="Pp">The old API was simply a set of methods you were required to
    implement:</p>
<dl class="Bl-tag">
  <dt>$bool = $e-&gt;causes_fail</dt>
  <dd>Returns true if this event should result in a test failure. In general
      this should be false.</dd>
  <dt>$bool = $e-&gt;increments_count</dt>
  <dd>Should be true if this event should result in a test count increment.</dd>
  <dt>$e-&gt;callback($hub)</dt>
  <dd>If your event needs to have extra effects on the Test2::Hub you can
      override this method.
    <p class="Pp">This is called <b>BEFORE</b> your event is passed to the
        formatter.</p>
  </dd>
  <dt>$num = $e-&gt;nested</dt>
  <dd>If this event is nested inside of other events, this should be the depth
      of nesting. (This is mainly for subtests)</dd>
  <dt>$bool = $e-&gt;global</dt>
  <dd>Set this to true if your event is global, that is ALL threads and
      processes should see it no matter when or where it is generated. This is
      not a common thing to want, it is used by bail-out and skip_all to end
      testing.</dd>
  <dt>$code = $e-&gt;terminate</dt>
  <dd>This is called <b>AFTER</b> your event has been passed to the formatter.
      This should normally return undef, only change this if your event should
      cause the test to exit immediately.
    <p class="Pp">If you want this event to cause the test to exit you should
        return the exit code here. Exit code of 0 means exit success, any other
        integer means exit with failure.</p>
    <p class="Pp">This is used by Test2::Event::Plan to exit 0 when the plan is
        'skip_all'. This is also used by Test2::Event:Bail to force the test to
        exit with a failure.</p>
    <p class="Pp">This is called after the event has been sent to the formatter
        in order to ensure the event is seen and understood.</p>
  </dd>
  <dt>$msg = $e-&gt;summary</dt>
  <dd>This is intended to be a human readable summary of the event. This should
      ideally only be one line long, but you can use multiple lines if
      necessary. This is intended for human consumption. You do not need to make
      it easy for machines to understand.
    <p class="Pp">The default is to simply return the event package name.</p>
  </dd>
  <dt>($count, $directive, $reason) = $e-&gt;<b>sets_plan()</b></dt>
  <dd>Check if this event sets the testing plan. It will return an empty list if
      it does not. If it does set the plan it will return a list of 1 to 3 items
      in order: Expected Test Count, Test Directive, Reason for directive.</dd>
  <dt>$bool = $e-&gt;diagnostics</dt>
  <dd>True if the event contains diagnostics info. This is useful because a
      non-verbose harness may choose to hide events that are not in this
      category. Some formatters may choose to send these to STDERR instead of
      STDOUT to ensure they are seen.</dd>
  <dt>$bool = $e-&gt;no_display</dt>
  <dd>False by default. This will return true on events that should not be
      displayed by formatters.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Test2::Manual - Primary index of the manual.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SOURCE"><a class="permalink" href="#SOURCE">SOURCE</a></h1>
<p class="Pp">The source code repository for Test2-Manual can be found at
    <i>https://github.com/Test-More/Test2-Suite/</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MAINTAINERS"><a class="permalink" href="#MAINTAINERS">MAINTAINERS</a></h1>
<dl class="Bl-tag">
  <dt id="Chad"><a class="permalink" href="#Chad">Chad Granum
    &lt;exodist@cpan.org&gt;</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<dl class="Bl-tag">
  <dt id="Chad~2"><a class="permalink" href="#Chad~2">Chad Granum
    &lt;exodist@cpan.org&gt;</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 2018 Chad Granum &lt;exodist@cpan.org&gt;.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">See <i>http://dev.perl.org/licenses/</i></p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-10-22</td>
    <td class="foot-os"><a href="..">perl v5.34.0</a></td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Regexp::Common(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Regexp::Common(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Regexp::Common(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Regexp::Common - Provide commonly requested regular
  expressions</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
 # STANDARD USAGE 

 use Regexp::Common;

 while (&lt;&gt;) {
     /$RE{num}{real}/               and print q{a number};
     /$RE{quoted}/                  and print q{a ['&quot;`] quoted string};
     /$RE{delimited}{-delim=&gt;'/'}/  and print q{a /.../ sequence};
     /$RE{balanced}{-parens=&gt;'()'}/ and print q{balanced parentheses};
     /$RE{profanity}/               and print q{a #*@%-ing word};
 }


 # SUBROUTINE-BASED INTERFACE

 use Regexp::Common 'RE_ALL';

 while (&lt;&gt;) {
     $_ =~ RE_num_real()              and print q{a number};
     $_ =~ RE_quoted()                and print q{a ['&quot;`] quoted string};
     $_ =~ RE_delimited(-delim=&gt;'/')  and print q{a /.../ sequence};
     $_ =~ RE_balanced(-parens=&gt;'()'} and print q{balanced parentheses};
     $_ =~ RE_profanity()             and print q{a #*@%-ing word};
 }


 # IN-LINE MATCHING...

 if ( $RE{num}{int}-&gt;matches($text) ) {...}


 # ...AND SUBSTITUTION

 my $cropped = $RE{ws}{crop}-&gt;subs($uncropped);


 # ROLL-YOUR-OWN PATTERNS

 use Regexp::Common 'pattern';

 pattern name   =&gt; ['name', 'mine'],
         create =&gt; '(?i:J[.]?\s+A[.]?\s+Perl-Hacker)',
         ;

 my $name_matcher = $RE{name}{mine};

 pattern name    =&gt; [ 'lineof', '-char=_' ],
         create  =&gt; sub {
                        my $flags = shift;
                        my $char = quotemeta $flags-&gt;{-char};
                        return '(?:^$char+$)';
                    },
         match   =&gt; sub {
                        my ($self, $str) = @_;
                        return $str !~ /[^$self-&gt;{flags}{-char}]/;
                    },
         subs   =&gt; sub {
                        my ($self, $str, $replacement) = @_;
                        $_[1] =~ s/^$self-&gt;{flags}{-char}+$//g;
                   },
         ;

 my $asterisks = $RE{lineof}{-char=&gt;'*'};

 # DECIDING WHICH PATTERNS TO LOAD.

 use Regexp::Common qw /comment number/;  # Comment and number patterns.
 use Regexp::Common qw /no_defaults/;     # Don't load any patterns.
 use Regexp::Common qw /!delimited/;      # All, but delimited patterns.
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">By default, this module exports a single hash
    (<span class="Li">%RE</span>) that stores or generates commonly needed
    regular expressions (see &quot;List of available patterns&quot;).</p>
<p class="Pp">There is an alternative, subroutine-based syntax described in
    &quot;Subroutine-based interface&quot;.</p>
<section class="Ss">
<h2 class="Ss" id="General_syntax_for_requesting_patterns"><a class="permalink" href="#General_syntax_for_requesting_patterns">General
  syntax for requesting patterns</a></h2>
<p class="Pp">To access a particular pattern, <span class="Li">%RE</span> is
    treated as a hierarchical hash of hashes (of hashes...), with each
    successive key being an identifier. For example, to access the pattern that
    matches real numbers, you specify:</p>
<p class="Pp"></p>
<pre>
        $RE{num}{real}
</pre>
<p class="Pp">and to access the pattern that matches integers:</p>
<p class="Pp"></p>
<pre>
        $RE{num}{int}
</pre>
<p class="Pp">Deeper layers of the hash are used to specify <i>flags</i>:
    arguments that modify the resulting pattern in some way. The keys used to
    access these layers are prefixed with a minus sign and may have a value; if
    a value is given, it's done by using a multidimensional key. For example, to
    access the pattern that matches base-2 real numbers with embedded commas
    separating groups of three digits (e.g. 10,101,110.110101101):</p>
<p class="Pp"></p>
<pre>
        $RE{num}{real}{-base =&gt; 2}{-sep =&gt; ','}{-group =&gt; 3}
</pre>
<p class="Pp">Through the magic of Perl, these flag layers may be specified in
    any order (and even interspersed through the identifier keys!) so you could
    get the same pattern with:</p>
<p class="Pp"></p>
<pre>
        $RE{num}{real}{-sep =&gt; ','}{-group =&gt; 3}{-base =&gt; 2}
</pre>
<p class="Pp">or:</p>
<p class="Pp"></p>
<pre>
        $RE{num}{-base =&gt; 2}{real}{-group =&gt; 3}{-sep =&gt; ','}
</pre>
<p class="Pp">or even:</p>
<p class="Pp"></p>
<pre>
        $RE{-base =&gt; 2}{-group =&gt; 3}{-sep =&gt; ','}{num}{real}
</pre>
<p class="Pp">etc.</p>
<p class="Pp">Note, however, that the relative order of amongst the identifier
    keys <i>is</i> significant. That is:</p>
<p class="Pp"></p>
<pre>
        $RE{list}{set}
</pre>
<p class="Pp">would not be the same as:</p>
<p class="Pp"></p>
<pre>
        $RE{set}{list}
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Flag_syntax"><a class="permalink" href="#Flag_syntax">Flag
  syntax</a></h2>
<p class="Pp">In versions prior to 2.113, flags could also be written as
    <span class="Li">&quot;{&quot;-flag=value&quot;}&quot;</span>. This no
    longer works, although
    <span class="Li">&quot;{&quot;-flag$;value&quot;}&quot;</span> still does.
    However, <span class="Li">&quot;{-flag =&gt; 'value'}&quot;</span> is the
    preferred syntax.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Universal_flags"><a class="permalink" href="#Universal_flags">Universal
  flags</a></h2>
<p class="Pp">Normally, flags are specific to a single pattern. However, there
    is two flags that all patterns may specify.</p>
<dl class="Bl-tag">
  <dt>&quot;-keep&quot;</dt>
  <dd>By default, the patterns provided by <span class="Li">%RE</span> contain
      no capturing parentheses. However, if the
      <span class="Li">&quot;-keep&quot;</span> flag is specified (it requires
      no value) then any significant substrings that the pattern matches are
      captured. For example:
    <p class="Pp"></p>
    <pre>
        if ($str =~ $RE{num}{real}{-keep}) {
                $number   = $1;
                $whole    = $3;
                $decimals = $5;
        }
    </pre>
    <p class="Pp">Special care is needed if a &quot;kept&quot; pattern is
        interpolated into a larger regular expression, as the presence of other
        capturing parentheses is likely to change the &quot;number
        variables&quot; into which significant substrings are saved.</p>
    <p class="Pp">See also &quot;Adding new regular expressions&quot;, which
        describes how to create new patterns with &quot;optional&quot; capturing
        brackets that respond to <span class="Li">&quot;-keep&quot;</span>.</p>
  </dd>
  <dt>&quot;-i&quot;</dt>
  <dd>Some patterns or subpatterns only match lowercase or uppercase letters. If
      one wants the do case insensitive matching, one option is to use the
      <span class="Li">&quot;/i&quot;</span> regexp modifier, or the special
      sequence <span class="Li">&quot;(?i)&quot;</span>. But if the functional
      interface is used, one does not have this option. The
      <span class="Li">&quot;-i&quot;</span> switch solves this problem; by
      using it, the pattern will do case insensitive matching.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">OO interface and inline matching/substitution</h2>
<p class="Pp">The patterns returned from <span class="Li">%RE</span> are
    objects, so rather than writing:</p>
<p class="Pp"></p>
<pre>
        if ($str =~ /$RE{some}{pattern}/ ) {...}
</pre>
<p class="Pp">you can write:</p>
<p class="Pp"></p>
<pre>
        if ( $RE{some}{pattern}-&gt;matches($str) ) {...}
</pre>
<p class="Pp">For matching this would seem to have no great advantage apart from
    readability (but see below).</p>
<p class="Pp">For substitutions, it has other significant benefits. Frequently
    you want to perform a substitution on a string without changing the
    original. Most people use this:</p>
<p class="Pp"></p>
<pre>
        $changed = $original;
        $changed =~ s/$RE{some}{pattern}/$replacement/;
</pre>
<p class="Pp">The more adept use:</p>
<p class="Pp"></p>
<pre>
        ($changed = $original) =~ s/$RE{some}{pattern}/$replacement/;
</pre>
<p class="Pp">Regexp::Common allows you do write this:</p>
<p class="Pp"></p>
<pre>
        $changed = $RE{some}{pattern}-&gt;subs($original=&gt;$replacement);
</pre>
<p class="Pp">Apart from reducing precedence-angst, this approach has the added
    advantages that the substitution behaviour can be optimized from the regular
    expression, and the replacement string can be provided by default (see
    &quot;Adding new regular expressions&quot;).</p>
<p class="Pp">For example, in the implementation of this substitution:</p>
<p class="Pp"></p>
<pre>
        $cropped = $RE{ws}{crop}-&gt;subs($uncropped);
</pre>
<p class="Pp">the default empty string is provided automatically, and the
    substitution is optimized to use:</p>
<p class="Pp"></p>
<pre>
        $uncropped =~ s/^\s+//;
        $uncropped =~ s/\s+$//;
</pre>
<p class="Pp">rather than:</p>
<p class="Pp"></p>
<pre>
        $uncropped =~ s/^\s+|\s+$//g;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Subroutine-based_interface"><a class="permalink" href="#Subroutine-based_interface">Subroutine-based
  interface</a></h2>
<p class="Pp">The hash-based interface was chosen because it allows regexes to
    be effortlessly interpolated, and because it also allows them to be
    &quot;curried&quot;. For example:</p>
<p class="Pp"></p>
<pre>
        my $num = $RE{num}{int};

        my $commad     = $num-&gt;{-sep=&gt;','}{-group=&gt;3};
        my $duodecimal = $num-&gt;{-base=&gt;12};
</pre>
<p class="Pp">However, the use of tied hashes does make the access to
    Regexp::Common patterns slower than it might otherwise be. In contexts where
    impatience overrules laziness, Regexp::Common provides an additional
    subroutine-based interface.</p>
<p class="Pp">For each (sub-)entry in the <span class="Li">%RE</span> hash
    (<span class="Li">$RE{key1}{key2}{etc}</span>), there is a corresponding
    exportable subroutine:
    <span class="Li">&quot;RE_key1_key2_etc()&quot;</span>. The name of each
    subroutine is the underscore-separated concatenation of the <i>non-flag</i>
    keys that locate the same pattern in <span class="Li">%RE</span>. Flags are
    passed to the subroutine in its argument list. Thus:</p>
<p class="Pp"></p>
<pre>
        use Regexp::Common qw( RE_ws_crop RE_num_real RE_profanity );

        $str =~ RE_ws_crop() and die &quot;Surrounded by whitespace&quot;;

        $str =~ RE_num_real(-base=&gt;8, -sep=&gt;&quot; &quot;) or next;

        $offensive = RE_profanity(-keep);
        $str =~ s/$offensive/$bad{$1}++; &quot;&lt;expletive deleted&gt;&quot;/ge;
</pre>
<p class="Pp">Note that, unlike the hash-based interface (which returns
    objects), these subroutines return ordinary
    <span class="Li">&quot;qr&quot;</span>'d regular expressions. Hence they do
    not curry, nor do they provide the OO match and substitution inlining
    described in the previous section.</p>
<p class="Pp">It is also possible to export subroutines for all available
    patterns like so:</p>
<p class="Pp"></p>
<pre>
        use Regexp::Common 'RE_ALL';
</pre>
<p class="Pp">Or you can export all subroutines with a common prefix of keys
    like so:</p>
<p class="Pp"></p>
<pre>
        use Regexp::Common 'RE_num_ALL';
</pre>
<p class="Pp">which will export <span class="Li">&quot;RE_num_int&quot;</span>
    and <span class="Li">&quot;RE_num_real&quot;</span> (and if you have create
    more patterns who have first key <i>num</i>, those will be exported as
    well). In general, <i>RE_key1_..._keyn_ALL</i> will export all subroutines
    whose pattern names have first keys <i>key1</i> ... <i>keyn</i>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Adding_new_regular_expressions"><a class="permalink" href="#Adding_new_regular_expressions">Adding
  new regular expressions</a></h2>
<p class="Pp">You can add your own regular expressions to the
    <span class="Li">%RE</span> hash at run-time, using the exportable
    <span class="Li">&quot;pattern&quot;</span> subroutine. It expects a
    hash-like list of key/value pairs that specify the behaviour of the pattern.
    The various possible argument pairs are:</p>
<dl class="Bl-tag">
  <dt>&quot;name =&gt; [ @list ]&quot;</dt>
  <dd>A required argument that specifies the name of the pattern, and any flags
      it may take, via a reference to a list of strings. For example:
    <p class="Pp"></p>
    <pre>
         pattern name =&gt; [qw( line of -char )],
                 # other args here
                 ;
    </pre>
    <p class="Pp">This specifies an entry <span class="Li">$RE{line}{of}</span>,
        which may take a <span class="Li">&quot;-char&quot;</span> flag.</p>
    <p class="Pp">Flags may also be specified with a default value, which is
        then used whenever the flag is specified without an explicit value (but
        not when the flag is omitted). For example:</p>
    <p class="Pp"></p>
    <pre>
         pattern name =&gt; [qw( line of -char=_ )],
                 # default char is '_'
                 # other args here
                 ;
    </pre>
  </dd>
  <dt>&quot;create =&gt; $sub_ref_or_string&quot;</dt>
  <dd>A required argument that specifies either a string that is to be returned
      as the pattern:
    <p class="Pp"></p>
    <pre>
        pattern name    =&gt; [qw( line of underscores )],
                create  =&gt; q/(?:^_+$)/
                ;
    </pre>
    <p class="Pp">or a reference to a subroutine that will be called to create
        the pattern:</p>
    <p class="Pp"></p>
    <pre>
        pattern name    =&gt; [qw( line of -char=_ )],
                create  =&gt; sub {
                                my ($self, $flags) = @_;
                                my $char = quotemeta $flags-&gt;{-char};
                                return '(?:^$char+$)';
                            },
                ;
    </pre>
    <p class="Pp">If the subroutine version is used, the subroutine will be
        called with three arguments: a reference to the pattern object itself, a
        reference to a hash containing the flags and their values, and a
        reference to an array containing the non-flag keys.</p>
    <p class="Pp">Whatever the subroutine returns is stringified as the
      pattern.</p>
    <p class="Pp">No matter how the pattern is created, it is immediately
        postprocessed to include or exclude capturing parentheses (according to
        the value of the <span class="Li">&quot;-keep&quot;</span> flag). To
        specify such &quot;optional&quot; capturing parentheses within the
        regular expression associated with
        <span class="Li">&quot;create&quot;</span>, use the notation
        <span class="Li">&quot;(?k:...)&quot;</span>. Any parentheses of this
        type will be converted to <span class="Li">&quot;(...)&quot;</span> when
        the <span class="Li">&quot;-keep&quot;</span> flag is specified, or
        <span class="Li">&quot;(?:...)&quot;</span> when it is not. It is a
        Regexp::Common convention that the outermost capturing parentheses
        always capture the entire pattern, but this is not enforced.</p>
  </dd>
  <dt>&quot;match =&gt; $sub_ref&quot;</dt>
  <dd>An optional argument that specifies a subroutine that is to be called when
      the <span class="Li">&quot;$RE{...}-&gt;matches(...)&quot;</span> method
      of this pattern is invoked.
    <p class="Pp">The subroutine should expect two arguments: a reference to the
        pattern object itself, and the string to be matched against.</p>
    <p class="Pp">It should return the same types of values as a
        <span class="Li">&quot;m/.../&quot;</span> does.</p>
    <p class="Pp"></p>
    <pre>
     pattern name    =&gt; [qw( line of -char )],
             create  =&gt; sub {...},
             match   =&gt; sub {
                             my ($self, $str) = @_;
                             $str !~ /[^$self-&gt;{flags}{-char}]/;
                        },
             ;
    </pre>
  </dd>
  <dt>&quot;subs =&gt; $sub_ref&quot;</dt>
  <dd>An optional argument that specifies a subroutine that is to be called when
      the <span class="Li">&quot;$RE{...}-&gt;subs(...)&quot;</span> method of
      this pattern is invoked.
    <p class="Pp">The subroutine should expect three arguments: a reference to
        the pattern object itself, the string to be changed, and the value to be
        substituted into it. The third argument may be
        <span class="Li">&quot;undef&quot;</span>, indicating the default
        substitution is required.</p>
    <p class="Pp">The subroutine should return the same types of values as an
        <span class="Li">&quot;s/.../.../&quot;</span> does.</p>
    <p class="Pp">For example:</p>
    <p class="Pp"></p>
    <pre>
     pattern name    =&gt; [ 'lineof', '-char=_' ],
             create  =&gt; sub {...},
             subs    =&gt; sub {
                          my ($self, $str, $ignore_replacement) = @_;
                          $_[1] =~ s/^$self-&gt;{flags}{-char}+$//g;
                        },
             ;
    </pre>
    <p class="Pp">Note that such a subroutine will almost always need to modify
        <span class="Li">$_[1]</span> directly.</p>
  </dd>
  <dt>&quot;version =&gt; $minimum_perl_version&quot;</dt>
  <dd>If this argument is given, it specifies the minimum version of perl
      required to use the new pattern. Attempts to use the pattern with earlier
      versions of perl will generate a fatal diagnostic.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Loading_specific_sets_of_patterns."><a class="permalink" href="#Loading_specific_sets_of_patterns.">Loading
  specific sets of patterns.</a></h2>
<p class="Pp">By default, all the sets of patterns listed below are made
    available. However, it is possible to indicate which sets of patterns should
    be made available - the wanted sets should be given as arguments to
    <span class="Li">&quot;use&quot;</span>. Alternatively, it is also possible
    to indicate which sets of patterns should not be made available - those sets
    will be given as argument to the <span class="Li">&quot;use&quot;</span>
    statement, but are preceeded with an exclaimation mark. The argument
    <i>no_defaults</i> indicates none of the default patterns should be made
    available. This is useful for instance if all you want is the
    <span class="Li">&quot;pattern()&quot;</span> subroutine.</p>
<p class="Pp">Examples:</p>
<p class="Pp"></p>
<pre>
 use Regexp::Common qw /comment number/;  # Comment and number patterns.
 use Regexp::Common qw /no_defaults/;     # Don't load any patterns.
 use Regexp::Common qw /!delimited/;      # All, but delimited patterns.
</pre>
<p class="Pp">It's also possible to load your own set of patterns. If you have a
    module <span class="Li">&quot;Regexp::Common::my_patterns&quot;</span> that
    makes patterns available, you can have it made available with</p>
<p class="Pp"></p>
<pre>
 use Regexp::Common qw /my_patterns/;
</pre>
<p class="Pp">Note that the default patterns will still be made available - only
    if you use <i>no_defaults</i>, or mention one of the default sets
    explicitely, the non mentioned defaults aren't made available.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="List_of_available_patterns"><a class="permalink" href="#List_of_available_patterns">List
  of available patterns</a></h2>
<p class="Pp">The patterns listed below are currently available. Each set of
    patterns has its own manual page describing the details. For each pattern
    set named <i>name</i>, the manual page <i>Regexp::Common::name</i> describes
    the details.</p>
<p class="Pp">Currently available are:</p>
<dl class="Bl-tag">
  <dt id="Regexp::Common::balanced"><a class="permalink" href="#Regexp::Common::balanced">Regexp::Common::balanced</a></dt>
  <dd>Provides regexes for strings with balanced parenthesized delimiters.</dd>
  <dt id="Regexp::Common::comment"><a class="permalink" href="#Regexp::Common::comment">Regexp::Common::comment</a></dt>
  <dd>Provides regexes for comments of various languages (43 languages
      currently).</dd>
  <dt id="Regexp::Common::delimited"><a class="permalink" href="#Regexp::Common::delimited">Regexp::Common::delimited</a></dt>
  <dd>Provides regexes for delimited strings.</dd>
  <dt id="Regexp::Common::lingua"><a class="permalink" href="#Regexp::Common::lingua">Regexp::Common::lingua</a></dt>
  <dd>Provides regexes for palindromes.</dd>
  <dt id="Regexp::Common::list"><a class="permalink" href="#Regexp::Common::list">Regexp::Common::list</a></dt>
  <dd>Provides regexes for lists.</dd>
  <dt id="Regexp::Common::net"><a class="permalink" href="#Regexp::Common::net">Regexp::Common::net</a></dt>
  <dd>Provides regexes for IPv4 addresses and MAC addresses.</dd>
  <dt id="Regexp::Common::number"><a class="permalink" href="#Regexp::Common::number">Regexp::Common::number</a></dt>
  <dd>Provides regexes for numbers (integers and reals).</dd>
  <dt id="Regexp::Common::profanity"><a class="permalink" href="#Regexp::Common::profanity">Regexp::Common::profanity</a></dt>
  <dd>Provides regexes for profanity.</dd>
  <dt id="Regexp::Common::whitespace"><a class="permalink" href="#Regexp::Common::whitespace">Regexp::Common::whitespace</a></dt>
  <dd>Provides regexes for leading and trailing whitespace.</dd>
  <dt id="Regexp::Common::zip"><a class="permalink" href="#Regexp::Common::zip">Regexp::Common::zip</a></dt>
  <dd>Provides regexes for zip codes.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Forthcoming_patterns_and_features"><a class="permalink" href="#Forthcoming_patterns_and_features">Forthcoming
  patterns and features</a></h2>
<p class="Pp">Future releases of the module will also provide patterns for the
    following:</p>
<p class="Pp"></p>
<pre>
        * email addresses 
        * HTML/XML tags
        * more numerical matchers,
        * mail headers (including multiline ones),
        * more URLS
        * telephone numbers of various countries
        * currency (universal 3 letter format, Latin-1, currency names)
        * dates
        * binary formats (e.g. UUencoded, MIMEd)
</pre>
<p class="Pp">If you have other patterns or pattern generators that you think
    would be generally useful, please send them to the maintainer -- preferably
    as source code using the <span class="Li">&quot;pattern&quot;</span>
    subroutine. Submissions that include a set of tests will be especially
    welcome.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DIAGNOSTICS"><a class="permalink" href="#DIAGNOSTICS">DIAGNOSTICS</a></h1>
<dl class="Bl-tag">
  <dt>&quot;Can't export unknown subroutine %s&quot;</dt>
  <dd>The subroutine-based interface didn't recognize the requested subroutine.
      Often caused by a spelling mistake or an incompletely specified name.</dd>
  <dt>&quot;Can't create unknown regex: $RE{...}&quot;</dt>
  <dd>Regexp::Common doesn't have a generator for the requested pattern. Often
      indicates a mispelt or missing parameter.</dd>
  <dt> &quot;Perl %f does not support the pattern $RE{...}. You need Perl %f or
    later&quot;</dt>
  <dd>The requested pattern requires advanced regex features (e.g. recursion)
      that not available in your version of Perl. Time to upgrade.</dd>
  <dt>&quot;pattern() requires argument: name =&gt; [ @list ]&quot;</dt>
  <dd>Every user-defined pattern specification must have a name.</dd>
  <dt>&quot;pattern() requires argument: create =&gt;
    $sub_ref_or_string&quot;</dt>
  <dd>Every user-defined pattern specification must provide a pattern creation
      mechanism: either a pattern string or a reference to a subroutine that
      returns the pattern string.</dd>
  <dt>&quot;Base must be between 1 and 36&quot;</dt>
  <dd>The
      <span class="Li">$RE{num}{real}{-base=&gt;'</span><i>N</i><span class="Li">'}</span>
      pattern uses the characters [0-9A-Z] to represent the digits of various
      bases. Hence it only produces regular expressions for bases up to
      hexatricensimal.</dd>
  <dt>&quot;Must specify delimiter in $RE{delimited}&quot;</dt>
  <dd>The pattern has no default delimiter. You need to write:
      <span class="Li">$RE{delimited}{-delim=&gt;</span><i>X</i><span class="Li">'}</span>
      for some character <i>X</i></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGEMENTS"><a class="permalink" href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></h1>
<p class="Pp">Deepest thanks to the many people who have encouraged and
    contributed to this project, especially: Elijah, Jarkko, Tom, Nat, Ed, and
    Vivek.</p>
<p class="Pp">Further thanks go to: Alexandr Ciornii, Blair Zajac, Bob
    Stockdale, Charles Thomas, Chris Vertonghen, the CPAN Testers, David Hand,
    Fany, Geoffrey Leach, Hermann-Marcus Behrens, Jerome Quelin, Jim Cromie,
    Lars Wilke, Linda Julien, Mike Arms, Mike Castle, Mikko, Murat Uenalan,
    Rafaeel Garcia-Suarez, Ron Savage, Sam Vilain, Slaven Rezic, Smylers, Tim
    Maher, and all the others I've forgotten.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Damian Conway (damian@conway.org)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MAINTAINANCE"><a class="permalink" href="#MAINTAINANCE">MAINTAINANCE</a></h1>
<p class="Pp">This package is maintained by Abigail
    (<i>regexp-common@abigail.be</i>).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS_AND_IRRITATIONS"><a class="permalink" href="#BUGS_AND_IRRITATIONS">BUGS
  AND IRRITATIONS</a></h1>
<p class="Pp">Bound to be plenty.</p>
<p class="Pp">For a start, there are many common regexes missing. Send them in
    to <i>regexp-common@abigail.be</i>.</p>
<p class="Pp">There are some POD issues when installing this module using a
    pre-5.6.0 perl; some manual pages may not install, or may not install
    correctly using a perl that is that old. You might consider upgrading your
    perl.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NOT_A_BUG"><a class="permalink" href="#NOT_A_BUG">NOT A
  BUG</a></h1>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>The various patterns are not anchored. That is, a pattern like
      <span class="Li">&quot;$RE {num} {int}&quot;</span> will match against
      &quot;abc4def&quot;, because a substring of the subject matches. This is
      by design, and not a bug. If you want the pattern to be anchored, use
      something like:
    <p class="Pp"></p>
    <pre>
 my $integer = $RE {num} {int};
 $subj =~ /^$integer$/ and print &quot;Matches!\n&quot;;
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE_and_COPYRIGHT"><a class="permalink" href="#LICENSE_and_COPYRIGHT">LICENSE
  and COPYRIGHT</a></h1>
<p class="Pp">This software is Copyright (c) 2001 - 2011, Damian Conway and
    Abigail.</p>
<p class="Pp">This module is free software, and maybe used under any of the
    following licenses:</p>
<p class="Pp"></p>
<pre>
 1) The Perl Artistic License.     See the file COPYRIGHT.AL.
 2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.
 3) The BSD Licence.               See the file COPYRIGHT.BSD.
 4) The MIT Licence.               See the file COPYRIGHT.MIT.
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-03-13</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>MIME::Tools(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">MIME::Tools(3)</td>
    <td class="head-vol"><a href=".">User Contributed Perl Documentation</a></td>
    <td class="head-rtitle">MIME::Tools(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">MIME-tools - modules for parsing (and creating!) MIME entities</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">Here's some pretty basic code for <b>parsing a MIME message,</b>
    and outputting its decoded components to a given directory:</p>
<p class="Pp"></p>
<pre>    use MIME::Parser;
    ### Create parser, and set some parsing options:
    my $parser = new MIME::Parser;
    $parser-&gt;output_under(&quot;$ENV{HOME}/mimemail&quot;);
    ### Parse input:
    $entity = $parser-&gt;parse(\*STDIN) or die &quot;parse failed\n&quot;;
    ### Take a look at the top-level entity (and any parts it has):
    $entity-&gt;dump_skeleton;
</pre>
<p class="Pp">Here's some code which <b>composes and sends a MIME message</b>
    containing three parts: a text file, an attached GIF, and some more
  text:</p>
<p class="Pp"></p>
<pre>    use MIME::Entity;
    ### Create the top-level, and set up the mail headers:
    $top = MIME::Entity-&gt;build(Type    =&gt;&quot;multipart/mixed&quot;,
                               From    =&gt; &quot;me\@myhost.com&quot;,
                               To      =&gt; &quot;you\@yourhost.com&quot;,
                               Subject =&gt; &quot;Hello, nurse!&quot;);
    ### Part #1: a simple text document:
    $top-&gt;attach(Path=&gt;&quot;./testin/short.txt&quot;);
    ### Part #2: a GIF file:
    $top-&gt;attach(Path        =&gt; &quot;./docs/mime-sm.gif&quot;,
                 Type        =&gt; &quot;image/gif&quot;,
                 Encoding    =&gt; &quot;base64&quot;);
    ### Part #3: some literal text:
    $top-&gt;attach(Data=&gt;$message);
    ### Send it:
    open MAIL, &quot;| /usr/lib/sendmail -t -oi -oem&quot; or die &quot;open: $!&quot;;
    $top-&gt;print(\*MAIL);
    close MAIL;
</pre>
<p class="Pp">For more examples, look at the scripts in the <b>examples</b>
    directory of the MIME-tools distribution.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">MIME-tools is a collection of Perl5 MIME:: modules for parsing,
    decoding, <i>and generating</i> single- or multipart (even nested multipart)
    MIME messages. (Yes, kids, that means you can send messages with attached
    GIF files).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="REQUIREMENTS"><a class="permalink" href="#REQUIREMENTS">REQUIREMENTS</a></h1>
<p class="Pp">You will need the following installed on your system:</p>
<p class="Pp"></p>
<pre>        File::Path
        File::Spec
        IPC::Open2              (optional)
        MIME::Base64
        MIME::QuotedPrint
        Net::SMTP
        Mail::Internet, ...     from the MailTools distribution.
</pre>
<p class="Pp">See the Makefile.PL in your distribution for the
    most-comprehensive list of prerequisite modules and their version
  numbers.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="A_QUICK_TOUR"><a class="permalink" href="#A_QUICK_TOUR">A
  QUICK TOUR</a></h1>
<section class="Ss">
<h2 class="Ss" id="Overview_of_the_classes"><a class="permalink" href="#Overview_of_the_classes">Overview
  of the classes</a></h2>
<p class="Pp">Here are the classes you'll generally be dealing with
  directly:</p>
<p class="Pp"></p>
<pre>    (START HERE)            results() .-----------------.
          \                 .--------&gt;| MIME::          |
           .-----------.   /          | Parser::Results |
           | MIME::    |--'           `-----------------'
           | Parser    |--.           .-----------------.
           `-----------'   \ filer()  | MIME::          |
              | parse()     `--------&gt;| Parser::Filer   |
              | gives you             `-----------------'
              | a...                                  | output_path()
              |                                       | determines
              |                                       | path() of...
              |    head()       .--------.            |
              |    returns...   | MIME:: | get()      |
              V       .--------&gt;| Head   | etc...     |
           .--------./          `--------'            |
     .---&gt; | MIME:: |                                 |
     `-----| Entity |           .--------.            |
   parts() `--------'\          | MIME:: |           /
   returns            `--------&gt;| Body   |&lt;---------'
   sub-entities    bodyhandle() `--------'
   (if any)        returns...       | open()
                                    | returns...
                                    |
                                    V
                                .--------. read()
                                | IO::   | getline()
                                | Handle | print()
                                `--------' etc...
</pre>
<p class="Pp">To illustrate, parsing works this way:</p>
<ul class="Bl-bullet">
  <li><b>The &quot;parser&quot; parses the MIME stream.</b> A parser is an
      instance of <span class="Li">&quot;MIME::Parser&quot;</span>. You hand it
      an input stream (like a filehandle) to parse a message from: if the parse
      is successful, the result is an &quot;entity&quot;.</li>
  <li><b>A parsed message is represented by an &quot;entity&quot;.</b> An entity
      is an instance of <span class="Li">&quot;MIME::Entity&quot;</span> (a
      subclass of <span class="Li">&quot;Mail::Internet&quot;</span>). If the
      message had &quot;parts&quot; (e.g., attachments), then those parts are
      &quot;entities&quot; as well, contained inside the top-level entity. Each
      entity has a &quot;head&quot; and a &quot;body&quot;.</li>
  <li><b>The entity's &quot;head&quot; contains information about the
      message.</b> A &quot;head&quot; is an instance of
      <span class="Li">&quot;MIME::Head&quot;</span> (a subclass of
      <span class="Li">&quot;Mail::Header&quot;</span>). It contains information
      from the message header: content type, sender, subject line, etc.</li>
  <li><b>The entity's &quot;body&quot; knows where the message data is.</b> You
      can ask to &quot;open&quot; this data source for <i>reading</i> or
      <i>writing</i>, and you will get back an &quot;I/O handle&quot;.</li>
  <li><b>You can </b><b>open()</b><b> a &quot;body&quot; and get an &quot;I/O
      handle&quot; to read/write message data.</b> This handle is an object that
      is basically like an IO::Handle... it can be any class, so long as it
      supports a small, standard set of methods for reading from or writing to
      the underlying data source.</li>
</ul>
<p class="Pp">A typical multipart message containing two parts -- a textual
    greeting and an &quot;attached&quot; GIF file -- would be a tree of
    MIME::Entity objects, each of which would have its own MIME::Head. Like
    this:</p>
<p class="Pp"></p>
<pre>    .--------.
    | MIME:: | Content-type: multipart/mixed
    | Entity | Subject: Happy Samhaine!
    `--------'
         |
         `----.
        parts |
              |   .--------.
              |---| MIME:: | Content-type: text/plain; charset=us-ascii
              |   | Entity | Content-transfer-encoding: 7bit
              |   `--------'
              |   .--------.
              |---| MIME:: | Content-type: image/gif
                  | Entity | Content-transfer-encoding: base64
                  `--------' Content-disposition: inline;
                               filename=&quot;hs.gif&quot;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Parsing_messages"><a class="permalink" href="#Parsing_messages">Parsing
  messages</a></h2>
<p class="Pp">You usually start by creating an instance of <b>MIME::Parser</b>
    and setting up certain parsing parameters: what directory to save extracted
    files to, how to name the files, etc.</p>
<p class="Pp">You then give that instance a readable filehandle on which waits a
    MIME message. If all goes well, you will get back a <b>MIME::Entity</b>
    object (a subclass of <b>Mail::Internet</b>), which consists of...</p>
<ul class="Bl-bullet">
  <li>A <b>MIME::Head</b> (a subclass of <b>Mail::Header</b>) which holds the
      MIME header data.</li>
  <li>A <b>MIME::Body</b>, which is a object that knows where the body data is.
      You ask this object to &quot;open&quot; itself for reading, and it will
      hand you back an &quot;I/O handle&quot; for reading the data: this could
      be of any class, so long as it conforms to a subset of the
      <b>IO::Handle</b> interface.</li>
</ul>
<p class="Pp">If the original message was a multipart document, the MIME::Entity
    object will have a non-empty list of &quot;parts&quot;, each of which is in
    turn a MIME::Entity (which might also be a multipart entity, etc,
  etc...).</p>
<p class="Pp">Internally, the parser (in MIME::Parser) asks for instances of
    <b>MIME::Decoder</b> whenever it needs to decode an encoded file.
    MIME::Decoder has a mapping from supported encodings (e.g., 'base64') to
    classes whose instances can decode them. You can add to this mapping to try
    out new/experiment encodings. You can also use MIME::Decoder by itself.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Composing_messages"><a class="permalink" href="#Composing_messages">Composing
  messages</a></h2>
<p class="Pp">All message composition is done via the <b>MIME::Entity</b> class.
    For single-part messages, you can use the <b>MIME::Entity/build</b>
    constructor to create MIME entities very easily.</p>
<p class="Pp">For multipart messages, you can start by creating a top-level
    <span class="Li">&quot;multipart&quot;</span> entity with
    <b></b><b>MIME::Entity::build()</b><b></b>, and then use the similar
    <b></b><b>MIME::Entity::attach()</b><b></b> method to attach parts to that
    message. <i>Please note:</i> what most people think of as &quot;a text
    message with an attached GIF file&quot; is <i>really</i> a multipart message
    with 2 parts: the first being the text message, and the second being the GIF
    file.</p>
<p class="Pp">When building MIME a entity, you'll have to provide two very
    important pieces of information: the <i>content type</i> and the <i>content
    transfer encoding</i>. The type is usually easy, as it is directly
    determined by the file format; e.g., an HTML file is
    <span class="Li">&quot;text/html&quot;</span>. The encoding, however, is
    trickier... for example, some HTML files are
    <span class="Li">&quot;7bit&quot;</span>-compliant, but others might have
    very long lines and would need to be sent
    <span class="Li">&quot;quoted-printable&quot;</span> for reliability.</p>
<p class="Pp">See the section on encoding/decoding for more details, as well as
    &quot;A MIME PRIMER&quot; below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Sending_email"><a class="permalink" href="#Sending_email">Sending
  email</a></h2>
<p class="Pp">Since MIME::Entity inherits directly from Mail::Internet, you can
    use the normal Mail::Internet mechanisms to send email. For example,</p>
<p class="Pp"></p>
<pre>    $entity-&gt;smtpsend;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Encoding/decoding_support"><a class="permalink" href="#Encoding/decoding_support">Encoding/decoding
  support</a></h2>
<p class="Pp">The <b>MIME::Decoder</b> class can be used to <i>encode</i> as
    well; this is done when printing MIME entities. All the standard encodings
    are supported (see &quot;A MIME PRIMER&quot; below for details):</p>
<p class="Pp"></p>
<pre>    Encoding:        | Normally used when message contents are:
    -------------------------------------------------------------------
    7bit             | 7-bit data with under 1000 chars/line, or multipart.
    8bit             | 8-bit data with under 1000 chars/line.
    binary           | 8-bit data with some long lines (or no line breaks).
    quoted-printable | Text files with some 8-bit chars (e.g., Latin-1 text).
    base64           | Binary files.
</pre>
<p class="Pp">Which encoding you choose for a given document depends largely on
    (1) what you know about the document's contents (text vs binary), and (2)
    whether you need the resulting message to have a reliable encoding for 7-bit
    Internet email transport.</p>
<p class="Pp">In general, only
    <span class="Li">&quot;quoted-printable&quot;</span> and
    <span class="Li">&quot;base64&quot;</span> guarantee reliable transport of
    all data; the other three &quot;no-encoding&quot; encodings simply pass the
    data through, and are only reliable if that data is 7bit ASCII with under
    1000 characters per line, and has no conflicts with the multipart
    boundaries.</p>
<p class="Pp">I've considered making it so that the content-type and encoding
    can be automatically inferred from the file's path, but that seems to be
    asking for trouble... or at least, for Mail::Cap...</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Message-logging"><a class="permalink" href="#Message-logging">Message-logging</a></h2>
<p class="Pp">MIME-tools is a large and complex toolkit which tries to deal with
    a wide variety of external input. It's sometimes helpful to see what's
    really going on behind the scenes. There are several kinds of messages
    logged by the toolkit itself:</p>
<dl class="Bl-tag">
  <dt id="Debug"><a class="permalink" href="#Debug">Debug messages</a></dt>
  <dd>These are printed directly to the STDERR, with a prefix of
      <span class="Li">&quot;MIME-tools: debug&quot;</span>.
    <p class="Pp">Debug message are only logged if you have turned
        &quot;debugging&quot; on in the MIME::Tools configuration.</p>
  </dd>
  <dt id="Warning"><a class="permalink" href="#Warning">Warning
    messages</a></dt>
  <dd>These are logged by the standard Perl <b>warn()</b> mechanism to indicate
      an unusual situation. They all have a prefix of
      <span class="Li">&quot;MIME-tools: warning&quot;</span>.
    <p class="Pp">Warning messages are only logged if
        <span class="Li">$^W</span> is set true and MIME::Tools is not
        configured to be &quot;quiet&quot;.</p>
  </dd>
  <dt id="Error"><a class="permalink" href="#Error">Error messages</a></dt>
  <dd>These are logged by the standard Perl <b>warn()</b> mechanism to indicate
      that something actually failed. They all have a prefix of
      <span class="Li">&quot;MIME-tools: error&quot;</span>.
    <p class="Pp">Error messages are only logged if <span class="Li">$^W</span>
        is set true and MIME::Tools is not configured to be
      &quot;quiet&quot;.</p>
  </dd>
  <dt id="Usage"><a class="permalink" href="#Usage">Usage messages</a></dt>
  <dd>Unlike &quot;typical&quot; warnings above, which warn about problems
      processing data, usage-warnings are for alerting developers of deprecated
      methods and suspicious invocations.
    <p class="Pp">Usage messages are currently only logged if
        <span class="Li">$^W</span> is set true and MIME::Tools is not
        configured to be &quot;quiet&quot;.</p>
  </dd>
</dl>
<p class="Pp">When a MIME::Parser (or one of its internal helper classes) wants
    to report a message, it generally does so by recording the message to the
    <b>MIME::Parser::Results</b> object immediately before invoking the
    appropriate function above. That means each parsing run has its own
    trace-log which can be examined for problems.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Configuring_the_toolkit"><a class="permalink" href="#Configuring_the_toolkit">Configuring
  the toolkit</a></h2>
<p class="Pp">If you want to tweak the way this toolkit works (for example, to
    turn on debugging), use the routines in the <b>MIME::Tools</b> module.</p>
<dl class="Bl-tag">
  <dt id="debugging"><a class="permalink" href="#debugging">debugging</a></dt>
  <dd>Turn debugging on or off. Default is false (off).
    <p class="Pp"></p>
    <pre>     MIME::Tools-&gt;debugging(1);
    </pre>
  </dd>
  <dt id="quiet"><a class="permalink" href="#quiet">quiet</a></dt>
  <dd>Turn the reporting of warning/error messages on or off. Default is true,
      meaning that these message are silenced.
    <p class="Pp"></p>
    <pre>     MIME::Tools-&gt;quiet(1);
    </pre>
  </dd>
  <dt id="version"><a class="permalink" href="#version">version</a></dt>
  <dd>Return the toolkit version.
    <p class="Pp"></p>
    <pre>     print MIME::Tools-&gt;version, &quot;\n&quot;;
    </pre>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="THINGS_YOU_SHOULD_DO"><a class="permalink" href="#THINGS_YOU_SHOULD_DO">THINGS
  YOU SHOULD DO</a></h1>
<section class="Ss">
<h2 class="Ss" id="Take_a_look_at_the_examples"><a class="permalink" href="#Take_a_look_at_the_examples">Take
  a look at the examples</a></h2>
<p class="Pp">The MIME-Tools distribution comes with an &quot;examples&quot;
    directory. The scripts in there are basically just tossed-together, but
    they'll give you some ideas of how to use the parser.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Run_with_warnings_enabled"><a class="permalink" href="#Run_with_warnings_enabled">Run
  with warnings enabled</a></h2>
<p class="Pp"><i>Always</i> run your Perl script with
    <span class="Li">&quot;-w&quot;</span>. If you see a warning about a
    deprecated method, change your code ASAP. This will ease upgrades
    tremendously.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Avoid_non-standard_encodings"><a class="permalink" href="#Avoid_non-standard_encodings">Avoid
  non-standard encodings</a></h2>
<p class="Pp">Don't try to MIME-encode using the non-standard MIME encodings.
    It's just not a good practice if you want people to be able to read your
    messages.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Plan_for_thrown_exceptions"><a class="permalink" href="#Plan_for_thrown_exceptions">Plan
  for thrown exceptions</a></h2>
<p class="Pp">For example, if your mail-handling code absolutely must not die,
    then perform mail parsing like this:</p>
<p class="Pp"></p>
<pre>    $entity = eval { $parser-&gt;parse(\*INPUT) };
</pre>
<p class="Pp">Parsing is a complex process, and some components may throw
    exceptions if seriously-bad things happen. Since &quot;seriously-bad&quot;
    is in the eye of the beholder, you're better off <i>catching</i> possible
    exceptions instead of asking me to propagate
    <span class="Li">&quot;undef&quot;</span> up the stack. Use of exceptions in
    reusable modules is one of those religious issues we're never all going to
    agree upon; thankfully, that's what
    <span class="Li">&quot;eval{}&quot;</span> is good for.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Check_the_parser_results_for_warnings/errors"><a class="permalink" href="#Check_the_parser_results_for_warnings/errors">Check
  the parser results for warnings/errors</a></h2>
<p class="Pp">As of 5.3xx, the parser tries extremely hard to give you a
    MIME::Entity. If there were any problems, it logs warnings/errors to the
    underlying &quot;results&quot; object (see MIME::Parser::Results). Look at
    that object after each parse. Print out the warnings and errors,
    <i>especially</i> if messages don't parse the way you thought they
  would.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Don't_plan_on_printing_exactly_what_you_parsed!"><a class="permalink" href="#Don't_plan_on_printing_exactly_what_you_parsed!">Don't
  plan on printing exactly what you parsed!</a></h2>
<p class="Pp"><i>Parsing is a (slightly) lossy operation.</i> Because of things
    like ambiguities in base64-encoding, the following is <i>not</i> going to
    spit out its input unchanged in all cases:</p>
<p class="Pp"></p>
<pre>    $entity = $parser-&gt;parse(\*STDIN);
    $entity-&gt;print(\*STDOUT);
</pre>
<p class="Pp">If you're using MIME::Tools to process email, remember to save the
    data you parse if you want to send it on unchanged. This is vital for things
    like PGP-signed email.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Understand_how_international_characters_are_represented"><a class="permalink" href="#Understand_how_international_characters_are_represented">Understand
  how international characters are represented</a></h2>
<p class="Pp">The MIME standard allows for text strings in headers to contain
    characters from any character set, by using special sequences which look
    like this:</p>
<p class="Pp"></p>
<pre>    =?ISO-8859-1?Q?Keld_J=F8rn_Simonsen?=
</pre>
<p class="Pp">To be consistent with the existing Mail::Field classes,
    MIME::Tools does <i>not</i> automatically unencode these strings, since
    doing so would lose the character-set information and interfere with the
    parsing of fields (see &quot;decode_headers&quot; in MIME::Parser for a full
    explanation). That means you should be prepared to deal with these encoded
    strings.</p>
<p class="Pp">The most common question then is, <b>how do I decode these encoded
    strings?</b> The answer depends on what you want to decode them <i>to</i>:
    ASCII, Latin1, UTF-8, etc. Be aware that your &quot;target&quot;
    representation may not support all possible character sets you might
    encounter; for example, Latin1 (ISO-8859-1) has no way of representing Big5
    (Chinese) characters. A common practice is to represent
    &quot;untranslateable&quot; characters as &quot;?&quot;s, or to ignore them
    completely.</p>
<p class="Pp">To unencode the strings into some of the more-popular Western byte
    representations (e.g., Latin1, Latin2, etc.), you can use the decoders in
    MIME::WordDecoder (see MIME::WordDecoder). The simplest way is by using
    <span class="Li">&quot;unmime()&quot;</span>, a function wrapped around your
    &quot;default&quot; decoder, as follows:</p>
<p class="Pp"></p>
<pre>    use MIME::WordDecoder;
    ...
    $subject = unmime $entity-&gt;head-&gt;get('subject');
</pre>
<p class="Pp">One place this <i>is</i> done automatically is in extracting the
    recommended filename for a part while parsing. That's why you should start
    by setting up the best &quot;default&quot; decoder if the default target of
    Latin1 isn't to your liking.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="THINGS_I_DO_THAT_YOU_SHOULD_KNOW_ABOUT"><a class="permalink" href="#THINGS_I_DO_THAT_YOU_SHOULD_KNOW_ABOUT">THINGS
  I DO THAT YOU SHOULD KNOW ABOUT</a></h1>
<section class="Ss">
<h2 class="Ss">Fuzzing of CRLF and newline on input</h2>
<p class="Pp">RFC 2045 dictates that MIME streams have lines terminated by CRLF
    (<span class="Li">&quot;\r\n&quot;</span>). However, it is extremely likely
    that folks will want to parse MIME streams where each line ends in the local
    newline character <span class="Li">&quot;\n&quot;</span> instead.</p>
<p class="Pp">An attempt has been made to allow the parser to handle both CRLF
    and newline-terminated input.</p>
</section>
<section class="Ss">
<h2 class="Ss">Fuzzing of CRLF and newline when decoding</h2>
<p class="Pp">The <span class="Li">&quot;7bit&quot;</span> and
    <span class="Li">&quot;8bit&quot;</span> decoders will decode both a
    <span class="Li">&quot;\n&quot;</span> and a
    <span class="Li">&quot;\r\n&quot;</span> end-of-line sequence into a
    <span class="Li">&quot;\n&quot;</span>.</p>
<p class="Pp">The <span class="Li">&quot;binary&quot;</span> decoder (default if
    no encoding specified) still outputs stuff verbatim... so a MIME message
    with CRLFs and no explicit encoding will be output as a text file that, on
    many systems, will have an annoying ^M at the end of each line... <i>but
    this is as it should be</i>.</p>
</section>
<section class="Ss">
<h2 class="Ss">Fuzzing of CRLF and newline when encoding/composing</h2>
<p class="Pp">TODO FIXME All encoders currently output the end-of-line sequence
    as a <span class="Li">&quot;\n&quot;</span>, with the assumption that the
    local mail agent will perform the conversion from newline to CRLF when
    sending the mail. However, there probably should be an option to output CRLF
    as per RFC 2045</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Inability_to_handle_multipart_boundaries_with_embedded_newlines"><a class="permalink" href="#Inability_to_handle_multipart_boundaries_with_embedded_newlines">Inability
  to handle multipart boundaries with embedded newlines</a></h2>
<p class="Pp">Let's get something straight: this is an evil, EVIL practice. If
    your mailer creates multipart boundary strings that contain newlines, give
    it two weeks notice and find another one. If your mail robot receives MIME
    mail like this, regard it as syntactically incorrect, which it is.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Ignoring_non-header_headers"><a class="permalink" href="#Ignoring_non-header_headers">Ignoring
  non-header headers</a></h2>
<p class="Pp">People like to hand the parser raw messages straight from POP3 or
    from a mailbox. There is often predictable non-header information in front
    of the real headers; e.g., the initial &quot;From&quot; line in the
    following message:</p>
<p class="Pp"></p>
<pre>    From - Wed Mar 22 02:13:18 2000
    Return-Path: &lt;eryq@zeegee.com&gt;
    Subject: Hello
</pre>
<p class="Pp">The parser simply ignores such stuff quietly. Perhaps it
    shouldn't, but most people seem to want that behavior.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Fuzzing_of_empty_multipart_preambles"><a class="permalink" href="#Fuzzing_of_empty_multipart_preambles">Fuzzing
  of empty multipart preambles</a></h2>
<p class="Pp">Please note that there is currently an ambiguity in the way
    preambles are parsed in. The following message fragments <i>both</i> are
    regarded as having an empty preamble (where
    <span class="Li">&quot;\n&quot;</span> indicates a newline character):</p>
<p class="Pp"></p>
<pre>     Content-type: multipart/mixed; boundary=&quot;xyz&quot;\n
     Subject: This message (#1) has an empty preamble\n
     \n
     --xyz\n
     ...
     Content-type: multipart/mixed; boundary=&quot;xyz&quot;\n
     Subject: This message (#2) also has an empty preamble\n
     \n
     \n
     --xyz\n
     ...
</pre>
<p class="Pp">In both cases, the <i>first</i> completely-empty line (after the
    &quot;Subject&quot;) marks the end of the header.</p>
<p class="Pp">But we should clearly ignore the <i>second</i> empty line in
    message #2, since it fills the role of <i>&quot;the newline which is only
    there to make</i> <i>sure that the boundary is at the beginning of a
    line&quot;</i>. Such newlines are <i>never</i> part of the content preceding
    the boundary; thus, there is no preamble &quot;content&quot; in message
  #2.</p>
<p class="Pp">However, it seems clear that message #1 <i>also</i> has no
    preamble &quot;content&quot;, and is in fact merely a compact representation
    of an empty preamble.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Use_of_a_temp_file_during_parsing"><a class="permalink" href="#Use_of_a_temp_file_during_parsing">Use
  of a temp file during parsing</a></h2>
<p class="Pp"><i>Why not do everything in core?</i> Although the amount of core
    available on even a modest home system continues to grow, the size of
    attachments continues to grow with it. I wanted to make sure that even users
    with small systems could deal with decoding multi-megabyte sounds and movie
    files. That means not being core-bound.</p>
<p class="Pp">As of the released 5.3xx, MIME::Parser gets by with only one temp
    file open per parser. This temp file provides a sort of infinite scratch
    space for dealing with the current message part. It's fast and lightweight,
    but you should know about it anyway.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Why_do_I_assume_that_"><a class="permalink" href="#Why_do_I_assume_that_">Why
  do I assume that MIME objects are email objects?</a></h2>
<p class="Pp">Achim Bohnet once pointed out that MIME headers do nothing more
    than store a collection of attributes, and thus could be represented as
    objects which don't inherit from Mail::Header.</p>
<p class="Pp">I agree in principle, but RFC 2045 says otherwise. RFC 2045 [MIME]
    headers are a syntactic subset of RFC-822 [email] headers. Perhaps a better
    name for these modules would have been RFC1521:: instead of MIME::, but
    we're a little beyond that stage now.</p>
<p class="Pp">When I originally wrote these modules for the CPAN, I agonized for
    a long time about whether or not they really should subclass from
    <b>Mail::Internet</b> (then at version 1.17). Thanks to Graham Barr, who
    graciously evolved MailTools 1.06 to be more MIME-friendly, unification was
    achieved at MIME-tools release 2.0. The benefits in reuse alone have been
    substantial.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="A_MIME_PRIMER"><a class="permalink" href="#A_MIME_PRIMER">A
  MIME PRIMER</a></h1>
<p class="Pp">So you need to parse (or create) MIME, but you're not quite up on
    the specifics? No problem...</p>
<section class="Ss">
<h2 class="Ss" id="Glossary"><a class="permalink" href="#Glossary">Glossary</a></h2>
<p class="Pp">Here are some definitions adapted from RFC 1521 (predecessor of
    the current RFC 204[56789] defining MIME) explaining the terminology we use;
    each is accompanied by the equivalent in MIME:: module terms...</p>
<dl class="Bl-tag">
  <dt id="attachment"><a class="permalink" href="#attachment">attachment</a></dt>
  <dd>An &quot;attachment&quot; is common slang for any part of a multipart
      message -- except, perhaps, for the first part, which normally carries a
      user message describing the attachments that follow (e.g.: &quot;Hey dude,
      here's that GIF file I promised you.&quot;).
    <p class="Pp">In our system, an attachment is just a <b>MIME::Entity</b>
        under the top-level entity, probably one of its parts.</p>
  </dd>
  <dt id="body"><a class="permalink" href="#body">body</a></dt>
  <dd>The &quot;body&quot; of an entity is that portion of the entity which
      follows the header and which contains the real message content. For
      example, if your MIME message has a GIF file attachment, then the body of
      that attachment is the base64-encoded GIF file itself.
    <p class="Pp">A body is represented by an instance of <b>MIME::Body</b>. You
        get the body of an entity by sending it a <b>bodyhandle()</b>
      message.</p>
  </dd>
  <dt>body part</dt>
  <dd>One of the parts of the body of a multipart <b>/entity</b>. A body part
      has a <b>/header</b> and a <b>/body</b>, so it makes sense to speak about
      the body of a body part.
    <p class="Pp">Since a body part is just a kind of entity, it's represented
        by an instance of <b>MIME::Entity</b>.</p>
  </dd>
  <dt id="entity"><a class="permalink" href="#entity">entity</a></dt>
  <dd>An &quot;entity&quot; means either a <b>/message</b> or a <b>/body
      part</b>. All entities have a <b>/header</b> and a <b>/body</b>.
    <p class="Pp">An entity is represented by an instance of
        <b>MIME::Entity</b>. There are instance methods for recovering the
        header (a <b>MIME::Head</b>) and the body (a <b>MIME::Body</b>).</p>
  </dd>
  <dt id="header"><a class="permalink" href="#header">header</a></dt>
  <dd>This is the top portion of the MIME message, which contains the
      &quot;Content-type&quot;, &quot;Content-transfer-encoding&quot;, etc.
      Every MIME entity has a header, represented by an instance of
      <b>MIME::Head</b>. You get the header of an entity by sending it a
      <b>head()</b> message.</dd>
  <dt id="message"><a class="permalink" href="#message">message</a></dt>
  <dd>A &quot;message&quot; generally means the complete (or
      &quot;top-level&quot;) message being transferred on a network.
    <p class="Pp">There currently is no explicit package for
        &quot;messages&quot;; under MIME::, messages are streams of data which
        may be read in from files or filehandles. You can think of the
        <b>MIME::Entity</b> returned by the <b>MIME::Parser</b> as representing
        the full message.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Content_types"><a class="permalink" href="#Content_types">Content
  types</a></h2>
<p class="Pp">This indicates what kind of data is in the MIME message, usually
    as <i>majortype/minortype</i>. The standard major types are shown below. A
    more-comprehensive listing may be found in RFC-2046.</p>
<dl class="Bl-tag">
  <dt id="application"><a class="permalink" href="#application">application</a></dt>
  <dd>Data which does not fit in any of the other categories, particularly data
      to be processed by some type of application program.
      <span class="Li">&quot;application/octet-stream&quot;</span>,
      <span class="Li">&quot;application/gzip&quot;</span>,
      <span class="Li">&quot;application/postscript&quot;</span>...</dd>
  <dt id="audio"><a class="permalink" href="#audio">audio</a></dt>
  <dd>Audio data. <span class="Li">&quot;audio/basic&quot;</span>...</dd>
  <dt id="image"><a class="permalink" href="#image">image</a></dt>
  <dd>Graphics data. <span class="Li">&quot;image/gif&quot;</span>,
      <span class="Li">&quot;image/jpeg&quot;</span>...</dd>
  <dt id="message~2"><a class="permalink" href="#message~2">message</a></dt>
  <dd>A message, usually another mail or MIME message.
      <span class="Li">&quot;message/rfc822&quot;</span>...</dd>
  <dt id="multipart"><a class="permalink" href="#multipart">multipart</a></dt>
  <dd>A message containing other messages.
      <span class="Li">&quot;multipart/mixed&quot;</span>,
      <span class="Li">&quot;multipart/alternative&quot;</span>...</dd>
  <dt id="text"><a class="permalink" href="#text">text</a></dt>
  <dd>Textual data, meant for humans to read.
      <span class="Li">&quot;text/plain&quot;</span>,
      <span class="Li">&quot;text/html&quot;</span>...</dd>
  <dt id="video"><a class="permalink" href="#video">video</a></dt>
  <dd>Video or video+audio data.
      <span class="Li">&quot;video/mpeg&quot;</span>...</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Content_transfer_encodings"><a class="permalink" href="#Content_transfer_encodings">Content
  transfer encodings</a></h2>
<p class="Pp">This is how the message body is packaged up for safe transit.
    There are the 5 major MIME encodings. A more-comprehensive listing may be
    found in RFC-2045.</p>
<dl class="Bl-tag">
  <dt>7bit</dt>
  <dd>No encoding is done at all. This label simply asserts that no 8-bit
      characters are present, and that lines do not exceed 1000 characters in
      length (including the CRLF).</dd>
  <dt>8bit</dt>
  <dd>No encoding is done at all. This label simply asserts that the message
      might contain 8-bit characters, and that lines do not exceed 1000
      characters in length (including the CRLF).</dd>
  <dt id="binary"><a class="permalink" href="#binary">binary</a></dt>
  <dd>No encoding is done at all. This label simply asserts that the message
      might contain 8-bit characters, and that lines may exceed 1000 characters
      in length. Such messages are the <i>least</i> likely to get through mail
      gateways.</dd>
  <dt id="base64"><a class="permalink" href="#base64">base64</a></dt>
  <dd>A standard encoding, which maps arbitrary binary data to the 7bit domain.
      Like &quot;uuencode&quot;, but very well-defined. This is how you should
      send essentially binary information (tar files, GIFs, JPEGs, etc.).</dd>
  <dt id="quoted-printable"><a class="permalink" href="#quoted-printable">quoted-printable</a></dt>
  <dd>A standard encoding, which maps arbitrary line-oriented data to the 7bit
      domain. Useful for encoding messages which are textual in nature, yet
      which contain non-ASCII characters (e.g., Latin-1, Latin-2, or any other
      8-bit alphabet).</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">MIME::Parser, MIME::Head, MIME::Body, MIME::Entity, MIME::Decoder,
    Mail::Header, Mail::Internet</p>
<p class="Pp">At the time of this writing, the MIME-tools homepage was
    <i>http://www.mimedefang.org/static/mime-tools.php</i>. Check there for
    updates and support.</p>
<p class="Pp">The MIME format is documented in RFCs 1521-1522, and more recently
    in RFCs 2045-2049.</p>
<p class="Pp">The MIME header format is an outgrowth of the mail header format
    documented in RFC 822.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
<p class="Pp">Please file support requests via rt.cpan.org.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CHANGE_LOG"><a class="permalink" href="#CHANGE_LOG">CHANGE
  LOG</a></h1>
<p class="Pp">Released as MIME-parser (1.0): 28 April 1996. Released as
    MIME-tools (2.0): Halloween 1996. Released as MIME-tools (4.0): Christmas
    1997. Released as MIME-tools (5.0): Mother's Day 2000.</p>
<p class="Pp">See ChangeLog file for full details.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Eryq (<i>eryq@zeegee.com</i>), ZeeGee Software Inc
    (<i>http://www.zeegee.com</i>). Dianne Skoll (<i>dfs@roaringpenguin.com</i>)
    <i>http://www.roaringpenguin.com</i>.</p>
<p class="Pp">Copyright (c) 1998, 1999 by ZeeGee Software Inc (www.zeegee.com).
    Copyright (c) 2004 by Roaring Penguin Software Inc
  (www.roaringpenguin.com)</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">See the COPYING file in the distribution for details.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGMENTS"><a class="permalink" href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a></h1>
<p class="Pp"><b>This kit would not have been possible</b> but for the direct
    contributions of the following:</p>
<p class="Pp"></p>
<pre>    Gisle Aas             The MIME encoding/decoding modules.
    Laurent Amon          Bug reports and suggestions.
    Graham Barr           The new MailTools.
    Achim Bohnet          Numerous good suggestions, including the I/O model.
    Kent Boortz           Initial code for RFC-1522-decoding of MIME headers.
    Andreas Koenig        Numerous good ideas, tons of beta testing,
                            and help with CPAN-friendly packaging.
    Igor Starovoitov      Bug reports and suggestions.
    Jason L Tibbitts III  Bug reports, suggestions, patches.
</pre>
<p class="Pp">Not to mention the Accidental Beta Test Team, whose bug reports
    (and comments) have been invaluable in improving the whole:</p>
<p class="Pp"></p>
<pre>    Phil Abercrombie
    Mike Blazer
    Brandon Browning
    Kurt Freytag
    Steve Kilbane
    Jake Morrison
    Rolf Nelson
    Joel Noble
    Michael W. Normandin
    Tim Pierce
    Andrew Pimlott
    Dragomir R. Radev
    Nickolay Saukh
    Russell Sutherland
    Larry Virden
    Zyx
</pre>
<p class="Pp">Please forgive me if I've accidentally left you out. Better yet,
    email me, and I'll put you in.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">See the COPYING file for more details.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-04-05</td>
    <td class="foot-os"><a href="..">perl v5.34.0</a></td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>DBIx::Class::Relationship(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBIx::Class::Relationship(3)</td>
    <td class="head-vol"><a href=".">User Contributed Perl Documentation</a></td>
    <td class="head-rtitle">DBIx::Class::Relationship(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">DBIx::Class::Relationship - Inter-table relationships</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  ## Creating relationships
  MyApp::Schema::Actor-&gt;has_many('actorroles' =&gt; 'MyApp::Schema::ActorRole',
                                'actor');
  MyApp::Schema::Role-&gt;has_many('actorroles' =&gt; 'MyApp::Schema::ActorRole',
                                'role');
  MyApp::Schema::ActorRole-&gt;belongs_to('role' =&gt; 'MyApp::Schema::Role');
  MyApp::Schema::ActorRole-&gt;belongs_to('actor' =&gt; 'MyApp::Schema::Actor');
  MyApp::Schema::Role-&gt;many_to_many('actors' =&gt; 'actorroles', 'actor');
  MyApp::Schema::Actor-&gt;many_to_many('roles' =&gt; 'actorroles', 'role');
  ## Using relationships
  $schema-&gt;resultset('Actor')-&gt;find({ id =&gt; 1})-&gt;roles();
  $schema-&gt;resultset('Role')-&gt;find({ id =&gt; 1 })-&gt;actorroles-&gt;search_related('actor', { Name =&gt; 'Fred' });
  $schema-&gt;resultset('Actor')-&gt;add_to_roles({ Name =&gt; 'Sherlock Holmes'});
</pre>
<p class="Pp">See DBIx::Class::Manual::Cookbook for more.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The word <i>Relationship</i> has a specific meaning in
    DBIx::Class, see the definition in the Glossary.</p>
<p class="Pp">This class provides methods to set up relationships between the
    tables in your database model. Relationships are the most useful and
    powerful technique that DBIx::Class provides. To create efficient database
    queries, create relationships between any and all tables that have something
    in common, for example if you have a table Authors:</p>
<p class="Pp"></p>
<pre>  ID  | Name | Age
 ------------------
   1  | Fred | 30
   2  | Joe  | 32
</pre>
<p class="Pp">and a table Books:</p>
<p class="Pp"></p>
<pre>  ID  | Author | Name
 --------------------
   1  |      1 | Rulers of the universe
   2  |      1 | Rulers of the galaxy
</pre>
<p class="Pp">Then without relationships, the method of getting all books by
    Fred goes like this:</p>
<p class="Pp"></p>
<pre> my $fred = $schema-&gt;resultset('Author')-&gt;find({ Name =&gt; 'Fred' });
 my $fredsbooks = $schema-&gt;resultset('Book')-&gt;search({ Author =&gt; $fred-&gt;ID });
</pre>
<p class="Pp">With a has_many relationship called &quot;books&quot; on Author
    (see below for details), we can do this instead:</p>
<p class="Pp"></p>
<pre> my $fredsbooks = $schema-&gt;resultset('Author')-&gt;find({ Name =&gt; 'Fred' })-&gt;books;
</pre>
<p class="Pp">Each relationship sets up an accessor method on the Result objects
    that represent the items of your table. From ResultSet objects, the
    relationships can be searched using the &quot;search_related&quot; method.
    In list context, each returns a list of Result objects for the related
    class, in scalar context, a new ResultSet representing the joined tables is
    returned. Thus, the calls can be chained to produce complex queries. Since
    the database is not actually queried until you attempt to retrieve the data
    for an actual item, no time is wasted producing them.</p>
<p class="Pp"></p>
<pre> my $cheapfredbooks = $schema-&gt;resultset('Author')-&gt;find({
   Name =&gt; 'Fred',
 })-&gt;books-&gt;search_related('prices', {
   Price =&gt; { '&lt;=' =&gt; '5.00' },
 });
</pre>
<p class="Pp">will produce a query something like:</p>
<p class="Pp"></p>
<pre> SELECT * FROM Author me
 LEFT JOIN Books books ON books.author = me.id
 LEFT JOIN Prices prices ON prices.book = books.id
 WHERE prices.Price &lt;= 5.00
</pre>
<p class="Pp">all without needing multiple fetches.</p>
<p class="Pp">Only the helper methods for setting up standard relationship types
    are documented here. For the basic, lower-level methods, and a description
    of all the useful *_related methods that you get for free, see
    DBIx::Class::Relationship::Base.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<p class="Pp">All helper methods are called similar to the following
  template:</p>
<p class="Pp"></p>
<pre>  __PACKAGE__-&gt;$method_name('rel_name', 'Foreign::Class', \%cond|\@cond|\&amp;cond?, \%attrs?);
</pre>
<p class="Pp">Both <span class="Li">&quot;cond&quot;</span> and
    <span class="Li">&quot;attrs&quot;</span> are optional. Pass
    <span class="Li">&quot;undef&quot;</span> for
    <span class="Li">&quot;cond&quot;</span> if you want to use the default
    value for it, but still want to set
    <span class="Li">&quot;attrs&quot;</span>.</p>
<p class="Pp">See &quot;condition&quot; in DBIx::Class::Relationship::Base for
    full documentation on definition of the
    <span class="Li">&quot;cond&quot;</span> argument.</p>
<p class="Pp">See &quot;attributes&quot; in DBIx::Class::Relationship::Base for
    documentation on the attributes that are allowed in the
    <span class="Li">&quot;attrs&quot;</span> argument.</p>
<section class="Ss">
<h2 class="Ss" id="belongs_to"><a class="permalink" href="#belongs_to">belongs_to</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:"><a class="permalink" href="#Arguments:">Arguments:
    $accessor_name, $related_class, $our_fk_column|\%cond|\@cond|\$cond?,
    \%attrs?</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Creates a relationship where the calling class stores the foreign
    class's primary key in one (or more) of the calling class columns. This
    relationship defaults to using <span class="Li">$accessor_name</span> as the
    column name in this class to resolve the join against the primary key from
    <span class="Li">$related_class</span>, unless
    <span class="Li">$our_fk_column</span> specifies the foreign key column in
    this class or <span class="Li">&quot;cond&quot;</span> specifies a reference
    to a join condition.</p>
<dl class="Bl-tag">
  <dt id="accessor_name"><a class="permalink" href="#accessor_name">accessor_name</a></dt>
  <dd>This argument is the name of the method you can call on a Result object to
      retrieve the instance of the foreign class matching this relationship.
      This is often called the <span class="Li">&quot;relation(ship)
      name&quot;</span>.
    <p class="Pp">Use this accessor_name in &quot;join&quot; in
        DBIx::Class::ResultSet or &quot;prefetch&quot; in DBIx::Class::ResultSet
        to join to the foreign table indicated by this relationship.</p>
  </dd>
  <dt id="related_class"><a class="permalink" href="#related_class">related_class</a></dt>
  <dd>This is the class name of the table referenced by the foreign key in this
      class.</dd>
  <dt id="our_fk_column"><a class="permalink" href="#our_fk_column">our_fk_column</a></dt>
  <dd>The column name on this class that contains the foreign key.
    <p class="Pp">OR</p>
  </dd>
  <dt id="cond"><a class="permalink" href="#cond">cond</a></dt>
  <dd>A hashref, arrayref or coderef specifying a custom join expression. For
      more info see &quot;condition&quot; in
    DBIx::Class::Relationship::Base.</dd>
</dl>
<p class="Pp"></p>
<pre>  # in a Book class (where Author has many Books)
  My::DBIC::Schema::Book-&gt;belongs_to(
    author =&gt;
    'My::DBIC::Schema::Author',
    'author_id'
  );
  # OR (same result)
  My::DBIC::Schema::Book-&gt;belongs_to(
    author =&gt;
    'My::DBIC::Schema::Author',
    { 'foreign.author_id' =&gt; 'self.author_id' }
  );
  # OR (similar result but uglier accessor name)
  My::DBIC::Schema::Book-&gt;belongs_to(
    author_id =&gt;
    'My::DBIC::Schema::Author'
  );
  # Usage
  my $author_obj = $book-&gt;author; # get author object
  $book-&gt;author( $new_author_obj ); # set author object
  $book-&gt;author_id(); # get the plain id
  # To retrieve the plain id if you used the ugly version:
  $book-&gt;get_column('author_id');
</pre>
<p class="Pp">If some of the foreign key columns are nullable you probably want
    to set the join_type attribute to <span class="Li">&quot;left&quot;</span>
    explicitly so that SQL expressing this relation is composed with a
    <span class="Li">&quot;LEFT JOIN&quot;</span> (as opposed to
    <span class="Li">&quot;INNER JOIN&quot;</span> which is default for
    &quot;belongs_to&quot; relationships). This ensures that relationship
    traversal works consistently in all situations. (i.e. resultsets involving
    join or prefetch). The modified declaration is shown below:</p>
<p class="Pp"></p>
<pre>  # in a Book class (where Author has_many Books)
  __PACKAGE__-&gt;belongs_to(
    author =&gt;
    'My::DBIC::Schema::Author',
    'author',
    { join_type =&gt; 'left' }
  );
</pre>
<p class="Pp">Cascading deletes are off by default on a
    <span class="Li">&quot;belongs_to&quot;</span> relationship. To turn them
    on, pass <span class="Li">&quot;cascade_delete =&gt; 1&quot;</span> in the
    <span class="Li">$attr</span> hashref.</p>
<p class="Pp">By default, DBIC will return undef and avoid querying the database
    if a <span class="Li">&quot;belongs_to&quot;</span> accessor is called when
    any part of the foreign key IS NULL. To disable this behavior, pass
    <span class="Li">&quot;undef_on_null_fk =&gt; 0&quot;</span> in the
    <span class="Li">&quot;\%attrs&quot;</span> hashref.</p>
<p class="Pp">NOTE: If you are used to Class::DBI relationships, this is the
    equivalent of <span class="Li">&quot;has_a&quot;</span>.</p>
<p class="Pp">See &quot;attributes&quot; in DBIx::Class::Relationship::Base for
    documentation on relationship methods and valid relationship attributes.
    Also see DBIx::Class::ResultSet for a list of standard resultset attributes
    which can be assigned to relationships as well.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="has_many"><a class="permalink" href="#has_many">has_many</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~2"><a class="permalink" href="#Arguments:~2">Arguments:
    $accessor_name, $related_class, $their_fk_column|\%cond|\@cond|\&amp;cond?,
    \%attrs?</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Creates a one-to-many relationship where the foreign class refers
    to this class's primary key. This relationship refers to zero or more
    records in the foreign table (e.g. a <span class="Li">&quot;LEFT
    JOIN&quot;</span>). This relationship defaults to using the end of this
    classes namespace as the foreign key in
    <span class="Li">$related_class</span> to resolve the join, unless
    <span class="Li">$their_fk_column</span> specifies the foreign key column in
    <span class="Li">$related_class</span> or
    <span class="Li">&quot;cond&quot;</span> specifies a reference to a join
    condition.</p>
<dl class="Bl-tag">
  <dt id="accessor_name~2"><a class="permalink" href="#accessor_name~2">accessor_name</a></dt>
  <dd>This argument is the name of the method you can call on a Result object to
      retrieve a resultset of the related class restricted to the ones related
      to the result object. In list context it returns the result objects. This
      is often called the <span class="Li">&quot;relation(ship)
      name&quot;</span>.
    <p class="Pp">Use this accessor_name in &quot;join&quot; in
        DBIx::Class::ResultSet or &quot;prefetch&quot; in DBIx::Class::ResultSet
        to join to the foreign table indicated by this relationship.</p>
  </dd>
  <dt id="related_class~2"><a class="permalink" href="#related_class~2">related_class</a></dt>
  <dd>This is the class name of the table which contains a foreign key column
      containing PK values of this class.</dd>
  <dt id="their_fk_column"><a class="permalink" href="#their_fk_column">their_fk_column</a></dt>
  <dd>The column name on the related class that contains the foreign key.
    <p class="Pp">OR</p>
  </dd>
  <dt id="cond~2"><a class="permalink" href="#cond~2">cond</a></dt>
  <dd>A hashref, arrayref or coderef specifying a custom join expression. For
      more info see &quot;condition&quot; in
    DBIx::Class::Relationship::Base.</dd>
</dl>
<p class="Pp"></p>
<pre>  # in an Author class (where Author has_many Books)
  # assuming related class is storing our PK in &quot;author_id&quot;
  My::DBIC::Schema::Author-&gt;has_many(
    books =&gt;
    'My::DBIC::Schema::Book',
    'author_id'
  );
  # OR (same result)
  My::DBIC::Schema::Author-&gt;has_many(
    books =&gt;
    'My::DBIC::Schema::Book',
    { 'foreign.author_id' =&gt; 'self.id' },
  );
  # OR (similar result, assuming related_class is storing our PK, in &quot;author&quot;)
  # (the &quot;author&quot; is guessed at from &quot;Author&quot; in the class namespace)
  My::DBIC::Schema::Author-&gt;has_many(
    books =&gt;
    'My::DBIC::Schema::Book',
  );
  # Usage
  # resultset of Books belonging to author
  my $booklist = $author-&gt;books;
  # resultset of Books belonging to author, restricted by author name
  my $booklist = $author-&gt;books({
    name =&gt; { LIKE =&gt; '%macaroni%' },
    { prefetch =&gt; [qw/book/],
  });
  # array of Book objects belonging to author
  my @book_objs = $author-&gt;books;
  # force resultset even in list context
  my $books_rs = $author-&gt;books;
  ( $books_rs ) = $obj-&gt;books_rs;
  # create a new book for this author, the relation fields are auto-filled
  $author-&gt;create_related('books', \%col_data);
  # alternative method for the above
  $author-&gt;add_to_books(\%col_data);
</pre>
<p class="Pp">Three methods are created when you create a has_many relationship.
    The first method is the expected accessor method,
    <span class="Li">&quot;$accessor_name()&quot;</span>. The second is almost
    exactly the same as the accessor method but &quot;_rs&quot; is added to the
    end of the method name, eg
    <span class="Li">&quot;$accessor_name_rs()&quot;</span>. This method works
    just like the normal accessor, except that it always returns a resultset,
    even in list context. The third method, named
    <span class="Li">&quot;add_to_$rel_name&quot;</span>, will also be added to
    your Row items; this allows you to insert new related items, using the same
    mechanism as in &quot;create_related&quot; in
    DBIx::Class::Relationship::Base.</p>
<p class="Pp">If you delete an object in a class with a
    <span class="Li">&quot;has_many&quot;</span> relationship, all the related
    objects will be deleted as well. To turn this behaviour off, pass
    <span class="Li">&quot;cascade_delete =&gt; 0&quot;</span> in the
    <span class="Li">$attr</span> hashref.</p>
<p class="Pp">The cascaded operations are performed after the requested delete
    or update, so if your database has a constraint on the relationship, it will
    have deleted/updated the related records or raised an exception before
    DBIx::Class gets to perform the cascaded operation.</p>
<p class="Pp">If you copy an object in a class with a
    <span class="Li">&quot;has_many&quot;</span> relationship, all the related
    objects will be copied as well. To turn this behaviour off, pass
    <span class="Li">&quot;cascade_copy =&gt; 0&quot;</span> in the
    <span class="Li">$attr</span> hashref. The behaviour defaults to
    <span class="Li">&quot;cascade_copy =&gt; 1&quot;</span>.</p>
<p class="Pp">See &quot;attributes&quot; in DBIx::Class::Relationship::Base for
    documentation on relationship methods and valid relationship attributes.
    Also see DBIx::Class::ResultSet for a list of standard resultset attributes
    which can be assigned to relationships as well.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="might_have"><a class="permalink" href="#might_have">might_have</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~3"><a class="permalink" href="#Arguments:~3">Arguments:
    $accessor_name, $related_class, $their_fk_column|\%cond|\@cond|\&amp;cond?,
    \%attrs?</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Creates an optional one-to-one relationship with a class. This
    relationship defaults to using <span class="Li">$accessor_name</span> as the
    foreign key in <span class="Li">$related_class</span> to resolve the join,
    unless <span class="Li">$their_fk_column</span> specifies the foreign key
    column in <span class="Li">$related_class</span> or
    <span class="Li">&quot;cond&quot;</span> specifies a reference to a join
    condition.</p>
<dl class="Bl-tag">
  <dt id="accessor_name~3"><a class="permalink" href="#accessor_name~3">accessor_name</a></dt>
  <dd>This argument is the name of the method you can call on a Result object to
      retrieve the instance of the foreign class matching this relationship.
      This is often called the <span class="Li">&quot;relation(ship)
      name&quot;</span>.
    <p class="Pp">Use this accessor_name in &quot;join&quot; in
        DBIx::Class::ResultSet or &quot;prefetch&quot; in DBIx::Class::ResultSet
        to join to the foreign table indicated by this relationship.</p>
  </dd>
  <dt id="related_class~3"><a class="permalink" href="#related_class~3">related_class</a></dt>
  <dd>This is the class name of the table which contains a foreign key column
      containing PK values of this class.</dd>
  <dt id="their_fk_column~2"><a class="permalink" href="#their_fk_column~2">their_fk_column</a></dt>
  <dd>The column name on the related class that contains the foreign key.
    <p class="Pp">OR</p>
  </dd>
  <dt id="cond~3"><a class="permalink" href="#cond~3">cond</a></dt>
  <dd>A hashref, arrayref or coderef specifying a custom join expression. For
      more info see &quot;condition&quot; in
    DBIx::Class::Relationship::Base.</dd>
</dl>
<p class="Pp"></p>
<pre>  # Author may have an entry in the pseudonym table
  My::DBIC::Schema::Author-&gt;might_have(
    pseudonym =&gt;
    'My::DBIC::Schema::Pseudonym',
    'author_id',
  );
  # OR (same result, assuming the related_class stores our PK)
  My::DBIC::Schema::Author-&gt;might_have(
    pseudonym =&gt;
    'My::DBIC::Schema::Pseudonym',
  );
  # OR (same result)
  My::DBIC::Schema::Author-&gt;might_have(
    pseudonym =&gt;
    'My::DBIC::Schema::Pseudonym',
    { 'foreign.author_id' =&gt; 'self.id' },
  );
  # Usage
  my $pname = $author-&gt;pseudonym; # to get the Pseudonym object
</pre>
<p class="Pp">If you update or delete an object in a class with a
    <span class="Li">&quot;might_have&quot;</span> relationship, the related
    object will be updated or deleted as well. To turn off this behavior, add
    <span class="Li">&quot;cascade_delete =&gt; 0&quot;</span> to the
    <span class="Li">$attr</span> hashref.</p>
<p class="Pp">The cascaded operations are performed after the requested delete
    or update, so if your database has a constraint on the relationship, it will
    have deleted/updated the related records or raised an exception before
    DBIx::Class gets to perform the cascaded operation.</p>
<p class="Pp">See &quot;attributes&quot; in DBIx::Class::Relationship::Base for
    documentation on relationship methods and valid relationship attributes.
    Also see DBIx::Class::ResultSet for a list of standard resultset attributes
    which can be assigned to relationships as well.</p>
<p class="Pp">Note that if you supply a condition on which to join, and the
    column in the current table allows nulls (i.e., has the
    <span class="Li">&quot;is_nullable&quot;</span> attribute set to a true
    value), than <span class="Li">&quot;might_have&quot;</span> will warn about
    this because it's naughty and you shouldn't do that. The warning will look
    something like:</p>
<p class="Pp"></p>
<pre>  &quot;might_have/has_one&quot; must not be on columns with is_nullable set to true (MySchema::SomeClass/key)
</pre>
<p class="Pp">If you must be naughty, you can suppress the warning by setting
    <span class="Li">&quot;DBIC_DONT_VALIDATE_RELS&quot;</span> environment
    variable to a true value. Otherwise, you probably just meant to use
    <span class="Li">&quot;DBIx::Class::Relationship/belongs_to&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="has_one"><a class="permalink" href="#has_one">has_one</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~4"><a class="permalink" href="#Arguments:~4">Arguments:
    $accessor_name, $related_class, $their_fk_column|\%cond|\@cond|\&amp;cond?,
    \%attrs?</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Creates a one-to-one relationship with a class. This relationship
    defaults to using <span class="Li">$accessor_name</span> as the foreign key
    in <span class="Li">$related_class</span> to resolve the join, unless
    <span class="Li">$their_fk_column</span> specifies the foreign key column in
    <span class="Li">$related_class</span> or
    <span class="Li">&quot;cond&quot;</span> specifies a reference to a join
    condition.</p>
<dl class="Bl-tag">
  <dt id="accessor_name~4"><a class="permalink" href="#accessor_name~4">accessor_name</a></dt>
  <dd>This argument is the name of the method you can call on a Result object to
      retrieve the instance of the foreign class matching this relationship.
      This is often called the <span class="Li">&quot;relation(ship)
      name&quot;</span>.
    <p class="Pp">Use this accessor_name in &quot;join&quot; in
        DBIx::Class::ResultSet or &quot;prefetch&quot; in DBIx::Class::ResultSet
        to join to the foreign table indicated by this relationship.</p>
  </dd>
  <dt id="related_class~4"><a class="permalink" href="#related_class~4">related_class</a></dt>
  <dd>This is the class name of the table which contains a foreign key column
      containing PK values of this class.</dd>
  <dt id="their_fk_column~3"><a class="permalink" href="#their_fk_column~3">their_fk_column</a></dt>
  <dd>The column name on the related class that contains the foreign key.
    <p class="Pp">OR</p>
  </dd>
  <dt id="cond~4"><a class="permalink" href="#cond~4">cond</a></dt>
  <dd>A hashref, arrayref or coderef specifying a custom join expression. For
      more info see &quot;condition&quot; in
    DBIx::Class::Relationship::Base.</dd>
</dl>
<p class="Pp"></p>
<pre>  # Every book has exactly one ISBN
  My::DBIC::Schema::Book-&gt;has_one(
    isbn =&gt;
    'My::DBIC::Schema::ISBN',
    'book_id',
  );
  # OR (same result, assuming related_class stores our PK)
  My::DBIC::Schema::Book-&gt;has_one(
    isbn =&gt;
    'My::DBIC::Schema::ISBN',
  );
  # OR (same result)
  My::DBIC::Schema::Book-&gt;has_one(
    isbn =&gt;
    'My::DBIC::Schema::ISBN',
    { 'foreign.book_id' =&gt; 'self.id' },
  );
  # Usage
  my $isbn_obj = $book-&gt;isbn; # to get the ISBN object
</pre>
<p class="Pp">Creates a one-to-one relationship with another class. This is just
    like <span class="Li">&quot;might_have&quot;</span>, except the implication
    is that the other object is always present. The only difference between
    <span class="Li">&quot;has_one&quot;</span> and
    <span class="Li">&quot;might_have&quot;</span> is that
    <span class="Li">&quot;has_one&quot;</span> uses an (ordinary) inner join,
    whereas <span class="Li">&quot;might_have&quot;</span> defaults to a left
    join.</p>
<p class="Pp">The has_one relationship should be used when a row in the table
    must have exactly one related row in another table. If the related row might
    not exist in the foreign table, use the &quot;might_have&quot; in
    DBIx::Class::Relationship relationship.</p>
<p class="Pp">In the above example, each Book in the database is associated with
    exactly one ISBN object.</p>
<p class="Pp">See &quot;attributes&quot; in DBIx::Class::Relationship::Base for
    documentation on relationship methods and valid relationship attributes.
    Also see DBIx::Class::ResultSet for a list of standard resultset attributes
    which can be assigned to relationships as well.</p>
<p class="Pp">Note that if you supply a condition on which to join, if the
    column in the current table allows nulls (i.e., has the
    <span class="Li">&quot;is_nullable&quot;</span> attribute set to a true
    value), than warnings might apply just as with &quot;might_have&quot; in
    DBIx::Class::Relationship.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="many_to_many"><a class="permalink" href="#many_to_many">many_to_many</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~5"><a class="permalink" href="#Arguments:~5">Arguments:
    $accessor_name, $link_rel_name, $foreign_rel_name, \%attrs?</a></dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li">&quot;many_to_many&quot;</span> is a
    <i>Relationship bridge</i> which has a specific meaning in DBIx::Class, see
    the definition in the Glossary.</p>
<p class="Pp"><span class="Li">&quot;many_to_many&quot;</span> is not strictly a
    relationship in its own right. Instead, it is a bridge between two
    resultsets which provide the same kind of convenience accessors as true
    relationships provide. Although the accessor will return a resultset or
    collection of objects just like has_many does, you cannot call
    <span class="Li">&quot;related_resultset&quot;</span> and similar methods
    which operate on true relationships.</p>
<dl class="Bl-tag">
  <dt id="accessor_name~5"><a class="permalink" href="#accessor_name~5">accessor_name</a></dt>
  <dd>This argument is the name of the method you can call on a Result object to
      retrieve the rows matching this relationship.
    <p class="Pp">On a many_to_many, unlike other relationships, this cannot be
        used in &quot;search&quot; in DBIx::Class::ResultSet to join tables. Use
        the relations bridged across instead.</p>
  </dd>
  <dt id="link_rel_name"><a class="permalink" href="#link_rel_name">link_rel_name</a></dt>
  <dd>This is the accessor_name from the has_many relationship we are bridging
      from.</dd>
  <dt id="foreign_rel_name"><a class="permalink" href="#foreign_rel_name">foreign_rel_name</a></dt>
  <dd>This is the accessor_name of the belongs_to relationship in the link table
      that we are bridging across (which gives us the table we are bridging
    to).</dd>
</dl>
<p class="Pp">To create a many_to_many relationship from Actor to Role:</p>
<p class="Pp"></p>
<pre>  My::DBIC::Schema::Actor-&gt;has_many( actor_roles =&gt;
                                     'My::DBIC::Schema::ActorRoles',
                                     'actor' );
  My::DBIC::Schema::ActorRoles-&gt;belongs_to( role =&gt;
                                            'My::DBIC::Schema::Role' );
  My::DBIC::Schema::ActorRoles-&gt;belongs_to( actor =&gt;
                                            'My::DBIC::Schema::Actor' );
  My::DBIC::Schema::Actor-&gt;many_to_many( roles =&gt; 'actor_roles',
                                         'role' );
</pre>
<p class="Pp">And, for the reverse relationship, from Role to Actor:</p>
<p class="Pp"></p>
<pre>  My::DBIC::Schema::Role-&gt;has_many( actor_roles =&gt;
                                    'My::DBIC::Schema::ActorRoles',
                                    'role' );
  My::DBIC::Schema::Role-&gt;many_to_many( actors =&gt; 'actor_roles', 'actor' );
</pre>
<p class="Pp">To add a role for your actor, and fill in the year of the role in
    the actor_roles table:</p>
<p class="Pp"></p>
<pre>  $actor-&gt;add_to_roles($role, { year =&gt; 1995 });
</pre>
<p class="Pp">In the above example, ActorRoles is the link table class, and Role
    is the foreign class. The <span class="Li">$link_rel_name</span> parameter
    is the name of the accessor for the has_many relationship from this table to
    the link table, and the <span class="Li">$foreign_rel_name</span> parameter
    is the accessor for the belongs_to relationship from the link table to the
    foreign table.</p>
<p class="Pp">To use many_to_many, existing relationships from the original
    table to the link table, and from the link table to the end table must
    already exist, these relation names are then used in the many_to_many
  call.</p>
<p class="Pp">In the above example, the Actor class will have 3 many_to_many
    accessor methods set: <span class="Li">&quot;roles&quot;</span>,
    <span class="Li">&quot;add_to_roles&quot;</span>,
    <span class="Li">&quot;set_roles&quot;</span>, and similarly named accessors
    will be created for the Role class for the
    <span class="Li">&quot;actors&quot;</span> many_to_many relationship.</p>
<p class="Pp">See &quot;attributes&quot; in DBIx::Class::Relationship::Base for
    documentation on relationship methods and valid relationship attributes.
    Also see DBIx::Class::ResultSet for a list of standard resultset attributes
    which can be assigned to relationships as well.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="FURTHER_QUESTIONS?"><a class="permalink" href="#FURTHER_QUESTIONS?">FURTHER
  QUESTIONS?</a></h1>
<p class="Pp">Check the list of additional DBIC resources.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This module is free software copyright by the DBIx::Class (DBIC)
    authors. You can redistribute it and/or modify it under the same terms as
    the DBIx::Class library.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-12-08</td>
    <td class="foot-os"><a href="..">perl v5.34.0</a></td>
  </tr>
</table>
</body>
</html>

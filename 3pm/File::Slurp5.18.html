<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>File::Slurp(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">File::Slurp(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">File::Slurp(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">File::Slurp - Simple and Efficient Reading/Writing/Modifying of
    Complete Files</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
  use File::Slurp;
</pre>
<p class="Pp"># read in a whole file into a scalar
  <br/>
   my <span class="Li">$text</span> = read_file( 'filename' ) ;</p>
<p class="Pp"># read in a whole file into an array of lines
  <br/>
   my <span class="Li">@lines</span> = read_file( 'filename' ) ;</p>
<p class="Pp"># write out a whole file from a scalar
  <br/>
   write_file( 'filename', <span class="Li">$text</span> ) ;</p>
<p class="Pp"># write out a whole file from an array of lines
  <br/>
   write_file( 'filename', <span class="Li">@lines</span> ) ;</p>
<p class="Pp"># Here is a simple and fast way to load and save a simple config
    file # made of key=value lines.
  <br/>
   my <span class="Li">%conf</span> = read_file(
    <span class="Li">$file_name</span> ) =~ /^(\w+)=(.*)$/mg ;
  <br/>
   write_file( <span class="Li">$file_name</span>, {atomic =&gt; 1}, map
    &quot;$_=$conf{$_}\n&quot;, keys <span class="Li">%conf</span> ) ;</p>
<p class="Pp"># insert text at the beginning of a file
  <br/>
   prepend_file( 'filename', <span class="Li">$text</span> ) ;</p>
<p class="Pp"># in-place edit to replace all 'foo' with 'bar' in file
  <br/>
   edit_file { s/foo/bar/g } 'filename' ;</p>
<p class="Pp"># in-place edit to delete all lines with 'foo' from file
  <br/>
   edit_file_lines sub { <span class="Li">$_</span> = '' if /foo/ }, 'filename'
    ;</p>
<p class="Pp"># read in a whole directory of file names (skipping . and ..)
  <br/>
   my <span class="Li">@files</span> = read_dir( '/path/to/dir' ) ;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module provides subs that allow you to read or write entire
    files with one simple call. They are designed to be simple to use, have
    flexible ways to pass in or get the file contents and to be very efficient.
    There is also a sub to read in all the files in a directory other than
    <span class="Li">&quot;.&quot;</span> and
    <span class="Li">&quot;..&quot;</span></p>
<p class="Pp">These slurp/spew subs work for files, pipes and sockets, stdio,
    pseudo-files, and the DATA handle. Read more about why slurping files is a
    good thing in the file 'slurp_article.pod' in the extras/ directory.</p>
<p class="Pp">If you are interested in how fast these calls work, check out the
    slurp_bench.pl program in the extras/ directory. It compares many different
    forms of slurping. You can select the I/O direction, context and file sizes.
    Use the --help option to see how to run it.</p>
<section class="Ss">
<h2 class="Ss"><b>read_file</b></h2>
<p class="Pp">This sub reads in an entire file and returns its contents to the
    caller. In scalar context it returns the entire file as a single scalar. In
    list context it will return a list of lines (using the current value of $/
    as the separator including support for paragraph mode when it is set to
  '').</p>
<p class="Pp"></p>
<pre>
  my $text = read_file( 'filename' ) ;
  my $bin = read_file( 'filename' { binmode =&gt; ':raw' } ) ;
  my @lines = read_file( 'filename' ) ;
  my $lines = read_file( 'filename', array_ref =&gt; 1 ) ;
</pre>
<p class="Pp">The first argument is the file to slurp in. If the next argument
    is a hash reference, then it is used as the options. Otherwise the rest of
    the argument list are is used as key/value options.</p>
<p class="Pp">If the file argument is a handle (if it is a ref and is an IO or
    GLOB object), then that handle is slurped in. This mode is supported so you
    slurp handles such as <span class="Li">&quot;DATA&quot;</span> and
    <span class="Li">&quot;STDIN&quot;</span>. See the test handle.t for an
    example that does <span class="Li">&quot;open( '-|' )&quot;</span> and the
    child process spews data to the parant which slurps it in. All of the
    options that control how the data is returned to the caller still work in
    this case.</p>
<p class="Pp">If the first argument is an overloaded object then its stringified
    value is used for the filename and that file is opened. This is a new
    feature in 9999.14. See the stringify.t test for an example.</p>
<p class="Pp">By default <span class="Li">&quot;read_file&quot;</span> returns
    an undef in scalar contex or a single undef in list context if it encounters
    an error. Those are both impossible to get with a clean read_file call which
    means you can check the return value and always know if you had an error.
    You can change how errors are handled with the
    <span class="Li">&quot;err_mode&quot;</span> option.</p>
<p class="Pp">Speed Note: If you call read_file and just get a scalar return
    value it is now optimized to handle shorter files. This is only used if no
    options are used, the file is shorter then 100k bytes, the filename is a
    plain scalar and a scalar file is returned. If you want the fastest
    slurping, use the <span class="Li">&quot;buf_ref&quot;</span> or
    <span class="Li">&quot;scalar_ref&quot;</span> options (see below)</p>
<p class="Pp">NOTE: as of version 9999.06, read_file works correctly on the
    <span class="Li">&quot;DATA&quot;</span> handle. It used to need a sysseek
    workaround but that is now handled when needed by the module itself.</p>
<p class="Pp">You can optionally request that
    <span class="Li">&quot;slurp()&quot;</span> is exported to your code. This
    is an alias for read_file and is meant to be forward compatible with Perl 6
    (which will have <i>slurp()</i> built-in).</p>
<p class="Pp">The options for <span class="Li">&quot;read_file&quot;</span>
  are:</p>
<p class="Pp"><i>binmode</i></p>
<p class="Pp">If you set the binmode option, then its value is passed to a call
    to binmode on the opened handle. You can use this to set the file to be read
    in binary mode, utf8, etc. See perldoc -f binmode for more.</p>
<p class="Pp"></p>
<pre>
        my $bin_data = read_file( $bin_file, binmode =&gt; ':raw' ) ;
        my $utf_text = read_file( $bin_file, binmode =&gt; ':utf8' ) ;
</pre>
<p class="Pp"><i>array_ref</i></p>
<p class="Pp">If this boolean option is set, the return value (only in scalar
    context) will be an array reference which contains the lines of the slurped
    file. The following two calls are equivalent:</p>
<p class="Pp"></p>
<pre>
        my $lines_ref = read_file( $bin_file, array_ref =&gt; 1 ) ;
        my $lines_ref = [ read_file( $bin_file ) ] ;
</pre>
<p class="Pp"><i>chomp</i></p>
<p class="Pp">If this boolean option is set, the lines are chomped. This only
    happens if you are slurping in a list context or using the
    <span class="Li">&quot;array_ref&quot;</span> option.</p>
<p class="Pp"><i>scalar_ref</i></p>
<p class="Pp">If this boolean option is set, the return value (only in scalar
    context) will be an scalar reference to a string which is the contents of
    the slurped file. This will usually be faster than returning the plain
    scalar. It will also save memory as it will not make a copy of the file to
    return. Run the extras/slurp_bench.pl script to see speed comparisons.</p>
<p class="Pp"></p>
<pre>
        my $text_ref = read_file( $bin_file, scalar_ref =&gt; 1 ) ;
</pre>
<p class="Pp"><i>buf_ref</i></p>
<p class="Pp">You can use this option to pass in a scalar reference and the
    slurped file contents will be stored in the scalar. This can be used in
    conjunction with any of the other options. This saves an extra copy of the
    slurped file and can lower ram usage vs returning the file. It is usually
    the fastest way to read a file into a scalar. Run the extras/slurp_bench.pl
    script to see speed comparisons.</p>
<p class="Pp"></p>
<pre>
        read_file( $bin_file, buf_ref =&gt; \$buffer ) ;
</pre>
<p class="Pp"><i>blk_size</i></p>
<p class="Pp">You can use this option to set the block size used when slurping
    from an already open handle (like \*STDIN). It defaults to 1MB.</p>
<p class="Pp"></p>
<pre>
        my $text_ref = read_file( $bin_file, blk_size =&gt; 10_000_000,
                                             array_ref =&gt; 1 ) ;
</pre>
<p class="Pp"><i>err_mode</i></p>
<p class="Pp">You can use this option to control how read_file behaves when an
    error occurs. This option defaults to 'croak'. You can set it to 'carp' or
    to 'quiet to have no special error handling. This code wants to carp and
    then read another file if it fails.</p>
<p class="Pp"></p>
<pre>
        my $text_ref = read_file( $file, err_mode =&gt; 'carp' ) ;
        unless ( $text_ref ) {

                # read a different file but croak if not found
                $text_ref = read_file( $another_file ) ;
        }
        
        # process ${$text_ref}
</pre>
</section>
<section class="Ss">
<h2 class="Ss"><b>write_file</b></h2>
<p class="Pp">This sub writes out an entire file in one call.</p>
<p class="Pp"></p>
<pre>
  write_file( 'filename', @data ) ;
</pre>
<p class="Pp">The first argument to
    <span class="Li">&quot;write_file&quot;</span> is the filename. The next
    argument is an optional hash reference and it contains key/values that can
    modify the behavior of <span class="Li">&quot;write_file&quot;</span>. The
    rest of the argument list is the data to be written to the file.</p>
<p class="Pp"></p>
<pre>
  write_file( 'filename', {append =&gt; 1 }, @data ) ;
  write_file( 'filename', {binmode =&gt; ':raw'}, $buffer ) ;
</pre>
<p class="Pp">As a shortcut if the first data argument is a scalar or array
    reference, it is used as the only data to be written to the file. Any
    following arguments in <span class="Li">@_</span> are ignored. This is a
    faster way to pass in the output to be written to the file and is equivalent
    to the <span class="Li">&quot;buf_ref&quot;</span> option of
    <span class="Li">&quot;read_file&quot;</span>. These following pairs are
    equivalent but the pass by reference call will be faster in most cases
    (especially with larger files).</p>
<p class="Pp"></p>
<pre>
  write_file( 'filename', \$buffer ) ;
  write_file( 'filename', $buffer ) ;

  write_file( 'filename', \@lines ) ;
  write_file( 'filename', @lines ) ;
</pre>
<p class="Pp">If the first argument is a handle (if it is a ref and is an IO or
    GLOB object), then that handle is written to. This mode is supported so you
    spew to handles such as \*STDOUT. See the test handle.t for an example that
    does <span class="Li">&quot;open( '-|' )&quot;</span> and child process
    spews data to the parent which slurps it in. All of the options that control
    how the data are passed into <span class="Li">&quot;write_file&quot;</span>
    still work in this case.</p>
<p class="Pp">If the first argument is an overloaded object then its stringified
    value is used for the filename and that file is opened. This is new feature
    in 9999.14. See the stringify.t test for an example.</p>
<p class="Pp">By default <span class="Li">&quot;write_file&quot;</span> returns
    1 upon successfully writing the file or undef if it encountered an error.
    You can change how errors are handled with the
    <span class="Li">&quot;err_mode&quot;</span> option.</p>
<p class="Pp">The options are:</p>
<p class="Pp"><i>binmode</i></p>
<p class="Pp">If you set the binmode option, then its value is passed to a call
    to binmode on the opened handle. You can use this to set the file to be read
    in binary mode, utf8, etc. See perldoc -f binmode for more.</p>
<p class="Pp"></p>
<pre>
        write_file( $bin_file, {binmode =&gt; ':raw'}, @data ) ;
        write_file( $bin_file, {binmode =&gt; ':utf8'}, $utf_text ) ;
</pre>
<p class="Pp"><i>perms</i></p>
<p class="Pp">The perms option sets the permissions of newly-created files. This
    value is modified by your process's umask and defaults to 0666 (same as
    sysopen).</p>
<p class="Pp">NOTE: this option is new as of File::Slurp version 9999.14;</p>
<p class="Pp"><i>buf_ref</i></p>
<p class="Pp">You can use this option to pass in a scalar reference which has
    the data to be written. If this is set then any data arguments (including
    the scalar reference shortcut) in <span class="Li">@_</span> will be
    ignored. These are equivalent:</p>
<p class="Pp"></p>
<pre>
        write_file( $bin_file, { buf_ref =&gt; \$buffer } ) ;
        write_file( $bin_file, \$buffer ) ;
        write_file( $bin_file, $buffer ) ;
</pre>
<p class="Pp"><i>atomic</i></p>
<p class="Pp">If you set this boolean option, the file will be written to in an
    atomic fashion. A temporary file name is created by appending the pid ($$)
    to the file name argument and that file is spewed to. After the file is
    closed it is renamed to the original file name (and rename is an atomic
    operation on most OS's). If the program using this were to crash in the
    middle of this, then the file with the pid suffix could be left behind.</p>
<p class="Pp"><i>append</i></p>
<p class="Pp">If you set this boolean option, the data will be written at the
    end of the current file. Internally this sets the sysopen mode flag
    O_APPEND.</p>
<p class="Pp"></p>
<pre>
        write_file( $file, {append =&gt; 1}, @data ) ;

 You
can import append_file and it does the same thing.
</pre>
<p class="Pp"><i>no_clobber</i></p>
<p class="Pp">If you set this boolean option, an existing file will not be
    overwritten.</p>
<p class="Pp"></p>
<pre>
        write_file( $file, {no_clobber =&gt; 1}, @data ) ;
</pre>
<p class="Pp"><i>err_mode</i></p>
<p class="Pp">You can use this option to control how
    <span class="Li">&quot;write_file&quot;</span> behaves when an error occurs.
    This option defaults to 'croak'. You can set it to 'carp' or to 'quiet' to
    have no error handling other than the return value. If the first call to
    <span class="Li">&quot;write_file&quot;</span> fails it will carp and then
    write to another file. If the second call to
    <span class="Li">&quot;write_file&quot;</span> fails, it will croak.</p>
<p class="Pp"></p>
<pre>
        unless ( write_file( $file, { err_mode =&gt; 'carp', \$data ) ;

                # write a different file but croak if not found
                write_file( $other_file, \$data ) ;
        }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="overwrite_file"><a class="permalink" href="#overwrite_file">overwrite_file</a></h2>
<p class="Pp">This sub is just a typeglob alias to write_file since write_file
    always overwrites an existing file. This sub is supported for backwards
    compatibility with the original version of this module. See write_file for
    its API and behavior.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="append_file"><a class="permalink" href="#append_file">append_file</a></h2>
<p class="Pp">This sub will write its data to the end of the file. It is a
    wrapper around write_file and it has the same API so see that for the full
    documentation. These calls are equivalent:</p>
<p class="Pp"></p>
<pre>
        append_file( $file, @data ) ;
        write_file( $file, {append =&gt; 1}, @data ) ;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="prepend_file"><a class="permalink" href="#prepend_file">prepend_file</a></h2>
<p class="Pp">This sub writes data to the beginning of a file. The previously
    existing data is written after that so the effect is prepending data in
    front of a file. It is a counterpart to the append_file sub in this module.
    It works by first using <span class="Li">&quot;read_file&quot;</span> to
    slurp in the file and then calling
    <span class="Li">&quot;write_file&quot;</span> with the new data and the
    existing file data.</p>
<p class="Pp">The first argument to
    <span class="Li">&quot;prepend_file&quot;</span> is the filename. The next
    argument is an optional hash reference and it contains key/values that can
    modify the behavior of <span class="Li">&quot;prepend_file&quot;</span>. The
    rest of the argument list is the data to be written to the file and that is
    passed to <span class="Li">&quot;write_file&quot;</span> as is (see that for
    allowed data).</p>
<p class="Pp">Only the <span class="Li">&quot;binmode&quot;</span> and
    <span class="Li">&quot;err_mode&quot;</span> options are supported. The
    <span class="Li">&quot;write_file&quot;</span> call has the
    <span class="Li">&quot;atomic&quot;</span> option set so you will always
    have a consistant file. See above for more about those options.</p>
<p class="Pp"><span class="Li">&quot;prepend_file&quot;</span> is not exported
    by default, you need to import it explicitly.</p>
<p class="Pp"></p>
<pre>
        use File::Slurp qw( prepend_file ) ;
        prepend_file( $file, $header ) ;
        prepend_file( $file, \@lines ) ;
        prepend_file( $file, { binmode =&gt; 'raw:'}, $bin_data ) ;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="edit_file,_edit_file_lines"><a class="permalink" href="#edit_file,_edit_file_lines">edit_file,
  edit_file_lines</a></h2>
<p class="Pp">These subs read in a file into <span class="Li">$_</span>, execute
    a code block which should modify <span class="Li">$_</span> and then write
    <span class="Li">$_</span> back to the file. The difference between them is
    that <span class="Li">&quot;edit_file&quot;</span> reads the whole file into
    <span class="Li">$_</span> and calls the code block one time. With
    <span class="Li">&quot;edit_file_lines&quot;</span> each line is read into
    <span class="Li">$_</span> and the code is called for each line. In both
    cases the code should modify <span class="Li">$_</span> if desired and it
    will be written back out. These subs are the equivalent of the -pi command
    line options of Perl but you can call them from inside your program and not
    fork out a process. They are in <span class="Li">@EXPORT_OK</span> so you
    need to request them to be imported on the use line or you can import both
    of them with:</p>
<p class="Pp"></p>
<pre>
        use File::Slurp qw( :edit ) ;
</pre>
<p class="Pp">The first argument to
    <span class="Li">&quot;edit_file&quot;</span> and
    <span class="Li">&quot;edit_file_lines&quot;</span> is a code block or a
    code reference. The code block is not followed by a comma (as with grep and
    map) but a code reference is followed by a comma. See the examples below for
    both styles. The next argument is the filename. The last argument is an
    optional hash reference and it contains key/values that can modify the
    behavior of <span class="Li">&quot;prepend_file&quot;</span>.</p>
<p class="Pp">Only the <span class="Li">&quot;binmode&quot;</span> and
    <span class="Li">&quot;err_mode&quot;</span> options are supported. The
    <span class="Li">&quot;write_file&quot;</span> call has the
    <span class="Li">&quot;atomic&quot;</span> option set so you will always
    have a consistant file. See above for more about those options.</p>
<p class="Pp">Each group of calls below show a Perl command line instance and
    the equivalent calls to <span class="Li">&quot;edit_file&quot;</span> and
    <span class="Li">&quot;edit_file_lines&quot;</span>.</p>
<p class="Pp"></p>
<pre>
        perl -0777 -pi -e 's/foo/bar/g' filename
        use File::Slurp qw( edit_file ) ;
        edit_file { s/foo/bar/g } 'filename' ;
        edit_file sub { s/foo/bar/g }, 'filename' ;
        edit_file \&amp;replace_foo, 'filename' ;
        sub replace_foo { s/foo/bar/g }

        perl -pi -e '$_ = &quot;&quot; if /foo/' filename
        use File::Slurp qw( edit_file_lines ) ;
        use File::Slurp ;
        edit_file_lines { $_ = '' if /foo/ } 'filename' ;
        edit_file_lines sub { $_ = '' if /foo/ }, 'filename' ;
        edit_file \&amp;delete_foo, 'filename' ;
        sub delete_foo { $_ = '' if /foo/ }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="read_dir"><a class="permalink" href="#read_dir">read_dir</a></h2>
<p class="Pp">This sub reads all the file names from directory and returns them
    to the caller but <span class="Li">&quot;.&quot;</span> and
    <span class="Li">&quot;..&quot;</span> are removed by default.</p>
<p class="Pp"></p>
<pre>
        my @files = read_dir( '/path/to/dir' ) ;
</pre>
<p class="Pp">The first argument is the path to the directory to read. If the
    next argument is a hash reference, then it is used as the options. Otherwise
    the rest of the argument list are is used as key/value options.</p>
<p class="Pp">In list context <span class="Li">&quot;read_dir&quot;</span>
    returns a list of the entries in the directory. In a scalar context it
    returns an array reference which has the entries.</p>
<p class="Pp"><i>err_mode</i></p>
<p class="Pp">If the <span class="Li">&quot;err_mode&quot;</span> option is set,
    it selects how errors are handled (see
    <span class="Li">&quot;err_mode&quot;</span> in
    <span class="Li">&quot;read_file&quot;</span> or
    <span class="Li">&quot;write_file&quot;</span>).</p>
<p class="Pp"><i>keep_dot_dot</i></p>
<p class="Pp">If this boolean option is set,
    <span class="Li">&quot;.&quot;</span> and
    <span class="Li">&quot;..&quot;</span> are not removed from the list of
    files.</p>
<p class="Pp"></p>
<pre>
        my @all_files = read_dir( '/path/to/dir', keep_dot_dot =&gt; 1 ) ;
</pre>
<p class="Pp"><i>prefix</i></p>
<p class="Pp">If this boolean option is set, the string &quot;$dir/&quot; is
    prefixed to each dir entry. This means you can directly use the results to
    open files. A common newbie mistake is not putting the directory in front of
    entries when opening themn.</p>
<p class="Pp"></p>
<pre>
        my @paths = read_dir( '/path/to/dir', prefix =&gt; 1 ) ;
</pre>
</section>
<section class="Ss">
<h2 class="Ss">EXPORT</h2>
<pre>
  These are exported by default or with
        use File::Slurp qw( :std ) ;

  read_file write_file overwrite_file append_file read_dir

  These are exported with
        use File::Slurp qw( :edit ) ;

  edit_file edit_file_lines

  You can get all subs in the module exported with 
        use File::Slurp qw( :all ) ;
</pre>
</section>
<section class="Ss">
<h2 class="Ss">LICENSE</h2>
<pre>
  Same as Perl.
</pre>
</section>
<section class="Ss">
<h2 class="Ss">SEE ALSO</h2>
<p class="Pp">An article on file slurping in extras/slurp_article.pod. There is
    also a benchmarking script in extras/slurp_bench.pl.</p>
</section>
<section class="Ss">
<h2 class="Ss">BUGS</h2>
<p class="Pp">If run under Perl 5.004, slurping from the DATA handle will fail
    as that requires B.pm which didn't get into core until 5.005.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Uri Guttman, &lt;uri AT stemsystems DOT com&gt;</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2011-05-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

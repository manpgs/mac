<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Pod::Simple(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Pod::Simple(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Pod::Simple(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Pod::Simple - framework for parsing Pod</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre> TODO
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Pod::Simple is a Perl library for parsing text in the Pod
    (&quot;plain old documentation&quot;) markup language that is typically used
    for writing documentation for Perl and for Perl modules. The Pod format is
    explained in perlpod; the most common formatter is called
    <span class="Li">&quot;perldoc&quot;</span>.</p>
<p class="Pp">Be sure to read &quot;ENCODING&quot; if your Pod contains
    non-ASCII characters.</p>
<p class="Pp">Pod formatters can use Pod::Simple to parse Pod documents and
    render them into plain text, HTML, or any number of other formats.
    Typically, such formatters will be subclasses of Pod::Simple, and so they
    will inherit its methods, like
    <span class="Li">&quot;parse_file&quot;</span>. But note that Pod::Simple
    doesn't understand and properly parse Perl itself, so if you have a file
    which contains a Perl program that has a multi-line quoted string which has
    lines that look like pod, Pod::Simple will treat them as pod. This can be
    avoided if the file makes these into indented here documents instead.</p>
<p class="Pp">If you're reading this document just because you have a
    Pod-processing subclass that you want to use, this document (plus the
    documentation for the subclass) is probably all you need to read.</p>
<p class="Pp">If you're reading this document because you want to write a
    formatter subclass, continue reading it and then read
    Pod::Simple::Subclassing, and then possibly even read perlpodspec (some of
    which is for parser-writers, but much of which is notes to
    formatter-writers).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MAIN_METHODS"><a class="permalink" href="#MAIN_METHODS">MAIN
  METHODS</a></h1>
<dl class="Bl-tag">
  <dt>&quot;$parser = <i>SomeClass</i>-&gt;new();&quot;</dt>
  <dd>This returns a new parser object, where
      <i></i><span class="Li"><i>&quot;SomeClass&quot;</i></span><i></i> is a
      subclass of Pod::Simple.</dd>
  <dt>&quot;$parser-&gt;output_fh( *OUT );&quot;</dt>
  <dd>This sets the filehandle that <span class="Li">$parser</span>'s output
      will be written to. You can pass <span class="Li">*STDOUT</span> or
      <span class="Li">*STDERR</span>, otherwise you should probably do
      something like this:
    <p class="Pp"></p>
    <pre>    my $outfile = &quot;output.txt&quot;;
    open TXTOUT, &quot;&gt;$outfile&quot; or die &quot;Can't write to $outfile: $!&quot;;
    $parser-&gt;output_fh(*TXTOUT);
    </pre>
    <p class="Pp">...before you call one of the
        <span class="Li">&quot;$parser-&gt;parse_</span><span class="Li"><i>whatever</i></span><span class="Li">&quot;</span>
        methods.</p>
  </dd>
  <dt>&quot;$parser-&gt;output_string( \$somestring );&quot;</dt>
  <dd>This sets the string that <span class="Li">$parser</span>'s output will be
      sent to, instead of any filehandle.</dd>
  <dt>&quot;$parser-&gt;parse_file( <i>$some_filename</i> );&quot;</dt>
  <dd></dd>
  <dt>&quot;$parser-&gt;parse_file( *INPUT_FH );&quot;</dt>
  <dd>This reads the Pod content of the file (or filehandle) that you specify,
      and processes it with that <span class="Li">$parser</span> object,
      according to however <span class="Li">$parser</span>'s class works, and
      according to whatever parser options you have set up for this
      <span class="Li">$parser</span> object.</dd>
  <dt>&quot;$parser-&gt;parse_string_document( <i>$all_content</i> );&quot;</dt>
  <dd>This works just like <span class="Li">&quot;parse_file&quot;</span> except
      that it reads the Pod content not from a file, but from a string that you
      have already in memory.</dd>
  <dt>&quot;$parser-&gt;parse_lines( <i>...@lines...</i>, undef );&quot;</dt>
  <dd>This processes the lines in <span class="Li">@lines</span> (where each
      list item must be a defined value, and must contain exactly one line of
      content -- so no items like <span class="Li">&quot;foo\nbar&quot;</span>
      are allowed). The final <span class="Li">&quot;undef&quot;</span> is used
      to indicate the end of document being parsed.
    <p class="Pp">The other
        <span class="Li">&quot;parser_</span><span class="Li"><i>whatever</i></span><span class="Li">&quot;</span>
        methods are meant to be called only once per
        <span class="Li">$parser</span> object; but
        <span class="Li">&quot;parse_lines&quot;</span> can be called as many
        times per <span class="Li">$parser</span> object as you want, as long as
        the last call (and only the last call) ends with an
        <span class="Li">&quot;undef&quot;</span> value.</p>
  </dd>
  <dt>&quot;$parser-&gt;content_seen&quot;</dt>
  <dd>This returns true only if there has been any real content seen for this
      document. Returns false in cases where the document contains content, but
      does not make use of any Pod markup.</dd>
  <dt>&quot;<i>SomeClass</i>-&gt;filter( <i>$filename</i> );&quot;</dt>
  <dd></dd>
  <dt>&quot;<i>SomeClass</i>-&gt;filter( <i>*INPUT_FH</i> );&quot;</dt>
  <dd></dd>
  <dt>&quot;<i>SomeClass</i>-&gt;filter( <i>\$document_content</i> );&quot;</dt>
  <dd>This is a shortcut method for creating a new parser object, setting the
      output handle to STDOUT, and then processing the specified file (or
      filehandle, or in-memory document). This is handy for one-liners like
      this:
    <p class="Pp"></p>
    <pre>  perl -MPod::Simple::Text -e &quot;Pod::Simple::Text-&gt;filter('thingy.pod')&quot;
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SECONDARY_METHODS"><a class="permalink" href="#SECONDARY_METHODS">SECONDARY
  METHODS</a></h1>
<p class="Pp">Some of these methods might be of interest to general users, as
    well as of interest to formatter-writers.</p>
<p class="Pp">Note that the general pattern here is that the accessor-methods
    read the attribute's value with <span class="Li">&quot;$value =
    $parser-&gt;</span><span class="Li"><i>attribute</i></span><span class="Li">&quot;</span>
    and set the attribute's value with
    <span class="Li">&quot;$parser-&gt;</span><span class="Li"><i>attribute</i></span><span class="Li">(</span><span class="Li"><i>newvalue</i></span><span class="Li">)&quot;</span>.
    For each accessor, I typically only mention one syntax or another, based on
    which I think you are actually most likely to use.</p>
<dl class="Bl-tag">
  <dt>&quot;$parser-&gt;parse_characters( <i>SOMEVALUE</i> )&quot;</dt>
  <dd>The Pod parser normally expects to read octets and to convert those octets
      to characters based on the <span class="Li">&quot;=encoding&quot;</span>
      declaration in the Pod source. Set this option to a true value to indicate
      that the Pod source is already a Perl character stream. This tells the
      parser to ignore any <span class="Li">&quot;=encoding&quot;</span> command
      and to skip all the code paths involving decoding octets.</dd>
  <dt>&quot;$parser-&gt;no_whining( <i>SOMEVALUE</i> )&quot;</dt>
  <dd>If you set this attribute to a true value, you will suppress the parser's
      complaints about irregularities in the Pod coding. By default, this
      attribute's value is false, meaning that irregularities will be reported.
    <p class="Pp">Note that turning this attribute to true won't suppress one or
        two kinds of complaints about rarely occurring unrecoverable errors.</p>
  </dd>
  <dt>&quot;$parser-&gt;no_errata_section( <i>SOMEVALUE</i> )&quot;</dt>
  <dd>If you set this attribute to a true value, you will stop the parser from
      generating a &quot;POD ERRORS&quot; section at the end of the document. By
      default, this attribute's value is false, meaning that an errata section
      will be generated, as necessary.</dd>
  <dt>&quot;$parser-&gt;complain_stderr( <i>SOMEVALUE</i> )&quot;</dt>
  <dd>If you set this attribute to a true value, it will send reports of parsing
      errors to STDERR. By default, this attribute's value is false, meaning
      that no output is sent to STDERR.
    <p class="Pp">Setting <span class="Li">&quot;complain_stderr&quot;</span>
        also sets <span class="Li">&quot;no_errata_section&quot;</span>.</p>
  </dd>
  <dt>&quot;$parser-&gt;source_filename&quot;</dt>
  <dd>This returns the filename that this parser object was set to read
    from.</dd>
  <dt>&quot;$parser-&gt;doc_has_started&quot;</dt>
  <dd>This returns true if <span class="Li">$parser</span> has read from a
      source, and has seen Pod content in it.</dd>
  <dt>&quot;$parser-&gt;source_dead&quot;</dt>
  <dd>This returns true if <span class="Li">$parser</span> has read from a
      source, and come to the end of that source.</dd>
  <dt>&quot;$parser-&gt;strip_verbatim_indent( <i>SOMEVALUE</i> )&quot;</dt>
  <dd>The perlpod spec for a Verbatim paragraph is &quot;It should be reproduced
      exactly...&quot;, which means that the whitespace you've used to indent
      your verbatim blocks will be preserved in the output. This can be annoying
      for outputs such as HTML, where that whitespace will remain in front of
      every line. It's an unfortunate case where syntax is turned into
      semantics.
    <p class="Pp">If the POD you're parsing adheres to a consistent indentation
        policy, you can have such indentation stripped from the beginning of
        every line of your verbatim blocks. This method tells Pod::Simple what
        to strip. For two-space indents, you'd use:</p>
    <p class="Pp"></p>
    <pre>  $parser-&gt;strip_verbatim_indent('  ');
    </pre>
    <p class="Pp">For tab indents, you'd use a tab character:</p>
    <p class="Pp"></p>
    <pre>  $parser-&gt;strip_verbatim_indent(&quot;\t&quot;);
    </pre>
    <p class="Pp">If the POD is inconsistent about the indentation of verbatim
        blocks, but you have figured out a heuristic to determine how much a
        particular verbatim block is indented, you can pass a code reference
        instead. The code reference will be executed with one argument, an array
        reference of all the lines in the verbatim block, and should return the
        value to be stripped from each line. For example, if you decide that
        you're fine to use the first line of the verbatim block to set the
        standard for indentation of the rest of the block, you can look at the
        first line and return the appropriate value, like so:</p>
    <p class="Pp"></p>
    <pre>  $new-&gt;strip_verbatim_indent(sub {
      my $lines = shift;
      (my $indent = $lines-&gt;[0]) =~ s/\S.*//;
      return $indent;
  });
    </pre>
    <p class="Pp">If you'd rather treat each line individually, you can do that,
        too, by just transforming them in-place in the code reference and
        returning <span class="Li">&quot;undef&quot;</span>. Say that you don't
        want <i>any</i> lines indented. You can do something like this:</p>
    <p class="Pp"></p>
    <pre>  $new-&gt;strip_verbatim_indent(sub {
      my $lines = shift;
      sub { s/^\s+// for @{ $lines },
      return undef;
  });
    </pre>
  </dd>
  <dt>&quot;$parser-&gt;expand_verbatim_tabs( <i>n</i> )&quot;</dt>
  <dd>Default: 8
    <p class="Pp">If after any stripping of indentation in verbatim blocks,
        there remain tabs, this method call indicates what to do with them.
        <span class="Li">0</span> means leave them as tabs, any other number
        indicates that each tab is to be translated so as to have tab stops
        every <span class="Li">&quot;n&quot;</span> columns.</p>
    <p class="Pp">This is independent of other methods (except that it operates
        after any verbatim input stripping is done).</p>
    <p class="Pp">Like the other methods, the input parameter is not checked for
        validity. <span class="Li">&quot;undef&quot;</span> or containing
        non-digits has the same effect as 8.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="TERTIARY_METHODS"><a class="permalink" href="#TERTIARY_METHODS">TERTIARY
  METHODS</a></h1>
<dl class="Bl-tag">
  <dt>&quot;$parser-&gt;abandon_output_fh()&quot;</dt>
  <dd>Cancel output to the file handle. Any POD read by the
      <span class="Li">$parser</span> is not effected.</dd>
  <dt>&quot;$parser-&gt;abandon_output_string()&quot;</dt>
  <dd>Cancel output to the output string. Any POD read by the
      <span class="Li">$parser</span> is not effected.</dd>
  <dt>&quot;$parser-&gt;accept_code( @codes )&quot;</dt>
  <dd>Alias for accept_codes.</dd>
  <dt>&quot;$parser-&gt;accept_codes( @codes )&quot;</dt>
  <dd>Allows <span class="Li">$parser</span> to accept a list of
      &quot;Formatting Codes&quot; in perlpod. This can be used to implement
      user-defined codes.</dd>
  <dt>&quot;$parser-&gt;accept_directive_as_data( @directives )&quot;</dt>
  <dd>Allows <span class="Li">$parser</span> to accept a list of directives for
      data paragraphs. A directive is the label of a &quot;Command
      Paragraph&quot; in perlpod. A data paragraph is one delimited by
      <span class="Li">&quot;=begin/=for/=end&quot;</span> directives. This can
      be used to implement user-defined directives.</dd>
  <dt>&quot;$parser-&gt;accept_directive_as_processed( @directives )&quot;</dt>
  <dd>Allows <span class="Li">$parser</span> to accept a list of directives for
      processed paragraphs. A directive is the label of a &quot;Command
      Paragraph&quot; in perlpod. A processed paragraph is also known as
      &quot;Ordinary Paragraph&quot; in perlpod. This can be used to implement
      user-defined directives.</dd>
  <dt>&quot;$parser-&gt;accept_directive_as_verbatim( @directives )&quot;</dt>
  <dd>Allows <span class="Li">$parser</span> to accept a list of directives for
      &quot;Verbatim Paragraph&quot; in perlpod. A directive is the label of a
      &quot;Command Paragraph&quot; in perlpod. This can be used to implement
      user-defined directives.</dd>
  <dt>&quot;$parser-&gt;accept_target( @targets )&quot;</dt>
  <dd>Alias for accept_targets.</dd>
  <dt>&quot;$parser-&gt;accept_target_as_text( @targets )&quot;</dt>
  <dd>Alias for accept_targets_as_text.</dd>
  <dt>&quot;$parser-&gt;accept_targets( @targets )&quot;</dt>
  <dd>Accepts targets for <span class="Li">&quot;=begin/=for/=end&quot;</span>
      sections of the POD.</dd>
  <dt>&quot;$parser-&gt;accept_targets_as_text( @targets )&quot;</dt>
  <dd>Accepts targets for <span class="Li">&quot;=begin/=for/=end&quot;</span>
      sections that should be parsed as POD. For details, see &quot;About Data
      Paragraphs&quot; in perlpodspec.</dd>
  <dt>&quot;$parser-&gt;any_errata_seen()&quot;</dt>
  <dd>Used to check if any errata was seen.
    <p class="Pp"><i>Example:</i></p>
    <p class="Pp"></p>
    <pre>  die &quot;too many errors\n&quot; if $parser-&gt;any_errata_seen();
    </pre>
  </dd>
  <dt>&quot;$parser-&gt;errata_seen()&quot;</dt>
  <dd>Returns a hash reference of all errata seen, both whines and screams. The
      hash reference's keys are the line number and the value is an array
      reference of the errors for that line.
    <p class="Pp"><i>Example:</i></p>
    <p class="Pp"></p>
    <pre>  if ( $parser-&gt;any_errata_seen() ) {
     $logger-&gt;log( $parser-&gt;errata_seen() );
  }
    </pre>
  </dd>
  <dt>&quot;$parser-&gt;detected_encoding()&quot;</dt>
  <dd>Return the encoding corresponding to
      <span class="Li">&quot;=encoding&quot;</span>, but only if the encoding
      was recognized and handled.</dd>
  <dt>&quot;$parser-&gt;encoding()&quot;</dt>
  <dd>Return encoding of the document, even if the encoding is not correctly
      handled.</dd>
  <dt>&quot;$parser-&gt;parse_from_file( $source, $to )&quot;</dt>
  <dd>Parses from <span class="Li">$source</span> file to
      <span class="Li">$to</span> file. Similar to &quot;parse_from_file&quot;
      in Pod::Parser.</dd>
  <dt>&quot;$parser-&gt;scream( @error_messages )&quot;</dt>
  <dd>Log an error that can't be ignored.</dd>
  <dt>&quot;$parser-&gt;unaccept_code( @codes )&quot;</dt>
  <dd>Alias for unaccept_codes.</dd>
  <dt>&quot;$parser-&gt;unaccept_codes( @codes )&quot;</dt>
  <dd>Removes <span class="Li">@codes</span> as valid codes for the parse.</dd>
  <dt>&quot;$parser-&gt;unaccept_directive( @directives )&quot;</dt>
  <dd>Alias for unaccept_directives.</dd>
  <dt>&quot;$parser-&gt;unaccept_directives( @directives )&quot;</dt>
  <dd>Removes <span class="Li">@directives</span> as valid directives for the
      parse.</dd>
  <dt>&quot;$parser-&gt;unaccept_target( @targets )&quot;</dt>
  <dd>Alias for unaccept_targets.</dd>
  <dt>&quot;$parser-&gt;unaccept_targets( @targets )&quot;</dt>
  <dd>Removes <span class="Li">@targets</span> as valid targets for the
    parse.</dd>
  <dt>&quot;$parser-&gt;version_report()&quot;</dt>
  <dd>Returns a string describing the version.</dd>
  <dt>&quot;$parser-&gt;whine( @error_messages )&quot;</dt>
  <dd>Log an error unless <span class="Li">&quot;$parser-&gt;no_whining( TRUE
      );&quot;</span>.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="ENCODING"><a class="permalink" href="#ENCODING">ENCODING</a></h1>
<p class="Pp">The Pod::Simple parser expects to read <b>octets</b>. The parser
    will decode the octets into Perl's internal character string representation
    using the value of the <span class="Li">&quot;=encoding&quot;</span>
    declaration in the POD source.</p>
<p class="Pp">If the POD source does not include an
    <span class="Li">&quot;=encoding&quot;</span> declaration, the parser will
    attempt to guess the encoding (selecting one of UTF-8 or CP 1252) by
    examining the first non-ASCII bytes and applying the heuristic described in
    perlpodspec. (If the POD source contains only ASCII bytes, the encoding is
    assumed to be ASCII.)</p>
<p class="Pp">If you set the
    <span class="Li">&quot;parse_characters&quot;</span> option to a true value
    the parser will expect characters rather than octets; will ignore any
    <span class="Li">&quot;=encoding&quot;</span>; and will make no attempt to
    decode the input.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Pod::Simple::Subclassing</p>
<p class="Pp">perlpod</p>
<p class="Pp">perlpodspec</p>
<p class="Pp">Pod::Escapes</p>
<p class="Pp">perldoc</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
<p class="Pp">Questions or discussion about POD and Pod::Simple should be sent
    to the pod-people@perl.org mail list. Send an empty email to
    pod-people-subscribe@perl.org to subscribe.</p>
<p class="Pp">This module is managed in an open GitHub repository,
    &lt;https://github.com/perl-pod/pod-simple/&gt;. Feel free to fork and
    contribute, or to clone &lt;git://github.com/perl-pod/pod-simple.git&gt; and
    send patches!</p>
<p class="Pp">Please use
    &lt;https://github.com/perl-pod/pod-simple/issues/new&gt; to file a bug
    report.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_DISCLAIMERS"><a class="permalink" href="#COPYRIGHT_AND_DISCLAIMERS">COPYRIGHT
  AND DISCLAIMERS</a></h1>
<p class="Pp">Copyright (c) 2002 Sean M. Burke.</p>
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">This program is distributed in the hope that it will be useful,
    but without any warranty; without even the implied warranty of
    merchantability or fitness for a particular purpose.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Pod::Simple was created by Sean M. Burke &lt;sburke@cpan.org&gt;.
    But don't bother him, he's retired.</p>
<p class="Pp">Pod::Simple is maintained by:</p>
<ul class="Bl-bullet">
  <li>Allison Randal <span class="Li">&quot;allison@perl.org&quot;</span></li>
  <li>Hans Dieter Pearcey <span class="Li">&quot;hdp@cpan.org&quot;</span></li>
  <li>David E. Wheeler
    <span class="Li">&quot;dwheeler@cpan.org&quot;</span></li>
  <li>Karl Williamson <span class="Li">&quot;khw@cpan.org&quot;</span></li>
</ul>
<p class="Pp">Documentation has been contributed by:</p>
<ul class="Bl-bullet">
  <li>Gabor Szabo <span class="Li">&quot;szabgab@gmail.com&quot;</span></li>
  <li>Shawn H Corey <span class="Li">&quot;SHCOREY at cpan.org&quot;</span></li>
</ul>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-06-14</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

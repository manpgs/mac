<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Moose::Cookbook::Extending::ExtensionOverview(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Moose::Cookbook::Extending::ExtensionOverview(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Moose::Cookbook::Extending::ExtensionOverview(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Moose::Cookbook::Extending::ExtensionOverview - Moose extension
    overview</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 2.2012</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Moose provides several ways in which extensions can hook into
    Moose and change its behavior. Moose also has a lot of behavior that can be
    changed. This recipe will provide an overview of each extension method and
    give you some recommendations on what tools to use.</p>
<p class="Pp">If you haven't yet read the recipes on metaclasses, go read those
    first. You can't write Moose extensions without understanding the
    metaclasses, and those recipes also demonstrate some basic extension
    mechanisms, such as metaclass subclasses and traits.</p>
<section class="Ss">
<h2 class="Ss" id="Playing_Nice_With_Others"><a class="permalink" href="#Playing_Nice_With_Others">Playing
  Nice With Others</a></h2>
<p class="Pp">One of the goals of this overview is to help you build extensions
    that cooperate well with other extensions. This is especially important if
    you plan to release your extension to CPAN.</p>
<p class="Pp">Moose comes with several modules that exist to help your write
    cooperative extensions. These are Moose::Exporter and Moose::Util::MetaRole.
    By using these two modules, you will ensure that your extension works with
    both the Moose core features and any other CPAN extension using those
    modules.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="PARTS_OF_Moose_YOU_CAN_EXTEND"><a class="permalink" href="#PARTS_OF_Moose_YOU_CAN_EXTEND">PARTS
  OF Moose YOU CAN EXTEND</a></h1>
<p class="Pp">The types of things you might want to do in Moose extensions fall
    into a few broad categories.</p>
<section class="Ss">
<h2 class="Ss" id="Metaclass_Extensions"><a class="permalink" href="#Metaclass_Extensions">Metaclass
  Extensions</a></h2>
<p class="Pp">One way of extending Moose is by extending one or more Moose
    metaclasses. For example, in Moose::Cookbook::Meta::Table_MetaclassTrait we
    saw a metaclass role that added a <span class="Li">&quot;table&quot;</span>
    attribute to the metaclass. If you were writing an ORM, this would be a
    logical extension.</p>
<p class="Pp">Many of the Moose extensions on CPAN work by providing an
    attribute metaclass role. For example, the MooseX::Aliases module provides
    an attribute metaclass trait that lets you specify aliases to install for
    methods and attribute accessors.</p>
<p class="Pp">A metaclass extension can be packaged as a role/trait or a
    subclass. If you can, we recommend using traits instead of subclasses, since
    it's much easier to combine disparate traits than it is to combine a bunch
    of subclasses.</p>
<p class="Pp">When your extensions are implemented as roles, you can apply them
    with the Moose::Util::MetaRole module.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Providing_Sugar_Functions"><a class="permalink" href="#Providing_Sugar_Functions">Providing
  Sugar Functions</a></h2>
<p class="Pp">As part of a metaclass extension, you may also want to provide
    some sugar functions, just like Moose.pm does. Moose provides a helper
    module called Moose::Exporter that makes this much simpler. We will be use
    Moose::Exporter in several of the extension recipes.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Object_Class_Extensions"><a class="permalink" href="#Object_Class_Extensions">Object
  Class Extensions</a></h2>
<p class="Pp">Another common Moose extension technique is to change the default
    object class's behavior. As with metaclass extensions, this can be done with
    a role/trait or with a subclass. For example, MooseX::StrictConstructor
    extension applies a trait that makes the constructor reject arguments which
    don't match its attributes.</p>
<p class="Pp">Object class extensions often include metaclass extensions as
    well. In particular, if you want your object extension to work when a class
    is made immutable, you may need to modify the behavior of some or all of the
    Moose::Meta::Instance, Moose::Meta::Method::Constructor, and
    Moose::Meta::Method::Destructor objects.</p>
<p class="Pp">The Moose::Util::MetaRole module lets you apply roles to the base
    object class, as well as the meta classes just mentioned.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Providing_a_Role"><a class="permalink" href="#Providing_a_Role">Providing
  a Role</a></h2>
<p class="Pp">Some extensions come in the form of a role for you to consume. The
    MooseX::Object::Pluggable extension is a great example of this. In fact,
    despite the <span class="Li">&quot;MooseX&quot;</span> name, it does not
    actually change anything about Moose's behavior. Instead, it is just a role
    that an object which wants to be pluggable can consume.</p>
<p class="Pp">If you are implementing this sort of extension, you don't need to
    do anything special. You simply create a role and document that it should be
    used via the normal <span class="Li">&quot;with&quot;</span> sugar:</p>
<p class="Pp"></p>
<pre>
   package MyApp::User;

   use Moose;

   with 'My::Role';
</pre>
<p class="Pp">Don't use &quot;MooseX&quot; in the name for such packages.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="New_Types"><a class="permalink" href="#New_Types">New
  Types</a></h2>
<p class="Pp">Another common Moose extension is a new type for the Moose type
    system. In this case, you simply create a type in your module. When people
    load your module, the type is created, and they can refer to it by name
    after that. The MooseX::Types::URI and MooseX::Types::DateTime distributions
    are two good examples of how this works. These both build on top of the
    MooseX::Types extension.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ROLES_VS_TRAITS_VS_SUBCLASSES"><a class="permalink" href="#ROLES_VS_TRAITS_VS_SUBCLASSES">ROLES
  VS TRAITS VS SUBCLASSES</a></h1>
<p class="Pp">It is important to understand that <b>roles and traits are the
    same thing</b>. A trait is simply a role applied to a instance. The only
    thing that may distinguish the two is that a trait can be packaged in a way
    that lets Moose resolve a short name to a class name. In other words, with a
    trait, the caller can refer to it by a short name like &quot;Big&quot;, and
    Moose will resolve it to a class like
    <span class="Li">&quot;MooseX::Embiggen::Meta::Attribute::Role::Big&quot;</span>.</p>
<p class="Pp">See Moose::Cookbook::Meta::Labeled_AttributeTrait and
    Moose::Cookbook::Meta::Table_MetaclassTrait for examples of traits in
    action. In particular, both of these recipes demonstrate the trait
    resolution mechanism.</p>
<p class="Pp">Implementing an extension as a (set of) metaclass or base object
    role(s) will make your extension more cooperative. It is hard for an
    end-user to effectively combine together multiple metaclass subclasses, but
    it is very easy to combine roles.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="USING_YOUR_EXTENSION"><a class="permalink" href="#USING_YOUR_EXTENSION">USING
  YOUR EXTENSION</a></h1>
<p class="Pp">There are a number of ways in which an extension can be applied.
    In some cases you can provide multiple ways of consuming your extension.</p>
<section class="Ss">
<h2 class="Ss" id="Extensions_as_Metaclass_Traits"><a class="permalink" href="#Extensions_as_Metaclass_Traits">Extensions
  as Metaclass Traits</a></h2>
<p class="Pp">If your extension is available as a trait, you can ask end users
    to simply specify it in a list of traits. Currently, this only works for
    (class) metaclass and attribute metaclass traits:</p>
<p class="Pp"></p>
<pre>
  use Moose -traits =&gt; [ 'Big', 'Blue' ];

  has 'animal' =&gt; (
      traits =&gt; [ 'Big', 'Blue' ],
      ...
  );
</pre>
<p class="Pp">If your extension applies to any other metaclass, or the object
    base class, you cannot use the trait mechanism.</p>
<p class="Pp">The benefit of the trait mechanism is that is very easy to see
    where a trait is applied in the code, and consumers have fine-grained
    control over what the trait applies to. This is especially true for
    attribute traits, where you can apply the trait to just one attribute in a
    class.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Extensions_as_Metaclass_(and_Base_Object)_Roles"><a class="permalink" href="#Extensions_as_Metaclass_(and_Base_Object)_Roles">Extensions
  as Metaclass (and Base Object) Roles</a></h2>
<p class="Pp">Implementing your extensions as metaclass roles makes your
    extensions easy to apply, and cooperative with other role-based extensions
    for metaclasses.</p>
<p class="Pp">Just as with a subclass, you will probably want to package your
    extensions for consumption with a single module that uses Moose::Exporter.
    However, in this case, you will use Moose::Util::MetaRole to apply all of
    your roles. The advantage of using this module is that <i>it preserves any
    subclassing or roles</i> <i>already applied to the user's metaclasses</i>.
    This means that your extension is cooperative <i>by default</i>, and
    consumers of your extension can easily use it with other role-based
    extensions. Most uses of Moose::Util::MetaRole can be handled by
    Moose::Exporter directly; see the Moose::Exporter docs.</p>
<p class="Pp"></p>
<pre>
  package MooseX::Embiggen;

  use Moose::Exporter;

  use MooseX::Embiggen::Role::Meta::Class;
  use MooseX::Embiggen::Role::Meta::Attribute;
  use MooseX::Embiggen::Role::Meta::Method::Constructor;
  use MooseX::Embiggen::Role::Object;

  Moose::Exporter-&gt;setup_import_methods(
      class_metaroles =&gt; {
          class     =&gt; ['MooseX::Embiggen::Role::Meta::Class'],
          attribute =&gt; ['MooseX::Embiggen::Role::Meta::Attribute'],
          constructor =&gt;
              ['MooseX::Embiggen::Role::Meta::Method::Constructor'],
      },
      base_class_roles =&gt; ['MooseX::Embiggen::Role::Object'],
  );
</pre>
<p class="Pp">As you can see from this example, you can use
    Moose::Util::MetaRole to apply roles to any metaclass, as well as the base
    object class. If some other extension has already applied its own roles,
    they will be preserved when your extension applies its roles, and vice
    versa.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Providing_Sugar"><a class="permalink" href="#Providing_Sugar">Providing
  Sugar</a></h2>
<p class="Pp">With Moose::Exporter, you can also export your own sugar
    functions:</p>
<p class="Pp"></p>
<pre>
  package MooseX::Embiggen;

  use Moose::Exporter;

  Moose::Exporter-&gt;setup_import_methods(
      with_meta       =&gt; ['embiggen'],
      class_metaroles =&gt; {
          class =&gt; ['MooseX::Embiggen::Role::Meta::Class'],
      },
  );

  sub embiggen {
      my $meta = shift;
      $meta-&gt;embiggen(@_);
  }
</pre>
<p class="Pp">And then the consumer of your extension can use your
    <span class="Li">&quot;embiggen&quot;</span> sub:</p>
<p class="Pp"></p>
<pre>
  package Consumer;

  use Moose;
  use MooseX::Embiggen;

  extends 'Thing';

  embiggen ...;
</pre>
<p class="Pp">This can be combined with metaclass and base class roles quite
    easily.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="More_advanced_extensions"><a class="permalink" href="#More_advanced_extensions">More
  advanced extensions</a></h2>
<p class="Pp">Providing your extension simply as a set of traits that gets
    applied to the appropriate metaobjects is easy, but sometimes not
    sufficient. For instance, sometimes you need to supply not just a base
    object role, but an actual base object class (due to needing to interact
    with existing systems that only provide a base class). To write extensions
    like this, you will need to provide a custom
    <span class="Li">&quot;init_meta&quot;</span> method in your exporter. For
    instance:</p>
<p class="Pp"></p>
<pre>
  package MooseX::Embiggen;

  use Moose::Exporter;

  my ($import, $unimport, $init_meta) = Moose::Exporter-&gt;build_import_methods(
      install         =&gt; ['import', 'unimport'],
      with_meta       =&gt; ['embiggen'],
      class_metaroles =&gt; {
          class =&gt; ['MooseX::Embiggen::Role::Meta::Class'],
      },
  );

  sub embiggen {
      my $meta = shift;
      $meta-&gt;embiggen(@_);
  }

  sub init_meta {
      my $package = shift;
      my %options = @_;
      if (my $meta = Class::MOP::class_of($options{for_class})) {
          if ($meta-&gt;isa('Class::MOP::Class')) {
              my @supers = $meta-&gt;superclasses;
              $meta-&gt;superclasses('MooseX::Embiggen::Base::Class')
                  if @supers == 1 &amp;&amp; $supers[0] eq 'Moose::Object';
          }
      }
      $package-&gt;$init_meta(%options);
  }
</pre>
<p class="Pp">In the previous examples,
    <span class="Li">&quot;init_meta&quot;</span> was generated for you, but
    here you must override it in order to add additional functionality. Some
    differences to note:</p>
<dl class="Bl-tag">
  <dt>&quot;build_import_methods&quot; instead of
    &quot;setup_import_methods&quot;</dt>
  <dd><span class="Li">&quot;build_import_methods&quot;</span> simply returns
      the <span class="Li">&quot;import&quot;</span>,
      <span class="Li">&quot;unimport&quot;</span>, and
      <span class="Li">&quot;init_meta&quot;</span> methods, rather than
      installing them under the appropriate names. This way, you can write your
      own methods which wrap the functionality provided by Moose::Exporter. The
      <span class="Li">&quot;build_import_methods&quot;</span> sub also takes an
      additional <span class="Li">&quot;install&quot;</span> parameter, which
      tells it to just go ahead and install these methods (since we don't need
      to modify them).</dd>
  <dt>&quot;sub init_meta&quot;</dt>
  <dd>Next, we must write our <span class="Li">&quot;init_meta&quot;</span>
      wrapper. The important things to remember are that it is called as a
      method, and that <span class="Li">%options</span> needs to be passed
      through to the existing implementation. We call the base implementation by
      using the <span class="Li">$init_meta</span> subroutine reference that was
      returned by <span class="Li">&quot;build_import_methods&quot;</span>
      earlier.</dd>
  <dt id="Additional"><a class="permalink" href="#Additional">Additional
    implementation</a></dt>
  <dd>This extension sets a different default base object class. To do so, it
      first checks to see if it's being applied to a class, and then checks to
      see if Moose::Object is that class's only superclass, and if so, replaces
      that with the superclass that this extension requires.
    <p class="Pp">Note that two extensions that do this same thing will not work
        together properly (the second extension to be loaded won't see
        Moose::Object as the base object, since it has already been overridden).
        This is why using a base object role is recommended for the general
        case.</p>
    <p class="Pp">This <span class="Li">&quot;init_meta&quot;</span> also works
        defensively, by only applying its functionality if a metaclass already
        exists. This makes sure it doesn't break with legacy extensions which
        override the metaclass directly (and so must be the first extension to
        initialize the metaclass). This is likely not necessary, since almost no
        extensions work this way anymore, but just provides an additional level
        of protection. The common case of <span class="Li">&quot;use Moose; use
        MooseX::Embiggen;&quot;</span> is not affected regardless.</p>
  </dd>
</dl>
<p class="Pp">This is just one example of what can be done with a custom
    <span class="Li">&quot;init_meta&quot;</span> method. It can also be used
    for preventing an extension from being applied to a role, doing other kinds
    of validation on the class being applied to, or pretty much anything that
    would otherwise be done in an <span class="Li">&quot;import&quot;</span>
    method.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="LEGACY_EXTENSION_MECHANISMS"><a class="permalink" href="#LEGACY_EXTENSION_MECHANISMS">LEGACY
  EXTENSION MECHANISMS</a></h1>
<p class="Pp">Before the existence of Moose::Exporter and Moose::Util::MetaRole,
    there were a number of other ways to extend Moose. In general, these methods
    were less cooperative, and only worked well with a single extension.</p>
<p class="Pp">These methods include metaclass.pm, Moose::Policy (which uses
    metaclass.pm under the hood), and various hacks to do what Moose::Exporter
    does. Please do not use these for your own extensions.</p>
<p class="Pp">Note that if you write a cooperative extension, it should
    cooperate with older extensions, though older extensions generally do not
    cooperate with each other.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONCLUSION"><a class="permalink" href="#CONCLUSION">CONCLUSION</a></h1>
<p class="Pp">If you can write your extension as one or more metaclass and base
    object roles, please consider doing so. Make sure to read the docs for
    Moose::Exporter and Moose::Util::MetaRole as well.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Stevan Little &lt;stevan.little@iinteractive.com&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
  <li>Shawn M Moore &lt;code@sartak.org&gt;</li>
  <li>&#x05D9;&#x05D5;&#x05D1;&#x05DC; &#x05E7;&#x05D5;&#x05D2;'&#x05DE;&#x05DF;
      (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Florian Ragwitz &lt;rafl@debian.org&gt;</li>
  <li>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</li>
  <li>Chris Prather &lt;chris@prather.org&gt;</li>
  <li>Matt S Trout &lt;mst@shadowcat.co.uk&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2006 by Infinity Interactive,
  Inc.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-11-22</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

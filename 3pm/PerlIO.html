<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PerlIO(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PerlIO(3pm)</td>
    <td class="head-vol"><a href=".">Perl Programmers Reference Guide</a></td>
    <td class="head-rtitle">PerlIO(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">PerlIO - On demand loader for PerlIO layers and root of PerlIO::*
    name space</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  # support platform-native and CRLF text files
  open(my $fh, &quot;&lt;:crlf&quot;, &quot;my.txt&quot;) or die &quot;open failed: $!&quot;;
  # append UTF-8 encoded text
  open(my $fh, &quot;&gt;&gt;:encoding(UTF-8)&quot;, &quot;some.log&quot;)
    or die &quot;open failed: $!&quot;;
  # portably open a binary file for reading
  open(my $fh, &quot;&lt;&quot;, &quot;his.jpg&quot;) or die &quot;open failed: $!&quot;;
  binmode($fh) or die &quot;binmode failed: $!&quot;;
  Shell:
    PERLIO=:perlio perl ....
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">When an undefined layer 'foo' is encountered in an
    <span class="Li">&quot;open&quot;</span> or
    <span class="Li">&quot;binmode&quot;</span> layer specification then C code
    performs the equivalent of:</p>
<p class="Pp"></p>
<pre>  use PerlIO 'foo';
</pre>
<p class="Pp">The Perl code in PerlIO.pm then attempts to locate a layer by
    doing</p>
<p class="Pp"></p>
<pre>  require PerlIO::foo;
</pre>
<p class="Pp">Otherwise the <span class="Li">&quot;PerlIO&quot;</span> package
    is a place holder for additional PerlIO related functions.</p>
<section class="Ss">
<h2 class="Ss" id="Layers"><a class="permalink" href="#Layers">Layers</a></h2>
<p class="Pp">Generally speaking, PerlIO layers (previously sometimes referred
    to as &quot;disciplines&quot;) are an ordered stack applied to a filehandle
    (specified as a space- or colon-separated list, conventionally written with
    a leading colon). Each layer performs some operation on any input or output,
    except when bypassed such as with
    <span class="Li">&quot;sysread&quot;</span> or
    <span class="Li">&quot;syswrite&quot;</span>. Read operations go through the
    stack in the order they are set (left to right), and write operations in the
    reverse order.</p>
<p class="Pp">There are also layers which actually just set flags on lower
    layers, or layers that modify the current stack but don't persist on the
    stack themselves; these are referred to as pseudo-layers.</p>
<p class="Pp">When opening a handle, it will be opened with any layers specified
    explicitly in the <b>open()</b> call (or the platform defaults, if specified
    as a colon with no following layers).</p>
<p class="Pp">If layers are not explicitly specified, the handle will be opened
    with the layers specified by the ${^OPEN} variable (usually set by using the
    open pragma for a lexical scope, or the
    <span class="Li">&quot;-C&quot;</span> command-line switch or
    <span class="Li">&quot;PERL_UNICODE&quot;</span> environment variable for
    the main program scope).</p>
<p class="Pp">If layers are not specified in the <b>open()</b> call or
    <span class="Li">&quot;${^OPEN}&quot;</span> variable, the handle will be
    opened with the default layer stack configured for that architecture; see
    &quot;Defaults and how to override them&quot;.</p>
<p class="Pp">Some layers will automatically insert required lower level layers
    if not present; for example <span class="Li">&quot;:perlio&quot;</span> will
    insert <span class="Li">&quot;:unix&quot;</span> below itself for low level
    IO, and <span class="Li">&quot;:encoding&quot;</span> will insert the
    platform defaults for buffered IO.</p>
<p class="Pp">The <span class="Li">&quot;binmode&quot;</span> function can be
    called on an opened handle to push additional layers onto the stack, which
    may also modify the existing layers.
    <span class="Li">&quot;binmode&quot;</span> called with no layers will
    remove or unset any existing layers which transform the byte stream, making
    the handle suitable for binary data.</p>
<p class="Pp">The following layers are currently defined:</p>
<dl class="Bl-tag">
  <dt>:unix</dt>
  <dd>Lowest level layer which provides basic PerlIO operations in terms of
      UNIX/POSIX numeric file descriptor calls (<b>open()</b>, <b>read()</b>,
      <b>write()</b>, <b>lseek()</b>, <b>close()</b>). It is used even on
      non-Unix architectures, and most other layers operate on top of it.</dd>
  <dt>:stdio</dt>
  <dd>Layer which calls <span class="Li">&quot;fread&quot;</span>,
      <span class="Li">&quot;fwrite&quot;</span> and
      <span class="Li">&quot;fseek&quot;</span>/<span class="Li">&quot;ftell&quot;</span>
      etc. Note that as this is &quot;real&quot; stdio it will ignore any layers
      beneath it and go straight to the operating system via the C library as
      usual. This layer implements both low level IO and buffering, but is
      rarely used on modern architectures.</dd>
  <dt>:perlio</dt>
  <dd>A from scratch implementation of buffering for PerlIO. Provides fast
      access to the buffer for <span class="Li">&quot;sv_gets&quot;</span> which
      implements Perl's readline/&lt;&gt; and in general attempts to minimize
      data copying.
    <p class="Pp"><span class="Li">&quot;:perlio&quot;</span> will insert a
        <span class="Li">&quot;:unix&quot;</span> layer below itself to do low
        level IO.</p>
  </dd>
  <dt>:crlf</dt>
  <dd>A layer that implements DOS/Windows like CRLF line endings. On read
      converts pairs of CR,LF to a single &quot;\n&quot; newline character. On
      write converts each &quot;\n&quot; to a CR,LF pair. Note that this layer
      will silently refuse to be pushed on top of itself.
    <p class="Pp">It currently does <i>not</i> mimic MS-DOS as far as treating
        of Control-Z as being an end-of-file marker.</p>
    <p class="Pp">On DOS/Windows like architectures where this layer is part of
        the defaults, it also acts like the
        <span class="Li">&quot;:perlio&quot;</span> layer, and removing the CRLF
        translation (such as with <span class="Li">&quot;:raw&quot;</span>) will
        only unset the CRLF translation flag. Since Perl 5.14, you can also
        apply another <span class="Li">&quot;:crlf&quot;</span> layer later,
        such as when the CRLF translation must occur after an encoding layer. On
        other architectures, it is a mundane CRLF translation layer and can be
        added and removed normally.</p>
    <p class="Pp"></p>
    <pre>    # translate CRLF after encoding on Perl 5.14 or newer
    binmode $fh, &quot;:raw:encoding(UTF-16LE):crlf&quot;
      or die &quot;binmode failed: $!&quot;;
    </pre>
  </dd>
  <dt>:utf8</dt>
  <dd>Pseudo-layer that declares that the stream accepts Perl's <i>internal</i>
      upgraded encoding of characters, which is approximately UTF-8 on ASCII
      machines, but UTF-EBCDIC on EBCDIC machines. This allows any character
      Perl can represent to be read from or written to the stream.
    <p class="Pp">This layer (which actually sets a flag on the preceding layer,
        and is implicitly set by any
        <span class="Li">&quot;:encoding&quot;</span> layer) does not translate
        or validate byte sequences. It instead indicates that the byte stream
        will have been arranged by other layers to be provided in Perl's
        internal upgraded encoding, which Perl code (and correctly written XS
        code) will interpret as decoded Unicode characters.</p>
    <p class="Pp"><b>CAUTION</b>: Do not use this layer to translate from UTF-8
        bytes, as invalid UTF-8 or binary data will result in malformed Perl
        strings. It is unlikely to produce invalid UTF-8 when used for output,
        though it will instead produce UTF-EBCDIC on EBCDIC systems. The
        <span class="Li">&quot;:encoding(UTF-8)&quot;</span> layer (hyphen is
        significant) is preferred as it will ensure translation between valid
        UTF-8 bytes and valid Unicode characters.</p>
  </dd>
  <dt>:bytes</dt>
  <dd>This is the inverse of the <span class="Li">&quot;:utf8&quot;</span>
      pseudo-layer. It turns off the flag on the layer below so that data read
      from it is considered to be Perl's internal downgraded encoding, thus
      interpreted as the native single-byte encoding of Latin-1 or EBCDIC.
      Likewise on output Perl will warn if a &quot;wide&quot; character (a
      codepoint not in the range 0..255) is written to a such a stream.
    <p class="Pp">This is very dangerous to push on a handle using an
        <span class="Li">&quot;:encoding&quot;</span> layer, as such a layer
        assumes to be working with Perl's internal upgraded encoding, so you
        will likely get a mangled result. Instead use
        <span class="Li">&quot;:raw&quot;</span> or
        <span class="Li">&quot;:pop&quot;</span> to remove encoding layers.</p>
  </dd>
  <dt>:raw</dt>
  <dd>The <span class="Li">&quot;:raw&quot;</span> pseudo-layer is
      <i>defined</i> as being identical to calling
      <span class="Li">&quot;binmode($fh)&quot;</span> - the stream is made
      suitable for passing binary data, i.e. each byte is passed as-is. The
      stream will still be buffered (but this was not always true before Perl
      5.14).
    <p class="Pp">In Perl 5.6 and some books the
        <span class="Li">&quot;:raw&quot;</span> layer is documented as the
        inverse of the <span class="Li">&quot;:crlf&quot;</span> layer. That is
        no longer the case - other layers which would alter the binary nature of
        the stream are also disabled. If you want UNIX line endings on a
        platform that normally does CRLF translation, but still want UTF-8 or
        encoding defaults, the appropriate thing to do is to add
        <span class="Li">&quot;:perlio&quot;</span> to the PERLIO environment
        variable, or open the handle explicitly with that layer, to replace the
        platform default of <span class="Li">&quot;:crlf&quot;</span>.</p>
    <p class="Pp">The implementation of <span class="Li">&quot;:raw&quot;</span>
        is as a pseudo-layer which when &quot;pushed&quot; pops itself and then
        any layers which would modify the binary data stream. (Undoing
        <span class="Li">&quot;:utf8&quot;</span> and
        <span class="Li">&quot;:crlf&quot;</span> may be implemented by clearing
        flags rather than popping layers but that is an implementation
      detail.)</p>
    <p class="Pp">As a consequence of the fact that
        <span class="Li">&quot;:raw&quot;</span> normally pops layers, it
        usually only makes sense to have it as the only or first element in a
        layer specification. When used as the first element it provides a known
        base on which to build e.g.</p>
    <p class="Pp"></p>
    <pre>    open(my $fh,&quot;&gt;:raw:encoding(UTF-8)&quot;,...)
      or die &quot;open failed: $!&quot;;
    </pre>
    <p class="Pp">will construct a &quot;binary&quot; stream regardless of the
        platform defaults, but then enable UTF-8 translation.</p>
  </dd>
  <dt>:pop</dt>
  <dd>A pseudo-layer that removes the top-most layer. Gives Perl code a way to
      manipulate the layer stack. Note that
      <span class="Li">&quot;:pop&quot;</span> only works on real layers and
      will not undo the effects of pseudo-layers or flags like
      <span class="Li">&quot;:utf8&quot;</span>. An example of a possible use
      might be:
    <p class="Pp"></p>
    <pre>    open(my $fh,...) or die &quot;open failed: $!&quot;;
    ...
    binmode($fh,&quot;:encoding(...)&quot;) or die &quot;binmode failed: $!&quot;;
    # next chunk is encoded
    ...
    binmode($fh,&quot;:pop&quot;) or die &quot;binmode failed: $!&quot;;
    # back to un-encoded
    </pre>
    <p class="Pp">A more elegant (and safer) interface is needed.</p>
  </dd>
  <dt>:win32</dt>
  <dd>On Win32 platforms this <i>experimental</i> layer uses the native
      &quot;handle&quot; IO rather than the unix-like numeric file descriptor
      layer. Known to be buggy as of Perl 5.8.2.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Custom_Layers"><a class="permalink" href="#Custom_Layers">Custom
  Layers</a></h2>
<p class="Pp">It is possible to write custom layers in addition to the above
    builtin ones, both in C/XS and Perl, as a module named
    <span class="Li">&quot;PerlIO::&lt;layer name&gt;&quot;</span>. Some custom
    layers come with the Perl distribution.</p>
<dl class="Bl-tag">
  <dt>:encoding</dt>
  <dd>Use <span class="Li">&quot;:encoding(ENCODING)&quot;</span> to
      transparently do character set and encoding transformations, for example
      from Shift-JIS to Unicode. Note that an
      <span class="Li">&quot;:encoding&quot;</span> also enables
      <span class="Li">&quot;:utf8&quot;</span>. See PerlIO::encoding for more
      information.</dd>
  <dt>:mmap</dt>
  <dd>A layer which implements &quot;reading&quot; of files by using
      <span class="Li">&quot;mmap()&quot;</span> to make a (whole) file appear
      in the process's address space, and then using that as PerlIO's
      &quot;buffer&quot;. This <i>may</i> be faster in certain circumstances for
      large files, and may result in less physical memory use when multiple
      processes are reading the same file.
    <p class="Pp">Files which are not
        <span class="Li">&quot;mmap()&quot;</span>-able revert to behaving like
        the <span class="Li">&quot;:perlio&quot;</span> layer. Writes also
        behave like the <span class="Li">&quot;:perlio&quot;</span> layer, as
        <span class="Li">&quot;mmap()&quot;</span> for write needs extra
        house-keeping (to extend the file) which negates any advantage.</p>
    <p class="Pp">The <span class="Li">&quot;:mmap&quot;</span> layer will not
        exist if the platform does not support
        <span class="Li">&quot;mmap()&quot;</span>. See PerlIO::mmap for more
        information.</p>
  </dd>
  <dt>:via</dt>
  <dd><span class="Li">&quot;:via(MODULE)&quot;</span> allows a transformation
      to be applied by an arbitrary Perl module, for example compression /
      decompression, encryption / decryption. See PerlIO::via for more
      information.</dd>
  <dt>:scalar</dt>
  <dd>A layer implementing &quot;in memory&quot; files using scalar variables,
      automatically used in place of the platform defaults for IO when opening
      such a handle. As such, the scalar is expected to act like a file, only
      containing or storing bytes. See PerlIO::scalar for more information.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Alternatives_to_raw"><a class="permalink" href="#Alternatives_to_raw">Alternatives
  to raw</a></h2>
<p class="Pp">To get a binary stream an alternate method is to use:</p>
<p class="Pp"></p>
<pre>    open(my $fh,&quot;&lt;&quot;,&quot;whatever&quot;) or die &quot;open failed: $!&quot;;
    binmode($fh) or die &quot;binmode failed: $!&quot;;
</pre>
<p class="Pp">This has the advantage of being backward compatible with older
    versions of Perl that did not use PerlIO or where
    <span class="Li">&quot;:raw&quot;</span> was buggy (as it was before Perl
    5.14).</p>
<p class="Pp">To get an unbuffered stream specify an unbuffered layer (e.g.
    <span class="Li">&quot;:unix&quot;</span>) in the open call:</p>
<p class="Pp"></p>
<pre>    open(my $fh,&quot;&lt;:unix&quot;,$path) or die &quot;open failed: $!&quot;;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Defaults_and_how_to_override_them"><a class="permalink" href="#Defaults_and_how_to_override_them">Defaults
  and how to override them</a></h2>
<p class="Pp">If the platform is MS-DOS like and normally does CRLF to
    &quot;\n&quot; translation for text files then the default layers are:</p>
<p class="Pp"></p>
<pre>  :unix:crlf
</pre>
<p class="Pp">Otherwise if <span class="Li">&quot;Configure&quot;</span> found
    out how to do &quot;fast&quot; IO using the system's stdio (not common on
    modern architectures), then the default layers are:</p>
<p class="Pp"></p>
<pre>  :stdio
</pre>
<p class="Pp">Otherwise the default layers are</p>
<p class="Pp"></p>
<pre>  :unix:perlio
</pre>
<p class="Pp">Note that the &quot;default stack&quot; depends on the operating
    system and on the Perl version, and both the compile-time and runtime
    configurations of Perl. The default can be overridden by setting the
    environment variable PERLIO to a space or colon separated list of layers,
    however this cannot be used to set layers that require loading modules like
    <span class="Li">&quot;:encoding&quot;</span>.</p>
<p class="Pp">This can be used to see the effect of/bugs in the various layers
    e.g.</p>
<p class="Pp"></p>
<pre>  cd .../perl/t
  PERLIO=:stdio  ./perl harness
  PERLIO=:perlio ./perl harness
</pre>
<p class="Pp">For the various values of PERLIO see &quot;PERLIO&quot; in
    perlrun.</p>
<p class="Pp">The following table summarizes the default layers on UNIX-like and
    DOS-like platforms and depending on the setting of
    <span class="Li">$ENV{PERLIO}</span>:</p>
<p class="Pp"></p>
<pre> PERLIO     UNIX-like                   DOS-like
 ------     ---------                   --------
 unset / &quot;&quot; :unix:perlio / :stdio [1]   :unix:crlf
 :stdio     :stdio                      :stdio
 :perlio    :unix:perlio                :unix:perlio
 # [1] &quot;:stdio&quot; if Configure found out how to do &quot;fast stdio&quot; (depends
 # on the stdio implementation) and in Perl 5.8, else &quot;:unix:perlio&quot;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Querying_the_layers_of_filehandles"><a class="permalink" href="#Querying_the_layers_of_filehandles">Querying
  the layers of filehandles</a></h2>
<p class="Pp">The following returns the <b>names</b> of the PerlIO layers on a
    filehandle.</p>
<p class="Pp"></p>
<pre>   my @layers = PerlIO::get_layers($fh); # Or FH, *FH, &quot;FH&quot;.
</pre>
<p class="Pp">The layers are returned in the order an <b>open()</b> or
    <b>binmode()</b> call would use them, and without colons.</p>
<p class="Pp">By default the layers from the input side of the filehandle are
    returned; to get the output side, use the optional
    <span class="Li">&quot;output&quot;</span> argument:</p>
<p class="Pp"></p>
<pre>   my @layers = PerlIO::get_layers($fh, output =&gt; 1);
</pre>
<p class="Pp">(Usually the layers are identical on either side of a filehandle
    but for example with sockets there may be differences.)</p>
<p class="Pp">There is no <b>set_layers()</b>, nor does <b>get_layers()</b>
    return a tied array mirroring the stack, or anything fancy like that. This
    is not accidental or unintentional. The PerlIO layer stack is a bit more
    complicated than just a stack (see for example the behaviour of
    <span class="Li">&quot;:raw&quot;</span>). You are supposed to use
    <b>open()</b> and <b>binmode()</b> to manipulate the stack.</p>
<p class="Pp"><b>Implementation details follow, please close your eyes.</b></p>
<p class="Pp">The arguments to layers are by default returned in parentheses
    after the name of the layer, and certain layers (like
    <span class="Li">&quot;:utf8&quot;</span>) are not real layers but instead
    flags on real layers; to get all of these returned separately, use the
    optional <span class="Li">&quot;details&quot;</span> argument:</p>
<p class="Pp"></p>
<pre>   my @layer_and_args_and_flags = PerlIO::get_layers($fh, details =&gt; 1);
</pre>
<p class="Pp">The result will be up to be three times the number of layers: the
    first element will be a name, the second element the arguments (unspecified
    arguments will be <span class="Li">&quot;undef&quot;</span>), the third
    element the flags, the fourth element a name again, and so forth.</p>
<p class="Pp"><b>You may open your eyes now.</b></p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Nick Ing-Simmons &lt;nick@ing-simmons.net&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">&quot;binmode&quot; in perlfunc, &quot;open&quot; in perlfunc,
    perlunicode, perliol, Encode</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os"><a href="..">perl v5.34.1</a></td>
  </tr>
</table>
</body>
</html>

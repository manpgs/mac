<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Import::Into(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Import::Into(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Import::Into(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Import::Into - Import packages into other packages</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  package My::MultiExporter;
  use Import::Into;
  # simple
  sub import {
    Thing1-&gt;import::into(scalar caller);
  }
  # multiple
  sub import {
    my $target = caller;
    Thing1-&gt;import::into($target);
    Thing2-&gt;import::into($target, qw(import arguments));
  }
  # by level
  sub import {
    Thing1-&gt;import::into(1);
  }
  # with exporter
  use base qw(Exporter);
  sub import {
    shift-&gt;export_to_level(1);
    Thing1-&gt;import::into(1);
  }
  # no My::MultiExporter == no Thing1
  sub unimport {
    Thing1-&gt;unimport::out_of(scalar caller);
  }
</pre>
<p class="Pp">People wanting to re-export your module should also be using
    Import::Into. Any exporter or pragma will work seamlessly.</p>
<p class="Pp">Note: You do <b>not</b> need to make any changes to Thing1 to be
    able to call <span class="Li">&quot;import::into&quot;</span> on it. This is
    a global method, and is callable on any package (and in fact on any object
    as well, although it's rarer that you'd want to do that).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Writing exporters is a pain. Some use Exporter, some use
    Sub::Exporter, some use Moose::Exporter, some use Exporter::Declare ... and
    some things are pragmas.</p>
<p class="Pp">Exporting on someone else's behalf is harder. The exporters don't
    provide a consistent API for this, and pragmas need to have their import
    method called directly, since they effect the current unit of
  compilation.</p>
<p class="Pp"><span class="Li">&quot;Import::Into&quot;</span> provides global
    methods to make this painless.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss">$package-&gt;import::into( $target, @arguments );</h2>
<p class="Pp">A global method, callable on any package. Loads and imports the
    given package into <span class="Li">$target</span>.
    <span class="Li">@arguments</span> are passed along to the package's import
    method.</p>
<p class="Pp"><span class="Li">$target</span> can be an package name to export
    to, an integer for the caller level to export to, or a hashref with the
    following options:</p>
<dl class="Bl-tag">
  <dt id="package"><a class="permalink" href="#package">package</a></dt>
  <dd>The target package to export to.</dd>
  <dt id="filename"><a class="permalink" href="#filename">filename</a></dt>
  <dd>The apparent filename to export to. Some exporting modules, such as
      autodie or strictures, care about the filename they are being imported
    to.</dd>
  <dt id="line"><a class="permalink" href="#line">line</a></dt>
  <dd>The apparent line number to export to. To be combined with the
      <span class="Li">&quot;filename&quot;</span> option.</dd>
  <dt id="level"><a class="permalink" href="#level">level</a></dt>
  <dd>The caller level to export to. This will automatically populate the
      <span class="Li">&quot;package&quot;</span>,
      <span class="Li">&quot;filename&quot;</span>, and
      <span class="Li">&quot;line&quot;</span> options, making it the easiest
      most constent option.</dd>
  <dt id="version"><a class="permalink" href="#version">version</a></dt>
  <dd>A version number to check for the module. The equivalent of specifying the
      version number on a <span class="Li">&quot;use&quot;</span> line.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">$package-&gt;unimport::out_of( $target, @arguments );</h2>
<p class="Pp">Equivalent to <span class="Li">&quot;import::into&quot;</span>,
    but dispatches to <span class="Li">$package</span>'s
    <span class="Li">&quot;unimport&quot;</span> method instead of
    <span class="Li">&quot;import&quot;</span>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="WHY_USE_THIS_MODULE"><a class="permalink" href="#WHY_USE_THIS_MODULE">WHY
  USE THIS MODULE</a></h1>
<p class="Pp">The APIs for exporting modules aren't consistent. Exporter
    subclasses provide export_to_level, but if they overrode their import method
    all bets are off. Sub::Exporter provides an into parameter but figuring out
    something used it isn't trivial. Pragmas need to have their
    <span class="Li">&quot;import&quot;</span> method called directly since they
    affect the current unit of compilation.</p>
<p class="Pp">It's ... annoying.</p>
<p class="Pp">However, there is an approach that actually works for all of these
    types.</p>
<p class="Pp"></p>
<pre>  eval &quot;package $target; use $thing;&quot;
</pre>
<p class="Pp">will work for anything checking caller, which is everything except
    pragmas. But it doesn't work for pragmas - pragmas need:</p>
<p class="Pp"></p>
<pre>  $thing-&gt;import;
</pre>
<p class="Pp">because they're designed to affect the code currently being
    compiled - so within an eval, that's the scope of the eval itself, not the
    module that just <span class="Li">&quot;use&quot;</span>d you - so</p>
<p class="Pp"></p>
<pre>  sub import {
    eval &quot;use strict;&quot;
  }
</pre>
<p class="Pp">doesn't do what you wanted, but</p>
<p class="Pp"></p>
<pre>  sub import {
    strict-&gt;import;
  }
</pre>
<p class="Pp">will apply strict to the calling file correctly.</p>
<p class="Pp">Of course, now you have two new problems - first, that you still
    need to know if something's a pragma, and second that you can't use either
    of these approaches alone on something like Moose or Moo that's both an
    exporter and a pragma.</p>
<p class="Pp">So, a solution for that is:</p>
<p class="Pp"></p>
<pre>  use Module::Runtime;
  my $sub = eval &quot;package $target; sub { use_module(shift)-&gt;import(\@_) }&quot;;
  $sub-&gt;($thing, @import_args);
</pre>
<p class="Pp">which means that import is called from the right place for pragmas
    to take effect, and from the right package for caller checking to work - and
    so behaves correctly for all types of exporter, for pragmas, and for
    hybrids.</p>
<p class="Pp">Additionally, some import routines check the filename they are
    being imported to. This can be dealt with by generating a #line directive in
    the eval, which will change what <span class="Li">&quot;caller&quot;</span>
    reports for the filename when called in the importer. The filename and line
    number to use in the directive then need to be fetched using
    <span class="Li">&quot;caller&quot;</span>:</p>
<p class="Pp"></p>
<pre>  my ($target, $file, $line) = caller(1);
  my $sub = eval qq{
    package $target;
  #line $line &quot;$file&quot;
    sub { use_module(shift)-&gt;import(\@_) }
  };
  $sub-&gt;($thing, @import_args);
</pre>
<p class="Pp">And you need to switch between these implementations depending on
    if you are targeting a specific package, or something in your call
  stack.</p>
<p class="Pp">Remembering all this, however, is excessively irritating. So I
    wrote a module so I didn't have to anymore. Loading Import::Into creates a
    global method <span class="Li">&quot;import::into&quot;</span> which you can
    call on any package to import it into another package. So now you can simply
    write:</p>
<p class="Pp"></p>
<pre>  use Import::Into;
  $thing-&gt;import::into($target, @import_args);
</pre>
<p class="Pp">This works because of how perl resolves method calls - a call to a
    simple method name is resolved against the package of the class or object,
    so</p>
<p class="Pp"></p>
<pre>  $thing-&gt;method_name(@args);
</pre>
<p class="Pp">is roughly equivalent to:</p>
<p class="Pp"></p>
<pre>  my $code_ref = $thing-&gt;can('method_name');
  $code_ref-&gt;($thing, @args);
</pre>
<p class="Pp">while if a <span class="Li">&quot;::&quot;</span> is found, the
    lookup is made relative to the package name (i.e. everything before the last
    <span class="Li">&quot;::&quot;</span>) so</p>
<p class="Pp"></p>
<pre>  $thing-&gt;Package::Name::method_name(@args);
</pre>
<p class="Pp">is roughly equivalent to:</p>
<p class="Pp"></p>
<pre>  my $code_ref = Package::Name-&gt;can('method_name');
  $code_ref-&gt;($thing, @args);
</pre>
<p class="Pp">So since Import::Into defines a method
    <span class="Li">&quot;into&quot;</span> in package
    <span class="Li">&quot;import&quot;</span> the syntax reliably calls
  that.</p>
<p class="Pp">For more craziness of this order, have a look at the article I
    wrote at &lt;http://shadow.cat/blog/matt-s-trout/madness-with-methods&gt;
    which covers coderef abuse and the
    <span class="Li">&quot;${\...}&quot;</span> syntax.</p>
<p class="Pp">And that's it.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">I gave a lightning talk on this module (and curry and Safe::Isa)
    at YAPC::NA 2013
    &lt;https://www.youtube.com/watch?v=wFXWV2yY7gE&amp;t=46m05s&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGEMENTS"><a class="permalink" href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></h1>
<p class="Pp">Thanks to Getty for asking &quot;how can I get
    <span class="Li">&quot;use strict; use warnings;&quot;</span> turned on for
    all consumers of my code?&quot; and then &quot;why is this not a
    module?!&quot;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">mst - Matt S. Trout (cpan:MSTROUT) &lt;mst@shadowcat.co.uk&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<p class="Pp">haarg - Graham Knop (cpan:HAARG) &lt;haarg@haarg.org&gt;</p>
<p class="Pp">Mithaldu - Christian Walde (cpan:MITHALDU)
    &lt;walde.christian@gmail.com&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 2012 the Import::Into &quot;AUTHOR&quot; and
    &quot;CONTRIBUTORS&quot; as listed above.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">This library is free software and may be distributed under the
    same terms as perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2015-08-28</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Data::Compare::Plugins(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Data::Compare::Plugins(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Data::Compare::Plugins(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Data::Compare::Plugins - how to extend Data::Compare</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Data::Compare natively handles several built-in data types -
    scalars, references to scalars, references to arrays, references to hashes,
    references to subroutines, compiled regular expressions, and globs. For
    objects, it tries to Do The Right Thing and compares the underlying data
    type. However, this is not always what you want. This is especially true if
    you have complex objects which overload stringification and/or
  numification.</p>
<p class="Pp">Hence we allow for plugins.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FINDING_PLUGINS"><a class="permalink" href="#FINDING_PLUGINS">FINDING
  PLUGINS</a></h1>
<p class="Pp">Data::Compare will try to load any module installed on your system
    under the various <span class="Li">@INC</span>/Data/Compare/Plugins/
    directories. If there is a problem loading any of them, an appropriate
    warning will be issued.</p>
<p class="Pp">Because of how we find plugins, no plugins are available when
    running in &quot;taint&quot; mode.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="WRITING_PLUGINS"><a class="permalink" href="#WRITING_PLUGINS">WRITING
  PLUGINS</a></h1>
<p class="Pp">Internally, plugins are
    <span class="Li">&quot;require&quot;</span>d into Data::Compare. This means
    that they need to evaluate to true. We make use of that true value. Where
    normally you just put:</p>
<p class="Pp"></p>
<pre>    1;
</pre>
<p class="Pp">at the end of an included file, you should instead ensure that you
    return a reference to an array. This is treated as being true so satisfies
    perl, and is a damned sight more useful.</p>
<p class="Pp">Inside that array should be either a description of what this
    plugin is to do, or references to several arrays containing such
    descriptions. A description consists of two or three items. First a string
    telling us what the first data-type handled by your plugin is. Second, (and
    optional, defaulting to the same as the first) the second data-type to
    compare. To handle comparisons to ordinary scalars, give the empty string
    for the data-type, ie:</p>
<p class="Pp"></p>
<pre>    ['MyType', '', sub { ...}]
</pre>
<p class="Pp">Third and last, we need a reference to the subroutine which does
    the comparison. That subroutine should expect to take two parameters, which
    will be of the specified type. It should return 1 if they compare the same,
    or 0 if they compare different.</p>
<p class="Pp">Be aware that while you might give a description like:</p>
<p class="Pp"></p>
<pre>    ['Type1', 'Type2', sub { ... }]
</pre>
<p class="Pp">this will handle both comparing Type1 to Type2, and comparing
    Type2 to Type1. ie, comparison is commutative.</p>
<p class="Pp">If you want to use Data::Compare's own comparison function from
    within your handler (to, for example, compare a data structure that you have
    stored somewhere in your object) then you will need to call it as
    Data::Compare::Compare. However, you must be careful to avoid infinite
    recursion by calling D::C::Compare which in turn calls back to your
  handler.</p>
<p class="Pp">The name of your plugins does not matter, only that it lives in
    one of those directories. Of course, giving it a sensible name means that
    the usual installation mechanisms will put it in the right place, and
    meaningful names will make it easier to debug your code.</p>
<p class="Pp">For an example, look at the plugin that handles Scalar::Properties
    objects, which is distributed with Data::Compare.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DISTRIBUTION"><a class="permalink" href="#DISTRIBUTION">DISTRIBUTION</a></h1>
<p class="Pp">Provided that the above rules are followed I see no reason for you
    to not upload your plugin to the CPAN yourself. You will need to make
    Data::Compare a pre-requisite, so that the CPAN.pm installer does the right
    thing.</p>
<p class="Pp">Alternatively, if you would prefer me to roll your plugin in with
    the Data::Compare distribution, I'd be happy to do so provided that the code
    is clear and well-commented, and that you include tests and
  documentation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Data::Compare</p>
<p class="Pp">Data::Compare::Plugins::Scalar::Properties</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Copyright (c) 2004 David Cantrell &lt;david@cantrell.org.uk&gt;.
    All rights reserved. This program is free software; you can redistribute it
    and/or modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-11-05</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

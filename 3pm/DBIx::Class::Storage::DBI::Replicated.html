<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>DBIx::Class::Storage::DBI::Replicated(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBIx::Class::Storage::DBI::Replicated(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBIx::Class::Storage::DBI::Replicated(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">DBIx::Class::Storage::DBI::Replicated - BETA Replicated database
    support</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">The Following example shows how to change an existing
    <span class="Li">$schema</span> to a replicated storage type, add some
    replicated (read-only) databases, and perform reporting tasks.</p>
<p class="Pp">You should set the 'storage_type attribute to a replicated type.
    You should also define your arguments, such as which balancer you want and
    any arguments that the Pool object should get.</p>
<p class="Pp"></p>
<pre>  my $schema = Schema::Class-&gt;clone;
  $schema-&gt;storage_type(['::DBI::Replicated', { balancer_type =&gt; '::Random' }]);
  $schema-&gt;connection(...);
</pre>
<p class="Pp">Next, you need to add in the Replicants. Basically this is an
    array of arrayrefs, where each arrayref is database connect information.
    Think of these arguments as what you'd pass to the 'normal'
    <span class="Li">$schema</span>-&gt;connect method.</p>
<p class="Pp"></p>
<pre>  $schema-&gt;storage-&gt;connect_replicants(
    [$dsn1, $user, $pass, \%opts],
    [$dsn2, $user, $pass, \%opts],
    [$dsn3, $user, $pass, \%opts],
  );
</pre>
<p class="Pp">Now, just use the <span class="Li">$schema</span> as you normally
    would. Automatically all reads will be delegated to the replicants, while
    writes to the master.</p>
<p class="Pp"></p>
<pre>  $schema-&gt;resultset('Source')-&gt;search({name=&gt;'etc'});
</pre>
<p class="Pp">You can force a given query to use a particular storage using the
    search attribute 'force_pool'. For example:</p>
<p class="Pp"></p>
<pre>  my $rs = $schema-&gt;resultset('Source')-&gt;search(undef, {force_pool=&gt;'master'});
</pre>
<p class="Pp">Now <span class="Li">$rs</span> will force everything (both reads
    and writes) to use whatever was setup as the master storage. 'master' is
    hardcoded to always point to the Master, but you can also use any Replicant
    name. Please see: DBIx::Class::Storage::DBI::Replicated::Pool and the
    replicants attribute for more.</p>
<p class="Pp">Also see transactions and &quot;execute_reliably&quot; for
    alternative ways to force read traffic to the master. In general, you should
    wrap your statements in a transaction when you are reading and writing to
    the same tables at the same time, since your replicants will often lag a bit
    behind the master.</p>
<p class="Pp">If you have a multi-statement read only transaction you can force
    it to select a random server in the pool by:</p>
<p class="Pp"></p>
<pre>  my $rs = $schema-&gt;resultset('Source')-&gt;search( undef,
    { force_pool =&gt; $db-&gt;storage-&gt;read_handler-&gt;next_storage }
  );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Warning: This class is marked BETA. This has been running a
    production website using MySQL native replication as its backend and we have
    some decent test coverage but the code hasn't yet been stressed by a variety
    of databases. Individual DBs may have quirks we are not aware of. Please use
    this in first development and pass along your experiences/bug fixes.</p>
<p class="Pp">This class implements replicated data store for DBI. Currently you
    can define one master and numerous slave database connections. All
    write-type queries (INSERT, UPDATE, DELETE and even LAST_INSERT_ID) are
    routed to master database, all read-type queries (SELECTs) go to the slave
    database.</p>
<p class="Pp">Basically, any method request that DBIx::Class::Storage::DBI would
    normally handle gets delegated to one of the two attributes:
    &quot;read_handler&quot; or to &quot;write_handler&quot;. Additionally, some
    methods need to be distributed to all existing storages. This way our
    storage class is a drop in replacement for DBIx::Class::Storage::DBI.</p>
<p class="Pp">Read traffic is spread across the replicants (slaves) occurring to
    a user selected algorithm. The default algorithm is random weighted.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<p class="Pp">The consistency between master and replicants is database
    specific. The Pool gives you a method to validate its replicants, removing
    and replacing them when they fail/pass predefined criteria. Please make
    careful use of the ways to force a query to run against Master when
  needed.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="REQUIREMENTS"><a class="permalink" href="#REQUIREMENTS">REQUIREMENTS</a></h1>
<p class="Pp">Replicated Storage has additional requirements not currently part
    of DBIx::Class. See DBIx::Class::Optional::Dependencies for more
  details.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ATTRIBUTES"><a class="permalink" href="#ATTRIBUTES">ATTRIBUTES</a></h1>
<p class="Pp">This class defines the following attributes.</p>
<section class="Ss">
<h2 class="Ss" id="schema"><a class="permalink" href="#schema">schema</a></h2>
<p class="Pp">The underlying DBIx::Class::Schema object this storage is
    attaching</p>
</section>
<section class="Ss">
<h2 class="Ss" id="pool_type"><a class="permalink" href="#pool_type">pool_type</a></h2>
<p class="Pp">Contains the classname which will instantiate the &quot;pool&quot;
    object. Defaults to: DBIx::Class::Storage::DBI::Replicated::Pool.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="pool_args"><a class="permalink" href="#pool_args">pool_args</a></h2>
<p class="Pp">Contains a hashref of initialized information to pass to the
    Balancer object. See DBIx::Class::Storage::DBI::Replicated::Pool for
    available arguments.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="balancer_type"><a class="permalink" href="#balancer_type">balancer_type</a></h2>
<p class="Pp">The replication pool requires a balance class to provider the
    methods for choose how to spread the query load across each replicant in the
    pool.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="balancer_args"><a class="permalink" href="#balancer_args">balancer_args</a></h2>
<p class="Pp">Contains a hashref of initialized information to pass to the
    Balancer object. See DBIx::Class::Storage::DBI::Replicated::Balancer for
    available arguments.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="pool"><a class="permalink" href="#pool">pool</a></h2>
<p class="Pp">Is a DBIx::Class::Storage::DBI::Replicated::Pool or derived class.
    This is a container class for one or more replicated databases.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="balancer"><a class="permalink" href="#balancer">balancer</a></h2>
<p class="Pp">Is a DBIx::Class::Storage::DBI::Replicated::Balancer or derived
    class. This is a class that takes a pool
    (DBIx::Class::Storage::DBI::Replicated::Pool)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="master"><a class="permalink" href="#master">master</a></h2>
<p class="Pp">The master defines the canonical state for a pool of connected
    databases. All the replicants are expected to match this databases state.
    Thus, in a classic Master / Slaves distributed system, all the slaves are
    expected to replicate the Master's state as quick as possible. This is the
    only database in the pool of databases that is allowed to handle write
    traffic.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ATTRIBUTES_IMPLEMENTING_THE_DBIx::Storage::DBI_INTERFACE"><a class="permalink" href="#ATTRIBUTES_IMPLEMENTING_THE_DBIx::Storage::DBI_INTERFACE">ATTRIBUTES
  IMPLEMENTING THE DBIx::Storage::DBI INTERFACE</a></h1>
<p class="Pp">The following methods are delegated all the methods required for
    the DBIx::Class::Storage::DBI interface.</p>
<section class="Ss">
<h2 class="Ss" id="read_handler"><a class="permalink" href="#read_handler">read_handler</a></h2>
<p class="Pp">Defines an object that implements the read side of
    DBIx::Class::Storage::DBI.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="write_handler"><a class="permalink" href="#write_handler">write_handler</a></h2>
<p class="Pp">Defines an object that implements the write side of
    DBIx::Class::Storage::DBI, as well as methods that don't write or read that
    can be called on only one storage, methods that return a
    <span class="Li">$dbh</span>, and any methods that don't make sense to run
    on a replicant.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="around:_connect_info"><a class="permalink" href="#around:_connect_info">around:
  connect_info</a></h2>
<p class="Pp">Preserves master's
    <span class="Li">&quot;connect_info&quot;</span> options (for merging with
    replicants.) Also sets any Replicated-related options from connect_info,
    such as <span class="Li">&quot;pool_type&quot;</span>,
    <span class="Li">&quot;pool_args&quot;</span>,
    <span class="Li">&quot;balancer_type&quot;</span> and
    <span class="Li">&quot;balancer_args&quot;</span>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<p class="Pp">This class defines the following methods.</p>
<section class="Ss">
<h2 class="Ss">BUILDARGS</h2>
<p class="Pp">DBIx::Class::Schema when instantiating its storage passed itself
    as the first argument. So we need to massage the arguments a bit so that all
    the bits get put into the correct places.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_build_master"><a class="permalink" href="#_build_master">_build_master</a></h2>
<p class="Pp">Lazy builder for the &quot;master&quot; attribute.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_build_pool"><a class="permalink" href="#_build_pool">_build_pool</a></h2>
<p class="Pp">Lazy builder for the &quot;pool&quot; attribute.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_build_balancer"><a class="permalink" href="#_build_balancer">_build_balancer</a></h2>
<p class="Pp">Lazy builder for the &quot;balancer&quot; attribute. This takes a
    Pool object so that the balancer knows which pool it's balancing.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_build_write_handler"><a class="permalink" href="#_build_write_handler">_build_write_handler</a></h2>
<p class="Pp">Lazy builder for the &quot;write_handler&quot; attribute. The
    default is to set this to the &quot;master&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_build_read_handler"><a class="permalink" href="#_build_read_handler">_build_read_handler</a></h2>
<p class="Pp">Lazy builder for the &quot;read_handler&quot; attribute. The
    default is to set this to the &quot;balancer&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="around:_connect_replicants"><a class="permalink" href="#around:_connect_replicants">around:
  connect_replicants</a></h2>
<p class="Pp">All calls to connect_replicants needs to have an existing
    <span class="Li">$schema</span> tacked onto top of the args, since
    DBIx::Class::Storage::DBI needs it, and any connect_info options merged with
    the master, with replicant opts having higher priority.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="all_storages"><a class="permalink" href="#all_storages">all_storages</a></h2>
<p class="Pp">Returns an array of all the connected storage backends. The first
    element in the returned array is the master, and the rest are each of the
    replicants.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="execute_reliably_($coderef,_?@args)"><a class="permalink" href="#execute_reliably_($coderef,_?@args)">execute_reliably
  ($coderef, ?@args)</a></h2>
<p class="Pp">Given a coderef, saves the current state of the
    &quot;read_handler&quot;, forces it to use reliable storage (e.g. sets it to
    the master), executes a coderef and then restores the original state.</p>
<p class="Pp">Example:</p>
<p class="Pp"></p>
<pre>  my $reliably = sub {
    my $name = shift @_;
    $schema-&gt;resultset('User')-&gt;create({name=&gt;$name});
    my $user_rs = $schema-&gt;resultset('User')-&gt;find({name=&gt;$name});
    return $user_rs;
  };
  my $user_rs = $schema-&gt;storage-&gt;execute_reliably($reliably, 'John');
</pre>
<p class="Pp">Use this when you must be certain of your database state, such as
    when you just inserted something and need to get a resultset including it,
    etc.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="set_reliable_storage"><a class="permalink" href="#set_reliable_storage">set_reliable_storage</a></h2>
<p class="Pp">Sets the current <span class="Li">$schema</span> to be 'reliable',
    that is all queries, both read and write are sent to the master</p>
</section>
<section class="Ss">
<h2 class="Ss" id="set_balanced_storage"><a class="permalink" href="#set_balanced_storage">set_balanced_storage</a></h2>
<p class="Pp">Sets the current <span class="Li">$schema</span> to be use the
    &lt;/balancer&gt; for all reads, while all writes are sent to the master
    only</p>
</section>
<section class="Ss">
<h2 class="Ss" id="connected"><a class="permalink" href="#connected">connected</a></h2>
<p class="Pp">Check that the master and at least one of the replicants is
    connected.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ensure_connected"><a class="permalink" href="#ensure_connected">ensure_connected</a></h2>
<p class="Pp">Make sure all the storages are connected.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="limit_dialect"><a class="permalink" href="#limit_dialect">limit_dialect</a></h2>
<p class="Pp">Set the limit_dialect for all existing storages</p>
</section>
<section class="Ss">
<h2 class="Ss" id="quote_char"><a class="permalink" href="#quote_char">quote_char</a></h2>
<p class="Pp">Set the quote_char for all existing storages</p>
</section>
<section class="Ss">
<h2 class="Ss" id="name_sep"><a class="permalink" href="#name_sep">name_sep</a></h2>
<p class="Pp">Set the name_sep for all existing storages</p>
</section>
<section class="Ss">
<h2 class="Ss" id="set_schema"><a class="permalink" href="#set_schema">set_schema</a></h2>
<p class="Pp">Set the schema object for all existing storages</p>
</section>
<section class="Ss">
<h2 class="Ss" id="debug"><a class="permalink" href="#debug">debug</a></h2>
<p class="Pp">set a debug flag across all storages</p>
</section>
<section class="Ss">
<h2 class="Ss" id="debugobj"><a class="permalink" href="#debugobj">debugobj</a></h2>
<p class="Pp">set a debug object</p>
</section>
<section class="Ss">
<h2 class="Ss" id="debugfh"><a class="permalink" href="#debugfh">debugfh</a></h2>
<p class="Pp">set a debugfh object</p>
</section>
<section class="Ss">
<h2 class="Ss" id="debugcb"><a class="permalink" href="#debugcb">debugcb</a></h2>
<p class="Pp">set a debug callback</p>
</section>
<section class="Ss">
<h2 class="Ss" id="disconnect"><a class="permalink" href="#disconnect">disconnect</a></h2>
<p class="Pp">disconnect everything</p>
</section>
<section class="Ss">
<h2 class="Ss" id="cursor_class"><a class="permalink" href="#cursor_class">cursor_class</a></h2>
<p class="Pp">set cursor class on all storages, or return master's</p>
</section>
<section class="Ss">
<h2 class="Ss" id="cursor"><a class="permalink" href="#cursor">cursor</a></h2>
<p class="Pp">set cursor class on all storages, or return master's, alias for
    &quot;cursor_class&quot; above.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="unsafe"><a class="permalink" href="#unsafe">unsafe</a></h2>
<p class="Pp">sets the &quot;unsafe&quot; in DBIx::Class::Storage::DBI option on
    all storages or returns master's current setting</p>
</section>
<section class="Ss">
<h2 class="Ss" id="disable_sth_caching"><a class="permalink" href="#disable_sth_caching">disable_sth_caching</a></h2>
<p class="Pp">sets the &quot;disable_sth_caching&quot; in
    DBIx::Class::Storage::DBI option on all storages or returns master's current
    setting</p>
</section>
<section class="Ss">
<h2 class="Ss" id="lag_behind_master"><a class="permalink" href="#lag_behind_master">lag_behind_master</a></h2>
<p class="Pp">returns the highest Replicant &quot;lag_behind_master&quot; in
    DBIx::Class::Storage::DBI setting</p>
</section>
<section class="Ss">
<h2 class="Ss" id="is_replicating"><a class="permalink" href="#is_replicating">is_replicating</a></h2>
<p class="Pp">returns true if all replicants return true for
    &quot;is_replicating&quot; in DBIx::Class::Storage::DBI</p>
</section>
<section class="Ss">
<h2 class="Ss" id="connect_call_datetime_setup"><a class="permalink" href="#connect_call_datetime_setup">connect_call_datetime_setup</a></h2>
<p class="Pp">calls &quot;connect_call_datetime_setup&quot; in
    DBIx::Class::Storage::DBI for all storages</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="GOTCHAS"><a class="permalink" href="#GOTCHAS">GOTCHAS</a></h1>
<p class="Pp">Due to the fact that replicants can lag behind a master, you must
    take care to make sure you use one of the methods to force read queries to a
    master should you need realtime data integrity. For example, if you insert a
    row, and then immediately re-read it from the database (say, by doing
    <span class="Li">$result</span>-&gt;discard_changes) or you insert a row and
    then immediately build a query that expects that row to be an item, you
    should force the master to handle reads. Otherwise, due to the lag, there is
    no certainty your data will be in the expected state.</p>
<p class="Pp">For data integrity, all transactions automatically use the master
    storage for all read and write queries. Using a transaction is the preferred
    and recommended method to force the master to handle all read queries.</p>
<p class="Pp">Otherwise, you can force a single query to use the master with the
    'force_pool' attribute:</p>
<p class="Pp"></p>
<pre>  my $result = $resultset-&gt;search(undef, {force_pool=&gt;'master'})-&gt;find($pk);
</pre>
<p class="Pp">This attribute will safely be ignored by non replicated storages,
    so you can use the same code for both types of systems.</p>
<p class="Pp">Lastly, you can use the &quot;execute_reliably&quot; method, which
    works very much like a transaction.</p>
<p class="Pp">For debugging, you can turn replication on/off with the methods
    &quot;set_reliable_storage&quot; and &quot;set_balanced_storage&quot;,
    however this operates at a global level and is not suitable if you have a
    shared Schema object being used by multiple processes, such as on a web
    application server. You can get around this limitation by using the Schema
    clone method.</p>
<p class="Pp"></p>
<pre>  my $new_schema = $schema-&gt;clone;
  $new_schema-&gt;set_reliable_storage;
  ## $new_schema will use only the Master storage for all reads/writes while
  ## the $schema object will use replicated storage.
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="FURTHER_QUESTIONS?"><a class="permalink" href="#FURTHER_QUESTIONS?">FURTHER
  QUESTIONS?</a></h1>
<p class="Pp">Check the list of additional DBIC resources.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This module is free software copyright by the DBIx::Class (DBIC)
    authors. You can redistribute it and/or modify it under the same terms as
    the DBIx::Class library.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-01-29</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

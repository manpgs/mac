<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Data::Dump::Filtered(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Data::Dump::Filtered(3)</td>
    <td class="head-vol"><a href=".">User Contributed Perl Documentation</a></td>
    <td class="head-rtitle">Data::Dump::Filtered(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Data::Dump::Filtered - Pretty printing with filtering</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The following functions are provided:</p>
<dl class="Bl-tag">
  <dt id="add_dump_filter("><a class="permalink" href="#add_dump_filter(">add_dump_filter(
    \&amp;filter )</a></dt>
  <dd>This registers a filter function to be used by the regular
      <b>Data::Dump::dump()</b> function. By default no filters are active.
    <p class="Pp">Since registering filters has a global effect is might be more
        appropriate to use the <b>dump_filtered()</b> function instead.</p>
  </dd>
  <dt id="remove_dump_filter("><a class="permalink" href="#remove_dump_filter(">remove_dump_filter(
    \&amp;filter )</a></dt>
  <dd>Unregister the given callback function as filter callback. This undoes the
      effect of add_filter.</dd>
  <dt id="dump_filtered(...,"><a class="permalink" href="#dump_filtered(...,">dump_filtered(...,
    \&amp;filter )</a></dt>
  <dd>Works like <b>Data::Dump::dump()</b>, but the last argument should be a
      filter callback function. As objects are visited the filter callback is
      invoked at it might influence how objects are dumped.
    <p class="Pp">Any filters registered with <b>add_filter()</b> are ignored
        when this interface is invoked. Actually, passing
        <span class="Li">&quot;undef&quot;</span> as \&amp;filter is allowed and
        <span class="Li">&quot;dump_filtered(..., undef)&quot;</span> is the
        official way to force unfiltered dumps.</p>
  </dd>
</dl>
<section class="Ss">
<h2 class="Ss" id="Filter_callback"><a class="permalink" href="#Filter_callback">Filter
  callback</a></h2>
<p class="Pp">A filter callback is a function that will be invoked with 2
    arguments; a context object and reference to the object currently visited.
    The return value should either be a hash reference or
    <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp"></p>
<pre>    sub filter_callback {
        my($ctx, $object_ref) = @_;
        ...
        return { ... }
    }
</pre>
<p class="Pp">If the filter callback returns
    <span class="Li">&quot;undef&quot;</span> (or nothing) then normal
    processing and formatting of the visited object happens. If the filter
    callback returns a hash it might replace or annotate the representation of
    the current object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Filter_context"><a class="permalink" href="#Filter_context">Filter
  context</a></h2>
<p class="Pp">The context object provide methods that can be used to determine
    what kind of object is currently visited and where it's located. The context
    object has the following interface:</p>
<dl class="Bl-tag">
  <dt>$ctx-&gt;object_ref</dt>
  <dd>Alternative way to obtain a reference to the current object</dd>
  <dt>$ctx-&gt;class</dt>
  <dd>If the object is blessed this return the class. Returns &quot;&quot; for
      objects not blessed.</dd>
  <dt>$ctx-&gt;reftype</dt>
  <dd>Returns what kind of object this is. It's a string like
      &quot;SCALAR&quot;, &quot;ARRAY&quot;, &quot;HASH&quot;,
      &quot;CODE&quot;,...</dd>
  <dt>$ctx-&gt;is_ref</dt>
  <dd>Returns true if a reference was provided.</dd>
  <dt>$ctx-&gt;is_blessed</dt>
  <dd>Returns true if the object is blessed. Actually, this is just an alias for
      <span class="Li">&quot;$ctx-&gt;class&quot;</span>.</dd>
  <dt>$ctx-&gt;is_array</dt>
  <dd>Returns true if the object is an array</dd>
  <dt>$ctx-&gt;is_hash</dt>
  <dd>Returns true if the object is a hash</dd>
  <dt>$ctx-&gt;is_scalar</dt>
  <dd>Returns true if the object is a scalar (a string or a number)</dd>
  <dt>$ctx-&gt;is_code</dt>
  <dd>Returns true if the object is a function (aka subroutine)</dd>
  <dt>$ctx-&gt;container_class</dt>
  <dd>Returns the class of the innermost container that contains this object.
      Returns &quot;&quot; if there is no blessed container.</dd>
  <dt>$ctx-&gt;container_self</dt>
  <dd>Returns an textual expression relative to the container object that names
      this object. The variable <span class="Li">$self</span> in this expression
      is the container itself.</dd>
  <dt>$ctx-&gt;object_isa( $class )</dt>
  <dd>Returns TRUE if the current object is of the given class or is of a
      subclass.</dd>
  <dt>$ctx-&gt;container_isa( $class )</dt>
  <dd>Returns TRUE if the innermost container is of the given class or is of a
      subclass.</dd>
  <dt>$ctx-&gt;depth</dt>
  <dd>Returns how many levels deep have we recursed into the structure (from the
      original <b>dump_filtered()</b> arguments).</dd>
  <dt>$ctx-&gt;expr</dt>
  <dd></dd>
  <dt>$ctx-&gt;expr( $top_level_name )</dt>
  <dd>Returns an textual expression that denotes the current object. In the
      expression <span class="Li">$var</span> is used as the name of the top
      level object dumped. This can be overridden by providing a different name
      as argument.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Filter_return_hash"><a class="permalink" href="#Filter_return_hash">Filter
  return hash</a></h2>
<p class="Pp">The following elements has significance in the returned hash:</p>
<dl class="Bl-tag">
  <dt id="dump"><a class="permalink" href="#dump">dump =&gt; $string</a></dt>
  <dd>incorporate the given string as the representation for the current
    value</dd>
  <dt id="object"><a class="permalink" href="#object">object =&gt;
    $value</a></dt>
  <dd>dump the given value instead of the one visited and passed in as
      <span class="Li">$object</span>. Basically the same as specifying
      <span class="Li">&quot;dump =&gt;
    Data::Dump::dump($value)&quot;</span>.</dd>
  <dt id="comment"><a class="permalink" href="#comment">comment =&gt;
    $comment</a></dt>
  <dd>prefix the value with the given comment string</dd>
  <dt id="bless"><a class="permalink" href="#bless">bless =&gt; $class</a></dt>
  <dd>make it look as if the current object is of the given
      <span class="Li">$class</span> instead of the class it really has (if
      any). The internals of the object is dumped in the regular way. The
      <span class="Li">$class</span> can be the empty string to make Data::Dump
      pretend the object wasn't blessed at all.</dd>
  <dt id="hide_keys"><a class="permalink" href="#hide_keys">hide_keys =&gt;
    ['key1', 'key2',...]</a></dt>
  <dd></dd>
  <dt id="hide_keys~2"><a class="permalink" href="#hide_keys~2">hide_keys =&gt;
    \&amp;code</a></dt>
  <dd>If the <span class="Li">$object</span> is a hash dump is as normal but
      pretend that the listed keys did not exist. If the argument is a function
      then the function is called to determine if the given key should be
      hidden.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Data::Dump</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-05-10</td>
    <td class="foot-os"><a href="..">perl v5.34.0</a></td>
  </tr>
</table>
</body>
</html>

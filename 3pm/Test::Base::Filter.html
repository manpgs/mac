<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Test::Base::Filter(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Test::Base::Filter(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Test::Base::Filter(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Test::Base::Filter - Default Filter Class for Test::Base</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>      package MyTestSuite;
      use Test::Base -Base;
      ... reusable testing code ...
      package MyTestSuite::Filter;
      use Test::Base::Filter -Base;
      sub my_filter1 {
          ...
      }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Filters are the key to writing effective data driven tests with
    Test::Base. Test::Base::Filter is a class containing a large default set of
    generic filters. You can easily subclass it to add/override
  functionality.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FILTERS"><a class="permalink" href="#FILTERS">FILTERS</a></h1>
<p class="Pp">This is a list of the default stock filters (in alphabetic
  order):</p>
<dl class="Bl-tag">
  <dt>&quot;append&quot;</dt>
  <dd>list =&gt; list
    <p class="Pp">Append a string to each element of a list.</p>
    <p class="Pp"></p>
    <pre>    --- numbers lines chomp append=-#\n join
    one
    two
    three
    </pre>
  </dd>
  <dt>&quot;array&quot;</dt>
  <dd>list =&gt; scalar
    <p class="Pp">Turn a list of values into an anonymous array reference.</p>
  </dd>
  <dt>&quot;base64_decode&quot;</dt>
  <dd>scalar =&gt; scalar
    <p class="Pp">Decode base64 data. Useful for binary tests.</p>
  </dd>
  <dt>&quot;base64_encode&quot;</dt>
  <dd>scalar =&gt; scalar
    <p class="Pp">Encode base64 data. Useful for binary tests.</p>
  </dd>
  <dt>&quot;chomp&quot;</dt>
  <dd>list =&gt; list
    <p class="Pp">Remove the final newline from each string value in a list.</p>
  </dd>
  <dt>&quot;chop&quot;</dt>
  <dd></dd>
</dl>
<p class="Pp">list =&gt; list</p>
<p class="Pp"></p>
<pre>    Remove the final char from each string value in a list.
</pre>
<dl class="Bl-tag">
  <dt>&quot;dumper&quot;</dt>
  <dd>scalar =&gt; list
    <p class="Pp">Take a data structure (presumably from another filter like
        eval) and use Data::Dumper to dump it in a canonical fashion.</p>
  </dd>
  <dt>&quot;escape&quot;</dt>
  <dd>scalar =&gt; scalar
    <p class="Pp">Unescape all backslash escaped chars.</p>
  </dd>
  <dt>&quot;eval&quot;</dt>
  <dd>scalar =&gt; list
    <p class="Pp">Run Perl's <span class="Li">&quot;eval&quot;</span> command
        against the data and use the returned value as the data.</p>
  </dd>
  <dt>&quot;eval_all&quot;</dt>
  <dd>scalar =&gt; list
    <p class="Pp">Run Perl's <span class="Li">&quot;eval&quot;</span> command
        against the data and return a list of 4 values:</p>
    <p class="Pp"></p>
    <pre>    1) The return value
    2) The error in $@
    3) Captured STDOUT
    4) Captured STDERR
    </pre>
  </dd>
  <dt>&quot;eval_stderr&quot;</dt>
  <dd>scalar =&gt; scalar
    <p class="Pp">Run Perl's <span class="Li">&quot;eval&quot;</span> command
        against the data and return the captured STDERR.</p>
  </dd>
  <dt>&quot;eval_stdout&quot;</dt>
  <dd>scalar =&gt; scalar
    <p class="Pp">Run Perl's <span class="Li">&quot;eval&quot;</span> command
        against the data and return the captured STDOUT.</p>
  </dd>
  <dt>&quot;exec_perl_stdout&quot;</dt>
  <dd>list =&gt; scalar
    <p class="Pp">Input Perl code is written to a temp file and run. STDOUT is
        captured and returned.</p>
  </dd>
  <dt>&quot;flatten&quot;</dt>
  <dd>scalar =&gt; list
    <p class="Pp">Takes a hash or array ref and flattens it to a list.</p>
  </dd>
  <dt>&quot;get_url&quot;</dt>
  <dd>scalar =&gt; scalar
    <p class="Pp">The text is chomped and considered to be a url. Then
        LWP::Simple::get is used to fetch the contents of the url.</p>
  </dd>
  <dt>&quot;hash&quot;</dt>
  <dd>list =&gt; scalar
    <p class="Pp">Turn a list of key/value pairs into an anonymous hash
        reference.</p>
  </dd>
  <dt>&quot;head[=number]&quot;</dt>
  <dd>list =&gt; list
    <p class="Pp">Takes a list and returns a number of the elements from the
        front of it. The default number is one.</p>
  </dd>
  <dt>&quot;join&quot;</dt>
  <dd>list =&gt; scalar
    <p class="Pp">Join a list of strings into a scalar.</p>
  </dd>
  <dt>&quot;Join&quot;</dt>
  <dd>Join the list of strings inside a list of array refs and return the
      strings in place of the array refs.</dd>
  <dt>&quot;lines&quot;</dt>
  <dd>scalar =&gt; list
    <p class="Pp">Break the data into an anonymous array of lines. Each line
        (except possibly the last one if the
        <span class="Li">&quot;chomp&quot;</span> filter came first) will have a
        newline at the end.</p>
  </dd>
  <dt>&quot;norm&quot;</dt>
  <dd>scalar =&gt; scalar
    <p class="Pp">Normalize the data. Change non-Unix line endings to Unix line
        endings.</p>
  </dd>
  <dt>&quot;prepend=string&quot;</dt>
  <dd>list =&gt; list
    <p class="Pp">Prepend a string onto each of a list of strings.</p>
  </dd>
  <dt>&quot;read_file&quot;</dt>
  <dd>scalar =&gt; scalar
    <p class="Pp">Read the file named by the current content and return the
        file's content.</p>
  </dd>
  <dt>&quot;regexp[=xism]&quot;</dt>
  <dd>scalar =&gt; scalar
    <p class="Pp">The <span class="Li">&quot;regexp&quot;</span> filter will
        turn your data section into a regular expression object. You can pass in
        extra flags after an equals sign.</p>
    <p class="Pp">If the text contains more than one line and no flags are
        specified, then the 'xism' flags are assumed.</p>
  </dd>
  <dt>&quot;reverse&quot;</dt>
  <dd>list =&gt; list
    <p class="Pp">Reverse the elements of a list.</p>
  </dd>
  <dt>&quot;Reverse&quot;</dt>
  <dd>list =&gt; list
    <p class="Pp">Reverse the list of strings inside a list of array refs.</p>
  </dd>
  <dt>&quot;slice=x[,y]&quot;</dt>
  <dd>list =&gt; list
    <p class="Pp">Returns the element number x through element number y of a
        list.</p>
  </dd>
  <dt>&quot;sort&quot;</dt>
  <dd>list =&gt; list
    <p class="Pp">Sorts the elements of a list in character sort order.</p>
  </dd>
  <dt>&quot;Sort&quot;</dt>
  <dd>list =&gt; list
    <p class="Pp">Sort the list of strings inside a list of array refs.</p>
  </dd>
  <dt>&quot;split[=string|pattern]&quot;</dt>
  <dd>scalar =&gt; list
    <p class="Pp">Split a string in into a list. Takes a optional string or
        regexp as a parameter. Defaults to <i>s+</i>. Same as Perl
        <span class="Li">&quot;split&quot;</span>.</p>
  </dd>
  <dt>&quot;Split[=string|pattern]&quot;</dt>
  <dd>list =&gt; list
    <p class="Pp">Split each of a list of strings and turn them into array
      refs.</p>
  </dd>
  <dt>&quot;strict&quot;</dt>
  <dd>scalar =&gt; scalar
    <p class="Pp">Prepend the string:</p>
    <p class="Pp"></p>
    <pre>    use strict;
    use warnings;
    </pre>
    <p class="Pp">to the block's text.</p>
  </dd>
  <dt>&quot;tail[=number]&quot;</dt>
  <dd>list =&gt; list
    <p class="Pp">Return a number of elements from the end of a list. The
        default number is one.</p>
  </dd>
  <dt>&quot;trim&quot;</dt>
  <dd>list =&gt; list
    <p class="Pp">Remove extra blank lines from the beginning and end of the
        data. This allows you to visually separate your test data with blank
        lines.</p>
  </dd>
  <dt>&quot;unchomp&quot;</dt>
  <dd>list =&gt; list
    <p class="Pp">Add a newline to each string value in a list.</p>
  </dd>
  <dt>&quot;write_file[=filename]&quot;</dt>
  <dd>scalar =&gt; scalar
    <p class="Pp">Write the content of the section to the named file. Return the
        filename.</p>
  </dd>
  <dt>&quot;yaml&quot;</dt>
  <dd>scalar =&gt; list
    <p class="Pp">Apply the YAML::Load function to the data block and use the
        resultant structure. Requires YAML.pm.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Ingy d&#x00F6;t Net &lt;ingy@cpan.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 2005-2018. Ingy d&#x00F6;t Net. All rights reserved.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">See &lt;http://www.perl.com/perl/misc/Artistic.html&gt;</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-04-19</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

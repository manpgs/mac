<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>DBD::DBM(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBD::DBM(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBD::DBM(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">DBD::DBM - a DBI driver for DBM &amp; MLDBM files</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
 use DBI;
 $dbh = DBI-&gt;connect('dbi:DBM:');                    # defaults to SDBM_File
 $dbh = DBI-&gt;connect('DBI:DBM(RaiseError=1):');      # defaults to SDBM_File
 $dbh = DBI-&gt;connect('dbi:DBM:dbm_type=DB_File');    # defaults to DB_File
 $dbh = DBI-&gt;connect('dbi:DBM:dbm_mldbm=Storable');  # MLDBM with SDBM_File

 # or
 $dbh = DBI-&gt;connect('dbi:DBM:', undef, undef);
 $dbh = DBI-&gt;connect('dbi:DBM:', undef, undef, {
     f_ext              =&gt; '.db/r',
     f_dir              =&gt; '/path/to/dbfiles/',
     f_lockfile         =&gt; '.lck',
     dbm_type           =&gt; 'BerkeleyDB',
     dbm_mldbm          =&gt; 'FreezeThaw',
     dbm_store_metadata =&gt; 1,
     dbm_berkeley_flags =&gt; {
         '-Cachesize' =&gt; 1000, # set a ::Hash flag
     },
 });
</pre>
<p class="Pp">and other variations on <i>connect()</i> as shown in the DBI docs,
    DBD::File metadata and &quot;Metadata&quot; shown below.</p>
<p class="Pp">Use standard DBI prepare, execute, fetch, placeholders, etc., see
    &quot;QUICK START&quot; for an example.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">DBD::DBM is a database management system that works right out of
    the box. If you have a standard installation of Perl and DBI you can begin
    creating, accessing, and modifying simple database tables without any
    further modules. You can add other modules (e.g., SQL::Statement, DB_File
    etc) for improved functionality.</p>
<p class="Pp">The module uses a DBM file storage layer. DBM file storage is
    common on many platforms and files can be created with it in many
    programming languages using different APIs. That means, in addition to
    creating files with DBI/SQL, you can also use DBI/SQL to access and modify
    files created by other DBM modules and programs and vice versa. <b>Note</b>
    that in those cases it might be necessary to use a common subset of the
    provided features.</p>
<p class="Pp">DBM files are stored in binary format optimized for quick
    retrieval when using a key field. That optimization can be used
    advantageously to make DBD::DBM SQL operations that use key fields very
    fast. There are several different &quot;flavors&quot; of DBM which use
    different storage formats supported by perl modules such as SDBM_File and
    MLDBM. This module supports all of the flavors that perl supports and, when
    used with MLDBM, supports tables with any number of columns and insertion of
    Perl objects into tables.</p>
<p class="Pp">DBD::DBM has been tested with the following DBM types: SDBM_File,
    NDBM_File, ODBM_File, GDBM_File, DB_File, BerkeleyDB. Each type was tested
    both with and without MLDBM and with the Data::Dumper, Storable, FreezeThaw,
    YAML and JSON serializers using the DBI::SQL::Nano or the SQL::Statement
    engines.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="QUICK_START"><a class="permalink" href="#QUICK_START">QUICK
  START</a></h1>
<p class="Pp">DBD::DBM operates like all other DBD drivers - it's basic syntax
    and operation is specified by DBI. If you're not familiar with DBI, you
    should start by reading DBI and the documents it points to and then come
    back and read this file. If you are familiar with DBI, you already know most
    of what you need to know to operate this module. Just jump in and create a
    test script something like the one shown below.</p>
<p class="Pp">You should be aware that there are several options for the SQL
    engine underlying DBD::DBM, see &quot;Supported SQL syntax&quot;. There are
    also many options for DBM support, see especially the section on
    &quot;Adding multi-column support with MLDBM&quot;.</p>
<p class="Pp">But here's a sample to get you started.</p>
<p class="Pp"></p>
<pre>
 use DBI;
 my $dbh = DBI-&gt;connect('dbi:DBM:');
 $dbh-&gt;{RaiseError} = 1;
 for my $sql( split /;\n+/,&quot;
     CREATE TABLE user ( user_name TEXT, phone TEXT );
     INSERT INTO user VALUES ('Fred Bloggs','233-7777');
     INSERT INTO user VALUES ('Sanjay Patel','777-3333');
     INSERT INTO user VALUES ('Junk','xxx-xxxx');
     DELETE FROM user WHERE user_name = 'Junk';
     UPDATE user SET phone = '999-4444' WHERE user_name = 'Sanjay Patel';
     SELECT * FROM user
 &quot;){
     my $sth = $dbh-&gt;prepare($sql);
     $sth-&gt;execute;
     $sth-&gt;dump_results if $sth-&gt;{NUM_OF_FIELDS};
 }
 $dbh-&gt;disconnect;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="USAGE"><a class="permalink" href="#USAGE">USAGE</a></h1>
<p class="Pp">This section will explain some usage cases in more detail. To get
    an overview about the available attributes, see &quot;Metadata&quot;.</p>
<section class="Ss">
<h2 class="Ss" id="Specifying_Files_and_Directories"><a class="permalink" href="#Specifying_Files_and_Directories">Specifying
  Files and Directories</a></h2>
<p class="Pp">DBD::DBM will automatically supply an appropriate file extension
    for the type of DBM you are using. For example, if you use SDBM_File, a
    table called &quot;fruit&quot; will be stored in two files called
    &quot;fruit.pag&quot; and &quot;fruit.dir&quot;. You should <b>never</b>
    specify the file extensions in your SQL statements.</p>
<p class="Pp">DBD::DBM recognizes following default extensions for following
    types:</p>
<dl class="Bl-tag">
  <dt>.pag/r</dt>
  <dd>Chosen for dbm_type <span class="Li">&quot;SDBM_File&quot;</span>,
      <span class="Li">&quot;ODBM_File&quot;</span> and
      <span class="Li">&quot;NDBM_File&quot;</span> when an implementation is
      detected which wraps <span class="Li">&quot;-ldbm&quot;</span> for
      <span class="Li">&quot;NDBM_File&quot;</span> (e.g. Solaris, AIX, ...).
    <p class="Pp">For those types, the <span class="Li">&quot;.dir&quot;</span>
        extension is recognized, too (for being deleted when dropping a
      table).</p>
  </dd>
  <dt>.db/r</dt>
  <dd>Chosen for dbm_type <span class="Li">&quot;NDBM_File&quot;</span> when an
      implementation is detected which wraps BerkeleyDB 1.x for
      <span class="Li">&quot;NDBM_File&quot;</span> (typically BSD's,
    Darwin).</dd>
</dl>
<p class="Pp"><span class="Li">&quot;GDBM_File&quot;</span>,
    <span class="Li">&quot;DB_File&quot;</span> and
    <span class="Li">&quot;BerkeleyDB&quot;</span> don't usually use a file
    extension.</p>
<p class="Pp">If your DBM type uses an extension other than one of the
    recognized types of extensions, you should set the <i>f_ext</i> attribute to
    the extension <b>and</b> file a bug report as described in DBI with the name
    of the implementation and extension so we can add it to DBD::DBM. Thanks in
    advance for that :-).</p>
<p class="Pp"></p>
<pre>
  $dbh = DBI-&gt;connect('dbi:DBM:f_ext=.db');  # .db extension is used
  $dbh = DBI-&gt;connect('dbi:DBM:f_ext=');     # no extension is used

  # or
  $dbh-&gt;{f_ext}='.db';                       # global setting
  $dbh-&gt;{f_meta}-&gt;{'qux'}-&gt;{f_ext}='.db';    # setting for table 'qux'
</pre>
<p class="Pp">By default files are assumed to be in the current working
    directory. To use other directories specify the <i>f_dir</i> attribute in
    either the connect string or by setting the database handle attribute.</p>
<p class="Pp">For example, this will look for the file /foo/bar/fruit (or
    /foo/bar/fruit.pag for DBM types that use that extension)</p>
<p class="Pp"></p>
<pre>
  my $dbh = DBI-&gt;connect('dbi:DBM:f_dir=/foo/bar');
  # and this will too:
  my $dbh = DBI-&gt;connect('dbi:DBM:');
  $dbh-&gt;{f_dir} = '/foo/bar';
  # but this is recommended
  my $dbh = DBI-&gt;connect('dbi:DBM:', undef, undef, { f_dir =&gt; '/foo/bar' } );

  # now you can do
  my $ary = $dbh-&gt;selectall_arrayref(q{ SELECT x FROM fruit });
</pre>
<p class="Pp">You can also use delimited identifiers to specify paths directly
    in SQL statements. This looks in the same place as the two examples above
    but without setting <i>f_dir</i>:</p>
<p class="Pp"></p>
<pre>
   my $dbh = DBI-&gt;connect('dbi:DBM:');
   my $ary = $dbh-&gt;selectall_arrayref(q{
       SELECT x FROM &quot;/foo/bar/fruit&quot;
   });
</pre>
<p class="Pp">You can also tell DBD::DBM to use a specified path for a specific
    table:</p>
<p class="Pp"></p>
<pre>
  $dbh-&gt;{dbm_tables}-&gt;{f}-&gt;{file} = q(/foo/bar/fruit);
</pre>
<p class="Pp">Please be aware that you cannot specify this during
  connection.</p>
<p class="Pp">If you have SQL::Statement installed, you can use table
  aliases:</p>
<p class="Pp"></p>
<pre>
   my $dbh = DBI-&gt;connect('dbi:DBM:');
   my $ary = $dbh-&gt;selectall_arrayref(q{
       SELECT f.x FROM &quot;/foo/bar/fruit&quot; AS f
   });
</pre>
<p class="Pp">See the &quot;GOTCHAS AND WARNINGS&quot; for using DROP on
  tables.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Table_locking_and_"><a class="permalink" href="#Table_locking_and_">Table
  locking and <i>flock()</i></a></h2>
<p class="Pp">Table locking is accomplished using a lockfile which has the same
    basename as the table's file but with the file extension '.lck' (or a
    lockfile extension that you supply, see below). This lock file is created
    with the table during a CREATE and removed during a DROP. Every time the
    table itself is opened, the lockfile is <i>flocked()</i>. For SELECT, this
    is a shared lock. For all other operations, it is an exclusive lock (except
    when you specify something different using the <i>f_lock</i> attribute).</p>
<p class="Pp">Since the locking depends on <i>flock()</i>, it only works on
    operating systems that support <i>flock()</i>. In cases where <i>flock()</i>
    is not implemented, DBD::DBM will simply behave as if the <i>flock()</i> had
    occurred although no actual locking will happen. Read the documentation for
    <i>flock()</i> for more information.</p>
<p class="Pp">Even on those systems that do support <i>flock()</i>, locking is
    only advisory - as is always the case with <i>flock()</i>. This means that
    if another program tries to access the table file while DBD::DBM has the
    table locked, that other program will *succeed* at opening unless it is also
    using flock on the '.lck' file. As a result DBD::DBM's locking only really
    applies to other programs using DBD::DBM or other program written to
    cooperate with DBD::DBM locking.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Specifying_the_"><a class="permalink" href="#Specifying_the_">Specifying
  the DBM type</a></h2>
<p class="Pp">Each &quot;flavor&quot; of DBM stores its files in a different
    format and has different capabilities and limitations. See AnyDBM_File for a
    comparison of DBM types.</p>
<p class="Pp">By default, DBD::DBM uses the
    <span class="Li">&quot;SDBM_File&quot;</span> type of storage since
    <span class="Li">&quot;SDBM_File&quot;</span> comes with Perl itself. If you
    have other types of DBM storage available, you can use any of them with
    DBD::DBM. It is strongly recommended to use at least
    <span class="Li">&quot;DB_File&quot;</span>, because
    <span class="Li">&quot;SDBM_File&quot;</span> has quirks and limitations and
    <span class="Li">&quot;ODBM_file&quot;</span>,
    <span class="Li">&quot;NDBM_File&quot;</span> and
    <span class="Li">&quot;GDBM_File&quot;</span> are not always available.</p>
<p class="Pp">You can specify the DBM type using the <i>dbm_type</i> attribute
    which can be set in the connection string or with
    <span class="Li">&quot;$dbh-&gt;{dbm_type}&quot;</span> and
    <span class="Li">&quot;$dbh-&gt;{f_meta}-&gt;{$table_name}-&gt;{type}&quot;</span>
    for per-table settings in cases where a single script is accessing more than
    one kind of DBM file.</p>
<p class="Pp">In the connection string, just set
    <span class="Li">&quot;dbm_type=TYPENAME&quot;</span> where
    <span class="Li">&quot;TYPENAME&quot;</span> is any DBM type such as
    GDBM_File, DB_File, etc. Do <i>not</i> use MLDBM as your <i>dbm_type</i> as
    that is set differently, see below.</p>
<p class="Pp"></p>
<pre>
 my $dbh=DBI-&gt;connect('dbi:DBM:');                # uses the default SDBM_File
 my $dbh=DBI-&gt;connect('dbi:DBM:dbm_type=GDBM_File'); # uses the GDBM_File

 # You can also use $dbh-&gt;{dbm_type} to set the DBM type for the connection:
 $dbh-&gt;{dbm_type} = 'DB_File';    # set the global DBM type
 print $dbh-&gt;{dbm_type};          # display the global DBM type
</pre>
<p class="Pp">If you have several tables in your script that use different DBM
    types, you can use the <span class="Li">$dbh</span>-&gt;{dbm_tables} hash to
    store different settings for the various tables. You can even use this to
    perform joins on files that have completely different storage
  mechanisms.</p>
<p class="Pp"></p>
<pre>
 # sets global default of GDBM_File
 my $dbh-&gt;('dbi:DBM:type=GDBM_File');

 # overrides the global setting, but only for the tables called
 # I&lt;foo&gt; and I&lt;bar&gt;
 my $dbh-&gt;{f_meta}-&gt;{foo}-&gt;{dbm_type} = 'DB_File';
 my $dbh-&gt;{f_meta}-&gt;{bar}-&gt;{dbm_type} = 'BerkeleyDB';

 # prints the dbm_type for the table &quot;foo&quot;
 print $dbh-&gt;{f_meta}-&gt;{foo}-&gt;{dbm_type};
</pre>
<p class="Pp"><b>Note</b> that you must change the <i>dbm_type</i> of a table
    before you access it for first time.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Adding_multi-column_support_with_"><a class="permalink" href="#Adding_multi-column_support_with_">Adding
  multi-column support with MLDBM</a></h2>
<p class="Pp">Most of the DBM types only support two columns and even if it
    would support more, DBD::DBM would only use two. However a CPAN module
    called MLDBM overcomes this limitation by allowing more than two columns.
    MLDBM does this by serializing the data - basically it puts a reference to
    an array into the second column. It can also put almost any kind of Perl
    object or even <b>Perl coderefs</b> into columns.</p>
<p class="Pp">If you want more than two columns, you <b>must</b> install MLDBM.
    It's available for many platforms and is easy to install.</p>
<p class="Pp">MLDBM is by default distributed with three serializers -
    Data::Dumper, Storable, and FreezeThaw. Data::Dumper is the default and
    Storable is the fastest. MLDBM can also make use of user-defined
    serialization methods or other serialization modules (e.g. YAML::MLDBM or
    MLDBM::Serializer::JSON. You select the serializer using the
    <i>dbm_mldbm</i> attribute.</p>
<p class="Pp">Some examples:</p>
<p class="Pp"></p>
<pre>
 $dbh=DBI-&gt;connect('dbi:DBM:dbm_mldbm=Storable');  # use MLDBM with Storable
 $dbh=DBI-&gt;connect(
    'dbi:DBM:dbm_mldbm=MySerializer' # use MLDBM with a user defined module
 );
 $dbh=DBI-&gt;connect('dbi::dbm:', undef,
     undef, { dbm_mldbm =&gt; 'YAML' }); # use 3rd party serializer
 $dbh-&gt;{dbm_mldbm} = 'YAML'; # same as above
 print $dbh-&gt;{dbm_mldbm} # show the MLDBM serializer
 $dbh-&gt;{f_meta}-&gt;{foo}-&gt;{dbm_mldbm}='Data::Dumper';   # set Data::Dumper for table &quot;foo&quot;
 print $dbh-&gt;{f_meta}-&gt;{foo}-&gt;{mldbm}; # show serializer for table &quot;foo&quot;
</pre>
<p class="Pp">MLDBM works on top of other DBM modules so you can also set a DBM
    type along with setting dbm_mldbm. The examples above would default to using
    SDBM_File with MLDBM. If you wanted GDBM_File instead, here's how:</p>
<p class="Pp"></p>
<pre>
 # uses DB_File with MLDBM and Storable
 $dbh = DBI-&gt;connect('dbi:DBM:', undef, undef, {
     dbm_type  =&gt; 'DB_File',
     dbm_mldbm =&gt; 'Storable',
 });
</pre>
<p class="Pp">SDBM_File, the default <i>dbm_type</i> is quite limited, so if you
    are going to use MLDBM, you should probably use a different type, see
    AnyDBM_File.</p>
<p class="Pp">See below for some &quot;GOTCHAS AND WARNINGS&quot; about
  MLDBM.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Support_for_Berkeley_"><a class="permalink" href="#Support_for_Berkeley_">Support
  for Berkeley DB</a></h2>
<p class="Pp">The Berkeley DB storage type is supported through two different
    Perl modules - DB_File (which supports only features in old versions of
    Berkeley DB) and BerkeleyDB (which supports all versions). DBD::DBM supports
    specifying either &quot;DB_File&quot; or &quot;BerkeleyDB&quot; as a
    <i>dbm_type</i>, with or without MLDBM support.</p>
<p class="Pp">The &quot;BerkeleyDB&quot; dbm_type is experimental and it's
    interface is likely to change. It currently defaults to BerkeleyDB::Hash and
    does not currently support ::Btree or ::Recno.</p>
<p class="Pp">With BerkeleyDB, you can specify initialization flags by setting
    them in your script like this:</p>
<p class="Pp"></p>
<pre>
 use BerkeleyDB;
 my $env = new BerkeleyDB::Env -Home =&gt; $dir;  # and/or other Env flags
 $dbh = DBI-&gt;connect('dbi:DBM:', undef, undef, {
     dbm_type  =&gt; 'BerkeleyDB',
     dbm_mldbm =&gt; 'Storable',
     dbm_berkeley_flags =&gt; {
         'DB_CREATE'  =&gt; DB_CREATE,  # pass in constants
         'DB_RDONLY'  =&gt; DB_RDONLY,  # pass in constants
         '-Cachesize' =&gt; 1000,       # set a ::Hash flag
         '-Env'       =&gt; $env,       # pass in an environment
     },
 });
</pre>
<p class="Pp">Do <i>not</i> set the -Flags or -Filename flags as those are
    determined and overwritten by the SQL (e.g. -Flags =&gt; DB_RDONLY is set
    automatically when you issue a SELECT statement).</p>
<p class="Pp">Time has not permitted us to provide support in this release of
    DBD::DBM for further Berkeley DB features such as transactions, concurrency,
    locking, etc. We will be working on these in the future and would value
    suggestions, patches, etc.</p>
<p class="Pp">See DB_File and BerkeleyDB for further details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Optimizing_the_use_of_key_fields"><a class="permalink" href="#Optimizing_the_use_of_key_fields">Optimizing
  the use of key fields</a></h2>
<p class="Pp">Most &quot;flavors&quot; of DBM have only two physical columns
    (but can contain multiple logical columns as explained above in &quot;Adding
    multi-column support with MLDBM&quot;). They work similarly to a Perl hash
    with the first column serving as the key. Like a Perl hash, DBM files permit
    you to do quick lookups by specifying the key and thus avoid looping through
    all records (supported by DBI::SQL::Nano only). Also like a Perl hash, the
    keys must be unique. It is impossible to create two records with the same
    key. To put this more simply and in SQL terms, the key column functions as
    the <i>PRIMARY KEY</i> or UNIQUE INDEX.</p>
<p class="Pp">In DBD::DBM, you can take advantage of the speed of keyed lookups
    by using DBI::SQL::Nano and a WHERE clause with a single equal comparison on
    the key field. For example, the following SQL statements are optimized for
    keyed lookup:</p>
<p class="Pp"></p>
<pre>
 CREATE TABLE user ( user_name TEXT, phone TEXT);
 INSERT INTO user VALUES ('Fred Bloggs','233-7777');
 # ... many more inserts
 SELECT phone FROM user WHERE user_name='Fred Bloggs';
</pre>
<p class="Pp">The &quot;user_name&quot; column is the key column since it is the
    first column. The SELECT statement uses the key column in a single equal
    comparison - &quot;user_name='Fred Bloggs'&quot; - so the search will find
    it very quickly without having to loop through all the names which were
    inserted into the table.</p>
<p class="Pp">In contrast, these searches on the same table are not
  optimized:</p>
<p class="Pp"></p>
<pre>
 1. SELECT phone FROM user WHERE user_name &lt; 'Fred';
 2. SELECT user_name FROM user WHERE phone = '233-7777';
</pre>
<p class="Pp">In #1, the operation uses a less-than (&lt;) comparison rather
    than an equals comparison, so it will not be optimized for key searching. In
    #2, the key field &quot;user_name&quot; is not specified in the WHERE
    clause, and therefore the search will need to loop through all rows to find
    the requested row(s).</p>
<p class="Pp"><b>Note</b> that the underlying DBM storage needs to loop over all
    <i>key/value</i> pairs when the optimized fetch is used. SQL::Statement has
    a massively improved where clause evaluation which costs around 15% of the
    evaluation in DBI::SQL::Nano - combined with the loop in the DBM storage the
    speed improvement isn't so impressive.</p>
<p class="Pp">Even if lookups are faster by around 50%, DBI::SQL::Nano and
    SQL::Statement can benefit from the key field optimizations on updating and
    deleting rows - and here the improved where clause evaluation of
    SQL::Statement might beat DBI::SQL::Nano every time the where clause
    contains not only the key field (or more than one).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Supported_"><a class="permalink" href="#Supported_">Supported
  SQL syntax</a></h2>
<p class="Pp">DBD::DBM uses a subset of SQL. The robustness of that subset
    depends on what other modules you have installed. Both options support basic
    SQL operations including CREATE TABLE, DROP TABLE, INSERT, DELETE, UPDATE,
    and SELECT.</p>
<p class="Pp"><b>Option #1:</b> By default, this module inherits its SQL support
    from DBI::SQL::Nano that comes with DBI. Nano is, as its name implies, a
    *very* small SQL engine. Although limited in scope, it is faster than option
    #2 for some operations (especially single <i>primary key</i> lookups). See
    DBI::SQL::Nano for a description of the SQL it supports and comparisons of
    it with option #2.</p>
<p class="Pp"><b>Option #2:</b> If you install the pure Perl CPAN module
    SQL::Statement, DBD::DBM will use it instead of Nano. This adds support for
    table aliases, functions, joins, and much more. If you're going to use
    DBD::DBM for anything other than very simple tables and queries, you should
    install SQL::Statement. You don't have to change DBD::DBM or your scripts in
    any way, simply installing SQL::Statement will give you the more robust SQL
    capabilities without breaking scripts written for DBI::SQL::Nano. See
    SQL::Statement for a description of the SQL it supports.</p>
<p class="Pp">To find out which SQL module is working in a given script, you can
    use the <i>dbm_versions()</i> method or, if you don't need the full output
    and version numbers, just do this:</p>
<p class="Pp"></p>
<pre>
 print $dbh-&gt;{sql_handler}, &quot;\n&quot;;
</pre>
<p class="Pp">That will print out either &quot;SQL::Statement&quot; or
    &quot;DBI::SQL::Nano&quot;.</p>
<p class="Pp">Baring the section about optimized access to the DBM storage in
    mind, comparing the benefits of both engines:</p>
<p class="Pp"></p>
<pre>
  # DBI::SQL::Nano is faster
  $sth = $dbh-&gt;prepare( &quot;update foo set value='new' where key=15&quot; );
  $sth-&gt;execute();
  $sth = $dbh-&gt;prepare( &quot;delete from foo where key=27&quot; );
  $sth-&gt;execute();
  $sth = $dbh-&gt;prepare( &quot;select * from foo where key='abc'&quot; );

  # SQL::Statement might faster (depending on DB size)
  $sth = $dbh-&gt;prepare( &quot;update foo set value='new' where key=?&quot; );
  $sth-&gt;execute(15);
  $sth = $dbh-&gt;prepare( &quot;update foo set value=? where key=15&quot; );
  $sth-&gt;execute('new');
  $sth = $dbh-&gt;prepare( &quot;delete from foo where key=?&quot; );
  $sth-&gt;execute(27);

  # SQL::Statement is faster
  $sth = $dbh-&gt;prepare( &quot;update foo set value='new' where value='old'&quot; );
  $sth-&gt;execute();
  # must be expressed using &quot;where key = 15 or key = 27 or key = 42 or key = 'abc'&quot;
  # in DBI::SQL::Nano
  $sth = $dbh-&gt;prepare( &quot;delete from foo where key in (15,27,42,'abc')&quot; );
  $sth-&gt;execute();
  # must be expressed using &quot;where key &gt; 10 and key &lt; 90&quot; in DBI::SQL::Nano
  $sth = $dbh-&gt;prepare( &quot;select * from foo where key between (10,90)&quot; );
  $sth-&gt;execute();

  # only SQL::Statement can handle
  $sth-&gt;prepare( &quot;select * from foo,bar where foo.name = bar.name&quot; );
  $sth-&gt;execute();
  $sth-&gt;prepare( &quot;insert into foo values ( 1, 'foo' ), ( 2, 'bar' )&quot; );
  $sth-&gt;execute();
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Specifying_Column_Names"><a class="permalink" href="#Specifying_Column_Names">Specifying
  Column Names</a></h2>
<p class="Pp">DBM files don't have a standard way to store column names.
    DBD::DBM gets around this issue with a DBD::DBM specific way of storing the
    column names. <b>If you are working only with DBD::DBM and not using files
    created by or</b> <b>accessed with other DBM programs, you can ignore this
    section.</b></p>
<p class="Pp">DBD::DBM stores column names as a row in the file with the key
    <i>_metadata</i> <i>\0</i>. So this code</p>
<p class="Pp"></p>
<pre>
 my $dbh = DBI-&gt;connect('dbi:DBM:');
 $dbh-&gt;do(&quot;CREATE TABLE baz (foo CHAR(10), bar INTEGER)&quot;);
 $dbh-&gt;do(&quot;INSERT INTO baz (foo,bar) VALUES ('zippy',1)&quot;);
</pre>
<p class="Pp">Will create a file that has a structure something like this:</p>
<p class="Pp"></p>
<pre>
  _metadata \0 | &lt;dbd_metadata&gt;&lt;schema&gt;&lt;/schema&gt;&lt;col_names&gt;foo,bar&lt;/col_names&gt;&lt;/dbd_metadata&gt;
  zippy        | 1
</pre>
<p class="Pp">The next time you access this table with DBD::DBM, it will treat
    the <i>_metadata \0</i> row as a header rather than as data and will pull
    the column names from there. However, if you access the file with something
    other than DBD::DBM, the row will be treated as a regular data row.</p>
<p class="Pp">If you do not want the column names stored as a data row in the
    table you can set the <i>dbm_store_metadata</i> attribute to 0.</p>
<p class="Pp"></p>
<pre>
 my $dbh = DBI-&gt;connect('dbi:DBM:', undef, undef, { dbm_store_metadata =&gt; 0 });

 # or
 $dbh-&gt;{dbm_store_metadata} = 0;

 # or for per-table setting
 $dbh-&gt;{f_meta}-&gt;{qux}-&gt;{dbm_store_metadata} = 0;
</pre>
<p class="Pp">By default, DBD::DBM assumes that you have two columns named
    &quot;k&quot; and &quot;v&quot; (short for &quot;key&quot; and
    &quot;value&quot;). So if you have <i>dbm_store_metadata</i> set to 1 and
    you want to use alternate column names, you need to specify the column names
    like this:</p>
<p class="Pp"></p>
<pre>
 my $dbh = DBI-&gt;connect('dbi:DBM:', undef, undef, {
     dbm_store_metadata =&gt; 0,
     dbm_cols =&gt; [ qw(foo bar) ],
 });

 # or
 $dbh-&gt;{dbm_store_metadata} = 0;
 $dbh-&gt;{dbm_cols}           = 'foo,bar';

 # or to set the column names on per-table basis, do this:
 # sets the column names only for table &quot;qux&quot;
 $dbh-&gt;{f_meta}-&gt;{qux}-&gt;{dbm_store_metadata} = 0;
 $dbh-&gt;{f_meta}-&gt;{qux}-&gt;{col_names}          = [qw(foo bar)];
</pre>
<p class="Pp">If you have a file that was created by another DBM program or
    created with <i>dbm_store_metadata</i> set to zero and you want to convert
    it to using DBD::DBM's column name storage, just use one of the methods
    above to name the columns but *without* specifying <i>dbm_store_metadata</i>
    as zero. You only have to do that once - thereafter you can get by without
    setting either <i>dbm_store_metadata</i> or setting <i>dbm_cols</i> because
    the names will be stored in the file.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DBI_database_handle_attributes"><a class="permalink" href="#DBI_database_handle_attributes">DBI
  database handle attributes</a></h1>
<section class="Ss">
<h2 class="Ss" id="Metadata"><a class="permalink" href="#Metadata">Metadata</a></h2>
<p class="Pp"><i>Statement handle ($sth) attributes and methods</i></p>
<p class="Pp">Most statement handle attributes such as NAME, NUM_OF_FIELDS, etc.
    are available only after an execute. The same is true of
    <span class="Li">$sth</span>-&gt;rows which is available after the execute
    but does <i>not</i> require a fetch.</p>
<p class="Pp"><i>Driver handle ($dbh) attributes</i></p>
<p class="Pp">It is not supported anymore to use dbm-attributes without the
    dbm_-prefix. Currently, if an DBD::DBM private attribute is accessed without
    an underscore in it's name, dbm_ is prepended to that attribute and it's
    processed further. If the resulting attribute name is invalid, an error is
    thrown.</p>
<p class="Pp">dbm_cols</p>
<p class="Pp">Contains a comma separated list of column names or an array
    reference to the column names.</p>
<p class="Pp">dbm_type</p>
<p class="Pp">Contains the DBM storage type. Currently known supported type are
    <span class="Li">&quot;ODBM_File&quot;</span>,
    <span class="Li">&quot;NDBM_File&quot;</span>,
    <span class="Li">&quot;SDBM_File&quot;</span>,
    <span class="Li">&quot;GDBM_File&quot;</span>,
    <span class="Li">&quot;DB_File&quot;</span> and
    <span class="Li">&quot;BerkeleyDB&quot;</span>. It is not recommended to use
    one of the first three types - even if
    <span class="Li">&quot;SDBM_File&quot;</span> is the most commonly available
    <i>dbm_type</i>.</p>
<p class="Pp">dbm_mldbm</p>
<p class="Pp">Contains the serializer for DBM storage (value column). Requires
    the CPAN module MLDBM installed. Currently known supported serializers
  are:</p>
<dl class="Bl-tag">
  <dt id="Data::Dumper"><a class="permalink" href="#Data::Dumper">Data::Dumper</a></dt>
  <dd>Default serializer. Deployed with Perl core.</dd>
  <dt id="Storable"><a class="permalink" href="#Storable">Storable</a></dt>
  <dd>Faster serializer. Deployed with Perl core.</dd>
  <dt id="FreezeThaw"><a class="permalink" href="#FreezeThaw">FreezeThaw</a></dt>
  <dd>Pure Perl serializer, requires FreezeThaw to be installed.</dd>
  <dt id="YAML"><a class="permalink" href="#YAML">YAML</a></dt>
  <dd>Portable serializer (between languages but not architectures). Requires
      YAML::MLDBM installation.</dd>
  <dt id="JSON"><a class="permalink" href="#JSON">JSON</a></dt>
  <dd>Portable, fast serializer (between languages but not architectures).
      Requires MLDBM::Serializer::JSON installation.</dd>
</dl>
<p class="Pp">dbm_store_metadata</p>
<p class="Pp">Boolean value which determines if the metadata in DBM is stored or
    not.</p>
<p class="Pp">dbm_berkeley_flags</p>
<p class="Pp">Hash reference with additional flags for BerkeleyDB::Hash
    instantiation.</p>
<p class="Pp">dbm_version</p>
<p class="Pp">Readonly attribute containing the version of DBD::DBM.</p>
<p class="Pp">f_meta</p>
<p class="Pp">In addition to the attributes DBD::File recognizes, DBD::DBM knows
    about the (public) attributes <span class="Li">&quot;col_names&quot;</span>
    (<b>Note</b> not <i>dbm_cols</i> here!),
    <span class="Li">&quot;dbm_type&quot;</span>,
    <span class="Li">&quot;dbm_mldbm&quot;</span>,
    <span class="Li">&quot;dbm_store_metadata&quot;</span> and
    <span class="Li">&quot;dbm_berkeley_flags&quot;</span>. As in DBD::File,
    there are undocumented, internal attributes in DBD::DBM. Be very careful
    when modifying attributes you do not know; the consequence might a destroyed
    or corrupted table.</p>
<p class="Pp">dbm_tables</p>
<p class="Pp">This attribute provides restricted access to the table meta data.
    See f_meta and &quot;f_meta&quot; in DBD::File for attribute details.</p>
<p class="Pp">dbm_tables is a tied hash providing the internal table names as
    keys (accessing unknown tables might create an entry) and their meta data as
    another tied hash. The table meta storage is obtained via the
    <span class="Li">&quot;get_table_meta&quot;</span> method from the table
    implementation (see DBD::File::Developers). Attribute setting and getting
    within the table meta data is handled via the methods
    <span class="Li">&quot;set_table_meta_attr&quot;</span> and
    <span class="Li">&quot;get_table_meta_attr&quot;</span>.</p>
<p class="Pp"><i>Following attributes are no longer handled by DBD::DBM:</i></p>
<p class="Pp">dbm_ext</p>
<p class="Pp">This attribute is silently mapped to DBD::File's attribute
    <i>f_ext</i>. Later versions of DBI might show a depreciated warning when
    this attribute is used and eventually it will be removed.</p>
<p class="Pp">dbm_lockfile</p>
<p class="Pp">This attribute is silently mapped to DBD::File's attribute
    <i>f_lockfile</i>. Later versions of DBI might show a depreciated warning
    when this attribute is used and eventually it will be removed.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DBI_database_handle_methods"><a class="permalink" href="#DBI_database_handle_methods">DBI
  database handle methods</a></h1>
<section class="Ss">
<h2 class="Ss" id="The_$dbh"><a class="permalink" href="#The_$dbh">The
  $dbh-&gt;<i>dbm_versions()</i> method</a></h2>
<p class="Pp">The private method <i>dbm_versions()</i> returns a summary of what
    other modules are being used at any given time. DBD::DBM can work with or
    without many other modules - it can use either SQL::Statement or
    DBI::SQL::Nano as its SQL engine, it can be run with DBI or DBI::PurePerl,
    it can use many kinds of DBM modules, and many kinds of serializers when run
    with MLDBM. The <i>dbm_versions()</i> method reports all of that and
  more.</p>
<p class="Pp"></p>
<pre>
  print $dbh-&gt;dbm_versions;               # displays global settings
  print $dbh-&gt;dbm_versions($table_name);  # displays per table settings
</pre>
<p class="Pp">An important thing to note about this method is that when it
    called with no arguments, it displays the *global* settings. If you override
    these by setting per-table attributes, these will <i>not</i> be shown unless
    you specify a table name as an argument to the method call.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Storing_Objects"><a class="permalink" href="#Storing_Objects">Storing
  Objects</a></h2>
<p class="Pp">If you are using MLDBM, you can use DBD::DBM to take advantage of
    its serializing abilities to serialize any Perl object that MLDBM can
    handle. To store objects in columns, you should (but don't absolutely need
    to) declare it as a column of type BLOB (the type is *currently* ignored by
    the SQL engine, but it's good form).</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXTENSIBILITY"><a class="permalink" href="#EXTENSIBILITY">EXTENSIBILITY</a></h1>
<dl class="Bl-tag">
  <dt>&quot;SQL::Statement&quot;</dt>
  <dd>Improved SQL engine compared to the built-in DBI::SQL::Nano - see
      &quot;Supported SQL syntax&quot;.</dd>
  <dt>&quot;DB_File&quot;</dt>
  <dd>Berkeley DB version 1. This database library is available on many systems
      without additional installation and most systems are supported.</dd>
  <dt>&quot;GDBM_File&quot;</dt>
  <dd>Simple dbm type (comparable to
      <span class="Li">&quot;DB_File&quot;</span>) under the GNU license.
      Typically not available (or requires extra installation) on non-GNU
      operating systems.</dd>
  <dt>&quot;BerkeleyDB&quot;</dt>
  <dd>Berkeley DB version up to v4 (and maybe higher) - requires additional
      installation but is easier than GDBM_File on non-GNU systems.
    <p class="Pp">db4 comes with a many tools which allow repairing and
        migrating databases. This is the <b>recommended</b> dbm type for
        production use.</p>
  </dd>
  <dt>&quot;MLDBM&quot;</dt>
  <dd>Serializer wrapper to support more than one column for the files. Comes
      with serializers using <span class="Li">&quot;Data::Dumper&quot;</span>,
      <span class="Li">&quot;FreezeThaw&quot;</span> and
      <span class="Li">&quot;Storable&quot;</span>.</dd>
  <dt>&quot;YAML::MLDBM&quot;</dt>
  <dd>Additional serializer for MLDBM. YAML is very portable between
    languages.</dd>
  <dt>&quot;MLDBM::Serializer::JSON&quot;</dt>
  <dd>Additional serializer for MLDBM. JSON is very portable between languages,
      probably more than YAML.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="GOTCHAS_AND_WARNINGS"><a class="permalink" href="#GOTCHAS_AND_WARNINGS">GOTCHAS
  AND WARNINGS</a></h1>
<p class="Pp">Using the SQL DROP command will remove any file that has the name
    specified in the command with either '.pag' and '.dir', '.db' or your
    {f_ext} appended to it. So this be dangerous if you aren't sure what file it
    refers to:</p>
<p class="Pp"></p>
<pre>
 $dbh-&gt;do(qq{DROP TABLE &quot;/path/to/any/file&quot;});
</pre>
<p class="Pp">Each DBM type has limitations. SDBM_File, for example, can only
    store values of less than 1,000 characters. *You* as the script author must
    ensure that you don't exceed those bounds. If you try to insert a value that
    is larger than DBM can store, the results will be unpredictable. See the
    documentation for whatever DBM you are using for details.</p>
<p class="Pp">Different DBM implementations return records in different orders.
    That means that you <i>should not</i> rely on the order of records unless
    you use an ORDER BY statement.</p>
<p class="Pp">DBM data files are platform-specific. To move them from one
    platform to another, you'll need to do something along the lines of dumping
    your data to CSV on platform #1 and then dumping from CSV to DBM on platform
    #2. DBD::AnyData and DBD::CSV can help with that. There may also be DBM
    conversion tools for your platforms which would probably be quicker.</p>
<p class="Pp">When using MLDBM, there is a very powerful serializer - it will
    allow you to store Perl code or objects in database columns. When these get
    de-serialized, they may be eval'ed - in other words MLDBM (or actually
    Data::Dumper when used by MLDBM) may take the values and try to execute them
    in Perl. Obviously, this can present dangers, so if you do not know what is
    in a file, be careful before you access it with MLDBM turned on!</p>
<p class="Pp">See the entire section on &quot;Table locking and
    <i>flock()</i>&quot; for gotchas and warnings about the use of
    <i>flock()</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS_AND_LIMITATIONS"><a class="permalink" href="#BUGS_AND_LIMITATIONS">BUGS
  AND LIMITATIONS</a></h1>
<p class="Pp">This module uses hash interfaces of two column file databases.
    While none of supported SQL engines have support for indices, the following
    statements really do the same (even if they mean something completely
    different) for each dbm type which lacks
    <span class="Li">&quot;EXISTS&quot;</span> support:</p>
<p class="Pp"></p>
<pre>
  $sth-&gt;do( &quot;insert into foo values (1, 'hello')&quot; );

  # this statement does ...
  $sth-&gt;do( &quot;update foo set v='world' where k=1&quot; );
  # ... the same as this statement
  $sth-&gt;do( &quot;insert into foo values (1, 'world')&quot; );
</pre>
<p class="Pp">This is considered to be a bug and might change in a future
    release.</p>
<p class="Pp">Known affected dbm types are
    <span class="Li">&quot;ODBM_File&quot;</span> and
    <span class="Li">&quot;NDBM_File&quot;</span>. We highly recommended you use
    a more modern dbm type such as
  <span class="Li">&quot;DB_File&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="GETTING_HELP,_MAKING_SUGGESTIONS,_AND_REPORTING_BUGS"><a class="permalink" href="#GETTING_HELP,_MAKING_SUGGESTIONS,_AND_REPORTING_BUGS">GETTING
  HELP, MAKING SUGGESTIONS, AND REPORTING BUGS</a></h1>
<p class="Pp">If you need help installing or using DBD::DBM, please write to the
    DBI users mailing list at dbi-users@perl.org or to the
    comp.lang.perl.modules newsgroup on usenet. I cannot always answer every
    question quickly but there are many on the mailing list or in the newsgroup
    who can.</p>
<p class="Pp">DBD developers for DBD's which rely on DBD::File or DBD::DBM or
    use one of them as an example are suggested to join the DBI developers
    mailing list at dbi-dev@perl.org and strongly encouraged to join our IRC
    channel at &lt;irc://irc.perl.org/dbi&gt;.</p>
<p class="Pp">If you have suggestions, ideas for improvements, or bugs to
    report, please report a bug as described in DBI. Do not mail any of the
    authors directly, you might not get an answer.</p>
<p class="Pp">When reporting bugs, please send the output of
    <span class="Li">$dbh</span>-&gt;dbm_versions($table) for a table that
    exhibits the bug and as small a sample as you can make of the code that
    produces the bug. And of course, patches are welcome, too :-).</p>
<p class="Pp">If you need enhancements quickly, you can get commercial support
    as described at &lt;http://dbi.perl.org/support/&gt; or you can contact Jens
    Rehsack at rehsack@cpan.org for commercial support in Germany.</p>
<p class="Pp">Please don't bother Jochen Wiedmann or Jeff Zucker for support -
    they handed over further maintenance to H.Merijn Brand and Jens Rehsack.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGEMENTS"><a class="permalink" href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></h1>
<p class="Pp">Many, many thanks to Tim Bunce for prodding me to write this, and
    for copious, wise, and patient suggestions all along the way. (Jeff
  Zucker)</p>
<p class="Pp">I send my thanks and acknowledgements to H.Merijn Brand for his
    initial refactoring of DBD::File and his strong and ongoing support of
    SQL::Statement. Without him, the current progress would never have been
    made. And I have to name Martin J. Evans for each laugh (and correction) of
    all those funny word creations I (as non-native speaker) made to the
    documentation. And - of course - I have to thank all those unnamed
    contributors and testers from the Perl community. (Jens Rehsack)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR_AND_COPYRIGHT"><a class="permalink" href="#AUTHOR_AND_COPYRIGHT">AUTHOR
  AND COPYRIGHT</a></h1>
<p class="Pp">This module is written by Jeff Zucker &lt; jzucker AT cpan.org
    &gt;, who also maintained it till 2007. After that, in 2010, Jens Rehsack
    &amp; H.Merijn Brand took over maintenance.</p>
<p class="Pp"></p>
<pre>
 Copyright (c) 2004 by Jeff Zucker, all rights reserved.
 Copyright (c) 2010-2013 by Jens Rehsack &amp; H.Merijn Brand, all rights reserved.
</pre>
<p class="Pp">You may freely distribute and/or modify this module under the
    terms of either the GNU General Public License (GPL) or the Artistic
    License, as specified in the Perl README file.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">DBI, SQL::Statement, DBI::SQL::Nano, AnyDBM_File, DB_File,
    BerkeleyDB, MLDBM, YAML::MLDBM, MLDBM::Serializer::JSON</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-09-08</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

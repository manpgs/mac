<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>XML::LibXML::Parser(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">XML::LibXML::Parser(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">XML::LibXML::Parser(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">XML::LibXML::Parser - Parsing XML Data with XML::LibXML</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  use XML::LibXML '1.70';
  # Parser constructor
  $parser = XML::LibXML-&gt;new();
  $parser = XML::LibXML-&gt;new(option=&gt;value, ...);
  $parser = XML::LibXML-&gt;new({option=&gt;value, ...});
  # Parsing XML
  $dom = XML::LibXML-&gt;load_xml(
      location =&gt; $file_or_url
      # parser options ...
    );
  $dom = XML::LibXML-&gt;load_xml(
      string =&gt; $xml_string
      # parser options ...
    );
  $dom = XML::LibXML-&gt;load_xml(
      string =&gt; (\$xml_string)
      # parser options ...
    );
  $dom = XML::LibXML-&gt;load_xml({
      IO =&gt; $perl_file_handle
      # parser options ...
    );
  $dom = $parser-&gt;load_xml(...);
  # Parsing HTML
  $dom = XML::LibXML-&gt;load_html(...);
  $dom = $parser-&gt;load_html(...);
  # Parsing well-balanced XML chunks
  $fragment = $parser-&gt;parse_balanced_chunk( $wbxmlstring, $encoding );
  # Processing XInclude
  $parser-&gt;process_xincludes( $doc );
  $parser-&gt;processXIncludes( $doc );
  # Old-style parser interfaces
  $doc = $parser-&gt;parse_file( $xmlfilename );
  $doc = $parser-&gt;parse_fh( $io_fh );
  $doc = $parser-&gt;parse_string( $xmlstring);
  $doc = $parser-&gt;parse_html_file( $htmlfile, \%opts );
  $doc = $parser-&gt;parse_html_fh( $io_fh, \%opts );
  $doc = $parser-&gt;parse_html_string( $htmlstring, \%opts );
  # Push parser
  $parser-&gt;parse_chunk($string, $terminate);
  $parser-&gt;init_push();
  $parser-&gt;push(@data);
  $doc = $parser-&gt;finish_push( $recover );
  # Set/query parser options
  $parser-&gt;option_exists($name);
  $parser-&gt;get_option($name);
  $parser-&gt;set_option($name,$value);
  $parser-&gt;set_options({$name=&gt;$value,...});
  # XML catalogs
  $parser-&gt;load_catalog( $catalog_file );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="PARSING"><a class="permalink" href="#PARSING">PARSING</a></h1>
<p class="Pp">An XML document is read into a data structure such as a DOM tree
    by a piece of software, called a parser. XML::LibXML currently provides four
    different parser interfaces:</p>
<ul class="Bl-bullet">
  <li>A DOM Pull-Parser</li>
  <li>A DOM Push-Parser</li>
  <li>A SAX Parser</li>
  <li>A DOM based SAX Parser.</li>
</ul>
<section class="Ss">
<h2 class="Ss" id="Creating_a_Parser_Instance"><a class="permalink" href="#Creating_a_Parser_Instance">Creating
  a Parser Instance</a></h2>
<p class="Pp">XML::LibXML provides an OO interface to the libxml2 parser
    functions. Thus you have to create a parser instance before you can parse
    any XML data.</p>
<dl class="Bl-tag">
  <dt id="new"><a class="permalink" href="#new">new</a></dt>
  <dd>
    <pre>  $parser = XML::LibXML-&gt;new();
  $parser = XML::LibXML-&gt;new(option=&gt;value, ...);
  $parser = XML::LibXML-&gt;new({option=&gt;value, ...});
    </pre>
    <p class="Pp">Create a new XML and HTML parser instance. Each parser
        instance holds default values for various parser options. Optionally,
        one can pass a hash reference or a list of option =&gt; value pairs to
        set a different default set of options. Unless specified otherwise, the
        options <span class="Li">&quot;load_ext_dtd&quot;</span>, and
        <span class="Li">&quot;expand_entities&quot;</span> are set to 1. See
        &quot;Parser Options&quot; for a list of libxml2 parser's options.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">DOM Parser</h2>
<p class="Pp">One of the common parser interfaces of XML::LibXML is the DOM
    parser. This parser reads XML data into a DOM like data structure, so each
    tag can get accessed and transformed.</p>
<p class="Pp">XML::LibXML's DOM parser is not only capable to parse XML data,
    but also (strict) HTML files. There are three ways to parse documents - as a
    string, as a Perl filehandle, or as a filename/URL. The return value from
    each is a XML::LibXML::Document object, which is a DOM object.</p>
<p class="Pp">All of the functions listed below will throw an exception if the
    document is invalid. To prevent this causing your program exiting, wrap the
    call in an eval{} block</p>
<dl class="Bl-tag">
  <dt id="load_xml"><a class="permalink" href="#load_xml">load_xml</a></dt>
  <dd>
    <pre>  $dom = XML::LibXML-&gt;load_xml(
      location =&gt; $file_or_url
      # parser options ...
    );
  $dom = XML::LibXML-&gt;load_xml(
      string =&gt; $xml_string
      # parser options ...
    );
  $dom = XML::LibXML-&gt;load_xml(
      string =&gt; (\$xml_string)
      # parser options ...
    );
  $dom = XML::LibXML-&gt;load_xml({
      IO =&gt; $perl_file_handle
      # parser options ...
    );
  $dom = $parser-&gt;load_xml(...);
    </pre>
    <p class="Pp">This function is available since XML::LibXML 1.70. It provides
        easy to use interface to the XML parser that parses given file (or URL),
        string, or input stream to a DOM tree. The arguments can be passed in a
        HASH reference or as name =&gt; value pairs. The function can be called
        as a class method or an object method. In both cases it internally
        creates a new parser instance passing the specified parser options; if
        called as an object method, it clones the original parser (preserving
        its settings) and additionally applies the specified options to the new
        parser. See the constructor <span class="Li">&quot;new&quot;</span> and
        &quot;Parser Options&quot; for more information.</p>
  </dd>
  <dt id="load_html"><a class="permalink" href="#load_html">load_html</a></dt>
  <dd>
    <pre>  $dom = XML::LibXML-&gt;load_html(...);
  $dom = $parser-&gt;load_html(...);
    </pre>
    <p class="Pp">This function is available since XML::LibXML 1.70. It has the
        same usage as <span class="Li">&quot;load_xml&quot;</span>, providing
        interface to the HTML parser. See
        <span class="Li">&quot;load_xml&quot;</span> for more information.</p>
  </dd>
</dl>
<p class="Pp">Parsing HTML may cause problems, especially if the ampersand
    ('&amp;') is used. This is a common problem if HTML code is parsed that
    contains links to CGI-scripts. Such links cause the parser to throw errors.
    In such cases libxml2 still parses the entire document as there was no
    error, but the error causes XML::LibXML to stop the parsing process.
    However, the document is not lost. Such HTML documents should be parsed
    using the <i>recover</i> flag. By default recovering is deactivated.</p>
<p class="Pp">The functions described above are implemented to parse well formed
    documents. In some cases a program gets well balanced XML instead of well
    formed documents (e.g. an XML fragment from a database). With XML::LibXML it
    is not required to wrap such fragments in the code, because XML::LibXML is
    capable even to parse well balanced XML fragments.</p>
<dl class="Bl-tag">
  <dt id="parse_balanced_chunk"><a class="permalink" href="#parse_balanced_chunk">parse_balanced_chunk</a></dt>
  <dd>
    <pre>  $fragment = $parser-&gt;parse_balanced_chunk( $wbxmlstring, $encoding );
    </pre>
    <p class="Pp">This function parses a well balanced XML string into a
        XML::LibXML::DocumentFragment. The first arguments contains the input
        string, the optional second argument can be used to specify character
        encoding of the input (UTF-8 is assumed by default).</p>
  </dd>
  <dt id="parse_xml_chunk"><a class="permalink" href="#parse_xml_chunk">parse_xml_chunk</a></dt>
  <dd>This is the old name of <b>parse_balanced_chunk()</b>. Because it may
      causes confusion with the push parser interface, this function should not
      be used anymore.</dd>
</dl>
<p class="Pp">By default XML::LibXML does not process XInclude tags within an
    XML Document (see options section below). XML::LibXML allows one to
    post-process a document to expand XInclude tags.</p>
<dl class="Bl-tag">
  <dt id="process_xincludes"><a class="permalink" href="#process_xincludes">process_xincludes</a></dt>
  <dd>
    <pre>  $parser-&gt;process_xincludes( $doc );
    </pre>
    <p class="Pp">After a document is parsed into a DOM structure, you may want
        to expand the documents XInclude tags. This function processes the given
        document structure and expands all XInclude tags (or throws an error) by
        using the flags and callbacks of the given parser instance.</p>
    <p class="Pp">Note that the resulting Tree contains some extra nodes (of
        type XML_XINCLUDE_START and XML_XINCLUDE_END) after successfully
        processing the document. These nodes indicate where data was included
        into the original tree. if the document is serialized, these extra nodes
        will not show up.</p>
    <p class="Pp">Remember: A Document with processed XIncludes differs from the
        original document after serialization, because the original XInclude
        tags will not get restored!</p>
    <p class="Pp">If the parser flag &quot;expand_xincludes&quot; is set to 1,
        you need not to post process the parsed document.</p>
  </dd>
  <dt id="processXIncludes"><a class="permalink" href="#processXIncludes">processXIncludes</a></dt>
  <dd>
    <pre>  $parser-&gt;processXIncludes( $doc );
    </pre>
    <p class="Pp">This is an alias to process_xincludes, but through a JAVA like
        function name.</p>
  </dd>
  <dt id="parse_file"><a class="permalink" href="#parse_file">parse_file</a></dt>
  <dd>
    <pre>  $doc = $parser-&gt;parse_file( $xmlfilename );
    </pre>
    <p class="Pp">This function parses an XML document from a file or network;
        <span class="Li">$xmlfilename</span> can be either a filename or an URL.
        Note that for parsing files, this function is the fastest choice, about
        6-8 times faster then <b>parse_fh()</b>.</p>
  </dd>
  <dt id="parse_fh"><a class="permalink" href="#parse_fh">parse_fh</a></dt>
  <dd>
    <pre>  $doc = $parser-&gt;parse_fh( $io_fh );
    </pre>
    <p class="Pp"><b>parse_fh()</b> parses a IOREF or a subclass of
      IO::Handle.</p>
    <p class="Pp">Because the data comes from an open handle, libxml2's parser
        does not know about the base URI of the document. To set the base URI
        one should use <b>parse_fh()</b> as follows:</p>
    <p class="Pp"></p>
    <pre>  my $doc = $parser-&gt;parse_fh( $io_fh, $baseuri );
    </pre>
  </dd>
  <dt id="parse_string"><a class="permalink" href="#parse_string">parse_string</a></dt>
  <dd>
    <pre>  $doc = $parser-&gt;parse_string( $xmlstring);
    </pre>
    <p class="Pp">This function is similar to <b>parse_fh()</b>, but it parses
        an XML document that is available as a single string in memory, or
        alternatively as a reference to a scalar containing a string. Again, you
        can pass an optional base URI to the function.</p>
    <p class="Pp"></p>
    <pre>  my $doc = $parser-&gt;parse_string( $xmlstring, $baseuri );
  my $doc = $parser-&gt;parse_string(\$xmlstring, $baseuri);
    </pre>
  </dd>
  <dt id="parse_html_file"><a class="permalink" href="#parse_html_file">parse_html_file</a></dt>
  <dd>
    <pre>  $doc = $parser-&gt;parse_html_file( $htmlfile, \%opts );
    </pre>
    <p class="Pp">Similar to <b>parse_file()</b> but parses HTML (strict)
        documents; <span class="Li">$htmlfile</span> can be filename or URL.</p>
    <p class="Pp">An optional second argument can be used to pass some options
        to the HTML parser as a HASH reference. See options labeled with HTML in
        &quot;Parser Options&quot;.</p>
  </dd>
  <dt id="parse_html_fh"><a class="permalink" href="#parse_html_fh">parse_html_fh</a></dt>
  <dd>
    <pre>  $doc = $parser-&gt;parse_html_fh( $io_fh, \%opts );
    </pre>
    <p class="Pp">Similar to <b>parse_fh()</b> but parses HTML (strict)
      streams.</p>
    <p class="Pp">An optional second argument can be used to pass some options
        to the HTML parser as a HASH reference. See options labeled with HTML in
        &quot;Parser Options&quot;.</p>
    <p class="Pp">Note: encoding option may not work correctly with this
        function in libxml2 &lt; 2.6.27 if the HTML file declares charset using
        a META tag.</p>
  </dd>
  <dt id="parse_html_string"><a class="permalink" href="#parse_html_string">parse_html_string</a></dt>
  <dd>
    <pre>  $doc = $parser-&gt;parse_html_string( $htmlstring, \%opts );
    </pre>
    <p class="Pp">Similar to <b>parse_string()</b> but parses HTML (strict)
        strings.</p>
    <p class="Pp">An optional second argument can be used to pass some options
        to the HTML parser as a HASH reference. See options labeled with HTML in
        &quot;Parser Options&quot;.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Push_Parser"><a class="permalink" href="#Push_Parser">Push
  Parser</a></h2>
<p class="Pp">XML::LibXML provides a push parser interface. Rather than pulling
    the data from a given source the push parser waits for the data to be pushed
    into it.</p>
<p class="Pp">This allows one to parse large documents without waiting for the
    parser to finish. The interface is especially useful if a program needs to
    pre-process the incoming pieces of XML (e.g. to detect document
  boundaries).</p>
<p class="Pp">While XML::LibXML parse_*() functions force the data to be a
    well-formed XML, the push parser will take any arbitrary string that
    contains some XML data. The only requirement is that all the pushed strings
    are together a well formed document. With the push parser interface a
    program can interrupt the parsing process as required, where the parse_*()
    functions give not enough flexibility.</p>
<p class="Pp">Different to the pull parser implemented in <b>parse_fh()</b> or
    <b>parse_file()</b>, the push parser is not able to find out about the
    documents end itself. Thus the calling program needs to indicate explicitly
    when the parsing is done.</p>
<p class="Pp">In XML::LibXML this is done by a single function:</p>
<dl class="Bl-tag">
  <dt id="parse_chunk"><a class="permalink" href="#parse_chunk">parse_chunk</a></dt>
  <dd>
    <pre>  $parser-&gt;parse_chunk($string, $terminate);
    </pre>
    <p class="Pp"><b>parse_chunk()</b> tries to parse a given chunk of data,
        which isn't necessarily well balanced data. The function takes two
        parameters: The chunk of data as a string and optional a termination
        flag. If the termination flag is set to a true value (e.g. 1), the
        parsing will be stopped and the resulting document will be returned as
        the following example describes:</p>
    <p class="Pp"></p>
    <pre>  my $parser = XML::LibXML-&gt;new;
  for my $string ( &quot;&lt;&quot;, &quot;foo&quot;, ' bar=&quot;hello world&quot;', &quot;/&gt;&quot;) {
       $parser-&gt;parse_chunk( $string );
  }
  my $doc = $parser-&gt;parse_chunk(&quot;&quot;, 1); # terminate the parsing
    </pre>
  </dd>
</dl>
<p class="Pp">Internally XML::LibXML provides three functions that control the
    push parser process:</p>
<dl class="Bl-tag">
  <dt id="init_push"><a class="permalink" href="#init_push">init_push</a></dt>
  <dd>
    <pre>  $parser-&gt;init_push();
    </pre>
    <p class="Pp">Initializes the push parser.</p>
  </dd>
  <dt id="push"><a class="permalink" href="#push">push</a></dt>
  <dd>
    <pre>  $parser-&gt;push(@data);
    </pre>
    <p class="Pp">This function pushes the data stored inside the array to
        libxml2's parser. Each entry in <span class="Li">@data</span> must be a
        normal scalar! This method can be called repeatedly.</p>
  </dd>
  <dt id="finish_push"><a class="permalink" href="#finish_push">finish_push</a></dt>
  <dd>
    <pre>  $doc = $parser-&gt;finish_push( $recover );
    </pre>
    <p class="Pp">This function returns the result of the parsing process. If
        this function is called without a parameter it will complain about non
        well-formed documents. If <span class="Li">$restore</span> is 1, the
        push parser can be used to restore broken or non well formed (XML)
        documents as the following example shows:</p>
    <p class="Pp"></p>
    <pre>  eval {
      $parser-&gt;push( &quot;&lt;foo&gt;&quot;, &quot;bar&quot; );
      $doc = $parser-&gt;finish_push();    # will report broken XML
  };
  if ( $@ ) {
     # ...
  }
    </pre>
    <p class="Pp">This can be annoying if the closing tag is missed by accident.
        The following code will restore the document:</p>
    <p class="Pp"></p>
    <pre>  eval {
      $parser-&gt;push( &quot;&lt;foo&gt;&quot;, &quot;bar&quot; );
      $doc = $parser-&gt;finish_push(1);   # will return the data parsed
                                        # unless an error happened
  };
  print $doc-&gt;toString(); # returns &quot;&lt;foo&gt;bar&lt;/foo&gt;&quot;
    </pre>
    <p class="Pp">Of course <b>finish_push()</b> will return nothing if there
        was no data pushed to the parser before.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Pull_Parser_(Reader)"><a class="permalink" href="#Pull_Parser_(Reader)">Pull
  Parser (Reader)</a></h2>
<p class="Pp">XML::LibXML also provides a pull-parser interface similar to the
    XmlReader interface in .NET. This interface is almost streaming, and is
    usually faster and simpler to use than SAX. See XML::LibXML::Reader.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Direct_"><a class="permalink" href="#Direct_">Direct SAX
  Parser</a></h2>
<p class="Pp">XML::LibXML provides a direct SAX parser in the XML::LibXML::SAX
    module.</p>
</section>
<section class="Ss">
<h2 class="Ss">DOM based SAX Parser</h2>
<p class="Pp">XML::LibXML also provides a DOM based SAX parser. The SAX parser
    is defined in the module XML::LibXML::SAX::Parser. As it is not a stream
    based parser, it parses documents into a DOM and traverses the DOM tree
    instead.</p>
<p class="Pp">The API of this parser is exactly the same as any other Perl SAX2
    parser. See XML::SAX::Intro for details.</p>
<p class="Pp">Aside from the regular parsing methods, you can access the DOM
    tree traverser directly, using the <b>generate()</b> method:</p>
<p class="Pp"></p>
<pre>  my $doc = build_yourself_a_document();
  my $saxparser = $XML::LibXML::SAX::Parser-&gt;new( ... );
  $parser-&gt;generate( $doc );
</pre>
<p class="Pp">This is useful for serializing DOM trees, for example that you
    might have done prior processing on, or that you have as a result of XSLT
    processing.</p>
<p class="Pp"><i>WARNING</i></p>
<p class="Pp">This is NOT a streaming SAX parser. As I said above, this parser
    reads the entire document into a DOM and serialises it. Some people couldn't
    read that in the paragraph above so I've added this warning. If you want a
    streaming SAX parser look at the XML::LibXML::SAX man page</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SERIALIZATION"><a class="permalink" href="#SERIALIZATION">SERIALIZATION</a></h1>
<p class="Pp">XML::LibXML provides some functions to serialize nodes and
    documents. The serialization functions are described on the
    XML::LibXML::Node manpage or the XML::LibXML::Document manpage. XML::LibXML
    checks three global flags that alter the serialization process:</p>
<ul class="Bl-bullet">
  <li>skipXMLDeclaration</li>
  <li>skipDTD</li>
  <li>setTagCompression</li>
</ul>
<p class="Pp">of that three functions only setTagCompression is available for
    all serialization functions.</p>
<p class="Pp">Because XML::LibXML does these flags not itself, one has to define
    them locally as the following example shows:</p>
<p class="Pp"></p>
<pre>  local $XML::LibXML::skipXMLDeclaration = 1;
  local $XML::LibXML::skipDTD = 1;
  local $XML::LibXML::setTagCompression = 1;
</pre>
<p class="Pp">If skipXMLDeclaration is defined and not '0', the XML declaration
    is omitted during serialization.</p>
<p class="Pp">If skipDTD is defined and not '0', an existing DTD would not be
    serialized with the document.</p>
<p class="Pp">If setTagCompression is defined and not '0' empty tags are
    displayed as open and closing tags rather than the shortcut. For example the
    empty tag <i>foo</i> will be rendered as <i>&lt;foo&gt;&lt;/foo&gt;</i>
    rather than <i>&lt;foo/&gt;</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PARSER_OPTIONS"><a class="permalink" href="#PARSER_OPTIONS">PARSER
  OPTIONS</a></h1>
<p class="Pp">Handling of libxml2 parser options has been unified and improved
    in XML::LibXML 1.70. You can now set default options for a particular parser
    instance by passing them to the constructor as
    <span class="Li">&quot;XML::LibXML-&gt;new({name=&gt;value,
    ...})&quot;</span> or
    <span class="Li">&quot;XML::LibXML-&gt;new(name=&gt;value,...)&quot;</span>.
    The options can be queried and changed using the following methods (pre-1.70
    interfaces such as
    <span class="Li">&quot;$parser-&gt;load_ext_dtd(0)&quot;</span> also exist,
    see below):</p>
<dl class="Bl-tag">
  <dt id="option_exists"><a class="permalink" href="#option_exists">option_exists</a></dt>
  <dd>
    <pre>  $parser-&gt;option_exists($name);
    </pre>
    <p class="Pp">Returns 1 if the current XML::LibXML version supports the
        option <span class="Li">$name</span>, otherwise returns 0 (note that
        this does not necessarily mean that the option is supported by the
        underlying libxml2 library).</p>
  </dd>
  <dt id="get_option"><a class="permalink" href="#get_option">get_option</a></dt>
  <dd>
    <pre>  $parser-&gt;get_option($name);
    </pre>
    <p class="Pp">Returns the current value of the parser option
        <span class="Li">$name</span>.</p>
  </dd>
  <dt id="set_option"><a class="permalink" href="#set_option">set_option</a></dt>
  <dd>
    <pre>  $parser-&gt;set_option($name,$value);
    </pre>
    <p class="Pp">Sets option <span class="Li">$name</span> to value
        <span class="Li">$value</span>.</p>
  </dd>
  <dt id="set_options"><a class="permalink" href="#set_options">set_options</a></dt>
  <dd>
    <pre>  $parser-&gt;set_options({$name=&gt;$value,...});
    </pre>
    <p class="Pp">Sets multiple parsing options at once.</p>
  </dd>
</dl>
<p class="Pp">IMPORTANT NOTE: This documentation reflects the parser flags
    available in libxml2 2.7.3. Some options have no effect if an older version
    of libxml2 is used.</p>
<p class="Pp">Each of the flags listed below is labeled</p>
<dl class="Bl-tag">
  <dt>/parser/</dt>
  <dd>if it can be used with a <span class="Li">&quot;XML::LibXML&quot;</span>
      parser object (i.e. passed to
      <span class="Li">&quot;XML::LibXML-&gt;new&quot;</span>,
      <span class="Li">&quot;XML::LibXML-&gt;set_option&quot;</span>, etc.)</dd>
  <dt>/html/</dt>
  <dd>if it can be used passed to the
      <span class="Li">&quot;parse_html_*&quot;</span> methods</dd>
  <dt>/reader/</dt>
  <dd>if it can be used with the
      <span class="Li">&quot;XML::LibXML::Reader&quot;</span>.</dd>
</dl>
<p class="Pp">Unless specified otherwise, the default for boolean valued options
    is 0 (false).</p>
<p class="Pp">The available options are:</p>
<dl class="Bl-tag">
  <dt id="URI"><a class="permalink" href="#URI">URI</a></dt>
  <dd>/parser, html, reader/
    <p class="Pp">In case of parsing strings or file handles, XML::LibXML
        doesn't know about the base uri of the document. To make relative
        references such as XIncludes work, one has to set a base URI, that is
        then used for the parsed document.</p>
  </dd>
  <dt id="line_numbers"><a class="permalink" href="#line_numbers">line_numbers</a></dt>
  <dd>/parser, html, reader/
    <p class="Pp">If this option is activated, libxml2 will store the line
        number of each element node in the parsed document. The line number can
        be obtained using the <span class="Li">&quot;line_number()&quot;</span>
        method of the <span class="Li">&quot;XML::LibXML::Node&quot;</span>
        class (for non-element nodes this may report the line number of the
        containing element). The line numbers are also used for reporting
        positions of validation errors.</p>
    <p class="Pp">IMPORTANT: Due to limitations in the libxml2 library line
        numbers greater than 65535 will be returned as 65535. Unfortunately,
        this is a long and sad story, please see
        &lt;http://bugzilla.gnome.org/show_bug.cgi?id=325533&gt; for more
        details.</p>
  </dd>
  <dt id="encoding"><a class="permalink" href="#encoding">encoding</a></dt>
  <dd>/html/
    <p class="Pp">character encoding of the input</p>
  </dd>
  <dt id="recover"><a class="permalink" href="#recover">recover</a></dt>
  <dd>/parser, html, reader/
    <p class="Pp">recover from errors; possible values are 0, 1, and 2</p>
    <p class="Pp">A true value turns on recovery mode which allows one to parse
        broken XML or HTML data. The recovery mode allows the parser to return
        the successfully parsed portion of the input document. This is useful
        for almost well-formed documents, where for example a closing tag is
        missing somewhere. Still, XML::LibXML will only parse until the first
        fatal (non-recoverable) error occurs, reporting recoverable parsing
        errors as warnings. To suppress even these warnings, use
      recover=&gt;2.</p>
    <p class="Pp">Note that validation is switched off automatically in recovery
        mode.</p>
  </dd>
  <dt id="expand_entities"><a class="permalink" href="#expand_entities">expand_entities</a></dt>
  <dd>/parser, reader/
    <p class="Pp">substitute entities; possible values are 0 and 1; default is
      1</p>
    <p class="Pp">Note that although this flag disables entity substitution, it
        does not prevent the parser from loading external entities; when
        substitution of an external entity is disabled, the entity will be
        represented in the document tree by an XML_ENTITY_REF_NODE node whose
        subtree will be the content obtained by parsing the external resource;
        Although this nesting is visible from the DOM it is transparent to XPath
        data model, so it is possible to match nodes in an unexpanded entity by
        the same XPath expression as if the entity were expanded. See also
        ext_ent_handler.</p>
  </dd>
  <dt id="ext_ent_handler"><a class="permalink" href="#ext_ent_handler">ext_ent_handler</a></dt>
  <dd>/parser/
    <p class="Pp">Provide a custom external entity handler to be used when
        expand_entities is set to 1. Possible value is a subroutine
      reference.</p>
    <p class="Pp">This feature does not work properly in libxml2 &lt;
      2.6.27!</p>
    <p class="Pp">The subroutine provided is called whenever the parser needs to
        retrieve the content of an external entity. It is called with two
        arguments: the system ID (URI) and the public ID. The value returned by
        the subroutine is parsed as the content of the entity.</p>
    <p class="Pp">This method can be used to completely disable entity loading,
        e.g. to prevent exploits of the type described at
        (&lt;http://searchsecuritychannel.techtarget.com/generic/0,295582,sid97_gci1304703,00.html&gt;),
        where a service is tricked to expose its private data by letting it
        parse a remote file (RSS feed) that contains an entity reference to a
        local file (e.g. <span class="Li">&quot;/etc/fstab&quot;</span>).</p>
    <p class="Pp">A more granular solution to this problem, however, is provided
        by custom URL resolvers, as in</p>
    <p class="Pp"></p>
    <pre>  my $c = XML::LibXML::InputCallback-&gt;new();
  sub match {   # accept file:/ URIs except for XML catalogs in /etc/xml/
    my ($uri) = @_;
    return ($uri=~m{^file:/}
            and $uri !~ m{^file:///etc/xml/})
           ? 1 : 0;
  }
  $c-&gt;register_callbacks([ \&amp;match, sub{}, sub{}, sub{} ]);
  $parser-&gt;input_callbacks($c);
    </pre>
  </dd>
  <dt id="load_ext_dtd"><a class="permalink" href="#load_ext_dtd">load_ext_dtd</a></dt>
  <dd>/parser, reader/
    <p class="Pp">load the external DTD subset while parsing; possible values
        are 0 and 1. Unless specified, XML::LibXML sets this option to 1.</p>
    <p class="Pp">This flag is also required for DTD Validation, to provide
        complete attribute, and to expand entities, regardless if the document
        has an internal subset. Thus switching off external DTD loading, will
        disable entity expansion, validation, and complete attributes on
        internal subsets as well.</p>
  </dd>
  <dt id="complete_attributes"><a class="permalink" href="#complete_attributes">complete_attributes</a></dt>
  <dd>/parser, reader/
    <p class="Pp">create default DTD attributes; possible values are 0 and 1</p>
  </dd>
  <dt id="validation"><a class="permalink" href="#validation">validation</a></dt>
  <dd>/parser, reader/
    <p class="Pp">validate with the DTD; possible values are 0 and 1</p>
  </dd>
  <dt id="suppress_errors"><a class="permalink" href="#suppress_errors">suppress_errors</a></dt>
  <dd>/parser, html, reader/
    <p class="Pp">suppress error reports; possible values are 0 and 1</p>
  </dd>
  <dt id="suppress_warnings"><a class="permalink" href="#suppress_warnings">suppress_warnings</a></dt>
  <dd>/parser, html, reader/
    <p class="Pp">suppress warning reports; possible values are 0 and 1</p>
  </dd>
  <dt id="pedantic_parser"><a class="permalink" href="#pedantic_parser">pedantic_parser</a></dt>
  <dd>/parser, html, reader/
    <p class="Pp">pedantic error reporting; possible values are 0 and 1</p>
  </dd>
  <dt id="no_blanks"><a class="permalink" href="#no_blanks">no_blanks</a></dt>
  <dd>/parser, html, reader/
    <p class="Pp">remove blank nodes; possible values are 0 and 1</p>
  </dd>
  <dt id="no_defdtd"><a class="permalink" href="#no_defdtd">no_defdtd</a></dt>
  <dd>/html/
    <p class="Pp">do not add a default DOCTYPE; possible values are 0 and 1</p>
    <p class="Pp">the default is (0) to add a DTD when the input html lacks
      one</p>
  </dd>
  <dt id="expand_xinclude"><a class="permalink" href="#expand_xinclude">expand_xinclude
    or xinclude</a></dt>
  <dd>/parser, reader/
    <p class="Pp">Implement XInclude substitution; possible values are 0 and
      1</p>
    <p class="Pp">Expands XInclude tags immediately while parsing the document.
        Note that the parser will use the URI resolvers installed via
        <span class="Li">&quot;XML::LibXML::InputCallback&quot;</span> to parse
        the included document (if any).</p>
  </dd>
  <dt id="no_xinclude_nodes"><a class="permalink" href="#no_xinclude_nodes">no_xinclude_nodes</a></dt>
  <dd>/parser, reader/
    <p class="Pp">do not generate XINCLUDE START/END nodes; possible values are
        0 and 1</p>
  </dd>
  <dt id="no_network"><a class="permalink" href="#no_network">no_network</a></dt>
  <dd>/parser, html, reader/
    <p class="Pp">Forbid network access; possible values are 0 and 1</p>
    <p class="Pp">If set to true, all attempts to fetch non-local resources
        (such as DTD or external entities) will fail (unless custom callbacks
        are defined).</p>
    <p class="Pp">It may be necessary to use the flag
        <span class="Li">&quot;recover&quot;</span> for processing documents
        requiring such resources while networking is off.</p>
  </dd>
  <dt id="clean_namespaces"><a class="permalink" href="#clean_namespaces">clean_namespaces</a></dt>
  <dd>/parser, reader/
    <p class="Pp">remove redundant namespaces declarations during parsing;
        possible values are 0 and 1.</p>
  </dd>
  <dt id="no_cdata"><a class="permalink" href="#no_cdata">no_cdata</a></dt>
  <dd>/parser, html, reader/
    <p class="Pp">merge CDATA as text nodes; possible values are 0 and 1</p>
  </dd>
  <dt id="no_basefix"><a class="permalink" href="#no_basefix">no_basefix</a></dt>
  <dd>/parser, reader/
    <p class="Pp">not fixup XINCLUDE xml#base URIS; possible values are 0 and
      1</p>
  </dd>
  <dt id="huge"><a class="permalink" href="#huge">huge</a></dt>
  <dd>/parser, html, reader/
    <p class="Pp">relax any hardcoded limit from the parser; possible values are
        0 and 1. Unless specified, XML::LibXML sets this option to 0.</p>
    <p class="Pp">Note: the default value for this option was changed to protect
        against denial of service through entity expansion attacks. Before
        enabling the option ensure you have taken alternative measures to
        protect your application against this type of attack.</p>
  </dd>
  <dt id="gdome"><a class="permalink" href="#gdome">gdome</a></dt>
  <dd>/parser/
    <p class="Pp">THIS OPTION IS EXPERIMENTAL!</p>
    <p class="Pp">Although quite powerful, XML::LibXML's DOM implementation is
        incomplete with respect to the DOM level 2 or level 3 specifications.
        XML::GDOME is based on libxml2 as well, and provides a rather complete
        DOM implementation by wrapping libgdome. This flag allows you to make
        use of XML::LibXML's full parser options and XML::GDOME's DOM
        implementation at the same time.</p>
    <p class="Pp">To make use of this function, one has to install libgdome and
        configure XML::LibXML to use this library. For this you need to rebuild
        XML::LibXML!</p>
    <p class="Pp">Note: this feature was not seriously tested in recent
        XML::LibXML releases.</p>
  </dd>
</dl>
<p class="Pp">For compatibility with XML::LibXML versions prior to 1.70, the
    following methods are also supported for querying and setting the
    corresponding parser options (if called without arguments, the methods
    return the current value of the corresponding parser options; with an
    argument sets the option to a given value):</p>
<p class="Pp"></p>
<pre>  $parser-&gt;validation();
  $parser-&gt;recover();
  $parser-&gt;pedantic_parser();
  $parser-&gt;line_numbers();
  $parser-&gt;load_ext_dtd();
  $parser-&gt;complete_attributes();
  $parser-&gt;expand_xinclude();
  $parser-&gt;gdome_dom();
  $parser-&gt;clean_namespaces();
  $parser-&gt;no_network();
</pre>
<p class="Pp">The following obsolete methods trigger parser options in some
    special way:</p>
<dl class="Bl-tag">
  <dt id="recover_silently"><a class="permalink" href="#recover_silently">recover_silently</a></dt>
  <dd>
    <pre>  $parser-&gt;recover_silently(1);
    </pre>
    <p class="Pp">If called without an argument, returns true if the current
        value of the <span class="Li">&quot;recover&quot;</span> parser option
        is 2 and returns false otherwise. With a true argument sets the
        <span class="Li">&quot;recover&quot;</span> parser option to 2; with a
        false argument sets the <span class="Li">&quot;recover&quot;</span>
        parser option to 0.</p>
  </dd>
  <dt id="expand_entities~2"><a class="permalink" href="#expand_entities~2">expand_entities</a></dt>
  <dd>
    <pre>  $parser-&gt;expand_entities(0);
    </pre>
    <p class="Pp">Get/set the
        <span class="Li">&quot;expand_entities&quot;</span> option. If called
        with a true argument, also turns the
        <span class="Li">&quot;load_ext_dtd&quot;</span> option to 1.</p>
  </dd>
  <dt id="keep_blanks"><a class="permalink" href="#keep_blanks">keep_blanks</a></dt>
  <dd>
    <pre>  $parser-&gt;keep_blanks(0);
    </pre>
    <p class="Pp">This is actually the opposite of the
        <span class="Li">&quot;no_blanks&quot;</span> parser option. If used
        without an argument retrieves negated value of
        <span class="Li">&quot;no_blanks&quot;</span>. If used with an argument
        sets <span class="Li">&quot;no_blanks&quot;</span> to the opposite
        value.</p>
  </dd>
  <dt id="base_uri"><a class="permalink" href="#base_uri">base_uri</a></dt>
  <dd>
    <pre>  $parser-&gt;base_uri( $your_base_uri );
    </pre>
    <p class="Pp">Get/set the <span class="Li">&quot;URI&quot;</span>
      option.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="XML_CATALOGS"><a class="permalink" href="#XML_CATALOGS">XML
  CATALOGS</a></h1>
<p class="Pp"><span class="Li">&quot;libxml2&quot;</span> supports XML catalogs.
    Catalogs are used to map remote resources to their local copies. Using
    catalogs can speed up parsing processes if many external resources from
    remote addresses are loaded into the parsed documents (such as DTDs or
    XIncludes).</p>
<p class="Pp">Note that libxml2 has a global pool of loaded catalogs, so if you
    apply the method <span class="Li">&quot;load_catalog&quot;</span> to one
    parser instance, all parser instances will start using the catalog (in
    addition to other previously loaded catalogs).</p>
<p class="Pp">Note also that catalogs are not used when a custom external entity
    handler is specified. At the current state it is not possible to make use of
    both types of resolving systems at the same time.</p>
<dl class="Bl-tag">
  <dt id="load_catalog"><a class="permalink" href="#load_catalog">load_catalog</a></dt>
  <dd>
    <pre>  $parser-&gt;load_catalog( $catalog_file );
    </pre>
    <p class="Pp">Loads the XML catalog file
        <span class="Li">$catalog_file</span>.</p>
    <p class="Pp"></p>
    <pre>  # Global external entity loader (similar to ext_ent_handler option
  # but this works really globally, also in XML::LibXSLT include etc..)
  XML::LibXML::externalEntityLoader(\&amp;my_loader);
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="ERROR_REPORTING"><a class="permalink" href="#ERROR_REPORTING">ERROR
  REPORTING</a></h1>
<p class="Pp">XML::LibXML throws exceptions during parsing, validation or XPath
    processing (and some other occasions). These errors can be caught by using
    <i>eval</i> blocks. The error is stored in <i>$@</i>. There are two
    implementations: the old one throws $@ which is just a message string, in
    the new one $@ is an object from the class XML::LibXML::Error; this class
    overrides the operator &quot;&quot; so that when printed, the object
    flattens to the usual error message.</p>
<p class="Pp">XML::LibXML throws errors as they occur. This is a very common
    misunderstanding in the use of XML::LibXML. If the eval is omitted,
    XML::LibXML will always halt your script by &quot;croaking&quot; (see Carp
    man page for details).</p>
<p class="Pp">Also note that an increasing number of functions throw errors if
    bad data is passed as arguments. If you cannot assure valid data passed to
    XML::LibXML you should eval these functions.</p>
<p class="Pp">Note: since version 1.59, <b>get_last_error()</b> is no longer
    available in XML::LibXML for thread-safety reasons.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp">Matt Sergeant, Christian Glahn, Petr Pajas</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">2.0110</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">2001-2007, AxKit.com Ltd.</p>
<p class="Pp">2002-2006, Christian Glahn.</p>
<p class="Pp">2006-2009, Petr Pajas.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-02-01</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Try::Tiny(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Try::Tiny(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Try::Tiny(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Try::Tiny - Minimal try/catch with proper preservation of $@</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 0.30</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">You can use Try::Tiny's <span class="Li">&quot;try&quot;</span>
    and <span class="Li">&quot;catch&quot;</span> to expect and handle
    exceptional conditions, avoiding quirks in Perl and common mistakes:</p>
<p class="Pp"></p>
<pre>  # handle errors with a catch handler
  try {
    die &quot;foo&quot;;
  } catch {
    warn &quot;caught error: $_&quot;; # not $@
  };
</pre>
<p class="Pp">You can also use it like a standalone
    <span class="Li">&quot;eval&quot;</span> to catch and ignore any error
    conditions. Obviously, this is an extreme measure not to be undertaken
    lightly:</p>
<p class="Pp"></p>
<pre>  # just silence errors
  try {
    die &quot;foo&quot;;
  };
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module provides bare bones
    <span class="Li">&quot;try&quot;</span>/<span class="Li">&quot;catch&quot;</span>/<span class="Li">&quot;finally&quot;</span>
    statements that are designed to minimize common mistakes with eval blocks,
    and NOTHING else.</p>
<p class="Pp">This is unlike TryCatch which provides a nice syntax and avoids
    adding another call stack layer, and supports calling
    <span class="Li">&quot;return&quot;</span> from the
    <span class="Li">&quot;try&quot;</span> block to return from the parent
    subroutine. These extra features come at a cost of a few dependencies,
    namely Devel::Declare and Scope::Upper which are occasionally problematic,
    and the additional catch filtering uses Moose type constraints which may not
    be desirable either.</p>
<p class="Pp">The main focus of this module is to provide simple and reliable
    error handling for those having a hard time installing TryCatch, but who
    still want to write correct <span class="Li">&quot;eval&quot;</span> blocks
    without 5 lines of boilerplate each time.</p>
<p class="Pp">It's designed to work as correctly as possible in light of the
    various pathological edge cases (see &quot;BACKGROUND&quot;) and to be
    compatible with any style of error values (simple strings, references,
    objects, overloaded objects, etc).</p>
<p class="Pp">If the <span class="Li">&quot;try&quot;</span> block dies, it
    returns the value of the last statement executed in the
    <span class="Li">&quot;catch&quot;</span> block, if there is one. Otherwise,
    it returns <span class="Li">&quot;undef&quot;</span> in scalar context or
    the empty list in list context. The following examples all assign
    <span class="Li">&quot;bar&quot;</span> to <span class="Li">$x</span>:</p>
<p class="Pp"></p>
<pre>  my $x = try { die &quot;foo&quot; } catch { &quot;bar&quot; };
  my $x = try { die &quot;foo&quot; } || &quot;bar&quot;;
  my $x = (try { die &quot;foo&quot; }) // &quot;bar&quot;;
  my $x = eval { die &quot;foo&quot; } || &quot;bar&quot;;
</pre>
<p class="Pp">You can add <span class="Li">&quot;finally&quot;</span> blocks,
    yielding the following:</p>
<p class="Pp"></p>
<pre>  my $x;
  try { die 'foo' } finally { $x = 'bar' };
  try { die 'foo' } catch { warn &quot;Got a die: $_&quot; } finally { $x = 'bar' };
</pre>
<p class="Pp"><span class="Li">&quot;finally&quot;</span> blocks are always
    executed making them suitable for cleanup code which cannot be handled using
    local. You can add as many <span class="Li">&quot;finally&quot;</span>
    blocks to a given <span class="Li">&quot;try&quot;</span> block as you
  like.</p>
<p class="Pp">Note that adding a <span class="Li">&quot;finally&quot;</span>
    block without a preceding <span class="Li">&quot;catch&quot;</span> block
    suppresses any errors. This behaviour is consistent with using a standalone
    <span class="Li">&quot;eval&quot;</span>, but it is not consistent with
    <span class="Li">&quot;try&quot;</span>/<span class="Li">&quot;finally&quot;</span>
    patterns found in other programming languages, such as Java, Python,
    Javascript or C#. If you learnt the
    <span class="Li">&quot;try&quot;</span>/<span class="Li">&quot;finally&quot;</span>
    pattern from one of these languages, watch out for this.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTS"><a class="permalink" href="#EXPORTS">EXPORTS</a></h1>
<p class="Pp">All functions are exported by default using Exporter.</p>
<p class="Pp">If you need to rename the <span class="Li">&quot;try&quot;</span>,
    <span class="Li">&quot;catch&quot;</span> or
    <span class="Li">&quot;finally&quot;</span> keyword consider using
    Sub::Import to get Sub::Exporter's flexibility.</p>
<dl class="Bl-tag">
  <dt id="try"><a class="permalink" href="#try">try (&amp;;@)</a></dt>
  <dd>Takes one mandatory <span class="Li">&quot;try&quot;</span> subroutine, an
      optional <span class="Li">&quot;catch&quot;</span> subroutine and
      <span class="Li">&quot;finally&quot;</span> subroutine.
    <p class="Pp">The mandatory subroutine is evaluated in the context of an
        <span class="Li">&quot;eval&quot;</span> block.</p>
    <p class="Pp">If no error occurred the value from the first block is
        returned, preserving list/scalar context.</p>
    <p class="Pp">If there was an error and the second subroutine was given it
        will be invoked with the error in <span class="Li">$_</span> (localized)
        and as that block's first and only argument.</p>
    <p class="Pp"><span class="Li">$@</span> does <b>not</b> contain the error.
        Inside the <span class="Li">&quot;catch&quot;</span> block it has the
        same value it had before the <span class="Li">&quot;try&quot;</span>
        block was executed.</p>
    <p class="Pp">Note that the error may be false, but if that happens the
        <span class="Li">&quot;catch&quot;</span> block will still be
      invoked.</p>
    <p class="Pp">Once all execution is finished then the
        <span class="Li">&quot;finally&quot;</span> block, if given, will
        execute.</p>
  </dd>
  <dt id="catch"><a class="permalink" href="#catch">catch (&amp;;@)</a></dt>
  <dd>Intended to be used in the second argument position of
      <span class="Li">&quot;try&quot;</span>.
    <p class="Pp">Returns a reference to the subroutine it was given but blessed
        as <span class="Li">&quot;Try::Tiny::Catch&quot;</span> which allows try
        to decode correctly what to do with this code reference.</p>
    <p class="Pp"></p>
    <pre>  catch { ... }
    </pre>
    <p class="Pp">Inside the <span class="Li">&quot;catch&quot;</span> block the
        caught error is stored in <span class="Li">$_</span>, while previous
        value of <span class="Li">$@</span> is still available for use. This
        value may or may not be meaningful depending on what happened before the
        <span class="Li">&quot;try&quot;</span>, but it might be a good idea to
        preserve it in an error stack.</p>
    <p class="Pp">For code that captures <span class="Li">$@</span> when
        throwing new errors (i.e. Class::Throwable), you'll need to do:</p>
    <p class="Pp"></p>
    <pre>  local $@ = $_;
    </pre>
  </dd>
  <dt id="finally"><a class="permalink" href="#finally">finally
    (&amp;;@)</a></dt>
  <dd>
    <pre>  try     { ... }
  catch   { ... }
  finally { ... };
    </pre>
    <p class="Pp">Or</p>
    <p class="Pp"></p>
    <pre>  try     { ... }
  finally { ... };
    </pre>
    <p class="Pp">Or even</p>
    <p class="Pp"></p>
    <pre>  try     { ... }
  finally { ... }
  catch   { ... };
    </pre>
    <p class="Pp">Intended to be the second or third element of
        <span class="Li">&quot;try&quot;</span>.
        <span class="Li">&quot;finally&quot;</span> blocks are always executed
        in the event of a successful <span class="Li">&quot;try&quot;</span> or
        if <span class="Li">&quot;catch&quot;</span> is run. This allows you to
        locate cleanup code which cannot be done via
        <span class="Li">&quot;local()&quot;</span> e.g. closing a file
      handle.</p>
    <p class="Pp">When invoked, the <span class="Li">&quot;finally&quot;</span>
        block is passed the error that was caught. If no error was caught, it is
        passed nothing. (Note that the
        <span class="Li">&quot;finally&quot;</span> block does not localize
        <span class="Li">$_</span> with the error, since unlike in a
        <span class="Li">&quot;catch&quot;</span> block, there is no way to know
        if <span class="Li">&quot;$_ == undef&quot;</span> implies that there
        were no errors.) In other words, the following code does just what you
        would expect:</p>
    <p class="Pp"></p>
    <pre>  try {
    die_sometimes();
  } catch {
    # ...code run in case of error
  } finally {
    if (@_) {
      print &quot;The try block died with: @_\n&quot;;
    } else {
      print &quot;The try block ran without error.\n&quot;;
    }
  };
    </pre>
    <p class="Pp"><b>You must always do your own error handling in the
        </b><span class="Li"><b>&quot;finally&quot;</b></span><b> block</b>.
        <span class="Li">&quot;Try::Tiny&quot;</span> will not do anything about
        handling possible errors coming from code located in these blocks.</p>
    <p class="Pp">Furthermore <b>exceptions in
        </b><span class="Li"><b>&quot;finally&quot;</b></span><b> blocks are not
        trappable and are unable</b> <b>to influence the execution of your
        program</b>. This is due to limitation of
        <span class="Li">&quot;DESTROY&quot;</span>-based scope guards, which
        <span class="Li">&quot;finally&quot;</span> is implemented on top of.
        This may change in a future version of Try::Tiny.</p>
    <p class="Pp">In the same way <span class="Li">&quot;catch()&quot;</span>
        blesses the code reference this subroutine does the same except it bless
        them as <span class="Li">&quot;Try::Tiny::Finally&quot;</span>.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="BACKGROUND"><a class="permalink" href="#BACKGROUND">BACKGROUND</a></h1>
<p class="Pp">There are a number of issues with
    <span class="Li">&quot;eval&quot;</span>.</p>
<section class="Ss">
<h2 class="Ss" id="Clobbering_$@"><a class="permalink" href="#Clobbering_$@">Clobbering
  $@</a></h2>
<p class="Pp">When you run an <span class="Li">&quot;eval&quot;</span> block and
    it succeeds, <span class="Li">$@</span> will be cleared, potentially
    clobbering an error that is currently being caught.</p>
<p class="Pp">This causes action at a distance, clearing previous errors your
    caller may have not yet handled.</p>
<p class="Pp"><span class="Li">$@</span> must be properly localized before
    invoking <span class="Li">&quot;eval&quot;</span> in order to avoid this
    issue.</p>
<p class="Pp">More specifically, before Perl version 5.14.0
    <span class="Li">$@</span> was clobbered at the beginning of the
    <span class="Li">&quot;eval&quot;</span>, which also made it impossible to
    capture the previous error before you die (for instance when making
    exception objects with error stacks).</p>
<p class="Pp">For this reason <span class="Li">&quot;try&quot;</span> will
    actually set <span class="Li">$@</span> to its previous value (the one
    available before entering the <span class="Li">&quot;try&quot;</span> block)
    in the beginning of the <span class="Li">&quot;eval&quot;</span> block.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Localizing_$@_silently_masks_errors"><a class="permalink" href="#Localizing_$@_silently_masks_errors">Localizing
  $@ silently masks errors</a></h2>
<p class="Pp">Inside an <span class="Li">&quot;eval&quot;</span> block,
    <span class="Li">&quot;die&quot;</span> behaves sort of like:</p>
<p class="Pp"></p>
<pre>  sub die {
    $@ = $_[0];
    return_undef_from_eval();
  }
</pre>
<p class="Pp">This means that if you were polite and localized
    <span class="Li">$@</span> you can't die in that scope, or your error will
    be discarded (printing &quot;Something's wrong&quot; instead).</p>
<p class="Pp">The workaround is very ugly:</p>
<p class="Pp"></p>
<pre>  my $error = do {
    local $@;
    eval { ... };
    $@;
  };
  ...
  die $error;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$@_might_not_be_a_true_value"><a class="permalink" href="#$@_might_not_be_a_true_value">$@
  might not be a true value</a></h2>
<p class="Pp">This code is wrong:</p>
<p class="Pp"></p>
<pre>  if ( $@ ) {
    ...
  }
</pre>
<p class="Pp">because due to the previous caveats it may have been unset.</p>
<p class="Pp"><span class="Li">$@</span> could also be an overloaded error
    object that evaluates to false, but that's asking for trouble anyway.</p>
<p class="Pp">The classic failure mode (fixed in Perl 5.14.0) is:</p>
<p class="Pp"></p>
<pre>  sub Object::DESTROY {
    eval { ... }
  }
  eval {
    my $obj = Object-&gt;new;
    die &quot;foo&quot;;
  };
  if ( $@ ) {
  }
</pre>
<p class="Pp">In this case since
    <span class="Li">&quot;Object::DESTROY&quot;</span> is not localizing
    <span class="Li">$@</span> but still uses
    <span class="Li">&quot;eval&quot;</span>, it will set
    <span class="Li">$@</span> to <span class="Li">&quot;&quot;</span>.</p>
<p class="Pp">The destructor is called when the stack is unwound, after
    <span class="Li">&quot;die&quot;</span> sets <span class="Li">$@</span> to
    <span class="Li">&quot;foo at Foo.pm line 42\n&quot;</span>, so by the time
    <span class="Li">&quot;if ( $@ )&quot;</span> is evaluated it has been
    cleared by <span class="Li">&quot;eval&quot;</span> in the destructor.</p>
<p class="Pp">The workaround for this is even uglier than the previous ones.
    Even though we can't save the value of <span class="Li">$@</span> from code
    that doesn't localize, we can at least be sure the
    <span class="Li">&quot;eval&quot;</span> was aborted due to an error:</p>
<p class="Pp"></p>
<pre>  my $failed = not eval {
    ...
    return 1;
  };
</pre>
<p class="Pp">This is because an <span class="Li">&quot;eval&quot;</span> that
    caught a <span class="Li">&quot;die&quot;</span> will always return a false
    value.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ALTERNATE_SYNTAX"><a class="permalink" href="#ALTERNATE_SYNTAX">ALTERNATE
  SYNTAX</a></h1>
<p class="Pp">Using Perl 5.10 you can use &quot;Switch statements&quot; in
    perlsyn (but please don't, because that syntax has since been deprecated
    because there was too much unexpected magical behaviour).</p>
<p class="Pp">The <span class="Li">&quot;catch&quot;</span> block is invoked in
    a topicalizer context (like a <span class="Li">&quot;given&quot;</span>
    block), but note that you can't return a useful value from
    <span class="Li">&quot;catch&quot;</span> using the
    <span class="Li">&quot;when&quot;</span> blocks without an explicit
    <span class="Li">&quot;return&quot;</span>.</p>
<p class="Pp">This is somewhat similar to Perl 6's
    <span class="Li">&quot;CATCH&quot;</span> blocks. You can use it to
    concisely match errors:</p>
<p class="Pp"></p>
<pre>  try {
    require Foo;
  } catch {
    when (/^Can't locate .*?\.pm in \@INC/) { } # ignore
    default { die $_ }
  };
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<ul class="Bl-bullet">
  <li><span class="Li">@_</span> is not available within the
      <span class="Li">&quot;try&quot;</span> block, so you need to copy your
      argument list. In case you want to work with argument values directly via
      <span class="Li">@_</span> aliasing (i.e. allow
      <span class="Li">&quot;$_[1] = &quot;foo&quot;&quot;</span>), you need to
      pass <span class="Li">@_</span> by reference:
    <p class="Pp"></p>
    <pre>  sub foo {
    my ( $self, @args ) = @_;
    try { $self-&gt;bar(@args) }
  }
    </pre>
    <p class="Pp">or</p>
    <p class="Pp"></p>
    <pre>  sub bar_in_place {
    my $self = shift;
    my $args = \@_;
    try { $_ = $self-&gt;bar($_) for @$args }
  }
    </pre>
  </li>
  <li><span class="Li">&quot;return&quot;</span> returns from the
      <span class="Li">&quot;try&quot;</span> block, not from the parent sub
      (note that this is also how <span class="Li">&quot;eval&quot;</span>
      works, but not how TryCatch works):
    <p class="Pp"></p>
    <pre>  sub parent_sub {
    try {
      die;
    }
    catch {
      return;
    };
    say &quot;this text WILL be displayed, even though an exception is thrown&quot;;
  }
    </pre>
    <p class="Pp">Instead, you should capture the return value:</p>
    <p class="Pp"></p>
    <pre>  sub parent_sub {
    my $success = try {
      die;
      1;
    };
    return unless $success;
    say &quot;This text WILL NEVER appear!&quot;;
  }
  # OR
  sub parent_sub_with_catch {
    my $success = try {
      die;
      1;
    }
    catch {
      # do something with $_
      return undef; #see note
    };
    return unless $success;
    say &quot;This text WILL NEVER appear!&quot;;
  }
    </pre>
    <p class="Pp">Note that if you have a
        <span class="Li">&quot;catch&quot;</span> block, it must return
        <span class="Li">&quot;undef&quot;</span> for this to work, since if a
        <span class="Li">&quot;catch&quot;</span> block exists, its return value
        is returned in place of <span class="Li">&quot;undef&quot;</span> when
        an exception is thrown.</p>
  </li>
  <li><span class="Li">&quot;try&quot;</span> introduces another caller stack
      frame. Sub::Uplevel is not used. Carp will not report this when using full
      stack traces, though, because <span class="Li">%Carp::Internal</span> is
      used. This lack of magic is considered a feature.</li>
  <li>The value of <span class="Li">$_</span> in the
      <span class="Li">&quot;catch&quot;</span> block is not guaranteed to be
      the value of the exception thrown (<span class="Li">$@</span>) in the
      <span class="Li">&quot;try&quot;</span> block. There is no safe way to
      ensure this, since <span class="Li">&quot;eval&quot;</span> may be used
      unhygienically in destructors. The only guarantee is that the
      <span class="Li">&quot;catch&quot;</span> will be called if an exception
      is thrown.</li>
  <li>The return value of the <span class="Li">&quot;catch&quot;</span> block is
      not ignored, so if testing the result of the expression for truth on
      success, be sure to return a false value from the
      <span class="Li">&quot;catch&quot;</span> block:
    <p class="Pp"></p>
    <pre>  my $obj = try {
    MightFail-&gt;new;
  } catch {
    ...
    return; # avoid returning a true value;
  };
  return unless $obj;
    </pre>
  </li>
  <li><span class="Li">$SIG{__DIE__}</span> is still in effect.
    <p class="Pp">Though it can be argued that
        <span class="Li">$SIG{__DIE__}</span> should be disabled inside of
        <span class="Li">&quot;eval&quot;</span> blocks, since it isn't people
        have grown to rely on it. Therefore in the interests of compatibility,
        <span class="Li">&quot;try&quot;</span> does not disable
        <span class="Li">$SIG{__DIE__}</span> for the scope of the error
        throwing code.</p>
  </li>
  <li>Lexical <span class="Li">$_</span> may override the one set by
      <span class="Li">&quot;catch&quot;</span>.
    <p class="Pp">For example Perl 5.10's
        <span class="Li">&quot;given&quot;</span> form uses a lexical
        <span class="Li">$_</span>, creating some confusing behavior:</p>
    <p class="Pp"></p>
    <pre>  given ($foo) {
    when (...) {
      try {
        ...
      } catch {
        warn $_; # will print $foo, not the error
        warn $_[0]; # instead, get the error like this
      }
    }
  }
    </pre>
    <p class="Pp">Note that this behavior was changed once again in Perl5
        version 18
        &lt;https://metacpan.org/module/perldelta#given-now-aliases-the-global-_&gt;.
        However, since the entirety of lexical <span class="Li">$_</span> is now
        considered experimental
      <br/>
      
        &lt;https://metacpan.org/module/perldelta#Lexical-_-is-now-experimental&gt;,
        it is unclear whether the new version 18 behavior is final.</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<dl class="Bl-tag">
  <dt id="TryCatch"><a class="permalink" href="#TryCatch">TryCatch</a></dt>
  <dd>Much more feature complete, more convenient semantics, but at the cost of
      implementation complexity.</dd>
  <dt id="autodie"><a class="permalink" href="#autodie">autodie</a></dt>
  <dd>Automatic error throwing for builtin functions and more. Also designed to
      work well with
      <span class="Li">&quot;given&quot;</span>/<span class="Li">&quot;when&quot;</span>.</dd>
  <dt id="Throwable"><a class="permalink" href="#Throwable">Throwable</a></dt>
  <dd>A lightweight role for rolling your own exception classes.</dd>
  <dt id="Error"><a class="permalink" href="#Error">Error</a></dt>
  <dd>Exception object implementation with a
      <span class="Li">&quot;try&quot;</span> statement. Does not localize
      <span class="Li">$@</span>.</dd>
  <dt id="Exception::Class::TryCatch"><a class="permalink" href="#Exception::Class::TryCatch">Exception::Class::TryCatch</a></dt>
  <dd>Provides a <span class="Li">&quot;catch&quot;</span> statement, but
      properly calling <span class="Li">&quot;eval&quot;</span> is your
      responsibility.
    <p class="Pp">The <span class="Li">&quot;try&quot;</span> keyword pushes
        <span class="Li">$@</span> onto an error stack, avoiding some of the
        issues with <span class="Li">$@</span>, but you still need to localize
        to prevent clobbering.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="LIGHTNING_TALK"><a class="permalink" href="#LIGHTNING_TALK">LIGHTNING
  TALK</a></h1>
<p class="Pp">I gave a lightning talk about this module, you can see the slides
    (Firefox only):</p>
<p class="Pp">&lt;http://web.archive.org/web/20100628040134/http://nothingmuch.woobling.org/talks/takahashi.xul&gt;</p>
<p class="Pp">Or read the source:</p>
<p class="Pp">&lt;http://web.archive.org/web/20100305133605/http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
<p class="Pp">Bugs may be submitted through the RT bug tracker
    &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=Try-Tiny&gt; (or
    bug-Try-Tiny@rt.cpan.org &lt;mailto:bug-Try-Tiny@rt.cpan.org&gt;).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>&#x05D9;&#x05D5;&#x05D1;&#x05DC; &#x05E7;&#x05D5;&#x05D2;'&#x05DE;&#x05DF;
      (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<ul class="Bl-bullet">
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Peter Rabbitson &lt;ribasushi@cpan.org&gt;</li>
  <li>Ricardo Signes &lt;rjbs@cpan.org&gt;</li>
  <li>Mark Fowler &lt;mark@twoshortplanks.com&gt;</li>
  <li>Graham Knop &lt;haarg@haarg.org&gt;</li>
  <li>Lukas Mai &lt;l.mai@web.de&gt;</li>
  <li>Aristotle Pagaltzis &lt;pagaltzis@gmx.de&gt;</li>
  <li>Dagfinn Ilmari Manns&#x00E5;ker &lt;ilmari@ilmari.org&gt;</li>
  <li>Paul Howarth &lt;paul@city-fan.org&gt;</li>
  <li>Rudolf Leermakers &lt;rudolf@hatsuseno.org&gt;</li>
  <li>anaxagoras &lt;walkeraj@gmail.com&gt;</li>
  <li>awalker &lt;awalker@sourcefire.com&gt;</li>
  <li>chromatic &lt;chromatic@wgz.org&gt;</li>
  <li>Alex &lt;alex@koban.(none)&gt;</li>
  <li>cm-perl &lt;cm-perl@users.noreply.github.com&gt;</li>
  <li>Andrew Yates &lt;ayates@haddock.local&gt;</li>
  <li>David Lowe &lt;davidl@lokku.com&gt;</li>
  <li>Glenn Fowler &lt;cebjyre@cpan.org&gt;</li>
  <li>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</li>
  <li>Jens Berthold &lt;jens@jebecs.de&gt;</li>
  <li>Jonathan Yu &lt;JAWNSY@cpan.org&gt;</li>
  <li>Marc Mims &lt;marc@questright.com&gt;</li>
  <li>Mark Stosberg &lt;mark@stosberg.com&gt;</li>
  <li>Pali &lt;pali@cpan.org&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENCE"><a class="permalink" href="#COPYRIGHT_AND_LICENCE">COPYRIGHT
  AND LICENCE</a></h1>
<p class="Pp">This software is Copyright (c) 2009 by
    &#x05D9;&#x05D5;&#x05D1;&#x05DC; &#x05E7;&#x05D5;&#x05D2;'&#x05DE;&#x05DF;
    (Yuval Kogman).</p>
<p class="Pp">This is free software, licensed under:</p>
<p class="Pp"></p>
<pre>  The MIT (X11) License
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-12-21</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

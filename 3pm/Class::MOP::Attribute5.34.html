<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Class::MOP::Attribute(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Class::MOP::Attribute(3)</td>
    <td class="head-vol"><a href=".">User Contributed Perl Documentation</a></td>
    <td class="head-rtitle">Class::MOP::Attribute(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Class::MOP::Attribute - Attribute Meta Object</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 2.2012</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  Class::MOP::Attribute-&gt;new(
      foo =&gt; (
          accessor  =&gt; 'foo',           # dual purpose get/set accessor
          predicate =&gt; 'has_foo',       # predicate check for defined-ness
          init_arg  =&gt; '-foo',          # class-&gt;new will look for a -foo key
          default   =&gt; 'BAR IS BAZ!'    # if no -foo key is provided, use this
      )
  );
  Class::MOP::Attribute-&gt;new(
      bar =&gt; (
          reader    =&gt; 'bar',           # getter
          writer    =&gt; 'set_bar',       # setter
          predicate =&gt; 'has_bar',       # predicate check for defined-ness
          init_arg  =&gt; ':bar',          # class-&gt;new will look for a :bar key
                                        # no default value means it is undef
      )
  );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The Attribute Protocol is almost entirely an invention of
    <span class="Li">&quot;Class::MOP&quot;</span>. Perl 5 does not have a
    consistent notion of attributes. There are so many ways in which this is
    done, and very few (if any) are easily discoverable by this module.</p>
<p class="Pp">With that said, this module attempts to inject some order into
    this chaos, by introducing a consistent API which can be used to create
    object attributes.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Creation"><a class="permalink" href="#Creation">Creation</a></h2>
<dl class="Bl-tag">
  <dt id="Class::MOP::Attribute"><a class="permalink" href="#Class::MOP::Attribute"><b>Class::MOP::Attribute-&gt;new($name,
    ?%options)</b></a></dt>
  <dd>An attribute must (at the very least), have a
      <span class="Li">$name</span>. All other <span class="Li">%options</span>
      are added as key-value pairs.</dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>init_arg
    <p class="Pp">This is a string value representing the expected key in an
        initialization hash. For instance, if we have an
        <span class="Li">&quot;init_arg&quot;</span> value of
        <span class="Li">&quot;-foo&quot;</span>, then the following code will
        Just Work.</p>
    <p class="Pp"></p>
    <pre>  MyClass-&gt;meta-&gt;new_object( -foo =&gt; 'Hello There' );
    </pre>
    <p class="Pp">If an init_arg is not assigned, it will automatically use the
        attribute's name. If <span class="Li">&quot;init_arg&quot;</span> is
        explicitly set to <span class="Li">&quot;undef&quot;</span>, the
        attribute cannot be specified during initialization.</p>
  </li>
  <li>builder
    <p class="Pp">This provides the name of a method that will be called to
        initialize the attribute. This method will be called on the object after
        it is constructed. It is expected to return a valid value for the
        attribute.</p>
  </li>
  <li>default
    <p class="Pp">This can be used to provide an explicit default for
        initializing the attribute. If the default you provide is a subroutine
        reference, then this reference will be called <i>as a method</i> on the
        object.</p>
    <p class="Pp">If the value is a simple scalar (string or number), then it
        can be just passed as is. However, if you wish to initialize it with a
        HASH or ARRAY ref, then you need to wrap that inside a subroutine
        reference:</p>
    <p class="Pp"></p>
    <pre>  Class::MOP::Attribute-&gt;new(
      'foo' =&gt; (
          default =&gt; sub { [] },
      )
  );
  # or ...
  Class::MOP::Attribute-&gt;new(
      'foo' =&gt; (
          default =&gt; sub { {} },
      )
  );
    </pre>
    <p class="Pp">If you wish to initialize an attribute with a subroutine
        reference itself, then you need to wrap that in a subroutine as
      well:</p>
    <p class="Pp"></p>
    <pre>  Class::MOP::Attribute-&gt;new(
      'foo' =&gt; (
          default =&gt; sub {
              sub { print &quot;Hello World&quot; }
          },
      )
  );
    </pre>
    <p class="Pp">And lastly, if the value of your attribute is dependent upon
        some other aspect of the instance structure, then you can take advantage
        of the fact that when the <span class="Li">&quot;default&quot;</span>
        value is called as a method:</p>
    <p class="Pp"></p>
    <pre>  Class::MOP::Attribute-&gt;new(
      'object_identity' =&gt; (
          default =&gt; sub { Scalar::Util::refaddr( $_[0] ) },
      )
  );
    </pre>
    <p class="Pp">Note that there is no guarantee that attributes are
        initialized in any particular order, so you cannot rely on the value of
        some other attribute when generating the default.</p>
  </li>
  <li>initializer
    <p class="Pp">This option can be either a method name or a subroutine
        reference. This method will be called when setting the attribute's value
        in the constructor. Unlike <span class="Li">&quot;default&quot;</span>
        and <span class="Li">&quot;builder&quot;</span>, the initializer is only
        called when a value is provided to the constructor. The initializer
        allows you to munge this value during object construction.</p>
    <p class="Pp">The initializer is called as a method with three arguments.
        The first is the value that was passed to the constructor. The second is
        a subroutine reference that can be called to actually set the
        attribute's value, and the last is the associated
        <span class="Li">&quot;Class::MOP::Attribute&quot;</span> object.</p>
    <p class="Pp">This contrived example shows an initializer that sets the
        attribute to twice the given value.</p>
    <p class="Pp"></p>
    <pre>  Class::MOP::Attribute-&gt;new(
      'doubled' =&gt; (
          initializer =&gt; sub {
              my ( $self, $value, $set, $attr ) = @_;
              $set-&gt;( $value * 2 );
          },
      )
  );
    </pre>
    <p class="Pp">Since an initializer can be a method name, you can easily make
        attribute initialization use the writer:</p>
    <p class="Pp"></p>
    <pre>  Class::MOP::Attribute-&gt;new(
      'some_attr' =&gt; (
          writer      =&gt; 'some_attr',
          initializer =&gt; 'some_attr',
      )
  );
    </pre>
    <p class="Pp">Your writer (actually, a wrapper around the writer, using
        method modifications) will need to examine <span class="Li">@_</span>
        and determine under which context it is being called:</p>
    <p class="Pp"></p>
    <pre>  around 'some_attr' =&gt; sub {
      my $orig = shift;
      my $self = shift;
      # $value is not defined if being called as a reader
      # $setter and $attr are only defined if being called as an initializer
      my ($value, $setter, $attr) = @_;
      # the reader behaves normally
      return $self-&gt;$orig if not @_;
      # mutate $value as desired
      # $value = &lt;something($value);
      # if called as an initializer, set the value and we're done
      return $setter-&gt;($row) if $setter;
      # otherwise, call the real writer with the new value
      $self-&gt;$orig($row);
  };
    </pre>
  </li>
</ul>
</div>
<div class="Bd-indent">
<p class="Pp">The <span class="Li">&quot;accessor&quot;</span>,
    <span class="Li">&quot;reader&quot;</span>,
    <span class="Li">&quot;writer&quot;</span>,
    <span class="Li">&quot;predicate&quot;</span> and
    <span class="Li">&quot;clearer&quot;</span> options all accept the same
    parameters. You can provide the name of the method, in which case an
    appropriate default method will be generated for you. Or instead you can
    also provide hash reference containing exactly one key (the method name) and
    one value. The value should be a subroutine reference, which will be
    installed as the method itself.</p>
<ul class="Bl-bullet">
  <li>accessor
    <p class="Pp">An <span class="Li">&quot;accessor&quot;</span> is a standard
        Perl-style read/write accessor. It will return the value of the
        attribute, and if a value is passed as an argument, it will assign that
        value to the attribute.</p>
    <p class="Pp">Note that <span class="Li">&quot;undef&quot;</span> is a
        legitimate value, so this will work:</p>
    <p class="Pp"></p>
    <pre>  $object-&gt;set_something(undef);
    </pre>
  </li>
  <li>reader
    <p class="Pp">This is a basic read-only accessor. It returns the value of
        the attribute.</p>
  </li>
  <li>writer
    <p class="Pp">This is a basic write accessor, it accepts a single argument,
        and assigns that value to the attribute.</p>
    <p class="Pp">Note that <span class="Li">&quot;undef&quot;</span> is a
        legitimate value, so this will work:</p>
    <p class="Pp"></p>
    <pre>  $object-&gt;set_something(undef);
    </pre>
  </li>
  <li>predicate
    <p class="Pp">The predicate method returns a boolean indicating whether or
        not the attribute has been explicitly set.</p>
    <p class="Pp">Note that the predicate returns true even if the attribute was
        set to a false value (<span class="Li">0</span> or
        <span class="Li">&quot;undef&quot;</span>).</p>
  </li>
  <li>clearer
    <p class="Pp">This method will uninitialize the attribute. After an
        attribute is cleared, its <span class="Li">&quot;predicate&quot;</span>
        will return false.</p>
  </li>
  <li>definition_context
    <p class="Pp">Mostly, this exists as a hook for the benefit of Moose.</p>
    <p class="Pp">This option should be a hash reference containing several keys
        which will be used when inlining the attribute's accessors. The keys
        should include <span class="Li">&quot;line&quot;</span>, the line number
        where the attribute was created, and either
        <span class="Li">&quot;file&quot;</span> or
        <span class="Li">&quot;description&quot;</span>.</p>
    <p class="Pp">This information will ultimately be used when eval'ing inlined
        accessor code so that error messages report a useful line and file
      name.</p>
  </li>
</ul>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;clone(%options)</b></dt>
  <dd>This clones the attribute. Any options you provide will override the
      settings of the original attribute. You can change the name of the new
      attribute by passing a <span class="Li">&quot;name&quot;</span> key in
      <span class="Li">%options</span>.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Informational"><a class="permalink" href="#Informational">Informational</a></h2>
<p class="Pp">These are all basic read-only accessors for the values passed into
    the constructor.</p>
<dl class="Bl-tag">
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;name</b></dt>
  <dd>Returns the attribute's name.</dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;accessor</b></dt>
  <dd></dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;reader</b></dt>
  <dd></dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;writer</b></dt>
  <dd></dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;predicate</b></dt>
  <dd></dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;clearer</b></dt>
  <dd>The <span class="Li">&quot;accessor&quot;</span>,
      <span class="Li">&quot;reader&quot;</span>,
      <span class="Li">&quot;writer&quot;</span>,
      <span class="Li">&quot;predicate&quot;</span>, and
      <span class="Li">&quot;clearer&quot;</span> methods all return exactly
      what was passed to the constructor, so it can be either a string
      containing a method name, or a hash reference.</dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;initializer</b></dt>
  <dd>Returns the initializer as passed to the constructor, so this may be
      either a method name or a subroutine reference.</dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;init_arg</b></dt>
  <dd></dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;is_default_a_coderef</b></dt>
  <dd></dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;builder</b></dt>
  <dd></dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;default($instance)</b></dt>
  <dd>The <span class="Li">$instance</span> argument is optional. If you don't
      pass it, the return value for this method is exactly what was passed to
      the constructor, either a simple scalar or a subroutine reference.
    <p class="Pp">If you <i>do</i> pass an <span class="Li">$instance</span> and
        the default is a subroutine reference, then the reference is called as a
        method on the <span class="Li">$instance</span> and the generated value
        is returned.</p>
  </dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;slots</b></dt>
  <dd>Return a list of slots required by the attribute. This is usually just
      one, the name of the attribute.
    <p class="Pp">A slot is the name of the hash key used to store the attribute
        in an object instance.</p>
  </dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;get_read_method</b></dt>
  <dd></dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;get_write_method</b></dt>
  <dd>Returns the name of a method suitable for reading or writing the value of
      the attribute in the associated class.
    <p class="Pp">If an attribute is read- or write-only, then these methods can
        return <span class="Li">&quot;undef&quot;</span> as appropriate.</p>
  </dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;has_read_method</b></dt>
  <dd></dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;has_write_method</b></dt>
  <dd>This returns a boolean indicating whether the attribute has a <i>named</i>
      read or write method.</dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;get_read_method_ref</b></dt>
  <dd></dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;get_write_method_ref</b></dt>
  <dd>Returns the subroutine reference of a method suitable for reading or
      writing the attribute's value in the associated class. These methods
      always return a subroutine reference, regardless of whether or not the
      attribute is read- or write-only.</dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;insertion_order</b></dt>
  <dd>If this attribute has been inserted into a class, this returns a zero
      based index regarding the order of insertion.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Informational_predicates"><a class="permalink" href="#Informational_predicates">Informational
  predicates</a></h2>
<p class="Pp">These are all basic predicate methods for the values passed into
    <span class="Li">&quot;new&quot;</span>.</p>
<dl class="Bl-tag">
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;has_accessor</b></dt>
  <dd></dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;has_reader</b></dt>
  <dd></dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;has_writer</b></dt>
  <dd></dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;has_predicate</b></dt>
  <dd></dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;has_clearer</b></dt>
  <dd></dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;has_initializer</b></dt>
  <dd></dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;has_init_arg</b></dt>
  <dd>This will be <i>false</i> if the
      <span class="Li">&quot;init_arg&quot;</span> was set to
      <span class="Li">&quot;undef&quot;</span>.</dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;has_default</b></dt>
  <dd>This will be <i>false</i> if the
      <span class="Li">&quot;default&quot;</span> was set to
      <span class="Li">&quot;undef&quot;</span>, since
      <span class="Li">&quot;undef&quot;</span> is the default
      <span class="Li">&quot;default&quot;</span> anyway.</dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;has_builder</b></dt>
  <dd></dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;has_insertion_order</b></dt>
  <dd>This will be <i>false</i> if this attribute has not be inserted into a
      class</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Value_management"><a class="permalink" href="#Value_management">Value
  management</a></h2>
<p class="Pp">These methods are basically &quot;back doors&quot; to the
    instance, and can be used to bypass the regular accessors, but still stay
    within the MOP.</p>
<p class="Pp">These methods are not for general use, and should only be used if
    you really know what you are doing.</p>
<dl class="Bl-tag">
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;initialize_instance_slot($meta_instance,
    </b><span class="Li"><b>$instance</b></span><b>,
    </b><span class="Li"><b>$params</b></span><b>)</b></dt>
  <dd>This method is used internally to initialize the attribute's slot in the
      object <span class="Li">$instance</span>.
    <p class="Pp">The <span class="Li">$params</span> is a hash reference of the
        values passed to the object constructor.</p>
    <p class="Pp">It's unlikely that you'll need to call this method
      yourself.</p>
  </dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;set_value($instance,
    </b><span class="Li"><b>$value</b></span><b>)</b></dt>
  <dd>Sets the value without going through the accessor. Note that this works
      even with read-only attributes.</dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;set_raw_value($instance,
    </b><span class="Li"><b>$value</b></span><b>)</b></dt>
  <dd>Sets the value with no side effects such as a trigger.
    <p class="Pp">This doesn't actually apply to Class::MOP attributes, only to
        subclasses.</p>
  </dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;set_initial_value($instance,
    </b><span class="Li"><b>$value</b></span><b>)</b></dt>
  <dd>Sets the value without going through the accessor. This method is only
      called when the instance is first being initialized.</dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;get_value($instance)</b></dt>
  <dd>Returns the value without going through the accessor. Note that this works
      even with write-only accessors.</dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;get_raw_value($instance)</b></dt>
  <dd>Returns the value without any side effects such as lazy attributes.
    <p class="Pp">Doesn't actually apply to Class::MOP attributes, only to
        subclasses.</p>
  </dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;has_value($instance)</b></dt>
  <dd>Return a boolean indicating whether the attribute has been set in
      <span class="Li">$instance</span>. This how the default
      <span class="Li">&quot;predicate&quot;</span> method works.</dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;clear_value($instance)</b></dt>
  <dd>This will clear the attribute's value in
      <span class="Li">$instance</span>. This is what the default
      <span class="Li">&quot;clearer&quot;</span> calls.
    <p class="Pp">Note that this works even if the attribute does not have any
        associated read, write or clear methods.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Class_association"><a class="permalink" href="#Class_association">Class
  association</a></h2>
<p class="Pp">These methods allow you to manage the attributes association with
    the class that contains it. These methods should not be used lightly, nor
    are they very magical, they are mostly used internally and by metaclass
    instances.</p>
<dl class="Bl-tag">
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;associated_class</b></dt>
  <dd>This returns the Class::MOP::Class with which this attribute is
      associated, if any.</dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;attach_to_class($metaclass)</b></dt>
  <dd>This method stores a weakened reference to the
      <span class="Li">$metaclass</span> object internally.
    <p class="Pp">This method does not remove the attribute from its old class,
        nor does it create any accessors in the new class.</p>
    <p class="Pp">It is probably best to use the Class::MOP::Class
        <span class="Li">&quot;add_attribute&quot;</span> method instead.</p>
  </dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;detach_from_class</b></dt>
  <dd>This method removes the associate metaclass object from the attribute it
      has one.
    <p class="Pp">This method does not remove the attribute itself from the
        class, or remove its accessors.</p>
    <p class="Pp">It is probably best to use the Class::MOP::Class
        <span class="Li">&quot;remove_attribute&quot;</span> method instead.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Attribute_Accessor_generation"><a class="permalink" href="#Attribute_Accessor_generation">Attribute
  Accessor generation</a></h2>
<dl class="Bl-tag">
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;accessor_metaclass</b></dt>
  <dd>Accessor methods are generated using an accessor metaclass. By default,
      this is Class::MOP::Method::Accessor. This method returns the name of the
      accessor metaclass that this attribute uses.</dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;associate_method($method)</b></dt>
  <dd>This associates a Class::MOP::Method object with the attribute. Typically,
      this is called internally when an attribute generates its accessors.</dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;associated_methods</b></dt>
  <dd>This returns the list of methods which have been associated with the
      attribute.</dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;install_accessors</b></dt>
  <dd>This method generates and installs code the attributes various accessors.
      It is typically called from the Class::MOP::Class
      <span class="Li">&quot;add_attribute&quot;</span> method.</dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;remove_accessors</b></dt>
  <dd>This method removes all of the accessors associated with the attribute.
    <p class="Pp">This does not currently remove methods from the list returned
        by <span class="Li">&quot;associated_methods&quot;</span>.</p>
  </dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;inline_get</b></dt>
  <dd></dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;inline_set</b></dt>
  <dd></dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;inline_has</b></dt>
  <dd></dd>
  <dt><b></b><span class="Li"><b>$attr</b></span><b>-&gt;inline_clear</b></dt>
  <dd>These methods return a code snippet suitable for inlining the relevant
      operation. They expect strings containing variable names to be used in the
      inlining, like <span class="Li">'$self'</span> or
      <span class="Li">'$_[1]'</span>.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Introspection"><a class="permalink" href="#Introspection">Introspection</a></h2>
<dl class="Bl-tag">
  <dt id="Class::MOP::Attribute~2"><a class="permalink" href="#Class::MOP::Attribute~2"><b>Class::MOP::Attribute-&gt;meta</b></a></dt>
  <dd>This will return a Class::MOP::Class instance for this class.
    <p class="Pp">It should also be noted that Class::MOP will actually
        bootstrap this module by installing a number of attribute meta-objects
        into its metaclass.</p>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Stevan Little &lt;stevan.little@iinteractive.com&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
  <li>Shawn M Moore &lt;code@sartak.org&gt;</li>
  <li>&#x05D9;&#x05D5;&#x05D1;&#x05DC; &#x05E7;&#x05D5;&#x05D2;'&#x05DE;&#x05DF;
      (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Florian Ragwitz &lt;rafl@debian.org&gt;</li>
  <li>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</li>
  <li>Chris Prather &lt;chris@prather.org&gt;</li>
  <li>Matt S Trout &lt;mst@shadowcat.co.uk&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2006 by Infinity Interactive,
  Inc.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-11-22</td>
    <td class="foot-os"><a href="..">perl v5.34.0</a></td>
  </tr>
</table>
</body>
</html>

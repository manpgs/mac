<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>MIME::Body(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">MIME::Body(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">MIME::Body(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">MIME::Body - the body of a MIME message</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">Before reading further, you should see MIME::Tools to make sure
    that you understand where this module fits into the grand scheme of things.
    Go on, do it now. I'll wait.</p>
<p class="Pp">Ready? Ok...</p>
<section class="Ss">
<h2 class="Ss" id="Obtaining_bodies"><a class="permalink" href="#Obtaining_bodies">Obtaining
  bodies</a></h2>
<pre>   ### Get the bodyhandle of a MIME::Entity object:
   $body = $entity-&gt;bodyhandle;
   ### Create a body which stores data in a disk file:
   $body = new MIME::Body::File &quot;/path/to/file&quot;;
   ### Create a body which stores data in an in-core array:
   $body = new MIME::Body::InCore \@strings;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Opening,_closing,_and_using_"><a class="permalink" href="#Opening,_closing,_and_using_">Opening,
  closing, and using IO handles</a></h2>
<pre>   ### Write data to the body:
   $IO = $body-&gt;open(&quot;w&quot;)      || die &quot;open body: $!&quot;;
   $IO-&gt;print($message);
   $IO-&gt;close                  || die &quot;close I/O handle: $!&quot;;
   ### Read data from the body (in this case, line by line):
   $IO = $body-&gt;open(&quot;r&quot;)      || die &quot;open body: $!&quot;;
   while (defined($_ = $IO-&gt;getline)) {
       ### do stuff
   }
   $IO-&gt;close                  || die &quot;close I/O handle: $!&quot;;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Other_I/O"><a class="permalink" href="#Other_I/O">Other
  I/O</a></h2>
<pre>   ### Dump the ENCODED body data to a filehandle:
   $body-&gt;print(\*STDOUT);
   ### Slurp all the UNENCODED data in, and put it in a scalar:
   $string = $body-&gt;as_string;
   ### Slurp all the UNENCODED data in, and put it in an array of lines:
   @lines = $body-&gt;as_lines;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Working_directly_with_paths_to_underlying_files"><a class="permalink" href="#Working_directly_with_paths_to_underlying_files">Working
  directly with paths to underlying files</a></h2>
<pre>   ### Where's the data?
   if (defined($body-&gt;path)) {   ### data is on disk:
       print &quot;data is stored externally, in &quot;, $body-&gt;path;
   }
   else {                        ### data is in core:
       print &quot;data is already in core, and is...\n&quot;, $body-&gt;as_string;
   }
   ### Get rid of anything on disk:
   $body-&gt;purge;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">MIME messages can be very long (e.g., tar files, MPEGs, etc.) or
    very short (short textual notes, as in ordinary mail). Long messages are
    best stored in files, while short ones are perhaps best stored in core.</p>
<p class="Pp">This class is an attempt to define a common interface for objects
    which contain message data, regardless of how the data is physically stored.
    The lifespan of a &quot;body&quot; object usually looks like this:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd><b>Body object is created by a MIME::Parser during parsing.</b> It's at
      this point that the actual MIME::Body subclass is chosen, and <b>new()</b>
      is invoked. (For example: if the body data is going to a file, then it is
      at this point that the class MIME::Body::File, and the filename, is
      chosen).</dd>
  <dt>2.</dt>
  <dd><b>Data is written to the body</b> (usually by the MIME parser) like this:
      The body is opened for writing, via
      <span class="Li">&quot;open(&quot;w&quot;)&quot;</span>. This will trash
      any previous contents, and return an &quot;I/O handle&quot; opened for
      writing. Data is written to this I/O handle, via <b>print()</b>. Then the
      I/O handle is closed, via <b>close()</b>.</dd>
  <dt>3.</dt>
  <dd><b>Data is read from the body</b> (usually by the user application) like
      this: The body is opened for reading by a user application, via
      <span class="Li">&quot;open(&quot;r&quot;)&quot;</span>. This will return
      an &quot;I/O handle&quot; opened for reading. Data is read from the I/O
      handle, via <b>read()</b>, <b>getline()</b>, or <b>getlines()</b>. Then
      the I/O handle is closed, via <b>close()</b>.</dd>
  <dt>4.</dt>
  <dd><b>Body object is destructed.</b></dd>
</dl>
<p class="Pp">You can write your own subclasses, as long as they follow the
    interface described below. Implementers of subclasses should assume that
    steps 2 and 3 may be repeated any number of times, and in different orders
    (e.g., 1-2-2-3-2-3-3-3-3-3-2-4).</p>
<p class="Pp">In any case, once a MIME::Body has been created, you ask to open
    it for reading or writing, which gets you an &quot;i/o handle&quot;: you
    then use the same mechanisms for reading from or writing to that handle, no
    matter what class it is.</p>
<p class="Pp">Beware: unless you know for certain what kind of body you have,
    you should <i>not</i> assume that the body has an underlying filehandle.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PUBLIC_INTERFACE"><a class="permalink" href="#PUBLIC_INTERFACE">PUBLIC
  INTERFACE</a></h1>
<dl class="Bl-tag">
  <dt id="new"><a class="permalink" href="#new">new ARGS...</a></dt>
  <dd><i>Class method, constructor.</i> Create a new body. Any ARGS are sent to
      <b>init()</b>.</dd>
  <dt id="init"><a class="permalink" href="#init">init ARGS...</a></dt>
  <dd><i>Instance method, abstract, initiallizer.</i> This is called
      automatically by <span class="Li">&quot;new()&quot;</span>, with the
      arguments given to <span class="Li">&quot;new()&quot;</span>. The
      arguments are optional, and entirely up to the subclass. The default
      method does nothing,</dd>
  <dt id="as_lines"><a class="permalink" href="#as_lines">as_lines</a></dt>
  <dd><i>Instance method.</i> Return the contents of the body as an array of
      lines (each terminated by a newline, with the possible exception of the
      final one). Returns empty on failure (NB: indistinguishable from an empty
      body!).
    <p class="Pp">Note: the default method gets the data via repeated
        <b>getline()</b> calls; your subclass might wish to override this.</p>
  </dd>
  <dt id="as_string"><a class="permalink" href="#as_string">as_string</a></dt>
  <dd><i>Instance method.</i> Return the body data as a string (slurping it into
      core if necessary). Best not to do this unless you're <i>sure</i> that the
      body is reasonably small! Returns empty string for an empty body, and
      undef on failure.
    <p class="Pp">Note: the default method uses <b>print()</b>, which gets the
        data via repeated <b>read()</b> calls; your subclass might wish to
        override this.</p>
  </dd>
  <dt id="binmode"><a class="permalink" href="#binmode">binmode [ONOFF]</a></dt>
  <dd><i>Instance method.</i> With argument, flags whether or not <b>open()</b>
      should return an I/O handle which has <b>binmode()</b> activated. With no
      argument, just returns the current value.</dd>
  <dt id="is_encoded"><a class="permalink" href="#is_encoded">is_encoded
    [ONOFF]</a></dt>
  <dd><i>Instance method.</i> If set to yes, no decoding is applied on output.
      This flag is set by MIME::Parser, if the parser runs in
      <b>decode_bodies</b>(0) mode, so the content is handled unmodified.</dd>
  <dt id="dup"><a class="permalink" href="#dup">dup</a></dt>
  <dd><i>Instance method.</i> Duplicate the bodyhandle.
    <p class="Pp"><i>Beware:</i> external data in bodyhandles is <i>not</i>
        copied to new files! Changing the data in one body's data file, or
        purging that body, <i>will</i> affect its duplicate. Bodies with in-core
        data probably need not worry.</p>
  </dd>
  <dt id="open"><a class="permalink" href="#open">open READWRITE</a></dt>
  <dd><i>Instance method, abstract.</i> This should do whatever is necessary to
      open the body for either writing (if READWRITE is &quot;w&quot;) or
      reading (if mode is &quot;r&quot;).
    <p class="Pp">This method is expected to return an &quot;I/O handle&quot;
        object on success, and undef on error. An I/O handle can be any object
        that supports a small set of standard methods for reading/writing data.
        See the IO::Handle class for an example.</p>
  </dd>
  <dt id="path"><a class="permalink" href="#path">path [PATH]</a></dt>
  <dd><i>Instance method.</i> If you're storing the body data externally (e.g.,
      in a disk file), you'll want to give applications the ability to get at
      that data, for cleanup. This method should return the path to the data, or
      undef if there is none.
    <p class="Pp">Where appropriate, the path <i>should</i> be a simple string,
        like a filename. With argument, sets the PATH, which should be undef if
        there is none.</p>
  </dd>
  <dt id="print"><a class="permalink" href="#print">print FILEHANDLE</a></dt>
  <dd><i>Instance method.</i> Output the body data to the given filehandle, or
      to the currently-selected one if none is given.</dd>
  <dt id="purge"><a class="permalink" href="#purge">purge</a></dt>
  <dd><i>Instance method, abstract.</i> Remove any data which resides external
      to the program (e.g., in disk files). Immediately after a <b>purge()</b>,
      the <b>path()</b> should return undef to indicate that the external data
      is no longer available.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SUBCLASSES"><a class="permalink" href="#SUBCLASSES">SUBCLASSES</a></h1>
<p class="Pp">The following built-in classes are provided:</p>
<p class="Pp"></p>
<pre>   Body                 Stores body     When open()ed,
   class:               data in:        returns:
   --------------------------------------------------------
   MIME::Body::File     disk file       IO::Handle
   MIME::Body::Scalar   scalar          IO::Handle
   MIME::Body::InCore   scalar array    IO::Handle
</pre>
<section class="Ss">
<h2 class="Ss" id="MIME::Body::File"><a class="permalink" href="#MIME::Body::File">MIME::Body::File</a></h2>
<p class="Pp">A body class that stores the data in a disk file. Invoke the
    constructor as:</p>
<p class="Pp"></p>
<pre>    $body = new MIME::Body::File &quot;/path/to/file&quot;;
</pre>
<p class="Pp">In this case, the <span class="Li">&quot;path()&quot;</span>
    method would return the given path, so you <i>could</i> say:</p>
<p class="Pp"></p>
<pre>    if (defined($body-&gt;path)) {
        open BODY, $body-&gt;path or die &quot;open: $!&quot;;
        while (&lt;BODY&gt;) {
            ### do stuff
        }
        close BODY;
    }
</pre>
<p class="Pp">But you're best off not doing this.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="MIME::Body::Scalar"><a class="permalink" href="#MIME::Body::Scalar">MIME::Body::Scalar</a></h2>
<p class="Pp">A body class that stores the data in-core, in a simple scalar.
    Invoke the constructor as:</p>
<p class="Pp"></p>
<pre>    $body = new MIME::Body::Scalar \$string;
</pre>
<p class="Pp">A single scalar argument sets the body to that value, exactly as
    though you'd opened for the body for writing, written the value, and closed
    the body again:</p>
<p class="Pp"></p>
<pre>    $body = new MIME::Body::Scalar &quot;Line 1\nLine 2\nLine 3&quot;;
</pre>
<p class="Pp">A single array reference sets the body to the result of joining
    all the elements of that array together:</p>
<p class="Pp"></p>
<pre>    $body = new MIME::Body::Scalar [&quot;Line 1\n&quot;,
                                    &quot;Line 2\n&quot;,
                                    &quot;Line 3&quot;];
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="MIME::Body::InCore"><a class="permalink" href="#MIME::Body::InCore">MIME::Body::InCore</a></h2>
<p class="Pp">A body class that stores the data in-core. Invoke the constructor
    as:</p>
<p class="Pp"></p>
<pre>    $body = new MIME::Body::InCore \$string;
    $body = new MIME::Body::InCore  $string;
    $body = new MIME::Body::InCore \@stringarray
</pre>
<p class="Pp">A simple scalar argument sets the body to that value, exactly as
    though you'd opened for the body for writing, written the value, and closed
    the body again:</p>
<p class="Pp"></p>
<pre>    $body = new MIME::Body::InCore &quot;Line 1\nLine 2\nLine 3&quot;;
</pre>
<p class="Pp">A single array reference sets the body to the concatenation of all
    scalars that it holds:</p>
<p class="Pp"></p>
<pre>    $body = new MIME::Body::InCore [&quot;Line 1\n&quot;,
                                    &quot;Line 2\n&quot;,
                                    &quot;Line 3&quot;];
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Defining_your_own_subclasses"><a class="permalink" href="#Defining_your_own_subclasses">Defining
  your own subclasses</a></h2>
<p class="Pp">So you're not happy with files and scalar-arrays? No problem: just
    define your own MIME::Body subclass, and make a subclass of MIME::Parser or
    MIME::ParserBase which returns an instance of your body class whenever
    appropriate in the <span class="Li">&quot;new_body_for(head)&quot;</span>
    method.</p>
<p class="Pp">Your &quot;body&quot; class must inherit from MIME::Body (or some
    subclass of it), and it must either provide (or inherit the default for) the
    following methods...</p>
<p class="Pp">The default inherited method <i>should suffice</i> for all
  these:</p>
<p class="Pp"></p>
<pre>    new
    binmode [ONOFF]
    path
</pre>
<p class="Pp">The default inherited method <i>may suffice</i> for these, but
    perhaps there's a better implementation for your subclass.</p>
<p class="Pp"></p>
<pre>    init ARGS...
    as_lines
    as_string
    dup
    print
    purge
</pre>
<p class="Pp">The default inherited method <i>will probably not suffice</i> for
    these:</p>
<p class="Pp"></p>
<pre>    open
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<p class="Pp">One reason I didn't just use IO::Handle objects for message bodies
    was that I wanted a &quot;body&quot; object to be a form of completely
    encapsulated program-persistent storage; that is, I wanted users to be able
    to write code like this...</p>
<p class="Pp"></p>
<pre>   ### Get body handle from this MIME message, and read its data:
   $body = $entity-&gt;bodyhandle;
   $IO = $body-&gt;open(&quot;r&quot;);
   while (defined($_ = $IO-&gt;getline)) {
       print STDOUT $_;
   }
   $IO-&gt;close;
</pre>
<p class="Pp">...without requiring that they know anything more about how the
    <span class="Li">$body</span> object is actually storing its data (disk
    file, scalar variable, array variable, or whatever).</p>
<p class="Pp">Storing the body of each MIME message in a persistently-open
    IO::Handle was a possibility, but it seemed like a bad idea, considering
    that a single multipart MIME message could easily suck up all the available
    file descriptors on some systems. This risk increases if the user
    application is processing more than one MIME entity at a time.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">MIME::Tools</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Eryq (<i>eryq@zeegee.com</i>), ZeeGee Software Inc
    (<i>http://www.zeegee.com</i>). David F. Skoll (dfs@roaringpenguin.com)
    http://www.roaringpenguin.com</p>
<p class="Pp">All rights reserved. This program is free software; you can
    redistribute it and/or modify it under the same terms as Perl itself.</p>
<p class="Pp">Thanks to Achim Bohnet for suggesting that MIME::Parser not be
    restricted to the use of FileHandles.</p>
<p class="Pp">#------------------------------ 1;</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-04-05</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

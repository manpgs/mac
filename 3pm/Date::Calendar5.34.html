<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Date::Calendar(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Date::Calendar(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Date::Calendar(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Date::Calendar - Calendar objects for different holiday
  schemes</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MOTTO"><a class="permalink" href="#MOTTO">MOTTO</a></h1>
<p class="Pp">There is more than one way to do it - this is just one of
  them!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PREFACE"><a class="permalink" href="#PREFACE">PREFACE</a></h1>
<p class="Pp">Basically, Date::Calendar is just a caching proxy class for
    Date::Calendar::Year objects, which are embedded in each Date::Calendar
    object.</p>
<p class="Pp">However, and in contrast to Date::Calendar::Year methods,
    Date::Calendar methods permit calculations spanning an arbitrary number of
    years, without loss of efficiency.</p>
<p class="Pp">So you should usually use Date::Calendar and not
    Date::Calendar::Year, since that way you don't have to worry about
    calculations crossing year boundaries.</p>
<p class="Pp">Note however that Date::Calendar and Date::Calendar::Year can only
    deal with years lying within the range [1583..2299].</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  use Date::Calendar::Profiles qw( $Profiles );
  use Date::Calendar;
  $calendar_US_AZ  = Date::Calendar-&gt;new( $Profiles-&gt;{'US-AZ'} [,LANG[,WEEKEND]] );
  $calendar_DE_SN  = Date::Calendar-&gt;new( $Profiles-&gt;{'DE-SN'} [,LANG[,WEEKEND]] );
  $year_2000_US_AZ = $calendar_US_AZ-&gt;year( 2000 );
  $year_2001_DE_SN = $calendar_DE_SN-&gt;year( 2001 );
  @years = $calendar-&gt;cache_keys(); # returns list of year numbers
  @years = $calendar-&gt;cache_vals(); # returns list of year objects
  $calendar-&gt;cache_clr();
  $calendar-&gt;cache_add(YEAR|DATE,...);
  $calendar-&gt;cache_del(YEAR|DATE,...);
  $index        = $calendar-&gt;date2index(YEAR,MONTH,DAY|DATE);
  @names        = $calendar-&gt;labels(YEAR,MONTH,DAY|DATE);
  @holidays     = $calendar-&gt;labels();
  $holidays     = $calendar-&gt;labels();
  @dates        = $calendar-&gt;search(PATTERN);
  $dates        = $calendar-&gt;search(PATTERN);
  $hashref      = $calendar-&gt;tags(YEAR,MONTH,DAY|DATE);
  $days         = $calendar-&gt;delta_workdays(YEAR1,MONTH1,DAY1|DATE1
                                           ,YEAR2,MONTH2,DAY2|DATE2
                                           ,FLAG1,FLAG2);
  ($date,$rest) = $calendar-&gt;add_delta_workdays(YEAR,MONTH,DAY|DATE
                                               ,DELTA);
  $date         = $calendar-&gt;add_delta_workdays(YEAR,MONTH,DAY|DATE
                                               ,DELTA);
  $flag         = $calendar-&gt;is_full(YEAR,MONTH,DAY|DATE);
  $flag         = $calendar-&gt;is_half(YEAR,MONTH,DAY|DATE);
  $flag         = $calendar-&gt;is_work(YEAR,MONTH,DAY|DATE);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="INTERFACE"><a class="permalink" href="#INTERFACE">INTERFACE</a></h1>
<p class="Pp">Note that whenever a year number, a date, a time or a combined
    date and time are expected as input parameters by one of the methods of this
    class, you can always pass a Date::Calc[::Object] date object or an array
    reference (of an array of appropriate length) instead!</p>
<p class="Pp">See <b>Date::Calc::Object</b>(3) for more details.</p>
<p class="Pp">So instead of calling a given method like this:</p>
<p class="Pp"></p>
<pre>  $object-&gt;method1( $year,$month,$day );
  $object-&gt;method2( $year1,$month1,$day1, $year2,$month2,$day2 );
  $object-&gt;method3( $year1, $year2, $year3 );
</pre>
<p class="Pp">You can also call it like so:</p>
<p class="Pp"></p>
<pre>  $object-&gt;method1( $date );
  $object-&gt;method1( [1964,1,3] );
  $object-&gt;method2( $year1,$month1,$day1, $date2 );
  $object-&gt;method2( $date1, $year2,$month2,$day2 );
  $object-&gt;method2( $date1, $date2 );
  $object-&gt;method2( $year1,$month1,$day1, [2001,3,17] );
  $object-&gt;method2( [1964,1,3], $year2,$month2,$day2 );
  $object-&gt;method2( [1964,1,3], [2001,3,17] );
  $object-&gt;method2( $date1, [2001,3,17] );
  $object-&gt;method2( [1964,1,3], $date2 );
  $object-&gt;method3( $year1, $date2, [2001,3,17] );
</pre>
<p class="Pp">And similarly if a time or a combined date and time are
  expected.</p>
<p class="Pp">If you substitute an expected year number by an anonymous array
    (this is the recommended way of writing date constants, for increased
    readability of your programs), it must contain three values, nevertheless
    (otherwise the use of an anonymous array would be pointless).</p>
<p class="Pp">Don't confuse year numbers and their substitutes (a date object or
    an array reference) with Date::Calendar::Year objects, which are a totally
    different thing!</p>
<p class="Pp">But incidentally <span class="Li">&quot;:-)&quot;</span>, you may
    also pass a Date::Calendar::Year object whenever a year number is expected.
    However, and perhaps against your expectations at times, especially in
    conjunction with the method &quot;<b>cache_add()</b>&quot;, only the year
    number from that object will be used, not the year object itself (the year
    object in question might be using the wrong profile!).</p>
<p class="Pp">Moreover, whenever a method of this class returns a date, it does
    so by returning a Date::Calc[::Object] date object.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;$calendar =
      Date::Calendar-&gt;new(PROFILE[,LANG[,WEEKEND]]);&quot;</span>
    <p class="Pp">The first argument must be the reference of a hash, which
        contains a holiday scheme or &quot;profile&quot; to be used in all
        calculations involving the new calendar object.</p>
    <p class="Pp">The second argument is optional, and must consist of the valid
        name or number of a language as provided by the <b>Date::Calc</b>(3)
        module if given.</p>
    <p class="Pp">After the second argument, a list of day numbers which will
        constitute the &quot;weekend&quot; can optionally be specified, where
        1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday, 6=Saturday and
        7=Sunday.</p>
    <p class="Pp">If no values are given, 6 and 7 (Saturday and Sunday) are
        automatically taken as default.</p>
    <p class="Pp">If values outside of the range <span class="Li">1..7</span>
        are given, they will be ignored.</p>
    <p class="Pp">This can be used to switch off this feature and to have no
        regularly recurring holidays at all when for instance a zero is
      given.</p>
    <p class="Pp">See <b>Date::Calendar::Profiles</b>(3) and
        <b>Date::Calendar::Year</b>(3) for more details about these arguments
        and about how to roll your own calendar profiles.</p>
    <p class="Pp">The method creates a new calendar object for a given profile,
        i.e., a given location and its scheme of holidays (or a scheme of your
        own).</p>
    <p class="Pp">This calendar object is a caching proxy object; it stores the
        reference of the given profile and contains a hash (the cache) of
        Date::Calendar::Year objects.</p>
  </li>
  <li><span class="Li">&quot;$year = $calendar-&gt;year(YEAR|DATE);&quot;</span>
    <p class="Pp">This method returns a Date::Calendar::Year object for the
        given year and the profile that was associated with the given calendar
        object.</p>
    <p class="Pp">If the cache in the given calendar object already contains an
        object for the requested year, the corresponding object reference is
        simply returned.</p>
    <p class="Pp">If not, a new Date::Calendar::Year object is created using the
        profile that has been associated with the given calendar object. The new
        Date::Calendar::Year object is then stored in the calendar object's
        cache and its object reference is returned.</p>
    <p class="Pp">A fatal &quot;given year out of range&quot; error will occur
        if the given year number lies outside the valid range of
      [1583..2299].</p>
  </li>
  <li><span class="Li">&quot;@years = $calendar-&gt;cache_keys();&quot;</span>
    <p class="Pp">This method returns the list of <b>YEAR NUMBERS</b> of the
        Date::Calendar::Year objects contained in the given calendar object's
        cache.</p>
  </li>
  <li><span class="Li">&quot;@years = $calendar-&gt;cache_vals();&quot;</span>
    <p class="Pp">This method returns the list of <b>OBJECT REFERENCES</b> of
        the Date::Calendar::Year objects contained in the given calendar
        object's cache.</p>
  </li>
  <li><span class="Li">&quot;$calendar-&gt;cache_clr();&quot;</span>
    <p class="Pp">This method clears the entire cache of the given calendar
        object (by destroying the cache hash and creating a new one).</p>
  </li>
  <li><span class="Li">&quot;$calendar-&gt;cache_add(YEAR|DATE,...);&quot;</span>
    <p class="Pp">Roughly, this method is a shortcut for</p>
    <p class="Pp"></p>
    <pre>  for $year (@list)
  {
      $calendar-&gt;year($year);
  }
    </pre>
  </li>
  <li><span class="Li">&quot;$calendar-&gt;cache_del(YEAR|DATE,...);&quot;</span>
    <p class="Pp">This method removes the Date::Calendar::Year objects whose
        year numbers are given from the cache of the given calendar object.</p>
    <p class="Pp">Year numbers for which the calendar object's cache doesn't
        contain an entry are simply ignored.</p>
  </li>
  <li><span class="Li">&quot;$index =
      $calendar-&gt;date2index(YEAR,MONTH,DAY|DATE);&quot;</span>
    <p class="Pp">This method converts a given date into the number of the day
        in that year (this is sometimes also referred to as the
        &quot;julian&quot; date), i.e., a number between 0 (for January 1st) and
        the number of days in the given year minus one, i.e., 364 or 365 (for
        December 31st).</p>
    <p class="Pp">You may need this in order to access the bit vectors returned
        by the Date::Calendar::Year methods &quot;<b>vec_full()</b>&quot;,
        &quot;<b>vec_half()</b>&quot; and &quot;<b>vec_work()</b>&quot;.</p>
    <p class="Pp">If the Date::Calendar::Year object for the given YEAR is not
        in the <span class="Li">$calendar</span>'s cache yet, it will be created
        and added.</p>
    <p class="Pp">An exception (&quot;invalid date&quot;) is thrown if the given
        arguments do not constitute a valid date, or (&quot;given year out of
        range [1583..2299]&quot;) if the given year lies outside of the
        permitted range.</p>
  </li>
  <li><span class="Li">&quot;@names =
      $calendar-&gt;labels(YEAR,MONTH,DAY|DATE);&quot;</span>
    <p class="Pp"><span class="Li">&quot;@holidays =
        $calendar-&gt;labels();&quot;</span></p>
    <p class="Pp"><span class="Li">&quot;$holidays =
        $calendar-&gt;labels();&quot;</span></p>
    <p class="Pp">If any arguments are given, they are supposed to represent a
        date. In that case, a list of all labels (= names of holidays)
        associated with that date are returned. The first item returned is
        always the name of the day of week for that date. The corresponding year
        object for the given date's year is added to the calendar's cache first
        if necessary.</p>
    <p class="Pp">If no arguments are given, the list of all available labels in
        all years that have previously been accessed in the given calendar
        (i.e., the years which are already in the given calendar's cache) is
        constructed. Note that this means that the returned list will be empty
        if there are no year objects in the given calendar's cache yet (!). The
        returned list does <b>NOT</b> include any names of the days of week
        (which would be pointless in this case).</p>
    <p class="Pp">Multiple labels are reported only once.</p>
    <p class="Pp">Usually all years have the same set of labels, so it may seem
        superfluous to scan all the years in the cache instead of just one. But
        there may be exceptions, because it is possible to define calendar
        profiles which do not contain all possible holidays in every year. See
        <b>Date::Calendar::Profiles</b>(3) and <b>Date::Calendar::Year</b>(3)
        for more details.</p>
    <p class="Pp">In list context, the resulting list itself is returned. In
        scalar context, the number of items in the resulting list is
      returned.</p>
  </li>
  <li><span class="Li">&quot;@dates =
      $calendar-&gt;search(PATTERN);&quot;</span>
    <p class="Pp"><span class="Li">&quot;$dates =
        $calendar-&gt;search(PATTERN);&quot;</span></p>
    <p class="Pp">This method searches through all the labels in all years that
        have previously been accessed in the given calendar (i.e., the years
        which are already in the given calendar's cache) and returns a list of
        date objects with all dates whose labels match the given pattern.</p>
    <p class="Pp">(Use the methods &quot;<b>cache_clr()</b>&quot;,
        &quot;<b>cache_add()</b>&quot; and &quot;<b>cache_del()</b>&quot; in
        order to put the year numbers you want into the calendar object's cache,
        or to make sure it only contains the year numbers you want to
      search.)</p>
    <p class="Pp">Note that this is a simple, case-insensitive substring search,
        <b>NOT</b> a full-fledged regular expression search!</p>
    <p class="Pp">The result is guaranteed to be sorted chronologically.</p>
    <p class="Pp">In scalar context, only the number of items in the resulting
        list is returned, instead of the resulting list itself (as in list
        context).</p>
  </li>
  <li><span class="Li">&quot;$hashref =
      $calendar-&gt;tags(YEAR,MONTH,DAY|DATE);&quot;</span>
    <p class="Pp">This method returns a hash reference for the given calendar
        and date. The hash it refers to is a copy of the calendar profile's
        internal hash which contains the names for the given date as keys and 0,
        1, 2, or 3 as their corresponding values meaning the following:</p>
    <p class="Pp"></p>
    <pre>    0    =&gt;    commemorative day
    1    =&gt;    &quot;half&quot; holiday
    2    =&gt;    &quot;full&quot; holiday
    3    =&gt;    both a &quot;half&quot; and a &quot;full&quot; holiday
    </pre>
    <p class="Pp">The value &quot;3&quot; should only occur if a date has been
        redefined by the underlying profile using the same key (i.e., the same
        name) but with a different type of holiday.</p>
  </li>
  <li><span class="Li">&quot;$days =
      $calendar-&gt;delta_workdays(YEAR1,MONTH1,DAY1, YEAR2,MONTH2,DAY2,
      FLAG1,FLAG2);&quot;</span>
    <p class="Pp"><span class="Li">&quot;$days =
        $calendar-&gt;delta_workdays(DATE1,DATE2,FLAG1,FLAG2);&quot;</span></p>
    <p class="Pp">This method calculates the number of work days (i.e., the
        number of days, but excluding all holidays) between two dates.</p>
    <p class="Pp">In other words, this method is equivalent to the
        &quot;<b>Delta_Days()</b>&quot; function of the Date::Calc module,
        except that it disregards holidays in its counting.</p>
    <p class="Pp">The two flags indicate whether the start and end dates should
        be included in the counting (that is, of course, only in case they
        aren't holidays), or not.</p>
    <p class="Pp">It is common, for example, that you want to know how many work
        days are left between the current date and a given deadline.</p>
    <p class="Pp">Typically, you will want to count the current date but not the
        deadline's date. So you would specify &quot;true&quot; (&quot;1&quot;)
        for FLAG1 and &quot;false&quot; (&quot;0&quot;) for FLAG2 in order to
        achieve that.</p>
    <p class="Pp">In other words, a value of &quot;true&quot; means
        &quot;including this date&quot;, a value of &quot;false&quot; means
        &quot;excluding this date&quot;.</p>
    <p class="Pp">As with the &quot;<b>Delta_Days()</b>&quot; function from the
        Date::Calc module, the dates have to be given in chronological order to
        yield a positive result. If the dates are reversed, the result will be
        negative.</p>
    <p class="Pp">The parameter FLAG1 is associated with the first given date,
        the parameter FLAG2 with the second given date (regardless of whether
        the dates are in chronological order or not).</p>
    <p class="Pp">An exception (&quot;invalid date&quot;) is raised if either of
        the two date arguments does not constitute a valid date.</p>
  </li>
  <li><span class="Li">&quot;($date,$rest) =
      $calendar-&gt;add_delta_workdays(YEAR,MONTH,DAY, DELTA);&quot;</span>
    <p class="Pp"><span class="Li">&quot;($date,$rest) =
        $calendar-&gt;add_delta_workdays(DATE,DELTA);&quot;</span></p>
    <p class="Pp"><span class="Li">&quot;$date =
        $calendar-&gt;add_delta_workdays(YEAR,MONTH,DAY,
      DELTA);&quot;</span></p>
    <p class="Pp"><span class="Li">&quot;$date =
        $calendar-&gt;add_delta_workdays(DATE,DELTA);&quot;</span></p>
    <p class="Pp">This method is the equivalent of the
        &quot;<b>Add_Delta_Days()</b>&quot; function from the Date::Calc module,
        except that it adds work days and skips holidays.</p>
    <p class="Pp">In other words, you can add or subtract a number of work days
        &quot;DELTA&quot; to/from a given date and get a new date as the result
        (as a Date::Calc object).</p>
    <p class="Pp">You add days (i.e., you go forward in time) with a positive
        offset &quot;DELTA&quot;, and you subtract days (i.e., you go backwards
        in time) with a negative offset.</p>
    <p class="Pp">Note that an exception (&quot;invalid date&quot;) is raised if
        the given date argument does not constitute a valid date.</p>
    <p class="Pp">In scalar context, the method just returns the resulting date
        object, whereas in list context the method not only returns the new
        date, but also a &quot;rest&quot;. This rest is useful for cases in
        which your profile contains &quot;half&quot; holidays, or when you add
        or subtract fractions of a day.</p>
    <p class="Pp">Sometimes it is not possible to accommodate the requested
        number of work days, and a rest remains.</p>
    <p class="Pp">This rest can currently only assume the value &quot;0.0&quot;
        (zero), &quot;-0.5&quot; (minus one half) or &quot;0.5&quot; (one half),
        provided you use only integral or multiples of 0.5 as offsets. A rest of
        zero indicates that the calculation yielded an exact result. If the rest
        is 0.5 or -0.5, this is to be interpreted as &quot;the resulting date at
        12:00 o'clock&quot;, instead of as &quot;the resulting date at 0:00
        o'clock&quot;.</p>
    <p class="Pp">The rest is always positive (or zero) if the offset
        &quot;DELTA&quot; is positive (or zero), and always negative (or zero)
        if the offset is negative (or zero).</p>
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>  #!perl
  use Date::Calendar;
  use Date::Calendar::Profiles qw( $Profiles );
  $year = shift;
  $cal = Date::Calendar-&gt;new( $Profiles-&gt;{'sdm-MUC'} );
  ($date,$rest) = $cal-&gt;add_delta_workdays($year,1,3, -3);
  $date-&gt;date_format(1);
  print &quot;\$date = $date, \$rest = $rest.\n&quot;;
  __END__
    </pre>
    <p class="Pp">This program calculates &quot;January 3rd of the given year
        minus 3 work days&quot;:</p>
    <p class="Pp"></p>
    <pre>  &gt; perl test.pl 2001
  $date = 28-Dec-2000, $rest = 0.
  &gt; perl test.pl 2002
  $date = 28-Dec-2001, $rest = -0.5.
    </pre>
    <p class="Pp">Note that December 31st is a &quot;half&quot; holiday in 2001
        for the calendar profile used in this example.</p>
    <p class="Pp">You can easily verify the results above with the help of the
        &quot;calendar.cgi&quot; CGI script or the &quot;linearcal.pl&quot;
        script from the &quot;examples&quot; subdirectory in the Date::Calc
        distribution.</p>
    <p class="Pp"><b>BEWARE</b> that this method may currently return unexpected
        (i.e., contradicting the above documentation) or plain wrong results
        when going back in time (this is a bug!).</p>
    <p class="Pp">However, it works correctly and as documented above when going
        forward in time.</p>
  </li>
  <li><span class="Li">&quot;$flag =
      $calendar-&gt;is_full(YEAR,MONTH,DAY|DATE);&quot;</span>
    <p class="Pp">This method returns &quot;true&quot; (&quot;1&quot;) if the
        bit corresponding to the given date is set in the bit vector
        representing &quot;full&quot; holidays, and &quot;false&quot;
        (&quot;0&quot;) otherwise.</p>
    <p class="Pp">I.e., the method returns &quot;true&quot; if the given date is
        a (full) holiday (according to the calendar profile associated with the
        given calendar object).</p>
    <p class="Pp">The corresponding Date::Calendar::Year object is created first
        and stored in the calendar object's cache if necessary (if it's not
        already there).</p>
    <p class="Pp">Note that you can get a reference to this bit vector (in order
        to use this bit vector in bit vector operations) as follows:</p>
    <p class="Pp"></p>
    <pre>  $vec_full = $calendar-&gt;year($year)-&gt;vec_full();
    </pre>
    <p class="Pp">The number of bits in this bit vector is the same as the
        number of days in the given year
        &quot;<span class="Li">$year</span>&quot;, which you can retrieve
        through either &quot;<span class="Li">&quot;$days =
        $vec_full-&gt;Size();&quot;</span>&quot; or
        &quot;<span class="Li">&quot;$days =
        $year-&gt;val_days();&quot;</span>&quot;.</p>
    <p class="Pp">See <b>Date::Calendar::Year</b>(3) and <b>Bit::Vector</b>(3)
        for more details.</p>
  </li>
  <li><span class="Li">&quot;$flag =
      $calendar-&gt;is_half(YEAR,MONTH,DAY|DATE);&quot;</span>
    <p class="Pp">This method returns &quot;true&quot; (&quot;1&quot;) if the
        bit corresponding to the given date is set in the bit vector
        representing &quot;half&quot; holidays, and &quot;false&quot;
        (&quot;0&quot;) otherwise.</p>
    <p class="Pp">I.e., the method returns &quot;true&quot; if the given date is
        a half holiday (according to the calendar profile associated with the
        given calendar object).</p>
    <p class="Pp">Note that if a date is a &quot;full&quot; holiday, the
        &quot;half&quot; bit is never set, even if you try to do so in your
        calendar profile, on purpose or by accident.</p>
    <p class="Pp">The corresponding Date::Calendar::Year object is created first
        and stored in the calendar object's cache if necessary (if it's not
        already there).</p>
    <p class="Pp">Note that you can get a reference to this bit vector (in order
        to use this bit vector in bit vector operations) as follows:</p>
    <p class="Pp"></p>
    <pre>  $vec_half = $calendar-&gt;year($year)-&gt;vec_half();
    </pre>
    <p class="Pp">The number of bits in this bit vector is the same as the
        number of days in the given year
        &quot;<span class="Li">$year</span>&quot;, which you can retrieve
        through either &quot;<span class="Li">&quot;$days =
        $vec_half-&gt;Size();&quot;</span>&quot; or
        &quot;<span class="Li">&quot;$days =
        $year-&gt;val_days();&quot;</span>&quot;.</p>
    <p class="Pp">See <b>Date::Calendar::Year</b>(3) and <b>Bit::Vector</b>(3)
        for more details.</p>
  </li>
  <li><span class="Li">&quot;$flag =
      $calendar-&gt;is_work(YEAR,MONTH,DAY|DATE);&quot;</span>
    <p class="Pp">This method returns &quot;true&quot; (&quot;1&quot;) if the
        bit corresponding to the given date is set in the bit vector used to
        perform all sorts of calculations, and &quot;false&quot; (&quot;0&quot;)
        otherwise.</p>
    <p class="Pp">The corresponding Date::Calendar::Year object is created first
        and stored in the calendar object's cache if necessary (if it's not
        already there).</p>
    <p class="Pp"><b>BEWARE</b> that the &quot;work&quot; in this method's name
        does <b>NOT</b> come from &quot;work days&quot;!</p>
    <p class="Pp">It comes from the fact that the corresponding bit vector can
        be used for any &quot;work&quot; that you need to do. In other words,
        it's a &quot;work space&quot;.</p>
    <p class="Pp">Therefore, this bit vector might contain about everything you
        could imagine - including a bit pattern which marks all &quot;work
        days&quot; with set bits, if it so happens!</p>
    <p class="Pp">But you better don't rely on it, unless you put the bit
        pattern there yourself in the first place.</p>
    <p class="Pp">Note that you can get a reference to this bit vector (in order
        to fill it with any bit pattern you like) as follows:</p>
    <p class="Pp"></p>
    <pre>  $vec_work = $calendar-&gt;year($year)-&gt;vec_work();
    </pre>
    <p class="Pp">The number of bits in this bit vector is the same as the
        number of days in the given year
        &quot;<span class="Li">$year</span>&quot;, which you can retrieve
        through either &quot;<span class="Li">&quot;$days =
        $vec_work-&gt;Size();&quot;</span>&quot; or
        &quot;<span class="Li">&quot;$days =
        $year-&gt;val_days();&quot;</span>&quot;.</p>
    <p class="Pp">See <b>Date::Calendar::Year</b>(3) and <b>Bit::Vector</b>(3)
        for more details.</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>Date::Calendar::Year</b>(3),
    <b>Date::Calendar::Profiles</b>(3), <b>Date::Calc::Object</b>(3),
    <b>Date::Calc</b>(3), <b>Date::Calc::Util</b>(3), <b>Bit::Vector</b>(3).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LIMITATIONS"><a class="permalink" href="#LIMITATIONS">LIMITATIONS</a></h1>
<p class="Pp">The calendar profiles included in
    <b>Date::Calendar::Profiles</b>(3) usually do not take historical
    irregularities into account (even though some do in order to show how this
    can be done), they only provide means for calculating <b>regularly</b>
    recurring events (<b>the profiles should therefore not be relied upon</b>
    <b>for historical faithfulness</b>).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="KNOWN_BUGS"><a class="permalink" href="#KNOWN_BUGS">KNOWN
  BUGS</a></h1>
<p class="Pp">The method &quot;<b>add_delta_workdays()</b>&quot; is known to
    produce results which are sometimes off by one working day when a negative
    offset is used. As a workaround, try to add one working day first and then
    subtract one working day more than initially intended. See also the file
    &quot;examples/bug.pl&quot; for how to do this.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">This man page documents &quot;Date::Calendar&quot; version
  6.4.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<pre>  Steffen Beyer
  mailto:STBEY@cpan.org
  http://www.engelschall.com/u/sb/download/
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 2000 - 2015 by Steffen Beyer. All rights
  reserved.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">This package is free software; you can use, modify and
    redistribute it under the same terms as Perl itself, i.e., at your option,
    under the terms either of the &quot;Artistic License&quot; or the &quot;GNU
    General Public License&quot;.</p>
<p class="Pp">The C library at the core of the module &quot;Date::Calc::XS&quot;
    can, at your discretion, also be used, modified and redistributed under the
    terms of the &quot;GNU Library General Public License&quot;.</p>
<p class="Pp">Please refer to the files &quot;Artistic.txt&quot;,
    &quot;GNU_GPL.txt&quot; and &quot;GNU_LGPL.txt&quot; in the
    &quot;license&quot; subdirectory of this distribution for any details!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DISCLAIMER"><a class="permalink" href="#DISCLAIMER">DISCLAIMER</a></h1>
<p class="Pp">This package is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</p>
<p class="Pp">See the &quot;GNU General Public License&quot; for more
  details.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2015-03-07</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

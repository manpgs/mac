<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Algorithm::Diff(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Algorithm::Diff(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Algorithm::Diff(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Algorithm::Diff - Compute `intelligent' differences between two
    files / lists</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
    require Algorithm::Diff;

    # This example produces traditional 'diff' output:

    my $diff = Algorithm::Diff-&gt;new( \@seq1, \@seq2 );

    $diff-&gt;Base( 1 );   # Return line numbers, not indices
    while(  $diff-&gt;Next()  ) {
        next   if  $diff-&gt;Same();
        my $sep = '';
        if(  ! $diff-&gt;Items(2)  ) {
            printf &quot;%d,%dd%d\n&quot;,
                $diff-&gt;Get(qw( Min1 Max1 Max2 ));
        } elsif(  ! $diff-&gt;Items(1)  ) {
            printf &quot;%da%d,%d\n&quot;,
                $diff-&gt;Get(qw( Max1 Min2 Max2 ));
        } else {
            $sep = &quot;---\n&quot;;
            printf &quot;%d,%dc%d,%d\n&quot;,
                $diff-&gt;Get(qw( Min1 Max1 Min2 Max2 ));
        }
        print &quot;&lt; $_&quot;   for  $diff-&gt;Items(1);
        print $sep;
        print &quot;&gt; $_&quot;   for  $diff-&gt;Items(2);
    }


    # Alternate interfaces:

    use Algorithm::Diff qw(
        LCS LCS_length LCSidx
        diff sdiff compact_diff
        traverse_sequences traverse_balanced );

    @lcs    = LCS( \@seq1, \@seq2 );
    $lcsref = LCS( \@seq1, \@seq2 );
    $count  = LCS_length( \@seq1, \@seq2 );

    ( $seq1idxref, $seq2idxref ) = LCSidx( \@seq1, \@seq2 );


    # Complicated interfaces:

    @diffs  = diff( \@seq1, \@seq2 );

    @sdiffs = sdiff( \@seq1, \@seq2 );

    @cdiffs = compact_diff( \@seq1, \@seq2 );

    traverse_sequences(
        \@seq1,
        \@seq2,
        {   MATCH     =&gt; \&amp;callback1,
            DISCARD_A =&gt; \&amp;callback2,
            DISCARD_B =&gt; \&amp;callback3,
        },
        \&amp;key_generator,
        @extra_args,
    );

    traverse_balanced(
        \@seq1,
        \@seq2,
        {   MATCH     =&gt; \&amp;callback1,
            DISCARD_A =&gt; \&amp;callback2,
            DISCARD_B =&gt; \&amp;callback3,
            CHANGE    =&gt; \&amp;callback4,
        },
        \&amp;key_generator,
        @extra_args,
    );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="INTRODUCTION"><a class="permalink" href="#INTRODUCTION">INTRODUCTION</a></h1>
<p class="Pp">(by Mark-Jason Dominus)</p>
<p class="Pp">I once read an article written by the authors of
    <span class="Li">&quot;diff&quot;</span>; they said that they worked very
    hard on the algorithm until they found the right one.</p>
<p class="Pp">I think what they ended up using (and I hope someone will correct
    me, because I am not very confident about this) was the `longest common
    subsequence' method. In the LCS problem, you have two sequences of
  items:</p>
<p class="Pp"></p>
<pre>
    a b c d f g h j q z

    a b c d e f g i j k r x y z
</pre>
<p class="Pp">and you want to find the longest sequence of items that is present
    in both original sequences in the same order. That is, you want to find a
    new sequence <i>S</i> which can be obtained from the first sequence by
    deleting some items, and from the secend sequence by deleting other items.
    You also want <i>S</i> to be as long as possible. In this case <i>S</i>
  is</p>
<p class="Pp"></p>
<pre>
    a b c d f g j z
</pre>
<p class="Pp">From there it's only a small step to get diff-like output:</p>
<p class="Pp"></p>
<pre>
    e   h i   k   q r x y
    +   - +   +   - + + +
</pre>
<p class="Pp">This module solves the LCS problem. It also includes a canned
    function to generate <span class="Li">&quot;diff&quot;</span>-like
  output.</p>
<p class="Pp">It might seem from the example above that the LCS of two sequences
    is always pretty obvious, but that's not always the case, especially when
    the two sequences have many repeated elements. For example, consider</p>
<p class="Pp"></p>
<pre>
    a x b y c z p d q
    a b c a x b y c z
</pre>
<p class="Pp">A naive approach might start by matching up the
    <span class="Li">&quot;a&quot;</span> and
    <span class="Li">&quot;b&quot;</span> that appear at the beginning of each
    sequence, like this:</p>
<p class="Pp"></p>
<pre>
    a x b y c         z p d q
    a   b   c a b y c z
</pre>
<p class="Pp">This finds the common subsequence <span class="Li">&quot;a b c
    z&quot;</span>. But actually, the LCS is <span class="Li">&quot;a x b y c
    z&quot;</span>:</p>
<p class="Pp"></p>
<pre>
          a x b y c z p d q
    a b c a x b y c z
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre>
    a       x b y c z p d q
    a b c a x b y c z
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="USAGE"><a class="permalink" href="#USAGE">USAGE</a></h1>
<p class="Pp">(See also the README file and several example scripts include with
    this module.)</p>
<p class="Pp">This module now provides an object-oriented interface that uses
    less memory and is easier to use than most of the previous procedural
    interfaces. It also still provides several exportable functions. We'll deal
    with these in ascending order of difficulty:
    <span class="Li">&quot;LCS&quot;</span>,
    <span class="Li">&quot;LCS_length&quot;</span>,
    <span class="Li">&quot;LCSidx&quot;</span>, OO interface,
    <span class="Li">&quot;prepare&quot;</span>,
    <span class="Li">&quot;diff&quot;</span>,
    <span class="Li">&quot;sdiff&quot;</span>,
    <span class="Li">&quot;traverse_sequences&quot;</span>, and
    <span class="Li">&quot;traverse_balanced&quot;</span>.</p>
<section class="Ss">
<h2 class="Ss" id="_LCS_"><a class="permalink" href="#_LCS_">&quot;LCS&quot;</a></h2>
<p class="Pp">Given references to two lists of items, LCS returns an array
    containing their longest common subsequence. In scalar context, it returns a
    reference to such a list.</p>
<p class="Pp"></p>
<pre>
    @lcs    = LCS( \@seq1, \@seq2 );
    $lcsref = LCS( \@seq1, \@seq2 );
</pre>
<p class="Pp"><span class="Li">&quot;LCS&quot;</span> may be passed an optional
    third parameter; this is a CODE reference to a key generation function. See
    &quot;KEY GENERATION FUNCTIONS&quot;.</p>
<p class="Pp"></p>
<pre>
    @lcs    = LCS( \@seq1, \@seq2, \&amp;keyGen, @args );
    $lcsref = LCS( \@seq1, \@seq2, \&amp;keyGen, @args );
</pre>
<p class="Pp">Additional parameters, if any, will be passed to the key
    generation routine.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_LCS_length_"><a class="permalink" href="#_LCS_length_">&quot;LCS_length&quot;</a></h2>
<p class="Pp">This is just like <span class="Li">&quot;LCS&quot;</span> except
    it only returns the length of the longest common subsequence. This provides
    a performance gain of about 9% compared to
    <span class="Li">&quot;LCS&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_LCSidx_"><a class="permalink" href="#_LCSidx_">&quot;LCSidx&quot;</a></h2>
<p class="Pp">Like <span class="Li">&quot;LCS&quot;</span> except it returns
    references to two arrays. The first array contains the indices into
    <span class="Li">@seq1</span> where the LCS items are located. The second
    array contains the indices into <span class="Li">@seq2</span> where the LCS
    items are located.</p>
<p class="Pp">Therefore, the following three lists will contain the same
  values:</p>
<p class="Pp"></p>
<pre>
    my( $idx1, $idx2 ) = LCSidx( \@seq1, \@seq2 );
    my @list1 = @seq1[ @$idx1 ];
    my @list2 = @seq2[ @$idx2 ];
    my @list3 = LCS( \@seq1, \@seq2 );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_new_"><a class="permalink" href="#_new_">&quot;new&quot;</a></h2>
<pre>
    $diff = Algorithm::Diffs-&gt;new( \@seq1, \@seq2 );
    $diff = Algorithm::Diffs-&gt;new( \@seq1, \@seq2, \%opts );
</pre>
<p class="Pp"><span class="Li">&quot;new&quot;</span> computes the smallest set
    of additions and deletions necessary to turn the first sequence into the
    second and compactly records them in the object.</p>
<p class="Pp">You use the object to iterate over <i>hunks</i>, where each hunk
    represents a contiguous section of items which should be added, deleted,
    replaced, or left unchanged.</p>
<p class="Pp"></p>
<div class="Bd-indent">The following summary of all of the methods looks a lot
  like Perl code but some of the symbols have different meanings:
<p class="Pp"></p>
<pre>
    [ ]     Encloses optional arguments
    :       Is followed by the default value for an optional argument
    |       Separates alternate return results
</pre>
<p class="Pp">Method summary:</p>
<p class="Pp"></p>
<pre>
    $obj        = Algorithm::Diff-&gt;new( \@seq1, \@seq2, [ \%opts ] );
    $pos        = $obj-&gt;Next(  [ $count : 1 ] );
    $revPos     = $obj-&gt;Prev(  [ $count : 1 ] );
    $obj        = $obj-&gt;Reset( [ $pos : 0 ] );
    $copy       = $obj-&gt;Copy(  [ $pos, [ $newBase ] ] );
    $oldBase    = $obj-&gt;Base(  [ $newBase ] );
</pre>
<p class="Pp">Note that all of the following methods
    <span class="Li">&quot;die&quot;</span> if used on an object that is
    &quot;reset&quot; (not currently pointing at any hunk).</p>
<p class="Pp"></p>
<pre>
    $bits       = $obj-&gt;Diff(  );
    @items|$cnt = $obj-&gt;Same(  );
    @items|$cnt = $obj-&gt;Items( $seqNum );
    @idxs |$cnt = $obj-&gt;Range( $seqNum, [ $base ] );
    $minIdx     = $obj-&gt;Min(   $seqNum, [ $base ] );
    $maxIdx     = $obj-&gt;Max(   $seqNum, [ $base ] );
    @values     = $obj-&gt;Get(   @names );
</pre>
<p class="Pp">Passing in <span class="Li">&quot;undef&quot;</span> for an
    optional argument is always treated the same as if no argument were passed
    in.</p>
<p class="Pp"><span class="Li">&quot;Next&quot;</span></p>
<p class="Pp"></p>
<pre>
    $pos = $diff-&gt;Next();    # Move forward 1 hunk
    $pos = $diff-&gt;Next( 2 ); # Move forward 2 hunks
    $pos = $diff-&gt;Next(-5);  # Move backward 5 hunks
</pre>
<p class="Pp"><span class="Li">&quot;Next&quot;</span> moves the object to point
    at the next hunk. The object starts out &quot;reset&quot;, which means it
    isn't pointing at any hunk. If the object is reset, then
    <span class="Li">&quot;Next()&quot;</span> moves to the first hunk.</p>
<p class="Pp"><span class="Li">&quot;Next&quot;</span> returns a true value iff
    the move didn't go past the last hunk. So <span class="Li">Next(0)</span>
    will return true iff the object is not reset.</p>
<p class="Pp">Actually, <span class="Li">&quot;Next&quot;</span> returns the
    object's new position, which is a number between 1 and the number of hunks
    (inclusive), or returns a false value.</p>
<p class="Pp"><span class="Li">&quot;Prev&quot;</span></p>
<p class="Pp"><span class="Li">&quot;Prev($N)&quot;</span> is almost identical
    to <span class="Li">&quot;Next(-$N)&quot;</span>; it moves to the
    <span class="Li">$Nth</span> previous hunk. On a 'reset' object,
    <span class="Li">&quot;Prev()&quot;</span> [and
    <span class="Li">&quot;Next(-1)&quot;</span>] move to the last hunk.</p>
<p class="Pp">The position returned by <span class="Li">&quot;Prev&quot;</span>
    is relative to the <i>end</i> of the hunks; -1 for the last hunk, -2 for the
    second-to-last, etc.</p>
<p class="Pp"><span class="Li">&quot;Reset&quot;</span></p>
<p class="Pp"></p>
<pre>
    $diff-&gt;Reset();     # Reset the object's position
    $diff-&gt;Reset($pos); # Move to the specified hunk
    $diff-&gt;Reset(1);    # Move to the first hunk
    $diff-&gt;Reset(-1);   # Move to the last hunk
</pre>
<p class="Pp"><span class="Li">&quot;Reset&quot;</span> returns the object, so,
    for example, you could use
    <span class="Li">&quot;$diff-&gt;Reset()-&gt;Next(-1)&quot;</span> to get
    the number of hunks.</p>
<p class="Pp"><span class="Li">&quot;Copy&quot;</span></p>
<p class="Pp"></p>
<pre>
    $copy = $diff-&gt;Copy( $newPos, $newBase );
</pre>
<p class="Pp"><span class="Li">&quot;Copy&quot;</span> returns a copy of the
    object. The copy and the orignal object share most of their data, so making
    copies takes very little memory. The copy maintains its own position
    (separate from the original), which is the main purpose of copies. It also
    maintains its own base.</p>
<p class="Pp">By default, the copy's position starts out the same as the
    original object's position. But <span class="Li">&quot;Copy&quot;</span>
    takes an optional first argument to set the new position, so the following
    three snippets are equivalent:</p>
<p class="Pp"></p>
<pre>
    $copy = $diff-&gt;Copy($pos);

    $copy = $diff-&gt;Copy();
    $copy-&gt;Reset($pos);

    $copy = $diff-&gt;Copy()-&gt;Reset($pos);
</pre>
<p class="Pp"><span class="Li">&quot;Copy&quot;</span> takes an optional second
    argument to set the base for the copy. If you wish to change the base of the
    copy but leave the position the same as in the original, here are two
    equivalent ways:</p>
<p class="Pp"></p>
<pre>
    $copy = $diff-&gt;Copy();
    $copy-&gt;Base( 0 );

    $copy = $diff-&gt;Copy(undef,0);
</pre>
<p class="Pp">Here are two equivalent way to get a &quot;reset&quot; copy:</p>
<p class="Pp"></p>
<pre>
    $copy = $diff-&gt;Copy(0);

    $copy = $diff-&gt;Copy()-&gt;Reset();
</pre>
<p class="Pp"><span class="Li">&quot;Diff&quot;</span></p>
<p class="Pp"></p>
<pre>
    $bits = $obj-&gt;Diff();
</pre>
<p class="Pp"><span class="Li">&quot;Diff&quot;</span> returns a true value iff
    the current hunk contains items that are different between the two
    sequences. It actually returns one of the follow 4 values:</p>
<dl class="Bl-tag">
  <dt>3</dt>
  <dd><span class="Li">&quot;3==(1|2)&quot;</span>. This hunk contains items
      from <span class="Li">@seq1</span> and the items from
      <span class="Li">@seq2</span> that should replace them. Both sequence 1
      and 2 contain changed items so both the 1 and 2 bits are set.</dd>
  <dt>2</dt>
  <dd>This hunk only contains items from <span class="Li">@seq2</span> that
      should be inserted (not items from <span class="Li">@seq1</span>). Only
      sequence 2 contains changed items so only the 2 bit is set.</dd>
  <dt>1</dt>
  <dd>This hunk only contains items from <span class="Li">@seq1</span> that
      should be deleted (not items from <span class="Li">@seq2</span>). Only
      sequence 1 contains changed items so only the 1 bit is set.</dd>
  <dt>0</dt>
  <dd>This means that the items in this hunk are the same in both sequences.
      Neither sequence 1 nor 2 contain changed items so neither the 1 nor the 2
      bits are set.</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp"><span class="Li">&quot;Same&quot;</span></p>
<p class="Pp"><span class="Li">&quot;Same&quot;</span> returns a true value iff
    the current hunk contains items that are the same in both sequences. It
    actually returns the list of items if they are the same or an emty list if
    they aren't. In a scalar context, it returns the size of the list.</p>
<p class="Pp"><span class="Li">&quot;Items&quot;</span></p>
<p class="Pp"></p>
<pre>
    $count = $diff-&gt;Items(2);
    @items = $diff-&gt;Items($seqNum);
</pre>
<p class="Pp"><span class="Li">&quot;Items&quot;</span> returns the (number of)
    items from the specified sequence that are part of the current hunk.</p>
<p class="Pp">If the current hunk contains only insertions, then
    <span class="Li">&quot;$diff-&gt;Items(1)&quot;</span> will return an empty
    list (0 in a scalar conext). If the current hunk contains only deletions,
    then <span class="Li">&quot;$diff-&gt;Items(2)&quot;</span> will return an
    empty list (0 in a scalar conext).</p>
<p class="Pp">If the hunk contains replacements, then both
    <span class="Li">&quot;$diff-&gt;Items(1)&quot;</span> and
    <span class="Li">&quot;$diff-&gt;Items(2)&quot;</span> will return
    different, non-empty lists.</p>
<p class="Pp">Otherwise, the hunk contains identical items and all of the
    following will return the same lists:</p>
<p class="Pp"></p>
<pre>
    @items = $diff-&gt;Items(1);
    @items = $diff-&gt;Items(2);
    @items = $diff-&gt;Same();
</pre>
<p class="Pp"><span class="Li">&quot;Range&quot;</span></p>
<p class="Pp"></p>
<pre>
    $count = $diff-&gt;Range( $seqNum );
    @indices = $diff-&gt;Range( $seqNum );
    @indices = $diff-&gt;Range( $seqNum, $base );
</pre>
<p class="Pp"><span class="Li">&quot;Range&quot;</span> is like
    <span class="Li">&quot;Items&quot;</span> except that it returns a list of
    <i>indices</i> to the items rather than the items themselves. By default,
    the index of the first item (in each sequence) is 0 but this can be changed
    by calling the <span class="Li">&quot;Base&quot;</span> method. So, by
    default, the following two snippets return the same lists:</p>
<p class="Pp"></p>
<pre>
    @list = $diff-&gt;Items(2);
    @list = @seq2[ $diff-&gt;Range(2) ];
</pre>
<p class="Pp">You can also specify the base to use as the second argument. So
    the following two snippets <i>always</i> return the same lists:</p>
<p class="Pp"></p>
<pre>
    @list = $diff-&gt;Items(1);
    @list = @seq1[ $diff-&gt;Range(1,0) ];
</pre>
<p class="Pp"><span class="Li">&quot;Base&quot;</span></p>
<p class="Pp"></p>
<pre>
    $curBase = $diff-&gt;Base();
    $oldBase = $diff-&gt;Base($newBase);
</pre>
<p class="Pp"><span class="Li">&quot;Base&quot;</span> sets and/or returns the
    current base (usually 0 or 1) that is used when you request range
    information. The base defaults to 0 so that range information is returned as
    array indices. You can set the base to 1 if you want to report traditional
    line numbers instead.</p>
<p class="Pp"><span class="Li">&quot;Min&quot;</span></p>
<p class="Pp"></p>
<pre>
    $min1 = $diff-&gt;Min(1);
    $min = $diff-&gt;Min( $seqNum, $base );
</pre>
<p class="Pp"><span class="Li">&quot;Min&quot;</span> returns the first value
    that <span class="Li">&quot;Range&quot;</span> would return (given the same
    arguments) or returns <span class="Li">&quot;undef&quot;</span> if
    <span class="Li">&quot;Range&quot;</span> would return an empty list.</p>
<p class="Pp"><span class="Li">&quot;Max&quot;</span></p>
<p class="Pp"><span class="Li">&quot;Max&quot;</span> returns the last value
    that <span class="Li">&quot;Range&quot;</span> would return or
    <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp"><span class="Li">&quot;Get&quot;</span></p>
<p class="Pp"></p>
<pre>
    ( $n, $x, $r ) = $diff-&gt;Get(qw( min1 max1 range1 ));
    @values = $diff-&gt;Get(qw( 0min2 1max2 range2 same base ));
</pre>
<p class="Pp"><span class="Li">&quot;Get&quot;</span> returns one or more scalar
    values. You pass in a list of the names of the values you want returned.
    Each name must match one of the following regexes:</p>
<p class="Pp"></p>
<pre>
    /^(-?\d+)?(min|max)[12]$/i
    /^(range[12]|same|diff|base)$/i
</pre>
<p class="Pp">The 1 or 2 after a name says which sequence you want the
    information for (and where allowed, it is required). The optional number
    before &quot;min&quot; or &quot;max&quot; is the base to use. So the
    following equalities hold:</p>
<p class="Pp"></p>
<pre>
    $diff-&gt;Get('min1') == $diff-&gt;Min(1)
    $diff-&gt;Get('0min2') == $diff-&gt;Min(2,0)
</pre>
<p class="Pp">Using <span class="Li">&quot;Get&quot;</span> in a scalar context
    when you've passed in more than one name is a fatal error
    (<span class="Li">&quot;die&quot;</span> is called).</p>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="_prepare_"><a class="permalink" href="#_prepare_">&quot;prepare&quot;</a></h2>
<p class="Pp">Given a reference to a list of items,
    <span class="Li">&quot;prepare&quot;</span> returns a reference to a hash
    which can be used when comparing this sequence to other sequences with
    <span class="Li">&quot;LCS&quot;</span> or
    <span class="Li">&quot;LCS_length&quot;</span>.</p>
<p class="Pp"></p>
<pre>
    $prep = prepare( \@seq1 );
    for $i ( 0 .. 10_000 )
    {
        @lcs = LCS( $prep, $seq[$i] );
        # do something useful with @lcs
    }
</pre>
<p class="Pp"><span class="Li">&quot;prepare&quot;</span> may be passed an
    optional third parameter; this is a CODE reference to a key generation
    function. See &quot;KEY GENERATION FUNCTIONS&quot;.</p>
<p class="Pp"></p>
<pre>
    $prep = prepare( \@seq1, \&amp;keyGen );
    for $i ( 0 .. 10_000 )
    {
        @lcs = LCS( $seq[$i], $prep, \&amp;keyGen );
        # do something useful with @lcs
    }
</pre>
<p class="Pp">Using <span class="Li">&quot;prepare&quot;</span> provides a
    performance gain of about 50% when calling LCS many times compared with not
    preparing.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_diff_"><a class="permalink" href="#_diff_">&quot;diff&quot;</a></h2>
<pre>
    @diffs     = diff( \@seq1, \@seq2 );
    $diffs_ref = diff( \@seq1, \@seq2 );
</pre>
<p class="Pp"><span class="Li">&quot;diff&quot;</span> computes the smallest set
    of additions and deletions necessary to turn the first sequence into the
    second, and returns a description of these changes. The description is a
    list of <i>hunks</i>; each hunk represents a contiguous section of items
    which should be added, deleted, or replaced. (Hunks containing unchanged
    items are not included.)</p>
<p class="Pp">The return value of <span class="Li">&quot;diff&quot;</span> is a
    list of hunks, or, in scalar context, a reference to such a list. If there
    are no differences, the list will be empty.</p>
<p class="Pp">Here is an example. Calling
    <span class="Li">&quot;diff&quot;</span> for the following two
  sequences:</p>
<p class="Pp"></p>
<pre>
    a b c e h j l m n p
    b c d e f j k l m r s t
</pre>
<p class="Pp">would produce the following list:</p>
<p class="Pp"></p>
<pre>
    (
      [ [ '-', 0, 'a' ] ],

      [ [ '+', 2, 'd' ] ],

      [ [ '-', 4, 'h' ],
        [ '+', 4, 'f' ] ],

      [ [ '+', 6, 'k' ] ],

      [ [ '-',  8, 'n' ],
        [ '-',  9, 'p' ],
        [ '+',  9, 'r' ],
        [ '+', 10, 's' ],
        [ '+', 11, 't' ] ],
    )
</pre>
<p class="Pp">There are five hunks here. The first hunk says that the
    <span class="Li">&quot;a&quot;</span> at position 0 of the first sequence
    should be deleted (<span class="Li">&quot;-&quot;</span>). The second hunk
    says that the <span class="Li">&quot;d&quot;</span> at position 2 of the
    second sequence should be inserted (<span class="Li">&quot;+&quot;</span>).
    The third hunk says that the <span class="Li">&quot;h&quot;</span> at
    position 4 of the first sequence should be removed and replaced with the
    <span class="Li">&quot;f&quot;</span> from position 4 of the second
    sequence. And so on.</p>
<p class="Pp"><span class="Li">&quot;diff&quot;</span> may be passed an optional
    third parameter; this is a CODE reference to a key generation function. See
    &quot;KEY GENERATION FUNCTIONS&quot;.</p>
<p class="Pp">Additional parameters, if any, will be passed to the key
    generation routine.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_sdiff_"><a class="permalink" href="#_sdiff_">&quot;sdiff&quot;</a></h2>
<pre>
    @sdiffs     = sdiff( \@seq1, \@seq2 );
    $sdiffs_ref = sdiff( \@seq1, \@seq2 );
</pre>
<p class="Pp"><span class="Li">&quot;sdiff&quot;</span> computes all necessary
    components to show two sequences and their minimized differences side by
    side, just like the Unix-utility <i>sdiff</i> does:</p>
<p class="Pp"></p>
<pre>
    same             same
    before     |     after
    old        &lt;     -
    -          &gt;     new
</pre>
<p class="Pp">It returns a list of array refs, each pointing to an array of
    display instructions. In scalar context it returns a reference to such a
    list. If there are no differences, the list will have one entry per item,
    each indicating that the item was unchanged.</p>
<p class="Pp">Display instructions consist of three elements: A modifier
    indicator (<span class="Li">&quot;+&quot;</span>: Element added,
    <span class="Li">&quot;-&quot;</span>: Element removed,
    <span class="Li">&quot;u&quot;</span>: Element unmodified,
    <span class="Li">&quot;c&quot;</span>: Element changed) and the value of the
    old and new elements, to be displayed side-by-side.</p>
<p class="Pp">An <span class="Li">&quot;sdiff&quot;</span> of the following two
    sequences:</p>
<p class="Pp"></p>
<pre>
    a b c e h j l m n p
    b c d e f j k l m r s t
</pre>
<p class="Pp">results in</p>
<p class="Pp"></p>
<pre>
    ( [ '-', 'a', ''  ],
      [ 'u', 'b', 'b' ],
      [ 'u', 'c', 'c' ],
      [ '+', '',  'd' ],
      [ 'u', 'e', 'e' ],
      [ 'c', 'h', 'f' ],
      [ 'u', 'j', 'j' ],
      [ '+', '',  'k' ],
      [ 'u', 'l', 'l' ],
      [ 'u', 'm', 'm' ],
      [ 'c', 'n', 'r' ],
      [ 'c', 'p', 's' ],
      [ '+', '',  't' ],
    )
</pre>
<p class="Pp"><span class="Li">&quot;sdiff&quot;</span> may be passed an
    optional third parameter; this is a CODE reference to a key generation
    function. See &quot;KEY GENERATION FUNCTIONS&quot;.</p>
<p class="Pp">Additional parameters, if any, will be passed to the key
    generation routine.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_compact_diff_"><a class="permalink" href="#_compact_diff_">&quot;compact_diff&quot;</a></h2>
<p class="Pp"><span class="Li">&quot;compact_diff&quot;</span> is much like
    <span class="Li">&quot;sdiff&quot;</span> except it returns a much more
    compact description consisting of just one flat list of indices. An example
    helps explain the format:</p>
<p class="Pp"></p>
<pre>
    my @a = qw( a b c   e  h j   l m n p      );
    my @b = qw(   b c d e f  j k l m    r s t );
    @cdiff = compact_diff( \@a, \@b );
    # Returns:
    #   @a      @b       @a       @b
    #  start   start   values   values
    (    0,      0,   #       =
         0,      0,   #    a  !
         1,      0,   #  b c  =  b c
         3,      2,   #       !  d
         3,      3,   #    e  =  e
         4,      4,   #    f  !  h
         5,      5,   #    j  =  j
         6,      6,   #       !  k
         6,      7,   #  l m  =  l m
         8,      9,   #  n p  !  r s t
        10,     12,   #
    );
</pre>
<p class="Pp">The 0th, 2nd, 4th, etc. entries are all indices into
    <span class="Li">@seq1</span> (@a in the above example) indicating where a
    hunk begins. The 1st, 3rd, 5th, etc. entries are all indices into
    <span class="Li">@seq2</span> (@b in the above example) indicating where the
    same hunk begins.</p>
<p class="Pp">So each pair of indices (except the last pair) describes where a
    hunk begins (in each sequence). Since each hunk must end at the item just
    before the item that starts the next hunk, the next pair of indices can be
    used to determine where the hunk ends.</p>
<p class="Pp">So, the first 4 entries (0..3) describe the first hunk. Entries 0
    and 1 describe where the first hunk begins (and so are always both 0).
    Entries 2 and 3 describe where the next hunk begins, so subtracting 1 from
    each tells us where the first hunk ends. That is, the first hunk contains
    items <span class="Li">$diff[0]</span> through
    <span class="Li">&quot;$diff[2] - 1&quot;</span> of the first sequence and
    contains items <span class="Li">$diff[1]</span> through
    <span class="Li">&quot;$diff[3] - 1&quot;</span> of the second sequence.</p>
<p class="Pp">In other words, the first hunk consists of the following two lists
    of items:</p>
<p class="Pp"></p>
<pre>
               #  1st pair     2nd pair
               # of indices   of indices
    @list1 = @a[ $cdiff[0] .. $cdiff[2]-1 ];
    @list2 = @b[ $cdiff[1] .. $cdiff[3]-1 ];
               # Hunk start   Hunk end
</pre>
<p class="Pp">Note that the hunks will always alternate between those that are
    part of the LCS (those that contain unchanged items) and those that contain
    changes. This means that all we need to be told is whether the first hunk is
    a 'same' or 'diff' hunk and we can determine which of the other hunks
    contain 'same' items or 'diff' items.</p>
<p class="Pp">By convention, we always make the first hunk contain unchanged
    items. So the 1st, 3rd, 5th, etc. hunks (all odd-numbered hunks if you start
    counting from 1) all contain unchanged items. And the 2nd, 4th, 6th, etc.
    hunks (all even-numbered hunks if you start counting from 1) all contain
    changed items.</p>
<p class="Pp">Since <span class="Li">@a</span> and <span class="Li">@b</span>
    don't begin with the same value, the first hunk in our example is empty
    (otherwise we'd violate the above convention). Note that the first 4 index
    values in our example are all zero. Plug these values into our previous code
    block and we get:</p>
<p class="Pp"></p>
<pre>
    @hunk1a = @a[ 0 .. 0-1 ];
    @hunk1b = @b[ 0 .. 0-1 ];
</pre>
<p class="Pp">And <span class="Li">&quot;0..-1&quot;</span> returns the empty
    list.</p>
<p class="Pp">Move down one pair of indices (2..5) and we get the offset ranges
    for the second hunk, which contains changed items.</p>
<p class="Pp">Since <span class="Li">@diff[2..5]</span> contains (0,0,1,0) in
    our example, the second hunk consists of these two lists of items:</p>
<p class="Pp"></p>
<pre>
        @hunk2a = @a[ $cdiff[2] .. $cdiff[4]-1 ];
        @hunk2b = @b[ $cdiff[3] .. $cdiff[5]-1 ];
    # or
        @hunk2a = @a[ 0 .. 1-1 ];
        @hunk2b = @b[ 0 .. 0-1 ];
    # or
        @hunk2a = @a[ 0 .. 0 ];
        @hunk2b = @b[ 0 .. -1 ];
    # or
        @hunk2a = ( 'a' );
        @hunk2b = ( );
</pre>
<p class="Pp">That is, we would delete item 0 ('a') from
    <span class="Li">@a</span>.</p>
<p class="Pp">Since <span class="Li">@diff[4..7]</span> contains (1,0,3,2) in
    our example, the third hunk consists of these two lists of items:</p>
<p class="Pp"></p>
<pre>
        @hunk3a = @a[ $cdiff[4] .. $cdiff[6]-1 ];
        @hunk3a = @b[ $cdiff[5] .. $cdiff[7]-1 ];
    # or
        @hunk3a = @a[ 1 .. 3-1 ];
        @hunk3a = @b[ 0 .. 2-1 ];
    # or
        @hunk3a = @a[ 1 .. 2 ];
        @hunk3a = @b[ 0 .. 1 ];
    # or
        @hunk3a = qw( b c );
        @hunk3a = qw( b c );
</pre>
<p class="Pp">Note that this third hunk contains unchanged items as our
    convention demands.</p>
<p class="Pp">You can continue this process until you reach the last two
    indices, which will always be the number of items in each sequence. This is
    required so that subtracting one from each will give you the indices to the
    last items in each sequence.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_traverse_sequences_"><a class="permalink" href="#_traverse_sequences_">&quot;traverse_sequences&quot;</a></h2>
<p class="Pp"><span class="Li">&quot;traverse_sequences&quot;</span> used to be
    the most general facility provided by this module (the new OO interface is
    more powerful and much easier to use).</p>
<p class="Pp">Imagine that there are two arrows. Arrow A points to an element of
    sequence A, and arrow B points to an element of the sequence B. Initially,
    the arrows point to the first elements of the respective sequences.
    <span class="Li">&quot;traverse_sequences&quot;</span> will advance the
    arrows through the sequences one element at a time, calling an appropriate
    user-specified callback function before each advance. It willadvance the
    arrows in such a way that if there are equal elements
    <span class="Li">$A[$i]</span> and <span class="Li">$B[$j]</span> which are
    equal and which are part of the LCS, there will be some moment during the
    execution of <span class="Li">&quot;traverse_sequences&quot;</span> when
    arrow A is pointing to <span class="Li">$A[$i]</span> and arrow B is
    pointing to <span class="Li">$B[$j]</span>. When this happens,
    <span class="Li">&quot;traverse_sequences&quot;</span> will call the
    <span class="Li">&quot;MATCH&quot;</span> callback function and then it will
    advance both arrows.</p>
<p class="Pp">Otherwise, one of the arrows is pointing to an element of its
    sequence that is not part of the LCS.
    <span class="Li">&quot;traverse_sequences&quot;</span> will advance that
    arrow and will call the <span class="Li">&quot;DISCARD_A&quot;</span> or the
    <span class="Li">&quot;DISCARD_B&quot;</span> callback, depending on which
    arrow it advanced. If both arrows point to elements that are not part of the
    LCS, then <span class="Li">&quot;traverse_sequences&quot;</span> will
    advance one of them and call the appropriate callback, but it is not
    specified which it will call.</p>
<p class="Pp">The arguments to
    <span class="Li">&quot;traverse_sequences&quot;</span> are the two sequences
    to traverse, and a hash which specifies the callback functions, like
  this:</p>
<p class="Pp"></p>
<pre>
    traverse_sequences(
        \@seq1, \@seq2,
        {   MATCH =&gt; $callback_1,
            DISCARD_A =&gt; $callback_2,
            DISCARD_B =&gt; $callback_3,
        }
    );
</pre>
<p class="Pp">Callbacks for MATCH, DISCARD_A, and DISCARD_B are invoked with at
    least the indices of the two arrows as their arguments. They are not
    expected to return any values. If a callback is omitted from the table, it
    is not called.</p>
<p class="Pp">Callbacks for A_FINISHED and B_FINISHED are invoked with at least
    the corresponding index in A or B.</p>
<p class="Pp">If arrow A reaches the end of its sequence, before arrow B does,
    <span class="Li">&quot;traverse_sequences&quot;</span> will call the
    <span class="Li">&quot;A_FINISHED&quot;</span> callback when it advances
    arrow B, if there is such a function; if not it will call
    <span class="Li">&quot;DISCARD_B&quot;</span> instead. Similarly if arrow B
    finishes first. <span class="Li">&quot;traverse_sequences&quot;</span>
    returns when both arrows are at the ends of their respective sequences. It
    returns true on success and false on failure. At present there is no way to
    fail.</p>
<p class="Pp"><span class="Li">&quot;traverse_sequences&quot;</span> may be
    passed an optional fourth parameter; this is a CODE reference to a key
    generation function. See &quot;KEY GENERATION FUNCTIONS&quot;.</p>
<p class="Pp">Additional parameters, if any, will be passed to the key
    generation function.</p>
<p class="Pp">If you want to pass additional parameters to your callbacks, but
    don't need a custom key generation function, you can get the default by
    passing undef:</p>
<p class="Pp"></p>
<pre>
    traverse_sequences(
        \@seq1, \@seq2,
        {   MATCH =&gt; $callback_1,
            DISCARD_A =&gt; $callback_2,
            DISCARD_B =&gt; $callback_3,
        },
        undef,     # default key-gen
        $myArgument1,
        $myArgument2,
        $myArgument3,
    );
</pre>
<p class="Pp"><span class="Li">&quot;traverse_sequences&quot;</span> does not
    have a useful return value; you are expected to plug in the appropriate
    behavior with the callback functions.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_traverse_balanced_"><a class="permalink" href="#_traverse_balanced_">&quot;traverse_balanced&quot;</a></h2>
<p class="Pp"><span class="Li">&quot;traverse_balanced&quot;</span> is an
    alternative to <span class="Li">&quot;traverse_sequences&quot;</span>. It
    uses a different algorithm to iterate through the entries in the computed
    LCS. Instead of sticking to one side and showing element changes as
    insertions and deletions only, it will jump back and forth between the two
    sequences and report <i>changes</i> occurring as deletions on one side
    followed immediatly by an insertion on the other side.</p>
<p class="Pp">In addition to the <span class="Li">&quot;DISCARD_A&quot;</span>,
    <span class="Li">&quot;DISCARD_B&quot;</span>, and
    <span class="Li">&quot;MATCH&quot;</span> callbacks supported by
    <span class="Li">&quot;traverse_sequences&quot;</span>,
    <span class="Li">&quot;traverse_balanced&quot;</span> supports a
    <span class="Li">&quot;CHANGE&quot;</span> callback indicating that one
    element got <span class="Li">&quot;replaced&quot;</span> by another:</p>
<p class="Pp"></p>
<pre>
    traverse_balanced(
        \@seq1, \@seq2,
        {   MATCH =&gt; $callback_1,
            DISCARD_A =&gt; $callback_2,
            DISCARD_B =&gt; $callback_3,
            CHANGE    =&gt; $callback_4,
        }
    );
</pre>
<p class="Pp">If no <span class="Li">&quot;CHANGE&quot;</span> callback is
    specified, <span class="Li">&quot;traverse_balanced&quot;</span> will map
    <span class="Li">&quot;CHANGE&quot;</span> events to
    <span class="Li">&quot;DISCARD_A&quot;</span> and
    <span class="Li">&quot;DISCARD_B&quot;</span> actions, therefore resulting
    in a similar behaviour as
    <span class="Li">&quot;traverse_sequences&quot;</span> with different order
    of events.</p>
<p class="Pp"><span class="Li">&quot;traverse_balanced&quot;</span> might be a
    bit slower than <span class="Li">&quot;traverse_sequences&quot;</span>,
    noticable only while processing huge amounts of data.</p>
<p class="Pp">The <span class="Li">&quot;sdiff&quot;</span> function of this
    module is implemented as call to
    <span class="Li">&quot;traverse_balanced&quot;</span>.</p>
<p class="Pp"><span class="Li">&quot;traverse_balanced&quot;</span> does not
    have a useful return value; you are expected to plug in the appropriate
    behavior with the callback functions.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="KEY_GENERATION_FUNCTIONS"><a class="permalink" href="#KEY_GENERATION_FUNCTIONS">KEY
  GENERATION FUNCTIONS</a></h1>
<p class="Pp">Most of the functions accept an optional extra parameter. This is
    a CODE reference to a key generating (hashing) function that should return a
    string that uniquely identifies a given element. It should be the case that
    if two elements are to be considered equal, their keys should be the same
    (and the other way around). If no key generation function is provided, the
    key will be the element as a string.</p>
<p class="Pp">By default, comparisons will use &quot;eq&quot; and elements will
    be turned into keys using the default stringizing operator
  '&quot;&quot;'.</p>
<p class="Pp">Where this is important is when you're comparing something other
    than strings. If it is the case that you have multiple different objects
    that should be considered to be equal, you should supply a key generation
    function. Otherwise, you have to make sure that your arrays contain unique
    references.</p>
<p class="Pp">For instance, consider this example:</p>
<p class="Pp"></p>
<pre>
    package Person;

    sub new
    {
        my $package = shift;
        return bless { name =&gt; '', ssn =&gt; '', @_ }, $package;
    }

    sub clone
    {
        my $old = shift;
        my $new = bless { %$old }, ref($old);
    }

    sub hash
    {
        return shift()-&gt;{'ssn'};
    }

    my $person1 = Person-&gt;new( name =&gt; 'Joe', ssn =&gt; '123-45-6789' );
    my $person2 = Person-&gt;new( name =&gt; 'Mary', ssn =&gt; '123-47-0000' );
    my $person3 = Person-&gt;new( name =&gt; 'Pete', ssn =&gt; '999-45-2222' );
    my $person4 = Person-&gt;new( name =&gt; 'Peggy', ssn =&gt; '123-45-9999' );
    my $person5 = Person-&gt;new( name =&gt; 'Frank', ssn =&gt; '000-45-9999' );
</pre>
<p class="Pp">If you did this:</p>
<p class="Pp"></p>
<pre>
    my $array1 = [ $person1, $person2, $person4 ];
    my $array2 = [ $person1, $person3, $person4, $person5 ];
    Algorithm::Diff::diff( $array1, $array2 );
</pre>
<p class="Pp">everything would work out OK (each of the objects would be
    converted into a string like &quot;Person=HASH(0x82425b0)&quot; for
    comparison).</p>
<p class="Pp">But if you did this:</p>
<p class="Pp"></p>
<pre>
    my $array1 = [ $person1, $person2, $person4 ];
    my $array2 = [ $person1, $person3, $person4-&gt;clone(), $person5 ];
    Algorithm::Diff::diff( $array1, $array2 );
</pre>
<p class="Pp"><span class="Li">$person4</span> and
    <span class="Li">$person4</span>-&gt;<i>clone()</i> (which have the same
    name and SSN) would be seen as different objects. If you wanted them to be
    considered equivalent, you would have to pass in a key generation
  function:</p>
<p class="Pp"></p>
<pre>
    my $array1 = [ $person1, $person2, $person4 ];
    my $array2 = [ $person1, $person3, $person4-&gt;clone(), $person5 ];
    Algorithm::Diff::diff( $array1, $array2, \&amp;Person::hash );
</pre>
<p class="Pp">This would use the 'ssn' field in each Person as a comparison key,
    and so would consider <span class="Li">$person4</span> and
    <span class="Li">$person4</span>-&gt;<i>clone()</i> as equal.</p>
<p class="Pp">You may also pass additional parameters to the key generation
    function if you wish.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ERROR_CHECKING"><a class="permalink" href="#ERROR_CHECKING">ERROR
  CHECKING</a></h1>
<p class="Pp">If you pass these routines a non-reference and they expect a
    reference, they will die with a message.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">This version released by Tye McQueen
    (http://perlmonks.org/?node=tye).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">Parts Copyright (c) 2000-2004 Ned Konz. All rights reserved. Parts
    by Tye McQueen.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MAILING_LIST"><a class="permalink" href="#MAILING_LIST">MAILING
  LIST</a></h1>
<p class="Pp">Mark-Jason still maintains a mailing list. To join a low-volume
    mailing list for announcements related to diff and Algorithm::Diff, send an
    empty mail message to mjd-perl-diff-request@plover.com.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CREDITS"><a class="permalink" href="#CREDITS">CREDITS</a></h1>
<p class="Pp">Versions through 0.59 (and much of this documentation) were
    written by:</p>
<p class="Pp">Mark-Jason Dominus, mjd-perl-diff@plover.com</p>
<p class="Pp">This version borrows some documentation and routine names from
    Mark-Jason's, but Diff.pm's code was completely replaced.</p>
<p class="Pp">This code was adapted from the Smalltalk code of Mario Wolczko
    &lt;mario@wolczko.com&gt;, which is available at
    ftp://st.cs.uiuc.edu/pub/Smalltalk/MANCHESTER/manchester/4.0/diff.st</p>
<p class="Pp"><span class="Li">&quot;sdiff&quot;</span> and
    <span class="Li">&quot;traverse_balanced&quot;</span> were written by Mike
    Schilli &lt;m@perlmeister.com&gt;.</p>
<p class="Pp">The algorithm is that described in <i>A Fast Algorithm for
    Computing Longest Common Subsequences</i>, CACM, vol.20, no.5, pp.350-353,
    May 1977, with a few minor improvements to improve the speed.</p>
<p class="Pp">Much work was done by Ned Konz (perl@bike-nomad.com).</p>
<p class="Pp">The OO interface and some other changes are by Tye McQueen.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="POD_ERRORS"><a class="permalink" href="#POD_ERRORS">POD
  ERRORS</a></h1>
<p class="Pp">Hey! <b>The above document had some coding errors, which are
    explained below:</b></p>
<dl class="Bl-tag">
  <dt id="Around"><a class="permalink" href="#Around">Around line 989:</a></dt>
  <dd>You can't have =items (as at line 1021) unless the first thing after the
      =over is an =item</dd>
  <dt id="Around~2"><a class="permalink" href="#Around~2">Around line
    1108:</a></dt>
  <dd>Expected text after =item, not a number</dd>
  <dt id="Around~3"><a class="permalink" href="#Around~3">Around line
    1114:</a></dt>
  <dd>Expected text after =item, not a number</dd>
  <dt id="Around~4"><a class="permalink" href="#Around~4">Around line
    1120:</a></dt>
  <dd>Expected text after =item, not a number</dd>
</dl>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2006-07-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>CPAN::Meta(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">CPAN::Meta(3pm)</td>
    <td class="head-vol"><a href=".">Perl Programmers Reference Guide</a></td>
    <td class="head-rtitle">CPAN::Meta(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">CPAN::Meta - the distribution metadata for a CPAN dist</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 2.150010</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use v5.10;
    use strict;
    use warnings;
    use CPAN::Meta;
    use Module::Load;
    my $meta = CPAN::Meta-&gt;load_file('META.json');
    printf &quot;testing requirements for %s version %s\n&quot;,
    $meta-&gt;name,
    $meta-&gt;version;
    my $prereqs = $meta-&gt;effective_prereqs;
    for my $phase ( qw/configure runtime build test/ ) {
        say &quot;Requirements for $phase:&quot;;
        my $reqs = $prereqs-&gt;requirements_for($phase, &quot;requires&quot;);
        for my $module ( sort $reqs-&gt;required_modules ) {
            my $status;
            if ( eval { load $module unless $module eq 'perl'; 1 } ) {
                my $version = $module eq 'perl' ? $] : $module-&gt;VERSION;
                $status = $reqs-&gt;accepts_module($module, $version)
                        ? &quot;$version ok&quot; : &quot;$version not ok&quot;;
            } else {
                $status = &quot;missing&quot;
            };
            say &quot;  $module ($status)&quot;;
        }
    }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Software distributions released to the CPAN include a
    <i>META.json</i> or, for older distributions, <i>META.yml</i>, which
    describes the distribution, its contents, and the requirements for building
    and installing the distribution. The data structure stored in the
    <i>META.json</i> file is described in CPAN::Meta::Spec.</p>
<p class="Pp">CPAN::Meta provides a simple class to represent this distribution
    metadata (or <i>distmeta</i>), along with some helpful methods for
    interrogating that data.</p>
<p class="Pp">The documentation below is only for the methods of the CPAN::Meta
    object. For information on the meaning of individual fields, consult the
    spec.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
<pre>  my $meta = CPAN::Meta-&gt;new($distmeta_struct, \%options);
</pre>
<p class="Pp">Returns a valid CPAN::Meta object or dies if the supplied metadata
    hash reference fails to validate. Older-format metadata will be up-converted
    to version 2 if they validate against the original stated specification.</p>
<p class="Pp">It takes an optional hashref of options. Valid options
  include:</p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>lazy_validation -- if true, new will attempt to convert the given metadata
      to version 2 before attempting to validate it. This means than any fixable
      errors will be handled by CPAN::Meta::Converter before validation. (Note
      that this might result in invalid optional data being silently dropped.)
      The default is false.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="create"><a class="permalink" href="#create">create</a></h2>
<pre>  my $meta = CPAN::Meta-&gt;create($distmeta_struct, \%options);
</pre>
<p class="Pp">This is same as <span class="Li">&quot;new()&quot;</span>, except
    that <span class="Li">&quot;generated_by&quot;</span> and
    <span class="Li">&quot;meta-spec&quot;</span> fields will be generated if
    not provided. This means the metadata structure is assumed to otherwise
    follow the latest CPAN::Meta::Spec.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="load_file"><a class="permalink" href="#load_file">load_file</a></h2>
<pre>  my $meta = CPAN::Meta-&gt;load_file($distmeta_file, \%options);
</pre>
<p class="Pp">Given a pathname to a file containing metadata, this deserializes
    the file according to its file suffix and constructs a new
    <span class="Li">&quot;CPAN::Meta&quot;</span> object, just like
    <span class="Li">&quot;new()&quot;</span>. It will die if the deserialized
    version fails to validate against its stated specification version.</p>
<p class="Pp">It takes the same options as
    <span class="Li">&quot;new()&quot;</span> but
    <span class="Li">&quot;lazy_validation&quot;</span> defaults to true.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="load_yaml_string"><a class="permalink" href="#load_yaml_string">load_yaml_string</a></h2>
<pre>  my $meta = CPAN::Meta-&gt;load_yaml_string($yaml, \%options);
</pre>
<p class="Pp">This method returns a new CPAN::Meta object using the first
    document in the given YAML string. In other respects it is identical to
    <span class="Li">&quot;load_file()&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="load_json_string"><a class="permalink" href="#load_json_string">load_json_string</a></h2>
<pre>  my $meta = CPAN::Meta-&gt;load_json_string($json, \%options);
</pre>
<p class="Pp">This method returns a new CPAN::Meta object using the structure
    represented by the given JSON string. In other respects it is identical to
    <span class="Li">&quot;load_file()&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="load_string"><a class="permalink" href="#load_string">load_string</a></h2>
<pre>  my $meta = CPAN::Meta-&gt;load_string($string, \%options);
</pre>
<p class="Pp">If you don't know if a string contains YAML or JSON, this method
    will use Parse::CPAN::Meta to guess. In other respects it is identical to
    <span class="Li">&quot;load_file()&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="save"><a class="permalink" href="#save">save</a></h2>
<pre>  $meta-&gt;save($distmeta_file, \%options);
</pre>
<p class="Pp">Serializes the object as JSON and writes it to the given file. The
    only valid option is <span class="Li">&quot;version&quot;</span>, which
    defaults to '2'. On Perl 5.8.1 or later, the file is saved with UTF-8
    encoding.</p>
<p class="Pp">For <span class="Li">&quot;version&quot;</span> 2 (or higher), the
    filename should end in '.json'. JSON::PP is the default JSON backend. Using
    another JSON backend requires JSON 2.5 or later and you must set the
    <span class="Li">$ENV{PERL_JSON_BACKEND}</span> to a supported alternate
    backend like JSON::XS.</p>
<p class="Pp">For <span class="Li">&quot;version&quot;</span> less than 2, the
    filename should end in '.yml'. CPAN::Meta::Converter is used to generate an
    older metadata structure, which is serialized to YAML. CPAN::Meta::YAML is
    the default YAML backend. You may set the
    <span class="Li">$ENV{PERL_YAML_BACKEND}</span> to a supported alternative
    backend, though this is not recommended due to subtle incompatibilities
    between YAML parsers on CPAN.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="meta_spec_version"><a class="permalink" href="#meta_spec_version">meta_spec_version</a></h2>
<p class="Pp">This method returns the version part of the
    <span class="Li">&quot;meta_spec&quot;</span> entry in the distmeta
    structure. It is equivalent to:</p>
<p class="Pp"></p>
<pre>  $meta-&gt;meta_spec-&gt;{version};
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="effective_prereqs"><a class="permalink" href="#effective_prereqs">effective_prereqs</a></h2>
<pre>  my $prereqs = $meta-&gt;effective_prereqs;
  my $prereqs = $meta-&gt;effective_prereqs( \@feature_identifiers );
</pre>
<p class="Pp">This method returns a CPAN::Meta::Prereqs object describing all
    the prereqs for the distribution. If an arrayref of feature identifiers is
    given, the prereqs for the identified features are merged together with the
    distribution's core prereqs before the CPAN::Meta::Prereqs object is
    returned.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="should_index_file"><a class="permalink" href="#should_index_file">should_index_file</a></h2>
<pre>  ... if $meta-&gt;should_index_file( $filename );
</pre>
<p class="Pp">This method returns true if the given file should be indexed. It
    decides this by checking the <span class="Li">&quot;file&quot;</span> and
    <span class="Li">&quot;directory&quot;</span> keys in the
    <span class="Li">&quot;no_index&quot;</span> property of the distmeta
    structure. Note that neither the version format nor
    <span class="Li">&quot;release_status&quot;</span> are considered.</p>
<p class="Pp"><span class="Li">$filename</span> should be given in unix
  format.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="should_index_package"><a class="permalink" href="#should_index_package">should_index_package</a></h2>
<pre>  ... if $meta-&gt;should_index_package( $package );
</pre>
<p class="Pp">This method returns true if the given package should be indexed.
    It decides this by checking the <span class="Li">&quot;package&quot;</span>
    and <span class="Li">&quot;namespace&quot;</span> keys in the
    <span class="Li">&quot;no_index&quot;</span> property of the distmeta
    structure. Note that neither the version format nor
    <span class="Li">&quot;release_status&quot;</span> are considered.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="features"><a class="permalink" href="#features">features</a></h2>
<pre>  my @feature_objects = $meta-&gt;features;
</pre>
<p class="Pp">This method returns a list of CPAN::Meta::Feature objects, one for
    each optional feature described by the distribution's metadata.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="feature"><a class="permalink" href="#feature">feature</a></h2>
<pre>  my $feature_object = $meta-&gt;feature( $identifier );
</pre>
<p class="Pp">This method returns a CPAN::Meta::Feature object for the optional
    feature with the given identifier. If no feature with that identifier
    exists, an exception will be raised.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="as_struct"><a class="permalink" href="#as_struct">as_struct</a></h2>
<pre>  my $copy = $meta-&gt;as_struct( \%options );
</pre>
<p class="Pp">This method returns a deep copy of the object's metadata as an
    unblessed hash reference. It takes an optional hashref of options. If the
    hashref contains a <span class="Li">&quot;version&quot;</span> argument, the
    copied metadata will be converted to the version of the specification and
    returned. For example:</p>
<p class="Pp"></p>
<pre>  my $old_spec = $meta-&gt;as_struct( {version =&gt; &quot;1.4&quot;} );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="as_string"><a class="permalink" href="#as_string">as_string</a></h2>
<pre>  my $string = $meta-&gt;as_string( \%options );
</pre>
<p class="Pp">This method returns a serialized copy of the object's metadata as
    a character string. (The strings are <b>not</b> UTF-8 encoded.) It takes an
    optional hashref of options. If the hashref contains a
    <span class="Li">&quot;version&quot;</span> argument, the copied metadata
    will be converted to the version of the specification and returned. For
    example:</p>
<p class="Pp"></p>
<pre>  my $string = $meta-&gt;as_string( {version =&gt; &quot;1.4&quot;} );
</pre>
<p class="Pp">For <span class="Li">&quot;version&quot;</span> greater than or
    equal to 2, the string will be serialized as JSON. For
    <span class="Li">&quot;version&quot;</span> less than 2, the string will be
    serialized as YAML. In both cases, the same rules are followed as in the
    <span class="Li">&quot;save()&quot;</span> method for choosing a
    serialization backend.</p>
<p class="Pp">The serialized structure will include a
    <span class="Li">&quot;x_serialization_backend&quot;</span> entry giving the
    package and version used to serialize. Any existing key in the given
    <span class="Li">$meta</span> object will be clobbered.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="STRING_DATA"><a class="permalink" href="#STRING_DATA">STRING
  DATA</a></h1>
<p class="Pp">The following methods return a single value, which is the value
    for the corresponding entry in the distmeta structure. Values should be
    either undef or strings.</p>
<ul class="Bl-bullet">
  <li>abstract</li>
  <li>description</li>
  <li>dynamic_config</li>
  <li>generated_by</li>
  <li>name</li>
  <li>release_status</li>
  <li>version</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="LIST_DATA"><a class="permalink" href="#LIST_DATA">LIST
  DATA</a></h1>
<p class="Pp">These methods return lists of string values, which might be
    represented in the distmeta structure as arrayrefs or scalars:</p>
<ul class="Bl-bullet">
  <li>authors</li>
  <li>keywords</li>
  <li>licenses</li>
</ul>
<p class="Pp">The <span class="Li">&quot;authors&quot;</span> and
    <span class="Li">&quot;licenses&quot;</span> methods may also be called as
    <span class="Li">&quot;author&quot;</span> and
    <span class="Li">&quot;license&quot;</span>, respectively, to match the
    field name in the distmeta structure.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MAP_DATA"><a class="permalink" href="#MAP_DATA">MAP
  DATA</a></h1>
<p class="Pp">These readers return hashrefs of arbitrary unblessed data
    structures, each described more fully in the specification:</p>
<ul class="Bl-bullet">
  <li>meta_spec</li>
  <li>resources</li>
  <li>provides</li>
  <li>no_index</li>
  <li>prereqs</li>
  <li>optional_features</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="CUSTOM_DATA"><a class="permalink" href="#CUSTOM_DATA">CUSTOM
  DATA</a></h1>
<p class="Pp">A list of custom keys are available from the
    <span class="Li">&quot;custom_keys&quot;</span> method and particular keys
    may be retrieved with the <span class="Li">&quot;custom&quot;</span>
  method.</p>
<p class="Pp"></p>
<pre>  say $meta-&gt;custom($_) for $meta-&gt;custom_keys;
</pre>
<p class="Pp">If a custom key refers to a data structure, a deep clone is
    returned.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">Please report any bugs or feature using the CPAN Request Tracker.
    Bugs can be submitted through the web interface at
    &lt;http://rt.cpan.org/Dist/Display.html?Queue=CPAN-Meta&gt;</p>
<p class="Pp">When submitting a bug or request, please include a test-file or a
    patch to an existing test-file that illustrates the bug or desired
  feature.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<ul class="Bl-bullet">
  <li>CPAN::Meta::Converter</li>
  <li>CPAN::Meta::Validator</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
<section class="Ss">
<h2 class="Ss" id="Bugs_/_Feature_Requests"><a class="permalink" href="#Bugs_/_Feature_Requests">Bugs
  / Feature Requests</a></h2>
<p class="Pp">Please report any bugs or feature requests through the issue
    tracker at &lt;https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues&gt;.
    You will be notified automatically of any progress on your issue.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Source_Code"><a class="permalink" href="#Source_Code">Source
  Code</a></h2>
<p class="Pp">This is open source software. The code repository is available for
    public review and contribution under the terms of the license.</p>
<p class="Pp">&lt;https://github.com/Perl-Toolchain-Gang/CPAN-Meta&gt;</p>
<p class="Pp"></p>
<pre>  git clone https://github.com/Perl-Toolchain-Gang/CPAN-Meta.git
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>David Golden &lt;dagolden@cpan.org&gt;</li>
  <li>Ricardo Signes &lt;rjbs@cpan.org&gt;</li>
  <li>Adam Kennedy &lt;adamk@cpan.org&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<ul class="Bl-bullet">
  <li>Ansgar Burchardt &lt;ansgar@cpan.org&gt;</li>
  <li>Avar Arnfjord Bjarmason &lt;avar@cpan.org&gt;</li>
  <li>Benjamin Noggle &lt;agwind@users.noreply.github.com&gt;</li>
  <li>Christopher J. Madsen &lt;cjm@cpan.org&gt;</li>
  <li>Chuck Adams &lt;cja987@gmail.com&gt;</li>
  <li>Cory G Watson &lt;gphat@cpan.org&gt;</li>
  <li>Damyan Ivanov &lt;dam@cpan.org&gt;</li>
  <li>David Golden &lt;xdg@xdg.me&gt;</li>
  <li>Eric Wilhelm &lt;ewilhelm@cpan.org&gt;</li>
  <li>Graham Knop &lt;haarg@haarg.org&gt;</li>
  <li>Gregor Hermann &lt;gregoa@debian.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Kenichi Ishigaki &lt;ishigaki@cpan.org&gt;</li>
  <li>Kent Fredric &lt;kentfredric@gmail.com&gt;</li>
  <li>Ken Williams &lt;kwilliams@cpan.org&gt;</li>
  <li>Lars Dieckow &lt;daxim@cpan.org&gt;</li>
  <li>Leon Timmermans &lt;leont@cpan.org&gt;</li>
  <li>majensen &lt;maj@fortinbras.us&gt;</li>
  <li>Mark Fowler &lt;markf@cpan.org&gt;</li>
  <li>Matt S Trout &lt;mst@shadowcat.co.uk&gt;</li>
  <li>Michael G. Schwern &lt;mschwern@cpan.org&gt;</li>
  <li>Mohammad S Anwar &lt;mohammad.anwar@yahoo.com&gt;</li>
  <li>mohawk2 &lt;mohawk2@users.noreply.github.com&gt;</li>
  <li>moznion &lt;moznion@gmail.com&gt;</li>
  <li>Niko Tyni &lt;ntyni@debian.org&gt;</li>
  <li>Olaf Alders &lt;olaf@wundersolutions.com&gt;</li>
  <li>Olivier Mengue &lt;dolmen@cpan.org&gt;</li>
  <li>Randy Sims &lt;randys@thepierianspring.org&gt;</li>
  <li>Tomohiro Hosaka &lt;bokutin@bokut.in&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2010 by David Golden, Ricardo
    Signes, Adam Kennedy and Contributors.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os"><a href="..">perl v5.34.1</a></td>
  </tr>
</table>
</body>
</html>

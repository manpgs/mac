<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Log::Message(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Log::Message(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Log::Message(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Log::Message - A generic message storing mechanism;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
    use Log::Message private =&gt; 0, config =&gt; '/our/cf_file';

    my $log = Log::Message-&gt;new(    private =&gt; 1,
                                    level   =&gt; 'log',
                                    config  =&gt; '/my/cf_file',
                               );

    $log-&gt;store('this is my first message');

    $log-&gt;store(    message =&gt; 'message #2',
                    tag     =&gt; 'MY_TAG',
                    level   =&gt; 'carp',
                    extra   =&gt; ['this is an argument to the handler'],
               );

    my @last_five_items = $log-&gt;retrieve(5);

    my @items = $log-&gt;retrieve( tag     =&gt; qr/my_tag/i,
                                message =&gt; qr/\d/,
                                remove  =&gt; 1,
                              );

    my @items = $log-&gt;final( level =&gt; qr/carp/, amount =&gt; 2 );

    my $first_error = $log-&gt;first()

    # croak with the last error on the stack
    $log-&gt;final-&gt;croak;

    # empty the stack
    $log-&gt;flush();
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Log::Message is a generic message storage mechanism. It allows you
    to store messages on a stack -- either shared or private -- and assign
    meta-data to it. Some meta-data will automatically be added for you, like a
    timestamp and a stack trace, but some can be filled in by the user, like a
    tag by which to identify it or group it, and a level at which to handle the
    message (for example, log it, or die with it)</p>
<p class="Pp">Log::Message also provides a powerful way of searching through
    items by regexes on messages, tags and level.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Hierarchy"><a class="permalink" href="#Hierarchy">Hierarchy</a></h1>
<p class="Pp">There are 4 modules of interest when dealing with the
    Log::Message::* modules:</p>
<dl class="Bl-tag">
  <dt id="Log::Message"><a class="permalink" href="#Log::Message">Log::Message</a></dt>
  <dd>Log::Message provides a few methods to manipulate the stack it keeps. It
      has the option of keeping either a private or a public stack. More on this
      below.</dd>
  <dt id="Log::Message::Item"><a class="permalink" href="#Log::Message::Item">Log::Message::Item</a></dt>
  <dd>These are individual message items, which are objects that contain the
      user message as well as the meta-data described above. See the
      Log::Message::Item manpage to see how to extract this meta-data and how to
      work with the Item objects. You should never need to create your own Item
      objects, but knowing about their methods and accessors is important if you
      want to write your own handlers. (See below)</dd>
  <dt id="Log::Message::Handlers"><a class="permalink" href="#Log::Message::Handlers">Log::Message::Handlers</a></dt>
  <dd>These are a collection of handlers that will be called for a level that is
      used on a Log::Message::Item object. For example, if a message is logged
      with the 'carp' level, the 'carp' handler from Log::Message::Handlers will
      be called. See the Log::Message::Handlers manpage for more explanation
      about how handlers work, which one are available and how to create your
      own.</dd>
  <dt id="Log::Message::Config"><a class="permalink" href="#Log::Message::Config">Log::Message::Config</a></dt>
  <dd>Per Log::Message object, there is a configuration required that will fill
      in defaults if the user did not specify arguments to override them (like
      for example what tag will be set if none was provided),
      Log::Message::Config handles the creation of these configurations.
    <p class="Pp">Configuration can be specified in 4 ways:</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>As a configuration file when you <span class="Li">&quot;use
      Log::Message&quot;</span></li>
  <li>As arguments when you <span class="Li">&quot;use
    Log::Message&quot;</span></li>
  <li>As a configuration file when you create a new Log::Message object. (The
      config will then only apply to that object if you marked it as
    private)</li>
  <li>As arguments when you create a new Log::Message object.
    <p class="Pp">You should never need to use the Log::Message::Config module
        yourself, as this is transparently done by Log::Message, but its manpage
        does provide an explanation of how you can create a config file.</p>
  </li>
</ul>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="Options"><a class="permalink" href="#Options">Options</a></h1>
<p class="Pp">When using Log::Message, or creating a new Log::Message object,
    you can supply various options to alter its behaviour. Of course, there are
    sensible defaults should you choose to omit these options.</p>
<p class="Pp">Below an explanation of all the options and how they work.</p>
<dl class="Bl-tag">
  <dt id="config"><a class="permalink" href="#config">config</a></dt>
  <dd>The path to a configuration file to be read. See the manpage of
      Log::Message::Config for the required format
    <p class="Pp">These options will be overridden by any explicit arguments
        passed.</p>
  </dd>
  <dt id="private"><a class="permalink" href="#private">private</a></dt>
  <dd>Whether to create, by default, private or shared objects. If you choose to
      create shared objects, all Log::Message objects will use the same stack.
    <p class="Pp">This means that even though every module may make its own
        <span class="Li">$log</span> object they will still be sharing the same
        error stack on which they are putting errors and from which they are
        retrieving.</p>
    <p class="Pp">This can be useful in big projects.</p>
    <p class="Pp">If you choose to create a private object, then the stack will
        of course be private to this object, but it will still fall back to the
        shared config should no private config or overriding arguments be
        provided.</p>
  </dd>
  <dt id="verbose"><a class="permalink" href="#verbose">verbose</a></dt>
  <dd>Log::Message makes use of another module to validate its arguments, which
      is called Params::Check, which is a lightweight, yet powerful input
      checker and parser. (See the Params::Check manpage for details).
    <p class="Pp">The verbose setting will control whether this module will
        generate warnings if something improper is passed as input, or merely
        silently returns undef, at which point Log::Message will generate a
        warning.</p>
    <p class="Pp">It's best to just leave this at its default value, which is
        '1'</p>
  </dd>
  <dt id="tag"><a class="permalink" href="#tag">tag</a></dt>
  <dd>The tag to add to messages if none was provided. If neither your config,
      nor any specific arguments supply a tag, then Log::Message will set it to
      'NONE'
    <p class="Pp">Tags are useful for searching on or grouping by. For example,
        you could tag all the messages you want to go to the user as 'USER
        ERROR' and all those that are only debug information with 'DEBUG'.</p>
    <p class="Pp">At the end of your program, you could then print all the ones
        tagged 'USER ERROR' to STDOUT, and those marked 'DEBUG' to a log
      file.</p>
  </dd>
  <dt id="level"><a class="permalink" href="#level">level</a></dt>
  <dd><span class="Li">&quot;level&quot;</span> describes what action to take
      when a message is logged. Just like
      <span class="Li">&quot;tag&quot;</span>, Log::Message will provide a
      default (which is 'log') if neither your config file, nor any explicit
      arguments are given to override it.
    <p class="Pp">See the Log::Message::Handlers manpage to see what handlers
        are available by default and what they do, as well as to how to add your
        own handlers.</p>
  </dd>
  <dt id="remove"><a class="permalink" href="#remove">remove</a></dt>
  <dd>This indicates whether or not to automatically remove the messages from
      the stack when you've retrieved them. The default setting provided by
      Log::Message is '0': do not remove.</dd>
  <dt id="chrono"><a class="permalink" href="#chrono">chrono</a></dt>
  <dd>This indicates whether messages should always be fetched in chronological
      order or not. This simply means that you can choose whether, when
      retrieving items, the item most recently added should be returned first,
      or the one that had been added most long ago.
    <p class="Pp">The default is to return the newest ones first</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Methods"><a class="permalink" href="#Methods">Methods</a></h1>
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
<p class="Pp">This creates a new Log::Message object; The parameters it takes
    are described in the <span class="Li">&quot;Options&quot;</span> section
    below and let it just be repeated that you can use these options like
  this:</p>
<p class="Pp"></p>
<pre>
    my $log = Log::Message-&gt;new( %options );
</pre>
<p class="Pp">as well as during <span class="Li">&quot;use&quot;</span> time,
    like this:</p>
<p class="Pp"></p>
<pre>
    use Log::Message option1 =&gt; value, option2 =&gt; value
</pre>
<p class="Pp">There are but 3 rules to keep in mind:</p>
<ul class="Bl-bullet">
  <li>Provided arguments take precedence over a configuration file.</li>
  <li>Arguments to new take precedence over options provided at
      <span class="Li">&quot;use&quot;</span> time</li>
  <li>An object marked private will always have an empty stack to begin
    with</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="store"><a class="permalink" href="#store">store</a></h2>
<p class="Pp">This will create a new Item object and store it on the stack.</p>
<p class="Pp">Possible arguments you can give to it are:</p>
<dl class="Bl-tag">
  <dt id="message"><a class="permalink" href="#message">message</a></dt>
  <dd>This is the only argument that is required. If no other arguments are
      given, you may even leave off the
      <span class="Li">&quot;message&quot;</span> key. The argument will then
      automatically be assumed to be the message.</dd>
  <dt id="tag~2"><a class="permalink" href="#tag~2">tag</a></dt>
  <dd>The tag to add to this message. If not provided, Log::Message will look in
      your configuration for one.</dd>
  <dt id="level~2"><a class="permalink" href="#level~2">level</a></dt>
  <dd>The level at which this message should be handled. If not provided,
      Log::Message will look in your configuration for one.</dd>
  <dt id="extra"><a class="permalink" href="#extra">extra</a></dt>
  <dd>This is an array ref with arguments passed to the handler for this
      message, when it is called from <i>store()</i>;
    <p class="Pp">The handler will receive them as a normal list</p>
  </dd>
</dl>
<p class="Pp"><i>store()</i> will return true upon success and undef upon
    failure, as well as issue a warning as to why it failed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="retrieve"><a class="permalink" href="#retrieve">retrieve</a></h2>
<p class="Pp">This will retrieve all message items matching the criteria
    specified from the stack.</p>
<p class="Pp">Here are the criteria you can discriminate on:</p>
<dl class="Bl-tag">
  <dt id="tag~3"><a class="permalink" href="#tag~3">tag</a></dt>
  <dd>A regex to which the tag must adhere. For example
      <span class="Li">&quot;qr/\w/&quot;</span>.</dd>
  <dt id="level~3"><a class="permalink" href="#level~3">level</a></dt>
  <dd>A regex to which the level must adhere.</dd>
  <dt id="message~2"><a class="permalink" href="#message~2">message</a></dt>
  <dd>A regex to which the message must adhere.</dd>
  <dt id="amount"><a class="permalink" href="#amount">amount</a></dt>
  <dd>Maximum amount of errors to return</dd>
  <dt id="chrono~2"><a class="permalink" href="#chrono~2">chrono</a></dt>
  <dd>Return in chronological order, or not?</dd>
  <dt id="remove~2"><a class="permalink" href="#remove~2">remove</a></dt>
  <dd>Remove items from the stack upon retrieval?</dd>
</dl>
<p class="Pp">In scalar context it will return the first item matching your
    criteria and in list context, it will return all of them.</p>
<p class="Pp">If an error occurs while retrieving, a warning will be issued and
    undef will be returned.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="first"><a class="permalink" href="#first">first</a></h2>
<p class="Pp">This is a shortcut for retrieving the first item(s) stored on the
    stack. It will default to only retrieving one if called with no arguments,
    and will always return results in chronological order.</p>
<p class="Pp">If you only supply one argument, it is assumed to be the amount
    you wish returned.</p>
<p class="Pp">Furthermore, it can take the same arguments as
    <span class="Li">&quot;retrieve&quot;</span> can.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="last"><a class="permalink" href="#last">last</a></h2>
<p class="Pp">This is a shortcut for retrieving the last item(s) stored on the
    stack. It will default to only retrieving one if called with no arguments,
    and will always return results in reverse chronological order.</p>
<p class="Pp">If you only supply one argument, it is assumed to be the amount
    you wish returned.</p>
<p class="Pp">Furthermore, it can take the same arguments as
    <span class="Li">&quot;retrieve&quot;</span> can.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="flush"><a class="permalink" href="#flush">flush</a></h2>
<p class="Pp">This removes all items from the stack and returns them to the
    caller</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Log::Message::Item, Log::Message::Handlers,
  Log::Message::Config</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">This module by Jos Boumans &lt;kane@cpan.org&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Acknowledgements"><a class="permalink" href="#Acknowledgements">Acknowledgements</a></h1>
<p class="Pp">Thanks to Ann Barcomb for her suggestions.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">This module is copyright (c) 2002 Jos Boumans
    &lt;kane@cpan.org&gt;. All rights reserved.</p>
<p class="Pp">This library is free software; you may redistribute and/or modify
    it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

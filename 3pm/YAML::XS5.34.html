<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>YAML::XS(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">YAML::XS(3)</td>
    <td class="head-vol"><a href=".">User Contributed Perl Documentation</a></td>
    <td class="head-rtitle">YAML::XS(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">YAML::XS - Perl YAML Serialization using XS and libyaml</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use YAML::XS;
    my $yaml = Dump [ 1..4 ];
    my $array = Load $yaml;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Kirill Simonov's <span class="Li">&quot;libyaml&quot;</span> is
    arguably the best YAML implementation. The C library is written precisely to
    the YAML 1.1 specification. It was originally bound to Python and was later
    bound to Ruby.</p>
<p class="Pp">This module is a Perl XS binding to libyaml which offers Perl the
    best YAML support to date.</p>
<p class="Pp">This module exports the functions
    <span class="Li">&quot;Dump&quot;</span>,
    <span class="Li">&quot;Load&quot;</span>,
    <span class="Li">&quot;DumpFile&quot;</span> and
    <span class="Li">&quot;LoadFile&quot;</span>. These functions are intended
    to work exactly like <span class="Li">&quot;YAML.pm&quot;</span>'s
    corresponding functions. Only <span class="Li">&quot;Load&quot;</span> and
    <span class="Li">&quot;Dump&quot;</span> are exported by default.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONFIGURATION"><a class="permalink" href="#CONFIGURATION">CONFIGURATION</a></h1>
<dl class="Bl-tag">
  <dt>$YAML::XS::LoadBlessed (since v0.69)</dt>
  <dd>Default: false.
    <p class="Pp">The default was changed in version 0.81.</p>
    <p class="Pp">When set to false, it will not bless data into objects, which
        can be a security problem, when loading YAML from an untrusted source.
        It will silently ignore the tag and just load the data unblessed.</p>
    <p class="Pp">In PyYAML, this is called SafeLoad.</p>
    <p class="Pp">If set to true, it will load the following YAML as
      objects:</p>
    <p class="Pp"></p>
    <pre>    ---
    local: !Foo::Bar [a]
    perl: !!perl/hash:Foo::Bar { a: 1 }
    regex: !!perl/regexp:Foo::Bar pattern
    </pre>
    <p class="Pp">You can create any kind of object with YAML. The creation
        itself is not the critical part. If the class has a
        <span class="Li">&quot;DESTROY&quot;</span> method, it will be called
        once the object is deleted. An example with File::Temp removing files
        can be found at
        &lt;https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=862373&gt;</p>
  </dd>
  <dt>$YAML::XS::UseCode</dt>
  <dd></dd>
  <dt>$YAML::XS::DumpCode</dt>
  <dd></dd>
  <dt>$YAML::XS::LoadCode</dt>
  <dd>If enabled supports deparsing and evaling of code blocks.
    <p class="Pp">Note that support for loading code was added in version 0.75,
        although <span class="Li">$LoadCode</span> was documented already in
        earlier versions.</p>
  </dd>
  <dt>$YAML::XS::QuoteNumericStrings</dt>
  <dd>When true (the default) strings that look like numbers but have not been
      numified will be quoted when dumping.
    <p class="Pp">This ensures leading that things like leading zeros and other
        formatting are preserved.</p>
  </dd>
  <dt>$YAML::XS::Boolean (since v0.67)</dt>
  <dd>Default is undef.
    <p class="Pp">When set to <span class="Li">&quot;JSON::PP&quot;</span> or
        <span class="Li">&quot;boolean&quot;</span>, the plain (unquoted)
        strings <span class="Li">&quot;true&quot;</span> and
        <span class="Li">&quot;false&quot;</span> will be loaded as
        <span class="Li">&quot;JSON::PP::Boolean&quot;</span> or
        <span class="Li">&quot;boolean.pm&quot;</span> objects. Those objects
        will be dumped again as plain &quot;true&quot; or &quot;false&quot;.</p>
    <p class="Pp">It will try to load JSON::PP or boolean and die if it can't be
        loaded.</p>
    <p class="Pp">With that it's possible to add new &quot;real&quot; booleans
        to a data structure:</p>
    <p class="Pp"></p>
    <pre>      local $YAML::XS::Boolean = &quot;JSON::PP&quot;; # or &quot;boolean&quot;
      my $data = Load(&quot;booltrue: true&quot;);
      $data-&gt;{boolfalse} = JSON::PP::false;
      my $yaml = Dump($data);
      # boolfalse: false
      # booltrue: true
    </pre>
    <p class="Pp">It also lets booleans survive when loading YAML via YAML::XS
        and encode it in JSON via one of the various JSON encoders, which mostly
        support JSON::PP booleans.</p>
    <p class="Pp">Please note that JSON::PP::Boolean and boolean.pm behave a bit
        differently. Ideally you should only use them in boolean context.</p>
    <p class="Pp">If not set, booleans are loaded as special perl variables
        <span class="Li">&quot;PL_sv_yes&quot;</span> and
        <span class="Li">&quot;PL_sv_no&quot;</span>, which have the
        disadvantage that they are readonly, and you can't add those to an
        existing data structure with pure perl.</p>
    <p class="Pp">If you simply need to load &quot;perl booleans&quot; that are
        true or false in boolean context, you will be fine with the default
        setting.</p>
  </dd>
  <dt>$YAML::XS::Indent (since v0.76)</dt>
  <dd>Default is 2.
    <p class="Pp">Sets the number of spaces for indentation for
        <span class="Li">&quot;Dump&quot;</span>.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="USING_YAML::XS_WITH_UNICODE"><a class="permalink" href="#USING_YAML::XS_WITH_UNICODE">USING
  YAML::XS WITH UNICODE</a></h1>
<p class="Pp">Handling unicode properly in Perl can be a pain. YAML::XS only
    deals with streams of utf8 octets. Just remember this:</p>
<p class="Pp"></p>
<pre>    $perl = Load($utf8_octets);
    $utf8_octets = Dump($perl);
</pre>
<p class="Pp">There are many, many places where things can go wrong with
    unicode. If you are having problems, use Devel::Peek on all the possible
    data points.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LIBYAML"><a class="permalink" href="#LIBYAML">LIBYAML</a></h1>
<p class="Pp">You can find out (since v.079) which libyaml version this module
    was built with:</p>
<p class="Pp"></p>
<pre>      my $libyaml_version = YAML::XS::LibYAML::libyaml_version();
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<ul class="Bl-bullet">
  <li>YAML.pm</li>
  <li>YAML::Syck</li>
  <li>YAML::Tiny</li>
  <li>YAML::PP</li>
  <li>YAML::PP::LibYAML</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Ingy d&#x00F6;t Net &lt;ingy@cpan.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">Copyright 2007-2020. Ingy d&#x00F6;t Net.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">See &lt;http://www.perl.com/perl/misc/Artistic.html&gt;</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-05-02</td>
    <td class="foot-os"><a href="..">perl v5.34.0</a></td>
  </tr>
</table>
</body>
</html>

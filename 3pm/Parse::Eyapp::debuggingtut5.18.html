<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Parse::Eyapp::debuggingtut(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Parse::Eyapp::debuggingtut(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Parse::Eyapp::debuggingtut(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Parse::Eyapp::debuggingtut - Solving ambiguities and fixing
    lexical, syntactic and semantic errors</p>
</section>
<section class="Sh">
<h1 class="Sh" id="INTRODUCTION"><a class="permalink" href="#INTRODUCTION">INTRODUCTION</a></h1>
<p class="Pp">The sources of error when programming with
    <span class="Li">&quot;eyapp&quot;</span> are many and various. Some of them
    are minor, as having a nonterminal without production rules or a terminal
    that is never produced by the lexical analyzer. These kind of errors can be
    caught with the help of the <span class="Li">%strict</span> directive.</p>
<p class="Pp">In the following sections we will discuss three main kind of
    errors that correspond to three development stages:</p>
<ul class="Bl-bullet">
  <li>Conflict errors:
    <p class="Pp">Conflicts with the grammar: the grammar is ambiguous or is not
        clear - perhaps due to the fact that
        <span class="Li">&quot;eyapp&quot;</span> uses only a lookahead symbol -
        which sort of tree must be built for some inputs</p>
  </li>
  <li>Tree building errors:
    <p class="Pp">There are no conflicts but the parser does not build the
        syntax tree as expected. May be it rejects correct sentences or accepts
        incorrect ones. Or may be it accepts correct ones but the syntax tree
        has not the shape we want (i.e. we have a precedence problem).</p>
  </li>
  <li>Semantic errors:
    <p class="Pp">We have solved the conflicts and trees are satisfactory but we
        have errors inside the semantic actions.</p>
  </li>
</ul>
<p class="Pp">Each time you discover an error write a test that covers that
    error. Section &quot;TREE EQUALITY&quot; deals with the problem of checking
    if the generated abstract syntax tree has the correct shape and
  attributes.</p>
<p class="Pp">As Andreas Zeller points out in his article &quot;Beautiful
    Debugging&quot; finding the causes of a failing program must follow the
    scientific method:</p>
<dl class="Bl-tag">
  <dt>1. Observe the failure (there are conflicts or ambiguity, there are
    precedence problems, there are semantic errors, the output is wrong)</dt>
  <dd></dd>
  <dt>2. Guess a hypothesis for the failure (if necessary use &quot;eyapp&quot;
    &quot;-v&quot; option, &quot;yydebug&quot;, the Perl debugger, etc. to build
    the hypothesis). If you use continuous testing it is likely related with the
    recently written code.</dt>
  <dd></dd>
  <dt>3. Based on your hypothesis make predictions</dt>
  <dd></dd>
  <dt>3. Using appropriate input tests and the available tools
    (&quot;eyapp&quot; &quot;-v&quot; option, &quot;yydebug&quot;, the Perl
    debugger, etc.) see if your predictions hold. Reject your hypothesis if they
    don't hold.</dt>
  <dd></dd>
  <dt>4. Repeat the last two steps until your hypothesis is confirmed. The
    hypothesis then becomes a theory.</dt>
  <dd></dd>
  <dt>5. Convert the knowledge and informal tests developed during this process
    in a formal test that covers the failure</dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="THE__strict_DIRECTIVE"><a class="permalink" href="#THE__strict_DIRECTIVE">THE
  %strict DIRECTIVE</a></h1>
<p class="Pp">By default, identifiers appearing in the rule section will be
    classified as terminal if they don't appear in the left hand side of any
    production rules.</p>
<p class="Pp">The directive <span class="Li">%strict</span> forces the
    declaration of all tokens. The following
    <span class="Li">&quot;eyapp&quot;</span> program issues a warning:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples/eyapplanguageref$ cat -n bugyapp2.eyp
       1  %strict
       2  %%
       3  expr: NUM;
       4  %%
  pl@nereida:~/LEyapp/examples/eyapplanguageref$ eyapp bugyapp2.eyp
  Warning! Non declared token NUM at line 3 of bugyapp2.eyp
</pre>
<p class="Pp">To keep silent the compiler declare all tokens using one of the
    token declaration directives (<span class="Li">%token</span>,
    <span class="Li">%left</span>, etc.)</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples/eyapplanguageref$ cat -n bugyapp3.eyp
       1  %strict
       2  %token NUM
       3  %%
       4  expr: NUM;
       5  %%
  pl@nereida:~/LEyapp/examples/eyapplanguageref$ eyapp bugyapp3.eyp
  pl@nereida:~/LEyapp/examples/eyapplanguageref$ ls -ltr | tail -1
  -rw-r--r-- 1 pl users 2395 2008-10-02 09:41 bugyapp3.pm
</pre>
<p class="Pp">It is a good practice to use <span class="Li">%strict</span> at
    the beginning of your grammar.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONFLICTS_AND_AMBIGUITIES"><a class="permalink" href="#CONFLICTS_AND_AMBIGUITIES">CONFLICTS
  AND AMBIGUITIES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Understanding_Priorities"><a class="permalink" href="#Understanding_Priorities">Understanding
  Priorities</a></h2>
<p class="Pp">Token and production priorities are used to solve conflicts.
    Recall the main points of yacc-like parsers related to priorities:</p>
<ul class="Bl-bullet">
  <li>The directives
    <p class="Pp"></p>
    <pre>
            %left
            %right
            %nonassoc
    </pre>
    <p class="Pp">can be used in the head section to declare the priority of a
        token</p>
  </li>
  <li>The later the declaration line the higher the priority</li>
  <li>The precedence of a production rule (right hand side) is the precedence of
      the last token in the right hand side</li>
  <li>In a shift-reduce conflict the default action is to shift. This action can
      be changed if the production and the token have explicit priorities</li>
  <li>If the precedence of the production rule is higher the shift-reduce
      conflict is solved in favor of the reduction</li>
  <li>If the precedence of the token is higher the shift-reduce conflict is
      solved in favor of the shift</li>
  <li>If the precedence of the token is the same than the precedence of the
      rule, and is left the shift-reduce conflict is solved in favor of the
      reduction</li>
  <li>If the precedence of the token is the same than the precedence of the
      rule, and is right the shift-reduce conflict is solved in favor of the
      shift</li>
  <li>If the precedence of the token is the same than the precedence of the
      rule, and is nonassoc the presence of a shift-reduce conflict means an
      error. This is used to describe operators, like the operator
      <span class="Li">&quot;.LT.&quot;</span> in FORTRAN, that may not
      associate with themselves. That is, because
    <p class="Pp"></p>
    <pre>
                             A .LT. B .LT. C
    </pre>
    <p class="Pp">is invalid in FORTRAN,
        <span class="Li">&quot;.LT.&quot;</span> would be described with the
        keyword <span class="Li">%nonassoc</span> in eyapp.</p>
  </li>
  <li>The default precedence of a production can be changed using the
      <span class="Li">&quot;%prec TOKEN&quot;</span> directive. Now the rule
      has the precedence and associativity of the specified
      <span class="Li">&quot;TOKEN&quot;</span>.</li>
</ul>
<p class="Pp">The program <span class="Li">&quot;Precedencia.eyp&quot;</span>
    illustrates the way priorities work in
    <span class="Li">&quot;eyapp&quot;</span>:</p>
<p class="Pp"></p>
<pre>
  pl@europa:~/LEyapp/examples/debuggingtut$ eyapp -c Precedencia.eyp
  %token NUM
  %left '@'
  %right '&amp;' dummy
  %tree

  %%

  list:
      | list '\n'
      | list e
  ;
  e:
        %name NUM
        NUM
      | %name AMPERSAND
        e '&amp;' e
      | %name AT
        e '@' e %prec dummy
  ;

  %%
</pre>
<p class="Pp">See an execution:</p>
<p class="Pp"></p>
<pre>
  pl@europa:~/LEyapp/examples/debuggingtut$ ./Precedencia.pm
  Expressions. Press CTRL-D (Unix) or CTRL-Z (Windows) to finish:
  2@3@4
  2@3&amp;4
  2&amp;3@4
  2&amp;3&amp;4
  &lt;CTRL-D&gt;
  AT(AT(NUM(TERMINAL[2]),NUM(TERMINAL[3])),NUM(TERMINAL[4]))
  AT(NUM(TERMINAL[2]),AMPERSAND(NUM(TERMINAL[3]),NUM(TERMINAL[4])))
  AT(AMPERSAND(NUM(TERMINAL[2]),NUM(TERMINAL[3])),NUM(TERMINAL[4]))
  AMPERSAND(NUM(TERMINAL[2]),AMPERSAND(NUM(TERMINAL[3]),NUM(TERMINAL[4])))
</pre>
<p class="Pp">See if you are able to understand the output:</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;2@3@4&quot;</span>: The phrase is interpreted as
      <span class="Li">&quot;(2@3)@4&quot;</span> since the rule
      <span class="Li">&quot;e '@' e&quot;</span> has the precedence of the
      token <span class="Li">&quot;dummy&quot;</span> which is stronger that
      then priority of token <span class="Li">&quot;@&quot;</span>. The conflict
      is solved in favor of the reduction</li>
  <li><span class="Li">&quot;2@3&amp;4&quot;</span>: The rule
      <span class="Li">&quot;e '@' e&quot;</span> has the precedence of
      <span class="Li">&quot;dummy&quot;</span> which is the same than the token
      <span class="Li">&quot;&amp;&quot;</span>. The associativity decides.
      Since they were declared <span class="Li">%right</span> the conflict is
      solved in favor of the shift. The phrase is interpreted as
      <span class="Li">&quot;2@(3&amp;4)&quot;</span></li>
  <li><span class="Li">&quot;2&amp;3@4&quot;</span>: The rule
      <span class="Li">&quot;e '&amp;' e&quot;</span> has more precedence than
      the token <span class="Li">&quot;@&quot;</span>. The phrase is interpreted
      as <span class="Li">&quot;(2&amp;3)@4&quot;</span></li>
  <li><span class="Li">&quot;2&amp;3&amp;4&quot;</span>: Both the rule and the
      token have the same precedence. Since they were declared
      <span class="Li">%right</span>, the conflict is solved in favor of the
      shift. The phrase is interpreted as
      <span class="Li">&quot;2&amp;(3&amp;4)&quot;</span></li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="An__eyapp__Program_with_Errors"><a class="permalink" href="#An__eyapp__Program_with_Errors">An
  &quot;eyapp&quot; Program with Errors</a></h2>
<p class="Pp">The following simplified <span class="Li">&quot;eyapp&quot;</span>
    program has some errors. The generated language is made of lists of
    declarations (<span class="Li">&quot;D&quot;</span> stands for declaration)
    followed by lists of sentences (<span class="Li">&quot;S&quot;</span> stands
    for statement) separated by semicolons:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples/debuggingtut$ cat -n Debug.eyp                   
     1  %{                                                                    
     2  =head1 SYNOPSIS                                                       
     3                                                                        
     4  This grammar has an unsolved shift-reduce conflict.                   
     5                                                                        
     6  Be sure C&lt;DebugTail.pm&gt; is reachable.                                 
     7  Compile it with                                                       
     8                                                                        
     9        eyapp -b '' Debug.eyp                                           
    10                                                                        
    11  See the C&lt;Debug.output&gt; file generated.                               
    12  Execute the generated modulino with:                                  
    13                                                                        
    14        ./Debug.pm -d  # to activate debugging                          
    15        ./Debug.pm -h  # for help
    16
    17  The generated parser will not recognize any input, since its shifts forever.
    18  Try input C&lt;'D; D; S'&gt;.
    19
    20  =head1 See also
    21
    22      http://search.cpan.org/perldoc?Parse::Eyapp::debuggingtut
    23
    24      Debug1.eyp Debug2.eyp DebugLookForward.eyp DebugDynamicResolution.eyp
    25
    26  =cut
    27
    28  our $VERSION = '0.01';
    29  use base q{DebugTail};
    30
    31  %}
    32
    33  %token D S
    34
    35  %%
    36  p:
    37      ds ';' ss
    38    | ss
    39  ;
    40
    41  ds:
    42      D ';' ds
    43    | D          /* this production is never used */
    44  ;
    45
    46  ss:
    47      S ';' ss
    48    | S
    49  ;
    50
    51  %%
    52
    53  __PACKAGE__-&gt;main('Provide a statement like &quot;D; D; S&quot; and press &lt;CR&gt;&lt;CTRL-D&gt;: ') unless caller;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Focusing_in_the_Grammar"><a class="permalink" href="#Focusing_in_the_Grammar">Focusing
  in the Grammar</a></h2>
<p class="Pp">Sometimes the presence of actions, attribute names and support
    code makes more difficult the readability of the grammar. You can use the
    <span class="Li">&quot;-c&quot;</span> option of eyapp, to see only the
    syntactic parts:</p>
<p class="Pp"></p>
<pre>
  $ eyapp -c examples/debuggingtut/Debug.eyp
  %token D S

  %%

  p:
        ds ';' ss
      | ss
  ;
  ds:
        D ';' ds
      | D
  ;
  ss:
        S ';' ss
      | S
  ;

  $
</pre>
<p class="Pp">It is clear now that the language generated by this grammar is
    made of non empty sequences of <span class="Li">&quot;D&quot;</span>
    followed by non empty sequences of &lt;S&gt; separated by semicolons.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Detecting_Conflicts"><a class="permalink" href="#Detecting_Conflicts">Detecting
  Conflicts</a></h2>
<p class="Pp">When compiling this grammar,
    <span class="Li">&quot;eyapp&quot;</span> produces a warning message
    announcing the existence of a conflict:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ eyapp Debug.eyp
  1 shift/reduce conflict (see .output file)
  State 4: shifts:
    to state    8 with ';'
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Studying_the__.output__file"><a class="permalink" href="#Studying_the__.output__file">Studying
  the &quot;.output&quot; file</a></h2>
<p class="Pp">The existence of warnings triggers the creation of a file
    <span class="Li">&quot;Debug.output&quot;</span> containing information
    about the grammar and the syntax analyzer.</p>
<p class="Pp">Let us see the contents of the
    <span class="Li">&quot;Debug.output&quot;</span> file:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ cat -n Debug.output
     1  Warnings:
     2  ---------
     3  1 shift/reduce conflict (see .output file)
     4  State 4: shifts:
     5    to state    8 with ';'
     6
     7  Conflicts:
     8  ----------
     9  State 4 contains 1 shift/reduce conflict
    10
    11  Rules:
    12  ------
    13  0:      $start -&gt; p $end
    14  1:      p -&gt; ds ';' ss
    15  2:      p -&gt; ss
    16  3:      ds -&gt; D ';' ds
    17  4:      ds -&gt; D
    18  5:      ss -&gt; S ';' ss
    19  6:      ss -&gt; S
    20
    21  States:
    22  -------
    23  State 0:
    24
    25          $start -&gt; . p $end      (Rule 0)
    26
    27          D       shift, and go to state 4
    28          S       shift, and go to state 1
    29
    30          p       go to state 2
    31          ss      go to state 3
    32          ds      go to state 5
    33
    ..  .........................................
    55  State 4:
    56
    57          ds -&gt; D . ';' ds        (Rule 3)
    58          ds -&gt; D .       (Rule 4)
    59
    60          ';'     shift, and go to state 8
    61
    62          ';'     [reduce using rule 4 (ds)]
    63
    ..  .........................................
    84  State 8:
    85
    86          ds -&gt; D ';' . ds        (Rule 3)
    87
    88          D       shift, and go to state 4
    89
    90          ds      go to state 11
    91
    ..  .........................................
   112  State 12:
   113
   114          p -&gt; ds ';' ss .        (Rule 1)
   115
   116          $default        reduce using rule 1 (p)
   117
   118
   119  Summary:
   120  --------
   121  Number of rules         : 7
   122  Number of terminals     : 4
   123  Number of non-terminals : 4
   124  Number of states        : 13
</pre>
<p class="Pp">The parser generated by
    <span class="Li">&quot;Parse::Eyapp&quot;</span> is based on a
    <i>deterministic finite automaton</i>. Each state of the automaton
    <i>remembers</i> what production rules are candidates to apply and what have
    been seen from the right hand side of the production rule. The problem,
    according to the warning, occurs in state 4. State 4 contains:</p>
<p class="Pp"></p>
<pre>
    55  State 4:
    56
    57          ds -&gt; D . ';' ds        (Rule 3)
    58          ds -&gt; D .       (Rule 4)
    59
    60          ';'     shift, and go to state 8
    61
    62          ';'     [reduce using rule 4 (ds)]
    63
</pre>
<p class="Pp">An state is a set of production rules with a marker (the dot in
    rules 3 and 4) somewhere in its right hand side. If the parser is in state 4
    is because the production rules <span class="Li">&quot;ds -&gt; D ';'
    ds&quot;</span> and <span class="Li">&quot;ds -&gt; D&quot;</span> are
    potential candidates to build the syntax tree. That they will win or not
    depends on what will happen next when more input is processed.</p>
<p class="Pp">The dot that appears on the right hand side means <i>position</i>
    in our guessing. The fact that <span class="Li">&quot;ds -&gt; D .';'
    ds&quot;</span> is in state 4 means that if the parser is in state 4 we have
    already seen <span class="Li">&quot;D&quot;</span> and we expect to see a
    semicolon followed by <span class="Li">&quot;ds&quot;</span> (or something
    derivable from <span class="Li">&quot;ds&quot;</span>). If such thing
    happens this production will be the right one (will be the <i>handle</i> in
    the jargon). The comment</p>
<p class="Pp"></p>
<pre>
    60          ';'     shift, and go to state 8
</pre>
<p class="Pp">means that if the next token is a semicolon the next state will be
    state 8:</p>
<p class="Pp"></p>
<pre>
    84  State 8:
    85
    86          ds -&gt; D ';' . ds        (Rule 3)
    87
    88          D       shift, and go to state 4
    89
    90          ds      go to state 11
</pre>
<p class="Pp">As we see state 8 has the item <span class="Li">&quot;ds -&gt; D
    ';' . ds&quot;</span> which means that we have already seen a
    <span class="Li">&quot;D&quot;</span> and a semicolon.</p>
<p class="Pp">The fact that <span class="Li">&quot;ds -&gt; D .&quot;</span> is
    in state 4 means that we have already seen
    <span class="Li">&quot;D&quot;</span> and since the dot is at the end of the
    rule, this production can be the right one, even if a semicolon is just
    waiting in the input. An example that it will be correct to
    &quot;reduce&quot; by the rule <span class="Li">&quot;ds -&gt; D
    .&quot;</span> in the presence of a semicolon is given by the input
    <span class="Li">&quot;D ; S&quot;</span>. A rightmost derivation for such
    input is:</p>
<p class="Pp"></p>
<pre>
  p =&gt; ds ; ss =&gt; ds ; S =&gt; D ; S
</pre>
<p class="Pp">that is processed by the <i>LALR</i>(1) algorithm following this
    sequence of actions:</p>
<p class="Pp"></p>
<pre>
 +----------+---------+---------+
 | rule     | read    | input   |
 |          |         | D ; S $ |
 |          | D       |   ; S $ |
 | ds-&gt;d    | ds      |   ; S $ |
 |          | ds ;    |     S $ |
 |          | ds ; S  |       $ |
 | ss-&gt;s    | ds ; ss |       $ |
 | p-&gt;ds;ss | p       |         |
 +----------+---------+---------+
</pre>
<p class="Pp">Since it is correct to reduce in some cases by the production
    <span class="Li">&quot;ds -&gt; D .&quot;</span> and others in which is
    correct to shift the semicolon, <span class="Li">&quot;eyapp&quot;</span>
    complains about a shift/reduce conflict with <span class="Li">';'</span>.
    State 4 has two rules that compete to be the right one:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ eyapp Debug.eyp
  1 shift/reduce conflict (see .output file)
</pre>
<p class="Pp">We can guess that the right item (the rules with the dot, i.e. the
    states of the automaton are called <i>LALR</i>(0) items in the yacc jargon)
    is <span class="Li">&quot;ds -&gt; D .';' ds&quot;</span> and <i>shift to
    state 8</i> consuming the semicolon, expecting to see something derivable
    from <span class="Li">&quot;ds&quot;</span> later or guess that
    <span class="Li">&quot;ds -&gt; D .&quot;</span> is the right <i>LR</i>(0)
    item and <i>reduce</i> for such rule. This is the meaning of the comments in
    state 4:</p>
<p class="Pp"></p>
<pre>
    60          ';'     shift, and go to state 8
    61
    62          ';'     [reduce using rule 4 (ds)]
</pre>
<p class="Pp">To illustrate the problem let us consider the phrases
    <span class="Li">&quot;D;S&quot;</span> and
    <span class="Li">&quot;D;D;S&quot;</span>.</p>
<p class="Pp">For both phrases, after consuming the
    <span class="Li">&quot;D&quot;</span> the parser will go to state 4 and the
    current token will be the semicolon.</p>
<p class="Pp">For the first phrase <span class="Li">&quot;D;S&quot;</span> the
    correct decision is to use rule 4 <span class="Li">&quot;ds -&gt;
    D&quot;</span> (to <i>reduce</i> in the jargon). For the second phrase
    <span class="Li">&quot;D;D;S&quot;</span> the correct decision is to follow
    rule 3 <span class="Li">&quot;ds -&gt; D . ';' ds&quot;</span>.</p>
<p class="Pp">The parser generated by <span class="Li">&quot;eyapp&quot;</span>
    would be able to know which rule is correct for each case if it were allowed
    to look at the token after the semicolon: if it is a
    <span class="Li">&quot;S&quot;</span> is rule 4, if it is a
    <span class="Li">&quot;D&quot;</span> is rule 3. But the parsers generated
    by <span class="Li">&quot;Eyapp&quot;</span> do not lookahead more than the
    next token (this is what the &quot;1&quot; means when we say that
    <span class="Li">&quot;Parse::Eyapp&quot;</span> parsers are <i>LALR</i>(1))
    and therefore is not in condition to decide which production rule
  applies.</p>
<p class="Pp">Unfortunately this is the sort of conflict that can't be solved by
    assigning priorities to the productions and tokens as it was done for the
    calculator example in Parse::Eyapp::eyappintro. If we run the analyzer it
    will refuse to accept correct entries like
    <span class="Li">&quot;D;D;S&quot;</span>:</p>
<p class="Pp"></p>
<pre>
  pl@europa:~/LEyapp/examples/debuggingtut$ eyapp -b '' -o debug.pl Debug.eyp
  1 shift/reduce conflict (see .output file)
  State 4: shifts:
    to state    8 with ';'
  pl@europa:~/LEyapp/examples/debuggingtut$ ./debug.pl
  D;D;S
  ----------------------------------------
  In state 0:
  Stack:[0]
  Need token. Got &gt;D&lt;
  Shift and go to state 4.
  ----------------------------------------
  In state 4:
  Stack:[0,4]
  Need token. Got &gt;;&lt;
  Shift and go to state 8.
  ----------------------------------------
  In state 8:
  Stack:[0,4,8]
  Need token. Got &gt;D&lt;
  Shift and go to state 4.
  ----------------------------------------
  In state 4:
  Stack:[0,4,8,4]
  Need token. Got &gt;;&lt;
  Shift and go to state 8.
  ----------------------------------------
  In state 8:
  Stack:[0,4,8,4,8]
  Need token. Got &gt;S&lt;
  Syntax error near input: 'S' line num 1
</pre>
<p class="Pp">The default parsing action is to shift the token
    <span class="Li">&quot;;&quot;</span> giving priority to the production</p>
<p class="Pp"></p>
<pre>
           ds -&gt; D . ';' ds
</pre>
<p class="Pp">over the production</p>
<p class="Pp"></p>
<pre>
           ds -&gt; D .
</pre>
<p class="Pp">Since no <span class="Li">&quot;ds&quot;</span> production starts
    with <span class="Li">&quot;S&quot;</span>, the presence of
    <span class="Li">&quot;S&quot;</span> is (erroneously) interpreted as an
    error.</p>
<p class="Pp"><i>The Importance of the FOLLOW Set</i></p>
<p class="Pp">You may wonder why the productions</p>
<p class="Pp"></p>
<pre>
  ss:
        S ';' ss
      | S
  ;
</pre>
<p class="Pp">do not also produce a shift-reduce conflict with the semicolon.
    This is because the reduction by <span class="Li">&quot;ss -&gt;
    S&quot;</span> always corresponds to the last
    <span class="Li">&quot;S&quot;</span> in a derivation:</p>
<p class="Pp"></p>
<pre>
   ss =&gt; S ; ss =&gt; S ; S ; ss =&gt; S ; S; S
</pre>
<p class="Pp">and thus, the reduction by <span class="Li">&quot;ss -&gt;
    S&quot;</span> only occurs in the presence of the <span class="Li">&quot;end
    of input&quot;</span> token and never with the semicolon. The FOLLOW set of
    a syntactic variable is the set of tokens that may appear next to such
    variable in some derivation. While the semicolon
    <span class="Li">&quot;;&quot;</span> is in the FOLLOW of
    <span class="Li">&quot;dd&quot;</span>, it isn't in the FOLLOW of
    <span class="Li">&quot;ss&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Solving_Shift-Reduce_Conflicts_by_Factorizing"><a class="permalink" href="#Solving_Shift-Reduce_Conflicts_by_Factorizing">Solving
  Shift-Reduce Conflicts by Factorizing</a></h2>
<p class="Pp">To solve the former conflict the
    <span class="Li">&quot;Eyapp&quot;</span> programmer has to reformulate the
    grammar modifying priorities and reorganizing the rules. Rewriting the
    recursive rule for <span class="Li">&quot;ds&quot;</span> to be let
    recursive solves the conflict:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples/debuggingtut$ sed -ne '/^ds:/,/^;/p' Debug1.eyp | cat -n
     1  ds:
     2      %name D2
     3        ds ';' D
     4    | %name D1
     5        D
     6  ;
</pre>
<p class="Pp">Now, for any phrase matching the pattern <span class="Li">&quot;D
    ; ...&quot;</span> the action to build the tree is to reduce by
    <span class="Li">&quot;ds -&gt; D&quot;</span>.</p>
<p class="Pp">The rightmost reverse derivation for
    <span class="Li">&quot;D;D;S&quot;</span> is:</p>
<p class="Pp"></p>
<pre>
             Derivation                 |             Tree
  --------------------------------------+-----------------------------
  D;D;S &lt;= ds;D;S &lt;= ds;S &lt;= ds;ss &lt;= p |  p(ds(ds(D),';',D),';',ss(S))
</pre>
<p class="Pp">while the rightmost reverse derivation for
    <span class="Li">&quot;D;S&quot;</span> is:</p>
<p class="Pp"></p>
<pre>
             Derivation                 |             Tree
  --------------------------------------+-----------------------------
  D;S &lt;= ds;S &lt;= ds;ss &lt;= p             |      p(ds(D),';',ss(S))
</pre>
<p class="Pp">When we recompile the modified grammar no warnings appear:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ eyapp Debug1.eyp
  pl@nereida:~/LEyapp/examples$
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Solving_Shift-Reduce_Conflicts_By_Looking_Ahead"><a class="permalink" href="#Solving_Shift-Reduce_Conflicts_By_Looking_Ahead">Solving
  Shift-Reduce Conflicts By Looking Ahead</a></h2>
<p class="Pp">The problem here is that
    <span class="Li">&quot;Eyapp/Yapp/Yacc&quot;</span> etc. produce
    <i>LALR</i>(1) parsers. They only look the next token. We can decide how to
    solve the conflict by rewriting the lexical analyzer to peer forward what
    token comes after the semicolon: it now returns
    <span class="Li">&quot;SEMICOLONS&quot;</span> if it is an
    <span class="Li">&quot;S&quot;</span> and
    <span class="Li">&quot;SEMICOLOND&quot;</span> if it is an
    <span class="Li">&quot;D&quot;</span>. Here is a solution based in this
    idea:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples/debuggingtut$ cat -n DebugLookForward.eyp               
     1  /*VIM: set ts=2 */                                                           
     2  %{                                                                           
     3  =head1 SYNOPSIS                                                              
     4                                                                               
     5  See                                                                          
     6                                                                               
     7     http://search.cpan.org/perldoc?Parse::Eyapp::debuggingtut                 
     8     file DebugLookForward.eyp                                                 
     9                                                                               
    10  This grammar fixes the conflicts an bugs in Debug.eyp and Debug1.eyp         
    11                                                                               
    12  Be sure C&lt;DebugTail.pm&gt; is reachable                                         
    13  compile it with                                                              
    14                                                                               
    15        eyapp -b '' DebugLookForward.eyp                                       
    16                                                                               
    17  execute the generated modulino with:                                         
    18                                                                               
    19        ./DebugLookForward.pm -t                                               
    20                                                                               
    21  =head1 See also                                                              
    22                                                                               
    23      Debug.eyp Debug1.eyp Debug2.eyp                                          
    24                                                                               
    25  =cut                                                                         
    26                                                                               
    27  our $VERSION = '0.01';                                                       
    28  use base q{DebugTail};                                                       
    29                                                                               
    30  %}                                                                           
    31                                                                               
    32  %token D S                                                                   
    33  %syntactic token SEMICOLONS SEMICOLOND                                       
    34                                                                               
    35  %tree                                                                        
    36                                                                               
    37  %%                                                                           
    38  p:                                                                           
    39      %name P                                                                  
    40      ds SEMICOLONS ss                                                         
    41    | %name SS
    42      ss
    43  ;
    44
    45  ds:
    46      %name D2
    47        D SEMICOLOND ds
    48    | %name D1
    49        D
    50  ;
    51
    52  ss:
    53      %name S2
    54        S SEMICOLONS ss
    55    | %name S1
    56        S
    57  ;
    58
    59  %%
    60
    61  __PACKAGE__-&gt;lexer(
    62    sub {
    63      my $self = shift;
    64
    65      for (${$self-&gt;input()}) {
    66         s{^(\s+)}{} and $self-&gt;tokenline($1 =~ tr{\n}{});
    67         return ('',undef) unless $_;
    68
    69         return ($1,$1) if s/^([sSDd])//;
    70         return ('SEMICOLOND', 'SEMICOLOND') if s/^;\s*D/D/;
    71         return ('SEMICOLONS', 'SEMICOLONS') if s/^;\s*S/S/;
    72         die &quot;Syntax error at line num ${$self-&gt;tokenline()}: ${substr($_,0,10)}\n&quot;;
    73      }
    74      return ('',undef);
    75    }
    76  );
    77
    78  __PACKAGE__-&gt;main unless caller();
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ERRORS_DURING_TREE_CONSTRUCTION"><a class="permalink" href="#ERRORS_DURING_TREE_CONSTRUCTION">ERRORS
  DURING TREE CONSTRUCTION</a></h1>
<p class="Pp">Though <span class="Li">&quot;Debug1.pm&quot;</span> seems to
    work:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples/debuggingtut$ ./Debug1.pm -t
  Try first &quot;D;S&quot; and then &quot;D; D;  S&quot; (press &lt;CR&gt;&lt;CTRL-D&gt; to finish): D;D;S
  P(D2(D1(TERMINAL[D]),TERMINAL[D]),S1(TERMINAL[S]))
</pre>
<p class="Pp">There are occasions where we observe an abnormal behavior:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples/debuggingtut$ ./Debug1.pm -t
  Try first &quot;D;S&quot; and then &quot;D; D;  S&quot; (press &lt;CR&gt;&lt;CTRL-D&gt; to finish):
  D

  ;

  D

  ;
  S
  Syntax error near end of input line num 3. Expecting (;)
</pre>
<p class="Pp">We can activate the option <span class="Li">&quot;yydebug =&gt;
    0xF&quot;</span> in the call to the parser method
    <span class="Li">&quot;YYParser&quot;</span>. The integer parameter
    <span class="Li">&quot;yydebug&quot;</span> of
    <span class="Li">&quot;new&quot;</span> and
    <span class="Li">&quot;YYParse&quot;</span> controls the level of debugging.
    Different levels of verbosity can be obtained by setting the bits of this
    argument. It works as follows:</p>
<p class="Pp"></p>
<pre>
     /============================================================\
     | Bit Value  | Outputs                                       |
     |------------+-----------------------------------------------|
     |  0x01      |  Token reading (useful for Lexer debugging)   |
     |------------+-----------------------------------------------|
     |  0x02      |  States information                           |
     |------------+-----------------------------------------------|
     |  0x04      |  Driver actions (shifts, reduces, accept...)  |
     |------------+-----------------------------------------------|
     |  0x08      |  Parse Stack dump                             |
     |------------+-----------------------------------------------|
     |  0x10      |  Error Recovery tracing                       |
     \============================================================/
</pre>
<p class="Pp">Let us see what happens when the input is
    <span class="Li">&quot;D;S&quot;</span>. We have introduced some white
    spaces and carriage returns between the terminals:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples/debuggingtut$ ./Debug1.pm -d
  Try first &quot;D;S&quot; and then &quot;D; D;  S&quot; (press &lt;CR&gt;&lt;CTRL-D&gt; to finish):
  D

  ;

  D

  ;
  S
  ----------------------------------------
  In state 0:
  Stack:[0]
  Need token. Got &gt;D&lt;
  Shift and go to state 4.
  ----------------------------------------
  In state 4:
  Stack:[0,4]
  Don't need token.
  Reduce using rule 4 (ds --&gt; D): Back to state 0, then go to state 5.
  ----------------------------------------
  In state 5:
  Stack:[0,5]
  Need token. Got &gt;&lt;
  Syntax error near end of input line num 3. Expecting (;)
</pre>
<p class="Pp">What's going on? After reading the carriage return</p>
<p class="Pp"></p>
<pre>
   Need token. Got &gt;D&lt;
</pre>
<p class="Pp">the parser receives an end of file. XWhy?. Something is going
    wrong in the communications between lexical analyzer and parser. Let us
    review the lexical analyzer:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples/debuggingtut$ sed -ne '/lexer/,/^)/p' Debug1.eyp | cat -n
     1  __PACKAGE__-&gt;lexer(
     2    sub {
     3      my $self = shift;
     4
     5      for (${$self-&gt;input()}) {  # contextualize
     6          s{^(\s)}{} and $self-&gt;tokenline($1 =~ tr{\n}{});
     7
     8          return ('', undef) unless $_;
     9          return ($1, $1) if s/^(.)//;
    10      }
    11      return ('', undef);
    12    }
    13  );
</pre>
<p class="Pp">The error is at line 6. Only a single white space is eaten! The
    second carraige return in the input does not match lines 8 and 9 and the
    contextualizing <span class="Li">&quot;for&quot;</span> finishes. Line 11
    then unconditionally returns the
    <span class="Li">&quot;('',undef)&quot;</span> signaling the end of
  input.</p>
<p class="Pp">The grammar in file <span class="Li">&quot;Debug2.eyp&quot;</span>
    fixes the problem: Now the analysis seems to work for this kind of
  input:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples/debuggingtut$ eyapp -b '' Debug2.eyp                     
  pl@nereida:~/LEyapp/examples/debuggingtut$ ./Debug2.pm -t -d                          
  Provide a statement like &quot;D; D; S&quot; and press &lt;CR&gt;&lt;CTRL-D&gt;:                            
  D                                                                                     

  ;

  D

  ;
  S
  ----------------------------------------
  In state 0:                             
  Stack:[0]                               
  Need token. Got &gt;D&lt;                     
  Shift and go to state 4.                
  ----------------------------------------
  In state 4:                             
  Stack:[0,4]                             
  Don't need token.                       
  Reduce using rule 4 (ds --&gt; D): Back to state 0, then go to state 5.
  ----------------------------------------                            
  In state 5:                                                         
  Stack:[0,5]                                                         
  Need token. Got &gt;;&lt;                                                 
  Shift and go to state 8.                                            
  ----------------------------------------                            
  In state 8:
  Stack:[0,5,8]
  Need token. Got &gt;D&lt;
  Shift and go to state 11.
  ----------------------------------------
  In state 11:
  Stack:[0,5,8,11]
  Don't need token.
  Reduce using rule 3 (ds --&gt; ds ; D): Back to state 0, then go to state 5.
  ----------------------------------------
  In state 5:
  Stack:[0,5]
  Need token. Got &gt;;&lt;
  Shift and go to state 8.
  ----------------------------------------
  In state 8:
  Stack:[0,5,8]
  Need token. Got &gt;S&lt;
  Shift and go to state 1.
  ----------------------------------------
  In state 1:
  Stack:[0,5,8,1]
  Need token. Got &gt;&lt;
  Reduce using rule 6 (ss --&gt; S): Back to state 8, then go to state 10.
  ----------------------------------------
  In state 10:
  Stack:[0,5,8,10]
  Don't need token.
  Reduce using rule 1 (p --&gt; ds ; ss): Back to state 0, then go to state 2.
  ----------------------------------------
  In state 2:
  Stack:[0,2]
  Shift and go to state 7.
  ----------------------------------------
  In state 7:
  Stack:[0,2,7]
  Don't need token.
  Accept.
  P(D2(D1(TERMINAL[D]),TERMINAL[D]),S1(TERMINAL[S]))
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="THE_LR_PARSING_ALGORITHM:_UNDERSTANDING_THE_OUTPUT_OF__yydebug_"><a class="permalink" href="#THE_LR_PARSING_ALGORITHM:_UNDERSTANDING_THE_OUTPUT_OF__yydebug_">THE
  LR PARSING ALGORITHM: UNDERSTANDING THE OUTPUT OF &quot;yydebug&quot;</a></h1>
<p class="Pp">The <span class="Li">&quot;YYParse&quot;</span> methods implements
    the generic LR parsing algorithm. It very much works
    <span class="Li">&quot;Parse::Yapp::YYParse&quot;</span> and as yacc/bison
    <span class="Li">&quot;yyparse&quot;</span>. It accepts almost the same
    arguments as <span class="Li">&quot;Class-&gt;new&quot;</span> (Being
    <span class="Li">&quot;Class&quot;</span> the name of the generated
  class).</p>
<p class="Pp">The parser uses two tables and a stack. The two tables are called
    the <i>action</i> table and the <i>goto</i> table. The stack is used to keep
    track of the states visited.</p>
<p class="Pp">At each step the generated parser consults the
    <span class="Li">&quot;action&quot;</span> table and takes one decision: To
    shift to a new state consuming one token (and pushing the current state in
    the stack) or to reduce by some production rule. In the last case the parser
    pops from its stack as many states as symbols are on the right hand side of
    the production rule. Here is a Perl/C like pseudocode summarizing the
    activity of <span class="Li">&quot;YYParse&quot;</span>:</p>
<p class="Pp"></p>
<pre>
     1   my $parser = shift; # The parser object
     2   push(@stack, $parser-&gt;{startstate});
     3   $b = $parser-&gt;YYLexer(); # Get the first token
     4   FOREVER: {
     5     $s = top(0);  # Get the state on top of the stack
     6     $a = $b;
     7     switch ($parser-&gt;action[$s-&gt;state][$a]) {
     8       case &quot;shift t&quot; : 
     9         my $t;
    10         $t-&gt;{state} = t;
    11         $t-&gt;{attr}  = $a-&gt;{attr};
    12         push($t); 
    13         $b = $parser-&gt;YYLexer(); # Call the lexical analyzer
    14         break;
    15       case &quot;reduce A-&gt;alpha&quot; : 
    16         # Call the semantic action with the attributes of the rhs as args
    17         my $semantic  = $parser-&gt;Semantic{A -&gt;alpha}; # The semantic action
    18         my $r;
    19         $r-&gt;{attr} = $semantic-&gt;($parser, top(|alpha|-1)-&gt;attr, ... , top(0)-&gt;attr); 
    20  
    21         # Pop as many states as symbols on the rhs of A-&gt;alpha
    22         pop(|alpha|);  
    23  
    24         # Goto next state 
    25         $r-&gt;{state} = $parser-&gt;goto[top(0)][A]; 
    26         push($r); 
    27         break;
    28       case &quot;accept&quot; : return (1); 
    29       default : $parser-&gt;YYError(&quot;syntax error&quot;); 
    30     }
    31     redo FOREVER;
    32   }
</pre>
<p class="Pp">Here <span class="Li">&quot;|alpha|&quot;</span> stands for the
    length of <span class="Li">&quot;alpha&quot;</span>. Function
    <span class="Li">top(k)</span> returns the state in position
    <span class="Li">&quot;k&quot;</span> from the top of the stack, i.e. the
    state at depth <span class="Li">&quot;k&quot;</span>. Function
    <span class="Li">pop(k)</span> extracts
    <span class="Li">&quot;k&quot;</span> states from the stack. The call
    <span class="Li">&quot;$state-&gt;attr&quot;</span> returns the attribute
    associated with <span class="Li">$state</span>. The call
    <span class="Li">&quot;$parser-&gt;Semantic{A -&gt;alpha}&quot;</span>
    returns the semantic action associated with production
    <span class="Li">&quot;A -&gt;alpha&quot;</span>.</p>
<p class="Pp">Let us see a trace for the small grammar in
    <span class="Li">&quot;examples/debuggingtut/aSb.yp&quot;</span>:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ /usr/local/bin/paste.pl aSb.yp aSb.output | head -5
  %%                                             | Rules:
  S:                 { print &quot;S -&gt; epsilon\n&quot; }  | ------
      |   'a' S 'b'  { print &quot;S -&gt; a S b\n&quot; }    | 0:    $start -&gt; S $end
  ;                                              | 1:    S -&gt; /* empty */
  %%                                             | 2:    S -&gt; 'a' S 'b'
</pre>
<p class="Pp">The tables in file <span class="Li">&quot;aSb.output&quot;</span>
    describe the actions and transitions to take:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ cat -n aSb.output
     .  .........................................
     7  States:
     8  -------
     9  State 0:
    10
    11          $start -&gt; . S $end      (Rule 0)
    12
    13          'a'     shift, and go to state 2
    14
    15          $default        reduce using rule 1 (S)
    16
    17          S       go to state 1
    18
    19  State 1:
    20
    21          $start -&gt; S . $end      (Rule 0)
    22
    23          $end    shift, and go to state 3
    24
    25  State 2:
    26
    27          S -&gt; 'a' . S 'b'        (Rule 2)
    28
    29          'a'     shift, and go to state 2
    30
    31          $default        reduce using rule 1 (S)
    32
    33          S       go to state 4
    34
    35  State 3:
    36
    37          $start -&gt; S $end .      (Rule 0)
    38
    39          $default        accept
    40
    41  State 4:
    42
    43          S -&gt; 'a' S . 'b'        (Rule 2)
    44
    45          'b'     shift, and go to state 5
    46
    47  State 5:
    48
    49          S -&gt; 'a' S 'b' .        (Rule 2)
    50
    51          $default        reduce using rule 2 (S)
    52
    53
    54  Summary:
    55  --------
    56  Number of rules         : 3
    57  Number of terminals     : 3
    58  Number of non-terminals : 2
    59  Number of states        : 6
</pre>
<p class="Pp">When executed with <span class="Li">&quot;yydebug&quot;</span> set
    and input <span class="Li">&quot;aabb&quot;</span> we obtain the following
    output:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples/debuggingtut$ eyapp -b '' -o use_aSb.pl aSb
  pl@nereida:~/LEyapp/examples/debuggingtut$ ./use_aSb.pl -d
  Provide a statement like &quot;a a b b&quot; and press &lt;CR&gt;&lt;CTRL-D&gt;: aabb
  ----------------------------------------                       
  In state 0:                                                    
  Stack:[0]                                                      
  Need token. Got &gt;a&lt;                                            
  Shift and go to state 2.                                       
  ----------------------------------------                       
  In state 2:                                                    
  Stack:[0,2]                                                    
  Need token. Got &gt;a&lt;
  Shift and go to state 2.
  ----------------------------------------
  In state 2:
  Stack:[0,2,2]
  Need token. Got &gt;b&lt;
  Reduce using rule 1 (S --&gt; /* empty */): S -&gt; epsilon
  Back to state 2, then go to state 4.
  ----------------------------------------
  In state 4:
  Stack:[0,2,2,4]
  Shift and go to state 5.
  ----------------------------------------
  In state 5:
  Stack:[0,2,2,4,5]
  Don't need token.
  Reduce using rule 2 (S --&gt; a S b): S -&gt; a S b
  Back to state 2, then go to state 4.
  ----------------------------------------
</pre>
<p class="Pp">As a result of reducing by rule 2 the three last visited states
    are popped from the stack, and the stack becomes
    <span class="Li">&quot;[0,2]&quot;</span>. But that means that we are now in
    state 2 seeing a <span class="Li">&quot;S&quot;</span>. If you look at the
    table above being in state 2 and seeing a
    <span class="Li">&quot;S&quot;</span> we go to state 4.</p>
<p class="Pp"></p>
<pre>
  In state 4:
  Stack:[0,2,4]
  Need token. Got &gt;b&lt;
  Shift and go to state 5.
  ----------------------------------------
  In state 5:
  Stack:[0,2,4,5]
  Don't need token.
  Reduce using rule 2 (S --&gt; a S b): S -&gt; a S b
  Back to state 0, then go to state 1.
  ----------------------------------------
  In state 1:
  Stack:[0,1]
  Need token. Got &gt;&lt;
  Shift and go to state 3.
  ----------------------------------------
  In state 3:
  Stack:[0,1,3]
  Don't need token.
  Accept.
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="ERRORS_INSIDE_SEMANTIC_ACTIONS"><a class="permalink" href="#ERRORS_INSIDE_SEMANTIC_ACTIONS">ERRORS
  INSIDE SEMANTIC ACTIONS</a></h1>
<p class="Pp">A third type of error occurs when the code inside a semantic
    action doesn't behave as expected.</p>
<p class="Pp">The semantic actions are translated in anonymous methods of the
    parser object. Since they are anonymous we can't use breakpoints as</p>
<p class="Pp"></p>
<pre>
  b subname # stop when arriving at sub ''name''
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre>
  c subname  # contine up to reach sub ''name''
</pre>
<p class="Pp">Furthermore the file loaded by the client program is the generated
    <span class="Li">&quot;.pm&quot;</span>. The code in the generated module
    <span class="Li">&quot;Debug.pm&quot;</span> is alien to us - Was
    automatically generated by <span class="Li">&quot;Parse::Eyapp&quot;</span>
    - and it can be difficult to find where our inserted semantic actions
  are.</p>
<p class="Pp">To watch the execution of a semantic action is simple: We use the
    debugger <span class="Li">&quot;f file.eyp &quot;</span> option to switch
    the viewing filename to our grammar file. The following session uses the
    example in the directory
    <span class="Li">&quot;examples/Calculator&quot;</span>:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples/Calculator$ perl -wd scripts/calc.pl
  Loading DB routines from perl5db.pl version 1.3
  Editor support available.
  Enter h or `h h' for help, or `man perldebug' for more help.

  main::(scripts/calc.pl:8):      Math::Calc-&gt;main();
    DB&lt;1&gt; f lib/Math/Calc.eyp
  1       2       3       4       5       6       7       #line 8 &quot;lib/Math/Calc.eyp&quot;
  8
  9:      use base q{Math::Tail};
  10:     my %s; # symbol table
</pre>
<p class="Pp">Lines 37 to 41 contain the semantic action associated with the
    production <span class="Li">&quot;exp -&gt; VAR&quot;</span> (see file
    <span class="Li">&quot;examples/Calculator/lib/Math/Calc.eyp&quot;</span>):</p>
<p class="Pp"></p>
<pre>
    DB&lt;2&gt; l 37,41
  37:            my $id = $VAR-&gt;[0];
  38:            my $val = $s{$id};
  39:            $_[0]-&gt;semantic_error(&quot;Accesing undefined variable $id at line $VAR-&gt;[1].\n&quot;)
  40             unless defined($val);
  41:            return $val;
</pre>
<p class="Pp">now we set a break at line 37, to see what happens when a non
    initialized variable is used:</p>
<p class="Pp"></p>
<pre>
    DB&lt;3&gt; b 37
</pre>
<p class="Pp">We issue now the command <span class="Li">&quot;c&quot;</span>
    (continue). The execution continues until line 37 of
    <span class="Li">&quot;lib/Math/Calc.eyp&quot;</span> is reached:</p>
<p class="Pp"></p>
<pre>
    DB&lt;4&gt; c
  Expressions. Press CTRL-D (Unix) or CTRL-Z (Windows) to finish:
  a = 2+b                                            # user input
  Math::Calc::CODE(0x191da98)(lib/Math/Calc.eyp:37):
  37:            my $id = $VAR-&gt;[0];
</pre>
<p class="Pp">Now we can issue any debugger commands (like
    <span class="Li">&quot;x&quot;</span>,
    <span class="Li">&quot;p&quot;</span>, etc.) to investigate the internal
    state of our program and determine what are the reasons of any abnormal
    behavior.</p>
<p class="Pp"></p>
<pre>
    DB&lt;4&gt; n
  Math::Calc::CODE(0x191da98)(lib/Math/Calc.eyp:38):
  38:            my $val = $s{$id};
    DB&lt;4&gt; x $id
  0  'b'
    DB&lt;5&gt; x %s
    empty array
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SOLVING_REDUCE-REDUCE_CONFLICTS"><a class="permalink" href="#SOLVING_REDUCE-REDUCE_CONFLICTS">SOLVING
  REDUCE-REDUCE CONFLICTS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Reduce-Reduce_Conflict:_Default_rules"><a class="permalink" href="#Reduce-Reduce_Conflict:_Default_rules">Reduce-Reduce
  Conflict: Default rules</a></h2>
<p class="Pp">Most of the time reduce-reduce conflicts are due to some ambiguity
    in the grammar, as it is the case for this minimal example:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples/debuggingtut$ sed -ne '/%%/,/%%/p' minimalrr.eyp | cat -n
     1  %%
     2  s:
     3        %name S_is_a
     4        'a'
     5      | A
     6  ;
     7  A:
     8        %name A_is_a
     9        'a'
    10  ;
    11
    12  %%
</pre>
<p class="Pp">In case of a reduce-reduce conflict, Parse::Eyapp reduces using
    the first production in the text:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples/debuggingtut$ eyapp -b '' minimalrr.eyp
  1 reduce/reduce conflict
  pl@nereida:~/LEyapp/examples/debuggingtut$ ./minimalrr.pm -t
  Try &quot;a&quot; and press &lt;CR&gt;&lt;CTRL-D&gt;: a
  S_is_a
</pre>
<p class="Pp">If we change the order of the productions</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples/debuggingtut$ sed -ne '/%start/,40p' minimalrr2.eyp | cat -n
     1  %start s
     2
     3  %%
     4  A:
     5        %name A_is_a
     6        'a'
     7  ;
     8
     9  s:
    10        %name S_is_a
    11        'a'
    12      | %name A
    13        A
    14  ;
    15  %%
</pre>
<p class="Pp">the selected production changes:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples/debuggingtut$ eyapp -b '' minimalrr2
  1 reduce/reduce conflict
  pl@nereida:~/LEyapp/examples/debuggingtut$ ./minimalrr2.pm -t
  Try &quot;a&quot; and press &lt;CR&gt;&lt;CTRL-D&gt;: a
  A(A_is_a)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Reduce-Reduce_conflicts:_typical_errors"><a class="permalink" href="#Reduce-Reduce_conflicts:_typical_errors">Reduce-Reduce
  conflicts: typical errors</a></h2>
<p class="Pp">In this example the programmer has attempted to define a language
    made of mixed lists <span class="Li">&quot;ID&quot;</span>s and
    <span class="Li">&quot;NUM&quot;</span>bers :</p>
<p class="Pp"></p>
<pre>
  ~/LEyapp/examples/debuggingtut$ eyapp -c typicalrr.eyp 
  %token ID NUM 
  %tree

  %%

  s:
        /* empty */
      | s ws
      | s ns 
  ;
  ns:
        /* empty */
      | ns NUM 
  ;
  ws:
        /* empty */
      | ws ID 
  ;

  %%
</pre>
<p class="Pp">The grammar has several reduce-reduce conflicts:</p>
<p class="Pp"></p>
<pre>
  ~/LEyapp/examples/debuggingtut$ eyapp -b '' typicalrr.eyp 
  3 shift/reduce conflicts and 3 reduce/reduce conflicts
</pre>
<p class="Pp">There are several sources of ambiguity in this grammar:</p>
<ul class="Bl-bullet">
  <li>Statments like
    <p class="Pp"></p>
    <pre>
              NUM NUM NUM
    </pre>
    <p class="Pp">are ambiguous. The following two left-most derivations
      exists:</p>
    <p class="Pp"></p>
    <pre>
             s =*=&gt; ns ns =*=&gt; NUM NUM ns =&gt; NUM NUM NUM
and

             s =*=&gt; ns ns =*=&gt; NUM ns =*=&gt; NUM NUM NUM
    </pre>
    <p class="Pp">the same with phrases like <span class="Li">&quot;ID ID
        ID&quot;</span></p>
  </li>
  <li>The empty word can be generated in many ways. For example:
    <p class="Pp"></p>
    <pre>
        s =&gt; empty
    </pre>
    <p class="Pp">or</p>
    <p class="Pp"></p>
    <pre>
        s =&gt; s ns =&gt; s empty =&gt; empty
    </pre>
    <p class="Pp">etc.</p>
  </li>
</ul>
<p class="Pp">The generated parser loops forever if feed with a list of
    identifiers:</p>
<p class="Pp"></p>
<pre>
  ~/LEyapp/examples/debuggingtut$ ./typicalrr.pm -d
  Try inputs &quot;4 5&quot;,  &quot;a b&quot; and &quot;4 5 a b&quot;(press &lt;CR&gt;&lt;CTRL-D&gt; to finish): ab
  ----------------------------------------
  In state 0:
  Stack:[0]
  Don't need token.
  Reduce using rule 1 (s --&gt; /* empty */): Back to state 0, then go to state 1.
  ----------------------------------------
  In state 1:
  Stack:[0,1]
  Need token. Got &gt;ID&lt;
  Reduce using rule 4 (ns --&gt; /* empty */): Back to state 1, then go to state 2.
  ----------------------------------------
  In state 2:
  Stack:[0,1,2]
  Reduce using rule 3 (s --&gt; s ns): Back to state 0, then go to state 1.
  ----------------------------------------
  In state 1:
  Stack:[0,1]
  Reduce using rule 4 (ns --&gt; /* empty */): Back to state 1, then go to state 2.
  ----------------------------------------
  In state 2:
  Stack:[0,1,2]
  Reduce using rule 3 (s --&gt; s ns): Back to state 0, then go to state 1.
  ----------------------------------------
  ^C
</pre>
<p class="Pp">The problem is easily solved designing an equivalent non ambiguous
    grammar:</p>
<p class="Pp"></p>
<pre>
  pl@europa:~/LEyapp/examples/debuggingtut$ cat -n correcttypicalrr.eyp
     1  %token ID NUM
     2
     3  %%
     4  s:
     5        /* empty */
     6      | s ID
     7      | s NUM
     8  ;
     9
    10  %%
</pre>
<p class="Pp">See also these files in the
    <span class="Li">&quot;examples/debuggintut/&quot;</span> directory:</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;typicalrr2.eyp&quot;</span> is equivalent to
      <span class="Li">&quot;typicalrr.eyp&quot;</span> but has
      <span class="Li">%name</span> directives, to have a nicer tree</li>
  <li><span class="Li">&quot;typicalrr_fixed.eyp&quot;</span> eliminates the
      ambiguity using a combination of priorities and elimination of the
      redundant empty productions. Explicit precedence via
      <span class="Li">%prec</span> directives are given to produce right
      recursive lists</li>
  <li><span class="Li">&quot;typicalrr_fixed_rightrecursive.eyp&quot;</span> is
      almost equal to <span class="Li">&quot;typicalrr_fixed.eyp&quot;</span>
      but eliminates the of <span class="Li">%prec</span> directives by making
      the list production right recursive</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Giving_an_Explicit_Priority_to_the_End-of-Input_Token"><a class="permalink" href="#Giving_an_Explicit_Priority_to_the_End-of-Input_Token">Giving
  an Explicit Priority to the End-of-Input Token</a></h2>
<p class="Pp">We can also try to disambiguate the former example using
    priorities. For that we need to give an explicit priority to the
    end-of-input token. To refer to the end-of-input token in the header
    section, use the empty string <span class="Li">''</span>. In the file
    <span class="Li">&quot;examples/debuggingtut/typicalrrwithprec.eyp&quot;</span>
    there is a priority based solution:</p>
<p class="Pp"></p>
<pre>
  ~/LEyapp/examples/debuggingtut$ eyapp -c typicalrrwithprec.eyp
  %right LNUM 
  %right NUM 
  %right ID 
  %right '' # The string '' refers to the 'End of Input' token
  %tree bypass

  %%

  s:
        %name EMPTY
        /* empty */%prec ''
      | %name LIST
        s ws
      | %name LIST
        s ns 
  ;
  ns:
        %name EMPTYNUM
        /* empty */%prec NUM
      | %name NUMS
        NUM ns 
  ;
  ws:
        %name EMPTYID
        /* empty */%prec LNUM
      | %name IDS
        ID ws 
  ;

  %%
</pre>
<p class="Pp">Observe the use of <span class="Li">&quot;%right ''&quot;</span>
    in the header section: it gives a priority to the end-of-input token.</p>
<p class="Pp"></p>
<pre>
  ~/LEyapp/examples/debuggingtut$ ./typicalrrwithprec.pm -t
  Try &quot;4 5 a b 2 3&quot; (press &lt;CR&gt;&lt;CTRL-D&gt; to finish): 4 5 a b 2 3
  ^D
  LIST(
    LIST(
      LIST(
        EMPTY,
        NUMS(
          TERMINAL[4],
          NUMS(
            TERMINAL[5],
            EMPTYNUM
          )
        )
      ),
      IDS(
        TERMINAL[a],
        IDS(
          TERMINAL[b],
          EMPTYID
        )
      )
    ),
    NUMS(
      TERMINAL[2],
      NUMS(
        TERMINAL[3],
        EMPTYNUM
      )
    )
  )
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Reduce-Reduce_conflict:_Enumerated_versus_Range_declarations_in_Extended_Pascal"><a class="permalink" href="#Reduce-Reduce_conflict:_Enumerated_versus_Range_declarations_in_Extended_Pascal">Reduce-Reduce
  conflict: Enumerated versus Range declarations in Extended Pascal</a></h2>
<p class="Pp">The grammar in file
    <span class="Li">&quot;examples/debuggintut/pascalenumeratedvsrange.eyp&quot;</span>:</p>
<p class="Pp"></p>
<pre>
  ~/LEyapp/examples/debuggingtut$ eyapp -c pascalenumeratedvsrange.eyp 
  %token TYPE DOTDOT ID 
  %left '+' '-' 
  %left '*' '/' 

  %%

  type_decl:
        TYPE ID '=' type ';' 
  ;
  type:
        '(' id_list ')'
      | expr DOTDOT expr 
  ;
  id_list:
        ID
      | id_list ',' ID 
  ;
  expr:
        '(' expr ')'
      | expr '+' expr
      | expr '-' expr
      | expr '*' expr
      | expr '/' expr
      | ID 
  ;

  %%
</pre>
<p class="Pp">introduces a problem that arises in the declaration of enumerated
    and subrange types in Pascal:</p>
<p class="Pp"></p>
<pre>
  type subrange = lo .. hi;
  type enum = (a, b, c);
</pre>
<p class="Pp">The original language standard allows only numeric literals and
    constant identifiers for the subrange bounds (`lo' and `hi'), but Extended
    Pascal and many other Pascal implementations allow arbitrary expressions
    there. This gives rise to the following situation, containing a superfluous
    pair of parentheses:</p>
<p class="Pp"></p>
<pre>
     type subrange = (a) .. b;
</pre>
<p class="Pp">Compare this to the following declaration of an enumerated type
    with only one value:</p>
<p class="Pp"></p>
<pre>
      type enum = (a);
</pre>
<p class="Pp">These two declarations look identical until the
    <span class="Li">&quot;..&quot;</span> token. With normal <i>LALR</i>(1)
    one-token look-ahead it is not possible to decide between the two forms when
    the identifier <span class="Li">&quot;a&quot;</span> is parsed. It is,
    however, desirable for a parser to decide this, since in the latter case
    <span class="Li">&quot;a&quot;</span> must become a new identifier to
    represent the enumeration value, while in the former case
    <span class="Li">&quot;a&quot;</span> must be evaluated with its current
    meaning, which may be a constant or even a function call.</p>
<p class="Pp">The consequence is a reduce-reduce conflict, which is summarized
    in this state of the LALR automata:</p>
<p class="Pp"></p>
<pre>
  State 10:

    id_list -&gt; ID . (Rule 4)
    expr -&gt; ID .    (Rule 11)

    ')' [reduce using rule 11 (expr)]
    ')' reduce using rule 4 (id_list)
    ',' reduce using rule 4 (id_list)
    $default    reduce using rule 11 (expr)
</pre>
<p class="Pp">The grammar in file
    <span class="Li">&quot;pascalenumeratedvsrangesolvedvialex.eyp&quot;</span>
    solves this particular problem by looking ahead in the lexical analyzer: if
    the parenthesis is followed by a sequence of comma separated identifiers
    finished by the closing parenthesis and a semicolon we can conclude that is
    a enumerated type declaration. For more details, have a look at the file.
    Another solution using the postponed conflict resolution strategy can be
    found in file
    <span class="Li">&quot;pascalenumeratedvsrangesolvedviadyn.eyp&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Reduce-Reduce_Conflicts_with_Unambiguous_Grammars"><a class="permalink" href="#Reduce-Reduce_Conflicts_with_Unambiguous_Grammars">Reduce-Reduce
  Conflicts with Unambiguous Grammars</a></h2>
<p class="Pp">Though not so common, it may occur that a reduce-reduce conflict
    is not due to ambiguity but to the limitations of the <i>LALR</i>(1)
    algorithm. The following example illustrates the point:</p>
<p class="Pp"></p>
<pre>
  pl@europa:~/LEyapp/examples/debuggingtut$ cat -n rrconflictnamefirst.eyp
     1  %token VAR ',' ':'
     2
     3  %{
     4  use base q{Tail};
     5  %}
     6
     7  %%
     8  def:    param_spec return_spec ','
     9          ;
    10  param_spec:
    11               type
    12          |    name_list ':' type
    13          ;
    14  return_spec:
    15               type
    16          |    name ':' type
    17          ;
    18  name:        VAR
    19          ;
    20  type:        VAR
    21          ;
    22  name_list:
    23               name
    24          |    name ',' name_list
    25          ;
    26  %%
    27
    28  __PACKAGE__-&gt;main unless caller();
</pre>
<p class="Pp">This non ambiguous grammar generates a language of sequences
  like</p>
<p class="Pp"></p>
<pre>
                 a, b : e f : e,
</pre>
<p class="Pp">The conflict is due to the final comma in:</p>
<p class="Pp"></p>
<pre>
      def:    param_spec return_spec ','
</pre>
<p class="Pp">If you suppress such comma there is no conflict (try it). When
    compiling with eyapp we get the warning:</p>
<p class="Pp"></p>
<pre>
  pl@europa:~/LEyapp/examples/debuggingtut$ eyapp rrconflictnamefirst.eyp
  1 reduce/reduce conflict
</pre>
<p class="Pp">Editing the <span class="Li">&quot;.output&quot;</span> file we
    can see the conflict is in state 2:</p>
<p class="Pp"></p>
<pre>
   46 State 2:
   47
   48         name -&gt; VAR .   (Rule 6)
   49         type -&gt; VAR .   (Rule 7)
   50
   51         ','     [reduce using rule 7 (type)]
   52         VAR     reduce using rule 7 (type)
   53         $default        reduce using rule 6 (name)
</pre>
<p class="Pp">If we look at the grammar we can see that a reduction by</p>
<p class="Pp"></p>
<pre>
                   type -&gt; VAR .
</pre>
<p class="Pp">may occur with a comma as incoming token but only after the
    reduction by <span class="Li">&quot;param_spec&quot;</span> has taken place.
    The problem is that the automaton forgets about it. Look the automaton
    transitions in the <span class="Li">&quot;.outputfile&quot;</span>. By
    making explicit the difference between the first and second
    <span class="Li">&quot;type&quot;</span> we solve the conflict:</p>
<p class="Pp"></p>
<pre>
  pl@europa:~/LEyapp/examples/debuggingtut$ cat -n rrconflictnamefirst_fix1.eyp
     1  %token VAR ',' ':'
     2
     3  %{
     4  use base q{Tail};
     5  %}
     6
     7  %%
     8  def:    param_spec return_spec ','
     9          ;
    10  param_spec:
    11               type
    12          |    name_list ':' type
    13          ;
    14  return_spec:
    15               typeafter
    16          |    name ':' typeafter
    17          ;
    18  name:        VAR
    19          ;
    20  type:        VAR
    21          ;
    22  typeafter:        VAR
    23          ;
    24  name_list:
    25               name
    26          |    name ',' name_list
    27          ;
    28  %%
    29
    30  __PACKAGE__-&gt;main unless caller();
</pre>
<p class="Pp">A reduce-reduce conflict is solved in favor of the first
    production found in the text. If we execute the grammar with the conflict
    <span class="Li">&quot;./rrconflictnamefirst.pm&quot;</span>, we get the
    correct behavior:</p>
<p class="Pp"></p>
<pre>
  pl@europa:~/LEyapp/examples/debuggingtut$ eyapp -b '' rrconflictnamefirst.eyp
  1 reduce/reduce conflict
  pl@europa:~/LEyapp/examples/debuggingtut$ ./rrconflictnamefirst.pm
  Expressions. Press CTRL-D (Unix) or CTRL-Z (Windows) to finish:
  a,b:c d:e,
  &lt;CTRL-D&gt;
  $
</pre>
<p class="Pp">The program accepts the correct language - in spite of the
    conflict - due to the fact that the production</p>
<p class="Pp"></p>
<pre>
                      name:        VAR
</pre>
<p class="Pp">is listed first.</p>
<p class="Pp">The parser rejects the correct phrases if we swap the order of the
    productions writing the <span class="Li">&quot;type: VAR&quot;</span>
    production first,</p>
<p class="Pp"></p>
<pre>
  pl@europa:~/LEyapp/examples/debuggingtut$ ./reducereduceconflict.pm
  Expressions. Press CTRL-D (Unix) or CTRL-Z (Windows) to finish:
  a,b:c d:e,
  &lt;CTRL-D&gt;

  Syntax error near input: ',' (lin num 1).
  Incoming text:
  ===
  b:c d
  ===
  Expected one of these terminals: VAR
</pre>
<p class="Pp">Files
    <span class="Li">&quot;reducereduceconflict_fix1.eyp&quot;</span> and
    <span class="Li">&quot;reducereduceconflict_fix2.eyp&quot;</span> offer
    other solutions to the problem.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TOKENS_DEPENDING_ON_THE_SYNTACTIC_CONTEXT"><a class="permalink" href="#TOKENS_DEPENDING_ON_THE_SYNTACTIC_CONTEXT">TOKENS
  DEPENDING ON THE SYNTACTIC CONTEXT</a></h1>
<p class="Pp">Usually there is a one-to-one relation between a token and a
    regexp. Problems arise, however when a token's type depends upon contextual
    information. An example of this problem comes from PL/I, where statements
    like this are legal:</p>
<p class="Pp"></p>
<pre>
         if then=if then if=then
</pre>
<p class="Pp">In PL/I this problem arises because keywords like
    <span class="Li">&quot;if&quot;</span> are not reserved and can be used in
    other contexts. This simplified grammar illustrates the problem:</p>
<p class="Pp"></p>
<pre>
  examples/debuggingtut$ eyapp -c PL_I_conflict.eyp
  # This grammar deals with the famous ambiguous PL/I phrase:
  #                if then=if then if=then
  # The (partial) solution uses YYExpect in the lexical analyzer to predict the token
  # that fulfills the parser expectatives.
  # Compile it with:
  # eyapp -b '' PL_I_conflict.eyp
  # Run it with;
  # ./PL_I_conflict.pm -debug
  %strict
  %token ID
  %tree bypass

  %%

  stmt:
        ifstmt
      | assignstmt
  ;
  # Exercise: change this production
  #     for 'if' expr 'then' stmt
  # and check with input 'if then=if then if=then'. The problem arises again
  ifstmt:
        %name IF
        'if' expr 'then' expr
  ;
  assignstmt:
        id '=' expr
  ;
  expr:
        %name EQ
        id '=' id
      | id
  ;
  id:
        %name ID
        ID
  ;

  %%
</pre>
<p class="Pp">If the token ambiguity depends only in the syntactic context, the
    problem can be alleviated using the
    <span class="Li">&quot;YYExpect&quot;</span> method. In case of doubt, the
    lexical analyzer calls the <span class="Li">&quot;YYExpect&quot;</span>
    method to know which of the several feasible tokens is expected by the
    parser:</p>
<p class="Pp"></p>
<pre>
  examples/debuggingtut$ sed -ne '/sub lex/,/^}/p' PL_I_conflict.eyp
  sub lexer {
    my $parser = shift;

    for ($parser-&gt;{input}) {    # contextualize
      m{\G\s*(\#.*)?}gc;

      m{\G([a-zA-Z_]\w*)}gc and do {
        my $id = $1;

        return ('if',   'if')   if ($id eq 'if')   &amp;&amp; is_in('if', $parser-&gt;YYExpect);
        return ('then', 'then') if ($id eq 'then') &amp;&amp; is_in('then', $parser-&gt;YYExpect);

        return ('ID', $id);
      };

      m{\G(.)}gc         and return ($1, $1);

      return('',undef);
    }
  }
</pre>
<p class="Pp">Here follows an example of execution:</p>
<p class="Pp"></p>
<pre>
  examples/debuggingtut$ eyapp -b '' PL_I_conflict.eyp
  examples/debuggingtut$ ./PL_I_conflict.pm
  Expressions. Press CTRL-D (Unix) or CTRL-Z (Windows) to finish:
  if then=if then if=then
  IF(EQ(ID,ID),EQ(ID,ID))
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="LEXICAL_TIE-INS"><a class="permalink" href="#LEXICAL_TIE-INS">LEXICAL
  TIE-INS</a></h1>
<p class="Pp">A <i>lexical tie-in</i> is a flag which is set to alter the
    behavior of the lexical analyzer. It is a way to handle
  context-dependency.</p>
<section class="Ss">
<h2 class="Ss" id="The_Parsing_of__C_"><a class="permalink" href="#The_Parsing_of__C_">The
  Parsing of &quot;C&quot;</a></h2>
<p class="Pp">The C language has a context dependency: the way an identifier is
    used depends on what its current meaning is. For example, consider this:</p>
<p class="Pp"></p>
<pre>
  T(x);
</pre>
<p class="Pp">This looks like a function call statement, but if
    <span class="Li">&quot;T&quot;</span> is a typedef name, then this is
    actually a declaration of <span class="Li">&quot;x&quot;</span>. How can a
    parser for C decide how to parse this input?</p>
<p class="Pp">Here is another example:</p>
<p class="Pp"></p>
<pre>
  {
    T * x;
    ...
  }
</pre>
<p class="Pp">What is this, a declaration of
    <span class="Li">&quot;x&quot;</span> as a pointer to
    <span class="Li">&quot;T&quot;</span>, or a void multiplication of the
    variables <span class="Li">&quot;T&quot;</span> and
    <span class="Li">&quot;x&quot;</span>?</p>
<p class="Pp">The usual method to solve this problem is to have two different
    token types, <span class="Li">&quot;ID&quot;</span> and
    <span class="Li">&quot;TYPENAME&quot;</span>. When the lexical analyzer
    finds an identifier, it looks up in the symbol table the current declaration
    of the identifier in order to decide which token type to return:
    <span class="Li">&quot;TYPENAME&quot;</span> if the identifier is declared
    as a typedef, <span class="Li">&quot;ID&quot;</span> otherwise. See the ANSI
    C parser example in the directory
    <span class="Li">&quot;examples/languages/C/ansic.eyp&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="A_Simple_Example"><a class="permalink" href="#A_Simple_Example">A
  Simple Example</a></h2>
<p class="Pp">In the &quot;Calc&quot;-like example in
    <span class="Li">&quot;examples/debuggintut/SemanticInfoInTokens.eyp&quot;</span>
    we have a language with a special construct <span class="Li">&quot;hex
    (hex-expr)&quot;</span>. After the keyword
    <span class="Li">&quot;hex&quot;</span> comes an
    <span class="Li">&quot;expression&quot;</span> in parentheses in which all
    integers are hexadecimal. In particular, strings in
    <span class="Li">&quot;/[A-F0-9]+/&quot;</span> like
    <span class="Li">&quot;A1B&quot;</span> must be treated as an hex integer
    unless they were previously declared as variables. Let us see an example of
    execution:</p>
<p class="Pp"></p>
<pre>
  $ eyapp -b '' SemanticInfoInTokens.eyp
  $ cat inputforsemanticinfo2.txt
  int A2
  A2 = HEX(A23);
  A2 = HEX(A2)

  $ ./SemanticInfoInTokens.pm -f inputforsemanticinfo2.txt  -t
  EXPS(ASSIGN(TERMINAL[A2],NUM[2595]),ASSIGN(TERMINAL[A2],ID[A2]))
</pre>
<p class="Pp">The first hex expression
    <span class="Li">&quot;HEX(A23)&quot;</span> is interpreted as the number
    <span class="Li">2595</span> while the second
    <span class="Li">&quot;HEX(A2)&quot;</span> refers to previously declared
    variable <span class="Li">&quot;A2&quot;</span>.</p>
<p class="Pp">An alternative solution to this problem that does not make use of
    lexical tie-ins - but still uses an attribute
    <span class="Li">&quot;HEXFLAG&quot;</span> for communication between
    different semantic actions - can be found in the file
    <span class="Li">&quot;examples/debuggintut/Tieins.eyp&quot;</span>.</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples/debuggingtut$ sed -ne '5,91p' SemanticInfoInTokens.eyp | cat -n
     1  %strict                                                                             
     2                                                                                      
     3  %token ID INT INTEGER                                                               
     4  %syntactic token HEX                                                                
     5                                                                                      
     6  %right '='                                                                          
     7  %left '+'                                                                           
     8                                                                                      
     9  %{                                                                                  
    10  use base q{DebugTail};                                                              
    11  my %st;                                                                             
    12  %}                                                                                  
    13                                                                                      
    14  %tree bypass alias                                                                  
    15                                                                                      
    16  %%                                                                                  
    17  stmt:                                                                               
    18      decl &lt;* ';'&gt; expr &lt;%name EXPS + ';'&gt;                                            
    19        {                                                                             
    20          # make the symbol table an attribute                                        
    21          # of the root node                                                          
    22          $_[2]-&gt;{st} = { %st };                                                      
    23          $_[2];                                                                      
    24        }                                                                             
    25  ;                                                                                   
    26                                                                                      
    27  decl:                                                                               
    28      INT ID &lt;+ ','&gt;                                                                  
    29        {                                                                             
    30          # insert identifiers in the symbol table                                    
    31          $st{$_-&gt;{attr}} = 1 for $_[2]-&gt;children();                                  
    32        }                                                                             
    33  ;                                                                                   
    34                                                                                      
    35  expr:                                                                               
    36      %name ID                                                                        
    37      ID                                                                              
    38    | %name NUM                                                                       
    39      INTEGER                                                                         
    40    | %name HEX                                                                       
    41      HEX '(' { $_[0]-&gt;{HEXFLAG} = 1; } $expr ')'                                     
    42        {                                                                             
    43          $_[0]-&gt;{HEXFLAG} = 0;                                                       
    44          $expr;                                                                      
    45        }                                                                             
    46    | %name ASSIGN                                                                    
    47      id '=' expr                                                                     
    48    | %name PLUS                                                                      
    49      expr '+' expr
    50  ;
    51
    52  id : ID
    53  ;
    54
    55  %%
    56
    57  # Context-dependant lexer
    58  __PACKAGE__-&gt;lexer( sub {
    59      my $parser = shift;
    60      my $hexflag = $parser-&gt;{HEXFLAG};
    61
    62      for (${$parser-&gt;input}) {    # contextualize
    63        m{\G\s*(\#.*)?}gc;
    64
    65        m{\G(HEX\b|INT\b)}igc and return (uc($1), $1);
    66
    67        m{(\G\d+)}gc and return ('INTEGER', $hexflag? hex($1) : $1);
    68
    69
    70        m{\G([a-zA-Z_]\w*)}gc and do {
    71          my $match = $1;
    72          $hexflag and !exists($st{$match}) and $match =~ m{^([A-F0-9]+$)}gc and return ('INTEGER', hex($match));
    73          return ('ID', $1);
    74        };
    75
    76        m{\G(.)}gc         and return ($1, $1);
    77
    78        return('',undef);
    79      }
    80    }
    81  );
    82
    83  *TERMINAL::info = *NUM::info = *ID::info = sub {
    84    $_[0]-&gt;{attr}
    85  };
    86
    87  __PACKAGE__-&gt;main() unless caller();
</pre>
<p class="Pp">Here the lexical analyzer looks at the value of the attribute
    <span class="Li">&quot;HEXFLAG&quot;</span>; when it is nonzero, all
    integers are parsed in hexadecimal, and tokens starting with letters are
    parsed as integers if possible.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="References_about_Lexical_tie-ins"><a class="permalink" href="#References_about_Lexical_tie-ins">References
  about Lexical tie-ins</a></h2>
<p class="Pp">For more about lexical tie-ins see also</p>
<ul class="Bl-bullet">
  <li>&lt;http://www.gnu.org/software/bison/manual/html_mono/bison.html#Lexical-Tie_002dins&gt;</li>
  <li>&lt;http://en.wikipedia.org/wiki/The_lexer_hack&gt;</li>
  <li>&lt;http://eli.thegreenplace.net/2007/11/24/the-context-sensitivity-of-cs-grammar/&gt;</li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SOLVING_CONFLICTS_WITH_THE_"><a class="permalink" href="#SOLVING_CONFLICTS_WITH_THE_">SOLVING
  CONFLICTS WITH THE <i>POSTPONED CONFLICT</i> STRATEGY</a></h1>
<p class="Pp">Yacc-like parser generators provide ways to solve shift-reduce
    mechanims based on token precedence. No mechanisms are provided for the
    resolution of reduce-reduce conflicts. The solution for such kind of
    conflicts is to modify the grammar. The strategy We present here provides a
    way to broach conflicts that can't be solved using static precedences.</p>
<section class="Ss">
<h2 class="Ss" id="The_"><a class="permalink" href="#The_">The <i>Postponed
  Conflict Resolution</i> Strategy</a></h2>
<p class="Pp">The <i>postponed conflict strategy</i> presented here can be used
    whenever there is a shift-reduce or reduce-reduce conflict that can not be
    solved using static precedences.</p>
</section>
<section class="Ss">
<h2 class="Ss"><i>Postponed Conflict Resolution</i>: Reduce-Reduce
  Conflicts</h2>
<p class="Pp">Let us assume we have a reduce-reduce conflict between to
    productions</p>
<p class="Pp"></p>
<pre>
                      A -&gt; alpha .
                      B -&gt; beta .
</pre>
<p class="Pp">for some token <span class="Li">&quot;@&quot;</span>. Let also
    assume that production</p>
<p class="Pp"></p>
<pre>
                      A -&gt; alpha
</pre>
<p class="Pp">has name <span class="Li">&quot;ruleA&quot;</span> and
  production</p>
<p class="Pp"></p>
<pre>
                      B -&gt; beta
</pre>
<p class="Pp">has name <span class="Li">&quot;ruleB&quot;</span>.</p>
<p class="Pp">The postponed conflict resolution strategy consists in modifying
    the conflictive grammar by marking the points where the conflict occurs with
    the new <span class="Li">%PREC</span> directive. In this case at then end of
    the involved productions:</p>
<p class="Pp"></p>
<pre>
                      A -&gt; alpha %PREC IsAorB 
                      B -&gt; beta  $PREC IsAorB
</pre>
<p class="Pp">The <span class="Li">&quot;IsAorB&quot;</span> identifier is
    called the <i>conflict name</i>.</p>
<p class="Pp">Inside the head section, the programmer associates with the
    conflict name a code whose mission is to solve the conflict by dynamically
    changing the parsing table like this:</p>
<p class="Pp"></p>
<pre>
                     %conflict IsAorB {
                          my $self = shift;

                          if (looks_like_A($self)) {
                            $self-&gt;YYSetReduce('@', 'ruleA' );
                          }
                          else {
                            $self-&gt;YYSetReduce('@', 'ruleB' );
                          }
                       }
</pre>
<p class="Pp">The code associated with the <i>conflict name</i> receives the
    name of <i> conflict handler</i>. The code of
    <span class="Li">&quot;looks_like_A&quot;</span> stands for some form of
    nested parsing which will decide which production applies.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Solving_the_Enumerated_versus_Range_declarations_conflict_using_the_Posponed_Conflict_Resolution_Strategy"><a class="permalink" href="#Solving_the_Enumerated_versus_Range_declarations_conflict_using_the_Posponed_Conflict_Resolution_Strategy">Solving
  the Enumerated versus Range declarations conflict using the Posponed Conflict
  Resolution Strategy</a></h2>
<p class="Pp">In file
    <span class="Li">&quot;pascalenumeratedvsrangesolvedviadyn.eyp&quot;</span>
    we apply the postponed conflict resolution strategy to the reduce reduce
    conflict that arises in Extended Pascal between the declaration of ranges
    and the declaration of enumerated types (see section &quot;Reduce-Reduce
    conflict: Enumerated versus Range declarations in Extended Pascal&quot;).
    Here is the solution:</p>
<p class="Pp"></p>
<pre>
  ~/LEyapp/examples/debuggingtut$ cat -n pascalenumeratedvsrangesolvedviadyn.eyp
     1  %{
     2  =head1 SYNOPSIS
     3  
     4  See 
     5  
     6  =over 2
     7  
     8  =item * File pascalenumeratedvsrange.eyp in examples/debuggintut/
     9  
    10  =item * The Bison manual L&lt;http://www.gnu.org/software/bison/manual/html_mono/bison.html&gt;
    11  
    12  =back
    13  
    14  Compile it with:
    15  
    16              eyapp -b '' pascalenumeratedvsrangesolvedviadyn.eyp
    17  
    18  run it with this options:
    19  
    20              ./pascalenumeratedvsrangesolvedviadyn.pm -t
    21  
    22  Try these inputs:
    23  
    24                  type r = (x) ..  y ;
    25                  type r = (x+2)*3 ..  y/2 ;
    26                  type e = (x, y, z);
    27                  type e = (x);
    28  
    29  =cut
    30  
    31  use base q{DebugTail}; 
    32  
    33  my $ID = qr{[A-Za-z][A-Za-z0-9_]*};
    34               # Identifiers separated by commas
    35  my $IDLIST = qr{ \s*(?:\s*,\s* $ID)* \s* }x;
    36               # list followed by a closing par and a semicolon 
    37  my $RESTOFLIST = qr{$IDLIST \) \s* ; }x;
    38  %}
    39  
    40  %namingscheme {
    41    #Receives a Parse::Eyapp object describing the grammar
    42    my $self = shift;
    43  
    44    $self-&gt;tokennames(
    45      '(' =&gt; 'LP',
    46      '..' =&gt; 'DOTDOT',
    47      ',' =&gt; 'COMMA',
    48      ')' =&gt; 'RP',
    49      '+' =&gt; 'PLUS',
    50      '-' =&gt; 'MINUS',
    51      '*' =&gt; 'TIMES',
    52      '/' =&gt; 'DIV',
    53    );
    54  
    55    # returns the handler that will give names
    56    # to the right hand sides
    57    \&amp;give_rhs_name;
    58  }
    59  
    60  %strict
    61  
    62  %token ID NUM DOTDOT TYPE
    63  %left   '-' '+'
    64  %left   '*' '/'
    65  
    66  %tree
    67  
    68  %%
    69  
    70  type_decl : TYPE ID '=' type ';'
    71  ;
    72  
    73  type : 
    74        %name ENUM
    75        '(' id_list ')'
    76      | %name RANGE
    77        expr DOTDOT expr
    78  ;
    79  
    80  id_list : 
    81        %name EnumID
    82        ID rangeORenum
    83      | id_list ',' ID
    84  ;
    85  
    86  expr : '(' expr ')'
    87      | expr '+' expr
    88      | expr '-' expr
    89      | expr '*' expr
    90      | expr '/' expr
    91      | %name RangeID
    92        ID rangeORenum
    93      | NUM
    94  ;
    95  
    96  rangeORenum: /* empty: postponed conflict resolution */
    97        {
    98            my $parser = shift;
    99            if (${$parser-&gt;input()} =~ m{\G(?= $RESTOFLIST)}gcx) {
   100                $parser-&gt;YYSetReduce(')', 'EnumID' );
   101              }
   102              else {
   103                $parser-&gt;YYSetReduce(')', 'RangeID' );
   104              }
   105        }
   106  ;
   107  
   108  %%
   109  
   110  __PACKAGE__-&gt;lexer(
   111    sub {
   112      my $parser = shift;
   113  
   114      for (${$parser-&gt;input()}) {    # contextualize
   115        m{\G(\s*)}gc;
   116        $parser-&gt;tokenline($1 =~ tr{\n}{});
   117  
   118        m{\Gtype\b}gic                 and return ('TYPE', 'TYPE');
   119  
   120        m{\G($ID)}gc                   and return ('ID',  $1);
   121  
   122        m{\G([0-9]+)}gc                and return ('NUM', $1);
   123  
   124        m{\G\.\.}gc                    and return ('DOTDOT',  '..');
   125  
   126        m{\G(.)}gc                     and return ($1,    $1);
   127  
   128        return('',undef);
   129      }
   130    }
   131  );
   132  
   133  unless (caller()) {
   134    $Parse::Eyapp::Node::INDENT = 1;
   135    my $prompt = &lt;&lt; 'EOP';
   136  Try this input:
   137      type 
   138      r
   139      =
   140      (x)
   141      ..
   142      y
   143      ;
   144  
   145  Here other inputs you can try:
   146  
   147      type r = (x+2)*3 ..  y/2 ;
   148      type e = (x, y, z);
   149      type e = (x);
   150  
   151  Press CTRL-D (CTRL-W in windows) to produce the end-of-file
   152  EOP
   153    __PACKAGE__-&gt;main($prompt); 
   154  }
</pre>
<p class="Pp">This example also illustrates how to modify the default production
    naming schema. Follows the result of several executions:</p>
<p class="Pp"></p>
<pre>
  ~/LEyapp/examples/debuggingtut$ ./pascalenumeratedvsrangesolvedviadyn.pm -t
  Try this input:
      type 
      r
      =
      (x)
      ..
      y
      ;

  Here other inputs you can try:

      type r = (x+2)*3 ..  y/2 ;
      type e = (x, y, z);
      type e = (x);

  Press CTRL-D (CTRL-W in windows) to produce the end-of-file
  type r = (x+2)*3 ..  y/2 ;
  ^D
  type_decl_is_TYPE_ID_type(
    TERMINAL[TYPE],
    TERMINAL[r],
    RANGE(
      expr_is_expr_TIMES_expr(
        expr_is_LP_expr_RP(
          expr_is_expr_PLUS_expr(
            RangeID(
              TERMINAL[x]
            ),
            expr_is_NUM(
              TERMINAL[2]
            )
          )
        ),
        expr_is_NUM(
          TERMINAL[3]
        )
      ),
      TERMINAL[..],
      expr_is_expr_DIV_expr(
        RangeID(
          TERMINAL[y]
        ),
        expr_is_NUM(
          TERMINAL[2]
        )
      )
    )
  )
  ~/LEyapp/examples/debuggingtut$ ./pascalenumeratedvsrangesolvedviadyn.pm -t
  Try this input:
      type 
      r
      =
      (x)
      ..
      y
      ;

  Here other inputs you can try:

      type r = (x+2)*3 ..  y/2 ;
      type e = (x, y, z);
      type e = (x);

  Press CTRL-D (CTRL-W in windows) to produce the end-of-file
  type e = (x);
  ^D
  type_decl_is_TYPE_ID_type(
    TERMINAL[TYPE],
    TERMINAL[e],
    ENUM(
      EnumID(
        TERMINAL[x]
      )
    )
  )
</pre>
</section>
<section class="Ss">
<h2 class="Ss"><i>Postponed Conflict Resolution</i>: Shift-Reduce Conflicts</h2>
<p class="Pp">The program in
    <span class="Li">&quot;examples/debuggingtut/DynamicallyChangingTheParser2.eyp&quot;</span>
    illustrates how the postponed conflict strategy is used for shift-reduce
    conflicts. This is an extension of the grammar in
    <span class="Li">&quot;examples/debuggingtut/Debug.eyp&quot;</span>. The
    generated language is constituted by sequences like:</p>
<p class="Pp"></p>
<pre>
    { D; D; S; S; S; } {D; S} { S }
</pre>
<p class="Pp">As you remember the conflict was:</p>
<p class="Pp"></p>
<pre>
  ~/LEyapp/examples/debuggingtut$ sed -ne '/^St.*13:/,/^St.*14/p' DynamicallyChangingTheParser.output  
  State 13:

      ds -&gt; D conflict . ';' ds   (Rule 6)
      ds -&gt; D conflict .  (Rule 7)

      ';' shift, and go to state 16

      ';' [reduce using rule 7 (ds)]

  State 14:
</pre>
<p class="Pp">The <span class="Li">&quot;conflict&quot;</span> handler below
    sets the LR action to reduce by the production with name
    <span class="Li">&quot;D1&quot;</span></p>
<p class="Pp"></p>
<pre>
                 ds -&gt; D
</pre>
<p class="Pp">in the presence of token <span class="Li">';'</span> if indeed is
    the last <span class="Li">'D'</span>, that is, if:</p>
<p class="Pp"></p>
<pre>
       ${$self-&gt;input()} =~ m{^\s*;\s*S}
</pre>
<p class="Pp">Otherwise we set the <span class="Li">&quot;shift&quot;</span>
    action via a call to the <span class="Li">&quot;YYSetShift&quot;</span>
    method.</p>
<p class="Pp"></p>
<pre>
  ~/LEyapp/examples/debuggingtut$ sed -ne '30,$p' DynamicallyChangingTheParser.eyp | cat -n
     1  %token D S
     2  
     3  %tree bypass
     4  
     5  # Expect just 1 shift-reduce conflict
     6  %expect 1 
     7  
     8  %%
     9  p: %name PROG
    10      block +
    11  ;
    12  
    13  block:
    14      %name BLOCK_DS
    15      '{' ds ';' ss '}' 
    16    | %name BLOCK_S
    17      '{' ss '}'
    18  ;
    19  
    20  ds:
    21      %name D2
    22      D conflict ';' ds    
    23    | %name D1
    24      D conflict        
    25  ;
    26  
    27  ss:
    28      %name S2
    29      S ';' ss      
    30    | %name S1
    31      S       
    32  ;
    33  
    34  conflict:
    35        /* empty. This action solves the conflict using dynamic precedence */
    36        {
    37          my $self = shift;
    38  
    39          if (${$self-&gt;input()} =~ m{^\s*;\s*S}) {
    40            $self-&gt;YYSetReduce(';', 'D1' )
    41          }
    42          else {
    43            $self-&gt;YYSetShift(';')
    44          }
    45  
    46          undef; # skip this node in the AST
    47        }
    48  ;
    49  
    50  %%
    51  
    52  my $prompt = 'Provide a statement like &quot;{D; S} {D; D; S}&quot; and press &lt;CR&gt;&lt;CTRL-D&gt;: ';
    53  __PACKAGE__-&gt;main($prompt) unless caller;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TREE_EQUALITY"><a class="permalink" href="#TREE_EQUALITY">TREE
  EQUALITY</a></h1>
<p class="Pp">The more the time invested writing tests the less the time spent
    debugging. This section deals with the Parse::Eyapp::Node method
    <span class="Li">&quot;equal&quot;</span> which can be used to test that the
    trees have the shape we expect.</p>
<section class="Ss">
<h2 class="Ss" id="$node"><a class="permalink" href="#$node">$node-&gt;equal</a></h2>
<p class="Pp">A call
    <span class="Li">&quot;$tree1-&gt;equal($tree2)&quot;</span> compare the two
    trees <span class="Li">$tree1</span> and <span class="Li">$tree2</span>. Two
    trees are considered equal if their root nodes belong to the same class,
    they have the same number of children and the children are (recursively)
    equal.</p>
<p class="Pp">In Addition to the two trees the programmer can specify pairs
    <span class="Li">&quot;attribute_key =&gt;
  equality_handler&quot;</span>:</p>
<p class="Pp"></p>
<pre>
  $tree1-&gt;equal($tree2, attr1 =&gt; \&amp;handler1, attr2 =&gt; \&amp;handler2, ...)
</pre>
<p class="Pp">In such case the definition of equality is more restrictive: Two
    trees are considered equal if</p>
<ul class="Bl-bullet">
  <li>Their root nodes belong to the same class,</li>
  <li>They have the same number of children</li>
  <li>For each of the specified attributes occur that for both nodes the
      existence and definition of the key is the same</li>
  <li>Assuming the key exists and is defined for both nodes, the equality
      handlers return true for each of its attributes and</li>
  <li>The respective children are (recursively) equal.</li>
</ul>
<p class="Pp">An attribute handler receives as arguments the values of the
    attributes of the two nodes being compared and must return true if, and only
    if, these two attributes are considered equal. Follows an example:</p>
<p class="Pp"></p>
<pre>
  examples/Node$ cat -n equal.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use Parse::Eyapp::Node;
     4
     5  my $string1 = shift || 'ASSIGN(VAR(TERMINAL))';
     6  my $string2 = shift || 'ASSIGN(VAR(TERMINAL))';
     7  my $t1 = Parse::Eyapp::Node-&gt;new($string1, sub { my $i = 0; $_-&gt;{n} = $i++ for @_ });
     8  my $t2 = Parse::Eyapp::Node-&gt;new($string2);
     9
    10  # Without attributes
    11  if ($t1-&gt;equal($t2)) {
    12    print &quot;\nNot considering attributes: Equal\n&quot;;
    13  }
    14  else {
    15    print &quot;\nNot considering attributes: Not Equal\n&quot;;
    16  }
    17
    18  # Equality with attributes
    19  if ($t1-&gt;equal($t2, n =&gt; sub { return $_[0] == $_[1] })) {
    20    print &quot;\nConsidering attributes: Equal\n&quot;;
    21  }
    22  else {
    23    print &quot;\nConsidering attributes: Not Equal\n&quot;;
    24  }
</pre>
<p class="Pp">When the former program is run without arguments produces the
    following output:</p>
<p class="Pp"></p>
<pre>
  examples/Node$ equal.pl

  Not considering attributes: Equal

  Considering attributes: Not Equal
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Using__equal__During_Testing"><a class="permalink" href="#Using__equal__During_Testing">Using
  &quot;equal&quot; During Testing</a></h2>
<p class="Pp">During the development of your compiler you add new stages to the
    existing ones. The consequence is that the AST is decorated with new
    attributes. Unfortunately, this implies that tests you wrote using
    <span class="Li">&quot;is_deeply&quot;</span> and comparisons against
    formerly correct abstract syntax trees are no longer valid. This is due to
    the fact that <span class="Li">&quot;is_deeply&quot;</span> requires both
    tree structures to be equivalent in every detail and that our new code
    produces a tree with new attributes.</p>
<p class="Pp">Instead of <span class="Li">&quot;is_deeply&quot;</span> use the
    <span class="Li">&quot;equal&quot;</span> method to check for partial
    equivalence between abstract syntax trees. You can follow these steps:</p>
<ul class="Bl-bullet">
  <li>Dump the tree for the source inserting
      <span class="Li">&quot;Data::Dumper&quot;</span> statements</li>
  <li>Carefully check that the tree is really correct</li>
  <li>Decide which attributes will be used for comparison</li>
  <li>Write the code for the expected value editing the output produced by
      <span class="Li">&quot;Data::Dumper&quot;</span></li>
  <li>Write the handlers for the attributes you decided. Write the comparison
      using <span class="Li">&quot;equal&quot;</span>.</li>
</ul>
<p class="Pp">Tests using this methodology will not fail even if later code
    decorating the AST with new attributes is introduced.</p>
<p class="Pp">See an example that checks an abstract syntax tree produced by the
    simple compiler (see
    <span class="Li">&quot;examples/typechecking/Simple-Types-XXX.tar.gz&quot;</span>)
    for a really simple source:</p>
<p class="Pp"></p>
<pre>
  Simple-Types/script$ cat prueba27.c
  int f() {
  }
</pre>
<p class="Pp">The first thing is to obtain a description of the tree, that can
    be done executing the compiler under the control of the Perl debugger,
    stopping just after the tree has been built and dumping the tree with
    Data::Dumper:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/Lbook/code/Simple-Types/script$ perl -wd usetypes.pl prueba27.c
  main::(usetypes.pl:5):  my $filename = shift || die &quot;Usage:\n$0 file.c\n&quot;;
    DB&lt;1&gt; c 12
  main::(usetypes.pl:12): Simple::Types::show_trees($t, $debug);
    DB&lt;2&gt; use Data::Dumper
    DB&lt;3&gt; $Data::Dumper::Purity = 1
    DB&lt;4&gt; p Dumper($t)
  $VAR1 = bless( {
                   ..............................................
                 }, 'PROGRAM' );
  ...............................................................
</pre>
<p class="Pp">Once we have the shape of a correct tree we can write our
  tests:</p>
<p class="Pp"></p>
<pre>
  examples/Node$ cat -n testequal.pl
     1  #!/usr/bin/perl -w
     2  use strict;
     3  use Parse::Eyapp::Node;
     4  use Data::Dumper;
     5  use Data::Compare;
     6
     7  my $debugging = 0;
     8
     9  my $handler = sub {
    10    print Dumper($_[0], $_[1]) if $debugging;
    11    Compare($_[0], $_[1])
    12  };
    13
    14  my $t1 = bless( {
    15                   'types' =&gt; {
    16                                'CHAR' =&gt; bless( { 'children' =&gt; [] }, 'CHAR' ),
    17                                'VOID' =&gt; bless( { 'children' =&gt; [] }, 'VOID' ),
    18                                'INT' =&gt; bless( { 'children' =&gt; [] }, 'INT' ),
    19                                'F(X_0(),INT)' =&gt; bless( {
    20                                   'children' =&gt; [
    21                                      bless( { 'children' =&gt; [] }, 'X_0' ),
    22                                      bless( { 'children' =&gt; [] }, 'INT' ) ]
    23                                 }, 'F' )
    24                              },
    25                   'symboltable' =&gt; { 'f' =&gt; { 'type' =&gt; 'F(X_0(),INT)', 'line' =&gt; 1 } },
    26                   'lines' =&gt; 2,
    27                   'children' =&gt; [
    28                                   bless( {
    29                                            'symboltable' =&gt; {},
    30                                            'fatherblock' =&gt; {},
    31                                            'children' =&gt; [],
    32                                            'depth' =&gt; 1,
    33                                            'parameters' =&gt; [],
    34                                            'function_name' =&gt; [ 'f', 1 ],
    35                                            'symboltableLabel' =&gt; {},
    36                                            'line' =&gt; 1
    37                                          }, 'FUNCTION' )
    38                                 ],
    39                   'depth' =&gt; 0,
    40                   'line' =&gt; 1
    41                 }, 'PROGRAM' );
    42  $t1-&gt;{'children'}[0]{'fatherblock'} = $t1;
    43
    44  # Tree similar to $t1 but without some attributes (line, depth, etc.)
    45  my $t2 = bless( {
    46                   'types' =&gt; {
    47                                'CHAR' =&gt; bless( { 'children' =&gt; [] }, 'CHAR' ),
    48                                'VOID' =&gt; bless( { 'children' =&gt; [] }, 'VOID' ),
    49                                'INT' =&gt; bless( { 'children' =&gt; [] }, 'INT' ),
    50                                'F(X_0(),INT)' =&gt; bless( {
    51                                   'children' =&gt; [
    52                                      bless( { 'children' =&gt; [] }, 'X_0' ),
    53                                      bless( { 'children' =&gt; [] }, 'INT' ) ]
    54                                 }, 'F' )
    55                              },
    56                   'symboltable' =&gt; { 'f' =&gt; { 'type' =&gt; 'F(X_0(),INT)', 'line' =&gt; 1 } },
    57                   'children' =&gt; [
    58                                   bless( {
    59                                            'symboltable' =&gt; {},
    60                                            'fatherblock' =&gt; {},
    61                                            'children' =&gt; [],
    62                                            'parameters' =&gt; [],
    63                                            'function_name' =&gt; [ 'f', 1 ],
    64                                          }, 'FUNCTION' )
    65                                 ],
    66                 }, 'PROGRAM' );
    67  $t2-&gt;{'children'}[0]{'fatherblock'} = $t2;
    68
    69  # Tree similar to $t1 but without some attributes (line, depth, etc.)
    70  # and without the symboltable and types attributes used in the comparison
    71  my $t3 = bless( {
    72                   'types' =&gt; {
    73                                'CHAR' =&gt; bless( { 'children' =&gt; [] }, 'CHAR' ),
    74                                'VOID' =&gt; bless( { 'children' =&gt; [] }, 'VOID' ),
    75                                'INT' =&gt; bless( { 'children' =&gt; [] }, 'INT' ),
    76                                'F(X_0(),INT)' =&gt; bless( {
    77                                   'children' =&gt; [
    78                                      bless( { 'children' =&gt; [] }, 'X_0' ),
    79                                      bless( { 'children' =&gt; [] }, 'INT' ) ]
    80                                 }, 'F' )
    81                              },
    82                   'children' =&gt; [
    83                                   bless( {
    84                                            'symboltable' =&gt; {},
    85                                            'fatherblock' =&gt; {},
    86                                            'children' =&gt; [],
    87                                            'parameters' =&gt; [],
    88                                            'function_name' =&gt; [ 'f', 1 ],
    89                                          }, 'FUNCTION' )
    90                                 ],
    91                 }, 'PROGRAM' );
    92
    93  $t3-&gt;{'children'}[0]{'fatherblock'} = $t2;
    94
    95  # Without attributes
    96  if (Parse::Eyapp::Node::equal($t1, $t2)) {
    97    print &quot;\nNot considering attributes: Equal\n&quot;;
    98  }
    99  else {
   100    print &quot;\nNot considering attributes: Not Equal\n&quot;;
   101  }
   102
   103  # Equality with attributes
   104  if (Parse::Eyapp::Node::equal(
   105        $t1, $t2,
   106        symboltable =&gt; $handler,
   107        types =&gt; $handler,
   108      )
   109     ) {
   110        print &quot;\nConsidering attributes: Equal\n&quot;;
   111  }
   112  else {
   113    print &quot;\nConsidering attributes: Not Equal\n&quot;;
   114  }
   115
   116  # Equality with attributes
   117  if (Parse::Eyapp::Node::equal(
   118        $t1, $t3,
   119        symboltable =&gt; $handler,
   120        types =&gt; $handler,
   121      )
   122     ) {
   123        print &quot;\nConsidering attributes: Equal\n&quot;;
   124  }
   125  else {
   126    print &quot;\nConsidering attributes: Not Equal\n&quot;;
   127  }
</pre>
<p class="Pp">The code defining tree <span class="Li">$t1</span> was obtained
    from an output using <span class="Li">&quot;Data::Dumper&quot;</span>. The
    code for trees <span class="Li">$t2</span> and <span class="Li">$t3</span>
    was written using cut-and-paste from <span class="Li">$t1</span>. They have
    the same shape than <span class="Li">$t1</span> but differ in their
    attributes. Tree <span class="Li">$t2</span> shares with
    <span class="Li">$t1</span> the attributes
    <span class="Li">&quot;symboltable&quot;</span> and
    <span class="Li">&quot;types&quot;</span> used in the comparison and so
    <span class="Li">&quot;equal&quot;</span> returns
    <span class="Li">&quot;true&quot;</span> when compared. Since
    <span class="Li">$t3</span> differs from <span class="Li">$t1</span> in the
    attributes <span class="Li">&quot;symboltable&quot;</span> and
    <span class="Li">&quot;types&quot;</span> the call to
    <span class="Li">&quot;equal&quot;</span> returns
    <span class="Li">&quot;false&quot;</span>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="FORMATTING_Parse::Eyapp_PROGRAMS"><a class="permalink" href="#FORMATTING_Parse::Eyapp_PROGRAMS">FORMATTING
  Parse::Eyapp PROGRAMS</a></h1>
<p class="Pp">I use these rules for indenting Parse::Eyapp programs:</p>
<ul class="Bl-bullet">
  <li>Use uppercase identifiers for tokens, lowercase identifiers for syntactic
      variables</li>
  <li>The syntactic variable that defines the rule must be at in a single line
      at the leftmost position:
    <p class="Pp"></p>
    <pre>
  synvar:
       'a' othervar 'c'
    |  'b' anothervar SOMETOKEN
  ;
    </pre>
    <p class="Pp">The separation bar <span class="Li">&quot;|&quot;</span> goes
        indented relative to the left side of the rule. Each production starts
        two spaces from the bar. The first right hand side is aligned with the
        rest.</p>
  </li>
  <li>The semicolon <span class="Li">&quot;;&quot;</span> must also be in its
      own line at column 0</li>
  <li>If there is an empty production it must be the first one and must be
      commented
    <p class="Pp"></p>
    <pre>
  syntacvar:
       /* empty */
    |  'a' othervar 'c'
    |  'b' anothervar 
  ;
    </pre>
  </li>
  <li>Only very short semantic actions can go in the same line than the
      production. Semantic actions requiring more than one line must go in its
      own indented block like in:
    <p class="Pp"></p>
    <pre>
  exp:
      $NUM            { $NUM-&gt;[0] }
    | $VAR
       {
         my $id = $VAR-&gt;[0];
         my $val = $s{$id};
         $_[0]-&gt;semantic_error(&quot;Accessing undefined variable $id at line $VAR-&gt;[1].\n&quot;)
         unless defined($val);
         return $val;
       }
    | $VAR '=' $exp   { $s{$VAR-&gt;[0]} = $exp }
    | exp.x '+' exp.y { $x + $y }
    | exp.x '-' exp.y { $x - $y }
    | exp.x '*' exp.y { $x * $y }
    | exp.x '/'.barr exp.y
      {
         return($x/$y) if $y;
         $_[0]-&gt;semantic_error(&quot;Illegal division by zero at line $barr-&gt;[1].\n&quot;);
         undef
      }
    | '-' $exp %prec NEG  { -$exp }
    | exp.x '^' exp.y     { $x ** $y }
    | '(' $exp ')'        { $exp }
  ;
    </pre>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<ul class="Bl-bullet">
  <li>The project home is at &lt;http://code.google.com/p/parse-eyapp/&gt;. Use
      a subversion client to anonymously check out the latest project source
      code:
    <p class="Pp"></p>
    <pre>
   svn checkout http://parse-eyapp.googlecode.com/svn/trunk/ parse-eyapp-read-only
    </pre>
  </li>
  <li>The tutorial <i>Parsing Strings and Trees with</i>
      <span class="Li">&quot;Parse::Eyapp&quot;</span> (An Introduction to
      Compiler Construction in seven pages) in
      &lt;http://nereida.deioc.ull.es/~pl/eyapsimple/&gt;</li>
  <li>Parse::Eyapp, Parse::Eyapp::eyapplanguageref, Parse::Eyapp::debuggingtut,
      Parse::Eyapp::defaultactionsintro, Parse::Eyapp::translationschemestut,
      Parse::Eyapp::Driver, Parse::Eyapp::Node, Parse::Eyapp::YATW,
      Parse::Eyapp::Treeregexp, Parse::Eyapp::Scope, Parse::Eyapp::Base,
      Parse::Eyapp::datagenerationtut</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf&gt;</li>
  <li>perldoc eyapp,</li>
  <li>perldoc treereg,</li>
  <li>perldoc vgg,</li>
  <li>The Syntax Highlight file for vim at
      &lt;http://www.vim.org/scripts/script.php?script_id=2453&gt; and
      &lt;http://nereida.deioc.ull.es/~vim/&gt;</li>
  <li><i>Analisis Lexico y Sintactico</i>, (Notes for a course in compiler
      construction) by Casiano Rodriguez-Leon. Available at
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/&gt; Is the more complete
      and reliable source for Parse::Eyapp. However is in Spanish.</li>
  <li>Parse::Yapp,</li>
  <li>Man pages of <i>yacc</i>(1) and <i>bison</i>(1),
      &lt;http://www.delorie.com/gnu/docs/bison/bison.html&gt;</li>
  <li>Language::AttributeGrammar</li>
  <li>Parse::RecDescent.</li>
  <li>HOP::Parser</li>
  <li>HOP::Lexer</li>
  <li>ocamlyacc tutorial at
      &lt;http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex-ocamlyacc/ocamlyacc-tutorial/ocamlyacc-tutorial.html&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="REFERENCES"><a class="permalink" href="#REFERENCES">REFERENCES</a></h1>
<ul class="Bl-bullet">
  <li>The classic Dragon's book <i>Compilers: Principles, Techniques, and
      Tools</i> by Alfred V. Aho, Ravi Sethi and Jeffrey D. Ullman
      (Addison-Wesley 1986)</li>
  <li><i>CS2121: The Implementation and Power of Programming Languages</i> (See
      &lt;http://www.cs.man.ac.uk/~pjj&gt;,
      &lt;http://www.cs.man.ac.uk/~pjj/complang/g2lr.html&gt; and
      &lt;http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html&gt;) by Pete Jinks</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<ul class="Bl-bullet">
  <li>Hal Finkel &lt;http://www.halssoftware.com/&gt;</li>
  <li>G. Williams &lt;http://kasei.us/&gt;</li>
  <li>Thomas L. Shinnick &lt;http://search.cpan.org/~tshinnic/&gt;</li>
  <li>Frank Leray</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Casiano Rodriguez-Leon (casiano@ull.es)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGMENTS"><a class="permalink" href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a></h1>
<p class="Pp">This work has been supported by CEE (FEDER) and the Spanish
    Ministry of <i>Educacion y Ciencia</i> through <i>Plan Nacional I+D+I</i>
    number TIN2005-08818-C04-04 (ULL::OPLINK project
    &lt;http://www.oplink.ull.es/&gt;). Support from Gobierno de Canarias was
    through GC02210601 (<i>Grupos Consolidados</i>). The University of La Laguna
    has also supported my work in many ways and for many years.</p>
<p class="Pp">A large percentage of code is verbatim taken from Parse::Yapp
    1.05. The author of Parse::Yapp is Francois Desarmenien.</p>
<p class="Pp">I wish to thank Francois Desarmenien for his Parse::Yapp module,
    to my students at La Laguna and to the Perl Community. Thanks to the people
    who have contributed to improve the module (see &quot;CONTRIBUTORS&quot; in
    Parse::Eyapp). Thanks to Larry Wall for giving us Perl. Special thanks to
    Juana.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENCE_AND_COPYRIGHT"><a class="permalink" href="#LICENCE_AND_COPYRIGHT">LICENCE
  AND COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 2006-2008 Casiano Rodriguez-Leon (casiano@ull.es).
    All rights reserved.</p>
<p class="Pp">Parse::Yapp copyright is of Francois Desarmenien, all rights
    reserved. 1998-2001</p>
<p class="Pp">These modules are free software; you can redistribute it and/or
    modify it under the same terms as Perl itself. See perlartistic.</p>
<p class="Pp">This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. </p>
</section>
<section class="Sh">
<h1 class="Sh" id="POD_ERRORS"><a class="permalink" href="#POD_ERRORS">POD
  ERRORS</a></h1>
<p class="Pp">Hey! <b>The above document had some coding errors, which are
    explained below:</b></p>
<dl class="Bl-tag">
  <dt id="Around"><a class="permalink" href="#Around">Around line 814:</a></dt>
  <dd>Non-ASCII character seen before =encoding in 'XWhy?.'. Assuming
    ISO8859-1</dd>
</dl>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2012-03-23</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

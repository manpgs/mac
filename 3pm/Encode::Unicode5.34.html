<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Encode::Unicode(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Encode::Unicode(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Encode::Unicode(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Encode::Unicode -- Various Unicode Transformation Formats</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use Encode qw/encode decode/;
    $ucs2 = encode(&quot;UCS-2BE&quot;, $utf8);
    $utf8 = decode(&quot;UCS-2BE&quot;, $ucs2);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="ABSTRACT"><a class="permalink" href="#ABSTRACT">ABSTRACT</a></h1>
<p class="Pp">This module implements all Character Encoding Schemes of Unicode
    that are officially documented by Unicode Consortium (except, of course, for
    UTF-8, which is a native format in perl).</p>
<dl class="Bl-tag">
  <dt>&lt;http://www.unicode.org/glossary/&gt; says:</dt>
  <dd><i>Character Encoding Scheme</i> A character encoding form plus byte
      serialization. There are Seven character encoding schemes in Unicode:
      UTF-8, UTF-16, UTF-16BE, UTF-16LE, UTF-32 (UCS-4), UTF-32BE (UCS-4BE) and
      UTF-32LE (UCS-4LE), and UTF-7.
    <p class="Pp">Since UTF-7 is a 7-bit (re)encoded version of UTF-16BE, It is
        not part of Unicode's Character Encoding Scheme. It is separately
        implemented in Encode::Unicode::UTF7. For details see
        Encode::Unicode::UTF7.</p>
  </dd>
  <dt id="Quick"><a class="permalink" href="#Quick">Quick Reference</a></dt>
  <dd>
    <pre>                Decodes from ord(N)           Encodes chr(N) to...
       octet/char BOM S.P d800-dfff  ord &gt; 0xffff     \x{1abcd} ==
  ---------------+-----------------+------------------------------
  UCS-2BE       2   N   N  is bogus                  Not Available
  UCS-2LE       2   N   N     bogus                  Not Available
  UTF-16      2/4   Y   Y  is   S.P           S.P            BE/LE
  UTF-16BE    2/4   N   Y       S.P           S.P    0xd82a,0xdfcd
  UTF-16LE    2/4   N   Y       S.P           S.P    0x2ad8,0xcddf
  UTF-32        4   Y   -  is bogus         As is            BE/LE
  UTF-32BE      4   N   -     bogus         As is       0x0001abcd
  UTF-32LE      4   N   -     bogus         As is       0xcdab0100
  UTF-8       1-4   -   -     bogus   &gt;= 4 octets   \xf0\x9a\af\8d
  ---------------+-----------------+------------------------------
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Size,_Endianness,_and_BOM"><a class="permalink" href="#Size,_Endianness,_and_BOM">Size,
  Endianness, and BOM</a></h1>
<p class="Pp">You can categorize these CES by 3 criteria: size of each
    character, endianness, and Byte Order Mark.</p>
<section class="Ss">
<h2 class="Ss" id="by_size"><a class="permalink" href="#by_size">by
  size</a></h2>
<p class="Pp">UCS-2 is a fixed-length encoding with each character taking 16
    bits. It <b>does not</b> support <i>surrogate pairs</i>. When a surrogate
    pair is encountered during <b>decode()</b>, its place is filled with
    \x{FFFD} if <i>CHECK</i> is 0, or the routine croaks if <i>CHECK</i> is 1.
    When a character whose ord value is larger than 0xFFFF is encountered, its
    place is filled with \x{FFFD} if <i>CHECK</i> is 0, or the routine croaks if
    <i>CHECK</i> is 1.</p>
<p class="Pp">UTF-16 is almost the same as UCS-2 but it supports <i>surrogate
    pairs</i>. When it encounters a high surrogate (0xD800-0xDBFF), it fetches
    the following low surrogate (0xDC00-0xDFFF) and
    <span class="Li">&quot;desurrogate&quot;</span>s them to form a character.
    Bogus surrogates result in death. When \x{10000} or above is encountered
    during <b>encode()</b>, it <span class="Li">&quot;ensurrogate&quot;</span>s
    them and pushes the surrogate pair to the output stream.</p>
<p class="Pp">UTF-32 (UCS-4) is a fixed-length encoding with each character
    taking 32 bits. Since it is 32-bit, there is no need for <i>surrogate
    pairs</i>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="by_endianness"><a class="permalink" href="#by_endianness">by
  endianness</a></h2>
<p class="Pp">The first (and now failed) goal of Unicode was to map all
    character repertoires into a fixed-length integer so that programmers are
    happy. Since each character is either a <i>short</i> or <i>long</i> in C,
    you have to pay attention to the endianness of each platform when you pass
    data to one another.</p>
<p class="Pp">Anything marked as BE is Big Endian (or network byte order) and LE
    is Little Endian (aka VAX byte order). For anything not marked either BE or
    LE, a character called Byte Order Mark (BOM) indicating the endianness is
    prepended to the string.</p>
<p class="Pp">CAVEAT: Though BOM in utf8 (\xEF\xBB\xBF) is valid, it is
    meaningless and as of this writing Encode suite just leave it as is
    (\x{FeFF}).</p>
<dl class="Bl-tag">
  <dt id="BOM"><a class="permalink" href="#BOM">BOM as integer when fetched in
    network byte order</a></dt>
  <dd>
    <pre>              16         32 bits/char
  -------------------------
  BE      0xFeFF 0x0000FeFF
  LE      0xFFFe 0xFFFe0000
  -------------------------
    </pre>
  </dd>
</dl>
<p class="Pp">This modules handles the BOM as follows.</p>
<ul class="Bl-bullet">
  <li>When BE or LE is explicitly stated as the name of encoding, BOM is simply
      treated as a normal character (ZERO WIDTH NO-BREAK SPACE).</li>
  <li>When BE or LE is omitted during <b>decode()</b>, it checks if BOM is at
      the beginning of the string; if one is found, the endianness is set to
      what the BOM says.</li>
  <li>Default Byte Order
    <p class="Pp">When no BOM is found, Encode 2.76 and blow croaked. Since
        Encode 2.77, it falls back to BE accordingly to RFC2781 and the Unicode
        Standard version 8.0</p>
  </li>
  <li>When BE or LE is omitted during <b>encode()</b>, it returns a BE-encoded
      string with BOM prepended. So when you want to encode a whole text file,
      make sure you <b>encode()</b> the whole text at once, not line by line or
      each line, not file, will have a BOM prepended.</li>
  <li><span class="Li">&quot;UCS-2&quot;</span> is an exception. Unlike others,
      this is an alias of UCS-2BE. UCS-2 is already registered by IANA and
      others that way.</li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Surrogate_Pairs"><a class="permalink" href="#Surrogate_Pairs">Surrogate
  Pairs</a></h1>
<p class="Pp">To say the least, surrogate pairs were the biggest mistake of the
    Unicode Consortium. But according to the late Douglas Adams in <i>The</i>
    <i>Hitchhiker's Guide to the Galaxy</i> Trilogy, <span class="Li">&quot;In
    the beginning the</span> <span class="Li">Universe was created. This has
    made a lot of people very angry and</span> <span class="Li">been widely
    regarded as a bad move&quot;</span>. Their mistake was not of this magnitude
    so let's forgive them.</p>
<p class="Pp">(I don't dare make any comparison with Unicode Consortium and the
    Vogons here ;) Or, comparing Encode to Babel Fish is completely appropriate
    -- if you can only stick this into your ear :)</p>
<p class="Pp">Surrogate pairs were born when the Unicode Consortium finally
    admitted that 16 bits were not big enough to hold all the world's character
    repertoires. But they already made UCS-2 16-bit. What do we do?</p>
<p class="Pp">Back then, the range 0xD800-0xDFFF was not allocated. Let's split
    that range in half and use the first half to represent the
    <span class="Li">&quot;upper</span> <span class="Li">half of a
    character&quot;</span> and the second half to represent the
    <span class="Li">&quot;lower</span> <span class="Li">half of a
    character&quot;</span>. That way, you can represent 1024 * 1024 = 1048576
    more characters. Now we can store character ranges up to \x{10ffff} even
    with 16-bit encodings. This pair of half-character is now called a
    <i>surrogate pair</i> and UTF-16 is the name of the encoding that embraces
    them.</p>
<p class="Pp">Here is a formula to ensurrogate a Unicode character \x{10000} and
    above;</p>
<p class="Pp"></p>
<pre>  $hi = ($uni - 0x10000) / 0x400 + 0xD800;
  $lo = ($uni - 0x10000) % 0x400 + 0xDC00;
</pre>
<p class="Pp">And to desurrogate;</p>
<p class="Pp"></p>
<pre> $uni = 0x10000 + ($hi - 0xD800) * 0x400 + ($lo - 0xDC00);
</pre>
<p class="Pp">Note this move has made \x{D800}-\x{DFFF} into a forbidden zone
    but perl does not prohibit the use of characters within this range. To perl,
    every one of \x{0000_0000} up to \x{ffff_ffff} (*) is <i>a
  character</i>.</p>
<p class="Pp"></p>
<pre>  (*) or \x{ffff_ffff_ffff_ffff} if your perl is compiled with 64-bit
  integer support!
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="Error_Checking"><a class="permalink" href="#Error_Checking">Error
  Checking</a></h1>
<p class="Pp">Unlike most encodings which accept various ways to handle errors,
    Unicode encodings simply croaks.</p>
<p class="Pp"></p>
<pre>  % perl -MEncode -e'$_ = &quot;\xfe\xff\xd8\xd9\xda\xdb\0\n&quot;' \
         -e'Encode::from_to($_, &quot;utf16&quot;,&quot;shift_jis&quot;, 0); print'
  UTF-16:Malformed LO surrogate d8d9 at /path/to/Encode.pm line 184.
  % perl -MEncode -e'$a = &quot;BOM missing&quot;' \
         -e' Encode::from_to($a, &quot;utf16&quot;, &quot;shift_jis&quot;, 0); print'
  UTF-16:Unrecognised BOM 424f at /path/to/Encode.pm line 184.
</pre>
<p class="Pp">Unlike other encodings where mappings are not one-to-one against
    Unicode, UTFs are supposed to map 100% against one another. So Encode is
    more strict on UTFs.</p>
<p class="Pp">Consider that &quot;division by zero&quot; of Encode :)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Encode, Encode::Unicode::UTF7,
    &lt;http://www.unicode.org/glossary/&gt;,
    &lt;http://www.unicode.org/unicode/faq/utf_bom.html&gt;,</p>
<p class="Pp">RFC 2781 &lt;http://www.ietf.org/rfc/rfc2781.txt&gt;,</p>
<p class="Pp">The whole Unicode standard
    &lt;http://www.unicode.org/unicode/uni2book/u2.html&gt;</p>
<p class="Pp">Ch. 15, pp. 403 of <span class="Li">&quot;Programming Perl (3rd
    Edition)&quot;</span> by Larry Wall, Tom Christiansen, Jon Orwant; O'Reilly
    &amp; Associates; ISBN 0-596-00027-8</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-06-14</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

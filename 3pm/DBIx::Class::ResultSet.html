<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>DBIx::Class::ResultSet(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBIx::Class::ResultSet(3)</td>
    <td class="head-vol"><a href=".">User Contributed Perl Documentation</a></td>
    <td class="head-rtitle">DBIx::Class::ResultSet(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">DBIx::Class::ResultSet - Represents a query used for fetching a
    set of results.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  my $users_rs = $schema-&gt;resultset('User');
  while( $user = $users_rs-&gt;next) {
    print $user-&gt;username;
  }
  my $registered_users_rs = $schema-&gt;resultset('User')-&gt;search({ registered =&gt; 1 });
  my @cds_in_2005 = $schema-&gt;resultset('CD')-&gt;search({ year =&gt; 2005 })-&gt;all();
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">A ResultSet is an object which stores a set of conditions
    representing a query. It is the backbone of DBIx::Class (i.e. the really
    important/useful bit).</p>
<p class="Pp">No SQL is executed on the database when a ResultSet is created, it
    just stores all the conditions needed to create the query.</p>
<p class="Pp">A basic ResultSet representing the data of an entire table is
    returned by calling <span class="Li">&quot;resultset&quot;</span> on a
    DBIx::Class::Schema and passing in a Source name.</p>
<p class="Pp"></p>
<pre>  my $users_rs = $schema-&gt;resultset('User');
</pre>
<p class="Pp">A new ResultSet is returned from calling &quot;search&quot; on an
    existing ResultSet. The new one will contain all the conditions of the
    original, plus any new conditions added in the
    <span class="Li">&quot;search&quot;</span> call.</p>
<p class="Pp">A ResultSet also incorporates an implicit iterator.
    &quot;next&quot; and &quot;reset&quot; can be used to walk through all the
    DBIx::Class::Rows the ResultSet represents.</p>
<p class="Pp">The query that the ResultSet represents is <b>only</b> executed
    against the database when these methods are called: &quot;find&quot;,
    &quot;next&quot;, &quot;all&quot;, &quot;first&quot;, &quot;single&quot;,
    &quot;count&quot;.</p>
<p class="Pp">If a resultset is used in a numeric context it returns the
    &quot;count&quot;. However, if it is used in a boolean context it is
    <b>always</b> true. So if you want to check if a resultset has any results,
    you must use <span class="Li">&quot;if $rs</span> <span class="Li">!=
    0&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Chaining_resultsets"><a class="permalink" href="#Chaining_resultsets">Chaining
  resultsets</a></h2>
<p class="Pp">Let's say you've got a query that needs to be run to return some
    data to the user. But, you have an authorization system in place that
    prevents certain users from seeing certain information. So, you want to
    construct the basic query in one method, but add constraints to it in
    another.</p>
<p class="Pp"></p>
<pre>  sub get_data {
    my $self = shift;
    my $request = $self-&gt;get_request; # Get a request object somehow.
    my $schema = $self-&gt;result_source-&gt;schema;
    my $cd_rs = $schema-&gt;resultset('CD')-&gt;search({
      title =&gt; $request-&gt;param('title'),
      year =&gt; $request-&gt;param('year'),
    });
    $cd_rs = $self-&gt;apply_security_policy( $cd_rs );
    return $cd_rs-&gt;all();
  }
  sub apply_security_policy {
    my $self = shift;
    my ($rs) = @_;
    return $rs-&gt;search({
      subversive =&gt; 0,
    });
  }
</pre>
<p class="Pp"><i>Resolving conditions and attributes</i></p>
<p class="Pp">When a resultset is chained from another resultset (e.g.:
    <span class="Li">&quot;my $new_rs = $old_rs-&gt;search(\%extra_cond,
    \%attrs)&quot;</span>), conditions and attributes with the same keys need
    resolving.</p>
<p class="Pp">If any of &quot;columns&quot;, &quot;select&quot;, &quot;as&quot;
    are present, they reset the original selection, and start the selection
    &quot;clean&quot;.</p>
<p class="Pp">The &quot;join&quot;, &quot;prefetch&quot;, &quot;+columns&quot;,
    &quot;+select&quot;, &quot;+as&quot; attributes are merged into the existing
    ones from the original resultset.</p>
<p class="Pp">The &quot;where&quot; and &quot;having&quot; attributes, and any
    search conditions, are merged with an SQL
    <span class="Li">&quot;AND&quot;</span> to the existing condition from the
    original resultset.</p>
<p class="Pp">All other attributes are overridden by any new ones supplied in
    the search attributes.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Multiple_queries"><a class="permalink" href="#Multiple_queries">Multiple
  queries</a></h2>
<p class="Pp">Since a resultset just defines a query, you can do all sorts of
    things with it with the same object.</p>
<p class="Pp"></p>
<pre>  # Don't hit the DB yet.
  my $cd_rs = $schema-&gt;resultset('CD')-&gt;search({
    title =&gt; 'something',
    year =&gt; 2009,
  });
  # Each of these hits the DB individually.
  my $count = $cd_rs-&gt;count;
  my $most_recent = $cd_rs-&gt;get_column('date_released')-&gt;max();
  my @records = $cd_rs-&gt;all;
</pre>
<p class="Pp">And it's not just limited to SELECT statements.</p>
<p class="Pp"></p>
<pre>  $cd_rs-&gt;delete();
</pre>
<p class="Pp">This is even cooler:</p>
<p class="Pp"></p>
<pre>  $cd_rs-&gt;create({ artist =&gt; 'Fred' });
</pre>
<p class="Pp">Which is the same as:</p>
<p class="Pp"></p>
<pre>  $schema-&gt;resultset('CD')-&gt;create({
    title =&gt; 'something',
    year =&gt; 2009,
    artist =&gt; 'Fred'
  });
</pre>
<p class="Pp">See: &quot;search&quot;, &quot;count&quot;,
    &quot;get_column&quot;, &quot;all&quot;, &quot;create&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Custom_ResultSet_classes"><a class="permalink" href="#Custom_ResultSet_classes">Custom
  ResultSet classes</a></h2>
<p class="Pp">To add methods to your resultsets, you can subclass
    DBIx::Class::ResultSet, similar to:</p>
<p class="Pp"></p>
<pre>  package MyApp::Schema::ResultSet::User;
  use strict;
  use warnings;
  use base 'DBIx::Class::ResultSet';
  sub active {
    my $self = shift;
    $self-&gt;search({ $self-&gt;current_source_alias . '.active' =&gt; 1 });
  }
  sub unverified {
    my $self = shift;
    $self-&gt;search({ $self-&gt;current_source_alias . '.verified' =&gt; 0 });
  }
  sub created_n_days_ago {
    my ($self, $days_ago) = @_;
    $self-&gt;search({
      $self-&gt;current_source_alias . '.create_date' =&gt; {
        '&lt;=',
      $self-&gt;result_source-&gt;schema-&gt;storage-&gt;datetime_parser-&gt;format_datetime(
        DateTime-&gt;now( time_zone =&gt; 'UTC' )-&gt;subtract( days =&gt; $days_ago )
      )}
    });
  }
  sub users_to_warn { shift-&gt;active-&gt;unverified-&gt;created_n_days_ago(7) }
  1;
</pre>
<p class="Pp">See &quot;load_namespaces&quot; in DBIx::Class::Schema on how DBIC
    can discover and automatically attach Result-specific ResulSet classes.</p>
<p class="Pp"><i>ResultSet subclassing with Moose and similar
    constructor-providers</i></p>
<p class="Pp">Using Moose or Moo in your ResultSet classes is usually overkill,
    but you may find it useful if your ResultSets contain a lot of business
    logic (e.g. <span class="Li">&quot;has xml_parser&quot;</span>,
    <span class="Li">&quot;has json&quot;</span>, etc) or if you just prefer to
    organize your code via roles.</p>
<p class="Pp">In order to write custom ResultSet classes with Moo you need to
    use the following template. The BUILDARGS is necessary due to the unusual
    signature of the constructor provided by DBIC
  <br/>
   <span class="Li">&quot;-&gt;new($source, \%args)&quot;</span>.</p>
<p class="Pp"></p>
<pre>  use Moo;
  extends 'DBIx::Class::ResultSet';
  sub BUILDARGS { $_[2] } # ::RS::new() expects my ($class, $rsrc, $args) = @_
  ...your code...
  1;
</pre>
<p class="Pp">If you want to build your custom ResultSet classes with Moose, you
    need a similar, though a little more elaborate template in order to
    interface the inlining of the Moose-provided object constructor, with the
    DBIC one.</p>
<p class="Pp"></p>
<pre>  package MyApp::Schema::ResultSet::User;
  use Moose;
  use MooseX::NonMoose;
  extends 'DBIx::Class::ResultSet';
  sub BUILDARGS { $_[2] } # ::RS::new() expects my ($class, $rsrc, $args) = @_
  ...your code...
  __PACKAGE__-&gt;meta-&gt;make_immutable;
  1;
</pre>
<p class="Pp">The MooseX::NonMoose is necessary so that the Moose constructor
    does not entirely overwrite the DBIC one (in contrast Moo does this
    automatically). Alternatively, you can skip MooseX::NonMoose and get by with
    just Moose instead by doing:</p>
<p class="Pp"></p>
<pre>  __PACKAGE__-&gt;meta-&gt;make_immutable(inline_constructor =&gt; 0);
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:"><a class="permalink" href="#Arguments:">Arguments:
    $source, \%attrs?</a></dt>
  <dd></dd>
  <dt id="Return"><a class="permalink" href="#Return">Return Value:
    $resultset</a></dt>
  <dd></dd>
</dl>
<p class="Pp">The resultset constructor. Takes a source object (usually a
    DBIx::Class::ResultSourceProxy::Table) and an attribute hash (see
    &quot;ATTRIBUTES&quot; below). Does not perform any queries -- these are
    executed as needed by the other methods.</p>
<p class="Pp">Generally you never construct a resultset manually. Instead you
    get one from e.g. a
    <span class="Li">&quot;$schema-&gt;resultset('$source_name')&quot;</span> or
    <span class="Li">&quot;$another_resultset-&gt;search(...)&quot;</span> (the
    later called in scalar context):</p>
<p class="Pp"></p>
<pre>  my $rs = $schema-&gt;resultset('CD')-&gt;search({ title =&gt; '100th Window' });
</pre>
<dl class="Bl-tag">
  <dt id="WARNING"><a class="permalink" href="#WARNING">WARNING</a></dt>
  <dd>If called on an object, proxies to &quot;new_result&quot; instead, so
    <p class="Pp"></p>
    <pre>  my $cd = $schema-&gt;resultset('CD')-&gt;new({ title =&gt; 'Spoon' });
    </pre>
    <p class="Pp">will return a CD object, not a ResultSet, and is equivalent
        to:</p>
    <p class="Pp"></p>
    <pre>  my $cd = $schema-&gt;resultset('CD')-&gt;new_result({ title =&gt; 'Spoon' });
    </pre>
    <p class="Pp">Please also keep in mind that many internals call
        &quot;new_result&quot; directly, so overloading this method with the
        idea of intercepting new result object creation <b>will not work</b>.
        See also warning pertaining to &quot;create&quot;.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="search"><a class="permalink" href="#search">search</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~2"><a class="permalink" href="#Arguments:~2">Arguments:
    $cond | undef, \%attrs?</a></dt>
  <dd></dd>
  <dt id="Return~2"><a class="permalink" href="#Return~2">Return Value:
    $resultset (scalar context) | @result_objs (list context)</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>  my @cds    = $cd_rs-&gt;search({ year =&gt; 2001 }); # &quot;... WHERE year = 2001&quot;
  my $new_rs = $cd_rs-&gt;search({ year =&gt; 2005 });
  my $new_rs = $cd_rs-&gt;search([ { year =&gt; 2005 }, { year =&gt; 2004 } ]);
                 # year = 2005 OR year = 2004
</pre>
<p class="Pp">In list context, <span class="Li">&quot;-&gt;all()&quot;</span> is
    called implicitly on the resultset, thus returning a list of result objects
    instead. To avoid that, use &quot;search_rs&quot;.</p>
<p class="Pp">If you need to pass in additional attributes but no additional
    condition, call it as <span class="Li">&quot;search(undef,
    \%attrs)&quot;</span>.</p>
<p class="Pp"></p>
<pre>  # &quot;SELECT name, artistid FROM $artist_table&quot;
  my @all_artists = $schema-&gt;resultset('Artist')-&gt;search(undef, {
    columns =&gt; [qw/name artistid/],
  });
</pre>
<p class="Pp">For a list of attributes that can be passed to
    <span class="Li">&quot;search&quot;</span>, see &quot;ATTRIBUTES&quot;. For
    more examples of using this function, see Searching. For a complete
    documentation for the first argument, see &quot;WHERE CLAUSES&quot; in
    SQL::Abstract and its extension DBIx::Class::SQLMaker.</p>
<p class="Pp">For more help on using joins with search, see
    DBIx::Class::Manual::Joining.</p>
<p class="Pp"><i>CAVEAT</i></p>
<p class="Pp">Note that &quot;search&quot; does not process/deflate any of the
    values passed in the SQL::Abstract-compatible search condition structure.
    This is unlike other condition-bound methods &quot;new_result&quot;,
    &quot;create&quot; and &quot;find&quot;. The user must ensure manually that
    any value passed to this method will stringify to something the RDBMS knows
    how to deal with. A notable example is the handling of DateTime objects, for
    more info see: &quot;Formatting DateTime objects in queries&quot; in
    DBIx::Class::Manual::Cookbook.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="search_rs"><a class="permalink" href="#search_rs">search_rs</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~3"><a class="permalink" href="#Arguments:~3">Arguments:
    $cond, \%attrs?</a></dt>
  <dd></dd>
  <dt id="Return~3"><a class="permalink" href="#Return~3">Return Value:
    $resultset</a></dt>
  <dd></dd>
</dl>
<p class="Pp">This method does the same exact thing as <b>search()</b> except it
    will always return a resultset, even in list context.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="search_literal"><a class="permalink" href="#search_literal">search_literal</a></h2>
<p class="Pp"><b>CAVEAT</b>: <span class="Li">&quot;search_literal&quot;</span>
    is provided for Class::DBI compatibility and should only be used in that
    context. <span class="Li">&quot;search_literal&quot;</span> is a convenience
    method. It is equivalent to calling
    <span class="Li">&quot;$schema-&gt;search(\[])&quot;</span>, but if you want
    to ensure columns are bound correctly, use &quot;search&quot;.</p>
<p class="Pp">See &quot;SEARCHING&quot; in DBIx::Class::Manual::Cookbook and
    &quot;Searching&quot; in DBIx::Class::Manual::FAQ for searching techniques
    that do not require <span class="Li">&quot;search_literal&quot;</span>.</p>
<dl class="Bl-tag">
  <dt id="Arguments:~4"><a class="permalink" href="#Arguments:~4">Arguments:
    $sql_fragment, @standalone_bind_values</a></dt>
  <dd></dd>
  <dt id="Return~4"><a class="permalink" href="#Return~4">Return Value:
    $resultset (scalar context) | @result_objs (list context)</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>  my @cds   = $cd_rs-&gt;search_literal('year = ? AND title = ?', qw/2001 Reload/);
  my $newrs = $artist_rs-&gt;search_literal('name = ?', 'Metallica');
</pre>
<p class="Pp">Pass a literal chunk of SQL to be added to the conditional part of
    the resultset query.</p>
<p class="Pp">Example of how to use <span class="Li">&quot;search&quot;</span>
    instead of <span class="Li">&quot;search_literal&quot;</span></p>
<p class="Pp"></p>
<pre>  my @cds = $cd_rs-&gt;search_literal('cdid = ? AND (artist = ? OR artist = ?)', (2, 1, 2));
  my @cds = $cd_rs-&gt;search(\[ 'cdid = ? AND (artist = ? OR artist = ?)', [ 'cdid', 2 ], [ 'artist', 1 ], [ 'artist', 2 ] ]);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="find"><a class="permalink" href="#find">find</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~5"><a class="permalink" href="#Arguments:~5">Arguments:
    \%columns_values | @pk_values, { key =&gt; $unique_constraint, %attrs
    }?</a></dt>
  <dd></dd>
  <dt id="Return~5"><a class="permalink" href="#Return~5">Return Value: $result
    | undef</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Finds and returns a single row based on supplied criteria. Takes
    either a hashref with the same format as &quot;create&quot; (including
    inference of foreign keys from related objects), or a list of primary key
    values in the same order as the primary columns declaration on the
    &quot;result_source&quot;.</p>
<p class="Pp">In either case an attempt is made to combine conditions already
    existing on the resultset with the condition passed to this method.</p>
<p class="Pp">To aid with preparing the correct query for the storage you may
    supply the <span class="Li">&quot;key&quot;</span> attribute, which is the
    name of a unique constraint (the unique constraint corresponding to the
    primary columns is always named
    <span class="Li">&quot;primary&quot;</span>). If the
    <span class="Li">&quot;key&quot;</span> attribute has been supplied, and
    DBIC is unable to construct a query that satisfies the named unique
    constraint fully ( non-NULL values for each column member of the constraint)
    an exception is thrown.</p>
<p class="Pp">If no <span class="Li">&quot;key&quot;</span> is specified, the
    search is carried over all unique constraints which are fully defined by the
    available condition.</p>
<p class="Pp">If no such constraint is found,
    <span class="Li">&quot;find&quot;</span> currently defaults to a simple
    <span class="Li">&quot;search-&gt;(\%column_values)&quot;</span> which may
    or may not do what you expect. Note that this fallback behavior may be
    deprecated in further versions. If you need to search with arbitrary
    conditions - use &quot;search&quot;. If the query resulting from this
    fallback produces more than one row, a warning to the effect is issued,
    though only the first row is constructed and returned as
    <span class="Li">$result_object</span>.</p>
<p class="Pp">In addition to <span class="Li">&quot;key&quot;</span>,
    &quot;find&quot; recognizes and applies standard resultset attributes in the
    same way as &quot;search&quot; does.</p>
<p class="Pp">Note that if you have extra concerns about the correctness of the
    resulting query you need to specify the
    <span class="Li">&quot;key&quot;</span> attribute and supply the entire
    condition as an argument to find (since it is not always possible to perform
    the combination of the resultset condition with the supplied one, especially
    if the resultset condition contains literal sql).</p>
<p class="Pp">For example, to find a row by its primary key:</p>
<p class="Pp"></p>
<pre>  my $cd = $schema-&gt;resultset('CD')-&gt;find(5);
</pre>
<p class="Pp">You can also find a row by a specific unique constraint:</p>
<p class="Pp"></p>
<pre>  my $cd = $schema-&gt;resultset('CD')-&gt;find(
    {
      artist =&gt; 'Massive Attack',
      title  =&gt; 'Mezzanine',
    },
    { key =&gt; 'cd_artist_title' }
  );
</pre>
<p class="Pp">See also &quot;find_or_create&quot; and
    &quot;update_or_create&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="search_related"><a class="permalink" href="#search_related">search_related</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~6"><a class="permalink" href="#Arguments:~6">Arguments:
    $rel_name, $cond?, \%attrs?</a></dt>
  <dd></dd>
  <dt id="Return~6"><a class="permalink" href="#Return~6">Return Value:
    $resultset (scalar context) | @result_objs (list context)</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>  $new_rs = $cd_rs-&gt;search_related('artist', {
    name =&gt; 'Emo-R-Us',
  });
</pre>
<p class="Pp">Searches the specified relationship, optionally specifying a
    condition and attributes for matching records. See &quot;ATTRIBUTES&quot;
    for more information.</p>
<p class="Pp">In list context, <span class="Li">&quot;-&gt;all()&quot;</span> is
    called implicitly on the resultset, thus returning a list of result objects
    instead. To avoid that, use &quot;search_related_rs&quot;.</p>
<p class="Pp">See also &quot;search_related_rs&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="search_related_rs"><a class="permalink" href="#search_related_rs">search_related_rs</a></h2>
<p class="Pp">This method works exactly the same as search_related, except that
    it guarantees a resultset, even in list context.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="cursor"><a class="permalink" href="#cursor">cursor</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~7"><a class="permalink" href="#Arguments:~7">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~7"><a class="permalink" href="#Return~7">Return Value:
    $cursor</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Returns a storage-driven cursor to the given resultset. See
    DBIx::Class::Cursor for more information.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="single"><a class="permalink" href="#single">single</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~8"><a class="permalink" href="#Arguments:~8">Arguments:
    $cond?</a></dt>
  <dd></dd>
  <dt id="Return~8"><a class="permalink" href="#Return~8">Return Value: $result
    | undef</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>  my $cd = $schema-&gt;resultset('CD')-&gt;single({ year =&gt; 2001 });
</pre>
<p class="Pp">Inflates the first result without creating a cursor if the
    resultset has any records in it; if not returns
    <span class="Li">&quot;undef&quot;</span>. Used by &quot;find&quot; as a
    lean version of &quot;search&quot;.</p>
<p class="Pp">While this method can take an optional search condition (just like
    &quot;search&quot;) being a fast-code-path it does not recognize search
    attributes. If you need to add extra joins or similar, call
    &quot;search&quot; and then chain-call &quot;single&quot; on the
    DBIx::Class::ResultSet returned.</p>
<dl class="Bl-tag">
  <dt id="Note"><a class="permalink" href="#Note"><b>Note</b></a></dt>
  <dd>As of 0.08100, this method enforces the assumption that the preceding
      query returns only one row. If more than one row is returned, you will
      receive a warning:
    <p class="Pp"></p>
    <pre>  Query returned more than one row
    </pre>
    <p class="Pp">In this case, you should be using &quot;next&quot; or
        &quot;find&quot; instead, or if you really know what you are doing, use
        the &quot;rows&quot; attribute to explicitly limit the size of the
        resultset.</p>
    <p class="Pp">This method will also throw an exception if it is called on a
        resultset prefetching has_many, as such a prefetch implies fetching
        multiple rows from the database in order to assemble the resulting
        object.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="get_column"><a class="permalink" href="#get_column">get_column</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~9"><a class="permalink" href="#Arguments:~9">Arguments:
    $cond?</a></dt>
  <dd></dd>
  <dt id="Return~9"><a class="permalink" href="#Return~9">Return Value:
    $resultsetcolumn</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>  my $max_length = $rs-&gt;get_column('length')-&gt;max;
</pre>
<p class="Pp">Returns a DBIx::Class::ResultSetColumn instance for a column of
    the ResultSet.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="search_like"><a class="permalink" href="#search_like">search_like</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~10"><a class="permalink" href="#Arguments:~10">Arguments:
    $cond, \%attrs?</a></dt>
  <dd></dd>
  <dt id="Return~10"><a class="permalink" href="#Return~10">Return Value:
    $resultset (scalar context) | @result_objs (list context)</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>  # WHERE title LIKE '%blue%'
  $cd_rs = $rs-&gt;search_like({ title =&gt; '%blue%'});
</pre>
<p class="Pp">Performs a search, but uses
    <span class="Li">&quot;LIKE&quot;</span> instead of
    <span class="Li">&quot;=&quot;</span> as the condition. Note that this is
    simply a convenience method retained for ex Class::DBI users. You most
    likely want to use &quot;search&quot; with specific operators.</p>
<p class="Pp">For more information, see DBIx::Class::Manual::Cookbook.</p>
<p class="Pp">This method is deprecated and will be removed in 0.09. Use
    <b>search()</b> instead. An example conversion is:</p>
<p class="Pp"></p>
<pre>  -&gt;search_like({ foo =&gt; 'bar' });
  # Becomes
  -&gt;search({ foo =&gt; { like =&gt; 'bar' } });
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="slice"><a class="permalink" href="#slice">slice</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~11"><a class="permalink" href="#Arguments:~11">Arguments:
    $first, $last</a></dt>
  <dd></dd>
  <dt id="Return~11"><a class="permalink" href="#Return~11">Return Value:
    $resultset (scalar context) | @result_objs (list context)</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Returns a resultset or object list representing a subset of
    elements from the resultset slice is called on. Indexes are from 0, i.e., to
    get the first three records, call:</p>
<p class="Pp"></p>
<pre>  my ($one, $two, $three) = $rs-&gt;slice(0, 2);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="next"><a class="permalink" href="#next">next</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~12"><a class="permalink" href="#Arguments:~12">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~12"><a class="permalink" href="#Return~12">Return Value:
    $result | undef</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Returns the next element in the resultset
    (<span class="Li">&quot;undef&quot;</span> is there is none).</p>
<p class="Pp">Can be used to efficiently iterate over records in the
  resultset:</p>
<p class="Pp"></p>
<pre>  my $rs = $schema-&gt;resultset('CD')-&gt;search;
  while (my $cd = $rs-&gt;next) {
    print $cd-&gt;title;
  }
</pre>
<p class="Pp">Note that you need to store the resultset object, and call
    <span class="Li">&quot;next&quot;</span> on it. Calling
    <span class="Li">&quot;resultset('Table')-&gt;next&quot;</span> repeatedly
    will always return the first record from the resultset.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="result_source"><a class="permalink" href="#result_source">result_source</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~13"><a class="permalink" href="#Arguments:~13">Arguments:
    $result_source?</a></dt>
  <dd></dd>
  <dt id="Return~13"><a class="permalink" href="#Return~13">Return Value:
    $result_source</a></dt>
  <dd></dd>
</dl>
<p class="Pp">An accessor for the primary ResultSource object from which this
    ResultSet is derived.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="result_class"><a class="permalink" href="#result_class">result_class</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~14"><a class="permalink" href="#Arguments:~14">Arguments:
    $result_class?</a></dt>
  <dd></dd>
  <dt id="Return~14"><a class="permalink" href="#Return~14">Return Value:
    $result_class</a></dt>
  <dd></dd>
</dl>
<p class="Pp">An accessor for the class to use when creating result objects.
    Defaults to
    <span class="Li">&quot;result_source-&gt;result_class&quot;</span> - which
    in most cases is the name of the &quot;table&quot; class.</p>
<p class="Pp">Note that changing the result_class will also remove any
    components that were originally loaded in the source class via
    load_components. Any overloaded methods in the original source class will
    not run.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="count"><a class="permalink" href="#count">count</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~15"><a class="permalink" href="#Arguments:~15">Arguments:
    $cond, \%attrs?</a></dt>
  <dd></dd>
  <dt id="Return~15"><a class="permalink" href="#Return~15">Return Value:
    $count</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Performs an SQL <span class="Li">&quot;COUNT&quot;</span> with the
    same query as the resultset was built with to find the number of elements.
    Passing arguments is equivalent to <span class="Li">&quot;$rs-&gt;search
    ($cond, \%attrs)-&gt;count&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="count_rs"><a class="permalink" href="#count_rs">count_rs</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~16"><a class="permalink" href="#Arguments:~16">Arguments:
    $cond, \%attrs?</a></dt>
  <dd></dd>
  <dt id="Return~16"><a class="permalink" href="#Return~16">Return Value:
    $count_rs</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Same as &quot;count&quot; but returns a
    DBIx::Class::ResultSetColumn object. This can be very handy for
  subqueries:</p>
<p class="Pp"></p>
<pre>  -&gt;search( { amount =&gt; $some_rs-&gt;count_rs-&gt;as_query } )
</pre>
<p class="Pp">As with regular resultsets the SQL query will be executed only
    after the resultset is accessed via &quot;next&quot; or &quot;all&quot;.
    That would return the same single value obtainable via
  &quot;count&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="count_literal"><a class="permalink" href="#count_literal">count_literal</a></h2>
<p class="Pp"><b>CAVEAT</b>: <span class="Li">&quot;count_literal&quot;</span>
    is provided for Class::DBI compatibility and should only be used in that
    context. See &quot;search_literal&quot; for further info.</p>
<dl class="Bl-tag">
  <dt id="Arguments:~17"><a class="permalink" href="#Arguments:~17">Arguments:
    $sql_fragment, @standalone_bind_values</a></dt>
  <dd></dd>
  <dt id="Return~17"><a class="permalink" href="#Return~17">Return Value:
    $count</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Counts the results in a literal query. Equivalent to calling
    &quot;search_literal&quot; with the passed arguments, then
    &quot;count&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="all"><a class="permalink" href="#all">all</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~18"><a class="permalink" href="#Arguments:~18">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~18"><a class="permalink" href="#Return~18">Return Value:
    @result_objs</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Returns all elements in the resultset.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="reset"><a class="permalink" href="#reset">reset</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~19"><a class="permalink" href="#Arguments:~19">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~19"><a class="permalink" href="#Return~19">Return Value:
    $self</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Resets the resultset's cursor, so you can iterate through the
    elements again. Implicitly resets the storage cursor, so a subsequent
    &quot;next&quot; will trigger another query.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="first"><a class="permalink" href="#first">first</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~20"><a class="permalink" href="#Arguments:~20">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~20"><a class="permalink" href="#Return~20">Return Value:
    $result | undef</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Resets the resultset (causing a fresh query to storage) and
    returns an object for the first result (or
    <span class="Li">&quot;undef&quot;</span> if the resultset is empty).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="update"><a class="permalink" href="#update">update</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~21"><a class="permalink" href="#Arguments:~21">Arguments:
    \%values</a></dt>
  <dd></dd>
  <dt id="Return~21"><a class="permalink" href="#Return~21">Return Value:
    $underlying_storage_rv</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Sets the specified columns in the resultset to the supplied values
    in a single query. Note that this will not run any
    accessor/set_column/update triggers, nor will it update any result object
    instances derived from this resultset (this includes the contents of the
    resultset cache if any). See &quot;update_all&quot; if you need to execute
    any on-update triggers or cascades defined either by you or a result
    component.</p>
<p class="Pp">The return value is a pass through of what the underlying storage
    backend returned, and may vary. See &quot;execute&quot; in DBI for the most
    common case.</p>
<p class="Pp"><i>CAVEAT</i></p>
<p class="Pp">Note that &quot;update&quot; does not process/deflate any of the
    values passed in. This is unlike the corresponding &quot;update&quot; in
    DBIx::Class::Row. The user must ensure manually that any value passed to
    this method will stringify to something the RDBMS knows how to deal with. A
    notable example is the handling of DateTime objects, for more info see:
    &quot;Formatting DateTime objects in queries&quot; in
    DBIx::Class::Manual::Cookbook.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="update_all"><a class="permalink" href="#update_all">update_all</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~22"><a class="permalink" href="#Arguments:~22">Arguments:
    \%values</a></dt>
  <dd></dd>
  <dt id="Return~22"><a class="permalink" href="#Return~22">Return Value:
    1</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Fetches all objects and updates them one at a time via
    &quot;update&quot; in DBIx::Class::Row. Note that
    <span class="Li">&quot;update_all&quot;</span> will run DBIC defined
    triggers, while &quot;update&quot; will not.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="delete"><a class="permalink" href="#delete">delete</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~23"><a class="permalink" href="#Arguments:~23">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~23"><a class="permalink" href="#Return~23">Return Value:
    $underlying_storage_rv</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Deletes the rows matching this resultset in a single query. Note
    that this will not run any delete triggers, nor will it alter the in_storage
    status of any result object instances derived from this resultset (this
    includes the contents of the resultset cache if any). See
    &quot;delete_all&quot; if you need to execute any on-delete triggers or
    cascades defined either by you or a result component.</p>
<p class="Pp">The return value is a pass through of what the underlying storage
    backend returned, and may vary. See &quot;execute&quot; in DBI for the most
    common case.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="delete_all"><a class="permalink" href="#delete_all">delete_all</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~24"><a class="permalink" href="#Arguments:~24">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~24"><a class="permalink" href="#Return~24">Return Value:
    1</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Fetches all objects and deletes them one at a time via
    &quot;delete&quot; in DBIx::Class::Row. Note that
    <span class="Li">&quot;delete_all&quot;</span> will run DBIC defined
    triggers, while &quot;delete&quot; will not.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="populate"><a class="permalink" href="#populate">populate</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~25"><a class="permalink" href="#Arguments:~25">Arguments: [
    \@column_list, \@row_values+ ] | [ \%col_data+ ]</a></dt>
  <dd></dd>
  <dt id="Return~25"><a class="permalink" href="#Return~25">Return Value:
    \@result_objects (scalar context) | @result_objects (list context)</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Accepts either an arrayref of hashrefs or alternatively an
    arrayref of arrayrefs.</p>
<dl class="Bl-tag">
  <dt id="NOTE"><a class="permalink" href="#NOTE">NOTE</a></dt>
  <dd>The context of this method call has an important effect on what is
      submitted to storage. In void context data is fed directly to fastpath
      insertion routines provided by the underlying storage (most often
      &quot;execute_for_fetch&quot; in DBI), bypassing the new and insert calls
      on the Result class, including any augmentation of these methods provided
      by components. For example if you are using something like
      DBIx::Class::UUIDColumns to create primary keys for you, you will find
      that your PKs are empty. In this case you will have to explicitly force
      scalar or list context in order to create those values.</dd>
</dl>
<p class="Pp">In non-void (scalar or list) context, this method is simply a
    wrapper for &quot;create&quot;. Depending on list or scalar context either a
    list of Result objects or an arrayref containing these objects is
  returned.</p>
<p class="Pp">When supplying data in &quot;arrayref of arrayrefs&quot;
    invocation style, the first element should be a list of column names and
    each subsequent element should be a data value in the earlier specified
    column order. For example:</p>
<p class="Pp"></p>
<pre>  $schema-&gt;resultset(&quot;Artist&quot;)-&gt;populate([
    [ qw( artistid name ) ],
    [ 100, 'A Formally Unknown Singer' ],
    [ 101, 'A singer that jumped the shark two albums ago' ],
    [ 102, 'An actually cool singer' ],
  ]);
</pre>
<p class="Pp">For the arrayref of hashrefs style each hashref should be a
    structure suitable for passing to &quot;create&quot;. Multi-create is also
    permitted with this syntax.</p>
<p class="Pp"></p>
<pre>  $schema-&gt;resultset(&quot;Artist&quot;)-&gt;populate([
     { artistid =&gt; 4, name =&gt; 'Manufactured Crap', cds =&gt; [
        { title =&gt; 'My First CD', year =&gt; 2006 },
        { title =&gt; 'Yet More Tweeny-Pop crap', year =&gt; 2007 },
      ],
     },
     { artistid =&gt; 5, name =&gt; 'Angsty-Whiny Girl', cds =&gt; [
        { title =&gt; 'My parents sold me to a record company', year =&gt; 2005 },
        { title =&gt; 'Why Am I So Ugly?', year =&gt; 2006 },
        { title =&gt; 'I Got Surgery and am now Popular', year =&gt; 2007 }
      ],
     },
  ]);
</pre>
<p class="Pp">If you attempt a void-context multi-create as in the example above
    (each Artist also has the related list of CDs), and <b>do not</b> supply the
    necessary autoinc foreign key information, this method will proxy to the
    less efficient &quot;create&quot;, and then throw the Result objects away.
    In this case there are obviously no benefits to using this method over
    &quot;create&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="pager"><a class="permalink" href="#pager">pager</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~26"><a class="permalink" href="#Arguments:~26">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~26"><a class="permalink" href="#Return~26">Return Value:
    $pager</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Returns a Data::Page object for the current resultset. Only makes
    sense for queries with a <span class="Li">&quot;page&quot;</span>
  attribute.</p>
<p class="Pp">To get the full count of entries for a paged resultset, call
    <span class="Li">&quot;total_entries&quot;</span> on the Data::Page
  object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="page"><a class="permalink" href="#page">page</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~27"><a class="permalink" href="#Arguments:~27">Arguments:
    $page_number</a></dt>
  <dd></dd>
  <dt id="Return~27"><a class="permalink" href="#Return~27">Return Value:
    $resultset</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Returns a resultset for the <span class="Li">$page_number</span>
    page of the resultset on which page is called, where each page contains a
    number of rows equal to the 'rows' attribute set on the resultset (10 by
    default).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="new_result"><a class="permalink" href="#new_result">new_result</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~28"><a class="permalink" href="#Arguments:~28">Arguments:
    \%col_data</a></dt>
  <dd></dd>
  <dt id="Return~28"><a class="permalink" href="#Return~28">Return Value:
    $result</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Creates a new result object in the resultset's result class and
    returns it. The row is not inserted into the database at this point, call
    &quot;insert&quot; in DBIx::Class::Row to do that. Calling
    &quot;in_storage&quot; in DBIx::Class::Row will tell you whether the result
    object has been inserted or not.</p>
<p class="Pp">Passes the hashref of input on to &quot;new&quot; in
    DBIx::Class::Row.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="as_query"><a class="permalink" href="#as_query">as_query</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~29"><a class="permalink" href="#Arguments:~29">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~29"><a class="permalink" href="#Return~29">Return Value: \[
    $sql, @bind_values ]</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Returns the SQL query and bind vars associated with the
  invocant.</p>
<p class="Pp">This is generally used as the RHS for a subquery.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="find_or_new"><a class="permalink" href="#find_or_new">find_or_new</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~30"><a class="permalink" href="#Arguments:~30">Arguments:
    \%col_data, { key =&gt; $unique_constraint, %attrs }?</a></dt>
  <dd></dd>
  <dt id="Return~30"><a class="permalink" href="#Return~30">Return Value:
    $result</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>  my $artist = $schema-&gt;resultset('Artist')-&gt;find_or_new(
    { artist =&gt; 'fred' }, { key =&gt; 'artists' });
  $cd-&gt;cd_to_producer-&gt;find_or_new({ producer =&gt; $producer },
                                   { key =&gt; 'primary' });
</pre>
<p class="Pp">Find an existing record from this resultset using
    &quot;find&quot;. if none exists, instantiate a new result object and return
    it. The object will not be saved into your storage until you call
    &quot;insert&quot; in DBIx::Class::Row on it.</p>
<p class="Pp">You most likely want this method when looking for existing rows
    using a unique constraint that is not the primary key, or looking for
    related rows.</p>
<p class="Pp">If you want objects to be saved immediately, use
    &quot;find_or_create&quot; instead.</p>
<p class="Pp"><b>Note</b>: Make sure to read the documentation of
    &quot;find&quot; and understand the significance of the
    <span class="Li">&quot;key&quot;</span> attribute, as its lack may skew your
    search, and subsequently result in spurious new objects.</p>
<p class="Pp"><b>Note</b>: Take care when using
    <span class="Li">&quot;find_or_new&quot;</span> with a table having columns
    with default values that you intend to be automatically supplied by the
    database (e.g. an auto_increment primary key column). In normal usage, the
    value of such columns should NOT be included at all in the call to
    <span class="Li">&quot;find_or_new&quot;</span>, even when set to
    <span class="Li">&quot;undef&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="create"><a class="permalink" href="#create">create</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~31"><a class="permalink" href="#Arguments:~31">Arguments:
    \%col_data</a></dt>
  <dd></dd>
  <dt id="Return~31"><a class="permalink" href="#Return~31">Return Value:
    $result</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Attempt to create a single new row or a row with multiple related
    rows in the table represented by the resultset (and related tables). This
    will not check for duplicate rows before inserting, use
    &quot;find_or_create&quot; to do that.</p>
<p class="Pp">To create one row for this resultset, pass a hashref of key/value
    pairs representing the columns of the table and the values you wish to
    store. If the appropriate relationships are set up, foreign key fields can
    also be passed an object representing the foreign row, and the value will be
    set to its primary key.</p>
<p class="Pp">To create related objects, pass a hashref of related-object column
    values <b>keyed on the relationship name</b>. If the relationship is of type
    <span class="Li">&quot;multi&quot;</span> (&quot;has_many&quot; in
    DBIx::Class::Relationship) - pass an arrayref of hashrefs. The process will
    correctly identify columns holding foreign keys, and will transparently
    populate them from the keys of the corresponding relation. This can be
    applied recursively, and will work correctly for a structure with an
    arbitrary depth and width, as long as the relationships actually exists and
    the correct column data has been supplied.</p>
<p class="Pp">Instead of hashrefs of plain related data (key/value pairs), you
    may also pass new or inserted objects. New objects (not inserted yet, see
    &quot;new_result&quot;), will be inserted into their appropriate tables.</p>
<p class="Pp">Effectively a shortcut for
    <span class="Li">&quot;-&gt;new_result(\%col_data)-&gt;insert&quot;</span>.</p>
<p class="Pp">Example of creating a new row.</p>
<p class="Pp"></p>
<pre>  $person_rs-&gt;create({
    name=&gt;&quot;Some Person&quot;,
    email=&gt;&quot;somebody@someplace.com&quot;
  });
</pre>
<p class="Pp">Example of creating a new row and also creating rows in a related
    <span class="Li">&quot;has_many&quot;</span> or
    <span class="Li">&quot;has_one&quot;</span> resultset. Note Arrayref.</p>
<p class="Pp"></p>
<pre>  $artist_rs-&gt;create(
     { artistid =&gt; 4, name =&gt; 'Manufactured Crap', cds =&gt; [
        { title =&gt; 'My First CD', year =&gt; 2006 },
        { title =&gt; 'Yet More Tweeny-Pop crap', year =&gt; 2007 },
      ],
     },
  );
</pre>
<p class="Pp">Example of creating a new row and also creating a row in a related
    <span class="Li">&quot;belongs_to&quot;</span> resultset. Note Hashref.</p>
<p class="Pp"></p>
<pre>  $cd_rs-&gt;create({
    title=&gt;&quot;Music for Silly Walks&quot;,
    year=&gt;2000,
    artist =&gt; {
      name=&gt;&quot;Silly Musician&quot;,
    }
  });
</pre>
<dl class="Bl-tag">
  <dt id="WARNING~2"><a class="permalink" href="#WARNING~2">WARNING</a></dt>
  <dd>When subclassing ResultSet never attempt to override this method. Since it
      is a simple shortcut for
      <span class="Li">&quot;$self-&gt;new_result($attrs)-&gt;insert&quot;</span>,
      a lot of the internals simply never call it, so your override will be
      bypassed more often than not. Override either &quot;new&quot; in
      DBIx::Class::Row or &quot;insert&quot; in DBIx::Class::Row depending on
      how early in the &quot;create&quot; process you need to intervene. See
      also warning pertaining to &quot;new&quot;.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="find_or_create"><a class="permalink" href="#find_or_create">find_or_create</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~32"><a class="permalink" href="#Arguments:~32">Arguments:
    \%col_data, { key =&gt; $unique_constraint, %attrs }?</a></dt>
  <dd></dd>
  <dt id="Return~32"><a class="permalink" href="#Return~32">Return Value:
    $result</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>  $cd-&gt;cd_to_producer-&gt;find_or_create({ producer =&gt; $producer },
                                      { key =&gt; 'primary' });
</pre>
<p class="Pp">Tries to find a record based on its primary key or unique
    constraints; if none is found, creates one and returns that instead.</p>
<p class="Pp"></p>
<pre>  my $cd = $schema-&gt;resultset('CD')-&gt;find_or_create({
    cdid   =&gt; 5,
    artist =&gt; 'Massive Attack',
    title  =&gt; 'Mezzanine',
    year   =&gt; 2005,
  });
</pre>
<p class="Pp">Also takes an optional <span class="Li">&quot;key&quot;</span>
    attribute, to search by a specific key or unique constraint. For
  example:</p>
<p class="Pp"></p>
<pre>  my $cd = $schema-&gt;resultset('CD')-&gt;find_or_create(
    {
      artist =&gt; 'Massive Attack',
      title  =&gt; 'Mezzanine',
    },
    { key =&gt; 'cd_artist_title' }
  );
</pre>
<p class="Pp"><b>Note</b>: Make sure to read the documentation of
    &quot;find&quot; and understand the significance of the
    <span class="Li">&quot;key&quot;</span> attribute, as its lack may skew your
    search, and subsequently result in spurious row creation.</p>
<p class="Pp"><b>Note</b>: Because <b>find_or_create()</b> reads from the
    database and then possibly inserts based on the result, this method is
    subject to a race condition. Another process could create a record in the
    table after the find has completed and before the create has started. To
    avoid this problem, use <b>find_or_create()</b> inside a transaction.</p>
<p class="Pp"><b>Note</b>: Take care when using
    <span class="Li">&quot;find_or_create&quot;</span> with a table having
    columns with default values that you intend to be automatically supplied by
    the database (e.g. an auto_increment primary key column). In normal usage,
    the value of such columns should NOT be included at all in the call to
    <span class="Li">&quot;find_or_create&quot;</span>, even when set to
    <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp">See also &quot;find&quot; and &quot;update_or_create&quot;. For
    information on how to declare unique constraints, see
    &quot;add_unique_constraint&quot; in DBIx::Class::ResultSource.</p>
<p class="Pp">If you need to know if an existing row was found or a new one
    created use &quot;find_or_new&quot; and &quot;in_storage&quot; in
    DBIx::Class::Row instead. Don't forget to call &quot;insert&quot; in
    DBIx::Class::Row to save the newly created row to the database!</p>
<p class="Pp"></p>
<pre>  my $cd = $schema-&gt;resultset('CD')-&gt;find_or_new({
    cdid   =&gt; 5,
    artist =&gt; 'Massive Attack',
    title  =&gt; 'Mezzanine',
    year   =&gt; 2005,
  });
  if( !$cd-&gt;in_storage ) {
      # do some stuff
      $cd-&gt;insert;
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="update_or_create"><a class="permalink" href="#update_or_create">update_or_create</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~33"><a class="permalink" href="#Arguments:~33">Arguments:
    \%col_data, { key =&gt; $unique_constraint, %attrs }?</a></dt>
  <dd></dd>
  <dt id="Return~33"><a class="permalink" href="#Return~33">Return Value:
    $result</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>  $resultset-&gt;update_or_create({ col =&gt; $val, ... });
</pre>
<p class="Pp">Like &quot;find_or_create&quot;, but if a row is found it is
    immediately updated via <span class="Li">&quot;$found_row-&gt;update
    (\%col_data)&quot;</span>.</p>
<p class="Pp">Takes an optional <span class="Li">&quot;key&quot;</span>
    attribute to search on a specific unique constraint. For example:</p>
<p class="Pp"></p>
<pre>  # In your application
  my $cd = $schema-&gt;resultset('CD')-&gt;update_or_create(
    {
      artist =&gt; 'Massive Attack',
      title  =&gt; 'Mezzanine',
      year   =&gt; 1998,
    },
    { key =&gt; 'cd_artist_title' }
  );
  $cd-&gt;cd_to_producer-&gt;update_or_create({
    producer =&gt; $producer,
    name =&gt; 'harry',
  }, {
    key =&gt; 'primary',
  });
</pre>
<p class="Pp"><b>Note</b>: Make sure to read the documentation of
    &quot;find&quot; and understand the significance of the
    <span class="Li">&quot;key&quot;</span> attribute, as its lack may skew your
    search, and subsequently result in spurious row creation.</p>
<p class="Pp"><b>Note</b>: Take care when using
    <span class="Li">&quot;update_or_create&quot;</span> with a table having
    columns with default values that you intend to be automatically supplied by
    the database (e.g. an auto_increment primary key column). In normal usage,
    the value of such columns should NOT be included at all in the call to
    <span class="Li">&quot;update_or_create&quot;</span>, even when set to
    <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp">See also &quot;find&quot; and &quot;find_or_create&quot;. For
    information on how to declare unique constraints, see
    &quot;add_unique_constraint&quot; in DBIx::Class::ResultSource.</p>
<p class="Pp">If you need to know if an existing row was updated or a new one
    created use &quot;update_or_new&quot; and &quot;in_storage&quot; in
    DBIx::Class::Row instead. Don't forget to call &quot;insert&quot; in
    DBIx::Class::Row to save the newly created row to the database!</p>
</section>
<section class="Ss">
<h2 class="Ss" id="update_or_new"><a class="permalink" href="#update_or_new">update_or_new</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~34"><a class="permalink" href="#Arguments:~34">Arguments:
    \%col_data, { key =&gt; $unique_constraint, %attrs }?</a></dt>
  <dd></dd>
  <dt id="Return~34"><a class="permalink" href="#Return~34">Return Value:
    $result</a></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<pre>  $resultset-&gt;update_or_new({ col =&gt; $val, ... });
</pre>
<p class="Pp">Like &quot;find_or_new&quot; but if a row is found it is
    immediately updated via <span class="Li">&quot;$found_row-&gt;update
    (\%col_data)&quot;</span>.</p>
<p class="Pp">For example:</p>
<p class="Pp"></p>
<pre>  # In your application
  my $cd = $schema-&gt;resultset('CD')-&gt;update_or_new(
    {
      artist =&gt; 'Massive Attack',
      title  =&gt; 'Mezzanine',
      year   =&gt; 1998,
    },
    { key =&gt; 'cd_artist_title' }
  );
  if ($cd-&gt;in_storage) {
      # the cd was updated
  }
  else {
      # the cd is not yet in the database, let's insert it
      $cd-&gt;insert;
  }
</pre>
<p class="Pp"><b>Note</b>: Make sure to read the documentation of
    &quot;find&quot; and understand the significance of the
    <span class="Li">&quot;key&quot;</span> attribute, as its lack may skew your
    search, and subsequently result in spurious new objects.</p>
<p class="Pp"><b>Note</b>: Take care when using
    <span class="Li">&quot;update_or_new&quot;</span> with a table having
    columns with default values that you intend to be automatically supplied by
    the database (e.g. an auto_increment primary key column). In normal usage,
    the value of such columns should NOT be included at all in the call to
    <span class="Li">&quot;update_or_new&quot;</span>, even when set to
    <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp">See also &quot;find&quot;, &quot;find_or_create&quot; and
    &quot;find_or_new&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="get_cache"><a class="permalink" href="#get_cache">get_cache</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~35"><a class="permalink" href="#Arguments:~35">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~35"><a class="permalink" href="#Return~35">Return Value:
    \@result_objs | undef</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Gets the contents of the cache for the resultset, if the cache is
    set.</p>
<p class="Pp">The cache is populated either by using the &quot;prefetch&quot;
    attribute to &quot;search&quot; or by calling &quot;set_cache&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="set_cache"><a class="permalink" href="#set_cache">set_cache</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~36"><a class="permalink" href="#Arguments:~36">Arguments:
    \@result_objs</a></dt>
  <dd></dd>
  <dt id="Return~36"><a class="permalink" href="#Return~36">Return Value:
    \@result_objs</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Sets the contents of the cache for the resultset. Expects an
    arrayref of objects of the same class as those produced by the resultset.
    Note that if the cache is set, the resultset will return the cached objects
    rather than re-querying the database even if the cache attr is not set.</p>
<p class="Pp">The contents of the cache can also be populated by using the
    &quot;prefetch&quot; attribute to &quot;search&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="clear_cache"><a class="permalink" href="#clear_cache">clear_cache</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~37"><a class="permalink" href="#Arguments:~37">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~37"><a class="permalink" href="#Return~37">Return Value:
    undef</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Clears the cache for the resultset.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="is_paged"><a class="permalink" href="#is_paged">is_paged</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~38"><a class="permalink" href="#Arguments:~38">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~38"><a class="permalink" href="#Return~38">Return Value: true,
    if the resultset has been paginated</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="is_ordered"><a class="permalink" href="#is_ordered">is_ordered</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~39"><a class="permalink" href="#Arguments:~39">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~39"><a class="permalink" href="#Return~39">Return Value: true,
    if the resultset has been ordered with &quot;order_by&quot;.</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="related_resultset"><a class="permalink" href="#related_resultset">related_resultset</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~40"><a class="permalink" href="#Arguments:~40">Arguments:
    $rel_name</a></dt>
  <dd></dd>
  <dt id="Return~40"><a class="permalink" href="#Return~40">Return Value:
    $resultset</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Returns a related resultset for the supplied relationship
  name.</p>
<p class="Pp"></p>
<pre>  $artist_rs = $schema-&gt;resultset('CD')-&gt;related_resultset('Artist');
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="current_source_alias"><a class="permalink" href="#current_source_alias">current_source_alias</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~41"><a class="permalink" href="#Arguments:~41">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~41"><a class="permalink" href="#Return~41">Return Value:
    $source_alias</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Returns the current table alias for the result source this
    resultset is built on, that will be used in the SQL query. Usually it is
    <span class="Li">&quot;me&quot;</span>.</p>
<p class="Pp">Currently the source alias that refers to the result set returned
    by a &quot;search&quot;/&quot;find&quot; family method depends on how you
    got to the resultset: it's <span class="Li">&quot;me&quot;</span> by
    default, but eg. &quot;search_related&quot; aliases it to the related result
    source name (and keeps <span class="Li">&quot;me&quot;</span> referring to
    the original result set). The long term goal is to make DBIx::Class always
    alias the current resultset as <span class="Li">&quot;me&quot;</span> (and
    make this method unnecessary).</p>
<p class="Pp">Thus it's currently necessary to use this method in predefined
    queries (see &quot;Predefined searches&quot; in
    DBIx::Class::Manual::Cookbook) when referring to the source alias of the
    current result set:</p>
<p class="Pp"></p>
<pre>  # in a result set class
  sub modified_by {
    my ($self, $user) = @_;
    my $me = $self-&gt;current_source_alias;
    return $self-&gt;search({
      &quot;$me.modified&quot; =&gt; $user-&gt;id,
    });
  }
</pre>
<p class="Pp">The alias of newly created resultsets can be altered by the alias
    attribute.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="as_subselect_rs"><a class="permalink" href="#as_subselect_rs">as_subselect_rs</a></h2>
<dl class="Bl-tag">
  <dt id="Arguments:~42"><a class="permalink" href="#Arguments:~42">Arguments:
    none</a></dt>
  <dd></dd>
  <dt id="Return~42"><a class="permalink" href="#Return~42">Return Value:
    $resultset</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Act as a barrier to SQL symbols. The resultset provided will be
    made into a &quot;virtual view&quot; by including it as a subquery within
    the from clause. From this point on, any joined tables are inaccessible to
    -&gt;search on the resultset (as if it were simply where-filtered without
    joins). For example:</p>
<p class="Pp"></p>
<pre> my $rs = $schema-&gt;resultset('Bar')-&gt;search({'x.name' =&gt; 'abc'},{ join =&gt; 'x' });
 # 'x' now pollutes the query namespace
 # So the following works as expected
 my $ok_rs = $rs-&gt;search({'x.other' =&gt; 1});
 # But this doesn't: instead of finding a 'Bar' related to two x rows (abc and
 # def) we look for one row with contradictory terms and join in another table
 # (aliased 'x_2') which we never use
 my $broken_rs = $rs-&gt;search({'x.name' =&gt; 'def'});
 my $rs2 = $rs-&gt;as_subselect_rs;
 # doesn't work - 'x' is no longer accessible in $rs2, having been sealed away
 my $not_joined_rs = $rs2-&gt;search({'x.other' =&gt; 1});
 # works as expected: finds a 'table' row related to two x rows (abc and def)
 my $correctly_joined_rs = $rs2-&gt;search({'x.name' =&gt; 'def'});
</pre>
<p class="Pp">Another example of when one might use this would be to select a
    subset of columns in a group by clause:</p>
<p class="Pp"></p>
<pre> my $rs = $schema-&gt;resultset('Bar')-&gt;search(undef, {
   group_by =&gt; [qw{ id foo_id baz_id }],
 })-&gt;as_subselect_rs-&gt;search(undef, {
   columns =&gt; [qw{ id foo_id }]
 });
</pre>
<p class="Pp">In the above example normally columns would have to be equal to
    the group by, but because we isolated the group by into a subselect the
    above works.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="throw_exception"><a class="permalink" href="#throw_exception">throw_exception</a></h2>
<p class="Pp">See &quot;throw_exception&quot; in DBIx::Class::Schema for
    details.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ATTRIBUTES"><a class="permalink" href="#ATTRIBUTES">ATTRIBUTES</a></h1>
<p class="Pp">Attributes are used to refine a ResultSet in various ways when
    searching for data. They can be passed to any method which takes an
    <span class="Li">&quot;\%attrs&quot;</span> argument. See
    &quot;search&quot;, &quot;search_rs&quot;, &quot;find&quot;,
    &quot;count&quot;.</p>
<p class="Pp">Default attributes can be set on the result class using
    &quot;resultset_attributes&quot; in DBIx::Class::ResultSource. (Please read
    the CAVEATS on that feature before using it!)</p>
<p class="Pp">These are in no particular order:</p>
<section class="Ss">
<h2 class="Ss" id="order_by"><a class="permalink" href="#order_by">order_by</a></h2>
<dl class="Bl-tag">
  <dt id="Value:"><a class="permalink" href="#Value:">Value: ( $order_by |
    \@order_by | \%order_by )</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Which column(s) to order the results by.</p>
<p class="Pp">[The full list of suitable values is documented in &quot;ORDER BY
    CLAUSES&quot; in SQL::Abstract; the following is a summary of common
    options.]</p>
<p class="Pp">If a single column name, or an arrayref of names is supplied, the
    argument is passed through directly to SQL. The hashref syntax allows for
    connection-agnostic specification of ordering direction:</p>
<p class="Pp"></p>
<pre> For descending order:
  order_by =&gt; { -desc =&gt; [qw/col1 col2 col3/] }
 For explicit ascending order:
  order_by =&gt; { -asc =&gt; 'col' }
</pre>
<p class="Pp">The old scalarref syntax (i.e. order_by =&gt; \'year DESC') is
    still supported, although you are strongly encouraged to use the hashref
    syntax as outlined above.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="columns"><a class="permalink" href="#columns">columns</a></h2>
<dl class="Bl-tag">
  <dt id="Value:~2"><a class="permalink" href="#Value:~2">Value: \@columns |
    \%columns | $column</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Shortcut to request a particular set of columns to be retrieved.
    Each column spec may be a string (a table column name), or a hash (in which
    case the key is the <span class="Li">&quot;as&quot;</span> value, and the
    value is used as the <span class="Li">&quot;select&quot;</span> expression).
    Adds the &quot;current_source_alias&quot; onto the start of any column
    without a <span class="Li">&quot;.&quot;</span> in it and sets
    <span class="Li">&quot;select&quot;</span> from that, then auto-populates
    <span class="Li">&quot;as&quot;</span> from
    <span class="Li">&quot;select&quot;</span> as normal. (You may also use the
    <span class="Li">&quot;cols&quot;</span> attribute, as in earlier versions
    of DBIC, but this is deprecated)</p>
<p class="Pp">Essentially <span class="Li">&quot;columns&quot;</span> does the
    same as &quot;select&quot; and &quot;as&quot;.</p>
<p class="Pp"></p>
<pre>    columns =&gt; [ 'some_column', { dbic_slot =&gt; 'another_column' } ]
</pre>
<p class="Pp">is the same as</p>
<p class="Pp"></p>
<pre>    select =&gt; [qw(some_column another_column)],
    as     =&gt; [qw(some_column dbic_slot)]
</pre>
<p class="Pp">If you want to individually retrieve related columns (in essence
    perform manual &quot;prefetch&quot;) you have to make sure to specify the
    correct inflation slot chain such that it matches existing
  relationships:</p>
<p class="Pp"></p>
<pre>    my $rs = $schema-&gt;resultset('Artist')-&gt;search({}, {
        # required to tell DBIC to collapse has_many relationships
        collapse =&gt; 1,
        join     =&gt; { cds =&gt; 'tracks' },
        '+columns'  =&gt; {
          'cds.cdid'         =&gt; 'cds.cdid',
          'cds.tracks.title' =&gt; 'tracks.title',
        },
    });
</pre>
<p class="Pp">Like elsewhere, literal SQL or literal values can be included by
    using a scalar reference or a literal bind value, and these values will be
    available in the result with <span class="Li">&quot;get_column&quot;</span>
    (see also &quot;Literal SQL and value type operators&quot; in
    SQL::Abstract):</p>
<p class="Pp"></p>
<pre>    # equivalent SQL: SELECT 1, 'a string', IF(my_column,?,?) ...
    # bind values: $true_value, $false_value
    columns =&gt; [
        {
            foo =&gt; \1,
            bar =&gt; \q{'a string'},
            baz =&gt; \[ 'IF(my_column,?,?)', $true_value, $false_value ],
        }
    ]
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="+columns"><a class="permalink" href="#+columns">+columns</a></h2>
<p class="Pp"><b>NOTE:</b> You <b>MUST</b> explicitly quote
    <span class="Li">'+columns'</span> when using this attribute. Not doing so
    causes Perl to incorrectly interpret
    <span class="Li">&quot;+columns&quot;</span> as a bareword with a unary plus
    operator before it, which is the same as simply
    <span class="Li">&quot;columns&quot;</span>.</p>
<dl class="Bl-tag">
  <dt id="Value:~3"><a class="permalink" href="#Value:~3">Value:
    \@extra_columns</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Indicates additional columns to be selected from storage. Works
    the same as &quot;columns&quot; but adds columns to the current selection.
    (You may also use the <span class="Li">&quot;include_columns&quot;</span>
    attribute, as in earlier versions of DBIC, but this is deprecated)</p>
<p class="Pp"></p>
<pre>  $schema-&gt;resultset('CD')-&gt;search(undef, {
    '+columns' =&gt; ['artist.name'],
    join =&gt; ['artist']
  });
</pre>
<p class="Pp">would return all CDs and include a 'name' column to the
    information passed to object inflation. Note that the 'artist' is the name
    of the column (or relationship) accessor, and 'name' is the name of the
    column accessor in the related table.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="select"><a class="permalink" href="#select">select</a></h2>
<dl class="Bl-tag">
  <dt id="Value:~4"><a class="permalink" href="#Value:~4">Value:
    \@select_columns</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Indicates which columns should be selected from the storage. You
    can use column names, or in the case of RDBMS back ends, function or stored
    procedure names:</p>
<p class="Pp"></p>
<pre>  $rs = $schema-&gt;resultset('Employee')-&gt;search(undef, {
    select =&gt; [
      'name',
      { count =&gt; 'employeeid' },
      { max =&gt; { length =&gt; 'name' }, -as =&gt; 'longest_name' }
    ]
  });
  # Equivalent SQL
  SELECT name, COUNT( employeeid ), MAX( LENGTH( name ) ) AS longest_name FROM employee
</pre>
<p class="Pp"><b>NOTE:</b> You will almost always need a corresponding
    &quot;as&quot; attribute when you use &quot;select&quot;, to instruct
    DBIx::Class how to store the result of the column.</p>
<p class="Pp">Also note that the &quot;as&quot; attribute has <b>nothing to
    do</b> with the SQL-side <span class="Li">&quot;AS&quot;</span> identifier
    aliasing. You <b>can</b> alias a function (so you can use it e.g. in an
    <span class="Li">&quot;ORDER BY&quot;</span> clause), however this is done
    via the <span class="Li">&quot;-as&quot;</span> <b>select</b> <b>function
    attribute</b> supplied as shown in the example above.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="+select"><a class="permalink" href="#+select">+select</a></h2>
<p class="Pp"><b>NOTE:</b> You <b>MUST</b> explicitly quote
    <span class="Li">'+select'</span> when using this attribute. Not doing so
    causes Perl to incorrectly interpret
    <span class="Li">&quot;+select&quot;</span> as a bareword with a unary plus
    operator before it, which is the same as simply
    <span class="Li">&quot;select&quot;</span>.</p>
<dl class="Bl-tag">
  <dt id="Value:~5"><a class="permalink" href="#Value:~5">Value:
    \@extra_select_columns</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Indicates additional columns to be selected from storage. Works
    the same as &quot;select&quot; but adds columns to the current selection,
    instead of specifying a new explicit list.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="as"><a class="permalink" href="#as">as</a></h2>
<dl class="Bl-tag">
  <dt id="Value:~6"><a class="permalink" href="#Value:~6">Value:
    \@inflation_names</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Indicates DBIC-side names for object inflation. That is
    &quot;as&quot; indicates the slot name in which the column value will be
    stored within the Row object. The value will then be accessible via this
    identifier by the <span class="Li">&quot;get_column&quot;</span> method (or
    via the object accessor <b>if one</b> <b>with the same name already
    exists</b>) as shown below.</p>
<p class="Pp">The &quot;as&quot; attribute has <b>nothing to do</b> with the
    SQL-side identifier aliasing <span class="Li">&quot;AS&quot;</span>. See
    &quot;select&quot; for details.</p>
<p class="Pp"></p>
<pre>  $rs = $schema-&gt;resultset('Employee')-&gt;search(undef, {
    select =&gt; [
      'name',
      { count =&gt; 'employeeid' },
      { max =&gt; { length =&gt; 'name' }, -as =&gt; 'longest_name' }
    ],
    as =&gt; [qw/
      name
      employee_count
      max_name_length
    /],
  });
</pre>
<p class="Pp">If the object against which the search is performed already has an
    accessor matching a column name specified in
    <span class="Li">&quot;as&quot;</span>, the value can be retrieved using the
    accessor as normal:</p>
<p class="Pp"></p>
<pre>  my $name = $employee-&gt;name();
</pre>
<p class="Pp">If on the other hand an accessor does not exist in the object, you
    need to use <span class="Li">&quot;get_column&quot;</span> instead:</p>
<p class="Pp"></p>
<pre>  my $employee_count = $employee-&gt;get_column('employee_count');
</pre>
<p class="Pp">You can create your own accessors if required - see
    DBIx::Class::Manual::Cookbook for details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="+as"><a class="permalink" href="#+as">+as</a></h2>
<p class="Pp"><b>NOTE:</b> You <b>MUST</b> explicitly quote
    <span class="Li">'+as'</span> when using this attribute. Not doing so causes
    Perl to incorrectly interpret <span class="Li">&quot;+as&quot;</span> as a
    bareword with a unary plus operator before it, which is the same as simply
    <span class="Li">&quot;as&quot;</span>.</p>
<dl class="Bl-tag">
  <dt id="Value:~7"><a class="permalink" href="#Value:~7">Value:
    \@extra_inflation_names</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Indicates additional inflation names for selectors added via
    &quot;+select&quot;. See &quot;as&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="join"><a class="permalink" href="#join">join</a></h2>
<dl class="Bl-tag">
  <dt id="Value:~8"><a class="permalink" href="#Value:~8">Value: ($rel_name |
    \@rel_names | \%rel_names)</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Contains a list of relationships that should be joined for this
    query. For example:</p>
<p class="Pp"></p>
<pre>  # Get CDs by Nine Inch Nails
  my $rs = $schema-&gt;resultset('CD')-&gt;search(
    { 'artist.name' =&gt; 'Nine Inch Nails' },
    { join =&gt; 'artist' }
  );
</pre>
<p class="Pp">Can also contain a hash reference to refer to the other relation's
    relations. For example:</p>
<p class="Pp"></p>
<pre>  package MyApp::Schema::Track;
  use base qw/DBIx::Class/;
  __PACKAGE__-&gt;table('track');
  __PACKAGE__-&gt;add_columns(qw/trackid cd position title/);
  __PACKAGE__-&gt;set_primary_key('trackid');
  __PACKAGE__-&gt;belongs_to(cd =&gt; 'MyApp::Schema::CD');
  1;
  # In your application
  my $rs = $schema-&gt;resultset('Artist')-&gt;search(
    { 'track.title' =&gt; 'Teardrop' },
    {
      join     =&gt; { cd =&gt; 'track' },
      order_by =&gt; 'artist.name',
    }
  );
</pre>
<p class="Pp">You need to use the relationship (not the table) name in
    conditions, because they are aliased as such. The current table is aliased
    as &quot;me&quot;, so you need to use me.column_name in order to avoid
    ambiguity. For example:</p>
<p class="Pp"></p>
<pre>  # Get CDs from 1984 with a 'Foo' track
  my $rs = $schema-&gt;resultset('CD')-&gt;search(
    {
      'me.year' =&gt; 1984,
      'tracks.name' =&gt; 'Foo'
    },
    { join =&gt; 'tracks' }
  );
</pre>
<p class="Pp">If the same join is supplied twice, it will be aliased to
    &lt;rel&gt;_2 (and similarly for a third time). For e.g.</p>
<p class="Pp"></p>
<pre>  my $rs = $schema-&gt;resultset('Artist')-&gt;search({
    'cds.title'   =&gt; 'Down to Earth',
    'cds_2.title' =&gt; 'Popular',
  }, {
    join =&gt; [ qw/cds cds/ ],
  });
</pre>
<p class="Pp">will return a set of all artists that have both a cd with title
    'Down to Earth' and a cd with title 'Popular'.</p>
<p class="Pp">If you want to fetch related objects from other tables as well,
    see &quot;prefetch&quot; below.</p>
<p class="Pp"></p>
<pre> NOTE: An internal join-chain pruner will discard certain joins while
 constructing the actual SQL query, as long as the joins in question do not
 affect the retrieved result. This for example includes 1:1 left joins
 that are not part of the restriction specification (WHERE/HAVING) nor are
 a part of the query selection.
</pre>
<p class="Pp">For more help on using joins with search, see
    DBIx::Class::Manual::Joining.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="collapse"><a class="permalink" href="#collapse">collapse</a></h2>
<dl class="Bl-tag">
  <dt id="Value:~9"><a class="permalink" href="#Value:~9">Value: (0 |
    1)</a></dt>
  <dd></dd>
</dl>
<p class="Pp">When set to a true value, indicates that any rows fetched from
    joined has_many relationships are to be aggregated into the corresponding
    &quot;parent&quot; object. For example, the resultset:</p>
<p class="Pp"></p>
<pre>  my $rs = $schema-&gt;resultset('CD')-&gt;search({}, {
    '+columns' =&gt; [ qw/ tracks.title tracks.position / ],
    join =&gt; 'tracks',
    collapse =&gt; 1,
  });
</pre>
<p class="Pp">While executing the following query:</p>
<p class="Pp"></p>
<pre>  SELECT me.*, tracks.title, tracks.position
    FROM cd me
    LEFT JOIN track tracks
      ON tracks.cdid = me.cdid
</pre>
<p class="Pp">Will return only as many objects as there are rows in the CD
    source, even though the result of the query may span many rows. Each of
    these CD objects will in turn have multiple &quot;Track&quot; objects hidden
    behind the has_many generated accessor
    <span class="Li">&quot;tracks&quot;</span>. Without
    <span class="Li">&quot;collapse =&gt; 1&quot;</span>, the return values of
    this resultset would be as many CD objects as there are tracks (a
    &quot;Cartesian product&quot;), with each CD object containing exactly one
    of all fetched Track data.</p>
<p class="Pp">When a collapse is requested on a non-ordered resultset, an order
    by some unique part of the main source (the left-most table) is inserted
    automatically. This is done so that the resultset is allowed to be
    &quot;lazy&quot; - calling <span class="Li">$rs</span>-&gt;next will fetch
    only as many rows as it needs to build the next object with all of its
    related data.</p>
<p class="Pp">If an &quot;order_by&quot; is already declared, and orders the
    resultset in a way that makes collapsing as described above impossible (e.g.
    <span class="Li">&quot;ORDER BY</span>
    <span class="Li">has_many_rel.column&quot;</span> or
    <span class="Li">&quot;ORDER BY RANDOM()&quot;</span>), DBIC will
    automatically switch to &quot;eager&quot; mode and slurp the entire
    resultset before constructing the first object returned by
  &quot;next&quot;.</p>
<p class="Pp">Setting this attribute on a resultset that does not join any
    has_many relations is a no-op.</p>
<p class="Pp">For a more in-depth discussion, see &quot;PREFETCHING&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="prefetch"><a class="permalink" href="#prefetch">prefetch</a></h2>
<dl class="Bl-tag">
  <dt id="Value:~10"><a class="permalink" href="#Value:~10">Value: ($rel_name |
    \@rel_names | \%rel_names)</a></dt>
  <dd></dd>
</dl>
<p class="Pp">This attribute is a shorthand for specifying a &quot;join&quot;
    spec, adding all columns from the joined related sources as
    &quot;+columns&quot; and setting &quot;collapse&quot; to a true value. It
    can be thought of as a rough <b>superset</b> of the &quot;join&quot;
    attribute.</p>
<p class="Pp">For example, the following two queries are equivalent:</p>
<p class="Pp"></p>
<pre>  my $rs = $schema-&gt;resultset('Artist')-&gt;search({}, {
    prefetch =&gt; { cds =&gt; ['genre', 'tracks' ] },
  });
</pre>
<p class="Pp">and</p>
<p class="Pp"></p>
<pre>  my $rs = $schema-&gt;resultset('Artist')-&gt;search({}, {
    join =&gt; { cds =&gt; ['genre', 'tracks' ] },
    collapse =&gt; 1,
    '+columns' =&gt; [
      (map
        { +{ &quot;cds.$_&quot; =&gt; &quot;cds.$_&quot; } }
        $schema-&gt;source('Artist')-&gt;related_source('cds')-&gt;columns
      ),
      (map
        { +{ &quot;cds.genre.$_&quot; =&gt; &quot;genre.$_&quot; } }
        $schema-&gt;source('Artist')-&gt;related_source('cds')-&gt;related_source('genre')-&gt;columns
      ),
      (map
        { +{ &quot;cds.tracks.$_&quot; =&gt; &quot;tracks.$_&quot; } }
        $schema-&gt;source('Artist')-&gt;related_source('cds')-&gt;related_source('tracks')-&gt;columns
      ),
    ],
  });
</pre>
<p class="Pp">Both producing the following SQL:</p>
<p class="Pp"></p>
<pre>  SELECT  me.artistid, me.name, me.rank, me.charfield,
          cds.cdid, cds.artist, cds.title, cds.year, cds.genreid, cds.single_track,
          genre.genreid, genre.name,
          tracks.trackid, tracks.cd, tracks.position, tracks.title, tracks.last_updated_on, tracks.last_updated_at
    FROM artist me
    LEFT JOIN cd cds
      ON cds.artist = me.artistid
    LEFT JOIN genre genre
      ON genre.genreid = cds.genreid
    LEFT JOIN track tracks
      ON tracks.cd = cds.cdid
  ORDER BY me.artistid
</pre>
<p class="Pp">While &quot;prefetch&quot; implies a &quot;join&quot;, it is ok to
    mix the two together, as the arguments are properly merged and generally do
    the right thing. For example, you may want to do the following:</p>
<p class="Pp"></p>
<pre>  my $artists_and_cds_without_genre = $schema-&gt;resultset('Artist')-&gt;search(
    { 'genre.genreid' =&gt; undef },
    {
      join =&gt; { cds =&gt; 'genre' },
      prefetch =&gt; 'cds',
    }
  );
</pre>
<p class="Pp">Which generates the following SQL:</p>
<p class="Pp"></p>
<pre>  SELECT  me.artistid, me.name, me.rank, me.charfield,
          cds.cdid, cds.artist, cds.title, cds.year, cds.genreid, cds.single_track
    FROM artist me
    LEFT JOIN cd cds
      ON cds.artist = me.artistid
    LEFT JOIN genre genre
      ON genre.genreid = cds.genreid
  WHERE genre.genreid IS NULL
  ORDER BY me.artistid
</pre>
<p class="Pp">For a more in-depth discussion, see &quot;PREFETCHING&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="alias"><a class="permalink" href="#alias">alias</a></h2>
<dl class="Bl-tag">
  <dt id="Value:~11"><a class="permalink" href="#Value:~11">Value:
    $source_alias</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Sets the source alias for the query. Normally, this defaults to
    <span class="Li">&quot;me&quot;</span>, but nested search queries
    (sub-SELECTs) might need specific aliases set to reference inner queries.
    For example:</p>
<p class="Pp"></p>
<pre>   my $q = $rs
      -&gt;related_resultset('CDs')
      -&gt;related_resultset('Tracks')
      -&gt;search({
         'track.id' =&gt; { -ident =&gt; 'none_search.id' },
      })
      -&gt;as_query;
   my $ids = $self-&gt;search({
      -not_exists =&gt; $q,
   }, {
      alias    =&gt; 'none_search',
      group_by =&gt; 'none_search.id',
   })-&gt;get_column('id')-&gt;as_query;
   $self-&gt;search({ id =&gt; { -in =&gt; $ids } })
</pre>
<p class="Pp">This attribute is directly tied to
    &quot;current_source_alias&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="page~2"><a class="permalink" href="#page~2">page</a></h2>
<dl class="Bl-tag">
  <dt id="Value:~12"><a class="permalink" href="#Value:~12">Value:
    $page</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Makes the resultset paged and specifies the page to retrieve.
    Effectively identical to creating a non-pages resultset and then calling
    -&gt;page($page) on it.</p>
<p class="Pp">If &quot;rows&quot; attribute is not specified it defaults to 10
    rows per page.</p>
<p class="Pp">When you have a paged resultset, &quot;count&quot; will only
    return the number of rows in the page. To get the total, use the
    &quot;pager&quot; and call <span class="Li">&quot;total_entries&quot;</span>
    on it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="rows"><a class="permalink" href="#rows">rows</a></h2>
<dl class="Bl-tag">
  <dt id="Value:~13"><a class="permalink" href="#Value:~13">Value:
    $rows</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Specifies the maximum number of rows for direct retrieval or the
    number of rows per page if the page attribute or method is used.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="offset"><a class="permalink" href="#offset">offset</a></h2>
<dl class="Bl-tag">
  <dt id="Value:~14"><a class="permalink" href="#Value:~14">Value:
    $offset</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Specifies the (zero-based) row number for the first row to be
    returned, or the of the first row of the first page if paging is used.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="software_limit"><a class="permalink" href="#software_limit">software_limit</a></h2>
<dl class="Bl-tag">
  <dt id="Value:~15"><a class="permalink" href="#Value:~15">Value: (0 |
    1)</a></dt>
  <dd></dd>
</dl>
<p class="Pp">When combined with &quot;rows&quot; and/or &quot;offset&quot; the
    generated SQL will not include any limit dialect stanzas. Instead the entire
    result will be selected as if no limits were specified, and DBIC will
    perform the limit locally, by artificially advancing and finishing the
    resulting &quot;cursor&quot;.</p>
<p class="Pp">This is the recommended way of performing resultset limiting when
    no sane RDBMS implementation is available (e.g. Sybase ASE using the Generic
    Sub Query hack)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="group_by"><a class="permalink" href="#group_by">group_by</a></h2>
<dl class="Bl-tag">
  <dt id="Value:~16"><a class="permalink" href="#Value:~16">Value:
    \@columns</a></dt>
  <dd></dd>
</dl>
<p class="Pp">A arrayref of columns to group by. Can include columns of joined
    tables.</p>
<p class="Pp"></p>
<pre>  group_by =&gt; [qw/ column1 column2 ... /]
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="having"><a class="permalink" href="#having">having</a></h2>
<dl class="Bl-tag">
  <dt id="Value:~17"><a class="permalink" href="#Value:~17">Value:
    $condition</a></dt>
  <dd></dd>
</dl>
<p class="Pp">The HAVING operator specifies a <b>secondary</b> condition applied
    to the set after the grouping calculations have been done. In other words it
    is a constraint just like &quot;where&quot; (and accepting the same
    SQL::Abstract syntax) applied to the data as it exists after GROUP BY has
    taken place. Specifying &quot;having&quot; without &quot;group_by&quot; is a
    logical mistake, and a fatal error on most RDBMS engines.</p>
<p class="Pp">E.g.</p>
<p class="Pp"></p>
<pre>  having =&gt; { 'count_employee' =&gt; { '&gt;=', 100 } }
</pre>
<p class="Pp">or with an in-place function in which case literal SQL is
    required:</p>
<p class="Pp"></p>
<pre>  having =&gt; \[ 'count(employee) &gt;= ?', 100 ]
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="distinct"><a class="permalink" href="#distinct">distinct</a></h2>
<dl class="Bl-tag">
  <dt id="Value:~18"><a class="permalink" href="#Value:~18">Value: (0 |
    1)</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Set to 1 to automatically generate a &quot;group_by&quot; clause
    based on the selection (including intelligent handling of
    &quot;order_by&quot; contents). Note that the group criteria calculation
    takes place over the <b>final</b> selection. This includes any
    &quot;+columns&quot;, &quot;+select&quot; or &quot;order_by&quot; additions
    in subsequent &quot;search&quot; calls, and standalone columns selected via
    DBIx::Class::ResultSetColumn (&quot;get_column&quot;). A notable exception
    are the extra selections specified via &quot;prefetch&quot; - such
    selections are explicitly excluded from group criteria calculations.</p>
<p class="Pp">If the final ResultSet also explicitly defines a
    &quot;group_by&quot; attribute, this setting is ignored and an appropriate
    warning is issued.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="where"><a class="permalink" href="#where">where</a></h2>
<div class="Bd-indent">Adds to the WHERE clause.
<p class="Pp"></p>
<pre>  # only return rows WHERE deleted IS NULL for all searches
  __PACKAGE__-&gt;resultset_attributes({ where =&gt; { deleted =&gt; undef } });
</pre>
<p class="Pp">Can be overridden by passing <span class="Li">&quot;{ where =&gt;
    undef }&quot;</span> as an attribute to a resultset.</p>
<p class="Pp">For more complicated where clauses see &quot;WHERE CLAUSES&quot;
    in SQL::Abstract.</p>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="cache"><a class="permalink" href="#cache">cache</a></h2>
<p class="Pp">Set to 1 to cache search results. This prevents extra SQL queries
    if you revisit rows in your ResultSet:</p>
<p class="Pp"></p>
<pre>  my $resultset = $schema-&gt;resultset('Artist')-&gt;search( undef, { cache =&gt; 1 } );
  while( my $artist = $resultset-&gt;next ) {
    ... do stuff ...
  }
  $rs-&gt;first; # without cache, this would issue a query
</pre>
<p class="Pp">By default, searches are not cached.</p>
<p class="Pp">For more examples of using these attributes, see
    DBIx::Class::Manual::Cookbook.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="for"><a class="permalink" href="#for">for</a></h2>
<dl class="Bl-tag">
  <dt id="Value:~19"><a class="permalink" href="#Value:~19">Value: ( 'update' |
    'shared' | \$scalar )</a></dt>
  <dd></dd>
</dl>
<p class="Pp">Set to 'update' for a SELECT ... FOR UPDATE or 'shared' for a
    SELECT ... FOR SHARED. If \$scalar is passed, this is taken directly and
    embedded in the query.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="PREFETCHING"><a class="permalink" href="#PREFETCHING">PREFETCHING</a></h1>
<p class="Pp">DBIx::Class supports arbitrary related data prefetching from
    multiple related sources. Any combination of relationship types and column
    sets are supported. If collapsing is requested, there is an additional
    requirement of selecting enough data to make every individual object
    uniquely identifiable.</p>
<p class="Pp">Here are some more involved examples, based on the following
    relationship map:</p>
<p class="Pp"></p>
<pre>  # Assuming:
  My::Schema::CD-&gt;belongs_to( artist      =&gt; 'My::Schema::Artist'     );
  My::Schema::CD-&gt;might_have( liner_note  =&gt; 'My::Schema::LinerNotes' );
  My::Schema::CD-&gt;has_many(   tracks      =&gt; 'My::Schema::Track'      );
  My::Schema::Artist-&gt;belongs_to( record_label =&gt; 'My::Schema::RecordLabel' );
  My::Schema::Track-&gt;has_many( guests =&gt; 'My::Schema::Guest' );
  my $rs = $schema-&gt;resultset('Tag')-&gt;search(
    undef,
    {
      prefetch =&gt; {
        cd =&gt; 'artist'
      }
    }
  );
</pre>
<p class="Pp">The initial search results in SQL like the following:</p>
<p class="Pp"></p>
<pre>  SELECT tag.*, cd.*, artist.* FROM tag
  JOIN cd ON tag.cd = cd.cdid
  JOIN artist ON cd.artist = artist.artistid
</pre>
<p class="Pp">DBIx::Class has no need to go back to the database when we access
    the <span class="Li">&quot;cd&quot;</span> or
    <span class="Li">&quot;artist&quot;</span> relationships, which saves us two
    SQL statements in this case.</p>
<p class="Pp">Simple prefetches will be joined automatically, so there is no
    need for a <span class="Li">&quot;join&quot;</span> attribute in the above
    search.</p>
<p class="Pp">The &quot;prefetch&quot; attribute can be used with any of the
    relationship types and multiple prefetches can be specified together. Below
    is a more complex example that prefetches a CD's artist, its liner notes (if
    present), the cover image, the tracks on that CD, and the guests on those
    tracks.</p>
<p class="Pp"></p>
<pre>  my $rs = $schema-&gt;resultset('CD')-&gt;search(
    undef,
    {
      prefetch =&gt; [
        { artist =&gt; 'record_label'},  # belongs_to =&gt; belongs_to
        'liner_note',                 # might_have
        'cover_image',                # has_one
        { tracks =&gt; 'guests' },       # has_many =&gt; has_many
      ]
    }
  );
</pre>
<p class="Pp">This will produce SQL like the following:</p>
<p class="Pp"></p>
<pre>  SELECT cd.*, artist.*, record_label.*, liner_note.*, cover_image.*,
         tracks.*, guests.*
    FROM cd me
    JOIN artist artist
      ON artist.artistid = me.artistid
    JOIN record_label record_label
      ON record_label.labelid = artist.labelid
    LEFT JOIN track tracks
      ON tracks.cdid = me.cdid
    LEFT JOIN guest guests
      ON guests.trackid = track.trackid
    LEFT JOIN liner_notes liner_note
      ON liner_note.cdid = me.cdid
    JOIN cd_artwork cover_image
      ON cover_image.cdid = me.cdid
  ORDER BY tracks.cd
</pre>
<p class="Pp">Now the <span class="Li">&quot;artist&quot;</span>,
    <span class="Li">&quot;record_label&quot;</span>,
    <span class="Li">&quot;liner_note&quot;</span>,
    <span class="Li">&quot;cover_image&quot;</span>,
    <span class="Li">&quot;tracks&quot;</span>, and
    <span class="Li">&quot;guests&quot;</span> of the CD will all be available
    through the relationship accessors without the need for additional queries
    to the database.</p>
<p class="Pp"><i>CAVEATS</i></p>
<p class="Pp">Prefetch does a lot of deep magic. As such, it may not behave
    exactly as you might expect.</p>
<ul class="Bl-bullet">
  <li>Prefetch uses the &quot;cache&quot; to populate the prefetched
      relationships. This may or may not be what you want.</li>
  <li>If you specify a condition on a prefetched relationship, ONLY those rows
      that match the prefetched condition will be fetched into that
      relationship. This means that adding prefetch to a <b>search()</b> <b>may
      alter</b> what is returned by traversing a relationship. So, if you have
      <span class="Li">&quot;Artist-&gt;has_many(CDs)&quot;</span> and you do
    <p class="Pp"></p>
    <pre>  my $artist_rs = $schema-&gt;resultset('Artist')-&gt;search({
      'cds.year' =&gt; 2008,
  }, {
      join =&gt; 'cds',
  });
  my $count = $artist_rs-&gt;first-&gt;cds-&gt;count;
  my $artist_rs_prefetch = $artist_rs-&gt;search( {}, { prefetch =&gt; 'cds' } );
  my $prefetch_count = $artist_rs_prefetch-&gt;first-&gt;cds-&gt;count;
  cmp_ok( $count, '==', $prefetch_count, &quot;Counts should be the same&quot; );
    </pre>
    <p class="Pp">That <b>cmp_ok()</b> may or may not pass depending on the
        datasets involved. In other words the
        <span class="Li">&quot;WHERE&quot;</span> condition would apply to the
        entire dataset, just like it would in regular SQL. If you want to add a
        condition only to the &quot;right side&quot; of a
        <span class="Li">&quot;LEFT JOIN&quot;</span> - consider declaring and
        using a relationship with a custom condition</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="DBIC_BIND_VALUES"><a class="permalink" href="#DBIC_BIND_VALUES">DBIC
  BIND VALUES</a></h1>
<p class="Pp">Because DBIC may need more information to bind values than just
    the column name and value itself, it uses a special format for both passing
    and receiving bind values. Each bind value should be composed of an arrayref
    of <span class="Li">&quot;[ \%args =&gt; $val ]&quot;</span>. The format of
    <span class="Li">&quot;\%args&quot;</span> is currently:</p>
<dl class="Bl-tag">
  <dt id="dbd_attrs"><a class="permalink" href="#dbd_attrs">dbd_attrs</a></dt>
  <dd>If present (in any form), this is what is being passed directly to
      bind_param. Note that different DBD's expect different bind args. (e.g.
      DBD::SQLite takes a single numerical type, while DBD::Pg takes a hashref
      if bind options.)
    <p class="Pp">If this is specified, all other bind options described below
        are ignored.</p>
  </dd>
  <dt id="sqlt_datatype"><a class="permalink" href="#sqlt_datatype">sqlt_datatype</a></dt>
  <dd>If present, this is used to infer the actual bind attribute by passing to
      <span class="Li">&quot;$resolved_storage-&gt;bind_attribute_by_data_type()&quot;</span>.
      Defaults to the &quot;data_type&quot; from the add_columns column info.
    <p class="Pp">Note that the data type is somewhat freeform (hence the sqlt_
        prefix); currently drivers are expected to &quot;Do the Right
        Thing&quot; when given a common datatype name. (Not ideal, but that's
        what we got at this point.)</p>
  </dd>
  <dt id="sqlt_size"><a class="permalink" href="#sqlt_size">sqlt_size</a></dt>
  <dd>Currently used to correctly allocate buffers for
      <b>bind_param_inout()</b>. Defaults to &quot;size&quot; from the
      add_columns column info, or to a sensible value based on the
      &quot;data_type&quot;.</dd>
  <dt id="dbic_colname"><a class="permalink" href="#dbic_colname">dbic_colname</a></dt>
  <dd>Used to fill in missing sqlt_datatype and sqlt_size attributes (if they
      are explicitly specified they are never overridden). Also used by some
      weird DBDs, where the column name should be available at bind_param time
      (e.g. Oracle).</dd>
</dl>
<p class="Pp">For backwards compatibility and convenience, the following
    shortcuts are supported:</p>
<p class="Pp"></p>
<pre>  [ $name =&gt; $val ] === [ { dbic_colname =&gt; $name }, $val ]
  [ \$dt  =&gt; $val ] === [ { sqlt_datatype =&gt; $dt }, $val ]
  [ undef,   $val ] === [ {}, $val ]
  $val              === [ {}, $val ]
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="FURTHER_QUESTIONS?"><a class="permalink" href="#FURTHER_QUESTIONS?">FURTHER
  QUESTIONS?</a></h1>
<p class="Pp">Check the list of additional DBIC resources.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This module is free software copyright by the DBIx::Class (DBIC)
    authors. You can redistribute it and/or modify it under the same terms as
    the DBIx::Class library.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-01-29</td>
    <td class="foot-os"><a href="..">perl v5.34.0</a></td>
  </tr>
</table>
</body>
</html>

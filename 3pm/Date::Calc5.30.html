<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Date::Calc(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Date::Calc(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Date::Calc(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Date::Calc - Gregorian calendar date calculations</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MOTTO"><a class="permalink" href="#MOTTO">MOTTO</a></h1>
<p class="Pp">Keep it small, fast and simple</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PREFACE"><a class="permalink" href="#PREFACE">PREFACE</a></h1>
<p class="Pp">This package consists of a C library and a Perl module (which uses
    the C library, internally) for all kinds of date calculations based on the
    Gregorian calendar (the one used in all western countries today), thereby
    complying with all relevant norms and standards: ISO/R&#x00A0;2015-1971,
    DIN&#x00A0;1355 and, to some extent, ISO&#x00A0;8601 (where applicable).</p>
<p class="Pp">(See also
    http://www.engelschall.com/u/sb/download/Date-Calc/DIN1355/ for a scan of
    part of the &quot;DIN&#x00A0;1355&quot; document (in German)).</p>
<p class="Pp">The module of course handles year numbers of 2000 and above
    correctly (&quot;Year 2000&quot; or &quot;Y2K&quot; compliance) -- actually
    all year numbers from 1 to the largest positive integer representable on
    your system (which is at least 32767) can be dealt with.</p>
<p class="Pp">This is not true, however, for the import/export functions in this
    package which are an interface to the internal POSIX date and time functions
    of your system, which can only cover dates in the following ranges:</p>
<p class="Pp"></p>
<pre> 01-Jan-1970 00:00:00 GMT .. 19-Jan-2038 03:14:07 GMT [Unix etc.]
 01-Jan-1904 00:00:00 LT  .. 06-Feb-2040 06:28:15 LT  [MacOS Classic]
 (LT = local time)
</pre>
<p class="Pp">Note that this package projects the Gregorian calendar back until
    the year 1&#x00A0;A.D. -- even though the Gregorian calendar was only
    adopted in 1582, mostly by the Catholic European countries, in obedience to
    the corresponding decree of Pope Gregory&#x00A0;XIII in that year.</p>
<p class="Pp">Some (mainly protestant) countries continued to use the Julian
    calendar (used until then) until as late as the beginning of the 20th
    century.</p>
<p class="Pp">Finally, note that this package is not intended to do everything
    you could ever imagine automagically for you; it is rather intended to serve
    as a toolbox (in the best of UNIX spirit and traditions) which should,
    however, always get you where you want to go.</p>
<p class="Pp">See the section &quot;RECIPES&quot; at the bottom of this document
    for solutions to common problems!</p>
<p class="Pp">If nevertheless you can't figure out how to solve a particular
    problem, please let me know! (See e-mail address at the end of this
    document.)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  use Date::Calc qw(
      Days_in_Year
      Days_in_Month
      Weeks_in_Year
      leap_year
      check_date
      check_time
      check_business_date
      Day_of_Year
      Date_to_Days
      Day_of_Week
      Week_Number
      Week_of_Year
      Monday_of_Week
      Nth_Weekday_of_Month_Year
      Standard_to_Business
      Business_to_Standard
      Delta_Days
      Delta_DHMS
      Delta_YMD
      Delta_YMDHMS
      N_Delta_YMD
      N_Delta_YMDHMS
      Normalize_DHMS
      Add_Delta_Days
      Add_Delta_DHMS
      Add_Delta_YM
      Add_Delta_YMD
      Add_Delta_YMDHMS
      Add_N_Delta_YMD
      Add_N_Delta_YMDHMS
      System_Clock
      Today
      Now
      Today_and_Now
      This_Year
      Gmtime
      Localtime
      Mktime
      Timezone
      Date_to_Time
      Time_to_Date
      Easter_Sunday
      Decode_Month
      Decode_Day_of_Week
      Decode_Language
      Decode_Date_EU
      Decode_Date_US
      Fixed_Window
      Moving_Window
      Compress
      Uncompress
      check_compressed
      Compressed_to_Text
      Date_to_Text
      Date_to_Text_Long
      English_Ordinal
      Calendar
      Month_to_Text
      Day_of_Week_to_Text
      Day_of_Week_Abbreviation
      Language_to_Text
      Language
      Languages
      Decode_Date_EU2
      Decode_Date_US2
      Parse_Date
      ISO_LC
      ISO_UC
  );
  use Date::Calc qw(:all);
  Days_in_Year
      $days = Days_in_Year($year,$month);
  Days_in_Month
      $days = Days_in_Month($year,$month);
  Weeks_in_Year
      $weeks = Weeks_in_Year($year);
  leap_year
      if (leap_year($year))
  check_date
      if (check_date($year,$month,$day))
  check_time
      if (check_time($hour,$min,$sec))
  check_business_date
      if (check_business_date($year,$week,$dow))
  Day_of_Year
      $doy = Day_of_Year($year,$month,$day);
  Date_to_Days
      $days = Date_to_Days($year,$month,$day);
  Day_of_Week
      $dow = Day_of_Week($year,$month,$day);
  Week_Number
      $week = Week_Number($year,$month,$day);          # DEPRECATED
  Week_of_Year
      ($week,$year) = Week_of_Year($year,$month,$day); # RECOMMENDED
      $week = Week_of_Year($year,$month,$day);         # DANGEROUS
  Monday_of_Week
      ($year,$month,$day) = Monday_of_Week($week,$year);
  Nth_Weekday_of_Month_Year
      if (($year,$month,$day) =
      Nth_Weekday_of_Month_Year($year,$month,$dow,$n))
  Standard_to_Business
      ($year,$week,$dow) =
      Standard_to_Business($year,$month,$day);
  Business_to_Standard
      ($year,$month,$day) =
      Business_to_Standard($year,$week,$dow);
  Delta_Days
      $Dd = Delta_Days($year1,$month1,$day1,
                       $year2,$month2,$day2);
  Delta_DHMS
      ($Dd,$Dh,$Dm,$Ds) =
      Delta_DHMS($year1,$month1,$day1, $hour1,$min1,$sec1,
                 $year2,$month2,$day2, $hour2,$min2,$sec2);
  Delta_YMD
      ($Dy,$Dm,$Dd) =
      Delta_YMD($year1,$month1,$day1,
                $year2,$month2,$day2);
  Delta_YMDHMS
      ($D_y,$D_m,$D_d, $Dh,$Dm,$Ds) =
      Delta_YMDHMS($year1,$month1,$day1, $hour1,$min1,$sec1,
                   $year2,$month2,$day2, $hour2,$min2,$sec2);
  N_Delta_YMD
      ($Dy,$Dm,$Dd) =
      N_Delta_YMD($year1,$month1,$day1,
                  $year2,$month2,$day2);
  N_Delta_YMDHMS
      ($D_y,$D_m,$D_d, $Dhh,$Dmm,$Dss) =
      N_Delta_YMDHMS($year1,$month1,$day1, $hour1,$min1,$sec1,
                     $year2,$month2,$day2, $hour2,$min2,$sec2);
  Normalize_DHMS
      ($Dd,$Dh,$Dm,$Ds) =
      Normalize_DHMS($Dd,$Dh,$Dm,$Ds);
  Add_Delta_Days
      ($year,$month,$day) =
      Add_Delta_Days($year,$month,$day,
                     $Dd);
  Add_Delta_DHMS
      ($year,$month,$day, $hour,$min,$sec) =
      Add_Delta_DHMS($year,$month,$day, $hour,$min,$sec,
                     $Dd,$Dh,$Dm,$Ds);
  Add_Delta_YM
      ($year,$month,$day) =
      Add_Delta_YM($year,$month,$day,
                   $Dy,$Dm);
  Add_Delta_YMD
      ($year,$month,$day) =
      Add_Delta_YMD($year,$month,$day,
                    $Dy,$Dm,$Dd);
  Add_Delta_YMDHMS
      ($year,$month,$day, $hour,$min,$sec) =
      Add_Delta_YMDHMS($year,$month,$day, $hour,$min,$sec,
                       $D_y,$D_m,$D_d, $Dh,$Dm,$Ds);
  Add_N_Delta_YMD
      ($year,$month,$day) =
      Add_N_Delta_YMD($year,$month,$day,
                      $Dy,$Dm,$Dd);
  Add_N_Delta_YMDHMS
      ($year,$month,$day, $hour,$min,$sec) =
      Add_N_Delta_YMDHMS($year,$month,$day, $hour,$min,$sec,
                         $D_y,$D_m,$D_d, $Dhh,$Dmm,$Dss);
  System_Clock
      ($year,$month,$day, $hour,$min,$sec, $doy,$dow,$dst) =
      System_Clock([$gmt]);
  Today
      ($year,$month,$day) = Today([$gmt]);
  Now
      ($hour,$min,$sec) = Now([$gmt]);
  Today_and_Now
      ($year,$month,$day, $hour,$min,$sec) = Today_and_Now([$gmt]);
  This_Year
      $year = This_Year([$gmt]);
  Gmtime
      ($year,$month,$day, $hour,$min,$sec, $doy,$dow,$dst) =
      Gmtime([time]);
  Localtime
      ($year,$month,$day, $hour,$min,$sec, $doy,$dow,$dst) =
      Localtime([time]);
  Mktime
      $time = Mktime($year,$month,$day, $hour,$min,$sec);
  Timezone
      ($D_y,$D_m,$D_d, $Dh,$Dm,$Ds, $dst) = Timezone([time]);
  Date_to_Time
      $time = Date_to_Time($year,$month,$day, $hour,$min,$sec);
  Time_to_Date
      ($year,$month,$day, $hour,$min,$sec) = Time_to_Date([time]);
  Easter_Sunday
      ($year,$month,$day) = Easter_Sunday($year);
  Decode_Month
      if ($month = Decode_Month($string[,$lang]))
  Decode_Day_of_Week
      if ($dow = Decode_Day_of_Week($string[,$lang]))
  Decode_Language
      if ($lang = Decode_Language($string))
  Decode_Date_EU
      if (($year,$month,$day) = Decode_Date_EU($string[,$lang]))
  Decode_Date_US
      if (($year,$month,$day) = Decode_Date_US($string[,$lang]))
  Fixed_Window
      $year = Fixed_Window($yy);
  Moving_Window
      $year = Moving_Window($yy);
  Compress
      $date = Compress($year,$month,$day);
  Uncompress
      if (($century,$year,$month,$day) = Uncompress($date))
  check_compressed
      if (check_compressed($date))
  Compressed_to_Text
      $string = Compressed_to_Text($date[,$lang]);
  Date_to_Text
      $string = Date_to_Text($year,$month,$day[,$lang]);
  Date_to_Text_Long
      $string = Date_to_Text_Long($year,$month,$day[,$lang]);
  English_Ordinal
      $string = English_Ordinal($number);
  Calendar
      $string = Calendar($year,$month[,$orthodox[,$lang]]);
  Month_to_Text
      $string = Month_to_Text($month[,$lang]);
  Day_of_Week_to_Text
      $string = Day_of_Week_to_Text($dow[,$lang]);
  Day_of_Week_Abbreviation
      $string = Day_of_Week_Abbreviation($dow[,$lang]);
  Language_to_Text
      $string = Language_to_Text($lang);
  Language
      $lang = Language();
      Language($lang);               # DEPRECATED
      $oldlang = Language($newlang); # DEPRECATED
  Languages
      $max_lang = Languages();
  Decode_Date_EU2
      if (($year,$month,$day) = Decode_Date_EU2($string[,$lang]))
  Decode_Date_US2
      if (($year,$month,$day) = Decode_Date_US2($string[,$lang]))
  Parse_Date
      if (($year,$month,$day) = Parse_Date($string[,$lang]))
  ISO_LC
      $lower = ISO_LC($string);
  ISO_UC
      $upper = ISO_UC($string);
  Version
      $string = Date::Calc::Version();
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="IMPORTANT_NOTES"><a class="permalink" href="#IMPORTANT_NOTES">IMPORTANT
  NOTES</a></h1>
<p class="Pp">(See the section &quot;RECIPES&quot; at the bottom of this
    document for solutions to common problems!)</p>
<ul class="Bl-bullet">
  <li>&quot;Year 2000&quot; (&quot;Y2K&quot;) compliance
    <p class="Pp">The upper limit for any year number in this module is only
        given by the size of the largest positive integer that can be
        represented in a variable of the C type &quot;int&quot; on your system,
        which is at least 32767, according to the ANSI C standard (exceptions
        see below).</p>
    <p class="Pp">In order to simplify calculations, this module projects the
        gregorian calendar back until the year 1&#x00A0;A.D. -- i.e., back
        <b>BEYOND</b> the year 1582 when this calendar was first decreed by the
        Catholic Pope Gregory&#x00A0;XIII!</p>
    <p class="Pp">Therefore, <b>BE SURE TO ALWAYS SPECIFY &quot;1998&quot; WHEN
        YOU MEAN &quot;1998&quot;</b>, for instance, and <b>DO NOT WRITE
        &quot;98&quot; INSTEAD</b>, because this will in fact perform a
        calculation based on the year &quot;98&quot; A.D. and <b>NOT</b>
        &quot;1998&quot;!</p>
    <p class="Pp">An exception from this rule are the functions which contain
        the word &quot;compress&quot; in their names (which can only handle
        years between 1970 and 2069 and also accept the abbreviations
        &quot;00&quot; to &quot;99&quot;), and the functions whose names begin
        with &quot;Decode_Date_&quot; (which translate year numbers below 100
        using a technique known as &quot;moving window&quot;).</p>
    <p class="Pp">If you want to convert a two-digit year number into a
        full-fledged, four-digit (at least for some years to come
        <span class="Li">&quot;;-)&quot;</span>) year number, use the two
        functions &quot;<b>Fixed_Window()</b>&quot; and
        &quot;<b>Moving_Window()</b>&quot; (see their description further
        below).</p>
    <p class="Pp">Note also that the following import/export functions (which
        are interfaces to the POSIX functions &quot;<b>time()</b>&quot;,
        &quot;<b>gmtime()</b>&quot;, &quot;<b>localtime()</b>&quot; and
        &quot;<b>mktime()</b>&quot; or (the last two) substitutes for the BSD
        function &quot;<b>timegm()</b>&quot; and the POSIX function
        &quot;<b>gmtime()</b>&quot;) have a very limited range of representable
        dates (in contrast to all other functions in this package, which cover
        virtually any date including and after
        January&#x00A0;1st&#x00A0;1&#x00A0;A.D.):</p>
    <p class="Pp"></p>
    <pre>              System_Clock()
              Today()
              Now()
              Today_and_Now()
              This_Year()
              Gmtime()
              Localtime()
              Mktime()
              Timezone()
              Date_to_Time()
              Time_to_Date()
    </pre>
    <p class="Pp">These functions can only deal with dates in the range from
        01-Jan-1970&#x00A0;00:00:00&#x00A0;GMT to
        19-Jan-2038&#x00A0;03:14:07&#x00A0;GMT (the latter limit is only
        authoritative on 32&#x00A0;bit systems, however, and can (in principle,
        through a few code changes) be extended somewhat
        <span class="Li">&quot;:-)&quot;</span> on 64&#x00A0;bit systems).</p>
    <p class="Pp">On MacOS Classic, the valid range of dates is between (both
        included) 01-Jan-1904&#x00A0;00:00:00 (local time) to
        06-Feb-2040&#x00A0;06:28:15 (local time).</p>
    <p class="Pp">Note further that the function
        &quot;<b>Easter_Sunday()</b>&quot; can only be used for years in the
        range 1583 to 2299.</p>
  </li>
  <li>POSIX functions
    <p class="Pp">Note that the following functions</p>
    <p class="Pp"></p>
    <pre>              Gmtime()
              Localtime()
              Mktime()
              Timezone()
    </pre>
    <p class="Pp">are actually wrappers around or based upon the corresponding
        POSIX functions &quot;<b>time()</b>&quot;, &quot;<b>gmtime()</b>&quot;,
        &quot;<b>localtime()</b>&quot; and &quot;<b>mktime()</b>&quot;.</p>
    <p class="Pp">As such, they depend on local settings of the underlying
        machine such as e.g. the system clock, the time zone and the locale.</p>
    <p class="Pp">Their results can therefore sometimes be unexpected or
        counter-intuitive.</p>
    <p class="Pp">Therefore, no support can be provided for these functions.</p>
    <p class="Pp">They are supplied &quot;as is&quot;, purely for the sake of
        interoperability.</p>
    <p class="Pp">Use at your own risk. (You have been warned!)</p>
  </li>
  <li>First index
    <p class="Pp"><b>ALL</b> ranges in this module start with
        &quot;<span class="Li">1</span>&quot;, <b>NOT</b>
        &quot;<span class="Li">0</span>&quot;!</p>
    <p class="Pp">I.e., the day of month, day of week, day of year, month of
        year, week of year, first valid year number and language <b>ALL</b>
        start counting at one, <b>NOT</b> zero!</p>
    <p class="Pp">The only exception is the function
        &quot;<span class="Li">&quot;Week_Number()&quot;</span>&quot;, which may
        in fact return &quot;<span class="Li">0</span>&quot; when the given date
        actually lies in the last week of the <b>PREVIOUS</b> year, and of
        course the numbers for hours (<span class="Li">0..23</span>), minutes
        (<span class="Li">0..59</span>) and seconds
        (<span class="Li">0..59</span>).</p>
  </li>
  <li>Function naming conventions
    <p class="Pp">Function names completely in lower case indicate a boolean
        return value.</p>
  </li>
  <li>Boolean values
    <p class="Pp">Boolean values returned from functions in this module are
        always a numeric zero (&quot;<span class="Li">0</span>&quot;) for
        &quot;false&quot; and a numeric one
        (&quot;<span class="Li">1</span>&quot;) for &quot;true&quot;.</p>
  </li>
  <li>Exception handling
    <p class="Pp">The functions in this module will usually die with a
        corresponding error message if their input parameters, intermediate
        results or output values are out of range.</p>
    <p class="Pp">The following functions handle errors differently:</p>
    <p class="Pp"></p>
    <pre>  -  check_date()
  -  check_time()
  -  check_business_date()
  -  check_compressed()
    </pre>
    <p class="Pp">(which return a &quot;false&quot; return value when the given
        input does not represent a valid date or time),</p>
    <p class="Pp"></p>
    <pre>  -  Nth_Weekday_of_Month_Year()
    </pre>
    <p class="Pp">(which returns an empty list if the requested 5th day of week
        does not exist),</p>
    <p class="Pp"></p>
    <pre>  -  Decode_Month()
  -  Decode_Day_of_Week()
  -  Decode_Language()
  -  Fixed_Window()
  -  Moving_Window()
  -  Compress()
    </pre>
    <p class="Pp">(which return &quot;<span class="Li">0</span>&quot; upon
        failure or invalid input), and</p>
    <p class="Pp"></p>
    <pre>  -  Decode_Date_EU()
  -  Decode_Date_US()
  -  Decode_Date_EU2()
  -  Decode_Date_US2()
  -  Parse_Date()
  -  Uncompress()
    </pre>
    <p class="Pp">(which return an empty list upon failure or invalid
      input).</p>
    <p class="Pp">Note that you can always catch an exception thrown by any of
        the functions in this module and handle it yourself by enclosing the
        function call in an &quot;<span class="Li">&quot;eval&quot;</span>&quot;
        with curly brackets and checking the special variable
        &quot;<span class="Li">$@</span>&quot; (see &quot;eval&quot; in
        <b>perlfunc</b>(1) for details).</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;use Date::Calc qw( Days_in_Year Days_in_Month ...
      );&quot;</span></li>
  <li><span class="Li">&quot;use Date::Calc qw(:all);&quot;</span>
    <p class="Pp">You can either specify the functions you want to import
        explicitly by enumerating them between the parentheses of the
        &quot;<span class="Li">&quot;qw()&quot;</span>&quot; operator, or you
        can use the &quot;<span class="Li">&quot;:all&quot;</span>&quot; tag
        instead to import <b>ALL</b> available functions.</p>
  </li>
  <li><span class="Li">&quot;$days = Days_in_Year($year,$month);&quot;</span>
    <p class="Pp">This function returns the sum of the number of days in the
        months starting with January up to and including
        &quot;<span class="Li">$month</span>&quot; in the given year
        &quot;<span class="Li">$year</span>&quot;.</p>
    <p class="Pp">I.e.,
        &quot;<span class="Li">&quot;Days_in_Year(1998,1)&quot;</span>&quot;
        returns &quot;<span class="Li">31</span>&quot;,
        &quot;<span class="Li">&quot;Days_in_Year(1998,2)&quot;</span>&quot;
        returns &quot;<span class="Li">59</span>&quot;,
        &quot;<span class="Li">&quot;Days_in_Year(1998,3)&quot;</span>&quot;
        returns &quot;<span class="Li">90</span>&quot;, and so on.</p>
    <p class="Pp">Note that
        &quot;<span class="Li">&quot;Days_in_Year($year,12)&quot;</span>&quot;
        returns the number of days in the given year
        &quot;<span class="Li">$year</span>&quot;, i.e., either
        &quot;<span class="Li">365</span>&quot; or
        &quot;<span class="Li">366</span>&quot;.</p>
  </li>
  <li><span class="Li">&quot;$days = Days_in_Month($year,$month);&quot;</span>
    <p class="Pp">This function returns the number of days in the given month
        &quot;<span class="Li">$month</span>&quot; of the given year
        &quot;<span class="Li">$year</span>&quot;.</p>
    <p class="Pp">The year must always be supplied, even though it is only
        needed when the month is February, in order to determine whether it is a
        leap year or not.</p>
    <p class="Pp">I.e.,
        &quot;<span class="Li">&quot;Days_in_Month(1998,1)&quot;</span>&quot;
        returns &quot;<span class="Li">31</span>&quot;,
        &quot;<span class="Li">&quot;Days_in_Month(1998,2)&quot;</span>&quot;
        returns &quot;<span class="Li">28</span>&quot;,
        &quot;<span class="Li">&quot;Days_in_Month(2000,2)&quot;</span>&quot;
        returns &quot;<span class="Li">29</span>&quot;,
        &quot;<span class="Li">&quot;Days_in_Month(1998,3)&quot;</span>&quot;
        returns &quot;<span class="Li">31</span>&quot;, and so on.</p>
  </li>
  <li><span class="Li">&quot;$weeks = Weeks_in_Year($year);&quot;</span>
    <p class="Pp">This function returns the number of weeks in the given year
        &quot;<span class="Li">$year</span>&quot;, i.e., either
        &quot;<span class="Li">52</span>&quot; or
        &quot;<span class="Li">53</span>&quot;.</p>
  </li>
  <li><span class="Li">&quot;if (leap_year($year))&quot;</span>
    <p class="Pp">This function returns &quot;true&quot;
        (&quot;<span class="Li">1</span>&quot;) if the given year
        &quot;<span class="Li">$year</span>&quot; is a leap year and
        &quot;false&quot; (&quot;<span class="Li">0</span>&quot;) otherwise.</p>
  </li>
  <li><span class="Li">&quot;if (check_date($year,$month,$day))&quot;</span>
    <p class="Pp">This function returns &quot;true&quot;
        (&quot;<span class="Li">1</span>&quot;) if the given three numerical
        values &quot;<span class="Li">$year</span>&quot;,
        &quot;<span class="Li">$month</span>&quot; and
        &quot;<span class="Li">$day</span>&quot; constitute a valid date, and
        &quot;false&quot; (&quot;<span class="Li">0</span>&quot;) otherwise.</p>
  </li>
  <li><span class="Li">&quot;if (check_time($hour,$min,$sec))&quot;</span>
    <p class="Pp">This function returns &quot;true&quot;
        (&quot;<span class="Li">1</span>&quot;) if the given three numerical
        values &quot;<span class="Li">$hour</span>&quot;,
        &quot;<span class="Li">$min</span>&quot; and
        &quot;<span class="Li">$sec</span>&quot; constitute a valid time
        (<span class="Li">&quot;0 &lt;= $hour &lt; 24&quot;</span>,
        <span class="Li">&quot;0 &lt;= $min &lt; 60&quot;</span> and
        <span class="Li">&quot;0 &lt;= $sec &lt; 60&quot;</span>), and
        &quot;false&quot; (&quot;<span class="Li">0</span>&quot;) otherwise.</p>
  </li>
  <li><span class="Li">&quot;if
      (check_business_date($year,$week,$dow))&quot;</span>
    <p class="Pp">This function returns &quot;true&quot;
        (&quot;<span class="Li">1</span>&quot;) if the given three numerical
        values &quot;<span class="Li">$year</span>&quot;,
        &quot;<span class="Li">$week</span>&quot; and
        &quot;<span class="Li">$dow</span>&quot; constitute a valid date in
        business format, and &quot;false&quot;
        (&quot;<span class="Li">0</span>&quot;) otherwise.</p>
    <p class="Pp"><b>Beware</b> that this function does <b>NOT</b> compute
        whether a given date is a business day (i.e., Monday to Friday)!</p>
    <p class="Pp">To do so, use
        &quot;<span class="Li">&quot;(Day_of_Week($year,$month,$day) &lt;
        6)&quot;</span>&quot; instead.</p>
  </li>
  <li><span class="Li">&quot;$doy = Day_of_Year($year,$month,$day);&quot;</span>
    <p class="Pp">This function returns the (relative) number of the day of the
        given date in the given year.</p>
    <p class="Pp">E.g.,
        &quot;<span class="Li">&quot;Day_of_Year($year,1,1)&quot;</span>&quot;
        returns &quot;<span class="Li">1</span>&quot;,
        &quot;<span class="Li">&quot;Day_of_Year($year,2,1)&quot;</span>&quot;
        returns &quot;<span class="Li">32</span>&quot;, and
        &quot;<span class="Li">&quot;Day_of_Year($year,12,31)&quot;</span>&quot;
        returns either &quot;<span class="Li">365</span>&quot; or
        &quot;<span class="Li">366</span>&quot;.</p>
    <p class="Pp">The day of year is sometimes also referred to as the Julian
        day (or date), although it has nothing to do with the Julian calendar,
        the calendar which was used before the Gregorian calendar.</p>
    <p class="Pp">In order to convert the number returned by this function back
        into a date, use the function
        &quot;<span class="Li">&quot;Add_Delta_Days()&quot;</span>&quot;
        (described further below), as follows:</p>
    <p class="Pp"></p>
    <pre>  $doy = Day_of_Year($year,$month,$day);
  ($year,$month,$day) = Add_Delta_Days($year,1,1, $doy - 1);
    </pre>
  </li>
  <li><span class="Li">&quot;$days =
      Date_to_Days($year,$month,$day);&quot;</span>
    <p class="Pp">This function returns the (absolute) number of the day of the
        given date, where counting starts at the 1st of January of the year
        1&#x00A0;A.D.</p>
    <p class="Pp">I.e.,
        &quot;<span class="Li">&quot;Date_to_Days(1,1,1)&quot;</span>&quot;
        returns &quot;<span class="Li">1</span>&quot;,
        &quot;<span class="Li">&quot;Date_to_Days(1,12,31)&quot;</span>&quot;
        returns &quot;<span class="Li">365</span>&quot;,
        &quot;<span class="Li">&quot;Date_to_Days(2,1,1)&quot;</span>&quot;
        returns &quot;<span class="Li">366</span>&quot;,
        &quot;<span class="Li">&quot;Date_to_Days(1998,5,1)&quot;</span>&quot;
        returns &quot;<span class="Li">729510</span>&quot;, and so on.</p>
    <p class="Pp">This is sometimes also referred to (not quite correctly) as
        the Julian date (or day). This may cause confusion, because also the
        number of the day in a year (from 1 to 365 or 366) is frequently called
        the &quot;Julian day&quot;.</p>
    <p class="Pp">More confusing still, this has nothing to do with the Julian
        calendar, which was used <b>BEFORE</b> the Gregorian calendar.</p>
    <p class="Pp">The Julian calendar was named after famous Julius Caesar, who
        had instituted it in Roman times. The Julian calendar is less precise
        than the Gregorian calendar because it has too many leap years compared
        to the true mean length of a year (but the Gregorian calendar also still
        has one day too much every 5000 years). Anyway, the Julian calendar was
        better than what existed before, because rulers had often changed the
        calendar used until then in arbitrary ways, in order to lengthen their
        own reign, for instance.</p>
    <p class="Pp">In order to convert the number returned by this function back
        into a date, use the function
        &quot;<span class="Li">&quot;Add_Delta_Days()&quot;</span>&quot;
        (described further below), as follows:</p>
    <p class="Pp"></p>
    <pre>  $days = Date_to_Days($year,$month,$day);
  ($year,$month,$day) = Add_Delta_Days(1,1,1, $days - 1);
    </pre>
  </li>
  <li><span class="Li">&quot;$dow = Day_of_Week($year,$month,$day);&quot;</span>
    <p class="Pp">This function returns the number of the day of week of the
        given date.</p>
    <p class="Pp">The function returns &quot;<span class="Li">1</span>&quot; for
        Monday, &quot;<span class="Li">2</span>&quot; for Tuesday and so on
        until &quot;<span class="Li">7</span>&quot; for Sunday.</p>
    <p class="Pp">Note that in the Hebrew calendar (on which the Christian
        calendar is based), the week starts with Sunday and ends with the
        Sabbath or Saturday (where according to the Genesis (as described in the
        Bible) the Lord rested from creating the world).</p>
    <p class="Pp">In medieval times, Catholic Popes have decreed the Sunday to
        be the official day of rest, in order to dissociate the Christian from
        the Hebrew belief.</p>
    <p class="Pp">It appears that this actually happened with the Emperor
        Constantin, who converted to Christianity but still worshipped the Sun
        god and therefore moved the Christian sabbath to the day of the Sun.</p>
    <p class="Pp">Nowadays, the Sunday <b>AND</b> the Saturday are commonly
        considered (and used as) days of rest, usually referred to as the
        &quot;week-end&quot;.</p>
    <p class="Pp">Consistent with this practice, current norms and standards
        (such as ISO/R&#x00A0;2015-1971, DIN&#x00A0;1355 and ISO&#x00A0;8601)
        define the Monday as the first day of the week.</p>
  </li>
  <li><span class="Li">&quot;$week =
      Week_Number($year,$month,$day);&quot;</span>
    <p class="Pp">This function returns the number of the week the given date
        lies in.</p>
    <p class="Pp">If the given date lies in the <b>LAST</b> week of the
        <b>PREVIOUS</b> year, &quot;<span class="Li">0</span>&quot; is
      returned.</p>
    <p class="Pp">If the given date lies in the <b>FIRST</b> week of the
        <b>NEXT</b> year, &quot;<span class="Li">&quot;Weeks_in_Year($year) +
        1&quot;</span>&quot; is returned.</p>
  </li>
  <li><span class="Li">&quot;($week,$year) =
      Week_of_Year($year,$month,$day);&quot;</span>
    <p class="Pp">This function returns the number of the week the given date
        lies in, as well as the year that week belongs to.</p>
    <p class="Pp">I.e., if the given date lies in the <b>LAST</b> week of the
        <b>PREVIOUS</b> year,
        &quot;<span class="Li">&quot;(Weeks_in_Year($year-1),
        $year-1)&quot;</span>&quot; is returned.</p>
    <p class="Pp">If the given date lies in the <b>FIRST</b> week of the
        <b>NEXT</b> year, &quot;<span class="Li">&quot;(1,
        $year+1)&quot;</span>&quot; is returned.</p>
    <p class="Pp">Otherwise,
        &quot;<span class="Li">&quot;(Week_Number($year,$month,$day),
        $year)&quot;</span>&quot; is returned.</p>
  </li>
  <li><span class="Li">&quot;$week =
      Week_of_Year($year,$month,$day);&quot;</span>
    <p class="Pp">In scalar context, this function returns just the week number.
        This allows you to write &quot;<span class="Li">&quot;$week =
        Week_of_Year($year,$month,$day);&quot;</span>&quot; instead of
        &quot;<span class="Li">&quot;($week) =
        Week_of_Year($year,$month,$day);&quot;</span>&quot; (note the
        parentheses around &quot;<span class="Li">$week</span>&quot;).</p>
    <p class="Pp">If the given date lies in the <b>LAST</b> week of the
        <b>PREVIOUS</b> year,
        &quot;<span class="Li">&quot;Weeks_in_Year($year-1)&quot;</span>&quot;
        is returned.</p>
    <p class="Pp">If the given date lies in the <b>FIRST</b> week of the
        <b>NEXT</b> year, &quot;<span class="Li">1</span>&quot; is returned.</p>
    <p class="Pp">Otherwise the return value is identical with that of
        &quot;<span class="Li">&quot;Week_Number($year,$month,$day)&quot;</span>&quot;.</p>
    <p class="Pp"><b>BEWARE</b> that using this function in scalar context is a
        <b>DANGEROUS</b> feature, because without knowing which year the week
        belongs to, you might inadvertently assume the wrong one!</p>
    <p class="Pp">If for instance you are iterating through an interval of
        dates, you might assume that the week always belongs to the same year as
        the given date, which unfortunately is <b>WRONG</b> in some cases!</p>
    <p class="Pp">In many years, the 31st of December for instance belongs to
        week number one of the <b>FOLLOWING</b> year. Assuming that the year is
        the same as your date (31st of December, in this example), sends you
        back to the first week of the <b>CURRENT</b> year - the Monday of which,
        by the way, in case of bad luck, might actually lie in the year
        <b>BEFORE</b> the current year!</p>
    <p class="Pp">This actually happens in 2002, for example.</p>
    <p class="Pp">So you always need to provide the correct corresponding year
        number by other means, keeping track of it yourself.</p>
    <p class="Pp">In case you do not understand this, never mind, but then
        simply <b>DO NOT USE</b> this function in scalar context!</p>
  </li>
  <li><span class="Li">&quot;($year,$month,$day) =
      Monday_of_Week($week,$year);&quot;</span>
    <p class="Pp">This function returns the date of the first day of the given
        week, i.e., the Monday.</p>
    <p class="Pp">&quot;<span class="Li">$year</span>&quot; must be greater than
        or equal to &quot;<span class="Li">1</span>&quot;, and
        &quot;<span class="Li">$week</span>&quot; must lie in the range
        &quot;<span class="Li">1</span>&quot; to
        &quot;<span class="Li">&quot;Weeks_in_Year($year)&quot;</span>&quot;.</p>
    <p class="Pp">Note that you can write
        &quot;<span class="Li">&quot;($year,$month,$day) =
        Monday_of_Week(Week_of_Year($year,$month,$day));&quot;</span>&quot; in
        order to calculate the date of the Monday of the same week as the given
        date.</p>
    <p class="Pp">If you want to calculate any other day of week in the same
        week as a given date, use</p>
    <p class="Pp"></p>
    <pre>  @date = Add_Delta_Days(Monday_of_Week(Week_of_Year(@date)),$offset);
    </pre>
    <p class="Pp">where <span class="Li">&quot;$offset = 1&quot;</span> for
        Tuesday, <span class="Li">2</span> for Wednesday etc.</p>
  </li>
  <li><span class="Li">&quot;if (($year,$month,$day) =
      Nth_Weekday_of_Month_Year($year,$month,$dow,$n))&quot;</span>
    <p class="Pp">This function calculates the date of the
        &quot;<span class="Li">$n</span>&quot;th day of week
        &quot;<span class="Li">$dow</span>&quot; in the given month
        &quot;<span class="Li">$month</span>&quot; and year
        &quot;<span class="Li">$year</span>&quot;; such as, for example, the 3rd
        Thursday of a given month and year.</p>
    <p class="Pp">This can be used to send a notification mail to the members of
        a group which meets regularly on every 3rd Thursday of a month, for
        instance.</p>
    <p class="Pp">(See the section &quot;RECIPES&quot; near the end of this
        document for a code snippet to actually do so.)</p>
    <p class="Pp">&quot;<span class="Li">$year</span>&quot; must be greater than
        or equal to &quot;<span class="Li">1</span>&quot;,
        &quot;<span class="Li">$month</span>&quot; must lie in the range
        &quot;<span class="Li">1</span>&quot; to
        &quot;<span class="Li">12</span>&quot;,
        &quot;<span class="Li">$dow</span>&quot; must lie in the range
        &quot;<span class="Li">1</span>&quot; to
        &quot;<span class="Li">7</span>&quot; and
        &quot;<span class="Li">$n</span>&quot; must lie in the range
        &quot;<span class="Li">1</span>&quot; to
        &quot;<span class="Li">5</span>&quot;, or a fatal error (with
        appropriate error message) occurs.</p>
    <p class="Pp">The function returns an empty list when the 5th of a given day
        of week does not exist in the given month and year.</p>
  </li>
  <li><span class="Li">&quot;($year,$week,$dow) =
      Standard_to_Business($year,$month,$day);&quot;</span>
    <p class="Pp">This function converts a given date from standard notation
        (year, month, day (of month)) to business notation (year, week, day of
        week).</p>
  </li>
  <li><span class="Li">&quot;($year,$month,$day) =
      Business_to_Standard($year,$week,$dow);&quot;</span>
    <p class="Pp">This function converts a given date from business notation
        (year, week, day of week) to standard notation (year, month, day (of
        month)).</p>
  </li>
  <li><span class="Li">&quot;$Dd = Delta_Days($year1,$month1,$day1,
      $year2,$month2,$day2);&quot;</span>
    <p class="Pp">This function returns the difference in days between the two
        given dates.</p>
    <p class="Pp">The result is positive if the two dates are in chronological
        order, i.e., if date #1 comes chronologically <b>BEFORE</b> date #2, and
        negative if the order of the two dates is reversed.</p>
    <p class="Pp">The result is zero if the two dates are identical.</p>
  </li>
  <li><span class="Li">&quot;($Dd,$Dh,$Dm,$Ds) =
      Delta_DHMS($year1,$month1,$day1, $hour1,$min1,$sec1, $year2,$month2,$day2,
      $hour2,$min2,$sec2);&quot;</span>
    <p class="Pp">This function returns the difference in days, hours, minutes
        and seconds between the two given dates with times.</p>
    <p class="Pp">All four return values will be positive if the two dates are
        in chronological order, i.e., if date #1 comes chronologically
        <b>BEFORE</b> date #2, and negative (in all four return values!) if the
        order of the two dates is reversed.</p>
    <p class="Pp">This is so that the two functions
        &quot;<span class="Li">&quot;Delta_DHMS()&quot;</span>&quot; and
        &quot;<span class="Li">&quot;Add_Delta_DHMS()&quot;</span>&quot;
        (description see further below) are complementary, i.e., mutually
        inverse:</p>
    <p class="Pp"></p>
    <pre>  Add_Delta_DHMS(@date1,@time1, Delta_DHMS(@date1,@time1, @date2,@time2))
    </pre>
    <p class="Pp">yields
        &quot;<span class="Li">&quot;(@date2,@time2)&quot;</span>&quot; again,
        whereas</p>
    <p class="Pp"></p>
    <pre>  Add_Delta_DHMS(@date2,@time2,
      map(-$_, Delta_DHMS(@date1,@time1, @date2,@time2)))
    </pre>
    <p class="Pp">yields
        &quot;<span class="Li">&quot;(@date1,@time1)&quot;</span>&quot;, and</p>
    <p class="Pp"></p>
    <pre>  Delta_DHMS(@date1,@time1, Add_Delta_DHMS(@date1,@time1, @delta))
    </pre>
    <p class="Pp">yields &quot;<span class="Li">@delta</span>&quot; again.</p>
    <p class="Pp">The result is zero (in all four return values) if the two
        dates and times are identical.</p>
  </li>
  <li><span class="Li">&quot;($Dy,$Dm,$Dd) = Delta_YMD($year1,$month1,$day1,
      $year2,$month2,$day2);&quot;</span>
    <p class="Pp">This function returns the vector</p>
    <p class="Pp"></p>
    <pre>    ( $year2 - $year1, $month2 - $month1, $day2 - $day1 )
    </pre>
    <p class="Pp">This is called the &quot;one-by-one&quot; semantics.</p>
    <p class="Pp">Adding the result of this function to the first date always
        yields the second date again, and adding the negative result (where the
        signs of all elements of the result vector have been flipped) to the
        second date gives the first date. See also the description of the
        function &quot;<b>Add_Delta_YMD()</b>&quot; further below.</p>
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>  (6,2,-30) == Delta_YMD(1996,1,31, 2002,3,1]);
  [1996,1,31] + ( 6, 2,-30) = [2002,3, 1]
  [2002,3, 1] + (-6,-2, 30) = [1996,1,31]
    </pre>
    <p class="Pp">An error occurs if any of the two given dates is invalid.</p>
  </li>
  <li><span class="Li">&quot;($D_y,$D_m,$D_d, $Dh,$Dm,$Ds) =
      Delta_YMDHMS($year1,$month1,$day1, $hour1,$min1,$sec1,
      $year2,$month2,$day2, $hour2,$min2,$sec2);&quot;</span>
    <p class="Pp">This function is based on the function
        &quot;<b>Delta_YMD()</b>&quot; above but additionally calculates the
        time difference. When a carry over from the time difference occurs, the
        value of &quot;<span class="Li">$D_d</span>&quot; is adjusted
        accordingly, thus giving the correct total date/time difference.</p>
    <p class="Pp">Arguments are expected to be in chronological order to yield a
        (usually) positive result.</p>
    <p class="Pp">In any case, adding the result of this function to the first
        date/time value
        (<span class="Li">&quot;$year1,$month1,$day1,&quot;</span>
        <span class="Li">&quot;$hour1,$min1,$sec1&quot;</span>) always gives the
        second date/time value
        (<span class="Li">&quot;$year2,$month2,$day2,&quot;</span>
        <span class="Li">&quot;$hour2,$min2,$sec2&quot;</span>) again, and
        adding the negative result (with the signs of all elements of the result
        vector flipped) to the second date/time value gives the first date/time
        value.</p>
    <p class="Pp">See the function &quot;<b>Add_Delta_YMDHMS()</b>&quot; further
        below for adding a date/time value and a date/time difference.</p>
    <p class="Pp">An error occurs if any of the given two date/time values is
        invalid.</p>
  </li>
  <li><span class="Li">&quot;($Dy,$Dm,$Dd) = N_Delta_YMD($year1,$month1,$day1,
      $year2,$month2,$day2);&quot;</span>
    <p class="Pp">This function returns the difference between the two given
        dates in a more intuitive way (as far as possible - more on that see a
        bit further below) than the function &quot;<b>Delta_YMD()</b>&quot;
        described above.</p>
    <p class="Pp">The &quot;N&quot; which precedes its name is meant to signify
        &quot;new&quot; or &quot;normalized&quot;.</p>
    <p class="Pp">This function is loosely based on recipe #17 b) (see the
        section &quot;RECIPES&quot; below near the end of this document).</p>
    <p class="Pp">However, the code of recipe #17 b) actually does not treat
        positive and negative values symmetrically and consistently.</p>
    <p class="Pp">This new routine does.</p>
    <p class="Pp">The return values of this function are guaranteed to all have
        the same sign (or to be zero). This is why this function is called
        &quot;normalized&quot;.</p>
    <p class="Pp">Moreover, the results are guaranteed to be
        &quot;minimal&quot;, in the sense that <span class="Li">&quot;|$Dm| &lt;
        12&quot;</span> and <span class="Li">&quot;|$Dd| &lt; 31&quot;</span>
        (which is equivalent to <span class="Li">$Dm</span> lying in the range
        <span class="Li">&quot;[-11..+11]&quot;</span> and
        <span class="Li">$Dd</span> lying in the range
        <span class="Li">&quot;[-30..+30]&quot;</span>).</p>
    <p class="Pp">When the results are applied (i.e., added) to the first given
        date in a left-to-right order, the second given date is guaranteed to be
        obtained, provided that intermediary results are truncated, as done by
        the function &quot;<b>Add_Delta_YM()</b>&quot; (see further below),
        i.e., that invalid intermediate dates such as e.g. [2009,2,31] will
        automatically be transformed into [2009,2,28] (and not
        &quot;wrapped&quot; into the next month, e.g. to [2009,3,3]).</p>
    <p class="Pp">This is called the &quot;left-to-right with truncation&quot;
        semantics.</p>
    <p class="Pp">Note that reversing the order of the given dates and reversing
        the sign of each of the result values will not always add up.</p>
    <p class="Pp">Consider the dates [2008,2,29] and [2009,2,1]: their
        difference is (0,11,3) ([2008,2,29] plus 11 months is [2009,1,29], which
        plus 3 days is [2009,2,1]), but the difference between [2009,2,1] and
        [2008,2,29] is (0,-11,-1), and not (0,-11,-3) ([2009,2,1] minus 11
        months is [2008,3,1], which minus one day is [2008,2,29]).</p>
    <p class="Pp">Another example: The difference between [1996,2,29] and
        [1997,2,28] is (1,0,0) (observe the truncation of the invalid date
        [1997,2,29] to [1997,2,28] here!), whereas the difference between
        [1997,2,28] and [1996,2,29] is (0,-11,-28) ([1997,2,28] minus 11 months
        is [1996,3,28], which minus 28 days is not [1996,3,0] but of course
        [1996,2,29]).</p>
    <p class="Pp">&quot;Benign&quot; examples such as for instance the
        difference between [1964,1,3] and [2009,9,10] are completely
        symmetrical: The difference in this example is (45,8,7), whereas the
        difference between [2009,9,10] and [1964,1,3] is (-45,-8,-7), as would
        normally be expected. In this example, the result is also the same as
        the one returned by &quot;<b>Delta_YMD()</b>&quot;.</p>
    <p class="Pp">All these counter-intuitive effects are due to the fact that
        months (and due to leap years, also years) do not correspond to a fixed
        number of days, so the semantics of &quot;plus one month&quot; or
        &quot;plus one year&quot; are in fact undefined.</p>
    <p class="Pp">The present function is an attempt to provide a definition
        which is intuitive most of the time, and at least consistent the rest of
        the time.</p>
    <p class="Pp">Other definitions are of course possible, but most often lead
        to contradictions (e.g., the results and the given first date do not add
        up to the second given date).</p>
    <p class="Pp">See the file &quot;datecalc.pl&quot; in the
        &quot;examples&quot; subdirectory of this distribution for a way to play
        around with this function, or go to
        http://www.engelschall.com/u/sb/datecalc/ for the online version.</p>
    <p class="Pp">An error occurs if any of the two given dates is invalid, or
        if any intermediate result leads to an invalid date (this does not apply
        to truncation, however, as explained above).</p>
  </li>
  <li><span class="Li">&quot;($D_y,$D_m,$D_d, $Dhh,$Dmm,$Dss) =
      N_Delta_YMDHMS($year1,$month1,$day1, $hour1,$min1,$sec1,
      $year2,$month2,$day2, $hour2,$min2,$sec2);&quot;</span>
    <p class="Pp">This function essentially does the same as the function
        &quot;<b>N_Delta_YMD()</b>&quot; described immediately above, except
        that also the difference in hours, minutes and seconds is taken into
        account.</p>
    <p class="Pp">This function is loosely based on recipe #17 a) (see the
        section &quot;RECIPES&quot; below near the end of this document).</p>
    <p class="Pp">However, the code of recipe #17 a) actually does not treat
        positive and negative values symmetrically and consistently.</p>
    <p class="Pp">This new routine does.</p>
    <p class="Pp">The return values of this function (including the time
        differences) are guaranteed to all have the same sign (or to be zero).
        This is the reason for the &quot;N&quot; that precedes the name of this
        function, which is intended to mean &quot;normalized&quot; (or
        &quot;new&quot;).</p>
    <p class="Pp">Moreover, the results are guaranteed to be
        &quot;minimal&quot;, in the sense that <span class="Li">&quot;|$D_m|
        &lt; 12&quot;</span>, <span class="Li">&quot;|$D_d| &lt;
        31&quot;</span>, <span class="Li">&quot;|$Dhh| &lt; 24&quot;</span>,
        <span class="Li">&quot;|$Dmm| &lt; 60&quot;</span> and
        <span class="Li">&quot;|$Dss| &lt; 60&quot;</span> (which is equivalent
        to <span class="Li">$D_m</span> lying in the range
        <span class="Li">&quot;[-11..+11]&quot;</span>,
        <span class="Li">$D_d</span> lying in the range
        <span class="Li">&quot;[-30..+30]&quot;</span>,
        <span class="Li">$Dhh</span> lying in the range
        <span class="Li">&quot;[-23..+23]&quot;</span>, and
        <span class="Li">$Dmm</span> and <span class="Li">$Dss</span> both lying
        in the range <span class="Li">&quot;[-59..+59]&quot;</span>).</p>
  </li>
  <li><span class="Li">&quot;($Dd,$Dh,$Dm,$Ds) =
      Normalize_DHMS($Dd,$Dh,$Dm,$Ds);&quot;</span>
    <p class="Pp">This function takes four arbitrary values for days, hours,
        minutes and seconds (which may have different signs) and renormalizes
        them so that the values for hours, minutes and seconds will lie in the
        ranges <span class="Li">&quot;[-23..23]&quot;</span>,
        <span class="Li">&quot;[-59..59]&quot;</span> and
        <span class="Li">&quot;[-59..59]&quot;</span>, respectively, and so that
        all four values have the same sign (or are zero).</p>
    <p class="Pp">The given values are left untouched, i.e., unchanged.</p>
  </li>
  <li><span class="Li">&quot;($year,$month,$day) =
      Add_Delta_Days($year,$month,$day, $Dd);&quot;</span>
    <p class="Pp">This function has two principal uses:</p>
    <p class="Pp">First, it can be used to calculate a new date, given an
        initial date and an offset (which may be positive or negative) in days,
        in order to answer questions like &quot;today plus 90 days -- which date
        gives that?&quot;.</p>
    <p class="Pp">(In order to add a weeks offset, simply multiply the weeks
        offset with &quot;<span class="Li">7</span>&quot; and use that as your
        days offset.)</p>
    <p class="Pp">Second, it can be used to convert the canonical representation
        of a date, i.e., the number of that day (where counting starts at the
        1st of January in 1&#x00A0;A.D.), back into a date given as year, month
        and day.</p>
    <p class="Pp">Because counting starts at
        &quot;<span class="Li">1</span>&quot;, you will actually have to
        subtract &quot;<span class="Li">1</span>&quot; from the canonical date
        in order to get back the original date:</p>
    <p class="Pp"></p>
    <pre>  $canonical = Date_to_Days($year,$month,$day);
  ($year,$month,$day) = Add_Delta_Days(1,1,1, $canonical - 1);
    </pre>
    <p class="Pp">Moreover, this function is the inverse of the function
        &quot;<span class="Li">&quot;Delta_Days()&quot;</span>&quot;:</p>
    <p class="Pp"></p>
    <pre>  Add_Delta_Days(@date1, Delta_Days(@date1, @date2))
    </pre>
    <p class="Pp">yields &quot;<span class="Li">@date2</span>&quot; again,
        whereas</p>
    <p class="Pp"></p>
    <pre>  Add_Delta_Days(@date2, -Delta_Days(@date1, @date2))
    </pre>
    <p class="Pp">yields &quot;<span class="Li">@date1</span>&quot;, and</p>
    <p class="Pp"></p>
    <pre>  Delta_Days(@date1, Add_Delta_Days(@date1, $delta))
    </pre>
    <p class="Pp">yields &quot;<span class="Li">$delta</span>&quot; again.</p>
  </li>
  <li><span class="Li">&quot;($year,$month,$day, $hour,$min,$sec) =
      Add_Delta_DHMS($year,$month,$day, $hour,$min,$sec,
      $Dd,$Dh,$Dm,$Ds);&quot;</span>
    <p class="Pp">This function serves to add a days, hours, minutes and seconds
        offset to a given date and time, in order to answer questions like
        &quot;today and now plus 7 days but minus 5 hours and then plus 30
        minutes, what date and time gives that?&quot;:</p>
    <p class="Pp"></p>
    <pre>  ($y,$m,$d,$H,$M,$S) = Add_Delta_DHMS(Today_and_Now(), +7,-5,+30,0);
    </pre>
  </li>
  <li><span class="Li">&quot;($year,$month,$day) =
      Add_Delta_YM($year,$month,$day, $Dy,$Dm);&quot;</span>
    <p class="Pp">This function can be used to add a year and/or month offset to
        a given date.</p>
    <p class="Pp">In contrast to the function described immediately below
        (&quot;<span class="Li">&quot;Add_Delta_YMD()&quot;</span>&quot;), this
        function does no &quot;wrapping&quot; into the next month if the day
        happens to lie outside the valid range for the resulting year and month
        (after adding the year and month offsets). Instead, it simply truncates
        the day to the last possible day of the resulting month.</p>
    <p class="Pp">Examples:</p>
    <p class="Pp">Adding an offset of 0 years, 1 month to the date [1999,1,31]
        would result in the (invalid) date [1999,2,31]. The function replaces
        this result by the (valid) date [1999,2,28].</p>
    <p class="Pp">Adding an offset of 1 year, 1 month to the same date
        [1999,1,31] as above would result in the (still invalid) date
        [2000,2,31]. The function replaces this result by the valid date
        [2000,2,29] (because 2000 is a leap year).</p>
    <p class="Pp">Note that the year and month offsets can be negative, and that
        they can have different signs.</p>
    <p class="Pp">If you want to additionally add a days offset, use the
        function
        &quot;<span class="Li">&quot;Add_Delta_Days()&quot;</span>&quot; before
        or after calling
        &quot;<span class="Li">&quot;Add_Delta_YM()&quot;</span>&quot;:</p>
    <p class="Pp"></p>
    <pre>  @date2 = Add_Delta_Days( Add_Delta_YM(@date1, $Dy,$Dm), $Dd );
  @date2 = Add_Delta_YM( Add_Delta_Days(@date1, $Dd), $Dy,$Dm );
    </pre>
    <p class="Pp">Note that your result may depend on the order in which you
        call these two functions!</p>
    <p class="Pp">Consider the date [1999,2,28] and the offsets 0 years, 1 month
        and 1 day:</p>
    <p class="Pp">[1999,2,28] plus one month is [1999,3,28], plus one day is
        [1999,3,29]. [1999,2,28] plus one day is [1999,3,1], plus one month is
        [1999,4,1].</p>
    <p class="Pp">(Which is also the reason why the
        &quot;<span class="Li">&quot;Add_Delta_YM()&quot;</span>&quot; function
        does not allow to add a days offset, because this would actually require
        TWO functions: One for adding the days offset BEFORE and one for adding
        it AFTER applying the year/month offsets.)</p>
    <p class="Pp">An error occurs if the initial date is not valid.</p>
    <p class="Pp">Note that &quot;<span class="Li">&quot;Add_Delta_YM(
        Add_Delta_YM(@date, $Dy,$Dm), -$Dy,-$Dm );&quot;</span>&quot; will not,
        in general, return the original date
        &quot;<span class="Li">@date</span>&quot; (consider the examples given
        above!).</p>
  </li>
  <li><span class="Li">&quot;($year,$month,$day) =
      Add_Delta_YMD($year,$month,$day, $Dy,$Dm,$Dd);&quot;</span>
    <p class="Pp">This function serves to add a years, months and days offset to
        a given date.</p>
    <p class="Pp">(In order to add a weeks offset, simply multiply the weeks
        offset with &quot;<span class="Li">7</span>&quot; and add this number to
        your days offset.)</p>
    <p class="Pp">Note that the three offsets for years, months and days are
        applied independently from each other. This also allows them to have
        different signs.</p>
    <p class="Pp">The years and months offsets are applied first, and the days
        offset is applied last.</p>
    <p class="Pp">If the resulting date happens to fall on a day after the end
        of the resulting month, like the 32nd of April or the 30th of February,
        then the date is simply counted forward into the next month (possibly
        also into the next year) by the number of excessive days (e.g., the 32nd
        of April will become the 2nd of May).</p>
    <p class="Pp"><b>BEWARE</b> that this behaviour differs from that of
        previous versions of this module! In previous versions, the day was
        simply truncated to the maximum number of days in the resulting
      month.</p>
    <p class="Pp">If you want the previous behaviour, use the new function
        &quot;<span class="Li">&quot;Add_Delta_YM()&quot;</span>&quot;
        (described immediately above) plus the function
        &quot;<span class="Li">&quot;Add_Delta_Days()&quot;</span>&quot;
        instead.</p>
    <p class="Pp"><b>BEWARE</b> also that because a year and a month offset is
        not equivalent to a fixed number of days, the transformation performed
        by this function is <b>NOT ALWAYS REVERSIBLE</b>!</p>
    <p class="Pp">This is in contrast to the functions
        &quot;<span class="Li">&quot;Add_Delta_Days()&quot;</span>&quot; and
        &quot;<span class="Li">&quot;Add_Delta_DHMS()&quot;</span>&quot;, which
        are fully and truly reversible (with the help of the functions
        &quot;<span class="Li">&quot;Delta_Days()&quot;</span>&quot; and
        &quot;<span class="Li">&quot;Delta_DHMS()&quot;</span>&quot;, for
        instance).</p>
    <p class="Pp">Note that for this same reason,</p>
    <p class="Pp"></p>
    <pre>  @date = Add_Delta_YMD(
          Add_Delta_YMD(@date, $Dy,$Dm,$Dd), -$Dy,-$Dm,-$Dd);
    </pre>
    <p class="Pp">will in general <b>NOT</b> return the initial date
        &quot;<span class="Li">@date</span>&quot;, even though</p>
    <p class="Pp"></p>
    <pre>  @date2 = Add_Delta_YMD( @date1, Delta_YMD(@date1, @date2) );
    </pre>
    <p class="Pp">will always return the second date
        &quot;<span class="Li">@date2</span>&quot;, and</p>
    <p class="Pp"></p>
    <pre>  @date1 = Add_Delta_YMD( @date2, map(-$_, Delta_YMD(@date1, @date2)) );
    </pre>
    <p class="Pp">which is the same as</p>
    <p class="Pp"></p>
    <pre>  @date1 = Add_Delta_YMD( @date2, Delta_YMD(@date2, @date1) );
    </pre>
    <p class="Pp">will always return the first date
        &quot;<span class="Li">@date1</span>&quot;.</p>
    <p class="Pp">Examples:</p>
    <p class="Pp"></p>
    <pre>  [1996,1,31] + ( 6, 1,-2) = [2002,3,1]
  [2002,3, 1] + (-6,-1, 2) = [1996,2,3] # EXPECTED: [1996,1,31]
  (6,2,-30) == Delta_YMD(1996,1,31, 2002,3,1);
  [1996,1,31] + ( 6, 2,-30) = [2002,3, 1]
  [2002,3, 1] + (-6,-2, 30) = [1996,1,31] # OK
  (6,1,-2) == Delta_YMD(1996,2,3, 2002,3,1);
  [1996,2,3] + ( 6, 1,-2) = [2002,3,1]
  [2002,3,1] + (-6,-1, 2) = [1996,2,3] # OK
    </pre>
    <p class="Pp">Note that this is <b>NOT</b> a program bug but
        <b>NECESSARILY</b> so, because of the variable lengths of years and
        months, and hence because of the ambiguity of the difference between two
        dates in terms of years, months and days, i.e., the fact that the
        difference between two dates can be expressed in more than one way:</p>
    <p class="Pp"></p>
    <pre>  [1996,1,31] + (6,1, -2) = [2002,3,1]
  [1996,1,31] + (6,2,-30) = [2002,3,1]
    </pre>
  </li>
  <li><span class="Li">&quot;($year,$month,$day, $hour,$min,$sec) =
      Add_Delta_YMDHMS($year,$month,$day, $hour,$min,$sec, $D_y,$D_m,$D_d,
      $Dh,$Dm,$Ds);&quot;</span>
    <p class="Pp">Same as the function above, except that a time offset may be
        given in addition to the year, month and day offset.</p>
  </li>
  <li><span class="Li">&quot;($year,$month,$day) =
      Add_N_Delta_YMD($year,$month,$day, $Dy,$Dm,$Dd);&quot;</span>
    <p class="Pp">This function is actually a shortcut for applying the function
        &quot;<b>Add_Delta_YM()</b>&quot; first, followed by the function
        &quot;<b>Add_Delta_Days()</b>&quot;, i.e., this function does exactly
        the same as</p>
    <p class="Pp"></p>
    <pre> ($year,$month,$day) = Add_Delta_Days( Add_Delta_YM($year,$month,$day,$Dy,$Dm), $Dd );
    </pre>
    <p class="Pp">Beware that, if necessary, the function
        &quot;<b>Add_Delta_YM()</b>&quot; truncates the resulting day of the
        month to the largest allowable value for that month, i.e., the (invalid)
        result [2009,2,31] is automatically transformed into [2009,2,28].</p>
    <p class="Pp">For more details on this truncation, see the description of
        the function &quot;<b>Add_Delta_YM()</b>&quot; further above.</p>
    <p class="Pp">This function is meant to be complementary with the function
        &quot;<b>N_Delta_YMD()</b>&quot; described further above.</p>
    <p class="Pp">This means that it is guaranteed that the result returned
      by</p>
    <p class="Pp"></p>
    <pre>  Add_N_Delta_YMD( @date1, N_Delta_YMD(@date1, @date2) );
    </pre>
    <p class="Pp">is always identical with the given date
        &quot;<span class="Li">@date2</span>&quot;.</p>
    <p class="Pp">Note however that unlike with function
        &quot;<b>Add_Delta_YMD()</b>&quot;, the reverse is not true here,
      i.e.,</p>
    <p class="Pp"></p>
    <pre>  ($Dy,$Dm,$Dd) = N_Delta_YMD(@date1,@date2);
  @date = Add_N_Delta_YMD(@date2, -$Dy,-$Dm,-$Dd);
    </pre>
    <p class="Pp">will <b>NOT</b> always return the initial date
        &quot;<span class="Li">@date1</span>&quot;.</p>
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>  (0,11,3) == N_Delta_YMD(2008,2,29, 2009,2,1);
  [2008,2,29] + (0, 11, 3) = [2009,2, 1]
  [2009,2, 1] + (0,-11,-3) = [2008,2,27] # EXPECTED: [2008,2,29]
    </pre>
  </li>
  <li><span class="Li">&quot;($year,$month,$day, $hour,$min,$sec) =
      Add_N_Delta_YMDHMS($year,$month,$day, $hour,$min,$sec, $D_y,$D_m,$D_d,
      $Dhh,$Dmm,$Dss);&quot;</span>
    <p class="Pp">This function essentially does the same as the function
        &quot;<b>Add_N_Delta_YMD()</b>&quot; described immediately above, except
        that also the difference in hours, minutes and seconds is taken into
        account.</p>
  </li>
  <li><span class="Li">&quot;($year,$month,$day, $hour,$min,$sec,
      $doy,$dow,$dst) = System_Clock([$gmt]);&quot;</span>
    <p class="Pp">If your operating system supports the corresponding system
        calls (&quot;<span class="Li">&quot;time()&quot;</span>&quot; and
        &quot;<span class="Li">&quot;localtime()&quot;</span>&quot; or
        &quot;<span class="Li">&quot;gmtime()&quot;</span>&quot;), this function
        will return the information provided by your system clock, i.e., the
        current date and time, the number of the day of year, the number of the
        day of week and a flag signaling whether daylight savings time is
        currently in effect or not.</p>
    <p class="Pp">The ranges of values returned (and their meanings) are as
        follows:</p>
    <p class="Pp"></p>
    <pre>        $year   :   1970..2038 (or more)  [Unix etc.]
        $year   :   1904..2040            [MacOS Classic]
        $month  :   1..12
        $day    :   1..31
        $hour   :   0..23
        $min    :   0..59
        $sec    :   0..59    (0..61 on some systems)
        $doy    :   1..366
        $dow    :   1..7
        $dst    :  -1..1
    </pre>
    <p class="Pp">&quot;<span class="Li">$doy</span>&quot; is the day of year,
        sometimes also referred to as the &quot;julian date&quot;, which starts
        at &quot;<span class="Li">1</span>&quot; and goes up to the number of
        days in that year.</p>
    <p class="Pp">The day of week (&quot;<span class="Li">$dow</span>&quot;)
        will be &quot;<span class="Li">1</span>&quot; for Monday,
        &quot;<span class="Li">2</span>&quot; for Tuesday and so on until
        &quot;<span class="Li">7</span>&quot; for Sunday.</p>
    <p class="Pp">The daylight savings time flag
        (&quot;<span class="Li">$dst</span>&quot;) will be
        &quot;<span class="Li">&quot;-1&quot;</span>&quot; if this information
        is not available on your system, &quot;<span class="Li">0</span>&quot;
        for no daylight savings time (i.e., winter time) and
        &quot;<span class="Li">1</span>&quot; when daylight savings time is in
        effect.</p>
    <p class="Pp">If your operating system does not provide the necessary system
        calls, calling this function will result in a fatal &quot;not available
        on this system&quot; error message.</p>
    <p class="Pp">If you want to handle this exception yourself, use
        &quot;<span class="Li">&quot;eval&quot;</span>&quot; as follows:</p>
    <p class="Pp"></p>
    <pre>  eval { ($year,$month,$day, $hour,$min,$sec, $doy,$dow,$dst) =
    System_Clock(); };
  if ($@)
  {
      # Handle missing system clock
      # (For instance, ask user to enter this information manually)
  }
    </pre>
    <p class="Pp">Note that curlies (&quot;{&quot; and &quot;}&quot;) are used
        here to delimit the statement to be &quot;eval&quot;ed (which is the way
        to catch exceptions in Perl), and not quotes (which is a way to evaluate
        Perl expressions at runtime).</p>
    <p class="Pp">If the optional (boolean) input parameter
        &quot;<span class="Li">$gmt</span>&quot; is given, a &quot;true&quot;
        value (&quot;<span class="Li">1</span>&quot;) will cause
        &quot;<span class="Li">&quot;gmtime()&quot;</span>&quot; to be used
        instead of &quot;<span class="Li">&quot;localtime()&quot;</span>&quot;,
        internally, thus returning Greenwich Mean Time (GMT, or UTC) instead of
        local time.</p>
  </li>
  <li><span class="Li">&quot;($year,$month,$day) = Today([$gmt]);&quot;</span>
    <p class="Pp">This function returns a subset of the values returned by the
        function &quot;<span class="Li">&quot;System_Clock()&quot;</span>&quot;
        (see above for details), namely the current year, month and day.</p>
    <p class="Pp">A fatal &quot;not available on this system&quot; error message
        will appear if the corresponding system calls are not supported by your
        current operating system.</p>
    <p class="Pp">If the optional (boolean) input parameter
        &quot;<span class="Li">$gmt</span>&quot; is given, a &quot;true&quot;
        value (&quot;<span class="Li">1</span>&quot;) will cause
        &quot;<span class="Li">&quot;gmtime()&quot;</span>&quot; to be used
        instead of &quot;<span class="Li">&quot;localtime()&quot;</span>&quot;,
        internally, thus returning Greenwich Mean Time (GMT, or UTC) instead of
        local time.</p>
  </li>
  <li><span class="Li">&quot;($hour,$min,$sec) = Now([$gmt]);&quot;</span>
    <p class="Pp">This function returns a subset of the values returned by the
        function &quot;<span class="Li">&quot;System_Clock()&quot;</span>&quot;
        (see above for details), namely the current time (hours, minutes and
        full seconds).</p>
    <p class="Pp">A fatal &quot;not available on this system&quot; error message
        will appear if the corresponding system calls are not supported by your
        current operating system.</p>
    <p class="Pp">If the optional (boolean) input parameter
        &quot;<span class="Li">$gmt</span>&quot; is given, a &quot;true&quot;
        value (&quot;<span class="Li">1</span>&quot;) will cause
        &quot;<span class="Li">&quot;gmtime()&quot;</span>&quot; to be used
        instead of &quot;<span class="Li">&quot;localtime()&quot;</span>&quot;,
        internally, thus returning Greenwich Mean Time (GMT, or UTC) instead of
        local time.</p>
  </li>
  <li><span class="Li">&quot;($year,$month,$day, $hour,$min,$sec) =
      Today_and_Now([$gmt]);&quot;</span>
    <p class="Pp">This function returns a subset of the values returned by the
        function &quot;<span class="Li">&quot;System_Clock()&quot;</span>&quot;
        (see above for details), namely the current date (year, month, day) and
        time (hours, minutes and full seconds).</p>
    <p class="Pp">A fatal &quot;not available on this system&quot; error message
        will appear if the corresponding system calls are not supported by your
        current operating system.</p>
    <p class="Pp">If the optional (boolean) input parameter
        &quot;<span class="Li">$gmt</span>&quot; is given, a &quot;true&quot;
        value (&quot;<span class="Li">1</span>&quot;) will cause
        &quot;<span class="Li">&quot;gmtime()&quot;</span>&quot; to be used
        instead of &quot;<span class="Li">&quot;localtime()&quot;</span>&quot;,
        internally, thus returning Greenwich Mean Time (GMT, or UTC) instead of
        local time.</p>
  </li>
  <li><span class="Li">&quot;$year = This_Year([$gmt]);&quot;</span>
    <p class="Pp">This function returns the current year, according to local
        time.</p>
    <p class="Pp">A fatal &quot;not available on this system&quot; error message
        will appear if the corresponding system calls are not supported by your
        current operating system.</p>
    <p class="Pp">If the optional (boolean) input parameter
        &quot;<span class="Li">$gmt</span>&quot; is given, a &quot;true&quot;
        value (&quot;<span class="Li">1</span>&quot;) will cause
        &quot;<span class="Li">&quot;gmtime()&quot;</span>&quot; to be used
        instead of &quot;<span class="Li">&quot;localtime()&quot;</span>&quot;,
        internally, thus returning Greenwich Mean Time (GMT, or UTC) instead of
        local time. However, this will only make a difference within a few hours
        around New Year (unless you are on a Pacific island, where this can be
        almost 24 hours).</p>
  </li>
  <li><span class="Li">&quot;($year,$month,$day, $hour,$min,$sec,
      $doy,$dow,$dst) = Gmtime([time]);&quot;</span>
    <p class="Pp">This is Date::Calc's equivalent of Perl's built-in
        &quot;<b>gmtime()</b>&quot; function. See also &quot;gmtime&quot; in
        <b>perlfunc</b>(1).</p>
    <p class="Pp">With the optional argument &quot;time&quot; (i.e., seconds
        since the epoch), this function will return the corresponding values for
        that particular time (instead of the current time when this parameter is
        omitted).</p>
    <p class="Pp">The ranges of values returned (and their meanings) are as
        follows:</p>
    <p class="Pp"></p>
    <pre>        $year   :   1970..2038 (or more)  [Unix etc.]
        $year   :   1904..2040            [MacOS Classic]
        $month  :   1..12
        $day    :   1..31
        $hour   :   0..23
        $min    :   0..59
        $sec    :   0..59
        $doy    :   1..366
        $dow    :   1..7
        $dst    :  -1..1
    </pre>
    <p class="Pp">&quot;<span class="Li">$doy</span>&quot; is the day of year,
        sometimes also referred to as the &quot;julian date&quot;, which starts
        at &quot;<span class="Li">1</span>&quot; and goes up to the number of
        days in that year.</p>
    <p class="Pp">The day of week (&quot;<span class="Li">$dow</span>&quot;)
        will be &quot;<span class="Li">1</span>&quot; for Monday,
        &quot;<span class="Li">2</span>&quot; for Tuesday and so on until
        &quot;<span class="Li">7</span>&quot; for Sunday.</p>
    <p class="Pp">The daylight savings time flag
        (&quot;<span class="Li">$dst</span>&quot;) will be
        &quot;<span class="Li">&quot;-1&quot;</span>&quot; if this information
        is not available on your system, &quot;<span class="Li">0</span>&quot;
        for no daylight savings time (i.e., winter time) and
        &quot;<span class="Li">1</span>&quot; when daylight savings time is in
        effect.</p>
    <p class="Pp">A fatal &quot;time out of range&quot; error will occur if the
        given time value is out of range
        <span class="Li">&quot;[0..(~0&gt;&gt;1)]&quot;</span>.</p>
    <p class="Pp">If the time value is omitted, the &quot;<b>time()</b>&quot;
        function is called instead, internally.</p>
  </li>
  <li><span class="Li">&quot;($year,$month,$day, $hour,$min,$sec,
      $doy,$dow,$dst) = Localtime([time]);&quot;</span>
    <p class="Pp">This is Date::Calc's equivalent of Perl's built-in
        &quot;<b>localtime()</b>&quot; function. See also &quot;localtime&quot;
        in <b>perlfunc</b>(1).</p>
    <p class="Pp">The ranges of values returned (and their meanings) are as
        follows:</p>
    <p class="Pp"></p>
    <pre>        $year   :   1970..2038 (or more)  [Unix etc.]
        $year   :   1904..2040            [MacOS Classic]
        $month  :   1..12
        $day    :   1..31
        $hour   :   0..23
        $min    :   0..59
        $sec    :   0..59
        $doy    :   1..366
        $dow    :   1..7
        $dst    :  -1..1
    </pre>
    <p class="Pp">&quot;<span class="Li">$doy</span>&quot; is the day of year,
        sometimes also referred to as the &quot;julian date&quot;, which starts
        at &quot;<span class="Li">1</span>&quot; and goes up to the number of
        days in that year.</p>
    <p class="Pp">The day of week (&quot;<span class="Li">$dow</span>&quot;)
        will be &quot;<span class="Li">1</span>&quot; for Monday,
        &quot;<span class="Li">2</span>&quot; for Tuesday and so on until
        &quot;<span class="Li">7</span>&quot; for Sunday.</p>
    <p class="Pp">The daylight savings time flag
        (&quot;<span class="Li">$dst</span>&quot;) will be
        &quot;<span class="Li">&quot;-1&quot;</span>&quot; if this information
        is not available on your system, &quot;<span class="Li">0</span>&quot;
        for no daylight savings time (i.e., winter time) and
        &quot;<span class="Li">1</span>&quot; when daylight savings time is in
        effect.</p>
    <p class="Pp">A fatal &quot;time out of range&quot; error will occur if the
        given time value is out of range
        <span class="Li">&quot;[0..(~0&gt;&gt;1)]&quot;</span>.</p>
    <p class="Pp">If the time value is omitted, the &quot;<b>time()</b>&quot;
        function is called instead, internally.</p>
  </li>
  <li><span class="Li">&quot;$time = Mktime($year,$month,$day,
      $hour,$min,$sec);&quot;</span>
    <p class="Pp">This function converts a date into a time value, i.e., into
        the number of seconds since whatever moment in time your system
        considers to be the &quot;epoch&quot;. On Unix and most other systems
        this is the number of seconds since January 1st 1970 at midnight (GMT).
        On MacOS Classic this is the number of seconds since January 1st 1904 at
        midnight (local time).</p>
    <p class="Pp">The function is similar to the
        &quot;<b>POSIX::mktime()</b>&quot; function (see &quot;mktime&quot; in
        <b>POSIX</b>(1) for more details), but in contrast to the latter, it
        expects dates in the usual ranges used throughout this module: The year
        2001 stays year 2001, and months are numbered from 1 to 12.</p>
    <p class="Pp">A fatal &quot;date out of range&quot; error will occur if the
        given date cannot be expressed in terms of seconds since the epoch (this
        happens for instance when the date lies before the epoch, or if it is
        later than 19-Jan-2038&#x00A0;03:14:07&#x00A0;GMT on 32&#x00A0;bit Unix
        systems, or later than 06-Feb-2040&#x00A0;06:28:15 (local time) on a
        Macintosh with MacOS Classic).</p>
    <p class="Pp">Just like the &quot;<b>POSIX::mktime()</b>&quot; function,
        this function uses the &quot;<b>mktime()</b>&quot; system call,
        internally.</p>
    <p class="Pp">This means that the given date and time is considered to be in
        local time, and that the value returned by this function will depend on
        your machine's local settings such as the time zone, whether daylight
        savings time is (or was, at the time) in effect, and the system clock
        itself.</p>
    <p class="Pp"><b>BEWARE</b> that &quot;<b>mktime()</b>&quot; does not always
        return the same time value as fed into &quot;<b>localtime()</b>&quot;,
        when you feed the output of &quot;<b>localtime()</b>&quot; back into
        &quot;<b>mktime()</b>&quot;, on some systems!</p>
    <p class="Pp">I.e.,
        &quot;<span class="Li">&quot;Mktime((Localtime($time))[0..5])&quot;</span>&quot;
        will not always return the same value as given in
        &quot;<span class="Li">$time</span>&quot;!</p>
  </li>
  <li><span class="Li">&quot;($D_y,$D_m,$D_d, $Dh,$Dm,$Ds, $dst) =
      Timezone([time]);&quot;</span>
    <p class="Pp">This function returns the difference between
        &quot;<span class="Li">&quot;localtime(time)&quot;</span>&quot; and
        &quot;<span class="Li">&quot;gmtime(time)&quot;</span>&quot;, which is
        the timezone offset in effect for the current location and the given
        &quot;<span class="Li">&quot;time&quot;</span>&quot;.</p>
    <p class="Pp">This offset is positive if you are located to the east of
        Greenwich, and is usually negative (except during daylight savings time,
        in some locations) if you are located to the west of Greenwich.</p>
    <p class="Pp">Note that this offset is influenced by all of the relevant
        system settings and parameters on your machine; such as locales,
        environment variables (e.g.
        &quot;<span class="Li">&quot;TZ&quot;</span>&quot;) and the system clock
        itself. See the relevant documentation on your system for more
      details.</p>
    <p class="Pp">If the &quot;<span class="Li">&quot;time&quot;</span>&quot; is
        omitted, the &quot;<span class="Li">&quot;time()&quot;</span>&quot;
        function will be called automatically, internally (similar to the
        built-in functions
        &quot;<span class="Li">&quot;localtime()&quot;</span>&quot; and
        &quot;<span class="Li">&quot;gmtime()&quot;</span>&quot; in Perl).</p>
    <p class="Pp">A fatal &quot;time out of range&quot; error will occur if the
        given time value is out of range
        <span class="Li">&quot;[0..(~0&gt;&gt;1)]&quot;</span>.</p>
    <p class="Pp">The last item of the returned list is a flag which indicates
        whether daylight savings time is currently in effect. This flag is
        negative (-1) if this information is not available on your system. It is
        zero (0) when daylight savings time is off, and positive (+1) when
        daylight savings time is on.</p>
    <p class="Pp">Thus you can check very quickly whether daylight savings time
        is currently in effect by evaluating this function in scalar context (in
        scalar context, Perl returns the last item of a list):</p>
    <p class="Pp"></p>
    <pre>  if (scalar Timezone &gt; 0) { # yes, daylight savings time
    </pre>
    <p class="Pp">However, a slightly more efficient way would be this:</p>
    <p class="Pp"></p>
    <pre>  if (scalar System_Clock &gt; 0) { # yes, daylight savings time
    </pre>
  </li>
  <li><span class="Li">&quot;$time = Date_to_Time($year,$month,$day,
      $hour,$min,$sec);&quot;</span>
    <p class="Pp">This function is a replacement for the BSD function
        &quot;<b>timegm()</b>&quot; (which is not available on all Unix
        systems), which converts a given date and time into a time value, i.e.,
        into the number of seconds since whatever moment in time your system
        considers to be the &quot;epoch&quot;. On Unix and most other systems
        this is the number of seconds since January 1st 1970 at midnight (GMT).
        On MacOS Classic this is the number of seconds since January 1st 1904 at
        midnight (local time).</p>
    <p class="Pp">Under Unix, the date and time are considered to be in UTC
        (&quot;Universal Time Coordinated&quot;, and so is the resulting time
        value.</p>
    <p class="Pp">UTC is almost the same as GMT (or &quot;Greenwich Mean
        Time&quot;), except that UTC has leap seconds (in order to account for
        small variations in the rotation of the earth, for instance), whereas
        GMT does not.</p>
    <p class="Pp">Under MacOS Classic, however, both input and output are
        considered to be in local time.</p>
    <p class="Pp">The ranges of year and month follow the same rules as
        throughout the rest of this module (and not the contorted rules of its
        Unix equivalent), i.e., the year &quot;2001&quot; stays &quot;2001&quot;
        and the month ranges from 1 to 12.</p>
    <p class="Pp">A fatal &quot;date out of range&quot; error will occur if the
        given date cannot be expressed in terms of seconds since the epoch (this
        happens for instance when the date lies before the epoch, or if it is
        later than 19-Jan-2038&#x00A0;03:14:07&#x00A0;GMT on 32&#x00A0;bit Unix
        systems, or later than 06-Feb-2040&#x00A0;06:28:15 (local time) on a
        Macintosh with MacOS Classic).</p>
    <p class="Pp">This function should be very fast, because it is implemented
        in a very straightforward manner and doesn't use any internal system
        calls.</p>
    <p class="Pp">Moreover, the functions &quot;<b>Date_to_Time()</b>&quot; and
        &quot;<b>Time_to_Date()</b>&quot; are guaranteed to be complementary,
        i.e., that
        &quot;<span class="Li">&quot;Date_to_Time(Time_to_Date($time))&quot;</span>&quot;
        and
        &quot;<span class="Li">&quot;Time_to_Date(Date_to_Time($year,$month,$day,
        $hour,$min,$sec))&quot;</span>&quot; will always return the initial
        values.</p>
  </li>
  <li><span class="Li">&quot;($year,$month,$day, $hour,$min,$sec) =
      Time_to_Date([time]);&quot;</span>
    <p class="Pp">This function is an alternative to the POSIX
        &quot;<b>gmtime()</b>&quot; function (and its built-in Perl equivalent),
        which converts a given time value into the corresponding date and time.
        The given time value must be the number of seconds since whatever moment
        in time your system considers to be the &quot;epoch&quot;. On Unix and
        most other systems this is the number of seconds since January 1st 1970
        at midnight (GMT). On MacOS Classic this is the number of seconds since
        January 1st 1904 at midnight (local time).</p>
    <p class="Pp">Under Unix, the given time value is considered to be in UTC
        (&quot;Universal Time Coordinated&quot;, and so is the resulting date
        and time.</p>
    <p class="Pp">UTC is almost the same as GMT (or &quot;Greenwich Mean
        Time&quot;), except that UTC has leap seconds (in order to account for
        small variations in the rotation of the earth, for instance), whereas
        GMT does not.</p>
    <p class="Pp">Under MacOS Classic, however, both input and output are
        considered to be in local time.</p>
    <p class="Pp">If the input value
        &quot;<span class="Li">&quot;time&quot;</span>&quot; is omitted, the
        &quot;<span class="Li">&quot;time()&quot;</span>&quot; function will be
        called automatically, internally (similar to the built-in functions
        &quot;<span class="Li">&quot;localtime()&quot;</span>&quot; and
        &quot;<span class="Li">&quot;gmtime()&quot;</span>&quot; in Perl).</p>
    <p class="Pp">A fatal &quot;time out of range&quot; error will occur if the
        given time value is negative.</p>
    <p class="Pp">This function should be very fast, because it is implemented
        in a very straightforward manner and doesn't use any internal system
        calls (except for &quot;<b>time()</b>&quot;, if the input value is
        omitted).</p>
    <p class="Pp">Moreover, the functions &quot;<b>Date_to_Time()</b>&quot; and
        &quot;<b>Time_to_Date()</b>&quot; are guaranteed to be complementary,
        i.e., that
        &quot;<span class="Li">&quot;Date_to_Time(Time_to_Date($time))&quot;</span>&quot;
        and
        &quot;<span class="Li">&quot;Time_to_Date(Date_to_Time($year,$month,$day,
        $hour,$min,$sec))&quot;</span>&quot; will always return the initial
        values.</p>
  </li>
  <li><span class="Li">&quot;($year,$month,$day) =
      Easter_Sunday($year);&quot;</span>
    <p class="Pp">This function calculates the date of Easter Sunday for all
        years in the range from 1583 to 2299 (all other year numbers will result
        in a fatal &quot;year out of range&quot; error message) using the method
        known as the &quot;Gaussian Rule&quot;.</p>
    <p class="Pp">Some related christian feast days which depend on the date of
        Easter Sunday:</p>
    <p class="Pp"></p>
    <pre>  Carnival Monday / Rosenmontag / Veille du Mardi Gras   =  -48 days
  Mardi Gras / Karnevalsdienstag / Mardi Gras            =  -47 days
  Ash Wednesday / Aschermittwoch / Mercredi des Cendres  =  -46 days
  Palm Sunday / Palmsonntag / Dimanche des Rameaux       =   -7 days
  Easter Friday / Karfreitag / Vendredi Saint            =   -2 days
  Easter Saturday / Ostersamstag / Samedi de Paques      =   -1 day
  Easter Monday / Ostermontag / Lundi de Paques          =   +1 day
  Ascension of Christ / Christi Himmelfahrt / Ascension  =  +39 days
  Whitsunday / Pfingstsonntag / Dimanche de Pentecote    =  +49 days
  Whitmonday / Pfingstmontag / Lundi de Pentecote        =  +50 days
  Feast of Corpus Christi / Fronleichnam / Fete-Dieu     =  +60 days
    </pre>
    <p class="Pp">Use the offsets shown above to calculate the date of the
        corresponding feast day as follows:</p>
    <p class="Pp"></p>
    <pre>  ($year,$month,$day) = Add_Delta_Days(Easter_Sunday($year), $offset));
    </pre>
  </li>
  <li><span class="Li">&quot;if ($month =
      Decode_Month($string[,$lang]))&quot;</span>
    <p class="Pp">This function takes a string as its argument, which should
        contain the name of a month in the given or currently selected language
        (see further below for details about the multi-language support of this
        package), or any uniquely identifying abbreviation of a month's name
        (i.e., the first few letters), and returns the corresponding number
        (1..12) upon a successful match, or
        &quot;<span class="Li">0</span>&quot; otherwise (therefore, the return
        value can also be used as the conditional expression in an
        &quot;if&quot; statement).</p>
    <p class="Pp">Note that the input string may not contain any other
        characters which do not pertain to the month's name, especially no
        leading or trailing whitespace.</p>
    <p class="Pp">Note also that matching is performed in a case-insensitive
        manner (this may depend on the &quot;locale&quot; setting on your
        current system, though!)</p>
    <p class="Pp">With &quot;1&quot; (&quot;English&quot;) as the given
        language, the following examples will all return the value
        &quot;<span class="Li">9</span>&quot;:</p>
    <p class="Pp"></p>
    <pre>  $month = Decode_Month(&quot;s&quot;,1);
  $month = Decode_Month(&quot;Sep&quot;,1);
  $month = Decode_Month(&quot;septemb&quot;,1);
  $month = Decode_Month(&quot;September&quot;,1);
    </pre>
  </li>
  <li><span class="Li">&quot;if ($dow =
      Decode_Day_of_Week($string[,$lang]))&quot;</span>
    <p class="Pp">This function takes a string as its argument, which should
        contain the name of a day of week in the given or currently selected
        language (see further below for details about the multi-language support
        of this package), or any uniquely identifying abbreviation of the name
        of a day of week (i.e., the first few letters), and returns the
        corresponding number (1..7) upon a successful match, or
        &quot;<span class="Li">0</span>&quot; otherwise (therefore, the return
        value can also be used as the conditional expression in an
        &quot;if&quot; statement).</p>
    <p class="Pp">Note that the input string may not contain any other
        characters which do not pertain to the name of the day of week,
        especially no leading or trailing whitespace.</p>
    <p class="Pp">Note also that matching is performed in a case-insensitive
        manner (this may depend on the &quot;locale&quot; setting on your
        current system, though!)</p>
    <p class="Pp">With &quot;1&quot; (&quot;English&quot;) as the given
        language, the following examples will all return the value
        &quot;<span class="Li">3</span>&quot;:</p>
    <p class="Pp"></p>
    <pre>  $dow = Decode_Day_of_Week(&quot;w&quot;,1);
  $dow = Decode_Day_of_Week(&quot;Wed&quot;,1);
  $dow = Decode_Day_of_Week(&quot;wednes&quot;,1);
  $dow = Decode_Day_of_Week(&quot;Wednesday&quot;,1);
    </pre>
  </li>
  <li><span class="Li">&quot;if ($lang = Decode_Language($string))&quot;</span>
    <p class="Pp">This function takes a string as its argument, which should
        contain the name of one of the languages supported by this package
        (<b>IN THIS VERY</b> <b>LANGUAGE ITSELF</b>), or any uniquely
        identifying abbreviation of the name of a language (i.e., the first few
        letters), and returns its corresponding internal number (1..14 in the
        original distribution) upon a successful match, or
        &quot;<span class="Li">0</span>&quot; otherwise (therefore, the return
        value can also be used as the conditional expression in an
        &quot;if&quot; statement).</p>
    <p class="Pp">Note that the input string may not contain any other
        characters which do not pertain to the name of a language, especially no
        leading or trailing whitespace.</p>
    <p class="Pp">Note also that matching is performed in a case-insensitive
        manner (this may depend on the &quot;locale&quot; setting on your
        current system, though!)</p>
    <p class="Pp">The original distribution supports the following fourteen
        languages:</p>
    <p class="Pp"></p>
    <pre>            English                    ==&gt;    1    (default)
            Fran&#x00E7;ais    (French)       ==&gt;    2
            Deutsch     (German)       ==&gt;    3
            Espa&#x00F1;ol     (Spanish)      ==&gt;    4
            Portugu&#x00EA;s   (Portuguese)   ==&gt;    5
            Nederlands  (Dutch)        ==&gt;    6
            Italiano    (Italian)      ==&gt;    7
            Norsk       (Norwegian)    ==&gt;    8
            Svenska     (Swedish)      ==&gt;    9
            Dansk       (Danish)       ==&gt;   10
            suomi       (Finnish)      ==&gt;   11
            Magyar      (Hungarian)    ==&gt;   12
            polski      (Polish)       ==&gt;   13
            Romaneste   (Romanian)     ==&gt;   14
    </pre>
    <p class="Pp">See the section &quot;How to install additional
        languages&quot; in the file &quot;INSTALL.txt&quot; in this distribution
        for how to add more languages to this package.</p>
    <p class="Pp">In the original distribution (no other languages installed),
        the following examples will all return the value
        &quot;<span class="Li">3</span>&quot;:</p>
    <p class="Pp"></p>
    <pre>  $lang = Decode_Language(&quot;d&quot;);
  $lang = Decode_Language(&quot;de&quot;);
  $lang = Decode_Language(&quot;Deutsch&quot;);
    </pre>
    <p class="Pp">Note that you may not be able to enter the special
        international characters in some of the languages' names over the
        keyboard directly on some systems.</p>
    <p class="Pp">This should never be a problem, though; just enter an
        abbreviation of the name of the language consisting of the first few
        letters up to the character before the first special international
        character.</p>
  </li>
  <li><span class="Li">&quot;if (($year,$month,$day) =
      Decode_Date_EU($string[,$lang]))&quot;</span>
    <p class="Pp">This function scans a given string and tries to parse any date
        which might be embedded in it.</p>
    <p class="Pp">The function returns an empty list if it can't successfully
        extract a valid date from its input string, or else it returns the date
        found.</p>
    <p class="Pp">The function accepts almost any format, as long as the date is
        given in the european order (hence its name) day-month-year.</p>
    <p class="Pp">Thereby, zero or more <b>NON-NUMERIC</b> characters may
        <b>PRECEDE</b> the day and <b>FOLLOW</b> the year.</p>
    <p class="Pp">Moreover, zero or more <b>NON-ALPHANUMERIC</b> characters are
        permitted <b>BETWEEN</b> these three items (i.e., between day and month
        and between month and year).</p>
    <p class="Pp">The month may be given either numerically (i.e., a number from
        &quot;<span class="Li">1</span>&quot; to
        &quot;<span class="Li">12</span>&quot;), or alphanumerically, i.e., as
        the name of the month in the given or currently selected language, or
        any uniquely identifying abbreviation thereof.</p>
    <p class="Pp">(See further below for details about the multi-language
        support of this package!)</p>
    <p class="Pp">If the year is given as one or two digits only (i.e., if the
        year is less than 100), it is mapped to a &quot;window&quot; of +/- 50
        years around the current year, as described by the
        &quot;<b>Moving_Window()</b>&quot; function (see further below).</p>
    <p class="Pp">If the day, month and year are all given numerically but
        <b>WITHOUT</b> any delimiting characters between them, this string of
        digits will be mapped to the day, month and year as follows:</p>
    <p class="Pp"></p>
    <pre>                Length:        Mapping:
                  3              dmy
                  4              dmyy
                  5              dmmyy
                  6              ddmmyy
                  7              dmmyyyy
                  8              ddmmyyyy
    </pre>
    <p class="Pp">(Where &quot;d&quot; stands for &quot;day&quot;, &quot;m&quot;
        stands for &quot;month&quot; and &quot;y&quot; stands for
        &quot;year&quot;.)</p>
    <p class="Pp">All other strings consisting purely of digits (without any
        intervening delimiters) are rejected, i.e., not recognized.</p>
    <p class="Pp">Examples:</p>
    <p class="Pp"></p>
    <pre>  &quot;3.1.64&quot;
  &quot;3 1 64&quot;
  &quot;03.01.64&quot;
  &quot;03/01/64&quot;
  &quot;3. Jan 1964&quot;
  &quot;Birthday: 3. Jan '64 in Backnang/Germany&quot;
  &quot;03-Jan-64&quot;
  &quot;3.Jan1964&quot;
  &quot;3Jan64&quot;
  &quot;030164&quot;
  &quot;3ja64&quot;
  &quot;3164&quot;
    </pre>
    <p class="Pp">Experiment! (See the corresponding example applications in the
        &quot;examples&quot; subdirectory of this distribution in order to do
        so.)</p>
  </li>
  <li><span class="Li">&quot;if (($year,$month,$day) =
      Decode_Date_US($string[,$lang]))&quot;</span>
    <p class="Pp">This function scans a given string and tries to parse any date
        which might be embedded in it.</p>
    <p class="Pp">The function returns an empty list if it can't successfully
        extract a valid date from its input string, or else it returns the date
        found.</p>
    <p class="Pp">The function accepts almost any format, as long as the date is
        given in the U.S. american order (hence its name) month-day-year.</p>
    <p class="Pp">Thereby, zero or more <b>NON-ALPHANUMERIC</b> characters may
        <b>PRECEDE</b> and <b>FOLLOW</b> the month (i.e., precede the month and
        separate it from the day which follows behind).</p>
    <p class="Pp">Moreover, zero or more <b>NON-NUMERIC</b> characters are
        permitted <b>BETWEEN</b> the day and the year, as well as <b>AFTER</b>
        the year.</p>
    <p class="Pp">The month may be given either numerically (i.e., a number from
        &quot;<span class="Li">1</span>&quot; to
        &quot;<span class="Li">12</span>&quot;), or alphanumerically, i.e., as
        the name of the month in the given or currently selected language, or
        any uniquely identifying abbreviation thereof.</p>
    <p class="Pp">(See further below for details about the multi-language
        support of this package!)</p>
    <p class="Pp">If the year is given as one or two digits only (i.e., if the
        year is less than 100), it is mapped to a &quot;window&quot; of +/- 50
        years around the current year, as described by the
        &quot;<b>Moving_Window()</b>&quot; function (see further below).</p>
    <p class="Pp">If the month, day and year are all given numerically but
        <b>WITHOUT</b> any delimiting characters between them, this string of
        digits will be mapped to the month, day and year as follows:</p>
    <p class="Pp"></p>
    <pre>                Length:        Mapping:
                  3              mdy
                  4              mdyy
                  5              mddyy
                  6              mmddyy
                  7              mddyyyy
                  8              mmddyyyy
    </pre>
    <p class="Pp">(Where &quot;m&quot; stands for &quot;month&quot;,
        &quot;d&quot; stands for &quot;day&quot; and &quot;y&quot; stands for
        &quot;year&quot;.)</p>
    <p class="Pp">All other strings consisting purely of digits (without any
        intervening delimiters) are rejected, i.e., not recognized.</p>
    <p class="Pp">If only the day and the year form a contiguous string of
        digits, they will be mapped as follows:</p>
    <p class="Pp"></p>
    <pre>                Length:        Mapping:
                  2              dy
                  3              dyy
                  4              ddyy
                  5              dyyyy
                  6              ddyyyy
    </pre>
    <p class="Pp">(Where &quot;d&quot; stands for &quot;day&quot; and
        &quot;y&quot; stands for &quot;year&quot;.)</p>
    <p class="Pp">Examples:</p>
    <p class="Pp"></p>
    <pre>  &quot;1 3 64&quot;
  &quot;01/03/64&quot;
  &quot;Jan 3 '64&quot;
  &quot;Jan 3 1964&quot;
  &quot;===&gt; January 3rd 1964 (birthday)&quot;
  &quot;Jan31964&quot;
  &quot;Jan364&quot;
  &quot;ja364&quot;
  &quot;1364&quot;
    </pre>
    <p class="Pp">Experiment! (See the corresponding example applications in the
        &quot;examples&quot; subdirectory of this distribution in order to do
        so.)</p>
  </li>
  <li><span class="Li">&quot;$year = Fixed_Window($yy);&quot;</span>
    <p class="Pp">This function applies a &quot;fixed window&quot; strategy to
        two-digit year numbers in order to convert them into four-digit year
        numbers.</p>
    <p class="Pp">All other year numbers are passed through unchanged, except
        for negative year numbers, which cause the function to return zero
        (&quot;<span class="Li">0</span>&quot;) instead.</p>
    <p class="Pp">Two-digit year numbers
        &quot;<span class="Li">&quot;yy&quot;</span>&quot; below 70 are
        converted to &quot;<span class="Li">&quot;20yy&quot;</span>&quot;,
        whereas year numbers equal to or greater than 70 (but less than 100) are
        converted to &quot;<span class="Li">&quot;19yy&quot;</span>&quot;.</p>
    <p class="Pp">In the original distribution of this package, the base century
        is set to &quot;1900&quot; and the base year to &quot;70&quot; (which is
        a standard on UNIX systems), but these constants (also called the
        &quot;epoch&quot;) can actually be chosen at will (in the files
        &quot;DateCalc.c&quot; and &quot;DateCalc.h&quot;) at compile time of
        this module.</p>
  </li>
  <li><span class="Li">&quot;$year = Moving_Window($yy);&quot;</span>
    <p class="Pp">This function applies a &quot;moving window&quot; strategy to
        two-digit year numbers in order to convert them into four-digit year
        numbers, provided the necessary system calls (system clock) are
        available. Otherwise the function falls back to the &quot;fixed
        window&quot; strategy described in the function above.</p>
    <p class="Pp">All other year numbers are passed through unchanged, except
        for negative year numbers, which cause the function to return zero
        (&quot;<span class="Li">0</span>&quot;) instead.</p>
    <p class="Pp">Two-digit year numbers are mapped according to a
        &quot;window&quot; of 50 years in both directions (past and future)
        around the current year.</p>
    <p class="Pp">That is, two-digit year numbers are first mapped to the same
        century as the current year. If the resulting year is smaller than the
        current year minus 50, then one more century is added to the result. If
        the resulting year is equal to or greater than the current year plus 50,
        then a century is subtracted from the result.</p>
  </li>
  <li><span class="Li">&quot;$date = Compress($year,$month,$day);&quot;</span>
    <p class="Pp">WARNING: This function is legacy code, its use is
      deprecated!</p>
    <p class="Pp">This function encodes a date in 16 bits, which is the value
        being returned.</p>
    <p class="Pp">The encoding scheme is as follows:</p>
    <p class="Pp"></p>
    <pre>            Bit number:    FEDCBA9 8765 43210
            Contents:      yyyyyyy mmmm ddddd
    </pre>
    <p class="Pp">(Where the &quot;yyyyyyy&quot; contain the number of the year,
        &quot;mmmm&quot; the number of the month and &quot;ddddd&quot; the
        number of the day.)</p>
    <p class="Pp">The function returns &quot;<span class="Li">0</span>&quot; if
        the given input values do not represent a valid date. Therefore, the
        return value of this function can also be used as the conditional
        expression in an &quot;if&quot; statement, in order to check whether the
        given input values constitute a valid date).</p>
    <p class="Pp">Through this special encoding scheme, it is possible to
        <b>COMPARE</b> compressed dates for equality and order (less
        than/greater than) <b>WITHOUT</b> any previous <b>DECODING</b>!</p>
    <p class="Pp">Note however that contiguous dates do <b>NOT</b> necessarily
        have contiguous compressed representations!</p>
    <p class="Pp">I.e., incrementing the compressed representation of a date
        <b>MAY OR MAY NOT</b> yield a valid new date!</p>
    <p class="Pp">Note also that this function can only handle dates within one
        century.</p>
    <p class="Pp">This century can be chosen at will (at compile time of this
        module) by defining a base century and year (also called the
        &quot;epoch&quot;). In the original distribution of this package, the
        base century is set to &quot;1900&quot; and the base year to
        &quot;70&quot; (which is standard on UNIX systems).</p>
    <p class="Pp">This allows this function to handle dates from
        &quot;1970&quot; up to &quot;2069&quot;.</p>
    <p class="Pp">If the given year is equal to, say, &quot;95&quot;, this
        package will automatically assume that you really meant &quot;1995&quot;
        instead. However, if you specify a year number which is <b>SMALLER</b>
        than 70, like &quot;64&quot;, for instance, this package will assume
        that you really meant &quot;2064&quot;.</p>
    <p class="Pp">You are not confined to two-digit (abbreviated) year numbers,
        though.</p>
    <p class="Pp">The function also accepts &quot;full-length&quot; year
        numbers, provided that they lie in the supported range (i.e., from
        &quot;1970&quot; to &quot;2069&quot;, in the original configuration of
        this package).</p>
    <p class="Pp">Note that this function is maintained mainly for backward
        compatibility, and that its use is not recommended.</p>
  </li>
  <li><span class="Li">&quot;if (($century,$year,$month,$day) =
      Uncompress($date))&quot;</span>
    <p class="Pp">WARNING: This function is legacy code, its use is
      deprecated!</p>
    <p class="Pp">This function decodes dates that were encoded previously using
        the function
      &quot;<span class="Li">&quot;Compress()&quot;</span>&quot;.</p>
    <p class="Pp">It returns the century, year, month and day of the date
        encoded in &quot;<span class="Li">$date</span>&quot; if
        &quot;<span class="Li">$date</span>&quot; represents a valid date, or an
        empty list otherwise.</p>
    <p class="Pp">The year returned in &quot;<span class="Li">$year</span>&quot;
        is actually a two-digit year number (i.e., the year number taken modulo
        100), and only the expression &quot;<span class="Li">&quot;$century +
        $year&quot;</span>&quot; yields the &quot;full-length&quot; year number
        (for example, <span class="Li">&quot;1900 + 95 = 1995&quot;</span>).</p>
    <p class="Pp">Note that this function is maintained mainly for backward
        compatibility, and that its use is not recommended.</p>
  </li>
  <li><span class="Li">&quot;if (check_compressed($date))&quot;</span>
    <p class="Pp">WARNING: This function is legacy code, its use is
      deprecated!</p>
    <p class="Pp">This function returns &quot;true&quot;
        (&quot;<span class="Li">1</span>&quot;) if the given input value
        constitutes a valid compressed date, and &quot;false&quot;
        (&quot;<span class="Li">0</span>&quot;) otherwise.</p>
    <p class="Pp">Note that this function is maintained mainly for backward
        compatibility, and that its use is not recommended.</p>
  </li>
  <li><span class="Li">&quot;$string =
      Compressed_to_Text($date[,$lang]);&quot;</span>
    <p class="Pp">WARNING: This function is legacy code, its use is
      deprecated!</p>
    <p class="Pp">This function returns a string of fixed length (always 9
        characters long) containing a textual representation of the compressed
        date encoded in &quot;<span class="Li">$date</span>&quot;.</p>
    <p class="Pp">This string has the form &quot;dd-Mmm-yy&quot;, where
        &quot;dd&quot; is the two-digit number of the day, &quot;Mmm&quot; are
        the first three letters of the name of the month in the given or
        currently selected language (see further below for details about the
        multi-language support of this package), and &quot;yy&quot; is the
        two-digit year number (i.e., the year number taken modulo 100).</p>
    <p class="Pp">If &quot;<span class="Li">$date</span>&quot; does not
        represent a valid date, the string &quot;??-???-??&quot; is returned
        instead.</p>
    <p class="Pp">Note that this function is maintained mainly for backward
        compatibility, and that its use is not recommended.</p>
  </li>
  <li><span class="Li">&quot;$string =
      Date_to_Text($year,$month,$day[,$lang]);&quot;</span>
    <p class="Pp">This function returns a string containing a textual
        representation of the given date of the form &quot;www
        dd-Mmm-yyyy&quot;, where &quot;www&quot; are the first three letters of
        the name of the day of week in the given or currently selected language,
        or a special abbreviation, if special abbreviations have been defined
        for the given or currently selected language (see further below for
        details about the multi-language support of this package),
        &quot;dd&quot; is the day (one or two digits), &quot;Mmm&quot; are the
        first three letters of the name of the month in the given or currently
        selected language, and &quot;yyyy&quot; is the number of the year in
        full length.</p>
    <p class="Pp">If the given input values do not constitute a valid date, a
        fatal &quot;not a valid date&quot; error occurs.</p>
    <p class="Pp">(See the section &quot;RECIPES&quot; near the end of this
        document for a code snippet for how to print dates in any format you
        like.)</p>
  </li>
  <li><span class="Li">&quot;$string =
      Date_to_Text_Long($year,$month,$day[,$lang]);&quot;</span>
    <p class="Pp">This function returns a string containing a textual
        representation of the given date roughly of the form &quot;Wwwwww, dd
        Mmmmmm yyyy&quot;, where &quot;Wwwwww&quot; is the name of the day of
        week in the given or currently selected language (see further below for
        details about the multi-language support of this package),
        &quot;dd&quot; is the day (one or two digits), &quot;Mmmmmm&quot; is the
        name of the month in the given or currently selected language, and
        &quot;yyyy&quot; is the number of the year in full length.</p>
    <p class="Pp">The exact format of the output string depends on the given or
        currently selected language. In the original distribution of this
        package, these formats are defined as follows:</p>
    <p class="Pp"></p>
    <pre>  1  English    :  &quot;Wwwwww, Mmmmmm ddth yyyy&quot;
  2  French     :  &quot;Wwwwww dd mmmmmm yyyy&quot;
  3  German     :  &quot;Wwwwww, den dd. Mmmmmm yyyy&quot;
  4  Spanish    :  &quot;Wwwwww, dd de mmmmmm de yyyy&quot;
  5  Portuguese :  &quot;Wwwwww, dia dd de mmmmmm de yyyy&quot;
  6  Dutch      :  &quot;Wwwwww, dd mmmmmm yyyy&quot;
  7  Italian    :  &quot;Wwwwww, dd Mmmmmm yyyy&quot;
  8  Norwegian  :  &quot;wwwwww, dd. mmmmmm yyyy&quot;
  9  Swedish    :  &quot;wwwwww, dd mmmmmm yyyy&quot;
 10  Danish     :  &quot;wwwwww, dd. mmmmmm yyyy&quot;
 11  Finnish    :  &quot;wwwwww, dd. mmmmmmta yyyy&quot;
 12  Hungarian  :  &quot;dd. Mmmmmm yyyy., wwwwww&quot;
 13  Polish     :  &quot;Wwwwww, dd Mmmmmm yyyy&quot;
 14  Romanian   :  &quot;Wwwwww dd Mmmmmm yyyy&quot;
    </pre>
    <p class="Pp">(You can change these formats in the file
        &quot;DateCalc.c&quot; before building this module in order to suit your
        personal preferences.)</p>
    <p class="Pp">If the given input values do not constitute a valid date, a
        fatal &quot;not a valid date&quot; error occurs.</p>
    <p class="Pp">In order to capitalize the day of week at the beginning of the
        string in Norwegian, use
        &quot;<span class="Li">&quot;ucfirst(Date_to_Text_Long($year,$month,$day,8));&quot;</span>&quot;.</p>
    <p class="Pp">(See the section &quot;RECIPES&quot; near the end of this
        document for an example on how to print dates in any format you
      like.)</p>
  </li>
  <li><span class="Li">&quot;$string = English_Ordinal($number);&quot;</span>
    <p class="Pp">This function returns a string containing the (english)
        abbreviation of the ordinal number for the given (cardinal) number
        &quot;<span class="Li">$number</span>&quot;.</p>
    <p class="Pp">I.e.,</p>
    <p class="Pp"></p>
    <pre>    0  =&gt;  '0th'    10  =&gt;  '10th'    20  =&gt;  '20th'
    1  =&gt;  '1st'    11  =&gt;  '11th'    21  =&gt;  '21st'
    2  =&gt;  '2nd'    12  =&gt;  '12th'    22  =&gt;  '22nd'
    3  =&gt;  '3rd'    13  =&gt;  '13th'    23  =&gt;  '23rd'
    4  =&gt;  '4th'    14  =&gt;  '14th'    24  =&gt;  '24th'
    5  =&gt;  '5th'    15  =&gt;  '15th'    25  =&gt;  '25th'
    6  =&gt;  '6th'    16  =&gt;  '16th'    26  =&gt;  '26th'
    7  =&gt;  '7th'    17  =&gt;  '17th'    27  =&gt;  '27th'
    8  =&gt;  '8th'    18  =&gt;  '18th'    28  =&gt;  '28th'
    9  =&gt;  '9th'    19  =&gt;  '19th'    29  =&gt;  '29th'
    </pre>
    <p class="Pp">etc.</p>
  </li>
  <li><span class="Li">&quot;$string =
      Calendar($year,$month[,$orthodox[,$lang]]);&quot;</span>
    <p class="Pp">This function returns a calendar of the given month in the
        given year (somewhat similar to the UNIX
        &quot;<span class="Li">&quot;cal&quot;</span>&quot; command), in the
        given or currently selected language (see further below for details
        about the multi-language support of this package).</p>
    <p class="Pp">Example:</p>
    <p class="Pp"></p>
    <pre>  print Calendar(1998,5);
    </pre>
    <p class="Pp">This will print:</p>
    <p class="Pp"></p>
    <pre>           May 1998
  Mon Tue Wed Thu Fri Sat Sun
                    1   2   3
    4   5   6   7   8   9  10
   11  12  13  14  15  16  17
   18  19  20  21  22  23  24
   25  26  27  28  29  30  31
    </pre>
    <p class="Pp">If the optional boolean parameter
        &quot;<span class="Li">$orthodox</span>&quot; is given and true, the
        calendar starts on Sunday instead of Monday.</p>
  </li>
  <li><span class="Li">&quot;$string =
      Month_to_Text($month[,$lang]);&quot;</span>
    <p class="Pp">This function returns the name of the given month in the given
        or currently selected language (see further below for details about the
        multi-language support of this package).</p>
    <p class="Pp">If the given month lies outside of the valid range from
        &quot;<span class="Li">1</span>&quot; to
        &quot;<span class="Li">12</span>&quot;, a fatal &quot;month out of
        range&quot; error will occur.</p>
  </li>
  <li><span class="Li">&quot;$string =
      Day_of_Week_to_Text($dow[,$lang]);&quot;</span>
    <p class="Pp">This function returns the name of the given day of week in the
        given or currently selected language (see further below for details
        about the multi-language support of this package).</p>
    <p class="Pp">If the given day of week lies outside of the valid range from
        &quot;<span class="Li">1</span>&quot; to
        &quot;<span class="Li">7</span>&quot;, a fatal &quot;day of week out of
        range&quot; error will occur.</p>
  </li>
  <li><span class="Li">&quot;$string =
      Day_of_Week_Abbreviation($dow[,$lang]);&quot;</span>
    <p class="Pp">This function returns the special abbreviation of the name of
        the given day of week, <b>IF</b> such special abbreviations have been
        defined for the given or currently selected language (see further below
        for details about the multi-language support of this package).</p>
    <p class="Pp">(In the original distribution of this package, this was only
        true for Portuguese. Starting with version 5.1, abbreviations for Polish
        have also been introduced. Starting with version 5.7, the abbreviations
        for Portuguese have been disabled. So Polish is currently the only
        language to define such special abbreviations.)</p>
    <p class="Pp">If not, the first three letters of the name of the day of week
        in the given or currently selected language are returned instead.</p>
    <p class="Pp">If the given day of week lies outside of the valid range from
        &quot;<span class="Li">1</span>&quot; to
        &quot;<span class="Li">7</span>&quot;, a fatal &quot;day of week out of
        range&quot; error will occur.</p>
    <p class="Pp">Currently, this table of special abbreviations is only used by
        the functions
        &quot;<span class="Li">&quot;Date_to_Text()&quot;</span>&quot; and
        &quot;<span class="Li">&quot;Calendar()&quot;</span>&quot;,
      internally.</p>
  </li>
  <li><span class="Li">&quot;$string = Language_to_Text($lang);&quot;</span>
    <p class="Pp">This function returns the name of any language supported by
        this package when the internal number representing that language is
        given as input.</p>
    <p class="Pp">The original distribution supports the following fourteen
        languages:</p>
    <p class="Pp"></p>
    <pre>            1   ==&gt;   English                     (default)
            2   ==&gt;   Fran&#x00E7;ais    (French)
            3   ==&gt;   Deutsch     (German)
            4   ==&gt;   Espa&#x00F1;ol     (Spanish)
            5   ==&gt;   Portugu&#x00EA;s   (Portuguese)
            6   ==&gt;   Nederlands  (Dutch)
            7   ==&gt;   Italiano    (Italian)
            8   ==&gt;   Norsk       (Norwegian)
            9   ==&gt;   Svenska     (Swedish)
           10   ==&gt;   Dansk       (Danish)
           11   ==&gt;   suomi       (Finnish)
           12   ==&gt;   Magyar      (Hungarian)
           13   ==&gt;   polski      (Polish)
           14   ==&gt;   Romaneste   (Romanian)
    </pre>
    <p class="Pp">See the section &quot;How to install additional
        languages&quot; in the file &quot;INSTALL.txt&quot; in this distribution
        for how to add more languages to this package.</p>
    <p class="Pp">See the description of the function
        &quot;<span class="Li">&quot;Languages()&quot;</span>&quot; further
        below to determine how many languages are actually available in a given
        installation of this package.</p>
  </li>
  <li><span class="Li">&quot;$lang = Language();&quot;</span></li>
  <li><span class="Li">&quot;Language($lang); # DEPRECATED&quot;</span></li>
  <li><span class="Li">&quot;$oldlang = Language($newlang); #
      DEPRECATED&quot;</span>
    <p class="Pp">This function can be used to determine which language is
        currently selected, and to change the selected language (this latter use
        is deprecated, because this global setting may cause conflicts between
        threads or modules running concurrently).</p>
    <p class="Pp">Thereby, each language has a unique internal number.</p>
    <p class="Pp">The original distribution contains the following fourteen
        languages:</p>
    <p class="Pp"></p>
    <pre>            1   ==&gt;   English                     (default)
            2   ==&gt;   Fran&#x00E7;ais    (French)
            3   ==&gt;   Deutsch     (German)
            4   ==&gt;   Espa&#x00F1;ol     (Spanish)
            5   ==&gt;   Portugu&#x00EA;s   (Portuguese)
            6   ==&gt;   Nederlands  (Dutch)
            7   ==&gt;   Italiano    (Italian)
            8   ==&gt;   Norsk       (Norwegian)
            9   ==&gt;   Svenska     (Swedish)
           10   ==&gt;   Dansk       (Danish)
           11   ==&gt;   suomi       (Finnish)
           12   ==&gt;   Magyar      (Hungarian)
           13   ==&gt;   polski      (Polish)
           14   ==&gt;   Romaneste   (Romanian)
    </pre>
    <p class="Pp">See the section &quot;How to install additional
        languages&quot; in the file &quot;INSTALL.txt&quot; in this distribution
        for how to add more languages to this package.</p>
    <p class="Pp">See the description of the function
        &quot;<span class="Li">&quot;Languages()&quot;</span>&quot; further
        below to determine how many languages are actually available in a given
        installation of this package.</p>
    <p class="Pp"><b>BEWARE</b> that in order for your programs to be portable,
        you should <b>NEVER</b> actually use the internal number of a language
        in this package <b>EXPLICITLY</b>, because the same number could mean
        different languages on different systems, depending on what languages
        have been added to any given installation of this package.</p>
    <p class="Pp">Therefore, you should always use a statement such as</p>
    <p class="Pp"></p>
    <pre>  Language(Decode_Language(&quot;Name_of_Language&quot;)); # DEPRECATED
    </pre>
    <p class="Pp">or</p>
    <p class="Pp"></p>
    <pre>  DateCalc_Function(@parameters,Decode_Language(&quot;Name_of_Language&quot;)); # RECOMMENDED
    </pre>
    <p class="Pp">to select the desired language, and</p>
    <p class="Pp"></p>
    <pre>  $language = Language_to_Text(Language());
    </pre>
    <p class="Pp">or</p>
    <p class="Pp"></p>
    <pre>  $old_language = Language_to_Text(Language(&quot;Name_of_new_Language&quot;)); # DEPRECATED
    </pre>
    <p class="Pp">to determine the (previously) selected language.</p>
    <p class="Pp">If the so chosen language is not available in the current
        installation, this will result in an appropriate error message, instead
        of silently using the wrong (a random) language (which just happens to
        have the same internal number in the other installation).</p>
    <p class="Pp"><b>BEWARE</b> that when using the function
        &quot;<span class="Li">&quot;Language()&quot;</span>&quot;, the selected
        language is a global setting, shared by all threads or modules you might
        be running concurrently, thus possibly causing conflicts between
      them.</p>
    <p class="Pp">In order to avoid these conflicts, you should <b>NEVER</b> use
        the function &quot;<span class="Li">&quot;Language()&quot;</span>&quot;,
        but should <b>ALWAYS</b> pass a language number (as returned by the
        function
        &quot;<span class="Li">&quot;Decode_Language()&quot;</span>&quot;) to
        the functions which are language-dependent, which are:</p>
    <p class="Pp">&quot;<b>Decode_Month()</b>&quot;,
        &quot;<b>Decode_Day_of_Week()</b>&quot;,
        &quot;<b>Compressed_to_Text()</b>&quot;,
        &quot;<b>Date_to_Text()</b>&quot;,
        &quot;<b>Date_to_Text_Long()</b>&quot;, &quot;<b>Calendar()</b>&quot;,
        &quot;<b>Month_to_Text()</b>&quot;,
        &quot;<b>Day_of_Week_to_Text()</b>&quot;,
        &quot;<b>Day_of_Week_Abbreviation()</b>&quot;,
        &quot;<b>Decode_Date_EU()</b>&quot;,
        &quot;<b>Decode_Date_US()</b>&quot;,
        &quot;<b>Decode_Date_EU2()</b>&quot;,
        &quot;<b>Decode_Date_US2()</b>&quot;,
      &quot;<b>Parse_Date()</b>&quot;.</p>
    <p class="Pp">Note that when you pass an invalid number, such as e.g. zero,
        or no language parameter at all, these functions will revert to their
        behaviour in the versions of this module prior to 6.0, which means that
        the global setting (as set by
        &quot;<span class="Li">&quot;Language()&quot;</span>&quot;) becomes
        active again (only in case of an invalid or missing language
        parameter!).</p>
    <p class="Pp">In the C library &quot;DateCalc.c&quot;, where omitting a
        parameter is not an option, passing a zero for the language is therefore
        the recommended way to guarantee backward compatibility.</p>
  </li>
  <li><span class="Li">&quot;$max_lang = Languages();&quot;</span>
    <p class="Pp">This function returns the (maximum) number of languages which
        are currently available in your installation of this package.</p>
    <p class="Pp">(This may vary from installation to installation.)</p>
    <p class="Pp">See the section &quot;How to install additional
        languages&quot; in the file &quot;INSTALL.txt&quot; in this distribution
        for how to add more languages to this package.</p>
    <p class="Pp">In the original distribution of this package there are
        fourteen built-in languages, therefore the value returned by this
        function will be &quot;<span class="Li">14</span>&quot; if no other
        languages have been added to your particular installation.</p>
  </li>
  <li><span class="Li">&quot;if (($year,$month,$day) =
      Decode_Date_EU2($string[,$lang))&quot;</span>
    <p class="Pp">This function is the Perl equivalent of the function
        &quot;<span class="Li">&quot;Decode_Date_EU()&quot;</span>&quot;
        (implemented in C), included here merely as an example to demonstrate
        how easy it is to write your own routine in Perl (using regular
        expressions) adapted to your own special needs, should the necessity
        arise, and intended primarily as a basis for your own development.</p>
    <p class="Pp">In one particular case this Perl version is actually slightly
        more permissive than its C equivalent, as far as the class of permitted
        intervening (i.e., delimiting) characters is concerned.</p>
    <p class="Pp">(Can you tell the subtle, almost insignificant difference by
        looking at the code? Or by experimenting? Hint: Try the string
        &quot;a3b1c64d&quot; with both functions.)</p>
  </li>
  <li><span class="Li">&quot;if (($year,$month,$day) =
      Decode_Date_US2($string[,$lang))&quot;</span>
    <p class="Pp">This function is the Perl equivalent of the function
        &quot;<span class="Li">&quot;Decode_Date_US()&quot;</span>&quot;
        (implemented in C), included here merely as an example to demonstrate
        how easy it is to write your own routine in Perl (using regular
        expressions) adapted to your own special needs, should the necessity
        arise, and intended primarily as a basis for your own development.</p>
    <p class="Pp">In one particular case this Perl version is actually slightly
        more permissive than its C equivalent.</p>
    <p class="Pp">(Hint: This is the same difference as with the
        &quot;<span class="Li">&quot;Decode_Date_EU()&quot;</span>&quot; and
        &quot;<span class="Li">&quot;Decode_Date_EU2()&quot;</span>&quot; pair
        of functions.)</p>
    <p class="Pp">In a different case, the C version is a little bit more
        permissive than its Perl equivalent.</p>
    <p class="Pp">(Can you tell the difference by looking at the code? Or by
        experimenting? Hint: Try the string &quot;(1/364)&quot; with both
        functions.)</p>
  </li>
  <li><span class="Li">&quot;if (($year,$month,$day) =
      Parse_Date($string[,$lang))&quot;</span>
    <p class="Pp">This function is useful for parsing dates as returned by the
        UNIX &quot;<span class="Li">&quot;date&quot;</span>&quot; command or as
        found in the headers of e-mail (in order to determine the date at which
        some e-mail has been sent or received, for instance).</p>
    <p class="Pp">Example #1:</p>
    <p class="Pp"></p>
    <pre>  ($year,$month,$day) = Parse_Date(`/bin/date`);
    </pre>
    <p class="Pp">Example #2:</p>
    <p class="Pp"></p>
    <pre>  while (&lt;MAIL&gt;)
  {
      if (/^From \S/)
      {
          ($year,$month,$day) = Parse_Date($_);
          ...
      }
      ...
  }
    </pre>
    <p class="Pp">The function returns an empty list if it can't extract a valid
        date from the input string.</p>
  </li>
  <li><span class="Li">&quot;$lower = ISO_LC($string);&quot;</span>
    <p class="Pp">Returns a copy of the given string where all letters of the
        ISO-Latin-1 character set have been replaced by their lower case
        equivalents.</p>
    <p class="Pp">Similar to Perl's built-in function
        &quot;<span class="Li">&quot;lc()&quot;</span>&quot; (see &quot;lc&quot;
        in <b>perlfunc</b>(1)) but for the whole ISO-Latin-1 character set, not
        just plain ASCII.</p>
  </li>
  <li><span class="Li">&quot;$upper = ISO_UC($string);&quot;</span>
    <p class="Pp">Returns a copy of the given string where all letters of the
        ISO-Latin-1 character set have been replaced by their upper case
        equivalents.</p>
    <p class="Pp">Similar to Perl's built-in function
        &quot;<span class="Li">&quot;uc()&quot;</span>&quot; (see &quot;uc&quot;
        in <b>perlfunc</b>(1)) but for the whole ISO-Latin-1 character set, not
        just plain ASCII.</p>
  </li>
  <li><span class="Li">&quot;$string = Date::Calc::Version();&quot;</span>
    <p class="Pp">This function returns a string with the (numeric) version
        number of the C&#x00A0;library (&quot;DateCalc.c&quot;) at the core of
        this package (which is also (automatically) the version number of the
        &quot;Calc.xs&quot; file).</p>
    <p class="Pp">Note that under all normal circumstances, this version number
        should be identical with the one found in the Perl variable
        &quot;<span class="Li">$Date::Calc::VERSION</span>&quot; (the version
        number of the &quot;Calc.pm&quot; file).</p>
    <p class="Pp">Since this function is not exported, you always have to
        qualify it explicitly, i.e.,
        &quot;<span class="Li">&quot;Date::Calc::Version()&quot;</span>&quot;.</p>
    <p class="Pp">This is to avoid possible name space conflicts with version
        functions from other modules.</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="RECIPES"><a class="permalink" href="#RECIPES">RECIPES</a></h1>
<dl class="Bl-tag">
  <dt>1)</dt>
  <dd>How do I compare two dates?
    <p class="Pp">Solution #1:</p>
    <p class="Pp"></p>
    <pre>  use Date::Calc qw( Date_to_Days );
  if (Date_to_Days($year1,$month1,$day1)  &lt;
      Date_to_Days($year2,$month2,$day2))
  if (Date_to_Days($year1,$month1,$day1)  &lt;=
      Date_to_Days($year2,$month2,$day2))
  if (Date_to_Days($year1,$month1,$day1)  &gt;
      Date_to_Days($year2,$month2,$day2))
  if (Date_to_Days($year1,$month1,$day1)  &gt;=
      Date_to_Days($year2,$month2,$day2))
  if (Date_to_Days($year1,$month1,$day1)  ==
      Date_to_Days($year2,$month2,$day2))
  if (Date_to_Days($year1,$month1,$day1)  !=
      Date_to_Days($year2,$month2,$day2))
  $cmp = (Date_to_Days($year1,$month1,$day1)  &lt;=&gt;
          Date_to_Days($year2,$month2,$day2));
    </pre>
    <p class="Pp">Solution #2:</p>
    <p class="Pp"></p>
    <pre>  use Date::Calc qw( Delta_Days );
  if (Delta_Days($year1,$month1,$day1,
                 $year2,$month2,$day2) &gt; 0)
  if (Delta_Days($year1,$month1,$day1,
                 $year2,$month2,$day2) &gt;= 0)
  if (Delta_Days($year1,$month1,$day1,
                 $year2,$month2,$day2) &lt; 0)
  if (Delta_Days($year1,$month1,$day1,
                 $year2,$month2,$day2) &lt;= 0)
  if (Delta_Days($year1,$month1,$day1,
                 $year2,$month2,$day2) == 0)
  if (Delta_Days($year1,$month1,$day1,
                 $year2,$month2,$day2) != 0)
    </pre>
  </dd>
  <dt>2)</dt>
  <dd>How do I check whether a given date lies within a certain range of dates?
    <p class="Pp"></p>
    <pre>  use Date::Calc qw( Date_to_Days );
  $lower = Date_to_Days($year1,$month1,$day1);
  $upper = Date_to_Days($year2,$month2,$day2);
  $date = Date_to_Days($year,$month,$day);
  if (($date &gt;= $lower) &amp;&amp; ($date &lt;= $upper))
  {
      # ok
  }
  else
  {
      # not ok
  }
    </pre>
  </dd>
  <dt>3)</dt>
  <dd>How do I compare two dates with times? How do I check whether two dates
      and times lie more or less than a given time interval apart?
    <p class="Pp">Solution #1:</p>
    <p class="Pp"></p>
    <pre>  use Date::Calc qw( Add_Delta_DHMS Date_to_Days );
  @date1 = (2002,8,31,23,59,1);
  @date2 = (2002,9,1,11,30,59); # ==&gt; less than 12 hours
  #@date1 = (2002,8,31,22,59,1);
  #@date2 = (2002,9,1,11,30,59); # ==&gt; more than 12 hours
  # Omit the next line if you just want to compare the two dates
  # (and change @date3 and @d3 to @date1 and @d1, respectively):
  @date3 = Add_Delta_DHMS(@date1, 0,12,0,0); # ==&gt; is the difference within 12 hours?
  @d2 = ( Date_to_Days(@date2[0..2]), ($date2[3]*60+$date2[4])*60+$date2[5] );
  @d3 = ( Date_to_Days(@date3[0..2]), ($date3[3]*60+$date3[4])*60+$date3[5] );
  @diff = ( $d2[0]-$d3[0], $d2[1]-$d3[1] );
  if ($diff[0] &gt; 0 and $diff[1] &lt; 0) { $diff[0]--; $diff[1] += 86400; }
  if ($diff[0] &lt; 0 and $diff[1] &gt; 0) { $diff[0]++; $diff[1] -= 86400; }
  if (($diff[0] || $diff[1]) &gt;= 0) { print &quot;More than 12 hours.\n&quot;; }
  else                             { print &quot;Less than 12 hours.\n&quot;; }
    </pre>
    <p class="Pp">Solution #2:</p>
    <p class="Pp">This solution is only feasible if your dates are guaranteed to
        lie within the range given by your system's epoch and overflow date and
        time!</p>
    <p class="Pp"></p>
    <pre>     Unix:    1-Jan-1970 00:00:00  to  19-Jan-2038 03:14:07
     MacOS:   1-Jan-1904 00:00:00  to   6-Feb-2040 06:28:15
  use Date::Calc qw( Date_to_Time );
  @date1 = (2002,8,31,23,59,1);
  @date2 = (2002,9,1,11,30,59); # ==&gt; less than 12 hours
  #@date1 = (2002,8,31,22,59,1);
  #@date2 = (2002,9,1,11,30,59); # ==&gt; more than 12 hours
  $d1 = Date_to_Time(@date1);
  $d2 = Date_to_Time(@date2);
  if ($d1 &lt;= $d2) { print &quot;The two dates are in chronological order.\n&quot;; }
  else            { print &quot;The two dates are in reversed order.\n&quot;; }
  if ($d1 + 12*60*60 &lt;= $d2) { print &quot;More than 12 hours.\n&quot;; }
  else                       { print &quot;Less than 12 hours.\n&quot;; }
    </pre>
  </dd>
  <dt>4)</dt>
  <dd>How do I verify whether someone has a certain age?
    <p class="Pp"></p>
    <pre>  use Date::Calc qw( Decode_Date_EU Today leap_year Delta_Days );
  $date = &lt;STDIN&gt;; # get birthday
  ($year1,$month1,$day1) = Decode_Date_EU($date);
  ($year2,$month2,$day2) = Today();
  if (($day1 == 29) &amp;&amp; ($month1 == 2) &amp;&amp; !leap_year($year2))
      { $day1--; }
  if ( (($year2 - $year1) &gt;  18) ||
     ( (($year2 - $year1) == 18) &amp;&amp;
     (Delta_Days($year2,$month1,$day1, $year2,$month2,$day2) &gt;= 0) ) )
  {
      print &quot;Ok - you are over 18.\n&quot;;
  }
  else
  {
      print &quot;Sorry - you aren't 18 yet!\n&quot;;
  }
  Or, alternatively (substituting the last &quot;if&quot; statement above):
  if (($year1+18 &lt;=&gt; $year2 || $month1 &lt;=&gt; $month2 || $day1 &lt;=&gt; $day2) &lt;= 0)
      { print &quot;Ok - you are over 18.\n&quot;; }
  else
      { print &quot;Sorry - you aren't 18 yet!\n&quot;; }
    </pre>
  </dd>
  <dt>5)</dt>
  <dd>How do I calculate the number of the week of month the current date lies
      in?
    <p class="Pp">For example:</p>
    <p class="Pp"></p>
    <pre>            April 1998
    Mon Tue Wed Thu Fri Sat Sun
              1   2   3   4   5  =  week #1
      6   7   8   9  10  11  12  =  week #2
     13  14  15  16  17  18  19  =  week #3
     20  21  22  23  24  25  26  =  week #4
     27  28  29  30              =  week #5
    </pre>
    <p class="Pp">Solution:</p>
    <p class="Pp"></p>
    <pre>  use Date::Calc qw( Today Day_of_Week );
  ($year,$month,$day) = Today();
  $week = int(($day + Day_of_Week($year,$month,1) - 2) / 7) + 1;
    </pre>
  </dd>
  <dt>6)</dt>
  <dd>How do I calculate whether a given date is the 1st, 2nd, 3rd, 4th or 5th
      of that day of week in the given month?
    <p class="Pp">For example:</p>
    <p class="Pp"></p>
    <pre>           October 2000
    Mon Tue Wed Thu Fri Sat Sun
                              1
      2   3   4   5   6   7   8
      9  10  11  12  13  14  15
     16  17  18  19  20  21  22
     23  24  25  26  27  28  29
     30  31
    </pre>
    <p class="Pp">Is Sunday, the 15th of October 2000, the 1st, 2nd, 3rd, 4th or
        5th Sunday of that month?</p>
    <p class="Pp">Solution:</p>
    <p class="Pp"></p>
    <pre>  use Date::Calc qw( Day_of_Week Delta_Days
                     Nth_Weekday_of_Month_Year
                     Date_to_Text_Long English_Ordinal
                     Day_of_Week_to_Text Month_to_Text );
  ($year,$month,$day) = (2000,10,15);
  $dow = Day_of_Week($year,$month,$day);
  $n = int( Delta_Days(
            Nth_Weekday_of_Month_Year($year,$month,$dow,1),
            $year,$month,$day)
            / 7) + 1;
  printf(&quot;%s is the %s %s in %s %d.\n&quot;,
      Date_to_Text_Long($year,$month,$day),
      English_Ordinal($n),
      Day_of_Week_to_Text($dow),
      Month_to_Text($month),
      $year);
    </pre>
    <p class="Pp">This prints:</p>
    <p class="Pp"></p>
    <pre>  Sunday, October 15th 2000 is the 3rd Sunday in October 2000.
    </pre>
  </dd>
  <dt>7)</dt>
  <dd>How do I calculate the date of the Wednesday of the same week as the
      current date?
    <p class="Pp">Solution #1:</p>
    <p class="Pp"></p>
    <pre>  use Date::Calc qw( Today Day_of_Week Add_Delta_Days );
  $searching_dow = 3; # 3 = Wednesday
  @today = Today();
  $current_dow = Day_of_Week(@today);
  @date = Add_Delta_Days(@today, $searching_dow - $current_dow);
    </pre>
    <p class="Pp">Solution #2:</p>
    <p class="Pp"></p>
    <pre>  use Date::Calc qw( Today Add_Delta_Days
                     Monday_of_Week Week_of_Year );
  $searching_dow = 3; # 3 = Wednesday
  @today = Today();
  @date = Add_Delta_Days( Monday_of_Week( Week_of_Year(@today) ),
                          $searching_dow - 1 );
    </pre>
    <p class="Pp">Solution #3:</p>
    <p class="Pp"></p>
    <pre>  use Date::Calc qw( Standard_to_Business Today
                     Business_to_Standard );
  @business = Standard_to_Business(Today());
  $business[2] = 3; # 3 = Wednesday
  @date = Business_to_Standard(@business);
    </pre>
  </dd>
  <dt>8)</dt>
  <dd>How can I add a week offset to a business date (including across year
      boundaries)?
    <p class="Pp"></p>
    <pre>  use Date::Calc qw( Business_to_Standard Add_Delta_Days
                     Standard_to_Business );
  @temp = Business_to_Standard($year,$week,$dow);
  @temp = Add_Delta_Days(@temp, $week_offset * 7);
  ($year,$week,$dow) = Standard_to_Business(@temp);
    </pre>
  </dd>
  <dt>9)</dt>
  <dd>How do I calculate the last and the next Saturday for any given date?
    <p class="Pp"></p>
    <pre>  use Date::Calc qw( Today Day_of_Week Add_Delta_Days
                     Day_of_Week_to_Text Date_to_Text );
  $searching_dow = 6; # 6 = Saturday
  @today = Today();
  $current_dow = Day_of_Week(@today);
  if ($searching_dow == $current_dow)
  {
      @prev = Add_Delta_Days(@today,-7);
      @next = Add_Delta_Days(@today,+7);
  }
  else
  {
      if ($searching_dow &gt; $current_dow)
      {
          @next = Add_Delta_Days(@today,
                    $searching_dow - $current_dow);
          @prev = Add_Delta_Days(@next,-7);
      }
      else
      {
          @prev = Add_Delta_Days(@today,
                    $searching_dow - $current_dow);
          @next = Add_Delta_Days(@prev,+7);
      }
  }
  $dow = Day_of_Week_to_Text($searching_dow);
  print &quot;Today is:      &quot;, ' ' x length($dow),
                               Date_to_Text(@today), &quot;\n&quot;;
  print &quot;Last $dow was:     &quot;, Date_to_Text(@prev),  &quot;\n&quot;;
  print &quot;Next $dow will be: &quot;, Date_to_Text(@next),  &quot;\n&quot;;
    </pre>
    <p class="Pp">This will print something like:</p>
    <p class="Pp"></p>
    <pre>  Today is:              Sun 12-Apr-1998
  Last Saturday was:     Sat 11-Apr-1998
  Next Saturday will be: Sat 18-Apr-1998
    </pre>
  </dd>
  <dt>10)</dt>
  <dd>How can I calculate the last business day (payday!) of a month?
    <p class="Pp">Solution #1 (holidays <b>NOT</b> taken into account):</p>
    <p class="Pp"></p>
    <pre>  use Date::Calc qw( Days_in_Month Day_of_Week Add_Delta_Days );
  $day = Days_in_Month($year,$month);
  $dow = Day_of_Week($year,$month,$day);
  if ($dow &gt; 5)
  {
      ($year,$month,$day) =
          Add_Delta_Days($year,$month,$day, 5-$dow);
  }
    </pre>
    <p class="Pp">Solution #2 (holidays taken into account):</p>
    <p class="Pp">This solution expects a multi-dimensional array
        &quot;<span class="Li">@holiday</span>&quot;, which contains all
        holidays, as follows:
        &quot;<span class="Li">&quot;$holiday[$year][$month][$day] =
        1;&quot;</span>&quot;.</p>
    <p class="Pp">(See the description of the function
        &quot;<span class="Li">&quot;Easter_Sunday()&quot;</span>&quot; further
        above for how to calculate the moving (variable) christian feast
      days!)</p>
    <p class="Pp">Days which are not holidays remain undefined or should have a
        value of zero in this array.</p>
    <p class="Pp"></p>
    <pre>  use Date::Calc qw( Days_in_Month Add_Delta_Days Day_of_Week );
  $day = Days_in_Month($year,$month);
  while (1)
  {
      while ($holiday[$year][$month][$day])
      {
          ($year,$month,$day) =
              Add_Delta_Days($year,$month,$day, -1);
      }
      $dow = Day_of_Week($year,$month,$day);
      if ($dow &gt; 5)
      {
          ($year,$month,$day) =
              Add_Delta_Days($year,$month,$day, 5-$dow);
      }
      else { last; }
  }
    </pre>
    <p class="Pp">Solution #3 (holidays taken into account, more comfortable,
        but requires <b>Date::Calendar</b>(3) and
      <b>Date::Calc::Object</b>(3)):</p>
    <p class="Pp"></p>
    <pre>  use Date::Calc::Object qw( Today Add_Delta_YM Date_to_Text_Long );
  use Date::Calendar::Profiles qw($Profiles);
  use Date::Calendar;
  $calendar = Date::Calendar-&gt;new( $Profiles-&gt;{'DE-BW'} );
  @today = Today();
  @nextmonth = Add_Delta_YM(@today[0,1],1, 0,1);
  $workaround = $calendar-&gt;add_delta_workdays(@nextmonth,+1);
  $payday     = $calendar-&gt;add_delta_workdays($workaround,-2);
  print &quot;Pay day = &quot;, Date_to_Text_Long($payday-&gt;date()), &quot;\n&quot;;
    </pre>
    <p class="Pp">The &quot;workaround&quot; is necessary due to a bug in the
        method &quot;<b>add_delta_workdays()</b>&quot; when adding a negative
        number of workdays.</p>
  </dd>
  <dt>11)</dt>
  <dd>How do I convert a MS Visual Basic &quot;DATETIME&quot; value into its
      date and time constituents?
    <p class="Pp"></p>
    <pre>  use Date::Calc qw( Add_Delta_DHMS Date_to_Text );
  $datetime = &quot;35883.121653&quot;;
  ($Dd,$Dh,$Dm,$Ds) = ($datetime =~ /^(\d+)\.(\d\d)(\d\d)(\d\d)$/);
  ($year,$month,$day, $hour,$min,$sec) =
      Add_Delta_DHMS(1900,1,1, 0,0,0, $Dd,$Dh,$Dm,$Ds);
  printf(&quot;The given date is %s %02d:%02d:%02d\n&quot;,
      Date_to_Text($year,$month,$day), $hour, $min, $sec);
    </pre>
    <p class="Pp">This prints:</p>
    <p class="Pp"></p>
    <pre>  The given date is Tue 31-Mar-1998 12:16:53
    </pre>
    <p class="Pp">Since I do not have or use Visual Basic, I can't guarantee
        that the number format assumed here is really the one used by Visual
        Basic - but you get the general idea.
        <span class="Li">&quot;:-)&quot;</span></p>
    <p class="Pp">Moreover, consider the following:</p>
    <p class="Pp">Morten Sickel &lt;Morten.Sickel@nrpa.no&gt; wrote:</p>
    <p class="Pp">I discovered a bug in Excel (2000): Excel thinks that 1900 was
        a leap year. Users should use 31-Dec-1899 as the date to add an Excel
        date value to in order to get the correct date.</p>
    <p class="Pp">I found out on the web that this bug originated in Lotus 123,
        which made 29-Feb-1900 an &quot;industrial standard&quot;. MS chose to
        keep the bug in order to be compatible with Lotus 123. But they have not
        mentioned anything about it in the help files.</p>
  </dd>
  <dt>12)</dt>
  <dd>How can I send a reminder to members of a group on the day before a
      meeting which occurs every first Friday of a month?
    <p class="Pp"></p>
    <pre>  use Date::Calc qw( Today Date_to_Days Add_Delta_YMD
                     Nth_Weekday_of_Month_Year );
  ($year,$month,$day) = Today();
  $tomorrow = Date_to_Days($year,$month,$day) + 1;
  $dow = 5; # 5 = Friday
  $n   = 1; # 1 = First of that day of week
  $meeting_this_month = Date_to_Days(
      Nth_Weekday_of_Month_Year($year,$month,$dow,$n) );
  ($year,$month,$day) = Add_Delta_YMD($year,$month,$day, 0,1,0);
  $meeting_next_month = Date_to_Days(
      Nth_Weekday_of_Month_Year($year,$month,$dow,$n) );
  if (($tomorrow == $meeting_this_month) ||
      ($tomorrow == $meeting_next_month))
  {
      # Send reminder e-mail!
  }
    </pre>
  </dd>
  <dt>13)</dt>
  <dd>How can I print a date in a different format than provided by the
      functions &quot;<span class="Li">&quot;Date_to_Text()&quot;</span>&quot;,
      &quot;<span class="Li">&quot;Date_to_Text_Long()&quot;</span>&quot; or
      &quot;<span class="Li">&quot;Compressed_to_Text()&quot;</span>&quot;?
    <p class="Pp"></p>
    <pre>  use Date::Calc qw( Today Day_of_Week_to_Text
                     Day_of_Week Month_to_Text
                     English_Ordinal );
  ($year,$month,$day) = Today();
    </pre>
    <p class="Pp">For example with leading zeros for the day:
        &quot;Fri&#x00A0;03-Jan-1964&quot;</p>
    <p class="Pp"></p>
    <pre>  printf(&quot;%.3s %02d-%.3s-%d\n&quot;,
      Day_of_Week_to_Text(Day_of_Week($year,$month,$day)),
      $day,
      Month_to_Text($month),
      $year);
    </pre>
    <p class="Pp">For example in U.S. american format:
        &quot;April&#x00A0;12th,&#x00A0;1998&quot;</p>
    <p class="Pp"></p>
    <pre>  $string = sprintf(&quot;%s %s, %d&quot;,
                Month_to_Text($month),
                English_Ordinal($day),
                $year);
    </pre>
    <p class="Pp">For example in one of the possible formats as specified by
        ISO&#x00A0;8601:</p>
    <p class="Pp"></p>
    <pre>  @date = ($year,$month,$day,$hour,$min,$sec);
  $date = sprintf(&quot;%d-%02d-%02d %02d:%02d:%02d&quot;, @date);
    </pre>
    <p class="Pp">(See also &quot;printf&quot; in <b>perlfunc</b>(1) and/or
        &quot;sprintf&quot; in <b>perlfunc</b>(1)!)</p>
  </dd>
  <dt>14)</dt>
  <dd>How can I iterate through a range of dates?
    <p class="Pp"></p>
    <pre>  use Date::Calc qw( Delta_Days Add_Delta_Days );
  @start = (1999,5,27);
  @stop  = (1999,6,1);
  $j = Delta_Days(@start,@stop);
  for ( $i = 0; $i &lt;= $j; $i++ )
  {
      @date = Add_Delta_Days(@start,$i);
      printf(&quot;%4d/%02d/%02d\n&quot;, @date);
  }
    </pre>
    <p class="Pp">Note that the loop can be improved; see also the recipe
      below.</p>
  </dd>
  <dt>15)</dt>
  <dd>How can I create a (Perl) list of dates in a certain range?
    <p class="Pp"></p>
    <pre>  use Date::Calc qw( Delta_Days Add_Delta_Days Date_to_Text );
  sub date_range
  {
      my(@date) = (@_)[0,1,2];
      my(@list);
      my($i);
      $i = Delta_Days(@_);
      while ($i-- &gt;= 0)
      {
          push( @list, [ @date ] );
          @date = Add_Delta_Days(@date, 1) if ($i &gt;= 0);
      }
      return(@list);
  }
  @range = &amp;date_range(1999,11,3, 1999,12,24); # in chronological order
  foreach $date (@range)
  {
      print Date_to_Text(@{$date}), &quot;\n&quot;;
  }
    </pre>
    <p class="Pp">Note that you probably shouldn't use this one, because it is
        much more efficient to iterate through all the dates (as shown in the
        recipe immediately above) than to construct such an array and then to
        loop through it. Also, it is much more space-efficient not to create
        this array.</p>
  </dd>
  <dt>16)</dt>
  <dd>How can I calculate the difference in days between dates, but without
      counting Saturdays and Sundays?
    <p class="Pp"></p>
    <pre>  sub Delta_Business_Days
  {
      my(@date1) = (@_)[0,1,2];
      my(@date2) = (@_)[3,4,5];
      my($minus,$result,$dow1,$dow2,$diff,$temp);
      $minus  = 0;
      $result = Delta_Days(@date1,@date2);
      if ($result != 0)
      {
          if ($result &lt; 0)
          {
              $minus = 1;
              $result = -$result;
              $dow1 = Day_of_Week(@date2);
              $dow2 = Day_of_Week(@date1);
          }
          else
          {
              $dow1 = Day_of_Week(@date1);
              $dow2 = Day_of_Week(@date2);
          }
          $diff = $dow2 - $dow1;
          $temp = $result;
          if ($diff != 0)
          {
              if ($diff &lt; 0)
              {
                  $diff += 7;
              }
              $temp -= $diff;
              $dow1 += $diff;
              if ($dow1 &gt; 6)
              {
                  $result--;
                  if ($dow1 &gt; 7)
                  {
                      $result--;
                  }
              }
          }
          if ($temp != 0)
          {
              $temp /= 7;
              $result -= ($temp &lt;&lt; 1);
          }
      }
      if ($minus) { return -$result; }
      else        { return  $result; }
  }
    </pre>
    <p class="Pp">This solution is probably of little practical value, however,
        because it doesn't take legal holidays into account.</p>
    <p class="Pp">See <b>Date::Calendar</b>(3) for how to do that.</p>
  </dd>
  <dt>17)</dt>
  <dd>How can I &quot;normalize&quot; the output of the
      &quot;<b>Delta_YMDHMS()</b>&quot; (or &quot;<b>Delta_YMD()</b>&quot;)
      function so that it contains only positive values?
    <p class="Pp">I.e., how can I show a difference in date (and time) in a more
        human-readable form, for example in order to show how much time until
        (or since) the expiration of something (e.g. an account, a domain, a
        credit card, etc.) is left (has passed)?</p>
    <p class="Pp">Correct solution: Use the functions
        &quot;<b>N_Delta_YMDHMS()</b>&quot; and &quot;<b>N_Delta_YMD()</b>&quot;
        instead!</p>
    <p class="Pp">The following gives a rudimentary sketch of a (much inferior)
        solution, which is maintained here only for historical reasons of this
        module:</p>
    <p class="Pp">a) <b>Delta_YMDHMS()</b>:</p>
    <p class="Pp"></p>
    <pre>  #!perl
  use strict;
  use Date::Calc qw(Today_and_Now Delta_YMDHMS Add_Delta_YMDHMS Delta_DHMS Date_to_Text);
  my $today = [Today_and_Now()];
  my $target = [2005,1,1,0,0,0];
  my $sign = &quot;until&quot;;
  my $delta = Normalize_Delta_YMDHMS($today,$target);
  if ($delta-&gt;[0] &lt; 0)
  {
      $sign = &quot;since&quot;;
      $delta = Normalize_Delta_YMDHMS($target,$today);
  }
  printf(&quot;Today is %s %02d:%02d:%02d\n&quot;, Date_to_Text(@{$today}[0..2]), @{$today}[3..5]);
  printf
  (
      &quot;%d year%s, %d month%s, %d day%s, %d hour%s, %d minute%s, %d second%s %s %s %02d:%02d:%02d\n&quot;,
      $delta-&gt;[0], (($delta-&gt;[0]==1)?'':'s'),
      $delta-&gt;[1], (($delta-&gt;[1]==1)?'':'s'),
      $delta-&gt;[2], (($delta-&gt;[2]==1)?'':'s'),
      $delta-&gt;[3], (($delta-&gt;[3]==1)?'':'s'),
      $delta-&gt;[4], (($delta-&gt;[4]==1)?'':'s'),
      $delta-&gt;[5], (($delta-&gt;[5]==1)?'':'s'),
      $sign,
      Date_to_Text(@{$target}[0..2]),
      @{$target}[3..5]
  );
  sub Normalize_Delta_YMDHMS
  {
      my($date1,$date2) = @_;
      my(@delta);
      @delta = Delta_YMDHMS(@$date1,@$date2);
      while ($delta[1] &lt; 0 or
             $delta[2] &lt; 0 or
             $delta[3] &lt; 0 or
             $delta[4] &lt; 0 or
             $delta[5] &lt; 0)
      {
          if ($delta[1] &lt; 0) { $delta[0]--; $delta[1] += 12; }
          if ($delta[2] &lt; 0)
          {
              $delta[1]--;
              @delta[2..5] = (0,0,0,0);
              @delta[2..5] = Delta_DHMS(Add_Delta_YMDHMS(@$date1,@delta),@$date2);
          }
          if ($delta[3] &lt; 0) { $delta[2]--; $delta[3] += 24; }
          if ($delta[4] &lt; 0) { $delta[3]--; $delta[4] += 60; }
          if ($delta[5] &lt; 0) { $delta[4]--; $delta[5] += 60; }
      }
      return \@delta;
  }
    </pre>
    <p class="Pp">b) <b>Delta_YMD()</b>:</p>
    <p class="Pp"></p>
    <pre>  #!perl
  use strict;
  use Date::Calc qw(Today Delta_YMD Add_Delta_YM Delta_Days Date_to_Text);
  my($sign,$delta);
  my $today = [Today()];
  my $target = [2005,1,1];
  if (Delta_Days(@$today,@$target) &lt; 0)
  {
      $sign = &quot;since&quot;;
      $delta = Normalize_Delta_YMD($target,$today);
  }
  else
  {
      $sign = &quot;until&quot;;
      $delta = Normalize_Delta_YMD($today,$target);
  }
  print &quot;Today is &quot;, Date_to_Text(@$today), &quot;\n&quot;;
  printf
  (
      &quot;%d year%s, %d month%s, %d day%s %s %s\n&quot;,
      $delta-&gt;[0], (($delta-&gt;[0]==1)?'':'s'),
      $delta-&gt;[1], (($delta-&gt;[1]==1)?'':'s'),
      $delta-&gt;[2], (($delta-&gt;[2]==1)?'':'s'),
      $sign,
      Date_to_Text(@$target)
  );
  sub Normalize_Delta_YMD
  {
      my($date1,$date2) = @_;
      my(@delta);
      @delta = Delta_YMD(@$date1,@$date2);
      while ($delta[1] &lt; 0 or $delta[2] &lt; 0)
      {
          if ($delta[1] &lt; 0) { $delta[0]--; $delta[1] += 12; }
          if ($delta[2] &lt; 0)
          {
              $delta[1]--;
              $delta[2] = Delta_Days(Add_Delta_YM(@$date1,@delta[0,1]),@$date2);
          }
      }
      return \@delta;
  }
    </pre>
    <p class="Pp">Note that for normalizing just a time vector, you can use the
        built-in function &quot;<b>Normalize_DHMS()</b>&quot;. However, this
        will yield either all positive <b>OR</b> all negative values, <b>NOT</b>
        all positive values as above.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>Date::Calc::Util</b>(3), <b>Date::Calc::Object</b>(3),
    <b>Date::Calendar</b>(3), <b>Date::Calendar::Year</b>(3),
    <b>Date::Calendar::Profiles</b>(3).</p>
<p class="Pp"></p>
<pre>  &quot;The Calendar FAQ&quot;:
  http://www.tondering.dk/claus/calendar.html
  by Claus Tondering &lt;claus@tondering.dk&gt;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="BEWARE"><a class="permalink" href="#BEWARE">BEWARE</a></h1>
<p class="Pp">When you are using the (deprecated) function
    &quot;<b>Language()</b>&quot;, the language setting is stored in a global
    variable.</p>
<p class="Pp">This may cause conflicts between threads or modules running
    concurrently.</p>
<p class="Pp">Therefore, in order to avoid such conflicts, NEVER use the
    function &quot;<b>Language()</b>&quot;, but ALWAYS pass a language parameter
    to the functions which are language-dependent.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">This man page documents &quot;Date::Calc&quot; version 6.4.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<pre>  Steffen Beyer
  mailto:STBEY@cpan.org
  http://www.engelschall.com/u/sb/download/
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 1995 - 2015 by Steffen Beyer. All rights
  reserved.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">This package is free software; you can use, modify and
    redistribute it under the same terms as Perl itself, i.e., at your option,
    under the terms either of the &quot;Artistic License&quot; or the &quot;GNU
    General Public License&quot;.</p>
<p class="Pp">The C library at the core of the module &quot;Date::Calc::XS&quot;
    can, at your discretion, also be used, modified and redistributed under the
    terms of the &quot;GNU Library General Public License&quot;.</p>
<p class="Pp">Please refer to the files &quot;Artistic.txt&quot;,
    &quot;GNU_GPL.txt&quot; and &quot;GNU_LGPL.txt&quot; in the
    &quot;license&quot; subdirectory of this distribution for any details!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DISCLAIMER"><a class="permalink" href="#DISCLAIMER">DISCLAIMER</a></h1>
<p class="Pp">This package is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</p>
<p class="Pp">See the &quot;GNU General Public License&quot; for more
  details.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="POD_ERRORS"><a class="permalink" href="#POD_ERRORS">POD
  ERRORS</a></h1>
<p class="Pp">Hey! <b>The above document had some coding errors, which are
    explained below:</b></p>
<dl class="Bl-tag">
  <dt id="Around"><a class="permalink" href="#Around">Around line 1761:</a></dt>
  <dd>Non-ASCII character seen before =encoding in 'Fran&#x00E7;ais'. Assuming
      CP1252</dd>
</dl>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2015-03-07</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

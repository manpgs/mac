<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Unicode::UCD(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Unicode::UCD(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Unicode::UCD(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Unicode::UCD - Unicode character database</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    use Unicode::UCD 'charinfo';
    my $charinfo   = charinfo($codepoint);
    use Unicode::UCD 'charprop';
    my $value  = charprop($codepoint, $property);
    use Unicode::UCD 'charprops_all';
    my $all_values_hash_ref = charprops_all($codepoint);
    use Unicode::UCD 'casefold';
    my $casefold = casefold($codepoint);
    use Unicode::UCD 'all_casefolds';
    my $all_casefolds_ref = all_casefolds();
    use Unicode::UCD 'casespec';
    my $casespec = casespec($codepoint);
    use Unicode::UCD 'charblock';
    my $charblock  = charblock($codepoint);
    use Unicode::UCD 'charscript';
    my $charscript = charscript($codepoint);
    use Unicode::UCD 'charblocks';
    my $charblocks = charblocks();
    use Unicode::UCD 'charscripts';
    my $charscripts = charscripts();
    use Unicode::UCD qw(charscript charinrange);
    my $range = charscript($script);
    print &quot;looks like $script\n&quot; if charinrange($range, $codepoint);
    use Unicode::UCD qw(general_categories bidi_types);
    my $categories = general_categories();
    my $types = bidi_types();
    use Unicode::UCD 'prop_aliases';
    my @space_names = prop_aliases(&quot;space&quot;);
    use Unicode::UCD 'prop_value_aliases';
    my @gc_punct_names = prop_value_aliases(&quot;Gc&quot;, &quot;Punct&quot;);
    use Unicode::UCD 'prop_values';
    my @all_EA_short_names = prop_values(&quot;East_Asian_Width&quot;);
    use Unicode::UCD 'prop_invlist';
    my @puncts = prop_invlist(&quot;gc=punctuation&quot;);
    use Unicode::UCD 'prop_invmap';
    my ($list_ref, $map_ref, $format, $missing)
                                      = prop_invmap(&quot;General Category&quot;);
    use Unicode::UCD 'search_invlist';
    my $index = search_invlist(\@invlist, $code_point);
    # The following function should be used only internally in
    # implementations of the Unicode Normalization Algorithm, and there
    # are better choices than it.
    use Unicode::UCD 'compexcl';
    my $compexcl = compexcl($codepoint);
    use Unicode::UCD 'namedseq';
    my $namedseq = namedseq($named_sequence_name);
    my $unicode_version = Unicode::UCD::UnicodeVersion();
    my $convert_to_numeric =
              Unicode::UCD::num(&quot;\N{RUMI DIGIT ONE}\N{RUMI DIGIT TWO}&quot;);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The Unicode::UCD module offers a series of functions that provide
    a simple interface to the Unicode Character Database.</p>
<section class="Ss">
<h2 class="Ss" id="code_point_argument"><a class="permalink" href="#code_point_argument">code
  point argument</a></h2>
<p class="Pp">Some of the functions are called with a <i>code point
    argument</i>, which is either a decimal or a hexadecimal scalar designating
    a code point in the platform's native character set (extended to Unicode),
    or a string containing <span class="Li">&quot;U+&quot;</span> followed by
    hexadecimals designating a Unicode code point. A leading 0 will force a
    hexadecimal interpretation, as will a hexadecimal digit that isn't a decimal
    digit.</p>
<p class="Pp">Examples:</p>
<p class="Pp"></p>
<pre>    223     # Decimal 223 in native character set
    0223    # Hexadecimal 223, native (= 547 decimal)
    0xDF    # Hexadecimal DF, native (= 223 decimal)
    '0xDF'  # String form of hexadecimal (= 223 decimal)
    'U+DF'  # Hexadecimal DF, in Unicode's character set
                              (= LATIN SMALL LETTER SHARP S)
</pre>
<p class="Pp">Note that the largest code point in Unicode is U+10FFFF.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>charinfo()</b></h2>
<pre>    use Unicode::UCD 'charinfo';
    my $charinfo = charinfo(0x41);
</pre>
<p class="Pp">This returns information about the input &quot;code point
    argument&quot; as a reference to a hash of fields as defined by the Unicode
    standard. If the &quot;code point argument&quot; is not assigned in the
    standard (i.e., has the general category
    <span class="Li">&quot;Cn&quot;</span> meaning
    <span class="Li">&quot;Unassigned&quot;</span>) or is a non-character
    (meaning it is guaranteed to never be assigned in the standard),
    <span class="Li">&quot;undef&quot;</span> is returned.</p>
<p class="Pp">Fields that aren't applicable to the particular code point
    argument exist in the returned hash, and are empty.</p>
<p class="Pp">For results that are less &quot;raw&quot; than this function
    returns, or to get the values for any property, not just the few covered by
    this function, use the &quot;<b>charprop()</b>&quot; function.</p>
<p class="Pp">The keys in the hash with the meanings of their values are:</p>
<dl class="Bl-tag">
  <dt id="code"><a class="permalink" href="#code"><b>code</b></a></dt>
  <dd>the input native &quot;code point argument&quot; expressed in hexadecimal,
      with leading zeros added if necessary to make it contain at least four
      hexdigits</dd>
  <dt id="name"><a class="permalink" href="#name"><b>name</b></a></dt>
  <dd>name of <i>code</i>, all IN UPPER CASE. Some control-type code points do
      not have names. This field will be empty for
      <span class="Li">&quot;Surrogate&quot;</span> and
      <span class="Li">&quot;Private Use&quot;</span> code points, and for the
      others without a name, it will contain a description enclosed in angle
      brackets, like <span class="Li">&quot;&lt;control&gt;&quot;</span>.</dd>
  <dt id="category"><a class="permalink" href="#category"><b>category</b></a></dt>
  <dd>The short name of the general category of <i>code</i>. This will match one
      of the keys in the hash returned by
      &quot;<b>general_categories()</b>&quot;.
    <p class="Pp">The &quot;<b>prop_value_aliases()</b>&quot; function can be
        used to get all the synonyms of the category name.</p>
  </dd>
  <dt id="combining"><a class="permalink" href="#combining"><b>combining</b></a></dt>
  <dd>the combining class number for <i>code</i> used in the Canonical Ordering
      Algorithm. For Unicode 5.1, this is described in Section 3.11
      <span class="Li">&quot;Canonical Ordering Behavior&quot;</span> available
      at &lt;http://www.unicode.org/versions/Unicode5.1.0/&gt;
    <p class="Pp">The &quot;<b>prop_value_aliases()</b>&quot; function can be
        used to get all the synonyms of the combining class number.</p>
  </dd>
  <dt id="bidi"><a class="permalink" href="#bidi"><b>bidi</b></a></dt>
  <dd>bidirectional type of <i>code</i>. This will match one of the keys in the
      hash returned by &quot;<b>bidi_types()</b>&quot;.
    <p class="Pp">The &quot;<b>prop_value_aliases()</b>&quot; function can be
        used to get all the synonyms of the bidi type name.</p>
  </dd>
  <dt id="decomposition"><a class="permalink" href="#decomposition"><b>decomposition</b></a></dt>
  <dd>is empty if <i>code</i> has no decomposition; or is one or more codes
      (separated by spaces) that, taken in order, represent a decomposition for
      <i>code</i>. Each has at least four hexdigits. The codes may be preceded
      by a word enclosed in angle brackets, then a space, like
      <span class="Li">&quot;&lt;compat&gt; &quot;</span>, giving the type of
      decomposition
    <p class="Pp">This decomposition may be an intermediate one whose components
        are also decomposable. Use Unicode::Normalize to get the final
        decomposition in one step.</p>
  </dd>
  <dt id="decimal"><a class="permalink" href="#decimal"><b>decimal</b></a></dt>
  <dd>if <i>code</i> represents a decimal digit this is its integer numeric
      value</dd>
  <dt id="digit"><a class="permalink" href="#digit"><b>digit</b></a></dt>
  <dd>if <i>code</i> represents some other digit-like number, this is its
      integer numeric value</dd>
  <dt id="numeric"><a class="permalink" href="#numeric"><b>numeric</b></a></dt>
  <dd>if <i>code</i> represents a whole or rational number, this is its numeric
      value. Rational values are expressed as a string like
      <span class="Li">&quot;1/4&quot;</span>.</dd>
  <dt id="mirrored"><a class="permalink" href="#mirrored"><b>mirrored</b></a></dt>
  <dd><span class="Li">&quot;Y&quot;</span> or
      <span class="Li">&quot;N&quot;</span> designating if <i>code</i> is
      mirrored in bidirectional text</dd>
  <dt id="unicode10"><a class="permalink" href="#unicode10"><b>unicode10</b></a></dt>
  <dd>name of <i>code</i> in the Unicode 1.0 standard if one existed for this
      code point and is different from the current name</dd>
  <dt id="comment"><a class="permalink" href="#comment"><b>comment</b></a></dt>
  <dd>As of Unicode 6.0, this is always empty.</dd>
  <dt id="upper"><a class="permalink" href="#upper"><b>upper</b></a></dt>
  <dd>is, if non-empty, the uppercase mapping for <i>code</i> expressed as at
      least four hexdigits. This indicates that the full uppercase mapping is a
      single character, and is identical to the simple (single-character only)
      mapping. When this field is empty, it means that the simple uppercase
      mapping is <i>code</i> itself; you'll need some other means, (like
      &quot;<b>charprop()</b>&quot; or &quot;<b>casespec()</b>&quot; to get the
      full mapping.</dd>
  <dt id="lower"><a class="permalink" href="#lower"><b>lower</b></a></dt>
  <dd>is, if non-empty, the lowercase mapping for <i>code</i> expressed as at
      least four hexdigits. This indicates that the full lowercase mapping is a
      single character, and is identical to the simple (single-character only)
      mapping. When this field is empty, it means that the simple lowercase
      mapping is <i>code</i> itself; you'll need some other means, (like
      &quot;<b>charprop()</b>&quot; or &quot;<b>casespec()</b>&quot; to get the
      full mapping.</dd>
  <dt id="title"><a class="permalink" href="#title"><b>title</b></a></dt>
  <dd>is, if non-empty, the titlecase mapping for <i>code</i> expressed as at
      least four hexdigits. This indicates that the full titlecase mapping is a
      single character, and is identical to the simple (single-character only)
      mapping. When this field is empty, it means that the simple titlecase
      mapping is <i>code</i> itself; you'll need some other means, (like
      &quot;<b>charprop()</b>&quot; or &quot;<b>casespec()</b>&quot; to get the
      full mapping.</dd>
  <dt id="block"><a class="permalink" href="#block"><b>block</b></a></dt>
  <dd>the block <i>code</i> belongs to (used in
      <span class="Li">&quot;\p{Blk=...}&quot;</span>). The
      &quot;<b>prop_value_aliases()</b>&quot; function can be used to get all
      the synonyms of the block name.
    <p class="Pp">See &quot;Blocks versus Scripts&quot;.</p>
  </dd>
  <dt id="script"><a class="permalink" href="#script"><b>script</b></a></dt>
  <dd>the script <i>code</i> belongs to. The
      &quot;<b>prop_value_aliases()</b>&quot; function can be used to get all
      the synonyms of the script name. Note that this is the older
      &quot;Script&quot; property value, and not the improved
      &quot;Script_Extensions&quot; value.
    <p class="Pp">See &quot;Blocks versus Scripts&quot;.</p>
  </dd>
</dl>
<p class="Pp">Note that you cannot do (de)composition and casing based solely on
    the <i>decomposition</i>, <i>combining</i>, <i>lower</i>, <i>upper</i>, and
    <i>title</i> fields; you will need also the &quot;<b>casespec()</b>&quot;
    function and the <span class="Li">&quot;Composition_Exclusion&quot;</span>
    property. (Or you could just use the <b>lc()</b>, <b>uc()</b>, and
    <b>ucfirst()</b> functions, and the Unicode::Normalize module.)</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>charprop()</b></h2>
<pre>    use Unicode::UCD 'charprop';
    print charprop(0x41, &quot;Gc&quot;), &quot;\n&quot;;
    print charprop(0x61, &quot;General_Category&quot;), &quot;\n&quot;;
  prints
    Lu
    Ll
</pre>
<p class="Pp">This returns the value of the Unicode property given by the second
    parameter for the &quot;code point argument&quot; given by the first.</p>
<p class="Pp">The passed-in property may be specified as any of the synonyms
    returned by &quot;<b>prop_aliases()</b>&quot;.</p>
<p class="Pp">The return value is always a scalar, either a string or a number.
    For properties where there are synonyms for the values, the synonym returned
    by this function is the longest, most descriptive form, the one returned by
    &quot;<b>prop_value_aliases()</b>&quot; when called in a scalar context. Of
    course, you can call &quot;<b>prop_value_aliases()</b>&quot; on the result
    to get other synonyms.</p>
<p class="Pp">The return values are more &quot;cooked&quot; than the
    &quot;<b>charinfo()</b>&quot; ones. For example, the
    <span class="Li">&quot;uc&quot;</span> property value is the actual string
    containing the full uppercase mapping of the input code point. You have to
    go to extra trouble with <span class="Li">&quot;charinfo&quot;</span> to get
    this value from its <span class="Li">&quot;upper&quot;</span> hash element
    when the full mapping differs from the simple one.</p>
<p class="Pp">Special note should be made of the return values for a few
    properties:</p>
<dl class="Bl-tag">
  <dt id="Block"><a class="permalink" href="#Block">Block</a></dt>
  <dd>The value returned is the new-style (see &quot;Old-style versus new-style
      block names&quot;).</dd>
  <dt id="Decomposition_Mapping"><a class="permalink" href="#Decomposition_Mapping">Decomposition_Mapping</a></dt>
  <dd>Like &quot;<b>charinfo()</b>&quot;, the result may be an intermediate
      decomposition whose components are also decomposable. Use
      Unicode::Normalize to get the final decomposition in one step.
    <p class="Pp">Unlike &quot;<b>charinfo()</b>&quot;, this does not include
        the decomposition type. Use the
        <span class="Li">&quot;Decomposition_Type&quot;</span> property to get
        that.</p>
  </dd>
  <dt id="Name_Alias"><a class="permalink" href="#Name_Alias">Name_Alias</a></dt>
  <dd>If the input code point's name has more than one synonym, they are
      returned joined into a single comma-separated string.</dd>
  <dt id="Numeric_Value"><a class="permalink" href="#Numeric_Value">Numeric_Value</a></dt>
  <dd>If the result is a fraction, it is converted into a floating point number
      to the accuracy of your platform.</dd>
  <dt id="Script_Extensions"><a class="permalink" href="#Script_Extensions">Script_Extensions</a></dt>
  <dd>If the result is multiple script names, they are returned joined into a
      single comma-separated string.</dd>
</dl>
<p class="Pp">When called with a property that is a Perl extension that isn't
    expressible in a compound form, this function currently returns
    <span class="Li">&quot;undef&quot;</span>, as the only two possible values
    are <i>true</i> or <i>false</i> (1 or 0 I suppose). This behavior may change
    in the future, so don't write code that relies on it.
    <span class="Li">&quot;Present_In&quot;</span> is a Perl extension that is
    expressible in a bipartite or compound form (for example,
    <span class="Li">&quot;\p{Present_In=4.0}&quot;</span>), so
    <span class="Li">&quot;charprop&quot;</span> accepts it. But
    <span class="Li">&quot;Any&quot;</span> is a Perl extension that isn't
    expressible that way, so <span class="Li">&quot;charprop&quot;</span>
    returns <span class="Li">&quot;undef&quot;</span> for it. Also
    <span class="Li">&quot;charprop&quot;</span> returns
    <span class="Li">&quot;undef&quot;</span> for all Perl extensions that are
    internal-only.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>charprops_all()</b></h2>
<pre>    use Unicode::UCD 'charprops_all';
    my $%properties_of_A_hash_ref = charprops_all(&quot;U+41&quot;);
</pre>
<p class="Pp">This returns a reference to a hash whose keys are all the distinct
    Unicode (no Perl extension) properties, and whose values are the respective
    values for those properties for the input &quot;code point
  argument&quot;.</p>
<p class="Pp">Each key is the property name in its longest, most descriptive
    form. The values are what &quot;<b>charprop()</b>&quot; would return.</p>
<p class="Pp">This function is expensive in time and memory.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>charblock()</b></h2>
<pre>    use Unicode::UCD 'charblock';
    my $charblock = charblock(0x41);
    my $charblock = charblock(1234);
    my $charblock = charblock(0x263a);
    my $charblock = charblock(&quot;U+263a&quot;);
    my $range     = charblock('Armenian');
</pre>
<p class="Pp">With a &quot;code point argument&quot;
    <span class="Li">&quot;charblock()&quot;</span> returns the <i>block</i> the
    code point belongs to, e.g. <span class="Li">&quot;Basic Latin&quot;</span>.
    The old-style block name is returned (see &quot;Old-style versus new-style
    block names&quot;). The &quot;<b>prop_value_aliases()</b>&quot; function can
    be used to get all the synonyms of the block name.</p>
<p class="Pp">If the code point is unassigned, this returns the block it would
    belong to if it were assigned. (If the Unicode version being used is so
    early as to not have blocks, all code points are considered to be in
    <span class="Li">&quot;No_Block&quot;</span>.)</p>
<p class="Pp">See also &quot;Blocks versus Scripts&quot;.</p>
<p class="Pp">If supplied with an argument that can't be a code point,
    <span class="Li">&quot;charblock()&quot;</span> tries to do the opposite and
    interpret the argument as an old-style block name. On an ASCII platform, the
    return value is a <i>range set</i> with one range: an anonymous array with a
    single element that consists of another anonymous array whose first element
    is the first code point in the block, and whose second element is the final
    code point in the block. On an EBCDIC platform, the first two Unicode blocks
    are not contiguous. Their range sets are lists containing
    <i>start-of-range</i>, <i>end-of-range</i> code point pairs. You can test
    whether a code point is in a range set using the
    &quot;<b>charinrange()</b>&quot; function. (To be precise, each <i>range
    set</i> contains a third array element, after the range boundary ones: the
    old_style block name.)</p>
<p class="Pp">If the argument to <span class="Li">&quot;charblock()&quot;</span>
    is not a known block, <span class="Li">&quot;undef&quot;</span> is
  returned.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>charscript()</b></h2>
<pre>    use Unicode::UCD 'charscript';
    my $charscript = charscript(0x41);
    my $charscript = charscript(1234);
    my $charscript = charscript(&quot;U+263a&quot;);
    my $range      = charscript('Thai');
</pre>
<p class="Pp">With a &quot;code point argument&quot;,
    <span class="Li">&quot;charscript()&quot;</span> returns the <i>script</i>
    the code point belongs to, e.g., <span class="Li">&quot;Latin&quot;</span>,
    <span class="Li">&quot;Greek&quot;</span>,
    <span class="Li">&quot;Han&quot;</span>. If the code point is unassigned or
    the Unicode version being used is so early that it doesn't have scripts,
    this function returns <span class="Li">&quot;Unknown&quot;</span>. The
    &quot;<b>prop_value_aliases()</b>&quot; function can be used to get all the
    synonyms of the script name.</p>
<p class="Pp">Note that the Script_Extensions property is an improved version of
    the Script property, and you should probably be using that instead, with the
    &quot;<b>charprop()</b>&quot; function.</p>
<p class="Pp">If supplied with an argument that can't be a code point,
    <b>charscript()</b> tries to do the opposite and interpret the argument as a
    script name. The return value is a <i>range set</i>: an anonymous array of
    arrays that contain <i>start-of-range</i>, <i>end-of-range</i> code point
    pairs. You can test whether a code point is in a range set using the
    &quot;<b>charinrange()</b>&quot; function. (To be precise, each <i>range
    set</i> contains a third array element, after the range boundary ones: the
    script name.)</p>
<p class="Pp">If the <span class="Li">&quot;charscript()&quot;</span> argument
    is not a known script, <span class="Li">&quot;undef&quot;</span> is
    returned.</p>
<p class="Pp">See also &quot;Blocks versus Scripts&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>charblocks()</b></h2>
<pre>    use Unicode::UCD 'charblocks';
    my $charblocks = charblocks();
</pre>
<p class="Pp"><span class="Li">&quot;charblocks()&quot;</span> returns a
    reference to a hash with the known block names as the keys, and the code
    point ranges (see &quot;<b>charblock()</b>&quot;) as the values.</p>
<p class="Pp">The names are in the old-style (see &quot;Old-style versus
    new-style block names&quot;).</p>
<p class="Pp">prop_invmap(&quot;block&quot;) can be used to get this same data
    in a different type of data structure.</p>
<p class="Pp">prop_values(&quot;Block&quot;) can be used to get all the known
    new-style block names as a list, without the code point ranges.</p>
<p class="Pp">See also &quot;Blocks versus Scripts&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>charscripts()</b></h2>
<pre>    use Unicode::UCD 'charscripts';
    my $charscripts = charscripts();
</pre>
<p class="Pp"><span class="Li">&quot;charscripts()&quot;</span> returns a
    reference to a hash with the known script names as the keys, and the code
    point ranges (see &quot;<b>charscript()</b>&quot;) as the values.</p>
<p class="Pp">prop_invmap(&quot;script&quot;) can be used to get this same data
    in a different type of data structure. Since the Script_Extensions property
    is an improved version of the Script property, you should instead use
    prop_invmap(&quot;scx&quot;).</p>
<p class="Pp"><span class="Li">&quot;prop_values(&quot;Script&quot;)&quot;</span>
    can be used to get all the known script names as a list, without the code
    point ranges.</p>
<p class="Pp">See also &quot;Blocks versus Scripts&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>charinrange()</b></h2>
<p class="Pp">In addition to using the
    <span class="Li">&quot;\p{Blk=...}&quot;</span> and
    <span class="Li">&quot;\P{Blk=...}&quot;</span> constructs, you can also
    test whether a code point is in the <i>range</i> as returned by
    &quot;<b>charblock()</b>&quot; and &quot;<b>charscript()</b>&quot; or as the
    values of the hash returned by &quot;<b>charblocks()</b>&quot; and
    &quot;<b>charscripts()</b>&quot; by using
    <span class="Li">&quot;charinrange()&quot;</span>:</p>
<p class="Pp"></p>
<pre>    use Unicode::UCD qw(charscript charinrange);
    $range = charscript('Hiragana');
    print &quot;looks like hiragana\n&quot; if charinrange($range, $codepoint);
</pre>
</section>
<section class="Ss">
<h2 class="Ss"><b>general_categories()</b></h2>
<pre>    use Unicode::UCD 'general_categories';
    my $categories = general_categories();
</pre>
<p class="Pp">This returns a reference to a hash which has short general
    category names (such as <span class="Li">&quot;Lu&quot;</span>,
    <span class="Li">&quot;Nd&quot;</span>,
    <span class="Li">&quot;Zs&quot;</span>,
    <span class="Li">&quot;S&quot;</span>) as keys and long names (such as
    <span class="Li">&quot;UppercaseLetter&quot;</span>,
    <span class="Li">&quot;DecimalNumber&quot;</span>,
    <span class="Li">&quot;SpaceSeparator&quot;</span>,
    <span class="Li">&quot;Symbol&quot;</span>) as values. The hash is
    reversible in case you need to go from the long names to the short names.
    The general category is the one returned from &quot;<b>charinfo()</b>&quot;
    under the <span class="Li">&quot;category&quot;</span> key.</p>
<p class="Pp">The &quot;<b>prop_values()</b>&quot; and
    &quot;<b>prop_value_aliases()</b>&quot; functions can be used as an
    alternative to this function; the first returning a simple list of the short
    category names; and the second gets all the synonyms of a given category
    name.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>bidi_types()</b></h2>
<pre>    use Unicode::UCD 'bidi_types';
    my $categories = bidi_types();
</pre>
<p class="Pp">This returns a reference to a hash which has the short bidi
    (bidirectional) type names (such as <span class="Li">&quot;L&quot;</span>,
    <span class="Li">&quot;R&quot;</span>) as keys and long names (such as
    <span class="Li">&quot;Left-to-Right&quot;</span>,
    <span class="Li">&quot;Right-to-Left&quot;</span>) as values. The hash is
    reversible in case you need to go from the long names to the short names.
    The bidi type is the one returned from &quot;<b>charinfo()</b>&quot; under
    the <span class="Li">&quot;bidi&quot;</span> key. For the exact meaning of
    the various bidi classes the Unicode TR9 is recommended reading:
    &lt;http://www.unicode.org/reports/tr9/&gt; (as of Unicode 5.0.0)</p>
<p class="Pp">The &quot;<b>prop_values()</b>&quot; and
    &quot;<b>prop_value_aliases()</b>&quot; functions can be used as an
    alternative to this function; the first returning a simple list of the short
    bidi type names; and the second gets all the synonyms of a given bidi type
    name.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>compexcl()</b></h2>
<p class="Pp">WARNING: Unicode discourages the use of this function or any of
    the alternative mechanisms listed in this section (the documentation of
    <span class="Li">&quot;compexcl()&quot;</span>), except internally in
    implementations of the Unicode Normalization Algorithm. You should be using
    Unicode::Normalize directly instead of these. Using these will likely lead
    to half-baked results.</p>
<p class="Pp"></p>
<pre>    use Unicode::UCD 'compexcl';
    my $compexcl = compexcl(0x09dc);
</pre>
<p class="Pp">This routine returns <span class="Li">&quot;undef&quot;</span> if
    the Unicode version being used is so early that it doesn't have this
    property.</p>
<p class="Pp"><span class="Li">&quot;compexcl()&quot;</span> is included for
    backwards compatibility, but as of Perl 5.12 and more modern Unicode
    versions, for most purposes it is probably more convenient to use one of the
    following instead:</p>
<p class="Pp"></p>
<pre>    my $compexcl = chr(0x09dc) =~ /\p{Comp_Ex};
    my $compexcl = chr(0x09dc) =~ /\p{Full_Composition_Exclusion};
</pre>
<p class="Pp">or even</p>
<p class="Pp"></p>
<pre>    my $compexcl = chr(0x09dc) =~ /\p{CE};
    my $compexcl = chr(0x09dc) =~ /\p{Composition_Exclusion};
</pre>
<p class="Pp">The first two forms return <b>true</b> if the &quot;code point
    argument&quot; should not be produced by composition normalization. For the
    final two forms to return <b>true</b>, it is additionally required that this
    fact not otherwise be determinable from the Unicode data base.</p>
<p class="Pp">This routine behaves identically to the final two forms. That is,
    it does not return <b>true</b> if the code point has a decomposition
    consisting of another single code point, nor if its decomposition starts
    with a code point whose combining class is non-zero. Code points that meet
    either of these conditions should also not be produced by composition
    normalization, which is probably why you should use the
    <span class="Li">&quot;Full_Composition_Exclusion&quot;</span> property
    instead, as shown above.</p>
<p class="Pp">The routine returns <b>false</b> otherwise.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>casefold()</b></h2>
<pre>    use Unicode::UCD 'casefold';
    my $casefold = casefold(0xDF);
    if (defined $casefold) {
        my @full_fold_hex = split / /, $casefold-&gt;{'full'};
        my $full_fold_string =
                    join &quot;&quot;, map {chr(hex($_))} @full_fold_hex;
        my @turkic_fold_hex =
                        split / /, ($casefold-&gt;{'turkic'} ne &quot;&quot;)
                                        ? $casefold-&gt;{'turkic'}
                                        : $casefold-&gt;{'full'};
        my $turkic_fold_string =
                        join &quot;&quot;, map {chr(hex($_))} @turkic_fold_hex;
    }
    if (defined $casefold &amp;&amp; $casefold-&gt;{'simple'} ne &quot;&quot;) {
        my $simple_fold_hex = $casefold-&gt;{'simple'};
        my $simple_fold_string = chr(hex($simple_fold_hex));
    }
</pre>
<p class="Pp">This returns the (almost) locale-independent case folding of the
    character specified by the &quot;code point argument&quot;. (Starting in
    Perl v5.16, the core function <span class="Li">&quot;fc()&quot;</span>
    returns the <span class="Li">&quot;full&quot;</span> mapping (described
    below) faster than this does, and for entire strings.)</p>
<p class="Pp">If there is no case folding for the input code point,
    <span class="Li">&quot;undef&quot;</span> is returned.</p>
<p class="Pp">If there is a case folding for that code point, a reference to a
    hash with the following fields is returned:</p>
<dl class="Bl-tag">
  <dt id="code~2"><a class="permalink" href="#code~2"><b>code</b></a></dt>
  <dd>the input native &quot;code point argument&quot; expressed in hexadecimal,
      with leading zeros added if necessary to make it contain at least four
      hexdigits</dd>
  <dt id="full"><a class="permalink" href="#full"><b>full</b></a></dt>
  <dd>one or more codes (separated by spaces) that, taken in order, give the
      code points for the case folding for <i>code</i>. Each has at least four
      hexdigits.</dd>
  <dt id="simple"><a class="permalink" href="#simple"><b>simple</b></a></dt>
  <dd>is empty, or is exactly one code with at least four hexdigits which can be
      used as an alternative case folding when the calling program cannot cope
      with the fold being a sequence of multiple code points. If <i>full</i> is
      just one code point, then <i>simple</i> equals <i>full</i>. If there is no
      single code point folding defined for <i>code</i>, then <i>simple</i> is
      the empty string. Otherwise, it is an inferior, but still
      better-than-nothing alternative folding to <i>full</i>.</dd>
  <dt id="mapping"><a class="permalink" href="#mapping"><b>mapping</b></a></dt>
  <dd>is the same as <i>simple</i> if <i>simple</i> is not empty, and it is the
      same as <i>full</i> otherwise. It can be considered to be the simplest
      possible folding for <i>code</i>. It is defined primarily for backwards
      compatibility.</dd>
  <dt id="status"><a class="permalink" href="#status"><b>status</b></a></dt>
  <dd>is <span class="Li">&quot;C&quot;</span> (for
      <span class="Li">&quot;common&quot;</span>) if the best possible fold is a
      single code point (<i>simple</i> equals <i>full</i> equals
      <i>mapping</i>). It is <span class="Li">&quot;S&quot;</span> if there are
      distinct folds, <i>simple</i> and <i>full</i> (<i>mapping</i> equals
      <i>simple</i>). And it is <span class="Li">&quot;F&quot;</span> if there
      is only a <i>full</i> fold (<i>mapping</i> equals <i>full</i>;
      <i>simple</i> is empty). Note that this describes the contents of
      <i>mapping</i>. It is defined primarily for backwards compatibility.
    <p class="Pp">For Unicode versions between 3.1 and 3.1.1 inclusive,
        <i>status</i> can also be <span class="Li">&quot;I&quot;</span> which is
        the same as <span class="Li">&quot;C&quot;</span> but is a special case
        for dotted uppercase I and dotless lowercase i:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>*</b> If you use this &quot;I&quot; mapping</dt>
  <dd>the result is case-insensitive, but dotless and dotted I's are not
      distinguished</dd>
  <dt><b>*</b> If you exclude this &quot;I&quot; mapping</dt>
  <dd>the result is not fully case-insensitive, but dotless and dotted I's are
      distinguished</dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="turkic"><a class="permalink" href="#turkic"><b>turkic</b></a></dt>
  <dd>contains any special folding for Turkic languages. For versions of Unicode
      starting with 3.2, this field is empty unless <i>code</i> has a different
      folding in Turkic languages, in which case it is one or more codes
      (separated by spaces) that, taken in order, give the code points for the
      case folding for <i>code</i> in those languages. Each code has at least
      four hexdigits. Note that this folding does not maintain canonical
      equivalence without additional processing.
    <p class="Pp">For Unicode versions between 3.1 and 3.1.1 inclusive, this
        field is empty unless there is a special folding for Turkic languages,
        in which case <i>status</i> is <span class="Li">&quot;I&quot;</span>,
        and <i>mapping</i>, <i>full</i>, <i>simple</i>, and <i>turkic</i> are
        all equal.</p>
  </dd>
</dl>
<p class="Pp">Programs that want complete generality and the best folding
    results should use the folding contained in the <i>full</i> field. But note
    that the fold for some code points will be a sequence of multiple code
    points.</p>
<p class="Pp">Programs that can't cope with the fold mapping being multiple code
    points can use the folding contained in the <i>simple</i> field, with the
    loss of some generality. In Unicode 5.1, about 7% of the defined foldings
    have no single code point folding.</p>
<p class="Pp">The <i>mapping</i> and <i>status</i> fields are provided for
    backwards compatibility for existing programs. They contain the same values
    as in previous versions of this function.</p>
<p class="Pp">Locale is not completely independent. The <i>turkic</i> field
    contains results to use when the locale is a Turkic language.</p>
<p class="Pp">For more information about case mappings see
    &lt;http://www.unicode.org/unicode/reports/tr21&gt;</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>all_casefolds()</b></h2>
<pre>    use Unicode::UCD 'all_casefolds';
    my $all_folds_ref = all_casefolds();
    foreach my $char_with_casefold (sort { $a &lt;=&gt; $b }
                                    keys %$all_folds_ref)
    {
        printf &quot;%04X:&quot;, $char_with_casefold;
        my $casefold = $all_folds_ref-&gt;{$char_with_casefold};
        # Get folds for $char_with_casefold
        my @full_fold_hex = split / /, $casefold-&gt;{'full'};
        my $full_fold_string =
                    join &quot;&quot;, map {chr(hex($_))} @full_fold_hex;
        print &quot; full=&quot;, join &quot; &quot;, @full_fold_hex;
        my @turkic_fold_hex =
                        split / /, ($casefold-&gt;{'turkic'} ne &quot;&quot;)
                                        ? $casefold-&gt;{'turkic'}
                                        : $casefold-&gt;{'full'};
        my $turkic_fold_string =
                        join &quot;&quot;, map {chr(hex($_))} @turkic_fold_hex;
        print &quot;; turkic=&quot;, join &quot; &quot;, @turkic_fold_hex;
        if (defined $casefold &amp;&amp; $casefold-&gt;{'simple'} ne &quot;&quot;) {
            my $simple_fold_hex = $casefold-&gt;{'simple'};
            my $simple_fold_string = chr(hex($simple_fold_hex));
            print &quot;; simple=$simple_fold_hex&quot;;
        }
        print &quot;\n&quot;;
    }
</pre>
<p class="Pp">This returns all the case foldings in the current version of
    Unicode in the form of a reference to a hash. Each key to the hash is the
    decimal representation of a Unicode character that has a casefold to other
    than itself. The casefold of a semi-colon is itself, so it isn't in the
    hash; likewise for a lowercase &quot;a&quot;, but there is an entry for a
    capital &quot;A&quot;. The hash value for each key is another hash,
    identical to what is returned by &quot;<b>casefold()</b>&quot; if called
    with that code point as its argument. So the value
    <span class="Li">&quot;all_casefolds()-&gt;{ord(&quot;A&quot;)}'&quot;</span>
    is equivalent to
    <span class="Li">&quot;casefold(ord(&quot;A&quot;))&quot;</span>;</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>casespec()</b></h2>
<pre>    use Unicode::UCD 'casespec';
    my $casespec = casespec(0xFB00);
</pre>
<p class="Pp">This returns the potentially locale-dependent case mappings of the
    &quot;code point argument&quot;. The mappings may be longer than a single
    code point (which the basic Unicode case mappings as returned by
    &quot;<b>charinfo()</b>&quot; never are).</p>
<p class="Pp">If there are no case mappings for the &quot;code point
    argument&quot;, or if all three possible mappings (<i>lower</i>,
    <i>title</i> and <i>upper</i>) result in single code points and are locale
    independent and unconditional, <span class="Li">&quot;undef&quot;</span> is
    returned (which means that the case mappings, if any, for the code point are
    those returned by &quot;<b>charinfo()</b>&quot;).</p>
<p class="Pp">Otherwise, a reference to a hash giving the mappings (or a
    reference to a hash of such hashes, explained below) is returned with the
    following keys and their meanings:</p>
<p class="Pp">The keys in the bottom layer hash with the meanings of their
    values are:</p>
<dl class="Bl-tag">
  <dt id="code~3"><a class="permalink" href="#code~3"><b>code</b></a></dt>
  <dd>the input native &quot;code point argument&quot; expressed in hexadecimal,
      with leading zeros added if necessary to make it contain at least four
      hexdigits</dd>
  <dt id="lower~2"><a class="permalink" href="#lower~2"><b>lower</b></a></dt>
  <dd>one or more codes (separated by spaces) that, taken in order, give the
      code points for the lower case of <i>code</i>. Each has at least four
      hexdigits.</dd>
  <dt id="title~2"><a class="permalink" href="#title~2"><b>title</b></a></dt>
  <dd>one or more codes (separated by spaces) that, taken in order, give the
      code points for the title case of <i>code</i>. Each has at least four
      hexdigits.</dd>
  <dt id="upper~2"><a class="permalink" href="#upper~2"><b>upper</b></a></dt>
  <dd>one or more codes (separated by spaces) that, taken in order, give the
      code points for the upper case of <i>code</i>. Each has at least four
      hexdigits.</dd>
  <dt id="condition"><a class="permalink" href="#condition"><b>condition</b></a></dt>
  <dd>the conditions for the mappings to be valid. If
      <span class="Li">&quot;undef&quot;</span>, the mappings are always valid.
      When defined, this field is a list of conditions, all of which must be
      true for the mappings to be valid. The list consists of one or more
      <i>locales</i> (see below) and/or <i>contexts</i> (explained in the next
      paragraph), separated by spaces. (Other than as used to separate elements,
      spaces are to be ignored.) Case distinctions in the condition list are not
      significant. Conditions preceded by &quot;NON_&quot; represent the
      negation of the condition.
    <p class="Pp">A <i>context</i> is one of those defined in the Unicode
        standard. For Unicode 5.1, they are defined in Section 3.13
        <span class="Li">&quot;Default Case Operations&quot;</span> available at
        &lt;http://www.unicode.org/versions/Unicode5.1.0/&gt;. These are for
        context-sensitive casing.</p>
  </dd>
</dl>
<p class="Pp">The hash described above is returned for locale-independent
    casing, where at least one of the mappings has length longer than one. If
    <span class="Li">&quot;undef&quot;</span> is returned, the code point may
    have mappings, but if so, all are length one, and are returned by
    &quot;<b>charinfo()</b>&quot;. Note that when this function does return a
    value, it will be for the complete set of mappings for a code point, even
    those whose length is one.</p>
<p class="Pp">If there are additional casing rules that apply only in certain
    locales, an additional key for each will be defined in the returned hash.
    Each such key will be its locale name, defined as a 2-letter ISO 3166
    country code, possibly followed by a &quot;_&quot; and a 2-letter ISO
    language code (possibly followed by a &quot;_&quot; and a variant code). You
    can find the lists of all possible locales, see Locale::Country and
    Locale::Language. (In Unicode 6.0, the only locales returned by this
    function are <span class="Li">&quot;lt&quot;</span>,
    <span class="Li">&quot;tr&quot;</span>, and
    <span class="Li">&quot;az&quot;</span>.)</p>
<p class="Pp">Each locale key is a reference to a hash that has the form above,
    and gives the casing rules for that particular locale, which take precedence
    over the locale-independent ones when in that locale.</p>
<p class="Pp">If the only casing for a code point is locale-dependent, then the
    returned hash will not have any of the base keys, like
    <span class="Li">&quot;code&quot;</span>,
    <span class="Li">&quot;upper&quot;</span>, etc., but will contain only
    locale keys.</p>
<p class="Pp">For more information about case mappings see
    &lt;http://www.unicode.org/unicode/reports/tr21/&gt;</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>namedseq()</b></h2>
<pre>    use Unicode::UCD 'namedseq';
    my $namedseq = namedseq(&quot;KATAKANA LETTER AINU P&quot;);
    my @namedseq = namedseq(&quot;KATAKANA LETTER AINU P&quot;);
    my %namedseq = namedseq();
</pre>
<p class="Pp">If used with a single argument in a scalar context, returns the
    string consisting of the code points of the named sequence, or
    <span class="Li">&quot;undef&quot;</span> if no named sequence by that name
    exists. If used with a single argument in a list context, it returns the
    list of the ordinals of the code points.</p>
<p class="Pp">If used with no arguments in a list context, it returns a hash
    with the names of all the named sequences as the keys and their sequences as
    strings as the values. Otherwise, it returns
    <span class="Li">&quot;undef&quot;</span> or an empty list depending on the
    context.</p>
<p class="Pp">This function only operates on officially approved (not
    provisional) named sequences.</p>
<p class="Pp">Note that as of Perl 5.14, <span class="Li">&quot;\N{KATAKANA
    LETTER AINU P}&quot;</span> will insert the named sequence into
    double-quoted strings, and
    <span class="Li">&quot;charnames::string_vianame(&quot;KATAKANA</span>
    <span class="Li">LETTER AINU P&quot;)&quot;</span> will return the same
    string this function does, but will also operate on character names that
    aren't named sequences, without you having to know which are which. See
    charnames.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>num()</b></h2>
<pre>    use Unicode::UCD 'num';
    my $val = num(&quot;123&quot;);
    my $one_quarter = num(&quot;\N{VULGAR FRACTION 1/4}&quot;);
    my $val = num(&quot;12a&quot;, \$valid_length);  # $valid_length contains 2
</pre>
<p class="Pp"><span class="Li">&quot;num()&quot;</span> returns the numeric
    value of the input Unicode string; or
    <span class="Li">&quot;undef&quot;</span> if it doesn't think the entire
    string has a completely valid, safe numeric value. If called with an
    optional second parameter, a reference to a scalar,
    <span class="Li">&quot;num()&quot;</span> will set the scalar to the length
    of any valid initial substring; or to 0 if none.</p>
<p class="Pp">If the string is just one character in length, the Unicode numeric
    value is returned if it has one, or
    <span class="Li">&quot;undef&quot;</span> otherwise. If the optional scalar
    ref is passed, it would be set to 1 if the return is valid; or 0 if the
    return is <span class="Li">&quot;undef&quot;</span>. Note that the numeric
    value returned need not be a whole number.
    <span class="Li">&quot;num(&quot;\N{TIBETAN DIGIT HALF
    ZERO}&quot;)&quot;</span>, for example returns -0.5.</p>
<p class="Pp">If the string is more than one character,
    <span class="Li">&quot;undef&quot;</span> is returned unless all its
    characters are decimal digits (that is, they would match
    <span class="Li">&quot;\d+&quot;</span>), from the same script. For example
    if you have an ASCII '0' and a Bengali '3', mixed together, they aren't
    considered a valid number, and <span class="Li">&quot;undef&quot;</span> is
    returned. A further restriction is that the digits all have to be of the
    same form. A half-width digit mixed with a full-width one will return
    <span class="Li">&quot;undef&quot;</span>. The Arabic script has two sets of
    digits; <span class="Li">&quot;num&quot;</span> will return
    <span class="Li">&quot;undef&quot;</span> unless all the digits in the
    string come from the same set. In all cases, the optional scalar ref
    parameter is set to how long any valid initial substring of digits is; hence
    it will be set to the entire string length if the main return value is not
    <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp"><span class="Li">&quot;num&quot;</span> errs on the side of
    safety, and there may be valid strings of decimal digits that it doesn't
    recognize. Note that Unicode defines a number of &quot;digit&quot;
    characters that aren't &quot;decimal digit&quot; characters. &quot;Decimal
    digits&quot; have the property that they have a positional value, i.e.,
    there is a units position, a 10's position, a 100's, etc, AND they are
    arranged in Unicode in blocks of 10 contiguous code points. The Chinese
    digits, for example, are not in such a contiguous block, and so Unicode
    doesn't view them as decimal digits, but merely digits, and so
    <span class="Li">&quot;\d&quot;</span> will not match them. A
    single-character string containing one of these digits will have its decimal
    value returned by <span class="Li">&quot;num&quot;</span>, but any longer
    string containing only these digits will return
    <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp">Strings of multiple sub- and superscripts are not recognized as
    numbers. You can use either of the compatibility decompositions in
    Unicode::Normalize to change these into digits, and then call
    <span class="Li">&quot;num&quot;</span> on the result.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>prop_aliases()</b></h2>
<pre>    use Unicode::UCD 'prop_aliases';
    my ($short_name, $full_name, @other_names) = prop_aliases(&quot;space&quot;);
    my $same_full_name = prop_aliases(&quot;Space&quot;);     # Scalar context
    my ($same_short_name) = prop_aliases(&quot;Space&quot;);  # gets 0th element
    print &quot;The full name is $full_name\n&quot;;
    print &quot;The short name is $short_name\n&quot;;
    print &quot;The other aliases are: &quot;, join(&quot;, &quot;, @other_names), &quot;\n&quot;;
    prints:
    The full name is White_Space
    The short name is WSpace
    The other aliases are: Space
</pre>
<p class="Pp">Most Unicode properties have several synonymous names. Typically,
    there is at least a short name, convenient to type, and a long name that
    more fully describes the property, and hence is more easily understood.</p>
<p class="Pp">If you know one name for a Unicode property, you can use
    <span class="Li">&quot;prop_aliases&quot;</span> to find either the long
    name (when called in scalar context), or a list of all of the names,
    somewhat ordered so that the short name is in the 0th element, the long name
    in the next element, and any other synonyms are in the remaining elements,
    in no particular order.</p>
<p class="Pp">The long name is returned in a form nicely capitalized, suitable
    for printing.</p>
<p class="Pp">The input parameter name is loosely matched, which means that
    white space, hyphens, and underscores are ignored (except for the trailing
    underscore in the old_form grandfathered-in
    <span class="Li">&quot;L_&quot;</span>, which is better written as
    <span class="Li">&quot;LC&quot;</span>, and both of which mean
    <span class="Li">&quot;General_Category=Cased Letter&quot;</span>).</p>
<p class="Pp">If the name is unknown, <span class="Li">&quot;undef&quot;</span>
    is returned (or an empty list in list context). Note that Perl typically
    recognizes property names in regular expressions with an optional
    <span class="Li">&quot;&quot;Is_&quot;</span>&quot; (with or without the
    underscore) prefixed to them, such as
    <span class="Li">&quot;\p{isgc=punct}&quot;</span>. This function does not
    recognize those in the input, returning
    <span class="Li">&quot;undef&quot;</span>. Nor are they included in the
    output as possible synonyms.</p>
<p class="Pp"><span class="Li">&quot;prop_aliases&quot;</span> does know about
    the Perl extensions to Unicode properties, such as
    <span class="Li">&quot;Any&quot;</span> and
    <span class="Li">&quot;XPosixAlpha&quot;</span>, and the single form
    equivalents to Unicode properties such as
    <span class="Li">&quot;XDigit&quot;</span>,
    <span class="Li">&quot;Greek&quot;</span>,
    <span class="Li">&quot;In_Greek&quot;</span>, and
    <span class="Li">&quot;Is_Greek&quot;</span>. The final example demonstrates
    that the <span class="Li">&quot;Is_&quot;</span> prefix is recognized for
    these extensions; it is needed to resolve ambiguities. For example,
    <span class="Li">&quot;prop_aliases('lc')&quot;</span> returns the list
    <span class="Li">&quot;(lc, Lowercase_Mapping)&quot;</span>, but
    <span class="Li">&quot;prop_aliases('islc')&quot;</span> returns
    <span class="Li">&quot;(Is_LC, Cased_Letter)&quot;</span>. This is because
    <span class="Li">&quot;islc&quot;</span> is a Perl extension which is short
    for <span class="Li">&quot;General_Category=Cased Letter&quot;</span>. The
    lists returned for the Perl extensions will not include the
    <span class="Li">&quot;Is_&quot;</span> prefix (whether or not the input had
    it) unless needed to resolve ambiguities, as shown in the
    <span class="Li">&quot;islc&quot;</span> example, where the returned list
    had one element containing <span class="Li">&quot;Is_&quot;</span>, and the
    other without.</p>
<p class="Pp">It is also possible for the reverse to happen:
    <span class="Li">&quot;prop_aliases('isc')&quot;</span> returns the list
    <span class="Li">&quot;(isc, ISO_Comment)&quot;</span>; whereas
    <span class="Li">&quot;prop_aliases('c')&quot;</span> returns
    <span class="Li">&quot;(C, Other)&quot;</span> (the latter being a Perl
    extension meaning
    <span class="Li">&quot;General_Category=Other&quot;</span>. &quot;Properties
    accessible through Unicode::UCD&quot; in perluniprops lists the available
    forms, including which ones are discouraged from use.</p>
<p class="Pp">Those discouraged forms are accepted as input to
    <span class="Li">&quot;prop_aliases&quot;</span>, but are not returned in
    the lists. <span class="Li">&quot;prop_aliases('isL&amp;')&quot;</span> and
    <span class="Li">&quot;prop_aliases('isL_')&quot;</span>, which are old
    synonyms for <span class="Li">&quot;Is_LC&quot;</span> and should not be
    used in new code, are examples of this. These both return
    <span class="Li">&quot;(Is_LC, Cased_Letter)&quot;</span>. Thus this
    function allows you to take a discouraged form, and find its acceptable
    alternatives. The same goes with single-form Block property equivalences.
    Only the forms that begin with <span class="Li">&quot;In_&quot;</span> are
    not discouraged; if you pass
    <span class="Li">&quot;prop_aliases&quot;</span> a discouraged form, you
    will get back the equivalent ones that begin with
    <span class="Li">&quot;In_&quot;</span>. It will otherwise look like a
    new-style block name (see. &quot;Old-style versus new-style block
    names&quot;).</p>
<p class="Pp"><span class="Li">&quot;prop_aliases&quot;</span> does not know
    about any user-defined properties, and will return
    <span class="Li">&quot;undef&quot;</span> if called with one of those.
    Likewise for Perl internal properties, with the exception of
    &quot;Perl_Decimal_Digit&quot; which it does know about (and which is
    documented below in &quot;<b>prop_invmap()</b>&quot;).</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>prop_values()</b></h2>
<pre>    use Unicode::UCD 'prop_values';
    print &quot;AHex values are: &quot;, join(&quot;, &quot;, prop_values(&quot;AHex&quot;)),
                               &quot;\n&quot;;
  prints:
    AHex values are: N, Y
</pre>
<p class="Pp">Some Unicode properties have a restricted set of legal values. For
    example, all binary properties are restricted to just
    <span class="Li">&quot;true&quot;</span> or
    <span class="Li">&quot;false&quot;</span>; and there are only a few dozen
    possible General Categories. Use
    <span class="Li">&quot;prop_values&quot;</span> to find out if a given
    property is one such, and if so, to get a list of the values:</p>
<p class="Pp"></p>
<pre>    print join &quot;, &quot;, prop_values(&quot;NFC_Quick_Check&quot;);
  prints:
    M, N, Y
</pre>
<p class="Pp">If the property doesn't have such a restricted set,
    <span class="Li">&quot;undef&quot;</span> is returned.</p>
<p class="Pp">There are usually several synonyms for each possible value. Use
    &quot;<b>prop_value_aliases()</b>&quot; to access those.</p>
<p class="Pp">Case, white space, hyphens, and underscores are ignored in the
    input property name (except for the trailing underscore in the old-form
    grandfathered-in general category property value
    <span class="Li">&quot;L_&quot;</span>, which is better written as
    <span class="Li">&quot;LC&quot;</span>).</p>
<p class="Pp">If the property name is unknown,
    <span class="Li">&quot;undef&quot;</span> is returned. Note that Perl
    typically recognizes property names in regular expressions with an optional
    <span class="Li">&quot;&quot;Is_&quot;</span>&quot; (with or without the
    underscore) prefixed to them, such as
    <span class="Li">&quot;\p{isgc=punct}&quot;</span>. This function does not
    recognize those in the property parameter, returning
    <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp">For the block property, new-style block names are returned (see
    &quot;Old-style versus new-style block names&quot;).</p>
<p class="Pp"><span class="Li">&quot;prop_values&quot;</span> does not know
    about any user-defined properties, and will return
    <span class="Li">&quot;undef&quot;</span> if called with one of those.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>prop_value_aliases()</b></h2>
<pre>    use Unicode::UCD 'prop_value_aliases';
    my ($short_name, $full_name, @other_names)
                                   = prop_value_aliases(&quot;Gc&quot;, &quot;Punct&quot;);
    my $same_full_name = prop_value_aliases(&quot;Gc&quot;, &quot;P&quot;);   # Scalar cntxt
    my ($same_short_name) = prop_value_aliases(&quot;Gc&quot;, &quot;P&quot;); # gets 0th
                                                           # element
    print &quot;The full name is $full_name\n&quot;;
    print &quot;The short name is $short_name\n&quot;;
    print &quot;The other aliases are: &quot;, join(&quot;, &quot;, @other_names), &quot;\n&quot;;
  prints:
    The full name is Punctuation
    The short name is P
    The other aliases are: Punct
</pre>
<p class="Pp">Some Unicode properties have a restricted set of legal values. For
    example, all binary properties are restricted to just
    <span class="Li">&quot;true&quot;</span> or
    <span class="Li">&quot;false&quot;</span>; and there are only a few dozen
    possible General Categories.</p>
<p class="Pp">You can use &quot;<b>prop_values()</b>&quot; to find out if a
    given property is one which has a restricted set of values, and if so, what
    those values are. But usually each value actually has several synonyms. For
    example, in Unicode binary properties, <i>truth</i> can be represented by
    any of the strings &quot;Y&quot;, &quot;Yes&quot;, &quot;T&quot;, or
    &quot;True&quot;; and the General Category &quot;Punctuation&quot; by that
    string, or &quot;Punct&quot;, or simply &quot;P&quot;.</p>
<p class="Pp">Like property names, there is typically at least a short name for
    each such property-value, and a long name. If you know any name of the
    property-value (which you can get by &quot;<b>prop_values()</b>&quot;, you
    can use <span class="Li">&quot;prop_value_aliases&quot;</span>() to get the
    long name (when called in scalar context), or a list of all the names, with
    the short name in the 0th element, the long name in the next element, and
    any other synonyms in the remaining elements, in no particular order, except
    that any all-numeric synonyms will be last.</p>
<p class="Pp">The long name is returned in a form nicely capitalized, suitable
    for printing.</p>
<p class="Pp">Case, white space, hyphens, and underscores are ignored in the
    input parameters (except for the trailing underscore in the old-form
    grandfathered-in general category property value
    <span class="Li">&quot;L_&quot;</span>, which is better written as
    <span class="Li">&quot;LC&quot;</span>).</p>
<p class="Pp">If either name is unknown,
    <span class="Li">&quot;undef&quot;</span> is returned. Note that Perl
    typically recognizes property names in regular expressions with an optional
    <span class="Li">&quot;&quot;Is_&quot;</span>&quot; (with or without the
    underscore) prefixed to them, such as
    <span class="Li">&quot;\p{isgc=punct}&quot;</span>. This function does not
    recognize those in the property parameter, returning
    <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp">If called with a property that doesn't have synonyms for its
    values, it returns the input value, possibly normalized with capitalization
    and underscores, but not necessarily checking that the input value is
  valid.</p>
<p class="Pp">For the block property, new-style block names are returned (see
    &quot;Old-style versus new-style block names&quot;).</p>
<p class="Pp">To find the synonyms for single-forms, such as
    <span class="Li">&quot;\p{Any}&quot;</span>, use
    &quot;<b>prop_aliases()</b>&quot; instead.</p>
<p class="Pp"><span class="Li">&quot;prop_value_aliases&quot;</span> does not
    know about any user-defined properties, and will return
    <span class="Li">&quot;undef&quot;</span> if called with one of those.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>prop_invlist()</b></h2>
<p class="Pp"><span class="Li">&quot;prop_invlist&quot;</span> returns an
    inversion list (described below) that defines all the code points for the
    binary Unicode property (or &quot;property=value&quot; pair) given by the
    input parameter string:</p>
<p class="Pp"></p>
<pre> use feature 'say';
 use Unicode::UCD 'prop_invlist';
 say join &quot;, &quot;, prop_invlist(&quot;Any&quot;);
 prints:
 0, 1114112
</pre>
<p class="Pp">If the input is unknown <span class="Li">&quot;undef&quot;</span>
    is returned in scalar context; an empty-list in list context. If the input
    is known, the number of elements in the list is returned if called in scalar
    context.</p>
<p class="Pp">perluniprops gives the list of properties that this function
    accepts, as well as all the possible forms for them (including with the
    optional &quot;Is_&quot; prefixes). (Except this function doesn't accept any
    Perl-internal properties, some of which are listed there.) This function
    uses the same loose or tighter matching rules for resolving the input
    property's name as is done for regular expressions. These are also specified
    in perluniprops. Examples of using the &quot;property=value&quot; form
  are:</p>
<p class="Pp"></p>
<pre> say join &quot;, &quot;, prop_invlist(&quot;Script_Extensions=Shavian&quot;);
 prints:
 66640, 66688
 say join &quot;, &quot;, prop_invlist(&quot;ASCII_Hex_Digit=No&quot;);
 prints:
 0, 48, 58, 65, 71, 97, 103
 say join &quot;, &quot;, prop_invlist(&quot;ASCII_Hex_Digit=Yes&quot;);
 prints:
 48, 58, 65, 71, 97, 103
</pre>
<p class="Pp">Inversion lists are a compact way of specifying Unicode
    property-value definitions. The 0th item in the list is the lowest code
    point that has the property-value. The next item (item [1]) is the lowest
    code point beyond that one that does NOT have the property-value. And the
    next item beyond that ([2]) is the lowest code point beyond that one that
    does have the property-value, and so on. Put another way, each element in
    the list gives the beginning of a range that has the property-value (for
    even numbered elements), or doesn't have the property-value (for odd
    numbered elements). The name for this data structure stems from the fact
    that each element in the list toggles (or inverts) whether the corresponding
    range is or isn't on the list.</p>
<p class="Pp">In the final example above, the first ASCII Hex digit is code
    point 48, the character &quot;0&quot;, and all code points from it through
    57 (a &quot;9&quot;) are ASCII hex digits. Code points 58 through 64 aren't,
    but 65 (an &quot;A&quot;) through 70 (an &quot;F&quot;) are, as are 97
    (&quot;a&quot;) through 102 (&quot;f&quot;). 103 starts a range of code
    points that aren't ASCII hex digits. That range extends to infinity, which
    on your computer can be found in the variable
    <span class="Li">$Unicode::UCD::MAX_CP</span>. (This variable is as close to
    infinity as Perl can get on your platform, and may be too high for some
    operations to work; you may wish to use a smaller number for your
  purposes.)</p>
<p class="Pp">Note that the inversion lists returned by this function can
    possibly include non-Unicode code points, that is anything above 0x10FFFF.
    Unicode properties are not defined on such code points. You might wish to
    change the output to not include these. Simply add 0x110000 at the end of
    the non-empty returned list if it isn't already that value; and pop that
    value if it is; like:</p>
<p class="Pp"></p>
<pre> my @list = prop_invlist(&quot;foo&quot;);
 if (@list) {
     if ($list[-1] == 0x110000) {
         pop @list;  # Defeat the turning on for above Unicode
     }
     else {
         push @list, 0x110000; # Turn off for above Unicode
     }
 }
</pre>
<p class="Pp">It is a simple matter to expand out an inversion list to a full
    list of all code points that have the property-value:</p>
<p class="Pp"></p>
<pre> my @invlist = prop_invlist($property_name);
 die &quot;empty&quot; unless @invlist;
 my @full_list;
 for (my $i = 0; $i &lt; @invlist; $i += 2) {
    my $upper = ($i + 1) &lt; @invlist
                ? $invlist[$i+1] - 1      # In range
                : $Unicode::UCD::MAX_CP;  # To infinity.
    for my $j ($invlist[$i] .. $upper) {
        push @full_list, $j;
    }
 }
</pre>
<p class="Pp"><span class="Li">&quot;prop_invlist&quot;</span> does not know
    about any user-defined nor Perl internal-only properties, and will return
    <span class="Li">&quot;undef&quot;</span> if called with one of those.</p>
<p class="Pp">The &quot;<b>search_invlist()</b>&quot; function is provided for
    finding a code point within an inversion list.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>prop_invmap()</b></h2>
<pre> use Unicode::UCD 'prop_invmap';
 my ($list_ref, $map_ref, $format, $default)
                                      = prop_invmap(&quot;General Category&quot;);
</pre>
<p class="Pp"><span class="Li">&quot;prop_invmap&quot;</span> is used to get the
    complete mapping definition for a property, in the form of an inversion map.
    An inversion map consists of two parallel arrays. One is an ordered list of
    code points that mark range beginnings, and the other gives the value (or
    mapping) that all code points in the corresponding range have.</p>
<p class="Pp"><span class="Li">&quot;prop_invmap&quot;</span> is called with the
    name of the desired property. The name is loosely matched, meaning that
    differences in case, white-space, hyphens, and underscores are not
    meaningful (except for the trailing underscore in the old-form
    grandfathered-in property <span class="Li">&quot;L_&quot;</span>, which is
    better written as <span class="Li">&quot;LC&quot;</span>, or even better,
    <span class="Li">&quot;Gc=LC&quot;</span>).</p>
<p class="Pp">Many Unicode properties have more than one name (or alias).
    <span class="Li">&quot;prop_invmap&quot;</span> understands all of these,
    including Perl extensions to them. Ambiguities are resolved as described
    above for &quot;<b>prop_aliases()</b>&quot; (except if a property has both a
    complete mapping, and a binary
    <span class="Li">&quot;Y&quot;</span>/<span class="Li">&quot;N&quot;</span>
    mapping, then specifying the property name prefixed by
    <span class="Li">&quot;is&quot;</span> causes the binary one to be
    returned). The Perl internal property &quot;Perl_Decimal_Digit, described
    below, is also accepted. An empty list is returned if the property name is
    unknown. See &quot;Properties accessible through Unicode::UCD&quot; in
    perluniprops for the properties acceptable as inputs to this function.</p>
<p class="Pp">It is a fatal error to call this function except in list
  context.</p>
<p class="Pp">In addition to the two arrays that form the inversion map,
    <span class="Li">&quot;prop_invmap&quot;</span> returns two other values;
    one is a scalar that gives some details as to the format of the entries of
    the map array; the other is a default value, useful in maps whose format
    name begins with the letter <span class="Li">&quot;a&quot;</span>, as
    described below in its subsection; and for specialized purposes, such as
    converting to another data structure, described at the end of this main
    section.</p>
<p class="Pp">This means that <span class="Li">&quot;prop_invmap&quot;</span>
    returns a 4 element list. For example,</p>
<p class="Pp"></p>
<pre> my ($blocks_ranges_ref, $blocks_maps_ref, $format, $default)
                                                 = prop_invmap(&quot;Block&quot;);
</pre>
<p class="Pp">In this call, the two arrays will be populated as shown below (for
    Unicode 6.0):</p>
<p class="Pp"></p>
<pre> Index  @blocks_ranges  @blocks_maps
   0        0x0000      Basic Latin
   1        0x0080      Latin-1 Supplement
   2        0x0100      Latin Extended-A
   3        0x0180      Latin Extended-B
   4        0x0250      IPA Extensions
   5        0x02B0      Spacing Modifier Letters
   6        0x0300      Combining Diacritical Marks
   7        0x0370      Greek and Coptic
   8        0x0400      Cyrillic
  ...
 233        0x2B820     No_Block
 234        0x2F800     CJK Compatibility Ideographs Supplement
 235        0x2FA20     No_Block
 236        0xE0000     Tags
 237        0xE0080     No_Block
 238        0xE0100     Variation Selectors Supplement
 239        0xE01F0     No_Block
 240        0xF0000     Supplementary Private Use Area-A
 241        0x100000    Supplementary Private Use Area-B
 242        0x110000    No_Block
</pre>
<p class="Pp">The first line (with Index [0]) means that the value for code
    point 0 is &quot;Basic Latin&quot;. The entry &quot;0x0080&quot; in the
    <span class="Li">@blocks_ranges</span> column in the second line means that
    the value from the first line, &quot;Basic Latin&quot;, extends to all code
    points in the range from 0 up to but not including 0x0080, that is, through
    127. In other words, the code points from 0 to 127 are all in the
    &quot;Basic Latin&quot; block. Similarly, all code points in the range from
    0x0080 up to (but not including) 0x0100 are in the block named &quot;Latin-1
    Supplement&quot;, etc. (Notice that the return is the old-style block names;
    see &quot;Old-style versus new-style block names&quot;).</p>
<p class="Pp">The final line (with Index [242]) means that the value for all
    code points above the legal Unicode maximum code point have the value
    &quot;No_Block&quot;, which is the term Unicode uses for a non-existing
    block.</p>
<p class="Pp">The arrays completely specify the mappings for all possible code
    points. The final element in an inversion map returned by this function will
    always be for the range that consists of all the code points that aren't
    legal Unicode, but that are expressible on the platform. (That is, it starts
    with code point 0x110000, the first code point above the legal Unicode
    maximum, and extends to infinity.) The value for that range will be the same
    that any typical unassigned code point has for the specified property.
    (Certain unassigned code points are not &quot;typical&quot;; for example the
    non-character code points, or those in blocks that are to be written
    right-to-left. The above-Unicode range's value is not based on these
    atypical code points.) It could be argued that, instead of treating these as
    unassigned Unicode code points, the value for this range should be
    <span class="Li">&quot;undef&quot;</span>. If you wish, you can change the
    returned arrays accordingly.</p>
<p class="Pp">The maps for almost all properties are simple scalars that should
    be interpreted as-is. These values are those given in the Unicode-supplied
    data files, which may be inconsistent as to capitalization and as to which
    synonym for a property-value is given. The results may be normalized by
    using the &quot;<b>prop_value_aliases()</b>&quot; function.</p>
<p class="Pp">There are exceptions to the simple scalar maps. Some properties
    have some elements in their map list that are themselves lists of scalars;
    and some special strings are returned that are not to be interpreted as-is.
    Element [2] (placed into <span class="Li">$format</span> in the example
    above) of the returned four element list tells you if the map has any of
    these special elements or not, as follows:</p>
<dl class="Bl-tag">
  <dt><b></b><span class="Li"><b>&quot;s&quot;</b></span><b></b></dt>
  <dd>means all the elements of the map array are simple scalars, with no
      special elements. Almost all properties are like this, like the
      <span class="Li">&quot;block&quot;</span> example above.</dd>
  <dt><b></b><span class="Li"><b>&quot;sl&quot;</b></span><b></b></dt>
  <dd>means that some of the map array elements have the form given by
      <span class="Li">&quot;s&quot;</span>, and the rest are lists of scalars.
      For example, here is a portion of the output of calling
      <span class="Li">&quot;prop_invmap&quot;</span>() with the &quot;Script
      Extensions&quot; property:
    <p class="Pp"></p>
    <pre> @scripts_ranges  @scripts_maps
      ...
      0x0953      Devanagari
      0x0964      [ Bengali, Devanagari, Gurumukhi, Oriya ]
      0x0966      Devanagari
      0x0970      Common
    </pre>
    <p class="Pp">Here, the code points 0x964 and 0x965 are both used in
        Bengali, Devanagari, Gurmukhi, and Oriya, but no other scripts.</p>
    <p class="Pp">The Name_Alias property is also of this form. But each scalar
        consists of two components: 1) the name, and 2) the type of alias this
        is. They are separated by a colon and a space. In Unicode 6.1, there are
        several alias types:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>&quot;correction&quot;</dt>
  <dd>indicates that the name is a corrected form for the original name (which
      remains valid) for the same code point.</dd>
  <dt>&quot;control&quot;</dt>
  <dd>adds a new name for a control character.</dd>
  <dt>&quot;alternate&quot;</dt>
  <dd>is an alternate name for a character</dd>
  <dt>&quot;figment&quot;</dt>
  <dd>is a name for a character that has been documented but was never in any
      actual standard.</dd>
  <dt>&quot;abbreviation&quot;</dt>
  <dd>is a common abbreviation for a character</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">The lists are ordered (roughly) so the most preferred names come
    before less preferred ones.</p>
<p class="Pp">For example,</p>
<p class="Pp"></p>
<pre> @aliases_ranges        @alias_maps
    ...
    0x009E        [ 'PRIVACY MESSAGE: control', 'PM: abbreviation' ]
    0x009F        [ 'APPLICATION PROGRAM COMMAND: control',
                    'APC: abbreviation'
                  ]
    0x00A0        'NBSP: abbreviation'
    0x00A1        &quot;&quot;
    0x00AD        'SHY: abbreviation'
    0x00AE        &quot;&quot;
    0x01A2        'LATIN CAPITAL LETTER GHA: correction'
    0x01A3        'LATIN SMALL LETTER GHA: correction'
    0x01A4        &quot;&quot;
    ...
</pre>
<p class="Pp">A map to the empty string means that there is no alias defined for
    the code point.</p>
</div>
<dl class="Bl-tag">
  <dt><b></b><span class="Li"><b>&quot;a&quot;</b></span><b></b></dt>
  <dd>is like <span class="Li">&quot;s&quot;</span> in that all the map array
      elements are scalars, but here they are restricted to all being integers,
      and some have to be adjusted (hence the name
      <span class="Li">&quot;a&quot;</span>) to get the correct result. For
      example, in:
    <p class="Pp"></p>
    <pre> my ($uppers_ranges_ref, $uppers_maps_ref, $format, $default)
                          = prop_invmap(&quot;Simple_Uppercase_Mapping&quot;);
    </pre>
    <p class="Pp">the returned arrays look like this:</p>
    <p class="Pp"></p>
    <pre> @$uppers_ranges_ref    @$uppers_maps_ref   Note
       0                      0
      97                     65          'a' maps to 'A', b =&gt; B ...
     123                      0
     181                    924          MICRO SIGN =&gt; Greek Cap MU
     182                      0
     ...
    </pre>
    <p class="Pp">and <span class="Li">$default</span> is 0.</p>
    <p class="Pp">Let's start with the second line. It says that the uppercase
        of code point 97 is 65; or
        <span class="Li">&quot;uc(&quot;a&quot;)&quot;</span> == &quot;A&quot;.
        But the line is for the entire range of code points 97 through 122. To
        get the mapping for any code point in this range, you take the offset it
        has from the beginning code point of the range, and add that to the
        mapping for that first code point. So, the mapping for 122
        (&quot;z&quot;) is derived by taking the offset of 122 from 97 (=25) and
        adding that to 65, yielding 90 (&quot;z&quot;). Likewise for everything
        in between.</p>
    <p class="Pp">Requiring this simple adjustment allows the returned arrays to
        be significantly smaller than otherwise, up to a factor of 10, speeding
        up searching through them.</p>
    <p class="Pp">Ranges that map to <span class="Li">$default</span>,
        <span class="Li">&quot;0&quot;</span>, behave somewhat differently. For
        these, each code point maps to itself. So, in the first line in the
        example, <span class="Li">&quot;ord(uc(chr(0)))&quot;</span> is 0,
        <span class="Li">&quot;ord(uc(chr(1)))&quot;</span> is 1, ..
        <span class="Li">&quot;ord(uc(chr(96)))&quot;</span> is 96.</p>
  </dd>
  <dt><b></b><span class="Li"><b>&quot;al&quot;</b></span><b></b></dt>
  <dd>means that some of the map array elements have the form given by
      <span class="Li">&quot;a&quot;</span>, and the rest are ordered lists of
      code points. For example, in:
    <p class="Pp"></p>
    <pre> my ($uppers_ranges_ref, $uppers_maps_ref, $format, $default)
                                 = prop_invmap(&quot;Uppercase_Mapping&quot;);
    </pre>
    <p class="Pp">the returned arrays look like this:</p>
    <p class="Pp"></p>
    <pre> @$uppers_ranges_ref    @$uppers_maps_ref
       0                      0
      97                     65
     123                      0
     181                    924
     182                      0
     ...
    0x0149              [ 0x02BC 0x004E ]
    0x014A                    0
    0x014B                  330
     ...
    </pre>
    <p class="Pp">This is the full Uppercase_Mapping property (as opposed to the
        Simple_Uppercase_Mapping given in the example for format
        <span class="Li">&quot;a&quot;</span>). The only difference between the
        two in the ranges shown is that the code point at 0x0149 (LATIN SMALL
        LETTER N PRECEDED BY APOSTROPHE) maps to a string of two characters,
        0x02BC (MODIFIER LETTER APOSTROPHE) followed by 0x004E (LATIN CAPITAL
        LETTER N).</p>
    <p class="Pp">No adjustments are needed to entries that are references to
        arrays; each such entry will have exactly one element in its range, so
        the offset is always 0.</p>
    <p class="Pp">The fourth (index [3]) element
        (<span class="Li">$default</span>) in the list returned for this format
        is 0.</p>
  </dd>
  <dt><b></b><span class="Li"><b>&quot;ae&quot;</b></span><b></b></dt>
  <dd>This is like <span class="Li">&quot;a&quot;</span>, but some elements are
      the empty string, and should not be adjusted. The one internal Perl
      property accessible by <span class="Li">&quot;prop_invmap&quot;</span> is
      of this type: &quot;Perl_Decimal_Digit&quot; returns an inversion map
      which gives the numeric values that are represented by the Unicode decimal
      digit characters. Characters that don't represent decimal digits map to
      the empty string, like so:
    <p class="Pp"></p>
    <pre> @digits    @values
 0x0000       &quot;&quot;
 0x0030        0
 0x003A:      &quot;&quot;
 0x0660:       0
 0x066A:      &quot;&quot;
 0x06F0:       0
 0x06FA:      &quot;&quot;
 0x07C0:       0
 0x07CA:      &quot;&quot;
 0x0966:       0
 ...
    </pre>
    <p class="Pp">This means that the code points from 0 to 0x2F do not
        represent decimal digits; the code point 0x30 (DIGIT ZERO) represents 0;
        code point 0x31, (DIGIT ONE), represents 0+1-0 = 1; ... code point 0x39,
        (DIGIT NINE), represents 0+9-0 = 9; ... code points 0x3A through 0x65F
        do not represent decimal digits; 0x660 (ARABIC-INDIC DIGIT ZERO),
        represents 0; ... 0x07C1 (NKO DIGIT ONE), represents 0+1-0 = 1 ...</p>
    <p class="Pp">The fourth (index [3]) element
        (<span class="Li">$default</span>) in the list returned for this format
        is the empty string.</p>
  </dd>
  <dt><b></b><span class="Li"><b>&quot;ale&quot;</b></span><b></b></dt>
  <dd>is a combination of the <span class="Li">&quot;al&quot;</span> type and
      the <span class="Li">&quot;ae&quot;</span> type. Some of the map array
      elements have the forms given by <span class="Li">&quot;al&quot;</span>,
      and the rest are the empty string. The property
      <span class="Li">&quot;NFKC_Casefold&quot;</span> has this form. An
      example slice is:
    <p class="Pp"></p>
    <pre> @$ranges_ref  @$maps_ref         Note
    ...
   0x00AA       97                FEMININE ORDINAL INDICATOR =&gt; 'a'
   0x00AB        0
   0x00AD                         SOFT HYPHEN =&gt; &quot;&quot;
   0x00AE        0
   0x00AF     [ 0x0020, 0x0304 ]  MACRON =&gt; SPACE . COMBINING MACRON
   0x00B0        0
   ...
    </pre>
    <p class="Pp">The fourth (index [3]) element
        (<span class="Li">$default</span>) in the list returned for this format
        is 0.</p>
  </dd>
  <dt><b></b><span class="Li"><b>&quot;ar&quot;</b></span><b></b></dt>
  <dd>means that all the elements of the map array are either rational numbers
      or the string <span class="Li">&quot;NaN&quot;</span>, meaning &quot;Not a
      Number&quot;. A rational number is either an integer, or two integers
      separated by a solidus (<span class="Li">&quot;/&quot;</span>). The second
      integer represents the denominator of the division implied by the solidus,
      and is actually always positive, so it is guaranteed not to be 0 and to
      not be signed. When the element is a plain integer (without the solidus),
      it may need to be adjusted to get the correct value by adding the offset,
      just as other <span class="Li">&quot;a&quot;</span> properties. No
      adjustment is needed for fractions, as the range is guaranteed to have
      just a single element, and so the offset is always 0.
    <p class="Pp">If you want to convert the returned map to entirely scalar
        numbers, you can use something like this:</p>
    <p class="Pp"></p>
    <pre> my ($invlist_ref, $invmap_ref, $format) = prop_invmap($property);
 if ($format &amp;&amp; $format eq &quot;ar&quot;) {
     map { $_ = eval $_ if $_ ne 'NaN' } @$map_ref;
 }
    </pre>
    <p class="Pp">Here's some entries from the output of the property
        &quot;Nv&quot;, which has format
      <span class="Li">&quot;ar&quot;</span>.</p>
    <p class="Pp"></p>
    <pre> @numerics_ranges  @numerics_maps       Note
        0x00           &quot;NaN&quot;
        0x30             0           DIGIT 0 .. DIGIT 9
        0x3A           &quot;NaN&quot;
        0xB2             2           SUPERSCRIPTs 2 and 3
        0xB4           &quot;NaN&quot;
        0xB9             1           SUPERSCRIPT 1
        0xBA           &quot;NaN&quot;
        0xBC            1/4          VULGAR FRACTION 1/4
        0xBD            1/2          VULGAR FRACTION 1/2
        0xBE            3/4          VULGAR FRACTION 3/4
        0xBF           &quot;NaN&quot;
        0x660            0           ARABIC-INDIC DIGIT ZERO .. NINE
        0x66A          &quot;NaN&quot;
    </pre>
    <p class="Pp">The fourth (index [3]) element
        (<span class="Li">$default</span>) in the list returned for this format
        is <span class="Li">&quot;NaN&quot;</span>.</p>
  </dd>
  <dt><b></b><span class="Li"><b>&quot;n&quot;</b></span><b></b></dt>
  <dd>means the Name property. All the elements of the map array are simple
      scalars, but some of them contain special strings that require more work
      to get the actual name.
    <p class="Pp">Entries such as:</p>
    <p class="Pp"></p>
    <pre> CJK UNIFIED IDEOGRAPH-&lt;code point&gt;
    </pre>
    <p class="Pp">mean that the name for the code point is &quot;CJK UNIFIED
        IDEOGRAPH-&quot; with the code point (expressed in hexadecimal) appended
        to it, like &quot;CJK UNIFIED IDEOGRAPH-3403&quot; (similarly for
        <span class="Li">&quot;CJK&#x00A0;COMPATIBILITY&#x00A0;IDEOGRAPH-&lt;code&#x00A0;point&gt;&quot;</span>).</p>
    <p class="Pp">Also, entries like</p>
    <p class="Pp"></p>
    <pre> &lt;hangul syllable&gt;
    </pre>
    <p class="Pp">means that the name is algorithmically calculated. This is
        easily done by the function &quot;charnames::viacode(code)&quot; in
        charnames.</p>
    <p class="Pp">Note that for control characters
        (<span class="Li">&quot;Gc=cc&quot;</span>), Unicode's data files have
        the string
        &quot;<span class="Li">&quot;&lt;control&gt;&quot;</span>&quot;, but the
        real name of each of these characters is the empty string. This function
        returns that real name, the empty string. (There are names for these
        characters, but they are considered aliases, not the Name property name,
        and are contained in the <span class="Li">&quot;Name_Alias&quot;</span>
        property.)</p>
  </dd>
  <dt><b></b><span class="Li"><b>&quot;ad&quot;</b></span><b></b></dt>
  <dd>means the Decomposition_Mapping property. This property is like
      <span class="Li">&quot;al&quot;</span> properties, except that one of the
      scalar elements is of the form:
    <p class="Pp"></p>
    <pre> &lt;hangul syllable&gt;
    </pre>
    <p class="Pp">This signifies that this entry should be replaced by the
        decompositions for all the code points whose decomposition is
        algorithmically calculated. (All of them are currently in one range and
        no others outside the range are likely to ever be added to Unicode; the
        <span class="Li">&quot;n&quot;</span> format has this same entry.) These
        can be generated via the function <b>Unicode::Normalize::NFD()</b>.</p>
    <p class="Pp">Note that the mapping is the one that is specified in the
        Unicode data files, and to get the final decomposition, it may need to
        be applied recursively. Unicode in fact discourages use of this property
        except internally in implementations of the Unicode Normalization
        Algorithm.</p>
    <p class="Pp">The fourth (index [3]) element
        (<span class="Li">$default</span>) in the list returned for this format
        is 0.</p>
  </dd>
</dl>
<p class="Pp">Note that a format begins with the letter &quot;a&quot; if and
    only the property it is for requires adjustments by adding the offsets in
    multi-element ranges. For all these properties, an entry should be adjusted
    only if the map is a scalar which is an integer. That is, it must match the
    regular expression:</p>
<p class="Pp"></p>
<pre>    / ^ -? \d+ $ /xa
</pre>
<p class="Pp">Further, the first element in a range never needs adjustment, as
    the adjustment would be just adding 0.</p>
<p class="Pp">A binary search such as that provided by
    &quot;<b>search_invlist()</b>&quot;, can be used to quickly find a code
    point in the inversion list, and hence its corresponding mapping.</p>
<p class="Pp">The final, fourth element (index [3], assigned to
    <span class="Li">$default</span> in the &quot;block&quot; example) in the
    four element list returned by this function is used with the
    <span class="Li">&quot;a&quot;</span> format types; it may also be useful
    for applications that wish to convert the returned inversion map data
    structure into some other, such as a hash. It gives the mapping that most
    code points map to under the property. If you establish the convention that
    any code point not explicitly listed in your data structure maps to this
    value, you can potentially make your data structure much smaller. As you
    construct your data structure from the one returned by this function, simply
    ignore those ranges that map to this value. For example, to convert to the
    data structure searchable by &quot;<b>charinrange()</b>&quot;, you can
    follow this recipe for properties that don't require adjustments:</p>
<p class="Pp"></p>
<pre> my ($list_ref, $map_ref, $format, $default) = prop_invmap($property);
 my @range_list;
 # Look at each element in the list, but the -2 is needed because we
 # look at $i+1 in the loop, and the final element is guaranteed to map
 # to $default by prop_invmap(), so we would skip it anyway.
 for my $i (0 .. @$list_ref - 2) {
    next if $map_ref-&gt;[$i] eq $default;
    push @range_list, [ $list_ref-&gt;[$i],
                        $list_ref-&gt;[$i+1],
                        $map_ref-&gt;[$i]
                      ];
 }
 print charinrange(\@range_list, $code_point), &quot;\n&quot;;
</pre>
<p class="Pp">With this, <span class="Li">&quot;charinrange()&quot;</span> will
    return <span class="Li">&quot;undef&quot;</span> if its input code point
    maps to <span class="Li">$default</span>. You can avoid this by omitting the
    <span class="Li">&quot;next&quot;</span> statement, and adding a line after
    the loop to handle the final element of the inversion map.</p>
<p class="Pp">Similarly, this recipe can be used for properties that do require
    adjustments:</p>
<p class="Pp"></p>
<pre> for my $i (0 .. @$list_ref - 2) {
    next if $map_ref-&gt;[$i] eq $default;
    # prop_invmap() guarantees that if the mapping is to an array, the
    # range has just one element, so no need to worry about adjustments.
    if (ref $map_ref-&gt;[$i]) {
        push @range_list,
                   [ $list_ref-&gt;[$i], $list_ref-&gt;[$i], $map_ref-&gt;[$i] ];
    }
    else {  # Otherwise each element is actually mapped to a separate
            # value, so the range has to be split into single code point
            # ranges.
        my $adjustment = 0;
        # For each code point that gets mapped to something...
        for my $j ($list_ref-&gt;[$i] .. $list_ref-&gt;[$i+1] -1 ) {
            # ... add a range consisting of just it mapping to the
            # original plus the adjustment, which is incremented for the
            # next time through the loop, as the offset increases by 1
            # for each element in the range
            push @range_list,
                             [ $j, $j, $map_ref-&gt;[$i] + $adjustment++ ];
        }
    }
 }
</pre>
<p class="Pp">Note that the inversion maps returned for the
    <span class="Li">&quot;Case_Folding&quot;</span> and
    <span class="Li">&quot;Simple_Case_Folding&quot;</span> properties do not
    include the Turkic-locale mappings. Use &quot;<b>casefold()</b>&quot; for
    these.</p>
<p class="Pp"><span class="Li">&quot;prop_invmap&quot;</span> does not know
    about any user-defined properties, and will return
    <span class="Li">&quot;undef&quot;</span> if called with one of those.</p>
<p class="Pp">The returned values for the Perl extension properties, such as
    <span class="Li">&quot;Any&quot;</span> and
    <span class="Li">&quot;Greek&quot;</span> are somewhat misleading. The
    values are either <span class="Li">&quot;Y&quot;</span> or
    <span class="Li">&quot;&quot;N&quot;</span>&quot;. All Unicode properties
    are bipartite, so you can actually use the
    <span class="Li">&quot;Y&quot;</span> or
    <span class="Li">&quot;&quot;N&quot;</span>&quot; in a Perl regular
    expression for these, like
    <span class="Li">&quot;qr/\p{ID_Start=Y/}&quot;</span> or
    <span class="Li">&quot;qr/\p{Upper=N/}&quot;</span>. But the Perl extensions
    aren't specified this way, only like
    <span class="Li">&quot;/qr/\p{Any}&quot;</span>, <i>etc</i>. You can't
    actually use the <span class="Li">&quot;Y&quot;</span> and
    <span class="Li">&quot;&quot;N&quot;</span>&quot; in them.</p>
<p class="Pp"><i>Getting every available name</i></p>
<p class="Pp">Instead of reading the Unicode Database directly from files, as
    you were able to do for a long time, you are encouraged to use the supplied
    functions. So, instead of reading
    <span class="Li">&quot;Name.pl&quot;</span> directly, which changed formats
    in 5.32, and may do so again without notice in the future or even disappear,
    you ought to use &quot;<b>prop_invmap()</b>&quot; like this:</p>
<p class="Pp"></p>
<pre>  my (%name, %cp, %cps, $n);
  # All codepoints
  foreach my $cat (qw( Name Name_Alias )) {
      my ($codepoints, $names, $format, $default) = prop_invmap($cat);
      # $format =&gt; &quot;n&quot;, $default =&gt; &quot;&quot;
      foreach my $i (0 .. @$codepoints - 2) {
          my ($cp, $n) = ($codepoints-&gt;[$i], $names-&gt;[$i]);
          # If $n is a ref, the same codepoint has multiple names
          foreach my $name (ref $n ? @$n : $n) {
              $name{$cp} //= $name;
              $cp{$name} //= $cp;
          }
      }
  }
  # Named sequences
  {   my %ns = namedseq();
      foreach my $name (sort { $ns{$a} cmp $ns{$b} } keys %ns) {
          $cp{$name} //= [ map { ord } split &quot;&quot; =&gt; $ns{$name} ];
      }
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss"><b>search_invlist()</b></h2>
<pre> use Unicode::UCD qw(prop_invmap prop_invlist);
 use Unicode::UCD 'search_invlist';
 my @invlist = prop_invlist($property_name);
 print $code_point, ((search_invlist(\@invlist, $code_point) // -1) % 2)
                     ? &quot; isn't&quot;
                     : &quot; is&quot;,
     &quot; in $property_name\n&quot;;
 my ($blocks_ranges_ref, $blocks_map_ref) = prop_invmap(&quot;Block&quot;);
 my $index = search_invlist($blocks_ranges_ref, $code_point);
 print &quot;$code_point is in block &quot;, $blocks_map_ref-&gt;[$index], &quot;\n&quot;;
</pre>
<p class="Pp"><span class="Li">&quot;search_invlist&quot;</span> is used to
    search an inversion list returned by
    <span class="Li">&quot;prop_invlist&quot;</span> or
    <span class="Li">&quot;prop_invmap&quot;</span> for a particular &quot;code
    point argument&quot;. <span class="Li">&quot;undef&quot;</span> is returned
    if the code point is not found in the inversion list (this happens only when
    it is not a legal &quot;code point argument&quot;, or is less than the
    list's first element). A warning is raised in the first instance.</p>
<p class="Pp">Otherwise, it returns the index into the list of the range that
    contains the code point.; that is, find
    <span class="Li">&quot;i&quot;</span> such that</p>
<p class="Pp"></p>
<pre>    list[i]&lt;= code_point &lt; list[i+1].
</pre>
<p class="Pp">As explained in &quot;<b>prop_invlist()</b>&quot;, whether a code
    point is in the list or not depends on if the index is even (in) or odd (not
    in). And as explained in &quot;<b>prop_invmap()</b>&quot;, the index is used
    with the returned parallel array to find the mapping.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Unicode::UCD::UnicodeVersion"><a class="permalink" href="#Unicode::UCD::UnicodeVersion">Unicode::UCD::UnicodeVersion</a></h2>
<p class="Pp">This returns the version of the Unicode Character Database, in
    other words, the version of the Unicode standard the database implements.
    The version is a string of numbers delimited by dots
    (<span class="Li">'.'</span>).</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>Blocks versus Scripts</b></h2>
<p class="Pp">The difference between a block and a script is that scripts are
    closer to the linguistic notion of a set of code points required to
    represent languages, while block is more of an artifact of the Unicode code
    point numbering and separation into blocks of consecutive code points (so
    far the size of a block is some multiple of 16, like 128 or 256).</p>
<p class="Pp">For example the Latin <b>script</b> is spread over several
    <b>blocks</b>, such as <span class="Li">&quot;Basic Latin&quot;</span>,
    <span class="Li">&quot;Latin 1 Supplement&quot;</span>,
    <span class="Li">&quot;Latin Extended-A&quot;</span>, and
    <span class="Li">&quot;Latin Extended-B&quot;</span>. On the other hand, the
    Latin script does not contain all the characters of the
    <span class="Li">&quot;Basic Latin&quot;</span> block (also known as ASCII):
    it includes only the letters, and not, for example, the digits nor the
    punctuation.</p>
<p class="Pp">For blocks see
    &lt;http://www.unicode.org/Public/UNIDATA/Blocks.txt&gt;</p>
<p class="Pp">For scripts see UTR #24:
    &lt;http://www.unicode.org/unicode/reports/tr24/&gt;</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>Matching Scripts and Blocks</b></h2>
<p class="Pp">Scripts are matched with the regular-expression construct
    <span class="Li">&quot;\p{...}&quot;</span> (e.g.
    <span class="Li">&quot;\p{Tibetan}&quot;</span> matches characters of the
    Tibetan script), while <span class="Li">&quot;\p{Blk=...}&quot;</span> is
    used for blocks (e.g. <span class="Li">&quot;\p{Blk=Tibetan}&quot;</span>
    matches any of the 256 code points in the Tibetan block).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Old-style_versus_new-style_block_names"><a class="permalink" href="#Old-style_versus_new-style_block_names">Old-style
  versus new-style block names</a></h2>
<p class="Pp">Unicode publishes the names of blocks in two different styles,
    though the two are equivalent under Unicode's loose matching rules.</p>
<p class="Pp">The original style uses blanks and hyphens in the block names
    (except for <span class="Li">&quot;No_Block&quot;</span>), like so:</p>
<p class="Pp"></p>
<pre> Miscellaneous Mathematical Symbols-B
</pre>
<p class="Pp">The newer style replaces these with underscores, like this:</p>
<p class="Pp"></p>
<pre> Miscellaneous_Mathematical_Symbols_B
</pre>
<p class="Pp">This newer style is consistent with the values of other Unicode
    properties. To preserve backward compatibility, all the functions in
    Unicode::UCD that return block names (except as noted) return the old-style
    ones. &quot;<b>prop_value_aliases()</b>&quot; returns the new-style and can
    be used to convert from old-style to new-style:</p>
<p class="Pp"></p>
<pre> my $new_style = prop_values_aliases(&quot;block&quot;, $old_style);
</pre>
<p class="Pp">Perl also has single-form extensions that refer to blocks,
    <span class="Li">&quot;In_Cyrillic&quot;</span>, meaning
    <span class="Li">&quot;Block=Cyrillic&quot;</span>. These have always been
    written in the new style.</p>
<p class="Pp">To convert from new-style to old-style, follow this recipe:</p>
<p class="Pp"></p>
<pre> $old_style = charblock((prop_invlist(&quot;block=$new_style&quot;))[0]);
</pre>
<p class="Pp">(which finds the range of code points in the block using
    <span class="Li">&quot;prop_invlist&quot;</span>, gets the lower end of the
    range (0th element) and then looks up the old name for its block using
    <span class="Li">&quot;charblock&quot;</span>).</p>
<p class="Pp">Note that starting in Unicode 6.1, many of the block names have
    shorter synonyms. These are always given in the new style.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Use_with_older_Unicode_versions"><a class="permalink" href="#Use_with_older_Unicode_versions">Use
  with older Unicode versions</a></h2>
<p class="Pp">The functions in this module work as well as can be expected when
    used on earlier Unicode versions. But, obviously, they use the available
    data from that Unicode version. For example, if the Unicode version predates
    the definition of the script property (Unicode 3.1), then any function that
    deals with scripts is going to return
    <span class="Li">&quot;undef&quot;</span> for the script portion of the
    return value.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Jarkko Hietaniemi. Now maintained by perl5 porters.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os">perl v5.34.1</td>
  </tr>
</table>
</body>
</html>

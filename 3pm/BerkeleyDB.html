<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>BerkeleyDB(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">BerkeleyDB(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">BerkeleyDB(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">BerkeleyDB - Perl extension for Berkeley DB version 2, 3, 4 or
  5</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
  use BerkeleyDB;

  $env = new BerkeleyDB::Env [OPTIONS] ;

  $db  = tie %hash, 'BerkeleyDB::Hash', [OPTIONS] ;
  $db  = new BerkeleyDB::Hash [OPTIONS] ;

  $db  = tie %hash, 'BerkeleyDB::Btree', [OPTIONS] ;
  $db  = new BerkeleyDB::Btree [OPTIONS] ;

  $db  = tie @array, 'BerkeleyDB::Recno', [OPTIONS] ;
  $db  = new BerkeleyDB::Recno [OPTIONS] ;

  $db  = tie @array, 'BerkeleyDB::Queue', [OPTIONS] ;
  $db  = new BerkeleyDB::Queue [OPTIONS] ;

  $db  = new BerkeleyDB::Heap [OPTIONS] ;

  $db  = new BerkeleyDB::Unknown [OPTIONS] ;

  $status = BerkeleyDB::db_remove [OPTIONS]
  $status = BerkeleyDB::db_rename [OPTIONS]
  $status = BerkeleyDB::db_verify [OPTIONS]

  $hash{$key} = $value ;
  $value = $hash{$key} ;
  each %hash ;
  keys %hash ;
  values %hash ;

  $env = $db-&gt;Env()
  $status = $db-&gt;db_get()
  $status = $db-&gt;db_exists() ;
  $status = $db-&gt;db_put() ;
  $status = $db-&gt;db_del() ;
  $status = $db-&gt;db_sync() ;
  $status = $db-&gt;db_close() ;
  $status = $db-&gt;db_pget()
  $hash_ref = $db-&gt;db_stat() ;
  $status = $db-&gt;db_key_range();
  $type = $db-&gt;type() ;
  $status = $db-&gt;status() ;
  $boolean = $db-&gt;byteswapped() ;
  $status = $db-&gt;truncate($count) ;
  $status = $db-&gt;compact($start, $stop, $c_data, $flags, $end);
  $status = $db-&gt;get_blob_threshold($t1) ;
  $status = $db-&gt;get_blob_dir($dir) ;

  $bool = $env-&gt;cds_enabled();
  $bool = $db-&gt;cds_enabled();
  $lock = $db-&gt;cds_lock();
  $lock-&gt;cds_unlock();
  
  ($flag, $old_offset, $old_length) = $db-&gt;partial_set($offset, $length) ;
  ($flag, $old_offset, $old_length) = $db-&gt;partial_clear() ;

  $cursor = $db-&gt;db_cursor([$flags]) ;
  $newcursor = $cursor-&gt;c_dup([$flags]);
  $status = $cursor-&gt;c_get() ;
  $status = $cursor-&gt;c_put() ;
  $status = $cursor-&gt;c_del() ;
  $status = $cursor-&gt;c_count() ;
  $status = $cursor-&gt;c_pget() ;
  $status = $cursor-&gt;status() ;
  $status = $cursor-&gt;c_close() ;
  $stream = $cursor-&gt;db_stream() ;

  $cursor = $db-&gt;db_join() ;
  $status = $cursor-&gt;c_get() ;
  $status = $cursor-&gt;c_close() ;

  $status = $stream-&gt;size($S);
  $status = $stream-&gt;read($data, $offset, $size);
  $status = $stream-&gt;write($data, $offset);

  $status = $env-&gt;txn_checkpoint()
  $hash_ref = $env-&gt;txn_stat()
  $status = $env-&gt;set_mutexlocks()
  $status = $env-&gt;set_flags()
  $status = $env-&gt;set_timeout()
  $status = $env-&gt;lock_detect()
  $status = $env-&gt;lsn_reset()
  $status = $env-&gt;get_blob_threshold($t1) ;
  $status = $env-&gt;get_blob_dir($dir) ;

  $txn = $env-&gt;txn_begin() ;
  $db-&gt;Txn($txn);
  $txn-&gt;Txn($db1, $db2,...);
  $status = $txn-&gt;txn_prepare()
  $status = $txn-&gt;txn_commit()
  $status = $txn-&gt;txn_abort()
  $status = $txn-&gt;txn_id()
  $status = $txn-&gt;txn_discard()
  $status = $txn-&gt;set_timeout()

  $status = $env-&gt;set_lg_dir();
  $status = $env-&gt;set_lg_bsize();
  $status = $env-&gt;set_lg_max();

  $status = $env-&gt;set_data_dir() ;
  $status = $env-&gt;set_tmp_dir() ;
  $status = $env-&gt;set_verbose() ;
  $db_env_ptr = $env-&gt;DB_ENV() ;

  $BerkeleyDB::Error
  $BerkeleyDB::db_version

  # DBM Filters
  $old_filter = $db-&gt;filter_store_key  ( sub { ... } ) ;
  $old_filter = $db-&gt;filter_store_value( sub { ... } ) ;
  $old_filter = $db-&gt;filter_fetch_key  ( sub { ... } ) ;
  $old_filter = $db-&gt;filter_fetch_value( sub { ... } ) ;

  # deprecated, but supported
  $txn_mgr = $env-&gt;TxnMgr();
  $status = $txn_mgr-&gt;txn_checkpoint()
  $hash_ref = $txn_mgr-&gt;txn_stat()
  $txn = $txn_mgr-&gt;txn_begin() ;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><b>NOTE: This document is still under construction. Expect it to
    be</b> <b>incomplete in places.</b></p>
<p class="Pp">This Perl module provides an interface to most of the
    functionality available in Berkeley DB versions 2, 3, 5 and 6. In general it
    is safe to assume that the interface provided here to be identical to the
    Berkeley DB interface. The main changes have been to make the Berkeley DB
    API work in a Perl way. Note that if you are using Berkeley DB 2.x, the new
    features available in Berkeley DB 3.x or later are not available via this
    module.</p>
<p class="Pp">The reader is expected to be familiar with the Berkeley DB
    documentation. Where the interface provided here is identical to the
    Berkeley DB library and the... TODO</p>
<p class="Pp">The <b>db_appinit</b>, <b>db_cursor</b>, <b>db_open</b> and
    <b>db_txn</b> man pages are particularly relevant.</p>
<p class="Pp">The interface to Berkeley DB is implemented with a number of Perl
    classes.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="The_BerkeleyDB::Env_Class"><a class="permalink" href="#The_BerkeleyDB::Env_Class">The
  BerkeleyDB::Env Class</a></h1>
<p class="Pp">The <b>BerkeleyDB::Env</b> class provides an interface to the
    Berkeley DB function <b>db_appinit</b> in Berkeley DB 2.x or
    <b>db_env_create</b> and <b>DBENV-&gt;open</b> in Berkeley DB 3.x (or
    later). Its purpose is to initialise a number of sub-systems that can then
    be used in a consistent way in all the databases you make use of in the
    environment.</p>
<p class="Pp">If you don't intend using transactions, locking or logging, then
    you shouldn't need to make use of <b>BerkeleyDB::Env</b>.</p>
<p class="Pp">Note that an environment consists of a number of files that
    Berkeley DB manages behind the scenes for you. When you first use an
    environment, it needs to be explicitly created. This is done by including
    <span class="Li">&quot;DB_CREATE&quot;</span> with the
    <span class="Li">&quot;Flags&quot;</span> parameter, described below.</p>
<section class="Ss">
<h2 class="Ss" id="Synopsis"><a class="permalink" href="#Synopsis">Synopsis</a></h2>
<pre>
    $env = new BerkeleyDB::Env
             [ -Home         =&gt; $path, ]
             [ -Server       =&gt; $name, ]
             [ -CacheSize    =&gt; $number, ]
             [ -Config       =&gt; { name =&gt; value, name =&gt; value }, ]
             [ -ErrFile      =&gt; filename, ]
             [ -MsgFile      =&gt; filename, ]
             [ -ErrPrefix    =&gt; &quot;string&quot;, ]
             [ -Flags        =&gt; number, ]
             [ -SetFlags     =&gt; bitmask, ]
             [ -LockDetect   =&gt; number, ]
             [ -TxMax        =&gt; number, ]
             [ -LogConfig    =&gt; number, ]
             [ -MaxLockers   =&gt; number, ]
             [ -MaxLocks     =&gt; number, ]
             [ -MaxObjects   =&gt; number, ]
             [ -SharedMemKey =&gt; number, ]
             [ -Verbose      =&gt; boolean, ]
             [ -BlobThreshold=&gt; $number, ]
             [ -BlobDir      =&gt; directory, ]
             [ -Encrypt      =&gt; { Password =&gt; &quot;string&quot;,
                                  Flags    =&gt; number }, ]
</pre>
<p class="Pp">All the parameters to the BerkeleyDB::Env constructor are
    optional.</p>
<dl class="Bl-tag">
  <dt id="Home"><a class="permalink" href="#Home">-Home</a></dt>
  <dd>If present, this parameter should point to an existing directory. Any
      files that <i>aren't</i> specified with an absolute path in the
      sub-systems that are initialised by the BerkeleyDB::Env class will be
      assumed to live in the <b>Home</b> directory.
    <p class="Pp">For example, in the code fragment below the database
        &quot;fred.db&quot; will be opened in the directory
        &quot;/home/databases&quot; because it was specified as a relative path,
        but &quot;joe.db&quot; will be opened in &quot;/other&quot; because it
        was part of an absolute path.</p>
    <p class="Pp"></p>
    <pre>
    $env = new BerkeleyDB::Env
             -Home         =&gt; &quot;/home/databases&quot;
    ...

    $db1 = new BerkeleyDB::Hash
             -Filename =&gt; &quot;fred.db&quot;,
             -Env =&gt; $env
    ...

    $db2 = new BerkeleyDB::Hash
             -Filename =&gt; &quot;/other/joe.db&quot;,
             -Env =&gt; $env
    ...
    </pre>
  </dd>
  <dt id="Server"><a class="permalink" href="#Server">-Server</a></dt>
  <dd>If present, this parameter should be the hostname of a server that is
      running the Berkeley DB RPC server. All databases will be accessed via the
      RPC server.</dd>
  <dt id="Encrypt"><a class="permalink" href="#Encrypt">-Encrypt</a></dt>
  <dd>If present, this parameter will enable encryption of all data before it is
      written to the database. This parameters must be given a hash reference.
      The format is shown below.
    <p class="Pp"></p>
    <pre>
    -Encrypt =&gt; { -Password =&gt; &quot;abc&quot;, Flags =&gt; DB_ENCRYPT_AES }
    </pre>
    <p class="Pp">Valid values for the Flags are 0 or
        <span class="Li">&quot;DB_ENCRYPT_AES&quot;</span>.</p>
    <p class="Pp">This option requires Berkeley DB 4.1 or better.</p>
  </dd>
  <dt id="Cachesize"><a class="permalink" href="#Cachesize">-Cachesize</a></dt>
  <dd>If present, this parameter sets the size of the environments shared memory
      buffer pool.</dd>
  <dt id="TxMax"><a class="permalink" href="#TxMax">-TxMax</a></dt>
  <dd>If present, this parameter sets the number of simultaneous transactions
      that are allowed. Default 100. This default is definitely too low for
      programs using the MVCC capabilities.</dd>
  <dt id="LogConfig"><a class="permalink" href="#LogConfig">-LogConfig</a></dt>
  <dd>If present, this parameter is used to configure log options.</dd>
  <dt id="MaxLockers"><a class="permalink" href="#MaxLockers">-MaxLockers</a></dt>
  <dd>If present, this parameter is used to configure the maximum number of
      processes doing locking on the database. Default 1000.</dd>
  <dt id="MaxLocks"><a class="permalink" href="#MaxLocks">-MaxLocks</a></dt>
  <dd>If present, this parameter is used to configure the maximum number of
      locks on the database. Default 1000. This is often lower than
    required.</dd>
  <dt id="MaxObjects"><a class="permalink" href="#MaxObjects">-MaxObjects</a></dt>
  <dd>If present, this parameter is used to configure the maximum number of
      locked objects. Default 1000. This is often lower than required.</dd>
  <dt id="SharedMemKey"><a class="permalink" href="#SharedMemKey">-SharedMemKey</a></dt>
  <dd>If present, this parameter sets the base segment ID for the shared memory
      region used by Berkeley DB.
    <p class="Pp">This option requires Berkeley DB 3.1 or better.</p>
    <p class="Pp">Use
        <span class="Li">&quot;$env-&gt;get_shm_key($id)&quot;</span> to find
        out the base segment ID used once the environment is open.</p>
  </dd>
  <dt id="ThreadCount"><a class="permalink" href="#ThreadCount">-ThreadCount</a></dt>
  <dd>If present, this parameter declares the approximate number of threads that
      will be used in the database environment. This parameter is only necessary
      when the <span class="Li">$env</span>-&gt;failchk method will be used. It
      does not actually set the maximum number of threads but rather is used to
      determine memory sizing.
    <p class="Pp">This option requires Berkeley DB 4.4 or better. It is only
        supported on Unix/Linux.</p>
  </dd>
  <dt id="BlobThreshold"><a class="permalink" href="#BlobThreshold">-BlobThreshold</a></dt>
  <dd>Sets the size threshold that will be used to decide when data is stored as
      a BLOB. This option must be set for a blobs to be used.
    <p class="Pp">This option requires Berkeley DB 6.0 or better.</p>
  </dd>
  <dt id="BlobDir"><a class="permalink" href="#BlobDir">-BlobDir</a></dt>
  <dd>The directory where the BLOB objects are stored.
    <p class="Pp">If not specified blob files are stores in the environment
        directoy.</p>
    <p class="Pp">This option requires Berkeley DB 6.0 or better.</p>
  </dd>
  <dt id="Config"><a class="permalink" href="#Config">-Config</a></dt>
  <dd>This is a variation on the <span class="Li">&quot;-Home&quot;</span>
      parameter, but it allows finer control of where specific types of files
      will be stored.
    <p class="Pp">The parameter expects a reference to a hash. Valid keys are:
        <b>DB_DATA_DIR</b>, <b>DB_LOG_DIR</b> and <b>DB_TMP_DIR</b></p>
    <p class="Pp">The code below shows an example of how it can be used.</p>
    <p class="Pp"></p>
    <pre>
    $env = new BerkeleyDB::Env
             -Config =&gt; { DB_DATA_DIR =&gt; &quot;/home/databases&quot;,
                          DB_LOG_DIR  =&gt; &quot;/home/logs&quot;,
                          DB_TMP_DIR  =&gt; &quot;/home/tmp&quot;
                        }
    ...
    </pre>
  </dd>
  <dt id="ErrFile"><a class="permalink" href="#ErrFile">-ErrFile</a></dt>
  <dd>Expects a filename or filehandle. Any errors generated internally by
      Berkeley DB will be logged to this file. A useful debug setting is to open
      environments with either
    <p class="Pp"></p>
    <pre>
    -ErrFile =&gt; *STDOUT
    </pre>
    <p class="Pp">or</p>
    <p class="Pp"></p>
    <pre>
    -ErrFile =&gt; *STDERR
    </pre>
  </dd>
  <dt id="ErrPrefix"><a class="permalink" href="#ErrPrefix">-ErrPrefix</a></dt>
  <dd>Allows a prefix to be added to the error messages before they are sent to
      <b>-ErrFile</b>.</dd>
  <dt id="Flags"><a class="permalink" href="#Flags">-Flags</a></dt>
  <dd>The <b>Flags</b> parameter specifies both which sub-systems to initialise,
      as well as a number of environment-wide options. See the Berkeley DB
      documentation for more details of these options.
    <p class="Pp">Any of the following can be specified by OR'ing them:</p>
    <p class="Pp"><b>DB_CREATE</b></p>
    <p class="Pp">If any of the files specified do not already exist, create
        them.</p>
    <p class="Pp"><b>DB_INIT_CDB</b></p>
    <p class="Pp">Initialise the Concurrent Access Methods</p>
    <p class="Pp"><b>DB_INIT_LOCK</b></p>
    <p class="Pp">Initialise the Locking sub-system.</p>
    <p class="Pp"><b>DB_INIT_LOG</b></p>
    <p class="Pp">Initialise the Logging sub-system.</p>
    <p class="Pp"><b>DB_INIT_MPOOL</b></p>
    <p class="Pp">Initialize the shared memory buffer pool subsystem. This
        subsystem should be used whenever an application is using any Berkeley
        DB access method.</p>
    <p class="Pp"><b>DB_INIT_TXN</b></p>
    <p class="Pp">Initialize the transaction subsystem. This subsystem should be
        used when recovery and atomicity of multiple operations are important.
        The DB_INIT_TXN flag implies the DB_INIT_LOG flag.</p>
    <p class="Pp"><b>DB_MPOOL_PRIVATE</b></p>
    <p class="Pp">Create a private memory pool; see memp_open. Ignored unless
        DB_INIT_MPOOL is also specified.</p>
    <p class="Pp"><b>DB_INIT_MPOOL</b> is also specified.</p>
    <p class="Pp"><b>DB_NOMMAP</b></p>
    <p class="Pp">Do not map this database into process memory.</p>
    <p class="Pp"><b>DB_RECOVER</b></p>
    <p class="Pp">Run normal recovery on this environment before opening it for
        normal use. If this flag is set, the DB_CREATE flag must also be set
        since the regions will be removed and recreated.</p>
    <p class="Pp">The db_appinit function returns successfully if DB_RECOVER is
        specified and no log files exist, so it is necessary to ensure all
        necessary log files are present before running recovery.</p>
    <p class="Pp"><b>DB_PRIVATE</b></p>
    <p class="Pp"><b>DB_RECOVER_FATAL</b></p>
    <p class="Pp">Run catastrophic recovery on this environment before opening
        it for normal use. If this flag is set, the DB_CREATE flag must also be
        set since the regions will be removed and recreated.</p>
    <p class="Pp">The db_appinit function returns successfully if
        DB_RECOVER_FATAL is specified and no log files exist, so it is necessary
        to ensure all necessary log files are present before running
      recovery.</p>
    <p class="Pp"><b>DB_THREAD</b></p>
    <p class="Pp">Ensure that handles returned by the Berkeley DB subsystems are
        useable by multiple threads within a single process, i.e., that the
        system is free-threaded.</p>
    <p class="Pp"><b>DB_TXN_NOSYNC</b></p>
    <p class="Pp">On transaction commit, do not synchronously flush the log; see
        txn_open. Ignored unless DB_INIT_TXN is also specified.</p>
    <p class="Pp"><b>DB_USE_ENVIRON</b></p>
    <p class="Pp">The Berkeley DB process' environment may be permitted to
        specify information to be used when naming files; see Berkeley DB File
        Naming. As permitting users to specify which files are used can create
        security problems, environment information will be used in file naming
        for all users only if the DB_USE_ENVIRON flag is set.</p>
    <p class="Pp"><b>DB_USE_ENVIRON_ROOT</b></p>
    <p class="Pp">The Berkeley DB process' environment may be permitted to
        specify information to be used when naming files; see Berkeley DB File
        Naming. As permitting users to specify which files are used can create
        security problems, if the DB_USE_ENVIRON_ROOT flag is set, environment
        information will be used for file naming only for users with a user-ID
        matching that of the superuser (specifically, users for whom the
        <b>getuid</b>(2) system call returns the user-ID 0).</p>
  </dd>
  <dt id="SetFlags"><a class="permalink" href="#SetFlags">-SetFlags</a></dt>
  <dd>Calls ENV-&gt;set_flags with the supplied bitmask. Use this when you need
      to make use of DB_ENV-&gt;set_flags before DB_ENV-&gt;open is called.
    <p class="Pp">Only valid when Berkeley DB 3.x or better is used.</p>
  </dd>
  <dt id="LockDetect"><a class="permalink" href="#LockDetect">-LockDetect</a></dt>
  <dd>Specifies what to do when a lock conflict occurs. The value should be one
      of
    <p class="Pp"><b>DB_LOCK_DEFAULT</b></p>
    <p class="Pp">Use the default policy as specified by db_deadlock.</p>
    <p class="Pp"><b>DB_LOCK_OLDEST</b></p>
    <p class="Pp">Abort the oldest transaction.</p>
    <p class="Pp"><b>DB_LOCK_RANDOM</b></p>
    <p class="Pp">Abort a random transaction involved in the deadlock.</p>
    <p class="Pp"><b>DB_LOCK_YOUNGEST</b></p>
    <p class="Pp">Abort the youngest transaction.</p>
  </dd>
  <dt id="Verbose"><a class="permalink" href="#Verbose">-Verbose</a></dt>
  <dd>Add extra debugging information to the messages sent to
    <b>-ErrFile</b>.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Methods"><a class="permalink" href="#Methods">Methods</a></h2>
<p class="Pp">The environment class has the following methods:</p>
<dl class="Bl-tag">
  <dt>$env-&gt;errPrefix(&quot;string&quot;) ;</dt>
  <dd>This method is identical to the <b>-ErrPrefix</b> flag. It allows the
      error prefix string to be changed dynamically.</dd>
  <dt>$env-&gt;set_flags(bitmask, 1|0);</dt>
  <dd></dd>
  <dt>$txn = $env-&gt;<b>TxnMgr()</b></dt>
  <dd>Constructor for creating a <b>TxnMgr</b> object. See
      &quot;TRANSACTIONS&quot; for more details of using transactions.
    <p class="Pp">This method is deprecated. Access the transaction methods
        using the <b>txn_</b> methods below from the environment object
        directly.</p>
  </dd>
  <dt>$env-&gt;<b>txn_begin()</b></dt>
  <dd>TODO</dd>
  <dt>$env-&gt;<b>txn_stat()</b></dt>
  <dd>TODO</dd>
  <dt>$env-&gt;<b>txn_checkpoint()</b></dt>
  <dd>TODO</dd>
  <dt>$env-&gt;<b>status()</b></dt>
  <dd>Returns the status of the last BerkeleyDB::Env method.</dd>
  <dt>$env-&gt;<b>DB_ENV()</b></dt>
  <dd>Returns a pointer to the underlying DB_ENV data structure that Berkeley DB
      uses.</dd>
  <dt>$env-&gt;get_shm_key($id)</dt>
  <dd>Writes the base segment ID for the shared memory region used by the
      Berkeley DB environment into <span class="Li">$id</span>. Returns 0 on
      success.
    <p class="Pp">This option requires Berkeley DB 4.2 or better.</p>
    <p class="Pp">Use the <span class="Li">&quot;-SharedMemKey&quot;</span>
        option when opening the environmet to set the base segment ID.</p>
  </dd>
  <dt>$env-&gt;<b>set_isalive()</b></dt>
  <dd>Set the callback that determines if the thread of control, identified by
      the pid and tid arguments, is still running. This method should only be
      used in combination with <span class="Li">$env</span>-&gt;failchk.
    <p class="Pp">This option requires Berkeley DB 4.4 or better.</p>
  </dd>
  <dt>$env-&gt;failchk($flags)</dt>
  <dd>The <span class="Li">$env</span>-&gt;failchk method checks for threads of
      control (either a true thread or a process) that have exited while
      manipulating Berkeley DB library data structures, while holding a logical
      database lock, or with an unresolved transaction (that is, a transaction
      that was never aborted or committed).
    <p class="Pp">If <span class="Li">$env</span>-&gt;failchk determines a
        thread of control exited while holding database read locks, it will
        release those locks. If <span class="Li">$env</span>-&gt;failchk
        determines a thread of control exited with an unresolved transaction,
        the transaction will be aborted.</p>
    <p class="Pp">Applications calling the
        <span class="Li">$env</span>-&gt;failchk method must have already called
        the <span class="Li">$env</span>-&gt;set_isalive method, on the same DB
        environment, and must have configured their database environment using
        the -ThreadCount flag. The ThreadCount flag cannot be used on an
        environment that wasn't previously initialized with it.</p>
    <p class="Pp">This option requires Berkeley DB 4.4 or better.</p>
  </dd>
  <dt>$env-&gt;stat_print</dt>
  <dd>Prints statistical information.
    <p class="Pp">If the <span class="Li">&quot;MsgFile&quot;</span> option is
        specified the output will be sent to the file. Otherwise output is sent
        to standard output.</p>
    <p class="Pp">This option requires Berkeley DB 4.3 or better.</p>
  </dd>
  <dt>$env-&gt;lock_stat_print</dt>
  <dd>Prints locking subsystem statistics.
    <p class="Pp">If the <span class="Li">&quot;MsgFile&quot;</span> option is
        specified the output will be sent to the file. Otherwise output is sent
        to standard output.</p>
    <p class="Pp">This option requires Berkeley DB 4.3 or better.</p>
  </dd>
  <dt>$env-&gt;mutex_stat_print</dt>
  <dd>Prints mutex subsystem statistics.
    <p class="Pp">If the <span class="Li">&quot;MsgFile&quot;</span> option is
        specified the output will be sent to the file. Otherwise output is sent
        to standard output.</p>
    <p class="Pp">This option requires Berkeley DB 4.4 or better.</p>
  </dd>
  <dt>$status = $env-&gt;get_blob_threshold($t1) ;</dt>
  <dd>Sets the parameter <span class="Li">$t1</span> to the threshold value (in
      bytes) that is used to determine when a data item is stored as a
    Blob.</dd>
  <dt>$status = $env-&gt;get_blob_dir($dir) ;</dt>
  <dd>Sets the <span class="Li">$dir</span> parameter to the directory where
      blob files are stored.</dd>
  <dt>$env-&gt;set_timeout($timeout, $flags)</dt>
  <dd></dd>
  <dt>$env-&gt;<b>status()</b></dt>
  <dd>Returns the status of the last BerkeleyDB::Env method.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Examples"><a class="permalink" href="#Examples">Examples</a></h2>
<p class="Pp">TODO.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Global_Classes"><a class="permalink" href="#Global_Classes">Global
  Classes</a></h1>
<pre>
  $status = BerkeleyDB::db_remove [OPTIONS]
  $status = BerkeleyDB::db_rename [OPTIONS]
  $status = BerkeleyDB::db_verify [OPTIONS]
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="THE_DATABASE_CLASSES"><a class="permalink" href="#THE_DATABASE_CLASSES">THE
  DATABASE CLASSES</a></h1>
<p class="Pp"><b>BerkeleyDB</b> supports the following database formats:</p>
<dl class="Bl-tag">
  <dt id="BerkeleyDB::Hash"><a class="permalink" href="#BerkeleyDB::Hash"><b>BerkeleyDB::Hash</b></a></dt>
  <dd>This database type allows arbitrary key/value pairs to be stored in data
      files. This is equivalent to the functionality provided by other hashing
      packages like DBM, NDBM, ODBM, GDBM, and SDBM. Remember though, the files
      created using <b>BerkeleyDB::Hash</b> are not compatible with any of the
      other packages mentioned.
    <p class="Pp">A default hashing algorithm, which will be adequate for most
        applications, is built into BerkeleyDB. If you do need to use your own
        hashing algorithm it is possible to write your own in Perl and have
        <b>BerkeleyDB</b> use it instead.</p>
  </dd>
  <dt id="BerkeleyDB::Btree"><a class="permalink" href="#BerkeleyDB::Btree"><b>BerkeleyDB::Btree</b></a></dt>
  <dd>The Btree format allows arbitrary key/value pairs to be stored in a
      B+tree.
    <p class="Pp">As with the <b>BerkeleyDB::Hash</b> format, it is possible to
        provide a user defined Perl routine to perform the comparison of keys.
        By default, though, the keys are stored in lexical order.</p>
  </dd>
  <dt id="BerkeleyDB::Recno"><a class="permalink" href="#BerkeleyDB::Recno"><b>BerkeleyDB::Recno</b></a></dt>
  <dd>TODO.</dd>
  <dt id="BerkeleyDB::Queue"><a class="permalink" href="#BerkeleyDB::Queue"><b>BerkeleyDB::Queue</b></a></dt>
  <dd>TODO.</dd>
  <dt id="BerkeleyDB::Heap"><a class="permalink" href="#BerkeleyDB::Heap"><b>BerkeleyDB::Heap</b></a></dt>
  <dd>TODO.</dd>
  <dt id="BerkeleyDB::Unknown"><a class="permalink" href="#BerkeleyDB::Unknown"><b>BerkeleyDB::Unknown</b></a></dt>
  <dd>This isn't a database format at all. It is used when you want to open an
      existing Berkeley DB database without having to know what type is it.</dd>
</dl>
<p class="Pp">Each of the database formats described above is accessed via a
    corresponding <b>BerkeleyDB</b> class. These will be described in turn in
    the next sections.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BerkeleyDB::Hash~2"><a class="permalink" href="#BerkeleyDB::Hash~2">BerkeleyDB::Hash</a></h1>
<p class="Pp">Equivalent to calling <b>db_open</b> with type <b>DB_HASH</b> in
    Berkeley DB 2.x and calling <b>db_create</b> followed by <b>DB-&gt;open</b>
    with type <b>DB_HASH</b> in Berkeley DB 3.x or greater.</p>
<p class="Pp">Two forms of constructor are supported:</p>
<p class="Pp"></p>
<pre>
    $db = new BerkeleyDB::Hash
                [ -Filename      =&gt; &quot;filename&quot;, ]
                [ -Subname       =&gt; &quot;sub-database name&quot;, ]
                [ -Flags         =&gt; flags,]
                [ -Property      =&gt; flags,]
                [ -Mode          =&gt; number,]
                [ -Cachesize     =&gt; number,]
                [ -Lorder        =&gt; number,]
                [ -Pagesize      =&gt; number,]
                [ -Env           =&gt; $env,]
                [ -Txn           =&gt; $txn,]
                [ -Encrypt       =&gt; { Password =&gt; &quot;string&quot;,
                                      Flags    =&gt; number }, ],
                [ -BlobThreshold=&gt; $number, ]
                [ -BlobDir      =&gt; directory, ]
                # BerkeleyDB::Hash specific
                [ -Ffactor       =&gt; number,]
                [ -Nelem         =&gt; number,]
                [ -Hash          =&gt; code reference,]
                [ -DupCompare    =&gt; code reference,]
</pre>
<p class="Pp">and this</p>
<p class="Pp"></p>
<pre>
    [$db =] tie %hash, 'BerkeleyDB::Hash', 
                [ -Filename      =&gt; &quot;filename&quot;, ]
                [ -Subname       =&gt; &quot;sub-database name&quot;, ]
                [ -Flags         =&gt; flags,]
                [ -Property      =&gt; flags,]
                [ -Mode          =&gt; number,]
                [ -Cachesize     =&gt; number,]
                [ -Lorder        =&gt; number,]
                [ -Pagesize      =&gt; number,]
                [ -Env           =&gt; $env,]
                [ -Txn           =&gt; $txn,]
                [ -Encrypt       =&gt; { Password =&gt; &quot;string&quot;,
                                      Flags    =&gt; number }, ],
                [ -BlobThreshold=&gt; $number, ]
                [ -BlobDir      =&gt; directory, ]
                # BerkeleyDB::Hash specific
                [ -Ffactor       =&gt; number,]
                [ -Nelem         =&gt; number,]
                [ -Hash          =&gt; code reference,]
                [ -DupCompare    =&gt; code reference,]
</pre>
<p class="Pp">When the &quot;tie&quot; interface is used, reading from and
    writing to the database is achieved via the tied hash. In this case the
    database operates like a Perl associative array that happens to be stored on
    disk.</p>
<p class="Pp">In addition to the high-level tied hash interface, it is possible
    to make use of the underlying methods provided by Berkeley DB</p>
<section class="Ss">
<h2 class="Ss" id="Options"><a class="permalink" href="#Options">Options</a></h2>
<p class="Pp">In addition to the standard set of options (see &quot;COMMON
    OPTIONS&quot;) <b>BerkeleyDB::Hash</b> supports these options:</p>
<dl class="Bl-tag">
  <dt id="Property"><a class="permalink" href="#Property">-Property</a></dt>
  <dd>Used to specify extra flags when opening a database. The following flags
      may be specified by bitwise OR'ing together one or more of the following
      values:
    <p class="Pp"><b>DB_DUP</b></p>
    <p class="Pp">When creating a new database, this flag enables the storing of
        duplicate keys in the database. If <b>DB_DUPSORT</b> is not specified as
        well, the duplicates are stored in the order they are created in the
        database.</p>
    <p class="Pp"><b>DB_DUPSORT</b></p>
    <p class="Pp">Enables the sorting of duplicate keys in the database. Ignored
        if <b>DB_DUP</b> isn't also specified.</p>
  </dd>
  <dt id="Ffactor"><a class="permalink" href="#Ffactor">-Ffactor</a></dt>
  <dd></dd>
  <dt id="Nelem"><a class="permalink" href="#Nelem">-Nelem</a></dt>
  <dd>See the Berkeley DB documentation for details of these options.</dd>
  <dt id="Hash"><a class="permalink" href="#Hash">-Hash</a></dt>
  <dd>Allows you to provide a user defined hash function. If not specified, a
      default hash function is used. Here is a template for a user-defined hash
      function
    <p class="Pp"></p>
    <pre>
    sub hash
    {
        my ($data) = shift ;
        ...
        # return the hash value for $data
        return $hash ;
    }

    tie %h, &quot;BerkeleyDB::Hash&quot;, 
        -Filename =&gt; $filename, 
        -Hash     =&gt; \&amp;hash,
        ...
    </pre>
    <p class="Pp">See &quot;&quot; for an example.</p>
  </dd>
  <dt id="DupCompare"><a class="permalink" href="#DupCompare">-DupCompare</a></dt>
  <dd>Used in conjunction with the <b>DB_DUPOSRT</b> flag.
    <p class="Pp"></p>
    <pre>
    sub compare
    {
        my ($key, $key2) = @_ ;
        ...
        # return  0 if $key1 eq $key2
        #        -1 if $key1 lt $key2
        #         1 if $key1 gt $key2
        return (-1 , 0 or 1) ;
    }

    tie %h, &quot;BerkeleyDB::Hash&quot;, 
        -Filename   =&gt; $filename, 
        -Property   =&gt; DB_DUP|DB_DUPSORT,
        -DupCompare =&gt; \&amp;compare,
        ...
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Methods~2"><a class="permalink" href="#Methods~2">Methods</a></h2>
<p class="Pp"><b>BerkeleyDB::Hash</b> only supports the standard database
    methods. See &quot;COMMON DATABASE METHODS&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="A_Simple_Tied_Hash_Example"><a class="permalink" href="#A_Simple_Tied_Hash_Example">A
  Simple Tied Hash Example</a></h2>
<pre>
    use strict ;
    use BerkeleyDB ;
    use vars qw( %h $k $v ) ;

    my $filename = &quot;fruit&quot; ;
    unlink $filename ;
    tie %h, &quot;BerkeleyDB::Hash&quot;,
                -Filename =&gt; $filename,
                -Flags    =&gt; DB_CREATE
        or die &quot;Cannot open file $filename: $! $BerkeleyDB::Error\n&quot; ;

    # Add a few key/value pairs to the file
    $h{&quot;apple&quot;} = &quot;red&quot; ;
    $h{&quot;orange&quot;} = &quot;orange&quot; ;
    $h{&quot;banana&quot;} = &quot;yellow&quot; ;
    $h{&quot;tomato&quot;} = &quot;red&quot; ;

    # Check for existence of a key
    print &quot;Banana Exists\n\n&quot; if $h{&quot;banana&quot;} ;

    # Delete a key/value pair.
    delete $h{&quot;apple&quot;} ;

    # print the contents of the file
    while (($k, $v) = each %h)
      { print &quot;$k -&gt; $v\n&quot; }

    untie %h ;
</pre>
<p class="Pp">here is the output:</p>
<p class="Pp"></p>
<pre>
    Banana Exists
    
    orange -&gt; orange
    tomato -&gt; red
    banana -&gt; yellow
</pre>
<p class="Pp">Note that the like ordinary associative arrays, the order of the
    keys retrieved from a Hash database are in an apparently random order.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Another_Simple_Hash_Example"><a class="permalink" href="#Another_Simple_Hash_Example">Another
  Simple Hash Example</a></h2>
<p class="Pp">Do the same as the previous example but not using tie.</p>
<p class="Pp"></p>
<pre>
    use strict ;
    use BerkeleyDB ;

    my $filename = &quot;fruit&quot; ;
    unlink $filename ;
    my $db = new BerkeleyDB::Hash
                -Filename =&gt; $filename,
                -Flags    =&gt; DB_CREATE
        or die &quot;Cannot open file $filename: $! $BerkeleyDB::Error\n&quot; ;

    # Add a few key/value pairs to the file
    $db-&gt;db_put(&quot;apple&quot;, &quot;red&quot;) ;
    $db-&gt;db_put(&quot;orange&quot;, &quot;orange&quot;) ;
    $db-&gt;db_put(&quot;banana&quot;, &quot;yellow&quot;) ;
    $db-&gt;db_put(&quot;tomato&quot;, &quot;red&quot;) ;

    # Check for existence of a key
    print &quot;Banana Exists\n\n&quot; if $db-&gt;db_get(&quot;banana&quot;, $v) == 0;

    # Delete a key/value pair.
    $db-&gt;db_del(&quot;apple&quot;) ;

    # print the contents of the file
    my ($k, $v) = (&quot;&quot;, &quot;&quot;) ;
    my $cursor = $db-&gt;db_cursor() ;
    while ($cursor-&gt;c_get($k, $v, DB_NEXT) == 0)
      { print &quot;$k -&gt; $v\n&quot; }

    undef $cursor ;
    undef $db ;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Duplicate_keys"><a class="permalink" href="#Duplicate_keys">Duplicate
  keys</a></h2>
<p class="Pp">The code below is a variation on the examples above. This time the
    hash has been inverted. The key this time is colour and the value is the
    fruit name. The <b>DB_DUP</b> flag has been specified to allow
  duplicates.</p>
<p class="Pp"></p>
<pre>
    use strict ;
    use BerkeleyDB ;

    my $filename = &quot;fruit&quot; ;
    unlink $filename ;
    my $db = new BerkeleyDB::Hash
                -Filename =&gt; $filename,
                -Flags    =&gt; DB_CREATE,
                -Property  =&gt; DB_DUP
        or die &quot;Cannot open file $filename: $! $BerkeleyDB::Error\n&quot; ;

    # Add a few key/value pairs to the file
    $db-&gt;db_put(&quot;red&quot;, &quot;apple&quot;) ;
    $db-&gt;db_put(&quot;orange&quot;, &quot;orange&quot;) ;
    $db-&gt;db_put(&quot;green&quot;, &quot;banana&quot;) ;
    $db-&gt;db_put(&quot;yellow&quot;, &quot;banana&quot;) ;
    $db-&gt;db_put(&quot;red&quot;, &quot;tomato&quot;) ;
    $db-&gt;db_put(&quot;green&quot;, &quot;apple&quot;) ;

    # print the contents of the file
    my ($k, $v) = (&quot;&quot;, &quot;&quot;) ;
    my $cursor = $db-&gt;db_cursor() ;
    while ($cursor-&gt;c_get($k, $v, DB_NEXT) == 0)
      { print &quot;$k -&gt; $v\n&quot; }

    undef $cursor ;
    undef $db ;
</pre>
<p class="Pp">here is the output:</p>
<p class="Pp"></p>
<pre>
    orange -&gt; orange
    yellow -&gt; banana
    red -&gt; apple
    red -&gt; tomato
    green -&gt; banana
    green -&gt; apple
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Sorting_Duplicate_Keys"><a class="permalink" href="#Sorting_Duplicate_Keys">Sorting
  Duplicate Keys</a></h2>
<p class="Pp">In the previous example, when there were duplicate keys, the
    values are sorted in the order they are stored in. The code below is
    identical to the previous example except the <b>DB_DUPSORT</b> flag is
    specified.</p>
<p class="Pp"></p>
<pre>
    use strict ;
    use BerkeleyDB ;

    my $filename = &quot;fruit&quot; ;
    unlink $filename ;
    my $db = new BerkeleyDB::Hash
                -Filename =&gt; $filename,
                -Flags    =&gt; DB_CREATE,
                -Property  =&gt; DB_DUP | DB_DUPSORT
        or die &quot;Cannot open file $filename: $! $BerkeleyDB::Error\n&quot; ;

    # Add a few key/value pairs to the file
    $db-&gt;db_put(&quot;red&quot;, &quot;apple&quot;) ;
    $db-&gt;db_put(&quot;orange&quot;, &quot;orange&quot;) ;
    $db-&gt;db_put(&quot;green&quot;, &quot;banana&quot;) ;
    $db-&gt;db_put(&quot;yellow&quot;, &quot;banana&quot;) ;
    $db-&gt;db_put(&quot;red&quot;, &quot;tomato&quot;) ;
    $db-&gt;db_put(&quot;green&quot;, &quot;apple&quot;) ;

    # print the contents of the file
    my ($k, $v) = (&quot;&quot;, &quot;&quot;) ;
    my $cursor = $db-&gt;db_cursor() ;
    while ($cursor-&gt;c_get($k, $v, DB_NEXT) == 0)
      { print &quot;$k -&gt; $v\n&quot; }

    undef $cursor ;
    undef $db ;
</pre>
<p class="Pp">Notice that in the output below the duplicate values are
  sorted.</p>
<p class="Pp"></p>
<pre>
    orange -&gt; orange
    yellow -&gt; banana
    red -&gt; apple
    red -&gt; tomato
    green -&gt; apple
    green -&gt; banana
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Custom_Sorting_Duplicate_Keys"><a class="permalink" href="#Custom_Sorting_Duplicate_Keys">Custom
  Sorting Duplicate Keys</a></h2>
<p class="Pp">Another variation</p>
<p class="Pp">TODO</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Changing_the_hash"><a class="permalink" href="#Changing_the_hash">Changing
  the hash</a></h2>
<p class="Pp">TODO</p>
</section>
<section class="Ss">
<h2 class="Ss">Using db_stat</h2>
<p class="Pp">TODO</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BerkeleyDB::Btree~2"><a class="permalink" href="#BerkeleyDB::Btree~2">BerkeleyDB::Btree</a></h1>
<p class="Pp">Equivalent to calling <b>db_open</b> with type <b>DB_BTREE</b> in
    Berkeley DB 2.x and calling <b>db_create</b> followed by <b>DB-&gt;open</b>
    with type <b>DB_BTREE</b> in Berkeley DB 3.x or greater.</p>
<p class="Pp">Two forms of constructor are supported:</p>
<p class="Pp"></p>
<pre>
    $db = new BerkeleyDB::Btree
                [ -Filename      =&gt; &quot;filename&quot;, ]
                [ -Subname       =&gt; &quot;sub-database name&quot;, ]
                [ -Flags         =&gt; flags,]
                [ -Property      =&gt; flags,]
                [ -Mode          =&gt; number,]
                [ -Cachesize     =&gt; number,]
                [ -Lorder        =&gt; number,]
                [ -Pagesize      =&gt; number,]
                [ -Env           =&gt; $env,]
                [ -Txn           =&gt; $txn,]
                [ -Encrypt       =&gt; { Password =&gt; &quot;string&quot;,
                                      Flags    =&gt; number }, ],
                [ -BlobThreshold=&gt; $number, ]
                [ -BlobDir      =&gt; directory, ]
                # BerkeleyDB::Btree specific
                [ -Minkey        =&gt; number,]
                [ -Compare       =&gt; code reference,]
                [ -DupCompare    =&gt; code reference,]
                [ -Prefix        =&gt; code reference,]
</pre>
<p class="Pp">and this</p>
<p class="Pp"></p>
<pre>
    [$db =] tie %hash, 'BerkeleyDB::Btree', 
                [ -Filename      =&gt; &quot;filename&quot;, ]
                [ -Subname       =&gt; &quot;sub-database name&quot;, ]
                [ -Flags         =&gt; flags,]
                [ -Property      =&gt; flags,]
                [ -Mode          =&gt; number,]
                [ -Cachesize     =&gt; number,]
                [ -Lorder        =&gt; number,]
                [ -Pagesize      =&gt; number,]
                [ -Env           =&gt; $env,]
                [ -Txn           =&gt; $txn,]
                [ -Encrypt       =&gt; { Password =&gt; &quot;string&quot;,
                                      Flags    =&gt; number }, ],
                [ -BlobThreshold=&gt; $number, ]
                [ -BlobDir      =&gt; directory, ]
                # BerkeleyDB::Btree specific
                [ -Minkey        =&gt; number,]
                [ -Compare       =&gt; code reference,]
                [ -DupCompare    =&gt; code reference,]
                [ -Prefix        =&gt; code reference,]
</pre>
<section class="Ss">
<h2 class="Ss" id="Options~2"><a class="permalink" href="#Options~2">Options</a></h2>
<p class="Pp">In addition to the standard set of options (see &quot;COMMON
    OPTIONS&quot;) <b>BerkeleyDB::Btree</b> supports these options:</p>
<dl class="Bl-tag">
  <dt id="Property~2"><a class="permalink" href="#Property~2">-Property</a></dt>
  <dd>Used to specify extra flags when opening a database. The following flags
      may be specified by bitwise OR'ing together one or more of the following
      values:
    <p class="Pp"><b>DB_DUP</b></p>
    <p class="Pp">When creating a new database, this flag enables the storing of
        duplicate keys in the database. If <b>DB_DUPSORT</b> is not specified as
        well, the duplicates are stored in the order they are created in the
        database.</p>
    <p class="Pp"><b>DB_DUPSORT</b></p>
    <p class="Pp">Enables the sorting of duplicate keys in the database. Ignored
        if <b>DB_DUP</b> isn't also specified.</p>
  </dd>
  <dt id="Minkey"><a class="permalink" href="#Minkey">Minkey</a></dt>
  <dd>TODO</dd>
  <dt id="Compare"><a class="permalink" href="#Compare">Compare</a></dt>
  <dd>Allow you to override the default sort order used in the database. See
      &quot;Changing the sort order&quot; for an example.
    <p class="Pp"></p>
    <pre>
    sub compare
    {
        my ($key, $key2) = @_ ;
        ...
        # return  0 if $key1 eq $key2
        #        -1 if $key1 lt $key2
        #         1 if $key1 gt $key2
        return (-1 , 0 or 1) ;
    }

    tie %h, &quot;BerkeleyDB::Hash&quot;, 
        -Filename   =&gt; $filename, 
        -Compare    =&gt; \&amp;compare,
        ...
    </pre>
  </dd>
  <dt id="Prefix"><a class="permalink" href="#Prefix">Prefix</a></dt>
  <dd>
    <pre>
    sub prefix
    {
        my ($key, $key2) = @_ ;
        ...
        # return number of bytes of $key2 which are 
        # necessary to determine that it is greater than $key1
        return $bytes ;
    }

    tie %h, &quot;BerkeleyDB::Hash&quot;, 
        -Filename   =&gt; $filename, 
        -Prefix     =&gt; \&amp;prefix,
        ...
=item DupCompare

    sub compare
    {
        my ($key, $key2) = @_ ;
        ...
        # return  0 if $key1 eq $key2
        #        -1 if $key1 lt $key2
        #         1 if $key1 gt $key2
        return (-1 , 0 or 1) ;
    }

    tie %h, &quot;BerkeleyDB::Hash&quot;, 
        -Filename   =&gt; $filename, 
        -DupCompare =&gt; \&amp;compare,
        ...
    </pre>
  </dd>
  <dt id="set_bt_compress"><a class="permalink" href="#set_bt_compress">set_bt_compress</a></dt>
  <dd>Enabled compression of the btree data. The callback interface is not
      supported at present. Need Berkeley DB 4.8 or better.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Methods~3"><a class="permalink" href="#Methods~3">Methods</a></h2>
<p class="Pp"><b>BerkeleyDB::Btree</b> supports the following database methods.
    See also &quot;COMMON DATABASE METHODS&quot;.</p>
<p class="Pp">All the methods below return 0 to indicate success.</p>
<dl class="Bl-tag">
  <dt>$status = $db-&gt;db_key_range($key, $less, $equal, $greater [,
    $flags])</dt>
  <dd>Given a key, <span class="Li">$key</span>, this method returns the
      proportion of keys less than <span class="Li">$key</span> in
      <span class="Li">$less</span>, the proportion equal to
      <span class="Li">$key</span> in <span class="Li">$equal</span> and the
      proportion greater than <span class="Li">$key</span> in
      <span class="Li">$greater</span>.
    <p class="Pp">The proportion is returned as a double in the range 0.0 to
        1.0.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="A_Simple_Btree_Example"><a class="permalink" href="#A_Simple_Btree_Example">A
  Simple Btree Example</a></h2>
<p class="Pp">The code below is a simple example of using a btree database.</p>
<p class="Pp"></p>
<pre>
    use strict ;
    use BerkeleyDB ;

    my $filename = &quot;tree&quot; ;
    unlink $filename ;
    my %h ;
    tie %h, 'BerkeleyDB::Btree',
                -Filename   =&gt; $filename,
                -Flags      =&gt; DB_CREATE
      or die &quot;Cannot open $filename: $! $BerkeleyDB::Error\n&quot; ;

    # Add a key/value pair to the file
    $h{'Wall'} = 'Larry' ;
    $h{'Smith'} = 'John' ;
    $h{'mouse'} = 'mickey' ;
    $h{'duck'}  = 'donald' ;

    # Delete
    delete $h{&quot;duck&quot;} ;

    # Cycle through the keys printing them in order.
    # Note it is not necessary to sort the keys as
    # the btree will have kept them in order automatically.
    foreach (keys %h)
      { print &quot;$_\n&quot; }

    untie %h ;
</pre>
<p class="Pp">Here is the output from the code above. The keys have been sorted
    using Berkeley DB's default sorting algorithm.</p>
<p class="Pp"></p>
<pre>
    Smith
    Wall
    mouse
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Changing_the_sort_order"><a class="permalink" href="#Changing_the_sort_order">Changing
  the sort order</a></h2>
<p class="Pp">It is possible to supply your own sorting algorithm if the one
    that Berkeley DB used isn't suitable. The code below is identical to the
    previous example except for the case insensitive compare function.</p>
<p class="Pp"></p>
<pre>
    use strict ;
    use BerkeleyDB ;

    my $filename = &quot;tree&quot; ;
    unlink $filename ;
    my %h ;
    tie %h, 'BerkeleyDB::Btree',
                -Filename   =&gt; $filename,
                -Flags      =&gt; DB_CREATE,
                -Compare    =&gt; sub { lc $_[0] cmp lc $_[1] }
      or die &quot;Cannot open $filename: $!\n&quot; ;

    # Add a key/value pair to the file
    $h{'Wall'} = 'Larry' ;
    $h{'Smith'} = 'John' ;
    $h{'mouse'} = 'mickey' ;
    $h{'duck'}  = 'donald' ;

    # Delete
    delete $h{&quot;duck&quot;} ;

    # Cycle through the keys printing them in order.
    # Note it is not necessary to sort the keys as
    # the btree will have kept them in order automatically.
    foreach (keys %h)
      { print &quot;$_\n&quot; }

    untie %h ;
</pre>
<p class="Pp">Here is the output from the code above.</p>
<p class="Pp"></p>
<pre>
    mouse
    Smith
    Wall
</pre>
<p class="Pp">There are a few point to bear in mind if you want to change the
    ordering in a BTREE database:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>The new compare function must be specified when you create the
    database.</dd>
  <dt>2.</dt>
  <dd>You cannot change the ordering once the database has been created. Thus
      you must use the same compare function every time you access the
    database.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">Using db_stat</h2>
<p class="Pp">TODO</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BerkeleyDB::Recno~2"><a class="permalink" href="#BerkeleyDB::Recno~2">BerkeleyDB::Recno</a></h1>
<p class="Pp">Equivalent to calling <b>db_open</b> with type <b>DB_RECNO</b> in
    Berkeley DB 2.x and calling <b>db_create</b> followed by <b>DB-&gt;open</b>
    with type <b>DB_RECNO</b> in Berkeley DB 3.x or greater.</p>
<p class="Pp">Two forms of constructor are supported:</p>
<p class="Pp"></p>
<pre>
    $db = new BerkeleyDB::Recno
                [ -Filename      =&gt; &quot;filename&quot;, ]
                [ -Subname       =&gt; &quot;sub-database name&quot;, ]
                [ -Flags         =&gt; flags,]
                [ -Property      =&gt; flags,]
                [ -Mode          =&gt; number,]
                [ -Cachesize     =&gt; number,]
                [ -Lorder        =&gt; number,]
                [ -Pagesize      =&gt; number,]
                [ -Env           =&gt; $env,]
                [ -Txn           =&gt; $txn,]
                [ -Encrypt       =&gt; { Password =&gt; &quot;string&quot;,
                                      Flags    =&gt; number }, ],
                # BerkeleyDB::Recno specific
                [ -Delim           =&gt; byte,]
                [ -Len             =&gt; number,]
                [ -Pad             =&gt; byte,]
                [ -Source          =&gt; filename,]
</pre>
<p class="Pp">and this</p>
<p class="Pp"></p>
<pre>
    [$db =] tie @arry, 'BerkeleyDB::Recno', 
                [ -Filename      =&gt; &quot;filename&quot;, ]
                [ -Subname       =&gt; &quot;sub-database name&quot;, ]
                [ -Flags         =&gt; flags,]
                [ -Property      =&gt; flags,]
                [ -Mode          =&gt; number,]
                [ -Cachesize     =&gt; number,]
                [ -Lorder        =&gt; number,]
                [ -Pagesize      =&gt; number,]
                [ -Env           =&gt; $env,]
                [ -Txn           =&gt; $txn,]
                [ -Encrypt       =&gt; { Password =&gt; &quot;string&quot;,
                                      Flags    =&gt; number }, ],
                # BerkeleyDB::Recno specific
                [ -Delim           =&gt; byte,]
                [ -Len             =&gt; number,]
                [ -Pad             =&gt; byte,]
                [ -Source          =&gt; filename,]
</pre>
<section class="Ss">
<h2 class="Ss" id="A_Recno_Example"><a class="permalink" href="#A_Recno_Example">A
  Recno Example</a></h2>
<p class="Pp">Here is a simple example that uses RECNO (if you are using a
    version of Perl earlier than 5.004_57 this example won't work -- see
    &quot;Extra RECNO Methods&quot; for a workaround).</p>
<p class="Pp"></p>
<pre>
    use strict ;
    use BerkeleyDB ;

    my $filename = &quot;text&quot; ;
    unlink $filename ;

    my @h ;
    tie @h, 'BerkeleyDB::Recno',
                -Filename   =&gt; $filename,
                -Flags      =&gt; DB_CREATE,
                -Property   =&gt; DB_RENUMBER
      or die &quot;Cannot open $filename: $!\n&quot; ;

    # Add a few key/value pairs to the file
    $h[0] = &quot;orange&quot; ;
    $h[1] = &quot;blue&quot; ;
    $h[2] = &quot;yellow&quot; ;

    push @h, &quot;green&quot;, &quot;black&quot; ;

    my $elements = scalar @h ;
    print &quot;The array contains $elements entries\n&quot; ;

    my $last = pop @h ;
    print &quot;popped $last\n&quot; ;

    unshift @h, &quot;white&quot; ;
    my $first = shift @h ;
    print &quot;shifted $first\n&quot; ;

    # Check for existence of a key
    print &quot;Element 1 Exists with value $h[1]\n&quot; if $h[1] ;

    untie @h ;
</pre>
<p class="Pp">Here is the output from the script:</p>
<p class="Pp"></p>
<pre>
    The array contains 5 entries
    popped black
    shifted white
    Element 1 Exists with value blue
    The last element is green
    The 2nd last element is yellow
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BerkeleyDB::Queue~2"><a class="permalink" href="#BerkeleyDB::Queue~2">BerkeleyDB::Queue</a></h1>
<p class="Pp">Equivalent to calling <b>db_create</b> followed by
    <b>DB-&gt;open</b> with type <b>DB_QUEUE</b> in Berkeley DB 3.x or greater.
    This database format isn't available if you use Berkeley DB 2.x.</p>
<p class="Pp">Two forms of constructor are supported:</p>
<p class="Pp"></p>
<pre>
    $db = new BerkeleyDB::Queue
                [ -Filename      =&gt; &quot;filename&quot;, ]
                [ -Subname       =&gt; &quot;sub-database name&quot;, ]
                [ -Flags         =&gt; flags,]
                [ -Property      =&gt; flags,]
                [ -Mode          =&gt; number,]
                [ -Cachesize     =&gt; number,]
                [ -Lorder        =&gt; number,]
                [ -Pagesize      =&gt; number,]
                [ -Env           =&gt; $env,]
                [ -Txn           =&gt; $txn,]
                [ -Encrypt       =&gt; { Password =&gt; &quot;string&quot;,
                                      Flags    =&gt; number }, ],
                # BerkeleyDB::Queue specific
                [ -Len             =&gt; number,]
                [ -Pad             =&gt; byte,]
                [ -ExtentSize    =&gt; number, ]
</pre>
<p class="Pp">and this</p>
<p class="Pp"></p>
<pre>
    [$db =] tie @arry, 'BerkeleyDB::Queue', 
                [ -Filename      =&gt; &quot;filename&quot;, ]
                [ -Subname       =&gt; &quot;sub-database name&quot;, ]
                [ -Flags         =&gt; flags,]
                [ -Property      =&gt; flags,]
                [ -Mode          =&gt; number,]
                [ -Cachesize     =&gt; number,]
                [ -Lorder        =&gt; number,]
                [ -Pagesize      =&gt; number,]
                [ -Env           =&gt; $env,]
                [ -Txn           =&gt; $txn,]
                [ -Encrypt       =&gt; { Password =&gt; &quot;string&quot;,
                                      Flags    =&gt; number }, ],
                # BerkeleyDB::Queue specific
                [ -Len             =&gt; number,]
                [ -Pad             =&gt; byte,]
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="BerkeleyDB::Heap~2"><a class="permalink" href="#BerkeleyDB::Heap~2">BerkeleyDB::Heap</a></h1>
<p class="Pp">Equivalent to calling <b>db_create</b> followed by
    <b>DB-&gt;open</b> with type <b>DB_HEAP</b> in Berkeley DB 5.2.x or greater.
    This database format isn't available if you use an older version of Berkeley
    DB.</p>
<p class="Pp">One form of constructor is supported:</p>
<p class="Pp"></p>
<pre>
    $db = new BerkeleyDB::Heap
                [ -Filename      =&gt; &quot;filename&quot;, ]
                [ -Subname       =&gt; &quot;sub-database name&quot;, ]
                [ -Flags         =&gt; flags,]
                [ -Property      =&gt; flags,]
                [ -Mode          =&gt; number,]
                [ -Cachesize     =&gt; number,]
                [ -Lorder        =&gt; number,]
                [ -Pagesize      =&gt; number,]
                [ -Env           =&gt; $env,]
                [ -Txn           =&gt; $txn,]
                [ -Encrypt       =&gt; { Password =&gt; &quot;string&quot;,
                                      Flags    =&gt; number }, ],
                [ -BlobThreshold=&gt; $number, ]
                [ -BlobDir      =&gt; directory, ]
                # BerkeleyDB::Heap specific
                [ -HeapSize      =&gt; number, ]
                [ -HeapSizeGb    =&gt; number, ]
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="BerkeleyDB::Unknown~2"><a class="permalink" href="#BerkeleyDB::Unknown~2">BerkeleyDB::Unknown</a></h1>
<p class="Pp">This class is used to open an existing database.</p>
<p class="Pp">Equivalent to calling <b>db_open</b> with type <b>DB_UNKNOWN</b>
    in Berkeley DB 2.x and calling <b>db_create</b> followed by
    <b>DB-&gt;open</b> with type <b>DB_UNKNOWN</b> in Berkeley DB 3.x or
    greater.</p>
<p class="Pp">The constructor looks like this:</p>
<p class="Pp"></p>
<pre>
    $db = new BerkeleyDB::Unknown
                [ -Filename      =&gt; &quot;filename&quot;, ]
                [ -Subname       =&gt; &quot;sub-database name&quot;, ]
                [ -Flags         =&gt; flags,]
                [ -Property      =&gt; flags,]
                [ -Mode          =&gt; number,]
                [ -Cachesize     =&gt; number,]
                [ -Lorder        =&gt; number,]
                [ -Pagesize      =&gt; number,]
                [ -Env           =&gt; $env,]
                [ -Txn           =&gt; $txn,]
                [ -Encrypt       =&gt; { Password =&gt; &quot;string&quot;,
                                      Flags    =&gt; number }, ],
</pre>
<section class="Ss">
<h2 class="Ss" id="An_example"><a class="permalink" href="#An_example">An
  example</a></h2>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="COMMON_OPTIONS"><a class="permalink" href="#COMMON_OPTIONS">COMMON
  OPTIONS</a></h1>
<p class="Pp">All database access class constructors support the common set of
    options defined below. All are optional.</p>
<dl class="Bl-tag">
  <dt id="Filename"><a class="permalink" href="#Filename">-Filename</a></dt>
  <dd>The database filename. If no filename is specified, a temporary file will
      be created and removed once the program terminates.</dd>
  <dt id="Subname"><a class="permalink" href="#Subname">-Subname</a></dt>
  <dd>Specifies the name of the sub-database to open. This option is only valid
      if you are using Berkeley DB 3.x or greater.</dd>
  <dt id="Flags~2"><a class="permalink" href="#Flags~2">-Flags</a></dt>
  <dd>Specify how the database will be opened/created. The valid flags are:
    <p class="Pp"><b>DB_CREATE</b></p>
    <p class="Pp">Create any underlying files, as necessary. If the files do not
        already exist and the <b>DB_CREATE</b> flag is not specified, the call
        will fail.</p>
    <p class="Pp"><b>DB_NOMMAP</b></p>
    <p class="Pp">Not supported by BerkeleyDB.</p>
    <p class="Pp"><b>DB_RDONLY</b></p>
    <p class="Pp">Opens the database in read-only mode.</p>
    <p class="Pp"><b>DB_THREAD</b></p>
    <p class="Pp">Not supported by BerkeleyDB.</p>
    <p class="Pp"><b>DB_TRUNCATE</b></p>
    <p class="Pp">If the database file already exists, remove all the data
        before opening it.</p>
  </dd>
  <dt id="Mode"><a class="permalink" href="#Mode">-Mode</a></dt>
  <dd>Determines the file protection when the database is created. Defaults to
      0666.</dd>
  <dt id="Cachesize~2"><a class="permalink" href="#Cachesize~2">-Cachesize</a></dt>
  <dd></dd>
  <dt id="Lorder"><a class="permalink" href="#Lorder">-Lorder</a></dt>
  <dd></dd>
  <dt id="Pagesize"><a class="permalink" href="#Pagesize">-Pagesize</a></dt>
  <dd></dd>
  <dt id="Env"><a class="permalink" href="#Env">-Env</a></dt>
  <dd>When working under a Berkeley DB environment, this parameter
    <p class="Pp">Defaults to no environment.</p>
  </dd>
  <dt id="Encrypt~2"><a class="permalink" href="#Encrypt~2">-Encrypt</a></dt>
  <dd>If present, this parameter will enable encryption of all data before it is
      written to the database. This parameters must be given a hash reference.
      The format is shown below.
    <p class="Pp"></p>
    <pre>
    -Encrypt =&gt; { -Password =&gt; &quot;abc&quot;, Flags =&gt; DB_ENCRYPT_AES }
    </pre>
    <p class="Pp">Valid values for the Flags are 0 or
        <span class="Li">&quot;DB_ENCRYPT_AES&quot;</span>.</p>
    <p class="Pp">This option requires Berkeley DB 4.1 or better.</p>
  </dd>
  <dt id="Txn"><a class="permalink" href="#Txn">-Txn</a></dt>
  <dd>TODO.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="COMMON_DATABASE_METHODS"><a class="permalink" href="#COMMON_DATABASE_METHODS">COMMON
  DATABASE METHODS</a></h1>
<p class="Pp">All the database interfaces support the common set of methods
    defined below.</p>
<p class="Pp">All the methods below return 0 to indicate success.</p>
<section class="Ss">
<h2 class="Ss" id="$env_=_$db"><a class="permalink" href="#$env_=_$db">$env =
  $db-&gt;<b>Env()</b>;</a></h2>
<p class="Pp">Returns the environment object the database is associated with or
    <span class="Li">&quot;undef&quot;</span> when no environment was used when
    opening the database.</p>
</section>
<section class="Ss">
<h2 class="Ss">$status = $db-&gt;db_get($key, $value [, $flags])</h2>
<p class="Pp">Given a key (<span class="Li">$key</span>) this method reads the
    value associated with it from the database. If it exists, the value read
    from the database is returned in the <span class="Li">$value</span>
    parameter.</p>
<p class="Pp">The <b></b><b>$flags</b><b></b> parameter is optional. If present,
    it must be set to <b>one</b> of the following values:</p>
<dl class="Bl-tag">
  <dt id="DB_GET_BOTH"><a class="permalink" href="#DB_GET_BOTH"><b>DB_GET_BOTH</b></a></dt>
  <dd>When the <b>DB_GET_BOTH</b> flag is specified, <b>db_get</b> checks for
      the existence of <b>both</b> the <span class="Li">$key</span> <b>and</b>
      <span class="Li">$value</span> in the database.</dd>
  <dt id="DB_SET_RECNO"><a class="permalink" href="#DB_SET_RECNO"><b>DB_SET_RECNO</b></a></dt>
  <dd>TODO.</dd>
</dl>
<p class="Pp">In addition, the following value may be set by bitwise OR'ing it
    into the <b></b><b>$flags</b><b></b> parameter:</p>
<dl class="Bl-tag">
  <dt id="DB_RMW"><a class="permalink" href="#DB_RMW"><b>DB_RMW</b></a></dt>
  <dd>TODO</dd>
</dl>
<p class="Pp">The variant <span class="Li">&quot;db_pget&quot;</span> allows you
    to query a secondary database:</p>
<p class="Pp"></p>
<pre>
        $status = $sdb-&gt;db_pget($skey, $pkey, $value);
</pre>
<p class="Pp">using the key <span class="Li">$skey</span> in the secondary db to
    lookup <span class="Li">$pkey</span> and <span class="Li">$value</span> from
    the primary db.</p>
</section>
<section class="Ss">
<h2 class="Ss">$status = $db-&gt;db_exists($key [, $flags])</h2>
<p class="Pp">This method checks for the existence of the given key
    (<span class="Li">$key</span>), but does not read the value. If the key is
    not found, <b>db_exists</b> will return <b>DB_NOTFOUND</b>. Requires BDB 4.6
    or better.</p>
</section>
<section class="Ss">
<h2 class="Ss">$status = $db-&gt;db_put($key, $value [, $flags])</h2>
<p class="Pp">Stores a key/value pair in the database.</p>
<p class="Pp">The <b></b><b>$flags</b><b></b> parameter is optional. If present
    it must be set to <b>one</b> of the following values:</p>
<dl class="Bl-tag">
  <dt id="DB_APPEND"><a class="permalink" href="#DB_APPEND"><b>DB_APPEND</b></a></dt>
  <dd>This flag is only applicable when accessing a <b>BerkeleyDB::Recno</b>
      database.
    <p class="Pp">TODO.</p>
  </dd>
  <dt id="DB_NOOVERWRITE"><a class="permalink" href="#DB_NOOVERWRITE"><b>DB_NOOVERWRITE</b></a></dt>
  <dd>If this flag is specified and <span class="Li">$key</span> already exists
      in the database, the call to <b>db_put</b> will return
    <b>DB_KEYEXIST</b>.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">$status = $db-&gt;db_del($key [, $flags])</h2>
<p class="Pp">Deletes a key/value pair in the database associated with
    <span class="Li">$key</span>. If duplicate keys are enabled in the database,
    <b>db_del</b> will delete <b>all</b> key/value pairs with key
    <span class="Li">$key</span>.</p>
<p class="Pp">The <b></b><b>$flags</b><b></b> parameter is optional and is
    currently unused.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$status_=_$env"><a class="permalink" href="#$status_=_$env">$status
  = $env-&gt;stat_print([$flags])</a></h2>
<p class="Pp">Prints statistical information.</p>
<p class="Pp">If the <span class="Li">&quot;MsgFile&quot;</span> option is
    specified the output will be sent to the file. Otherwise output is sent to
    standard output.</p>
<p class="Pp">This option requires Berkeley DB 4.3 or better.</p>
</section>
<section class="Ss">
<h2 class="Ss">$status = $db-&gt;<b>db_sync()</b></h2>
<p class="Pp">If any parts of the database are in memory, write them to the
    database.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$cursor_=_$db"><a class="permalink" href="#$cursor_=_$db">$cursor
  = $db-&gt;db_cursor([$flags])</a></h2>
<p class="Pp">Creates a cursor object. This is used to access the contents of
    the database sequentially. See CURSORS for details of the methods available
    when working with cursors.</p>
<p class="Pp">The <b></b><b>$flags</b><b></b> parameter is optional. If present
    it must be set to <b>one</b> of the following values:</p>
<dl class="Bl-tag">
  <dt id="DB_RMW~2"><a class="permalink" href="#DB_RMW~2"><b>DB_RMW</b></a></dt>
  <dd>TODO.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">($flag, $old_offset, $old_length) = $db-&gt;partial_set($offset,
  $length) ;</h2>
<p class="Pp">TODO</p>
</section>
<section class="Ss">
<h2 class="Ss">($flag, $old_offset, $old_length) =
  $db-&gt;<b>partial_clear()</b> ;</h2>
<p class="Pp">TODO</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$db"><a class="permalink" href="#$db">$db-&gt;<b>byteswapped()</b></a></h2>
<p class="Pp">TODO</p>
</section>
<section class="Ss">
<h2 class="Ss">$status = $db-&gt;get_blob_threshold($t1) ;</h2>
<p class="Pp">Sets the parameter <span class="Li">$t1</span> to the threshold
    value (in bytes) that is used to determine when a data item is stored as a
    Blob.</p>
</section>
<section class="Ss">
<h2 class="Ss">$status = $db-&gt;get_blob_dir($dir) ;</h2>
<p class="Pp">Sets the <span class="Li">$dir</span> parameter to the directory
    where blob files are stored.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$db~2"><a class="permalink" href="#$db~2">$db-&gt;<b>type()</b></a></h2>
<p class="Pp">Returns the type of the database. The possible return code are
    <b>DB_HASH</b> for a <b>BerkeleyDB::Hash</b> database, <b>DB_BTREE</b> for a
    <b>BerkeleyDB::Btree</b> database and <b>DB_RECNO</b> for a
    <b>BerkeleyDB::Recno</b> database. This method is typically used when a
    database has been opened with <b>BerkeleyDB::Unknown</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$bool_=_$env"><a class="permalink" href="#$bool_=_$env">$bool
  = $env-&gt;<b>cds_enabled()</b>;</a></h2>
<p class="Pp">Returns true if the Berkeley DB environment
    <span class="Li">$env</span> has been opened on CDS mode.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$bool_=_$db"><a class="permalink" href="#$bool_=_$db">$bool =
  $db-&gt;<b>cds_enabled()</b>;</a></h2>
<p class="Pp">Returns true if the database <span class="Li">$db</span> has been
    opened on CDS mode.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$lock_=_$db"><a class="permalink" href="#$lock_=_$db">$lock =
  $db-&gt;<b>cds_lock()</b>;</a></h2>
<p class="Pp">Creates a CDS write lock object <span class="Li">$lock</span>.</p>
<p class="Pp">It is a fatal error to attempt to create a cds_lock if the
    Berkeley DB environment has not been opened in CDS mode.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$lock"><a class="permalink" href="#$lock">$lock-&gt;<b>cds_unlock()</b>;</a></h2>
<p class="Pp">Removes a CDS lock. The destruction of the CDS lock object
    automatically calls this method.</p>
<p class="Pp">Note that if multiple CDS lock objects are created, the underlying
    write lock will not be released until all CDS lock objects are either
    explicitly unlocked with this method, or the CDS lock objects have been
    destroyed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$ref_=_$db"><a class="permalink" href="#$ref_=_$db">$ref =
  $db-&gt;<b>db_stat()</b></a></h2>
<p class="Pp">Returns a reference to an associative array containing information
    about the database. The keys of the associative array correspond directly to
    the names of the fields defined in the Berkeley DB documentation. For
    example, in the DB documentation, the field <b>bt_version</b> stores the
    version of the Btree database. Assuming you called <b>db_stat</b> on a Btree
    database the equivalent field would be accessed as follows:</p>
<p class="Pp"></p>
<pre>
    $version = $ref-&gt;{'bt_version'} ;
</pre>
<p class="Pp">If you are using Berkeley DB 3.x or better, this method will work
    will all database formats. When DB 2.x is used, it only works with
    <b>BerkeleyDB::Btree</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss">$status = $db-&gt;<b>status()</b></h2>
<p class="Pp">Returns the status of the last <span class="Li">$db</span> method
    called.</p>
</section>
<section class="Ss">
<h2 class="Ss">$status = $db-&gt;truncate($count)</h2>
<p class="Pp">Truncates the database and returns the number or records deleted
    in <span class="Li">$count</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss">$status = $db-&gt;compact($start, $stop, $c_data, $flags,
  $end);</h2>
<p class="Pp">Compacts the database <span class="Li">$db</span>.</p>
<p class="Pp">All the parameters are optional - if only want to make use of some
    of them, use <span class="Li">&quot;undef&quot;</span> for those you don't
    want. Trailing unused parameters can be omitted. For example, if you only
    want to use the <span class="Li">$c_data</span> parameter to set the
    <span class="Li">&quot;compact_fillpercent&quot;</span>, write you code like
    this</p>
<p class="Pp"></p>
<pre>
    my %hash;
    $hash{compact_fillpercent} = 50;
    $db-&gt;compact(undef, undef, \%hash);
</pre>
<p class="Pp">The parameters operate identically to the C equivalent of this
    method. The <span class="Li">$c_data</span> needs a bit of explanation - it
    must be a hash reference. The values of the following keys can be set before
    calling <span class="Li">&quot;compact&quot;</span> and will affect the
    operation of the compaction.</p>
<ul class="Bl-bullet">
  <li>compact_fillpercent</li>
  <li>compact_timeout</li>
</ul>
<p class="Pp">The following keys, along with associated values, will be created
    in the hash reference if the <span class="Li">&quot;compact&quot;</span>
    operation was successful.</p>
<ul class="Bl-bullet">
  <li>compact_deadlock</li>
  <li>compact_levels</li>
  <li>compact_pages_free</li>
  <li>compact_pages_examine</li>
  <li>compact_pages_truncated</li>
</ul>
<p class="Pp">You need to be running Berkeley DB 4.4 or better if you want to
    make use of <span class="Li">&quot;compact&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss">$status = $db-&gt;associate($secondary, \&amp;key_callback)</h2>
<p class="Pp">Associate <span class="Li">$db</span> with the secondary DB
    <span class="Li">$secondary</span></p>
<p class="Pp">New key/value pairs inserted to the database will be passed to the
    callback which must set its third argument to the secondary key to allow
    lookup. If an array reference is set multiple keys secondary keys will be
    associated with the primary database entry.</p>
<p class="Pp">Data may be retrieved fro the secondary database using
    <span class="Li">&quot;db_pget&quot;</span> to also obtain the primary
  key.</p>
<p class="Pp">Secondary databased are maintained automatically.</p>
</section>
<section class="Ss">
<h2 class="Ss">$status = $db-&gt;associate_foreign($secondary, callback,
  $flags)</h2>
<p class="Pp">Associate a foreign key database <span class="Li">$db</span> with
    the secondary DB <span class="Li">$secondary</span>.</p>
<p class="Pp">The second parameter must be a reference to a sub or
    <span class="Li">&quot;undef&quot;</span>.</p>
<p class="Pp">The <span class="Li">$flags</span> parameter must be either
    <span class="Li">&quot;DB_FOREIGN_CASCADE&quot;</span>,
    <span class="Li">&quot;DB_FOREIGN_ABORT&quot;</span> or
    <span class="Li">&quot;DB_FOREIGN_NULLIFY&quot;</span>.</p>
<p class="Pp">When the flags parameter is
    <span class="Li">&quot;DB_FOREIGN_NULLIFY&quot;</span> the second parameter
    is a reference to a sub of the form</p>
<p class="Pp"></p>
<pre>
    sub foreign_cb
    {
        my $key = \$_[0];
        my $value = \$_[1];
        my $foreignkey = \$_[2];
        my $changed = \$_[3] ;

        # for ... set $$value and set $$changed to 1

        return 0;
    }

    $foreign_db-&gt;associate_foreign($secondary, \&amp;foreign_cb, DB_FOREIGN_NULLIFY);
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CURSORS"><a class="permalink" href="#CURSORS">CURSORS</a></h1>
<p class="Pp">A cursor is used whenever you want to access the contents of a
    database in sequential order. A cursor object is created with the
    <span class="Li">&quot;db_cursor&quot;</span></p>
<p class="Pp">A cursor object has the following methods available:</p>
<section class="Ss">
<h2 class="Ss" id="$newcursor_=_$cursor"><a class="permalink" href="#$newcursor_=_$cursor">$newcursor
  = $cursor-&gt;c_dup($flags)</a></h2>
<p class="Pp">Creates a duplicate of <span class="Li">$cursor</span>. This
    method needs Berkeley DB 3.0.x or better.</p>
<p class="Pp">The <span class="Li">$flags</span> parameter is optional and can
    take the following value:</p>
<dl class="Bl-tag">
  <dt id="DB_POSITION"><a class="permalink" href="#DB_POSITION">DB_POSITION</a></dt>
  <dd>When present this flag will position the new cursor at the same place as
      the existing cursor.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">$status = $cursor-&gt;c_get($key, $value, $flags)</h2>
<p class="Pp">Reads a key/value pair from the database, returning the data in
    <span class="Li">$key</span> and <span class="Li">$value</span>. The
    key/value pair actually read is controlled by the
    <span class="Li">$flags</span> parameter, which can take <b>one</b> of the
    following values:</p>
<dl class="Bl-tag">
  <dt id="DB_FIRST"><a class="permalink" href="#DB_FIRST"><b>DB_FIRST</b></a></dt>
  <dd>Set the cursor to point to the first key/value pair in the database.
      Return the key/value pair in <span class="Li">$key</span> and
      <span class="Li">$value</span>.</dd>
  <dt id="DB_LAST"><a class="permalink" href="#DB_LAST"><b>DB_LAST</b></a></dt>
  <dd>Set the cursor to point to the last key/value pair in the database. Return
      the key/value pair in <span class="Li">$key</span> and
      <span class="Li">$value</span>.</dd>
  <dt id="DB_NEXT"><a class="permalink" href="#DB_NEXT"><b>DB_NEXT</b></a></dt>
  <dd>If the cursor is already pointing to a key/value pair, it will be
      incremented to point to the next key/value pair and return its contents.
    <p class="Pp">If the cursor isn't initialised, <b>DB_NEXT</b> works just
        like <b>DB_FIRST</b>.</p>
    <p class="Pp">If the cursor is already positioned at the last key/value
        pair, <b>c_get</b> will return <b>DB_NOTFOUND</b>.</p>
  </dd>
  <dt id="DB_NEXT_DUP"><a class="permalink" href="#DB_NEXT_DUP"><b>DB_NEXT_DUP</b></a></dt>
  <dd>This flag is only valid when duplicate keys have been enabled in a
      database. If the cursor is already pointing to a key/value pair and the
      key of the next key/value pair is identical, the cursor will be
      incremented to point to it and their contents returned.</dd>
  <dt id="DB_PREV"><a class="permalink" href="#DB_PREV"><b>DB_PREV</b></a></dt>
  <dd>If the cursor is already pointing to a key/value pair, it will be
      decremented to point to the previous key/value pair and return its
      contents.
    <p class="Pp">If the cursor isn't initialised, <b>DB_PREV</b> works just
        like <b>DB_LAST</b>.</p>
    <p class="Pp">If the cursor is already positioned at the first key/value
        pair, <b>c_get</b> will return <b>DB_NOTFOUND</b>.</p>
  </dd>
  <dt id="DB_CURRENT"><a class="permalink" href="#DB_CURRENT"><b>DB_CURRENT</b></a></dt>
  <dd>If the cursor has been set to point to a key/value pair, return their
      contents. If the key/value pair referenced by the cursor has been deleted,
      <b>c_get</b> will return <b>DB_KEYEMPTY</b>.</dd>
  <dt id="DB_SET"><a class="permalink" href="#DB_SET"><b>DB_SET</b></a></dt>
  <dd>Set the cursor to point to the key/value pair referenced by
      <b></b><b>$key</b><b></b> and return the value in
      <b></b><b>$value</b><b></b>.</dd>
  <dt id="DB_SET_RANGE"><a class="permalink" href="#DB_SET_RANGE"><b>DB_SET_RANGE</b></a></dt>
  <dd>This flag is a variation on the <b>DB_SET</b> flag. As well as returning
      the value, it also returns the key, via <b></b><b>$key</b><b></b>. When
      used with a <b>BerkeleyDB::Btree</b> database the key matched by
      <b>c_get</b> will be the shortest key (in length) which is greater than or
      equal to the key supplied, via <b></b><b>$key</b><b></b>. This allows
      partial key searches. See ??? for an example of how to use this flag.</dd>
  <dt id="DB_GET_BOTH~2"><a class="permalink" href="#DB_GET_BOTH~2"><b>DB_GET_BOTH</b></a></dt>
  <dd>Another variation on <b>DB_SET</b>. This one returns both the key and the
      value.</dd>
  <dt id="DB_SET_RECNO~2"><a class="permalink" href="#DB_SET_RECNO~2"><b>DB_SET_RECNO</b></a></dt>
  <dd>TODO.</dd>
  <dt id="DB_GET_RECNO"><a class="permalink" href="#DB_GET_RECNO"><b>DB_GET_RECNO</b></a></dt>
  <dd>TODO.</dd>
</dl>
<p class="Pp">In addition, the following value may be set by bitwise OR'ing it
    into the <b></b><b>$flags</b><b></b> parameter:</p>
<dl class="Bl-tag">
  <dt id="DB_RMW~3"><a class="permalink" href="#DB_RMW~3"><b>DB_RMW</b></a></dt>
  <dd>TODO.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">$status = $cursor-&gt;c_put($key, $value, $flags)</h2>
<p class="Pp">Stores the key/value pair in the database. The position that the
    data is stored in the database is controlled by the
    <span class="Li">$flags</span> parameter, which must take <b>one</b> of the
    following values:</p>
<dl class="Bl-tag">
  <dt id="DB_AFTER"><a class="permalink" href="#DB_AFTER"><b>DB_AFTER</b></a></dt>
  <dd>When used with a Btree or Hash database, a duplicate of the key referenced
      by the current cursor position will be created and the contents of
      <b></b><b>$value</b><b></b> will be associated with it -
      <b></b><b>$key</b><b></b> is ignored. The new key/value pair will be
      stored immediately after the current cursor position. Obviously the
      database has to have been opened with <b>DB_DUP</b>.
    <p class="Pp">When used with a Recno ... TODO</p>
  </dd>
  <dt id="DB_BEFORE"><a class="permalink" href="#DB_BEFORE"><b>DB_BEFORE</b></a></dt>
  <dd>When used with a Btree or Hash database, a duplicate of the key referenced
      by the current cursor position will be created and the contents of
      <b></b><b>$value</b><b></b> will be associated with it -
      <b></b><b>$key</b><b></b> is ignored. The new key/value pair will be
      stored immediately before the current cursor position. Obviously the
      database has to have been opened with <b>DB_DUP</b>.
    <p class="Pp">When used with a Recno ... TODO</p>
  </dd>
  <dt id="DB_CURRENT~2"><a class="permalink" href="#DB_CURRENT~2"><b>DB_CURRENT</b></a></dt>
  <dd>If the cursor has been initialised, replace the value of the key/value
      pair stored in the database with the contents of
      <b></b><b>$value</b><b></b>.</dd>
  <dt id="DB_KEYFIRST"><a class="permalink" href="#DB_KEYFIRST"><b>DB_KEYFIRST</b></a></dt>
  <dd>Only valid with a Btree or Hash database. This flag is only really used
      when duplicates are enabled in the database and sorted duplicates haven't
      been specified. In this case the key/value pair will be inserted as the
      first entry in the duplicates for the particular key.</dd>
  <dt id="DB_KEYLAST"><a class="permalink" href="#DB_KEYLAST"><b>DB_KEYLAST</b></a></dt>
  <dd>Only valid with a Btree or Hash database. This flag is only really used
      when duplicates are enabled in the database and sorted duplicates haven't
      been specified. In this case the key/value pair will be inserted as the
      last entry in the duplicates for the particular key.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss">$status = $cursor-&gt;c_del([$flags])</h2>
<p class="Pp">This method deletes the key/value pair associated with the current
    cursor position. The cursor position will not be changed by this operation,
    so any subsequent cursor operation must first initialise the cursor to point
    to a valid key/value pair.</p>
<p class="Pp">If the key/value pair associated with the cursor have already been
    deleted, <b>c_del</b> will return <b>DB_KEYEMPTY</b>.</p>
<p class="Pp">The <b></b><b>$flags</b><b></b> parameter is not used at
  present.</p>
</section>
<section class="Ss">
<h2 class="Ss">$status = $cursor-&gt;c_count($cnt [, $flags])</h2>
<p class="Pp">Stores the number of duplicates at the current cursor position in
    <b></b><b>$cnt</b><b></b>.</p>
<p class="Pp">The <b></b><b>$flags</b><b></b> parameter is not used at present.
    This method needs Berkeley DB 3.1 or better.</p>
</section>
<section class="Ss">
<h2 class="Ss">$status = $cursor-&gt;<b>status()</b></h2>
<p class="Pp">Returns the status of the last cursor method as a dual type.</p>
</section>
<section class="Ss">
<h2 class="Ss">$status = $cursor-&gt;<b>c_pget()</b> ;</h2>
<p class="Pp">See <span class="Li">&quot;db_pget&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss">$status = $cursor-&gt;<b>c_close()</b></h2>
<p class="Pp">Closes the cursor <b></b><b>$cursor</b><b></b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$stream_=_$cursor"><a class="permalink" href="#$stream_=_$cursor">$stream
  = $cursor-&gt;db_stream($flags);</a></h2>
<p class="Pp">Create a BerkeleyDB::DbStream object to read the blob at the
    current cursor location. See Blob for details of the the
    BerkeleyDB::DbStream object.</p>
<p class="Pp"><span class="Li">$flags</span> must be one or more of the
    following OR'ed together</p>
<p class="Pp">DB_STREAM_READ DB_STREAM_WRITE DB_STREAM_SYNC_WRITE</p>
<p class="Pp">For full information on the flags refer to the Berkeley DB
    Reference Guide.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Cursor_Examples"><a class="permalink" href="#Cursor_Examples">Cursor
  Examples</a></h2>
<p class="Pp">TODO</p>
<p class="Pp">Iterating from first to last, then in reverse.</p>
<p class="Pp">examples of each of the flags.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="JOIN"><a class="permalink" href="#JOIN">JOIN</a></h1>
<p class="Pp">Join support for BerkeleyDB is in progress. Watch this space.</p>
<p class="Pp">TODO</p>
</section>
<section class="Sh">
<h1 class="Sh" id="TRANSACTIONS"><a class="permalink" href="#TRANSACTIONS">TRANSACTIONS</a></h1>
<p class="Pp">Transactions are created using the
    <span class="Li">&quot;txn_begin&quot;</span> method on BerkeleyDB::Env:</p>
<p class="Pp"></p>
<pre>
        my $txn = $env-&gt;txn_begin;
</pre>
<p class="Pp">If this is a nested transaction, supply the parent transaction as
    an argument:</p>
<p class="Pp"></p>
<pre>
        my $child_txn = $env-&gt;txn_begin($parent_txn);
</pre>
<p class="Pp">Then in order to work with the transaction, you must set it as the
    current transaction on the database handles you want to work with:</p>
<p class="Pp"></p>
<pre>
        $db-&gt;Txn($txn);
</pre>
<p class="Pp">Or for multiple handles:</p>
<p class="Pp"></p>
<pre>
        $txn-&gt;Txn(@handles);
</pre>
<p class="Pp">The current transaction is given by BerkeleyDB each time to the
    various BDB operations. In the C api it is required explicitly as an
    argument to every operation.</p>
<p class="Pp">To commit a transaction call the
    <span class="Li">&quot;commit&quot;</span> method on it:</p>
<p class="Pp"></p>
<pre>
        $txn-&gt;txn_commit;
</pre>
<p class="Pp">and to roll back call abort:</p>
<p class="Pp"></p>
<pre>
        $txn-&gt;txn_abort
</pre>
<p class="Pp">After committing or aborting a child transaction you need to set
    the active transaction again using
  <span class="Li">&quot;Txn&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BerkeleyDBB::DbStream_--_support_for_BLOB"><a class="permalink" href="#BerkeleyDBB::DbStream_--_support_for_BLOB">BerkeleyDBB::DbStream
  -- support for BLOB</a></h1>
<p class="Pp">Blob support is available in Berkeley DB starting with version
    6.0. Refer to the section &quot;Blob Support&quot; in the Berkeley DB
    Programmer Reference for details of how Blob supports works.</p>
<p class="Pp">A Blob is access via a BerkeleyDBB::DbStream object. This is
    created via a cursor object.</p>
<p class="Pp"></p>
<pre>
    # Note - error handling not shown below.

    # Set the key we want
    my $k = &quot;some key&quot;;

    # Don't want the value retrieved by the cursor,
    # so use partial_set to make sure no data is retrieved.
    my $v = '';
    $cursor-&gt;partial_set(0,0) ;
    $cursor-&gt;c_get($k, $v, DB_SET) ;
    $cursor-&gt;partial_clear() ;

    # Now create a stream to the blob
    my $stream = $cursor-&gt;db_stream(DB_STREAM_WRITE) ;

    # get the size of the blob
    $stream-&gt;size(my $s) ;

    # Read the first 1k of data from the blob
    my $data ;
    $stream-&gt;read($data, 0, 1024);
</pre>
<p class="Pp">A BerkeleyDB::DbStream object has the following methods
  available:</p>
<section class="Ss">
<h2 class="Ss">$status = $stream-&gt;size($SIZE);</h2>
<p class="Pp">Outputs the length of the Blob in the
    <span class="Li">$SIZE</span> parameter.</p>
</section>
<section class="Ss">
<h2 class="Ss">$status = $stream-&gt;read($data, $offset, $size);</h2>
<p class="Pp">Read from the blob. <span class="Li">$offset</span> is the number
    of bytes from the start of the blob to read from.
    <span class="Li">$size</span> if the number of bytes to read.</p>
</section>
<section class="Ss">
<h2 class="Ss">$status = $stream-&gt;write($data, $offset, $flags);</h2>
<p class="Pp">Write <span class="Li">$data</span> to the blob, starting at
    offset <span class="Li">$offset</span>.</p>
<p class="Pp">Example</p>
<p class="Pp">Below is an example of how to walk through a database when you
    don't know beforehand which entries are blobs and which are not.</p>
<p class="Pp"></p>
<pre>
    while (1)
    {
        my $k = '';
        my $v = '';
        $cursor-&gt;partial_set(0,0) ;
        my $status = $cursor-&gt;c_get($k, $v, DB_NEXT) ;
        $cursor-&gt;partial_clear();

        last if $status != 0 ;

        my $stream = $cursor-&gt;db_stream(DB_STREAM_WRITE);

        if (defined $stream)
        {
            # It's a Blob
            $stream-&gt;size(my $s) ;
        }
        else
        {
            # Not a Blob
            $cursor-&gt;c_get($k, $v, DB_CURRENT) ;
        }
    }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Berkeley_DB_Concurrent_Data_Store_(CDS)"><a class="permalink" href="#Berkeley_DB_Concurrent_Data_Store_(CDS)">Berkeley
  DB Concurrent Data Store (CDS)</a></h1>
<p class="Pp">The Berkeley DB <i>Concurrent Data Store</i> (CDS) is a
    lightweight locking mechanism that is useful in scenarios where transactions
    are overkill.</p>
<section class="Ss">
<h2 class="Ss" id="What_is_"><a class="permalink" href="#What_is_">What is
  CDS?</a></h2>
<p class="Pp">The Berkeley DB CDS interface is a simple lightweight locking
    mechanism that allows safe concurrent access to Berkeley DB databases. Your
    application can have multiple reader and write processes, but Berkeley DB
    will arrange it so that only one process can have a write lock against the
    database at a time, i.e. multiple processes can read from a database
    concurrently, but all write processes will be serialised.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Should_I_use_it?"><a class="permalink" href="#Should_I_use_it?">Should
  I use it?</a></h2>
<p class="Pp">Whilst this simple locking model is perfectly adequate for some
    applications, it will be too restrictive for others. Before deciding on
    using CDS mode, you need to be sure that it is suitable for the expected
    behaviour of your application.</p>
<p class="Pp">The key features of this model are</p>
<ul class="Bl-bullet">
  <li>All writes operations are serialised.</li>
  <li>A write operation will block until all reads have finished.</li>
</ul>
<p class="Pp">There are a few of the attributes of your application that you
    need to be aware of before choosing to use CDS.</p>
<p class="Pp">Firstly, if you application needs either recoverability or
    transaction support, then CDS will not be suitable.</p>
<p class="Pp">Next what is the ratio of read operation to write operations will
    your application have?</p>
<p class="Pp">If it is carrying out mostly read operations, and very few writes,
    then CDS may be appropriate.</p>
<p class="Pp">What is the expected throughput of reads/writes in your
    application?</p>
<p class="Pp">If you application does 90% writes and 10% reads, but on average
    you only have a transaction every 5 seconds, then the fact that all writes
    are serialised will not matter, because there will hardly ever be multiple
    writes processes blocking.</p>
<p class="Pp">In summary CDS mode may be appropriate for your application if it
    performs mostly reads and very few writes or there is a low throughput.
    Also, if you do not need to be able to roll back a series of database
    operations if an error occurs, then CDS is ok.</p>
<p class="Pp">If any of these is not the case you will need to use Berkeley DB
    transactions. That is outside the scope of this document.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Locking_Used"><a class="permalink" href="#Locking_Used">Locking
  Used</a></h2>
<p class="Pp">Berkeley DB implements CDS mode using two kinds of lock behind the
    scenes - namely read locks and write locks. A read lock allows multiple
    processes to access the database for reading at the same time. A write lock
    will only get access to the database when there are no read or write locks
    active. The write lock will block until the process holding the lock
    releases it.</p>
<p class="Pp">Multiple processes with read locks can all access the database at
    the same time as long as no process has a write lock. A process with a write
    lock can only access the database if there are no other active read or write
    locks.</p>
<p class="Pp">The majority of the time the Berkeley DB CDS mode will handle all
    locking without your application having to do anything. There are a couple
    of exceptions you need to be aware of though - these will be discussed in
    &quot;Safely Updating Records&quot; and &quot;Implicit Cursors&quot;
  below.</p>
<p class="Pp">A Berkeley DB Cursor (created with
    <span class="Li">&quot;$db-&gt;db_cursor&quot;</span>) will by hold a lock
    on the database until it is either explicitly closed or destroyed. This
    means the lock has the potential to be long lived.</p>
<p class="Pp">By default Berkeley DB cursors create a read lock, but it is
    possible to create a cursor that holds a write lock, thus</p>
<p class="Pp"></p>
<pre>
    $cursor = $db-&gt;db_cursor(DB_WRITECURSOR);
</pre>
<p class="Pp">Whilst either a read or write cursor is active, it will block any
    other processes that wants to write to the database.</p>
<p class="Pp">To avoid blocking problems, only keep cursors open as long as they
    are needed. The same is true when you use the
    <span class="Li">&quot;cursor&quot;</span> method or the
    <span class="Li">&quot;cds_lock&quot;</span> method.</p>
<p class="Pp">For full information on CDS see the &quot;Berkeley DB Concurrent
    Data Store applications&quot; section in the Berkeley DB Reference
  Guide.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Opening_a_database_for_"><a class="permalink" href="#Opening_a_database_for_">Opening
  a database for CDS</a></h2>
<p class="Pp">Here is the typical signature that is used when opening a database
    in CDS mode.</p>
<p class="Pp"></p>
<pre>
    use BerkeleyDB ;

    my $env = new BerkeleyDB::Env
                  -Home   =&gt; &quot;./home&quot; ,
                  -Flags  =&gt; DB_CREATE| DB_INIT_CDB | DB_INIT_MPOOL
        or die &quot;cannot open environment: $BerkeleyDB::Error\n&quot;;

    my $db  = new BerkeleyDB::Hash
                -Filename       =&gt; 'test1.db',
                -Flags          =&gt; DB_CREATE,
                -Env            =&gt; $env
        or die &quot;cannot open database: $BerkeleyDB::Error\n&quot;;
</pre>
<p class="Pp">or this, if you use the tied interface</p>
<p class="Pp"></p>
<pre>
    tie %hash, &quot;BerkeleyDB::Hash&quot;,
                -Filename       =&gt; 'test2.db',
                -Flags          =&gt; DB_CREATE,
                -Env            =&gt; $env
        or die &quot;cannot open database: $BerkeleyDB::Error\n&quot;;
</pre>
<p class="Pp">The first thing to note is that you <b>MUST</b> always use a
    Berkeley DB environment if you want to use locking with Berkeley DB.</p>
<p class="Pp">Remember, that apart from the actual database files you explicitly
    create yourself, Berkeley DB will create a few behind the scenes to handle
    locking - they usually have names like &quot;__db.001&quot;. It is therefore
    a good idea to use the <span class="Li">&quot;-Home&quot;</span> option,
    unless you are happy for all these files to be written in the current
    directory.</p>
<p class="Pp">Next, remember to include the
    <span class="Li">&quot;DB_CREATE&quot;</span> flag when opening the
    environment for the first time. A common mistake is to forget to add this
    option and then wonder why the application doesn't work.</p>
<p class="Pp">Finally, it is vital that all processes that are going to access
    the database files use the same Berkeley DB environment.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Safely_Updating_a_Record"><a class="permalink" href="#Safely_Updating_a_Record">Safely
  Updating a Record</a></h2>
<p class="Pp">One of the main gotchas when using CDS is if you want to update a
    record in a database, i.e. you want to retrieve a record from a database,
    modify it in some way and put it back in the database.</p>
<p class="Pp">For example, say you are writing a web application and you want to
    keep a record of the number of times your site is accessed in a Berkeley DB
    database. So your code will have a line of code like this (assume, of
    course, that <span class="Li">%hash</span> has been tied to a Berkeley DB
    database):</p>
<p class="Pp"></p>
<pre>
    $hash{Counter} ++ ;
</pre>
<p class="Pp">That may look innocent enough, but there is a race condition
    lurking in there. If I rewrite the line of code using the low-level Berkeley
    DB API, which is what will actually be executed, the race condition may be
    more apparent:</p>
<p class="Pp"></p>
<pre>
    $db-&gt;db_get(&quot;Counter&quot;, $value);
    ++ $value ;
    $db-&gt;db_put(&quot;Counter&quot;, $value);
</pre>
<p class="Pp">Consider what happens behind the scenes when you execute the
    commands above. Firstly, the existing value for the key &quot;Counter&quot;
    is fetched from the database using
    <span class="Li">&quot;db_get&quot;</span>. A read lock will be used for
    this part of the update. The value is then incremented, and the new value is
    written back to the database using
    <span class="Li">&quot;db_put&quot;</span>. This time a write lock will be
    used.</p>
<p class="Pp">Here's the problem - there is nothing to stop two (or more)
    processes executing the read part at the same time. Remember multiple
    processes can hold a read lock on the database at the same time. So both
    will fetch the same value, let's say 7, from the database. Both increment
    the value to 8 and attempt to write it to the database. Berkeley DB will
    ensure that only one of the processes gets a write lock, while the other
    will be blocked. So the process that happened to get the write lock will
    store the value 8 to the database and release the write lock. Now the other
    process will be unblocked, and it too will write the value 8 to the
    database. The result, in this example, is we have missed a hit in the
    counter.</p>
<p class="Pp">To deal with this kind of scenario, you need to make the update
    atomic. A convenience method, called
    <span class="Li">&quot;cds_lock&quot;</span>, is supplied with the
    BerkeleyDB module for this purpose. Using
    <span class="Li">&quot;cds_lock&quot;</span>, the counter update code can
    now be rewritten thus:</p>
<p class="Pp"></p>
<pre>
    my $lk = $dbh-&gt;cds_lock() ; 
    $hash{Counter} ++ ;
    $lk-&gt;cds_unlock;
</pre>
<p class="Pp">or this, where scoping is used to limit the lifetime of the lock
    object</p>
<p class="Pp"></p>
<pre>
    {
        my $lk = $dbh-&gt;cds_lock() ;
        $hash{Counter} ++ ;
    }
</pre>
<p class="Pp">Similarly, <span class="Li">&quot;cds_lock&quot;</span> can be
    used with the native Berkeley DB API</p>
<p class="Pp"></p>
<pre>
    my $lk = $dbh-&gt;cds_lock() ;
    $db-&gt;db_get(&quot;Counter&quot;, $value);
    ++ $value ;
    $db-&gt;db_put(&quot;Counter&quot;, $value);
    $lk-&gt;unlock;
</pre>
<p class="Pp">The <span class="Li">&quot;cds_lock&quot;</span> method will
    ensure that the current process has exclusive access to the database until
    the lock is either explicitly released, via the
    <span class="Li">&quot;$lk-&gt;cds_unlock()&quot;</span> or by the lock
    object being destroyed.</p>
<p class="Pp">If you are interested, all that
    <span class="Li">&quot;cds_lock&quot;</span> does is open a
    &quot;write&quot; cursor. This has the useful side-effect of holding a
    write-lock on the database until the cursor is deleted. This is how you
    create a write-cursor</p>
<p class="Pp"></p>
<pre>
    $cursor = $db-&gt;db_cursor(DB_WRITECURSOR);
</pre>
<p class="Pp">If you have instantiated multiple
    <span class="Li">&quot;cds_lock&quot;</span> objects for one database within
    a single process, that process will hold a write-lock on the database until
    <i>ALL</i> <span class="Li">&quot;cds_lock&quot;</span> objects have been
    destroyed.</p>
<p class="Pp">As with all write-cursors, you should try to limit the scope of
    the <span class="Li">&quot;cds_lock&quot;</span> to as short a time as
    possible. Remember the complete database will be locked to other process
    whilst the write lock is in place.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Cannot_write_with_a_read_cursor_while_a_write_cursor_is_active"><a class="permalink" href="#Cannot_write_with_a_read_cursor_while_a_write_cursor_is_active">Cannot
  write with a read cursor while a write cursor is active</a></h2>
<p class="Pp">This issue is easier to demonstrate with an example, so consider
    the code below. The intention of the code is to increment the values of all
    the elements in a database by one.</p>
<p class="Pp"></p>
<pre>
    # Assume $db is a database opened in a CDS environment.

    # Create a write-lock
    my $lock = $db-&gt;db_cursor(DB_WRITECURSOR);
    # or 
    # my $lock = $db-&gt;cds_lock();

    
    my $cursor = $db-&gt;db_cursor();

    # Now loop through the database, and increment
    # each value using c_put.
    while ($cursor-&gt;c_get($key, $value, DB_NEXT) == 0) 
    {
         $cursor-&gt;c_put($key, $value+1, DB_CURRENT) == 0
             or die &quot;$BerkeleyDB::Error\n&quot;;
    }
</pre>
<p class="Pp">When this code is run, it will fail on the
    <span class="Li">&quot;c_put&quot;</span> line with this error</p>
<p class="Pp"></p>
<pre>
    Write attempted on read-only cursor
</pre>
<p class="Pp">The read cursor has automatically disallowed a write operation to
    prevent a deadlock.</p>
<p class="Pp">So the rule is -- you <b>CANNOT</b> carry out a write operation
    using a read-only cursor (i.e. you cannot use
    <span class="Li">&quot;c_put&quot;</span> or
    <span class="Li">&quot;c_del&quot;</span>) whilst another write-cursor is
    already active.</p>
<p class="Pp">The workaround for this issue is to just use
    <span class="Li">&quot;db_put&quot;</span> instead of
    <span class="Li">&quot;c_put&quot;</span>, like this</p>
<p class="Pp"></p>
<pre>
    # Assume $db is a database opened in a CDS environment.

    # Create a write-lock
    my $lock = $db-&gt;db_cursor(DB_WRITECURSOR);
    # or 
    # my $lock = $db-&gt;cds_lock();

    
    my $cursor = $db-&gt;db_cursor();

    # Now loop through the database, and increment
    # each value using c_put.
    while ($cursor-&gt;c_get($key, $value, DB_NEXT) == 0) 
    {
         $db-&gt;db_put($key, $value+1) == 0
             or die &quot;$BerkeleyDB::Error\n&quot;;
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Implicit_Cursors"><a class="permalink" href="#Implicit_Cursors">Implicit
  Cursors</a></h2>
<p class="Pp">All Berkeley DB cursors will hold either a read lock or a write
    lock on the database for the existence of the cursor. In order to prevent
    blocking of other processes you need to make sure that they are not long
    lived.</p>
<p class="Pp">There are a number of instances where the Perl interface to
    Berkeley DB will create a cursor behind the scenes without you being aware
    of it. Most of these are very short-lived and will not affect the running of
    your script, but there are a few notable exceptions.</p>
<p class="Pp">Consider this snippet of code</p>
<p class="Pp"></p>
<pre>
    while (my ($k, $v) = each %hash)
    {
        # do something
    }
</pre>
<p class="Pp">To implement the &quot;each&quot; functionality, a read cursor
    will be created behind the scenes to allow you to iterate through the tied
    hash, <span class="Li">%hash</span>. While that cursor is still active, a
    read lock will obviously be held against the database. If your application
    has any other writing processes, these will be blocked until the read cursor
    is closed. That won't happen until the loop terminates.</p>
<p class="Pp">To avoid blocking problems, only keep cursors open as long as they
    are needed. The same is true when you use the
    <span class="Li">&quot;cursor&quot;</span> method or the
    <span class="Li">&quot;cds_lock&quot;</span> method.</p>
<p class="Pp">The locking behaviour of the
    <span class="Li">&quot;values&quot;</span> or
    <span class="Li">&quot;keys&quot;</span> functions, shown below, is subtly
    different.</p>
<p class="Pp"></p>
<pre>
    foreach my $k (keys %hash)
    {
        # do something
    }

    foreach my $v (values %hash)
    {
        # do something
    }
</pre>
<p class="Pp">Just as in the <span class="Li">&quot;each&quot;</span> function,
    a read cursor will be created to iterate over the database in both of these
    cases. Where <span class="Li">&quot;keys&quot;</span> and
    <span class="Li">&quot;values&quot;</span> differ is the place where the
    cursor carries out the iteration through the database. Whilst
    <span class="Li">&quot;each&quot;</span> carried out a single iteration
    every time it was invoked, the <span class="Li">&quot;keys&quot;</span> and
    <span class="Li">&quot;values&quot;</span> functions will iterate through
    the entire database in one go -- the complete database will be read into
    memory before the first iteration of the loop.</p>
<p class="Pp">Apart from the fact that a read lock will be held for the amount
    of time required to iterate through the database, the use of
    <span class="Li">&quot;keys&quot;</span> and
    <span class="Li">&quot;values&quot;</span> is <b>not</b> recommended because
    it will result in the complete database being read into memory.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Avoiding_Deadlock_with_multiple_databases"><a class="permalink" href="#Avoiding_Deadlock_with_multiple_databases">Avoiding
  Deadlock with multiple databases</a></h2>
<p class="Pp">If your CDS application uses multiple database files, and you need
    to write to more than one of them, you need to be careful you don't create a
    deadlock.</p>
<p class="Pp">For example, say you have two databases, D1 and D2, and two
    processes, P1 and P2. Assume you want to write a record to each database. If
    P1 writes the records to the databases in the order D1, D2 while process P2
    writes the records in the order D2, D1, there is the potential for a
    deadlock to occur.</p>
<p class="Pp">This scenario can be avoided by either always acquiring the write
    locks in exactly the same order in your application code, or by using the
    <span class="Li">&quot;DB_CDB_ALLDB&quot;</span> flag when opening the
    environment. This flag will make a write-lock apply to all the databases in
    the environment.</p>
<p class="Pp">Add example here</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DBM_Filters"><a class="permalink" href="#DBM_Filters">DBM
  Filters</a></h1>
<p class="Pp">A DBM Filter is a piece of code that is be used when you
    <i>always</i> want to make the same transformation to all keys and/or values
    in a DBM database. All of the database classes (BerkeleyDB::Hash,
    BerkeleyDB::Btree and BerkeleyDB::Recno) support DBM Filters.</p>
<p class="Pp">There are four methods associated with DBM Filters. All work
    identically, and each is used to install (or uninstall) a single DBM Filter.
    Each expects a single parameter, namely a reference to a sub. The only
    difference between them is the place that the filter is installed.</p>
<p class="Pp">To summarise:</p>
<dl class="Bl-tag">
  <dt id="filter_store_key"><a class="permalink" href="#filter_store_key"><b>filter_store_key</b></a></dt>
  <dd>If a filter has been installed with this method, it will be invoked every
      time you write a key to a DBM database.</dd>
  <dt id="filter_store_value"><a class="permalink" href="#filter_store_value"><b>filter_store_value</b></a></dt>
  <dd>If a filter has been installed with this method, it will be invoked every
      time you write a value to a DBM database.</dd>
  <dt id="filter_fetch_key"><a class="permalink" href="#filter_fetch_key"><b>filter_fetch_key</b></a></dt>
  <dd>If a filter has been installed with this method, it will be invoked every
      time you read a key from a DBM database.</dd>
  <dt id="filter_fetch_value"><a class="permalink" href="#filter_fetch_value"><b>filter_fetch_value</b></a></dt>
  <dd>If a filter has been installed with this method, it will be invoked every
      time you read a value from a DBM database.</dd>
</dl>
<p class="Pp">You can use any combination of the methods, from none, to all
    four.</p>
<p class="Pp">All filter methods return the existing filter, if present, or
    <span class="Li">&quot;undef&quot;</span> in not.</p>
<p class="Pp">To delete a filter pass <span class="Li">&quot;undef&quot;</span>
    to it.</p>
<section class="Ss">
<h2 class="Ss" id="The_Filter"><a class="permalink" href="#The_Filter">The
  Filter</a></h2>
<p class="Pp">When each filter is called by Perl, a local copy of
    <span class="Li">$_</span> will contain the key or value to be filtered.
    Filtering is achieved by modifying the contents of
    <span class="Li">$_</span>. The return code from the filter is ignored.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="An_Example_--_the_"><a class="permalink" href="#An_Example_--_the_">An
  Example -- the NULL termination problem.</a></h2>
<p class="Pp">Consider the following scenario. You have a DBM database that you
    need to share with a third-party C application. The C application assumes
    that <i>all</i> keys and values are NULL terminated. Unfortunately when Perl
    writes to DBM databases it doesn't use NULL termination, so your Perl
    application will have to manage NULL termination itself. When you write to
    the database you will have to use something like this:</p>
<p class="Pp"></p>
<pre>
    $hash{&quot;$key\0&quot;} = &quot;$value\0&quot; ;
</pre>
<p class="Pp">Similarly the NULL needs to be taken into account when you are
    considering the length of existing keys/values.</p>
<p class="Pp">It would be much better if you could ignore the NULL terminations
    issue in the main application code and have a mechanism that automatically
    added the terminating NULL to all keys and values whenever you write to the
    database and have them removed when you read from the database. As I'm sure
    you have already guessed, this is a problem that DBM Filters can fix very
    easily.</p>
<p class="Pp"></p>
<pre>
    use strict ;
    use BerkeleyDB ;

    my %hash ;
    my $filename = &quot;filt.db&quot; ;
    unlink $filename ;

    my $db = tie %hash, 'BerkeleyDB::Hash',
                -Filename   =&gt; $filename,
                -Flags      =&gt; DB_CREATE
      or die &quot;Cannot open $filename: $!\n&quot; ;

    # Install DBM Filters
    $db-&gt;filter_fetch_key  ( sub { s/\0$//    } ) ;
    $db-&gt;filter_store_key  ( sub { $_ .= &quot;\0&quot; } ) ;
    $db-&gt;filter_fetch_value( sub { s/\0$//    } ) ;
    $db-&gt;filter_store_value( sub { $_ .= &quot;\0&quot; } ) ;

    $hash{&quot;abc&quot;} = &quot;def&quot; ;
    my $a = $hash{&quot;ABC&quot;} ;
    # ...
    undef $db ;
    untie %hash ;
</pre>
<p class="Pp">Hopefully the contents of each of the filters should be
    self-explanatory. Both &quot;fetch&quot; filters remove the terminating
    NULL, and both &quot;store&quot; filters add a terminating NULL.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Another_Example_--_Key_is_a_C_int."><a class="permalink" href="#Another_Example_--_Key_is_a_C_int.">Another
  Example -- Key is a C int.</a></h2>
<p class="Pp">Here is another real-life example. By default, whenever Perl
    writes to a DBM database it always writes the key and value as strings. So
    when you use this:</p>
<p class="Pp"></p>
<pre>
    $hash{12345} = &quot;something&quot; ;
</pre>
<p class="Pp">the key 12345 will get stored in the DBM database as the 5 byte
    string &quot;12345&quot;. If you actually want the key to be stored in the
    DBM database as a C int, you will have to use
    <span class="Li">&quot;pack&quot;</span> when writing, and
    <span class="Li">&quot;unpack&quot;</span> when reading.</p>
<p class="Pp">Here is a DBM Filter that does it:</p>
<p class="Pp"></p>
<pre>
    use strict ;
    use BerkeleyDB ;
    my %hash ;
    my $filename = &quot;filt.db&quot; ;
    unlink $filename ;


    my $db = tie %hash, 'BerkeleyDB::Btree',
                -Filename   =&gt; $filename,
                -Flags      =&gt; DB_CREATE
      or die &quot;Cannot open $filename: $!\n&quot; ;

    $db-&gt;filter_fetch_key  ( sub { $_ = unpack(&quot;i&quot;, $_) } ) ;
    $db-&gt;filter_store_key  ( sub { $_ = pack (&quot;i&quot;, $_) } ) ;
    $hash{123} = &quot;def&quot; ;
    # ...
    undef $db ;
    untie %hash ;
</pre>
<p class="Pp">This time only two filters have been used -- we only need to
    manipulate the contents of the key, so it wasn't necessary to install any
    value filters.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Using_BerkeleyDB_with_MLDBM"><a class="permalink" href="#Using_BerkeleyDB_with_MLDBM">Using
  BerkeleyDB with MLDBM</a></h1>
<p class="Pp">Both BerkeleyDB::Hash and BerkeleyDB::Btree can be used with the
    MLDBM module. The code fragment below shows how to open associate MLDBM with
    BerkeleyDB::Btree. To use BerkeleyDB::Hash just replace BerkeleyDB::Btree
    with BerkeleyDB::Hash.</p>
<p class="Pp"></p>
<pre>
    use strict ;
    use BerkeleyDB ;
    use MLDBM qw(BerkeleyDB::Btree) ;
    use Data::Dumper;
 
    my $filename = 'testmldbm' ;
    my %o ;
     
    unlink $filename ;
    tie %o, 'MLDBM', -Filename =&gt; $filename,
                     -Flags    =&gt; DB_CREATE
                    or die &quot;Cannot open database '$filename: $!\n&quot;;
</pre>
<p class="Pp">See the MLDBM documentation for information on how to use the
    module and for details of its limitations.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">TODO.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="HINTS_&amp;_TIPS"><a class="permalink" href="#HINTS_&amp;_TIPS">HINTS
  &amp; TIPS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Sharing_Databases_With_C_Applications"><a class="permalink" href="#Sharing_Databases_With_C_Applications">Sharing
  Databases With C Applications</a></h2>
<p class="Pp">There is no technical reason why a Berkeley DB database cannot be
    shared by both a Perl and a C application.</p>
<p class="Pp">The vast majority of problems that are reported in this area boil
    down to the fact that C strings are NULL terminated, whilst Perl strings are
    not. See &quot;An Example -- the NULL termination problem.&quot; in the DBM
    FILTERS section for a generic way to work around this problem.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_untie_Gotcha"><a class="permalink" href="#The_untie_Gotcha">The
  untie Gotcha</a></h2>
<p class="Pp">TODO</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="COMMON_QUESTIONS"><a class="permalink" href="#COMMON_QUESTIONS">COMMON
  QUESTIONS</a></h1>
<p class="Pp">This section attempts to answer some of the more common questions
    that I get asked.</p>
<section class="Ss">
<h2 class="Ss" id="Relationship_with_DB_File"><a class="permalink" href="#Relationship_with_DB_File">Relationship
  with DB_File</a></h2>
<p class="Pp">Before Berkeley DB 2.x was written there was only one Perl module
    that interfaced to Berkeley DB. That module is called <b>DB_File</b>.
    Although <b>DB_File</b> can be build with Berkeley DB 1.x, 2.x, 3.x or 4.x,
    it only provides an interface to the functionality available in Berkeley DB
    1.x. That means that it doesn't support transactions, locking or any of the
    other new features available in DB 2.x or better.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_store_Perl_data_structures_with_BerkeleyDB?"><a class="permalink" href="#How_do_I_store_Perl_data_structures_with_BerkeleyDB?">How
  do I store Perl data structures with BerkeleyDB?</a></h2>
<p class="Pp">See &quot;Using BerkeleyDB with MLDBM&quot;.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
<p class="Pp">See the Changes file.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AVAILABILITY"><a class="permalink" href="#AVAILABILITY">AVAILABILITY</a></h1>
<p class="Pp">The most recent version of <b>BerkeleyDB</b> can always be found
    on CPAN (see &quot;CPAN&quot; in perlmod for details), in the directory
    <i>modules/by-module/BerkeleyDB</i>.</p>
<p class="Pp">The official web site for Berkeley DB is
    <i>http://www.oracle.com/technology/products/berkeley-db/db/index.html</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 1997-2013 Paul Marquess. All rights reserved. This
    program is free software; you can redistribute it and/or modify it under the
    same terms as Perl itself.</p>
<p class="Pp">Although <b>BerkeleyDB</b> is covered by the Perl license, the
    library it makes use of, namely Berkeley DB, is not. Berkeley DB has its own
    copyright and its own license. Please take the time to read it.</p>
<p class="Pp">Here are few words taken from the Berkeley DB FAQ (at
    <i>http://www.oracle.com/technology/products/berkeley-db/db/index.html</i>)
    regarding the license:</p>
<p class="Pp"></p>
<pre>
    Do I have to license DB to use it in Perl scripts?

    No. The Berkeley DB license requires that software that uses
    Berkeley DB be freely redistributable. In the case of Perl, that
    software is Perl, and not your scripts. Any Perl scripts that you
    write are your property, including scripts that make use of Berkeley
    DB. Neither the Perl license nor the Berkeley DB license
    place any restriction on what you may do with them.
</pre>
<p class="Pp">If you are in any doubt about the license situation, contact
    either the Berkeley DB authors or the author of BerkeleyDB. See
    &quot;AUTHOR&quot; for details.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Paul Marquess &lt;pmqs@cpan.org&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>perl</b>(1), DB_File, Berkeley DB.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-08-14</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

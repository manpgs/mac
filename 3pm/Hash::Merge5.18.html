<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Hash::Merge(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Hash::Merge(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Hash::Merge(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Hash::Merge - Merges arbitrarily deep hashes into a single
  hash</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
    use Hash::Merge qw( merge );
    my %a = ( 
                'foo'    =&gt; 1,
            'bar'    =&gt; [ qw( a b e ) ],
            'querty' =&gt; { 'bob' =&gt; 'alice' },
        );
    my %b = ( 
                'foo'     =&gt; 2, 
                'bar'    =&gt; [ qw(c d) ],
                'querty' =&gt; { 'ted' =&gt; 'margeret' }, 
        );

    my %c = %{ merge( \%a, \%b ) };

    Hash::Merge::set_behavior( 'RIGHT_PRECEDENT' );

    # This is the same as above

        Hash::Merge::specify_behavior(
            {
                        'SCALAR' =&gt; {
                                'SCALAR' =&gt; sub { $_[1] },
                                'ARRAY'  =&gt; sub { [ $_[0], @{$_[1]} ] },
                                'HASH'   =&gt; sub { $_[1] },
                        },
                        'ARRAY =&gt; {
                                'SCALAR' =&gt; sub { $_[1] },
                                'ARRAY'  =&gt; sub { [ @{$_[0]}, @{$_[1]} ] },
                                'HASH'   =&gt; sub { $_[1] }, 
                        },
                        'HASH' =&gt; {
                                'SCALAR' =&gt; sub { $_[1] },
                                'ARRAY'  =&gt; sub { [ values %{$_[0]}, @{$_[1]} ] },
                                'HASH'   =&gt; sub { Hash::Merge::_merge_hashes( $_[0], $_[1] ) }, 
                        },
                }, 
                'My Behavior', 
        );
        
        # Also there is OO interface.
        
        my $merge = Hash::Merge-&gt;new( 'LEFT_PRECEDENT' );
        my %c = %{ $merge-&gt;merge( \%a, \%b ) };
        
        # All behavioral changes (e.g. $merge-&gt;set_behavior(...)), called on an object remain specific to that object
        # The legacy &quot;Global Setting&quot; behavior is respected only when new called as a non-OO function.
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Hash::Merge merges two arbitrarily deep hashes into a single hash.
    That is, at any level, it will add non-conflicting key-value pairs from one
    hash to the other, and follows a set of specific rules when there are key
    value conflicts (as outlined below). The hash is followed recursively, so
    that deeply nested hashes that are at the same level will be merged when the
    parent hashes are merged. <b>Please note that self-referencing</b>
    <b>hashes, or recursive references, are not handled well by this
  method.</b></p>
<p class="Pp">Values in hashes are considered to be either ARRAY references,
    HASH references, or otherwise are treated as SCALARs. By default, the data
    passed to the merge function will be cloned using the Clone module; however,
    if necessary, this behavior can be changed to use as many of the original
    values as possible. (See
    <span class="Li">&quot;set_clone_behavior&quot;</span>).</p>
<p class="Pp">Because there are a number of possible ways that one may want to
    merge values when keys are conflicting, Hash::Merge provides several preset
    methods for your convenience, as well as a way to define you own. These are
    (currently):</p>
<dl class="Bl-tag">
  <dt id="Left"><a class="permalink" href="#Left">Left Precedence</a></dt>
  <dd>This is the default behavior.
    <p class="Pp">The values buried in the left hash will never be lost; any
        values that can be added from the right hash will be attempted.</p>
    <p class="Pp"></p>
    <pre>
   my $merge = Hash::Merge-&gt;new();
   my $merge = Hash::Merge-&gt;new('LEFT_PRECEDENT');
   $merge-&gt;set_set_behavior('LEFT_PRECEDENT')
   Hash::Merge::set_set_behavior('LEFT_PRECEDENT')
    </pre>
  </dd>
  <dt id="Right"><a class="permalink" href="#Right">Right Precedence</a></dt>
  <dd>Same as Left Precedence, but with the right hash values never being lost
    <p class="Pp"></p>
    <pre>
   my $merge = Hash::Merge-&gt;new('RIGHT_PRECEDENT');
   $merge-&gt;set_set_behavior('RIGHT_PRECEDENT')
   Hash::Merge::set_set_behavior('RIGHT_PRECEDENT')
    </pre>
  </dd>
  <dt id="Storage"><a class="permalink" href="#Storage">Storage
    Precedence</a></dt>
  <dd>If conflicting keys have two different storage mediums, the 'bigger'
      medium will win; arrays are preferred over scalars, hashes over either.
      The other medium will try to be fitted in the other, but if this isn't
      possible, the data is dropped.
    <p class="Pp"></p>
    <pre>
   my $merge = Hash::Merge-&gt;new('STORAGE_PRECEDENT');
   $merge-&gt;set_set_behavior('STORAGE_PRECEDENT')
   Hash::Merge::set_set_behavior('STORAGE_PRECEDENT')
    </pre>
  </dd>
  <dt id="Retainment"><a class="permalink" href="#Retainment">Retainment
    Precedence</a></dt>
  <dd>No data will be lost; scalars will be joined with arrays, and scalars and
      arrays will be 'hashified' to fit them into a hash.
    <p class="Pp"></p>
    <pre>
   my $merge = Hash::Merge-&gt;new('RETAINMENT_PRECEDENT');
   $merge-&gt;set_set_behavior('RETAINMENT_PRECEDENT')
   Hash::Merge::set_set_behavior('RETAINMENT_PRECEDENT')
    </pre>
  </dd>
</dl>
<p class="Pp">Specific descriptions of how these work are detailed below.</p>
<dl class="Bl-tag">
  <dt id="merge"><a class="permalink" href="#merge">merge ( &lt;hashref&gt;,
    &lt;hashref&gt; )</a></dt>
  <dd>Merges two hashes given the rules specified. Returns a reference to the
      new hash.</dd>
  <dt>_hashify( &lt;scalar&gt;|&lt;arrayref&gt; ) -- INTERNAL FUNCTION</dt>
  <dd>Returns a reference to a hash created from the scalar or array reference,
      where, for the scalar value, or each item in the array, there is a key and
      it's value equal to that specific value. Example, if you pass scalar '3',
      the hash will be { 3 =&gt; 3 }.</dd>
  <dt>_merge_hashes( &lt;hashref&gt;, &lt;hashref&gt; ) -- INTERNAL
    FUNCTION</dt>
  <dd>Actually does the key-by-key evaluation of two hashes and returns the new
      merged hash. Note that this recursively calls
      <span class="Li">&quot;merge&quot;</span>.</dd>
  <dt id="set_clone_behavior("><a class="permalink" href="#set_clone_behavior(">set_clone_behavior(
    &lt;scalar&gt; )</a></dt>
  <dd>Sets how the data cloning is handled by Hash::Merge. If this is true, then
      data will be cloned; if false, then original data will be used whenever
      possible. By default, cloning is on (set to true).</dd>
  <dt id="get_clone_behavior("><a class="permalink" href="#get_clone_behavior(">get_clone_behavior(
    )</a></dt>
  <dd>Returns the current behavior for data cloning.</dd>
  <dt id="set_behavior("><a class="permalink" href="#set_behavior(">set_behavior(
    &lt;scalar&gt; )</a></dt>
  <dd>Specify which built-in behavior for merging that is desired. The scalar
      must be one of those given below.</dd>
  <dt id="get_behavior("><a class="permalink" href="#get_behavior(">get_behavior(
    )</a></dt>
  <dd>Returns the behavior that is currently in use by Hash::Merge.</dd>
  <dt id="specify_behavior("><a class="permalink" href="#specify_behavior(">specify_behavior(
    &lt;hashref&gt;, [&lt;name&gt;] )</a></dt>
  <dd>Specify a custom merge behavior for Hash::Merge. This must be a hashref
      defined with (at least) 3 keys, SCALAR, ARRAY, and HASH; each of those
      keys must have another hashref with (at least) the same 3 keys defined.
      Furthermore, the values in those hashes must be coderefs. These will be
      called with two arguments, the left and right values for the merge. Your
      coderef should return either a scalar or an array or hash reference as per
      your planned behavior. If necessary, use the functions _hashify and
      _merge_hashes as helper functions for these. For example, if you want to
      add the left SCALAR to the right ARRAY, you can have your behavior
      specification include:
    <p class="Pp"></p>
    <pre>
   %spec = ( ...SCALAR =&gt; { ARRAY =&gt; sub { [ $_[0], @$_[1] ] }, ... } } );
    </pre>
    <p class="Pp">Note that you can import _hashify and _merge_hashes into your
        program's namespace with the 'custom' tag.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="BUILT-IN_BEHAVIORS"><a class="permalink" href="#BUILT-IN_BEHAVIORS">BUILT-IN
  BEHAVIORS</a></h1>
<p class="Pp">Here is the specifics on how the current internal behaviors are
    called, and what each does. Assume that the left value is given as
    <span class="Li">$a</span>, and the right as <span class="Li">$b</span>
    (these are either scalars or appropriate references)</p>
<p class="Pp"></p>
<pre>
        LEFT TYPE   RIGHT TYPE      LEFT_PRECEDENT       RIGHT_PRECEDENT
         SCALAR      SCALAR            $a                   $b
         SCALAR      ARRAY             $a                   ( $a, @$b )
         SCALAR      HASH              $a                   %$b
         ARRAY       SCALAR            ( @$a, $b )          $b
         ARRAY       ARRAY             ( @$a, @$b )         ( @$a, @$b )
         ARRAY       HASH              ( @$a, values %$b )  %$b 
         HASH        SCALAR            %$a                  $b
         HASH        ARRAY             %$a                  ( values %$a, @$b )
         HASH        HASH              merge( %$a, %$b )    merge( %$a, %$b )

        LEFT TYPE   RIGHT TYPE  STORAGE_PRECEDENT   RETAINMENT_PRECEDENT
         SCALAR      SCALAR     $a                  ( $a ,$b )
         SCALAR      ARRAY      ( $a, @$b )         ( $a, @$b )
         SCALAR      HASH       %$b                 merge( hashify( $a ), %$b )
         ARRAY       SCALAR     ( @$a, $b )         ( @$a, $b )
         ARRAY       ARRAY      ( @$a, @$b )        ( @$a, @$b )
         ARRAY       HASH       %$b                 merge( hashify( @$a ), %$b )
         HASH        SCALAR     %$a                 merge( %$a, hashify( $b ) )
         HASH        ARRAY      %$a                 merge( %$a, hashify( @$b ) )
         HASH        HASH       merge( %$a, %$b )   merge( %$a, %$b )
</pre>
<p class="Pp">(*) note that merge calls _merge_hashes, hashify calls
  _hashify.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<p class="Pp">This will not handle self-referencing/recursion within hashes
    well. Plans for a future version include incorporate deep recursion
    protection.</p>
<p class="Pp">As of Feb 16, 2002, ActiveState Perl's PPM of Clone.pm is only at
    0.09. This version does not support the cloning of scalars if passed to the
    function. This is fixed by 0.10 (and currently, Clone.pm is at 0.13). So
    while most other users can upgrade their Clone.pm appropriately (and I could
    put this as a requirement into the Makefile.PL), those using ActiveState
    would lose out on the ability to use this module. (Clone.pm is not pure
    perl, so it's not simply a matter of moving the newer file into place).
    Thus, for the time being, a check is done at the start of loading of this
    module to see if a newer version of clone is around. Then, all cloning calls
    have been wrapped in the internal _my_clone function to block any scalar
    clones if Clone.pm is too old. However, this also prevents the cloning of
    anything that isn't a hash or array under the same conditions. Once
    ActiveState updates their Clone, I'll remove this wrapper.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Michael K. Neylon &lt;mneylon-pm@masemware.com&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 2001,2002 Michael K. Neylon. All rights
  reserved.</p>
<p class="Pp">This library is free software. You can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-11-03</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

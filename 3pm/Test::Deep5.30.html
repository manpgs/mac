<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Test::Deep(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Test::Deep(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Test::Deep(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Test::Deep - Extremely flexible deep comparison</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  use Test::More tests =&gt; $Num_Tests;
  use Test::Deep;
  cmp_deeply(
    $actual_horrible_nested_data_structure,
    $expected_horrible_nested_data_structure,
    &quot;got the right horrible nested data structure&quot;
  );
  cmp_deeply(
    $object,
    methods(name =&gt; &quot;John&quot;, phone =&gt; &quot;55378008&quot;),
    &quot;object methods ok&quot;
  );
  cmp_deeply(
    \@array,
    [$hash1, $hash2, ignore()],
    &quot;first 2 elements are as expected, ignoring 3&quot;
  );
  cmp_deeply(
    $object,
    noclass({value =&gt; 5}),
    &quot;object looks ok, not checking its class&quot;
  );
  cmp_deeply(
    \@result,
    bag('a', 'b', {key =&gt; [1, 2]}),
    &quot;array has the 3 things we wanted in some order&quot;
  );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">If you don't know anything about automated testing in Perl then
    you should probably read about Test::Simple and Test::More before preceding.
    Test::Deep uses the Test::Builder framework.</p>
<p class="Pp">Test::Deep gives you very flexible ways to check that the result
    you got is the result you were expecting. At its simplest it compares two
    structures by going through each level, ensuring that the values match, that
    arrays and hashes have the same elements and that references are blessed
    into the correct class. It also handles circular data structures without
    getting caught in an infinite loop.</p>
<p class="Pp">Where it becomes more interesting is in allowing you to do
    something besides simple exact comparisons. With strings, the
    <span class="Li">&quot;eq&quot;</span> operator checks that 2 strings are
    exactly equal but sometimes that's not what you want. When you don't know
    exactly what the string should be but you do know some things about how it
    should look, <span class="Li">&quot;eq&quot;</span> is no good and you must
    use pattern matching instead. Test::Deep provides pattern matching for
    complex data structures</p>
<p class="Pp">Test::Deep has <b></b><b><i>a lot</i></b><b></b> of exports. See
    &quot;EXPORTS&quot; below.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">How Test::Deep works is much easier to understand by seeing some
    examples.</p>
<section class="Ss">
<h2 class="Ss" id="Without_Test::Deep"><a class="permalink" href="#Without_Test::Deep">Without
  Test::Deep</a></h2>
<p class="Pp">Say you want to test a function which returns a string. You know
    that your string should be a 7 digit number beginning with 0,
    <span class="Li">&quot;eq&quot;</span> is no good in this situation, you
    need a regular expression. So you could use Test::More's
    <span class="Li">&quot;like()&quot;</span> function:</p>
<p class="Pp"></p>
<pre>  like($string, qr/^0[0-9]{6}$/, &quot;number looks good&quot;);
</pre>
<p class="Pp">Similarly, to check that a string looks like a name, you could
  do:</p>
<p class="Pp"></p>
<pre>  like($string, qr/^(Mr|Mrs|Miss) \w+ \w+$/,
    &quot;got title, first and last name&quot;);
</pre>
<p class="Pp">Now imagine your function produces a hash with some personal
    details in it. You want to make sure that there are 2 keys, Name and Phone
    and that the name looks like a name and the phone number looks like a phone
    number. You could do:</p>
<p class="Pp"></p>
<pre>  $hash = make_person();
  like($hash-&gt;{Name}, qr/^(Mr|Mrs|Miss) \w+ \w+$/, &quot;name ok&quot;);
  like($hash-&gt;{Phone}, qr/^0[0-9]{6}$/, &quot;phone ok&quot;);
  is(scalar keys %$hash, 2, &quot;correct number of keys&quot;);
</pre>
<p class="Pp">But that's not quite right, what if make_person has a serious
    problem and didn't even return a hash? We really need to write</p>
<p class="Pp"></p>
<pre>  if (ref($hash) eq &quot;HASH&quot;)
  {
    like($hash-&gt;{Name}, qr/^(Mr|Mrs|Miss) \w+ \w+$/, &quot;name ok&quot;);
    like($hash-&gt;{Phone}, qr/^0[0-9]{6}$/, &quot;phone ok&quot;);
    is(scalar keys %$hash, 2, &quot;correct number of keys&quot;);
  }
  else
  {
    fail(&quot;person not a hash&quot;);
    fail(&quot;person not a hash&quot;);
    fail(&quot;person not a hash&quot;); # need 3 to keep the plan correct
  }
</pre>
<p class="Pp">Already this is getting messy, now imagine another entry in the
    hash, an array of children's names. This would require</p>
<p class="Pp"></p>
<pre>  if (ref($hash) eq &quot;HASH&quot;)
  {
    like($hash-&gt;{Name}, $name_pat, &quot;name ok&quot;);
    like($hash-&gt;{Phone}, '/^0d{6}$/', &quot;phone ok&quot;);
    my $cn = $hash-&gt;{ChildNames};
    if (ref($cn) eq &quot;ARRAY&quot;)
    {
      foreach my $child (@$cn)
      {
        like($child, $name_pat);
      }
    }
    else
    {
        fail(&quot;child names not an array&quot;)
    }
  }
  else
  {
    fail(&quot;person not a hash&quot;);
  }
</pre>
<p class="Pp">This is a horrible mess and because we don't know in advance how
    many children's names there will be, we can't make a plan for our test
    anymore (actually, we could but it would make things even more
  complicated).</p>
<p class="Pp">Test::Deep to the rescue.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="With_Test::Deep"><a class="permalink" href="#With_Test::Deep">With
  Test::Deep</a></h2>
<pre>  my $name_re = re('^(Mr|Mrs|Miss) \w+ \w+$');
  cmp_deeply(
    $person,
    {
      Name =&gt; $name_re,
      Phone =&gt; re('^0d{6}$'),
      ChildNames =&gt; array_each($name_re)
    },
    &quot;person ok&quot;
  );
</pre>
<p class="Pp">This will do everything that the messy code above does and it will
    give a sensible message telling you exactly what went wrong if it finds a
    part of <span class="Li">$person</span> that doesn't match the pattern.
    <span class="Li">&quot;re()&quot;</span> and
    <span class="Li">&quot;array_each()&quot;</span> are special function
    imported from Test::Deep. They create a marker that tells Test::Deep that
    something different is happening here. Instead of just doing a simple
    comparison and checking are two things exactly equal, it should do something
    else.</p>
<p class="Pp">If a person was asked to check that 2 structures are equal, they
    could print them both out and compare them line by line. The markers above
    are similar to writing a note in red pen on one of the printouts telling the
    person that for this piece of the structure, they should stop doing simple
    line by line comparison and do something else.</p>
<p class="Pp"><span class="Li">&quot;re($regex)&quot;</span> means that
    Test::Deep should check that the current piece of data matches the regex in
    <span class="Li">$regex</span>.
    <span class="Li">&quot;array_each($struct)&quot;</span> means that
    Test::Deep should expect the current piece of data to be an array and it
    should check that every element of that array matches
    <span class="Li">$struct</span>. In this case, every element of
    <span class="Li">&quot;$person-&gt;{ChildNames}&quot;</span> should look
    like a name. If say the 3rd one didn't you would get an error message
    something like</p>
<p class="Pp"></p>
<pre>  Using Regexp on $data-&gt;{ChildNames}[3]
     got    : 'Queen John Paul Sartre'
     expect : /^(Mr|Mrs|Miss) \w+ \w+$/
</pre>
<p class="Pp">There are lots of other special comparisons available, see
    &quot;SPECIAL COMPARISONS PROVIDED&quot; below for the full list.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Reusing_structures"><a class="permalink" href="#Reusing_structures">Reusing
  structures</a></h2>
<p class="Pp">Test::Deep is good for reusing test structures so you can do
  this</p>
<p class="Pp"></p>
<pre>  my $name_re = re('^(Mr|Mrs|Miss) \w+ \w+$');
  my $person_cmp = {
    Name =&gt; $name_re,
    Phone =&gt; re('^0d{6}$'),
    ChildNames =&gt; array_each($name_re)
  };
  cmp_deeply($person1, $person_cmp, &quot;person ok&quot;);
  cmp_deeply($person2, $person_cmp, &quot;person ok&quot;);
  cmp_deeply($person3, $person_cmp, &quot;person ok&quot;);
</pre>
<p class="Pp">You can even put <span class="Li">$person_cmp</span> in a module
    and let other people use it when they are writing test scripts for modules
    that use your modules.</p>
<p class="Pp">To make things a little more difficult, lets change the person
    data structure so that instead of a list of ChildNames, it contains a list
    of hashes, one for each child. So in fact our person structure will contain
    other person structures which may contain other person structures and so on.
    This is easy to handle with Test::Deep because Test::Deep structures can
    include themselves. Simply do</p>
<p class="Pp"></p>
<pre>  my $name_re = re('^(Mr|Mrs|Miss) \w+ \w+$');
  my $person_cmp = {
    Name =&gt; $name_re,
    Phone =&gt; re('^0d{6}$'),
    # note no mention of Children here
  };
  $person_cmp-&gt;{Children} = array_each($person_cmp);
  cmp_deeply($person, $person_cmp, &quot;person ok&quot;);
</pre>
<p class="Pp">This will now check that
    <span class="Li">$person</span>-&gt;{Children} is an array and that every
    element of that array also matches <span class="Li">$person_cmp</span>, this
    includes checking that its children also match the same pattern and so
  on.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Circular_data_structures"><a class="permalink" href="#Circular_data_structures">Circular
  data structures</a></h2>
<p class="Pp">A circular data structure is one which loops back on itself, you
    can make one easily by doing</p>
<p class="Pp"></p>
<pre>  my @b;
  my @a = (1, 2, 3, \@b);
  push(@b, \@a);
</pre>
<p class="Pp">now <span class="Li">@a</span> contains a reference to be
    <span class="Li">@b</span> and <span class="Li">@b</span> contains a
    reference to <span class="Li">@a</span>. This causes problems if you have a
    program that wants to look inside <span class="Li">@a</span> and keep
    looking deeper and deeper at every level, it could get caught in an infinite
    loop looking into <span class="Li">@a</span> then <span class="Li">@b</span>
    then <span class="Li">@a</span> then <span class="Li">@b</span> and so
  on.</p>
<p class="Pp">Test::Deep avoids this problem so we can extend our example
    further by saying that a person should also list their parents.</p>
<p class="Pp"></p>
<pre>  my $name_re = re('^(Mr|Mrs|Miss) \w+ \w+$');
  my $person_cmp = {
    Name =&gt; $name_re,
    Phone =&gt; re('^0d{6}$'),
    # note no mention of Children here
  };
  $person_cmp-&gt;{Children} = each_array($person_cmp);
  $person_cmp-&gt;{Parents} = each_array($person_cmp);
  cmp_deeply($person, $person_cmp, &quot;person ok&quot;);
</pre>
<p class="Pp">So this will check that for each child
    <span class="Li">$child</span> in
    <span class="Li">&quot;$person-&gt;{Children}&quot;</span> that the
    <span class="Li">&quot;$child-&gt;{Parents}&quot;</span> matches
    <span class="Li">$person_cmp</span> however it is smart enough not to get
    caught in an infinite loop where it keeps bouncing between the same Parent
    and Child.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TERMINOLOGY"><a class="permalink" href="#TERMINOLOGY">TERMINOLOGY</a></h1>
<p class="Pp"><span class="Li">&quot;cmp_deeply($got, $expected,
    $name)&quot;</span> takes 3 arguments. <span class="Li">$got</span> is the
    structure that you are checking, you must not include any special
    comparisons in this structure or you will get a fatal error.
    <span class="Li">$expected</span> describes what Test::Deep will be looking
    for in <span class="Li">$got</span>. You can put special comparisons in
    <span class="Li">$expected</span> if you want to.</p>
<p class="Pp">As Test::Deep descends through the 2 structures, it compares them
    one piece at a time, so at any point in the process, Test::Deep is thinking
    about 2 things - the current value from <span class="Li">$got</span> and the
    current value from <span class="Li">$expected</span>. In the documentation,
    I call them <span class="Li">$got_v</span> and
    <span class="Li">&quot;exp_v&quot;</span> respectively.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COMPARISON_FUNCTIONS"><a class="permalink" href="#COMPARISON_FUNCTIONS">COMPARISON
  FUNCTIONS</a></h1>
<p class="Pp"><i>cmp_deeply</i></p>
<p class="Pp"></p>
<pre>  my $ok = cmp_deeply($got, $expected, $name)
</pre>
<p class="Pp"><span class="Li">$got</span> is the result to be checked.
    <span class="Li">$expected</span> is the structure against which
    <span class="Li">$got</span> will be check. <span class="Li">$name</span> is
    the test name.</p>
<p class="Pp">This is the main comparison function, the others are just wrappers
    around this. <span class="Li">$got</span> and
    <span class="Li">$expected</span> are compared recursively. Each value in
    <span class="Li">$expected</span> defines what's expected at the
    corresponding location in <span class="Li">$got</span>. Simple scalars are
    compared with <span class="Li">&quot;eq&quot;</span>. References to
    structures like hashes and arrays are compared recursively.</p>
<p class="Pp">Items in <span class="Li">$expected</span>, though, can also
    represent complex tests that check for numbers in a given range, hashes with
    at least a certain set of keys, a string matching a regex, or many other
    things.</p>
<p class="Pp">See &quot;WHAT ARE SPECIAL COMPARISONS&quot; for details.</p>
<p class="Pp"><i>cmp_bag</i></p>
<p class="Pp"></p>
<pre>  my $ok = cmp_bag(\@got, \@bag, $name)
</pre>
<p class="Pp">Is shorthand for cmp_deeply(\@got, bag(@bag),
    <span class="Li">$name</span>)</p>
<p class="Pp"><i>n.b.</i>: Both arguments must be array refs. If they aren't an
    exception will be thrown.</p>
<p class="Pp"><i>cmp_set</i></p>
<p class="Pp"></p>
<pre>  my $ok = cmp_set(\@got, \@set, $name)
</pre>
<p class="Pp">Is shorthand for cmp_deeply(\@got, set(@set),
    <span class="Li">$name</span>)</p>
<p class="Pp"><i>cmp_methods</i></p>
<p class="Pp"></p>
<pre>  my $ok = cmp_methods(\@got, \@methods, $name)
</pre>
<p class="Pp">Is shorthand for cmp_deeply(\@got, methods(@methods),
    <span class="Li">$name</span>)</p>
<p class="Pp"><i>eq_deeply</i></p>
<p class="Pp"></p>
<pre>  my $ok = eq_deeply($got, $expected)
</pre>
<p class="Pp">This is the same as <b>cmp_deeply()</b> except it just returns
    true or false. It does not create diagnostics or talk to Test::Builder, but
    if you want to use it in a non-testing environment then you should import it
    through Test::Deep::NoTest. For example</p>
<p class="Pp"></p>
<pre>  use Test::Deep::NoTest;
  print &quot;a equals b&quot; unless eq_deeply($a, $b);
</pre>
<p class="Pp">otherwise the Test::Builder framework will be loaded and testing
    messages will be output when your program ends.</p>
<p class="Pp"><i>cmp_details</i></p>
<p class="Pp"></p>
<pre>  ($ok, $stack) = cmp_details($got, $expected)
</pre>
<p class="Pp">This behaves much like eq_deeply, but it additionally allows you
    to produce diagnostics in case of failure by passing the value in
    <span class="Li">$stack</span> to
    <span class="Li">&quot;deep_diag&quot;</span>.</p>
<p class="Pp">Do not make assumptions about the structure or content of
    <span class="Li">$stack</span> and do not use it if
    <span class="Li">$ok</span> contains a true value.</p>
<p class="Pp">See &quot;USING TEST::DEEP WITH TEST::BUILDER&quot; for example
    uses.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SPECIAL_COMPARISONS_PROVIDED"><a class="permalink" href="#SPECIAL_COMPARISONS_PROVIDED">SPECIAL
  COMPARISONS PROVIDED</a></h1>
<p class="Pp">In the documentation below, <span class="Li">$got_v</span> is used
    to indicate any given value within the <span class="Li">$got</span>
    structure.</p>
<p class="Pp"><i>ignore</i></p>
<p class="Pp"></p>
<pre>  cmp_deeply( $got, ignore() );
</pre>
<p class="Pp">This makes Test::Deep skip tests on
    <span class="Li">$got_v</span>. No matter what value
    <span class="Li">$got_v</span> has, Test::Deep will think it's correct. This
    is useful if some part of the structure you are testing is very complicated
    and already tested elsewhere, or if it is unpredictable.</p>
<p class="Pp"></p>
<pre>  cmp_deeply(
    $got,
    {
      name    =&gt; 'John',
      random  =&gt; ignore(),
      address =&gt; [ '5 A street', 'a town', 'a country' ],
    }
  );
</pre>
<p class="Pp">is the equivalent of checking</p>
<p class="Pp"></p>
<pre>  $got-&gt;{name} eq 'John';
  exists $got-&gt;{random};
  cmp_deeply($got-&gt;{address}, ['5 A street', 'a town', 'a country']);
</pre>
<p class="Pp"><i>methods</i></p>
<p class="Pp"></p>
<pre>  cmp_deeply( $got, methods(%hash) );
</pre>
<p class="Pp"><span class="Li">%hash</span> is a hash of method call =&gt;
    expected value pairs.</p>
<p class="Pp">This lets you call methods on an object and check the result of
    each call. The methods will be called in the order supplied. If you want to
    pass arguments to the method you should wrap the method name and arguments
    in an array reference.</p>
<p class="Pp"></p>
<pre>  cmp_deeply(
    $obj,
    methods(name =&gt; &quot;John&quot;, [&quot;favourite&quot;, &quot;food&quot;] =&gt; &quot;taco&quot;)
  );
</pre>
<p class="Pp">is roughly the equivalent of checking that</p>
<p class="Pp"></p>
<pre>  $obj-&gt;name eq &quot;John&quot;
  $obj-&gt;favourite(&quot;food&quot;) eq &quot;taco&quot;
</pre>
<p class="Pp">The methods will be called in the order you supply them and will
    be called in scalar context. If you need to test methods called in list
    context then you should use
    <span class="Li">&quot;listmethods()&quot;</span>.</p>
<p class="Pp"><b>NOTE</b> Just as in a normal test script, you need to be
    careful if the methods you call have side effects like changing the object
    or other objects in the structure. Although the order of the methods is
    fixed, the order of some other tests is not so if
    <span class="Li">$expected</span> is</p>
<p class="Pp"></p>
<pre>  {
    manager =&gt; methods(@manager_methods),
    coder =&gt; methods(@coder_methods)
  }
</pre>
<p class="Pp">there is no way to know which if manager and coder will be tested
    first. If the methods you are testing depend on and alter global variables
    or if manager and coder are the same object then you may run into
  problems.</p>
<p class="Pp"><i>listmethods</i></p>
<p class="Pp"></p>
<pre>  cmp_deeply( $got, listmethods(%hash) );
</pre>
<p class="Pp"><span class="Li">%hash</span> is a hash of pairs mapping method
    names to expected return values.</p>
<p class="Pp">This is almost identical to <b>methods()</b> except the methods
    are called in list context instead of scalar context. This means that the
    expected return values supplied must be in array references.</p>
<p class="Pp"></p>
<pre>  cmp_deeply(
    $obj,
    listmethods(
      name =&gt; [ &quot;John&quot; ],
      [&quot;favourites&quot;, &quot;food&quot;] =&gt; [&quot;Mapo tofu&quot;, &quot;Gongbao chicken&quot;]
    )
  );
</pre>
<p class="Pp">is the equivalent of checking that</p>
<p class="Pp"></p>
<pre>  cmp_deeply([$obj-&gt;name], [&quot;John&quot;]);
  cmp_deeply([$obj-&gt;favourites(&quot;food&quot;)], [&quot;Mapo tofu&quot;, &quot;Gongbao chicken&quot;]);
</pre>
<p class="Pp">The methods will be called in the order you supply them.</p>
<p class="Pp"><b>NOTE</b> The same caveats apply as for <b>methods()</b>.</p>
<p class="Pp"><i>shallow</i></p>
<p class="Pp"></p>
<pre>  cmp_deeply( $got, shallow($thing) );
</pre>
<p class="Pp"><span class="Li">$thing</span> is a ref.</p>
<p class="Pp">This prevents Test::Deep from looking inside
    <span class="Li">$thing</span>. It allows you to check that
    <span class="Li">$got_v</span> and <span class="Li">$thing</span> are
    references to the same variable. So</p>
<p class="Pp"></p>
<pre>  my @a = @b = (1, 2, 3);
  cmp_deeply(\@a, \@b);
</pre>
<p class="Pp">will pass because <span class="Li">@a</span> and
    <span class="Li">@b</span> have the same elements however</p>
<p class="Pp"></p>
<pre>  cmp_deeply(\@a, shallow(\@b))
</pre>
<p class="Pp">will fail because although <span class="Li">&quot;\@a&quot;</span>
    and <span class="Li">&quot;\@b&quot;</span> both contain
    <span class="Li">&quot;1, 2, 3&quot;</span> they are references to different
    arrays.</p>
<p class="Pp"><i>noclass</i></p>
<p class="Pp"></p>
<pre>  cmp_deeply( $got, noclass($thing) );
</pre>
<p class="Pp"><span class="Li">$thing</span> is a structure to be compared
    against.</p>
<p class="Pp">This makes Test::Deep ignore the class of objects, so it just
    looks at the data they contain. Class checking will be turned off until
    Test::Deep is finished comparing <span class="Li">$got_v</span> against
    <span class="Li">$thing</span>. Once Test::Deep comes out of
    <span class="Li">$thing</span> it will go back to its previous setting for
    checking class.</p>
<p class="Pp">This can be useful when you want to check that objects have been
    constructed correctly but you don't want to write lots of
    <span class="Li">&quot;bless&quot;</span>es. If
    <span class="Li">@people</span> is an array of Person objects then</p>
<p class="Pp"></p>
<pre>  cmp_deeply(\@people, [
    bless {name =&gt; 'John', phone =&gt; '555-5555'}, &quot;Person&quot;,
    bless {name =&gt; 'Anne', phone =&gt; '444-4444'}, &quot;Person&quot;,
  ]);
</pre>
<p class="Pp">can be replaced with</p>
<p class="Pp"></p>
<pre>  cmp_deeply(\@people, noclass([
    {name =&gt; 'John', phone =&gt; '555-5555'},
    {name =&gt; 'Anne', phone =&gt; '444-4444'}
  ]));
</pre>
<p class="Pp">However, this is testing so you should also check that the objects
    are blessed correctly. You could use a map to bless all those hashes or you
    could do a second test like</p>
<p class="Pp"></p>
<pre>  cmp_deeply(\@people, array_each(isa(&quot;Person&quot;));
</pre>
<p class="Pp"><i>useclass</i></p>
<p class="Pp"></p>
<pre>  cmp_deeply( $got, useclass($thing) );
</pre>
<p class="Pp">This turns back on the class comparison while inside a
    <span class="Li">&quot;noclass()&quot;</span>.</p>
<p class="Pp"></p>
<pre>  cmp_deeply(
    $got,
    noclass(
      [
        useclass( $object )
      ]
    )
  )
</pre>
<p class="Pp">In this example the class of the array reference in
    <span class="Li">$got</span> is ignored but the class of
    <span class="Li">$object</span> is checked, as is the class of everything
    inside <span class="Li">$object</span>.</p>
<p class="Pp"><i>re</i></p>
<p class="Pp"></p>
<pre>  cmp_deeply( $got, re($regexp, $capture_data, $flags) );
</pre>
<p class="Pp"><span class="Li">$regexp</span> is either a regular expression
    reference produced with <span class="Li">&quot;qr/.../&quot;</span> or a
    string which will be used to construct a regular expression.</p>
<p class="Pp"><span class="Li">$capture_data</span> is optional and is used to
    check the strings captured by an regex. This should can be an array ref or a
    Test::Deep comparator that works on array refs.</p>
<p class="Pp"><span class="Li">$flags</span> is an optional string which
    controls whether the regex runs as a global match. If
    <span class="Li">$flags</span> is &quot;g&quot; then the regex will run as
    <span class="Li">&quot;m/$regexp/g&quot;</span>.</p>
<p class="Pp">Without <span class="Li">$capture_data</span>, this simply
    compares <span class="Li">$got_v</span> with the regular expression
    provided. So</p>
<p class="Pp"></p>
<pre>  cmp_deeply($got, [ re(&quot;ferg&quot;) ])
</pre>
<p class="Pp">is the equivalent of</p>
<p class="Pp"></p>
<pre>  $got-&gt;[0] =~ /ferg/
</pre>
<p class="Pp">With <span class="Li">$capture_data</span>,</p>
<p class="Pp"></p>
<pre>  cmp_deeply($got, [re($regex, $capture_data)])
</pre>
<p class="Pp">is the equivalent of</p>
<p class="Pp"></p>
<pre>  my @data = $got-&gt;[0] =~ /$regex/;
  cmp_deeply(\@data, $capture_data);
</pre>
<p class="Pp">So you can do something simple like</p>
<p class="Pp"></p>
<pre>  cmp_deeply($got, re(qr/(\d\d)(\w\w)/, [25, &quot;ab&quot; ]))
</pre>
<p class="Pp">to check that <span class="Li">&quot;(\d\d)&quot;</span> was 25
    and <span class="Li">&quot;(\w\w)&quot;</span> was &quot;ab&quot; but you
    can also use Test::Deep objects to do more complex testing of the captured
    values</p>
<p class="Pp"></p>
<pre>  cmp_deeply(
    &quot;cat=2,dog=67,sheep=3,goat=2,dog=5&quot;,
    re(
      qr/(\D+)=\d+,?/,
      set(qw( cat sheep dog )),
      &quot;g&quot;
    ),
  );
</pre>
<p class="Pp">here, the regex will match the string and will capture the animal
    names and check that they match the specified set, in this case it will
    fail, complaining that &quot;goat&quot; is not in the set.</p>
<p class="Pp"><i>all</i></p>
<p class="Pp"></p>
<pre>  cmp_deeply( $got, all(@expecteds) );
</pre>
<p class="Pp"><span class="Li">@expecteds</span> is an array of expected
    structures.</p>
<p class="Pp">This allows you to compare data against multiple expected results
    and make sure each of them matches.</p>
<p class="Pp"></p>
<pre>  cmp_deeply($got, all(isa(&quot;Person&quot;), methods(name =&gt; 'John')))
</pre>
<p class="Pp">is equivalent to</p>
<p class="Pp"></p>
<pre>  $got-&gt;isa(&quot;Person&quot;)
  $got-&gt;name eq 'John'
</pre>
<p class="Pp">If either test fails then the whole thing is considered a fail.
    This is a short-circuit test, the testing is stopped after the first
    failure, although in the future it may complete all tests so that
    diagnostics can be output for all failures. When reporting failure, the
    parts are counted from 1.</p>
<p class="Pp">Thanks to the magic of overloading, you can write</p>
<p class="Pp"></p>
<pre>  any( re(&quot;^wi&quot;), all(isa(&quot;Person&quot;), methods(name =&gt; 'John')) )
</pre>
<p class="Pp">as</p>
<p class="Pp"></p>
<pre>   re(&quot;^wi&quot;) | isa(&quot;Person&quot;) &amp; methods(name =&gt; 'John')
</pre>
<p class="Pp">Note <b>single</b> <span class="Li">&quot;|&quot;</span> not
    double, as <span class="Li">&quot;||&quot;</span> cannot be overloaded. This
    will only work when there is a special comparison involved. If you write</p>
<p class="Pp"></p>
<pre>  &quot;john&quot; | &quot;anne&quot; | &quot;robert&quot;
</pre>
<p class="Pp">Perl will turn this into</p>
<p class="Pp"></p>
<pre>  &quot;{onort&quot;
</pre>
<p class="Pp">which is presumably not what you wanted. This is because perl ors
    them together as strings before Test::Deep gets a chance to do any overload
    tricks.</p>
<p class="Pp"><i>any</i></p>
<p class="Pp"></p>
<pre>  cmp_deeply( $got, any(@expecteds) );
</pre>
<p class="Pp"><span class="Li">@expecteds</span> is an array of expected
    structures.</p>
<p class="Pp">This can be used to compare data against multiple expected results
    and make sure that at least one of them matches. This is a short-circuit
    test so if a test passes then none of the tests after that will be
    attempted.</p>
<p class="Pp">You can also use overloading with
    <span class="Li">&quot;|&quot;</span> similarly to <b>all()</b>.</p>
<p class="Pp"><i>Isa</i></p>
<p class="Pp"></p>
<pre>  cmp_deeply( $got, Isa($class) );
</pre>
<p class="Pp"><i>isa</i></p>
<p class="Pp"></p>
<pre>  cmp_deeply( $got, isa($class) );
</pre>
<p class="Pp"><span class="Li">$class</span> is a class name.</p>
<p class="Pp">This uses <span class="Li">&quot;UNIVERSAL::isa()&quot;</span> to
    check that <span class="Li">$got_v</span> is blessed into the class
    <span class="Li">$class</span>.</p>
<p class="Pp"><b>NOTE:</b> <span class="Li">&quot;Isa()&quot;</span> does
    exactly as documented here, but <span class="Li">&quot;isa()&quot;</span> is
    slightly different. If <span class="Li">&quot;isa()&quot;</span> is called
    with 1 argument it falls through to
    <span class="Li">&quot;Isa()&quot;</span>. If
    <span class="Li">&quot;isa()&quot;</span> called with 2 arguments, it falls
    through to <span class="Li">&quot;UNIVERSAL::isa&quot;</span>. This is to
    prevent breakage when you import <span class="Li">&quot;isa()&quot;</span>
    into a package that is used as a class. Without this, anyone calling
    <span class="Li">&quot;Class-&gt;isa($other_class)&quot;</span> would get
    the wrong answer. This is a hack to patch over the fact that
    <span class="Li">&quot;isa&quot;</span> is exported by default.</p>
<p class="Pp"><i>obj_isa</i></p>
<p class="Pp"></p>
<pre>  cmp_deeply( $got, obj_isa($class) );
</pre>
<p class="Pp">This test accepts only objects that are instances of
    <span class="Li">$class</span> or a subclass. Unlike the
    <span class="Li">&quot;Isa&quot;</span> test, this test will never accept
    class names.</p>
<p class="Pp"><i>array_each</i></p>
<p class="Pp"></p>
<pre>  cmp_deeply( \@got, array_each($thing) );
</pre>
<p class="Pp"><span class="Li">$thing</span> is a structure to be compared
    against.</p>
<p class="Pp">&lt;$got_v&gt; must be an array reference. Each element of it will
    be compared to <span class="Li">$thing</span>. This is useful when you have
    an array of similar things, for example objects of a known type and you
    don't want to have to repeat the same test for each one.</p>
<p class="Pp"></p>
<pre>  my $common_tests = all(
     isa(&quot;MyFile&quot;),
     methods(
       handle =&gt; isa(&quot;IO::Handle&quot;)
       filename =&gt; re(&quot;^/home/ted/tmp&quot;),
    )
  );
  cmp_deeply($got, array_each($common_tests));
</pre>
<p class="Pp">is similar to</p>
<p class="Pp"></p>
<pre>  foreach my $got_v (@$got) {
    cmp_deeply($got_v, $common_tests)
  }
</pre>
<p class="Pp">Except it will not explode if <span class="Li">$got</span> is not
    an array reference. It will check that each of the objects in
    <span class="Li">@$got</span> is a MyFile and that each one gives the
    correct results for its methods.</p>
<p class="Pp">You could go further, if for example there were 3 files and you
    knew the size of each one you could do this</p>
<p class="Pp"></p>
<pre>  cmp_deeply(
    $got,
    all(
      array_each($common_tests),
      [
        methods(size =&gt; 1000),
        methods(size =&gt; 200),
        methods(size =&gt; 20)
      ]
    )
  )
  cmp_deeply($got, array_each($structure));
</pre>
<p class="Pp"><i>hash_each</i></p>
<p class="Pp"></p>
<pre>  cmp_deeply( \%got, hash_each($thing) );
</pre>
<p class="Pp">This test behaves like
    <span class="Li">&quot;array_each&quot;</span> (see above) but tests that
    each hash value passes its tests.</p>
<p class="Pp"><i>str</i></p>
<p class="Pp"></p>
<pre>  cmp_deeply( $got, str($string) );
</pre>
<p class="Pp"><span class="Li">$string</span> is a string.</p>
<p class="Pp">This will stringify <span class="Li">$got_v</span> and compare it
    to <span class="Li">$string</span> using
    <span class="Li">&quot;eq&quot;</span>, even if
    <span class="Li">$got_v</span> is a ref. It is useful for checking the
    stringified value of an overloaded reference.</p>
<p class="Pp"><i>num</i></p>
<p class="Pp"></p>
<pre>  cmp_deeply( $got, num($number, $tolerance) );
</pre>
<p class="Pp"><span class="Li">$number</span> is a number.</p>
<p class="Pp"><span class="Li">$tolerance</span> is an optional number.</p>
<p class="Pp">This will add 0 to <span class="Li">$got_v</span> and check if
    it's numerically equal to <span class="Li">$number</span>, even if
    <span class="Li">$got_v</span> is a ref. It is useful for checking the
    numerical value of an overloaded reference. If
    <span class="Li">$tolerance</span> is supplied then this will check that
    <span class="Li">$got_v</span> and <span class="Li">$exp_v</span> are less
    than <span class="Li">$tolerance</span> apart. This is useful when comparing
    floating point numbers as rounding errors can make it hard or impossible for
    <span class="Li">$got_v</span> to be exactly equal to
    <span class="Li">$exp_v</span>. When <span class="Li">$tolerance</span> is
    supplied, the test passes if <span class="Li">&quot;abs($got_v - $exp_v)
    &lt;= $tolerance&quot;</span>.</p>
<p class="Pp"><b>Note</b> in Perl, <span class="Li">&quot;&quot;12blah&quot; ==
    12&quot;</span> because Perl will be smart and convert &quot;12blah&quot;
    into 12. You may not want this. There was a strict mode but that is now
    gone. A &quot;looks like a number&quot; test will replace it soon. Until
    then you can usually just use the <b>string()</b> comparison to be more
    strict. This will work fine for almost all situations, however it will not
    work when &lt;$got_v&gt; is an overloaded value who's string and numerical
    values differ.</p>
<p class="Pp"><i>bool, true, false</i></p>
<p class="Pp"></p>
<pre>  cmp_deeply( $got, bool($value) );
  cmp_deeply( $got, true );
  cmp_deeply( $got, false );
</pre>
<p class="Pp"><span class="Li">$value</span> is anything you like but it's
    probably best to use 0 or 1</p>
<p class="Pp">This will check that <span class="Li">$got_v</span> and
    <span class="Li">$value</span> have the same truth value, that is they will
    give the same result when used in boolean context, like in an
    <span class="Li">&quot;if()&quot;</span> statement.</p>
<p class="Pp"><b>Note:</b> <span class="Li">&quot;true&quot;</span> and
    <span class="Li">&quot;false&quot;</span> are only imported by special
    request.</p>
<p class="Pp"><i>code</i></p>
<p class="Pp"></p>
<pre>  cmp_deeply( $got, code(\&amp;subref) );
</pre>
<p class="Pp"><span class="Li">&quot;\&amp;subref&quot;</span> is a reference to
    a subroutine which will be passed a single argument, it then should return a
    true or false and possibly a string</p>
<p class="Pp">This will pass <span class="Li">$got_v</span> to the subroutine
    which returns true or false to indicate a pass or fail. Fails can be
    accompanied by a diagnostic string which gives an explanation of why it's a
    fail.</p>
<p class="Pp"></p>
<pre>  sub check_name
  {
    my $name = shift;
    if ($boss-&gt;likes($name))
    {
      return 1;
    }
    else
    {
      return (0, &quot;the boss doesn't like your name&quot;);
    }
  }
  cmp_deeply(&quot;Brian&quot;, code(\&amp;check_name));
</pre>
<section class="Ss">
<h2 class="Ss">SET COMPARISONS</h2>
<p class="Pp">Set comparisons give special semantics to array comparisons:</p>
<ul class="Bl-bullet">
  <li>The order of items in a set is irrelevant</li>
  <li>The presence of duplicate items in a set is ignored.</li>
</ul>
<p class="Pp">As such, in any set comparison, the following arrays are
  equal:</p>
<p class="Pp"></p>
<pre>  [ 1, 2 ]
  [ 1, 1, 2 ]
  [ 1, 2, 1 ]
  [ 2, 1, 1 ]
  [ 1, 1, 2 ]
</pre>
<p class="Pp">All are interpreted by <span class="Li">&quot;set&quot;</span>
    semantics as if the set was only specified as:</p>
<p class="Pp"></p>
<pre>  [ 1, 2 ]
</pre>
<p class="Pp">All <span class="Li">&quot;set&quot;</span> functions return an
    object which can have additional items added to it:</p>
<p class="Pp"></p>
<pre>  my $set = set( 1, 2 );
  $set-&gt;add(1, 3, 1 );  # Set is now ( 1, 2, 3 )
</pre>
<p class="Pp">Special care must be taken when using special comparisons within
    sets. See &quot;SPECIAL CARE WITH SPECIAL COMPARISONS IN SETS AND BAGS&quot;
    for details.</p>
<p class="Pp"><i>set</i></p>
<p class="Pp"></p>
<pre>  cmp_deeply( \@got, set(@elements) );
</pre>
<p class="Pp">This does a set comparison, that is, it compares two arrays but
    ignores the order of the elements and it ignores duplicate elements, but
    ensures that all items in <span class="Li">@elements</span> will be in
    <span class="Li">$got</span> and all items in <span class="Li">$got</span>
    will be in <span class="Li">@elements</span>.</p>
<p class="Pp">So the following tests will be passes, and will be equivalent:</p>
<p class="Pp"></p>
<pre>  cmp_deeply([1, 2, 2, 3], set(3, 2, 1, 1));
  cmp_deeply([1, 2, 3],    set(3, 2, 1));
</pre>
<p class="Pp"><i>supersetof</i></p>
<p class="Pp"></p>
<pre>  cmp_deeply( \@got, supersetof(@elements) );
</pre>
<p class="Pp">This function works much like
    <span class="Li">&quot;set&quot;</span>, and performs a set comparison of
    <span class="Li">$got_v</span> with the elements of
    <span class="Li">@elements</span>.</p>
<p class="Pp"><span class="Li">&quot;supersetof&quot;</span> is however slightly
    relaxed, such that <span class="Li">$got</span> may contain things not in
    <span class="Li">@elements</span>, but must at least contain all
    <span class="Li">@elements</span>.</p>
<p class="Pp">These two statements are equivalent, and will be passes:</p>
<p class="Pp"></p>
<pre>  cmp_deeply([1,2,3,3,4,5], supersetof(2,2,3));
  cmp_deeply([1,2,3,4,5],   supersetof(2,3));
</pre>
<p class="Pp">But these will be failures:</p>
<p class="Pp"></p>
<pre>  cmp_deeply([1,2,3,4,5],   supersetof(2,3,6)); # 6 not in superset
  cmp_deeply([1],           supersetof(1,2));   # 2 not in superset
</pre>
<p class="Pp"><i>subsetof</i></p>
<p class="Pp"></p>
<pre>  cmp_deeply( \@got, subsetof(@elements) );
</pre>
<p class="Pp">This function works much like
    <span class="Li">&quot;set&quot;</span>, and performs a set comparison of
    <span class="Li">$got_v</span> with the elements of
    <span class="Li">@elements</span>.</p>
<p class="Pp">This is the inverse of
    <span class="Li">&quot;supersetof&quot;</span>, which expects all unique
    elements found in <span class="Li">$got_v</span> must be in
    <span class="Li">@elements</span>.</p>
<p class="Pp"></p>
<pre>  cmp_deeply([1,2,4,5], subsetof(2,3,3)    ) # Fail: 1,4 &amp; 5 extra
  cmp_deeply([2,3,3],   subsetof(1,2,4,5)  ) # Fail: 3 extra
  cmp_deeply([2,3,3],   subsetof(1,2,4,5,3)) # Pass
</pre>
<p class="Pp"><i>none</i></p>
<p class="Pp"></p>
<pre>  cmp_deeply( $got, none(@elements) );
</pre>
<p class="Pp"><span class="Li">@elements</span> is an array of elements, wherein
    no elements in <span class="Li">@elements</span> may be equal to
    <span class="Li">$got_v</span>.</p>
<p class="Pp"><i>noneof</i></p>
<p class="Pp"></p>
<pre>  cmp_deeply( \@got, noneof(@elements) );
</pre>
<p class="Pp"><span class="Li">@elements</span> is an array of elements, wherein
    no elements in <span class="Li">@elements</span> may be found in
    <span class="Li">$got_v</span>.</p>
<p class="Pp">For example:</p>
<p class="Pp"></p>
<pre>  # Got has no 1, no 2, and no 3
  cmp_deeply( [1], noneof( 1, 2, 3 ) ); # fail
  cmp_deeply( [5], noneof( 1, 2, 3 ) ); # pass
</pre>
</section>
<section class="Ss">
<h2 class="Ss">BAG COMPARISONS</h2>
<p class="Pp">Bag comparisons give special semantics to array comparisons, that
    are similar to set comparisons, but slightly different.</p>
<ul class="Bl-bullet">
  <li>The order of items in a bag is irrelevant</li>
  <li>The presence of duplicate items in a bag is <b>PRESERVED</b></li>
</ul>
<p class="Pp">As such, in any bag comparison, the following arrays are
  equal:</p>
<p class="Pp"></p>
<pre>  [ 1, 1, 2 ]
  [ 1, 2, 1 ]
  [ 2, 1, 1 ]
  [ 1, 1, 2 ]
</pre>
<p class="Pp">However, they are <b>NOT</b> equal to any of the following:</p>
<p class="Pp"></p>
<pre>  [ 1, 2 ]
  [ 1, 2, 2 ]
  [ 1, 1, 1, 2 ]
</pre>
<p class="Pp">All <span class="Li">&quot;bag&quot;</span> functions return an
    object which can have additional items added to it:</p>
<p class="Pp"></p>
<pre>  my $bag = bag( 1, 2 );
  $bag-&gt;add(1, 3, 1 );  # Bag is now ( 1, 1, 1, 2, 3 )
</pre>
<p class="Pp">Special care must be taken when using special comparisons within
    bags. See &quot;SPECIAL CARE WITH SPECIAL COMPARISONS IN SETS AND BAGS&quot;
    for details.</p>
<p class="Pp"><i>bag</i></p>
<p class="Pp"></p>
<pre>  cmp_deeply( \@got, bag(@elements) );
</pre>
<p class="Pp">This does an order-insensitive bag comparison between
    <span class="Li">$got</span> and <span class="Li">@elements</span>, ensuring
    that:</p>
<dl class="Bl-tag">
  <dt id="each"><a class="permalink" href="#each">each item in @elements is
    found in $got</a></dt>
  <dd></dd>
  <dt id="the"><a class="permalink" href="#the">the number of times a
    $expected_v is found in @elements is reflected in $got</a></dt>
  <dd></dd>
  <dt id="no"><a class="permalink" href="#no">no items are found in $got other
    than those in @elements.</a></dt>
  <dd></dd>
</dl>
<p class="Pp">As such, the following are passes, and are equivalent to each
    other:</p>
<p class="Pp"></p>
<pre>  cmp_deeply([1, 2, 2], bag(2, 2, 1))
  cmp_deeply([2, 1, 2], bag(2, 2, 1))
  cmp_deeply([2, 2, 1], bag(2, 2, 1))
</pre>
<p class="Pp">But the following are failures:</p>
<p class="Pp"></p>
<pre>  cmp_deeply([1, 2, 2],     bag(2, 2, 1, 1)) # Not enough 1's in Got
  cmp_deeply([1, 2, 2, 1],  bag(2, 2, 1)   ) # Too many   1's in Got
</pre>
<p class="Pp"><i>superbagof</i></p>
<p class="Pp"></p>
<pre>  cmp_deeply( \@got, superbagof( @elements ) );
</pre>
<p class="Pp">This function works much like
    <span class="Li">&quot;bag&quot;</span>, and performs a bag comparison of
    <span class="Li">$got_v</span> with the elements of
    <span class="Li">@elements</span>.</p>
<p class="Pp"><span class="Li">&quot;superbagof&quot;</span> is however slightly
    relaxed, such that <span class="Li">$got</span> may contain things not in
    <span class="Li">@elements</span>, but must at least contain all
    <span class="Li">@elements</span>.</p>
<p class="Pp">So:</p>
<p class="Pp"></p>
<pre>  # pass
  cmp_deeply( [1, 1, 2], superbagof( 1 )      );
  # fail: not enough 1's in superbag
  cmp_deeply( [1, 1, 2], superbagof( 1, 1, 1 ));
</pre>
<p class="Pp"><i>subbagof</i></p>
<p class="Pp"></p>
<pre>  cmp_deeply( \@got, subbagof(@elements) );
</pre>
<p class="Pp">This function works much like
    <span class="Li">&quot;bag&quot;</span>, and performs a bag comparison of
    <span class="Li">$got_v</span> with the elements of
    <span class="Li">@elements</span>.</p>
<p class="Pp">This is the inverse of
    <span class="Li">&quot;superbagof&quot;</span>, and expects all elements in
    <span class="Li">$got</span> to be in <span class="Li">@elements</span>,
    while allowing items to exist in <span class="Li">@elements</span> that are
    not in <span class="Li">$got</span></p>
<p class="Pp"></p>
<pre>  # pass
  cmp_deeply( [1],        subbagof( 1, 1, 2 ) );
  # fail: too many 1's in subbag
  cmp_deeply( [1, 1, 1],  subbagof( 1, 1, 2 ) );
</pre>
</section>
<section class="Ss">
<h2 class="Ss">HASH COMPARISONS</h2>
<p class="Pp">Typically, if you're doing simple hash comparisons,</p>
<p class="Pp"></p>
<pre>  cmp_deeply( \%got, \%expected )
</pre>
<p class="Pp">is sufficient. <span class="Li">&quot;cmp_deeply&quot;</span> will
    ensure <span class="Li">%got</span> and <span class="Li">%hash</span> have
    identical keys, and each key from either has the same corresponding
  value.</p>
<p class="Pp"><i>superhashof</i></p>
<p class="Pp"></p>
<pre>  cmp_deeply( \%got, superhashof(\%hash) );
</pre>
<p class="Pp">This will check that the hash <span class="Li">%$got</span> is a
    &quot;super-hash&quot; of <span class="Li">%hash</span>. That is that all
    the key and value pairs in <span class="Li">%hash</span> appear in
    <span class="Li">%$got</span> but <span class="Li">%$got</span> can have
    extra ones also.</p>
<p class="Pp">For example</p>
<p class="Pp"></p>
<pre>  cmp_deeply({a =&gt; 1, b =&gt; 2}, superhashof({a =&gt; 1}))
</pre>
<p class="Pp">will pass but</p>
<p class="Pp"></p>
<pre>  cmp_deeply({a =&gt; 1, b =&gt; 2}, superhashof({a =&gt; 1, c =&gt; 3}))
</pre>
<p class="Pp">will fail.</p>
<p class="Pp"><i>subhashof</i></p>
<p class="Pp"></p>
<pre>  cmp_deeply( \%got, subhashof(\%hash) );
</pre>
<p class="Pp">This will check that the hash <span class="Li">%$got</span> is a
    &quot;sub-hash&quot; of <span class="Li">%hash</span>. That is that all the
    key and value pairs in <span class="Li">%$got</span> also appear in
    <span class="Li">%hash</span>.</p>
<p class="Pp">For example</p>
<p class="Pp"></p>
<pre>  cmp_deeply({a =&gt; 1}, subhashof({a =&gt; 1, b =&gt; 2}))
</pre>
<p class="Pp">will pass but</p>
<p class="Pp"></p>
<pre>  cmp_deeply({a =&gt; 1, c =&gt; 3}, subhashof({a =&gt; 1, b =&gt; 2}))
</pre>
<p class="Pp">will fail.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DIAGNOSTIC_FUNCTIONS"><a class="permalink" href="#DIAGNOSTIC_FUNCTIONS">DIAGNOSTIC
  FUNCTIONS</a></h1>
<p class="Pp"><i>deep_diag</i></p>
<p class="Pp"></p>
<pre>  my $reason = deep_diag($stack);
</pre>
<p class="Pp"><span class="Li">$stack</span> is a value returned by cmp_details.
    Do not call this function if cmp_details returned a true value for
    <span class="Li">$ok</span>.</p>
<p class="Pp"><span class="Li">&quot;deep_diag()&quot;</span> returns a human
    readable string describing how the comparison failed.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ANOTHER_EXAMPLE"><a class="permalink" href="#ANOTHER_EXAMPLE">ANOTHER
  EXAMPLE</a></h1>
<p class="Pp">You've written a module to handle people and their film interests.
    Say you have a function that returns an array of people from a query, each
    person is a hash with 2 keys: Name and Age and the array is sorted by Name.
    You can do</p>
<p class="Pp"></p>
<pre>  cmp_deeply(
    $result,
    [
      {Name =&gt; 'Anne', Age =&gt; 26},
      {Name =&gt; &quot;Bill&quot;, Age =&gt; 47}
      {Name =&gt; 'John', Age =&gt; 25},
    ]
  );
</pre>
<p class="Pp">Soon after, your query function changes and all the results now
    have an ID field. Now your test is failing again because you left out ID
    from each of the hashes. The problem is that the IDs are generated by the
    database and you have no way of knowing what each person's ID is. With
    Test::Deep you can change your query to</p>
<p class="Pp"></p>
<pre>  cmp_deeply(
    $result,
    [
      {Name =&gt; 'John', Age =&gt; 25, ID =&gt; ignore()},
      {Name =&gt; 'Anne', Age =&gt; 26, ID =&gt; ignore()},
      {Name =&gt; &quot;Bill&quot;, Age =&gt; 47, ID =&gt; ignore()}
    ]
  );
</pre>
<p class="Pp">But your test still fails. Now, because you're using a database,
    you no longer know what order the people will appear in. You could add a
    sort into the database query but that could slow down your application.
    Instead you can get Test::Deep to ignore the order of the array by doing a
    bag comparison instead.</p>
<p class="Pp"></p>
<pre>  cmp_deeply(
    $result,
    bag(
      {Name =&gt; 'John', Age =&gt; 25, ID =&gt; ignore()},
      {Name =&gt; 'Anne', Age =&gt; 26, ID =&gt; ignore()},
      {Name =&gt; &quot;Bill&quot;, Age =&gt; 47, ID =&gt; ignore()}
    )
  );
</pre>
<p class="Pp">Finally person gets even more complicated and includes a new field
    called Movies, this is a list of movies that the person has seen recently,
    again these movies could also come back in any order so we need a bag inside
    our other bag comparison, giving us something like</p>
<p class="Pp"></p>
<pre>  cmp_deeply(
  $result,
    bag(
      {Name =&gt; 'John', Age =&gt; 25, ID =&gt; ignore(), Movies =&gt; bag(...)},
      {Name =&gt; 'Anne', Age =&gt; 26, ID =&gt; ignore(), Movies =&gt; bag(...)},
      {Name =&gt; &quot;Bill&quot;, Age =&gt; 47, ID =&gt; ignore(), Movies =&gt; bag(...)}
    )
  );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="USING_TEST::DEEP_WITH_TEST::BUILDER"><a class="permalink" href="#USING_TEST::DEEP_WITH_TEST::BUILDER">USING
  TEST::DEEP WITH TEST::BUILDER</a></h1>
<p class="Pp">Combining <span class="Li">&quot;cmp_details&quot;</span> and
    <span class="Li">&quot;deep_diag&quot;</span> makes it possible to use
    Test::Deep in your own test classes.</p>
<p class="Pp">In a Test::Builder subclass, create a test method in the following
    form:</p>
<p class="Pp"></p>
<pre>  sub behaves_ok {
    my $self = shift;
    my $expected = shift;
    my $test_name = shift;
    my $got = do_the_important_work_here();
    my ($ok, $stack) = cmp_details($got, $expected);
    unless ($Test-&gt;ok($ok, $test_name)) {
      my $diag = deep_diag($stack);
      $Test-&gt;diag($diag);
    }
  }
</pre>
<p class="Pp">As the subclass defines a test class, not tests themselves, make
    sure it uses Test::Deep::NoTest, not
    <span class="Li">&quot;Test::Deep&quot;</span> itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LIMITATIONS"><a class="permalink" href="#LIMITATIONS">LIMITATIONS</a></h1>
<p class="Pp">Currently any CODE, GLOB or IO refs will be compared using
    <b>shallow()</b>, which means only their memory addresses are compared.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">There is a bug in set and bag compare to do with competing SCs. It
    only occurs when you put certain special comparisons inside bag or set
    comparisons you don't need to worry about it. The full details are in the
    <span class="Li">&quot;bag()&quot;</span> docs. It will be fixed in an
    upcoming version.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<section class="Ss">
<h2 class="Ss">SPECIAL CARE WITH SPECIAL COMPARISONS IN SETS AND BAGS</h2>
<p class="Pp">If you use certain special comparisons within a bag or set
    comparison there is a danger that a test will fail when it should have
    passed. It can only happen if two or more special comparisons in the bag are
    competing to match elements. Consider this comparison</p>
<p class="Pp"></p>
<pre>  cmp_deeply(['furry', 'furball'], bag(re(&quot;^fur&quot;), re(&quot;furb&quot;)))
</pre>
<p class="Pp">There are two things that could happen, hopefully
    <span class="Li">&quot;re(&quot;^fur&quot;)&quot;</span> is paired with
    &quot;furry&quot; and
    <span class="Li">&quot;re(&quot;^furb&quot;)&quot;</span> is paired with
    &quot;furb&quot; and everything is fine but it could happen that
    <span class="Li">&quot;re(&quot;^fur&quot;)&quot;</span> is paired with
    &quot;furball&quot; and then
    <span class="Li">&quot;re(&quot;^furb&quot;)&quot;</span> cannot find a
    match and so the test fails. Examples of other competing comparisons are
    <span class="Li">&quot;bag(1, 2, 2)&quot;</span> vs
    <span class="Li">&quot;set(1, 2)&quot;</span> and
    <span class="Li">&quot;methods(m1 =&gt; &quot;v1&quot;, m2 =&gt;
    &quot;v2&quot;)&quot;</span> vs <span class="Li">&quot;methods(m1 =&gt;
    &quot;v1&quot;)&quot;</span></p>
<p class="Pp">This problem is could be solved by using a slower and more
    complicated algorithm for set and bag matching. Something for the
  future...</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="WHAT_ARE_SPECIAL_COMPARISONS?"><a class="permalink" href="#WHAT_ARE_SPECIAL_COMPARISONS?">WHAT
  ARE SPECIAL COMPARISONS?</a></h1>
<p class="Pp">A special comparison (SC) is simply an object that inherits from
    Test::Deep::Cmp. Whenever <span class="Li">$expected_v</span> is an SC then
    instead of checking <span class="Li">&quot;$got_v eq
    $expected_v&quot;</span>, we pass control over to the SC and let it do its
    thing.</p>
<p class="Pp">Test::Deep exports lots of SC constructors, to make it easy for
    you to use them in your test scripts. For example is
    <span class="Li">&quot;re(&quot;hello&quot;)&quot;</span> is just a handy
    way of creating a Test::Deep::Regexp object that will match any string
    containing &quot;hello&quot;. So</p>
<p class="Pp"></p>
<pre>  cmp_deeply([ 'a', 'b', 'hello world'], ['a', 'b', re(&quot;^hello&quot;)]);
</pre>
<p class="Pp">will check <span class="Li">'a' eq 'a'</span>,
    <span class="Li">'b' eq 'b'</span> but when it comes to comparing
    <span class="Li">'hello world'</span> and
    <span class="Li">&quot;re(&quot;^hello&quot;)&quot;</span> it will see that
    <span class="Li">$expected_v</span> is an SC and so will pass control to the
    Test::Deep::Regexp class by do something like
    <span class="Li">&quot;$expected_v-&gt;descend($got_v)&quot;</span>. The
    <span class="Li">&quot;descend()&quot;</span> method should just return true
    or false.</p>
<p class="Pp">This gives you enough to write your own SCs but I haven't
    documented how diagnostics works because it's about to get an overhaul
    (theoretically).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTS"><a class="permalink" href="#EXPORTS">EXPORTS</a></h1>
<p class="Pp">By default, Test::Deep will export everything in its
    <span class="Li">&quot;v0&quot;</span> tag, as if you had written:</p>
<p class="Pp"></p>
<pre>  use Test::Deep ':v0';
</pre>
<p class="Pp">Those things are:</p>
<p class="Pp"></p>
<pre>  all any array array_each arrayelementsonly arraylength arraylengthonly bag
  blessed bool cmp_bag cmp_deeply cmp_methods cmp_set code eq_deeply hash
  hash_each hashkeys hashkeysonly ignore Isa isa listmethods methods noclass
  none noneof num obj_isa re reftype regexpmatches regexponly regexpref
  regexprefonly scalarrefonly scalref set shallow str subbagof subhashof
  subsetof superbagof superhashof supersetof useclass
</pre>
<p class="Pp">A slightly better set of exports is the
    <span class="Li">&quot;v1&quot;</span> set. It's all the same things, with
    the exception of <span class="Li">&quot;Isa&quot;</span> and
    <span class="Li">&quot;blessed&quot;</span>. If you want to import
    &quot;everything&quot;, you probably want to <span class="Li">&quot;use
    Test::Deep ':V1';&quot;</span>.</p>
<p class="Pp">There's another magic export group:
    <span class="Li">&quot;:preload&quot;</span>. If that is specified, all of
    the Test::Deep plugins will be loaded immediately instead of lazily.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Test::More</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MAINTAINER"><a class="permalink" href="#MAINTAINER">MAINTAINER</a></h1>
<pre>  Ricardo Signes &lt;rjbs@cpan.org&gt;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Fergal Daly &lt;fergal@esatclear.ie&gt;, with thanks to Michael G
    Schwern for Test::More's is_deeply function which inspired this.</p>
<p class="Pp"><b>Please</b> do not bother Fergal Daly with bug reports. Send
    them to the maintainer (above) or submit them at the issue tracker
    &lt;https://github.com/rjbs/Test-Deep/issues&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 2003, 2004 by Fergal Daly
  &lt;fergal@esatclear.ie&gt;.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">See <i>http://www.perl.com/perl/misc/Artistic.html</i></p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-03-01</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

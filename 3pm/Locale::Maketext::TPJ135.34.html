<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Locale::Maketext::TPJ13(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Locale::Maketext::TPJ13(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Locale::Maketext::TPJ13(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Locale::Maketext::TPJ13 -- article about software localization</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  # This an article, not a module.
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The following article by Sean M. Burke and Jordan Lachler first
    appeared in <i>The Perl Journal</i> #13 and is copyright 1999 The Perl
    Journal. It appears courtesy of Jon Orwant and The Perl Journal. This
    document may be distributed under the same terms as Perl itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Localization_and_Perl:_gettext_breaks,_Maketext_fixes"><a class="permalink" href="#Localization_and_Perl:_gettext_breaks,_Maketext_fixes">Localization
  and Perl: gettext breaks, Maketext fixes</a></h1>
<p class="Pp">by Sean M. Burke and Jordan Lachler</p>
<p class="Pp">This article points out cases where gettext (a common system for
    localizing software interfaces -- i.e., making them work in the user's
    language of choice) fails because of basic differences between human
    languages. This article then describes Maketext, a new system capable of
    correctly treating these differences.</p>
<section class="Ss">
<h2 class="Ss" id="A_Localization_Horror_Story:_It_Could_Happen_To_You"><a class="permalink" href="#A_Localization_Horror_Story:_It_Could_Happen_To_You">A
  Localization Horror Story: It Could Happen To You</a></h2>
<div class="Bd-indent">&quot;There are a number of languages spoken by human
  beings in this world.&quot;
<p class="Pp">-- Harald Tveit Alvestrand, in RFC 1766, &quot;Tags for the
    Identification of Languages&quot;</p>
</div>
<p class="Pp">Imagine that your task for the day is to localize a piece of
    software -- and luckily for you, the only output the program emits is two
    messages, like this:</p>
<p class="Pp"></p>
<pre>  I scanned 12 directories.
  Your query matched 10 files in 4 directories.
</pre>
<p class="Pp">So how hard could that be? You look at the code that produces the
    first item, and it reads:</p>
<p class="Pp"></p>
<pre>  printf(&quot;I scanned %g directories.&quot;,
         $directory_count);
</pre>
<p class="Pp">You think about that, and realize that it doesn't even work right
    for English, as it can produce this output:</p>
<p class="Pp"></p>
<pre>  I scanned 1 directories.
</pre>
<p class="Pp">So you rewrite it to read:</p>
<p class="Pp"></p>
<pre>  printf(&quot;I scanned %g %s.&quot;,
         $directory_count,
         $directory_count == 1 ?
           &quot;directory&quot; : &quot;directories&quot;,
  );
</pre>
<p class="Pp">...which does the Right Thing. (In case you don't recall,
    &quot;%g&quot; is for locale-specific number interpolation, and
    &quot;%s&quot; is for string interpolation.)</p>
<p class="Pp">But you still have to localize it for all the languages you're
    producing this software for, so you pull Locale::gettext off of CPAN so you
    can access the <span class="Li">&quot;gettext&quot;</span> C functions
    you've heard are standard for localization tasks.</p>
<p class="Pp">And you write:</p>
<p class="Pp"></p>
<pre>  printf(gettext(&quot;I scanned %g %s.&quot;),
         $dir_scan_count,
         $dir_scan_count == 1 ?
           gettext(&quot;directory&quot;) : gettext(&quot;directories&quot;),
  );
</pre>
<p class="Pp">But you then read in the gettext manual (Drepper, Miller, and
    Pinard 1995) that this is not a good idea, since how a single word like
    &quot;directory&quot; or &quot;directories&quot; is translated may depend on
    context -- and this is true, since in a case language like German or
    Russian, you'd may need these words with a different case ending in the
    first instance (where the word is the object of a verb) than in the second
    instance, which you haven't even gotten to yet (where the word is the object
    of a preposition, &quot;in <span class="Li">%g</span> directories&quot;) --
    assuming these keep the same syntax when translated into those
  languages.</p>
<p class="Pp">So, on the advice of the gettext manual, you rewrite:</p>
<p class="Pp"></p>
<pre>  printf( $dir_scan_count == 1 ?
           gettext(&quot;I scanned %g directory.&quot;) :
           gettext(&quot;I scanned %g directories.&quot;),
         $dir_scan_count );
</pre>
<p class="Pp">So, you email your various translators (the boss decides that the
    languages du jour are Chinese, Arabic, Russian, and Italian, so you have one
    translator for each), asking for translations for &quot;I scanned
    <span class="Li">%g</span> directory.&quot; and &quot;I scanned
    <span class="Li">%g</span> directories.&quot;. When they reply, you'll put
    that in the lexicons for gettext to use when it localizes your software, so
    that when the user is running under the &quot;zh&quot; (Chinese) locale,
    gettext(&quot;I scanned <span class="Li">%g</span> directory.&quot;) will
    return the appropriate Chinese text, with a &quot;%g&quot; in there where
    printf can then interpolate <span class="Li">$dir_scan</span>.</p>
<p class="Pp">Your Chinese translator emails right back -- he says both of these
    phrases translate to the same thing in Chinese, because, in linguistic
    jargon, Chinese &quot;doesn't have number as a grammatical category&quot; --
    whereas English does. That is, English has grammatical rules that refer to
    &quot;number&quot;, i.e., whether something is grammatically singular or
    plural; and one of these rules is the one that forces nouns to take a plural
    suffix (generally &quot;s&quot;) when in a plural context, as they are when
    they follow a number other than &quot;one&quot; (including, oddly enough,
    &quot;zero&quot;). Chinese has no such rules, and so has just the one phrase
    where English has two. But, no problem, you can have this one Chinese phrase
    appear as the translation for the two English phrases in the &quot;zh&quot;
    gettext lexicon for your program.</p>
<p class="Pp">Emboldened by this, you dive into the second phrase that your
    software needs to output: &quot;Your query matched 10 files in 4
    directories.&quot;. You notice that if you want to treat phrases as
    indivisible, as the gettext manual wisely advises, you need four cases now,
    instead of two, to cover the permutations of singular and plural on the two
    items, <span class="Li">$dir_count</span> and
    <span class="Li">$file_count</span>. So you try this:</p>
<p class="Pp"></p>
<pre>  printf( $file_count == 1 ?
    ( $directory_count == 1 ?
     gettext(&quot;Your query matched %g file in %g directory.&quot;) :
     gettext(&quot;Your query matched %g file in %g directories.&quot;) ) :
    ( $directory_count == 1 ?
     gettext(&quot;Your query matched %g files in %g directory.&quot;) :
     gettext(&quot;Your query matched %g files in %g directories.&quot;) ),
   $file_count, $directory_count,
  );
</pre>
<p class="Pp">(The case of &quot;1 file in 2 [or more] directories&quot; could,
    I suppose, occur in the case of symlinking or something of the sort.)</p>
<p class="Pp">It occurs to you that this is not the prettiest code you've ever
    written, but this seems the way to go. You mail off to the translators
    asking for translations for these four cases. The Chinese guy replies with
    the one phrase that these all translate to in Chinese, and that phrase has
    two &quot;%g&quot;s in it, as it should -- but there's a problem. He
    translates it word-for-word back: &quot;In <span class="Li">%g</span>
    directories contains <span class="Li">%g</span> files match your
    query.&quot; The <span class="Li">%g</span> slots are in an order reverse to
    what they are in English. You wonder how you'll get gettext to handle
  that.</p>
<p class="Pp">But you put it aside for the moment, and optimistically hope that
    the other translators won't have this problem, and that their languages will
    be better behaved -- i.e., that they will be just like English.</p>
<p class="Pp">But the Arabic translator is the next to write back. First off,
    your code for &quot;I scanned <span class="Li">%g</span> directory.&quot; or
    &quot;I scanned <span class="Li">%g</span> directories.&quot; assumes
    there's only singular or plural. But, to use linguistic jargon again, Arabic
    has grammatical number, like English (but unlike Chinese), but it's a
    three-term category: singular, dual, and plural. In other words, the way you
    say &quot;directory&quot; depends on whether there's one directory, or
    <i>two</i> of them, or <i>more than two</i> of them. Your test of
    <span class="Li">&quot;($directory == 1)&quot;</span> no longer does the
    job. And it means that where English's grammatical category of number
    necessitates only the two permutations of the first sentence based on
    &quot;directory [singular]&quot; and &quot;directories [plural]&quot;,
    Arabic has three -- and, worse, in the second sentence (&quot;Your query
    matched <span class="Li">%g</span> file in <span class="Li">%g</span>
    directory.&quot;), where English has four, Arabic has nine. You sense an
    unwelcome, exponential trend taking shape.</p>
<p class="Pp">Your Italian translator emails you back and says that &quot;I
    searched 0 directories&quot; (a possible English output of your program) is
    stilted, and if you think that's fine English, that's your problem, but that
    <i>just will not do</i> in the language of Dante. He insists that where
    <span class="Li">$directory_count</span> is 0, your program should produce
    the Italian text for &quot;I <i>didn't</i> scan <i>any</i>
    directories.&quot;. And ditto for &quot;I didn't match any files in any
    directories&quot;, although he says the last part about &quot;in any
    directories&quot; should probably just be left off.</p>
<p class="Pp">You wonder how you'll get gettext to handle this; to accommodate
    the ways Arabic, Chinese, and Italian deal with numbers in just these few
    very simple phrases, you need to write code that will ask gettext for
    different queries depending on whether the numerical values in question are
    1, 2, more than 2, or in some cases 0, and you still haven't figured out the
    problem with the different word order in Chinese.</p>
<p class="Pp">Then your Russian translator calls on the phone, to
    <i>personally</i> tell you the bad news about how really unpleasant your
    life is about to become:</p>
<p class="Pp">Russian, like German or Latin, is an inflectional language; that
    is, nouns and adjectives have to take endings that depend on their case
    (i.e., nominative, accusative, genitive, etc...) -- which is roughly a
    matter of what role they have in syntax of the sentence -- as well as on the
    grammatical gender (i.e., masculine, feminine, neuter) and number (i.e.,
    singular or plural) of the noun, as well as on the declension class of the
    noun. But unlike with most other inflected languages, putting a
    number-phrase (like &quot;ten&quot; or &quot;forty-three&quot;, or their
    Arabic numeral equivalents) in front of noun in Russian can change the case
    and number that noun is, and therefore the endings you have to put on
  it.</p>
<p class="Pp">He elaborates: In &quot;I scanned <span class="Li">%g</span>
    directories&quot;, you'd <i>expect</i> &quot;directories&quot; to be in the
    accusative case (since it is the direct object in the sentence) and the
    plural number, except where <span class="Li">$directory_count</span> is 1,
    then you'd expect the singular, of course. Just like Latin or German.
    <i>But!</i> Where <span class="Li">$directory_count</span> % 10 is 1
    (&quot;%&quot; for modulo, remember), assuming
    <span class="Li">$directory</span> count is an integer, and except where
    <span class="Li">$directory_count</span> % 100 is 11,
    &quot;directories&quot; is forced to become grammatically singular, which
    means it gets the ending for the accusative singular... You begin to
    visualize the code it'd take to test for the problem so far, <i>and still
    work for Chinese</i> <i>and Arabic and Italian</i>, and how many gettext
    items that'd take, but he keeps going... But where
    <span class="Li">$directory_count</span> % 10 is 2, 3, or 4 (except where
    <span class="Li">$directory_count</span> % 100 is 12, 13, or 14), the word
    for &quot;directories&quot; is forced to be genitive singular -- which means
    another ending... The room begins to spin around you, slowly at first... But
    with <i>all other</i> integer values, since &quot;directory&quot; is an
    inanimate noun, when preceded by a number and in the nominative or
    accusative cases (as it is here, just your luck!), it does stay plural, but
    it is forced into the genitive case -- yet another ending... And you never
    hear him get to the part about how you're going to run into similar (but
    maybe subtly different) problems with other Slavic languages like Polish,
    because the floor comes up to meet you, and you fade into
  unconsciousness.</p>
<p class="Pp">The above cautionary tale relates how an attempt at localization
    can lead from programmer consternation, to program obfuscation, to a need
    for sedation. But careful evaluation shows that your choice of tools merely
    needed further consideration.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Linguistic_View"><a class="permalink" href="#The_Linguistic_View">The
  Linguistic View</a></h2>
<div class="Bd-indent">&quot;It is more complicated than you think.&quot;
<p class="Pp">-- The Eighth Networking Truth, from RFC 1925</p>
</div>
<p class="Pp">The field of Linguistics has expended a great deal of effort over
    the past century trying to find grammatical patterns which hold across
    languages; it's been a constant process of people making generalizations
    that should apply to all languages, only to find out that, all too often,
    these generalizations fail -- sometimes failing for just a few languages,
    sometimes whole classes of languages, and sometimes nearly every language in
    the world except English. Broad statistical trends are evident in what the
    &quot;average language&quot; is like as far as what its rules can look like,
    must look like, and cannot look like. But the &quot;average language&quot;
    is just as unreal a concept as the &quot;average person&quot; -- it runs up
    against the fact no language (or person) is, in fact, average. The wisdom of
    past experience leads us to believe that any given language can do whatever
    it wants, in any order, with appeal to any kind of grammatical categories
    wants -- case, number, tense, real or metaphoric characteristics of the
    things that words refer to, arbitrary or predictable classifications of
    words based on what endings or prefixes they can take, degree or means of
    certainty about the truth of statements expressed, and so on, ad
  infinitum.</p>
<p class="Pp">Mercifully, most localization tasks are a matter of finding ways
    to translate whole phrases, generally sentences, where the context is
    relatively set, and where the only variation in content is <i>usually</i> in
    a number being expressed -- as in the example sentences above. Translating
    specific, fully-formed sentences is, in practice, fairly foolproof -- which
    is good, because that's what's in the phrasebooks that so many tourists rely
    on. Now, a given phrase (whether in a phrasebook or in a gettext lexicon) in
    one language <i>might</i> have a greater or lesser applicability than that
    phrase's translation into another language -- for example, strictly
    speaking, in Arabic, the &quot;your&quot; in &quot;Your query
    matched...&quot; would take a different form depending on whether the user
    is male or female; so the Arabic translation &quot;your[feminine]
    query&quot; is applicable in fewer cases than the corresponding English
    phrase, which doesn't distinguish the user's gender. (In practice, it's not
    feasible to have a program know the user's gender, so the masculine
    &quot;you&quot; in Arabic is usually used, by default.)</p>
<p class="Pp">But in general, such surprises are rare when entire sentences are
    being translated, especially when the functional context is restricted to
    that of a computer interacting with a user either to convey a fact or to
    prompt for a piece of information. So, for purposes of localization,
    translation by phrase (generally by sentence) is both the simplest and the
    least problematic.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Breaking_gettext"><a class="permalink" href="#Breaking_gettext">Breaking
  gettext</a></h2>
<div class="Bd-indent">&quot;It Has To Work.&quot;
<p class="Pp">-- First Networking Truth, RFC 1925</p>
</div>
<p class="Pp">Consider that sentences in a tourist phrasebook are of two types:
    ones like &quot;How do I get to the marketplace?&quot; that don't have any
    blanks to fill in, and ones like &quot;How much do these ___ cost?&quot;,
    where there's one or more blanks to fill in (and these are usually linked to
    a list of words that you can put in that blank: &quot;fish&quot;,
    &quot;potatoes&quot;, &quot;tomatoes&quot;, etc.). The ones with no blanks
    are no problem, but the fill-in-the-blank ones may not be really
    straightforward. If it's a Swahili phrasebook, for example, the authors
    probably didn't bother to tell you the complicated ways that the verb
    &quot;cost&quot; changes its inflectional prefix depending on the noun
    you're putting in the blank. The trader in the marketplace will still
    understand what you're saying if you say &quot;how much do these potatoes
    cost?&quot; with the wrong inflectional prefix on &quot;cost&quot;. After
    all, <i>you</i> can't speak proper Swahili, <i>you're</i> just a tourist.
    But while tourists can be stupid, computers are supposed to be smart; the
    computer should be able to fill in the blank, and still have the results be
    grammatical.</p>
<p class="Pp">In other words, a phrasebook entry takes some values as parameters
    (the things that you fill in the blank or blanks), and provides a value
    based on these parameters, where the way you get that final value from the
    given values can, properly speaking, involve an arbitrarily complex series
    of operations. (In the case of Chinese, it'd be not at all complex, at least
    in cases like the examples at the beginning of this article; whereas in the
    case of Russian it'd be a rather complex series of operations. And in some
    languages, the complexity could be spread around differently: while the act
    of putting a number-expression in front of a noun phrase might not be
    complex by itself, it may change how you have to, for example, inflect a
    verb elsewhere in the sentence. This is what in syntax is called
    &quot;long-distance dependencies&quot;.)</p>
<p class="Pp">This talk of parameters and arbitrary complexity is just another
    way to say that an entry in a phrasebook is what in a programming language
    would be called a &quot;function&quot;. Just so you don't miss it, this is
    the crux of this article: <i>A phrase is a function; a phrasebook is a</i>
    <i>bunch of functions.</i></p>
<p class="Pp">The reason that using gettext runs into walls (as in the above
    second-person horror story) is that you're trying to use a string (or worse,
    a choice among a bunch of strings) to do what you really need a function for
    -- which is futile. Preforming (s)printf interpolation on the strings which
    you get back from gettext does allow you to do <i>some</i> common things
    passably well... sometimes... sort of; but, to paraphrase what some people
    say about <span class="Li">&quot;csh&quot;</span> script programming,
    &quot;it fools you into thinking you can use it for real things, but you
    can't, and you don't discover this until you've already spent too much time
    trying, and by then it's too late.&quot;</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Replacing_gettext"><a class="permalink" href="#Replacing_gettext">Replacing
  gettext</a></h2>
<p class="Pp">So, what needs to replace gettext is a system that supports
    lexicons of functions instead of lexicons of strings. An entry in a lexicon
    from such a system should <i>not</i> look like this:</p>
<p class="Pp"></p>
<pre>  &quot;J'ai trouv\xE9 %g fichiers dans %g r\xE9pertoires&quot;
</pre>
<p class="Pp">[\xE9 is e-acute in Latin-1. Some pod renderers would scream if I
    used the actual character here. -- SB]</p>
<p class="Pp">but instead like this, bearing in mind that this is just a first
    stab:</p>
<p class="Pp"></p>
<pre>  sub I_found_X1_files_in_X2_directories {
    my( $files, $dirs ) = @_[0,1];
    $files = sprintf(&quot;%g %s&quot;, $files,
      $files == 1 ? 'fichier' : 'fichiers');
    $dirs = sprintf(&quot;%g %s&quot;, $dirs,
      $dirs == 1 ? &quot;r\xE9pertoire&quot; : &quot;r\xE9pertoires&quot;);
    return &quot;J'ai trouv\xE9 $files dans $dirs.&quot;;
  }
</pre>
<p class="Pp">Now, there's no particularly obvious way to store anything but
    strings in a gettext lexicon; so it looks like we just have to start over
    and make something better, from scratch. I call my shot at a
    gettext-replacement system &quot;Maketext&quot;, or, in CPAN terms,
    Locale::Maketext.</p>
<p class="Pp">When designing Maketext, I chose to plan its main features in
    terms of &quot;buzzword compliance&quot;. And here are the buzzwords:</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Buzzwords:_Abstraction_and_Encapsulation"><a class="permalink" href="#Buzzwords:_Abstraction_and_Encapsulation">Buzzwords:
  Abstraction and Encapsulation</a></h2>
<p class="Pp">The complexity of the language you're trying to output a phrase in
    is entirely abstracted inside (and encapsulated within) the Maketext module
    for that interface. When you call:</p>
<p class="Pp"></p>
<pre>  print $lang-&gt;maketext(&quot;You have [quant,_1,piece] of new mail.&quot;,
                       scalar(@messages));
</pre>
<p class="Pp">you don't know (and in fact can't easily find out) whether this
    will involve lots of figuring, as in Russian (if
    <span class="Li">$lang</span> is a handle to the Russian module), or
    relatively little, as in Chinese. That kind of abstraction and encapsulation
    may encourage other pleasant buzzwords like modularization and
    stratification, depending on what design decisions you make.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Buzzword:_Isomorphism"><a class="permalink" href="#Buzzword:_Isomorphism">Buzzword:
  Isomorphism</a></h2>
<p class="Pp">&quot;Isomorphism&quot; means &quot;having the same structure or
    form&quot;; in discussions of program design, the word takes on the special,
    specific meaning that your implementation of a solution to a problem <i>has
    the same</i> <i>structure</i> as, say, an informal verbal description of the
    solution, or maybe of the problem itself. Isomorphism is, all things
    considered, a good thing -- it's what problem-solving (and
    solution-implementing) should look like.</p>
<p class="Pp">What's wrong the with gettext-using code like this...</p>
<p class="Pp"></p>
<pre>  printf( $file_count == 1 ?
    ( $directory_count == 1 ?
     &quot;Your query matched %g file in %g directory.&quot; :
     &quot;Your query matched %g file in %g directories.&quot; ) :
    ( $directory_count == 1 ?
     &quot;Your query matched %g files in %g directory.&quot; :
     &quot;Your query matched %g files in %g directories.&quot; ),
   $file_count, $directory_count,
  );
</pre>
<p class="Pp">is first off that it's not well abstracted -- these ways of
    testing for grammatical number (as in the expressions like
    <span class="Li">&quot;foo == 1 ?</span> <span class="Li">singular_form :
    plural_form&quot;</span>) should be abstracted to each language module,
    since how you get grammatical number is language-specific.</p>
<p class="Pp">But second off, it's not isomorphic -- the &quot;solution&quot;
    (i.e., the phrasebook entries) for Chinese maps from these four English
    phrases to the one Chinese phrase that fits for all of them. In other words,
    the informal solution would be &quot;The way to say what you want in Chinese
    is with the one phrase 'For your question, in Y directories you would find X
    files'&quot; -- and so the implemented solution should be, isomorphically,
    just a straightforward way to spit out that one phrase, with numerals
    properly interpolated. It shouldn't have to map from the complexity of other
    languages to the simplicity of this one.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Buzzword:_Inheritance"><a class="permalink" href="#Buzzword:_Inheritance">Buzzword:
  Inheritance</a></h2>
<p class="Pp">There's a great deal of reuse possible for sharing of phrases
    between modules for related dialects, or for sharing of auxiliary functions
    between related languages. (By &quot;auxiliary functions&quot;, I mean
    functions that don't produce phrase-text, but which, say, return an answer
    to &quot;does this number require a plural noun after it?&quot;. Such
    auxiliary functions would be used in the internal logic of functions that
    actually do produce phrase-text.)</p>
<p class="Pp">In the case of sharing phrases, consider that you have an
    interface already localized for American English (probably by having been
    written with that as the native locale, but that's incidental). Localizing
    it for UK English should, in practical terms, be just a matter of running it
    past a British person with the instructions to indicate what few phrases
    would benefit from a change in spelling or possibly minor rewording. In that
    case, you should be able to put in the UK English localization module
    <i>only</i> those phrases that are UK-specific, and for all the rest,
    <i>inherit</i> from the American English module. (And I expect this same
    situation would apply with Brazilian and Continental Portugese, possibly
    with some <i>very</i> closely related languages like Czech and Slovak, and
    possibly with the slightly different &quot;versions&quot; of written
    Mandarin Chinese, as I hear exist in Taiwan and mainland China.)</p>
<p class="Pp">As to sharing of auxiliary functions, consider the problem of
    Russian numbers from the beginning of this article; obviously, you'd want to
    write only once the hairy code that, given a numeric value, would return
    some specification of which case and number a given quantified noun should
    use. But suppose that you discover, while localizing an interface for, say,
    Ukrainian (a Slavic language related to Russian, spoken by several million
    people, many of whom would be relieved to find that your Web site's or
    software's interface is available in their language), that the rules in
    Ukrainian are the same as in Russian for quantification, and probably for
    many other grammatical functions. While there may well be no phrases in
    common between Russian and Ukrainian, you could still choose to have the
    Ukrainian module inherit from the Russian module, just for the sake of
    inheriting all the various grammatical methods. Or, probably better
    organizationally, you could move those functions to a module called
    <span class="Li">&quot;_E_Slavic&quot;</span> or something, which Russian
    and Ukrainian could inherit useful functions from, but which would
    (presumably) provide no lexicon.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Buzzword:_Concision"><a class="permalink" href="#Buzzword:_Concision">Buzzword:
  Concision</a></h2>
<p class="Pp">Okay, concision isn't a buzzword. But it should be, so I decree
    that as a new buzzword, &quot;concision&quot; means that simple common
    things should be expressible in very few lines (or maybe even just a few
    characters) of code -- call it a special case of &quot;making simple things
    easy and hard things possible&quot;, and see also the role it played in the
    MIDI::Simple language, discussed elsewhere in this issue [TPJ#13].</p>
<p class="Pp">Consider our first stab at an entry in our &quot;phrasebook of
    functions&quot;:</p>
<p class="Pp"></p>
<pre>  sub I_found_X1_files_in_X2_directories {
    my( $files, $dirs ) = @_[0,1];
    $files = sprintf(&quot;%g %s&quot;, $files,
      $files == 1 ? 'fichier' : 'fichiers');
    $dirs = sprintf(&quot;%g %s&quot;, $dirs,
      $dirs == 1 ? &quot;r\xE9pertoire&quot; : &quot;r\xE9pertoires&quot;);
    return &quot;J'ai trouv\xE9 $files dans $dirs.&quot;;
  }
</pre>
<p class="Pp">You may sense that a lexicon (to use a non-committal catch-all
    term for a collection of things you know how to say, regardless of whether
    they're phrases or words) consisting of functions <i>expressed</i> as above
    would make for rather long-winded and repetitive code -- even if you wisely
    rewrote this to have quantification (as we call adding a number expression
    to a noun phrase) be a function called like:</p>
<p class="Pp"></p>
<pre>  sub I_found_X1_files_in_X2_directories {
    my( $files, $dirs ) = @_[0,1];
    $files = quant($files, &quot;fichier&quot;);
    $dirs =  quant($dirs,  &quot;r\xE9pertoire&quot;);
    return &quot;J'ai trouv\xE9 $files dans $dirs.&quot;;
  }
</pre>
<p class="Pp">And you may also sense that you do not want to bother your
    translators with having to write Perl code -- you'd much rather that they
    spend their <i>very costly time</i> on just translation. And this is to say
    nothing of the near impossibility of finding a commercial translator who
    would know even simple Perl.</p>
<p class="Pp">In a first-hack implementation of Maketext, each language-module's
    lexicon looked like this:</p>
<p class="Pp"></p>
<pre> %Lexicon = (
   &quot;I found %g files in %g directories&quot;
   =&gt; sub {
      my( $files, $dirs ) = @_[0,1];
      $files = quant($files, &quot;fichier&quot;);
      $dirs =  quant($dirs,  &quot;r\xE9pertoire&quot;);
      return &quot;J'ai trouv\xE9 $files dans $dirs.&quot;;
    },
  ... and so on with other phrase =&gt; sub mappings ...
 );
</pre>
<p class="Pp">but I immediately went looking for some more concise way to
    basically denote the same phrase-function -- a way that would also serve to
    concisely denote <i>most</i> phrase-functions in the lexicon for <i>most</i>
    languages. After much time and even some actual thought, I decided on this
    system:</p>
<p class="Pp">* Where a value in a <span class="Li">%Lexicon</span> hash is a
    contentful string instead of an anonymous sub (or, conceivably, a coderef),
    it would be interpreted as a sort of shorthand expression of what the sub
    does. When accessed for the first time in a session, it is parsed, turned
    into Perl code, and then eval'd into an anonymous sub; then that sub
    replaces the original string in that lexicon. (That way, the work of parsing
    and evaling the shorthand form for a given phrase is done no more than once
    per session.)</p>
<p class="Pp">* Calls to <span class="Li">&quot;maketext&quot;</span> (as
    Maketext's main function is called) happen thru a &quot;language session
    handle&quot;, notionally very much like an IO handle, in that you open one
    at the start of the session, and use it for &quot;sending signals&quot; to
    an object in order to have it return the text you want.</p>
<p class="Pp">So, this:</p>
<p class="Pp"></p>
<pre>  $lang-&gt;maketext(&quot;You have [quant,_1,piece] of new mail.&quot;,
                 scalar(@messages));
</pre>
<p class="Pp">basically means this: look in the lexicon for
    <span class="Li">$lang</span> (which may inherit from any number of other
    lexicons), and find the function that we happen to associate with the string
    &quot;You have [quant,_1,piece] of new mail&quot; (which is, and should be,
    a functioning &quot;shorthand&quot; for this function in the native locale
    -- English in this case). If you find such a function, call it with
    <span class="Li">$lang</span> as its first parameter (as if it were a
    method), and then a copy of scalar(@messages) as its second, and then return
    that value. If that function was found, but was in string shorthand instead
    of being a fully specified function, parse it and make it into a function
    before calling it the first time.</p>
<p class="Pp">* The shorthand uses code in brackets to indicate method calls
    that should be performed. A full explanation is not in order here, but a few
    examples will suffice:</p>
<p class="Pp"></p>
<pre>  &quot;You have [quant,_1,piece] of new mail.&quot;
</pre>
<p class="Pp">The above code is shorthand for, and will be interpreted as,
  this:</p>
<p class="Pp"></p>
<pre>  sub {
    my $handle = $_[0];
    my(@params) = @_;
    return join '',
      &quot;You have &quot;,
      $handle-&gt;quant($params[1], 'piece'),
      &quot;of new mail.&quot;;
  }
</pre>
<p class="Pp">where &quot;quant&quot; is the name of a method you're using to
    quantify the noun &quot;piece&quot; with the number
    <span class="Li">$params</span>[0].</p>
<p class="Pp">A string with no brackety calls, like this:</p>
<p class="Pp"></p>
<pre>  &quot;Your search expression was malformed.&quot;
</pre>
<p class="Pp">is somewhat of a degenerate case, and just gets turned into:</p>
<p class="Pp"></p>
<pre>  sub { return &quot;Your search expression was malformed.&quot; }
</pre>
<p class="Pp">However, not everything you can write in Perl code can be written
    in the above shorthand system -- not by a long shot. For example, consider
    the Italian translator from the beginning of this article, who wanted the
    Italian for &quot;I didn't find any files&quot; as a special case, instead
    of &quot;I found 0 files&quot;. That couldn't be specified (at least not
    easily or simply) in our shorthand system, and it would have to be written
    out in full, like this:</p>
<p class="Pp"></p>
<pre>  sub {  # pretend the English strings are in Italian
    my($handle, $files, $dirs) = @_[0,1,2];
    return &quot;I didn't find any files&quot; unless $files;
    return join '',
      &quot;I found &quot;,
      $handle-&gt;quant($files, 'file'),
      &quot; in &quot;,
      $handle-&gt;quant($dirs,  'directory'),
      &quot;.&quot;;
  }
</pre>
<p class="Pp">Next to a lexicon full of shorthand code, that sort of sticks out
    like a sore thumb -- but this <i>is</i> a special case, after all; and at
    least it's possible, if not as concise as usual.</p>
<p class="Pp">As to how you'd implement the Russian example from the beginning
    of the article, well, There's More Than One Way To Do It, but it could be
    something like this (using English words for Russian, just so you know
    what's going on):</p>
<p class="Pp"></p>
<pre>  &quot;I [quant,_1,directory,accusative] scanned.&quot;
</pre>
<p class="Pp">This shifts the burden of complexity off to the quant method. That
    method's parameters are: the numeric value it's going to use to quantify
    something; the Russian word it's going to quantify; and the parameter
    &quot;accusative&quot;, which you're using to mean that this sentence's
    syntax wants a noun in the accusative case there, although that
    quantification method may have to overrule, for grammatical reasons you may
    recall from the beginning of this article.</p>
<p class="Pp">Now, the Russian quant method here is responsible not only for
    implementing the strange logic necessary for figuring out how Russian
    number-phrases impose case and number on their noun-phrases, but also for
    inflecting the Russian word for &quot;directory&quot;. How that inflection
    is to be carried out is no small issue, and among the solutions I've seen,
    some (like variations on a simple lookup in a hash where all possible forms
    are provided for all necessary words) are straightforward but <i>can</i>
    become cumbersome when you need to inflect more than a few dozen words; and
    other solutions (like using algorithms to model the inflections, storing
    only root forms and irregularities) <i>can</i> involve more overhead than is
    justifiable for all but the largest lexicons.</p>
<p class="Pp">Mercifully, this design decision becomes crucial only in the
    hairiest of inflected languages, of which Russian is by no means the
    <i>worst</i> case scenario, but is worse than most. Most languages have
    simpler inflection systems; for example, in English or Swahili, there are
    generally no more than two possible inflected forms for a given noun
    (&quot;error/errors&quot;; &quot;kosa/makosa&quot;), and the rules for
    producing these forms are fairly simple -- or at least, simple rules can be
    formulated that work for most words, and you can then treat the exceptions
    as just &quot;irregular&quot;, at least relative to your ad hoc rules. A
    simpler inflection system (simpler rules, fewer forms) means that design
    decisions are less crucial to maintaining sanity, whereas the same decisions
    could incur overhead-versus-scalability problems in languages like Russian.
    It may <i>also</i> be likely that code (possibly in Perl, as with
    Lingua::EN::Inflect, for English nouns) has already been written for the
    language in question, whether simple or complex.</p>
<p class="Pp">Moreover, a third possibility may even be simpler than anything
    discussed above: &quot;Just require that all possible (or at least
    applicable) forms be provided in the call to the given language's quant
    method, as in:&quot;</p>
<p class="Pp"></p>
<pre>  &quot;I found [quant,_1,file,files].&quot;
</pre>
<p class="Pp">That way, quant just has to chose which form it needs, without
    having to look up or generate anything. While possibly not optimal for
    Russian, this should work well for most other languages, where
    quantification is not as complicated an operation.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Devil_in_the_Details"><a class="permalink" href="#The_Devil_in_the_Details">The
  Devil in the Details</a></h2>
<p class="Pp">There's plenty more to Maketext than described above -- for
    example, there's the details of how language tags (&quot;en-US&quot;,
    &quot;i-pwn&quot;, &quot;fi&quot;, etc.) or locale IDs (&quot;en_US&quot;)
    interact with actual module naming (&quot;BogoQuery/Locale/en_us.pm&quot;),
    and what magic can ensue; there's the details of how to record (and possibly
    negotiate) what character encoding Maketext will return text in (UTF8?
    Latin-1? KOI8?). There's the interesting fact that Maketext is for
    localization, but nowhere actually has a &quot;<span class="Li">&quot;use
    locale;&quot;</span>&quot; anywhere in it. For the curious, there's the
    somewhat frightening details of how I actually implement something like data
    inheritance so that searches across modules'
    <span class="Li">%Lexicon</span> hashes can parallel how Perl implements
    method inheritance.</p>
<p class="Pp">And, most importantly, there's all the practical details of how to
    actually go about deriving from Maketext so you can use it for your
    interfaces, and the various tools and conventions for starting out and
    maintaining individual language modules.</p>
<p class="Pp">That is all covered in the documentation for Locale::Maketext and
    the modules that come with it, available in CPAN. After having read this
    article, which covers the why's of Maketext, the documentation, which covers
    the how's of it, should be quite straightforward.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Proof_in_the_Pudding:_Localizing_Web_Sites"><a class="permalink" href="#The_Proof_in_the_Pudding:_Localizing_Web_Sites">The
  Proof in the Pudding: Localizing Web Sites</a></h2>
<p class="Pp">Maketext and gettext have a notable difference: gettext is in C,
    accessible thru C library calls, whereas Maketext is in Perl, and really
    can't work without a Perl interpreter (although I suppose something like it
    could be written for C). Accidents of history (and not necessarily lucky
    ones) have made C++ the most common language for the implementation of
    applications like word processors, Web browsers, and even many in-house
    applications like custom query systems. Current conditions make it somewhat
    unlikely that the next one of any of these kinds of applications will be
    written in Perl, albeit clearly more for reasons of custom and inertia than
    out of consideration of what is the right tool for the job.</p>
<p class="Pp">However, other accidents of history have made Perl a well-accepted
    language for design of server-side programs (generally in CGI form) for Web
    site interfaces. Localization of static pages in Web sites is trivial,
    feasible either with simple language-negotiation features in servers like
    Apache, or with some kind of server-side inclusions of language-appropriate
    text into layout templates. However, I think that the localization of
    Perl-based search systems (or other kinds of dynamic content) in Web sites,
    be they public or access-restricted, is where Maketext will see the greatest
    use.</p>
<p class="Pp">I presume that it would be only the exceptional Web site that gets
    localized for English <i>and</i> Chinese <i>and</i> Italian <i>and</i>
    Arabic <i>and</i> Russian, to recall the languages from the beginning of
    this article -- to say nothing of German, Spanish, French, Japanese,
    Finnish, and Hindi, to name a few languages that benefit from large numbers
    of programmers or Web viewers or both.</p>
<p class="Pp">However, the ever-increasing internationalization of the Web
    (whether measured in terms of amount of content, of numbers of content
    writers or programmers, or of size of content audiences) makes it
    increasingly likely that the interface to the average Web-based dynamic
    content service will be localized for two or maybe three languages. It is my
    hope that Maketext will make that task as simple as possible, and will
    remove previous barriers to localization for languages dissimilar to
    English.</p>
<p class="Pp"></p>
<pre> __END__
</pre>
<p class="Pp">Sean M. Burke (sburke@cpan.org) has a Master's in linguistics from
    Northwestern University; he specializes in language technology. Jordan
    Lachler (lachler@unm.edu) is a PhD student in the Department of Linguistics
    at the University of New Mexico; he specializes in morphology and pedagogy
    of North American native languages.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="References"><a class="permalink" href="#References">References</a></h2>
<p class="Pp">Alvestrand, Harald Tveit. 1995. <i>RFC 1766: Tags for the</i>
    <i>Identification of Languages.</i>
    <span class="Li">&quot;&lt;http://www.ietf.org/rfc/rfc1766.txt&gt;&quot;</span>
    [Now see RFC 3066.]</p>
<p class="Pp">Callon, Ross, editor. 1996. <i>RFC 1925: The Twelve</i>
    <i>Networking Truths.</i>
    <span class="Li">&quot;&lt;http://www.ietf.org/rfc/rfc1925.txt&gt;&quot;</span></p>
<p class="Pp">Drepper, Ulrich, Peter Miller, and Francois Pinard. 1995-2001. GNU
    <span class="Li">&quot;gettext&quot;</span>. Available in
    <span class="Li">&quot;&lt;ftp://prep.ai.mit.edu/pub/gnu/&gt;&quot;</span>,
    with extensive docs in the distribution tarball. [Since I wrote this article
    in 1998, I now see that the gettext docs are now trying more to come to
    terms with plurality. Whether useful conclusions have come from it is
    another question altogether. -- SMB, May 2001]</p>
<p class="Pp">Forbes, Nevill. 1964. <i>Russian Grammar.</i> Third Edition,
    revised by J. C. Dumbreck. Oxford University Press.</p>
</section>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-10-24</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PPI(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PPI(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">PPI(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">PPI - Parse, Analyze and Manipulate Perl (without perl)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  use PPI;
  
  # Create a new empty document
  my $Document = PPI::Document-&gt;new;
  
  # Create a document from source
  $Document = PPI::Document-&gt;new(\'print &quot;Hello World!\n&quot;');
  
  # Load a Document from a file
  $Document = PPI::Document-&gt;new('Module.pm');
  
  # Does it contain any POD?
  if ( $Document-&gt;find_any('PPI::Token::Pod') ) {
      print &quot;Module contains POD\n&quot;;
  }
  
  # Get the name of the main package
  $pkg = $Document-&gt;find_first('PPI::Statement::Package')-&gt;namespace;
  
  # Remove all that nasty documentation
  $Document-&gt;prune('PPI::Token::Pod');
  $Document-&gt;prune('PPI::Token::Comment');
  
  # Save the file
  $Document-&gt;save('Module.pm.stripped');
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<section class="Ss">
<h2 class="Ss" id="About_this_Document"><a class="permalink" href="#About_this_Document">About
  this Document</a></h2>
<p class="Pp">This is the PPI manual. It describes its reason for existing, its
    general structure, its use, an overview of the API, and provides a few
    implementation samples.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Background"><a class="permalink" href="#Background">Background</a></h2>
<p class="Pp">The ability to read, and manipulate Perl (the language)
    programmatically other than with perl (the application) was one that caused
    difficulty for a long time.</p>
<p class="Pp">The cause of this problem was Perl's complex and dynamic grammar.
    Although there is typically not a huge diversity in the grammar of most Perl
    code, certain issues cause large problems when it comes to parsing.</p>
<p class="Pp">Indeed, quite early in Perl's history Tom Christiansen introduced
    the Perl community to the quote <i>&quot;Nothing but perl can parse
    Perl&quot;</i>, or as it is more often stated now as a truism:</p>
<p class="Pp"><b>&quot;Only perl can parse Perl&quot;</b></p>
<p class="Pp">One example of the sorts of things the prevent Perl being easily
    parsed are function signatures, as demonstrated by the following.</p>
<p class="Pp"></p>
<pre>  @result = (dothis $foo, $bar);
  
  # Which of the following is it equivalent to?
  @result = (dothis($foo), $bar);
  @result = dothis($foo, $bar);
</pre>
<p class="Pp">The first line above can be interpreted in two different ways,
    depending on whether the <span class="Li">&amp;dothis</span> function is
    expecting one argument, or two, or several.</p>
<p class="Pp">A &quot;code parser&quot; (something that parses for the purpose
    of execution) such as perl needs information that is not found in the
    immediate vicinity of the statement being parsed.</p>
<p class="Pp">The information might not just be elsewhere in the file, it might
    not even be in the same file at all. It might also not be able to determine
    this information without the prior execution of a
    <span class="Li">&quot;BEGIN {}&quot;</span> block, or the loading and
    execution of one or more external modules. Or worse the
    <span class="Li">&amp;dothis</span> function may not even have been written
    yet.</p>
<p class="Pp"><b>When parsing Perl as code, you must also execute it</b></p>
<p class="Pp">Even perl itself never really fully understands the structure of
    the source code after and indeed <b>as</b> it processes it, and in that
    sense doesn't &quot;parse&quot; Perl source into anything remotely like a
    structured document. This makes it of no real use for any task that needs to
    treat the source code as a document, and do so reliably and robustly.</p>
<p class="Pp">For more information on why it is impossible to parse perl, see
    Randal Schwartz's seminal response to the question of &quot;Why can't you
    parse Perl&quot;.</p>
<p class="Pp">&lt;http://www.perlmonks.org/index.pl?node_id=44722&gt;</p>
<p class="Pp">The purpose of PPI is <b>not</b> to parse Perl <i>Code</i>, but to
    parse Perl <i>Documents</i>. By treating the problem this way, we are able
    to parse a single file containing Perl source code &quot;isolated&quot; from
    any other resources, such as libraries upon which the code may depend, and
    without needing to run an instance of perl alongside or inside the
  parser.</p>
<p class="Pp">Historically, using an embedded perl parser was widely considered
    to be the most likely avenue for finding a solution to parsing Perl. It has
    been investigated from time to time, but attempts have generally failed or
    suffered from sufficiently bad corner cases that they were abandoned.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="What_Does_"><a class="permalink" href="#What_Does_">What Does
  PPI Stand For?</a></h2>
<p class="Pp"><span class="Li">&quot;PPI&quot;</span> is an acronym for the
    longer original module name
    <span class="Li">&quot;Parse::Perl::Isolated&quot;</span>. And in the spirit
    of the silly acronym games played by certain unnamed Open Source projects
    you may have <i>hurd</i> of, it is also a reverse backronym of &quot;I Parse
    Perl&quot;.</p>
<p class="Pp">Of course, I could just be lying and have just made that second
    bit up 10 minutes before the release of PPI 1.000. Besides, <b>all</b> the
    cool Perl packages have TLAs (Three Letter Acronyms). It's a rule or
    something.</p>
<p class="Pp">Why don't you just think of it as the <b>Perl Parsing
    Interface</b> for simplicity.</p>
<p class="Pp">The original name was shortened to prevent the author (and you the
    users) from contracting RSI by having to type crazy things like
    <span class="Li">&quot;Parse::Perl::Isolated::Token::QuoteLike::Backtick&quot;</span>
    100 times a day.</p>
<p class="Pp">In acknowledgment that someone may some day come up with a valid
    solution for the grammar problem it was decided at the commencement of the
    project to leave the <span class="Li">&quot;Parse::Perl&quot;</span>
    namespace free for any such effort.</p>
<p class="Pp">Since that time I've been able to prove to my own satisfaction
    that it <b>is</b> truly impossible to accurately parse Perl as both code and
    document at once. For the academics, parsing Perl suffers from the
    &quot;Halting Problem&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Why_Parse_Perl?"><a class="permalink" href="#Why_Parse_Perl?">Why
  Parse Perl?</a></h2>
<p class="Pp">Once you can accept that we will never be able to parse Perl well
    enough to meet the standards of things that treat Perl as code, it is worth
    re-examining <i>why</i> we want to &quot;parse&quot; Perl at all.</p>
<p class="Pp">What are the things that people might want a &quot;Perl
    parser&quot; for?</p>
<dl class="Bl-tag">
  <dt id="Documentation"><a class="permalink" href="#Documentation">Documentation</a></dt>
  <dd>Analyzing the contents of a Perl document to automatically generate
      documentation, in parallel to, or as a replacement for, POD documentation.
    <p class="Pp">Allow an indexer to locate and process all the comments and
        documentation from code for &quot;full text search&quot;
      applications.</p>
  </dd>
  <dt id="Structural"><a class="permalink" href="#Structural">Structural and
    Quality Analysis</a></dt>
  <dd>Determine quality or other metrics across a body of code, and identify
      situations relating to particular phrases, techniques or locations.
    <p class="Pp">Index functions, variables and packages within Perl code, and
        doing search and graph (in the node/edge sense) analysis of large code
        bases.</p>
    <p class="Pp">Perl::Critic, based on PPI, is a large, thriving tool for bug
        detection and style analysis of Perl code.</p>
  </dd>
  <dt id="Refactoring"><a class="permalink" href="#Refactoring">Refactoring</a></dt>
  <dd>Make structural, syntax, or other changes to code in an automated manner,
      either independently or in assistance to an editor. This sort of task list
      includes backporting, forward porting, partial evaluation,
      &quot;improving&quot; code, or whatever. All the sort of things you'd want
      from a Perl::Editor.</dd>
  <dt id="Layout"><a class="permalink" href="#Layout">Layout</a></dt>
  <dd>Change the layout of code without changing its meaning. This includes
      techniques such as tidying (like perltidy), obfuscation, compressing and
      &quot;squishing&quot;, or to implement formatting preferences or
    policies.</dd>
  <dt id="Presentation"><a class="permalink" href="#Presentation">Presentation</a></dt>
  <dd>This includes methods of improving the presentation of code, without
      changing the content of the code. Modify, improve, syntax colour etc the
      presentation of a Perl document. Generating &quot;IntelliText&quot;-like
      functions.</dd>
</dl>
<p class="Pp">If we treat this as a baseline for the sort of things we are going
    to have to build on top of Perl, then it becomes possible to identify a
    standard for how good a Perl parser needs to be.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_good_is_Good_Enough("><a class="permalink" href="#How_good_is_Good_Enough(">How
  good is Good Enough(TM)</a></h2>
<p class="Pp">PPI seeks to be good enough to achieve all of the above tasks, or
    to provide a sufficiently good API on which to allow others to implement
    modules in these and related areas.</p>
<p class="Pp">However, there are going to be limits to this process. Because PPI
    cannot adapt to changing grammars, any code written using source filters
    should not be assumed to be parsable.</p>
<p class="Pp">At one extreme, this includes anything munged by Acme::Bleach, as
    well as (arguably) more common cases like Switch. We do not pretend to be
    able to always parse code using these modules, although as long as it still
    follows a format that looks like Perl syntax, it may be possible to extend
    the lexer to handle them.</p>
<p class="Pp">The ability to extend PPI to handle lexical additions to the
    language is on the drawing board to be done some time post-1.0</p>
<p class="Pp">The goal for success was originally to be able to successfully
    parse 99% of all Perl documents contained in CPAN. This means the entire
    file in each case.</p>
<p class="Pp">PPI has succeeded in this goal far beyond the expectations of even
    the author. At time of writing there are only 28 non-Acme Perl modules in
    CPAN that PPI is incapable of parsing. Most of these are so badly broken
    they do not compile as Perl code anyway.</p>
<p class="Pp">So unless you are actively going out of your way to break PPI, you
    should expect that it will handle your code just fine.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Internationalisation"><a class="permalink" href="#Internationalisation">Internationalisation</a></h2>
<p class="Pp">PPI provides partial support for internationalisation and
    localisation.</p>
<p class="Pp">Specifically, it allows the use of characters from the Latin-1
    character set to be used in quotes, comments, and POD. Primarily, this
    covers languages from Europe and South America.</p>
<p class="Pp">PPI does <b>not</b> currently provide support for Unicode. If you
    need Unicode support and would like to help, contact the author. (contact
    details below)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Round_Trip_Safe"><a class="permalink" href="#Round_Trip_Safe">Round
  Trip Safe</a></h2>
<p class="Pp">When PPI parses a file it builds <b>everything</b> into the model,
    including whitespace. This is needed in order to make the Document fully
    &quot;Round Trip&quot; safe.</p>
<p class="Pp">The general concept behind a &quot;Round Trip&quot; parser is that
    it knows what it is parsing is somewhat uncertain, and so <b>expects</b> to
    get things wrong from time to time. In the cases where it parses code
    wrongly the tree will serialize back out to the same string of code that was
    read in, repairing the parser's mistake as it heads back out to the
  file.</p>
<p class="Pp">The end result is that if you parse in a file and serialize it
    back out without changing the tree, you are guaranteed to get the same file
    you started with. PPI does this correctly and reliably for 100% of all known
    cases.</p>
<p class="Pp"><b>What goes in, will come out. Every time.</b></p>
<p class="Pp">The one minor exception at this time is that if the newlines for
    your file are wrong (meaning not matching the platform newline format), PPI
    will localise them for you. (It isn't to be convenient, supporting arbitrary
    newlines would make some of the code more complicated)</p>
<p class="Pp">Better control of the newline type is on the wish list though, and
    anyone wanting to help out is encouraged to contact the author.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="IMPLEMENTATION"><a class="permalink" href="#IMPLEMENTATION">IMPLEMENTATION</a></h1>
<section class="Ss">
<h2 class="Ss" id="General_Layout"><a class="permalink" href="#General_Layout">General
  Layout</a></h2>
<p class="Pp">PPI is built upon two primary &quot;parsing&quot; components,
    PPI::Tokenizer and PPI::Lexer, and a large tree of about 70 classes which
    implement the various the <i>Perl Document Object Model</i> (PDOM).</p>
<p class="Pp">The PDOM is conceptually similar in style and intent to the
    regular DOM or other code Abstract Syntax Trees (ASTs), but contains some
    differences to handle perl-specific cases, and to assist in treating the
    code as a document. Please note that it is <b>not</b> an implementation of
    the official Document Object Model specification, only somewhat similar to
    it.</p>
<p class="Pp">On top of the Tokenizer, Lexer and the classes of the PDOM, sit a
    number of classes intended to make life a little easier when dealing with
    PDOM trees.</p>
<p class="Pp">Both the major parsing components were hand-coded from scratch
    with only plain Perl code and a few small utility modules. There are no
    grammar or patterns mini-languages, no YACC or LEX style tools and only a
    small number of regular expressions.</p>
<p class="Pp">This is primarily because of the sheer volume of accumulated cruft
    that exists in Perl. Not even perl itself is capable of parsing Perl
    documents (remember, it just parses and executes it as code).</p>
<p class="Pp">As a result, PPI needed to be cruftier than perl itself. Feel free
    to shudder at this point, and hope you never have to understand the
    Tokenizer codebase. Speaking of which...</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Tokenizer"><a class="permalink" href="#The_Tokenizer">The
  Tokenizer</a></h2>
<p class="Pp">The Tokenizer takes source code and converts it into a series of
    tokens. It does this using a slow but thorough character by character manual
    process, rather than using a pattern system or complex regexes.</p>
<p class="Pp">Or at least it does so conceptually. If you were to actually trace
    the code you would find it's not truly character by character due to a
    number of regexps and optimisations throughout the code. This lets the
    Tokenizer &quot;skip ahead&quot; when it can find shortcuts, so it tends to
    jump around a line a bit wildly at times.</p>
<p class="Pp">In practice, the number of times the Tokenizer will
    <b>actually</b> move the character cursor itself is only about 5% - 10%
    higher than the number of tokens contained in the file. This makes it about
    as optimal as it can be made without implementing it in something other than
    Perl.</p>
<p class="Pp">In 2001 when PPI was started, this structure made PPI quite slow,
    and not really suitable for interactive tasks. This situation has improved
    greatly with multi-gigahertz processors, but can still be painful when
    working with very large files.</p>
<p class="Pp">The target parsing rate for PPI is about 5000 lines per gigacycle.
    It is currently believed to be at about 1500, and the main avenue for making
    it to the target speed has now become PPI::XS, a drop-in XS accelerator for
    PPI.</p>
<p class="Pp">Since PPI::XS has only just gotten off the ground and is currently
    only at proof-of-concept stage, this may take a little while. Anyone
    interested in helping out with PPI::XS is <b>highly</b> encouraged to
    contact the author. In fact, the design of PPI::XS means it's possible to
    port one function at a time safely and reliably. So every little bit will
    help.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Lexer"><a class="permalink" href="#The_Lexer">The
  Lexer</a></h2>
<p class="Pp">The Lexer takes a token stream, and converts it to a lexical tree.
    Because we are parsing Perl <b>documents</b> this includes whitespace,
    comments, and all number of weird things that have no relevance when code is
    actually executed.</p>
<p class="Pp">An instantiated PPI::Lexer consumes PPI::Tokenizer objects and
    produces PPI::Document objects. However you should probably never be working
    with the Lexer directly. You should just be able to create PPI::Document
    objects and work with them directly.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Perl_Document_Object_Model"><a class="permalink" href="#The_Perl_Document_Object_Model">The
  Perl Document Object Model</a></h2>
<p class="Pp">The PDOM is a structured collection of data classes that together
    provide a correct and scalable model for documents that follow the standard
    Perl syntax.</p>
</section>
<section class="Ss">
<h2 class="Ss">The PDOM Class Tree</h2>
<p class="Pp">The following lists all of the 72 current PDOM classes, listing
    with indentation based on inheritance.</p>
<p class="Pp"></p>
<pre>   PPI::Element
      PPI::Node
         PPI::Document
            PPI::Document::Fragment
         PPI::Statement
            PPI::Statement::Package
            PPI::Statement::Include
            PPI::Statement::Sub
               PPI::Statement::Scheduled
            PPI::Statement::Compound
            PPI::Statement::Break
            PPI::Statement::Given
            PPI::Statement::When
            PPI::Statement::Data
            PPI::Statement::End
            PPI::Statement::Expression
               PPI::Statement::Variable
            PPI::Statement::Null
            PPI::Statement::UnmatchedBrace
            PPI::Statement::Unknown
         PPI::Structure
            PPI::Structure::Block
            PPI::Structure::Subscript
            PPI::Structure::Constructor
            PPI::Structure::Condition
            PPI::Structure::List
            PPI::Structure::For
            PPI::Structure::Given
            PPI::Structure::When
            PPI::Structure::Unknown
      PPI::Token
         PPI::Token::Whitespace
         PPI::Token::Comment
         PPI::Token::Pod
         PPI::Token::Number
            PPI::Token::Number::Binary
            PPI::Token::Number::Octal
            PPI::Token::Number::Hex
            PPI::Token::Number::Float
               PPI::Token::Number::Exp
            PPI::Token::Number::Version
         PPI::Token::Word
         PPI::Token::DashedWord
         PPI::Token::Symbol
            PPI::Token::Magic
         PPI::Token::ArrayIndex
         PPI::Token::Operator
         PPI::Token::Quote
            PPI::Token::Quote::Single
            PPI::Token::Quote::Double
            PPI::Token::Quote::Literal
            PPI::Token::Quote::Interpolate
         PPI::Token::QuoteLike
            PPI::Token::QuoteLike::Backtick
            PPI::Token::QuoteLike::Command
            PPI::Token::QuoteLike::Regexp
            PPI::Token::QuoteLike::Words
            PPI::Token::QuoteLike::Readline
         PPI::Token::Regexp
            PPI::Token::Regexp::Match
            PPI::Token::Regexp::Substitute
            PPI::Token::Regexp::Transliterate
         PPI::Token::HereDoc
         PPI::Token::Cast
         PPI::Token::Structure
         PPI::Token::Label
         PPI::Token::Separator
         PPI::Token::Data
         PPI::Token::End
         PPI::Token::Prototype
         PPI::Token::Attribute
         PPI::Token::Unknown
</pre>
<p class="Pp">To summarize the above layout, all PDOM objects inherit from the
    PPI::Element class.</p>
<p class="Pp">Under this are PPI::Token, strings of content with a known type,
    and PPI::Node, syntactically significant containers that hold other
    Elements.</p>
<p class="Pp">The three most important of these are the PPI::Document, the
    PPI::Statement and the PPI::Structure classes.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Document,_Statement_and_Structure"><a class="permalink" href="#The_Document,_Statement_and_Structure">The
  Document, Statement and Structure</a></h2>
<p class="Pp">At the top of all complete PDOM trees is a PPI::Document object.
    It represents a complete file of Perl source code as you might find it on
    disk.</p>
<p class="Pp">There are some specialised types of document, such as
    PPI::Document::File and PPI::Document::Normalized but for the purposes of
    the PDOM they are all just considered to be the same thing.</p>
<p class="Pp">Each Document will contain a number of <b>Statements</b>,
    <b>Structures</b> and <b>Tokens</b>.</p>
<p class="Pp">A PPI::Statement is any series of Tokens and Structures that are
    treated as a single contiguous statement by perl itself. You should note
    that a Statement is as close as PPI can get to &quot;parsing&quot; the code
    in the sense that perl-itself parses Perl code when it is building the
    op-tree.</p>
<p class="Pp">Because of the isolation and Perl's syntax, it is provably
    impossible for PPI to accurately determine precedence of operators or which
    tokens are implicit arguments to a sub call.</p>
<p class="Pp">So rather than lead you on with a bad guess that has a strong
    chance of being wrong, PPI does not attempt to determine precedence or sub
    parameters at all.</p>
<p class="Pp">At a fundamental level, it only knows that this series of elements
    represents a single Statement as perl sees it, but it can do so with enough
    certainty that it can be trusted.</p>
<p class="Pp">However, for specific Statement types the PDOM is able to derive
    additional useful information about their meaning. For the best, most
    useful, and most heavily used example, see PPI::Statement::Include.</p>
<p class="Pp">A PPI::Structure is any series of tokens contained within matching
    braces. This includes code blocks, conditions, function argument braces,
    anonymous array and hash constructors, lists, scoping braces and all other
    syntactic structures represented by a matching pair of braces, including
    (although it may not seem obvious at first)
    <span class="Li">&quot;&lt;READLINE&gt;&quot;</span> braces.</p>
<p class="Pp">Each Structure contains none, one, or many Tokens and Structures
    (the rules for which vary for the different Structure subclasses)</p>
<p class="Pp">Under the PDOM structure rules, a Statement can <b>never</b>
    directly contain another child Statement, a Structure can <b>never</b>
    directly contain another child Structure, and a Document can <b>never</b>
    contain another Document anywhere in the tree.</p>
<p class="Pp">Aside from these three rules, the PDOM tree is extremely
  flexible.</p>
</section>
<section class="Ss">
<h2 class="Ss">The PDOM at Work</h2>
<p class="Pp">To demonstrate the PDOM in use lets start with an example showing
    how the tree might look for the following chunk of simple Perl code.</p>
<p class="Pp"></p>
<pre>  #!/usr/bin/perl
  print( &quot;Hello World!&quot; );
  exit();
</pre>
<p class="Pp">Translated into a PDOM tree it would have the following structure
    (as shown via the included PPI::Dumper).</p>
<p class="Pp"></p>
<pre>  PPI::Document
    PPI::Token::Comment                '#!/usr/bin/perl\n'
    PPI::Token::Whitespace             '\n'
    PPI::Statement
      PPI::Token::Word                 'print'
      PPI::Structure::List             ( ... )
        PPI::Token::Whitespace         ' '
        PPI::Statement::Expression
          PPI::Token::Quote::Double    '&quot;Hello World!&quot;'
        PPI::Token::Whitespace         ' '
      PPI::Token::Structure            ';'
    PPI::Token::Whitespace             '\n'
    PPI::Token::Whitespace             '\n'
    PPI::Statement
      PPI::Token::Word                 'exit'
      PPI::Structure::List             ( ... )
      PPI::Token::Structure            ';'
    PPI::Token::Whitespace             '\n'
</pre>
<p class="Pp">Please note that in this example, strings are only listed for the
    <b>actual</b> PPI::Token that contains that string. Structures are listed
    with the type of brace characters they represent noted.</p>
<p class="Pp">The PPI::Dumper module can be used to generate similar trees
    yourself.</p>
<p class="Pp">We can make that PDOM dump a little easier to read if we strip out
    all the whitespace. Here it is again, sans the distracting whitespace
    tokens.</p>
<p class="Pp"></p>
<pre>  PPI::Document
    PPI::Token::Comment                '#!/usr/bin/perl\n'
    PPI::Statement
      PPI::Token::Word                 'print'
      PPI::Structure::List             ( ... )
        PPI::Statement::Expression
          PPI::Token::Quote::Double    '&quot;Hello World!&quot;'
      PPI::Token::Structure            ';'
    PPI::Statement
      PPI::Token::Word                 'exit'
      PPI::Structure::List             ( ... )
      PPI::Token::Structure            ';'
</pre>
<p class="Pp">As you can see, the tree can get fairly deep at time, especially
    when every isolated token in a bracket becomes its own statement. This is
    needed to allow anything inside the tree the ability to grow. It also makes
    the search and analysis algorithms much more flexible.</p>
<p class="Pp">Because of the depth and complexity of PDOM trees, a vast number
    of very easy to use methods have been added wherever possible to help people
    working with PDOM trees do normal tasks relatively quickly and
  efficiently.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Overview_of_the_Primary_Classes"><a class="permalink" href="#Overview_of_the_Primary_Classes">Overview
  of the Primary Classes</a></h2>
<p class="Pp">The main PPI classes, and links to their own documentation, are
    listed here in alphabetical order.</p>
<dl class="Bl-tag">
  <dt id="PPI::Document"><a class="permalink" href="#PPI::Document">PPI::Document</a></dt>
  <dd>The Document object, the root of the PDOM.</dd>
  <dt id="PPI::Document::Fragment"><a class="permalink" href="#PPI::Document::Fragment">PPI::Document::Fragment</a></dt>
  <dd>A cohesive fragment of a larger Document. Although not of any real current
      use, it is needed for use in certain internal tree manipulation
      algorithms.
    <p class="Pp">For example, doing things like cut/copy/paste etc. Very
        similar to a PPI::Document, but has some additional methods and does not
        represent a lexical scope boundary.</p>
    <p class="Pp">A document fragment is also non-serializable, and so cannot be
        written out to a file.</p>
  </dd>
  <dt id="PPI::Dumper"><a class="permalink" href="#PPI::Dumper">PPI::Dumper</a></dt>
  <dd>A simple class for dumping readable debugging versions of PDOM structures,
      such as in the demonstration above.</dd>
  <dt id="PPI::Element"><a class="permalink" href="#PPI::Element">PPI::Element</a></dt>
  <dd>The Element class is the abstract base class for all objects within the
      PDOM</dd>
  <dt id="PPI::Find"><a class="permalink" href="#PPI::Find">PPI::Find</a></dt>
  <dd>Implements an instantiable object form of a PDOM tree search.</dd>
  <dt id="PPI::Lexer"><a class="permalink" href="#PPI::Lexer">PPI::Lexer</a></dt>
  <dd>The PPI Lexer. Converts Token streams into PDOM trees.</dd>
  <dt id="PPI::Node"><a class="permalink" href="#PPI::Node">PPI::Node</a></dt>
  <dd>The Node object, the abstract base class for all PDOM objects that can
      contain other Elements, such as the Document, Statement and Structure
      objects.</dd>
  <dt id="PPI::Statement"><a class="permalink" href="#PPI::Statement">PPI::Statement</a></dt>
  <dd>The base class for all Perl statements. Generic &quot;evaluate for
      side-effects&quot; statements are of this actual type. Other more
      interesting statement types belong to one of its children.
    <p class="Pp">See its own documentation for a longer description and list of
        all of the different statement types and sub-classes.</p>
  </dd>
  <dt id="PPI::Structure"><a class="permalink" href="#PPI::Structure">PPI::Structure</a></dt>
  <dd>The abstract base class for all structures. A Structure is a language
      construct consisting of matching braces containing a set of other
      elements.
    <p class="Pp">See the PPI::Structure documentation for a description and
        list of all of the different structure types and sub-classes.</p>
  </dd>
  <dt id="PPI::Token"><a class="permalink" href="#PPI::Token">PPI::Token</a></dt>
  <dd>A token is the basic unit of content. At its most basic, a Token is just a
      string tagged with metadata (its class, and some additional flags in some
      cases).</dd>
  <dt id="PPI::Token::_QuoteEngine"><a class="permalink" href="#PPI::Token::_QuoteEngine">PPI::Token::_QuoteEngine</a></dt>
  <dd>The PPI::Token::Quote and PPI::Token::QuoteLike classes provide abstract
      base classes for the many and varied types of quote and quote-like things
      in Perl. However, much of the actual quote logic is implemented in a
      separate quote engine, based at PPI::Token::_QuoteEngine.
    <p class="Pp">Classes that inherit from PPI::Token::Quote,
        PPI::Token::QuoteLike and PPI::Token::Regexp are generally parsed only
        by the Quote Engine.</p>
  </dd>
  <dt id="PPI::Tokenizer"><a class="permalink" href="#PPI::Tokenizer">PPI::Tokenizer</a></dt>
  <dd>The PPI Tokenizer. One Tokenizer consumes a chunk of text and provides
      access to a stream of PPI::Token objects.
    <p class="Pp">The Tokenizer is very very complicated, to the point where
        even the author treads carefully when working with it.</p>
    <p class="Pp">Most of the complication is the result of optimizations which
        have tripled the tokenization speed, at the expense of maintainability.
        We cope with the spaghetti by heavily commenting everything.</p>
  </dd>
  <dt id="PPI::Transform"><a class="permalink" href="#PPI::Transform">PPI::Transform</a></dt>
  <dd>The Perl Document Transformation API. Provides a standard interface and
      abstract base class for objects and classes that manipulate
    Documents.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="INSTALLING"><a class="permalink" href="#INSTALLING">INSTALLING</a></h1>
<p class="Pp">The core PPI distribution is pure Perl and has been kept as tight
    as possible and with as few dependencies as possible.</p>
<p class="Pp">It should download and install normally on any platform from
    within the CPAN and CPANPLUS applications, or directly using the
    distribution tarball. If installing by hand, you may need to install a few
    small utility modules first. The exact ones will depend on your version of
    perl.</p>
<p class="Pp">There are no special install instructions for PPI, and the normal
    <span class="Li">&quot;Perl Makefile.PL&quot;</span>,
    <span class="Li">&quot;make&quot;</span>, <span class="Li">&quot;make
    test&quot;</span>, <span class="Li">&quot;make install&quot;</span>
    instructions apply.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXTENDING"><a class="permalink" href="#EXTENDING">EXTENDING</a></h1>
<p class="Pp">The PPI namespace itself is reserved for use by PPI itself. You
    are recommended to use the PPIx:: namespace for PPI-specific modifications
    or prototypes thereof, or Perl:: for modules which provide a general Perl
    language-related functions.</p>
<p class="Pp">If what you wish to implement looks like it fits into the PPIx::
    namespace, you should consider contacting the PPI maintainers on GitHub
    first, as what you want may already be in progress, or you may wish to
    consider contributing to PPI itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="TO_DO"><a class="permalink" href="#TO_DO">TO DO</a></h1>
<p class="Pp">- Many more analysis and utility methods for PDOM classes</p>
<p class="Pp">- Creation of a PPI::Tutorial document</p>
<p class="Pp">- Add many more key functions to PPI::XS</p>
<p class="Pp">- We can <b>always</b> write more and better unit tests</p>
<p class="Pp">- Complete the full implementation of -&gt;literal (1.200)</p>
<p class="Pp">- Full understanding of scoping (due 1.300)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
<p class="Pp">The most recent version of PPI is available at the following
    address.</p>
<p class="Pp">&lt;http://search.cpan.org/~mithaldu/PPI/&gt;</p>
<p class="Pp">PPI source is maintained in a GitHub repository at the following
    address.</p>
<p class="Pp">&lt;https://github.com/adamkennedy/PPI&gt;</p>
<p class="Pp">Contributions via GitHub pull request are welcome.</p>
<p class="Pp">Bug fixes in the form of pull requests or bug reports with new
    (failing) unit tests have the best chance of being addressed by busy
    maintainers, and are <b>strongly</b> encouraged.</p>
<p class="Pp">If you cannot provide a test or fix, or don't have time to do so,
    then regular bug reports are still accepted and appreciated via the GitHub
    bug tracker.</p>
<p class="Pp">&lt;https://github.com/adamkennedy/PPI/issues&gt;</p>
<p class="Pp">The <span class="Li">&quot;ppidump&quot;</span> utility that is
    part of the Perl::Critic distribution is a useful tool for demonstrating how
    PPI is parsing (or misparsing) small code snippets, and for providing
    information for bug reports.</p>
<p class="Pp">For other issues, questions, or commercial or media-related
    enquiries, contact the author.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Adam Kennedy &lt;adamk@cpan.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGMENTS"><a class="permalink" href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a></h1>
<p class="Pp">A huge thank you to Phase N Australia
    (&lt;http://phase-n.com/&gt;) for permitting the original open sourcing and
    release of this distribution from what was originally several thousand hours
    of commercial work.</p>
<p class="Pp">Another big thank you to The Perl Foundation
    (&lt;http://www.perlfoundation.org/&gt;) for funding for the final big
    refactoring and completion run.</p>
<p class="Pp">Also, to the various co-maintainers that have contributed both
    large and small with tests and patches and especially to those rare few who
    have deep-dived into the guts to (gasp) add a feature.</p>
<p class="Pp"></p>
<pre>  - Dan Brook       : PPIx::XPath, Acme::PerlML
  - Audrey Tang     : &quot;Line Noise&quot; Testing
  - Arjen Laarhoven : Three-element -&gt;location support
  - Elliot Shank    : Perl 5.10 support, five-element -&gt;location
</pre>
<p class="Pp">And finally, thanks to those brave ( and foolish :) ) souls
    willing to dive in and use, test drive and provide feedback on PPI before
    version 1.000, in some cases before it made it to beta quality, and still
    did extremely distasteful things (like eating 50 meg of RAM a second).</p>
<p class="Pp">I owe you all a beer. Corner me somewhere and collect at your
    convenience. If I missed someone who wasn't in my email history, thank you
    too :)</p>
<p class="Pp"></p>
<pre>  # In approximate order of appearance
  - Claes Jacobsson
  - Michael Schwern
  - Jeff T. Parsons
  - CPAN Author &quot;CHOCOLATEBOY&quot;
  - Robert Rotherberg
  - CPAN Author &quot;PODMASTER&quot;
  - Richard Soderberg
  - Nadim ibn Hamouda el Khemir
  - Graciliano M. P.
  - Leon Brocard
  - Jody Belka
  - Curtis Ovid
  - Yuval Kogman
  - Michael Schilli
  - Slaven Rezic
  - Lars Thegler
  - Tony Stubblebine
  - Tatsuhiko Miyagawa
  - CPAN Author &quot;CHROMATIC&quot;
  - Matisse Enzer
  - Roy Fulbright
  - Dan Brook
  - Johnny Lee
  - Johan Lindstrom
</pre>
<p class="Pp">And to single one person out, thanks go to Randal Schwartz who
    spent a great number of hours in IRC over a critical 6 month period
    explaining why Perl is impossibly unparsable and constantly shoving evil and
    ugly corner cases in my face. He remained a tireless devil's advocate, and
    without his support this project genuinely could never have been
  completed.</p>
<p class="Pp">So for my schooling in the Deep Magiks, you have my deepest
    gratitude Randal.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright 2001 - 2011 Adam Kennedy.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">The full text of the license can be found in the LICENSE file
    included with this module.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-07-09</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

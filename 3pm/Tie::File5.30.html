<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Tie::File(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Tie::File(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Tie::File(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Tie::File - Access the lines of a disk file via a Perl array</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
 # This file documents Tie::File version 0.98
 use Tie::File;

 tie @array, 'Tie::File', filename or die ...;

 $array[13] = 'blah';     # line 13 of the file is now 'blah'
 print $array[42];        # display line 42 of the file

 $n_recs = @array;        # how many records are in the file?
 $#array -= 2;            # chop two records off the end


 for (@array) {
   s/PERL/Perl/g;        # Replace PERL with Perl everywhere in the file
 }

 # These are just like regular push, pop, unshift, shift, and splice
 # Except that they modify the file in the way you would expect

 push @array, new recs...;
 my $r1 = pop @array;
 unshift @array, new recs...;
 my $r2 = shift @array;
 @old_recs = splice @array, 3, 7, new recs...;

 untie @array;            # all finished
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><span class="Li">&quot;Tie::File&quot;</span> represents a regular
    text file as a Perl array. Each element in the array corresponds to a record
    in the file. The first line of the file is element 0 of the array; the
    second line is element 1, and so on.</p>
<p class="Pp">The file is <i>not</i> loaded into memory, so this will work even
    for gigantic files.</p>
<p class="Pp">Changes to the array are reflected in the file immediately.</p>
<p class="Pp">Lazy people and beginners may now stop reading the manual.</p>
<section class="Ss">
<h2 class="Ss" id="_recsep_"><a class="permalink" href="#_recsep_">&quot;recsep&quot;</a></h2>
<p class="Pp">What is a 'record'? By default, the meaning is the same as for the
    <span class="Li">&quot;&lt;...&gt;&quot;</span> operator: It's a string
    terminated by <span class="Li">$/</span>, which is probably
    <span class="Li">&quot;\n&quot;</span>. (Minor exception: on DOS and Win32
    systems, a 'record' is a string terminated by
    <span class="Li">&quot;\r\n&quot;</span>.) You may change the definition of
    &quot;record&quot; by supplying the
    <span class="Li">&quot;recsep&quot;</span> option in the
    <span class="Li">&quot;tie&quot;</span> call:</p>
<p class="Pp"></p>
<pre>
        tie @array, 'Tie::File', $file, recsep =&gt; 'es';
</pre>
<p class="Pp">This says that records are delimited by the string
    <span class="Li">&quot;es&quot;</span>. If the file contained the following
    data:</p>
<p class="Pp"></p>
<pre>
        Curse these pesky flies!\n
</pre>
<p class="Pp">then the <span class="Li">@array</span> would appear to have four
    elements:</p>
<p class="Pp"></p>
<pre>
        &quot;Curse th&quot;
        &quot;e p&quot;
        &quot;ky fli&quot;
        &quot;!\n&quot;
</pre>
<p class="Pp">An undefined value is not permitted as a record separator. Perl's
    special &quot;paragraph mode&quot; semantics (a la <span class="Li">&quot;$/
    = &quot;&quot;&quot;</span>) are not emulated.</p>
<p class="Pp">Records read from the tied array do not have the record separator
    string on the end; this is to allow</p>
<p class="Pp"></p>
<pre>
        $array[17] .= &quot;extra&quot;;
</pre>
<p class="Pp">to work as expected.</p>
<p class="Pp">(See &quot;autochomp&quot;, below.) Records stored into the array
    will have the record separator string appended before they are written to
    the file, if they don't have one already. For example, if the record
    separator string is <span class="Li">&quot;\n&quot;</span>, then the
    following two lines do exactly the same thing:</p>
<p class="Pp"></p>
<pre>
        $array[17] = &quot;Cherry pie&quot;;
        $array[17] = &quot;Cherry pie\n&quot;;
</pre>
<p class="Pp">The result is that the contents of line 17 of the file will be
    replaced with &quot;Cherry pie&quot;; a newline character will separate line
    17 from line 18. This means that this code will do nothing:</p>
<p class="Pp"></p>
<pre>
        chomp $array[17];
</pre>
<p class="Pp">Because the <span class="Li">&quot;chomp&quot;</span>ed value will
    have the separator reattached when it is written back to the file. There is
    no way to create a file whose trailing record separator string is
  missing.</p>
<p class="Pp">Inserting records that <i>contain</i> the record separator string
    is not supported by this module. It will probably produce a reasonable
    result, but what this result will be may change in a future version. Use
    'splice' to insert records or to replace one record with several.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_autochomp_"><a class="permalink" href="#_autochomp_">&quot;autochomp&quot;</a></h2>
<p class="Pp">Normally, array elements have the record separator removed, so
    that if the file contains the text</p>
<p class="Pp"></p>
<pre>
        Gold
        Frankincense
        Myrrh
</pre>
<p class="Pp">the tied array will appear to contain
    <span class="Li">&quot;(&quot;Gold&quot;, &quot;Frankincense&quot;,</span>
    <span class="Li">&quot;Myrrh&quot;)&quot;</span>. If you set
    <span class="Li">&quot;autochomp&quot;</span> to a false value, the record
    separator will not be removed. If the file above was tied with</p>
<p class="Pp"></p>
<pre>
        tie @gifts, &quot;Tie::File&quot;, $gifts, autochomp =&gt; 0;
</pre>
<p class="Pp">then the array <span class="Li">@gifts</span> would appear to
    contain <span class="Li">&quot;(&quot;Gold\n&quot;,</span>
    <span class="Li">&quot;Frankincense\n&quot;,
    &quot;Myrrh\n&quot;)&quot;</span>, or (on Win32 systems)
    <span class="Li">&quot;(&quot;Gold\r\n&quot;,</span>
    <span class="Li">&quot;Frankincense\r\n&quot;,
    &quot;Myrrh\r\n&quot;)&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_mode_"><a class="permalink" href="#_mode_">&quot;mode&quot;</a></h2>
<p class="Pp">Normally, the specified file will be opened for read and write
    access, and will be created if it does not exist. (That is, the flags
    <span class="Li">&quot;O_RDWR | O_CREAT&quot;</span> are supplied in the
    <span class="Li">&quot;open&quot;</span> call.) If you want to change this,
    you may supply alternative flags in the
    <span class="Li">&quot;mode&quot;</span> option. See Fcntl for a listing of
    available flags. For example:</p>
<p class="Pp"></p>
<pre>
        # open the file if it exists, but fail if it does not exist
        use Fcntl 'O_RDWR';
        tie @array, 'Tie::File', $file, mode =&gt; O_RDWR;

        # create the file if it does not exist
        use Fcntl 'O_RDWR', 'O_CREAT';
        tie @array, 'Tie::File', $file, mode =&gt; O_RDWR | O_CREAT;

        # open an existing file in read-only mode
        use Fcntl 'O_RDONLY';
        tie @array, 'Tie::File', $file, mode =&gt; O_RDONLY;
</pre>
<p class="Pp">Opening the data file in write-only or append mode is not
    supported.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_memory_"><a class="permalink" href="#_memory_">&quot;memory&quot;</a></h2>
<p class="Pp">This is an upper limit on the amount of memory that
    <span class="Li">&quot;Tie::File&quot;</span> will consume at any time while
    managing the file. This is used for two things: managing the <i>read
    cache</i> and managing the <i>deferred write</i> <i>buffer</i>.</p>
<p class="Pp">Records read in from the file are cached, to avoid having to
    re-read them repeatedly. If you read the same record twice, the first time
    it will be stored in memory, and the second time it will be fetched from the
    <i>read cache</i>. The amount of data in the read cache will not exceed the
    value you specified for <span class="Li">&quot;memory&quot;</span>. If
    <span class="Li">&quot;Tie::File&quot;</span> wants to cache a new record,
    but the read cache is full, it will make room by expiring the least-recently
    visited records from the read cache.</p>
<p class="Pp">The default memory limit is 2Mib. You can adjust the maximum read
    cache size by supplying the <span class="Li">&quot;memory&quot;</span>
    option. The argument is the desired cache size, in bytes.</p>
<p class="Pp"></p>
<pre>
 # I have a lot of memory, so use a large cache to speed up access
 tie @array, 'Tie::File', $file, memory =&gt; 20_000_000;
</pre>
<p class="Pp">Setting the memory limit to 0 will inhibit caching; records will
    be fetched from disk every time you examine them.</p>
<p class="Pp">The <span class="Li">&quot;memory&quot;</span> value is not an
    absolute or exact limit on the memory used.
    <span class="Li">&quot;Tie::File&quot;</span> objects contains some
    structures besides the read cache and the deferred write buffer, whose sizes
    are not charged against <span class="Li">&quot;memory&quot;</span>.</p>
<p class="Pp">The cache itself consumes about 310 bytes per cached record, so if
    your file has many short records, you may want to decrease the cache memory
    limit, or else the cache overhead may exceed the size of the cached
  data.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_dw_size_"><a class="permalink" href="#_dw_size_">&quot;dw_size&quot;</a></h2>
<p class="Pp">(This is an advanced feature. Skip this section on first
  reading.)</p>
<p class="Pp">If you use deferred writing (See &quot;Deferred Writing&quot;,
    below) then data you write into the array will not be written directly to
    the file; instead, it will be saved in the <i>deferred write buffer</i> to
    be written out later. Data in the deferred write buffer is also charged
    against the memory limit you set with the
    <span class="Li">&quot;memory&quot;</span> option.</p>
<p class="Pp">You may set the <span class="Li">&quot;dw_size&quot;</span> option
    to limit the amount of data that can be saved in the deferred write buffer.
    This limit may not exceed the total memory limit. For example, if you set
    <span class="Li">&quot;dw_size&quot;</span> to 1000 and
    <span class="Li">&quot;memory&quot;</span> to 2500, that means that no more
    than 1000 bytes of deferred writes will be saved up. The space available for
    the read cache will vary, but it will always be at least 1500 bytes (if the
    deferred write buffer is full) and it could grow as large as 2500 bytes (if
    the deferred write buffer is empty.)</p>
<p class="Pp">If you don't specify a
    <span class="Li">&quot;dw_size&quot;</span>, it defaults to the entire
    memory limit.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Option_Format"><a class="permalink" href="#Option_Format">Option
  Format</a></h2>
<p class="Pp"><span class="Li">&quot;-mode&quot;</span> is a synonym for
    <span class="Li">&quot;mode&quot;</span>.
    <span class="Li">&quot;-recsep&quot;</span> is a synonym for
    <span class="Li">&quot;recsep&quot;</span>.
    <span class="Li">&quot;-memory&quot;</span> is a synonym for
    <span class="Li">&quot;memory&quot;</span>. You get the idea.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Public_Methods"><a class="permalink" href="#Public_Methods">Public
  Methods</a></h1>
<p class="Pp">The <span class="Li">&quot;tie&quot;</span> call returns an
    object, say <span class="Li">$o</span>. You may call</p>
<p class="Pp"></p>
<pre>
        $rec = $o-&gt;FETCH($n);
        $o-&gt;STORE($n, $rec);
</pre>
<p class="Pp">to fetch or store the record at line <span class="Li">$n</span>,
    respectively; similarly the other tied array methods. (See perltie for
    details.) You may also call the following methods on this object:</p>
<section class="Ss">
<h2 class="Ss" id="_flock_"><a class="permalink" href="#_flock_">&quot;flock&quot;</a></h2>
<pre>
        $o-&gt;flock(MODE)
</pre>
<p class="Pp">will lock the tied file. <span class="Li">&quot;MODE&quot;</span>
    has the same meaning as the second argument to the Perl built-in
    <span class="Li">&quot;flock&quot;</span> function; for example
    <span class="Li">&quot;LOCK_SH&quot;</span> or
    <span class="Li">&quot;LOCK_EX | LOCK_NB&quot;</span>. (These constants are
    provided by the <span class="Li">&quot;use Fcntl ':flock'&quot;</span>
    declaration.)</p>
<p class="Pp"><span class="Li">&quot;MODE&quot;</span> is optional; the default
    is <span class="Li">&quot;LOCK_EX&quot;</span>.</p>
<p class="Pp"><span class="Li">&quot;Tie::File&quot;</span> maintains an
    internal table of the byte offset of each record it has seen in the
  file.</p>
<p class="Pp">When you use <span class="Li">&quot;flock&quot;</span> to lock the
    file, <span class="Li">&quot;Tie::File&quot;</span> assumes that the read
    cache is no longer trustworthy, because another process might have modified
    the file since the last time it was read. Therefore, a successful call to
    <span class="Li">&quot;flock&quot;</span> discards the contents of the read
    cache and the internal record offset table.</p>
<p class="Pp"><span class="Li">&quot;Tie::File&quot;</span> promises that the
    following sequence of operations will be safe:</p>
<p class="Pp"></p>
<pre>
        my $o = tie @array, &quot;Tie::File&quot;, $filename;
        $o-&gt;flock;
</pre>
<p class="Pp">In particular, <span class="Li">&quot;Tie::File&quot;</span> will
    <i>not</i> read or write the file during the
    <span class="Li">&quot;tie&quot;</span> call. (Exception: Using
    <span class="Li">&quot;mode =&gt; O_TRUNC&quot;</span> will, of course,
    erase the file during the <span class="Li">&quot;tie&quot;</span> call. If
    you want to do this safely, then open the file without
    <span class="Li">&quot;O_TRUNC&quot;</span>, lock the file, and use
    <span class="Li">&quot;@array = ()&quot;</span>.)</p>
<p class="Pp">The best way to unlock a file is to discard the object and untie
    the array. It is probably unsafe to unlock the file without also untying it,
    because if you do, changes may remain unwritten inside the object. That is
    why there is no shortcut for unlocking. If you really want to unlock the
    file prematurely, you know what to do; if you don't know what to do, then
    don't do it.</p>
<p class="Pp">All the usual warnings about file locking apply here. In
    particular, note that file locking in Perl is <b>advisory</b>, which means
    that holding a lock will not prevent anyone else from reading, writing, or
    erasing the file; it only prevents them from getting another lock at the
    same time. Locks are analogous to green traffic lights: If you have a green
    light, that does not prevent the idiot coming the other way from plowing
    into you sideways; it merely guarantees to you that the idiot does not also
    have a green light at the same time.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_autochomp_~2"><a class="permalink" href="#_autochomp_~2">&quot;autochomp&quot;</a></h2>
<pre>
        my $old_value = $o-&gt;autochomp(0);    # disable autochomp option
        my $old_value = $o-&gt;autochomp(1);    #  enable autochomp option

        my $ac = $o-&gt;autochomp();   # recover current value
</pre>
<p class="Pp">See &quot;autochomp&quot;, above.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_defer_,__flush_,__discard_,_and__autodefer_"><a class="permalink" href="#_defer_,__flush_,__discard_,_and__autodefer_">&quot;defer&quot;,
  &quot;flush&quot;, &quot;discard&quot;, and &quot;autodefer&quot;</a></h2>
<p class="Pp">See &quot;Deferred Writing&quot;, below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_offset_"><a class="permalink" href="#_offset_">&quot;offset&quot;</a></h2>
<pre>
        $off = $o-&gt;offset($n);
</pre>
<p class="Pp">This method returns the byte offset of the start of the
    <span class="Li">$n</span>th record in the file. If there is no such record,
    it returns an undefined value.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Tying_to_an_already-opened_filehandle"><a class="permalink" href="#Tying_to_an_already-opened_filehandle">Tying
  to an already-opened filehandle</a></h1>
<p class="Pp">If <span class="Li">$fh</span> is a filehandle, such as is
    returned by <span class="Li">&quot;IO::File&quot;</span> or one of the other
    <span class="Li">&quot;IO&quot;</span> modules, you may use:</p>
<p class="Pp"></p>
<pre>
        tie @array, 'Tie::File', $fh, ...;
</pre>
<p class="Pp">Similarly if you opened that handle
    <span class="Li">&quot;FH&quot;</span> with regular
    <span class="Li">&quot;open&quot;</span> or
    <span class="Li">&quot;sysopen&quot;</span>, you may use:</p>
<p class="Pp"></p>
<pre>
        tie @array, 'Tie::File', \*FH, ...;
</pre>
<p class="Pp">Handles that were opened write-only won't work. Handles that were
    opened read-only will work as long as you don't try to modify the array.
    Handles must be attached to seekable sources of data---that means no pipes
    or sockets. If <span class="Li">&quot;Tie::File&quot;</span> can detect that
    you supplied a non-seekable handle, the
    <span class="Li">&quot;tie&quot;</span> call will throw an exception. (On
    Unix systems, it can detect this.)</p>
<p class="Pp">Note that Tie::File will only close any filehandles that it opened
    internally. If you passed it a filehandle as above, you &quot;own&quot; the
    filehandle, and are responsible for closing it after you have untied the
    <span class="Li">@array</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Deferred_Writing"><a class="permalink" href="#Deferred_Writing">Deferred
  Writing</a></h1>
<p class="Pp">(This is an advanced feature. Skip this section on first
  reading.)</p>
<p class="Pp">Normally, modifying a
    <span class="Li">&quot;Tie::File&quot;</span> array writes to the underlying
    file immediately. Every assignment like <span class="Li">&quot;$a[3] =
    ...&quot;</span> rewrites as much of the file as is necessary; typically,
    everything from line 3 through the end will need to be rewritten. This is
    the simplest and most transparent behavior. Performance even for large files
    is reasonably good.</p>
<p class="Pp">However, under some circumstances, this behavior may be
    excessively slow. For example, suppose you have a million-record file, and
    you want to do:</p>
<p class="Pp"></p>
<pre>
        for (@FILE) {
          $_ = &quot;&gt; $_&quot;;
        }
</pre>
<p class="Pp">The first time through the loop, you will rewrite the entire file,
    from line 0 through the end. The second time through the loop, you will
    rewrite the entire file from line 1 through the end. The third time through
    the loop, you will rewrite the entire file from line 2 to the end. And so
    on.</p>
<p class="Pp">If the performance in such cases is unacceptable, you may defer
    the actual writing, and then have it done all at once. The following loop
    will perform much better for large files:</p>
<p class="Pp"></p>
<pre>
        (tied @a)-&gt;defer;
        for (@a) {
          $_ = &quot;&gt; $_&quot;;
        }
        (tied @a)-&gt;flush;
</pre>
<p class="Pp">If <span class="Li">&quot;Tie::File&quot;</span>'s memory limit is
    large enough, all the writing will done in memory. Then, when you call
    <span class="Li">&quot;-&gt;flush&quot;</span>, the entire file will be
    rewritten in a single pass.</p>
<p class="Pp">(Actually, the preceding discussion is something of a fib. You
    don't need to enable deferred writing to get good performance for this
    common case, because <span class="Li">&quot;Tie::File&quot;</span> will do
    it for you automatically unless you specifically tell it not to. See
    &quot;Autodeferring&quot;, below.)</p>
<p class="Pp">Calling <span class="Li">&quot;-&gt;flush&quot;</span> returns the
    array to immediate-write mode. If you wish to discard the deferred writes,
    you may call <span class="Li">&quot;-&gt;discard&quot;</span> instead of
    <span class="Li">&quot;-&gt;flush&quot;</span>. Note that in some cases,
    some of the data will have been written already, and it will be too late for
    <span class="Li">&quot;-&gt;discard&quot;</span> to discard all the changes.
    Support for <span class="Li">&quot;-&gt;discard&quot;</span> may be
    withdrawn in a future version of
    <span class="Li">&quot;Tie::File&quot;</span>.</p>
<p class="Pp">Deferred writes are cached in memory up to the limit specified by
    the <span class="Li">&quot;dw_size&quot;</span> option (see above). If the
    deferred-write buffer is full and you try to write still more deferred data,
    the buffer will be flushed. All buffered data will be written immediately,
    the buffer will be emptied, and the now-empty space will be used for future
    deferred writes.</p>
<p class="Pp">If the deferred-write buffer isn't yet full, but the total size of
    the buffer and the read cache would exceed the
    <span class="Li">&quot;memory&quot;</span> limit, the oldest records will be
    expired from the read cache until the total size is under the limit.</p>
<p class="Pp"><span class="Li">&quot;push&quot;</span>,
    <span class="Li">&quot;pop&quot;</span>,
    <span class="Li">&quot;shift&quot;</span>,
    <span class="Li">&quot;unshift&quot;</span>, and
    <span class="Li">&quot;splice&quot;</span> cannot be deferred. When you
    perform one of these operations, any deferred data is written to the file
    and the operation is performed immediately. This may change in a future
    version.</p>
<p class="Pp">If you resize the array with deferred writing enabled, the file
    will be resized immediately, but deferred records will not be written. This
    has a surprising consequence: <span class="Li">&quot;@a = (...)&quot;</span>
    erases the file immediately, but the writing of the actual data is deferred.
    This might be a bug. If it is a bug, it will be fixed in a future
  version.</p>
<section class="Ss">
<h2 class="Ss" id="Autodeferring"><a class="permalink" href="#Autodeferring">Autodeferring</a></h2>
<p class="Pp"><span class="Li">&quot;Tie::File&quot;</span> tries to guess when
    deferred writing might be helpful, and to turn it on and off
  automatically.</p>
<p class="Pp"></p>
<pre>
        for (@a) {
          $_ = &quot;&gt; $_&quot;;
        }
</pre>
<p class="Pp">In this example, only the first two assignments will be done
    immediately; after this, all the changes to the file will be deferred up to
    the user-specified memory limit.</p>
<p class="Pp">You should usually be able to ignore this and just use the module
    without thinking about deferring. However, special applications may require
    fine control over which writes are deferred, or may require that all writes
    be immediate. To disable the autodeferment feature, use</p>
<p class="Pp"></p>
<pre>
        (tied @o)-&gt;autodefer(0);
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre>
        tie @array, 'Tie::File', $file, autodefer =&gt; 0;
</pre>
<p class="Pp">Similarly, <span class="Li">&quot;-&gt;autodefer(1)&quot;</span>
    re-enables autodeferment, and
    <span class="Li">&quot;-&gt;autodefer()&quot;</span> recovers the current
    value of the autodefer setting.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CONCURRENT_ACCESS_TO_FILES"><a class="permalink" href="#CONCURRENT_ACCESS_TO_FILES">CONCURRENT
  ACCESS TO FILES</a></h1>
<p class="Pp">Caching and deferred writing are inappropriate if you want the
    same file to be accessed simultaneously from more than one process. Other
    optimizations performed internally by this module are also incompatible with
    concurrent access. A future version of this module will support a
    <span class="Li">&quot;concurrent =&gt; 1&quot;</span> option that enables
    safe concurrent access.</p>
<p class="Pp">Previous versions of this documentation suggested using
    <span class="Li">&quot;memory</span> <span class="Li">=&gt; 0&quot;</span>
    for safe concurrent access. This was mistaken. Tie::File will not support
    safe concurrent access before version 0.96.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<p class="Pp">(That's Latin for 'warnings'.)</p>
<ul class="Bl-bullet">
  <li>Reasonable effort was made to make this module efficient. Nevertheless,
      changing the size of a record in the middle of a large file will always be
      fairly slow, because everything after the new record must be moved.</li>
  <li>The behavior of tied arrays is not precisely the same as for regular
      arrays. For example:
    <p class="Pp"></p>
    <pre>
        # This DOES print &quot;How unusual!&quot;
        undef $a[10];  print &quot;How unusual!\n&quot; if defined $a[10];
    </pre>
    <p class="Pp"><span class="Li">&quot;undef&quot;</span>-ing a
        <span class="Li">&quot;Tie::File&quot;</span> array element just blanks
        out the corresponding record in the file. When you read it back again,
        you'll get the empty string, so the
        supposedly-<span class="Li">&quot;undef&quot;</span>'ed value will be
        defined. Similarly, if you have
        <span class="Li">&quot;autochomp&quot;</span> disabled, then</p>
    <p class="Pp"></p>
    <pre>
        # This DOES print &quot;How unusual!&quot; if 'autochomp' is disabled
        undef $a[10];
        print &quot;How unusual!\n&quot; if $a[10];
    </pre>
    <p class="Pp">Because when <span class="Li">&quot;autochomp&quot;</span> is
        disabled, <span class="Li">$a[10]</span> will read back as
        <span class="Li">&quot;\n&quot;</span> (or whatever the record separator
        string is.)</p>
    <p class="Pp">There are other minor differences, particularly regarding
        <span class="Li">&quot;exists&quot;</span> and
        <span class="Li">&quot;delete&quot;</span>, but in general, the
        correspondence is extremely close.</p>
  </li>
  <li>I have supposed that since this module is concerned with file I/O, almost
      all normal use of it will be heavily I/O bound. This means that the time
      to maintain complicated data structures inside the module will be
      dominated by the time to actually perform the I/O. When there was an
      opportunity to spend CPU time to avoid doing I/O, I usually tried to take
      it.</li>
  <li>You might be tempted to think that deferred writing is like transactions,
      with <span class="Li">&quot;flush&quot;</span> as
      <span class="Li">&quot;commit&quot;</span> and
      <span class="Li">&quot;discard&quot;</span> as
      <span class="Li">&quot;rollback&quot;</span>, but it isn't, so don't.</li>
  <li>There is a large memory overhead for each record offset and for each cache
      entry: about 310 bytes per cached data record, and about 21 bytes per
      offset table entry.
    <p class="Pp">The per-record overhead will limit the maximum number of
        records you can access per file. Note that <i>accessing</i> the length
        of the array via <span class="Li">&quot;$x = scalar
        @tied_file&quot;</span> accesses <b>all</b> records and stores their
        offsets. The same for <span class="Li">&quot;foreach
        (@tied_file)&quot;</span>, even if you exit the loop early.</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="SUBCLASSING"><a class="permalink" href="#SUBCLASSING">SUBCLASSING</a></h1>
<p class="Pp">This version promises absolutely nothing about the internals,
    which may change without notice. A future version of the module will have a
    well-defined and stable subclassing API.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="WHAT_ABOUT__DB_File_?"><a class="permalink" href="#WHAT_ABOUT__DB_File_?">WHAT
  ABOUT &quot;DB_File&quot;?</a></h1>
<p class="Pp">People sometimes point out that DB_File will do something similar,
    and ask why <span class="Li">&quot;Tie::File&quot;</span> module is
    necessary.</p>
<p class="Pp">There are a number of reasons that you might prefer
    <span class="Li">&quot;Tie::File&quot;</span>. A list is available at
    <span class="Li">&quot;http://perl.plover.com/TieFile/why-not-DB_File&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Mark Jason Dominus</p>
<p class="Pp">To contact the author, send email to:
    <span class="Li">&quot;mjd-perl-tiefile+@plover.com&quot;</span></p>
<p class="Pp">To receive an announcement whenever a new version of this module
    is released, send a blank email message to
    <span class="Li">&quot;mjd-perl-tiefile-subscribe@plover.com&quot;</span>.</p>
<p class="Pp">The most recent version of this module, including documentation
    and any news of importance, will be available at</p>
<p class="Pp"></p>
<pre>
        http://perl.plover.com/TieFile/
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp"><span class="Li">&quot;Tie::File&quot;</span> version 0.96 is
    copyright (C) 2003 Mark Jason Dominus.</p>
<p class="Pp">This library is free software; you may redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">These terms are your choice of any of (1) the Perl Artistic
    Licence, or (2) version 2 of the GNU General Public License as published by
    the Free Software Foundation, or (3) any later version of the GNU General
    Public License.</p>
<p class="Pp">This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
    Public License for more details.</p>
<p class="Pp">You should have received a copy of the GNU General Public License
    along with this library program; it should be in the file
    <span class="Li">&quot;COPYING&quot;</span>. If not, write to the Free
    Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301, USA</p>
<p class="Pp">For licensing inquiries, contact the author at:</p>
<p class="Pp"></p>
<pre>
        Mark Jason Dominus
        255 S. Warnock St.
        Philadelphia, PA 19107
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="WARRANTY"><a class="permalink" href="#WARRANTY">WARRANTY</a></h1>
<p class="Pp"><span class="Li">&quot;Tie::File&quot;</span> version 0.98 comes
    with ABSOLUTELY NO WARRANTY. For details, see the license.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="THANKS"><a class="permalink" href="#THANKS">THANKS</a></h1>
<p class="Pp">Gigantic thanks to Jarkko Hietaniemi, for agreeing to put this in
    the core when I hadn't written it yet, and for generally being helpful,
    supportive, and competent. (Usually the rule is &quot;choose any one.&quot;)
    Also big thanks to Abhijit Menon-Sen for all of the same things.</p>
<p class="Pp">Special thanks to Craig Berry and Peter Prymmer (for VMS
    portability help), Randy Kobes (for Win32 portability help), Clinton Pierce
    and Autrijus Tang (for heroic eleventh-hour Win32 testing above and beyond
    the call of duty), Michael G Schwern (for testing advice), and the rest of
    the CPAN testers (for testing generally).</p>
<p class="Pp">Special thanks to Tels for suggesting several speed and memory
    optimizations.</p>
<p class="Pp">Additional thanks to: Edward Avis / Mattia Barbon / Tom
    Christiansen / Gerrit Haase / Gurusamy Sarathy / Jarkko Hietaniemi (again) /
    Nikola Knezevic / John Kominetz / Nick Ing-Simmons / Tassilo von Parseval /
    H. Dieter Pearcey / Slaven Rezic / Eric Roode / Peter Scott / Peter Somu /
    Autrijus Tang (again) / Tels (again) / Juerd Waalboer / Todd Rinaldo</p>
</section>
<section class="Sh">
<h1 class="Sh" id="TODO"><a class="permalink" href="#TODO">TODO</a></h1>
<p class="Pp">More tests. (Stuff I didn't think of yet.)</p>
<p class="Pp">Paragraph mode?</p>
<p class="Pp">Fixed-length mode. Leave-blanks mode.</p>
<p class="Pp">Maybe an autolocking mode?</p>
<p class="Pp">For many common uses of the module, the read cache is a liability.
    For example, a program that inserts a single record, or that scans the file
    once, will have a cache hit rate of zero. This suggests a major
    optimization: The cache should be initially disabled. Here's a hybrid
    approach: Initially, the cache is disabled, but the cache code maintains
    statistics about how high the hit rate would be *if* it were enabled. When
    it sees the hit rate get high enough, it enables itself. The STAT comments
    in this code are the beginning of an implementation of this.</p>
<p class="Pp">Record locking with <b>fcntl()</b>? Then the module might support
    an undo log and get real transactions. What a tour de force that would
  be.</p>
<p class="Pp">Keeping track of the highest cached record. This would allow
    reads-in-a-row to skip the cache lookup faster (if reading from 1..N with
    empty cache at start, the last cached value will be always N-1).</p>
<p class="Pp">More tests.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

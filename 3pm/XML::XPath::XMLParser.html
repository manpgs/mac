<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>XML::XPath::XMLParser(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">XML::XPath::XMLParser(3)</td>
    <td class="head-vol"><a href=".">User Contributed Perl Documentation</a></td>
    <td class="head-rtitle">XML::XPath::XMLParser(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">XML::XPath::XMLParser - The default XML parsing class that
    produces a node tree</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    my $parser = XML::XPath::XMLParser-&gt;new(
                filename =&gt; $self-&gt;get_filename,
                xml =&gt; $self-&gt;get_xml,
                ioref =&gt; $self-&gt;get_ioref,
                parser =&gt; $self-&gt;get_parser,
            );
    my $root_node = $parser-&gt;parse;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module generates a node tree for use as the context node for
    XPath processing. It aims to be a quick parser, nothing fancy, and yet has
    to store more information than most parsers. To achieve this I've used array
    refs everywhere - no hashes. I don't have any performance figures for the
    speedups achieved, so I make no apologies for anyone not used to using
    arrays instead of hashes. I think they make good sense here where we know
    the attributes of each type of node.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Node_Structure"><a class="permalink" href="#Node_Structure">Node
  Structure</a></h1>
<p class="Pp">All nodes have the same first 2 entries in the array: node_parent
    and node_pos. The type of the node is determined using the <b>ref()</b>
    function. The node_parent always contains an entry for the parent of the
    current node - except for the root node which has undef in there. And
    node_pos is the position of this node in the array that it is in (think:
    <span class="Li">$node</span> ==
    <span class="Li">$node</span>-&gt;[node_parent]-&gt;[node_children]-&gt;[$node-&gt;[node_pos]]
    )</p>
<p class="Pp">Nodes are structured as follows:</p>
<section class="Ss">
<h2 class="Ss" id="Root_Node"><a class="permalink" href="#Root_Node">Root
  Node</a></h2>
<p class="Pp">The root node is just an element node with no parent.</p>
<p class="Pp"></p>
<pre>    [
      undef, # node_parent - check for undef to identify root node
      undef, # node_pos
      undef, # node_prefix
      [ ... ], # node_children (see below)
    ]
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Element_Node"><a class="permalink" href="#Element_Node">Element
  Node</a></h2>
<pre>    [
      $parent, # node_parent
      &lt;position in current array&gt;, # node_pos
      'xxx', # node_prefix - namespace prefix on this element
      [ ... ], # node_children
      'yyy', # node_name - element tag name
      [ ... ], # node_attribs - attributes on this element
      [ ... ], # node_namespaces - namespaces currently in scope
    ]
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Attribute_Node"><a class="permalink" href="#Attribute_Node">Attribute
  Node</a></h2>
<pre>    [
      $parent, # node_parent - the element node
      &lt;position in current array&gt;, # node_pos
      'xxx', # node_prefix - namespace prefix on this element
      'href', # node_key - attribute name
      'ftp://ftp.com/', # node_value - value in the node
    ]
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Namespace_Nodes"><a class="permalink" href="#Namespace_Nodes">Namespace
  Nodes</a></h2>
<p class="Pp">Each element has an associated set of namespace nodes that are
    currently in scope. Each namespace node stores a prefix and the expanded
    name (retrieved from the xmlns:prefix=&quot;...&quot; attribute).</p>
<p class="Pp"></p>
<pre>    [
      $parent,
      &lt;pos&gt;,
      'a', # node_prefix - the namespace as it was written as a prefix
      'http://my.namespace.com', # node_expanded - the expanded name.
    ]
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Text_Nodes"><a class="permalink" href="#Text_Nodes">Text
  Nodes</a></h2>
<pre>    [
      $parent,
      &lt;pos&gt;,
      'This is some text' # node_text - the text in the node
    ]
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Comment_Nodes"><a class="permalink" href="#Comment_Nodes">Comment
  Nodes</a></h2>
<pre>    [
      $parent,
      &lt;pos&gt;,
      'This is a comment' # node_comment
    ]
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Processing_Instruction_Nodes"><a class="permalink" href="#Processing_Instruction_Nodes">Processing
  Instruction Nodes</a></h2>
<pre>    [
      $parent,
      &lt;pos&gt;,
      'target', # node_target
      'data', # node_data
    ]
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Usage"><a class="permalink" href="#Usage">Usage</a></h1>
<p class="Pp">If you feel the need to use this module outside of XML::XPath (for
    example you might use this module directly so that you can cache parsed
    trees), you can follow the following API:</p>
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
<p class="Pp">The new method takes either no parameters, or any of the following
    parameters:</p>
<p class="Pp"></p>
<pre>        filename
        xml
        parser
        ioref
</pre>
<p class="Pp">This uses the familiar hash syntax, so an example might be:</p>
<p class="Pp"></p>
<pre>    use XML::XPath::XMLParser;
    my $parser = XML::XPath::XMLParser-&gt;new(filename =&gt; 'example.xml');
</pre>
<p class="Pp">The parameters represent a filename, a string containing XML, an
    XML::Parser instance and an open filehandle ref respectively. You can also
    set or get all of these properties using the get_ and set_ functions that
    have the same name as the property: e.g. get_filename, set_ioref, etc.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="parse"><a class="permalink" href="#parse">parse</a></h2>
<p class="Pp">The parse method generally takes no parameters, however you are
    free to pass either an open filehandle reference or an XML string if you so
    require. The return value is a tree that XML::XPath can use. The parse
    method will die if there is an error in your XML, so be sure to use perl's
    exception handling mechanism (eval{};) if you want to avoid this.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="parsefile"><a class="permalink" href="#parsefile">parsefile</a></h2>
<p class="Pp">The parsefile method is identical to <b>parse()</b> except it
    expects a single parameter that is a string naming a file to open and parse.
    Again it returns a tree and also dies if there are XML errors.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTICES"><a class="permalink" href="#NOTICES">NOTICES</a></h1>
<p class="Pp">This file is distributed as part of the XML::XPath module, and is
    copyright 2000 Fastnet Software Ltd. Please see the documentation for the
    module as a whole for licencing information.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-10-11</td>
    <td class="foot-os"><a href="..">perl v5.34.0</a></td>
  </tr>
</table>
</body>
</html>

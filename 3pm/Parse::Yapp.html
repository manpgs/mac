<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Parse::Yapp(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Parse::Yapp(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Parse::Yapp(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Parse::Yapp - Perl extension for generating and using LALR
    parsers.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
  yapp -m MyParser grammar_file.yp

  ...

  use MyParser;

  $parser=new MyParser();
  $value=$parser-&gt;YYParse(yylex =&gt; \&amp;lexer_sub, yyerror =&gt; \&amp;error_sub);

  $nberr=$parser-&gt;YYNberr();

  $parser-&gt;YYData-&gt;{DATA}= [ 'Anything', 'You Want' ];

  $data=$parser-&gt;YYData-&gt;{DATA}[0];
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Parse::Yapp (Yet Another Perl Parser compiler) is a collection of
    modules that let you generate and use yacc like thread safe (reentrant)
    parsers with perl object oriented interface.</p>
<p class="Pp">The script yapp is a front-end to the Parse::Yapp module and let
    you easily create a Perl OO parser from an input grammar file.</p>
<section class="Ss">
<h2 class="Ss" id="The_Grammar_file"><a class="permalink" href="#The_Grammar_file">The
  Grammar file</a></h2>
<dl class="Bl-tag">
  <dt>&quot;Comments&quot;</dt>
  <dd>Through all your files, comments are either Perl style, introduced by
      <i>#</i> up to the end of line, or C style, enclosed between <i>/*</i> and
      <i>*/</i>.</dd>
  <dt>&quot;Tokens and string literals&quot;</dt>
  <dd>Through all the grammar files, two kind of symbols may appear:
      <i>Non-terminal</i> symbols, called also <i>left-hand-side</i> symbols,
      which are the names of your rules, and <i>Terminal</i> symbols, called
      also <i>Tokens</i>.
    <p class="Pp">Tokens are the symbols your lexer function will feed your
        parser with (see below). They are of two flavours: symbolic tokens and
        string literals.</p>
    <p class="Pp">Non-terminals and symbolic tokens share the same identifier
        syntax:</p>
    <p class="Pp"></p>
    <pre>
                [A-Za-z][A-Za-z0-9_]*
    </pre>
    <p class="Pp">String literals are enclosed in single quotes and can contain
        almost anything. They will be output to your parser file double-quoted,
        making any special character as such. '&quot;', '$' and '@' will be
        automatically quoted with '\', making their writing more natural. On the
        other hand, if you need a single quote inside your literal, just quote
        it with '\'.</p>
    <p class="Pp">You cannot have a literal <i>'error'</i> in your grammar as it
        would confuse the driver with the <i>error</i> token. Use a symbolic
        token instead. In case you inadvertently use it, this will produce a
        warning telling you you should have written it <i>error</i> and will
        treat it as if it were the <i>error</i> token, which is certainly NOT
        what you meant.</p>
  </dd>
  <dt>&quot;Grammar file syntax&quot;</dt>
  <dd>It is very close to yacc syntax (in fact, <i>Parse::Yapp</i> should
      compile a clean <i>yacc</i> grammar without any modification, whereas the
      opposite is not true).
    <p class="Pp">This file is divided in three sections, separated by
        <span class="Li">&quot;%%&quot;</span>:</p>
    <p class="Pp"></p>
    <pre>
        header section
        %%
        rules section
        %%
        footer section
    </pre>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="The"><a class="permalink" href="#The"><b>The Header Section</b>
    section may optionally contain:</a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>One or more code blocks enclosed inside
      <span class="Li">&quot;%{&quot;</span> and
      <span class="Li">&quot;%}&quot;</span> just like in yacc. They may contain
      any valid Perl code and will be copied verbatim at the very beginning of
      the parser module. They are not as useful as they are in yacc, but you can
      use them, for example, for global variable declarations, though you will
      notice later that such global variables can be avoided to make a reentrant
      parser module.</li>
  <li>Precedence declarations, introduced by <span class="Li">%left</span>,
      <span class="Li">%right</span> and <span class="Li">%nonassoc</span>
      specifying associativity, followed by the list of tokens or litterals
      having the same precedence and associativity. The precedence being the
      latter declared will be having the highest level. (see the yacc or bison
      manuals for a full explanation of how they work, as they are implemented
      exactly the same way in Parse::Yapp)</li>
  <li><span class="Li">%start</span> followed by a rule's left hand side,
      declaring this rule to be the starting rule of your grammar. The default,
      when <span class="Li">%start</span> is not used, is the first rule in your
      grammar section.</li>
  <li><span class="Li">%token</span> followed by a list of symbols, forcing them
      to be recognized as tokens, generating a syntax error if used in the left
      hand side of a rule declaration. Note that in Parse::Yapp, you
      <i>don't</i> need to declare tokens as in yacc: any symbol not appearing
      as a left hand side of a rule is considered to be a token. Other yacc
      declarations or constructs such as <span class="Li">%type</span> and
      <span class="Li">%union</span> are parsed but (almost) ignored.</li>
  <li><span class="Li">%expect</span> followed by a number, suppress warnings
      about number of Shift/Reduce conflicts when both numbers match, a la
      bison.</li>
</ul>
</div>
<div class="Bd-indent"></div>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="The~2"><a class="permalink" href="#The~2"><b>The Rule Section</b>
    contains your grammar rules:</a></dt>
  <dd>A rule is made of a left-hand-side symbol, followed by a
      <span class="Li">':'</span> and one or more right-hand-sides separated by
      <span class="Li">'|'</span> and terminated by a
      <span class="Li">';'</span>:
    <p class="Pp"></p>
    <pre>
    exp:    exp '+' exp
        |   exp '-' exp
        ;
    </pre>
    <p class="Pp">A right hand side may be empty:</p>
    <p class="Pp"></p>
    <pre>
    input:  #empty
        |   input line
        ;
    </pre>
    <p class="Pp">(if you have more than one empty rhs, Parse::Yapp will issue a
        warning, as this is usually a mistake, and you will certainly have a
        reduce/reduce conflict)</p>
    <p class="Pp">A rhs may be followed by an optional
        <span class="Li">%prec</span> directive, followed by a token, giving the
        rule an explicit precedence (see yacc manuals for its precise meaning)
        and optional semantic action code block (see below).</p>
    <p class="Pp"></p>
    <pre>
    exp:   '-' exp %prec NEG { -$_[1] }
        |  exp '+' exp       { $_[1] + $_[3] }
        |  NUM
        ;
    </pre>
    <p class="Pp">Note that in Parse::Yapp, a lhs <i>cannot</i> appear more than
        once as a rule name (This differs from yacc).</p>
  </dd>
  <dt>&quot;The footer section&quot;</dt>
  <dd>may contain any valid Perl code and will be appended at the very end of
      your parser module. Here you can write your lexer, error report subs and
      anything relevant to you parser.</dd>
  <dt>&quot;Semantic actions&quot;</dt>
  <dd>Semantic actions are run every time a <i>reduction</i> occurs in the
      parsing flow and they must return a semantic value.
    <p class="Pp">They are (usually, but see below <span class="Li">&quot;In
        rule actions&quot;</span>) written at the very end of the rhs, enclosed
        with <span class="Li">&quot;{ }&quot;</span>, and are copied verbatim to
        your parser file, inside of the rules table.</p>
    <p class="Pp">Be aware that matching braces in Perl is much more difficult
        than in C: inside strings they don't need to match. While in C it is
        very easy to detect the beginning of a string construct, or a single
        character, it is much more difficult in Perl, as there are so many ways
        of writing such literals. So there is no check for that today. If you
        need a brace in a double-quoted string, just quote it
        (<span class="Li">&quot;\{&quot;</span> or
        <span class="Li">&quot;\}&quot;</span>). For single-quoted strings, you
        will need to make a comment matching it <i>in th right order</i>. Sorry
        for the inconvenience.</p>
    <p class="Pp"></p>
    <pre>
    {
        &quot;{ My string block }&quot;.
        &quot;\{ My other string block \}&quot;.
        qq/ My unmatched brace \} /.
        # Force the match: {
        q/ for my closing brace } /
        q/ My opening brace { /
        # must be closed: }
    }
    </pre>
    <p class="Pp">All of these constructs should work.</p>
    <p class="Pp">In Parse::Yapp, semantic actions are called like normal Perl
        sub calls, with their arguments passed in <span class="Li">@_</span>,
        and their semantic value are their return values.</p>
    <p class="Pp"><span class="Li">$_</span>[1] to <span class="Li">$_</span>[n]
        are the parameters just as <span class="Li">$1</span> to
        <span class="Li">$n</span> in yacc, while <span class="Li">$_</span>[0]
        is the parser object itself.</p>
    <p class="Pp">Having <span class="Li">$_</span>[0] being the parser object
        itself allows you to call parser methods. That's how the yacc macros are
        implemented:</p>
    <p class="Pp"></p>
    <pre>
        yyerrok is done by calling $_[0]-&gt;YYErrok
        YYERROR is done by calling $_[0]-&gt;YYError
        YYACCEPT is done by calling $_[0]-&gt;YYAccept
        YYABORT is done by calling $_[0]-&gt;YYAbort
    </pre>
    <p class="Pp">All those methods explicitly return <i>undef</i>, for
        convenience.</p>
    <p class="Pp"></p>
    <pre>
    YYRECOVERING is done by calling $_[0]-&gt;YYRecovering
    </pre>
    <p class="Pp">Four useful methods in error recovery sub</p>
    <p class="Pp"></p>
    <pre>
    $_[0]-&gt;YYCurtok
    $_[0]-&gt;YYCurval
    $_[0]-&gt;YYExpect
    $_[0]-&gt;YYLexer
    </pre>
    <p class="Pp">return respectivly the current input token that made the parse
        fail, its semantic value (both can be used to modify their values too,
        but <i>know what you are doing</i> ! See <i>Error reporting routine</i>
        section for an example), a list which contains the tokens the parser
        expected when the failure occurred and a reference to the lexer
      routine.</p>
    <p class="Pp">Note that if
        <span class="Li">&quot;$_[0]-&gt;YYCurtok&quot;</span> is declared as a
        <span class="Li">%nonassoc</span> token, it can be included in
        <span class="Li">&quot;$_[0]-&gt;YYExpect&quot;</span> list whenever the
        input try to use it in an associative way. This is not a bug: the token
        IS expected to report an error if encountered.</p>
    <p class="Pp">To detect such a thing in your error reporting sub, the
        following example should do the trick:</p>
    <p class="Pp"></p>
    <pre>
        grep { $_[0]-&gt;YYCurtok eq $_ } $_[0]-&gt;YYExpect
    and do {
        #Non-associative token used in an associative expression
    };
    </pre>
    <p class="Pp">Accessing semantics values on the left of your reducing rule
        is done through the method</p>
    <p class="Pp"></p>
    <pre>
    $_[0]-&gt;YYSemval( index )
    </pre>
    <p class="Pp">where index is an integer. Its value being <i>1 .. n</i>
        returns the same values than <i></i><i>$_</i><i>[1] ..
        </i><i>$_</i><i>[n]</i>, but <i>-n .. 0</i> returns values on the left
        of the rule being reduced (It is related to <i>$-n .. </i><i>$0</i><i>
        .. </i><i>$n</i><i></i> in yacc, but you cannot use
        <i></i><i>$_</i><i>[0]</i> or <i></i><i>$_</i><i>[-n]</i> constructs in
        Parse::Yapp for obvious reasons)</p>
    <p class="Pp">There is also a provision for a user data area in the parser
        object, accessed by the method:</p>
    <p class="Pp"></p>
    <pre>
    $_[0]-&gt;YYData
    </pre>
    <p class="Pp">which returns a reference to an anonymous hash, which let you
        have all of your parsing data held inside the object (see the Calc.yp or
        ParseYapp.yp files in the distribution for some examples). That's how
        you can make you parser module reentrant: all of your module states and
        variables are held inside the parser object.</p>
    <p class="Pp">Note: unfortunately, method calls in Perl have a lot of
        overhead,
      <br/>
       and when YYData is used, it may be called a huge number
      <br/>
       of times. If your are not a *real* purist and efficiency
      <br/>
       is your concern, you may access directly the user-space
      <br/>
       in the object: <span class="Li">$parser</span>-&gt;{USER} wich is a
        reference to an
      <br/>
       anonymous hash array, and then benchmark.</p>
    <p class="Pp">If no action is specified for a rule, the equivalant of a
        default action is run, which returns the first parameter:</p>
    <p class="Pp"></p>
    <pre>
   { $_[1] }
    </pre>
  </dd>
  <dt>&quot;In rule actions&quot;</dt>
  <dd>It is also possible to embed semantic actions inside of a rule:
    <p class="Pp"></p>
    <pre>
    typedef:    TYPE { $type = $_[1] } identlist { ... } ;
    </pre>
    <p class="Pp">When the Parse::Yapp's parser encounter such an embedded
        action, it modifies the grammar as if you wrote (although
        <span class="Li">@x</span>-1 is not a legal lhs value):</p>
    <p class="Pp"></p>
    <pre>
    @x-1:   /* empty */ { $type = $_[1] };
    typedef:    TYPE @x-1 identlist { ... } ;
    </pre>
    <p class="Pp">where <i>x</i> is a sequential number incremented for each
        &quot;in rule&quot; action, and <i>-1</i> represents the &quot;dot
        position&quot; in the rule where the action arises.</p>
    <p class="Pp">In such actions, you can use <i></i><i>$_</i><i>[1]..$_[n]</i>
        variables, which are the semantic values on the left of your action.</p>
    <p class="Pp">Be aware that the way Parse::Yapp modifies your grammar
        because of <i>in rule actions</i> can produce, in some cases, spurious
        conflicts that wouldn't happen otherwise.</p>
  </dd>
  <dt>&quot;Generating the Parser Module&quot;</dt>
  <dd>Now that you grammar file is written, you can use yapp on it to generate
      your parser module:
    <p class="Pp"></p>
    <pre>
    yapp -v Calc.yp
    </pre>
    <p class="Pp">will create two files <i>Calc.pm</i>, your parser module, and
        <i>Calc.output</i> a verbose output of your parser rules, conflicts,
        warnings, states and summary.</p>
    <p class="Pp">What your are missing now is a lexer routine.</p>
  </dd>
  <dt>&quot;The Lexer sub&quot;</dt>
  <dd>is called each time the parser need to read the next token.
    <p class="Pp">It is called with only one argument that is the parser object
        itself, so you can access its methods, specially the</p>
    <p class="Pp"></p>
    <pre>
    $_[0]-&gt;YYData
    </pre>
    <p class="Pp">data area.</p>
    <p class="Pp">It is its duty to return the next token and value to the
        parser. They <span class="Li">&quot;must&quot;</span> be returned as a
        list of two variables, the first one is the token known by the parser
        (symbolic or literal), the second one being anything you want (usually
        the content of the token, or the literal value) from a simple scalar
        value to any complex reference, as the parsing driver never use it but
        to call semantic actions:</p>
    <p class="Pp"></p>
    <pre>
    ( 'NUMBER', $num )
or
    ( '&gt;=', '&gt;=' )
or
    ( 'ARRAY', [ @values ] )
    </pre>
    <p class="Pp">When the lexer reach the end of input, it must return the
        <span class="Li">''</span> empty token with an undef value:</p>
    <p class="Pp"></p>
    <pre>
     ( '', undef )
    </pre>
    <p class="Pp">Note that your lexer should <i>never</i> return
        <span class="Li">'error'</span> as token value: for the driver, this is
        the error token used for error recovery and would lead to odd
      reactions.</p>
    <p class="Pp">Now that you have your lexer written, maybe you will need to
        output meaningful error messages, instead of the default which is to
        print 'Parse error.' on STDERR.</p>
    <p class="Pp">So you will need an Error reporting sub.</p>
  </dd>
  <dt>&quot;Error reporting routine&quot;</dt>
  <dd>If you want one, write it knowing that it is passed as parameter the
      parser object. So you can share information with the lexer routine quite
      easily.
    <p class="Pp">You can also use the
        <span class="Li">&quot;$_[0]-&gt;YYErrok&quot;</span> method in it,
        which will resume parsing as if no error occurred. Of course, since the
        invalid token is still invalid, you're supposed to fix the problem by
        yourself.</p>
    <p class="Pp">The method
        <span class="Li">&quot;$_[0]-&gt;YYLexer&quot;</span> may help you, as
        it returns a reference to the lexer routine, and can be called as</p>
    <p class="Pp"></p>
    <pre>
    ($tok,$val)=&amp;{$_[0]-&gt;Lexer}
    </pre>
    <p class="Pp">to get the next token and semantic value from the input
        stream. To make them current for the parser, use:</p>
    <p class="Pp"></p>
    <pre>
    ($_[0]-&gt;YYCurtok, $_[0]-&gt;YYCurval) = ($tok, $val)
    </pre>
    <p class="Pp">and know what you're doing...</p>
  </dd>
  <dt>&quot;Parsing&quot;</dt>
  <dd>Now you've got everything to do the parsing.
    <p class="Pp">First, use the parser module:</p>
    <p class="Pp"></p>
    <pre>
    use Calc;
    </pre>
    <p class="Pp">Then create the parser object:</p>
    <p class="Pp"></p>
    <pre>
    $parser=new Calc;
    </pre>
    <p class="Pp">Now, call the YYParse method, telling it where to find the
        lexer and error report subs:</p>
    <p class="Pp"></p>
    <pre>
    $result=$parser-&gt;YYParse(yylex =&gt; \&amp;Lexer,
                           yyerror =&gt; \&amp;ErrorReport);
    </pre>
    <p class="Pp">(assuming Lexer and ErrorReport subs have been written in your
        current package)</p>
    <p class="Pp">The order in which parameters appear is unimportant.</p>
    <p class="Pp">Et voila.</p>
    <p class="Pp">The YYParse method will do the parse, then return the last
        semantic value returned, or undef if error recovery cannot recover.</p>
    <p class="Pp">If you need to be sure the parse has been successful (in case
        your last returned semantic value <i>is</i> undef) make a call to:</p>
    <p class="Pp"></p>
    <pre>
    $parser-&gt;YYNberr()
    </pre>
    <p class="Pp">which returns the total number of time the error reporting sub
        has been called.</p>
  </dd>
  <dt>&quot;Error Recovery&quot;</dt>
  <dd>in Parse::Yapp is implemented the same way it is in yacc.</dd>
  <dt>&quot;Debugging Parser&quot;</dt>
  <dd>To debug your parser, you can call the YYParse method with a debug
      parameter:
    <p class="Pp"></p>
    <pre>
    $parser-&gt;YYParse( ... , yydebug =&gt; value, ... )
    </pre>
    <p class="Pp">where value is a bitfield, each bit representing a specific
        debug output:</p>
    <p class="Pp"></p>
    <pre>
    Bit Value    Outputs
    0x01         Token reading (useful for Lexer debugging)
    0x02         States information
    0x04         Driver actions (shifts, reduces, accept...)
    0x08         Parse Stack dump
    0x10         Error Recovery tracing
    </pre>
    <p class="Pp">To have a full debugging output, use</p>
    <p class="Pp"></p>
    <pre>
    debug =&gt; 0x1F
    </pre>
    <p class="Pp">Debugging output is sent to STDERR, and be aware that it can
        produce <span class="Li">&quot;huge&quot;</span> outputs.</p>
  </dd>
  <dt>&quot;Standalone Parsers&quot;</dt>
  <dd>By default, the parser modules generated will need the Parse::Yapp module
      installed on the system to run. They use the Parse::Yapp::Driver which can
      be safely shared between parsers in the same script.
    <p class="Pp">In the case you'd prefer to have a standalone module
        generated, use the <span class="Li">&quot;-s&quot;</span> switch with
        yapp: this will automagically copy the driver code into your module so
        you can use/distribute it without the need of the Parse::Yapp module,
        making it really a <span class="Li">&quot;Standalone
        Parser&quot;</span>.</p>
    <p class="Pp">If you do so, please remember to include Parse::Yapp's
        copyright notice in your main module copyright, so others can know about
        Parse::Yapp module.</p>
  </dd>
  <dt>&quot;Source file line numbers&quot;</dt>
  <dd>by default will be included in the generated parser module, which will
      help to find the guilty line in your source file in case of a syntax
      error. You can disable this feature by compiling your grammar with yapp
      using the <span class="Li">&quot;-n&quot;</span> switch.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS_AND_SUGGESTIONS"><a class="permalink" href="#BUGS_AND_SUGGESTIONS">BUGS
  AND SUGGESTIONS</a></h1>
<p class="Pp">If you find bugs, think of anything that could improve Parse::Yapp
    or have any questions related to it, feel free to contact the author.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">William N. Braswell, Jr.
    &lt;wbraswell_cpan@NOSPAM.nym.hush.com&gt; (Remove &quot;NOSPAM&quot;.)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>yapp</b>(1) <b>perl</b>(1) <b>yacc</b>(1) <b>bison</b>(1).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">The Parse::Yapp module and its related modules and shell scripts
    are copyright: Copyright &#x00A9; 1998, 1999, 2000, 2001, Francois
    Desarmenien. Copyright &#x00A9; 2017 William N. Braswell, Jr.</p>
<p class="Pp">You may use and distribute them under the terms of either the GNU
    General Public License or the Artistic License, as specified in the Perl
    README file.</p>
<p class="Pp">If you use the &quot;standalone parser&quot; option so people
    don't need to install Parse::Yapp on their systems in order to run you
    software, this copyright noticed should be included in your software
    copyright too, and the copyright notice in the embedded driver should be
    left untouched.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-08-04</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Convert::BinHex(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Convert::BinHex(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Convert::BinHex(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Convert::BinHex - extract data from Macintosh BinHex files</p>
<p class="Pp">ALPHA WARNING: this code is currently in its Alpha release. Things
    may change drastically until the interface is hammered out: if you have
    suggestions or objections, please speak up now!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp"><b>Simple functions:</b></p>
<p class="Pp"></p>
<pre>    use Convert::BinHex qw(binhex_crc macbinary_crc);
    # Compute HQX7-style CRC for data, pumping in old CRC if desired:
    $crc = binhex_crc($data, $crc);
    # Compute the MacBinary-II-style CRC for the data:
    $crc = macbinary_crc($data, $crc);
</pre>
<p class="Pp"><b>Hex to bin, low-level interface.</b> Conversion is actually
    done via an object (&quot;Convert::BinHex::Hex2Bin&quot;) which keeps
    internal conversion state:</p>
<p class="Pp"></p>
<pre>    # Create and use a &quot;translator&quot; object:
    my $H2B = Convert::BinHex-&gt;hex2bin;    # get a converter object
    while (&lt;STDIN&gt;) {
        print $STDOUT $H2B-&gt;next($_);        # convert some more input
    }
    print $STDOUT $H2B-&gt;done;              # no more input: finish up
</pre>
<p class="Pp"><b>Hex to bin, OO interface.</b> The following operations
    <i>must</i> be done in the order shown!</p>
<p class="Pp"></p>
<pre>    # Read data in piecemeal:
    $HQX = Convert::BinHex-&gt;open(FH=&gt;\*STDIN) || die &quot;open: $!&quot;;
    $HQX-&gt;read_header;                  # read header info
    @data = $HQX-&gt;read_data;            # read in all the data
    @rsrc = $HQX-&gt;read_resource;        # read in all the resource
</pre>
<p class="Pp"><b>Bin to hex, low-level interface.</b> Conversion is actually
    done via an object (&quot;Convert::BinHex::Bin2Hex&quot;) which keeps
    internal conversion state:</p>
<p class="Pp"></p>
<pre>    # Create and use a &quot;translator&quot; object:
    my $B2H = Convert::BinHex-&gt;bin2hex;    # get a converter object
    while (&lt;STDIN&gt;) {
        print $STDOUT $B2H-&gt;next($_);        # convert some more input
    }
    print $STDOUT $B2H-&gt;done;              # no more input: finish up
</pre>
<p class="Pp"><b>Bin to hex, file interface.</b> Yes, you can convert <i>to</i>
    BinHex as well as from it!</p>
<p class="Pp"></p>
<pre>    # Create new, empty object:
    my $HQX = Convert::BinHex-&gt;new;
    # Set header attributes:
    $HQX-&gt;filename(&quot;logo.gif&quot;);
    $HQX-&gt;type(&quot;GIFA&quot;);
    $HQX-&gt;creator(&quot;CNVS&quot;);
    # Give it the data and resource forks (either can be absent):
    $HQX-&gt;data(Path =&gt; &quot;/path/to/data&quot;);       # here, data is on disk
    $HQX-&gt;resource(Data =&gt; $resourcefork);     # here, resource is in core
    # Output as a BinHex stream, complete with leading comment:
    $HQX-&gt;encode(\*STDOUT);
</pre>
<p class="Pp"><b>PLANNED!!!! Bin to hex, &quot;CAP&quot; interface.</b>
    <i>Thanks to Ken Lunde for suggesting this</i>.</p>
<p class="Pp"></p>
<pre>    # Create new, empty object from CAP tree:
    my $HQX = Convert::BinHex-&gt;from_cap(&quot;/path/to/root/file&quot;);
    $HQX-&gt;encode(\*STDOUT);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><b>BinHex</b> is a format used by Macintosh for transporting Mac
    files safely through electronic mail, as short-lined, 7-bit, semi-compressed
    data streams. Ths module provides a means of converting those data streams
    back into into binary data.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FORMAT"><a class="permalink" href="#FORMAT">FORMAT</a></h1>
<p class="Pp"><i>(Some text taken from RFC-1741.)</i> Files on the Macintosh
    consist of two parts, called <i>forks</i>:</p>
<dl class="Bl-tag">
  <dt>Data fork</dt>
  <dd>The actual data included in the file. The Data fork is typically the only
      meaningful part of a Macintosh file on a non-Macintosh computer system.
      For example, if a Macintosh user wants to send a file of data to a user on
      an IBM-PC, she would only send the Data fork.</dd>
  <dt id="Resource"><a class="permalink" href="#Resource">Resource fork</a></dt>
  <dd>Contains a collection of arbitrary attribute/value pairs, including
      program segments, icon bitmaps, and parametric values.</dd>
</dl>
<p class="Pp">Additional information regarding Macintosh files is stored by the
    Finder in a hidden file, called the &quot;Desktop Database&quot;.</p>
<p class="Pp">Because of the complications in storing different parts of a
    Macintosh file in a non-Macintosh filesystem that only handles consecutive
    data in one part, it is common to convert the Macintosh file into some other
    format before transferring it over the network. The BinHex format squashes
    that data into transmittable ASCII as follows:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>The file is output as a <b>byte stream</b> consisting of some basic header
      information (filename, type, creator), then the data fork, then the
      resource fork.</dd>
  <dt>2.</dt>
  <dd>The byte stream is <b>compressed</b> by looking for series of duplicated
      bytes and representing them using a special binary escape sequence (of
      course, any occurences of the escape character must also be escaped).</dd>
  <dt>3.</dt>
  <dd>The compressed stream is <b>encoded</b> via the &quot;6/8 hemiola&quot;
      common to <i>base64</i> and <i>uuencode</i>: each group of three 8-bit
      bytes (24 bits) is chopped into four 6-bit numbers, which are used as
      indexes into an ASCII &quot;alphabet&quot;. (I assume that leftover bytes
      are zero-padded; documentation is thin).</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTIONS"><a class="permalink" href="#FUNCTIONS">FUNCTIONS</a></h1>
<section class="Ss">
<h2 class="Ss">CRC computation</h2>
<dl class="Bl-tag">
  <dt id="macbinary_crc"><a class="permalink" href="#macbinary_crc">macbinary_crc
    DATA, SEED</a></dt>
  <dd>Compute the MacBinary-II-style CRC for the given DATA, with the CRC seeded
      to SEED. Normally, you start with a SEED of 0, and you pump in the
      previous CRC as the SEED if you're handling a lot of data one chunk at a
      time. That is:
    <p class="Pp"></p>
    <pre>    $crc = 0;
    while (&lt;STDIN&gt;) {
        $crc = macbinary_crc($_, $crc);
    }
    </pre>
    <p class="Pp"><i>Note:</i> Extracted from the <i>mcvert</i> utility (Doug
        Moore, April '87), using a &quot;magic array&quot; algorithm by Jim Van
        Verth for efficiency. Converted to Perl5 by Eryq. <b>Untested.</b></p>
  </dd>
  <dt id="binhex_crc"><a class="permalink" href="#binhex_crc">binhex_crc DATA,
    SEED</a></dt>
  <dd>Compute the HQX-style CRC for the given DATA, with the CRC seeded to SEED.
      Normally, you start with a SEED of 0, and you pump in the previous CRC as
      the SEED if you're handling a lot of data one chunk at a time. That is:
    <p class="Pp"></p>
    <pre>    $crc = 0;
    while (&lt;STDIN&gt;) {
        $crc = binhex_crc($_, $crc);
    }
    </pre>
    <p class="Pp"><i>Note:</i> Extracted from the <i>mcvert</i> utility (Doug
        Moore, April '87), using a &quot;magic array&quot; algorithm by Jim Van
        Verth for efficiency. Converted to Perl5 by Eryq.</p>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="OO_INTERFACE"><a class="permalink" href="#OO_INTERFACE">OO
  INTERFACE</a></h1>
<section class="Ss">
<h2 class="Ss" id="Conversion"><a class="permalink" href="#Conversion">Conversion</a></h2>
<dl class="Bl-tag">
  <dt id="bin2hex"><a class="permalink" href="#bin2hex">bin2hex</a></dt>
  <dd><i>Class method, constructor.</i> Return a converter object. Just creates
      a new instance of &quot;Convert::BinHex::Bin2Hex&quot;; see that class for
      details.</dd>
  <dt id="hex2bin"><a class="permalink" href="#hex2bin">hex2bin</a></dt>
  <dd><i>Class method, constructor.</i> Return a converter object. Just creates
      a new instance of &quot;Convert::BinHex::Hex2Bin&quot;; see that class for
      details.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Construction"><a class="permalink" href="#Construction">Construction</a></h2>
<dl class="Bl-tag">
  <dt id="new"><a class="permalink" href="#new">new PARAMHASH</a></dt>
  <dd><i>Class method, constructor.</i> Return a handle on a BinHex'able entity.
      In general, the data and resource forks for such an entity are stored in
      native format (binary) format.
    <p class="Pp">Parameters in the PARAMHASH are the same as header-oriented
        method names, and may be used to set attributes:</p>
    <p class="Pp"></p>
    <pre>    $HQX = new Convert::BinHex filename =&gt; &quot;icon.gif&quot;,
                               type    =&gt; &quot;GIFB&quot;,
                               creator =&gt; &quot;CNVS&quot;;
    </pre>
  </dd>
  <dt id="open"><a class="permalink" href="#open">open PARAMHASH</a></dt>
  <dd><i>Class method, constructor.</i> Return a handle on a new BinHex'ed
      stream, for parsing. Params are:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Data"><a class="permalink" href="#Data">Data</a></dt>
  <dd>Input a HEX stream from the given data. This can be a scalar, or a
      reference to an array of scalars.</dd>
  <dt id="Expr"><a class="permalink" href="#Expr">Expr</a></dt>
  <dd>Input a HEX stream from any <b>open()</b>able expression. It will be
      opened and binmode'd, and the filehandle will be closed either on a
      <span class="Li">&quot;close()&quot;</span> or when the object is
      destructed.</dd>
  <dt id="FH"><a class="permalink" href="#FH">FH</a></dt>
  <dd>Input a HEX stream from the given filehandle.</dd>
  <dt id="NoComment"><a class="permalink" href="#NoComment">NoComment</a></dt>
  <dd>If true, the parser should not attempt to skip a leading &quot;(This
      file...)&quot; comment. That means that the first nonwhite characters
      encountered must be the binhex'ed data.</dd>
</dl>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Ss">
<h2 class="Ss" id="Get/set_header_information"><a class="permalink" href="#Get/set_header_information">Get/set
  header information</a></h2>
<dl class="Bl-tag">
  <dt id="creator"><a class="permalink" href="#creator">creator [VALUE]</a></dt>
  <dd><i>Instance method.</i> Get/set the creator of the file. This is a
      four-character string (though I don't know if it's guaranteed to be
      printable ASCII!) that serves as part of the Macintosh's version of a MIME
      &quot;content-type&quot;.
    <p class="Pp">For example, a document created by &quot;Canvas&quot; might
        have creator <span class="Li">&quot;CNVS&quot;</span>.</p>
  </dd>
  <dt id="data"><a class="permalink" href="#data">data [PARAMHASH]</a></dt>
  <dd><i>Instance method.</i> Get/set the data fork. Any arguments are passed
      into the <b>new()</b> method of &quot;Convert::BinHex::Fork&quot;.</dd>
  <dt id="filename"><a class="permalink" href="#filename">filename
    [VALUE]</a></dt>
  <dd><i>Instance method.</i> Get/set the name of the file.</dd>
  <dt id="flags"><a class="permalink" href="#flags">flags [VALUE]</a></dt>
  <dd><i>Instance method.</i> Return the flags, as an integer. Use bitmasking to
      get as the values you need.</dd>
  <dt id="header_as_string"><a class="permalink" href="#header_as_string">header_as_string</a></dt>
  <dd>Return a stringified version of the header that you might use for
      logging/debugging purposes. It looks like this:
    <p class="Pp"></p>
    <pre>    X-HQX-Software: BinHex 4.0 (Convert::BinHex 1.102)
    X-HQX-Filename: Something_new.eps
    X-HQX-Version: 0
    X-HQX-Type: EPSF
    X-HQX-Creator: ART5
    X-HQX-Data-Length: 49731
    X-HQX-Rsrc-Length: 23096
    </pre>
    <p class="Pp">As some of you might have guessed, this is RFC-822-style, and
        may be easily plunked down into the middle of a mail header, or split
        into lines, etc.</p>
  </dd>
  <dt id="requires"><a class="permalink" href="#requires">requires
    [VALUE]</a></dt>
  <dd><i>Instance method.</i> Get/set the software version required to convert
      this file, as extracted from the comment that preceded the actual
      binhex'ed data; e.g.:
    <p class="Pp"></p>
    <pre>    (This file must be converted with BinHex 4.0)
    </pre>
    <p class="Pp">In this case, after parsing in the comment, the code:</p>
    <p class="Pp"></p>
    <pre>    $HQX-&gt;requires;
    </pre>
    <p class="Pp">would get back &quot;4.0&quot;.</p>
  </dd>
  <dt id="resource"><a class="permalink" href="#resource">resource
    [PARAMHASH]</a></dt>
  <dd><i>Instance method.</i> Get/set the resource fork. Any arguments are
      passed into the <b>new()</b> method of
    &quot;Convert::BinHex::Fork&quot;.</dd>
  <dt id="type"><a class="permalink" href="#type">type [VALUE]</a></dt>
  <dd><i>Instance method.</i> Get/set the type of the file. This is a
      four-character string (though I don't know if it's guaranteed to be
      printable ASCII!) that serves as part of the Macintosh's version of a MIME
      &quot;content-type&quot;.
    <p class="Pp">For example, a GIF89a file might have type
        <span class="Li">&quot;GF89&quot;</span>.</p>
  </dd>
  <dt id="version"><a class="permalink" href="#version">version [VALUE]</a></dt>
  <dd><i>Instance method.</i> Get/set the version, as an integer.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Decode,_high-level"><a class="permalink" href="#Decode,_high-level">Decode,
  high-level</a></h2>
<dl class="Bl-tag">
  <dt id="read_comment"><a class="permalink" href="#read_comment">read_comment</a></dt>
  <dd><i>Instance method.</i> Skip past the opening comment in the file, which
      is of the form:
    <p class="Pp"></p>
    <pre>   (This file must be converted with BinHex 4.0)
    </pre>
    <p class="Pp">As per RFC-1741, <i>this comment must immediately precede the
        BinHex data,</i> and any text before it will be ignored.</p>
    <p class="Pp"><i>You don't need to invoke this method yourself;</i>
        <span class="Li">&quot;read_header()&quot;</span> will do it for you.
        After the call, the version number in the comment is accessible via the
        <span class="Li">&quot;requires()&quot;</span> method.</p>
  </dd>
  <dt id="read_header"><a class="permalink" href="#read_header">read_header</a></dt>
  <dd><i>Instance method.</i> Read in the BinHex file header. You must do this
      first!</dd>
  <dt id="read_data"><a class="permalink" href="#read_data">read_data
    [NBYTES]</a></dt>
  <dd><i>Instance method.</i> Read information from the data fork. Use it in an
      array context to slurp all the data into an array of scalars:
    <p class="Pp"></p>
    <pre>    @data = $HQX-&gt;read_data;
    </pre>
    <p class="Pp">Or use it in a scalar context to get the data piecemeal:</p>
    <p class="Pp"></p>
    <pre>    while (defined($data = $HQX-&gt;read_data)) {
       # do stuff with $data
    }
    </pre>
    <p class="Pp">The NBYTES to read defaults to 2048.</p>
  </dd>
  <dt id="read_resource"><a class="permalink" href="#read_resource">read_resource
    [NBYTES]</a></dt>
  <dd><i>Instance method.</i> Read in all/some of the resource fork. See
      <span class="Li">&quot;read_data()&quot;</span> for usage.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Encode,_high-level"><a class="permalink" href="#Encode,_high-level">Encode,
  high-level</a></h2>
<dl class="Bl-tag">
  <dt id="encode"><a class="permalink" href="#encode">encode OUT</a></dt>
  <dd>Encode the object as a BinHex stream to the given output handle OUT. OUT
      can be a filehandle, or any blessed object that responds to a
      <span class="Li">&quot;print()&quot;</span> message.
    <p class="Pp">The leading comment is output, using the
        <span class="Li">&quot;requires()&quot;</span> attribute.</p>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SUBMODULES"><a class="permalink" href="#SUBMODULES">SUBMODULES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Convert::BinHex::Bin2Hex"><a class="permalink" href="#Convert::BinHex::Bin2Hex">Convert::BinHex::Bin2Hex</a></h2>
<p class="Pp">A BINary-to-HEX converter. This kind of conversion requires a
    certain amount of state information; it cannot be done by just calling a
    simple function repeatedly. Use it like this:</p>
<p class="Pp"></p>
<pre>    # Create and use a &quot;translator&quot; object:
    my $B2H = Convert::BinHex-&gt;bin2hex;    # get a converter object
    while (&lt;STDIN&gt;) {
        print STDOUT $B2H-&gt;next($_);          # convert some more input
    }
    print STDOUT $B2H-&gt;done;               # no more input: finish up
    # Re-use the object:
    $B2H-&gt;rewind;                 # ready for more action!
    while (&lt;MOREIN&gt;) { ...
</pre>
<p class="Pp">On each iteration, <span class="Li">&quot;next()&quot;</span> (and
    <span class="Li">&quot;done()&quot;</span>) may return either a decent-sized
    non-empty string (indicating that more converted data is ready for you) or
    an empty string (indicating that the converter is waiting to amass more
    input in its private buffers before handing you more stuff to output.</p>
<p class="Pp">Note that <span class="Li">&quot;done()&quot;</span> <i>always</i>
    converts and hands you whatever is left.</p>
<p class="Pp">This may have been a good approach. It may not. Someday, the
    converter may also allow you give it an object that responds to
    <b>read()</b>, or a FileHandle, and it will do all the nasty buffer-filling
    on its own, serving you stuff line by line:</p>
<p class="Pp"></p>
<pre>    # Someday, maybe...
    my $B2H = Convert::BinHex-&gt;bin2hex(\*STDIN);
    while (defined($_ = $B2H-&gt;getline)) {
        print STDOUT $_;
    }
</pre>
<p class="Pp">Someday, maybe. Feel free to voice your opinions.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Convert::BinHex::Hex2Bin"><a class="permalink" href="#Convert::BinHex::Hex2Bin">Convert::BinHex::Hex2Bin</a></h2>
<p class="Pp">A HEX-to-BINary converter. This kind of conversion requires a
    certain amount of state information; it cannot be done by just calling a
    simple function repeatedly. Use it like this:</p>
<p class="Pp"></p>
<pre>    # Create and use a &quot;translator&quot; object:
    my $H2B = Convert::BinHex-&gt;hex2bin;    # get a converter object
    while (&lt;STDIN&gt;) {
        print STDOUT $H2B-&gt;next($_);          # convert some more input
    }
    print STDOUT $H2B-&gt;done;               # no more input: finish up
    # Re-use the object:
    $H2B-&gt;rewind;                 # ready for more action!
    while (&lt;MOREIN&gt;) { ...
</pre>
<p class="Pp">On each iteration, <span class="Li">&quot;next()&quot;</span> (and
    <span class="Li">&quot;done()&quot;</span>) may return either a decent-sized
    non-empty string (indicating that more converted data is ready for you) or
    an empty string (indicating that the converter is waiting to amass more
    input in its private buffers before handing you more stuff to output.</p>
<p class="Pp">Note that <span class="Li">&quot;done()&quot;</span> <i>always</i>
    converts and hands you whatever is left.</p>
<p class="Pp">Note that this converter does <i>not</i> find the initial
    &quot;BinHex version&quot; comment. You have to skip that yourself. It only
    handles data between the opening and closing
    <span class="Li">&quot;:&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Convert::BinHex::Fork"><a class="permalink" href="#Convert::BinHex::Fork">Convert::BinHex::Fork</a></h2>
<p class="Pp">A fork in a Macintosh file.</p>
<p class="Pp"></p>
<pre>    # How to get them...
    $data_fork = $HQX-&gt;data;      # get the data fork
    $rsrc_fork = $HQX-&gt;resource;  # get the resource fork
    # Make a new fork:
    $FORK = Convert::BinHex::Fork-&gt;new(Path =&gt; &quot;/tmp/file.data&quot;);
    $FORK = Convert::BinHex::Fork-&gt;new(Data =&gt; $scalar);
    $FORK = Convert::BinHex::Fork-&gt;new(Data =&gt; \@array_of_scalars);
    # Get/set the length of the data fork:
    $len = $FORK-&gt;length;
    $FORK-&gt;length(170);        # this overrides the REAL value: be careful!
    # Get/set the path to the underlying data (if in a disk file):
    $path = $FORK-&gt;path;
    $FORK-&gt;path(&quot;/tmp/file.data&quot;);
    # Get/set the in-core data itself, which may be a scalar or an arrayref:
    $data = $FORK-&gt;data;
    $FORK-&gt;data($scalar);
    $FORK-&gt;data(\@array_of_scalars);
    # Get/set the CRC:
    $crc = $FORK-&gt;crc;
    $FORK-&gt;crc($crc);
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="UNDER_THE_HOOD"><a class="permalink" href="#UNDER_THE_HOOD">UNDER
  THE HOOD</a></h1>
<section class="Ss">
<h2 class="Ss" id="Design_issues"><a class="permalink" href="#Design_issues">Design
  issues</a></h2>
<dl class="Bl-tag">
  <dt id="BinHex"><a class="permalink" href="#BinHex">BinHex needs a stateful
    parser</a></dt>
  <dd>Unlike its cousins <i>base64</i> and <i>uuencode</i>, BinHex format is not
      amenable to being parsed line-by-line. There appears to be no guarantee
      that lines contain 4n encoded characters... and even if there is one, the
      BinHex compression algorithm interferes: even when you can <i>decode</i>
      one line at a time, you can't necessarily <i>decompress</i> a line at a
      time.
    <p class="Pp">For example: a decoded line ending with the byte
        <span class="Li">&quot;\x90&quot;</span> (the escape or &quot;mark&quot;
        character) is ambiguous: depending on the next decoded byte, it could
        mean a literal <span class="Li">&quot;\x90&quot;</span> (if the next
        byte is a <span class="Li">&quot;\x00&quot;</span>), or it could mean
        n-1 more repetitions of the previous character (if the next byte is some
        nonzero <span class="Li">&quot;n&quot;</span>).</p>
    <p class="Pp">For this reason, a BinHex parser has to be somewhat stateful:
        you cannot have code like this:</p>
    <p class="Pp"></p>
    <pre>    #### NO! #### NO! #### NO! #### NO! #### NO! ####
    while (&lt;STDIN&gt;) {            # read HEX
        print hexbin($_);          # convert and write BIN
    }
    </pre>
    <p class="Pp">unless something is happening &quot;behind the scenes&quot; to
        keep track of what was last done. <i>The dangerous thing, however, is
        that this</i> <i>approach will </i><b><i>seem</i></b><i> to work, if you
        only test it on BinHex files</i> <i>which do not use compression and
        which have 4n HEX characters</i> <i>on each line.</i></p>
    <p class="Pp">Since we have to be stateful anyway, we use the parser object
        to keep our state.</p>
  </dd>
  <dt id="We"><a class="permalink" href="#We">We need to be handle large input
    files</a></dt>
  <dd>Solutions that demand reading everything into core don't cut it in my
      book. The first MPEG file that comes along can louse up your whole day.
      So, there are no size limitations in this module: the data is read
      on-demand, and filehandles are always an option.</dd>
  <dt id="Boy,"><a class="permalink" href="#Boy,">Boy, is this slow!</a></dt>
  <dd>A lot of the byte-level manipulation that has to go on, particularly the
      CRC computing (which involves intensive bit-shifting and masking) slows
      this module down significantly. What is needed perhaps is an
      <i>optional</i> extension library where the slow pieces can be done more
      quickly... a Convert::BinHex::CRC, if you will. Volunteers, anyone?
    <p class="Pp">Even considering that, however, it's slower than I'd like. I'm
        sure many improvements can be made in the HEX-to-BIN end of things. No
        doubt I'll attempt some as time goes on...</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="How_it_works"><a class="permalink" href="#How_it_works">How
  it works</a></h2>
<p class="Pp">Since BinHex is a layered format, consisting of...</p>
<p class="Pp"></p>
<pre>      A Macintosh file [the &quot;BIN&quot;]...
         Encoded as a structured 8-bit bytestream, then...
            Compressed to reduce duplicate bytes, then...
               Encoded as 7-bit ASCII [the &quot;HEX&quot;]
</pre>
<p class="Pp">...there is a layered parsing algorithm to reverse the process.
    Basically, it works in a similar fashion to stdio's <b>fread()</b>:</p>
<p class="Pp"></p>
<pre>       0. There is an internal buffer of decompressed (BIN) data,
          initially empty.
       1. Application asks to read() n bytes of data from object
       2. If the buffer is not full enough to accommodate the request:
            2a. The read() method grabs the next available chunk of input
                data (the HEX).
            2b. HEX data is converted and decompressed into as many BIN
                bytes as possible.
            2c. BIN bytes are added to the read() buffer.
            2d. Go back to step 2a. until the buffer is full enough
                or we hit end-of-input.
</pre>
<p class="Pp">The conversion-and-decompression algorithms need their own
    internal buffers and state (since the next input chunk may not contain all
    the data needed for a complete conversion/decompression operation). These
    are maintained in the object, so parsing two different input streams
    simultaneously is possible.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="WARNINGS"><a class="permalink" href="#WARNINGS">WARNINGS</a></h1>
<p class="Pp">Only handles <span class="Li">&quot;Hqx7&quot;</span> files, as
    per RFC-1741.</p>
<p class="Pp">Remember that Macintosh text files use
    <span class="Li">&quot;\r&quot;</span> as end-of-line: this means that if
    you want a textual file to look normal on a non-Mac system, you probably
    want to do this to the data:</p>
<p class="Pp"></p>
<pre>    # Get the data, and output it according to normal conventions:
    foreach ($HQX-&gt;read_data) { s/\r/\n/g; print }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR_AND_CREDITS"><a class="permalink" href="#AUTHOR_AND_CREDITS">AUTHOR
  AND CREDITS</a></h1>
<p class="Pp">Maintained by Stephen Nelson &lt;stephenenelson@mac.com&gt;</p>
<p class="Pp">Written by Eryq, <i>http://www.enteract.com/~eryq</i> /
    <i>eryq@enteract.com</i></p>
<p class="Pp">Support for native-Mac conversion, <i>plus</i> invaluable
    contributions in Alpha Testing, <i>plus</i> a few patches, <i>plus</i> the
    baseline binhex/debinhex programs, were provided by Paul J. Schinder
    (NASA/GSFC).</p>
<p class="Pp">Ken Lunde (Adobe) suggested incorporating the CAP file
    representation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">Copyright (c) 1997 by Eryq. All rights reserved. This program is
    free software; you can redistribute it and/or modify it under the same terms
    as Perl itself.</p>
<p class="Pp">This software comes with <b>NO WARRANTY</b> of any kind. See the
    COPYING file in the distribution for details.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2015-11-15</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

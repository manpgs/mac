<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Compress::Zlib(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Compress::Zlib(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Compress::Zlib(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Compress::Zlib - Interface to zlib compression library</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
    use Compress::Zlib ;

    ($d, $status) = deflateInit( [OPT] ) ;
    $status = $d-&gt;deflate($input, $output) ;
    $status = $d-&gt;flush([$flush_type]) ;
    $d-&gt;deflateParams(OPTS) ;
    $d-&gt;deflateTune(OPTS) ;
    $d-&gt;dict_adler() ;
    $d-&gt;crc32() ;
    $d-&gt;adler32() ;
    $d-&gt;total_in() ;
    $d-&gt;total_out() ;
    $d-&gt;msg() ;
    $d-&gt;get_Strategy();
    $d-&gt;get_Level();
    $d-&gt;get_BufSize();

    ($i, $status) = inflateInit( [OPT] ) ;
    $status = $i-&gt;inflate($input, $output [, $eof]) ;
    $status = $i-&gt;inflateSync($input) ;
    $i-&gt;dict_adler() ;
    $d-&gt;crc32() ;
    $d-&gt;adler32() ;
    $i-&gt;total_in() ;
    $i-&gt;total_out() ;
    $i-&gt;msg() ;
    $d-&gt;get_BufSize();

    $dest = compress($source) ;
    $dest = uncompress($source) ;

    $gz = gzopen($filename or filehandle, $mode) ;
    $bytesread = $gz-&gt;gzread($buffer [,$size]) ;
    $bytesread = $gz-&gt;gzreadline($line) ;
    $byteswritten = $gz-&gt;gzwrite($buffer) ;
    $status = $gz-&gt;gzflush($flush) ;
    $offset = $gz-&gt;gztell() ;
    $status = $gz-&gt;gzseek($offset, $whence) ;
    $status = $gz-&gt;gzclose() ;
    $status = $gz-&gt;gzeof() ;
    $status = $gz-&gt;gzsetparams($level, $strategy) ;
    $errstring = $gz-&gt;gzerror() ;
    $gzerrno

    $dest = Compress::Zlib::memGzip($buffer) ;
    $dest = Compress::Zlib::memGunzip($buffer) ;

    $crc = adler32($buffer [,$crc]) ;
    $crc = crc32($buffer [,$crc]) ;

    $crc = crc32_combine($crc1, $crc2, $len2);
    $adler = adler32_combine($adler1, $adler2, $len2);

    my $version = Compress::Raw::Zlib::zlib_version();
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The <i>Compress::Zlib</i> module provides a Perl interface to the
    <i>zlib</i> compression library (see &quot;AUTHOR&quot; for details about
    where to get <i>zlib</i>).</p>
<p class="Pp">The <span class="Li">&quot;Compress::Zlib&quot;</span> module can
    be split into two general areas of functionality, namely a simple read/write
    interface to <i>gzip</i> files and a low-level in-memory
    compression/decompression interface.</p>
<p class="Pp">Each of these areas will be discussed in the following
  sections.</p>
<section class="Ss">
<h2 class="Ss" id="Notes_for_users_of_Compress::Zlib_version_1"><a class="permalink" href="#Notes_for_users_of_Compress::Zlib_version_1">Notes
  for users of Compress::Zlib version 1</a></h2>
<p class="Pp">The main change in
    <span class="Li">&quot;Compress::Zlib&quot;</span> version 2.x is that it
    does not now interface directly to the zlib library. Instead it uses the
    <span class="Li">&quot;IO::Compress::Gzip&quot;</span> and
    <span class="Li">&quot;IO::Uncompress::Gunzip&quot;</span> modules for
    reading/writing gzip files, and the
    <span class="Li">&quot;Compress::Raw::Zlib&quot;</span> module for some
    low-level zlib access.</p>
<p class="Pp">The interface provided by version 2 of this module should be 100%
    backward compatible with version 1. If you find a difference in the expected
    behaviour please contact the author (See &quot;AUTHOR&quot;). See &quot;GZIP
    INTERFACE&quot;</p>
<p class="Pp">With the creation of the
    <span class="Li">&quot;IO::Compress&quot;</span> and
    <span class="Li">&quot;IO::Uncompress&quot;</span> modules no new features
    are planned for <span class="Li">&quot;Compress::Zlib&quot;</span> - the new
    modules do everything that
    <span class="Li">&quot;Compress::Zlib&quot;</span> does and then some.
    Development on <span class="Li">&quot;Compress::Zlib&quot;</span> will be
    limited to bug fixes only.</p>
<p class="Pp">If you are writing new code, your first port of call should be one
    of the new <span class="Li">&quot;IO::Compress&quot;</span> or
    <span class="Li">&quot;IO::Uncompress&quot;</span> modules.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="GZIP_INTERFACE"><a class="permalink" href="#GZIP_INTERFACE">GZIP
  INTERFACE</a></h1>
<p class="Pp">A number of functions are supplied in <i>zlib</i> for reading and
    writing <i>gzip</i> files that conform to RFC 1952. This module provides an
    interface to most of them.</p>
<p class="Pp">If you have previously used
    <span class="Li">&quot;Compress::Zlib&quot;</span> 1.x, the following
    enhancements/changes have been made to the
    <span class="Li">&quot;gzopen&quot;</span> interface:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>If you want to open either STDIN or STDOUT with
      <span class="Li">&quot;gzopen&quot;</span>, you can now optionally use the
      special filename &quot;<span class="Li">&quot;-&quot;</span>&quot; as a
      synonym for <span class="Li">&quot;\*STDIN&quot;</span> and
      <span class="Li">&quot;\*STDOUT&quot;</span>.</dd>
  <dt>2.</dt>
  <dd>In <span class="Li">&quot;Compress::Zlib&quot;</span> version 1.x,
      <span class="Li">&quot;gzopen&quot;</span> used the zlib library to open
      the underlying file. This made things especially tricky when a Perl
      filehandle was passed to <span class="Li">&quot;gzopen&quot;</span>.
      Behind the scenes the numeric C file descriptor had to be extracted from
      the Perl filehandle and this passed to the zlib library.
    <p class="Pp">Apart from being non-portable to some operating systems, this
        made it difficult to use <span class="Li">&quot;gzopen&quot;</span> in
        situations where you wanted to extract/create a gzip data stream that is
        embedded in a larger file, without having to resort to opening and
        closing the file multiple times.</p>
    <p class="Pp">It also made it impossible to pass a perl filehandle that
        wasn't associated with a real filesystem file, like, say, an
        <span class="Li">&quot;IO::String&quot;</span>.</p>
    <p class="Pp">In <span class="Li">&quot;Compress::Zlib&quot;</span> version
        2.x, the <span class="Li">&quot;gzopen&quot;</span> interface has been
        completely rewritten to use the IO::Compress::Gzip for writing gzip
        files and IO::Uncompress::Gunzip for reading gzip files. None of the
        limitations mentioned above apply.</p>
  </dd>
  <dt>3.</dt>
  <dd>Addition of <span class="Li">&quot;gzseek&quot;</span> to provide a
      restricted <span class="Li">&quot;seek&quot;</span> interface.</dd>
  <dt>4.</dt>
  <dd>Added <span class="Li">&quot;gztell&quot;</span>.</dd>
</dl>
<p class="Pp">A more complete and flexible interface for reading/writing gzip
    files/buffers is included with the module
    <span class="Li">&quot;IO-Compress-Zlib&quot;</span>. See IO::Compress::Gzip
    and IO::Uncompress::Gunzip for more details.</p>
<dl class="Bl-tag">
  <dt><b></b><b>$gz</b><b> = gzopen($filename, </b><b>$mode</b><b>)</b></dt>
  <dd></dd>
  <dt><b></b><b>$gz</b><b> = gzopen($filehandle, </b><b>$mode</b><b>)</b></dt>
  <dd>This function opens either the <i>gzip</i> file
      <span class="Li">$filename</span> for reading or writing or attaches to
      the opened filehandle, <span class="Li">$filehandle</span>. It returns an
      object on success and <span class="Li">&quot;undef&quot;</span> on
      failure.
    <p class="Pp">When writing a gzip file this interface will <i>always</i>
        create the smallest possible gzip header (exactly 10 bytes). If you want
        greater control over what gets stored in the gzip header (like the
        original filename or a comment) use IO::Compress::Gzip instead.
        Similarly if you want to read the contents of the gzip header use
        IO::Uncompress::Gunzip.</p>
    <p class="Pp">The second parameter, <span class="Li">$mode</span>, is used
        to specify whether the file is opened for reading or writing and to
        optionally specify a compression level and compression strategy when
        writing. The format of the <span class="Li">$mode</span> parameter is
        similar to the mode parameter to the 'C' function
        <span class="Li">&quot;fopen&quot;</span>, so &quot;rb&quot; is used to
        open for reading, &quot;wb&quot; for writing and &quot;ab&quot; for
        appending (writing at the end of the file).</p>
    <p class="Pp">To specify a compression level when writing, append a digit
        between 0 and 9 to the mode string -- 0 means no compression and 9 means
        maximum compression. If no compression level is specified
        Z_DEFAULT_COMPRESSION is used.</p>
    <p class="Pp">To specify the compression strategy when writing, append 'f'
        for filtered data, 'h' for Huffman only compression, or 'R' for
        run-length encoding. If no strategy is specified Z_DEFAULT_STRATEGY is
        used.</p>
    <p class="Pp">So, for example, &quot;wb9&quot; means open for writing with
        the maximum compression using the default strategy and &quot;wb4R&quot;
        means open for writing with compression level 4 and run-length
      encoding.</p>
    <p class="Pp">Refer to the <i>zlib</i> documentation for the exact format of
        the <span class="Li">$mode</span> parameter.</p>
  </dd>
  <dt><b></b><b>$bytesread</b><b> = </b><b>$gz</b><b>-&gt;gzread($buffer [,
    </b><b>$size</b><b>]) ;</b></dt>
  <dd>Reads <span class="Li">$size</span> bytes from the compressed file into
      <span class="Li">$buffer</span>. If <span class="Li">$size</span> is not
      specified, it will default to 4096. If the scalar
      <span class="Li">$buffer</span> is not large enough, it will be extended
      automatically.
    <p class="Pp">Returns the number of bytes actually read. On EOF it returns 0
        and in the case of an error, -1.</p>
  </dd>
  <dt><b></b><b>$bytesread</b><b> = </b><b>$gz</b><b>-&gt;gzreadline($line)
    ;</b></dt>
  <dd>Reads the next line from the compressed file into
      <span class="Li">$line</span>.
    <p class="Pp">Returns the number of bytes actually read. On EOF it returns 0
        and in the case of an error, -1.</p>
    <p class="Pp">It is legal to intermix calls to
        <span class="Li">&quot;gzread&quot;</span> and
        <span class="Li">&quot;gzreadline&quot;</span>.</p>
    <p class="Pp">To maintain backward compatibility with version 1.x of this
        module <span class="Li">&quot;gzreadline&quot;</span> ignores the
        <span class="Li">$/</span> variable - it <i>always</i> uses the string
        <span class="Li">&quot;\n&quot;</span> as the line delimiter.</p>
    <p class="Pp">If you want to read a gzip file a line at a time and have it
        respect the <span class="Li">$/</span> variable (or
        <span class="Li">$INPUT_RECORD_SEPARATOR</span>, or
        <span class="Li">$RS</span> when
        <span class="Li">&quot;English&quot;</span> is in use) see
        IO::Uncompress::Gunzip.</p>
  </dd>
  <dt><b></b><b>$byteswritten</b><b> = </b><b>$gz</b><b>-&gt;gzwrite($buffer)
    ;</b></dt>
  <dd>Writes the contents of <span class="Li">$buffer</span> to the compressed
      file. Returns the number of bytes actually written, or 0 on error.</dd>
  <dt><b></b><b>$status</b><b> = </b><b>$gz</b><b>-&gt;gzflush($flush_type)
    ;</b></dt>
  <dd>Flushes all pending output into the compressed file.
    <p class="Pp">This method takes an optional parameter,
        <span class="Li">$flush_type</span>, that controls how the flushing will
        be carried out. By default the <span class="Li">$flush_type</span> used
        is <span class="Li">&quot;Z_FINISH&quot;</span>. Other valid values for
        <span class="Li">$flush_type</span> are
        <span class="Li">&quot;Z_NO_FLUSH&quot;</span>,
        <span class="Li">&quot;Z_SYNC_FLUSH&quot;</span>,
        <span class="Li">&quot;Z_FULL_FLUSH&quot;</span> and
        <span class="Li">&quot;Z_BLOCK&quot;</span>. It is strongly recommended
        that you only set the <span class="Li">&quot;flush_type&quot;</span>
        parameter if you fully understand the implications of what it does -
        overuse of <span class="Li">&quot;flush&quot;</span> can seriously
        degrade the level of compression achieved. See the
        <span class="Li">&quot;zlib&quot;</span> documentation for details.</p>
    <p class="Pp">Returns 0 on success.</p>
  </dd>
  <dt><b></b><b>$offset</b><b> = </b><b>$gz</b><b>-&gt;</b><b>gztell()</b><b>
    ;</b></dt>
  <dd>Returns the uncompressed file offset.</dd>
  <dt><b></b><b>$status</b><b> = </b><b>$gz</b><b>-&gt;gzseek($offset,
    </b><b>$whence</b><b>) ;</b></dt>
  <dd>Provides a sub-set of the <span class="Li">&quot;seek&quot;</span>
      functionality, with the restriction that it is only legal to seek forward
      in the compressed file. It is a fatal error to attempt to seek backward.
    <p class="Pp">When opened for writing, empty parts of the file will have
        NULL (0x00) bytes written to them.</p>
    <p class="Pp">The <span class="Li">$whence</span> parameter should be one of
        SEEK_SET, SEEK_CUR or SEEK_END.</p>
    <p class="Pp">Returns 1 on success, 0 on failure.</p>
  </dd>
  <dt><b></b><b>$gz</b><b>-&gt;gzclose</b></dt>
  <dd>Closes the compressed file. Any pending data is flushed to the file before
      it is closed.
    <p class="Pp">Returns 0 on success.</p>
  </dd>
  <dt><b></b><b>$gz</b><b>-&gt;gzsetparams($level,
    </b><b>$strategy</b><b></b></dt>
  <dd>Change settings for the deflate stream <span class="Li">$gz</span>.
    <p class="Pp">The list of the valid options is shown below. Options not
        specified will remain unchanged.</p>
    <p class="Pp">Note: This method is only available if you are running zlib
        1.0.6 or better.</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b></b><b>$level</b><b></b></dt>
  <dd>Defines the compression level. Valid values are 0 through 9,
      <span class="Li">&quot;Z_NO_COMPRESSION&quot;</span>,
      <span class="Li">&quot;Z_BEST_SPEED&quot;</span>,
      <span class="Li">&quot;Z_BEST_COMPRESSION&quot;</span>, and
      <span class="Li">&quot;Z_DEFAULT_COMPRESSION&quot;</span>.</dd>
  <dt><b></b><b>$strategy</b><b></b></dt>
  <dd>Defines the strategy used to tune the compression. The valid values are
      <span class="Li">&quot;Z_DEFAULT_STRATEGY&quot;</span>,
      <span class="Li">&quot;Z_FILTERED&quot;</span> and
      <span class="Li">&quot;Z_HUFFMAN_ONLY&quot;</span>.</dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt><b></b><b>$gz</b><b>-&gt;gzerror</b></dt>
  <dd>Returns the <i>zlib</i> error message or number for the last operation
      associated with <span class="Li">$gz</span>. The return value will be the
      <i>zlib</i> error number when used in a numeric context and the
      <i>zlib</i> error message when used in a string context. The <i>zlib</i>
      error number constants, shown below, are available for use.
    <p class="Pp"></p>
    <pre>
    Z_OK
    Z_STREAM_END
    Z_ERRNO
    Z_STREAM_ERROR
    Z_DATA_ERROR
    Z_MEM_ERROR
    Z_BUF_ERROR
    </pre>
  </dd>
  <dt><b></b><b>$gzerrno</b><b></b></dt>
  <dd>The <span class="Li">$gzerrno</span> scalar holds the error code
      associated with the most recent <i>gzip</i> routine. Note that unlike
      <span class="Li">&quot;gzerror()&quot;</span>, the error is <i>not</i>
      associated with a particular file.
    <p class="Pp">As with <span class="Li">&quot;gzerror()&quot;</span> it
        returns an error number in numeric context and an error message in
        string context. Unlike <span class="Li">&quot;gzerror()&quot;</span>
        though, the error message will correspond to the <i>zlib</i> message
        when the error is associated with <i>zlib</i> itself, or the UNIX error
        message when it is not (i.e. <i>zlib</i> returned
        <span class="Li">&quot;Z_ERRORNO&quot;</span>).</p>
    <p class="Pp">As there is an overlap between the error numbers used by
        <i>zlib</i> and UNIX, <span class="Li">$gzerrno</span> should only be
        used to check for the presence of <i>an</i> error in numeric context.
        Use <span class="Li">&quot;gzerror()&quot;</span> to check for specific
        <i>zlib</i> errors. The <i>gzcat</i> example below shows how the
        variable can be used safely.</p>
  </dd>
</dl>
<section class="Ss">
<h2 class="Ss" id="Examples"><a class="permalink" href="#Examples">Examples</a></h2>
<p class="Pp">Here is an example script which uses the interface. It implements
    a <i>gzcat</i> function.</p>
<p class="Pp"></p>
<pre>
    use strict ;
    use warnings ;
    
    use Compress::Zlib ;
    
    # use stdin if no files supplied
    @ARGV = '-' unless @ARGV ;
    
    foreach my $file (@ARGV) {
        my $buffer ;
    
        my $gz = gzopen($file, &quot;rb&quot;)
             or die &quot;Cannot open $file: $gzerrno\n&quot; ;
    
        print $buffer while $gz-&gt;gzread($buffer) &gt; 0 ;
    
        die &quot;Error reading from $file: $gzerrno&quot; . ($gzerrno+0) . &quot;\n&quot;
            if $gzerrno != Z_STREAM_END ;
        
        $gz-&gt;gzclose() ;
    }
</pre>
<p class="Pp">Below is a script which makes use of
    <span class="Li">&quot;gzreadline&quot;</span>. It implements a very simple
    <i>grep</i> like script.</p>
<p class="Pp"></p>
<pre>
    use strict ;
    use warnings ;
    
    use Compress::Zlib ;
    
    die &quot;Usage: gzgrep pattern [file...]\n&quot;
        unless @ARGV &gt;= 1;
    
    my $pattern = shift ;
    
    # use stdin if no files supplied
    @ARGV = '-' unless @ARGV ;
    
    foreach my $file (@ARGV) {
        my $gz = gzopen($file, &quot;rb&quot;)
             or die &quot;Cannot open $file: $gzerrno\n&quot; ;
    
        while ($gz-&gt;gzreadline($_) &gt; 0) {
            print if /$pattern/ ;
        }
    
        die &quot;Error reading from $file: $gzerrno\n&quot;
            if $gzerrno != Z_STREAM_END ;
        
        $gz-&gt;gzclose() ;
    }
</pre>
<p class="Pp">This script, <i>gzstream</i>, does the opposite of the
    <i>gzcat</i> script above. It reads from standard input and writes a gzip
    data stream to standard output.</p>
<p class="Pp"></p>
<pre>
    use strict ;
    use warnings ;
    
    use Compress::Zlib ;
    
    binmode STDOUT;  # gzopen only sets it on the fd
    
    my $gz = gzopen(\*STDOUT, &quot;wb&quot;)
          or die &quot;Cannot open stdout: $gzerrno\n&quot; ;
    
    while (&lt;&gt;) {
        $gz-&gt;gzwrite($_)
          or die &quot;error writing: $gzerrno\n&quot; ;
    }

    $gz-&gt;gzclose ;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Compress::Zlib::memGzip"><a class="permalink" href="#Compress::Zlib::memGzip">Compress::Zlib::memGzip</a></h2>
<p class="Pp">This function is used to create an in-memory gzip file with the
    minimum possible gzip header (exactly 10 bytes).</p>
<p class="Pp"></p>
<pre>
    $dest = Compress::Zlib::memGzip($buffer)
        or die &quot;Cannot compress: $gzerrno\n&quot;;
</pre>
<p class="Pp">If successful, it returns the in-memory gzip file. Otherwise it
    returns <span class="Li">&quot;undef&quot;</span> and the
    <span class="Li">$gzerrno</span> variable will store the zlib error
  code.</p>
<p class="Pp">The <span class="Li">$buffer</span> parameter can either be a
    scalar or a scalar reference.</p>
<p class="Pp">See IO::Compress::Gzip for an alternative way to carry out
    in-memory gzip compression.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Compress::Zlib::memGunzip"><a class="permalink" href="#Compress::Zlib::memGunzip">Compress::Zlib::memGunzip</a></h2>
<p class="Pp">This function is used to uncompress an in-memory gzip file.</p>
<p class="Pp"></p>
<pre>
    $dest = Compress::Zlib::memGunzip($buffer)
        or die &quot;Cannot uncompress: $gzerrno\n&quot;;
</pre>
<p class="Pp">If successful, it returns the uncompressed gzip file. Otherwise it
    returns <span class="Li">&quot;undef&quot;</span> and the
    <span class="Li">$gzerrno</span> variable will store the zlib error
  code.</p>
<p class="Pp">The <span class="Li">$buffer</span> parameter can either be a
    scalar or a scalar reference. The contents of the
    <span class="Li">$buffer</span> parameter are destroyed after calling this
    function.</p>
<p class="Pp">If <span class="Li">$buffer</span> consists of multiple
    concatenated gzip data streams only the first will be uncompressed. Use
    <span class="Li">&quot;gunzip&quot;</span> with the
    <span class="Li">&quot;MultiStream&quot;</span> option in the
    <span class="Li">&quot;IO::Uncompress::Gunzip&quot;</span> module if you
    need to deal with concatenated data streams.</p>
<p class="Pp">See IO::Uncompress::Gunzip for an alternative way to carry out
    in-memory gzip uncompression.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="COMPRESS/UNCOMPRESS"><a class="permalink" href="#COMPRESS/UNCOMPRESS">COMPRESS/UNCOMPRESS</a></h1>
<p class="Pp">Two functions are provided to perform in-memory
    compression/uncompression of RFC 1950 data streams. They are called
    <span class="Li">&quot;compress&quot;</span> and
    <span class="Li">&quot;uncompress&quot;</span>.</p>
<dl class="Bl-tag">
  <dt><b></b><b>$dest</b><b> = compress($source [, </b><b>$level</b><b>] )
    ;</b></dt>
  <dd>Compresses <span class="Li">$source</span>. If successful it returns the
      compressed data. Otherwise it returns <i>undef</i>.
    <p class="Pp">The source buffer, <span class="Li">$source</span>, can either
        be a scalar or a scalar reference.</p>
    <p class="Pp">The <span class="Li">$level</span> parameter defines the
        compression level. Valid values are 0 through 9,
        <span class="Li">&quot;Z_NO_COMPRESSION&quot;</span>,
        <span class="Li">&quot;Z_BEST_SPEED&quot;</span>,
        <span class="Li">&quot;Z_BEST_COMPRESSION&quot;</span>, and
        <span class="Li">&quot;Z_DEFAULT_COMPRESSION&quot;</span>. If
        <span class="Li">$level</span> is not specified
        <span class="Li">&quot;Z_DEFAULT_COMPRESSION&quot;</span> will be
      used.</p>
  </dd>
  <dt><b></b><b>$dest</b><b> = uncompress($source) ;</b></dt>
  <dd>Uncompresses <span class="Li">$source</span>. If successful it returns the
      uncompressed data. Otherwise it returns <i>undef</i>.
    <p class="Pp">The source buffer can either be a scalar or a scalar
        reference.</p>
  </dd>
</dl>
<p class="Pp">Please note: the two functions defined above are <i>not</i>
    compatible with the Unix commands of the same name.</p>
<p class="Pp">See IO::Deflate and IO::Inflate included with this distribution
    for an alternative interface for reading/writing RFC 1950 files/buffers.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Deflate_Interface"><a class="permalink" href="#Deflate_Interface">Deflate
  Interface</a></h1>
<p class="Pp">This section defines an interface that allows in-memory
    compression using the <i>deflate</i> interface provided by zlib.</p>
<p class="Pp">Here is a definition of the interface available:</p>
<section class="Ss">
<h2 class="Ss"><b>($d, </b><b>$status</b><b>) = deflateInit( [OPT] )</b></h2>
<p class="Pp">Initialises a deflation stream.</p>
<p class="Pp">It combines the features of the <i>zlib</i> functions
    <span class="Li">&quot;deflateInit&quot;</span>,
    <span class="Li">&quot;deflateInit2&quot;</span> and
    <span class="Li">&quot;deflateSetDictionary&quot;</span>.</p>
<p class="Pp">If successful, it will return the initialised deflation stream,
    <span class="Li">$d</span> and <span class="Li">$status</span> of
    <span class="Li">&quot;Z_OK&quot;</span> in a list context. In scalar
    context it returns the deflation stream, <span class="Li">$d</span>,
  only.</p>
<p class="Pp">If not successful, the returned deflation stream
    (<span class="Li">$d</span>) will be <i>undef</i> and
    <span class="Li">$status</span> will hold the exact <i>zlib</i> error
  code.</p>
<p class="Pp">The function optionally takes a number of named options specified
    as <span class="Li">&quot;-Name=&gt;value&quot;</span> pairs. This allows
    individual options to be tailored without having to specify them all in the
    parameter list.</p>
<p class="Pp">For backward compatibility, it is also possible to pass the
    parameters as a reference to a hash containing the name=&gt;value pairs.</p>
<p class="Pp">The function takes one optional parameter, a reference to a hash.
    The contents of the hash allow the deflation interface to be tailored.</p>
<p class="Pp">Here is a list of the valid options:</p>
<dl class="Bl-tag">
  <dt id="Level"><a class="permalink" href="#Level"><b>-Level</b></a></dt>
  <dd>Defines the compression level. Valid values are 0 through 9,
      <span class="Li">&quot;Z_NO_COMPRESSION&quot;</span>,
      <span class="Li">&quot;Z_BEST_SPEED&quot;</span>,
      <span class="Li">&quot;Z_BEST_COMPRESSION&quot;</span>, and
      <span class="Li">&quot;Z_DEFAULT_COMPRESSION&quot;</span>.
    <p class="Pp">The default is Z_DEFAULT_COMPRESSION.</p>
  </dd>
  <dt id="Method"><a class="permalink" href="#Method"><b>-Method</b></a></dt>
  <dd>Defines the compression method. The only valid value at present (and the
      default) is Z_DEFLATED.</dd>
  <dt id="WindowBits"><a class="permalink" href="#WindowBits"><b>-WindowBits</b></a></dt>
  <dd>To create an RFC 1950 data stream, set
      <span class="Li">&quot;WindowBits&quot;</span> to a positive number.
    <p class="Pp">To create an RFC 1951 data stream, set
        <span class="Li">&quot;WindowBits&quot;</span> to
        <span class="Li">&quot;-MAX_WBITS&quot;</span>.</p>
    <p class="Pp">For a full definition of the meaning and valid values for
        <span class="Li">&quot;WindowBits&quot;</span> refer to the <i>zlib</i>
        documentation for <i>deflateInit2</i>.</p>
    <p class="Pp">Defaults to MAX_WBITS.</p>
  </dd>
  <dt id="MemLevel"><a class="permalink" href="#MemLevel"><b>-MemLevel</b></a></dt>
  <dd>For a definition of the meaning and valid values for
      <span class="Li">&quot;MemLevel&quot;</span> refer to the <i>zlib</i>
      documentation for <i>deflateInit2</i>.
    <p class="Pp">Defaults to MAX_MEM_LEVEL.</p>
  </dd>
  <dt id="Strategy"><a class="permalink" href="#Strategy"><b>-Strategy</b></a></dt>
  <dd>Defines the strategy used to tune the compression. The valid values are
      <span class="Li">&quot;Z_DEFAULT_STRATEGY&quot;</span>,
      <span class="Li">&quot;Z_FILTERED&quot;</span> and
      <span class="Li">&quot;Z_HUFFMAN_ONLY&quot;</span>.
    <p class="Pp">The default is Z_DEFAULT_STRATEGY.</p>
  </dd>
  <dt id="Dictionary"><a class="permalink" href="#Dictionary"><b>-Dictionary</b></a></dt>
  <dd>When a dictionary is specified <i>Compress::Zlib</i> will automatically
      call <span class="Li">&quot;deflateSetDictionary&quot;</span> directly
      after calling <span class="Li">&quot;deflateInit&quot;</span>. The Adler32
      value for the dictionary can be obtained by calling the method
      <span class="Li">&quot;$d-&gt;dict_adler()&quot;</span>.
    <p class="Pp">The default is no dictionary.</p>
  </dd>
  <dt id="Bufsize"><a class="permalink" href="#Bufsize"><b>-Bufsize</b></a></dt>
  <dd>Sets the initial size for the deflation buffer. If the buffer has to be
      reallocated to increase the size, it will grow in increments of
      <span class="Li">&quot;Bufsize&quot;</span>.
    <p class="Pp">The default is 4096.</p>
  </dd>
</dl>
<p class="Pp">Here is an example of using the
    <span class="Li">&quot;deflateInit&quot;</span> optional parameter list to
    override the default buffer size and compression level. All other options
    will take their default values.</p>
<p class="Pp"></p>
<pre>
    deflateInit( -Bufsize =&gt; 300,
                 -Level =&gt; Z_BEST_SPEED  ) ;
</pre>
</section>
<section class="Ss">
<h2 class="Ss"><b>($out, </b><b>$status</b><b>) =
  </b><b>$d</b><b>-&gt;deflate($buffer)</b></h2>
<p class="Pp">Deflates the contents of <span class="Li">$buffer</span>. The
    buffer can either be a scalar or a scalar reference. When finished,
    <span class="Li">$buffer</span> will be completely processed (assuming there
    were no errors). If the deflation was successful it returns the deflated
    output, <span class="Li">$out</span>, and a status value,
    <span class="Li">$status</span>, of
    <span class="Li">&quot;Z_OK&quot;</span>.</p>
<p class="Pp">On error, <span class="Li">$out</span> will be <i>undef</i> and
    <span class="Li">$status</span> will contain the <i>zlib</i> error code.</p>
<p class="Pp">In a scalar context <span class="Li">&quot;deflate&quot;</span>
    will return <span class="Li">$out</span> only.</p>
<p class="Pp">As with the <i>deflate</i> function in <i>zlib</i>, it is not
    necessarily the case that any output will be produced by this method. So
    don't rely on the fact that <span class="Li">$out</span> is empty for an
    error test.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>($out, </b><b>$status</b><b>) =
  </b><b>$d</b><b>-&gt;flush()</b> =head2 <b>($out, </b><b>$status</b><b>) =
  </b><b>$d</b><b>-&gt;flush($flush_type)</b></h2>
<p class="Pp">Typically used to finish the deflation. Any pending output will be
    returned via <span class="Li">$out</span>. <span class="Li">$status</span>
    will have a value <span class="Li">&quot;Z_OK&quot;</span> if
  successful.</p>
<p class="Pp">In a scalar context <span class="Li">&quot;flush&quot;</span> will
    return <span class="Li">$out</span> only.</p>
<p class="Pp">Note that flushing can seriously degrade the compression ratio, so
    it should only be used to terminate a decompression (using
    <span class="Li">&quot;Z_FINISH&quot;</span>) or when you want to create a
    <i>full flush point</i> (using
    <span class="Li">&quot;Z_FULL_FLUSH&quot;</span>).</p>
<p class="Pp">By default the <span class="Li">&quot;flush_type&quot;</span> used
    is <span class="Li">&quot;Z_FINISH&quot;</span>. Other valid values for
    <span class="Li">&quot;flush_type&quot;</span> are
    <span class="Li">&quot;Z_NO_FLUSH&quot;</span>,
    <span class="Li">&quot;Z_PARTIAL_FLUSH&quot;</span>,
    <span class="Li">&quot;Z_SYNC_FLUSH&quot;</span> and
    <span class="Li">&quot;Z_FULL_FLUSH&quot;</span>. It is strongly recommended
    that you only set the <span class="Li">&quot;flush_type&quot;</span>
    parameter if you fully understand the implications of what it does. See the
    <span class="Li">&quot;zlib&quot;</span> documentation for details.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><b>$status</b><b> =
  </b><b>$d</b><b>-&gt;deflateParams([OPT])</b></h2>
<p class="Pp">Change settings for the deflate stream
  <span class="Li">$d</span>.</p>
<p class="Pp">The list of the valid options is shown below. Options not
    specified will remain unchanged.</p>
<dl class="Bl-tag">
  <dt id="Level~2"><a class="permalink" href="#Level~2"><b>-Level</b></a></dt>
  <dd>Defines the compression level. Valid values are 0 through 9,
      <span class="Li">&quot;Z_NO_COMPRESSION&quot;</span>,
      <span class="Li">&quot;Z_BEST_SPEED&quot;</span>,
      <span class="Li">&quot;Z_BEST_COMPRESSION&quot;</span>, and
      <span class="Li">&quot;Z_DEFAULT_COMPRESSION&quot;</span>.</dd>
  <dt id="Strategy~2"><a class="permalink" href="#Strategy~2"><b>-Strategy</b></a></dt>
  <dd>Defines the strategy used to tune the compression. The valid values are
      <span class="Li">&quot;Z_DEFAULT_STRATEGY&quot;</span>,
      <span class="Li">&quot;Z_FILTERED&quot;</span> and
      <span class="Li">&quot;Z_HUFFMAN_ONLY&quot;</span>.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><b>$d</b><b>-&gt;dict_adler()</b></h2>
<p class="Pp">Returns the adler32 value for the dictionary.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><b>$d</b><b>-&gt;msg()</b></h2>
<p class="Pp">Returns the last error message generated by zlib.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><b>$d</b><b>-&gt;total_in()</b></h2>
<p class="Pp">Returns the total number of bytes uncompressed bytes input to
    deflate.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><b>$d</b><b>-&gt;total_out()</b></h2>
<p class="Pp">Returns the total number of compressed bytes output from
  deflate.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Example"><a class="permalink" href="#Example">Example</a></h2>
<p class="Pp">Here is a trivial example of using
    <span class="Li">&quot;deflate&quot;</span>. It simply reads standard input,
    deflates it and writes it to standard output.</p>
<p class="Pp"></p>
<pre>
    use strict ;
    use warnings ;

    use Compress::Zlib ;

    binmode STDIN;
    binmode STDOUT;
    my $x = deflateInit()
       or die &quot;Cannot create a deflation stream\n&quot; ;

    my ($output, $status) ;
    while (&lt;&gt;)
    {
        ($output, $status) = $x-&gt;deflate($_) ;
    
        $status == Z_OK
            or die &quot;deflation failed\n&quot; ;
    
        print $output ;
    }
    
    ($output, $status) = $x-&gt;flush() ;
    
    $status == Z_OK
        or die &quot;deflation failed\n&quot; ;
    
    print $output ;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Inflate_Interface"><a class="permalink" href="#Inflate_Interface">Inflate
  Interface</a></h1>
<p class="Pp">This section defines the interface available that allows in-memory
    uncompression using the <i>deflate</i> interface provided by zlib.</p>
<p class="Pp">Here is a definition of the interface:</p>
<section class="Ss">
<h2 class="Ss"><b>($i, </b><b>$status</b><b>) = inflateInit()</b></h2>
<p class="Pp">Initialises an inflation stream.</p>
<p class="Pp">In a list context it returns the inflation stream,
    <span class="Li">$i</span>, and the <i>zlib</i> status code in
    <span class="Li">$status</span>. In a scalar context it returns the
    inflation stream only.</p>
<p class="Pp">If successful, <span class="Li">$i</span> will hold the inflation
    stream and <span class="Li">$status</span> will be
    <span class="Li">&quot;Z_OK&quot;</span>.</p>
<p class="Pp">If not successful, <span class="Li">$i</span> will be <i>undef</i>
    and <span class="Li">$status</span> will hold the <i>zlib</i> error
  code.</p>
<p class="Pp">The function optionally takes a number of named options specified
    as <span class="Li">&quot;-Name=&gt;value&quot;</span> pairs. This allows
    individual options to be tailored without having to specify them all in the
    parameter list.</p>
<p class="Pp">For backward compatibility, it is also possible to pass the
    parameters as a reference to a hash containing the name=&gt;value pairs.</p>
<p class="Pp">The function takes one optional parameter, a reference to a hash.
    The contents of the hash allow the deflation interface to be tailored.</p>
<p class="Pp">Here is a list of the valid options:</p>
<dl class="Bl-tag">
  <dt id="WindowBits~2"><a class="permalink" href="#WindowBits~2"><b>-WindowBits</b></a></dt>
  <dd>To uncompress an RFC 1950 data stream, set
      <span class="Li">&quot;WindowBits&quot;</span> to a positive number.
    <p class="Pp">To uncompress an RFC 1951 data stream, set
        <span class="Li">&quot;WindowBits&quot;</span> to
        <span class="Li">&quot;-MAX_WBITS&quot;</span>.</p>
    <p class="Pp">For a full definition of the meaning and valid values for
        <span class="Li">&quot;WindowBits&quot;</span> refer to the <i>zlib</i>
        documentation for <i>inflateInit2</i>.</p>
    <p class="Pp">Defaults to MAX_WBITS.</p>
  </dd>
  <dt id="Bufsize~2"><a class="permalink" href="#Bufsize~2"><b>-Bufsize</b></a></dt>
  <dd>Sets the initial size for the inflation buffer. If the buffer has to be
      reallocated to increase the size, it will grow in increments of
      <span class="Li">&quot;Bufsize&quot;</span>.
    <p class="Pp">Default is 4096.</p>
  </dd>
  <dt id="Dictionary~2"><a class="permalink" href="#Dictionary~2"><b>-Dictionary</b></a></dt>
  <dd>The default is no dictionary.</dd>
</dl>
<p class="Pp">Here is an example of using the
    <span class="Li">&quot;inflateInit&quot;</span> optional parameter to
    override the default buffer size.</p>
<p class="Pp"></p>
<pre>
    inflateInit( -Bufsize =&gt; 300 ) ;
</pre>
</section>
<section class="Ss">
<h2 class="Ss"><b>($out, </b><b>$status</b><b>) =
  </b><b>$i</b><b>-&gt;inflate($buffer)</b></h2>
<p class="Pp">Inflates the complete contents of <span class="Li">$buffer</span>.
    The buffer can either be a scalar or a scalar reference.</p>
<p class="Pp">Returns <span class="Li">&quot;Z_OK&quot;</span> if successful and
    <span class="Li">&quot;Z_STREAM_END&quot;</span> if the end of the
    compressed data has been successfully reached. If not successful,
    <span class="Li">$out</span> will be <i>undef</i> and
    <span class="Li">$status</span> will hold the <i>zlib</i> error code.</p>
<p class="Pp">The <span class="Li">$buffer</span> parameter is modified by
    <span class="Li">&quot;inflate&quot;</span>. On completion it will contain
    what remains of the input buffer after inflation. This means that
    <span class="Li">$buffer</span> will be an empty string when the return
    status is <span class="Li">&quot;Z_OK&quot;</span>. When the return status
    is <span class="Li">&quot;Z_STREAM_END&quot;</span> the
    <span class="Li">$buffer</span> parameter will contains what (if anything)
    was stored in the input buffer after the deflated data stream.</p>
<p class="Pp">This feature is useful when processing a file format that
    encapsulates a compressed data stream (e.g. gzip, zip).</p>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><b>$status</b><b> =
  </b><b>$i</b><b>-&gt;inflateSync($buffer)</b></h2>
<p class="Pp">Scans <span class="Li">$buffer</span> until it reaches either a
    <i>full flush point</i> or the end of the buffer.</p>
<p class="Pp">If a <i>full flush point</i> is found,
    <span class="Li">&quot;Z_OK&quot;</span> is returned and
    <span class="Li">$buffer</span> will be have all data up to the flush point
    removed. This can then be passed to the
    <span class="Li">&quot;deflate&quot;</span> method.</p>
<p class="Pp">Any other return code means that a flush point was not found. If
    more data is available, <span class="Li">&quot;inflateSync&quot;</span> can
    be called repeatedly with more compressed data until the flush point is
    found.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><b>$i</b><b>-&gt;dict_adler()</b></h2>
<p class="Pp">Returns the adler32 value for the dictionary.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><b>$i</b><b>-&gt;msg()</b></h2>
<p class="Pp">Returns the last error message generated by zlib.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><b>$i</b><b>-&gt;total_in()</b></h2>
<p class="Pp">Returns the total number of bytes compressed bytes input to
    inflate.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b></b><b>$i</b><b>-&gt;total_out()</b></h2>
<p class="Pp">Returns the total number of uncompressed bytes output from
    inflate.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Example~2"><a class="permalink" href="#Example~2">Example</a></h2>
<p class="Pp">Here is an example of using
    <span class="Li">&quot;inflate&quot;</span>.</p>
<p class="Pp"></p>
<pre>
    use strict ;
    use warnings ;
    
    use Compress::Zlib ;
    
    my $x = inflateInit()
       or die &quot;Cannot create a inflation stream\n&quot; ;
    
    my $input = '' ;
    binmode STDIN;
    binmode STDOUT;
    
    my ($output, $status) ;
    while (read(STDIN, $input, 4096))
    {
        ($output, $status) = $x-&gt;inflate(\$input) ;
    
        print $output
            if $status == Z_OK or $status == Z_STREAM_END ;
    
        last if $status != Z_OK ;
    }
    
    die &quot;inflation failed\n&quot;
        unless $status == Z_STREAM_END ;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CHECKSUM_FUNCTIONS"><a class="permalink" href="#CHECKSUM_FUNCTIONS">CHECKSUM
  FUNCTIONS</a></h1>
<p class="Pp">Two functions are provided by <i>zlib</i> to calculate checksums.
    For the Perl interface, the order of the two parameters in both functions
    has been reversed. This allows both running checksums and one off
    calculations to be done.</p>
<p class="Pp"></p>
<pre>
    $crc = adler32($buffer [,$crc]) ;
    $crc = crc32($buffer [,$crc]) ;
</pre>
<p class="Pp">The buffer parameters can either be a scalar or a scalar
    reference.</p>
<p class="Pp">If the <span class="Li">$crc</span> parameters is
    <span class="Li">&quot;undef&quot;</span>, the crc value will be reset.</p>
<p class="Pp">If you have built this module with zlib 1.2.3 or better, two more
    CRC-related functions are available.</p>
<p class="Pp"></p>
<pre>
    $crc = crc32_combine($crc1, $crc2, $len2);
    $adler = adler32_combine($adler1, $adler2, $len2);
</pre>
<p class="Pp">These functions allow checksums to be merged. Refer to the
    <i>zlib</i> documentation for more details.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Misc"><a class="permalink" href="#Misc">Misc</a></h1>
<section class="Ss">
<h2 class="Ss" id="my_$version_=_"><a class="permalink" href="#my_$version_=_">my
  $version = <b>Compress::Zlib::zlib_version()</b>;</a></h2>
<p class="Pp">Returns the version of the zlib library.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CONSTANTS"><a class="permalink" href="#CONSTANTS">CONSTANTS</a></h1>
<p class="Pp">All the <i>zlib</i> constants are automatically imported when you
    make use of <i>Compress::Zlib</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">IO::Compress::Gzip, IO::Uncompress::Gunzip, IO::Compress::Deflate,
    IO::Uncompress::Inflate, IO::Compress::RawDeflate,
    IO::Uncompress::RawInflate, IO::Compress::Bzip2, IO::Uncompress::Bunzip2,
    IO::Compress::Lzma, IO::Uncompress::UnLzma, IO::Compress::Xz,
    IO::Uncompress::UnXz, IO::Compress::Lzip, IO::Uncompress::UnLzip,
    IO::Compress::Lzop, IO::Uncompress::UnLzop, IO::Compress::Lzf,
    IO::Uncompress::UnLzf, IO::Compress::Zstd, IO::Uncompress::UnZstd,
    IO::Uncompress::AnyInflate, IO::Uncompress::AnyUncompress</p>
<p class="Pp">IO::Compress::FAQ</p>
<p class="Pp">File::GlobMapper, Archive::Zip, Archive::Tar, IO::Zlib</p>
<p class="Pp">For RFC 1950, 1951 and 1952 see
    &lt;http://www.faqs.org/rfcs/rfc1950.html&gt;,
    &lt;http://www.faqs.org/rfcs/rfc1951.html&gt; and
    &lt;http://www.faqs.org/rfcs/rfc1952.html&gt;</p>
<p class="Pp">The <i>zlib</i> compression library was written by Jean-loup
    Gailly <span class="Li">&quot;gzip@prep.ai.mit.edu&quot;</span> and Mark
    Adler <span class="Li">&quot;madler@alumni.caltech.edu&quot;</span>.</p>
<p class="Pp">The primary site for the <i>zlib</i> compression library is
    &lt;http://www.zlib.org&gt;.</p>
<p class="Pp">The primary site for gzip is &lt;http://www.gzip.org&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">This module was written by Paul Marquess,
    <span class="Li">&quot;pmqs@cpan.org&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MODIFICATION_HISTORY"><a class="permalink" href="#MODIFICATION_HISTORY">MODIFICATION
  HISTORY</a></h1>
<p class="Pp">See the Changes file.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">Copyright (c) 1995-2019 Paul Marquess. All rights reserved.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

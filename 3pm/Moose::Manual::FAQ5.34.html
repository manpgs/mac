<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Moose::Manual::FAQ(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Moose::Manual::FAQ(3)</td>
    <td class="head-vol"><a href=".">User Contributed Perl Documentation</a></td>
    <td class="head-rtitle">Moose::Manual::FAQ(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Moose::Manual::FAQ - Frequently asked questions about Moose</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 2.2012</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FREQUENTLY_ASKED_QUESTIONS"><a class="permalink" href="#FREQUENTLY_ASKED_QUESTIONS">FREQUENTLY
  ASKED QUESTIONS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Module_Stability"><a class="permalink" href="#Module_Stability">Module
  Stability</a></h2>
<p class="Pp"><i>Is Moose &quot;production ready&quot;?</i></p>
<p class="Pp">Yes! Many sites with household names are using Moose to build
    high-traffic services. Countless others are using Moose in production. See
    &lt;http://moose.iinteractive.com/about.html#organizations&gt; for a partial
    list.</p>
<p class="Pp">As of this writing, Moose is a dependency of several hundred CPAN
    modules. &lt;https://metacpan.org/requires/module/Moose&gt;</p>
<p class="Pp"><i>Is Moose's API stable?</i></p>
<p class="Pp">Yes. The sugary API, the one 95% of users will interact with, is
    <b>very stable</b>. Any changes will be <b>100% backwards
  compatible</b>.</p>
<p class="Pp">The meta API is less set in stone. We reserve the right to tweak
    parts of it to improve efficiency or consistency. This will not be done
    lightly. We do perform deprecation cycles. We <i>really</i> do not like
    making ourselves look bad by breaking your code. Submitting test cases is
    the best way to ensure that your code is not inadvertently broken by
    refactoring.</p>
<p class="Pp"><i>I heard Moose is slow, is this true?</i></p>
<p class="Pp">Again, this one is tricky, so Yes <i>and</i> No.</p>
<p class="Pp">Firstly, <i>nothing</i> in life is free, and some Moose features
    do cost more than others. It is also the policy of Moose to <b>only charge
    you</b> <b>for the features you use</b>, and to do our absolute best to not
    place any extra burdens on the execution of your code for features you are
    not using. Of course using Moose itself does involve some overhead, but it
    is mostly compile time. At this point we do have some options available for
    getting the speed you need.</p>
<p class="Pp">Currently we provide the option of making your classes immutable
    as a means of boosting speed. This will mean a slightly larger compile time
    cost, but the runtime speed increase (especially in object construction) is
    pretty significant. This can be done with the following code:</p>
<p class="Pp"></p>
<pre>  MyClass-&gt;meta-&gt;make_immutable();
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Constructors"><a class="permalink" href="#Constructors">Constructors</a></h2>
<p class="Pp"><i>How do I write custom constructors with Moose?</i></p>
<p class="Pp">Ideally, you should never write your own
    <span class="Li">&quot;new&quot;</span> method, and should use Moose's other
    features to handle your specific object construction needs. Here are a few
    scenarios, and the Moose way to solve them;</p>
<p class="Pp">If you need to call initialization code post instance
    construction, then use the <span class="Li">&quot;BUILD&quot;</span> method.
    This feature is taken directly from Perl 6. Every
    <span class="Li">&quot;BUILD&quot;</span> method in your inheritance chain
    is called (in the correct order) immediately after the instance is
    constructed. This allows you to ensure that all your superclasses are
    initialized properly as well. This is the best approach to take (when
    possible) because it makes subclassing your class much easier.</p>
<p class="Pp">If you need to affect the constructor's parameters prior to the
    instance actually being constructed, you have a number of options.</p>
<p class="Pp">To change the parameter processing as a whole, you can use the
    <span class="Li">&quot;BUILDARGS&quot;</span> method. The default
    implementation accepts key/value pairs or a hash reference. You can override
    it to take positional args, or any other format</p>
<p class="Pp">To change the handling of individual parameters, there are
    <i>coercions</i> (See the Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion
    for a complete example and explanation of coercions). With coercions it is
    possible to morph argument values into the correct expected types. This
    approach is the most flexible and robust, but does have a slightly higher
    learning curve.</p>
<p class="Pp"><i>How do I make non-Moose constructors work with Moose?</i></p>
<p class="Pp">Usually the correct approach to subclassing a non-Moose class is
    delegation. Moose makes this easy using the
    <span class="Li">&quot;handles&quot;</span> keyword, coercions, and
    <span class="Li">&quot;lazy_build&quot;</span>, so subclassing is often not
    the ideal route.</p>
<p class="Pp">That said, if you really need to inherit from a non-Moose class,
    see Moose::Cookbook::Basics::DateTime_ExtendingNonMooseParent for an example
    of how to do it, or take a look at &quot;MooseX::NonMoose&quot; in
    Moose::Manual::MooseX.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Accessors"><a class="permalink" href="#Accessors">Accessors</a></h2>
<p class="Pp"><i>How do I tell Moose to use get/set accessors?</i></p>
<p class="Pp">The easiest way to accomplish this is to use the
    <span class="Li">&quot;reader&quot;</span> and
    <span class="Li">&quot;writer&quot;</span> attribute options:</p>
<p class="Pp"></p>
<pre>  has 'bar' =&gt; (
      isa    =&gt; 'Baz',
      reader =&gt; 'get_bar',
      writer =&gt; 'set_bar',
  );
</pre>
<p class="Pp">Moose will still take advantage of type constraints, triggers,
    etc. when creating these methods.</p>
<p class="Pp">If you do not like this much typing, and wish it to be a default
    for your classes, please see MooseX::FollowPBP. This extension will allow
    you to write:</p>
<p class="Pp"></p>
<pre>  has 'bar' =&gt; (
      isa =&gt; 'Baz',
      is  =&gt; 'rw',
  );
</pre>
<p class="Pp">Moose will create separate
    <span class="Li">&quot;get_bar&quot;</span> and
    <span class="Li">&quot;set_bar&quot;</span> methods instead of a single
    <span class="Li">&quot;bar&quot;</span> method.</p>
<p class="Pp">If you like <span class="Li">&quot;bar&quot;</span> and
    <span class="Li">&quot;set_bar&quot;</span>, see
    MooseX::SemiAffordanceAccessor.</p>
<p class="Pp">NOTE: This <b>cannot</b> be set globally in Moose, as that would
    break other classes which are built with Moose. You can still save on typing
    by defining a new <span class="Li">&quot;MyApp::Moose&quot;</span> that
    exports Moose's sugar and then turns on MooseX::FollowPBP. See
    Moose::Cookbook::Extending::Mooseish_MooseSugar.</p>
<p class="Pp"><i>How can I inflate/deflate values in accessors?</i></p>
<p class="Pp">Well, the first question to ask is if you actually need both
    inflate and deflate.</p>
<p class="Pp">If you only need to inflate, then we suggest using coercions. Here
    is some basic sample code for inflating a DateTime object:</p>
<p class="Pp"></p>
<pre>  class_type 'DateTime';
  coerce 'DateTime'
      =&gt; from 'Str'
      =&gt; via { DateTime::Format::MySQL-&gt;parse_datetime($_) };
  has 'timestamp' =&gt; (is =&gt; 'rw', isa =&gt; 'DateTime', coerce =&gt; 1);
</pre>
<p class="Pp">This creates a custom type for DateTime objects, then attaches a
    coercion to that type. The <span class="Li">&quot;timestamp&quot;</span>
    attribute is then told to expect a
    <span class="Li">&quot;DateTime&quot;</span> type, and to try to coerce it.
    When a <span class="Li">&quot;Str&quot;</span> type is given to the
    <span class="Li">&quot;timestamp&quot;</span> accessor, it will attempt to
    coerce the value into a <span class="Li">&quot;DateTime&quot;</span> object
    using the code in found in the <span class="Li">&quot;via&quot;</span>
    block.</p>
<p class="Pp">For a more comprehensive example of using coercions, see the
    Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion.</p>
<p class="Pp">If you need to deflate your attribute's value, the current best
    practice is to add an <span class="Li">&quot;around&quot;</span> modifier to
    your accessor:</p>
<p class="Pp"></p>
<pre>  # a timestamp which stores as
  # seconds from the epoch
  has 'timestamp' =&gt; (is =&gt; 'rw', isa =&gt; 'Int');
  around 'timestamp' =&gt; sub {
      my $next = shift;
      my $self = shift;
      return $self-&gt;$next unless @_;
      # assume we get a DateTime object ...
      my $timestamp = shift;
      return $self-&gt;$next( $timestamp-&gt;epoch );
  };
</pre>
<p class="Pp">It is also possible to do deflation using coercion, but this tends
    to get quite complex and require many subtypes. An example of this is
    outside the scope of this document, ask on #moose or send a mail to the
    list.</p>
<p class="Pp">Still another option is to write a custom attribute metaclass,
    which is also outside the scope of this document, but we would be happy to
    explain it on #moose or the mailing list.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Method_Modifiers"><a class="permalink" href="#Method_Modifiers">Method
  Modifiers</a></h2>
<p class="Pp"><i>How can I affect the values in
    </i><span class="Li"><i>@_</i></span><i> using
    </i><span class="Li"><i>&quot;before&quot;</i></span><i>?</i></p>
<p class="Pp">You can't, actually: <span class="Li">&quot;before&quot;</span>
    only runs before the main method, and it cannot easily affect the method's
    execution.</p>
<p class="Pp">You similarly can't use <span class="Li">&quot;after&quot;</span>
    to affect the return value of a method.</p>
<p class="Pp">We limit <span class="Li">&quot;before&quot;</span> and
    <span class="Li">&quot;after&quot;</span> because this lets you write more
    concise code. You do not have to worry about passing
    <span class="Li">@_</span> to the original method, or forwarding its return
    value (being careful to preserve context).</p>
<p class="Pp">The <span class="Li">&quot;around&quot;</span> method modifier has
    neither of these limitations, but is a little more verbose.</p>
<p class="Pp">Alternatively, the MooseX::Mangle extension provides the
    <span class="Li">&quot;mangle_args&quot;</span> function, which does allow
    you to affect <span class="Li">@_</span>.</p>
<p class="Pp"><i>Can I use
    </i><span class="Li"><i>&quot;before&quot;</i></span><i> to stop execution
    of a method?</i></p>
<p class="Pp">Yes, but only if you throw an exception. If this is too drastic a
    measure then we suggest using <span class="Li">&quot;around&quot;</span>
    instead. The <span class="Li">&quot;around&quot;</span> method modifier is
    the only modifier which can gracefully prevent execution of the main method.
    Here is an example:</p>
<p class="Pp"></p>
<pre>    around 'baz' =&gt; sub {
        my $next = shift;
        my ($self, %options) = @_;
        unless ($options-&gt;{bar} eq 'foo') {
            return 'bar';
        }
        $self-&gt;$next(%options);
    };
</pre>
<p class="Pp">By choosing not to call the <span class="Li">$next</span> method,
    you can stop the execution of the main method.</p>
<p class="Pp">Alternatively, the MooseX::Mangle extension provides the
    <span class="Li">&quot;guard&quot;</span> function, which will conditionally
    prevent execution of the original method.</p>
<p class="Pp"><i>Why can't I see return values in an
    </i><span class="Li"><i>&quot;after&quot;</i></span><i> modifier?</i></p>
<p class="Pp">As with the <span class="Li">&quot;before&quot;</span> modifier,
    the <span class="Li">&quot;after&quot;</span> modifier is simply called
    <i>after</i> the main method. It is passed the original contents of
    <span class="Li">@_</span> and <b>not</b> the return values of the main
    method.</p>
<p class="Pp">Again, the arguments are too lengthy as to why this has to be. And
    as with <span class="Li">&quot;before&quot;</span> I recommend using an
    <span class="Li">&quot;around&quot;</span> modifier instead. Here is some
    sample code:</p>
<p class="Pp"></p>
<pre>  around 'foo' =&gt; sub {
      my $next = shift;
      my ($self, @args) = @_;
      my @rv = $next-&gt;($self, @args);
      # do something silly with the return values
      return reverse @rv;
  };
</pre>
<p class="Pp">Alternatively, the MooseX::Mangle extension provides the
    <span class="Li">&quot;mangle_return&quot;</span> function, which allows
    modifying the return values of the original method.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Type_Constraints"><a class="permalink" href="#Type_Constraints">Type
  Constraints</a></h2>
<p class="Pp"><i>How can I provide a custom error message for a type
    constraint?</i></p>
<p class="Pp">Use the <span class="Li">&quot;message&quot;</span> option when
    building the subtype:</p>
<p class="Pp"></p>
<pre>  subtype 'NaturalLessThanTen'
      =&gt; as 'Natural'
      =&gt; where { $_ &lt; 10 }
      =&gt; message { &quot;This number ($_) is not less than ten!&quot; };
</pre>
<p class="Pp">This <span class="Li">&quot;message&quot;</span> block will be
    called when a value fails to pass the
    <span class="Li">&quot;NaturalLessThanTen&quot;</span> constraint check.</p>
<p class="Pp"><i>Can I turn off type constraint checking?</i></p>
<p class="Pp">There's no support for it in the core of Moose yet. This option
    may come in a future release.</p>
<p class="Pp">Meanwhile there's a MooseX extension that allows you to do this on
    a per-attribute basis, and if it doesn't do what you it's easy to write one
    that fits your use case.</p>
<p class="Pp"><i>My coercions stopped working with recent Moose, why did you
    break it?</i></p>
<p class="Pp">Moose 0.76 fixed a case where coercions were being applied even if
    the original constraint passed. This has caused some edge cases to fail
    where people were doing something like</p>
<p class="Pp"></p>
<pre>    subtype 'Address', as 'Str';
    coerce 'Address', from 'Str', via { get_address($_) };
</pre>
<p class="Pp">This is not what they intended, because the type constraint
    <span class="Li">&quot;Address&quot;</span> is too loose in this case. It is
    saying that all strings are Addresses, which is obviously not the case. The
    solution is to provide a <span class="Li">&quot;where&quot;</span> clause
    that properly restricts the type constraint:</p>
<p class="Pp"></p>
<pre>    subtype 'Address', as 'Str', where { looks_like_address($_) };
</pre>
<p class="Pp">This will allow the coercion to apply only to strings that fail to
    look like an Address.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Roles"><a class="permalink" href="#Roles">Roles</a></h2>
<p class="Pp"><i>Why is BUILD not called for my composed roles?</i></p>
<p class="Pp"><span class="Li">&quot;BUILD&quot;</span> is never called in
    composed roles. The primary reason is that roles are <b>not</b> order
    sensitive. Roles are composed in such a way that the order of composition
    does not matter (for information on the deeper theory of this read the
    original traits papers here
    &lt;http://www.iam.unibe.ch/~scg/Research/Traits/&gt;).</p>
<p class="Pp">Because roles are essentially unordered, it would be impossible to
    determine the order in which to execute the
    <span class="Li">&quot;BUILD&quot;</span> methods.</p>
<p class="Pp">As for alternate solutions, there are a couple.</p>
<ul class="Bl-bullet">
  <li>Using a combination of lazy and default in your attributes to defer
      initialization (see the Binary Tree example in the cookbook for a good
      example of lazy/default usage
      Moose::Cookbook::Basics::BinaryTree_AttributeFeatures)</li>
  <li>Use attribute triggers, which fire after an attribute is set, to
      facilitate initialization. These are described in the Moose docs, and
      examples can be found in the test suite.</li>
</ul>
<p class="Pp">In general, roles should not <i>require</i> initialization; they
    should either provide sane defaults or should be documented as needing
    specific initialization. One such way to &quot;document&quot; this is to
    have a separate attribute initializer which is required for the role. Here
    is an example of how to do this:</p>
<p class="Pp"></p>
<pre>  package My::Role;
  use Moose::Role;
  has 'height' =&gt; (
      is      =&gt; 'rw',
      isa     =&gt; 'Int',
      lazy    =&gt; 1,
      default =&gt; sub {
          my $self = shift;
          $self-&gt;init_height;
      }
  );
  requires 'init_height';
</pre>
<p class="Pp">In this example, the role will not compose successfully unless the
    class provides a <span class="Li">&quot;init_height&quot;</span> method.</p>
<p class="Pp">If none of those solutions work, then it is possible that a role
    is not the best tool for the job, and you really should be using classes.
    Or, at the very least, you should reduce the amount of functionality in your
    role so that it does not require initialization.</p>
<p class="Pp"><i>What are traits, and how are they different from roles?</i></p>
<p class="Pp">In Moose, a trait is almost exactly the same thing as a role,
    except that traits typically register themselves, which allows you to refer
    to them by a short name (&quot;Big&quot; vs
  &quot;MyApp::Role::Big&quot;).</p>
<p class="Pp">In Moose-speak, a <i>Role</i> is usually composed into a
    <i>class</i> at compile time, whereas a <i>Trait</i> is usually composed
    into an instance of a class at runtime to add or modify the behavior of
    <b>just that</b> <b>instance</b>.</p>
<p class="Pp">Outside the context of Moose, traits and roles generally mean
    exactly the same thing. The original paper called them traits, but Perl 6
    will call them roles.</p>
<p class="Pp"><i>Can an attribute-generated method (e.g. an accessor) satisfy
    requires?</i></p>
<p class="Pp">Yes, just be sure to consume the role <i>after</i> declaring your
    attribute. &quot;Required Attributes&quot; in Moose::Manual::Roles provides
    an example:</p>
<p class="Pp"></p>
<pre>  package Breakable;
  use Moose::Role;
  requires 'stress';
  package Car;
  use Moose;
  has 'stress' =&gt; ( is  =&gt; 'rw', isa =&gt; 'Int' );
  with 'Breakable';
</pre>
<p class="Pp">If you mistakenly consume the
    <span class="Li">&quot;Breakable&quot;</span> role before declaring your
    <span class="Li">&quot;stress&quot;</span> attribute, you would see an error
    like this:</p>
<p class="Pp"></p>
<pre>  'Breakable' requires the method 'stress' to be implemented by 'Car' at...
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Moose_and_Subroutine_Attributes"><a class="permalink" href="#Moose_and_Subroutine_Attributes">Moose
  and Subroutine Attributes</a></h2>
<p class="Pp"><i>Why don't subroutine attributes I inherited from a superclass
    work?</i></p>
<p class="Pp">Currently when subclassing a module is done at runtime with the
    <span class="Li">&quot;extends&quot;</span> keyword, but attributes are
    checked at compile time by Perl. To make attributes work, you must place
    <span class="Li">&quot;extends&quot;</span> in a
    <span class="Li">&quot;BEGIN&quot;</span> block so that the attribute
    handlers will be available at compile time, like this:</p>
<p class="Pp"></p>
<pre>  BEGIN { extends qw/Foo/ }
</pre>
<p class="Pp">Note that we're talking about Perl's subroutine attributes here,
    not Moose attributes:</p>
<p class="Pp"></p>
<pre>  sub foo : Bar(27) { ... }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Stevan Little &lt;stevan.little@iinteractive.com&gt;</li>
  <li>Dave Rolsky &lt;autarch@urth.org&gt;</li>
  <li>Jesse Luehrs &lt;doy@tozt.net&gt;</li>
  <li>Shawn M Moore &lt;code@sartak.org&gt;</li>
  <li>&#x05D9;&#x05D5;&#x05D1;&#x05DC; &#x05E7;&#x05D5;&#x05D2;'&#x05DE;&#x05DF;
      (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</li>
  <li>Karen Etheridge &lt;ether@cpan.org&gt;</li>
  <li>Florian Ragwitz &lt;rafl@debian.org&gt;</li>
  <li>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</li>
  <li>Chris Prather &lt;chris@prather.org&gt;</li>
  <li>Matt S Trout &lt;mst@shadowcat.co.uk&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This software is copyright (c) 2006 by Infinity Interactive,
  Inc.</p>
<p class="Pp">This is free software; you can redistribute it and/or modify it
    under the same terms as the Perl 5 programming language system itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-11-22</td>
    <td class="foot-os"><a href="..">perl v5.34.0</a></td>
  </tr>
</table>
</body>
</html>

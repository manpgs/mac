<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>autobox(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">autobox(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">autobox(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">autobox - call methods on native types</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
    use autobox;

    # integers

        my $range = 10-&gt;to(1); # [ 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 ]

    # floats

        my $error = 3.1415927-&gt;minus(22/7)-&gt;abs();

    # strings

        my @list = 'SELECT * FROM foo'-&gt;list();
        my $greeting = &quot;Hello, world!&quot;-&gt;upper(); # &quot;HELLO, WORLD!&quot;

        $greeting-&gt;for_each(\&amp;character_handler);

    # arrays and array refs

        my $schwartzian = @_-&gt;map(...)-&gt;sort(...)-&gt;map(...);
        my $hash = [ 'SELECT * FROM foo WHERE id IN (?, ?)', 1, 2 ]-&gt;hash();

    # hashes and hash refs

        { alpha =&gt; 'beta', gamma =&gt; 'vlissides' }-&gt;for_each(...);
        %hash-&gt;keys();

    # code refs

        my $plus_five = (\&amp;add)-&gt;curry()-&gt;(5);
        my $minus_three = sub { $_[0] - $_[1] }-&gt;reverse-&gt;curry-&gt;(3);

    # can, isa, VERSION, import and unimport can be accessed via autobox_class

        42-&gt;autobox_class-&gt;isa('MyNumber')
        say []-&gt;autobox_class-&gt;VERSION
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The autobox pragma allows methods to be called on integers,
    floats, strings, arrays, hashes, and code references in exactly the same
    manner as blessed references.</p>
<p class="Pp">Autoboxing is transparent: values are not blessed into their
    (user-defined) implementation class (unless the method elects to bestow such
    a blessing) - they simply use its methods as though they are.</p>
<p class="Pp">The classes (packages) into which the native types are boxed are
    fully configurable. By default, a method invoked on a non-object value is
    assumed to be defined in a class whose name corresponds to the
    <span class="Li">&quot;ref()&quot;</span> type of that value - or SCALAR if
    the value is a non-reference.</p>
<p class="Pp">This mapping can be overridden by passing key/value pairs to the
    <span class="Li">&quot;use autobox&quot;</span> statement, in which the keys
    represent native types, and the values their associated classes.</p>
<p class="Pp">As with regular objects, autoboxed values are passed as the first
    argument of the specified method. Consequently, given a vanilla
    <span class="Li">&quot;use autobox&quot;</span>:</p>
<p class="Pp"></p>
<pre>
    &quot;Hello, world!&quot;-&gt;upper()
</pre>
<p class="Pp">is invoked as:</p>
<p class="Pp"></p>
<pre>
    SCALAR::upper(&quot;hello, world!&quot;)
</pre>
<p class="Pp">while:</p>
<p class="Pp"></p>
<pre>
    [ 1 .. 10 ]-&gt;for_each(sub { ... })
</pre>
<p class="Pp">resolves to:</p>
<p class="Pp"></p>
<pre>
    ARRAY::for_each([ 1 .. 10 ], sub { ... })
</pre>
<p class="Pp">Values beginning with the array
    <span class="Li">&quot;@&quot;</span> and hash
    <span class="Li">&quot;%&quot;</span> sigils are passed by reference, i.e.
    under the default bindings:</p>
<p class="Pp"></p>
<pre>
    @array-&gt;join(', ')
    @{ ... }-&gt;length()
    %hash-&gt;keys()
    %$hash-&gt;values()
</pre>
<p class="Pp">are equivalent to:</p>
<p class="Pp"></p>
<pre>
    ARRAY::join(\@array, ', ')
    ARRAY::length(\@{ ... })
    HASH::keys(\%hash)
    HASH::values(\%$hash)
</pre>
<p class="Pp">Multiple <span class="Li">&quot;use autobox&quot;</span>
    statements can appear in the same scope. These are merged both
    &quot;horizontally&quot; (i.e. multiple classes can be associated with a
    particular type) and &quot;vertically&quot; (i.e. multiple classes can be
    associated with multiple types).</p>
<p class="Pp">Thus:</p>
<p class="Pp"></p>
<pre>
    use autobox SCALAR =&gt; 'Foo';
    use autobox SCALAR =&gt; 'Bar';
</pre>
<p class="Pp">- associates SCALAR types with a synthetic class whose
    <span class="Li">@ISA</span> includes both Foo and Bar (in that order).</p>
<p class="Pp">Likewise:</p>
<p class="Pp"></p>
<pre>
    use autobox SCALAR =&gt; 'Foo';
    use autobox SCALAR =&gt; 'Bar';
    use autobox ARRAY  =&gt; 'Baz';
</pre>
<p class="Pp">and</p>
<p class="Pp"></p>
<pre>
    use autobox SCALAR =&gt; [ 'Foo', 'Bar' ];
    use autobox ARRAY  =&gt; 'Baz';
</pre>
<p class="Pp">- bind SCALAR types to the Foo and Bar classes and ARRAY types to
    Baz.</p>
<p class="Pp">autobox is lexically scoped, and bindings for an outer scope can
    be extended or countermanded in a nested scope:</p>
<p class="Pp"></p>
<pre>
    {
        use autobox; # default bindings: autobox all native types
        ...

        {
            # appends 'MyScalar' to the @ISA associated with SCALAR types
            use autobox SCALAR =&gt; 'MyScalar';
            ...
        }

        # back to the default (no MyScalar)
        ...
    }
</pre>
<p class="Pp">Autoboxing can be turned off entirely by using the
    <span class="Li">&quot;no&quot;</span> syntax:</p>
<p class="Pp"></p>
<pre>
    {
        use autobox;
        ...
        no autobox;
        ...
    }
</pre>
<p class="Pp">- or can be selectively disabled by passing arguments to the
    <span class="Li">&quot;no autobox&quot;</span> statement:</p>
<p class="Pp"></p>
<pre>
    use autobox; # default bindings

    no autobox qw(SCALAR);

    []-&gt;foo(); # OK: ARRAY::foo([])

    &quot;Hello, world!&quot;-&gt;bar(); # runtime error
</pre>
<p class="Pp">Autoboxing is not performed for barewords i.e.</p>
<p class="Pp"></p>
<pre>
    my $foo = Foo-&gt;new();
</pre>
<p class="Pp">and:</p>
<p class="Pp"></p>
<pre>
    my $foo = new Foo;
</pre>
<p class="Pp">behave as expected.</p>
<p class="Pp">Methods are called on native types by means of the arrow operator.
    As with regular objects, the right hand side of the operator can either be a
    bare method name or a variable containing a method name or subroutine
    reference. Thus the following are all valid:</p>
<p class="Pp"></p>
<pre>
    sub method1 { ... }
    my $method2 = 'some_method';
    my $method3 = sub { ... };
    my $method4 = \&amp;some_method;

    &quot; ... &quot;-&gt;method1();
    [ ... ]-&gt;$method2();
    { ... }-&gt;$method3();
    sub { ... }-&gt;$method4();
</pre>
<p class="Pp">A native type is only associated with a class if the type =&gt;
    class mapping is supplied in the <span class="Li">&quot;use
    autobox&quot;</span> statement. Thus the following will not work:</p>
<p class="Pp"></p>
<pre>
    use autobox SCALAR =&gt; 'MyScalar';

    @array-&gt;some_array_method();
</pre>
<p class="Pp">- as no class is specified for the ARRAY type. Note: the result of
    calling a method on a native type that is not associated with a class is the
    usual runtime error message:</p>
<p class="Pp"></p>
<pre>
    Can't call method &quot;some_array_method&quot; on unblessed reference at ...
</pre>
<p class="Pp">As a convenience, there is one exception to this rule. If
    <span class="Li">&quot;use autobox&quot;</span> is invoked with no arguments
    (ignoring the DEBUG option) the four main native types are associated with
    classes of the same name.</p>
<p class="Pp">Thus:</p>
<p class="Pp"></p>
<pre>
    use autobox;
</pre>
<p class="Pp">- is equivalent to:</p>
<p class="Pp"></p>
<pre>
    use autobox {
        SCALAR =&gt; 'SCALAR',
        ARRAY  =&gt; 'ARRAY',
        HASH   =&gt; 'HASH',
        CODE   =&gt; 'CODE',
    }
</pre>
<p class="Pp">This facilitates one-liners and prototypes:</p>
<p class="Pp"></p>
<pre>
    use autobox;

    sub SCALAR::split { [ split '', $_[0] ] }
    sub ARRAY::length { scalar @{$_[0]} }

    print &quot;Hello, world!&quot;-&gt;split-&gt;length();
</pre>
<p class="Pp">However, using these default bindings is not recommended as
    there's no guarantee that another piece of code won't trample over the same
    namespace/methods.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OPTIONS"><a class="permalink" href="#OPTIONS">OPTIONS</a></h1>
<p class="Pp">A mapping from native types to their user-defined classes can be
    specified by passing a hashref or a list of key/value pairs to the
    <span class="Li">&quot;use autobox&quot;</span> statement.</p>
<p class="Pp">The following example shows the range of valid arguments:</p>
<p class="Pp"></p>
<pre>
    use autobox {
        SCALAR    =&gt; 'MyScalar'                     # class name
        ARRAY     =&gt; 'MyNamespace::',               # class prefix (ending in '::')
        HASH      =&gt; [ 'MyHash', 'MyNamespace::' ], # one or more class names and/or prefixes
        CODE      =&gt; ...,                           # any of the 3 value types above
        INTEGER   =&gt; ...,                           # any of the 3 value types above
        FLOAT     =&gt; ...,                           # any of the 3 value types above
        NUMBER    =&gt; ...,                           # any of the 3 value types above
        STRING    =&gt; ...,                           # any of the 3 value types above
        UNDEF     =&gt; ...,                           # any of the 3 value types above
        UNIVERSAL =&gt; ...,                           # any of the 3 value types above
        DEFAULT   =&gt; ...,                           # any of the 3 value types above
        DEBUG     =&gt; ...                            # boolean or coderef
    }
</pre>
<p class="Pp">The INTEGER, FLOAT, NUMBER, STRING, SCALAR, ARRAY, HASH, CODE,
    UNDEF, DEFAULT and UNIVERSAL options can take three different types of
    value:</p>
<ul class="Bl-bullet">
  <li>A class name e.g.
    <p class="Pp"></p>
    <pre>
    use autobox INTEGER =&gt; 'MyInt';
    </pre>
    <p class="Pp">This binds the specified native type to the specified class.
        All methods invoked on values of type
        <span class="Li">&quot;key&quot;</span> will be dispatched as methods of
        the class specified in the corresponding
        <span class="Li">&quot;value&quot;</span>.</p>
  </li>
  <li>A namespace: this is a class prefix (up to and including the final '::')
      to which the specified type name (INTEGER, FLOAT, STRING &amp;c.) will be
      appended:
    <p class="Pp">Thus:</p>
    <p class="Pp"></p>
    <pre>
    use autobox ARRAY =&gt; 'Prelude::';
    </pre>
    <p class="Pp">is equivalent to:</p>
    <p class="Pp"></p>
    <pre>
    use autobox ARRAY =&gt; 'Prelude::ARRAY';
    </pre>
  </li>
  <li>A reference to an array of class names and/or namespaces. This associates
      multiple classes with the specified type.</li>
</ul>
<section class="Ss">
<h2 class="Ss">DEFAULT</h2>
<p class="Pp">The <span class="Li">&quot;DEFAULT&quot;</span> option specifies
    bindings for any of the four default types (SCALAR, ARRAY, HASH and CODE)
    not supplied in the <span class="Li">&quot;use autobox&quot;</span>
    statement. As with the other options, the
    <span class="Li">&quot;value&quot;</span> corresponding to the
    <span class="Li">&quot;DEFAULT&quot;</span>
    <span class="Li">&quot;key&quot;</span> can be a class name, a namespace, or
    a reference to an array containing one or more class names and/or
    namespaces.</p>
<p class="Pp">Thus:</p>
<p class="Pp"></p>
<pre>
    use autobox {
        STRING  =&gt; 'MyString',
        DEFAULT =&gt; 'MyDefault',
    }
</pre>
<p class="Pp">is equivalent to:</p>
<p class="Pp"></p>
<pre>
    use autobox {
        STRING  =&gt; 'MyString',
        SCALAR  =&gt; 'MyDefault',
        ARRAY   =&gt; 'MyDefault',
        HASH    =&gt; 'MyDefault',
        CODE    =&gt; 'MyDefault',
    }
</pre>
<p class="Pp">Which in turn is equivalent to:</p>
<p class="Pp"></p>
<pre>
    use autobox {
        INTEGER =&gt; 'MyDefault',
        FLOAT   =&gt; 'MyDefault',
        STRING  =&gt; [ 'MyString', 'MyDefault' ],
        ARRAY   =&gt; 'MyDefault',
        HASH    =&gt; 'MyDefault',
        CODE    =&gt; 'MyDefault',
    }
</pre>
<p class="Pp">Namespaces in DEFAULT values have the default type name appended,
    which, in the case of defaulted SCALAR types, is SCALAR rather than INTEGER,
    FLOAT &amp;c.</p>
<p class="Pp">Thus:</p>
<p class="Pp"></p>
<pre>
    use autobox {
        ARRAY   =&gt; 'MyArray',
        HASH    =&gt; 'MyHash',
        CODE    =&gt; 'MyCode',
        DEFAULT =&gt; 'MyNamespace::',
    }
</pre>
<p class="Pp">is equivalent to:</p>
<p class="Pp"></p>
<pre>
    use autobox {
        INTEGER =&gt; 'MyNamespace::SCALAR',
        FLOAT   =&gt; 'MyNamespace::SCALAR',
        STRING  =&gt; 'MyNamespace::SCALAR',
        ARRAY   =&gt; 'MyArray',
        HASH    =&gt; 'MyArray',
        CODE    =&gt; 'MyCode',
    }
</pre>
<p class="Pp">Any of the four default types can be exempted from defaulting to
    the DEFAULT value by supplying a value of undef:</p>
<p class="Pp"></p>
<pre>
    use autobox {
        HASH    =&gt; undef,
        DEFAULT =&gt; 'MyDefault',
    }

    42-&gt;foo # ok: MyDefault::foo
    []-&gt;bar # ok: MyDefault::bar

    %INC-&gt;baz # not ok: runtime error
</pre>
</section>
<section class="Ss">
<h2 class="Ss">UNDEF</h2>
<p class="Pp">The pseudotype, UNDEF, can be used to autobox undefined values.
    These are not autoboxed by default.</p>
<p class="Pp">This doesn't work:</p>
<p class="Pp"></p>
<pre>
    use autobox;

    undef-&gt;foo() # runtime error
</pre>
<p class="Pp">This works:</p>
<p class="Pp"></p>
<pre>
    use autobox UNDEF =&gt; 'MyUndef';

    undef-&gt;foo(); # ok
</pre>
<p class="Pp">So does this:</p>
<p class="Pp"></p>
<pre>
    use autobox UNDEF =&gt; 'MyNamespace::';

    undef-&gt;foo(); # ok
</pre>
</section>
<section class="Ss">
<h2 class="Ss">NUMBER, SCALAR and UNIVERSAL</h2>
<p class="Pp">The virtual types NUMBER, SCALAR and UNIVERSAL function as macros
    or shortcuts which create bindings for their subtypes. The type hierarchy is
    as follows:</p>
<p class="Pp"></p>
<pre>
  UNIVERSAL -+
             |
             +- SCALAR -+
             |          |
             |          +- NUMBER -+
             |          |          |
             |          |          +- INTEGER
             |          |          |
             |          |          +- FLOAT
             |          |
             |          +- STRING
             |
             +- ARRAY
             |
             +- HASH
             |
             +- CODE
</pre>
<p class="Pp">Thus:</p>
<p class="Pp"></p>
<pre>
    use autobox NUMBER =&gt; 'MyNumber';
</pre>
<p class="Pp">is equivalent to:</p>
<p class="Pp"></p>
<pre>
    use autobox {
        INTEGER =&gt; 'MyNumber',
        FLOAT   =&gt; 'MyNumber',
    }
</pre>
<p class="Pp">And:</p>
<p class="Pp"></p>
<pre>
    use autobox SCALAR =&gt; 'MyScalar';
</pre>
<p class="Pp">is equivalent to:</p>
<p class="Pp"></p>
<pre>
    use autobox {
        INTEGER =&gt; 'MyScalar',
        FLOAT   =&gt; 'MyScalar',
        STRING  =&gt; 'MyScalar',
    }
</pre>
<p class="Pp">Virtual types can also be passed to
    <span class="Li">&quot;unimport&quot;</span> via the
    <span class="Li">&quot;no autobox&quot;</span> syntax. This disables
    autoboxing for the corresponding subtypes e.g.</p>
<p class="Pp"></p>
<pre>
    no autobox qw(NUMBER);
</pre>
<p class="Pp">is equivalent to:</p>
<p class="Pp"></p>
<pre>
    no autobox qw(INTEGER FLOAT);
</pre>
<p class="Pp">Virtual type bindings can be mixed with ordinary bindings to
    provide fine-grained control over inheritance and delegation. For
  instance:</p>
<p class="Pp"></p>
<pre>
    use autobox {
        INTEGER =&gt; 'MyInteger',
        NUMBER  =&gt; 'MyNumber',
        SCALAR  =&gt; 'MyScalar',
    }
</pre>
<p class="Pp">would result in the following bindings:</p>
<p class="Pp"></p>
<pre>
    42-&gt;foo              -&gt; [ MyInteger, MyNumber, MyScalar ]
    3.1415927-&gt;bar       -&gt; [ MyNumber, MyScalar ]
    &quot;Hello, world!&quot;-&gt;baz -&gt; [ MyScalar ]
</pre>
<p class="Pp">Note that DEFAULT bindings take precedence over virtual type
    bindings i.e.</p>
<p class="Pp"></p>
<pre>
    use autobox {
        UNIVERSAL =&gt; 'MyUniversal',
        DEFAULT   =&gt; 'MyDefault', # default SCALAR, ARRAY, HASH and CODE before UNIVERSAL
    }
</pre>
<p class="Pp">is equivalent to:</p>
<p class="Pp"></p>
<pre>
  use autobox {
      INTEGER =&gt; [ 'MyDefault', 'MyUniversal' ],
      FLOAT   =&gt; [ 'MyDefault', 'MyUniversal' ], # ... &amp;c.
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss">DEBUG</h2>
<p class="Pp"><span class="Li">&quot;DEBUG&quot;</span> allows the autobox
    bindings for the current scope to be inspected, either by dumping them to
    the console or passing them to a callback function. This allows the computed
    bindings to be seen in &quot;longhand&quot;.</p>
<p class="Pp">The option is ignored if the value corresponding to the
    <span class="Li">&quot;DEBUG&quot;</span> key is false.</p>
<p class="Pp">If the value is a CODE ref, it is called with a reference to the
    hash containing the computed bindings for the current scope.</p>
<p class="Pp">Finally, if <span class="Li">&quot;DEBUG&quot;</span> is true but
    not a CODE ref, the bindings are dumped to STDERR.</p>
<p class="Pp">Thus:</p>
<p class="Pp"></p>
<pre>
    use autobox DEBUG =&gt; 1, ...
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre>
    use autobox DEBUG =&gt; sub { ... }, ...
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre>
    sub my_callback ($) {
        my $hashref = shift;
        ...
    }

    use autobox DEBUG =&gt; \&amp;my_callback, ...
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="import"><a class="permalink" href="#import">import</a></h2>
<p class="Pp">This method sets up autobox bindings for the current lexical
    scope. It can be used to implement autobox extensions i.e. lexically-scoped
    modules that provide autobox bindings for one or more native types without
    requiring calling code to <span class="Li">&quot;use
  autobox&quot;</span>.</p>
<p class="Pp">This is done by subclassing autobox and overriding
    <span class="Li">&quot;import&quot;</span>. This allows extensions to
    effectively translate <span class="Li">&quot;use MyModule&quot;</span> into
    a bespoke <span class="Li">&quot;use autobox&quot;</span> call e.g.:</p>
<p class="Pp"></p>
<pre>
    package String::Trim;

    use base qw(autobox);

    sub import {
        my $class = shift;

        $class-&gt;SUPER::import(
            STRING =&gt; 'String::Trim::String'
        );
    }

    package String::Trim::String;

    sub trim {
        my $string = shift;
        $string =~ s/^\s+//;
        $string =~ s/\s+$//;
        $string;
    }

    1;
</pre>
<p class="Pp">Note that <span class="Li">&quot;trim&quot;</span> is defined in
    an auxiliary class rather than in String::Trim itself to prevent
    String::Trim's own methods (i.e. the methods it inherits from autobox) being
    exposed to <span class="Li">&quot;STRING&quot;</span> types.</p>
<p class="Pp">This module can now be used without a <span class="Li">&quot;use
    autobox&quot;</span> statement to enable the
    <span class="Li">&quot;trim&quot;</span> method in the current lexical scope
    e.g.:</p>
<p class="Pp"></p>
<pre>
    #!/usr/bin/env perl

    use String::Trim;

    print &quot;  Hello, world!  &quot;-&gt;trim();
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="UNIVERSAL_METHODS_FOR_AUTOBOXED_TYPES"><a class="permalink" href="#UNIVERSAL_METHODS_FOR_AUTOBOXED_TYPES">UNIVERSAL
  METHODS FOR AUTOBOXED TYPES</a></h1>
<section class="Ss">
<h2 class="Ss" id="autobox_class"><a class="permalink" href="#autobox_class">autobox_class</a></h2>
<p class="Pp">autobox adds a single method to all autoboxed types:
    <span class="Li">&quot;autobox_class&quot;</span>. This can be used to call
    UNIVERSAL methods i.e. <span class="Li">&quot;can&quot;</span>,
    <span class="Li">&quot;DOES&quot;</span>,
    <span class="Li">&quot;import&quot;</span>,
    <span class="Li">&quot;isa&quot;</span>,
    <span class="Li">&quot;unimport&quot;</span> and
    <span class="Li">&quot;VERSION&quot;</span> e.g.</p>
<p class="Pp"></p>
<pre>
    if (sub { ... }-&gt;autobox_class-&gt;can('curry')) ...
    if (42-&gt;autobox_class-&gt;isa('SCALAR')) ...
</pre>
<p class="Pp">Note: <span class="Li">&quot;autobox_class&quot;</span> must
    <b>always</b> be used when calling these methods. Calling them directly on
    native types produces the same results as calling them with autobox disabled
    e.g.:</p>
<p class="Pp"></p>
<pre>
    42-&gt;isa('NUMBER') # &quot;&quot; (interpeted as &quot;42&quot;-&gt;isa(&quot;NUMBER&quot;))
    []-&gt;can('push')   # Error: Can't call method &quot;can&quot; on unblessed reference
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTS"><a class="permalink" href="#EXPORTS">EXPORTS</a></h1>
<section class="Ss">
<h2 class="Ss" id="type"><a class="permalink" href="#type">type</a></h2>
<p class="Pp">autobox includes an additional module, autobox::universal, which
    exports a single subroutine, <span class="Li">&quot;type&quot;</span>.</p>
<p class="Pp">This sub returns the type of its argument within autobox (which is
    essentially longhand for the type names used within perl). This value is
    used by autobox to associate a method invocant with its designated classes
    e.g.</p>
<p class="Pp"></p>
<pre>
    use autobox::universal qw(type);

    type(&quot;42&quot;)  # STRING
    type(42)    # INTEGER
    type(42.0)  # FLOAT
    type(undef) # UNDEF
</pre>
<p class="Pp">autobox::universal is loaded automatically by autobox, and, as its
    name suggests, can be used to install a universal
    <span class="Li">&quot;type&quot;</span> method for autoboxed values
  e.g.</p>
<p class="Pp"></p>
<pre>
    use autobox UNIVERSAL =&gt; 'autobox::universal';

    42-&gt;type        # INTEGER
    3.1415927-&gt;type # FLOAT
    %ENV-&gt;type      # HASH
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Performance"><a class="permalink" href="#Performance">Performance</a></h2>
<p class="Pp">Calling</p>
<p class="Pp"></p>
<pre>
    &quot;Hello, world!&quot;-&gt;length()
</pre>
<p class="Pp">is slightly slower than the equivalent method call on a
    string-like object, and significantly slower than</p>
<p class="Pp"></p>
<pre>
    length(&quot;Hello, world!&quot;)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Gotchas"><a class="permalink" href="#Gotchas">Gotchas</a></h2>
<p class="Pp"><i>Precedence</i></p>
<p class="Pp">Due to Perl's precedence rules, some autoboxed literals may need
    to be parenthesized:</p>
<p class="Pp">For instance, while this works:</p>
<p class="Pp"></p>
<pre>
    my $curried = sub { ... }-&gt;curry();
</pre>
<p class="Pp">this doesn't:</p>
<p class="Pp"></p>
<pre>
    my $curried = \&amp;foo-&gt;curry();
</pre>
<p class="Pp">The solution is to wrap the reference in parentheses:</p>
<p class="Pp"></p>
<pre>
    my $curried = (\&amp;foo)-&gt;curry();
</pre>
<p class="Pp">The same applies for signed integer and float literals:</p>
<p class="Pp"></p>
<pre>
    # this works
    my $range = 10-&gt;to(1);

    # this doesn't work
    my $range = -10-&gt;to(10);

    # this works
    my $range = (-10)-&gt;to(10);
</pre>
<p class="Pp"><i>print BLOCK</i></p>
<p class="Pp">Perl's special-casing for the <span class="Li">&quot;print BLOCK
    ...&quot;</span> syntax (see perlsub) means that
    <span class="Li">&quot;print { expression() } ...&quot;</span> (where the
    curly brackets denote an anonymous HASH ref) may require some further
    disambiguation:</p>
<p class="Pp"></p>
<pre>
    # this works
    print { foo =&gt; 'bar' }-&gt;foo();

    # and this
    print { 'foo', 'bar' }-&gt;foo();

    # and even this
    print { 'foo', 'bar', @_ }-&gt;foo();

    # but this doesn't
    print { @_ }-&gt;foo() ? 1 : 0
</pre>
<p class="Pp">In the latter case, the solution is to supply something other than
    a HASH ref literal as the first argument to
    <span class="Li">&quot;print()&quot;</span>:</p>
<p class="Pp"></p>
<pre>
    # e.g.
    print STDOUT { @_ }-&gt;foo() ? 1 : 0;

    # or
    my $hashref = { @_ };
    print $hashref-&gt;foo() ? 1 : 0;

    # or
    print '', { @_ }-&gt;foo() ? 1 : 0;

    # or
    print '' . { @_ }-&gt;foo() ? 1 : 0;

    # or even
    { @_ }-&gt;print_if_foo(1, 0);
</pre>
<p class="Pp"><i>eval EXPR</i></p>
<p class="Pp">Like most pragmas, autobox performs operations at compile time,
    and, as a result, runtime string <span class="Li">&quot;eval&quot;</span>s
    are not executed within its scope i.e. this doesn't work:</p>
<p class="Pp"></p>
<pre>
    use autobox;

    eval &quot;42-&gt;foo&quot;;
</pre>
<p class="Pp">The workaround is to use autobox within the
    <span class="Li">&quot;eval&quot;</span> e.g.</p>
<p class="Pp"></p>
<pre>
    eval &lt;&lt;'EOS';
        use autobox;
        42-&gt;foo();
    EOS
</pre>
<p class="Pp">Note that the <span class="Li">&quot;eval BLOCK&quot;</span> form
    works as expected:</p>
<p class="Pp"></p>
<pre>
    use autobox;

    eval { 42-&gt;foo() }; # OK
</pre>
<p class="Pp"><i>Operator Overloading</i></p>
<p class="Pp">Operator overloading via the overload pragma doesn't
    (automatically) work. autobox works by lexically overriding the arrow
    operator. It doesn't bless native types into objects, so overloading - or
    any other kind of &quot;magic&quot; which depends on values being blessed -
    doesn't apply.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">3.0.1</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<ul class="Bl-bullet">
  <li>autobox::Core</li>
  <li>Moose::Autobox</li>
  <li>perl5i</li>
  <li>Scalar::Properties</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">chocolateboy &lt;chocolate@cpan.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">Copyright (c) 2003-2018 by chocolateboy.</p>
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the terms of the Artistic License 2.0
    &lt;http://www.opensource.org/licenses/artistic-license-2.0.php&gt;.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-05-05</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

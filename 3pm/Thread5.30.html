<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Thread(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Thread(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Thread(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Thread - Manipulate threads in Perl (for old code only)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DEPRECATED"><a class="permalink" href="#DEPRECATED">DEPRECATED</a></h1>
<p class="Pp">The <span class="Li">&quot;Thread&quot;</span> module served as
    the frontend to the old-style thread model, called <i>5005threads</i>, that
    was introduced in release 5.005. That model was deprecated, and has been
    removed in version 5.10.</p>
<p class="Pp">For old code and interim backwards compatibility, the
    <span class="Li">&quot;Thread&quot;</span> module has been reworked to
    function as a frontend for the new interpreter threads (<i>ithreads</i>)
    model. However, some previous functionality is not available. Further, the
    data sharing models between the two thread models are completely different,
    and anything to do with data sharing has to be thought differently. With
    <i>ithreads</i>, you must explicitly
    <span class="Li">&quot;share()&quot;</span> variables between the
  threads.</p>
<p class="Pp">You are strongly encouraged to migrate any existing threaded code
    to the new model (i.e., use the <span class="Li">&quot;threads&quot;</span>
    and <span class="Li">&quot;threads::shared&quot;</span> modules) as soon as
    possible.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
<p class="Pp">In Perl 5.005, the thread model was that all data is implicitly
    shared, and shared access to data has to be explicitly synchronized. This
    model is called <i>5005threads</i>.</p>
<p class="Pp">In Perl 5.6, a new model was introduced in which all is was thread
    local and shared access to data has to be explicitly declared. This model is
    called <i>ithreads</i>, for &quot;interpreter threads&quot;.</p>
<p class="Pp">In Perl 5.6, the <i>ithreads</i> model was not available as a
    public API; only as an internal API that was available for extension
    writers, and to implement <b>fork()</b> emulation on Win32 platforms.</p>
<p class="Pp">In Perl 5.8, the <i>ithreads</i> model became available through
    the <span class="Li">&quot;threads&quot;</span> module, and the
    <i>5005threads</i> model was deprecated.</p>
<p class="Pp">In Perl 5.10, the <i>5005threads</i> model was removed from the
    Perl interpreter.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
    use Thread qw(:DEFAULT async yield);

    my $t = Thread-&gt;new(\&amp;start_sub, @start_args);

    $result = $t-&gt;join;
    $t-&gt;detach;

    if ($t-&gt;done) {
        $t-&gt;join;
    }

    if($t-&gt;equal($another_thread)) {
        # ...
    }

    yield();

    my $tid = Thread-&gt;self-&gt;tid;

    lock($scalar);
    lock(@array);
    lock(%hash);

    my @list = Thread-&gt;list;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The <span class="Li">&quot;Thread&quot;</span> module provides
    multithreading support for Perl.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTIONS"><a class="permalink" href="#FUNCTIONS">FUNCTIONS</a></h1>
<dl class="Bl-tag">
  <dt>$thread = Thread-&gt;new(\&amp;start_sub)</dt>
  <dd></dd>
  <dt>$thread = Thread-&gt;new(\&amp;start_sub, LIST)</dt>
  <dd><span class="Li">&quot;new&quot;</span> starts a new thread of execution
      in the referenced subroutine. The optional list is passed as parameters to
      the subroutine. Execution continues in both the subroutine and the code
      after the <span class="Li">&quot;new&quot;</span> call.
    <p class="Pp"><span class="Li">&quot;Thread-&amp;gt;new&quot;</span> returns
        a thread object representing the newly created thread.</p>
  </dd>
  <dt id="lock"><a class="permalink" href="#lock">lock VARIABLE</a></dt>
  <dd><span class="Li">&quot;lock&quot;</span> places a lock on a variable until
      the lock goes out of scope.
    <p class="Pp">If the variable is locked by another thread, the
        <span class="Li">&quot;lock&quot;</span> call will block until it's
        available. <span class="Li">&quot;lock&quot;</span> is recursive, so
        multiple calls to <span class="Li">&quot;lock&quot;</span> are safe--the
        variable will remain locked until the outermost lock on the variable
        goes out of scope.</p>
    <p class="Pp">Locks on variables only affect
        <span class="Li">&quot;lock&quot;</span> calls--they do <i>not</i>
        affect normal access to a variable. (Locks on subs are different, and
        covered in a bit.) If you really, <i>really</i> want locks to block
        access, then go ahead and tie them to something and manage this
        yourself. This is done on purpose. While managing access to variables is
        a good thing, Perl doesn't force you out of its living room...</p>
    <p class="Pp">If a container object, such as a hash or array, is locked, all
        the elements of that container are not locked. For example, if a thread
        does a <span class="Li">&quot;lock @a&quot;</span>, any other thread
        doing a <span class="Li">&quot;lock($a[12])&quot;</span> won't
      block.</p>
    <p class="Pp">Finally, <span class="Li">&quot;lock&quot;</span> will
        traverse up references exactly <i>one</i> level.
        <span class="Li">&quot;lock(\$a)&quot;</span> is equivalent to
        <span class="Li">&quot;lock($a)&quot;</span>, while
        <span class="Li">&quot;lock(\\$a)&quot;</span> is not.</p>
  </dd>
  <dt id="async"><a class="permalink" href="#async">async BLOCK;</a></dt>
  <dd><span class="Li">&quot;async&quot;</span> creates a thread to execute the
      block immediately following it. This block is treated as an anonymous sub,
      and so must have a semi-colon after the closing brace. Like
      <span class="Li">&quot;Thread-&amp;gt;new&quot;</span>,
      <span class="Li">&quot;async&quot;</span> returns a thread object.</dd>
  <dt id="Thread"><a class="permalink" href="#Thread">Thread-&gt;self</a></dt>
  <dd>The <span class="Li">&quot;Thread-&gt;self&quot;</span> function returns a
      thread object that represents the thread making the
      <span class="Li">&quot;Thread-&gt;self&quot;</span> call.</dd>
  <dt id="Thread~2"><a class="permalink" href="#Thread~2">Thread-&gt;list</a></dt>
  <dd>Returns a list of all non-joined, non-detached Thread objects.</dd>
  <dt id="cond_wait"><a class="permalink" href="#cond_wait">cond_wait
    VARIABLE</a></dt>
  <dd>The <span class="Li">&quot;cond_wait&quot;</span> function takes a
      <b>locked</b> variable as a parameter, unlocks the variable, and blocks
      until another thread does a
      <span class="Li">&quot;cond_signal&quot;</span> or
      <span class="Li">&quot;cond_broadcast&quot;</span> for that same locked
      variable. The variable that <span class="Li">&quot;cond_wait&quot;</span>
      blocked on is relocked after the
      <span class="Li">&quot;cond_wait&quot;</span> is satisfied. If there are
      multiple threads <span class="Li">&quot;cond_wait&quot;</span>ing on the
      same variable, all but one will reblock waiting to re-acquire the lock on
      the variable. (So if you're only using
      <span class="Li">&quot;cond_wait&quot;</span> for synchronization, give up
      the lock as soon as possible.)</dd>
  <dt id="cond_signal"><a class="permalink" href="#cond_signal">cond_signal
    VARIABLE</a></dt>
  <dd>The <span class="Li">&quot;cond_signal&quot;</span> function takes a
      locked variable as a parameter and unblocks one thread that's
      <span class="Li">&quot;cond_wait&quot;</span>ing on that variable. If more
      than one thread is blocked in a
      <span class="Li">&quot;cond_wait&quot;</span> on that variable, only one
      (and which one is indeterminate) will be unblocked.
    <p class="Pp">If there are no threads blocked in a
        <span class="Li">&quot;cond_wait&quot;</span> on the variable, the
        signal is discarded.</p>
  </dd>
  <dt id="cond_broadcast"><a class="permalink" href="#cond_broadcast">cond_broadcast
    VARIABLE</a></dt>
  <dd>The <span class="Li">&quot;cond_broadcast&quot;</span> function works
      similarly to <span class="Li">&quot;cond_signal&quot;</span>.
      <span class="Li">&quot;cond_broadcast&quot;</span>, though, will unblock
      <b>all</b> the threads that are blocked in a
      <span class="Li">&quot;cond_wait&quot;</span> on the locked variable,
      rather than only one.</dd>
  <dt id="yield"><a class="permalink" href="#yield">yield</a></dt>
  <dd>The <span class="Li">&quot;yield&quot;</span> function allows another
      thread to take control of the CPU. The exact results are
      implementation-dependent.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<dl class="Bl-tag">
  <dt id="join"><a class="permalink" href="#join">join</a></dt>
  <dd><span class="Li">&quot;join&quot;</span> waits for a thread to end and
      returns any values the thread exited with.
      <span class="Li">&quot;join&quot;</span> will block until the thread has
      ended, though it won't block if the thread has already terminated.
    <p class="Pp">If the thread being <span class="Li">&quot;join&quot;</span>ed
        <span class="Li">&quot;die&quot;</span>d, the error it died with will be
        returned at this time. If you don't want the thread performing the
        <span class="Li">&quot;join&quot;</span> to die as well, you should
        either wrap the <span class="Li">&quot;join&quot;</span> in an
        <span class="Li">&quot;eval&quot;</span> or use the
        <span class="Li">&quot;eval&quot;</span> thread method instead of
        <span class="Li">&quot;join&quot;</span>.</p>
  </dd>
  <dt id="detach"><a class="permalink" href="#detach">detach</a></dt>
  <dd><span class="Li">&quot;detach&quot;</span> tells a thread that it is never
      going to be joined i.e. that all traces of its existence can be removed
      once it stops running. Errors in detached threads will not be visible
      anywhere - if you want to catch them, you should use
      <span class="Li">$SIG</span>{__DIE__} or something like that.</dd>
  <dt id="equal"><a class="permalink" href="#equal">equal</a></dt>
  <dd><span class="Li">&quot;equal&quot;</span> tests whether two thread objects
      represent the same thread and returns true if they do.</dd>
  <dt id="tid"><a class="permalink" href="#tid">tid</a></dt>
  <dd>The <span class="Li">&quot;tid&quot;</span> method returns the tid of a
      thread. The tid is a monotonically increasing integer assigned when a
      thread is created. The main thread of a program will have a tid of zero,
      while subsequent threads will have tids assigned starting with one.</dd>
  <dt id="done"><a class="permalink" href="#done">done</a></dt>
  <dd>The <span class="Li">&quot;done&quot;</span> method returns true if the
      thread you're checking has finished, and false otherwise.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="DEFUNCT"><a class="permalink" href="#DEFUNCT">DEFUNCT</a></h1>
<p class="Pp">The following were implemented with <i>5005threads</i>, but are no
    longer available with <i>ithreads</i>.</p>
<dl class="Bl-tag">
  <dt id="lock("><a class="permalink" href="#lock(">lock(\&amp;sub)</a></dt>
  <dd>With 5005threads, you could also <span class="Li">&quot;lock&quot;</span>
      a sub such that any calls to that sub from another thread would block
      until the lock was released.
    <p class="Pp">Also, subroutines could be declared with the
        <span class="Li">&quot;:locked&quot;</span> attribute which would
        serialize access to the subroutine, but allowed different threads
        non-simultaneous access.</p>
  </dd>
  <dt id="eval"><a class="permalink" href="#eval">eval</a></dt>
  <dd>The <span class="Li">&quot;eval&quot;</span> method wrapped an
      <span class="Li">&quot;eval&quot;</span> around a
      <span class="Li">&quot;join&quot;</span>, and so waited for a thread to
      exit, passing along any values the thread might have returned and placing
      any errors into <span class="Li">$@</span>.</dd>
  <dt id="flags"><a class="permalink" href="#flags">flags</a></dt>
  <dd>The <span class="Li">&quot;flags&quot;</span> method returned the flags
      for the thread - an integer value corresponding to the internal flags for
      the thread.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">threads, threads::shared, Thread::Queue, Thread::Semaphore</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

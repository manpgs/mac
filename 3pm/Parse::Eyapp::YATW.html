<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Parse::Eyapp::YATW(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Parse::Eyapp::YATW(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Parse::Eyapp::YATW(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Parse::Eyapp::YATW - Tree transformation objects</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
  #!/usr/bin/perl -w
  use strict;
  use Rule6;
  use Parse::Eyapp::YATW;

  my %BinaryOperation = (PLUS=&gt;'+', MINUS =&gt; '-', TIMES=&gt;'*', DIV =&gt; '/');

  sub set_terminfo {
    no warnings;
    *TERMINAL::info = sub { $_[0]{attr} };
  }
  sub is_foldable {
    my ($op, $left, $right);
    return 0 unless defined($op = $BinaryOperation{ref($_[0])});
    return 0 unless ($left = $_[0]-&gt;child(0), $left-&gt;isa('NUM'));
    return 0 unless ($right = $_[0]-&gt;child(1), $right-&gt;isa('NUM'));

    my $leftnum = $left-&gt;child(0)-&gt;{attr};
    my $rightnum = $right-&gt;child(0)-&gt;{attr};
    $left-&gt;child(0)-&gt;{attr} = eval &quot;$leftnum $op $rightnum&quot;;
    $_[0] = $left;
  }

  my $parser = new Rule6();
  my $input = &quot;2*3&quot;;
  my $t = $parser-&gt;Run(\$input);
  &amp;set_terminfo;
  print &quot;\n***** Before ******\n&quot;;
  print $t-&gt;str;
  my $p = Parse::Eyapp::YATW-&gt;new(PATTERN =&gt; \&amp;is_foldable);
  $p-&gt;s($t);
  print &quot;\n***** After ******\n&quot;;
  print $t-&gt;str.&quot;\n&quot;;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="INTRODUCTION"><a class="permalink" href="#INTRODUCTION">INTRODUCTION</a></h1>
<p class="Pp"><span class="Li">&quot;Parse::Eyapp:YATW&quot;</span> objects
    implement tree transformations. They have two attributes
    <span class="Li">&quot;PATTERN&quot;</span> and
    <span class="Li">&quot;NAME&quot;</span>.
    <span class="Li">&quot;PATTERN&quot;</span> is a reference to the code
    implementing the transformation. <span class="Li">&quot;NAME&quot;</span> is
    the name of the transformation.</p>
<p class="Pp">Though usually you build a transformation by means of Treeregexp
    programs you can directly invoke the method
    <span class="Li">&quot;new&quot;</span> to build a tree transformation. A
    transformation object can be built from a function that conforms to the YATW
    tree transformation call protocol</p>
<p class="Pp">For a subroutine <span class="Li">&quot;pattern_sub&quot;</span>
    to work as a YATW tree transformation - as subroutine
    <span class="Li">&quot;is_foldable&quot;</span> in the SYNOPSIS section -
    has to conform to the following call description:</p>
<p class="Pp"></p>
<pre>
  pattern_sub(
      $_[0],  # Node being visited
      $_[1],  # Father of this node
      $index, # Index of this node in @Father-&gt;children
      $self,  # The YATW pattern object
  );
</pre>
<p class="Pp">The <span class="Li">&quot;pattern_sub&quot;</span> must return
    TRUE if matched and FALSE otherwise.</p>
<p class="Pp">The function <span class="Li">&quot;is_foldable&quot;</span> in
    the SYNOPSIS section (file
    <span class="Li">&quot;examples/YATW/foldrule6.pl&quot;</span>) holds the
    properties to be a YATW tree transformation</p>
<p class="Pp"></p>
<pre>
     1    sub is_foldable {
     2      my ($op, $left, $right);
     3  
     4      return 0 unless defined($op = $BinaryOperation{ref($_[0])});
     5      return 0 unless ($left = $_[0]-&gt;child(0), $left-&gt;isa('NUM'));
     6      return 0 unless ($right = $_[0]-&gt;child(1), $right-&gt;isa('NUM'));
     7  
     8      my $leftnum = $left-&gt;child(0)-&gt;{attr};
     9      my $rightnum = $right-&gt;child(0)-&gt;{attr};
    10      $left-&gt;child(0)-&gt;{attr} = eval &quot;$leftnum $op $rightnum&quot;;
    11      $_[0] = $left;
    12    }
</pre>
<p class="Pp">First, checks that the current node is one of
    <span class="Li">&quot;PLUS&quot;</span>,
    <span class="Li">&quot;MINUS&quot;</span>,
    <span class="Li">&quot;TIMES&quot;</span> or
    <span class="Li">&quot;DIV&quot;</span> (line 4). Then checks that both
    children are <span class="Li">&quot;NUM&quot;</span>bers (lines 5 and 6). In
    such case proceeds to modify its left child with the result of operating
    both children (line 10). The matching tree is finally substituted by its
    left child (line 11).</p>
<p class="Pp">This is the output of the program in the SYNOPSIS section:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ eyapp Rule6.yp; foldrule6.pl

  ***** Before ******
  TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3]))
  ***** After ******
  NUM(TERMINAL[6])
</pre>
<p class="Pp">Follows the grammar description file in
    <span class="Li">&quot;Rule6.yp&quot;</span>:</p>
<p class="Pp"></p>
<pre>
  pl@nereida:~/LEyapp/examples$ cat -n Rule6.yp
     1  %{
     2  use Data::Dumper;
     3  %}
     4  %right  '='
     5  %left   '-' '+'
     6  %left   '*' '/'
     7  %left   NEG
     8  %tree
     9
    10  %%
    11  line: exp  { $_[1] }
    12  ;
    13
    14  exp:      %name NUM
    15              NUM
    16          | %name VAR
    17            VAR
    18          | %name ASSIGN
    19            VAR '=' exp
    20          | %name PLUS
    21            exp '+' exp
    22          | %name MINUS
    23            exp '-' exp
    24          | %name TIMES
    25            exp '*' exp
    26          | %name DIV
    27            exp '/' exp
    28          | %name UMINUS
    29            '-' exp %prec NEG
    30          |   '(' exp ')'  { $_[2] } /* Let us simplify a bit the tree */
    31  ;
    32
    33  %%
    34
    35  use Tail2;
</pre>
<p class="Pp">The module <span class="Li">&quot;Tail2&quot;</span> in file
    <span class="Li">&quot;examples/Tail2.pm&quot;</span> implements the lexical
    analyzer plus the <span class="Li">&quot;error&quot;</span> and
    <span class="Li">&quot;run&quot;</span> methods.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Parse::Eyapp:YATW__Methods"><a class="permalink" href="#Parse::Eyapp:YATW__Methods">Parse::Eyapp:YATW
  Methods</a></h1>
<p class="Pp"><span class="Li">&quot;Parse::Eyapp:YATW&quot;</span> objects
    represent tree transformations. They carry the information of what nodes
    match and how to modify them.</p>
<section class="Ss">
<h2 class="Ss" id="Parse::Eyapp::YATW"><a class="permalink" href="#Parse::Eyapp::YATW">Parse::Eyapp::YATW-&gt;new</a></h2>
<p class="Pp">Builds a treeregexp transformation object. Though usually you
    build a transformation by means of Treeregexp programs you can directly
    invoke the method to build a tree transformation. A transformation object
    can be built from a function that conforms to the YATW tree transformation
    call protocol (see the section &quot;The YATW Tree Transformation Call
    Protocol&quot;). Follows an example (file
    <span class="Li">&quot;examples/12ts_simplify_with_s.pl&quot;</span>):</p>
<p class="Pp"></p>
<pre>
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; \
        sed -ne '68,$p' 12ts_simplify_with_s.pl | cat -n
  1  sub is_code {
  2    my $self = shift; # tree
  3
  4    # After the shift $_[0] is the father, $_[1] the index
  5    if ((ref($self) eq 'CODE')) {
  6      splice(@{$_[0]-&gt;{children}}, $_[1], 1);
  7      return 1;
  8    }
  9    return 0;
 10  }
 11
 12  Parse::Eyapp-&gt;new_grammar(
 13    input=&gt;$translationscheme,
 14    classname=&gt;'Calc',
 15    firstline =&gt;7,
 16  );
 17  my $parser = Calc-&gt;new();                # Create the parser
 18
 19  $parser-&gt;YYData-&gt;{INPUT} = &quot;2*-3\n&quot;;  print &quot;2*-3\n&quot;; # Set the input
 20  my $t = $parser-&gt;Run;                    # Parse it
 21  print $t-&gt;str.&quot;\n&quot;;
 22  my $p = Parse::Eyapp::YATW-&gt;new(PATTERN =&gt; \&amp;is_code);
 23  $p-&gt;s($t);
 24  { no warnings; # make attr info available only for this display
 25    local *TERMINAL::info = sub { $_[0]{attr} };
 26    print $t-&gt;str.&quot;\n&quot;;
 27  }
</pre>
<p class="Pp">After the <span class="Li">&quot;Parse::Eyapp::YATW&quot;</span>
    object <span class="Li">$p</span> is built at line 22 the call to method
    <span class="Li">&quot;$p-&gt;s($t)&quot;</span> applies the transformation
    <span class="Li">&quot;is_code&quot;</span> using a bottom-up traversing of
    the tree <span class="Li">$t</span>. The achieved effect is the elimination
    of <span class="Li">&quot;CODE&quot;</span> references in the translation
    scheme tree. When executed the former code produces:</p>
<p class="Pp"></p>
<pre>
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; 12ts_simplify_with_s.pl
 2*-3
 EXP(TIMES(NUM(TERMINAL,CODE),TERMINAL,UMINUS(TERMINAL,NUM(TERMINAL,CODE),CODE),CODE),CODE)
 EXP(TIMES(NUM(TERMINAL[2]),TERMINAL[*],UMINUS(TERMINAL[-],NUM(TERMINAL[3]))))
</pre>
<p class="Pp">The file <span class="Li">&quot;foldrule6.pl&quot;</span> in the
    <span class="Li">&quot;examples/&quot;</span> distribution directory gives
    you another example:</p>
<p class="Pp"></p>
<pre>
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; cat -n foldrule6.pl
   1  #!/usr/bin/perl -w
   2  use strict;
   3  use Rule6;
   4  use Parse::Eyapp::YATW;
   5
   6  my %BinaryOperation = (PLUS=&gt;'+', MINUS =&gt; '-', TIMES=&gt;'*', DIV =&gt; '/');
   7
   8  sub set_terminfo {
   9    no warnings;
  10    *TERMINAL::info = sub { $_[0]{attr} };
  11  }
  12  sub is_foldable {
  13    my ($op, $left, $right);
  14    return 0 unless defined($op = $BinaryOperation{ref($_[0])});
  15    return 0 unless ($left = $_[0]-&gt;child(0), $left-&gt;isa('NUM'));
  16    return 0 unless ($right = $_[0]-&gt;child(1), $right-&gt;isa('NUM'));
  17
  18    my $leftnum = $left-&gt;child(0)-&gt;{attr};
  19    my $rightnum = $right-&gt;child(0)-&gt;{attr};
  20    $left-&gt;child(0)-&gt;{attr} = eval &quot;$leftnum $op $rightnum&quot;;
  21    $_[0] = $left;
  22  }
  23
  24  my $parser = new Rule6();
  25  $parser-&gt;YYData-&gt;{INPUT} = &quot;2*3&quot;;
  26  my $t = $parser-&gt;Run;
  27  &amp;set_terminfo;
  28  print &quot;\n***** Before ******\n&quot;;
  29  print $t-&gt;str;
  30  my $p = Parse::Eyapp::YATW-&gt;new(PATTERN =&gt; \&amp;is_foldable);
  31  $p-&gt;s($t);
  32  print &quot;\n***** After ******\n&quot;;
  33  print $t-&gt;str.&quot;\n&quot;;
</pre>
<p class="Pp">when executed produces:</p>
<p class="Pp"></p>
<pre>
 nereida:~/src/perl/YappWithDefaultAction/examples&gt; foldrule6.pl

 ***** Before ******
 TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3]))
 ***** After ******
 NUM(TERMINAL[6])
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The_"><a class="permalink" href="#The_">The YATW Tree
  Transformation Call Protocol</a></h2>
<p class="Pp">For a subroutine <span class="Li">&quot;pattern_sub&quot;</span>
    to work as a YATW tree transformation - as subroutines
    <span class="Li">&quot;is_foldable&quot;</span> and
    <span class="Li">&quot;is_code&quot;</span> above - has to conform to the
    following call description:</p>
<p class="Pp"></p>
<pre>
  pattern_sub(
      $_[0],  # Node being visited
      $_[1],  # Father of this node
      $index, # Index of this node in @Father-&gt;children
      $self,  # The YATW pattern object
  );
</pre>
<p class="Pp">The <span class="Li">&quot;pattern_sub&quot;</span> must return
    TRUE if matched and FALSE otherwise.</p>
<p class="Pp">The protocol may change in the near future. Avoid using other
    information than the fact that the first argument is the node being
  visited.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Parse::Eyapp::YATW~2"><a class="permalink" href="#Parse::Eyapp::YATW~2">Parse::Eyapp::YATW-&gt;buildpatterns</a></h2>
<p class="Pp">Works as <span class="Li">&quot;Parse::Eyapp-&gt;new&quot;</span>
    but receives an array of subs conforming to the YATW Tree Transformation
    Call Protocol.</p>
<p class="Pp"></p>
<pre>
  our @all = Parse::Eyapp::YATW-&gt;buildpatt(\&amp;delete_code, \&amp;delete_tokens);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$yatw"><a class="permalink" href="#$yatw">$yatw-&gt;delete</a></h2>
<p class="Pp">The root of the tree that is currently matched by the YATW
    transformation <span class="Li">$yatw</span> will be deleted from the tree
    as soon as is safe. That usually means when the processing of their siblings
    is finished. The following example (taken from file
    <span class="Li">&quot;examples/13ts_simplify_with_delete.pl&quot;</span> in
    the Parse::Eyapp distribution) illustrates how to eliminate CODE and
    syntactic terminals from the syntax tree:</p>
<p class="Pp"></p>
<pre>
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ \
        sed -ne '62,$p' 13ts_simplify_with_delete.pl | cat -n
  1  sub not_useful {
  2    my $self = shift; # node
  3    my $pat = $_[2];  # get the YATW object
  4
  5    (ref($self) eq 'CODE') or ((ref($self) eq 'TERMINAL') and ($self-&gt;{token} eq $self-&gt;{attr}))
  6      or do { return 0 };
  7    $pat-&gt;delete();
  8    return 1;
  9  }
 10
 11  Parse::Eyapp-&gt;new_grammar(
 12    input=&gt;$translationscheme,
 13    classname=&gt;'Calc',
 14    firstline =&gt;7,
 15  );
 16  my $parser = Calc-&gt;new();                # Create the parser
 17
 18  $parser-&gt;YYData-&gt;{INPUT} = &quot;2*3\n&quot;; print $parser-&gt;YYData-&gt;{INPUT};
 19  my $t = $parser-&gt;Run;                    # Parse it
 20  print $t-&gt;str.&quot;\n&quot;;                      # Show the tree
 21  my $p = Parse::Eyapp::YATW-&gt;new(PATTERN =&gt; \&amp;not_useful); 
 22  $p-&gt;s($t);                               # Delete nodes
 23  print $t-&gt;str.&quot;\n&quot;;                      # Show the tree
</pre>
<p class="Pp">when executed we get the following output:</p>
<p class="Pp"></p>
<pre>
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ 13ts_simplify_with_delete.pl
 2*3
 EXP(TIMES(NUM(TERMINAL[2],CODE),TERMINAL[*],NUM(TERMINAL[3],CODE),CODE))
 EXP(TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$yatw~2"><a class="permalink" href="#$yatw~2">$yatw-&gt;unshift</a></h2>
<p class="Pp">The call <span class="Li">&quot;$yatw-&gt;unshift($b)&quot;</span>
    safely unshifts (inserts at the beginning) the node
    <span class="Li">$b</span> in the list of its siblings of the node that
    matched (i.e in the list of siblings of <span class="Li">$_[0]</span>). The
    following example shows a YATW transformation
    <span class="Li">&quot;insert_child&quot;</span> that illustrates the use of
    <span class="Li">&quot;unshift&quot;</span> (file
    <span class="Li">&quot;examples/26delete_with_trreereg.pl&quot;</span>):</p>
<p class="Pp"></p>
<pre>
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ \
         sed -ne '70,$p' 26delete_with_trreereg.pl | cat -n
  1  my $transform = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
  2
  3      delete_code : CODE =&gt; { $delete_code-&gt;delete() }
  4
  5      {
  6        sub not_semantic {
  7          my $self = shift;
  8          return  1 if ((ref($self) eq 'TERMINAL') and ($self-&gt;{token} eq $self-&gt;{attr}));
  9          return 0;
 10        }
 11      }
 12
 13      delete_tokens : TERMINAL and { not_semantic($TERMINAL) } =&gt; {
 14        $delete_tokens-&gt;delete();
 15      }
 16
 17      insert_child : TIMES(NUM(TERMINAL), NUM(TERMINAL)) =&gt; {
 18        my $b = Parse::Eyapp::Node-&gt;new( 'UMINUS(TERMINAL)',
 19          sub { $_[1]-&gt;{attr} = '4.5' }); # The new node will be a sibling of TIMES
 20
 21        $insert_child-&gt;unshift($b); 
 22      }
 23    },
 24  )-&gt;generate();
 25
 26  Parse::Eyapp-&gt;new_grammar(
 27    input=&gt;$translationscheme,
 28    classname=&gt;'Calc',
 29    firstline =&gt;7,
 30  );
 31  my $parser = Calc-&gt;new();                # Create the parser
 32
 33  $parser-&gt;YYData-&gt;{INPUT} = &quot;2*3\n&quot;; print $parser-&gt;YYData-&gt;{INPUT}; # Set the input
 34  my $t = $parser-&gt;Run;                # Parse it
 35  print $t-&gt;str.&quot;\n&quot;;                        # Show the tree
 36  # Get the AST
 37  our ($delete_tokens, $delete_code);
 38  $t-&gt;s($delete_tokens, $delete_code);
 39  print $t-&gt;str.&quot;\n&quot;;                        # Show the tree
 40  our $insert_child;
 41  $insert_child-&gt;s($t);
 42  print $t-&gt;str.&quot;\n&quot;;                        # Show the tree
</pre>
<p class="Pp">When is executed the program produces the following output:</p>
<p class="Pp"></p>
<pre>
 pl@nereida:~/src/perl/YappWithDefaultAction/examples$ 26delete_with_trreereg.pl
 2*3
 EXP(TIMES(NUM(TERMINAL[2],CODE),TERMINAL[*],NUM(TERMINAL[3],CODE),CODE))
 EXP(TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
 EXP(UMINUS(TERMINAL[4.5]),TIMES(NUM(TERMINAL[2]),NUM(TERMINAL[3])))
</pre>
<p class="Pp">Don't try to take advantage that the transformation sub receives
    in <span class="Li">$_[1]</span> a reference to the father (see the section
    &quot;The YATW Tree Transformation Call Protocol&quot;) and do something
    like:</p>
<p class="Pp"></p>
<pre>
  unshift $_[1]-&gt;{children}, $b
</pre>
<p class="Pp">it is unsafe.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$yatw~3"><a class="permalink" href="#$yatw~3">$yatw-&gt;insert_before</a></h2>
<p class="Pp">A call to
    <span class="Li">&quot;$yatw-&gt;insert_before($node)&quot;</span> safely
    inserts <span class="Li">$node</span> in the list of siblings of
    <span class="Li">$_[0]</span> just before <span class="Li">$_[0]</span>
    (i.e. the node that matched with <span class="Li">$yatw</span>). The
    following example (see file
    <span class="Li">&quot;examples/YATW/moveinvariantoutofloopcomplexformula.pl&quot;</span>)
    illustrates its use:</p>
<p class="Pp"></p>
<pre>
  my $p = Parse::Eyapp::Treeregexp-&gt;new( STRING =&gt; q{
    moveinvariant: WHILE(VAR($b), BLOCK(@a, ASSIGN($x, $e), @c)) 
         and { is_invariant($ASSIGN, $WHILE) } =&gt; {
           my $assign = $ASSIGN;
           $BLOCK-&gt;delete($ASSIGN);
           $moveinvariant-&gt;insert_before($assign);
         }
    },
  );
</pre>
<p class="Pp">Here the <span class="Li">&quot;ASSIGN($x, $e)&quot;</span>
    subtree - if is loop invariant - will be moved to the list of siblings of
    <span class="Li">$WHILE</span> just before the
    <span class="Li">$WHILE</span>. Thus a program like</p>
<p class="Pp"></p>
<pre>
  &quot;a =1000; c = 1; while (a) { c = c*a; b = 5; a = a-1 }\n&quot;
</pre>
<p class="Pp">is transformed in s.t. like:</p>
<p class="Pp"></p>
<pre>
  &quot;a =1000; c = 1; b = 5; while (a) { c = c*a; a = a-1 }\n&quot;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TREE_MATCHING_AND_TREE_SUBSTITUTION"><a class="permalink" href="#TREE_MATCHING_AND_TREE_SUBSTITUTION">TREE
  MATCHING AND TREE SUBSTITUTION</a></h1>
<p class="Pp">See the documentation in Parse::Eyapp::treematchingtut</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<ul class="Bl-bullet">
  <li>The project home is at &lt;http://code.google.com/p/parse-eyapp/&gt;. Use
      a subversion client to anonymously check out the latest project source
      code:
    <p class="Pp"></p>
    <pre>
   svn checkout http://parse-eyapp.googlecode.com/svn/trunk/ parse-eyapp-read-only
    </pre>
  </li>
  <li>The tutorial <i>Parsing Strings and Trees with</i>
      <span class="Li">&quot;Parse::Eyapp&quot;</span> (An Introduction to
      Compiler Construction in seven pages) in
      &lt;http://nereida.deioc.ull.es/~pl/eyapsimple/&gt;</li>
  <li>Parse::Eyapp, Parse::Eyapp::eyapplanguageref, Parse::Eyapp::debuggingtut,
      Parse::Eyapp::defaultactionsintro, Parse::Eyapp::translationschemestut,
      Parse::Eyapp::Driver, Parse::Eyapp::Node, Parse::Eyapp::YATW,
      Parse::Eyapp::Treeregexp, Parse::Eyapp::Scope, Parse::Eyapp::Base,
      Parse::Eyapp::datagenerationtut</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf&gt;</li>
  <li>The pdf file in
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf&gt;</li>
  <li>perldoc eyapp,</li>
  <li>perldoc treereg,</li>
  <li>perldoc vgg,</li>
  <li>The Syntax Highlight file for vim at
      &lt;http://www.vim.org/scripts/script.php?script_id=2453&gt; and
      &lt;http://nereida.deioc.ull.es/~vim/&gt;</li>
  <li><i>Analisis Lexico y Sintactico</i>, (Notes for a course in compiler
      construction) by Casiano Rodriguez-Leon. Available at
      &lt;http://nereida.deioc.ull.es/~pl/perlexamples/&gt; Is the more complete
      and reliable source for Parse::Eyapp. However is in Spanish.</li>
  <li>Parse::Yapp,</li>
  <li>Man pages of <i>yacc</i>(1) and <i>bison</i>(1),
      &lt;http://www.delorie.com/gnu/docs/bison/bison.html&gt;</li>
  <li>Language::AttributeGrammar</li>
  <li>Parse::RecDescent.</li>
  <li>HOP::Parser</li>
  <li>HOP::Lexer</li>
  <li>ocamlyacc tutorial at
      &lt;http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex-ocamlyacc/ocamlyacc-tutorial/ocamlyacc-tutorial.html&gt;</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="REFERENCES"><a class="permalink" href="#REFERENCES">REFERENCES</a></h1>
<ul class="Bl-bullet">
  <li>The classic Dragon's book <i>Compilers: Principles, Techniques, and
      Tools</i> by Alfred V. Aho, Ravi Sethi and Jeffrey D. Ullman
      (Addison-Wesley 1986)</li>
  <li><i>CS2121: The Implementation and Power of Programming Languages</i> (See
      &lt;http://www.cs.man.ac.uk/~pjj&gt;,
      &lt;http://www.cs.man.ac.uk/~pjj/complang/g2lr.html&gt; and
      &lt;http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html&gt;) by Pete Jinks</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
<ul class="Bl-bullet">
  <li>Hal Finkel &lt;http://www.halssoftware.com/&gt;</li>
  <li>G. Williams &lt;http://kasei.us/&gt;</li>
  <li>Thomas L. Shinnick &lt;http://search.cpan.org/~tshinnic/&gt;</li>
  <li>Frank Leray</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Casiano Rodriguez-Leon (casiano@ull.es)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGMENTS"><a class="permalink" href="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</a></h1>
<p class="Pp">This work has been supported by CEE (FEDER) and the Spanish
    Ministry of <i>Educacion y Ciencia</i> through <i>Plan Nacional I+D+I</i>
    number TIN2005-08818-C04-04 (ULL::OPLINK project
    &lt;http://www.oplink.ull.es/&gt;). Support from Gobierno de Canarias was
    through GC02210601 (<i>Grupos Consolidados</i>). The University of La Laguna
    has also supported my work in many ways and for many years.</p>
<p class="Pp">A large percentage of code is verbatim taken from Parse::Yapp
    1.05. The author of Parse::Yapp is Francois Desarmenien.</p>
<p class="Pp">I wish to thank Francois Desarmenien for his Parse::Yapp module,
    to my students at La Laguna and to the Perl Community. Thanks to the people
    who have contributed to improve the module (see &quot;CONTRIBUTORS&quot; in
    Parse::Eyapp). Thanks to Larry Wall for giving us Perl. Special thanks to
    Juana.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENCE_AND_COPYRIGHT"><a class="permalink" href="#LICENCE_AND_COPYRIGHT">LICENCE
  AND COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 2006-2008 Casiano Rodriguez-Leon (casiano@ull.es).
    All rights reserved.</p>
<p class="Pp">Parse::Yapp copyright is of Francois Desarmenien, all rights
    reserved. 1998-2001</p>
<p class="Pp">These modules are free software; you can redistribute it and/or
    modify it under the same terms as Perl itself. See perlartistic.</p>
<p class="Pp">This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. </p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2012-03-23</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

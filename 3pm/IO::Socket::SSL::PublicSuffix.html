<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>IO::Socket::SSL::PublicSuffix(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">IO::Socket::SSL::PublicSuffix(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">IO::Socket::SSL::PublicSuffix(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">IO::Socket::SSL::PublicSuffix - provide access to Mozilla's list
    of effective TLD names</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
    # use builtin default
    use IO::Socket::SSL::PublicSuffix;
    $ps = IO::Socket::SSL::PublicSuffix-&gt;default;

    # load from string
    $ps = IO::Socket::SSL::PublicSuffix-&gt;from_string(&quot;*.uk\n*&quot;);

    # load from file or file handle
    $ps = IO::Socket::SSL::PublicSuffix-&gt;from_file($filename);
    $ps = IO::Socket::SSL::PublicSuffix-&gt;from_file(\*STDIN);


    # --- string in -&gt; string out
    # $rest -&gt; whatever.host
    # $tld  -&gt; co.uk
    my ($rest,$tld) = $ps-&gt;public_suffix('whatever.host.co.uk');
    my $tld = $ps-&gt;public_suffix('whatever.host.co.uk');

    # $root_domain -&gt; host.co.uk
    my $root_domain = $ps-&gt;public_suffix('whatever.host.co.uk', 1);

    # --- array in -&gt; array out
    # $rest -&gt; [qw(whatever host)]
    # $tld  -&gt; [qw(co uk)]
    my ($rest,$tld) = $ps-&gt;public_suffix([qw(whatever host co uk)]);

 ----

    # To update this file with the current list:
    perl -MIO::Socket::SSL::PublicSuffix -e 'IO::Socket::SSL::PublicSuffix::update_self_from_url()'
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module uses the list of effective top level domain names from
    the mozilla project to determine the public top level domain for a given
    hostname.</p>
<section class="Ss">
<h2 class="Ss" id="Method"><a class="permalink" href="#Method">Method</a></h2>
<dl class="Bl-tag">
  <dt id="class"><a class="permalink" href="#class">class-&gt;default(%args)</a></dt>
  <dd>Returns object with builtin default.
      <span class="Li">&quot;min_suffix&quot;</span> can be given in
      <span class="Li">%args</span> to specify the minimal suffix, default is
    1.</dd>
  <dt id="class~2"><a class="permalink" href="#class~2">class-&gt;from_string(string,%args)</a></dt>
  <dd>Returns object with configuration from string. See method
      <span class="Li">&quot;default&quot;</span> for
      <span class="Li">%args</span>.</dd>
  <dt id="class~3"><a class="permalink" href="#class~3">class-&gt;from_file(
    file name| file handle, %args )</a></dt>
  <dd>Returns object with configuration from file or file handle. See method
      <span class="Li">&quot;default&quot;</span> for
      <span class="Li">%args</span>.</dd>
  <dt>$self-&gt;public_suffix( $host|\@host, [ $add ] )</dt>
  <dd>In array context the function returns the non-tld part and the tld part of
      the given hostname, in scalar context only the tld part. It adds
      <span class="Li">$add</span> parts of the non-tld part to the tld, e.g.
      with <span class="Li">&quot;$add=1&quot;</span> it will return the root
      domain.
    <p class="Pp">If there were no explicit matches against the public suffix
        configuration it will fall back to a suffix of length 1.</p>
    <p class="Pp">The function accepts a string or an array-ref (e.g. host split
        by <span class="Li">&quot;.&quot;</span>). In the first case it will
        return string(s), in the latter case array-ref(s).</p>
    <p class="Pp">International hostnames or labels can be in ASCII (IDNA form
        starting with <span class="Li">&quot;xn--&quot;</span>) or unicode. In
        the latter case an IDNA handling library like Net::IDN:::Encode,
        Net::LibIDN or recent versions of URI need to be installed.</p>
  </dd>
  <dt>($self|class)-&gt;can_idn</dt>
  <dd>Returns true if IDN support is available.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="FILES"><a class="permalink" href="#FILES">FILES</a></h1>
<p class="Pp">http://publicsuffix.org/list/effective_tld_names.dat</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Domain::PublicSuffix, Mozilla::PublicSuffix</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<pre>
 Q: Why yet another module, we already have L&lt;Domain::PublicSuffix&gt; and
    L&lt;Mozilla::PublicSuffix&gt;.
 A: Because the public suffix data change more often than these modules do,
    IO::Socket::SSL needs this list and it is more easy this way to keep it
    up-to-date.
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Steffen Ullrich</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-03-31</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

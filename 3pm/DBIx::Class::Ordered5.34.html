<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>DBIx::Class::Ordered(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBIx::Class::Ordered(3)</td>
    <td class="head-vol"><a href=".">User Contributed Perl Documentation</a></td>
    <td class="head-rtitle">DBIx::Class::Ordered(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">DBIx::Class::Ordered - Modify the position of objects in an
    ordered list.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">Create a table for your ordered data.</p>
<p class="Pp"></p>
<pre>  CREATE TABLE items (
    item_id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    position INTEGER NOT NULL
  );
</pre>
<p class="Pp">Optionally, add one or more columns to specify groupings, allowing
    you to maintain independent ordered lists within one table:</p>
<p class="Pp"></p>
<pre>  CREATE TABLE items (
    item_id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    position INTEGER NOT NULL,
    group_id INTEGER NOT NULL
  );
</pre>
<p class="Pp">Or even</p>
<p class="Pp"></p>
<pre>  CREATE TABLE items (
    item_id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    position INTEGER NOT NULL,
    group_id INTEGER NOT NULL,
    other_group_id INTEGER NOT NULL
  );
</pre>
<p class="Pp">In your Schema or DB class add &quot;Ordered&quot; to the top of
    the component list.</p>
<p class="Pp"></p>
<pre>  __PACKAGE__-&gt;load_components(qw( Ordered ... ));
</pre>
<p class="Pp">Specify the column that stores the position number for each
  row.</p>
<p class="Pp"></p>
<pre>  package My::Item;
  __PACKAGE__-&gt;position_column('position');
</pre>
<p class="Pp">If you are using one grouping column, specify it as follows:</p>
<p class="Pp"></p>
<pre>  __PACKAGE__-&gt;grouping_column('group_id');
</pre>
<p class="Pp">Or if you have multiple grouping columns:</p>
<p class="Pp"></p>
<pre>  __PACKAGE__-&gt;grouping_column(['group_id', 'other_group_id']);
</pre>
<p class="Pp">That's it, now you can change the position of your objects.</p>
<p class="Pp"></p>
<pre>  #!/use/bin/perl
  use My::Item;
  my $item = My::Item-&gt;create({ name=&gt;'Matt S. Trout' });
  # If using grouping_column:
  my $item = My::Item-&gt;create({ name=&gt;'Matt S. Trout', group_id=&gt;1 });
  my $rs = $item-&gt;siblings();
  my @siblings = $item-&gt;siblings();
  my $sibling;
  $sibling = $item-&gt;first_sibling();
  $sibling = $item-&gt;last_sibling();
  $sibling = $item-&gt;previous_sibling();
  $sibling = $item-&gt;next_sibling();
  $item-&gt;move_previous();
  $item-&gt;move_next();
  $item-&gt;move_first();
  $item-&gt;move_last();
  $item-&gt;move_to( $position );
  $item-&gt;move_to_group( 'groupname' );
  $item-&gt;move_to_group( 'groupname', $position );
  $item-&gt;move_to_group( {group_id=&gt;'groupname', 'other_group_id=&gt;'othergroupname'} );
  $item-&gt;move_to_group( {group_id=&gt;'groupname', 'other_group_id=&gt;'othergroupname'}, $position );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module provides a simple interface for modifying the ordered
    position of DBIx::Class objects.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTO_UPDATE"><a class="permalink" href="#AUTO_UPDATE">AUTO
  UPDATE</a></h1>
<p class="Pp">All of the move_* methods automatically update the rows involved
    in the query. This is not configurable and is due to the fact that if you
    move a record it always causes other records in the list to be updated.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="position_column"><a class="permalink" href="#position_column">position_column</a></h2>
<pre>  __PACKAGE__-&gt;position_column('position');
</pre>
<p class="Pp">Sets and retrieves the name of the column that stores the
    positional value of each record. Defaults to &quot;position&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="grouping_column"><a class="permalink" href="#grouping_column">grouping_column</a></h2>
<pre>  __PACKAGE__-&gt;grouping_column('group_id');
</pre>
<p class="Pp">This method specifies a column to limit all queries in this module
    by. This effectively allows you to have multiple ordered lists within the
    same table.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="null_position_value"><a class="permalink" href="#null_position_value">null_position_value</a></h2>
<pre>  __PACKAGE__-&gt;null_position_value(undef);
</pre>
<p class="Pp">This method specifies a value of &quot;position_column&quot; which
    <b>would</b> <b>never be assigned to a row</b> during normal operation. When
    a row is moved, its position is set to this value temporarily, so that any
    unique constraints can not be violated. This value defaults to 0, which
    should work for all cases except when your positions do indeed start from
  0.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="siblings"><a class="permalink" href="#siblings">siblings</a></h2>
<pre>  my $rs = $item-&gt;siblings();
  my @siblings = $item-&gt;siblings();
</pre>
<p class="Pp">Returns an <b>ordered</b> resultset of all other objects in the
    same group excluding the one you called it on.</p>
<p class="Pp">The ordering is a backwards-compatibility artifact - if you need a
    resultset with no ordering applied use
    <span class="Li">&quot;_siblings&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="previous_siblings"><a class="permalink" href="#previous_siblings">previous_siblings</a></h2>
<pre>  my $prev_rs = $item-&gt;previous_siblings();
  my @prev_siblings = $item-&gt;previous_siblings();
</pre>
<p class="Pp">Returns a resultset of all objects in the same group positioned
    before the object on which this method was called.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="next_siblings"><a class="permalink" href="#next_siblings">next_siblings</a></h2>
<pre>  my $next_rs = $item-&gt;next_siblings();
  my @next_siblings = $item-&gt;next_siblings();
</pre>
<p class="Pp">Returns a resultset of all objects in the same group positioned
    after the object on which this method was called.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="previous_sibling"><a class="permalink" href="#previous_sibling">previous_sibling</a></h2>
<pre>  my $sibling = $item-&gt;previous_sibling();
</pre>
<p class="Pp">Returns the sibling that resides one position back. Returns 0 if
    the current object is the first one.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="first_sibling"><a class="permalink" href="#first_sibling">first_sibling</a></h2>
<pre>  my $sibling = $item-&gt;first_sibling();
</pre>
<p class="Pp">Returns the first sibling object, or 0 if the first sibling is
    this sibling.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="next_sibling"><a class="permalink" href="#next_sibling">next_sibling</a></h2>
<pre>  my $sibling = $item-&gt;next_sibling();
</pre>
<p class="Pp">Returns the sibling that resides one position forward. Returns 0
    if the current object is the last one.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="last_sibling"><a class="permalink" href="#last_sibling">last_sibling</a></h2>
<pre>  my $sibling = $item-&gt;last_sibling();
</pre>
<p class="Pp">Returns the last sibling, or 0 if the last sibling is this
    sibling.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="move_previous"><a class="permalink" href="#move_previous">move_previous</a></h2>
<pre>  $item-&gt;move_previous();
</pre>
<p class="Pp">Swaps position with the sibling in the position previous in the
    list. Returns 1 on success, and 0 if the object is already the first
  one.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="move_next"><a class="permalink" href="#move_next">move_next</a></h2>
<pre>  $item-&gt;move_next();
</pre>
<p class="Pp">Swaps position with the sibling in the next position in the list.
    Returns 1 on success, and 0 if the object is already the last in the
  list.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="move_first"><a class="permalink" href="#move_first">move_first</a></h2>
<pre>  $item-&gt;move_first();
</pre>
<p class="Pp">Moves the object to the first position in the list. Returns 1 on
    success, and 0 if the object is already the first.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="move_last"><a class="permalink" href="#move_last">move_last</a></h2>
<pre>  $item-&gt;move_last();
</pre>
<p class="Pp">Moves the object to the last position in the list. Returns 1 on
    success, and 0 if the object is already the last one.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="move_to"><a class="permalink" href="#move_to">move_to</a></h2>
<pre>  $item-&gt;move_to( $position );
</pre>
<p class="Pp">Moves the object to the specified position. Returns 1 on success,
    and 0 if the object is already at the specified position.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="move_to_group"><a class="permalink" href="#move_to_group">move_to_group</a></h2>
<pre>  $item-&gt;move_to_group( $group, $position );
</pre>
<p class="Pp">Moves the object to the specified position of the specified group,
    or to the end of the group if <span class="Li">$position</span> is undef. 1
    is returned on success, and 0 is returned if the object is already at the
    specified position of the specified group.</p>
<p class="Pp"><span class="Li">$group</span> may be specified as a single scalar
    if only one grouping column is in use, or as a hashref of column =&gt; value
    pairs if multiple grouping columns are in use.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="insert"><a class="permalink" href="#insert">insert</a></h2>
<p class="Pp">Overrides the DBIC <b>insert()</b> method by providing a default
    position number. The default will be the number of rows in the table +1,
    thus positioning the new record at the last position.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="update"><a class="permalink" href="#update">update</a></h2>
<p class="Pp">Overrides the DBIC <b>update()</b> method by checking for a change
    to the position and/or group columns. Movement within a group or to another
    group is handled by repositioning the appropriate siblings. Position
    defaults to the end of a new group if it has been changed to undef.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="delete"><a class="permalink" href="#delete">delete</a></h2>
<p class="Pp">Overrides the DBIC <b>delete()</b> method by first moving the
    object to the last position, then deleting it, thus ensuring the integrity
    of the positions.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS_FOR_EXTENDING_ORDERED"><a class="permalink" href="#METHODS_FOR_EXTENDING_ORDERED">METHODS
  FOR EXTENDING ORDERED</a></h1>
<p class="Pp">You would want to override the methods below if you use sparse
    (non-linear) or non-numeric position values. This can be useful if you are
    working with preexisting non-normalised position data, or if you need to
    work with materialized path columns.</p>
<section class="Ss">
<h2 class="Ss" id="_position_from_value"><a class="permalink" href="#_position_from_value">_position_from_value</a></h2>
<pre>  my $num_pos = $item-&gt;_position_from_value ( $pos_value )
</pre>
<p class="Pp">Returns the <b>absolute numeric position</b> of an object with a
    <b>position</b> <b>value</b> set to <span class="Li">$pos_value</span>. By
    default simply returns <span class="Li">$pos_value</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_position_value"><a class="permalink" href="#_position_value">_position_value</a></h2>
<pre>  my $pos_value = $item-&gt;_position_value ( $pos )
</pre>
<p class="Pp">Returns the <b>value</b> of &quot;position_column&quot; of the
    object at numeric position <span class="Li">$pos</span>. By default simply
    returns <span class="Li">$pos</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_initial_position_value"><a class="permalink" href="#_initial_position_value">_initial_position_value</a></h2>
<pre>  __PACKAGE__-&gt;_initial_position_value(0);
</pre>
<p class="Pp">This method specifies a <b>value</b> of
    &quot;position_column&quot; which is assigned to the first inserted element
    of a group, if no value was supplied at insertion time. All subsequent
    values are derived from this one by &quot;_next_position_value&quot; below.
    Defaults to 1.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_next_position_value"><a class="permalink" href="#_next_position_value">_next_position_value</a></h2>
<pre>  my $new_value = $item-&gt;_next_position_value ( $position_value )
</pre>
<p class="Pp">Returns a position <b>value</b> that would be considered
    <span class="Li">&quot;next&quot;</span> with regards to
    <span class="Li">$position_value</span>. Can be pretty much anything, given
    that <span class="Li">&quot;$position_value &lt; $new_value&quot;</span>
    where <span class="Li">&quot;&lt;&quot;</span> is the SQL comparison
    operator (usually works fine on strings). The default method expects
    <span class="Li">$position_value</span> to be numeric, and returns
    <span class="Li">&quot;$position_value + 1&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="_shift_siblings"><a class="permalink" href="#_shift_siblings">_shift_siblings</a></h2>
<pre>  $item-&gt;_shift_siblings ($direction, @between)
</pre>
<p class="Pp">Shifts all siblings with <b>positions values</b> in the range
    <span class="Li">@between</span> (inclusive) by one position as specified by
    <span class="Li">$direction</span> (left if &lt; 0,
  <br/>
   right if &gt; 0). By default simply increments/decrements each
    &quot;position_column&quot; value by 1, doing so in a way as to not violate
    any existing constraints.</p>
<p class="Pp">Note that if you override this method and have unique constraints
    including the &quot;position_column&quot; the shift is not a trivial task.
    Refer to the implementation source of the default method for more
    information.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Resultset_Methods"><a class="permalink" href="#Resultset_Methods">Resultset
  Methods</a></h2>
<p class="Pp">Note that all Insert/Create/Delete overrides are happening on
    DBIx::Class::Row methods only. If you use the DBIx::Class::ResultSet
    versions of update or delete, all logic present in this module will be
    bypassed entirely (possibly resulting in a broken order-tree). Instead
    always use the update_all and delete_all methods, which will invoke the
    corresponding row method on every member of the given resultset.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Race_Condition_on_Insert"><a class="permalink" href="#Race_Condition_on_Insert">Race
  Condition on Insert</a></h2>
<p class="Pp">If a position is not specified for an insert, a position will be
    chosen based either on &quot;_initial_position_value&quot; or
    &quot;_next_position_value&quot;, depending if there are already some items
    in the current group. The space of time between the necessary selects and
    insert introduces a race condition. Having unique constraints on your
    position/group columns, and using transactions (see &quot;txn_do&quot; in
    DBIx::Class::Storage) will prevent such race conditions going
  undetected.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Multiple_Moves"><a class="permalink" href="#Multiple_Moves">Multiple
  Moves</a></h2>
<p class="Pp">If you have multiple same-group result objects already loaded from
    storage, you need to be careful when executing
    <span class="Li">&quot;move_*&quot;</span> operations on them: without a
    &quot;position_column&quot; reload the &quot;_position_value&quot; of the
    &quot;siblings&quot; will be out of sync with the underlying storage.</p>
<p class="Pp">Starting from version <span class="Li">0.082800</span> DBIC will
    implicitly perform such reloads when the
    <span class="Li">&quot;move_*&quot;</span> happens as a part of a
    transaction (a good example of such situation is
    <span class="Li">&quot;$ordered_resultset-&gt;delete_all&quot;</span>).</p>
<p class="Pp">If it is not possible for you to wrap the entire call-chain in a
    transaction, you will need to call &quot;discard_changes&quot; in
    DBIx::Class::Row to get an object up-to-date before proceeding, otherwise
    undefined behavior will result.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Default_Values"><a class="permalink" href="#Default_Values">Default
  Values</a></h2>
<p class="Pp">Using a database defined default_value on one of your group
    columns could result in the position not being assigned correctly.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="FURTHER_QUESTIONS?"><a class="permalink" href="#FURTHER_QUESTIONS?">FURTHER
  QUESTIONS?</a></h1>
<p class="Pp">Check the list of additional DBIC resources.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This module is free software copyright by the DBIx::Class (DBIC)
    authors. You can redistribute it and/or modify it under the same terms as
    the DBIx::Class library.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-01-29</td>
    <td class="foot-os"><a href="..">perl v5.34.0</a></td>
  </tr>
</table>
</body>
</html>

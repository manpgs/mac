<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>DBIx::Class::SQLMaker::LimitDialects(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBIx::Class::SQLMaker::LimitDialects(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBIx::Class::SQLMaker::LimitDialects(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">DBIx::Class::SQLMaker::LimitDialects - SQL::Abstract::Limit-like
    functionality for DBIx::Class::SQLMaker</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This module replicates a lot of the functionality originally found
    in SQL::Abstract::Limit. While simple limits would work as-is, the more
    complex dialects that require e.g. subqueries could not be reliably
    implemented without taking full advantage of the metadata locked within
    DBIx::Class::ResultSource classes. After reimplementation of close to 80% of
    the SQL::Abstract::Limit functionality it was deemed more practical to
    simply make an independent DBIx::Class-specific limit-dialect provider.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SQL_LIMIT_DIALECTS"><a class="permalink" href="#SQL_LIMIT_DIALECTS">SQL
  LIMIT DIALECTS</a></h1>
<p class="Pp">Note that the actual implementations listed below never use
    <span class="Li">&quot;*&quot;</span> literally. Instead proper re-aliasing
    of selectors and order criteria is done, so that the limit dialect are safe
    to use on joined resultsets with clashing column names.</p>
<p class="Pp">Currently the provided dialects are:</p>
<section class="Ss">
<h2 class="Ss" id="LimitOffset"><a class="permalink" href="#LimitOffset">LimitOffset</a></h2>
<pre> SELECT ... LIMIT $limit OFFSET $offset
</pre>
<p class="Pp">Supported by <b>PostgreSQL</b> and <b>SQLite</b></p>
</section>
<section class="Ss">
<h2 class="Ss" id="LimitXY"><a class="permalink" href="#LimitXY">LimitXY</a></h2>
<pre> SELECT ... LIMIT $offset, $limit
</pre>
<p class="Pp">Supported by <b>MySQL</b> and any SQL::Statement based DBD</p>
</section>
<section class="Ss">
<h2 class="Ss" id="RowNumberOver"><a class="permalink" href="#RowNumberOver">RowNumberOver</a></h2>
<pre> SELECT * FROM (
  SELECT *, ROW_NUMBER() OVER( ORDER BY ... ) AS RNO__ROW__INDEX FROM (
   SELECT ...
  )
 ) WHERE RNO__ROW__INDEX BETWEEN ($offset+1) AND ($limit+$offset)
</pre>
<p class="Pp">ANSI standard Limit/Offset implementation. Supported by <b>DB2</b>
    and <b>MSSQL &gt;= 2005</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="SkipFirst"><a class="permalink" href="#SkipFirst">SkipFirst</a></h2>
<pre> SELECT SKIP $offset FIRST $limit * FROM ...
</pre>
<p class="Pp">Supported by <b>Informix</b>, almost like LimitOffset. According
    to SQL::Abstract::Limit <span class="Li">&quot;... SKIP $offset LIMIT $limit
    ...&quot;</span> is also supported.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="FirstSkip"><a class="permalink" href="#FirstSkip">FirstSkip</a></h2>
<pre> SELECT FIRST $limit SKIP $offset * FROM ...
</pre>
<p class="Pp">Supported by <b>Firebird/Interbase</b>, reverse of SkipFirst.
    According to SQL::Abstract::Limit <span class="Li">&quot;... ROWS $limit TO
    $offset ...&quot;</span> is also supported.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="RowNum"><a class="permalink" href="#RowNum">RowNum</a></h2>
<p class="Pp">Depending on the resultset attributes one of:</p>
<p class="Pp"></p>
<pre> SELECT * FROM (
  SELECT *, ROWNUM AS rownum__index FROM (
   SELECT ...
  ) WHERE ROWNUM &lt;= ($limit+$offset)
 ) WHERE rownum__index &gt;= ($offset+1)
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre> SELECT * FROM (
  SELECT *, ROWNUM AS rownum__index FROM (
    SELECT ...
  )
 ) WHERE rownum__index BETWEEN ($offset+1) AND ($limit+$offset)
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre> SELECT * FROM (
    SELECT ...
  ) WHERE ROWNUM &lt;= ($limit+1)
</pre>
<p class="Pp">Supported by <b>Oracle</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Top"><a class="permalink" href="#Top">Top</a></h2>
<pre> SELECT * FROM
 SELECT TOP $limit FROM (
  SELECT TOP $limit FROM (
   SELECT TOP ($limit+$offset) ...
  ) ORDER BY $reversed_original_order
 ) ORDER BY $original_order
</pre>
<p class="Pp">Unreliable Top-based implementation, supported by <b>MSSQL &lt;
    2005</b>.</p>
<p class="Pp"><i>CAVEAT</i></p>
<p class="Pp">Due to its implementation, this limit dialect returns <b>incorrect
    results</b> when <span class="Li">$limit</span>+$offset &gt; total amount of
    rows in the resultset.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="FetchFirst"><a class="permalink" href="#FetchFirst">FetchFirst</a></h2>
<pre> SELECT * FROM
 (
 SELECT * FROM (
  SELECT * FROM (
   SELECT * FROM ...
  ) ORDER BY $reversed_original_order
    FETCH FIRST $limit ROWS ONLY
 ) ORDER BY $original_order
   FETCH FIRST $limit ROWS ONLY
 )
</pre>
<p class="Pp">Unreliable FetchFirst-based implementation, supported by <b>IBM
    DB2 &lt;= V5R3</b>.</p>
<p class="Pp"><i>CAVEAT</i></p>
<p class="Pp">Due to its implementation, this limit dialect returns <b>incorrect
    results</b> when <span class="Li">$limit</span>+$offset &gt; total amount of
    rows in the resultset.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="GenericSubQ"><a class="permalink" href="#GenericSubQ">GenericSubQ</a></h2>
<pre> SELECT * FROM (
  SELECT ...
 )
 WHERE (
  SELECT COUNT(*) FROM $original_table cnt WHERE cnt.id &lt; $original_table.id
 ) BETWEEN $offset AND ($offset+$rows-1)
</pre>
<p class="Pp">This is the most evil limit &quot;dialect&quot; (more of a hack)
    for <i>really</i> stupid databases. It works by ordering the set by some
    unique column, and calculating the amount of rows that have a less-er value
    (thus emulating a &quot;RowNum&quot;-like index). Of course this implies the
    set can only be ordered by a single unique column.</p>
<p class="Pp">Also note that this technique can be and often is
    <b>excruciatingly slow</b>. You may have much better luck using
    &quot;software_limit&quot; in DBIx::Class::ResultSet instead.</p>
<p class="Pp">Currently used by <b>Sybase ASE</b>, due to lack of any other
    option.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="FURTHER_QUESTIONS?"><a class="permalink" href="#FURTHER_QUESTIONS?">FURTHER
  QUESTIONS?</a></h1>
<p class="Pp">Check the list of additional DBIC resources.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
<p class="Pp">This module is free software copyright by the DBIx::Class (DBIC)
    authors. You can redistribute it and/or modify it under the same terms as
    the DBIx::Class library.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-01-29</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Mail::SPF::Query(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Mail::SPF::Query(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Mail::SPF::Query(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Mail::SPF::Query - query Sender Policy Framework for an
    IP,email,helo</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">1.999.1</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    my $query = new Mail::SPF::Query (ip =&gt; &quot;127.0.0.1&quot;, sender=&gt;'foo@example.com', helo=&gt;&quot;somehost.example.com&quot;, trusted=&gt;0, guess=&gt;0);
    my ($result,           # pass | fail | softfail | neutral | none | error | unknown [mechanism]
        $smtp_comment,     # &quot;please see http://www.openspf.org/why.html?...&quot;  when rejecting, return this string to the SMTP client
        $header_comment,   # prepend_header(&quot;Received-SPF&quot; =&gt; &quot;$result ($header_comment)&quot;)
        $spf_record,       # &quot;v=spf1 ...&quot; original SPF record for the domain
       ) = $query-&gt;result();
    if    ($result eq &quot;pass&quot;) { &quot;Domain is not forged. Apply RHSBL and content filters.&quot; }
    elsif ($result eq &quot;fail&quot;) { &quot;Domain is forged. Reject or save to spambox.&quot; }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="ABSTRACT"><a class="permalink" href="#ABSTRACT">ABSTRACT</a></h1>
<p class="Pp">The SPF protocol relies on sender domains to describe their
    designated outbound mailers in DNS. Given an email address, Mail::SPF::Query
    determines the legitimacy of an SMTP client IP address.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">There are two ways to use Mail::SPF::Query. Your choice depends on
    whether the domains your server is an MX for have secondary MXes which your
    server doesn't know about.</p>
<p class="Pp">The first and more common style, calling -&gt;<b>result()</b>, is
    suitable when all mail is received directly from the originator's MTA. If
    the domains you receive do not have secondary MX entries, this is
    appropriate. This style of use is outlined in the SYNOPSIS above. This is
    the common case.</p>
<p class="Pp">The second style is more complex, but works when your server
    receives mail from secondary MXes. This performs checks as each recipient is
    handled. If the message is coming from a valid MX secondary for a recipient,
    then the SPF check is not performed, and a &quot;pass&quot; response is
    returned right away. To do this, call
    <span class="Li">&quot;result2()&quot;</span> and
    <span class="Li">&quot;message_result2()&quot;</span> instead of
    <span class="Li">&quot;result()&quot;</span>.</p>
<p class="Pp">If you do not know what a secondary MX is, you probably don't have
    one. Use the first style.</p>
<p class="Pp">You can try out Mail::SPF::Query on the command line with the
    following command:</p>
<p class="Pp"></p>
<pre>    perl -MMail::SPF::Query -le 'print for Mail::SPF::Query-&gt;new(
        helo =&gt; shift, ipv4 =&gt; shift, sender =&gt; shift)-&gt;result' \
        helohost.example.com 1.2.3.4 user@example.com
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">Mail::SPF::Query tries to implement the SPF specification (see
    &quot;SEE ALSO&quot;) as close as reasonably possible given that M:S:Q has
    been the very first SPF implementation and has changed with the SPF
    specification over time. As a result, M:S:Q has various known deficiencies
    that cannot be corrected with reasonably little effort:</p>
<ul class="Bl-bullet">
  <li><b>Unable to query HELO and MAIL FROM separately.</b> M:S:Q is not
      designed to support the <i>separate</i> querying of the HELO and MAIL FROM
      identities. Passing the HELO identity as the
      <span class="Li">&quot;sender&quot;</span> argument for a stand-alone HELO
      check might generally work but could yield unexpected results.</li>
  <li><b>No IPv6 support.</b> IPv6 is not supported.
      <span class="Li">&quot;ip6&quot;</span> mechanisms in SPF records and
      everywhere else are simply ignored.</li>
  <li><b>Result explanation may be inappropriate for local policy results.</b>
      If a query result was caused by anything other than a real SPF record
      (i.e. local policy, overrides, fallbacks, etc.), and no custom
      <span class="Li">&quot;default_explanation&quot;</span> was specified, the
      domain's explanation or M:S:Q's hard-coded default explanation will still
      be returned. Be aware that in this case the explanation may not correctly
      explain the reason for such an artificial result.</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="NON-STANDARD_FEATURES"><a class="permalink" href="#NON-STANDARD_FEATURES">NON-STANDARD
  FEATURES</a></h1>
<p class="Pp">Also due to its long history, M:S:Q does have some legacy features
    that are not parts of the official SPF specification, most notably <i>best
    guess processing</i> and <i>trusted forwarder accreditation checking</i>.
    Please be careful when using these <i>non-standard</i> features or when
    reproducing them in your own SPF implementation, as they may cause
    unexpected results.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="_Mail::SPF::Query"><a class="permalink" href="#_Mail::SPF::Query">&quot;Mail::SPF::Query-&gt;new()&quot;</a></h2>
<pre>    my $query = eval { new Mail::SPF::Query (
        ip          =&gt; '127.0.0.1',
        sender      =&gt; 'foo@example.com',
        helo        =&gt; 'host.example.com',
        # Optional parameters:
        debug       =&gt; 1, debuglog =&gt; sub { print STDERR &quot;@_\n&quot; },
        local       =&gt; 'extra mechanisms',
        trusted     =&gt; 1,                   # do trusted forwarder processing
        guess       =&gt; 1,                   # do best guess if no SPF record
        default_explanation =&gt; 'Please see http://spf.my.isp/spferror.html for details',
        max_lookup_count    =&gt; 10,          # total number of SPF includes/redirects
        sanitize    =&gt; 0,                   # do not sanitize all returned strings
        myhostname  =&gt; 'foo.example.com',   # prepended to header_comment
        override    =&gt; {   'example.net' =&gt; 'v=spf1 a mx -all',
                         '*.example.net' =&gt; 'v=spf1 a mx -all' },
        fallback    =&gt; {   'example.org' =&gt; 'v=spf1 a mx -all',
                         '*.example.org' =&gt; 'v=spf1 a mx -all' }
    ) };
    if ($@) { warn &quot;bad input to Mail::SPF::Query: $@&quot; }
</pre>
<p class="Pp">Set <span class="Li">&quot;trusted=&gt;1&quot;</span> to turned on
    <span class="Li">&quot;trusted-forwarder.org&quot;</span> accreditation
    checking. The mechanism
    <span class="Li">&quot;include:spf.trusted-forwarder.org&quot;</span> is
    used just before a <span class="Li">&quot;-all&quot;</span> or
    <span class="Li">&quot;?all&quot;</span>. The precise circumstances are
    somewhat more complicated, but it does get the case of
    <span class="Li">&quot;v=spf1 -all&quot;</span> right -- i.e.
    <span class="Li">&quot;trusted-forwarder.org&quot;</span> is not checked.
    <b>This is a non-standard feature.</b></p>
<p class="Pp">Set <span class="Li">&quot;guess=&gt;1&quot;</span> to turned on
    automatic best guess processing. This will use the best_guess SPF record
    when one cannot be found in the DNS. Note that this can only return
    <span class="Li">&quot;pass&quot;</span> or
    <span class="Li">&quot;neutral&quot;</span>. The
    <span class="Li">&quot;trusted&quot;</span> and
    <span class="Li">&quot;local&quot;</span> flags also operate when the
    best_guess is being used. <b>This is a non-standard</b> <b>feature.</b></p>
<p class="Pp">Set
    <span class="Li">&quot;local=&gt;'include:local.domain'&quot;</span> to
    include some extra processing just before a
    <span class="Li">&quot;-all&quot;</span> or
    <span class="Li">&quot;?all&quot;</span>. The local processing happens just
    before the trusted forwarder processing. <b>This is a non-standard
    feature.</b></p>
<p class="Pp">Set <span class="Li">&quot;default_explanation&quot;</span> to a
    string to be used if the SPF record does not provide a specific explanation.
    The default value will direct the user to a page at www.openspf.org with the
    following message:</p>
<p class="Pp"></p>
<pre>    Please see http://www.openspf.org/why.html?sender=%{S}&amp;ip=%{I}&amp;receiver=%{R}
</pre>
<p class="Pp">Note that the string has macro substitution performed.</p>
<p class="Pp">Set <span class="Li">&quot;sanitize&quot;</span> to 0 to get all
    the returned strings unsanitized. Alternatively, pass a function reference
    and this function will be used to sanitize the returned values. The function
    must take a single string argument and return a single string which contains
    the sanitized result.</p>
<p class="Pp">Set <span class="Li">&quot;debug=&gt;1&quot;</span> to watch the
    queries happen.</p>
<p class="Pp">Set <span class="Li">&quot;override&quot;</span> to define SPF
    records for domains that do publish but which you want to override anyway.
    Wildcards are supported. <b>This is a non-standard</b> <b>feature.</b></p>
<p class="Pp">Set <span class="Li">&quot;fallback&quot;</span> to define
    &quot;pretend&quot; SPF records for domains that don't publish them yet.
    Wildcards are supported. <b>This is a non-standard feature.</b></p>
<p class="Pp">Note: domain name arguments to override and fallback need to be in
    all lowercase.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_$query"><a class="permalink" href="#_$query">&quot;$query-&gt;result()&quot;</a></h2>
<pre>    my ($result, $smtp_comment, $header_comment, $spf_record, $detail) = $query-&gt;result();
</pre>
<p class="Pp"><span class="Li">$result</span> will be one of
    <span class="Li">&quot;pass&quot;</span>,
    <span class="Li">&quot;fail&quot;</span>,
    <span class="Li">&quot;softfail&quot;</span>,
    <span class="Li">&quot;neutral&quot;</span>,
    <span class="Li">&quot;none&quot;</span>,
    <span class="Li">&quot;error&quot;</span> or <span class="Li">&quot;unknown
    [...]&quot;</span>:</p>
<dl class="Bl-tag">
  <dt>&quot;pass&quot;</dt>
  <dd>The client IP address is an authorized mailer for the sender. The mail
      should be accepted subject to local policy regarding the sender.</dd>
  <dt>&quot;fail&quot;</dt>
  <dd>The client IP address is not an authorized mailer, and the sender wants
      you to reject the transaction for fear of forgery.</dd>
  <dt>&quot;softfail&quot;</dt>
  <dd>The client IP address is not an authorized mailer, but the sender prefers
      that you accept the transaction because it isn't absolutely sure all its
      users are mailing through approved servers. The
      <span class="Li">&quot;softfail&quot;</span> status is often used during
      initial deployment of SPF records by a domain.</dd>
  <dt>&quot;neutral&quot;</dt>
  <dd>The sender makes no assertion about the status of the client IP.</dd>
  <dt>&quot;none&quot;</dt>
  <dd>There is no SPF record for this domain.</dd>
  <dt>&quot;error&quot;</dt>
  <dd>The DNS lookup encountered a temporary error during processing.</dd>
  <dt>&quot;unknown [...]&quot;</dt>
  <dd>The domain has a configuration error in the published data or defines a
      mechanism that this library does not understand. If the data contained an
      unrecognized mechanism, it will be presented following
      &quot;unknown&quot;. You should test for unknown using a regexp
      <span class="Li">&quot;/^unknown/&quot;</span> rather than
      <span class="Li">&quot;eq &quot;unknown&quot;&quot;</span>.</dd>
</dl>
<p class="Pp">Results are cached internally for a default of 120 seconds. You
    can call <span class="Li">&quot;-&gt;result()&quot;</span> repeatedly;
    subsequent lookups won't hit your DNS.</p>
<p class="Pp"><span class="Li">&quot;smtp_comment&quot;</span> should be
    displayed to the SMTP client.</p>
<p class="Pp"><span class="Li">&quot;header_comment&quot;</span> goes into a
    <span class="Li">&quot;Received-SPF&quot;</span> header, like so:</p>
<p class="Pp"></p>
<pre>    Received-SPF: $result ($header_comment)
</pre>
<p class="Pp"><span class="Li">&quot;spf_record&quot;</span> shows the original
    SPF record fetched for the query. If there is no SPF record, it is blank.
    Otherwise, it will start with <span class="Li">&quot;v=spf1&quot;</span> and
    contain the SPF mechanisms and such that describe the domain.</p>
<p class="Pp">Note that the strings returned by this method (and most of the
    other methods) are (at least partially) under the control of the sender's
    domain. This means that, if the sender is an attacker, the contents can be
    assumed to be hostile. The various methods that return these strings make
    sure that (by default) the strings returned contain only characters in the
    range 32 - 126. This behavior can be changed by setting
    <span class="Li">&quot;sanitize&quot;</span> to 0 to turn off sanitization
    entirely. You can also set <span class="Li">&quot;sanitize&quot;</span> to a
    function reference to perform custom sanitization. In particular, assume
    that <span class="Li">&quot;smtp_comment&quot;</span> might contain a
    newline character.</p>
<p class="Pp"><span class="Li">&quot;detail&quot;</span> is a hash of all the
    foregoing result elements, plus extra data returned by the SPF result.</p>
<p class="Pp"><i>Why the weird duplication?</i> In the beginning,
    <span class="Li">&quot;result()&quot;</span> returned only one value, the
    <span class="Li">$result</span>. Then <span class="Li">$smtp_comment</span>
    and <span class="Li">$header_comment</span> came along. Then
    <span class="Li">$spf_record</span>. Past a certain number of positional
    results, it makes more sense to have a hash. But we didn't want to break
    backwards compatibility, so we just declared that the fifth result would be
    a hash and future return value would go in there.</p>
<p class="Pp">The keys of the hash are:</p>
<p class="Pp"></p>
<pre>    result
    smtp_comment
    header_comment
    header_pairs
    spf_record
    modifiers
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_$query~2"><a class="permalink" href="#_$query~2">&quot;$query-&gt;result2()&quot;</a></h2>
<pre>    my ($result, $smtp_comment, $header_comment, $spf_record) = $query-&gt;result2('recipient@domain', 'recipient2@domain');
</pre>
<p class="Pp"><span class="Li">&quot;result2()&quot;</span> does everything that
    <span class="Li">&quot;result()&quot;</span> does, but it first checks to
    see if the sending system is a recognized MX secondary for the recipient(s).
    If so, then it returns <span class="Li">&quot;pass&quot;</span> and does not
    perform the SPF query. Note that the sending system may be a MX secondary
    for some (but not all) of the recipients for a multi-recipient message,
    which is why result2 takes an argument list. See also
    <span class="Li">&quot;message_result2()&quot;</span>.</p>
<p class="Pp"><b>This is a non-standard feature.</b> <b>This feature is also
    deprecated, because</b> <b>exemption of trusted relays, such as secondary
    MXes, should really be performed</b> <b>by the software that uses this
    library before doing an SPF check.</b></p>
<p class="Pp"><span class="Li">$result</span> will be one of
    <span class="Li">&quot;pass&quot;</span>,
    <span class="Li">&quot;fail&quot;</span>, <span class="Li">&quot;neutral
    [...]&quot;</span>, or <span class="Li">&quot;unknown&quot;</span>. See
    <span class="Li">&quot;result()&quot;</span> above for meanings.</p>
<p class="Pp">If you have secondary MXes and if you are unable to explicitly
    white-list them before SPF tests occur, you can use this method in place of
    <span class="Li">&quot;result()&quot;</span>, calling it as many times as
    there are recipients, or just providing all the recipients at one time.</p>
<p class="Pp"><span class="Li">&quot;smtp_comment&quot;</span> can be displayed
    to the SMTP client.</p>
<p class="Pp">For example:</p>
<p class="Pp"></p>
<pre>    my $query = new Mail::SPF::Query (ip =&gt; &quot;127.0.0.1&quot;,
                                      sender=&gt;'foo@example.com',
                                      helo=&gt;&quot;somehost.example.com&quot;);
    ...
    my ($result, $smtp_comment, $header_comment);
    ($result, $smtp_comment, $header_comment) = $query-&gt;result2('recip1@example.com');
    # return suitable error code based on $result eq 'fail' or not
    ($result, $smtp_comment, $header_comment) = $query-&gt;result2('recip2@example.org');
    # return suitable error code based on $result eq 'fail' or not
    ($result, $smtp_comment, $header_comment) = $query-&gt;message_result2();
    # return suitable error if $result eq 'fail'
    # prefix message with &quot;Received-SPF: $result ($header_comment)&quot;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_$query~3"><a class="permalink" href="#_$query~3">&quot;$query-&gt;message_result2()&quot;</a></h2>
<pre>    my ($result, $smtp_comment, $header_comment, $spf_record) = $query-&gt;message_result2();
</pre>
<p class="Pp"><span class="Li">&quot;message_result2()&quot;</span> returns an
    overall status for the message after zero or more calls to
    <span class="Li">&quot;result2()&quot;</span>. It will always be the last
    status returned by <span class="Li">&quot;result2()&quot;</span>, or the
    status returned by <span class="Li">&quot;result()&quot;</span> if
    <span class="Li">&quot;result2()&quot;</span> was never called.</p>
<p class="Pp"><span class="Li">$result</span> will be one of
    <span class="Li">&quot;pass&quot;</span>,
    <span class="Li">&quot;fail&quot;</span>, <span class="Li">&quot;neutral
    [...]&quot;</span>, or <span class="Li">&quot;error&quot;</span>. See
    <span class="Li">&quot;result()&quot;</span> above for meanings.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_$query~4"><a class="permalink" href="#_$query~4">&quot;$query-&gt;best_guess()&quot;</a></h2>
<pre>    my ($result, $smtp_comment, $header_comment) = $query-&gt;best_guess();
</pre>
<p class="Pp">When a domain does not publish an SPF record, this library can
    produce an educated guess anyway.</p>
<p class="Pp">It pretends the domain defined A, MX, and PTR mechanisms, plus a
    few others. The default set of directives is</p>
<p class="Pp"></p>
<pre>    a/24 mx/24 ptr
</pre>
<p class="Pp">That default set will return either &quot;pass&quot; or
    &quot;neutral&quot;.</p>
<p class="Pp">If you want to experiment with a different default, you can pass
    it as an argument: <span class="Li">&quot;$query-&gt;best_guess(&quot;a mx
    ptr&quot;)&quot;</span></p>
<p class="Pp"><b>This is a non-standard feature.</b> <b>This method is also
    deprecated.</b> You should set
    <span class="Li">&quot;guess=&gt;1&quot;</span> on the
    <span class="Li">&quot;new()&quot;</span> method instead.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_$query~5"><a class="permalink" href="#_$query~5">&quot;$query-&gt;trusted_forwarder()&quot;</a></h2>
<pre>    my ($result, $smtp_comment, $header_comment) = $query-&gt;best_guess();
</pre>
<p class="Pp">It is possible that the message is coming through a known-good
    relay like <span class="Li">&quot;acm.org&quot;</span> or
    <span class="Li">&quot;pobox.com&quot;</span>. During the transitional
    period, many legitimate services may appear to forge a sender address: for
    example, a news website may have a &quot;send me this article in email&quot;
    link.</p>
<p class="Pp">The <span class="Li">&quot;trusted-forwarder.org&quot;</span>
    domain is a white-list of known-good hosts that either forward mail or
    perform benign envelope sender forgery:</p>
<p class="Pp"></p>
<pre>    include:spf.trusted-forwarder.org
</pre>
<p class="Pp">This will return either &quot;pass&quot; or
  &quot;neutral&quot;.</p>
<p class="Pp"><b>This is a non-standard feature.</b> <b>This method is also
    deprecated.</b> You should set
    <span class="Li">&quot;trusted=&gt;1&quot;</span> on the
    <span class="Li">&quot;new()&quot;</span> method instead.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_$query~6"><a class="permalink" href="#_$query~6">&quot;$query-&gt;sanitize('string')&quot;</a></h2>
<p class="Pp">This applies the sanitization rules for the particular query
    object. These rules are controlled by the
    <span class="Li">&quot;sanitize&quot;</span> parameter to the
    c&lt;<b>new()</b>&gt; method.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_strict_sanitize("><a class="permalink" href="#_strict_sanitize(">&quot;strict_sanitize('string')&quot;</a></h2>
<p class="Pp">This ensures that all the characters in the returned string are
    printable. All whitespace is converted into spaces, and all other
    non-printable characters are converted into question marks. This is probably
    over-aggressive for many applications.</p>
<p class="Pp">This function is used by default when the
    <span class="Li">&quot;sanitize&quot;</span> option is passed to the
    <span class="Li">&quot;new()&quot;</span> method.</p>
<p class="Pp"><b>This function is not a class method.</b></p>
</section>
<section class="Ss">
<h2 class="Ss" id="_$query~7"><a class="permalink" href="#_$query~7">&quot;$query-&gt;debuglog()&quot;</a></h2>
<p class="Pp">Subclasses may override this with their own debug logger.
    <span class="Li">&quot;Log::Dispatch&quot;</span> is recommended.</p>
<p class="Pp">Alternatively, pass the <span class="Li">&quot;new()&quot;</span>
    constructor a <span class="Li">&quot;debuglog =&gt; sub { ... }&quot;</span>
    callback, and we'll pass debugging lines to that.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="WARNINGS"><a class="permalink" href="#WARNINGS">WARNINGS</a></h1>
<p class="Pp">Mail::Query::SPF should only be used at the point where messages
    are received from the Internet. The underlying assumption is that the sender
    of the e-mail is sending the message directly to you or one of your
    secondary MXes. If your MTA does not have an exhaustive list of secondary
    MXes, then the <span class="Li">&quot;result2()&quot;</span> and
    <span class="Li">&quot;message_result2()&quot;</span> methods can be used.
    These methods take care to permit mail from secondary MXes.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp">Meng Weng Wong &lt;mengwong+spf@pobox.com&gt;, Philip Gladstone,
    Julian Mehnle &lt;julian@mehnle.net&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">About SPF: &lt;http://www.openspf.org&gt;</p>
<p class="Pp">Mail::SPF::Query:
    &lt;http://search.cpan.org/dist/Mail-SPF-Query&gt;</p>
<p class="Pp">The latest release of the SPF specification:
    &lt;http://www.openspf.org/spf-classic-current.txt&gt;</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2006-02-26</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>

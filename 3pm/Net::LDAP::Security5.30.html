<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Net::LDAP::Security(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Net::LDAP::Security(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Net::LDAP::Security(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Net::LDAP::Security - Security issues with LDAP connections</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  none
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This document discusses various security issues relating to using
    LDAP and connecting to LDAP servers, notably how to manage these potential
    vulnerabilities:</p>
<ul class="Bl-bullet">
  <li>do you know that you are connected to the right server</li>
  <li>can someone sniff your passwords/userids from the directory
    connection</li>
  <li>can someone sniff other confidential information from the directory
      connection</li>
</ul>
<p class="Pp"><b>Net::LDAP</b> provides ways to address these vulnerabilities:
    through the use of LDAPS, or LDAPv3 and TLS, and/or the use of SASL. Each of
    these will be explained below.</p>
<section class="Ss">
<h2 class="Ss">How does an LDAP connection work</h2>
<p class="Pp">A normal LDAPv2 or LDAPv3 connection works by the client
    connecting directly to port 389 (by default), and then issuing various LDAP
    requests like search, add, etc.</p>
<p class="Pp">There is no way to guarantee that an LDAP client is connected to
    the right LDAP server. Hackers could have poisoned your DNS, so
    'ldap.example.com' could be made to point to 'ldap.hacker.com'. Or they
    could have installed their own server on the correct machine.</p>
<p class="Pp">It is in the nature of the LDAP protocol that all information goes
    between the client and the server in 'plain text'. This is a term used by
    cryptographers to describe unencrypted and recoverable data, so even though
    LDAP can transfer binary values like JPEG photographs, audio clips and X.509
    certificates, everything is still considered 'plain text'.</p>
<p class="Pp">If these vulnerabilities are an issue to, then you should consider
    the other possibilities described below, namely LDAPS, LDAPv3 and TLS, and
    SASL.</p>
</section>
<section class="Ss">
<h2 class="Ss">How does an LDAPS connection work</h2>
<p class="Pp">LDAPS is an unofficial protocol. It is to LDAP what HTTPS is to
    HTTP, namely the exact same protocol (but in this case LDAPv2 or LDAPv3)
    running over a <i>secured</i> SSL (&quot;Secure Socket Layer&quot;)
    connection to port 636 (by default).</p>
<p class="Pp">Not all servers will be configured to listen for LDAPS
    connections, but if they do, it will commonly be on a different port from
    the normal plain text LDAP port.</p>
<p class="Pp">Using LDAPS can <i>potentially</i> solve the vulnerabilities
    described above, but you should be aware that simply &quot;using&quot; SSL
    is not a magic bullet that automatically makes your system
    &quot;secure&quot;.</p>
<p class="Pp">First of all, LDAPS can solve the problem of verifying that you
    are connected to the correct server. When the client and server connect,
    they perform a special SSL 'handshake', part of which involves the server
    and client exchanging cryptographic keys, which are described using X.509
    certificates. If the client wishes to confirm that it is connected to the
    correct server, all it needs to do is verify the server's certificate which
    is sent in the handshake. This is done in two ways:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>check that the certificate is signed (trusted) by someone that you trust,
      and that the certificate hasn't been revoked. For instance, the server's
      certificate may have been signed by Verisign (www.verisign.com), and you
      decide that you want to trust Verisign to sign legitimate
    certificates.</dd>
  <dt>2.</dt>
  <dd>check that the least-significant cn RDN in the server's certificate's DN
      is the fully-qualified hostname of the hostname that you connected to when
      creating the LDAPS object. For example if the server is
      &lt;cn=ldap.example.com,ou=My department,o=My company&gt;, then the RDN to
      check is cn=ldap.example.com.</dd>
</dl>
<p class="Pp">You can do this by using the cafile and capath options when
    creating a <b>Net::LDAPS</b> object, <i>and</i> by setting the verify option
    to 'require'.</p>
<p class="Pp">To prevent hackers 'sniffing' passwords and other information on
    your connection, you also have to make sure the encryption algorithm used by
    the SSL connection is good enough. This is also something that gets decided
    by the SSL handshake - if the client and server cannot agree on an
    acceptable algorithm the connection is not made.</p>
<p class="Pp"><b>Net::LDAPS</b> will by default use all the algorithms built
    into your copy of OpenSSL, except for ones considered to use &quot;low&quot;
    strength encryption, and those using export strength encryption. You can
    override this when you create the <b>Net::LDAPS</b> object using the
    'ciphers' option.</p>
<p class="Pp">Once you've made the secure connection, you should also check that
    the encryption algorithm that is actually being used is one that you find
    acceptable. Broken servers have been observed in the field which 'fail over'
    and give you an unencrypted connection, so you ought to check for that.</p>
</section>
<section class="Ss">
<h2 class="Ss">How does LDAP and TLS work</h2>
<p class="Pp">SSL is a good solution to many network security problems, but it
    is not a standard. The IETF corrected some defects in the SSL mechanism and
    published a standard called RFC 2246 which describes TLS (&quot;Transport
    Layer Security&quot;), which is simply a cleaned up and standardized version
    of SSL.</p>
<p class="Pp">You can only use TLS with an LDAPv3 server. That is because the
    standard (RFC 4511) for LDAP and TLS requires that the <i>normal</i> LDAP
    connection (i.e., on port 389) can be switched on demand from plain text
    into a TLS connection. The switching mechanism uses a special extended LDAP
    operation, and since these are not legal in LDAPv2, you can only switch to
    TLS on an LDAPv3 connection.</p>
<p class="Pp">So the way you use TLS with LDAPv3 is that you create your normal
    LDAPv3 connection using
    <span class="Li">&quot;Net::LDAP::new()&quot;</span>, and then you perform
    the switch using <span class="Li">&quot;Net::LDAP::start_tls()&quot;</span>.
    The <span class="Li">&quot;start_tls()&quot;</span> method takes pretty much
    the same arguments as <span class="Li">&quot;Net::LDAPS::new()&quot;</span>,
    so check above for details.</p>
</section>
<section class="Ss">
<h2 class="Ss">How does SASL work</h2>
<p class="Pp">SASL is an authentication framework that can be used by a number
    of different Internet services, including LDAPv3. Because it is only a
    framework, it doesn't provide any way to authenticate by itself; to actually
    authenticate to a service you need to use a specific SASL <i>mechanism</i>.
    A number of mechanisms are defined, such as CRAM-MD5.</p>
<p class="Pp">The use of a mechanism like CRAM-MD5 provides a solution to the
    password sniffing vulnerability, because these mechanisms typically do not
    require the user to send across a secret (e.g., a password) in the clear
    across the network. Instead, authentication is carried out in a clever way
    which avoids this, and so prevents passwords from being sniffed.</p>
<p class="Pp"><b>Net::LDAP</b> supports SASL using the <b>Authen::SASL</b>
    class. Currently the only <b>Authen::SASL</b> subclasses (i.e., SASL
    mechanism) available are CRAM-MD5 and EXTERNAL.</p>
<p class="Pp">Some SASL mechanisms provide a general solution to the sniffing of
    all data on the network vulnerability, as they can negotiate confidential
    (i.e., encrypted) network connections. Note that this is over and above any
    SSL or TLS encryption! Unfortunately, perl's <b>Authen::SASL</b> code cannot
    negotiate this.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Net::LDAP, Net::LDAPS, Authen::SASL</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGEMENTS"><a class="permalink" href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></h1>
<p class="Pp">Jim Dutton &lt;jimd@dutton3.it.siu.edu&gt; provided lots of useful
    feedback on the early drafts.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Chris Ridd &lt;chris.ridd@isode.com&gt;</p>
<p class="Pp">Please report any bugs, or post any suggestions, to the perl-ldap
    mailing list &lt;perl-ldap@perl.org&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 2001-2004 Chris Ridd. All rights reserved. This
    program is free software; you can redistribute it and/or modify it under the
    same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-01-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

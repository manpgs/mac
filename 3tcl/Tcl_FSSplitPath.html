<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Copyright (c) 2001 Vincent Darley
  
   See the file "license.terms" for information on usage and redistribution
   of this file, and for a DISCLAIMER OF ALL WARRANTIES.
  
   RCS: @(#) $Id: FileSystem.3,v 1.62.2.1 2009/11/27 14:53:54 dkf Exp $
  
   The -*- nroff -*- definitions below are for supplemental macros used
   in Tcl/Tk manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO ?manpage?
  	Start of list of standard options for a Tk widget. The manpage
  	argument defines where to look up the standard options; if
  	omitted, defaults to "options". The options follow on successive
  	lines, in three columns separated by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   .QW arg1 ?arg2?
  	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
  
   .PQ arg1 ?arg2?
  	Print an open parenthesis, arg1 in quotes, then arg2 normally
  	(for trailing punctuation) and then a closing parenthesis.
  
   RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Filesystem(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Filesystem(3)</td>
    <td class="head-vol">Tcl Library Procedures</td>
    <td class="head-rtitle">Filesystem(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>

</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Tcl_FSRegister, Tcl_FSUnregister, Tcl_FSData, Tcl_FSMountsChanged,
    Tcl_FSGetFileSystemForPath, Tcl_FSGetPathType, Tcl_FSCopyFile,
    Tcl_FSCopyDirectory, Tcl_FSCreateDirectory, Tcl_FSDeleteFile,
    Tcl_FSRemoveDirectory, Tcl_FSRenameFile, Tcl_FSListVolumes, Tcl_FSEvalFile,
    Tcl_FSEvalFileEx, Tcl_FSLoadFile, Tcl_FSMatchInDirectory, Tcl_FSLink,
    Tcl_FSLstat, Tcl_FSUtime, Tcl_FSFileAttrsGet, Tcl_FSFileAttrsSet,
    Tcl_FSFileAttrStrings, Tcl_FSStat, Tcl_FSAccess, Tcl_FSOpenFileChannel,
    Tcl_FSGetCwd, Tcl_FSChdir, Tcl_FSPathSeparator, Tcl_FSJoinPath,
    Tcl_FSSplitPath, Tcl_FSEqualPaths, Tcl_FSGetNormalizedPath,
    Tcl_FSJoinToPath, Tcl_FSConvertToPathType, Tcl_FSGetInternalRep,
    Tcl_FSGetTranslatedPath, Tcl_FSGetTranslatedStringPath, Tcl_FSNewNativePath,
    Tcl_FSGetNativePath, Tcl_FSFileSystemInfo, Tcl_AllocStatBuf - procedures to
    interact with any filesystem</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
<b>#include &lt;tcl.h&gt;</b>

int
<b>Tcl_FSRegister</b>(<i>clientData, fsPtr</i>)

int
<b>Tcl_FSUnregister</b>(<i>fsPtr</i>)

ClientData
<b>Tcl_FSData</b>(<i>fsPtr</i>)

void
<b>Tcl_FSMountsChanged</b>(<i>fsPtr</i>)

Tcl_Filesystem*
<b>Tcl_FSGetFileSystemForPath</b>(<i>pathPtr</i>)

Tcl_PathType
<b>Tcl_FSGetPathType</b>(<i>pathPtr</i>)

int
<b>Tcl_FSCopyFile</b>(<i>srcPathPtr, destPathPtr</i>)

int
<b>Tcl_FSCopyDirectory</b>(<i>srcPathPtr, destPathPtr, errorPtr</i>)

int
<b>Tcl_FSCreateDirectory</b>(<i>pathPtr</i>)

int
<b>Tcl_FSDeleteFile</b>(<i>pathPtr</i>)

int
<b>Tcl_FSRemoveDirectory</b>(<i>pathPtr, int recursive, errorPtr</i>)

int
<b>Tcl_FSRenameFile</b>(<i>srcPathPtr, destPathPtr</i>)

Tcl_Obj*
<b>Tcl_FSListVolumes</b>(<i>void</i>)

int
<b>Tcl_FSEvalFileEx</b>(<i>interp, pathPtr, encodingName</i>)

int
<b>Tcl_FSEvalFile</b>(<i>interp, pathPtr</i>)

int
<b>Tcl_FSLoadFile</b>(<i>interp, pathPtr, sym1, sym2, proc1Ptr, proc2Ptr,</i>
<i>               handlePtr, unloadProcPtr</i>)

int
<b>Tcl_FSMatchInDirectory</b>(<i>interp, resultPtr, pathPtr, pattern, types</i>)

Tcl_Obj*
<b>Tcl_FSLink</b>(<i>linkNamePtr, toPtr, linkAction</i>)

int
<b>Tcl_FSLstat</b>(<i>pathPtr, statPtr</i>)

int
<b>Tcl_FSUtime</b>(<i>pathPtr, tval</i>)

int
<b>Tcl_FSFileAttrsGet</b>(<i>interp, int index, pathPtr, objPtrRef</i>)

int
<b>Tcl_FSFileAttrsSet</b>(<i>interp, int index, pathPtr, Tcl_Obj *objPtr</i>)

const char**
<b>Tcl_FSFileAttrStrings</b>(<i>pathPtr, objPtrRef</i>)

int
<b>Tcl_FSStat</b>(<i>pathPtr, statPtr</i>)

int
<b>Tcl_FSAccess</b>(<i>pathPtr, mode</i>)

Tcl_Channel
<b>Tcl_FSOpenFileChannel</b>(<i>interp, pathPtr, modeString, permissions</i>)

Tcl_Obj*
<b>Tcl_FSGetCwd</b>(<i>interp</i>)

int
<b>Tcl_FSChdir</b>(<i>pathPtr</i>)

Tcl_Obj*
<b>Tcl_FSPathSeparator</b>(<i>pathPtr</i>)

Tcl_Obj*
<b>Tcl_FSJoinPath</b>(<i>listObj, elements</i>)

Tcl_Obj*
<b>Tcl_FSSplitPath</b>(<i>pathPtr, lenPtr</i>)

int
<b>Tcl_FSEqualPaths</b>(<i>firstPtr, secondPtr</i>)

Tcl_Obj*
<b>Tcl_FSGetNormalizedPath</b>(<i>interp, pathPtr</i>)

Tcl_Obj*
<b>Tcl_FSJoinToPath</b>(<i>basePtr, objc, objv</i>)

int
<b>Tcl_FSConvertToPathType</b>(<i>interp, pathPtr</i>)

ClientData
<b>Tcl_FSGetInternalRep</b>(<i>pathPtr, fsPtr</i>)

Tcl_Obj *
<b>Tcl_FSGetTranslatedPath</b>(<i>interp, pathPtr</i>)

const char *
<b>Tcl_FSGetTranslatedStringPath</b>(<i>interp, pathPtr</i>)

Tcl_Obj*
<b>Tcl_FSNewNativePath</b>(<i>fsPtr, clientData</i>)

const char *
<b>Tcl_FSGetNativePath</b>(<i>pathPtr</i>)

Tcl_Obj*
<b>Tcl_FSFileSystemInfo</b>(<i>pathPtr</i>)

Tcl_StatBuf*
<b>Tcl_AllocStatBuf</b>()
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="ARGUMENTS"><a class="permalink" href="#ARGUMENTS">ARGUMENTS</a></h1>
<dl class="Bl-tag">
  <dt>Tcl_Filesystem <i>*fsPtr</i> (in)</dt>
  <dd>Points to a structure containing the addresses of procedures that can be
      called to perform the various filesystem operations.</dd>
  <dt>Tcl_Obj <i>*pathPtr</i> (in)</dt>
  <dd>The path represented by this object is used for the operation in question.
      If the object does not already have an internal <b>path</b>
      representation, it will be converted to have one.</dd>
  <dt>Tcl_Obj <i>*srcPathPtr</i> (in)</dt>
  <dd>As for <i>pathPtr</i>, but used for the source file for a copy or rename
      operation.</dd>
  <dt>Tcl_Obj <i>*destPathPtr</i> (in)</dt>
  <dd>As for <i>pathPtr</i>, but used for the destination filename for a copy or
      rename operation.</dd>
  <dt>const char <i>*encodingName</i> (in)</dt>
  <dd>The encoding of the data stored in the file identified by <i>pathPtr</i>
      and to be evaluated.</dd>
  <dt>const char <i>*pattern</i> (in)</dt>
  <dd>Only files or directories matching this pattern will be returned.</dd>
  <dt>Tcl_GlobTypeData <i>*types</i> (in)</dt>
  <dd>Only files or directories matching the type descriptions contained in this
      structure will be returned. This parameter may be NULL.</dd>
  <dt>Tcl_Interp <i>*interp</i> (in)</dt>
  <dd>Interpreter to use either for results, evaluation, or reporting error
      messages.</dd>
  <dt>ClientData <i>clientData</i> (in)</dt>
  <dd>The native description of the path object to create.</dd>
  <dt>Tcl_Obj <i>*firstPtr</i> (in)</dt>
  <dd>The first of two path objects to compare. The object may be converted to
      <b>path</b> type.</dd>
  <dt>Tcl_Obj <i>*secondPtr</i> (in)</dt>
  <dd>The second of two path objects to compare. The object may be converted to
      <b>path</b> type.</dd>
  <dt>Tcl_Obj <i>*listObj</i> (in)</dt>
  <dd>The list of path elements to operate on with a <b>join</b> operation.</dd>
  <dt>int <i>elements</i> (in)</dt>
  <dd>If non-negative, the number of elements in the <i>listObj</i> which should
      be joined together. If negative, then all elements are joined.</dd>
  <dt>Tcl_Obj <i>**errorPtr</i> (out)</dt>
  <dd>In the case of an error, filled with an object containing the name of the
      file which caused an error in the various copy/rename operations.</dd>
  <dt>Tcl_Obj <i>**objPtrRef</i> (out)</dt>
  <dd>Filled with an object containing the result of the operation.</dd>
  <dt>Tcl_Obj <i>*resultPtr</i> (out)</dt>
  <dd>Pre-allocated object in which to store (using
      <b>Tcl_ListObjAppendElement</b>) the list of files or directories which
      are successfully matched.</dd>
  <dt>int <i>mode</i> (in)</dt>
  <dd>Mask consisting of one or more of R_OK, W_OK, X_OK and F_OK. R_OK, W_OK
      and X_OK request checking whether the file exists and has read, write and
      execute permissions, respectively. F_OK just requests checking for the
      existence of the file.</dd>
  <dt>Tcl_StatBuf <i>*statPtr</i> (out)</dt>
  <dd>The structure that contains the result of a stat or lstat operation.</dd>
  <dt>const char <i>*sym1</i> (in)</dt>
  <dd>Name of a procedure to look up in the file's symbol table</dd>
  <dt>const char <i>*sym2</i> (in)</dt>
  <dd>Name of a procedure to look up in the file's symbol table</dd>
  <dt>Tcl_PackageInitProc <i>**proc1Ptr</i> (out)</dt>
  <dd>Filled with the init function for this code.</dd>
  <dt>Tcl_PackageInitProc <i>**proc2Ptr</i> (out)</dt>
  <dd>Filled with the safe-init function for this code.</dd>
  <dt>ClientData <i>*clientDataPtr</i> (out)</dt>
  <dd>Filled with the clientData value to pass to this code's unload function
      when it is called.</dd>
  <dt>Tcl_LoadHandle <i>*handlePtr</i> (out)</dt>
  <dd>Filled with an abstract token representing the loaded file.</dd>
  <dt>Tcl_FSUnloadFileProc <i>**unloadProcPtr</i> (out)</dt>
  <dd>Filled with the function to use to unload this piece of code.</dd>
  <dt>utimbuf <i>*tval</i> (in)</dt>
  <dd>The access and modification times in this structure are read and used to
      set those values for a given file.</dd>
  <dt>const char <i>*modeString</i> (in)</dt>
  <dd>Specifies how the file is to be accessed. May have any of the values
      allowed for the <i>mode</i> argument to the Tcl <b>open</b> command.</dd>
  <dt>int <i>permissions</i> (in)</dt>
  <dd>POSIX-style permission flags such as 0644. If a new file is created, these
      permissions will be set on the created file.</dd>
  <dt>int <i>*lenPtr</i> (out)</dt>
  <dd>If non-NULL, filled with the number of elements in the split path.</dd>
  <dt>Tcl_Obj <i>*basePtr</i> (in)</dt>
  <dd>The base path on to which to join the given elements. May be NULL.</dd>
  <dt>int <i>objc</i> (in)</dt>
  <dd>The number of elements in <i>objv</i>.</dd>
  <dt>Tcl_Obj *const <i>objv[]</i> (in)</dt>
  <dd>The elements to join to the given base path.</dd>
  <dt>Tcl_Obj <i>*linkNamePtr</i> (in)</dt>
  <dd>The name of the link to be created or read.</dd>
  <dt>Tcl_Obj <i>*toPtr</i> (in)</dt>
  <dd>What the link called <i>linkNamePtr</i> should be linked to, or NULL if
      the symbolic link specified by <i>linkNamePtr</i> is to be read.</dd>
  <dt>int <i>linkAction</i> (in)</dt>
  <dd>OR-ed combination of flags indicating what kind of link should be created
      (will be ignored if <i>toPtr</i> is NULL). Valid bits to set are
      <b>TCL_CREATE_SYMBOLIC_LINK</b> and <b>TCL_CREATE_HARD_LINK</b>. When both
      flags are set and the underlying filesystem can do either, symbolic links
      are preferred.
    <pre>

    </pre>
    <p class="Pp"></p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">There are several reasons for calling the <b>Tcl_FS</b> API
    functions (e.g. <b>Tcl_FSAccess</b> and <b>Tcl_FSStat</b>) rather than
    calling system level functions like <b>access</b> and <b>stat</b> directly.
    First, they will work cross-platform, so an extension which calls them
    should work unmodified on Unix and Windows. Second, the Windows
    implementation of some of these functions fixes some bugs in the system
    level calls. Third, these function calls deal with any &#x201C;Utf to
    platform-native&#x201D; path conversions which may be required (and may
    cache the results of such conversions for greater efficiency on subsequent
    calls). Fourth, and perhaps most importantly, all of these functions are
    &#x201C;virtual filesystem aware&#x201D;. Any virtual filesystem (VFS for
    short) which has been registered (through <b>Tcl_FSRegister</b>) may reroute
    file access to alternative media or access methods. This means that all of
    these functions (and therefore the corresponding <b>file</b>, <b>glob</b>,
    <b>pwd</b>, <b>cd</b>, <b>open</b>, etc. Tcl commands) may be operate on
    &#x201C;files&#x201D; which are not native files in the native filesystem.
    This also means that any Tcl extension which accesses the filesystem (FS for
    short) through this API is automatically &#x201C;virtual filesystem
    aware&#x201D;. Of course, if an extension accesses the native filesystem
    directly (through platform-specific APIs, for example), then Tcl cannot
    intercept such calls.</p>
<p class="Pp">If appropriate VFSes have been registered, the
    &#x201C;files&#x201D; may, to give two examples, be remote (e.g. situated on
    a remote ftp server) or archived (e.g. lying inside a .zip archive). Such
    registered filesystems provide a lookup table of functions to implement all
    or some of the functionality listed here. Finally, the <b>Tcl_FSStat</b> and
    <b>Tcl_FSLstat</b> calls abstract away from what the &#x201C;struct
    stat&#x201D; buffer is actually declared to be, allowing the same code to be
    used both on systems with and systems without support for files larger than
    2GB in size.</p>
<p class="Pp">The <b>Tcl_FS</b> API is objectified and may cache internal
    representations and other path-related strings (e.g. the current working
    directory). One side-effect of this is that one must not pass in objects
    with a reference count of zero to any of these functions. If such calls were
    handled, they might result in memory leaks (under some circumstances, the
    filesystem code may wish to retain a reference to the passed in object, and
    so one must not assume that after any of these calls return, the object
    still has a reference count of zero - it may have been incremented) or in a
    direct segmentation fault (or other memory access error) due to the object
    being freed part way through the complex object manipulation required to
    ensure that the path is fully normalized and absolute for filesystem
    determination. The practical lesson to learn from this is that</p>
<div class="Bd-indent">
<pre>
Tcl_Obj *path = Tcl_NewStringObj(...);
Tcl_FS<i>Whatever</i>(path);
Tcl_DecrRefCount(path);
</pre>
</div>
is wrong, and may cause memory errors. The <i>path</i> must have its reference
  count incremented before passing it in, or decrementing it. For this reason,
  objects with a reference count of zero are considered not to be valid
  filesystem paths and calling any Tcl_FS API function with such an object will
  result in no action being taken.
<section class="Ss">
<h2 class="Ss" id="FS_API_FUNCTIONS"><a class="permalink" href="#FS_API_FUNCTIONS">FS
  API FUNCTIONS</a></h2>
<p class="Pp"><b>Tcl_FSCopyFile</b> attempts to copy the file given by
    <i>srcPathPtr</i> to the path name given by <i>destPathPtr</i>. If the two
    paths given lie in the same filesystem (according to
    <b>Tcl_FSGetFileSystemForPath</b>) then that filesystem's &#x201C;copy
    file&#x201D; function is called (if it is non-NULL). Otherwise the function
    returns -1 and sets the <b>errno</b> global C variable to the
    &#x201C;EXDEV&#x201D; POSIX error code (which signifies a
    &#x201C;cross-domain link&#x201D;).</p>
<p class="Pp"><b>Tcl_FSCopyDirectory</b> attempts to copy the directory given by
    <i>srcPathPtr</i> to the path name given by <i>destPathPtr</i>. If the two
    paths given lie in the same filesystem (according to
    <b>Tcl_FSGetFileSystemForPath</b>) then that filesystem's &#x201C;copy
    file&#x201D; function is called (if it is non-NULL). Otherwise the function
    returns -1 and sets the <b>errno</b> global C variable to the
    &#x201C;EXDEV&#x201D; POSIX error code (which signifies a
    &#x201C;cross-domain link&#x201D;).</p>
<p class="Pp"><b>Tcl_FSCreateDirectory</b> attempts to create the directory
    given by <i>pathPtr</i> by calling the owning filesystem's &#x201C;create
    directory&#x201D; function.</p>
<p class="Pp"><b>Tcl_FSDeleteFile</b> attempts to delete the file given by
    <i>pathPtr</i> by calling the owning filesystem's &#x201C;delete
    file&#x201D; function.</p>
<p class="Pp"><b>Tcl_FSRemoveDirectory</b> attempts to remove the directory
    given by <i>pathPtr</i> by calling the owning filesystem's &#x201C;remove
    directory&#x201D; function.</p>
<p class="Pp"><b>Tcl_FSRenameFile</b> attempts to rename the file or directory
    given by <i>srcPathPtr</i> to the path name given by <i>destPathPtr</i>. If
    the two paths given lie in the same filesystem (according to
    <b>Tcl_FSGetFileSystemForPath</b>) then that filesystem's &#x201C;rename
    file&#x201D; function is called (if it is non-NULL). Otherwise the function
    returns -1 and sets the <b>errno</b> global C variable to the
    &#x201C;EXDEV&#x201D; POSIX error code (which signifies a
    &#x201C;cross-domain link&#x201D;).</p>
<p class="Pp"><b>Tcl_FSListVolumes</b> calls each filesystem which has a
    non-NULL &#x201C;list volumes&#x201D; function and asks them to return their
    list of root volumes. It accumulates the return values in a list which is
    returned to the caller (with a reference count of 0).</p>
<p class="Pp"><b>Tcl_FSEvalFileEx</b> reads the file given by <i>pathPtr</i>
    using the encoding identified by <i>encodingName</i> and evaluates its
    contents as a Tcl script. It returns the same information as
    <b>Tcl_EvalObjEx</b>. If <i>encodingName</i> is NULL, the system encoding is
    used for reading the file contents. If the file could not be read then a Tcl
    error is returned to describe why the file could not be read. The eofchar
    for files is &#x201C;\32&#x201D; (^Z) for all platforms. If you require a
    &#x201C;^Z&#x201D; in code for string comparison, you can use
    &#x201C;\032&#x201D; or &#x201C;\u001a&#x201D;, which will be safely
    substituted by the Tcl interpreter into &#x201C;^Z&#x201D;.
    <b>Tcl_FSEvalFile</b> is a simpler version of <b>Tcl_FSEvalFileEx</b> that
    always uses the system encoding when reading the file.</p>
<p class="Pp"><b>Tcl_FSLoadFile</b> dynamically loads a binary code file into
    memory and returns the addresses of two procedures within that file, if they
    are defined. The appropriate function for the filesystem to which
    <i>pathPtr</i> belongs will be called. If that filesystem does not implement
    this function (most virtual filesystems will not, because of OS limitations
    in dynamically loading binary code), Tcl will attempt to copy the file to a
    temporary directory and load that temporary file.</p>
<p class="Pp">Returns a standard Tcl completion code. If an error occurs, an
    error message is left in the <i>interp</i>'s result.</p>
<p class="Pp"><b>Tcl_FSMatchInDirectory</b> is used by the globbing code to
    search a directory for all files which match a given pattern. The
    appropriate function for the filesystem to which <i>pathPtr</i> belongs will
    be called.</p>
<p class="Pp">The return value is a standard Tcl result indicating whether an
    error occurred in globbing. Error messages are placed in interp (unless
    interp is NULL, which is allowed), but good results are placed in the
    resultPtr given.</p>
<p class="Pp">Note that the <b>glob</b> code implements recursive patterns
    internally, so this function will only ever be passed simple patterns, which
    can be matched using the logic of <b>string match</b>. To handle recursion,
    Tcl will call this function frequently asking only for directories to be
    returned. A special case of being called with a NULL pattern indicates that
    the path needs to be checked only for the correct type.</p>
<p class="Pp"><b>Tcl_FSLink</b> replaces the library version of <b>readlink</b>,
    and extends it to support the creation of links. The appropriate function
    for the filesystem to which <i>linkNamePtr</i> belongs will be called.</p>
<p class="Pp">If the <i>toPtr</i> is NULL, a &#x201C;read link&#x201D; action is
    performed. The result is a Tcl_Obj specifying the contents of the symbolic
    link given by <i>linkNamePtr</i>, or NULL if the link could not be read. The
    result is owned by the caller, which should call Tcl_DecrRefCount when the
    result is no longer needed. If the <i>toPtr</i> is not NULL, Tcl should
    create a link of one of the types passed in in the <i>linkAction</i> flag.
    This flag is an ORed combination of <b>TCL_CREATE_SYMBOLIC_LINK</b> and
    <b>TCL_CREATE_HARD_LINK</b>. Where a choice exists (i.e. more than one flag
    is passed in), the Tcl convention is to prefer symbolic links. When a link
    is successfully created, the return value should be <i>toPtr</i> (which is
    therefore already owned by the caller). If unsuccessful, NULL is
  returned.</p>
<p class="Pp"><b>Tcl_FSLstat</b> fills the stat structure <i>statPtr</i> with
    information about the specified file. You do not need any access rights to
    the file to get this information but you need search rights to all
    directories named in the path leading to the file. The stat structure
    includes info regarding device, inode (always 0 on Windows), privilege mode,
    nlink (always 1 on Windows), user id (always 0 on Windows), group id (always
    0 on Windows), rdev (same as device on Windows), size, last access time,
    last modification time, and creation time.</p>
<p class="Pp">If <i>path</i> exists, <b>Tcl_FSLstat</b> returns 0 and the stat
    structure is filled with data. Otherwise, -1 is returned, and no stat info
    is given.</p>
<p class="Pp"><b>Tcl_FSUtime</b> replaces the library version of utime.</p>
<p class="Pp">This returns 0 on success and -1 on error (as per the <b>utime</b>
    documentation). If successful, the function will update the
    &#x201C;atime&#x201D; and &#x201C;mtime&#x201D; values of the file
  given.</p>
<p class="Pp"><b>Tcl_FSFileAttrsGet</b> implements read access for the hookable
    <b>file</b> <b>attributes</b> subcommand. The appropriate function for the
    filesystem to which <i>pathPtr</i> belongs will be called.</p>
<p class="Pp">If the result is <b>TCL_OK</b>, then an object was placed in
    <i>objPtrRef</i>, which will only be temporarily valid (unless
    <b>Tcl_IncrRefCount</b> is called).</p>
<p class="Pp"><b>Tcl_FSFileAttrsSet</b> implements write access for the hookable
    <b>file</b> <b>attributes</b> subcommand. The appropriate function for the
    filesystem to which <i>pathPtr</i> belongs will be called.</p>
<p class="Pp"><b>Tcl_FSFileAttrStrings</b> implements part of the hookable
    <b>file</b> <b>attributes</b> subcommand. The appropriate function for the
    filesystem to which <i>pathPtr</i> belongs will be called.</p>
<p class="Pp">The called procedure may either return an array of strings, or may
    instead return NULL and place a Tcl list into the given <i>objPtrRef</i>.
    Tcl will take that list and first increment its reference count before using
    it. On completion of that use, Tcl will decrement its reference count. Hence
    if the list should be disposed of by Tcl when done, it should have a
    reference count of zero, and if the list should not be disposed of, the
    filesystem should ensure it retains a reference count to the object.</p>
<p class="Pp"><b>Tcl_FSAccess</b> checks whether the process would be allowed to
    read, write or test for existence of the file (or other filesystem object)
    whose name is <i>pathname</i>. If <i>pathname</i> is a symbolic link on
    Unix, then permissions of the file referred by this symbolic link are
    tested.</p>
<p class="Pp">On success (all requested permissions granted), zero is returned.
    On error (at least one bit in mode asked for a permission that is denied, or
    some other error occurred), -1 is returned.</p>
<p class="Pp"><b>Tcl_FSStat</b> fills the stat structure <i>statPtr</i> with
    information about the specified file. You do not need any access rights to
    the file to get this information but you need search rights to all
    directories named in the path leading to the file. The stat structure
    includes info regarding device, inode (always 0 on Windows), privilege mode,
    nlink (always 1 on Windows), user id (always 0 on Windows), group id (always
    0 on Windows), rdev (same as device on Windows), size, last access time,
    last modification time, and creation time.</p>
<p class="Pp">If <i>path</i> exists, <b>Tcl_FSStat</b> returns 0 and the stat
    structure is filled with data. Otherwise, -1 is returned, and no stat info
    is given.</p>
<p class="Pp"><b>Tcl_FSOpenFileChannel</b> opens a file specified by
    <i>pathPtr</i> and returns a channel handle that can be used to perform
    input and output on the file. This API is modeled after the <b>fopen</b>
    procedure of the Unix standard I/O library. The syntax and meaning of all
    arguments is similar to those given in the Tcl <b>open</b> command when
    opening a file. If an error occurs while opening the channel,
    <b>Tcl_FSOpenFileChannel</b> returns NULL and records a POSIX error code
    that can be retrieved with <b>Tcl_GetErrno</b>. In addition, if
    <i>interp</i> is non-NULL, <b>Tcl_FSOpenFileChannel</b> leaves an error
    message in <i>interp</i>'s result after any error.</p>
<p class="Pp">The newly created channel is not registered in the supplied
    interpreter; to register it, use <b>Tcl_RegisterChannel</b>, described
    below. If one of the standard channels, <b>stdin, stdout</b> or
    <b>stderr</b> was previously closed, the act of creating the new channel
    also assigns it as a replacement for the standard channel.</p>
<p class="Pp"><b>Tcl_FSGetCwd</b> replaces the library version of
  <b>getcwd</b>.</p>
<p class="Pp">It returns the Tcl library's current working directory. This may
    be different to the native platform's working directory, which happens when
    the current working directory is not in the native filesystem.</p>
<p class="Pp">The result is a pointer to a Tcl_Obj specifying the current
    directory, or NULL if the current directory could not be determined. If NULL
    is returned, an error message is left in the <i>interp</i>'s result.</p>
<p class="Pp">The result already has its reference count incremented for the
    caller. When it is no longer needed, that reference count should be
    decremented. This is needed for thread-safety purposes, to allow multiple
    threads to access this and related functions, while ensuring the results are
    always valid.</p>
<p class="Pp"><b>Tcl_FSChdir</b> replaces the library version of <b>chdir</b>.
    The path is normalized and then passed to the filesystem which claims it. If
    that filesystem does not implement this function, Tcl will fallback to a
    combination of <b>stat</b> and <b>access</b> to check whether the directory
    exists and has appropriate permissions.</p>
<p class="Pp">For results, see <b>chdir</b> documentation. If successful, we
    keep a record of the successful path in <i>cwdPathPtr</i> for subsequent
    calls to <b>Tcl_FSGetCwd</b>.</p>
<p class="Pp"><b>Tcl_FSPathSeparator</b> returns the separator character to be
    used for most specific element of the path specified by <i>pathPtr</i> (i.e.
    the last part of the path).</p>
<p class="Pp">The separator is returned as a Tcl_Obj containing a string of
    length 1. If the path is invalid, NULL is returned.</p>
<p class="Pp"><b>Tcl_FSJoinPath</b> takes the given Tcl_Obj, which must be a
    valid list (which is allowed to have a reference count of zero), and returns
    the path object given by considering the first <i>elements</i> elements as
    valid path segments (each path segment may be a complete path, a partial
    path or just a single possible directory or file name). If any path segment
    is actually an absolute path, then all prior path segments are discarded. If
    <i>elements</i> is less than 0, we use the entire list.</p>
<p class="Pp">It is possible that the returned object is actually an element of
    the given list, so the caller should be careful to increment the reference
    count of the result before freeing the list.</p>
<p class="Pp">The returned object, typically with a reference count of zero (but
    it could be shared under some conditions), contains the joined path. The
    caller must add a reference count to the object before using it. In
    particular, the returned object could be an element of the given list, so
    freeing the list might free the object prematurely if no reference count has
    been taken. If the number of elements is zero, then the returned object will
    be an empty-string Tcl_Obj.</p>
<p class="Pp"><b>Tcl_FSSplitPath</b> takes the given Tcl_Obj, which should be a
    valid path, and returns a Tcl list object containing each segment of that
    path as an element. It returns a list object with a reference count of zero.
    If the passed in <i>lenPtr</i> is non-NULL, the variable it points to will
    be updated to contain the number of elements in the returned list.</p>
<p class="Pp"><b>Tcl_FSEqualPaths</b> tests whether the two paths given
    represent the same filesystem object</p>
<p class="Pp">It returns 1 if the paths are equal, and 0 if they are different.
    If either path is NULL, 0 is always returned.</p>
<p class="Pp"><b>Tcl_FSGetNormalizedPath</b> this important function attempts to
    extract from the given Tcl_Obj a unique normalized path representation,
    whose string value can be used as a unique identifier for the file.</p>
<p class="Pp">It returns the normalized path object, owned by Tcl, or NULL if
    the path was invalid or could otherwise not be successfully converted.
    Extraction of absolute, normalized paths is very efficient (because the
    filesystem operates on these representations internally), although the
    result when the filesystem contains numerous symbolic links may not be the
    most user-friendly version of a path. The return value is owned by Tcl and
    has a lifetime equivalent to that of the <i>pathPtr</i> passed in (unless
    that is a relative path, in which case the normalized path object may be
    freed any time the cwd changes) - the caller can of course increment the
    refCount if it wishes to maintain a copy for longer.</p>
<p class="Pp"><b>Tcl_FSJoinToPath</b> takes the given object, which should
    usually be a valid path or NULL, and joins onto it the array of paths
    segments given.</p>
<p class="Pp">Returns object, typically with refCount of zero (but it could be
    shared under some conditions), containing the joined path. The caller must
    add a refCount to the object before using it. If any of the objects passed
    into this function (pathPtr or path elements) have a refCount of zero, they
    will be freed when this function returns.</p>
<p class="Pp"><b>Tcl_FSConvertToPathType</b> tries to convert the given Tcl_Obj
    to a valid Tcl path type, taking account of the fact that the cwd may have
    changed even if this object is already supposedly of the correct type. The
    filename may begin with &#x201C;~&#x201D; (to indicate current user's home
    directory) or &#x201C;~&lt;user&gt;&#x201D; (to indicate any user's home
    directory).</p>
<p class="Pp">If the conversion succeeds (i.e. the object is a valid path in one
    of the current filesystems), then <b>TCL_OK</b> is returned. Otherwise
    <b>TCL_ERROR</b> is returned, and an error message may be left in the
    interpreter.</p>
<p class="Pp"><b>Tcl_FSGetInternalRep</b> extracts the internal representation
    of a given path object, in the given filesystem. If the path object belongs
    to a different filesystem, we return NULL. If the internal representation is
    currently NULL, we attempt to generate it, by calling the filesystem's
    <b>Tcl_FSCreateInternalRepProc</b>.</p>
<p class="Pp">Returns NULL or a valid internal path representation. This
    internal representation is cached, so that repeated calls to this function
    will not require additional conversions.</p>
<p class="Pp"><b>Tcl_FSGetTranslatedPath</b> attempts to extract the translated
    path from the given Tcl_Obj.</p>
<p class="Pp">If the translation succeeds (i.e. the object is a valid path),
    then it is returned. Otherwise NULL will be returned, and an error message
    may be left in the interpreter. A &#x201C;translated&#x201D; path is one
    which contains no &#x201C;~&#x201D; or &#x201C;~user&#x201D; sequences
    (these have been expanded to their current representation in the
    filesystem). The object returned is owned by the caller, which must store it
    or call Tcl_DecrRefCount to ensure memory is freed. This function is of
    little practical use, and <b>Tcl_FSGetNormalizedPath</b> or
    <b>Tcl_GetNativePath</b> are usually better functions to use for most
    purposes.</p>
<p class="Pp"><b>Tcl_FSGetTranslatedStringPath</b> does the same as
    <b>Tcl_FSGetTranslatedPath</b>, but returns a character string or NULL. The
    string returned is dynamically allocated and owned by the caller, which must
    store it or call <b>ckfree</b> to ensure it is freed. Again,
    <b>Tcl_FSGetNormalizedPath</b> or <b>Tcl_GetNativePath</b> are usually
    better functions to use for most purposes.</p>
<p class="Pp"><b>Tcl_FSNewNativePath</b> performs something like the reverse of
    the usual obj-&gt;path-&gt;nativerep conversions. If some code retrieves a
    path in native form (from, e.g. <b>readlink</b> or a native dialog), and
    that path is to be used at the Tcl level, then calling this function is an
    efficient way of creating the appropriate path object type.</p>
<p class="Pp">The resulting object is a pure &#x201C;path&#x201D; object, which
    will only receive a UTF-8 string representation if that is required by some
    Tcl code.</p>
<p class="Pp"><b>Tcl_FSGetNativePath</b> is for use by the Win/Unix native
    filesystems, so that they can easily retrieve the native (char* or TCHAR*)
    representation of a path. This function is a convenience wrapper around
    <b>Tcl_FSGetInternalRep</b>, and assumes the native representation is
    string-based. It may be desirable in the future to have non-string-based
    native representations (for example, on MacOSX, a representation using a
    fileSpec of FSRef structure would probably be more efficient). On Windows a
    full Unicode representation would allow for paths of unlimited length.
    Currently the representation is simply a character string which may contain
    either the relative path or a complete, absolute normalized path in the
    native encoding (complex conditions dictate which of these will be provided,
    so neither can be relied upon, unless the path is known to be absolute). If
    you need a native path which must be absolute, then you should ask for the
    native version of a normalized path. If for some reason a non-absolute,
    non-normalized version of the path is needed, that must be constructed
    separately (e.g. using <b>Tcl_FSGetTranslatedPath</b>).</p>
<p class="Pp">The native representation is cached so that repeated calls to this
    function will not require additional conversions. The return value is owned
    by Tcl and has a lifetime equivalent to that of the <i>pathPtr</i> passed in
    (unless that is a relative path, in which case the native representation may
    be freed any time the cwd changes).</p>
<p class="Pp"><b>Tcl_FSFileSystemInfo</b> returns a list of two elements. The
    first element is the name of the filesystem (e.g. &#x201C;native&#x201D;,
    &#x201C;vfs&#x201D;, &#x201C;zip&#x201D;, or &#x201C;prowrap&#x201D;,
    perhaps), and the second is the particular type of the given path within
    that filesystem (which is filesystem dependent). The second element may be
    empty if the filesystem does not provide a further categorization of
  files.</p>
<p class="Pp">A valid list object is returned, unless the path object is not
    recognized, when NULL will be returned.</p>
<p class="Pp"><b>Tcl_FSGetFileSystemForPath</b> returns the a pointer to the
    <b>Tcl_Filesystem</b> which accepts this path as valid.</p>
<p class="Pp">If no filesystem will accept the path, NULL is returned.</p>
<p class="Pp"><b>Tcl_FSGetPathType</b> determines whether the given path is
    relative to the current directory, relative to the current volume, or
    absolute.</p>
<p class="Pp">It returns one of <b>TCL_PATH_ABSOLUTE</b>,
    <b>TCL_PATH_RELATIVE</b>, or <b>TCL_PATH_VOLUME_RELATIVE</b></p>
<p class="Pp"><b>Tcl_AllocStatBuf</b> allocates a <i>Tcl_StatBuf</i> on the
    system heap (which may be deallocated by being passed to <b>ckfree</b>.)
    This allows extensions to invoke <b>Tcl_FSStat</b> and <b>Tcl_FSLStat</b>
    without being dependent on the size of the buffer. That in turn depends on
    the flags used to build Tcl.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="THE_VIRTUAL_FILESYSTEM_API"><a class="permalink" href="#THE_VIRTUAL_FILESYSTEM_API">THE
  VIRTUAL FILESYSTEM API</a></h1>
<p class="Pp">A filesystem provides a <b>Tcl_Filesystem</b> structure that
    contains pointers to functions that implement the various operations on a
    filesystem; these operations are invoked as needed by the generic layer,
    which generally occurs through the functions listed above.</p>
<p class="Pp">The <b>Tcl_Filesystem</b> structures are manipulated using the
    following methods.</p>
<p class="Pp"><b>Tcl_FSRegister</b> takes a pointer to a filesystem structure
    and an optional piece of data to associated with that filesystem. On calling
    this function, Tcl will attach the filesystem to the list of known
    filesystems, and it will become fully functional immediately. Tcl does not
    check if the same filesystem is registered multiple times (and in general
    that is not a good thing to do). <b>TCL_OK</b> will be returned.</p>
<p class="Pp"><b>Tcl_FSUnregister</b> removes the given filesystem structure
    from the list of known filesystems, if it is known, and returns
    <b>TCL_OK</b>. If the filesystem is not currently registered,
    <b>TCL_ERROR</b> is returned.</p>
<p class="Pp"><b>Tcl_FSData</b> will return the ClientData associated with the
    given filesystem, if that filesystem is registered. Otherwise it will return
    NULL.</p>
<p class="Pp"><b>Tcl_FSMountsChanged</b> is used to inform the Tcl's core that
    the set of mount points for the given (already registered) filesystem have
    changed, and that cached file representations may therefore no longer be
    correct.</p>
<section class="Ss">
<h2 class="Ss" id="THE_TCL_FILESYSTEM_STRUCTURE"><a class="permalink" href="#THE_TCL_FILESYSTEM_STRUCTURE">THE
  TCL_FILESYSTEM STRUCTURE</a></h2>
<p class="Pp">The <b>Tcl_Filesystem</b> structure contains the following
  fields:</p>
<div class="Bd-indent">
<pre>
typedef struct Tcl_Filesystem {
    const char *<i>typeName</i>;
    int <i>structureLength</i>;
    Tcl_FSVersion <i>version</i>;
    Tcl_FSPathInFilesystemProc *<i>pathInFilesystemProc</i>;
    Tcl_FSDupInternalRepProc *<i>dupInternalRepProc</i>;
    Tcl_FSFreeInternalRepProc *<i>freeInternalRepProc</i>;
    Tcl_FSInternalToNormalizedProc *<i>internalToNormalizedProc</i>;
    Tcl_FSCreateInternalRepProc *<i>createInternalRepProc</i>;
    Tcl_FSNormalizePathProc *<i>normalizePathProc</i>;
    Tcl_FSFilesystemPathTypeProc *<i>filesystemPathTypeProc</i>;
    Tcl_FSFilesystemSeparatorProc *<i>filesystemSeparatorProc</i>;
    Tcl_FSStatProc *<i>statProc</i>;
    Tcl_FSAccessProc *<i>accessProc</i>;
    Tcl_FSOpenFileChannelProc *<i>openFileChannelProc</i>;
    Tcl_FSMatchInDirectoryProc *<i>matchInDirectoryProc</i>;
    Tcl_FSUtimeProc *<i>utimeProc</i>;
    Tcl_FSLinkProc *<i>linkProc</i>;
    Tcl_FSListVolumesProc *<i>listVolumesProc</i>;
    Tcl_FSFileAttrStringsProc *<i>fileAttrStringsProc</i>;
    Tcl_FSFileAttrsGetProc *<i>fileAttrsGetProc</i>;
    Tcl_FSFileAttrsSetProc *<i>fileAttrsSetProc</i>;
    Tcl_FSCreateDirectoryProc *<i>createDirectoryProc</i>;
    Tcl_FSRemoveDirectoryProc *<i>removeDirectoryProc</i>;
    Tcl_FSDeleteFileProc *<i>deleteFileProc</i>;
    Tcl_FSCopyFileProc *<i>copyFileProc</i>;
    Tcl_FSRenameFileProc *<i>renameFileProc</i>;
    Tcl_FSCopyDirectoryProc *<i>copyDirectoryProc</i>;
    Tcl_FSLstatProc *<i>lstatProc</i>;
    Tcl_FSLoadFileProc *<i>loadFileProc</i>;
    Tcl_FSGetCwdProc *<i>getCwdProc</i>;
    Tcl_FSChdirProc *<i>chdirProc</i>;
} Tcl_Filesystem;
</pre>
</div>
<p class="Pp">Except for the first three fields in this structure which contain
    simple data elements, all entries contain addresses of functions called by
    the generic filesystem layer to perform the complete range of filesystem
    related actions.</p>
<p class="Pp">The many functions in this structure are broken down into three
    categories: infrastructure functions (almost all of which must be
    implemented), operational functions (which must be implemented if a complete
    filesystem is provided), and efficiency functions (which need only be
    implemented if they can be done so efficiently, or if they have side-effects
    which are required by the filesystem; Tcl has less efficient emulations it
    can fall back on). It is important to note that, in the current version of
    Tcl, most of these fallbacks are only used to handle commands initiated in
    Tcl, not in C. What this means is, that if a <b>file rename</b> command is
    issued in Tcl, and the relevant filesystem(s) do not implement their
    <i>Tcl_FSRenameFileProc</i>, Tcl's core will instead fallback on a
    combination of other filesystem functions (it will use
    <i>Tcl_FSCopyFileProc</i> followed by <i>Tcl_FSDeleteFileProc</i>, and if
    <i>Tcl_FSCopyFileProc</i> is not implemented there is a further fallback).
    However, if a <i>Tcl_FSRenameFileProc</i> command is issued at the C level,
    no such fallbacks occur. This is true except for the last four entries in
    the filesystem table (<b>lstat</b>, <b>load</b>, <b>getcwd</b> and
    <b>chdir</b>) for which fallbacks do in fact occur at the C level.</p>
<p class="Pp">Any functions which take path names in Tcl_Obj form take those
    names in UTF-8 form. The filesystem infrastructure API is designed to
    support efficient, cached conversion of these UTF-8 paths to other native
    representations.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="EXAMPLE_FILESYSTEM_DEFINITION"><a class="permalink" href="#EXAMPLE_FILESYSTEM_DEFINITION">EXAMPLE
  FILESYSTEM DEFINITION</a></h2>
<p class="Pp">Here is the filesystem lookup table used by the
    &#x201C;vfs&#x201D; extension which allows filesystem actions to be
    implemented in Tcl.</p>
<div class="Bd-indent">
<pre>
static Tcl_Filesystem vfsFilesystem = {
    &quot;tclvfs&quot;,
    sizeof(Tcl_Filesystem),
    TCL_FILESYSTEM_VERSION_1,
    &amp;VfsPathInFilesystem,
    &amp;VfsDupInternalRep,
    &amp;VfsFreeInternalRep,
    /* No internal to normalized, since we don't create
     * any pure 'internal' Tcl_Obj path representations */
    NULL,
    /* No create native rep function, since we don't use
     * it and don't choose to support uses of
     * Tcl_FSNewNativePath */
    NULL,
    /* Normalize path isn't needed - we assume paths only
     * have one representation */
    NULL,
    &amp;VfsFilesystemPathType,
    &amp;VfsFilesystemSeparator,
    &amp;VfsStat,
    &amp;VfsAccess,
    &amp;VfsOpenFileChannel,
    &amp;VfsMatchInDirectory,
    &amp;VfsUtime,
    /* We choose not to support symbolic links inside our
     * VFS's */
    NULL,
    &amp;VfsListVolumes,
    &amp;VfsFileAttrStrings,
    &amp;VfsFileAttrsGet,
    &amp;VfsFileAttrsSet,
    &amp;VfsCreateDirectory,
    &amp;VfsRemoveDirectory,
    &amp;VfsDeleteFile,
    /* No copy file; use the core fallback mechanism */
    NULL,
    /* No rename file; use the core fallback mechanism */
    NULL,
    /* No copy directory; use the core fallback mechanism */
    NULL,
    /* Core will use stat for lstat */
    NULL,
    /* No load; use the core fallback mechanism */
    NULL,
    /* We don't need a getcwd or chdir; the core's own
     * internal value is suitable */
    NULL,
    NULL
};
</pre>
</div>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="FILESYSTEM_INFRASTRUCTURE"><a class="permalink" href="#FILESYSTEM_INFRASTRUCTURE">FILESYSTEM
  INFRASTRUCTURE</a></h1>
<p class="Pp">These fields contain basic information about the filesystem
    structure and addresses of functions which are used to associate a
    particular filesystem with a file path, and deal with the internal handling
    of path representations, for example copying and freeing such
    representations.</p>
<section class="Ss">
<h2 class="Ss" id="TYPENAME"><a class="permalink" href="#TYPENAME">TYPENAME</a></h2>
<p class="Pp">The <i>typeName</i> field contains a null-terminated string that
    identifies the type of the filesystem implemented, e.g.
    &#x201C;native&#x201D;, &#x201C;zip&#x201D; or &#x201C;vfs&#x201D;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="STRUCTURE_LENGTH"><a class="permalink" href="#STRUCTURE_LENGTH">STRUCTURE
  LENGTH</a></h2>
<p class="Pp">The <i>structureLength</i> field is generally implemented as
    <i>sizeof(Tcl_Filesystem)</i>, and is there to allow easier binary backwards
    compatibility if the size of the structure changes in a future Tcl
  release.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h2>
<p class="Pp">The <i>version</i> field should be set to
    <b>TCL_FILESYSTEM_VERSION_1</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="PATHINFILESYSTEMPROC"><a class="permalink" href="#PATHINFILESYSTEMPROC">PATHINFILESYSTEMPROC</a></h2>
<p class="Pp">The <i>pathInFilesystemProc</i> field contains the address of a
    function which is called to determine whether a given path object belongs to
    this filesystem or not. Tcl will only call the rest of the filesystem
    functions with a path for which this function has returned <b>TCL_OK</b>. If
    the path does not belong, -1 should be returned (the behaviour of Tcl for
    any other return value is not defined). If <b>TCL_OK</b> is returned, then
    the optional <i>clientDataPtr</i> output parameter can be used to return an
    internal (filesystem specific) representation of the path, which will be
    cached inside the path object, and may be retrieved efficiently by the other
    filesystem functions. Tcl will simultaneously cache the fact that this path
    belongs to this filesystem. Such caches are invalidated when filesystem
    structures are added or removed from Tcl's internal list of known
    filesystems.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef int Tcl_FSPathInFilesystemProc(
        Tcl_Obj *<i>pathPtr</i>,
        ClientData *<i>clientDataPtr</i>);
</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="DUPINTERNALREPPROC"><a class="permalink" href="#DUPINTERNALREPPROC">DUPINTERNALREPPROC</a></h2>
<p class="Pp">This function makes a copy of a path's internal representation,
    and is called when Tcl needs to duplicate a path object. If NULL, Tcl will
    simply not copy the internal representation, which may then need to be
    regenerated later.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef ClientData Tcl_FSDupInternalRepProc(
        ClientData <i>clientData</i>);
</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="FREEINTERNALREPPROC"><a class="permalink" href="#FREEINTERNALREPPROC">FREEINTERNALREPPROC</a></h2>
<p class="Pp">Free the internal representation. This must be implemented if
    internal representations need freeing (i.e. if some memory is allocated when
    an internal representation is generated), but may otherwise be NULL.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef void Tcl_FSFreeInternalRepProc(
        ClientData <i>clientData</i>);
</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="INTERNALTONORMALIZEDPROC"><a class="permalink" href="#INTERNALTONORMALIZEDPROC">INTERNALTONORMALIZEDPROC</a></h2>
<p class="Pp">Function to convert internal representation to a normalized path.
    Only required if the filesystem creates pure path objects with no
    string/path representation. The return value is a Tcl object whose string
    representation is the normalized path.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef Tcl_Obj* Tcl_FSInternalToNormalizedProc(
        ClientData <i>clientData</i>);
</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="CREATEINTERNALREPPROC"><a class="permalink" href="#CREATEINTERNALREPPROC">CREATEINTERNALREPPROC</a></h2>
<p class="Pp">Function to take a path object, and calculate an internal
    representation for it, and store that native representation in the object.
    May be NULL if paths have no internal representation, or if the
    <i>Tcl_FSPathInFilesystemProc</i> for this filesystem always immediately
    creates an internal representation for paths it accepts.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef ClientData Tcl_FSCreateInternalRepProc(
        Tcl_Obj *<i>pathPtr</i>);
</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="NORMALIZEPATHPROC"><a class="permalink" href="#NORMALIZEPATHPROC">NORMALIZEPATHPROC</a></h2>
<p class="Pp">Function to normalize a path. Should be implemented for all
    filesystems which can have multiple string representations for the same path
    object. In Tcl, every &#x201C;path&#x201D; must have a single unique
    &#x201C;normalized&#x201D; string representation. Depending on the
    filesystem, there may be more than one unnormalized string representation
    which refers to that path (e.g. a relative path, a path with different
    character case if the filesystem is case insensitive, a path contain a
    reference to a home directory such as &#x201C;~&#x201D;, a path containing
    symbolic links, etc). If the very last component in the path is a symbolic
    link, it should not be converted into the object it points to (but its case
    or other aspects should be made unique). All other path components should be
    converted from symbolic links. This one exception is required to agree with
    Tcl's semantics with <b>file</b> <b>delete</b>, <b>file rename</b>, <b>file
    copy</b> operating on symbolic links. This function may be called with
    <i>nextCheckpoint</i> either at the beginning of the path (i.e. zero), at
    the end of the path, or at any intermediate file separator in the path. It
    will never point to any other arbitrary position in the path. In the last of
    the three valid cases, the implementation can assume that the path up to and
    including the file separator is known and normalized.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef int Tcl_FSNormalizePathProc(
        Tcl_Interp *<i>interp</i>,
        Tcl_Obj *<i>pathPtr</i>,
        int <i>nextCheckpoint</i>);
</pre>
</div>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="FILESYSTEM_OPERATIONS"><a class="permalink" href="#FILESYSTEM_OPERATIONS">FILESYSTEM
  OPERATIONS</a></h1>
<p class="Pp">The fields in this section of the structure contain addresses of
    functions which are called to carry out the basic filesystem operations. A
    filesystem which expects to be used with the complete standard Tcl command
    set must implement all of these. If some of them are not implemented, then
    certain Tcl commands may fail when operating on paths within that
    filesystem. However, in some instances this may be desirable (for example, a
    read-only filesystem should not implement the last four functions, and a
    filesystem which does not support symbolic links need not implement the
    <b>readlink</b> function, etc. The Tcl core expects filesystems to behave in
    this way).</p>
<section class="Ss">
<h2 class="Ss" id="FILESYSTEMPATHTYPEPROC"><a class="permalink" href="#FILESYSTEMPATHTYPEPROC">FILESYSTEMPATHTYPEPROC</a></h2>
<p class="Pp">Function to determine the type of a path in this filesystem. May
    be NULL, in which case no type information will be available to users of the
    filesystem. The &#x201C;type&#x201D; is used only for informational
    purposes, and should be returned as the string representation of the Tcl_Obj
    which is returned. A typical return value might be
    &#x201C;networked&#x201D;, &#x201C;zip&#x201D; or &#x201C;ftp&#x201D;. The
    Tcl_Obj result is owned by the filesystem and so Tcl will increment the
    refCount of that object if it wishes to retain a reference to it.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef Tcl_Obj* Tcl_FSFilesystemPathTypeProc(
        Tcl_Obj *<i>pathPtr</i>);
</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="FILESYSTEMSEPARATORPROC"><a class="permalink" href="#FILESYSTEMSEPARATORPROC">FILESYSTEMSEPARATORPROC</a></h2>
<p class="Pp">Function to return the separator character(s) for this filesystem.
    This need only be implemented if the filesystem wishes to use a different
    separator than the standard string &#x201C;/&#x201D;. Amongst other uses, it
    is returned by the <b>file separator</b> command. The return value should be
    an object with refCount of zero.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef Tcl_Obj* Tcl_FSFilesystemSeparatorProc(
        Tcl_Obj *<i>pathPtr</i>);
</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="STATPROC"><a class="permalink" href="#STATPROC">STATPROC</a></h2>
<p class="Pp">Function to process a <b>Tcl_FSStat</b> call. Must be implemented
    for any reasonable filesystem, since many Tcl level commands depend
    crucially upon it (e.g. <b>file atime</b>, <b>file isdirectory</b>, <b>file
    size</b>, <b>glob</b>).</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef int Tcl_FSStatProc(
        Tcl_Obj *<i>pathPtr</i>,
        Tcl_StatBuf *<i>statPtr</i>);
</pre>
</div>
<p class="Pp">The <b>Tcl_FSStatProc</b> fills the stat structure <i>statPtr</i>
    with information about the specified file. You do not need any access rights
    to the file to get this information but you need search rights to all
    directories named in the path leading to the file. The stat structure
    includes info regarding device, inode (always 0 on Windows), privilege mode,
    nlink (always 1 on Windows), user id (always 0 on Windows), group id (always
    0 on Windows), rdev (same as device on Windows), size, last access time,
    last modification time, and creation time.</p>
<p class="Pp">If the file represented by <i>pathPtr</i> exists, the
    <b>Tcl_FSStatProc</b> returns 0 and the stat structure is filled with data.
    Otherwise, -1 is returned, and no stat info is given.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ACCESSPROC"><a class="permalink" href="#ACCESSPROC">ACCESSPROC</a></h2>
<p class="Pp">Function to process a <b>Tcl_FSAccess</b> call. Must be
    implemented for any reasonable filesystem, since many Tcl level commands
    depend crucially upon it (e.g. <b>file exists</b>, <b>file
  readable</b>).</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef int Tcl_FSAccessProc(
        Tcl_Obj *<i>pathPtr</i>,
        int <i>mode</i>);
</pre>
</div>
<p class="Pp">The <b>Tcl_FSAccessProc</b> checks whether the process would be
    allowed to read, write or test for existence of the file (or other
    filesystem object) whose name is in <i>pathPtr</i>. If the pathname refers
    to a symbolic link, then the permissions of the file referred by this
    symbolic link should be tested.</p>
<p class="Pp">On success (all requested permissions granted), zero is returned.
    On error (at least one bit in mode asked for a permission that is denied, or
    some other error occurred), -1 is returned.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="OPENFILECHANNELPROC"><a class="permalink" href="#OPENFILECHANNELPROC">OPENFILECHANNELPROC</a></h2>
<p class="Pp">Function to process a <b>Tcl_FSOpenFileChannel</b> call. Must be
    implemented for any reasonable filesystem, since any operations which
    require open or accessing a file's contents will use it (e.g. <b>open</b>,
    <b>encoding</b>, and many Tk commands).</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef Tcl_Channel Tcl_FSOpenFileChannelProc(
        Tcl_Interp *<i>interp</i>,
        Tcl_Obj *<i>pathPtr</i>,
        int <i>mode</i>,
        int <i>permissions</i>);
</pre>
</div>
<p class="Pp">The <b>Tcl_FSOpenFileChannelProc</b> opens a file specified by
    <i>pathPtr</i> and returns a channel handle that can be used to perform
    input and output on the file. This API is modeled after the <b>fopen</b>
    procedure of the Unix standard I/O library. The syntax and meaning of all
    arguments is similar to those given in the Tcl <b>open</b> command when
    opening a file, where the <i>mode</i> argument is a combination of the POSIX
    flags O_RDONLY, O_WRONLY, etc. If an error occurs while opening the channel,
    the <b>Tcl_FSOpenFileChannelProc</b> returns NULL and records a POSIX error
    code that can be retrieved with <b>Tcl_GetErrno</b>. In addition, if
    <i>interp</i> is non-NULL, the <b>Tcl_FSOpenFileChannelProc</b> leaves an
    error message in <i>interp</i>'s result after any error.</p>
<p class="Pp">The newly created channel is not registered in the supplied
    interpreter; to register it, use <b>Tcl_RegisterChannel</b>. If one of the
    standard channels, <b>stdin, stdout</b> or <b>stderr</b> was previously
    closed, the act of creating the new channel also assigns it as a replacement
    for the standard channel.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="MATCHINDIRECTORYPROC"><a class="permalink" href="#MATCHINDIRECTORYPROC">MATCHINDIRECTORYPROC</a></h2>
<p class="Pp">Function to process a <b>Tcl_FSMatchInDirectory</b> call. If not
    implemented, then glob and recursive copy functionality will be lacking in
    the filesystem (and this may impact commands like <b>encoding names</b>
    which use glob functionality internally).</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef int Tcl_FSMatchInDirectoryProc(
        Tcl_Interp* <i>interp</i>,
        Tcl_Obj *<i>resultPtr</i>,
        Tcl_Obj *<i>pathPtr</i>,
        const char *<i>pattern</i>,
        Tcl_GlobTypeData *<i>types</i>);
</pre>
</div>
<p class="Pp">The function should return all files or directories (or other
    filesystem objects) which match the given pattern and accord with the
    <i>types</i> specification given. There are two ways in which this function
    may be called. If <i>pattern</i> is NULL, then <i>pathPtr</i> is a full path
    specification of a single file or directory which should be checked for
    existence and correct type. Otherwise, <i>pathPtr</i> is a directory, the
    contents of which the function should search for files or directories which
    have the correct type. In either case, <i>pathPtr</i> can be assumed to be
    both non-NULL and non-empty. It is not currently documented whether
    <i>pathPtr</i> will have a file separator at its end of not, so code should
    be flexible to both possibilities.</p>
<p class="Pp">The return value is a standard Tcl result indicating whether an
    error occurred in the matching process. Error messages are placed in
    <i>interp</i>, unless <i>interp</i> in NULL in which case no error message
    need be generated; on a <b>TCL_OK</b> result, results should be added to the
    <i>resultPtr</i> object given (which can be assumed to be a valid unshared
    Tcl list). The matches added to <i>resultPtr</i> should include any path
    prefix given in <i>pathPtr</i> (this usually means they will be absolute
    path specifications). Note that if no matches are found, that simply leads
    to an empty result; errors are only signaled for actual file or filesystem
    problems which may occur during the matching process.</p>
<p class="Pp">The <b>Tcl_GlobTypeData</b> structure passed in the <i>types</i>
    parameter contains the following fields:</p>
<div class="Bd-indent">
<pre>
typedef struct Tcl_GlobTypeData {
        /* Corresponds to bcdpfls as in 'find -t' */
        int <i>type</i>;
        /* Corresponds to file permissions */
        int <i>perm</i>;
        /* Acceptable mac type */
        Tcl_Obj *<i>macType</i>;
        /* Acceptable mac creator */
        Tcl_Obj *<i>macCreator</i>;
} Tcl_GlobTypeData;
</pre>
</div>
<p class="Pp">There are two specific cases which it is important to handle
    correctly, both when <i>types</i> is non-NULL. The two cases are when
    <i>types-&gt;types</i> <i>&amp; TCL_GLOB_TYPE_DIR</i> or <i>types-&gt;types
    &amp; TCL_GLOB_TYPE_MOUNT</i> are true (and in particular when the other
    flags are false). In the first of these cases, the function must list the
    contained directories. Tcl uses this to implement recursive globbing, so it
    is critical that filesystems implement directory matching correctly. In the
    second of these cases, with <b>TCL_GLOB_TYPE_MOUNT</b>, the filesystem must
    list the mount points which lie within the given <i>pathPtr</i> (and in this
    case, <i>pathPtr</i> need not lie within the same filesystem - different to
    all other cases in which this function is called). Support for this is
    critical if Tcl is to have seamless transitions between from one filesystem
    to another.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="UTIMEPROC"><a class="permalink" href="#UTIMEPROC">UTIMEPROC</a></h2>
<p class="Pp">Function to process a <b>Tcl_FSUtime</b> call. Required to allow
    setting (not reading) of times with <b>file mtime</b>, <b>file atime</b> and
    the open-r/open-w/fcopy implementation of <b>file copy</b>.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef int Tcl_FSUtimeProc(
        Tcl_Obj *<i>pathPtr</i>,
        struct utimbuf *<i>tval</i>);
</pre>
</div>
<p class="Pp">The access and modification times of the file specified by
    <i>pathPtr</i> should be changed to the values given in the <i>tval</i>
    structure.</p>
<p class="Pp">The return value should be 0 on success and -1 on an error, as
    with the system <b>utime</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="LINKPROC"><a class="permalink" href="#LINKPROC">LINKPROC</a></h2>
<p class="Pp">Function to process a <b>Tcl_FSLink</b> call. Should be
    implemented only if the filesystem supports links, and may otherwise be
    NULL.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef Tcl_Obj* Tcl_FSLinkProc(
        Tcl_Obj *<i>linkNamePtr</i>,
        Tcl_Obj *<i>toPtr</i>,
        int <i>linkAction</i>);
</pre>
</div>
<p class="Pp">If <i>toPtr</i> is NULL, the function is being asked to read the
    contents of a link. The result is a Tcl_Obj specifying the contents of the
    link given by <i>linkNamePtr</i>, or NULL if the link could not be read. The
    result is owned by the caller (and should therefore have its ref count
    incremented before being returned). Any callers should call Tcl_DecrRefCount
    on this result when it is no longer needed. If <i>toPtr</i> is not NULL, the
    function should attempt to create a link. The result in this case should be
    <i>toPtr</i> if the link was successful and NULL otherwise. In this case the
    result is not owned by the caller (i.e. no ref count manipulation on either
    end is needed). See the documentation for <b>Tcl_FSLink</b> for the correct
    interpretation of the <i>linkAction</i> flags.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="LISTVOLUMESPROC"><a class="permalink" href="#LISTVOLUMESPROC">LISTVOLUMESPROC</a></h2>
<p class="Pp">Function to list any filesystem volumes added by this filesystem.
    Should be implemented only if the filesystem adds volumes at the head of the
    filesystem, so that they can be returned by <b>file volumes</b>.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef Tcl_Obj* Tcl_FSListVolumesProc(void);
</pre>
</div>
<p class="Pp">The result should be a list of volumes added by this filesystem,
    or NULL (or an empty list) if no volumes are provided. The result object is
    considered to be owned by the filesystem (not by Tcl's core), but should be
    given a refCount for Tcl. Tcl will use the contents of the list and then
    decrement that refCount. This allows filesystems to choose whether they
    actually want to retain a &#x201C;master list&#x201D; of volumes or not (if
    not, they generate the list on the fly and pass it to Tcl with a refCount of
    1 and then forget about the list, if yes, then they simply increment the
    refCount of their master list and pass it to Tcl which will copy the
    contents and then decrement the count back to where it was).</p>
<p class="Pp">Therefore, Tcl considers return values from this proc to be
    read-only.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="FILEATTRSTRINGSPROC"><a class="permalink" href="#FILEATTRSTRINGSPROC">FILEATTRSTRINGSPROC</a></h2>
<p class="Pp">Function to list all attribute strings which are valid for this
    filesystem. If not implemented the filesystem will not support the <b>file
    attributes</b> command. This allows arbitrary additional information to be
    attached to files in the filesystem. If it is not implemented, there is no
    need to implement the <b>get</b> and <b>set</b> methods.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef const char** Tcl_FSFileAttrStringsProc(
        Tcl_Obj *<i>pathPtr</i>,
        Tcl_Obj** <i>objPtrRef</i>);
</pre>
</div>
<p class="Pp">The called function may either return an array of strings, or may
    instead return NULL and place a Tcl list into the given <i>objPtrRef</i>.
    Tcl will take that list and first increment its reference count before using
    it. On completion of that use, Tcl will decrement its reference count. Hence
    if the list should be disposed of by Tcl when done, it should have a
    reference count of zero, and if the list should not be disposed of, the
    filesystem should ensure it returns an object with a reference count of at
    least one.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="FILEATTRSGETPROC"><a class="permalink" href="#FILEATTRSGETPROC">FILEATTRSGETPROC</a></h2>
<p class="Pp">Function to process a <b>Tcl_FSFileAttrsGet</b> call, used by
    <b>file</b> <b>attributes</b>.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef int Tcl_FSFileAttrsGetProc(
        Tcl_Interp *<i>interp</i>,
        int <i>index</i>,
        Tcl_Obj *<i>pathPtr</i>,
        Tcl_Obj **<i>objPtrRef</i>);
</pre>
</div>
<p class="Pp">Returns a standard Tcl return code. The attribute value retrieved,
    which corresponds to the <i>index</i>'th element in the list returned by the
    <b>Tcl_FSFileAttrStringsProc</b>, is a Tcl_Obj placed in <i>objPtrRef</i>
    (if <b>TCL_OK</b> was returned) and is likely to have a reference count of
    zero. Either way we must either store it somewhere (e.g. the Tcl result), or
    Incr/Decr its reference count to ensure it is properly freed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="FILEATTRSSETPROC"><a class="permalink" href="#FILEATTRSSETPROC">FILEATTRSSETPROC</a></h2>
<p class="Pp">Function to process a <b>Tcl_FSFileAttrsSet</b> call, used by
    <b>file</b> <b>attributes</b>. If the filesystem is read-only, there is no
    need to implement this.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef int Tcl_FSFileAttrsSetProc(
        Tcl_Interp *<i>interp</i>,
        int <i>index</i>,
        Tcl_Obj *<i>pathPtr</i>,
        Tcl_Obj *<i>objPtr</i>);
</pre>
</div>
<p class="Pp">The attribute value of the <i>index</i>'th element in the list
    returned by the Tcl_FSFileAttrStringsProc should be set to the <i>objPtr</i>
    given.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="CREATEDIRECTORYPROC"><a class="permalink" href="#CREATEDIRECTORYPROC">CREATEDIRECTORYPROC</a></h2>
<p class="Pp">Function to process a <b>Tcl_FSCreateDirectory</b> call. Should be
    implemented unless the FS is read-only.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef int Tcl_FSCreateDirectoryProc(
        Tcl_Obj *<i>pathPtr</i>);
</pre>
</div>
<p class="Pp">The return value is a standard Tcl result indicating whether an
    error occurred in the process. If successful, a new directory should have
    been added to the filesystem in the location specified by
  <i>pathPtr</i>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="REMOVEDIRECTORYPROC"><a class="permalink" href="#REMOVEDIRECTORYPROC">REMOVEDIRECTORYPROC</a></h2>
<p class="Pp">Function to process a <b>Tcl_FSRemoveDirectory</b> call. Should be
    implemented unless the FS is read-only.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef int Tcl_FSRemoveDirectoryProc(
        Tcl_Obj *<i>pathPtr</i>,
        int <i>recursive</i>,
        Tcl_Obj **<i>errorPtr</i>);
</pre>
</div>
<p class="Pp">The return value is a standard Tcl result indicating whether an
    error occurred in the process. If successful, the directory specified by
    <i>pathPtr</i> should have been removed from the filesystem. If the
    <i>recursive</i> flag is given, then a non-empty directory should be deleted
    without error. If this flag is not given, then and the directory is
    non-empty a POSIX &#x201C;EEXIST&#x201D; error should be signaled. If an
    error does occur, the name of the file or directory which caused the error
    should be placed in <i>errorPtr</i>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="DELETEFILEPROC"><a class="permalink" href="#DELETEFILEPROC">DELETEFILEPROC</a></h2>
<p class="Pp">Function to process a <b>Tcl_FSDeleteFile</b> call. Should be
    implemented unless the FS is read-only.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef int Tcl_FSDeleteFileProc(
        Tcl_Obj *<i>pathPtr</i>);
</pre>
</div>
<p class="Pp">The return value is a standard Tcl result indicating whether an
    error occurred in the process. If successful, the file specified by
    <i>pathPtr</i> should have been removed from the filesystem. Note that, if
    the filesystem supports symbolic links, Tcl will always call this function
    and not Tcl_FSRemoveDirectoryProc when needed to delete them (even if they
    are symbolic links to directories).</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="FILESYSTEM_EFFICIENCY"><a class="permalink" href="#FILESYSTEM_EFFICIENCY">FILESYSTEM
  EFFICIENCY</a></h1>
<p class="Pp">These functions need not be implemented for a particular
    filesystem because the core has a fallback implementation available. See
    each individual description for the consequences of leaving the field
  NULL.</p>
<section class="Ss">
<h2 class="Ss" id="LSTATPROC"><a class="permalink" href="#LSTATPROC">LSTATPROC</a></h2>
<p class="Pp">Function to process a <b>Tcl_FSLstat</b> call. If not implemented,
    Tcl will attempt to use the <i>statProc</i> defined above instead. Therefore
    it need only be implemented if a filesystem can differentiate between
    <b>stat</b> and <b>lstat</b> calls.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef int Tcl_FSLstatProc(
        Tcl_Obj *<i>pathPtr</i>,
        Tcl_StatBuf *<i>statPtr</i>);
</pre>
</div>
<p class="Pp">The behavior of this function is very similar to that of the
    <b>Tcl_FSStatProc</b> defined above, except that if it is applied to a
    symbolic link, it returns information about the link, not about the target
    file.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="COPYFILEPROC"><a class="permalink" href="#COPYFILEPROC">COPYFILEPROC</a></h2>
<p class="Pp">Function to process a <b>Tcl_FSCopyFile</b> call. If not
    implemented Tcl will fall back on <b>open</b>-r, <b>open</b>-w and
    <b>fcopy</b> as a copying mechanism. Therefore it need only be implemented
    if the filesystem can perform that action more efficiently.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef int Tcl_FSCopyFileProc(
        Tcl_Obj *<i>srcPathPtr</i>,
        Tcl_Obj *<i>destPathPtr</i>);
</pre>
</div>
<p class="Pp">The return value is a standard Tcl result indicating whether an
    error occurred in the copying process. Note that, <i>destPathPtr</i> is the
    name of the file which should become the copy of <i>srcPathPtr</i>. It is
    never the name of a directory into which <i>srcPathPtr</i> could be copied
    (i.e. the function is much simpler than the Tcl level <b>file</b>
    <b>copy</b> subcommand). Note that, if the filesystem supports symbolic
    links, Tcl will always call this function and not <i>copyDirectoryProc</i>
    when needed to copy them (even if they are symbolic links to directories).
    Finally, if the filesystem determines it cannot support the <b>file copy</b>
    action, calling <b>Tcl_SetErrno(EXDEV)</b> and returning a non-<b>TCL_OK</b>
    result will tell Tcl to use its standard fallback mechanisms.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="RENAMEFILEPROC"><a class="permalink" href="#RENAMEFILEPROC">RENAMEFILEPROC</a></h2>
<p class="Pp">Function to process a <b>Tcl_FSRenameFile</b> call. If not
    implemented, Tcl will fall back on a copy and delete mechanism. Therefore it
    need only be implemented if the filesystem can perform that action more
    efficiently.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef int Tcl_FSRenameFileProc(
        Tcl_Obj *<i>srcPathPtr</i>,
        Tcl_Obj *<i>destPathPtr</i>);
</pre>
</div>
<p class="Pp">The return value is a standard Tcl result indicating whether an
    error occurred in the renaming process. If the filesystem determines it
    cannot support the <b>file rename</b> action, calling
    <b>Tcl_SetErrno(EXDEV)</b> and returning a non-<b>TCL_OK</b> result will
    tell Tcl to use its standard fallback mechanisms.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="COPYDIRECTORYPROC"><a class="permalink" href="#COPYDIRECTORYPROC">COPYDIRECTORYPROC</a></h2>
<p class="Pp">Function to process a <b>Tcl_FSCopyDirectory</b> call. If not
    implemented, Tcl will fall back on a recursive <b>file mkdir</b>, <b>file
    copy</b> mechanism. Therefore it need only be implemented if the filesystem
    can perform that action more efficiently.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef int Tcl_FSCopyDirectoryProc(
        Tcl_Obj *<i>srcPathPtr</i>,
        Tcl_Obj *<i>destPathPtr</i>,
        Tcl_Obj **<i>errorPtr</i>);
</pre>
</div>
<p class="Pp">The return value is a standard Tcl result indicating whether an
    error occurred in the copying process. If an error does occur, the name of
    the file or directory which caused the error should be placed in
    <i>errorPtr</i>. Note that, <i>destPathPtr</i> is the name of the
    directory-name which should become the mirror-image of <i>srcPathPtr</i>. It
    is not the name of a directory into which <i>srcPathPtr</i> should be copied
    (i.e. the function is much simpler than the Tcl level <b>file copy</b>
    subcommand). Finally, if the filesystem determines it cannot support the
    directory copy action, calling <b>Tcl_SetErrno(EXDEV)</b> and returning a
    non-<b>TCL_OK</b> result will tell Tcl to use its standard fallback
    mechanisms.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="LOADFILEPROC"><a class="permalink" href="#LOADFILEPROC">LOADFILEPROC</a></h2>
<p class="Pp">Function to process a <b>Tcl_FSLoadFile</b> call. If not
    implemented, Tcl will fall back on a copy to native-temp followed by a
    <b>Tcl_FSLoadFile</b> on that temporary copy. Therefore it need only be
    implemented if the filesystem can load code directly, or it can be
    implemented simply to return <b>TCL_ERROR</b> to disable load functionality
    in this filesystem entirely.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef int Tcl_FSLoadFileProc(
        Tcl_Interp *<i>interp</i>,
        Tcl_Obj *<i>pathPtr</i>,
        Tcl_LoadHandle *<i>handlePtr</i>,
        Tcl_FSUnloadFileProc *<i>unloadProcPtr</i>);
</pre>
</div>
<p class="Pp">Returns a standard Tcl completion code. If an error occurs, an
    error message is left in the <i>interp</i>'s result. The function
    dynamically loads a binary code file into memory. On a successful load, the
    <i>handlePtr</i> should be filled with a token for the dynamically loaded
    file, and the <i>unloadProcPtr</i> should be filled in with the address of a
    procedure. The unload procedure will be called with the given
    <b>Tcl_LoadHandle</b> as its only parameter when Tcl needs to unload the
    file. For example, for the native filesystem, the <b>Tcl_LoadHandle</b>
    returned is currently a token which can be used in the private
    <b>TclpFindSymbol</b> to access functions in the new code. Each filesystem
    is free to define the <b>Tcl_LoadHandle</b> as it requires. Finally, if the
    filesystem determines it cannot support the file load action, calling
    <b>Tcl_SetErrno(EXDEV)</b> and returning a non-<b>TCL_OK</b> result will
    tell Tcl to use its standard fallback mechanisms.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="UNLOADFILEPROC"><a class="permalink" href="#UNLOADFILEPROC">UNLOADFILEPROC</a></h2>
<p class="Pp">Function to unload a previously successfully loaded file. If load
    was implemented, then this should also be implemented, if there is any
    cleanup action required.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef void Tcl_FSUnloadFileProc(
        Tcl_LoadHandle <i>loadHandle</i>);
</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="GETCWDPROC"><a class="permalink" href="#GETCWDPROC">GETCWDPROC</a></h2>
<p class="Pp">Function to process a <b>Tcl_FSGetCwd</b> call. Most filesystems
    need not implement this. It will usually only be called once, if
    <b>getcwd</b> is called before <b>chdir</b>. May be NULL.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef Tcl_Obj* Tcl_FSGetCwdProc(
        Tcl_Interp *<i>interp</i>);
</pre>
</div>
<p class="Pp">If the filesystem supports a native notion of a current working
    directory (which might perhaps change independent of Tcl), this function
    should return that cwd as the result, or NULL if the current directory could
    not be determined (e.g. the user does not have appropriate permissions on
    the cwd directory). If NULL is returned, an error message is left in the
    <i>interp</i>'s result.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="CHDIRPROC"><a class="permalink" href="#CHDIRPROC">CHDIRPROC</a></h2>
<p class="Pp">Function to process a <b>Tcl_FSChdir</b> call. If filesystems do
    not implement this, it will be emulated by a series of directory access
    checks. Otherwise, virtual filesystems which do implement it need only
    respond with a positive return result if the <i>pathPtr</i> is a valid,
    accessible directory in their filesystem. They need not remember the result,
    since that will be automatically remembered for use by <b>Tcl_FSGetCwd</b>.
    Real filesystems should carry out the correct action (i.e. call the correct
    system <b>chdir</b> API).</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
typedef int Tcl_FSChdirProc(
        Tcl_Obj *<i>pathPtr</i>);
</pre>
</div>
<p class="Pp">The <b>Tcl_FSChdirProc</b> changes the applications current
    working directory to the value specified in <i>pathPtr</i>. The function
    returns -1 on error or 0 on success.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">cd(n), file(n), load(n), open(n), pwd(n), unload(n)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
<p class="Pp">stat, access, filesystem, vfs, virtual</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">8.4</td>
    <td class="foot-os">Tcl</td>
  </tr>
</table>
</body>
</html>

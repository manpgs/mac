<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Copyright (c) 1989-1993 The Regents of the University of California.
   Copyright (c) 1994-1996 Sun Microsystems, Inc.
  
   See the file "license.terms" for information on usage and redistribution
   of this file, and for a DISCLAIMER OF ALL WARRANTIES.
  
   RCS: @(#) $Id: Hash.3,v 1.26.2.2 2009/11/27 14:53:54 dkf Exp $
  
   The -*- nroff -*- definitions below are for supplemental macros used
   in Tcl/Tk manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO ?manpage?
  	Start of list of standard options for a Tk widget. The manpage
  	argument defines where to look up the standard options; if
  	omitted, defaults to "options". The options follow on successive
  	lines, in three columns separated by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   .QW arg1 ?arg2?
  	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
  
   .PQ arg1 ?arg2?
  	Print an open parenthesis, arg1 in quotes, then arg2 normally
  	(for trailing punctuation) and then a closing parenthesis.
  
   RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Tcl_Hash(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Tcl_Hash(3)</td>
    <td class="head-vol"><a href=".">Tcl Library Procedures</a></td>
    <td class="head-rtitle">Tcl_Hash(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>
</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Tcl_InitHashTable, Tcl_InitCustomHashTable, Tcl_InitObjHashTable,
    Tcl_DeleteHashTable, Tcl_CreateHashEntry, Tcl_DeleteHashEntry,
    Tcl_FindHashEntry, Tcl_GetHashValue, Tcl_SetHashValue, Tcl_GetHashKey,
    Tcl_FirstHashEntry, Tcl_NextHashEntry, Tcl_HashStats - procedures to manage
    hash tables</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre><b>#include &lt;tcl.h&gt;</b>

<b>Tcl_InitHashTable</b>(<i>tablePtr, keyType</i>)

<b>Tcl_InitCustomHashTable</b>(<i>tablePtr, keyType, typePtr</i>)

<b>Tcl_InitObjHashTable</b>(<i>tablePtr</i>)

<b>Tcl_DeleteHashTable</b>(<i>tablePtr</i>)

Tcl_HashEntry *
<b>Tcl_CreateHashEntry</b>(<i>tablePtr, key, newPtr</i>)

<b>Tcl_DeleteHashEntry</b>(<i>entryPtr</i>)

Tcl_HashEntry *
<b>Tcl_FindHashEntry</b>(<i>tablePtr, key</i>)

ClientData
<b>Tcl_GetHashValue</b>(<i>entryPtr</i>)

<b>Tcl_SetHashValue</b>(<i>entryPtr, value</i>)

char *
<b>Tcl_GetHashKey</b>(<i>tablePtr, entryPtr</i>)

Tcl_HashEntry *
<b>Tcl_FirstHashEntry</b>(<i>tablePtr, searchPtr</i>)

Tcl_HashEntry *
<b>Tcl_NextHashEntry</b>(<i>searchPtr</i>)

char *
<b>Tcl_HashStats</b>(<i>tablePtr</i>)</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="ARGUMENTS"><a class="permalink" href="#ARGUMENTS">ARGUMENTS</a></h1>
<dl class="Bl-tag">
  <dt>Tcl_HashTable <i>*tablePtr</i> (in)</dt>
  <dd>Address of hash table structure (for all procedures but
      <b>Tcl_InitHashTable</b>, this must have been initialized by previous call
      to <b>Tcl_InitHashTable</b>).</dd>
  <dt>int <i>keyType</i> (in)</dt>
  <dd>Kind of keys to use for new hash table. Must be either
      <b>TCL_STRING_KEYS</b>, <b>TCL_ONE_WORD_KEYS</b>,
      <b>TCL_CUSTOM_TYPE_KEYS</b>, <b>TCL_CUSTOM_PTR_KEYS</b>, or an integer
      value greater than 1.</dd>
  <dt>Tcl_HashKeyType <i>*typePtr</i> (in)</dt>
  <dd>Address of structure which defines the behaviour of the hash table.</dd>
  <dt>const char <i>*key</i> (in)</dt>
  <dd>Key to use for probe into table. Exact form depends on <i>keyType</i> used
      to create table.</dd>
  <dt>int <i>*newPtr</i> (out)</dt>
  <dd>The word at <i>*newPtr</i> is set to 1 if a new entry was created and 0 if
      there was already an entry for <i>key</i>.</dd>
  <dt>Tcl_HashEntry <i>*entryPtr</i> (in)</dt>
  <dd>Pointer to hash table entry.</dd>
  <dt>ClientData <i>value</i> (in)</dt>
  <dd>New value to assign to hash table entry. Need not have type ClientData,
      but must fit in same space as ClientData.</dd>
  <dt>Tcl_HashSearch <i>*searchPtr</i> (in)</dt>
  <dd>Pointer to record to use to keep track of progress in enumerating all the
      entries in a hash table.
    <pre>
    </pre>
    <br/>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">A hash table consists of zero or more entries, each consisting of
    a key and a value. Given the key for an entry, the hashing routines can very
    quickly locate the entry, and hence its value. There may be at most one
    entry in a hash table with a particular key, but many entries may have the
    same value. Keys can take one of four forms: strings, one-word values,
    integer arrays, or custom keys defined by a Tcl_HashKeyType structure (See
    section <b>THE TCL_HASHKEYTYPE</b> <b>STRUCTURE</b> below). All of the keys
    in a given table have the same form, which is specified when the table is
    initialized.</p>
<p class="Pp">The value of a hash table entry can be anything that fits in the
    same space as a &#x201C;char *&#x201D; pointer. Values for hash table
    entries are managed entirely by clients, not by the hash module itself.
    Typically each entry's value is a pointer to a data structure managed by
    client code.</p>
<p class="Pp">Hash tables grow gracefully as the number of entries increases, so
    that there are always less than three entries per hash bucket, on average.
    This allows for fast lookups regardless of the number of entries in a
  table.</p>
<p class="Pp">The core provides three functions for the initialization of hash
    tables, Tcl_InitHashTable, Tcl_InitObjHashTable and
  Tcl_InitCustomHashTable.</p>
<p class="Pp"><b>Tcl_InitHashTable</b> initializes a structure that describes a
    new hash table. The space for the structure is provided by the caller, not
    by the hash module. The value of <i>keyType</i> indicates what kinds of keys
    will be used for all entries in the table. All of the key types described
    later are allowed, with the exception of <b>TCL_CUSTOM_TYPE_KEYS</b> and
    <b>TCL_CUSTOM_PTR_KEYS</b>.</p>
<p class="Pp"><b>Tcl_InitObjHashTable</b> is a wrapper around
    <b>Tcl_InitCustomHashTable</b> and initializes a hash table whose keys are
    Tcl_Obj *.</p>
<p class="Pp"><b>Tcl_InitCustomHashTable</b> initializes a structure that
    describes a new hash table. The space for the structure is provided by the
    caller, not by the hash module. The value of <i>keyType</i> indicates what
    kinds of keys will be used for all entries in the table. <i>KeyType</i> must
    have one of the following values:</p>
<dl class="Bl-tag">
  <dt id="TCL_STRING_KEYS"><a class="permalink" href="#TCL_STRING_KEYS"><b>TCL_STRING_KEYS</b></a></dt>
  <dd>Keys are null-terminated strings. They are passed to hashing routines
      using the address of the first character of the string.</dd>
  <dt id="TCL_ONE_WORD_KEYS"><a class="permalink" href="#TCL_ONE_WORD_KEYS"><b>TCL_ONE_WORD_KEYS</b></a></dt>
  <dd>Keys are single-word values; they are passed to hashing routines and
      stored in hash table entries as &#x201C;char *&#x201D; values. The pointer
      value is the key; it need not (and usually does not) actually point to a
      string.</dd>
  <dt id="TCL_CUSTOM_TYPE_KEYS"><a class="permalink" href="#TCL_CUSTOM_TYPE_KEYS"><b>TCL_CUSTOM_TYPE_KEYS</b></a></dt>
  <dd>Keys are of arbitrary type, and are stored in the entry. Hashing and
      comparison is determined by <i>typePtr</i>. The Tcl_HashKeyType structure
      is described in the section <b>THE TCL_HASHKEYTYPE STRUCTURE</b>
    below.</dd>
  <dt id="TCL_CUSTOM_PTR_KEYS"><a class="permalink" href="#TCL_CUSTOM_PTR_KEYS"><b>TCL_CUSTOM_PTR_KEYS</b></a></dt>
  <dd>Keys are pointers to an arbitrary type, and are stored in the entry.
      Hashing and comparison is determined by <i>typePtr</i>. The
      Tcl_HashKeyType structure is described in the section <b>THE
      TCL_HASHKEYTYPE STRUCTURE</b> below.</dd>
  <dt id="other"><a class="permalink" href="#other"><i>other</i></a></dt>
  <dd>If <i>keyType</i> is not one of the above, then it must be an integer
      value greater than 1. In this case the keys will be arrays of
      &#x201C;int&#x201D; values, where <i>keyType</i> gives the number of ints
      in each key. This allows structures to be used as keys. All keys must have
      the same size. Array keys are passed into hashing functions using the
      address of the first int in the array.</dd>
</dl>
<p class="Pp"><b>Tcl_DeleteHashTable</b> deletes all of the entries in a hash
    table and frees up the memory associated with the table's bucket array and
    entries. It does not free the actual table structure (pointed to by
    <i>tablePtr</i>), since that memory is assumed to be managed by the client.
    <b>Tcl_DeleteHashTable</b> also does not free or otherwise manipulate the
    values of the hash table entries. If the entry values point to
    dynamically-allocated memory, then it is the client's responsibility to free
    these structures before deleting the table.</p>
<p class="Pp"><b>Tcl_CreateHashEntry</b> locates the entry corresponding to a
    particular key, creating a new entry in the table if there was not already
    one with the given key. If an entry already existed with the given key then
    <i>*newPtr</i> is set to zero. If a new entry was created, then
    <i>*newPtr</i> is set to a non-zero value and the value of the new entry
    will be set to zero. The return value from <b>Tcl_CreateHashEntry</b> is a
    pointer to the entry, which may be used to retrieve and modify the entry's
    value or to delete the entry from the table.</p>
<p class="Pp"><b>Tcl_DeleteHashEntry</b> will remove an existing entry from a
    table. The memory associated with the entry itself will be freed, but the
    client is responsible for any cleanup associated with the entry's value,
    such as freeing a structure that it points to.</p>
<p class="Pp"><b>Tcl_FindHashEntry</b> is similar to <b>Tcl_CreateHashEntry</b>
    except that it does not create a new entry if the key doesn't exist;
    instead, it returns NULL as result.</p>
<p class="Pp"><b>Tcl_GetHashValue</b> and <b>Tcl_SetHashValue</b> are used to
    read and write an entry's value, respectively. Values are stored and
    retrieved as type &#x201C;ClientData&#x201D;, which is large enough to hold
    a pointer value. On almost all machines this is large enough to hold an
    integer value too.</p>
<p class="Pp"><b>Tcl_GetHashKey</b> returns the key for a given hash table
    entry, either as a pointer to a string, a one-word (&#x201C;char *&#x201D;)
    key, or as a pointer to the first word of an array of integers, depending on
    the <i>keyType</i> used to create a hash table. In all cases
    <b>Tcl_GetHashKey</b> returns a result with type &#x201C;char *&#x201D;.
    When the key is a string or array, the result of <b>Tcl_GetHashKey</b>
    points to information in the table entry; this information will remain valid
    until the entry is deleted or its table is deleted.</p>
<p class="Pp"><b>Tcl_FirstHashEntry</b> and <b>Tcl_NextHashEntry</b> may be used
    to scan all of the entries in a hash table. A structure of type
    &#x201C;Tcl_HashSearch&#x201D;, provided by the client, is used to keep
    track of progress through the table. <b>Tcl_FirstHashEntry</b> initializes
    the search record and returns the first entry in the table (or NULL if the
    table is empty). Each subsequent call to <b>Tcl_NextHashEntry</b> returns
    the next entry in the table or NULL if the end of the table has been
    reached. A call to <b>Tcl_FirstHashEntry</b> followed by calls to
    <b>Tcl_NextHashEntry</b> will return each of the entries in the table
    exactly once, in an arbitrary order. It is inadvisable to modify the
    structure of the table, e.g. by creating or deleting entries, while the
    search is in progress, with the exception of deleting the entry returned by
    <b>Tcl_FirstHashEntry</b> or <b>Tcl_NextHashEntry</b>.</p>
<p class="Pp"><b>Tcl_HashStats</b> returns a dynamically-allocated string with
    overall information about a hash table, such as the number of entries it
    contains, the number of buckets in its hash array, and the utilization of
    the buckets. It is the caller's responsibility to free the result string by
    passing it to <b>ckfree</b>.</p>
<p class="Pp">The header file <b>tcl.h</b> defines the actual data structures
    used to implement hash tables. This is necessary so that clients can
    allocate Tcl_HashTable structures and so that macros can be used to read and
    write the values of entries. However, users of the hashing routines should
    never refer directly to any of the fields of any of the hash-related data
    structures; use the procedures and macros defined here.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="THE_TCL_HASHKEYTYPE_STRUCTURE"><a class="permalink" href="#THE_TCL_HASHKEYTYPE_STRUCTURE">THE
  TCL_HASHKEYTYPE STRUCTURE</a></h1>
<p class="Pp">Extension writers can define new hash key types by defining four
    procedures, initializing a <b>Tcl_HashKeyType</b> structure to describe the
    type, and calling <b>Tcl_InitCustomHashTable</b>. The <b>Tcl_HashKeyType</b>
    structure is defined as follows:</p>
<div class="Bd-indent">
<pre>
typedef struct Tcl_HashKeyType {
    int <i>version</i>;
    int <i>flags</i>;
    Tcl_HashKeyProc *<i>hashKeyProc</i>;
    Tcl_CompareHashKeysProc *<i>compareKeysProc</i>;
    Tcl_AllocHashEntryProc *<i>allocEntryProc</i>;
    Tcl_FreeHashEntryProc *<i>freeEntryProc</i>;
} Tcl_HashKeyType;</pre>
</div>
<p class="Pp">The <i>version</i> member is the version of the table. If this
    structure is extended in future then the version can be used to distinguish
    between different structures. It should be set to
    <b>TCL_HASH_KEY_TYPE_VERSION</b>.</p>
<p class="Pp">The <i>flags</i> member is 0 or one or more of the following
    values OR'ed together:</p>
<dl class="Bl-tag">
  <dt id="TCL_HASH_KEY_RANDOMIZE_HASH"><a class="permalink" href="#TCL_HASH_KEY_RANDOMIZE_HASH"><b>TCL_HASH_KEY_RANDOMIZE_HASH</b></a></dt>
  <dd>There are some things, pointers for example which do not hash well because
      they do not use the lower bits. If this flag is set then the hash table
      will attempt to rectify this by randomizing the bits and then using the
      upper N bits as the index into the table.</dd>
  <dt id="TCL_HASH_KEY_SYSTEM_HASH"><a class="permalink" href="#TCL_HASH_KEY_SYSTEM_HASH"><b>TCL_HASH_KEY_SYSTEM_HASH</b></a></dt>
  <dd>This flag forces Tcl to use the memory allocation procedures provided by
      the operating system when allocating and freeing memory used to store the
      hash table data structures, and not any of Tcl's own customized memory
      allocation routines. This is important if the hash table is to be used in
      the implementation of a custom set of allocation routines, or something
      that a custom set of allocation routines might depend on, in order to
      avoid any circular dependency.</dd>
</dl>
<p class="Pp">The <i>hashKeyProc</i> member contains the address of a function
    called to calculate a hash value for the key.</p>
<div class="Bd-indent">
<pre>
typedef unsigned int (Tcl_HashKeyProc) (
        Tcl_HashTable *<i>tablePtr</i>,
        void *<i>keyPtr</i>);</pre>
</div>
If this is NULL then <i>keyPtr</i> is used and
  <b>TCL_HASH_KEY_RANDOMIZE_HASH</b> is assumed.
<p class="Pp">The <i>compareKeysProc</i> member contains the address of a
    function called to compare two keys.</p>
<div class="Bd-indent">
<pre>
typedef int (Tcl_CompareHashKeysProc) (
        void *<i>keyPtr</i>,
        Tcl_HashEntry *<i>hPtr</i>);</pre>
</div>
If this is NULL then the <i>keyPtr</i> pointers are compared. If the keys do not
  match then the function returns 0, otherwise it returns 1.
<p class="Pp">The <i>allocEntryProc</i> member contains the address of a
    function called to allocate space for an entry and initialize the key and
    clientData.</p>
<div class="Bd-indent">
<pre>
typedef Tcl_HashEntry *(Tcl_AllocHashEntryProc) (
        Tcl_HashTable *<i>tablePtr</i>,
        void *<i>keyPtr</i>);</pre>
</div>
If this is NULL then Tcl_Alloc is used to allocate enough space for a
  Tcl_HashEntry, the key pointer is assigned to key.oneWordValue and the
  clientData is set to NULL. String keys and array keys use this function to
  allocate enough space for the entry and the key in one block, rather than
  doing it in two blocks. This saves space for a pointer to the key from the
  entry and another memory allocation. Tcl_Obj* keys use this function to
  allocate enough space for an entry and increment the reference count on the
  object.
<p class="Pp">The <i>freeEntryProc</i> member contains the address of a function
    called to free space for an entry.</p>
<div class="Bd-indent">
<pre>
typedef void (Tcl_FreeHashEntryProc) (Tcl_HashEntry *<i>hPtr</i>);</pre>
</div>
If this is NULL then Tcl_Free is used to free the space for the entry. Tcl_Obj*
  keys use this function to decrement the reference count on the object.
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
<p class="Pp">hash table, key, lookup, search, value</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date"></td>
    <td class="foot-os"><a href="..">Tcl</a></td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Copyright (c) 1994-1997 Sun Microsystems, Inc.
  
   See the file "license.terms" for information on usage and redistribution
   of this file, and for a DISCLAIMER OF ALL WARRANTIES.
  
   RCS: @(#) $Id: StringObj.3,v 1.26 2007/12/13 15:22:32 dgp Exp $
  
   The -*- nroff -*- definitions below are for supplemental macros used
   in Tcl/Tk manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO ?manpage?
  	Start of list of standard options for a Tk widget. The manpage
  	argument defines where to look up the standard options; if
  	omitted, defaults to "options". The options follow on successive
  	lines, in three columns separated by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   .QW arg1 ?arg2?
  	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
  
   .PQ arg1 ?arg2?
  	Print an open parenthesis, arg1 in quotes, then arg2 normally
  	(for trailing punctuation) and then a closing parenthesis.
  
   RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>Tcl_StringObj(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Tcl_StringObj(3)</td>
    <td class="head-vol"><a href=".">Tcl Library Procedures</a></td>
    <td class="head-rtitle">Tcl_StringObj(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>
</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">Tcl_NewStringObj, Tcl_NewUnicodeObj, Tcl_SetStringObj,
    Tcl_SetUnicodeObj, Tcl_GetStringFromObj, Tcl_GetString,
    Tcl_GetUnicodeFromObj, Tcl_GetUnicode, Tcl_GetUniChar, Tcl_GetCharLength,
    Tcl_GetRange, Tcl_AppendToObj, Tcl_AppendUnicodeToObj, Tcl_AppendObjToObj,
    Tcl_AppendStringsToObj, Tcl_AppendStringsToObjVA, Tcl_AppendLimitedToObj,
    Tcl_Format, Tcl_AppendFormatToObj, Tcl_ObjPrintf, Tcl_AppendPrintfToObj,
    Tcl_SetObjLength, Tcl_AttemptSetObjLength, Tcl_ConcatObj - manipulate Tcl
    objects as strings</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre><b>#include &lt;tcl.h&gt;</b>

Tcl_Obj *
<b>Tcl_NewStringObj</b>(<i>bytes, length</i>)

Tcl_Obj *
<b>Tcl_NewUnicodeObj</b>(<i>unicode, numChars</i>)

void
<b>Tcl_SetStringObj</b>(<i>objPtr, bytes, length</i>)

void
<b>Tcl_SetUnicodeObj</b>(<i>objPtr, unicode, numChars</i>)

char *
<b>Tcl_GetStringFromObj</b>(<i>objPtr, lengthPtr</i>)

char *
<b>Tcl_GetString</b>(<i>objPtr</i>)

Tcl_UniChar *
<b>Tcl_GetUnicodeFromObj</b>(<i>objPtr, lengthPtr</i>)

Tcl_UniChar *
<b>Tcl_GetUnicode</b>(<i>objPtr</i>)

Tcl_UniChar
<b>Tcl_GetUniChar</b>(<i>objPtr, index</i>)

int
<b>Tcl_GetCharLength</b>(<i>objPtr</i>)

Tcl_Obj *
<b>Tcl_GetRange</b>(<i>objPtr, first, last</i>)

void
<b>Tcl_AppendToObj</b>(<i>objPtr, bytes, length</i>)

void
<b>Tcl_AppendUnicodeToObj</b>(<i>objPtr, unicode, numChars</i>)

void
<b>Tcl_AppendObjToObj</b>(<i>objPtr, appendObjPtr</i>)

void
<b>Tcl_AppendStringsToObj</b>(<i>objPtr, string, string, ... </i><b>(char *) NULL</b>)

void
<b>Tcl_AppendStringsToObjVA</b>(<i>objPtr, argList</i>)

void
<b>Tcl_AppendLimitedToObj</b>(<i>objPtr, bytes, length, limit, ellipsis</i>)

Tcl_Obj *
<b>Tcl_Format</b>(<i>interp, format, objc, objv</i>)

int
<b>Tcl_AppendFormatToObj</b>(<i>interp, objPtr, format, objc, objv</i>)

Tcl_Obj *
<b>Tcl_ObjPrintf</b>(<i>format, ...</i>)

int
<b>Tcl_AppendPrintfToObj</b>(<i>objPtr, format, ...</i>)

void
<b>Tcl_SetObjLength</b>(<i>objPtr, newLength</i>)

int
<b>Tcl_AttemptSetObjLength</b>(<i>objPtr, newLength</i>)

Tcl_Obj *
<b>Tcl_ConcatObj</b>(<i>objc, objv</i>)</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="ARGUMENTS"><a class="permalink" href="#ARGUMENTS">ARGUMENTS</a></h1>
<dl class="Bl-tag">
  <dt>const char <i>*bytes</i> (in)</dt>
  <dd>Points to the first byte of an array of UTF-8-encoded bytes used to set or
      append to a string object. This byte array may contain embedded null
      characters unless <i>numChars</i> is negative. (Applications needing null
      bytes should represent them as the two-byte sequence <i>\700\600</i>, use
      <b>Tcl_ExternalToUtf</b> to convert, or <b>Tcl_NewByteArrayObj</b> if the
      string is a collection of uninterpreted bytes.)</dd>
  <dt>int <i>length</i> (in)</dt>
  <dd>The number of bytes to copy from <i>bytes</i> when initializing, setting,
      or appending to a string object. If negative, all bytes up to the first
      null are used.</dd>
  <dt>const Tcl_UniChar <i>*unicode</i> (in)</dt>
  <dd>Points to the first byte of an array of Unicode characters used to set or
      append to a string object. This byte array may contain embedded null
      characters unless <i>numChars</i> is negative.</dd>
  <dt>int <i>numChars</i> (in)</dt>
  <dd>The number of Unicode characters to copy from <i>unicode</i> when
      initializing, setting, or appending to a string object. If negative, all
      characters up to the first null character are used.</dd>
  <dt>int <i>index</i> (in)</dt>
  <dd>The index of the Unicode character to return.</dd>
  <dt>int <i>first</i> (in)</dt>
  <dd>The index of the first Unicode character in the Unicode range to be
      returned as a new object.</dd>
  <dt>int <i>last</i> (in)</dt>
  <dd>The index of the last Unicode character in the Unicode range to be
      returned as a new object.</dd>
  <dt>Tcl_Obj <i>*objPtr</i> (in/out)</dt>
  <dd>Points to an object to manipulate.</dd>
  <dt>Tcl_Obj <i>*appendObjPtr</i> (in)</dt>
  <dd>The object to append to <i>objPtr</i> in <b>Tcl_AppendObjToObj</b>.</dd>
  <dt>int <i>*lengthPtr</i> (out)</dt>
  <dd>If non-NULL, the location where <b>Tcl_GetStringFromObj</b> will store the
      length of an object's string representation.</dd>
  <dt>const char <i>*string</i> (in)</dt>
  <dd>Null-terminated string value to append to <i>objPtr</i>.</dd>
  <dt>va_list <i>argList</i> (in)</dt>
  <dd>An argument list which must have been initialised using <b>va_start</b>,
      and cleared using <b>va_end</b>.</dd>
  <dt>int <i>limit</i> (in)</dt>
  <dd>Maximum number of bytes to be appended.</dd>
  <dt>const char <i>*ellipsis</i> (in)</dt>
  <dd>Suffix to append when the limit leads to string truncation. If NULL is
      passed then the suffix &quot;...&quot; is used.</dd>
  <dt>const char <i>*format</i> (in)</dt>
  <dd>Format control string including % conversion specifiers.</dd>
  <dt>int <i>objc</i> (in)</dt>
  <dd>The number of elements to format or concatenate.</dd>
  <dt>Tcl_Obj <i>*objv[]</i> (in)</dt>
  <dd>The array of objects to format or concatenate.</dd>
  <dt>int <i>newLength</i> (in)</dt>
  <dd>New length for the string value of <i>objPtr</i>, not including the final
      null character.
    <pre>
    </pre>
    <p class="Pp"></p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The procedures described in this manual entry allow Tcl objects to
    be manipulated as string values. They use the internal representation of the
    object to store additional information to make the string manipulations more
    efficient. In particular, they make a series of append operations efficient
    by allocating extra storage space for the string so that it does not have to
    be copied for each append. Also, indexing and length computations are
    optimized because the Unicode string representation is calculated and cached
    as needed. When using the <b>Tcl_Append*</b> family of functions where the
    interpreter's result is the object being appended to, it is important to
    call Tcl_ResetResult first to ensure you are not unintentionally appending
    to existing data in the result object.</p>
<p class="Pp"><b>Tcl_NewStringObj</b> and <b>Tcl_SetStringObj</b> create a new
    object or modify an existing object to hold a copy of the string given by
    <i>bytes</i> and <i>length</i>. <b>Tcl_NewUnicodeObj</b> and
    <b>Tcl_SetUnicodeObj</b> create a new object or modify an existing object to
    hold a copy of the Unicode string given by <i>unicode</i> and
    <i>numChars</i>. <b>Tcl_NewStringObj</b> and <b>Tcl_NewUnicodeObj</b> return
    a pointer to a newly created object with reference count zero. All four
    procedures set the object to hold a copy of the specified string.
    <b>Tcl_SetStringObj</b> and <b>Tcl_SetUnicodeObj</b> free any old string
    representation as well as any old internal representation of the object.</p>
<p class="Pp"><b>Tcl_GetStringFromObj</b> and <b>Tcl_GetString</b> return an
    object's string representation. This is given by the returned byte pointer
    and (for <b>Tcl_GetStringFromObj</b>) length, which is stored in
    <i>lengthPtr</i> if it is non-NULL. If the object's UTF string
    representation is invalid (its byte pointer is NULL), the string
    representation is regenerated from the object's internal representation. The
    storage referenced by the returned byte pointer is owned by the object
    manager. It is passed back as a writable pointer so that extension author
    creating their own <b>Tcl_ObjType</b> will be able to modify the string
    representation within the <b>Tcl_UpdateStringProc</b> of their
    <b>Tcl_ObjType</b>. Except for that limited purpose, the pointer returned by
    <b>Tcl_GetStringFromObj</b> or <b>Tcl_GetString</b> should be treated as
    read-only. It is recommended that this pointer be assigned to a (const char
    *) variable. Even in the limited situations where writing to this pointer is
    acceptable, one should take care to respect the copy-on-write semantics
    required by <b>Tcl_Obj</b>'s, with appropriate calls to <b>Tcl_IsShared</b>
    and <b>Tcl_DuplicateObj</b> prior to any in-place modification of the string
    representation. The procedure <b>Tcl_GetString</b> is used in the common
    case where the caller does not need the length of the string
  representation.</p>
<p class="Pp"><b>Tcl_GetUnicodeFromObj</b> and <b>Tcl_GetUnicode</b> return an
    object's value as a Unicode string. This is given by the returned pointer
    and (for <b>Tcl_GetUnicodeFromObj</b>) length, which is stored in
    <i>lengthPtr</i> if it is non-NULL. The storage referenced by the returned
    byte pointer is owned by the object manager and should not be modified by
    the caller. The procedure <b>Tcl_GetUnicode</b> is used in the common case
    where the caller does not need the length of the unicode string
    representation.</p>
<p class="Pp"><b>Tcl_GetUniChar</b> returns the <i>index</i>'th character in the
    object's Unicode representation.</p>
<p class="Pp"><b>Tcl_GetRange</b> returns a newly created object comprised of
    the characters between <i>first</i> and <i>last</i> (inclusive) in the
    object's Unicode representation. If the object's Unicode representation is
    invalid, the Unicode representation is regenerated from the object's string
    representation.</p>
<p class="Pp"><b>Tcl_GetCharLength</b> returns the number of characters (as
    opposed to bytes) in the string object.</p>
<p class="Pp"><b>Tcl_AppendToObj</b> appends the data given by <i>bytes</i> and
    <i>length</i> to the string representation of the object specified by
    <i>objPtr</i>. If the object has an invalid string representation, then an
    attempt is made to convert <i>bytes</i> is to the Unicode format. If the
    conversion is successful, then the converted form of <i>bytes</i> is
    appended to the object's Unicode representation. Otherwise, the object's
    Unicode representation is invalidated and converted to the UTF format, and
    <i>bytes</i> is appended to the object's new string representation.</p>
<p class="Pp"><b>Tcl_AppendUnicodeToObj</b> appends the Unicode string given by
    <i>unicode</i> and <i>numChars</i> to the object specified by <i>objPtr</i>.
    If the object has an invalid Unicode representation, then <i>unicode</i> is
    converted to the UTF format and appended to the object's string
    representation. Appends are optimized to handle repeated appends relatively
    efficiently (it overallocates the string or Unicode space to avoid repeated
    reallocations and copies of object's string value).</p>
<p class="Pp"><b>Tcl_AppendObjToObj</b> is similar to <b>Tcl_AppendToObj</b>,
    but it appends the string or Unicode value (whichever exists and is best
    suited to be appended to <i>objPtr</i>) of <i>appendObjPtr</i> to
    <i>objPtr</i>.</p>
<p class="Pp"><b>Tcl_AppendStringsToObj</b> is similar to <b>Tcl_AppendToObj</b>
    except that it can be passed more than one value to append and each value
    must be a null-terminated string (i.e. none of the values may contain
    internal null characters). Any number of <i>string</i> arguments may be
    provided, but the last argument must be a NULL pointer to indicate the end
    of the list.</p>
<p class="Pp"><b>Tcl_AppendStringsToObjVA</b> is the same as
    <b>Tcl_AppendStringsToObj</b> except that instead of taking a variable
    number of arguments it takes an argument list.</p>
<p class="Pp"><b>Tcl_AppendLimitedToObj</b> is similar to <b>Tcl_AppendToObj</b>
    except that it imposes a limit on how many bytes are appended. This can be
    handy when the string to be appended might be very large, but the value
    being constructed should not be allowed to grow without bound. A common
    usage is when constructing an error message, where the end result should be
    kept short enough to be read. Bytes from <i>bytes</i> are appended to
    <i>objPtr</i>, but no more than <i>limit</i> bytes total are to be appended.
    If the limit prevents all <i>length</i> bytes that are available from being
    appended, then the appending is done so that the last bytes appended are
    from the string <i>ellipsis</i>. This allows for an indication of the
    truncation to be left in the string. When <i>length</i> is <b>-1</b>, all
    bytes up to the first zero byte are appended, subject to the limit. When
    <i>ellipsis</i> is NULL, the default string <b>...</b> is used. When
    <i>ellipsis</i> is non-NULL, it must point to a zero-byte-terminated string
    in Tcl's internal UTF encoding. The number of bytes appended can be less
    than the lesser of <i>length</i> and <i>limit</i> when appending fewer bytes
    is necessary to append only whole multi-byte characters.</p>
<p class="Pp"><b>Tcl_Format</b> is the C-level interface to the engine of the
    <b>format</b> command. The actual command procedure for <b>format</b> is
    little more than</p>
<div class="Bd-indent">
<pre>
Tcl_Format(interp, Tcl_GetString(objv[1]), objc-2, objv+2);</pre>
</div>
The <i>objc</i> Tcl_Obj values in <i>objv</i> are formatted into a string
  according to the conversion specification in <i>format</i> argument, following
  the documentation for the <b>format</b> command. The resulting formatted
  string is converted to a new Tcl_Obj with refcount of zero and returned. If
  some error happens during production of the formatted string, NULL is
  returned, and an error message is recorded in <i>interp</i>, if <i>interp</i>
  is non-NULL.
<p class="Pp"><b>Tcl_AppendFormatToObj</b> is an appending alternative form of
    <b>Tcl_Format</b> with functionality equivalent to</p>
<div class="Bd-indent">
<pre>
Tcl_Obj *newPtr = Tcl_Format(interp, format, objc, objv);
if (newPtr == NULL) return TCL_ERROR;
Tcl_AppendObjToObj(objPtr, newPtr);
return TCL_OK;</pre>
</div>
but with greater convenience and efficiency when the appending functionality is
  needed.
<p class="Pp"><b>Tcl_ObjPrintf</b> serves as a replacement for the common
    sequence</p>
<div class="Bd-indent">
<pre>
char buf[SOME_SUITABLE_LENGTH];
sprintf(buf, format, ...);
Tcl_NewStringObj(buf, -1);</pre>
</div>
but with greater convenience and no need to determine
  <b>SOME_SUITABLE_LENGTH</b>. The formatting is done with the same core
  formatting engine used by <b>Tcl_Format</b>. This means the set of supported
  conversion specifiers is that of the <b>format</b> command and not that of the
  <b>sprintf</b> routine where the two sets differ. When a conversion specifier
  passed to <b>Tcl_ObjPrintf</b> includes a precision, the value is taken as a
  number of bytes, as <b>sprintf</b> does, and not as a number of characters, as
  <b>format</b> does. This is done on the assumption that C code is more likely
  to know how many bytes it is passing around than the number of encoded
  characters those bytes happen to represent. The variable number of arguments
  passed in should be of the types that would be suitable for passing to
  <b>sprintf</b>. Note in this example usage, <i>x</i> is of type <b>long</b>.
<div class="Bd-indent">
<pre>
long x = 5;
Tcl_Obj *objPtr = Tcl_ObjPrintf(&quot;Value is %d&quot;, x);</pre>
</div>
If the value of <i>format</i> contains internal inconsistencies or invalid
  specifier formats, the formatted string result produced by
  <b>Tcl_ObjPrintf</b> will be an error message describing the error.
<p class="Pp"><b>Tcl_AppendPrintfToObj</b> is an appending alternative form of
    <b>Tcl_ObjPrintf</b> with functionality equivalent to</p>
<div class="Bd-indent">
<pre>
Tcl_AppendObjToObj(objPtr, Tcl_ObjPrintf(format, ...));</pre>
</div>
but with greater convenience and efficiency when the appending functionality is
  needed.
<p class="Pp">The <b>Tcl_SetObjLength</b> procedure changes the length of the
    string value of its <i>objPtr</i> argument. If the <i>newLength</i> argument
    is greater than the space allocated for the object's string, then the string
    space is reallocated and the old value is copied to the new space; the bytes
    between the old length of the string and the new length may have arbitrary
    values. If the <i>newLength</i> argument is less than the current length of
    the object's string, with <i>objPtr-&gt;length</i> is reduced without
    reallocating the string space; the original allocated size for the string is
    recorded in the object, so that the string length can be enlarged in a
    subsequent call to <b>Tcl_SetObjLength</b> without reallocating storage. In
    all cases <b>Tcl_SetObjLength</b> leaves a null character at
    <i>objPtr-&gt;bytes[newLength]</i>.</p>
<p class="Pp"><b>Tcl_AttemptSetObjLength</b> is identical in function to
    <b>Tcl_SetObjLength</b> except that if sufficient memory to satisfy the
    request cannot be allocated, it does not cause the Tcl interpreter to
    <b>panic</b>. Thus, if <i>newLength</i> is greater than the space allocated
    for the object's string, and there is not enough memory available to satisfy
    the request, <b>Tcl_AttemptSetObjLength</b> will take no action and return 0
    to indicate failure. If there is enough memory to satisfy the request,
    <b>Tcl_AttemptSetObjLength</b> behaves just like <b>Tcl_SetObjLength</b> and
    returns 1 to indicate success.</p>
<p class="Pp">The <b>Tcl_ConcatObj</b> function returns a new string object
    whose value is the space-separated concatenation of the string
    representations of all of the objects in the <i>objv</i> array.
    <b>Tcl_ConcatObj</b> eliminates leading and trailing white space as it
    copies the string representations of the <i>objv</i> array to the result. If
    an element of the <i>objv</i> array consists of nothing but white space,
    then that object is ignored entirely. This white-space removal was added to
    make the output of the <b>concat</b> command cleaner-looking.
    <b>Tcl_ConcatObj</b> returns a pointer to a newly-created object whose ref
    count is zero.</p>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">Tcl_NewObj, Tcl_IncrRefCount, Tcl_DecrRefCount, format,
  sprintf</p>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
<p class="Pp">append, internal representation, object, object type, string
    object, string type, string representation, concat, concatenate, unicode</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">8.1</td>
    <td class="foot-os"><a href="..">Tcl</a></td>
  </tr>
</table>
</body>
</html>

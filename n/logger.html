<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   The definitions below are for supplemental macros used in Tcl/Tk
   manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO
  	Start of list of standard options for a Tk widget.  The
  	options follow on successive lines, in four columns separated
  	by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   RCS: @(#) $Id: man.macros,v 1.1 2009/01/30 04:56:47 andreas_kupries Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>logger(n)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">logger(n)</td>
    <td class="head-vol">Object Oriented logging facility</td>
    <td class="head-rtitle">logger(n)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>
</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">logger - System to control logging of events.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">package require <b>Tcl 8.2</b></p>
<p class="Pp">package require <b>logger ?0.9?</b></p>
<p class="Pp"><b>logger::init</b> <i>service</i></p>
<p class="Pp"><b>logger::import</b> ?<b>-all</b>? ?<b>-force</b>?
    ?<b>-prefix</b> <i>prefix</i>? ?<b>-namespace</b> <i>namespace</i>?
    <i>service</i></p>
<p class="Pp"><b>logger::initNamespace</b> <i>ns</i> ?<i>level</i>?</p>
<p class="Pp"><b>logger::services</b></p>
<p class="Pp"><b>logger::enable</b> <i>level</i></p>
<p class="Pp"><b>logger::disable</b> <i>level</i></p>
<p class="Pp"><b>logger::setlevel</b> <i>level</i></p>
<p class="Pp"><b>logger::levels</b></p>
<p class="Pp"><b>logger::servicecmd</b> <i>service</i></p>
<p class="Pp"><b>${log}::debug</b> <i>message</i></p>
<p class="Pp"><b>${log}::info</b> <i>message</i></p>
<p class="Pp"><b>${log}::notice</b> <i>message</i></p>
<p class="Pp"><b>${log}::warn</b> <i>message</i></p>
<p class="Pp"><b>${log}::error</b> <i>message</i></p>
<p class="Pp"><b>${log}::critical</b> <i>message</i></p>
<p class="Pp"><b>${log}::alert</b> <i>message</i></p>
<p class="Pp"><b>${log}::emergency</b> <i>message</i></p>
<p class="Pp"><b>${log}::setlevel</b> <i>level</i></p>
<p class="Pp"><b>${log}::enable</b> <i>level</i></p>
<p class="Pp"><b>${log}::disable</b> <i>level</i></p>
<p class="Pp"><b>${log}::lvlchangeproc</b> <i>command</i></p>
<p class="Pp"><b>${log}::lvlchangeproc</b></p>
<p class="Pp"><b>${log}::logproc</b> <i>level</i></p>
<p class="Pp"><b>${log}::logproc</b> <i>level</i> <i>command</i></p>
<p class="Pp"><b>${log}::logproc</b> <i>level</i> <i>argname</i> <i>body</i></p>
<p class="Pp"><b>${log}::services</b></p>
<p class="Pp"><b>${log}::servicename</b></p>
<p class="Pp"><b>${log}::currentloglevel</b></p>
<p class="Pp"><b>${log}::delproc</b> <i>command</i></p>
<p class="Pp"><b>${log}::delproc</b></p>
<p class="Pp"><b>${log}::delete</b></p>
<p class="Pp"><b>${log}::trace</b> <i>command</i></p>
<p class="Pp"><b>${log}::trace</b> <b>on</b></p>
<p class="Pp"><b>${log}::trace</b> <b>off</b></p>
<p class="Pp"><b>${log}::trace</b> <b>status</b> ?procName? ?...?</p>
<p class="Pp"><b>${log}::trace</b> <b>add</b> <i>procName</i> ?...?</p>
<p class="Pp"><b>${log}::trace</b> <b>add</b> ?-ns? <i>nsName</i> ?...?</p>
<p class="Pp"><b>${log}::trace</b> <b>remove</b> <i>procName</i> ?...?</p>
<p class="Pp"><b>${log}::trace</b> <b>remove</b> ?-ns? <i>nsName</i> ?...?</p>
<p class="Pp"></p>
<pre>
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The <b>logger</b> package provides a flexible system for logging
    messages from different services, at priority levels, with different
    commands.</p>
<p class="Pp">To begin using the logger package, we do the following:</p>
<p class="Pp"></p>
<pre>
    package require logger
    set log [logger::init myservice]
    ${log}::notice &quot;Initialized myservice logging&quot;
    ... code ...
    ${log}::notice &quot;Ending myservice logging&quot;
    ${log}::delete
</pre>
<p class="Pp">In the above code, after the package is loaded, the following
    things happen:</p>
<dl class="Bl-tag">
  <dt id="logger::init"><a class="permalink" href="#logger::init"><b>logger::init</b>
    <i>service</i></a></dt>
  <dd>Initializes the service <i>service</i> for logging. The service names are
      actually Tcl namespace names, so they are separated with '::'. When a
      logger service is initialized, it &quot;inherits&quot; properties from its
      parents. For instance, if there were a service <i>foo</i>, and we did a
      <b>logger::init</b> <i>foo::bar</i> (to create a <i>bar</i> service
      underneath <i>foo</i>), <i>bar</i> would copy the current configuration of
      the <i>foo</i> service, although it would of course, also be possible to
      then separately configure <i>bar</i>. If a logger service is initialized
      and the parent does not yet exist, the parent is also created. The new
      logger service is initialized with the default loglevel set with
      <b>logger::setlevel</b>.</dd>
  <dt id="logger::import"><a class="permalink" href="#logger::import"><b>logger::import</b>
    ?<b>-all</b>? ?<b>-force</b>? ?<b>-prefix</b> <i>prefix</i>?
    ?<b>-namespace</b> <i>namespace</i>? <i>service</i></a></dt>
  <dd>Import the logger service commands into the current namespace. Without the
      <b>-all</b> option only the commands corresponding to the log levels are
      imported. If <b>-all</b> is given, all the <b>${log}::cmd</b> style
      commands are imported. If the import would overwrite a command an error is
      returned and no command is imported. Use the <b>-force</b> option to force
      the import and overwrite existing commands without complaining. If the
      <b>-prefix</b> option is given, the commands are imported with the given
      <i>prefix</i> prepended to their names. If the <b>-namespace</b> option is
      given, the commands are imported into the given namespace. If the
      namespace does not exist, it is created. If a namespace without a leading
      :: is given, it is interpreted as a child namespace to the current
      namespace.</dd>
  <dt id="logger::initNamespace"><a class="permalink" href="#logger::initNamespace"><b>logger::initNamespace</b>
    <i>ns</i> ?<i>level</i>?</a></dt>
  <dd>Convenience command for setting up a namespace for logging. Creates a
      logger service named after the namespace <i>ns</i> (a :: prefix is
      stripped), imports all the log commands into the namespace, and sets the
      default logging level, either to the specified <i>level</i>, or the
      default level, &quot;warn&quot;.</dd>
  <dt id="logger::services"><a class="permalink" href="#logger::services"><b>logger::services</b></a></dt>
  <dd>Returns a list of all the available services.</dd>
  <dt id="logger::enable"><a class="permalink" href="#logger::enable"><b>logger::enable</b>
    <i>level</i></a></dt>
  <dd>Globally enables logging at and &quot;above&quot; the given level. Levels
      are <b>debug</b>, <b>info</b>, <b>notice</b>, <b>warn</b>, <b>error</b>,
      <b>critical</b>, <b>alert</b>, <b>emergency</b>.</dd>
  <dt id="logger::disable"><a class="permalink" href="#logger::disable"><b>logger::disable</b>
    <i>level</i></a></dt>
  <dd>Globally disables logging at and &quot;below&quot; the given level. Levels
      are those listed above.</dd>
  <dt id="logger::setlevel"><a class="permalink" href="#logger::setlevel"><b>logger::setlevel</b>
    <i>level</i></a></dt>
  <dd>Globally enable logging at and &quot;above&quot; the given level. Levels
      are those listed above. This command changes the default loglevel for new
      loggers created with <b>logger::init</b>.</dd>
  <dt id="logger::levels"><a class="permalink" href="#logger::levels"><b>logger::levels</b></a></dt>
  <dd>Returns a list of the available log levels (also listed above under
      <b>enable</b>).</dd>
  <dt id="logger::servicecmd"><a class="permalink" href="#logger::servicecmd"><b>logger::servicecmd</b>
    <i>service</i></a></dt>
  <dd>Returns the <b>${log}</b> token created by <b>logger::init</b> for this
      service.</dd>
  <dt><b>${log}::debug</b> <i>message</i></dt>
  <dd></dd>
  <dt><b>${log}::info</b> <i>message</i></dt>
  <dd></dd>
  <dt><b>${log}::notice</b> <i>message</i></dt>
  <dd></dd>
  <dt><b>${log}::warn</b> <i>message</i></dt>
  <dd></dd>
  <dt><b>${log}::error</b> <i>message</i></dt>
  <dd></dd>
  <dt><b>${log}::critical</b> <i>message</i></dt>
  <dd></dd>
  <dt><b>${log}::alert</b> <i>message</i></dt>
  <dd></dd>
  <dt><b>${log}::emergency</b> <i>message</i></dt>
  <dd>These are the commands called to actually log a message about an event.
      <b>${log}</b> is the variable obtained from <b>logger::init</b>.</dd>
  <dt><b>${log}::setlevel</b> <i>level</i></dt>
  <dd>Enable logging, in the service referenced by <b>${log}</b>, and its
      children, at and above the level specified, and disable logging below
    it.</dd>
  <dt><b>${log}::enable</b> <i>level</i></dt>
  <dd>Enable logging, in the service referenced by <b>${log}</b>, and its
      children, at and above the level specified. Note that this does <i>not</i>
      disable logging below this level, so you should probably use
      <b>setlevel</b> instead.</dd>
  <dt><b>${log}::disable</b> <i>level</i></dt>
  <dd>Disable logging, in the service referenced by <b>${log}</b>, and its
      children, at and below the level specified. Note that this does <i>not</i>
      enable logging above this level, so you should probably use
      <b>setlevel</b> instead. Disabling the loglevel <b>emergency</b> switches
      logging off for the service and its children.</dd>
  <dt><b>${log}::lvlchangeproc</b> <i>command</i></dt>
  <dd></dd>
  <dt><b>${log}::lvlchangeproc</b></dt>
  <dd>Set the script to call when the log instance in question changes its log
      level. If called without a command it returns the currently registered
      command. The command gets two arguments appended, the old and the new
      loglevel. The callback is invoked after all changes have been done. If
      child loggers are affected, their callbacks are called before their
      parents callback.
    <pre>
 	proc lvlcallback {old new} {
 	    puts &quot;Loglevel changed from $old to $new&quot;
 	}
 	${log}::lvlchangeproc lvlcallback
    </pre>
  </dd>
  <dt><b>${log}::logproc</b> <i>level</i></dt>
  <dd></dd>
  <dt><b>${log}::logproc</b> <i>level</i> <i>command</i></dt>
  <dd></dd>
  <dt><b>${log}::logproc</b> <i>level</i> <i>argname</i> <i>body</i></dt>
  <dd>This command comes in three forms - the third, older one is deprecated and
      may be removed from future versions of the logger package. The current set
      version takes one argument, a command to be executed when the level is
      called. The callback command takes on argument, the text to be logged. If
      called only with a valid level <b>logproc</b> returns the name of the
      command currently registered as callback command. <b>logproc</b> specifies
      which command will perform the actual logging for a given level. The
      logger package ships with default commands for all log levels, but with
      <b>logproc</b> it is possible to replace them with custom code. This would
      let you send your logs over the network, to a database, or anything else.
      For example:
    <pre>
    proc logtoserver {txt} {
        variable socket
        puts $socket &quot;Notice: $txt&quot;
    }
    ${log}::logproc notice logtoserver
    </pre>
    Trace logs are slightly different: instead of a plain text argument, the
      argument provided to the logproc is a dictionary consisting of the
      <b>enter</b> or <b>leave</b> keyword along with another dictionary of
      details about the trace. These include:</dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li><b>proc</b> - Name of the procedure being traced.</li>
  <li><b>level</b> - The stack level for the procedure invocation (from
      <b>info</b> <b>level</b>).</li>
  <li><b>script</b> - The name of the file in which the procedure is defined, or
      an empty string if defined in interactive mode.</li>
  <li><b>caller</b> - The name of the procedure calling the procedure being
      traced, or an empty string if the procedure was called from the global
      scope (stack level 0).</li>
  <li><b>procargs</b> - A dictionary consisting of the names of arguments to the
      procedure paired with values given for those arguments (<b>enter</b>
      traces only).</li>
  <li><b>status</b> - The Tcl return code (e.g. <b>ok</b>, <b>continue</b>,
      etc.) (<b>leave</b> traces only).</li>
  <li><b>result</b> - The value returned by the procedure (<b>leave</b> traces
      only).</li>
</ul>
</div>
<dl class="Bl-tag">
  <dt><b>${log}::services</b></dt>
  <dd>Returns a list of the registered logging services which are children of
      this service.</dd>
  <dt><b>${log}::servicename</b></dt>
  <dd>Returns the name of this service.</dd>
  <dt><b>${log}::currentloglevel</b></dt>
  <dd>Returns the currently enabled log level for this service. If no logging is
      enabled returns <b>none</b>.</dd>
  <dt><b>${log}::delproc</b> <i>command</i></dt>
  <dd></dd>
  <dt><b>${log}::delproc</b></dt>
  <dd>Set the script to call when the log instance in question is deleted. If
      called without a command it returns the currently registered command. For
      example:
    <pre>
    ${log}::delproc [list closesock $logsock]
    </pre>
  </dd>
  <dt><b>${log}::delete</b></dt>
  <dd>This command deletes a particular logging service, and its children. You
      must call this to clean up the resources used by a service.</dd>
  <dt><b>${log}::trace</b> <i>command</i></dt>
  <dd>This command controls logging of enter/leave traces for specified
      procedures. It is used to enable and disable tracing, query tracing
      status, and specify procedures are to be traced. Trace handlers are
      unregistered when tracing is disabled. As a result, there is not
      performance impact to a library when tracing is disabled, just as with
      other log level commands.
    <pre>
  proc tracecmd { dict } {
      puts $dict
  }
  set log [::logger::init example]
  ${log}::logproc trace tracecmd
  proc foo { args } {
      puts &quot;In foo&quot;
      bar 1
      return &quot;foo_result&quot;
  }
  proc bar { x } {
      puts &quot;In bar&quot;
      return &quot;bar_result&quot;
  }
  ${log}::trace add foo bar
  ${log}::trace on
  foo
# Output:
enter {proc ::foo level 1 script {} caller {} procargs {args {}}}
In foo
enter {proc ::bar level 2 script {} caller ::foo procargs {x 1}}
In bar
leave {proc ::bar level 2 script {} caller ::foo status ok result bar_result}
leave {proc ::foo level 1 script {} caller {} status ok result foo_result}
    </pre>
  </dd>
  <dt><b>${log}::trace</b> <b>on</b></dt>
  <dd>Turns on trace logging for procedures registered through the <b>trace</b>
      <b>add</b> command. This is similar to the <b>enable</b> command for other
      logging levels, but allows trace logging to take place at any level. The
      trace logging mechanism takes advantage of the execution trace feature of
      Tcl 8.4 and later. The <b>trace</b> <b>on</b> command will return an error
      if called from earlier versions of Tcl.</dd>
  <dt><b>${log}::trace</b> <b>off</b></dt>
  <dd>Turns off trace logging for procedures registered for trace logging
      through the <b>trace</b> <b>add</b> command. This is similar to the
      <b>disable</b> command for other logging levels, but allows trace logging
      to take place at any level. Procedures are not unregistered, so logging
      for them can be turned back on with the <b>trace</b> <b>on</b> command.
      There is no overhead imposed by trace registration when trace logging is
      disabled.</dd>
  <dt><b>${log}::trace</b> <b>status</b> ?procName? ?...?</dt>
  <dd>This command returns a list of the procedures currently registered for
      trace logging, or a flag indicating whether or not a trace is registered
      for one or more specified procedures.</dd>
  <dt><b>${log}::trace</b> <b>add</b> <i>procName</i> ?...?</dt>
  <dd></dd>
  <dt><b>${log}::trace</b> <b>add</b> ?-ns? <i>nsName</i> ?...?</dt>
  <dd>This command registers one or more procedures for logging of entry/exit
      traces. Procedures can be specified via a list of procedure names or
      namespace names (in which case all procedure within the namespace are
      targeted by the operation). By default, each name is first interpreted as
      a procedure name or glob-style search pattern, and if not found its
      interpreted as a namespace name. The <i>-ns</i> option can be used to
      force interpretation of all provided arguments as namespace names.
      Procedures must be defined prior to registering them for tracing through
      the <b>trace</b> <b>add</b> command. Any procedure or namespace
      names/patterns that don't match any existing procedures will be silently
      ignored.</dd>
  <dt><b>${log}::trace</b> <b>remove</b> <i>procName</i> ?...?</dt>
  <dd></dd>
  <dt><b>${log}::trace</b> <b>remove</b> ?-ns? <i>nsName</i> ?...?</dt>
  <dd>This command unregisters one or more procedures so that they will no
      longer have trace logging performed, with the same matching rules as that
      of the <b>trace</b> <b>add</b> command.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="IMPLEMENTATION"><a class="permalink" href="#IMPLEMENTATION">IMPLEMENTATION</a></h1>
<p class="Pp">The logger package is implemented in such a way as to optimize
    (for Tcl 8.4 and newer) log procedures which are disabled. They are aliased
    to a proc which has no body, which is compiled to a no op in bytecode. This
    should make the peformance hit minimal. If you really want to pull out all
    the stops, you can replace the ${log} token in your code with the actual
    namespace and command (${log}::warn becomes
    ::logger::tree::myservice::warn), so that no variable lookup is done. This
    puts the performance of disabled logger commands very close to no logging at
    all.</p>
<p class="Pp">The &quot;object orientation&quot; is done through a hierarchy of
    namespaces. Using an actual object oriented system would probably be a
    better way of doing things, or at least provide for a cleaner
    implementation.</p>
<p class="Pp">The service &quot;object orientation&quot; is done with
    namespaces.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LOGPROCS_AND_CALLSTACK"><a class="permalink" href="#LOGPROCS_AND_CALLSTACK">LOGPROCS
  AND CALLSTACK</a></h1>
<p class="Pp">The logger package takes extra care to keep the logproc out of the
    call stack. This enables logprocs to execute code in the callers scope by
    using uplevel or linking to local variables by using upvar. This may fire
    traces with all usual side effects.</p>
<pre>
     # Print caller and current vars in the calling proc
     proc log_local_var {txt} {
          set caller [info level -1]
          set vars [uplevel 1 info vars]
          foreach var [lsort $vars] {
             if {[uplevel 1 [list array exists $var]] == 1} {
             	lappend val $var &lt;Array&gt;
             } else {
             	lappend val $var [uplevel 1 [list set $var]]
             }
          }
          puts &quot;$txt&quot;
          puts &quot;Caller: $caller&quot;
          puts &quot;Variables in callers scope:&quot;
          foreach {var value} $val {
          	puts &quot;$var = $value&quot;
          }
     }
     # install as logproc
     ${log}::logproc debug log_local_var
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS,_IDEAS,_FEEDBACK"><a class="permalink" href="#BUGS,_IDEAS,_FEEDBACK">BUGS,
  IDEAS, FEEDBACK</a></h1>
<p class="Pp">This document, and the package it describes, will undoubtedly
    contain bugs and other problems. Please report such in the category
    <i>logger</i> of the <i>Tcllib SF Trackers</i>
    [http://sourceforge.net/tracker/?group_id=12883]. Please also report any
    ideas for enhancements you may have for either package and/or
  documentation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
<p class="Pp">log, log level, logger, service</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CATEGORY"><a class="permalink" href="#CATEGORY">CATEGORY</a></h1>
<p class="Pp">Programming tools</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">0.8</td>
    <td class="foot-os">log</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Copyright (c) 2004-2008 Arjen Markus <arjenmarkus@users.sourceforge.net>
   Copyright (c) 2004 Ed Hume <http://www.hume.com/contact.us.htm>
   Copyright (c) 2008 Michael Buadin <relaxkmike@users.sourceforge.net>
  
   The definitions below are for supplemental macros used in Tcl/Tk
   manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO
  	Start of list of standard options for a Tk widget.  The
  	options follow on successive lines, in four columns separated
  	by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   RCS: @(#) $Id: man.macros,v 1.1 2009/01/30 04:56:47 andreas_kupries Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>math::linearalgebra(n)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">math::linearalgebra(n)</td>
    <td class="head-vol">Tcl Math Library</td>
    <td class="head-rtitle">math::linearalgebra(n)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>
</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">math::linearalgebra - Linear Algebra</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">package require <b>Tcl ?8.4?</b></p>
<p class="Pp">package require <b>math::linearalgebra ?1.1?</b></p>
<p class="Pp"><b>::math::linearalgebra::mkVector</b> <i>ndim</i>
  <i>value</i></p>
<p class="Pp"><b>::math::linearalgebra::mkUnitVector</b> <i>ndim</i>
  <i>ndir</i></p>
<p class="Pp"><b>::math::linearalgebra::mkMatrix</b> <i>nrows</i> <i>ncols</i>
    <i>value</i></p>
<p class="Pp"><b>::math::linearalgebra::getrow</b> <i>matrix</i> <i>row</i>
    ?imin? ?imax?</p>
<p class="Pp"><b>::math::linearalgebra::setrow</b> <i>matrix</i> <i>row</i>
    <i>newvalues</i> ?imin? ?imax?</p>
<p class="Pp"><b>::math::linearalgebra::getcol</b> <i>matrix</i> <i>col</i>
    ?imin? ?imax?</p>
<p class="Pp"><b>::math::linearalgebra::setcol</b> <i>matrix</i> <i>col</i>
    <i>newvalues</i> ?imin? ?imax?</p>
<p class="Pp"><b>::math::linearalgebra::getelem</b> <i>matrix</i> <i>row</i>
    <i>col</i></p>
<p class="Pp"><b>::math::linearalgebra::setelem</b> <i>matrix</i> <i>row</i>
    ?col? <i>newvalue</i></p>
<p class="Pp"><b>::math::linearalgebra::swaprows</b> <i>matrix</i> <i>irow1</i>
    <i>irow2</i> ?imin? ?imax?</p>
<p class="Pp"><b>::math::linearalgebra::swapcols</b> <i>matrix</i> <i>icol1</i>
    <i>icol2</i> ?imin? ?imax?</p>
<p class="Pp"><b>::math::linearalgebra::show</b> <i>obj</i> ?format? ?rowsep?
    ?colsep?</p>
<p class="Pp"><b>::math::linearalgebra::dim</b> <i>obj</i></p>
<p class="Pp"><b>::math::linearalgebra::shape</b> <i>obj</i></p>
<p class="Pp"><b>::math::linearalgebra::conforming</b> <i>type</i> <i>obj1</i>
    <i>obj2</i></p>
<p class="Pp"><b>::math::linearalgebra::symmetric</b> <i>matrix</i> ?eps?</p>
<p class="Pp"><b>::math::linearalgebra::norm</b> <i>vector</i> <i>type</i></p>
<p class="Pp"><b>::math::linearalgebra::norm_one</b> <i>vector</i></p>
<p class="Pp"><b>::math::linearalgebra::norm_two</b> <i>vector</i></p>
<p class="Pp"><b>::math::linearalgebra::norm_max</b> <i>vector</i> ?index?</p>
<p class="Pp"><b>::math::linearalgebra::normMatrix</b> <i>matrix</i>
  <i>type</i></p>
<p class="Pp"><b>::math::linearalgebra::dotproduct</b> <i>vect1</i>
  <i>vect2</i></p>
<p class="Pp"><b>::math::linearalgebra::unitLengthVector</b> <i>vector</i></p>
<p class="Pp"><b>::math::linearalgebra::normalizeStat</b> <i>mv</i></p>
<p class="Pp"><b>::math::linearalgebra::axpy</b> <i>scale</i> <i>mv1</i>
    <i>mv2</i></p>
<p class="Pp"><b>::math::linearalgebra::add</b> <i>mv1</i> <i>mv2</i></p>
<p class="Pp"><b>::math::linearalgebra::sub</b> <i>mv1</i> <i>mv2</i></p>
<p class="Pp"><b>::math::linearalgebra::scale</b> <i>scale</i> <i>mv</i></p>
<p class="Pp"><b>::math::linearalgebra::rotate</b> <i>c</i> <i>s</i>
    <i>vect1</i> <i>vect2</i></p>
<p class="Pp"><b>::math::linearalgebra::transpose</b> <i>matrix</i></p>
<p class="Pp"><b>::math::linearalgebra::matmul</b> <i>mv1</i> <i>mv2</i></p>
<p class="Pp"><b>::math::linearalgebra::angle</b> <i>vect1</i> <i>vect2</i></p>
<p class="Pp"><b>::math::linearalgebra::crossproduct</b> <i>vect1</i>
    <i>vect2</i></p>
<p class="Pp"><b>::math::linearalgebra::matmul</b> <i>mv1</i> <i>mv2</i></p>
<p class="Pp"><b>::math::linearalgebra::mkIdentity</b> <i>size</i></p>
<p class="Pp"><b>::math::linearalgebra::mkDiagonal</b> <i>diag</i></p>
<p class="Pp"><b>::math::linearalgebra::mkRandom</b> <i>size</i></p>
<p class="Pp"><b>::math::linearalgebra::mkTriangular</b> <i>size</i> ?uplo?
    ?value?</p>
<p class="Pp"><b>::math::linearalgebra::mkHilbert</b> <i>size</i></p>
<p class="Pp"><b>::math::linearalgebra::mkDingdong</b> <i>size</i></p>
<p class="Pp"><b>::math::linearalgebra::mkOnes</b> <i>size</i></p>
<p class="Pp"><b>::math::linearalgebra::mkMoler</b> <i>size</i></p>
<p class="Pp"><b>::math::linearalgebra::mkFrank</b> <i>size</i></p>
<p class="Pp"><b>::math::linearalgebra::mkBorder</b> <i>size</i></p>
<p class="Pp"><b>::math::linearalgebra::mkWilkinsonW+</b> <i>size</i></p>
<p class="Pp"><b>::math::linearalgebra::mkWilkinsonW-</b> <i>size</i></p>
<p class="Pp"><b>::math::linearalgebra::solveGauss</b> <i>matrix</i>
    <i>bvect</i></p>
<p class="Pp"><b>::math::linearalgebra::solvePGauss</b> <i>matrix</i>
    <i>bvect</i></p>
<p class="Pp"><b>::math::linearalgebra::solveTriangular</b> <i>matrix</i>
    <i>bvect</i> ?uplo?</p>
<p class="Pp"><b>::math::linearalgebra::solveGaussBand</b> <i>matrix</i>
    <i>bvect</i></p>
<p class="Pp"><b>::math::linearalgebra::solveTriangularBand</b> <i>matrix</i>
    <i>bvect</i></p>
<p class="Pp"><b>::math::linearalgebra::determineSVD</b> <i>A</i> <i>eps</i></p>
<p class="Pp"><b>::math::linearalgebra::eigenvectorsSVD</b> <i>A</i>
  <i>eps</i></p>
<p class="Pp"><b>::math::linearalgebra::leastSquaresSVD</b> <i>A</i> <i>y</i>
    <i>qmin</i> <i>eps</i></p>
<p class="Pp"><b>::math::linearalgebra::choleski</b> <i>matrix</i></p>
<p class="Pp"><b>::math::linearalgebra::orthonormalizeColumns</b>
  <i>matrix</i></p>
<p class="Pp"><b>::math::linearalgebra::orthonormalizeRows</b> <i>matrix</i></p>
<p class="Pp"><b>::math::linearalgebra::dger</b> <i>matrix</i> <i>alpha</i>
    <i>x</i> <i>y</i> ?scope?</p>
<p class="Pp"><b>::math::linearalgebra::dgetrf</b> <i>matrix</i></p>
<p class="Pp"><b>::math::linearalgebra::det</b> <i>matrix</i></p>
<p class="Pp"><b>::math::linearalgebra::largesteigen</b> <i>matrix</i>
    <i>tolerance</i> <i>maxiter</i></p>
<p class="Pp"><b>::math::linearalgebra::to_LA</b> <i>mv</i></p>
<p class="Pp"><b>::math::linearalgebra::from_LA</b> <i>mv</i></p>
<p class="Pp"></p>
<pre>
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This package offers both low-level procedures and high-level
    algorithms to deal with linear algebra problems:</p>
<ul class="Bl-bullet">
  <li>robust solution of linear equations or least squares problems</li>
  <li>determining eigenvectors and eigenvalues of symmetric matrices</li>
  <li>various decompositions of general matrices or matrices of a specific
    form</li>
  <li>(limited) support for matrices in band storage, a common type of sparse
      matrices</li>
</ul>
<p class="Pp">It arose as a re-implementation of Hume's LA package and the
    desire to offer low-level procedures as found in the well-known BLAS
    library. Matrices are implemented as lists of lists rather linear lists with
    reserved elements, as in the original LA package, as it was found that such
    an implementation is actually faster.</p>
<p class="Pp">It is advisable, however, to use the procedures that are offered,
    such as <i>setrow</i> and <i>getrow</i>, rather than rely on this
    representation explicitly: that way it is to switch to a possibly even
    faster compiled implementation that supports the same API.</p>
<p class="Pp"><i>Note:</i> When using this package in combination with Tk, there
    may be a naming conflict, as both this package and Tk define a command
    <i>scale</i>. See the <b>NAMING CONFLICT</b> section below.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PROCEDURES"><a class="permalink" href="#PROCEDURES">PROCEDURES</a></h1>
<p class="Pp">The package defines the following public procedures (several exist
    as specialised procedures, see below):</p>
<p class="Pp"><i>Constructing matrices and vectors</i></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::mkVector</b> <i>ndim</i> <i>value</i></dt>
  <dd>Create a vector with ndim elements, each with the value <i>value</i>.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="integer"><a class="permalink" href="#integer">integer
    <i>ndim</i></a></dt>
  <dd>Dimension of the vector (number of components)</dd>
  <dt id="double"><a class="permalink" href="#double">double
    <i>value</i></a></dt>
  <dd>Uniform value to be used (default: 0.0)</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::mkUnitVector</b> <i>ndim</i> <i>ndir</i></dt>
  <dd>Create a unit vector in <i>ndim</i>-dimensional space, along the
      <i>ndir</i>-th direction.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="integer~2"><a class="permalink" href="#integer~2">integer
    <i>ndim</i></a></dt>
  <dd>Dimension of the vector (number of components)</dd>
  <dt id="integer~3"><a class="permalink" href="#integer~3">integer
    <i>ndir</i></a></dt>
  <dd>Direction (0, ..., ndim-1)</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::mkMatrix</b> <i>nrows</i> <i>ncols</i>
    <i>value</i></dt>
  <dd>Create a matrix with <i>nrows</i> rows and <i>ncols</i> columns. All
      elements have the value <i>value</i>.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="integer~4"><a class="permalink" href="#integer~4">integer
    <i>nrows</i></a></dt>
  <dd>Number of rows</dd>
  <dt id="integer~5"><a class="permalink" href="#integer~5">integer
    <i>ncols</i></a></dt>
  <dd>Number of columns</dd>
  <dt id="double~2"><a class="permalink" href="#double~2">double
    <i>value</i></a></dt>
  <dd>Uniform value to be used (default: 0.0)</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::getrow</b> <i>matrix</i> <i>row</i> ?imin?
    ?imax?</dt>
  <dd>Returns a single row of a matrix as a list</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list"><a class="permalink" href="#list">list <i>matrix</i></a></dt>
  <dd>Matrix in question</dd>
  <dt id="integer~6"><a class="permalink" href="#integer~6">integer
    <i>row</i></a></dt>
  <dd>Index of the row to return</dd>
  <dt id="integer~7"><a class="permalink" href="#integer~7">integer
    <i>imin</i></a></dt>
  <dd>Minimum index of the column (default: 0)</dd>
  <dt id="integer~8"><a class="permalink" href="#integer~8">integer
    <i>imax</i></a></dt>
  <dd>Maximum index of the column (default: ncols-1)</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::setrow</b> <i>matrix</i> <i>row</i>
    <i>newvalues</i> ?imin? ?imax?</dt>
  <dd>Set a single row of a matrix to new values (this list must have the same
      number of elements as the number of <i>columns</i> in the matrix)</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~2"><a class="permalink" href="#list~2">list
    <i>matrix</i></a></dt>
  <dd><i>name</i> of the matrix in question</dd>
  <dt id="integer~9"><a class="permalink" href="#integer~9">integer
    <i>row</i></a></dt>
  <dd>Index of the row to update</dd>
  <dt id="list~3"><a class="permalink" href="#list~3">list
    <i>newvalues</i></a></dt>
  <dd>List of new values for the row</dd>
  <dt id="integer~10"><a class="permalink" href="#integer~10">integer
    <i>imin</i></a></dt>
  <dd>Minimum index of the column (default: 0)</dd>
  <dt id="integer~11"><a class="permalink" href="#integer~11">integer
    <i>imax</i></a></dt>
  <dd>Maximum index of the column (default: ncols-1)</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::getcol</b> <i>matrix</i> <i>col</i> ?imin?
    ?imax?</dt>
  <dd>Returns a single column of a matrix as a list</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~4"><a class="permalink" href="#list~4">list
    <i>matrix</i></a></dt>
  <dd>Matrix in question</dd>
  <dt id="integer~12"><a class="permalink" href="#integer~12">integer
    <i>col</i></a></dt>
  <dd>Index of the column to return</dd>
  <dt id="integer~13"><a class="permalink" href="#integer~13">integer
    <i>imin</i></a></dt>
  <dd>Minimum index of the row (default: 0)</dd>
  <dt id="integer~14"><a class="permalink" href="#integer~14">integer
    <i>imax</i></a></dt>
  <dd>Maximum index of the row (default: nrows-1)</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::setcol</b> <i>matrix</i> <i>col</i>
    <i>newvalues</i> ?imin? ?imax?</dt>
  <dd>Set a single column of a matrix to new values (this list must have the
      same number of elements as the number of <i>rows</i> in the matrix)</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~5"><a class="permalink" href="#list~5">list
    <i>matrix</i></a></dt>
  <dd><i>name</i> of the matrix in question</dd>
  <dt id="integer~15"><a class="permalink" href="#integer~15">integer
    <i>col</i></a></dt>
  <dd>Index of the column to update</dd>
  <dt id="list~6"><a class="permalink" href="#list~6">list
    <i>newvalues</i></a></dt>
  <dd>List of new values for the column</dd>
  <dt id="integer~16"><a class="permalink" href="#integer~16">integer
    <i>imin</i></a></dt>
  <dd>Minimum index of the row (default: 0)</dd>
  <dt id="integer~17"><a class="permalink" href="#integer~17">integer
    <i>imax</i></a></dt>
  <dd>Maximum index of the row (default: nrows-1)</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::getelem</b> <i>matrix</i> <i>row</i>
    <i>col</i></dt>
  <dd>Returns a single element of a matrix/vector</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~7"><a class="permalink" href="#list~7">list
    <i>matrix</i></a></dt>
  <dd>Matrix or vector in question</dd>
  <dt id="integer~18"><a class="permalink" href="#integer~18">integer
    <i>row</i></a></dt>
  <dd>Row of the element</dd>
  <dt id="integer~19"><a class="permalink" href="#integer~19">integer
    <i>col</i></a></dt>
  <dd>Column of the element (not present for vectors)</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::setelem</b> <i>matrix</i> <i>row</i> ?col?
    <i>newvalue</i></dt>
  <dd>Set a single element of a matrix (or vector) to a new value</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~8"><a class="permalink" href="#list~8">list
    <i>matrix</i></a></dt>
  <dd><i>name</i> of the matrix in question</dd>
  <dt id="integer~20"><a class="permalink" href="#integer~20">integer
    <i>row</i></a></dt>
  <dd>Row of the element</dd>
  <dt id="integer~21"><a class="permalink" href="#integer~21">integer
    <i>col</i></a></dt>
  <dd>Column of the element (not present for vectors)</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::swaprows</b> <i>matrix</i> <i>irow1</i>
    <i>irow2</i> ?imin? ?imax?</dt>
  <dd>Swap two rows in a matrix completely or only a selected part</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~9"><a class="permalink" href="#list~9">list
    <i>matrix</i></a></dt>
  <dd><i>name</i> of the matrix in question</dd>
  <dt id="integer~22"><a class="permalink" href="#integer~22">integer
    <i>irow1</i></a></dt>
  <dd>Index of first row</dd>
  <dt id="integer~23"><a class="permalink" href="#integer~23">integer
    <i>irow2</i></a></dt>
  <dd>Index of second row</dd>
  <dt id="integer~24"><a class="permalink" href="#integer~24">integer
    <i>imin</i></a></dt>
  <dd>Minimum column index (default: 0)</dd>
  <dt id="integer~25"><a class="permalink" href="#integer~25">integer
    <i>imin</i></a></dt>
  <dd>Maximum column index (default: ncols-1)</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::swapcols</b> <i>matrix</i> <i>icol1</i>
    <i>icol2</i> ?imin? ?imax?</dt>
  <dd>Swap two columns in a matrix completely or only a selected part</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~10"><a class="permalink" href="#list~10">list
    <i>matrix</i></a></dt>
  <dd><i>name</i> of the matrix in question</dd>
  <dt id="integer~26"><a class="permalink" href="#integer~26">integer
    <i>irow1</i></a></dt>
  <dd>Index of first column</dd>
  <dt id="integer~27"><a class="permalink" href="#integer~27">integer
    <i>irow2</i></a></dt>
  <dd>Index of second column</dd>
  <dt id="integer~28"><a class="permalink" href="#integer~28">integer
    <i>imin</i></a></dt>
  <dd>Minimum row index (default: 0)</dd>
  <dt id="integer~29"><a class="permalink" href="#integer~29">integer
    <i>imin</i></a></dt>
  <dd>Maximum row index (default: nrows-1)</dd>
</dl>
</div>
<p class="Pp"><i>Querying matrices and vectors</i></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::show</b> <i>obj</i> ?format? ?rowsep?
    ?colsep?</dt>
  <dd>Return a string representing the vector or matrix, for easy printing.
      (There is currently no way to print fixed sets of columns)</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~11"><a class="permalink" href="#list~11">list <i>obj</i></a></dt>
  <dd>Matrix or vector in question</dd>
  <dt id="string"><a class="permalink" href="#string">string
    <i>format</i></a></dt>
  <dd>Format for printing the numbers (default: %6.4f)</dd>
  <dt id="string~2"><a class="permalink" href="#string~2">string
    <i>rowsep</i></a></dt>
  <dd>String to use for separating rows (default: newline)</dd>
  <dt id="string~3"><a class="permalink" href="#string~3">string
    <i>colsep</i></a></dt>
  <dd>String to use for separating columns (default: space)</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::dim</b> <i>obj</i></dt>
  <dd>Returns the number of dimensions for the object (either 0 for a scalar, 1
      for a vector and 2 for a matrix)</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="any"><a class="permalink" href="#any">any <i>obj</i></a></dt>
  <dd>Scalar, vector, or matrix</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::shape</b> <i>obj</i></dt>
  <dd>Returns the number of elements in each dimension for the object (either an
      empty list for a scalar, a single number for a vector and a list of the
      number of rows and columns for a matrix)</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="any~2"><a class="permalink" href="#any~2">any <i>obj</i></a></dt>
  <dd>Scalar, vector, or matrix</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::conforming</b> <i>type</i> <i>obj1</i>
    <i>obj2</i></dt>
  <dd>Checks if two objects (vector or matrix) have conforming shapes, that is
      if they can be applied in an operation like addition or matrix
      multiplication.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="string~4"><a class="permalink" href="#string~4">string
    <i>type</i></a></dt>
  <dd>Type of check:</dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>&quot;shape&quot; - the two objects have the same shape (for all
      element-wise operations)</li>
  <li>&quot;rows&quot; - the two objects have the same number of rows (for use
      as A and b in a system of linear equations <i>Ax = b</i></li>
  <li>&quot;matmul&quot; - the first object has the same number of columns as
      the number of rows of the second object. Useful for matrix-matrix or
      matrix-vector multiplication.</li>
</ul>
</div>
<dl class="Bl-tag">
  <dt id="list~12"><a class="permalink" href="#list~12">list
    <i>obj1</i></a></dt>
  <dd>First vector or matrix (left operand)</dd>
  <dt id="list~13"><a class="permalink" href="#list~13">list
    <i>obj2</i></a></dt>
  <dd>Second vector or matrix (right operand)</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::symmetric</b> <i>matrix</i> ?eps?</dt>
  <dd>Checks if the given (square) matrix is symmetric. The argument eps is the
      tolerance.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~14"><a class="permalink" href="#list~14">list
    <i>matrix</i></a></dt>
  <dd>Matrix to be inspected</dd>
  <dt id="float"><a class="permalink" href="#float">float <i>eps</i></a></dt>
  <dd>Tolerance for determining approximate equality (defaults to 1.0e-8)</dd>
</dl>
</div>
<p class="Pp"><i>Basic operations</i></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::norm</b> <i>vector</i> <i>type</i></dt>
  <dd>Returns the norm of the given vector. The type argument can be: 1, 2, inf
      or max, respectively the sum of absolute values, the ordinary Euclidean
      norm or the max norm.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~15"><a class="permalink" href="#list~15">list
    <i>vector</i></a></dt>
  <dd>Vector, list of coefficients</dd>
  <dt id="string~5"><a class="permalink" href="#string~5">string
    <i>type</i></a></dt>
  <dd>Type of norm (default: 2, the Euclidean norm)</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::norm_one</b> <i>vector</i></dt>
  <dd>Returns the L1 norm of the given vector, the sum of absolute values</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~16"><a class="permalink" href="#list~16">list
    <i>vector</i></a></dt>
  <dd>Vector, list of coefficients</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::norm_two</b> <i>vector</i></dt>
  <dd>Returns the L2 norm of the given vector, the ordinary Euclidean norm</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~17"><a class="permalink" href="#list~17">list
    <i>vector</i></a></dt>
  <dd>Vector, list of coefficients</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::norm_max</b> <i>vector</i> ?index?</dt>
  <dd>Returns the Linf norm of the given vector, the maximum absolute
      coefficient</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~18"><a class="permalink" href="#list~18">list
    <i>vector</i></a></dt>
  <dd>Vector, list of coefficients</dd>
  <dt id="integer~30"><a class="permalink" href="#integer~30">integer
    <i>index</i></a></dt>
  <dd>(optional) if non zero, returns a list made of the maximum value and the
      index where that maximum was found. if zero, returns the maximum
    value.</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::normMatrix</b> <i>matrix</i> <i>type</i></dt>
  <dd>Returns the norm of the given matrix. The type argument can be: 1, 2, inf
      or max, respectively the sum of absolute values, the ordinary Euclidean
      norm or the max norm.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~19"><a class="permalink" href="#list~19">list
    <i>matrix</i></a></dt>
  <dd>Matrix, list of row vectors</dd>
  <dt id="string~6"><a class="permalink" href="#string~6">string
    <i>type</i></a></dt>
  <dd>Type of norm (default: 2, the Euclidean norm)</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::dotproduct</b> <i>vect1</i> <i>vect2</i></dt>
  <dd>Determine the inproduct or dot product of two vectors. These must have the
      same shape (number of dimensions)</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~20"><a class="permalink" href="#list~20">list
    <i>vect1</i></a></dt>
  <dd>First vector, list of coefficients</dd>
  <dt id="list~21"><a class="permalink" href="#list~21">list
    <i>vect2</i></a></dt>
  <dd>Second vector, list of coefficients</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::unitLengthVector</b> <i>vector</i></dt>
  <dd>Return a vector in the same direction with length 1.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~22"><a class="permalink" href="#list~22">list
    <i>vector</i></a></dt>
  <dd>Vector to be normalized</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::normalizeStat</b> <i>mv</i></dt>
  <dd>Normalize the matrix or vector in a statistical sense: the mean of the
      elements of the columns of the result is zero and the standard deviation
      is 1.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~23"><a class="permalink" href="#list~23">list <i>mv</i></a></dt>
  <dd>Vector or matrix to be normalized in the above sense</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::axpy</b> <i>scale</i> <i>mv1</i> <i>mv2</i></dt>
  <dd>Return a vector or matrix that results from a &quot;daxpy&quot; operation,
      that is: compute a*x+y (a a scalar and x and y both vectors or matrices of
      the same shape) and return the result.
    <p class="Pp">Specialised variants are: axpy_vect and axpy_mat (slightly
        faster, but no check on the arguments)</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="double~3"><a class="permalink" href="#double~3">double
    <i>scale</i></a></dt>
  <dd>The scale factor for the first vector/matrix (a)</dd>
  <dt id="list~24"><a class="permalink" href="#list~24">list <i>mv1</i></a></dt>
  <dd>First vector or matrix (x)</dd>
  <dt id="list~25"><a class="permalink" href="#list~25">list <i>mv2</i></a></dt>
  <dd>Second vector or matrix (y)</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::add</b> <i>mv1</i> <i>mv2</i></dt>
  <dd>Return a vector or matrix that is the sum of the two arguments (x+y)
    <p class="Pp">Specialised variants are: add_vect and add_mat (slightly
        faster, but no check on the arguments)</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~26"><a class="permalink" href="#list~26">list <i>mv1</i></a></dt>
  <dd>First vector or matrix (x)</dd>
  <dt id="list~27"><a class="permalink" href="#list~27">list <i>mv2</i></a></dt>
  <dd>Second vector or matrix (y)</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::sub</b> <i>mv1</i> <i>mv2</i></dt>
  <dd>Return a vector or matrix that is the difference of the two arguments
      (x-y)
    <p class="Pp">Specialised variants are: sub_vect and sub_mat (slightly
        faster, but no check on the arguments)</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~28"><a class="permalink" href="#list~28">list <i>mv1</i></a></dt>
  <dd>First vector or matrix (x)</dd>
  <dt id="list~29"><a class="permalink" href="#list~29">list <i>mv2</i></a></dt>
  <dd>Second vector or matrix (y)</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::scale</b> <i>scale</i> <i>mv</i></dt>
  <dd>Scale a vector or matrix and return the result, that is: compute a*x.
    <p class="Pp">Specialised variants are: scale_vect and scale_mat (slightly
        faster, but no check on the arguments)</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="double~4"><a class="permalink" href="#double~4">double
    <i>scale</i></a></dt>
  <dd>The scale factor for the vector/matrix (a)</dd>
  <dt id="list~30"><a class="permalink" href="#list~30">list <i>mv</i></a></dt>
  <dd>Vector or matrix (x)</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::rotate</b> <i>c</i> <i>s</i> <i>vect1</i>
    <i>vect2</i></dt>
  <dd>Apply a planar rotation to two vectors and return the result as a list of
      two vectors: c*x-s*y and s*x+c*y. In algorithms you can often easily
      determine the cosine and sine of the angle, so it is more efficient to
      pass that information directly.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="double~5"><a class="permalink" href="#double~5">double
    <i>c</i></a></dt>
  <dd>The cosine of the angle</dd>
  <dt id="double~6"><a class="permalink" href="#double~6">double
    <i>s</i></a></dt>
  <dd>The sine of the angle</dd>
  <dt id="list~31"><a class="permalink" href="#list~31">list
    <i>vect1</i></a></dt>
  <dd>First vector (x)</dd>
  <dt id="list~32"><a class="permalink" href="#list~32">list
    <i>vect2</i></a></dt>
  <dd>Seocnd vector (x)</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::transpose</b> <i>matrix</i></dt>
  <dd>Transpose a matrix</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~33"><a class="permalink" href="#list~33">list
    <i>matrix</i></a></dt>
  <dd>Matrix to be transposed</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::matmul</b> <i>mv1</i> <i>mv2</i></dt>
  <dd>Multiply a vector/matrix with another vector/matrix. The result is a
      matrix, if both x and y are matrices or both are vectors, in which case
      the &quot;outer product&quot; is computed. If one is a vector and the
      other is a matrix, then the result is a vector.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~34"><a class="permalink" href="#list~34">list <i>mv1</i></a></dt>
  <dd>First vector/matrix (x)</dd>
  <dt id="list~35"><a class="permalink" href="#list~35">list <i>mv2</i></a></dt>
  <dd>Second vector/matrix (y)</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::angle</b> <i>vect1</i> <i>vect2</i></dt>
  <dd>Compute the angle between two vectors (in radians)</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~36"><a class="permalink" href="#list~36">list
    <i>vect1</i></a></dt>
  <dd>First vector</dd>
  <dt id="list~37"><a class="permalink" href="#list~37">list
    <i>vect2</i></a></dt>
  <dd>Second vector</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::crossproduct</b> <i>vect1</i> <i>vect2</i></dt>
  <dd>Compute the cross product of two (three-dimensional) vectors</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~38"><a class="permalink" href="#list~38">list
    <i>vect1</i></a></dt>
  <dd>First vector</dd>
  <dt id="list~39"><a class="permalink" href="#list~39">list
    <i>vect2</i></a></dt>
  <dd>Second vector</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::matmul</b> <i>mv1</i> <i>mv2</i></dt>
  <dd>Multiply a vector/matrix with another vector/matrix. The result is a
      matrix, if both x and y are matrices or both are vectors, in which case
      the &quot;outer product&quot; is computed. If one is a vector and the
      other is a matrix, then the result is a vector.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~40"><a class="permalink" href="#list~40">list <i>mv1</i></a></dt>
  <dd>First vector/matrix (x)</dd>
  <dt id="list~41"><a class="permalink" href="#list~41">list <i>mv2</i></a></dt>
  <dd>Second vector/matrix (y)</dd>
</dl>
</div>
<p class="Pp"><i>Common matrices and test matrices</i></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::mkIdentity</b> <i>size</i></dt>
  <dd>Create an identity matrix of dimension <i>size</i>.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="integer~31"><a class="permalink" href="#integer~31">integer
    <i>size</i></a></dt>
  <dd>Dimension of the matrix</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::mkDiagonal</b> <i>diag</i></dt>
  <dd>Create a diagonal matrix whose diagonal elements are the elements of the
      vector <i>diag</i>.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~42"><a class="permalink" href="#list~42">list
    <i>diag</i></a></dt>
  <dd>Vector whose elements are used for the diagonal</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::mkRandom</b> <i>size</i></dt>
  <dd>Create a square matrix whose elements are uniformly distributed random
      numbers between 0 and 1 of dimension <i>size</i>.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="integer~32"><a class="permalink" href="#integer~32">integer
    <i>size</i></a></dt>
  <dd>Dimension of the matrix</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::mkTriangular</b> <i>size</i> ?uplo? ?value?</dt>
  <dd>Create a triangular matrix with non-zero elements in the upper or lower
      part, depending on argument <i>uplo</i>.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="integer~33"><a class="permalink" href="#integer~33">integer
    <i>size</i></a></dt>
  <dd>Dimension of the matrix</dd>
  <dt id="string~7"><a class="permalink" href="#string~7">string
    <i>uplo</i></a></dt>
  <dd>Fill the upper (U) or lower part (L)</dd>
  <dt id="double~7"><a class="permalink" href="#double~7">double
    <i>value</i></a></dt>
  <dd>Value to fill the matrix with</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::mkHilbert</b> <i>size</i></dt>
  <dd>Create a Hilbert matrix of dimension <i>size</i>. Hilbert matrices are
      very ill-conditioned with respect to eigenvalue/eigenvector problems.
      Therefore they are good candidates for testing the accuracy of algorithms
      and implementations.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="integer~34"><a class="permalink" href="#integer~34">integer
    <i>size</i></a></dt>
  <dd>Dimension of the matrix</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::mkDingdong</b> <i>size</i></dt>
  <dd>Create a &quot;dingdong&quot; matrix of dimension <i>size</i>. Dingdong
      matrices are imprecisely represented, but have the property of being very
      stable in such algorithms as Gauss elimination.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="integer~35"><a class="permalink" href="#integer~35">integer
    <i>size</i></a></dt>
  <dd>Dimension of the matrix</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::mkOnes</b> <i>size</i></dt>
  <dd>Create a square matrix of dimension <i>size</i> whose entries are all
    1.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="integer~36"><a class="permalink" href="#integer~36">integer
    <i>size</i></a></dt>
  <dd>Dimension of the matrix</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::mkMoler</b> <i>size</i></dt>
  <dd>Create a Moler matrix of size <i>size</i>. (Moler matrices have a very
      simple Choleski decomposition. It has one small eigenvalue and it can
      easily upset elimination methods for systems of linear equations.)</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="integer~37"><a class="permalink" href="#integer~37">integer
    <i>size</i></a></dt>
  <dd>Dimension of the matrix</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::mkFrank</b> <i>size</i></dt>
  <dd>Create a Frank matrix of size <i>size</i>. (Frank matrices are fairly
      well-behaved matrices)</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="integer~38"><a class="permalink" href="#integer~38">integer
    <i>size</i></a></dt>
  <dd>Dimension of the matrix</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::mkBorder</b> <i>size</i></dt>
  <dd>Create a bordered matrix of size <i>size</i>. (Bordered matrices have a
      very low rank and can upset certain specialised algorithms.)</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="integer~39"><a class="permalink" href="#integer~39">integer
    <i>size</i></a></dt>
  <dd>Dimension of the matrix</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::mkWilkinsonW+</b> <i>size</i></dt>
  <dd>Create a Wilkinson W+ of size <i>size</i>. This kind of matrix has pairs
      of eigenvalues that are very close together. Usually the order (size) is
      odd.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="integer~40"><a class="permalink" href="#integer~40">integer
    <i>size</i></a></dt>
  <dd>Dimension of the matrix</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::mkWilkinsonW-</b> <i>size</i></dt>
  <dd>Create a Wilkinson W- of size <i>size</i>. This kind of matrix has pairs
      of eigenvalues with opposite signs, when the order (size) is odd.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="integer~41"><a class="permalink" href="#integer~41">integer
    <i>size</i></a></dt>
  <dd>Dimension of the matrix</dd>
</dl>
</div>
<p class="Pp"><i>Common algorithms</i></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::solveGauss</b> <i>matrix</i> <i>bvect</i></dt>
  <dd>Solve a system of linear equations (Ax=b) using Gauss elimination. Returns
      the solution (x) as a vector or matrix of the same shape as bvect.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~43"><a class="permalink" href="#list~43">list
    <i>matrix</i></a></dt>
  <dd>Square matrix (matrix A)</dd>
  <dt id="list~44"><a class="permalink" href="#list~44">list
    <i>bvect</i></a></dt>
  <dd>Vector or matrix whose columns are the individual b-vectors</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::solvePGauss</b> <i>matrix</i> <i>bvect</i></dt>
  <dd>Solve a system of linear equations (Ax=b) using Gauss elimination with
      partial pivoting. Returns the solution (x) as a vector or matrix of the
      same shape as bvect.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~45"><a class="permalink" href="#list~45">list
    <i>matrix</i></a></dt>
  <dd>Square matrix (matrix A)</dd>
  <dt id="list~46"><a class="permalink" href="#list~46">list
    <i>bvect</i></a></dt>
  <dd>Vector or matrix whose columns are the individual b-vectors</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::solveTriangular</b> <i>matrix</i> <i>bvect</i>
    ?uplo?</dt>
  <dd>Solve a system of linear equations (Ax=b) by backward substitution. The
      matrix is supposed to be upper-triangular.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~47"><a class="permalink" href="#list~47">list
    <i>matrix</i></a></dt>
  <dd>Lower or upper-triangular matrix (matrix A)</dd>
  <dt id="list~48"><a class="permalink" href="#list~48">list
    <i>bvect</i></a></dt>
  <dd>Vector or matrix whose columns are the individual b-vectors</dd>
  <dt id="string~8"><a class="permalink" href="#string~8">string
    <i>uplo</i></a></dt>
  <dd>Indicates whether the matrix is lower-triangular (L) or upper-triangular
      (U). Defaults to &quot;U&quot;.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::solveGaussBand</b> <i>matrix</i>
    <i>bvect</i></dt>
  <dd>Solve a system of linear equations (Ax=b) using Gauss elimination, where
      the matrix is stored as a band matrix (<i>cf.</i> <b>STORAGE</b>). Returns
      the solution (x) as a vector or matrix of the same shape as bvect.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~49"><a class="permalink" href="#list~49">list
    <i>matrix</i></a></dt>
  <dd>Square matrix (matrix A; in band form)</dd>
  <dt id="list~50"><a class="permalink" href="#list~50">list
    <i>bvect</i></a></dt>
  <dd>Vector or matrix whose columns are the individual b-vectors</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::solveTriangularBand</b> <i>matrix</i>
    <i>bvect</i></dt>
  <dd>Solve a system of linear equations (Ax=b) by backward substitution. The
      matrix is supposed to be upper-triangular and stored in band form.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~51"><a class="permalink" href="#list~51">list
    <i>matrix</i></a></dt>
  <dd>Upper-triangular matrix (matrix A)</dd>
  <dt id="list~52"><a class="permalink" href="#list~52">list
    <i>bvect</i></a></dt>
  <dd>Vector or matrix whose columns are the individual b-vectors</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::determineSVD</b> <i>A</i> <i>eps</i></dt>
  <dd>Determines the Singular Value Decomposition of a matrix: A = U S Vtrans.
      Returns a list with the matrix U, the vector of singular values S and the
      matrix V.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~53"><a class="permalink" href="#list~53">list <i>A</i></a></dt>
  <dd>Matrix to be decomposed</dd>
  <dt id="float~2"><a class="permalink" href="#float~2">float
    <i>eps</i></a></dt>
  <dd>Tolerance (defaults to 2.3e-16)</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::eigenvectorsSVD</b> <i>A</i> <i>eps</i></dt>
  <dd>Determines the eigenvectors and eigenvalues of a real <i>symmetric</i>
      matrix, using SVD. Returns a list with the matrix of normalized
      eigenvectors and their eigenvalues.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~54"><a class="permalink" href="#list~54">list <i>A</i></a></dt>
  <dd>Matrix whose eigenvalues must be determined</dd>
  <dt id="float~3"><a class="permalink" href="#float~3">float
    <i>eps</i></a></dt>
  <dd>Tolerance (defaults to 2.3e-16)</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::leastSquaresSVD</b> <i>A</i> <i>y</i>
    <i>qmin</i> <i>eps</i></dt>
  <dd>Determines the solution to a least-sqaures problem Ax ~ y via singular
      value decomposition. The result is the vector x.
    <p class="Pp">Note that if you add a column of 1s to the matrix, then this
        column will represent a constant like in: y = a*x1 + b*x2 + c. To force
        the intercept to be zero, simply leave it out.</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~55"><a class="permalink" href="#list~55">list <i>A</i></a></dt>
  <dd>Matrix of independent variables</dd>
  <dt id="list~56"><a class="permalink" href="#list~56">list <i>y</i></a></dt>
  <dd>List of observed values</dd>
  <dt id="float~4"><a class="permalink" href="#float~4">float
    <i>qmin</i></a></dt>
  <dd>Minimum singular value to be considered (defaults to 0.0)</dd>
  <dt id="float~5"><a class="permalink" href="#float~5">float
    <i>eps</i></a></dt>
  <dd>Tolerance (defaults to 2.3e-16)</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::choleski</b> <i>matrix</i></dt>
  <dd>Determine the Choleski decomposition of a symmetric positive semidefinite
      matrix (this condition is not checked!). The result is the
      lower-triangular matrix L such that L Lt = matrix.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~57"><a class="permalink" href="#list~57">list
    <i>matrix</i></a></dt>
  <dd>Matrix to be decomposed</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::orthonormalizeColumns</b> <i>matrix</i></dt>
  <dd>Use the modified Gram-Schmidt method to orthogonalize and normalize the
      <i>columns</i> of the given matrix and return the result.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~58"><a class="permalink" href="#list~58">list
    <i>matrix</i></a></dt>
  <dd>Matrix whose columns must be orthonormalized</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::orthonormalizeRows</b> <i>matrix</i></dt>
  <dd>Use the modified Gram-Schmidt method to orthogonalize and normalize the
      <i>rows</i> of the given matrix and return the result.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~59"><a class="permalink" href="#list~59">list
    <i>matrix</i></a></dt>
  <dd>Matrix whose rows must be orthonormalized</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::dger</b> <i>matrix</i> <i>alpha</i> <i>x</i>
    <i>y</i> ?scope?</dt>
  <dd>Perform the rank 1 operation A + alpha*x*y' inline (that is: the matrix A
      is adjusted). For convenience the new matrix is also returned as the
      result.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~60"><a class="permalink" href="#list~60">list
    <i>matrix</i></a></dt>
  <dd>Matrix whose rows must be adjusted</dd>
  <dt id="double~8"><a class="permalink" href="#double~8">double
    <i>alpha</i></a></dt>
  <dd>Scale factor</dd>
  <dt id="list~61"><a class="permalink" href="#list~61">list <i>x</i></a></dt>
  <dd>A column vector</dd>
  <dt id="list~62"><a class="permalink" href="#list~62">list <i>y</i></a></dt>
  <dd>A column vector</dd>
  <dt id="list~63"><a class="permalink" href="#list~63">list
    <i>scope</i></a></dt>
  <dd>If not provided, the operation is performed on all rows/columns of A if
      provided, it is expected to be the list {imin imax jmin jmax} where:</dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li><i>imin</i> Minimum row index</li>
  <li><i>imax</i> Maximum row index</li>
  <li><i>jmin</i> Minimum column index</li>
  <li><i>jmax</i> Maximum column index</li>
</ul>
</div>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::dgetrf</b> <i>matrix</i></dt>
  <dd>Computes an LU factorization of a general matrix, using partial, pivoting
      with row interchanges. Returns the permutation vector.
    <p class="Pp">The factorization has the form</p>
    <pre>
   P * A = L * U
    </pre>
    where P is a permutation matrix, L is lower triangular with unit diagonal
      elements, and U is upper triangular. Returns the permutation vector, as a
      list of length n-1. The last entry of the permutation is not stored, since
      it is implicitely known, with value n (the last row is not swapped with
      any other row). At index #i of the permutation is stored the index of the
      row #j which is swapped with row #i at step #i. That means that each index
      of the permutation gives the permutation at each step, not the cumulated
      permutation matrix, which is the product of permutations.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~64"><a class="permalink" href="#list~64">list
    <i>matrix</i></a></dt>
  <dd>On entry, the matrix to be factored. On exit, the factors L and U from the
      factorization P*A = L*U; the unit diagonal elements of L are not
    stored.</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::det</b> <i>matrix</i></dt>
  <dd>Returns the determinant of the given matrix, based on PA=LU decomposition,
      i.e. Gauss partial pivotal.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~65"><a class="permalink" href="#list~65">list
    <i>matrix</i></a></dt>
  <dd>Square matrix (matrix A)</dd>
  <dt id="list~66"><a class="permalink" href="#list~66">list
    <i>ipiv</i></a></dt>
  <dd>The pivots (optionnal). If the pivots are not provided, a PA=LU
      decomposition is performed. If the pivots are provided, we assume that it
      contains the pivots and that the matrix A contains the L and U factors, as
      provided by dgterf. b-vectors</dd>
</dl>
</div>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::largesteigen</b> <i>matrix</i> <i>tolerance</i>
    <i>maxiter</i></dt>
  <dd>Returns a list made of the largest eigenvalue (in magnitude) and
      associated eigenvector. Uses iterative Power Method as provided as
      algorithm #7.3.3 of Golub &amp; Van Loan. This algorithm is used here for
      a dense matrix (but is usually used for sparse matrices).</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~67"><a class="permalink" href="#list~67">list
    <i>matrix</i></a></dt>
  <dd>Square matrix (matrix A)</dd>
  <dt id="double~9"><a class="permalink" href="#double~9">double
    <i>tolerance</i></a></dt>
  <dd>The relative tolerance of the eigenvalue (default:1.e-8).</dd>
  <dt id="integer~42"><a class="permalink" href="#integer~42">integer
    <i>maxiter</i></a></dt>
  <dd>The maximum number of iterations (default:10).</dd>
</dl>
</div>
<p class="Pp"><i>Compability with the LA package</i> Two procedures are provided
    for compatibility with Hume's LA package:</p>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::to_LA</b> <i>mv</i></dt>
  <dd>Transforms a vector or matrix into the format used by the original LA
      package.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~68"><a class="permalink" href="#list~68">list <i>mv</i></a></dt>
  <dd>Matrix or vector</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>::math::linearalgebra::from_LA</b> <i>mv</i></dt>
  <dd>Transforms a vector or matrix from the format used by the original LA
      package into the format used by the present implementation.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="list~69"><a class="permalink" href="#list~69">list <i>mv</i></a></dt>
  <dd>Matrix or vector as used by the LA package</dd>
</dl>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="STORAGE"><a class="permalink" href="#STORAGE">STORAGE</a></h1>
<p class="Pp">While most procedures assume that the matrices are given in full
    form, the procedures <i>solveGaussBand</i> and <i>solveTriangularBand</i>
    assume that the matrices are stored as <i>band matrices</i>. This common
    type of &quot;sparse&quot; matrices is related to ordinary matrices as
    follows:</p>
<ul class="Bl-bullet">
  <li>&quot;A&quot; is a full-size matrix with N rows and M columns.</li>
  <li>&quot;B&quot; is a band matrix, with m upper and lower diagonals and n
      rows.</li>
  <li>&quot;B&quot; can be stored in an ordinary matrix of (2m+1) columns (one
      for each off-diagonal and the main diagonal) and n rows.</li>
  <li>Element i,j (i = -m,...,m; j =1,...,n) of &quot;B&quot; corresponds to
      element k,j of &quot;A&quot; where k = M+i-1 and M is at least (!) n, the
      number of rows in &quot;B&quot;.</li>
  <li>To set element (i,j) of matrix &quot;B&quot; use:
    <pre>
    setelem B $j [expr {$N+$i-1}] $value
    </pre>
  </li>
</ul>
<p class="Pp">(There is no convenience procedure for this yet)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="REMARKS_ON_THE_IMPLEMENTATION"><a class="permalink" href="#REMARKS_ON_THE_IMPLEMENTATION">REMARKS
  ON THE IMPLEMENTATION</a></h1>
<p class="Pp">There is a difference between the original LA package by Hume and
    the current implementation. Whereas the LA package uses a linear list, the
    current package uses lists of lists to represent matrices. It turns out that
    with this representation, the algorithms are faster and easier to
  implement.</p>
<p class="Pp">The LA package was used as a model and in fact the implementation
    of, for instance, the SVD algorithm was taken from that package. The set of
    procedures was expanded using ideas from the well-known BLAS library and
    some algorithms were updated from the second edition of J.C. Nash's book,
    Compact Numerical Methods for Computers, (Adam Hilger, 1990) that inspired
    the LA package.</p>
<p class="Pp">Two procedures are provided to make the transition between the two
    implementations easier: <i>to_LA</i> and <i>from_LA</i>. They are described
    above.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="TODO"><a class="permalink" href="#TODO">TODO</a></h1>
<p class="Pp">Odds and ends: the following algorithms have not been implemented
    yet:</p>
<ul class="Bl-bullet">
  <li>determineQR</li>
  <li>certainlyPositive, diagonallyDominant</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="NAMING_CONFLICT"><a class="permalink" href="#NAMING_CONFLICT">NAMING
  CONFLICT</a></h1>
<p class="Pp">If you load this package in a Tk-enabled shell like wish, then the
    command</p>
<pre>namespace import ::math::linearalgebra</pre>
<p class="Pp">results in an error message about &quot;scale&quot;. This is due
    to the fact that Tk defines all its commands in the global namespace. The
    solution is to import the linear algebra commands in a namespace that is not
    the global one:</p>
<pre>
package require math::linearalgebra
namespace eval compute {
    namespace import ::math::linearalgebra::*
    ... use the linear algebra version of scale ...
}
</pre>
<p class="Pp">To use Tk's scale command in that same namespace you can rename
    it:</p>
<pre>
namespace eval compute {
    rename ::scale scaleTk
    scaleTk .scale ...
}
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS,_IDEAS,_FEEDBACK"><a class="permalink" href="#BUGS,_IDEAS,_FEEDBACK">BUGS,
  IDEAS, FEEDBACK</a></h1>
<p class="Pp">This document, and the package it describes, will undoubtedly
    contain bugs and other problems. Please report such in the category <i>math
    :: linearalgebra</i> of the <i>Tcllib SF Trackers</i>
    [http://sourceforge.net/tracker/?group_id=12883]. Please also report any
    ideas for enhancements you may have for either package and/or
  documentation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
<p class="Pp">least squares, linear algebra, linear equations, math, matrices,
    vectors</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CATEGORY"><a class="permalink" href="#CATEGORY">CATEGORY</a></h1>
<p class="Pp">Mathematics</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<pre>Copyright (c) 2004-2008 Arjen Markus &lt;arjenmarkus@users.sourceforge.net&gt;
Copyright (c) 2004 Ed Hume &lt;http://www.hume.com/contact.us.htm&gt;
Copyright (c) 2008 Michael Buadin &lt;relaxkmike@users.sourceforge.net&gt;
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">1.1</td>
    <td class="foot-os">math</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Generated from file '/AppleInternal/Library/BuildRoots/0032d1ee-80fd-11ee-8227-6aecfccc70fe/Library/Caches/com.apple.xbs/Sources/tcl/tcl_ext/tcllib/tcllib/modules/grammar_me/me_tcl.man' by tcllib/doctools with format 'nroff'
   Copyright (c) 2005 Andreas Kupries <andreas_kupries@users.sourceforge.net>
  
   The definitions below are for supplemental macros used in Tcl/Tk
   manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO
  	Start of list of standard options for a Tk widget.  The
  	options follow on successive lines, in four columns separated
  	by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   RCS: @(#) $Id: man.macros,v 1.1 2009/01/30 04:56:47 andreas_kupries Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>grammar::me::tcl(n)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">grammar::me::tcl(n)</td>
    <td class="head-vol">Grammar operations and usage</td>
    <td class="head-rtitle">grammar::me::tcl(n)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>
</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">grammar::me::tcl - Virtual machine implementation I for parsing
    token streams</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">package require <b>Tcl 8.4</b></p>
<p class="Pp">package require <b>grammar::me::tcl ?0.1?</b></p>
<p class="Pp"><b>::grammar::me::tcl</b> <b>cmd</b> <i>...</i></p>
<p class="Pp"><b>::grammar::me::tcl</b> <b>init</b> <i>nextcmd</i>
    ?<i>tokmap</i>?</p>
<p class="Pp"><b>::grammar::me::tcl</b> <b>lc</b> <i>location</i></p>
<p class="Pp"><b>::grammar::me::tcl</b> <b>tok</b> <i>from</i> ?<i>to</i>?</p>
<p class="Pp"><b>::grammar::me::tcl</b> <b>tokens</b></p>
<p class="Pp"><b>::grammar::me::tcl</b> <b>sv</b></p>
<p class="Pp"><b>::grammar::me::tcl</b> <b>ast</b></p>
<p class="Pp"><b>::grammar::me::tcl</b> <b>astall</b></p>
<p class="Pp"><b>::grammar::me::tcl</b> <b>ctok</b></p>
<p class="Pp"><b>::grammar::me::tcl</b> <b>nc</b></p>
<p class="Pp"><b>::grammar::me::tcl</b> <b>next</b></p>
<p class="Pp"><b>::grammar::me::tcl</b> <b>ord</b></p>
<p class="Pp"><b>::grammar::me::tcl::ict_advance</b> <i>message</i></p>
<p class="Pp"><b>::grammar::me::tcl::ict_match_token</b> <i>tok</i>
    <i>message</i></p>
<p class="Pp"><b>::grammar::me::tcl::ict_match_tokrange</b> <i>tokbegin</i>
    <i>tokend</i> <i>message</i></p>
<p class="Pp"><b>::grammar::me::tcl::ict_match_tokclass</b> <i>code</i>
    <i>message</i></p>
<p class="Pp"><b>::grammar::me::tcl::inc_restore</b> <i>nt</i></p>
<p class="Pp"><b>::grammar::me::tcl::inc_save</b> <i>nt</i>
  <i>startlocation</i></p>
<p class="Pp"><b>::grammar::me::tcl::iok_ok</b></p>
<p class="Pp"><b>::grammar::me::tcl::iok_fail</b></p>
<p class="Pp"><b>::grammar::me::tcl::iok_negate</b></p>
<p class="Pp"><b>::grammar::me::tcl::icl_get</b></p>
<p class="Pp"><b>::grammar::me::tcl::icl_rewind</b> <i>oldlocation</i></p>
<p class="Pp"><b>::grammar::me::tcl::ier_get</b></p>
<p class="Pp"><b>::grammar::me::tcl::ier_clear</b></p>
<p class="Pp"><b>::grammar::me::tcl::ier_nonterminal</b> <i>message</i>
    <i>location</i></p>
<p class="Pp"><b>::grammar::me::tcl::ier_merge</b> <i>olderror</i></p>
<p class="Pp"><b>::grammar::me::tcl::isv_clear</b></p>
<p class="Pp"><b>::grammar::me::tcl::isv_terminal</b></p>
<p class="Pp"><b>::grammar::me::tcl::isv_nonterminal_leaf</b> <i>nt</i>
    <i>startlocation</i></p>
<p class="Pp"><b>::grammar::me::tcl::isv_nonterminal_range</b> <i>nt</i>
    <i>startlocation</i></p>
<p class="Pp"><b>::grammar::me::tcl::isv_nonterminal_reduce</b> <i>nt</i>
    <i>startlocation</i> ?<i>marker</i>?</p>
<p class="Pp"><b>::grammar::me::tcl::ias_push</b></p>
<p class="Pp"><b>::grammar::me::tcl::ias_mark</b></p>
<p class="Pp"><b>::grammar::me::tcl::ias_pop2mark</b> <i>marker</i></p>
<p class="Pp"></p>
<pre>
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This package provides an implementation of the ME virtual machine.
    Please go and read the document <b>grammar::me_intro</b> first if you do not
    know what a ME virtual machine is.</p>
<p class="Pp">This implementation is tied very strongly to Tcl. All the stacks
    in the machine state are handled through the Tcl stack, all control flow is
    handled by Tcl commands, and the remaining machine instructions are directly
    mapped to Tcl commands. Especially the matching of nonterminal symbols is
    handled by Tcl procedures as well, essentially extending the machine
    implementation with custom instructions.</p>
<p class="Pp">Further on the implementation handles only a single machine which
    is uninteruptible during execution and hardwired for pull operation. I.e. it
    explicitly requests each new token through a callback, pulling them into its
    state.</p>
<p class="Pp">A related package is <b>grammar::peg::interp</b> which provides a
    generic interpreter / parser for parsing expression grammars (PEGs),
    implemented on top of this implementation of the ME virtual machine.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="API"><a class="permalink" href="#API">API</a></h1>
<p class="Pp">The commands documented in this section do not implement any of
    the instructions of the ME virtual machine. They provide the facilities for
    the initialization of the machine and the retrieval of important
    information.</p>
<dl class="Bl-tag">
  <dt><b>::grammar::me::tcl</b> <b>cmd</b> <i>...</i></dt>
  <dd>This is an ensemble command providing access to the commands listed in
      this section. See the methods themselves for detailed specifications.</dd>
  <dt><b>::grammar::me::tcl</b> <b>init</b> <i>nextcmd</i> ?<i>tokmap</i>?</dt>
  <dd>This command (re)initializes the machine. It returns the empty string.
      This command has to be invoked before any other command of this package.
    <p class="Pp">The command prefix <i>nextcmd</i> represents the input stream
        of characters and is invoked by the machine whenever the a new character
        from the stream is required. The instruction for handling this is
        <i>ict_advance</i>. The callback has to return either the empty list, or
        a list of 4 elements containing the token, its lexeme attribute, and its
        location as line number and column index, in this order. The empty list
        is the signal that the end of the input stream has been reached. The
        lexeme attribute is stored in the terminal cache, but otherwise not used
        by the machine.</p>
    <p class="Pp">The optional dictionary <i>tokmap</i> maps from tokens to
        integer numbers. If present the numbers impose an order on the tokens,
        which is subsequently used by <i>ict_match_tokrange</i> to determine if
        a token is in the specified range or not. If no token map is specified
        the lexicographic order of th token names will be used instead. This
        choice is especially asensible when using characters as tokens.</p>
  </dd>
  <dt><b>::grammar::me::tcl</b> <b>lc</b> <i>location</i></dt>
  <dd>This command converts the location of a token given as offset in the input
      stream into the associated line number and column index. The result of the
      command is a 2-element list containing the two values, in the order
      mentioned in the previous sentence. This allows higher levels to convert
      the location information found in the error status and the generated AST
      into more human readable data.
    <p class="Pp"><i>Note</i> that the command is not able to convert locations
        which have not been reached by the machine yet. In other words, if the
        machine has read 7 tokens the command is able to convert the offsets
        <b>0</b> to <b>6</b>, but nothing beyond that. This also shows that it
        is not possible to convert offsets which refer to locations before the
        beginning of the stream.</p>
    <p class="Pp">After a call of <b>init</b> the state used for the conversion
        is cleared, making further conversions impossible until the machine has
        read tokens again.</p>
  </dd>
  <dt><b>::grammar::me::tcl</b> <b>tok</b> <i>from</i> ?<i>to</i>?</dt>
  <dd>This command returns a Tcl list containing the part of the input stream
      between the locations <i>from</i> and <i>to</i> (both inclusive). If
      <i>to</i> is not specified it will default to the value of <i>from</i>.
    <p class="Pp">Each element of the returned list is a list of four elements,
        the token, its associated lexeme, line number, and column index, in this
        order. In other words, each element has the same structure as the result
        of the <i>nextcmd</i> callback given to
      <b>::grammar::me::tcl::init</b></p>
    <p class="Pp">This command places the same restrictions on its location
        arguments as <b>::grammar::me::tcl::lc</b>.</p>
  </dd>
  <dt><b>::grammar::me::tcl</b> <b>tokens</b></dt>
  <dd>This command returns the number of tokens currently known to the ME
      virtual machine.</dd>
  <dt><b>::grammar::me::tcl</b> <b>sv</b></dt>
  <dd>This command returns the current semantic value <i>SV</i> stored in the
      machine. This is an abstract syntax tree as specified in the document
      <b>grammar::me_ast</b>, section <b>AST VALUES</b>.</dd>
  <dt><b>::grammar::me::tcl</b> <b>ast</b></dt>
  <dd>This method returns the abstract syntax tree currently at the top of the
      AST stack of the ME virtual machine. This is an abstract syntax tree as
      specified in the document <b>grammar::me_ast</b>, section <b>AST
      VALUES</b>.</dd>
  <dt><b>::grammar::me::tcl</b> <b>astall</b></dt>
  <dd>This method returns the whole stack of abstract syntax trees currently
      known to the ME virtual machine. Each element of the returned list is an
      abstract syntax tree as specified in the document <b>grammar::me_ast</b>,
      section <b>AST VALUES</b>. The top of the stack resides at the end of the
      list.</dd>
  <dt><b>::grammar::me::tcl</b> <b>ctok</b></dt>
  <dd>This method returns the current token considered by the ME virtual
      machine.</dd>
  <dt><b>::grammar::me::tcl</b> <b>nc</b></dt>
  <dd>This method returns the contents of the nonterminal cache as a dictionary
      mapping from &quot;<b>symbol</b>,<b>location</b>&quot; to match
      information.</dd>
  <dt><b>::grammar::me::tcl</b> <b>next</b></dt>
  <dd>This method returns the next token callback as specified during
      initialization of the ME virtual machine.</dd>
  <dt><b>::grammar::me::tcl</b> <b>ord</b></dt>
  <dd>This method returns a dictionary containing the <i>tokmap</i> specified
      during initialization of the ME virtual machine.
      <b></b><b>::grammar::me::tcl::ok</b> This variable contains the current
      match status <i>OK</i>. It is provided as variable instead of a command
      because that makes access to this information faster, and the speed of
      access is considered very important here as this information is used
      constantly to determine the control flow.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="MACHINE_STATE"><a class="permalink" href="#MACHINE_STATE">MACHINE
  STATE</a></h1>
<p class="Pp">Please go and read the document <b>grammar::me_vm</b> first for a
    specification of the basic ME virtual machine and its state.</p>
<p class="Pp">This implementation manages the state described in that document,
    except for the stacks minus the AST stack. In other words, location stack,
    error stack, return stack, and ast marker stack are implicitly managed
    through standard Tcl scoping, i.e. Tcl variables in procedures, outside of
    this implementation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MACHINE_INSTRUCTIONS"><a class="permalink" href="#MACHINE_INSTRUCTIONS">MACHINE
  INSTRUCTIONS</a></h1>
<p class="Pp">Please go and read the document <b>grammar::me_vm</b> first for a
    specification of the basic ME virtual machine and its instruction set.</p>
<p class="Pp">This implementation maps all instructions to Tcl commands in the
    namespace &quot;::grammar::me::tcl&quot;, except for the stack related
    commands, nonterminal symbols and control flow. Here we simply list the
    commands and explain the differences to the specified instructions, if there
    are any. For their semantics see the aforementioned specification. The
    machine commands are <i>not</i> reachable through the ensemble command
    <b>::grammar::me::tcl</b>.</p>
<dl class="Bl-tag">
  <dt><b>::grammar::me::tcl::ict_advance</b> <i>message</i></dt>
  <dd>No changes.</dd>
  <dt><b>::grammar::me::tcl::ict_match_token</b> <i>tok</i> <i>message</i></dt>
  <dd>No changes.</dd>
  <dt><b>::grammar::me::tcl::ict_match_tokrange</b> <i>tokbegin</i>
    <i>tokend</i> <i>message</i></dt>
  <dd>If, and only if a token map was specified during initialization then the
      arguments are the numeric representations of the smallest and largest
      tokens in the range. Otherwise they are the relevant tokens themselves and
      lexicographic comparison is used.</dd>
  <dt><b>::grammar::me::tcl::ict_match_tokclass</b> <i>code</i>
    <i>message</i></dt>
  <dd>No changes.</dd>
  <dt><b>::grammar::me::tcl::inc_restore</b> <i>nt</i></dt>
  <dd>Instead of taking a branchlabel the command returns a boolean value. The
      result will be <b>true</b> if and only if cached information was found.
      The caller has to perform the appropriate branching.</dd>
  <dt><b>::grammar::me::tcl::inc_save</b> <i>nt</i> <i>startlocation</i></dt>
  <dd>The command takes the start location as additional argument, as it is
      managed on the Tcl stack, and not in the machine state.</dd>
  <dt id="icf_ntcall"><a class="permalink" href="#icf_ntcall"><b>icf_ntcall</b>
    <i>branchlabel</i></a></dt>
  <dd></dd>
  <dt id="icf_ntreturn"><a class="permalink" href="#icf_ntreturn"><b>icf_ntreturn</b></a></dt>
  <dd>These two instructions are not mapped to commands. They are control flow
      instructions and handled in Tcl.</dd>
  <dt><b>::grammar::me::tcl::iok_ok</b></dt>
  <dd>No changes.</dd>
  <dt><b>::grammar::me::tcl::iok_fail</b></dt>
  <dd>No changes.</dd>
  <dt><b>::grammar::me::tcl::iok_negate</b></dt>
  <dd>No changes.</dd>
  <dt id="icf_jalways"><a class="permalink" href="#icf_jalways"><b>icf_jalways</b>
    <i>branchlabel</i></a></dt>
  <dd></dd>
  <dt id="icf_jok"><a class="permalink" href="#icf_jok"><b>icf_jok</b>
    <i>branchlabel</i></a></dt>
  <dd></dd>
  <dt id="icf_jfail"><a class="permalink" href="#icf_jfail"><b>icf_jfail</b>
    <i>branchlabel</i></a></dt>
  <dd></dd>
  <dt id="icf_halt"><a class="permalink" href="#icf_halt"><b>icf_halt</b></a></dt>
  <dd>These four instructions are not mapped to commands. They are control flow
      instructions and handled in Tcl.</dd>
  <dt><b>::grammar::me::tcl::icl_get</b></dt>
  <dd>This command returns the current location <i>CL</i> in the input. It
      replaces <i>icl_push</i>.</dd>
  <dt><b>::grammar::me::tcl::icl_rewind</b> <i>oldlocation</i></dt>
  <dd>The command takes the location as argument as it comes from the Tcl stack,
      not the machine state.</dd>
  <dt id="icl_pop"><a class="permalink" href="#icl_pop"><b>icl_pop</b></a></dt>
  <dd>Not mapped, the stacks are not managed by the package.</dd>
  <dt><b>::grammar::me::tcl::ier_get</b></dt>
  <dd>This command returns the current error state <i>ER</i>. It replaces
      <i>ier_push</i>.</dd>
  <dt><b>::grammar::me::tcl::ier_clear</b></dt>
  <dd>No changes.</dd>
  <dt><b>::grammar::me::tcl::ier_nonterminal</b> <i>message</i>
    <i>location</i></dt>
  <dd>The command takes the location as argument as it comes from the Tcl stack,
      not the machine state.</dd>
  <dt><b>::grammar::me::tcl::ier_merge</b> <i>olderror</i></dt>
  <dd>The command takes the second error state to merge as argument as it comes
      from the Tcl stack, not the machine state.</dd>
  <dt><b>::grammar::me::tcl::isv_clear</b></dt>
  <dd>No changes.</dd>
  <dt><b>::grammar::me::tcl::isv_terminal</b></dt>
  <dd>No changes.</dd>
  <dt><b>::grammar::me::tcl::isv_nonterminal_leaf</b> <i>nt</i>
    <i>startlocation</i></dt>
  <dd>The command takes the start location as argument as it comes from the Tcl
      stack, not the machine state.</dd>
  <dt><b>::grammar::me::tcl::isv_nonterminal_range</b> <i>nt</i>
    <i>startlocation</i></dt>
  <dd>The command takes the start location as argument as it comes from the Tcl
      stack, not the machine state.</dd>
  <dt><b>::grammar::me::tcl::isv_nonterminal_reduce</b> <i>nt</i>
    <i>startlocation</i> ?<i>marker</i>?</dt>
  <dd>The command takes start location and marker as argument as it comes from
      the Tcl stack, not the machine state.</dd>
  <dt><b>::grammar::me::tcl::ias_push</b></dt>
  <dd>No changes.</dd>
  <dt><b>::grammar::me::tcl::ias_mark</b></dt>
  <dd>This command returns a marker for the current state of the AST stack
      <i>AS</i>. The marker stack is not managed by the machine.</dd>
  <dt><b>::grammar::me::tcl::ias_pop2mark</b> <i>marker</i></dt>
  <dd>The command takes the marker as argument as it comes from the Tcl stack,
      not the machine state. It replaces <i>ias_mpop</i>.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS,_IDEAS,_FEEDBACK"><a class="permalink" href="#BUGS,_IDEAS,_FEEDBACK">BUGS,
  IDEAS, FEEDBACK</a></h1>
<p class="Pp">This document, and the package it describes, will undoubtedly
    contain bugs and other problems. Please report such in the category
    <i>grammar_me</i> of the <i>Tcllib SF Trackers</i>
    [http://sourceforge.net/tracker/?group_id=12883]. Please also report any
    ideas for enhancements you may have for either package and/or
  documentation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
<p class="Pp">grammar, parsing, virtual machine</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CATEGORY"><a class="permalink" href="#CATEGORY">CATEGORY</a></h1>
<p class="Pp">Grammars and finite automata</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<pre>Copyright (c) 2005 Andreas Kupries &lt;andreas_kupries@users.sourceforge.net&gt;
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">0.1</td>
    <td class="foot-os">grammar_me</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Generated from file '/AppleInternal/Library/BuildRoots/98ed8ad3-3356-11ee-9b53-aead88ae2785/Library/Caches/com.apple.xbs/Sources/tcl/tcl_ext/tcllib/tcllib/modules/struct/struct_list.man' by tcllib/doctools with format 'nroff'
   Copyright (c) 2003-2005 by Kevin B. Kenny. All rights reserved
   Copyright (c) 2003-2008 Andreas Kupries <andreas_kupries@users.sourceforge.net>
  
   The definitions below are for supplemental macros used in Tcl/Tk
   manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO
  	Start of list of standard options for a Tk widget.  The
  	options follow on successive lines, in four columns separated
  	by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   RCS: @(#) $Id: man.macros,v 1.1 2009/01/30 04:56:47 andreas_kupries Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>struct::list(n)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">struct::list(n)</td>
    <td class="head-vol">Tcl Data Structures</td>
    <td class="head-rtitle">struct::list(n)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>
</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">struct::list - Procedures for manipulating lists</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">package require <b>Tcl 8.0</b></p>
<p class="Pp">package require <b>struct::list ?1.7?</b></p>
<p class="Pp"><b>::struct::list</b> <b>longestCommonSubsequence</b>
    <i>sequence1</i> <i>sequence2</i> ?<i>maxOccurs</i>?</p>
<p class="Pp"><b>::struct::list</b> <b>longestCommonSubsequence2</b>
    <i>sequence1 sequence2</i> ?<i>maxOccurs</i>?</p>
<p class="Pp"><b>::struct::list</b> <b>lcsInvert</b> <i>lcsData</i> <i>len1</i>
    <i>len2</i></p>
<p class="Pp"><b>::struct::list</b> <b>lcsInvert2</b> <i>lcs1</i> <i>lcs2</i>
    <i>len1</i> <i>len2</i></p>
<p class="Pp"><b>::struct::list</b> <b>lcsInvertMerge</b> <i>lcsData</i>
    <i>len1</i> <i>len2</i></p>
<p class="Pp"><b>::struct::list</b> <b>lcsInvertMerge2</b> <i>lcs1</i>
    <i>lcs2</i> <i>len1</i> <i>len2</i></p>
<p class="Pp"><b>::struct::list</b> <b>reverse</b> <i>sequence</i></p>
<p class="Pp"><b>::struct::list</b> <b>assign</b> <i>sequence</i> <i>varname</i>
    ?<i>varname</i>?...</p>
<p class="Pp"><b>::struct::list</b> <b>flatten</b> ?<b>-full</b>? ?<b>--</b>?
    <i>sequence</i></p>
<p class="Pp"><b>::struct::list</b> <b>map</b> <i>sequence</i>
  <i>cmdprefix</i></p>
<p class="Pp"><b>::struct::list</b> <b>mapfor</b> <i>var</i> <i>sequence</i>
    <i>script</i></p>
<p class="Pp"><b>::struct::list</b> <b>filter</b> <i>sequence</i>
    <i>cmdprefix</i></p>
<p class="Pp"><b>::struct::list</b> <b>filterfor</b> <i>var</i> <i>sequence</i>
    <i>expr</i></p>
<p class="Pp"><b>::struct::list</b> <b>split</b> <i>sequence</i>
    <i>cmdprefix</i> ?<i>passVar</i> <i>failVar</i>?</p>
<p class="Pp"><b>::struct::list</b> <b>fold</b> <i>sequence</i>
    <i>initialvalue</i> <i>cmdprefix</i></p>
<p class="Pp"><b>::struct::list</b> <b>shift</b> <i>listvar</i></p>
<p class="Pp"><b>::struct::list</b> <b>iota</b> <i>n</i></p>
<p class="Pp"><b>::struct::list</b> <b>equal</b> <i>a</i> <i>b</i></p>
<p class="Pp"><b>::struct::list</b> <b>repeat</b> <i>size</i> <i>element1</i>
    ?<i>element2</i> <i>element3</i>...?</p>
<p class="Pp"><b>::struct::list</b> <b>repeatn</b> <i>value</i>
  <i>size</i>...</p>
<p class="Pp"><b>::struct::list</b> <b>dbJoin</b>
    ?<b>-inner</b>|<b>-left</b>|<b>-right</b>|<b>-full</b>? ?<b>-keys</b>
    <i>varname</i>? {<i>keycol</i> <i>table</i>}...</p>
<p class="Pp"><b>::struct::list</b> <b>dbJoinKeyed</b>
    ?<b>-inner</b>|<b>-left</b>|<b>-right</b>|<b>-full</b>? ?<b>-keys</b>
    <i>varname</i>? <i>table</i>...</p>
<p class="Pp"><b>::struct::list</b> <b>swap</b> <i>listvar</i> <i>i</i>
  <i>j</i></p>
<p class="Pp"><b>::struct::list</b> <b>firstperm</b> <i>list</i></p>
<p class="Pp"><b>::struct::list</b> <b>nextperm</b> <i>perm</i></p>
<p class="Pp"><b>::struct::list</b> <b>permutations</b> <i>list</i></p>
<p class="Pp"><b>::struct::list</b> <b>foreachperm</b> <i>var</i> <i>list</i>
    <i>body</i></p>
<p class="Pp"></p>
<pre>
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The <b>::struct::list</b> namespace contains several useful
    commands for processing Tcl lists. Generally speaking, they implement
    algorithms more complex or specialized than the ones provided by Tcl
  itself.</p>
<p class="Pp">It exports only a single command, <b>struct::list</b>. All
    functionality provided here can be reached through a subcommand of this
    command.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COMMANDS"><a class="permalink" href="#COMMANDS">COMMANDS</a></h1>
<dl class="Bl-tag">
  <dt><b>::struct::list</b> <b>longestCommonSubsequence</b> <i>sequence1</i>
    <i>sequence2</i> ?<i>maxOccurs</i>?</dt>
  <dd>Returns the longest common subsequence of elements in the two lists
      <i>sequence1</i> and <i>sequence2</i>. If the <i>maxOccurs</i> parameter
      is provided, the common subsequence is restricted to elements that occur
      no more than <i>maxOccurs</i> times in <i>sequence2</i>.
    <p class="Pp">The return value is a list of two lists of equal length. The
        first sublist is of indices into <i>sequence1</i>, and the second
        sublist is of indices into <i>sequence2</i>. Each corresponding pair of
        indices corresponds to equal elements in the sequences; the sequence
        returned is the longest possible.</p>
  </dd>
  <dt><b>::struct::list</b> <b>longestCommonSubsequence2</b> <i>sequence1
    sequence2</i> ?<i>maxOccurs</i>?</dt>
  <dd>Returns an approximation to the longest common sequence of elements in the
      two lists <i>sequence1</i> and <i>sequence2</i>. If the <i>maxOccurs</i>
      parameter is omitted, the subsequence computed is exactly the longest
      common subsequence; otherwise, the longest common subsequence is
      approximated by first determining the longest common sequence of only
      those elements that occur no more than <i>maxOccurs</i> times in
      <i>sequence2</i>, and then using that result to align the two lists,
      determining the longest common subsequences of the sublists between the
      two elements.
    <p class="Pp">As with <b>longestCommonSubsequence</b>, the return value is a
        list of two lists of equal length. The first sublist is of indices into
        <i>sequence1</i>, and the second sublist is of indices into
        <i>sequence2</i>. Each corresponding pair of indices corresponds to
        equal elements in the sequences. The sequence approximates the longest
        common subsequence.</p>
  </dd>
  <dt><b>::struct::list</b> <b>lcsInvert</b> <i>lcsData</i> <i>len1</i>
    <i>len2</i></dt>
  <dd>This command takes a description of a longest common subsequence
      (<i>lcsData</i>), inverts it, and returns the result. Inversion means here
      that as the input describes which parts of the two sequences are identical
      the output describes the differences instead.
    <p class="Pp">To be fully defined the lengths of the two sequences have to
        be known and are specified through <i>len1</i> and <i>len2</i>.</p>
    <p class="Pp">The result is a list where each element describes one chunk of
        the differences between the two sequences. This description is a list
        containing three elements, a type and two pairs of indices into
        <i>sequence1</i> and <i>sequence2</i> respectively, in this order. The
        type can be one of three values:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="added"><a class="permalink" href="#added"><b>added</b></a></dt>
  <dd>Describes an addition. I.e. items which are missing in <i>sequence1</i>
      can be found in <i>sequence2</i>. The pair of indices into
      <i>sequence1</i> describes where the added range had been expected to be
      in <i>sequence1</i>. The first index refers to the item just before the
      added range, and the second index refers to the item just after the added
      range. The pair of indices into <i>sequence2</i> describes the range of
      items which has been added to it. The first index refers to the first item
      in the range, and the second index refers to the last item in the
    range.</dd>
  <dt id="deleted"><a class="permalink" href="#deleted"><b>deleted</b></a></dt>
  <dd>Describes a deletion. I.e. items which are in <i>sequence1</i> are missing
      from <i>sequence2</i>. The pair of indices into <i>sequence1</i> describes
      the range of items which has been deleted. The first index refers to the
      first item in the range, and the second index refers to the last item in
      the range. The pair of indices into <i>sequence2</i> describes where the
      deleted range had been expected to be in <i>sequence2</i>. The first index
      refers to the item just before the deleted range, and the second index
      refers to the item just after the deleted range.</dd>
  <dt id="changed"><a class="permalink" href="#changed"><b>changed</b></a></dt>
  <dd>Describes a general change. I.e a range of items in <i>sequence1</i> has
      been replaced by a different range of items in <i>sequence2</i>. The pair
      of indices into <i>sequence1</i> describes the range of items which has
      been replaced. The first index refers to the first item in the range, and
      the second index refers to the last item in the range. The pair of indices
      into <i>sequence2</i> describes the range of items replacing the original
      range. Again the first index refers to the first item in the range, and
      the second index refers to the last item in the range.</dd>
</dl>
</div>
<p class="Pp"></p>
<pre>
    sequence 1 = {a b r a c a d a b r a}
    lcs 1      =   {1 2   4 5     8 9 10}
    lcs 2      =   {0 1   3 4     5 6 7}
    sequence 2 =   {b r i c a     b r a c}
    Inversion  = {{deleted  {0  0} {-1 0}}
                  {changed  {3  3}  {2 2}}
                  {deleted  {6  7}  {4 5}}
                  {added   {10 11}  {8 8}}}
</pre>
<p class="Pp"><i>Notes:</i></p>
<p class="Pp"></p>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>An index of <b>-1</b> in a <i>deleted</i> chunk refers to just before the
      first element of the second sequence.</li>
  <li>Also an index equal to the length of the first sequence in an <i>added</i>
      chunk refers to just behind the end of the sequence.</li>
</ul>
</div>
<dl class="Bl-tag">
  <dt><b>::struct::list</b> <b>lcsInvert2</b> <i>lcs1</i> <i>lcs2</i>
    <i>len1</i> <i>len2</i></dt>
  <dd>Similar to <b>lcsInvert</b>. Instead of directly taking the result of a
      call to <b>longestCommonSubsequence</b> this subcommand expects the
      indices for the two sequences in two separate lists.</dd>
  <dt><b>::struct::list</b> <b>lcsInvertMerge</b> <i>lcsData</i> <i>len1</i>
    <i>len2</i></dt>
  <dd>Similar to <b>lcsInvert</b>. It returns essentially the same structure as
      that command, except that it may contain chunks of type <b>unchanged</b>
      too.
    <p class="Pp">These new chunks describe the parts which are unchanged
        between the two sequences. This means that the result of this command
        describes both the changed and unchanged parts of the two sequences in
        one structure.</p>
    <p class="Pp"></p>
    <pre>
    sequence 1 = {a b r a c a d a b r a}
    lcs 1      =   {1 2   4 5     8 9 10}
    lcs 2      =   {0 1   3 4     5 6 7}
    sequence 2 =   {b r i c a     b r a c}
    Inversion/Merge  = {{deleted   {0  0} {-1 0}}
                        {unchanged {1  2}  {0 1}}
                        {changed   {3  3}  {2 2}}
                        {unchanged {4  5}  {3 4}}
                        {deleted   {6  7}  {4 5}}
                        {unchanged {8 10}  {5 7}}
                        {added    {10 11}  {8 8}}}
    </pre>
  </dd>
  <dt><b>::struct::list</b> <b>lcsInvertMerge2</b> <i>lcs1</i> <i>lcs2</i>
    <i>len1</i> <i>len2</i></dt>
  <dd>Similar to <b>lcsInvertMerge</b>. Instead of directly taking the result of
      a call to <b>longestCommonSubsequence</b> this subcommand expects the
      indices for the two sequences in two separate lists.</dd>
  <dt><b>::struct::list</b> <b>reverse</b> <i>sequence</i></dt>
  <dd>The subcommand takes a single <i>sequence</i> as argument and returns a
      new sequence containing the elements of the input sequence in reverse
      order.</dd>
  <dt><b>::struct::list</b> <b>assign</b> <i>sequence</i> <i>varname</i>
    ?<i>varname</i>?...</dt>
  <dd>The subcommand assigns the first <b>n</b> elements of the input
      <i>sequence</i> to the one or more variables whose names were listed after
      the sequence, where <b>n</b> is the number of specified variables.
    <p class="Pp">If there are more variables specified than there are elements
        in the <i>sequence</i> the empty string will be assigned to the
        superfluous variables.</p>
    <p class="Pp">If there are more elements in the <i>sequence</i> than
        variable names specified the subcommand returns a list containing the
        unassigned elements. Else an empty list is returned.</p>
    <pre>
    tclsh&gt; ::struct::list assign {a b c d e} foo bar
    c d e
    tclsh&gt; set foo
    a
    tclsh&gt; set bar
    b
    </pre>
  </dd>
  <dt><b>::struct::list</b> <b>flatten</b> ?<b>-full</b>? ?<b>--</b>?
    <i>sequence</i></dt>
  <dd>The subcommand takes a single <i>sequence</i> and returns a new sequence
      where one level of nesting was removed from the input sequence. In other
      words, the sublists in the input sequence are replaced by their elements.
    <p class="Pp">The subcommand will remove any nesting it finds if the option
        <b>-full</b> is specified.</p>
    <pre>
    tclsh&gt; ::struct::list flatten {1 2 3 {4 5} {6 7} {{8 9}} 10}
    1 2 3 4 5 6 7 {8 9} 10
    tclsh&gt; ::struct::list flatten -full {1 2 3 {4 5} {6 7} {{8 9}} 10}
    1 2 3 4 5 6 7 8 9 10
    </pre>
  </dd>
  <dt><b>::struct::list</b> <b>map</b> <i>sequence</i> <i>cmdprefix</i></dt>
  <dd>The subcommand takes a <i>sequence</i> to operate on and a command prefix
      (<i>cmdprefix</i>) specifying an operation, applies the command prefix to
      each element of the sequence and returns a sequence consisting of the
      results of that application.
    <p class="Pp">The command prefix will be evaluated with a single word
        appended to it. The evaluation takes place in the context of the caller
        of the subcommand.</p>
    <p class="Pp"></p>
    <pre>
    tclsh&gt; # squaring all elements in a list
    tclsh&gt; proc sqr {x} {expr {$x*$x}}
    tclsh&gt; ::struct::list map {1 2 3 4 5} sqr
    1 4 9 16 25
    tclsh&gt; # Retrieving the second column from a matrix
    tclsh&gt; # given as list of lists.
    tclsh&gt; proc projection {n list} {::lindex $list $n}
    tclsh&gt; ::struct::list map {{a b c} {1 2 3} {d f g}} {projection 1}
    b 2 f
    </pre>
  </dd>
  <dt><b>::struct::list</b> <b>mapfor</b> <i>var</i> <i>sequence</i>
    <i>script</i></dt>
  <dd>The subcommand takes a <i>sequence</i> to operate on and a tcl
      <i>script</i>, applies the script to each element of the sequence and
      returns a sequence consisting of the results of that application.
    <p class="Pp">The script will be evaluated as is, and has access to the
        current list element through the specified iteration variable
        <i>var</i>. The evaluation takes place in the context of the caller of
        the subcommand.</p>
    <p class="Pp"></p>
    <pre>
    tclsh&gt; # squaring all elements in a list
    tclsh&gt; ::struct::list mapfor x {1 2 3 4 5} {
	expr {$x * $x}
    }
    1 4 9 16 25
    tclsh&gt; # Retrieving the second column from a matrix
    tclsh&gt; # given as list of lists.
    tclsh&gt; ::struct::list mapfor x {{a b c} {1 2 3} {d f g}} {
	lindex $x 1
    }
    b 2 f
    </pre>
  </dd>
  <dt><b>::struct::list</b> <b>filter</b> <i>sequence</i> <i>cmdprefix</i></dt>
  <dd>The subcommand takes a <i>sequence</i> to operate on and a command prefix
      (<i>cmdprefix</i>) specifying an operation, applies the command prefix to
      each element of the sequence and returns a sequence consisting of all
      elements of the <i>sequence</i> for which the command prefix returned
      <b>true</b>. In other words, this command filters out all elements of the
      input <i>sequence</i> which fail the test the <i>cmdprefix</i> represents,
      and returns the remaining elements.
    <p class="Pp">The command prefix will be evaluated with a single word
        appended to it. The evaluation takes place in the context of the caller
        of the subcommand.</p>
    <p class="Pp"></p>
    <pre>
    tclsh&gt; # removing all odd numbers from the input
    tclsh&gt; proc even {x} {expr {($x % 2) == 0}}
    tclsh&gt; ::struct::list filter {1 2 3 4 5} even
    2 4
    </pre>
    <p class="Pp"><i>Note:</i> The <b>filter</b> is a specialized application of
        <b>fold</b> where the result is extended with the current item or not,
        depending o nthe result of the test.</p>
  </dd>
  <dt><b>::struct::list</b> <b>filterfor</b> <i>var</i> <i>sequence</i>
    <i>expr</i></dt>
  <dd>The subcommand takes a <i>sequence</i> to operate on and a tcl expression
      (<i>expr</i>) specifying a condition, applies the conditionto each element
      of the sequence and returns a sequence consisting of all elements of the
      <i>sequence</i> for which the expression returned <b>true</b>. In other
      words, this command filters out all elements of the input <i>sequence</i>
      which fail the test the condition <i>expr</i> represents, and returns the
      remaining elements.
    <p class="Pp">The expression will be evaluated as is, and has access to the
        current list element through the specified iteration variable
        <i>var</i>. The evaluation takes place in the context of the caller of
        the subcommand.</p>
    <p class="Pp"></p>
    <pre>
    tclsh&gt; # removing all odd numbers from the input
    tclsh&gt; ::struct::list filterfor x {1 2 3 4 5} {($x % 2) == 0}
    2 4
    </pre>
  </dd>
  <dt><b>::struct::list</b> <b>split</b> <i>sequence</i> <i>cmdprefix</i>
    ?<i>passVar</i> <i>failVar</i>?</dt>
  <dd>This is a variant of method <b>filter</b>, see above. Instead of returning
      just the elements passing the test we get lists of both passing and
      failing elements.
    <p class="Pp">If no variable names are specified then the result of the
        command will be a list containing the list of passing elements, and the
        list of failing elements, in this order. Otherwise the lists of passing
        and failing elements are stored into the two specified variables, and
        the result will be a list containing two numbers, the number of elements
        passing the test, and the number of elements failing, in this order.</p>
    <p class="Pp">The interface to the test is the same as used by
        <b>filter</b>.</p>
  </dd>
  <dt><b>::struct::list</b> <b>fold</b> <i>sequence</i> <i>initialvalue</i>
    <i>cmdprefix</i></dt>
  <dd>The subcommand takes a <i>sequence</i> to operate on, an arbitrary string
      <i>initial value</i> and a command prefix (<i>cmdprefix</i>) specifying an
      operation.
    <p class="Pp">The command prefix will be evaluated with two words appended
        to it. The second of these words will always be an element of the
        sequence. The evaluation takes place in the context of the caller of the
        subcommand.</p>
    <p class="Pp">It then reduces the sequence into a single value through
        repeated application of the command prefix and returns that value. This
        reduction is done by</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>1</b></dt>
  <dd>Application of the command to the initial value and the first element of
      the list.</dd>
  <dt><b>2</b></dt>
  <dd>Application of the command to the result of the last call and the second
      element of the list.</dd>
  <dt id="i"><a class="permalink" href="#i"><b>i</b></a></dt>
  <dd>Application of the command to the result of the last call and the
      <b>i</b>'th element of the list.</dd>
  <dt id="end"><a class="permalink" href="#end"><b>end</b></a></dt>
  <dd>Application of the command to the result of the last call and the last
      element of the list. The result of this call is returned as the result of
      the subcommand.</dd>
</dl>
</div>
<p class="Pp"></p>
<pre>
    tclsh&gt; # summing the elements in a list.
    tclsh&gt; proc + {a b} {expr {$a + $b}}
    tclsh&gt; ::struct::list fold {1 2 3 4 5} 0 +
    15
</pre>
<dl class="Bl-tag">
  <dt><b>::struct::list</b> <b>shift</b> <i>listvar</i></dt>
  <dd>The subcommand takes the list contained in the variable named by
      <i>listvar</i> and shifts it down one element. After the call
      <i>listvar</i> will contain a list containing the second to last elements
      of the input list. The first element of the ist is returned as the result
      of the command. Shifting the empty list does nothing.</dd>
  <dt><b>::struct::list</b> <b>iota</b> <i>n</i></dt>
  <dd>The subcommand returns a list containing the integer numbers in the range
      <b>[0,n)</b>. The element at index <b>i</b> of the list contain the number
      <b>i</b>.
    <p class="Pp">For &quot;<i>n</i> == <b>0</b>&quot; an empty list will be
        returned.</p>
  </dd>
  <dt><b>::struct::list</b> <b>equal</b> <i>a</i> <i>b</i></dt>
  <dd>The subcommand compares the two lists <i>a</i> and <i>b</i> for equality.
      In other words, they have to be of the same length and have to contain the
      same elements in the same order. If an element is a list the same
      definition of equality applies recursively.
    <p class="Pp">A boolean value will be returned as the result of the command.
        This value will be <b>true</b> if the two lists are equal, and
        <b>false</b> else.</p>
  </dd>
  <dt><b>::struct::list</b> <b>repeat</b> <i>size</i> <i>element1</i>
    ?<i>element2</i> <i>element3</i>...?</dt>
  <dd>The subcommand creates a list of length &quot;<i>size</i> * <i>number of
      elements</i>&quot; by repeating <i>size</i> times the sequence of elements
      <i>element1</i> <i>element2</i> <i>...</i>. <i>size</i> must be a positive
      integer, <i>element</i><b>n</b> can be any Tcl value. Note that <b>repeat
      1 arg ...</b> is identical to <b>list arg ...</b>, though the <i>arg</i>
      is required with <b>repeat</b>.
    <p class="Pp"><i>Examples:</i></p>
    <p class="Pp"></p>
    <pre>
    tclsh&gt; ::struct::list repeat 3 a
    a a a
    tclsh&gt; ::struct::list repeat 3 [::struct::list repeat 3 0]
    {0 0 0} {0 0 0} {0 0 0}
    tclsh&gt; ::struct::list repeat 3 a b c
    a b c a b c a b c
    tclsh&gt; ::struct::list repeat 3 [::struct::list repeat 2 a] b c
    {a a} b c {a a} b c {a a} b c
    </pre>
  </dd>
  <dt><b>::struct::list</b> <b>repeatn</b> <i>value</i> <i>size</i>...</dt>
  <dd>The subcommand creates a (nested) list containing the <i>value</i> in all
      positions. The exact size and degree of nesting is determined by the
      <i>size</i> arguments, all of which have to be integer numbers greater
      than or equal to zero.
    <p class="Pp">A single argument <i>size</i> which is a list of more than one
        element will be treated as if more than argument <i>size</i> was
        specified.</p>
    <p class="Pp">If only one argument <i>size</i> is present the returned list
        will not be nested, of length <i>size</i> and contain <i>value</i> in
        all positions. If more than one <i>size</i> argument is present the
        returned list will be nested, and of the length specified by the last
        <i>size</i> argument given to it. The elements of that list are defined
        as the result of <b>Repeat</b> for the same arguments, but with the last
        <i>size</i> value removed.</p>
    <p class="Pp">An empty list will be returned if no <i>size</i> arguments are
        present.</p>
    <p class="Pp"></p>
    <pre>
    tclsh&gt; ::struct::list repeatn  0 3 4
    {0 0 0} {0 0 0} {0 0 0} {0 0 0}
    tclsh&gt; ::struct::list repeatn  0 {3 4}
    {0 0 0} {0 0 0} {0 0 0} {0 0 0}
    tclsh&gt; ::struct::list repeatn  0 {3 4 5}
    {{0 0 0} {0 0 0} {0 0 0} {0 0 0}} {{0 0 0} {0 0 0} {0 0 0} {0 0 0}} {{0 0 0} {0 0 0} {0 0 0} {0 0 0}} {{0 0 0} {0 0 0} {0 0 0} {0 0 0}} {{0 0 0} {0 0 0} {0 0 0} {0 0 0}}
    </pre>
  </dd>
  <dt><b>::struct::list</b> <b>dbJoin</b>
    ?<b>-inner</b>|<b>-left</b>|<b>-right</b>|<b>-full</b>? ?<b>-keys</b>
    <i>varname</i>? {<i>keycol</i> <i>table</i>}...</dt>
  <dd>The method performs a table join according to relational algebra. The
      execution of any of the possible outer join operation is triggered by the
      presence of either option <b>-left</b>, <b>-right</b>, or <b>-full</b>. If
      none of these options is present a regular inner join will be performed.
      This can also be triggered by specifying <b>-inner</b>. The various
      possible join operations are explained in detail in section <b>TABLE
      JOIN</b>.
    <p class="Pp">If the <b>-keys</b> is present its argument is the name of a
        variable to store the full list of found keys into. Depending on the
        exact nature of the input table and the join mode the output table may
        not contain all the keys by default. In such a case the caller can
        declare a variable for this information and then insert it into the
        output table on its own, as she will have more information about the
        placement than this command.</p>
    <p class="Pp">What is left to explain is the format of the arguments.</p>
    <p class="Pp">The <i>keycol</i> arguments are the indices of the columns in
        the tables which contain the key values to use for the joining. Each
        argument applies to the table following immediately after it. The
        columns are counted from <b>0</b>, which references the first column.
        The table associated with the column index has to have at least
        <i>keycol</i>+1 columns. An error will be thrown if there are less.</p>
    <p class="Pp">The <i>table</i> arguments represent a table or matrix of rows
        and columns of values. We use the same representation as generated and
        consumed by the methods <b>get rect</b> and <b>set rect</b> of
        <b>matrix</b> objects. In other words, each argument is a list,
        representing the whole matrix. Its elements are lists too, each
        representing a single rows of the matrix. The elements of the row-lists
        are the column values.</p>
    <p class="Pp">The table resulting from the join operation is returned as the
        result of the command. We use the same representation as described above
        for the input <i>table</i>s.</p>
  </dd>
  <dt><b>::struct::list</b> <b>dbJoinKeyed</b>
    ?<b>-inner</b>|<b>-left</b>|<b>-right</b>|<b>-full</b>? ?<b>-keys</b>
    <i>varname</i>? <i>table</i>...</dt>
  <dd>The operations performed by this method are the same as described above
      for <b>dbJoin</b>. The only difference is in the specification of the keys
      to use. Instead of using column indices separate from the table here the
      keys are provided within the table itself. The row elements in each
      <i>table</i> are not the lists of column values, but a two-element list
      where the second element is the regular list of column values and the
      first element is the key to use.</dd>
  <dt><b>::struct::list</b> <b>swap</b> <i>listvar</i> <i>i</i> <i>j</i></dt>
  <dd>The subcommand exchanges the elements at the indices <i>i</i> and <i>j</i>
      in the list stored in the variable named by <i>listvar</i>. The list is
      modified in place, and also returned as the result of the subcommand.</dd>
  <dt><b>::struct::list</b> <b>firstperm</b> <i>list</i></dt>
  <dd>This subcommand returns the lexicographically first permutation of the
      input <i>list</i>.</dd>
  <dt><b>::struct::list</b> <b>nextperm</b> <i>perm</i></dt>
  <dd>This subcommand accepts a permutation of a set of elements (provided by
      <i>perm</i>) and returns the next permutatation in lexicographic sequence.
    <p class="Pp">The algorithm used here is by Donal E. Knuth, see section
        <b>REFERENCES</b> for details.</p>
  </dd>
  <dt><b>::struct::list</b> <b>permutations</b> <i>list</i></dt>
  <dd>This subcommand returns a list containing all permutations of the input
      <i>list</i> in lexicographic order.</dd>
  <dt><b>::struct::list</b> <b>foreachperm</b> <i>var</i> <i>list</i>
    <i>body</i></dt>
  <dd>This subcommand executes the script <i>body</i> once for each permutation
      of the specified <i>list</i>. The permutations are visited in
      lexicographic order, and the variable <i>var</i> is set to the permutation
      for which <i>body</i> is currently executed. The result of the loop
      command is the empty string.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="LONGEST_COMMON_SUBSEQUENCE_AND_FILE_COMPARISON"><a class="permalink" href="#LONGEST_COMMON_SUBSEQUENCE_AND_FILE_COMPARISON">LONGEST
  COMMON SUBSEQUENCE AND FILE COMPARISON</a></h1>
<p class="Pp">The <b>longestCommonSubsequence</b> subcommand forms the core of a
    flexible system for doing differential comparisons of files, similar to the
    capability offered by the Unix command <b>diff</b>. While this procedure is
    quite rapid for many tasks of file comparison, its performance degrades
    severely if <i>sequence2</i> contains many equal elements (as, for instance,
    when using this procedure to compare two files, a quarter of whose lines are
    blank. This drawback is intrinsic to the algorithm used (see the Reference
    for details).</p>
<p class="Pp">One approach to dealing with the performance problem that is
    sometimes effective in practice is arbitrarily to exclude elements that
    appear more than a certain number of times. This number is provided as the
    <i>maxOccurs</i> parameter. If frequent lines are excluded in this manner,
    they will not appear in the common subsequence that is computed; the result
    will be the longest common subsequence of infrequent elements. The procedure
    <b>longestCommonSubsequence2</b> implements this heuristic. It functions as
    a wrapper around <b>longestCommonSubsequence</b>; it computes the longest
    common subsequence of infrequent elements, and then subdivides the
    subsequences that lie between the matches to approximate the true longest
    common subsequence.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="TABLE_JOIN"><a class="permalink" href="#TABLE_JOIN">TABLE
  JOIN</a></h1>
<p class="Pp">This is an operation from relational algebra for relational
    databases.</p>
<p class="Pp">The easiest way to understand the regular inner join is that it
    creates the cartesian product of all the tables involved first and then
    keeps only all those rows in the resulting table for which the values in the
    specified key columns are equal to each other.</p>
<p class="Pp">Implementing this description naively, i.e. as described above
    will generate a <i>huge</i> intermediate result. To avoid this the cartesian
    product and the filtering of row are done at the same time. What is required
    is a fast way to determine if a key is present in a table. In a true
    database this is done through indices. Here we use arrays internally.</p>
<p class="Pp">An <i>outer</i> join is an extension of the inner join for two
    tables. There are three variants of outerjoins, called <i>left</i>,
    <i>right</i>, and <i>full</i> outer joins. Their result always contains all
    rows from an inner join and then some additional rows.</p>
<dl class="Bl-tag">
  <dt>[1]</dt>
  <dd>For the left outer join the additional rows are all rows from the left
      table for which there is no key in the right table. They are joined to an
      empty row of the right table to fit them into the result.</dd>
  <dt>[2]</dt>
  <dd>For the right outer join the additional rows are all rows from the right
      table for which there is no key in the left table. They are joined to an
      empty row of the left table to fit them into the result.</dd>
  <dt>[3]</dt>
  <dd>The full outer join combines both left and right outer join. In other
      words, the additional rows are as defined for left outer join, and right
      outer join, combined.</dd>
</dl>
<p class="Pp">We extend all the joins from two to <b>n</b> tables (<b>n</b> &gt;
    2) by executing</p>
<pre>
    (...((table1 join table2) join table3) ...) join tableN
</pre>
<p class="Pp">Examples for all the joins:</p>
<pre>
    Inner Join
    {0 foo}              {0 bagel}    {0 foo   0 bagel}
    {1 snarf} inner join {1 snatz}  = {1 snarf 1 snatz}
    {2 blue}             {3 driver}
    Left Outer Join
    {0 foo}                   {0 bagel}    {0 foo   0 bagel}
    {1 snarf} left outer join {1 snatz}  = {1 snarf 1 snatz}
    {2 blue}                  {3 driver}   {2 blue  {} {}}
    Right Outer Join
    {0 foo}                    {0 bagel}    {0 foo   0 bagel}
    {1 snarf} right outer join {1 snatz}  = {1 snarf 1 snatz}
    {2 blue}                   {3 driver}   {{} {}   3 driver}
    Full Outer Join
    {0 foo}                   {0 bagel}    {0 foo   0 bagel}
    {1 snarf} full outer join {1 snatz}  = {1 snarf 1 snatz}
    {2 blue}                  {3 driver}   {2 blue  {} {}}
                                           {{} {}   3 driver}
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="REFERENCES"><a class="permalink" href="#REFERENCES">REFERENCES</a></h1>
<dl class="Bl-tag">
  <dt>[1]</dt>
  <dd>J. W. Hunt and M. D. McIlroy, &quot;An algorithm for differential file
      comparison,&quot; Comp. Sci. Tech. Rep. #41, Bell Telephone Laboratories
      (1976). Available on the Web at the second author's personal site:
      <i>http://www.cs.dartmouth.edu/~doug/</i></dd>
  <dt>[2]</dt>
  <dd>Donald E. Knuth, &quot;Fascicle 2b of 'The Art of Computer Programming'
      volume 4&quot;. Available on the Web at the author's personal site:
      <i>http://www-cs-faculty.stanford.edu/~knuth/fasc2b.ps.gz</i>.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS,_IDEAS,_FEEDBACK"><a class="permalink" href="#BUGS,_IDEAS,_FEEDBACK">BUGS,
  IDEAS, FEEDBACK</a></h1>
<p class="Pp">This document, and the package it describes, will undoubtedly
    contain bugs and other problems. Please report such in the category
    <i>struct :: list</i> of the <i>Tcllib SF Trackers</i>
    [http://sourceforge.net/tracker/?group_id=12883]. Please also report any
    ideas for enhancements you may have for either package and/or
  documentation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
<p class="Pp">assign, common, comparison, diff, differential, equal, equality,
    filter, first permutation, flatten, folding, full outer join, generate
    permutations, inner join, join, left outer join, list, longest common
    subsequence, map, next permutation, outer join, permutation, reduce,
    repeating, repetition, reverse, right outer join, subsequence, swapping</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CATEGORY"><a class="permalink" href="#CATEGORY">CATEGORY</a></h1>
<p class="Pp">Data structures</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<pre>Copyright (c) 2003-2005 by Kevin B. Kenny. All rights reserved
Copyright (c) 2003-2008 Andreas Kupries &lt;andreas_kupries@users.sourceforge.net&gt;
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">1.7</td>
    <td class="foot-os">struct</td>
  </tr>
</table>
</body>
</html>

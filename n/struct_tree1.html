<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Copyright (c) 2002 Andreas Kupries <andreas_kupries@users.sourceforge.net>
  
   The definitions below are for supplemental macros used in Tcl/Tk
   manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO
  	Start of list of standard options for a Tk widget.  The
  	options follow on successive lines, in four columns separated
  	by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   RCS: @(#) $Id: man.macros,v 1.1 2009/01/30 04:56:47 andreas_kupries Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>struct::tree v1(n)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">struct::tree v1(n)</td>
    <td class="head-vol"><a href=".">Tcl Data Structures</a></td>
    <td class="head-rtitle">struct::tree v1(n)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>
</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">struct::tree v1 - Create and manipulate tree objects</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">package require <b>Tcl 8.2</b></p>
<p class="Pp">package require <b>struct::tree ?1.2.2?</b></p>
<p class="Pp"><b>treeName</b> <b>option</b> ?<i>arg arg ...</i>?</p>
<p class="Pp"><i>treeName</i> <b>append</b> <i>node</i> ?-key <i>key</i>?
    <i>value</i></p>
<p class="Pp"><i>treeName</i> <b>children</b> <i>node</i></p>
<p class="Pp"><i>treeName</i> <b>cut</b> <i>node</i></p>
<p class="Pp"><i>treeName</i> <b>delete</b> <i>node</i> ?<i>node</i> ...?</p>
<p class="Pp"><i>treeName</i> <b>depth</b> <i>node</i></p>
<p class="Pp"><i>treeName</i> <b>destroy</b></p>
<p class="Pp"><i>treeName</i> <b>exists</b> <i>node</i></p>
<p class="Pp"><i>treeName</i> <b>get</b> <i>node</i> ?<b>-key</b>
  <i>key</i>?</p>
<p class="Pp"><i>treeName</i> <b>getall</b> <i>node</i></p>
<p class="Pp"><i>treeName</i> <b>keys</b> <i>node</i></p>
<p class="Pp"><i>treeName</i> <b>keyexists</b> <i>node</i> ?-key <i>key</i>?</p>
<p class="Pp"><i>treeName</i> <b>index</b> <i>node</i></p>
<p class="Pp"><i>treeName</i> <b>insert</b> <i>parent</i> <i>index</i>
    ?<i>child</i> ?<i>child</i> ...??</p>
<p class="Pp"><i>treeName</i> <b>isleaf</b> <i>node</i></p>
<p class="Pp"><i>treeName</i> <b>lappend</b> <i>node</i> ?-key <i>key</i>?
    <i>value</i></p>
<p class="Pp"><i>treeName</i> <b>move</b> <i>parent</i> <i>index</i> <i>node</i>
    ?<i>node</i> ...?</p>
<p class="Pp"><i>treeName</i> <b>next</b> <i>node</i></p>
<p class="Pp"><i>treeName</i> <b>numchildren</b> <i>node</i></p>
<p class="Pp"><i>treeName</i> <b>parent</b> <i>node</i></p>
<p class="Pp"><i>treeName</i> <b>previous</b> <i>node</i></p>
<p class="Pp"><i>treeName</i> <b>set</b> <i>node</i> ?<b>-key</b> <i>key</i>?
    ?<i>value</i>?</p>
<p class="Pp"><i>treeName</i> <b>size</b> ?<i>node</i>?</p>
<p class="Pp"><i>treeName</i> <b>splice</b> <i>parent</i> <i>from</i>
    ?<i>to</i>? ?<i>child</i>?</p>
<p class="Pp"><i>treeName</i> <b>swap</b> <i>node1</i> <i>node2</i></p>
<p class="Pp"><i>treeName</i> <b>unset</b> <i>node</i> ?<b>-key</b>
  <i>key</i>?</p>
<p class="Pp"><i>treeName</i> <b>walk</b> <i>node</i> ?<b>-order</b>
    <i>order</i>? ?<b>-type</b> <i>type</i>? <b>-command</b> <i>cmd</i></p>
<p class="Pp"></p>
<pre>
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The <b>::struct::tree</b> command creates a new tree object with
    an associated global Tcl command whose name is <i>treeName</i>. This command
    may be used to invoke various operations on the tree. It has the following
    general form:</p>
<dl class="Bl-tag">
  <dt id="treeName"><a class="permalink" href="#treeName"><b>treeName</b>
    <b>option</b> ?<i>arg arg ...</i>?</a></dt>
  <dd><i>Option</i> and the <i>arg</i>s determine the exact behavior of the
      command.</dd>
</dl>
<p class="Pp">A tree is a collection of named elements, called nodes, one of
    which is distinguished as a root, along with a relation
    (&quot;parenthood&quot;) that places a hierarchical structure on the nodes.
    (Data Structures and Algorithms; Aho, Hopcroft and Ullman; Addison-Wesley,
    1987). In addition to maintaining the node relationships, this tree
    implementation allows any number of keyed values to be associated with each
    node.</p>
<p class="Pp">The element names can be arbitrary strings.</p>
<p class="Pp">A tree is thus similar to an array, but with three important
    differences:</p>
<dl class="Bl-tag">
  <dt>[1]</dt>
  <dd>Trees are accessed through an object command, whereas arrays are accessed
      as variables. (This means trees cannot be local to a procedure.)</dd>
  <dt>[2]</dt>
  <dd>Trees have a hierarchical structure, whereas an array is just an unordered
      collection.</dd>
  <dt>[3]</dt>
  <dd>Each node of a tree has a separate collection of attributes and values.
      This is like an array where every value is a dictionary.</dd>
</dl>
<p class="Pp">The following commands are possible for tree objects:</p>
<dl class="Bl-tag">
  <dt id="treeName~2"><a class="permalink" href="#treeName~2"><i>treeName</i>
    <b>append</b> <i>node</i> ?-key <i>key</i>? <i>value</i></a></dt>
  <dd>Appends a <i>value</i> to one of the keyed values associated with an node.
      If no <i>key</i> is specified, the key <b>data</b> is assumed.</dd>
  <dt id="treeName~3"><a class="permalink" href="#treeName~3"><i>treeName</i>
    <b>children</b> <i>node</i></a></dt>
  <dd>Return a list of the children of <i>node</i>.</dd>
  <dt id="treeName~4"><a class="permalink" href="#treeName~4"><i>treeName</i>
    <b>cut</b> <i>node</i></a></dt>
  <dd>Removes the node specified by <i>node</i> from the tree, but not its
      children. The children of <i>node</i> are made children of the parent of
      the <i>node</i>, at the index at which <i>node</i> was located.</dd>
  <dt id="treeName~5"><a class="permalink" href="#treeName~5"><i>treeName</i>
    <b>delete</b> <i>node</i> ?<i>node</i> ...?</a></dt>
  <dd>Remove the specified nodes from the tree. All of the nodes' children will
      be removed as well to prevent orphaned nodes.</dd>
  <dt id="treeName~6"><a class="permalink" href="#treeName~6"><i>treeName</i>
    <b>depth</b> <i>node</i></a></dt>
  <dd>Return the number of steps from node <i>node</i> to the root node.</dd>
  <dt id="treeName~7"><a class="permalink" href="#treeName~7"><i>treeName</i>
    <b>destroy</b></a></dt>
  <dd>Destroy the tree, including its storage space and associated command.</dd>
  <dt id="treeName~8"><a class="permalink" href="#treeName~8"><i>treeName</i>
    <b>exists</b> <i>node</i></a></dt>
  <dd>Remove true if the specified node exists in the tree.</dd>
  <dt id="treeName~9"><a class="permalink" href="#treeName~9"><i>treeName</i>
    <b>get</b> <i>node</i> ?<b>-key</b> <i>key</i>?</a></dt>
  <dd>Return the value associated with the key <i>key</i> for the node
      <i>node</i>. If no key is specified, the key <b>data</b> is assumed.</dd>
  <dt id="treeName~10"><a class="permalink" href="#treeName~10"><i>treeName</i>
    <b>getall</b> <i>node</i></a></dt>
  <dd>Returns a serialized list of key/value pairs (suitable for use with
      [<b>array set</b>]) for the <i>node</i>.</dd>
  <dt id="treeName~11"><a class="permalink" href="#treeName~11"><i>treeName</i>
    <b>keys</b> <i>node</i></a></dt>
  <dd>Returns a list of keys for the <i>node</i>.</dd>
  <dt id="treeName~12"><a class="permalink" href="#treeName~12"><i>treeName</i>
    <b>keyexists</b> <i>node</i> ?-key <i>key</i>?</a></dt>
  <dd>Return true if the specified <i>key</i> exists for the <i>node</i>. If no
      <i>key</i> is specified, the key <b>data</b> is assumed.</dd>
  <dt id="treeName~13"><a class="permalink" href="#treeName~13"><i>treeName</i>
    <b>index</b> <i>node</i></a></dt>
  <dd>Returns the index of <i>node</i> in its parent's list of children. For
      example, if a node has <i>nodeFoo</i>, <i>nodeBar</i>, and <i>nodeBaz</i>
      as children, in that order, the index of <i>nodeBar</i> is 1.</dd>
  <dt id="treeName~14"><a class="permalink" href="#treeName~14"><i>treeName</i>
    <b>insert</b> <i>parent</i> <i>index</i> ?<i>child</i> ?<i>child</i>
    ...??</a></dt>
  <dd>Insert one or more nodes into the tree as children of the node
      <i>parent</i>. The nodes will be added in the order they are given. If
      <i>parent</i> is <b>root</b>, it refers to the root of the tree. The new
      nodes will be added to the <i>parent</i> node's child list at the index
      given by <i>index</i>. The <i>index</i> can be <b>end</b> in which case
      the new nodes will be added after the current last child.
    <p class="Pp">If any of the specified children already exist in
        <i>treeName</i>, those nodes will be moved from their original location
        to the new location indicated by this command.</p>
    <p class="Pp">If no <i>child</i> is specified, a single node will be added,
        and a name will be generated for the new node. The generated name is of
        the form <i>node</i><b>x</b>, where <b>x</b> is a number. If names are
        specified they must neither contain whitespace nor colons
        (&quot;:&quot;).</p>
    <p class="Pp">The return result from this command is a list of nodes
      added.</p>
  </dd>
  <dt id="treeName~15"><a class="permalink" href="#treeName~15"><i>treeName</i>
    <b>isleaf</b> <i>node</i></a></dt>
  <dd>Returns true if <i>node</i> is a leaf of the tree (if <i>node</i> has no
      children), false otherwise.</dd>
  <dt id="treeName~16"><a class="permalink" href="#treeName~16"><i>treeName</i>
    <b>lappend</b> <i>node</i> ?-key <i>key</i>? <i>value</i></a></dt>
  <dd>Appends a <i>value</i> (as a list) to one of the keyed values associated
      with an <i>node</i>. If no <i>key</i> is specified, the key <b>data</b> is
      assumed.</dd>
  <dt id="treeName~17"><a class="permalink" href="#treeName~17"><i>treeName</i>
    <b>move</b> <i>parent</i> <i>index</i> <i>node</i> ?<i>node</i>
    ...?</a></dt>
  <dd>Make the specified nodes children of <i>parent</i>, inserting them into
      the parent's child list at the index given by <i>index</i>. Note that the
      command will take all nodes out of the tree before inserting them under
      the new parent, and that it determines the position to place them into
      after the removal, before the re-insertion. This behaviour is important
      when it comes to moving one or more nodes to a different index without
      changing their parent node.</dd>
  <dt id="treeName~18"><a class="permalink" href="#treeName~18"><i>treeName</i>
    <b>next</b> <i>node</i></a></dt>
  <dd>Return the right sibling of <i>node</i>, or the empty string if
      <i>node</i> was the last child of its parent.</dd>
  <dt id="treeName~19"><a class="permalink" href="#treeName~19"><i>treeName</i>
    <b>numchildren</b> <i>node</i></a></dt>
  <dd>Return the number of immediate children of <i>node</i>.</dd>
  <dt id="treeName~20"><a class="permalink" href="#treeName~20"><i>treeName</i>
    <b>parent</b> <i>node</i></a></dt>
  <dd>Return the parent of <i>node</i>.</dd>
  <dt id="treeName~21"><a class="permalink" href="#treeName~21"><i>treeName</i>
    <b>previous</b> <i>node</i></a></dt>
  <dd>Return the left sibling of <i>node</i>, or the empty string if <i>node</i>
      was the first child of its parent.</dd>
  <dt id="treeName~22"><a class="permalink" href="#treeName~22"><i>treeName</i>
    <b>set</b> <i>node</i> ?<b>-key</b> <i>key</i>? ?<i>value</i>?</a></dt>
  <dd>Set or get one of the keyed values associated with a node. If no key is
      specified, the key <b>data</b> is assumed. Each node that is added to a
      tree has the value &quot;&quot; assigned to the key <b>data</b>
      automatically. A node may have any number of keyed values associated with
      it. If <i>value</i> is not specified, this command returns the current
      value assigned to the key; if <i>value</i> is specified, this command
      assigns that value to the key.</dd>
  <dt id="treeName~23"><a class="permalink" href="#treeName~23"><i>treeName</i>
    <b>size</b> ?<i>node</i>?</a></dt>
  <dd>Return a count of the number of descendants of the node <i>node</i>; if no
      node is specified, <b>root</b> is assumed.</dd>
  <dt id="treeName~24"><a class="permalink" href="#treeName~24"><i>treeName</i>
    <b>splice</b> <i>parent</i> <i>from</i> ?<i>to</i>? ?<i>child</i>?</a></dt>
  <dd>Insert a node named <i>child</i> into the tree as a child of the node
      <i>parent</i>. If <i>parent</i> is <b>root</b>, it refers to the root of
      the tree. The new node will be added to the parent node's child list at
      the index given by <i>from</i>. The children of <i>parent</i> which are in
      the range of the indices <i>from</i> and <i>to</i> are made children of
      <i>child</i>. If the value of <i>to</i> is not specified it defaults to
      <b>end</b>. If no name is given for <i>child</i>, a name will be generated
      for the new node. The generated name is of the form <i>node</i><b>x</b>,
      where <b>x</b> is a number. The return result from this command is the
      name of the new node.</dd>
  <dt id="treeName~25"><a class="permalink" href="#treeName~25"><i>treeName</i>
    <b>swap</b> <i>node1</i> <i>node2</i></a></dt>
  <dd>Swap the position of <i>node1</i> and <i>node2</i> in the tree.</dd>
  <dt id="treeName~26"><a class="permalink" href="#treeName~26"><i>treeName</i>
    <b>unset</b> <i>node</i> ?<b>-key</b> <i>key</i>?</a></dt>
  <dd>Remove a keyed value from the node <i>node</i>. If no key is specified,
      the key <b>data</b> is assumed.</dd>
  <dt id="treeName~27"><a class="permalink" href="#treeName~27"><i>treeName</i>
    <b>walk</b> <i>node</i> ?<b>-order</b> <i>order</i>? ?<b>-type</b>
    <i>type</i>? <b>-command</b> <i>cmd</i></a></dt>
  <dd>Perform a breadth-first or depth-first walk of the tree starting at the
      node <i>node</i>. The type of walk, breadth-first or depth-first, is
      determined by the value of <i>type</i>; <b>bfs</b> indicates
      breadth-first, <b>dfs</b> indicates depth-first. Depth-first is the
      default. The order of the walk, pre-, post-, both- or in-order is
      determined by the value of <i>order</i>; <b>pre</b> indicates pre-order,
      <b>post</b> indicates post-order, <b>both</b> indicates both-order and
      <b>in</b> indicates in-order. Pre-order is the default.
    <p class="Pp">Pre-order walking means that a parent node is visited before
        any of its children. For example, a breadth-first search starting from
        the root will visit the root, followed by all of the root's children,
        followed by all of the root's grandchildren. Post-order walking means
        that a parent node is visited after any of its children. Both-order
        walking means that a parent node is visited before <i>and</i> after any
        of its children. In-order walking means that a parent node is visited
        after its first child and before the second. This is a generalization of
        in-order walking for binary trees and will do the right thing if a
        binary is walked. The combination of a breadth-first walk with in-order
        is illegal.</p>
    <p class="Pp">As the walk progresses, the command <i>cmd</i> will be
        evaluated at each node. Percent substitution will be performed on
        <i>cmd</i> before evaluation, just as in a <b>bind</b> script. The
        following substitutions are recognized:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>%%</b></dt>
  <dd>Insert the literal % character.</dd>
  <dt><b>%t</b></dt>
  <dd>Name of the tree object.</dd>
  <dt><b>%n</b></dt>
  <dd>Name of the current node.</dd>
  <dt><b>%a</b></dt>
  <dd>Name of the action occurring; one of <b>enter</b>, <b>leave</b>, or
      <b>visit</b>. <b>enter</b> actions occur during pre-order walks;
      <b>leave</b> actions occur during post-order walks; <b>visit</b> actions
      occur during in-order walks. In a both-order walk, the command will be
      evaluated twice for each node; the action is <b>enter</b> for the first
      evaluation, and <b>leave</b> for the second.</dd>
</dl>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS,_IDEAS,_FEEDBACK"><a class="permalink" href="#BUGS,_IDEAS,_FEEDBACK">BUGS,
  IDEAS, FEEDBACK</a></h1>
<p class="Pp">This document, and the package it describes, will undoubtedly
    contain bugs and other problems. Please report such in the category
    <i>struct :: tree</i> of the <i>Tcllib SF Trackers</i>
    [http://sourceforge.net/tracker/?group_id=12883]. Please also report any
    ideas for enhancements you may have for either package and/or
  documentation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
<p class="Pp">tree</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CATEGORY"><a class="permalink" href="#CATEGORY">CATEGORY</a></h1>
<p class="Pp">Data structures</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<pre>Copyright (c) 2002 Andreas Kupries &lt;andreas_kupries@users.sourceforge.net&gt;
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">1.2.2</td>
    <td class="foot-os"><a href="..">struct</a></td>
  </tr>
</table>
</body>
</html>

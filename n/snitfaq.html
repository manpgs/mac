<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Generated from file '/AppleInternal/Library/BuildRoots/aaefcfd1-5c95-11ed-8734-2e32217d8374/Library/Caches/com.apple.xbs/Sources/tcl/tcl_ext/tcllib/tcllib/modules/snit/snitfaq.man' by tcllib/doctools with format 'nroff'
   Copyright (c) 2003-2006, by William H. Duquette
  
   The definitions below are for supplemental macros used in Tcl/Tk
   manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO
  	Start of list of standard options for a Tk widget.  The
  	options follow on successive lines, in four columns separated
  	by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   RCS: @(#) $Id: man.macros,v 1.1 2009/01/30 04:56:47 andreas_kupries Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>snitfaq(n)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">snitfaq(n)</td>
    <td class="head-vol">Snit's Not Incr Tcl, OO system</td>
    <td class="head-rtitle">snitfaq(n)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>
</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">snitfaq - Snit Frequently Asked Questions</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
</section>
<section class="Sh">
<h1 class="Sh" id="OVERVIEW"><a class="permalink" href="#OVERVIEW">OVERVIEW</a></h1>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_THIS_DOCUMENT?"><a class="permalink" href="#WHAT_IS_THIS_DOCUMENT?">WHAT
  IS THIS DOCUMENT?</a></h2>
<p class="Pp">This is an atypical FAQ list, in that few of the questions are
    frequently asked. Rather, these are the questions I think a newcomer to Snit
    should be asking. This file is not a complete reference to Snit, however;
    that information is in the <b>snit</b> man page.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_SNIT?"><a class="permalink" href="#WHAT_IS_SNIT?">WHAT
  IS SNIT?</a></h2>
<p class="Pp">Snit is a framework for defining abstract data types and
    megawidgets in pure Tcl. The name &quot;Snit&quot; stands for &quot;Snit's
    Not Incr Tcl&quot;, signifying that Snit takes a different approach to
    defining objects than does Incr Tcl, the best known object framework for
    Tcl. Had I realized that Snit would become at all popular, I'd probably have
    chosen something else.</p>
<p class="Pp">The primary purpose of Snit is to be <i>object glue</i>--to help
    you compose diverse objects from diverse sources into types and megawidgets
    with clean, convenient interfaces so that you can more easily build your
    application.</p>
<p class="Pp">Snit isn't about theoretical purity or minimalist design; it's
    about being able to do powerful things easily and consistently without
    having to think about them--so that you can concentrate on building your
    application.</p>
<p class="Pp">Snit isn't about implementing thousands of nearly identical
    carefully-specified lightweight thingamajigs--not as individual Snit
    objects. Traditional Tcl methods will be much faster, and not much more
    complicated. But Snit <i>is</i> about implementing a clean interface to
    manage a collection of thousands of nearly identical carefully-specified
    lightweight thingamajigs (e.g., think of the text widget and text tags, or
    the canvas widget and canvas objects). Snit lets you hide the details of
    just how those thingamajigs are stored--so that you can ignore it, and
    concentrate on building your application.</p>
<p class="Pp">Snit isn't a way of life, a silver bullet, or the Fountain of
    Youth. It's just a way of managing complexity--and of managing some of the
    complexity of managing complexity--so that you can concentrate on building
    your application.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="WHAT_VERSION_OF_TCL_DOES_SNIT_REQUIRE?"><a class="permalink" href="#WHAT_VERSION_OF_TCL_DOES_SNIT_REQUIRE?">WHAT
  VERSION OF TCL DOES SNIT REQUIRE?</a></h2>
<p class="Pp">Snit 1.3 requires Tcl 8.3 or later; Snit 2.2 requires Tcl 8.5 or
    later. See <b>SNIT VERSIONS</b> for the differences between Snit 1.3 and
    Snit 2.2.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="WHERE_CAN_I_DOWNLOAD_SNIT?"><a class="permalink" href="#WHERE_CAN_I_DOWNLOAD_SNIT?">WHERE
  CAN I DOWNLOAD SNIT?</a></h2>
<p class="Pp">Snit is part of Tcllib, the standard Tcl library, so you might
    already have it. It's also available at the Snit Home Page,
    <i>http://www.wjduquette.com/snit</i>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="WHAT_ARE_SNIT'S_GOALS?"><a class="permalink" href="#WHAT_ARE_SNIT'S_GOALS?">WHAT
  ARE SNIT'S GOALS?</a></h2>
<ul class="Bl-bullet">
  <li>A Snit object should be at least as efficient as a hand-coded Tcl object
      (see <i>http://www.wjduquette.com/tcl/objects.html</i>).</li>
  <li>The fact that Snit was used in an object's implementation should be
      transparent (and irrelevant) to clients of that object.</li>
  <li>Snit should be able to encapsulate objects from other sources,
      particularly Tk widgets.</li>
  <li>Snit megawidgets should be (to the extent possible) indistinguishable in
      interface from Tk widgets.</li>
  <li>Snit should be Tclish--that is, rather than trying to emulate C++,
      Smalltalk, or anything else, it should try to emulate Tcl itself.</li>
  <li>It should have a simple, easy-to-use, easy-to-remember syntax.</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_IS_SNIT_DIFFERENT_FROM_OTHER_OO_FRAMEWORKS?"><a class="permalink" href="#HOW_IS_SNIT_DIFFERENT_FROM_OTHER_OO_FRAMEWORKS?">HOW
  IS SNIT DIFFERENT FROM OTHER OO FRAMEWORKS?</a></h2>
<p class="Pp">Snit is unique among Tcl object systems in that it is based not on
    inheritance but on delegation. Object systems based on inheritance only
    allow you to inherit from classes defined using the same system, and that's
    a shame. In Tcl, an object is anything that acts like an object; it
    shouldn't matter how the object was implemented. I designed Snit to help me
    build applications out of the materials at hand; thus, Snit is designed to
    be able to incorporate and build on any object, whether it's a hand-coded
    object, a Tk widget, an Incr Tcl object, a BWidget or almost anything
  else.</p>
<p class="Pp">Note that you can achieve the effect of inheritance using
    <b>COMPONENTS</b> and <b>DELEGATION</b>--and you can inherit from anything
    that looks like a Tcl object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="WHAT_CAN_I_DO_WITH_SNIT?"><a class="permalink" href="#WHAT_CAN_I_DO_WITH_SNIT?">WHAT
  CAN I DO WITH SNIT?</a></h2>
<p class="Pp">Using Snit, a programmer can:</p>
<ul class="Bl-bullet">
  <li>Create abstract data types and Tk megawidgets.</li>
  <li>Define instance variables, type variables, and Tk-style options.</li>
  <li>Define constructors, destructors, instance methods, type methods,
    procs.</li>
  <li>Assemble a type out of component types. Instance methods and options can
      be delegated to the component types automatically.</li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SNIT_VERSIONS"><a class="permalink" href="#SNIT_VERSIONS">SNIT
  VERSIONS</a></h1>
<section class="Ss">
<h2 class="Ss" id="WHICH_VERSION_OF_SNIT_SHOULD_I_USE?"><a class="permalink" href="#WHICH_VERSION_OF_SNIT_SHOULD_I_USE?">WHICH
  VERSION OF SNIT SHOULD I USE?</a></h2>
<p class="Pp">The current Snit distribution includes two versions, Snit 1.3 and
    Snit 2.2. The reason that both are included is that Snit 2.2 takes advantage
    of a number of new features of Tcl 8.5 to improve run-time efficiency; as a
    side-effect, the ugliness of Snit's error messages and stack traces has been
    reduced considerably. The cost of using Snit 2.2, of course, is that you
    must target Tcl 8.5.</p>
<p class="Pp">Snit 1.3, on the other hand, lacks Snit 2.2's optimizations, but
    requires only Tcl 8.3 and later.</p>
<p class="Pp">In short, if you're targetting Tcl 8.3 or 8.4 you should use Snit
    1.3. If you can afford to target Tcl 8.5, you should definitely use Snit
    2.2. If you will be targetting both, you can use Snit 1.3 exclusively, or
    (if your code is unaffected by the minor incompatibilities between the two
    versions) you can use Snit 1.3 for Tcl 8.4 and Snit 2.2 for Tcl 8.5.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_I_SELECT_THE_VERSION_OF_SNIT_I_WANT_TO_USE?"><a class="permalink" href="#HOW_DO_I_SELECT_THE_VERSION_OF_SNIT_I_WANT_TO_USE?">HOW
  DO I SELECT THE VERSION OF SNIT I WANT TO USE?</a></h2>
<p class="Pp">To always use Snit 1.3 (or a later version of Snit 1.x), invoke
    Snit as follows:</p>
<pre>package require snit 1.3
</pre>
<p class="Pp">To always use Snit 2.2 (or a later version of Snit 2.x), say this
    instead:</p>
<pre>package require snit 2.2
</pre>
<p class="Pp">Note that if you request Snit 2.2 explicitly, your application
    will halt with Tcl 8.4, since Snit 2.2 is unavailable for Tcl 8.4.</p>
<p class="Pp">If you wish your application to always use the latest available
    version of Snit, don't specify a version number:</p>
<pre>package require snit
</pre>
Tcl will find and load the latest version that's available relative to the
  version of Tcl being used. In this case, be careful to avoid using any
  incompatible features.
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_ARE_SNIT_1.3_AND_SNIT_2.2_INCOMPATIBLE?"><a class="permalink" href="#HOW_ARE_SNIT_1.3_AND_SNIT_2.2_INCOMPATIBLE?">HOW
  ARE SNIT 1.3 AND SNIT 2.2 INCOMPATIBLE?</a></h2>
<p class="Pp">To the extent possible, Snit 2.2 is intended to be a drop-in
    replacement for Snit 1.3. Unfortunately, some incompatibilities were
    inevitable because Snit 2.2 uses Tcl 8.5's new <b>namespace ensemble</b>
    mechanism to implement subcommand dispatch. This approach is much faster
    than the mechanism used in Snit 1.3, and also results in much better error
    messages; however, it also places new constraints on the implementation.</p>
<p class="Pp">There are four specific incompatibilities between Snit 1.3 and
    Snit 2.2.</p>
<ul class="Bl-bullet">
  <li>Snit 1.3 supports implicit naming of objects. Suppose you define a new
      <b>snit::type</b> called <b>dog</b>. You can create instances of
      <b>dog</b> in three ways:
    <pre>dog spot               ;# Explicit naming
set obj1 [dog %AUTO%]  ;# Automatic naming
set obj2 [dog]         ;# Implicit naming
    </pre>
    In Snit 2.2, type commands are defined using the <b>namespace ensemble</b>
      mechanism; and <b>namespace ensemble</b> doesn't allow an ensemble command
      to be called without a subcommand. In short, using <b>namespace
      ensemble</b> there's no way to support implicit naming.
    <p class="Pp">All is not lost, however. If the type has no type methods,
        then the type command is a simple command rather than an ensemble, and
        <b>namespace ensemble</b> is not used. In this case, implicit naming is
        still possible.</p>
    <p class="Pp">In short, you can have implicit naming if you're willing to do
        without type methods (including the standard type methods, like <b>$type
        info</b>). To do so, use the <b>-hastypemethods</b> pragma:</p>
    <pre>pragma -hastypemethods 0</pre>
  </li>
  <li>Hierarchical methods and type methods are implemented differently in Snit
      2.2.
    <p class="Pp">A hierarchical method is an instance method which has
        subcommands; these subcommands are themselves methods. The Tk text
        widget's <b>tag</b> command and its subcommands are examples of
        hierarchical methods. You can implement such subcommands in Snit simply
        by including multiple words in the method names:</p>
    <pre>method {tag configure} {tag args} { ... }
method {tag cget} {tag option} {...}
    </pre>
    Here we've implicitly defined a <b>tag</b> method which has two subcommands,
      <b>configure</b> and <b>cget</b>.
    <p class="Pp">In Snit 1.3, hierarchical methods could be called in two
      ways:</p>
    <pre>$obj tag cget -myoption      ;# The good way
$obj {tag cget} -myoption    ;# The weird way
    </pre>
    In the second call, we see that a hierarchical method or type method is
      simply one whose name contains multiple words.
    <p class="Pp">In Snit 2.2 this is no longer the case, and the
        &quot;weird&quot; way of calling hierarchical methods and type methods
        no longer works.</p>
  </li>
  <li>The third incompatibility derives from the second. In Snit 1.3,
      hierarchical methods were also simply methods whose name contains multiple
      words. As a result, <b>$obj info methods</b> returned the full names of
      all hierarchical methods. In the example above, the list returned by
      <b>$obj info methods</b> would include <b>tag configure</b> and <b>tag
      cget</b> but not <b>tag</b>, since <b>tag</b> is defined only implicitly.
    <p class="Pp">In Snit 2.2, hierarchical methods and type methods are no
        longer simply ones whose name contains multiple words; in the above
        example, the list returned by <b>$obj info methods</b> would include
        <b>tag</b> but not <b>tag configure</b> or <b>tag cget</b>.</p>
  </li>
  <li>The fourth incompatibility is due to a new feature. Snit 2.2 uses the new
      <b>namespace path</b> command so that a type's code can call any command
      defined in the type's parent namespace without qualification or
      importation. For example, suppose you have a package called
      <b>mypackage</b> which defines a number of commands including a type,
      <b>::mypackage::mytype</b>. Thanks to <b>namespace path</b>, the type's
      code can call any of the other commands defined in <b>::mypackage::</b>.
    <p class="Pp">This is extremely convenient. However, it also means that
        commands defined in the parent namespace, <b>::mypackage::</b> can block
        the type's access to identically named commands in the global namespace.
        This can lead to bugs. For example, Tcllib includes a type called
        <b>::tie::std::file</b>. This type's code calls the standard <b>file</b>
        command. When run with Snit 2.2, the code broke-- the type's command,
        <b>::tie::std::file</b>, is itself a command in the type's parent
        namespace, and so instead of calling the standard <b>file</b> command,
        the type found itself calling itself.</p>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="ARE_THERE_OTHER_DIFFERENCES_BETWEEN_SNIT_1.X_AND_SNIT_2.2?"><a class="permalink" href="#ARE_THERE_OTHER_DIFFERENCES_BETWEEN_SNIT_1.X_AND_SNIT_2.2?">ARE
  THERE OTHER DIFFERENCES BETWEEN SNIT 1.X AND SNIT 2.2?</a></h2>
<p class="Pp">Yes.</p>
<ul class="Bl-bullet">
  <li>Method dispatch is considerably faster.</li>
  <li>Many error messages and stack traces are cleaner.</li>
  <li>The <b>-simpledispatch</b> pragma is obsolete, and ignored if present. In
      Snit 1.x, <b>-simpledispatch</b> substitutes a faster mechanism for method
      dispatch, at the cost of losing certain features. Snit 2.2 method dispatch
      is faster still in all cases, so <b>-simpledispatch</b> is no longer
      needed.</li>
  <li>In Snit 2.2, a type's code (methods, type methods, etc.) can call commands
      from the type's parent namespace without qualifying or importing them,
      i.e., type <b>::parentns::mytype</b>'s code can call
      <b>::parentns::someproc</b> as just <b>someproc</b>.
    <p class="Pp">This is extremely useful when a type is defined as part of a
        larger package, and shares a parent namespace with the rest of the
        package; it means that the type can call other commands defined by the
        package without any extra work.</p>
    <p class="Pp">This feature depends on the new Tcl 8.5 <b>namespace path</b>
        command, which is why it hasn't been implemented for V1.x. V1.x code can
        achieve something similar by placing</p>
    <pre>namespace import [namespace parent]::*</pre>
    in a type constructor. This is less useful, however, as it picks up only
      those commands which have already been exported by the parent namespace at
      the time the type is defined.</li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="OBJECTS"><a class="permalink" href="#OBJECTS">OBJECTS</a></h1>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_AN_OBJECT?"><a class="permalink" href="#WHAT_IS_AN_OBJECT?">WHAT
  IS AN OBJECT?</a></h2>
<p class="Pp">A full description of object-oriented programming is beyond the
    scope of this FAQ, obviously. In simple terms, an object is an instance of
    an abstract data type--a coherent bundle of code and data. There are many
    ways to represent objects in Tcl/Tk; the best known examples are the Tk
    widgets.</p>
<p class="Pp">A Tk widget is an object; it is represented by a Tcl command. The
    object's methods are subcommands of the Tcl command. The object's properties
    are options accessed using the <b>configure</b> and <b>cget</b> methods.
    Snit uses the same conventions as Tk widgets do.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_AN_ABSTRACT_DATA_TYPE?"><a class="permalink" href="#WHAT_IS_AN_ABSTRACT_DATA_TYPE?">WHAT
  IS AN ABSTRACT DATA TYPE?</a></h2>
<p class="Pp">In computer science terms, an abstract data type is a complex data
    structure along with a set of operations--a stack, a queue, a binary tree,
    etc--that is to say, in modern terms, an object. In systems that include
    some form of inheritance the word <i>class</i> is usually used instead of
    <i>abstract data type</i>, but as Snit doesn't implement inheritance as it's
    ordinarily understood the older term seems more appropriate. Sometimes this
    is called <i>object-based</i> programming as opposed to object-oriented
    programming. Note that you can easily create the effect of inheritance using
    <b>COMPONENTS</b> and <b>DELEGATION</b>.</p>
<p class="Pp">In Snit, as in Tk, a <i>type</i> is a command that creates
    instances -- objects -- which belong to the type. Most types define some
    number of <i>options</i> which can be set at creation time, and usually can
    be changed later.</p>
<p class="Pp">Further, an <i>instance</i> is also a Tcl command--a command that
    gives access to the operations which are defined for that abstract data
    type. Conventionally, the operations are defined as subcommands of the
    instance command. For example, to insert text into a Tk text widget, you use
    the text widget's <b>insert</b> subcommand:</p>
<p class="Pp"></p>
<pre>
    # Create a text widget and insert some text in it.
    text .mytext -width 80 -height 24
    .mytext insert end &quot;Howdy!&quot;
</pre>
<p class="Pp">In this example, <b>text</b> is the <i>type</i> command and
    <b>.mytext</b> is the <i>instance</i> command.</p>
<p class="Pp">In Snit, object subcommands are generally called <b>INSTANCE
    METHODS</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="WHAT_KINDS_OF_ABSTRACT_DATA_TYPES_DOES_SNIT_PROVIDE?"><a class="permalink" href="#WHAT_KINDS_OF_ABSTRACT_DATA_TYPES_DOES_SNIT_PROVIDE?">WHAT
  KINDS OF ABSTRACT DATA TYPES DOES SNIT PROVIDE?</a></h2>
<p class="Pp">Snit allows you to define three kinds of abstract data type:</p>
<ul class="Bl-bullet">
  <li><b>snit::type</b></li>
  <li><b>snit::widget</b></li>
  <li><b>snit::widgetadaptor</b></li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_A_SNIT::TYPE?"><a class="permalink" href="#WHAT_IS_A_SNIT::TYPE?">WHAT
  IS A SNIT::TYPE?</a></h2>
<p class="Pp">A <b>snit::type</b> is a non-GUI abstract data type, e.g., a stack
    or a queue. <b>snit::type</b>s are defined using the <b>snit::type</b>
    command. For example, if you were designing a kennel management system for a
    dog breeder, you'd need a dog type.</p>
<p class="Pp"></p>
<pre>% snit::type dog {
    # ...
}
::dog
%
</pre>
<p class="Pp">This definition defines a new command (<b>::dog</b>, in this case)
    that can be used to define dog objects.</p>
<p class="Pp">An instance of a <b>snit::type</b> can have <b>INSTANCE
    METHODS</b>, <b>INSTANCE VARIABLES</b>, <b>OPTIONS</b>, and
    <b>COMPONENTS</b>. The type itself can have <b>TYPE METHODS</b>, <b>TYPE
    VARIABLES</b>, <b>TYPE COMPONENTS</b>, and <b>PROCS</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_A_SNIT::WIDGET?,_THE_SHORT_STORY"><a class="permalink" href="#WHAT_IS_A_SNIT::WIDGET?,_THE_SHORT_STORY">WHAT
  IS A SNIT::WIDGET?, THE SHORT STORY</a></h2>
<p class="Pp">A <b>snit::widget</b> is a Tk megawidget built using Snit; it is
    very similar to a <b>snit::type</b>. See <b>WIDGETS</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_A_SNIT::WIDGETADAPTOR?,_THE_SHORT_STORY"><a class="permalink" href="#WHAT_IS_A_SNIT::WIDGETADAPTOR?,_THE_SHORT_STORY">WHAT
  IS A SNIT::WIDGETADAPTOR?, THE SHORT STORY</a></h2>
<p class="Pp">A <b>snit::widgetadaptor</b> uses Snit to wrap an existing widget
    type (e.g., a Tk label), modifying its interface to a lesser or greater
    extent. It is very similar to a <b>snit::widget</b>. See <b>WIDGET
    ADAPTORS</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_I_CREATE_AN_INSTANCE_OF_A_SNIT::TYPE?"><a class="permalink" href="#HOW_DO_I_CREATE_AN_INSTANCE_OF_A_SNIT::TYPE?">HOW
  DO I CREATE AN INSTANCE OF A SNIT::TYPE?</a></h2>
<p class="Pp">You create an instance of a <b>snit::type</b> by passing the new
    instance's name to the type's create method. In the following example, we
    create a <b>dog</b> object called <b>spot</b>.</p>
<p class="Pp"></p>
<pre>% snit::type dog {
    # ....
}
::dog
% dog create spot
::spot
%
</pre>
<p class="Pp">In general, the <b>create</b> method name can be omitted so long
    as the instance name doesn't conflict with any defined <b>TYPE METHODS</b>.
    (See <b>TYPE COMPONENTS</b> for the special case in which this doesn't
    work.) So the following example is identical to the previous example:</p>
<p class="Pp"></p>
<pre>% snit::type dog {
    # ....
}
::dog
% dog spot
::spot
%
</pre>
<p class="Pp">This document generally uses the shorter form.</p>
<p class="Pp">If the <b>dog</b> type defines <b>OPTIONS</b>, these can usually
    be given defaults at creation time:</p>
<p class="Pp"></p>
<pre>% snit::type dog {
    option -breed mongrel
    option -color brown
    method bark {} { return &quot;$self barks.&quot; }
}
::dog
% dog create spot -breed dalmation -color spotted
::spot
% spot cget -breed
dalmation
% spot cget -color
spotted
%
</pre>
<p class="Pp">Once created, the instance name now names a new Tcl command that
    is used to manipulate the object. For example, the following code makes the
    dog bark:</p>
<p class="Pp"></p>
<pre>% spot bark
::spot barks.
%
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_I_REFER_TO_AN_OBJECT_INDIRECTLY?"><a class="permalink" href="#HOW_DO_I_REFER_TO_AN_OBJECT_INDIRECTLY?">HOW
  DO I REFER TO AN OBJECT INDIRECTLY?</a></h2>
<p class="Pp">Some programmers prefer to save the object name in a variable, and
    reference it that way. For example,</p>
<p class="Pp"></p>
<pre>% snit::type dog { ... }
::dog
% set d [dog spot -breed dalmation -color spotted]
::spot
% $d cget -breed
dalmation
% $d bark
::spot barks.
%
</pre>
<p class="Pp">If you prefer this style, you might prefer to have Snit generate
    the instance's name automatically.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_CAN_I_GENERATE_THE_OBJECT_NAME_AUTOMATICALLY?"><a class="permalink" href="#HOW_CAN_I_GENERATE_THE_OBJECT_NAME_AUTOMATICALLY?">HOW
  CAN I GENERATE THE OBJECT NAME AUTOMATICALLY?</a></h2>
<p class="Pp">If you'd like Snit to generate an object name for you, use the
    <b>%AUTO%</b> keyword as the requested name:</p>
<p class="Pp"></p>
<pre>% snit::type dog { ... }
::dog
% set d [dog %AUTO%]
::dog2
% $d bark
::dog2 barks.
%
</pre>
<p class="Pp">The <b>%AUTO%</b> keyword can be embedded in a longer string:</p>
<p class="Pp"></p>
<pre>% set d [dog obj_%AUTO%]
::obj_dog4
% $d bark
::obj_dog4 barks.
%
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="CAN_TYPES_BE_RENAMED?"><a class="permalink" href="#CAN_TYPES_BE_RENAMED?">CAN
  TYPES BE RENAMED?</a></h2>
<p class="Pp">Tcl's <b>rename</b> command renames other commands. It's a common
    technique in Tcl to modify an existing command by renaming it and defining a
    new command with the original name; the new command usually calls the
    renamed command.</p>
<p class="Pp"><b>snit::type</b> commands, however, should never be renamed; to
    do so breaks the connection between the type and its objects.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="CAN_OBJECTS_BE_RENAMED?"><a class="permalink" href="#CAN_OBJECTS_BE_RENAMED?">CAN
  OBJECTS BE RENAMED?</a></h2>
<p class="Pp">Tcl's <b>rename</b> command renames other commands. It's a common
    technique in Tcl to modify an existing command by renaming it and defining a
    new command with the original name; the new command usually calls the
    renamed command.</p>
<p class="Pp">All Snit objects (including <i>widgets</i> and
    <i>widgetadaptors</i>) can be renamed, though this flexibility has some
    consequences:</p>
<ul class="Bl-bullet">
  <li>In an instance method, the implicit argument <b>self</b> will always
      contain the object's current name, so instance methods can always call
      other instance methods using <b>$self</b>.</li>
  <li>If the object is renamed, however, then <b>$self</b>'s value will change.
      Therefore, don't use <b>$self</b> for anything that will break if
      <b>$self</b> changes. For example, don't pass a callback command to
      another object like this:
    <pre>
    .btn configure -command [list $self ButtonPress]
    </pre>
    You'll get an error if <b>.btn</b> calls your command after your object is
      renamed.</li>
  <li>Instead, your object should define its callback command like this:
    <pre>
    .btn configure -command [mymethod ButtonPress]
    </pre>
    The <b>mymethod</b> command returns code that will call the desired method
      safely; the caller of the callback can add additional arguments to the end
      of the command as usual.</li>
  <li>Every object has a private namespace; the name of this namespace is
      available in method bodies, etc., as the value of the implicit argument
      <b>selfns</b>. This value is constant for the life of the object. Use
      <b>$selfns</b> instead of <b>$self</b> if you need a unique token to
      identify the object.</li>
  <li>When a <b>snit::widget</b>'s instance command is renamed, its Tk window
      name remains the same -- and is still extremely important. Consequently,
      the Tk window name is available in method bodies as the value of the
      implicit argument <b>win</b>. This value is constant for the life of the
      object. When creating child windows, it's best to use <b>$win.child</b>
      rather than <b>$self.child</b> as the name of the child window.</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_I_DESTROY_A_SNIT_OBJECT?"><a class="permalink" href="#HOW_DO_I_DESTROY_A_SNIT_OBJECT?">HOW
  DO I DESTROY A SNIT OBJECT?</a></h2>
<p class="Pp">Any Snit object of any type can be destroyed by renaming it to the
    empty string using the Tcl <b>rename</b> command.</p>
<p class="Pp">Snit megawidgets (i.e., instances of <b>snit::widget</b> and
    <b>snit::widgetadaptor</b>) can be destroyed like any other widget: by using
    the Tk <b>destroy</b> command on the widget or on one of its ancestors in
    the window hierarchy.</p>
<p class="Pp">Every instance of a <b>snit::type</b> has a <b>destroy</b>
  method:</p>
<p class="Pp"></p>
<pre>% snit::type dog { ... }
::dog
% dog spot
::spot
% spot bark
::spot barks.
% spot destroy
% spot barks
invalid command name &quot;spot&quot;
%
</pre>
<p class="Pp">Finally, every Snit type has a type method called <b>destroy</b>;
    calling it destroys the type and all of its instances:</p>
<pre>% snit::type dog { ... }
::dog
% dog spot
::spot
% spot bark
::spot barks.
% dog destroy
% spot bark
invalid command name &quot;spot&quot;
% dog fido
invalid command name &quot;dog&quot;
%
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="INSTANCE_METHODS"><a class="permalink" href="#INSTANCE_METHODS">INSTANCE
  METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_AN_INSTANCE_METHOD?"><a class="permalink" href="#WHAT_IS_AN_INSTANCE_METHOD?">WHAT
  IS AN INSTANCE METHOD?</a></h2>
<p class="Pp">An instance method is a procedure associated with a specific
    object and called as a subcommand of the object's command. It is given free
    access to all of the object's type variables, instance variables, and so
    forth.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_I_DEFINE_AN_INSTANCE_METHOD?"><a class="permalink" href="#HOW_DO_I_DEFINE_AN_INSTANCE_METHOD?">HOW
  DO I DEFINE AN INSTANCE METHOD?</a></h2>
<p class="Pp">Instance methods are defined in the type definition using the
    <b>method</b> statement. Consider the following code that might be used to
    add dogs to a computer simulation:</p>
<p class="Pp"></p>
<pre>% snit::type dog {
    method bark {} {
        return &quot;$self barks.&quot;
    }
    method chase {thing} {
        return &quot;$self chases $thing.&quot;
    }
}
::dog
%
</pre>
<p class="Pp">A dog can bark, and it can chase things.</p>
<p class="Pp">The <b>method</b> statement looks just like a normal Tcl
    <b>proc</b>, except that it appears in a <b>snit::type</b> definition.
    Notice that every instance method gets an implicit argument called
    <b>self</b>; this argument contains the object's name. (There's more on
    implicit method arguments below.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DOES_A_CLIENT_CALL_AN_INSTANCE_METHOD?"><a class="permalink" href="#HOW_DOES_A_CLIENT_CALL_AN_INSTANCE_METHOD?">HOW
  DOES A CLIENT CALL AN INSTANCE METHOD?</a></h2>
<p class="Pp">The method name becomes a subcommand of the object. For example,
    let's put a simulated dog through its paces:</p>
<p class="Pp"></p>
<pre>% dog spot
::spot
% spot bark
::spot barks.
% spot chase cat
::spot chases cat.
%
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DOES_AN_INSTANCE_METHOD_CALL_ANOTHER_INSTANCE_METHOD?"><a class="permalink" href="#HOW_DOES_AN_INSTANCE_METHOD_CALL_ANOTHER_INSTANCE_METHOD?">HOW
  DOES AN INSTANCE METHOD CALL ANOTHER INSTANCE METHOD?</a></h2>
<p class="Pp">If method A needs to call method B on the same object, it does so
    just as a client does: it calls method B as a subcommand of the object
    itself, using the object name stored in the implicit argument
  <b>self</b>.</p>
<p class="Pp">Suppose, for example, that our dogs never chase anything without
    barking at them:</p>
<p class="Pp"></p>
<pre>% snit::type dog {
    method bark {} {
        return &quot;$self barks.&quot;
    }
    method chase {thing} {
        return &quot;$self chases $thing.  [$self bark]&quot;
    }
}
::dog
% dog spot
::spot
% spot bark
::spot barks.
% spot chase cat
::spot chases cat.  ::spot barks.
%
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="ARE_THERE_ANY_LIMITATIONS_ON_INSTANCE_METHOD_NAMES?"><a class="permalink" href="#ARE_THERE_ANY_LIMITATIONS_ON_INSTANCE_METHOD_NAMES?">ARE
  THERE ANY LIMITATIONS ON INSTANCE METHOD NAMES?</a></h2>
<p class="Pp">Not really, so long as you avoid the standard instance method
    names: <b>configure</b>, <b>configurelist</b>, <b>cget</b>, <b>destroy</b>,
    and <b>info</b>. Also, method names consisting of multiple words define
    hierarchical methods.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_A_HIERARCHICAL_METHOD?"><a class="permalink" href="#WHAT_IS_A_HIERARCHICAL_METHOD?">WHAT
  IS A HIERARCHICAL METHOD?</a></h2>
<p class="Pp">An object's methods are subcommands of the object's instance
    command. Hierarchical methods allow an object's methods to have subcommands
    of their own; and these can in turn have subcommands, and so on. This allows
    the programmer to define a tree-shaped command structure, such as is used by
    many of the Tk widgets--the subcommands of the Tk <b>text</b> widget's
    <b>tag</b> method are hierarchical methods.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_I_DEFINE_A_HIERARCHICAL_METHOD?"><a class="permalink" href="#HOW_DO_I_DEFINE_A_HIERARCHICAL_METHOD?">HOW
  DO I DEFINE A HIERARCHICAL METHOD?</a></h2>
<p class="Pp">Define methods whose names consist of multiple words. These words
    define the hierarchy implicitly. For example, the following code defines a
    <b>tag</b> method with subcommands <b>cget</b> and <b>configure</b>:</p>
<pre>snit::widget mytext {
    method {tag configure} {tag args} { ... }
    method {tag cget} {tag option} {...}
}
</pre>
<p class="Pp">Note that there is no explicit definition for the <b>tag</b>
    method; it is implicit in the definition of <b>tag configure</b> and <b>tag
    cget</b>. If you tried to define <b>tag</b> explicitly in this example,
    you'd get an error.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_I_CALL_HIERARCHICAL_METHODS?"><a class="permalink" href="#HOW_DO_I_CALL_HIERARCHICAL_METHODS?">HOW
  DO I CALL HIERARCHICAL METHODS?</a></h2>
<p class="Pp">As subcommands of subcommands.</p>
<pre>% mytext .text
% .text tag configure redtext -foreground red -background black
% .text tag cget redtext -foreground
red
%
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_I_MAKE_AN_INSTANCE_METHOD_PRIVATE?"><a class="permalink" href="#HOW_DO_I_MAKE_AN_INSTANCE_METHOD_PRIVATE?">HOW
  DO I MAKE AN INSTANCE METHOD PRIVATE?</a></h2>
<p class="Pp">It's often useful to define private methods, that is, instance
    methods intended to be called only by other methods of the same object.</p>
<p class="Pp">Snit doesn't implement any access control on instance methods, so
    all methods are <i>de facto</i> public. Conventionally, though, the names of
    public methods begin with a lower-case letter, and the names of private
    methods begin with an upper-case letter.</p>
<p class="Pp">For example, suppose our simulated dogs only bark in response to
    other stimuli; they never bark just for fun. So the <b>bark</b> method
    becomes <b>Bark</b> to indicate that it is private:</p>
<p class="Pp"></p>
<pre>% snit::type dog {
    # Private by convention: begins with uppercase letter.
    method Bark {} {
        return &quot;$self barks.&quot;
    }
    method chase {thing} {
        return &quot;$self chases $thing. [$self Bark]&quot;
    }
}
::dog
% dog fido
::fido
% fido chase cat
::fido chases cat. ::fido barks.
%
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="ARE_THERE_ANY_LIMITATIONS_ON_INSTANCE_METHOD_ARGUMENTS?"><a class="permalink" href="#ARE_THERE_ANY_LIMITATIONS_ON_INSTANCE_METHOD_ARGUMENTS?">ARE
  THERE ANY LIMITATIONS ON INSTANCE METHOD ARGUMENTS?</a></h2>
<p class="Pp">Method argument lists are defined just like normal Tcl <b>proc</b>
    argument lists; in particular, they can include arguments with default
    values and the <b>args</b> argument.</p>
<p class="Pp">However, every method also has a number of implicit arguments
    provided by Snit in addition to those explicitly defined. The names of these
    implicit arguments may not used to name explicit arguments.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="WHAT_IMPLICIT_ARGUMENTS_ARE_PASSED_TO_EACH_INSTANCE_METHOD?"><a class="permalink" href="#WHAT_IMPLICIT_ARGUMENTS_ARE_PASSED_TO_EACH_INSTANCE_METHOD?">WHAT
  IMPLICIT ARGUMENTS ARE PASSED TO EACH INSTANCE METHOD?</a></h2>
<p class="Pp">The arguments implicitly passed to every method are <b>type</b>,
    <b>selfns</b>, <b>win</b>, and <b>self</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_$TYPE?"><a class="permalink" href="#WHAT_IS_$TYPE?">WHAT
  IS $TYPE?</a></h2>
<p class="Pp">The implicit argument <b>type</b> contains the fully qualified
    name of the object's type:</p>
<p class="Pp"></p>
<pre>% snit::type thing {
    method mytype {} {
        return $type
    }
}
::thing
% thing something
::something
% something mytype
::thing
%
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_$SELF?"><a class="permalink" href="#WHAT_IS_$SELF?">WHAT
  IS $SELF?</a></h2>
<p class="Pp">The implicit argument <b>self</b> contains the object's fully
    qualified name.</p>
<p class="Pp">If the object's command is renamed, then <b>$self</b> will change
    to match in subsequent calls. Thus, your code should not assume that
    <b>$self</b> is constant unless you know for sure that the object will never
    be renamed.</p>
<p class="Pp"></p>
<pre>% snit::type thing {
    method myself {} {
        return $self
    }
}
::thing
% thing mutt
::mutt
% mutt myself
::mutt
% rename mutt jeff
% jeff myself
::jeff
%
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_$SELFNS?"><a class="permalink" href="#WHAT_IS_$SELFNS?">WHAT
  IS $SELFNS?</a></h2>
<p class="Pp">Each Snit object has a private namespace in which to store its
    <b>INSTANCE VARIABLES</b> and <b>OPTIONS</b>. The implicit argument
    <b>selfns</b> contains the name of this namespace; its value never changes,
    and is constant for the life of the object, even if the object's name
    changes:</p>
<p class="Pp"></p>
<pre>% snit::type thing {
    method myNameSpace {} {
        return $selfns
    }
}
::thing
% thing jeff
::jeff
% jeff myNameSpace
::thing::Snit_inst3
% rename jeff mutt
% mutt myNameSpace
::thing::Snit_inst3
%
</pre>
<p class="Pp">The above example reveals how Snit names an instance's private
    namespace; however, you should not write code that depends on the specific
    naming convention, as it might change in future releases.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_$WIN?"><a class="permalink" href="#WHAT_IS_$WIN?">WHAT
  IS $WIN?</a></h2>
<p class="Pp">The implicit argument <b>win</b> is defined for all Snit methods,
    though it really makes sense only for those of <b>WIDGETS</b> and <b>WIDGET
    ADAPTORS</b>. <b>$win</b> is simply the original name of the object, whether
    it's been renamed or not. For widgets and widgetadaptors, it is also
    therefore the name of a Tk window.</p>
<p class="Pp">When a <b>snit::widgetadaptor</b> is used to modify the interface
    of a widget or megawidget, it must rename the widget's original command and
    replace it with its own.</p>
<p class="Pp">Thus, using <b>win</b> whenever the Tk window name is called for
    means that a <b>snit::widget</b> or <b>snit::widgetadaptor</b> can be
    adapted by a <b>snit::widgetadaptor</b>. See <b>WIDGETS</b> for more
    information.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_I_PASS_AN_INSTANCE_METHOD_AS_A_CALLBACK?"><a class="permalink" href="#HOW_DO_I_PASS_AN_INSTANCE_METHOD_AS_A_CALLBACK?">HOW
  DO I PASS AN INSTANCE METHOD AS A CALLBACK?</a></h2>
<p class="Pp">It depends on the context.</p>
<p class="Pp">Suppose in my application I have a <b>dog</b> object named
    <b>fido</b>, and I want <b>fido</b> to bark when a Tk button called
    <b>.bark</b> is pressed. In this case, I create the callback command in the
    usual way, using <b>list</b>:</p>
<p class="Pp"></p>
<pre>
    button .bark -text &quot;Bark!&quot; -command [list fido bark]
</pre>
<p class="Pp">In typical Tcl style, we use a callback to hook two independent
    components together. But suppose that the <b>dog</b> object has a graphical
    interface and owns the button itself? In this case, the <b>dog</b> must pass
    one of its own instance methods to the button it owns. The obvious thing to
    do is this:</p>
<p class="Pp"></p>
<pre>% snit::widget dog {
    constructor {args} {
        #...
        button $win.barkbtn -text &quot;Bark!&quot; -command [list $self bark]
        #...
    }
}
::dog
%
</pre>
<p class="Pp">(Note that in this example, our <b>dog</b> becomes a
    <b>snit::widget</b>, because it has GUI behavior. See <b>WIDGETS</b> for
    more.) Thus, if we create a <b>dog</b> called <b>.spot</b>, it will create a
    Tk button called <b>.spot.barkbtn</b>; when pressed, the button will call
    <b>$self bark</b>.</p>
<p class="Pp">Now, this will work--provided that <b>.spot</b> is never renamed
    to something else. But surely renaming widgets is abnormal? And so it
    is--unless <b>.spot</b> is the hull component of a
    <b>snit::widgetadaptor</b>. If it is, then it will be renamed, and
    <b>.spot</b> will become the name of the <b>snit::widgetadaptor</b> object.
    When the button is pressed, the command <b>$self bark</b> will be handled by
    the <b>snit::widgetadaptor</b>, which might or might not do the right
  thing.</p>
<p class="Pp">There's a safer way to do it, and it looks like this:</p>
<p class="Pp"></p>
<pre>% snit::widget dog {
    constructor {args} {
        #...
        button $win.barkbtn -text &quot;Bark!&quot; -command [mymethod bark]
        #...
    }
}
::dog
%
</pre>
<p class="Pp">The command <b>mymethod</b> takes any number of arguments, and can
    be used like <b>list</b> to build up a callback command; the only difference
    is that <b>mymethod</b> returns a form of the command that won't change even
    if the instance's name changes.</p>
<p class="Pp">On the other hand, you might prefer to allow a widgetadaptor to
    override a method such that your renamed widget will call the
    widgetadaptor's method instead of its own. In this case, using <b>[list
    $self bark]</b> will do what you want...but this is a technique which should
    be used only in carefully controlled circumstances.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_I_DELEGATE_INSTANCE_METHODS_TO_A_COMPONENT?"><a class="permalink" href="#HOW_DO_I_DELEGATE_INSTANCE_METHODS_TO_A_COMPONENT?">HOW
  DO I DELEGATE INSTANCE METHODS TO A COMPONENT?</a></h2>
<p class="Pp">See <b>DELEGATION</b>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="INSTANCE_VARIABLES"><a class="permalink" href="#INSTANCE_VARIABLES">INSTANCE
  VARIABLES</a></h1>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_AN_INSTANCE_VARIABLE?"><a class="permalink" href="#WHAT_IS_AN_INSTANCE_VARIABLE?">WHAT
  IS AN INSTANCE VARIABLE?</a></h2>
<p class="Pp">An instance variable is a private variable associated with some
    particular Snit object. Instance variables can be scalars or arrays.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_IS_A_SCALAR_INSTANCE_VARIABLE_DEFINED?"><a class="permalink" href="#HOW_IS_A_SCALAR_INSTANCE_VARIABLE_DEFINED?">HOW
  IS A SCALAR INSTANCE VARIABLE DEFINED?</a></h2>
<p class="Pp">Scalar instance variables are defined in the type definition using
    the <b>variable</b> statement. You can simply name it, or you can initialize
    it with a value:</p>
<p class="Pp"></p>
<pre>snit::type mytype {
    # Define variable &quot;greeting&quot; and initialize it with &quot;Howdy!&quot;
    variable greeting &quot;Howdy!&quot;
}
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_IS_AN_ARRAY_INSTANCE_VARIABLE_DEFINED?"><a class="permalink" href="#HOW_IS_AN_ARRAY_INSTANCE_VARIABLE_DEFINED?">HOW
  IS AN ARRAY INSTANCE VARIABLE DEFINED?</a></h2>
<p class="Pp">Array instance variables are also defined in the type definition
    using the <b>variable</b> command. You can initialize them at the same time
    by specifying the <b>-array</b> option:</p>
<p class="Pp"></p>
<pre>snit::type mytype {
    # Define array variable &quot;greetings&quot;
    variable greetings -array {
        formal &quot;Good Evening&quot;
        casual &quot;Howdy!&quot;
    }
}
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="WHAT_HAPPENS_IF_I_DON'T_INITIALIZE_AN_INSTANCE_VARIABLE?"><a class="permalink" href="#WHAT_HAPPENS_IF_I_DON'T_INITIALIZE_AN_INSTANCE_VARIABLE?">WHAT
  HAPPENS IF I DON'T INITIALIZE AN INSTANCE VARIABLE?</a></h2>
<p class="Pp">Variables do not really exist until they are given values. If you
    do not initialize a variable when you define it, then you must be sure to
    assign a value to it (in the constructor, say, or in some method) before you
    reference it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ARE_THERE_ANY_LIMITATIONS_ON_INSTANCE_VARIABLE_NAMES?"><a class="permalink" href="#ARE_THERE_ANY_LIMITATIONS_ON_INSTANCE_VARIABLE_NAMES?">ARE
  THERE ANY LIMITATIONS ON INSTANCE VARIABLE NAMES?</a></h2>
<p class="Pp">Just a few.</p>
<p class="Pp">First, every Snit object has a built-in instance variable called
    <b>options</b>, which should never be redefined.</p>
<p class="Pp">Second, all names beginning with &quot;Snit_&quot; are reserved
    for use by Snit internal code.</p>
<p class="Pp">Third, instance variable names containing the namespace delimiter
    (<b>::</b>) are likely to cause great confusion.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="DO_I_NEED_TO_DECLARE_MY_INSTANCE_VARIABLES_IN_MY_METHODS?"><a class="permalink" href="#DO_I_NEED_TO_DECLARE_MY_INSTANCE_VARIABLES_IN_MY_METHODS?">DO
  I NEED TO DECLARE MY INSTANCE VARIABLES IN MY METHODS?</a></h2>
<p class="Pp">No. Once you've defined an instance variable in the type
    definition, it can be used in any instance code (instance methods, the
    constructor, and the destructor) without declaration. This differs from
    normal Tcl practice, in which all non-local variables in a proc need to be
    declared.</p>
<p class="Pp">There is a speed penalty to having all instance variables
    implicitly available in all instance code. Even though your code need not
    declare the variables explicitly, Snit must still declare them, and that
    takes time. If you have ten instance variables, a method that uses none of
    them must still pay the declaration penalty for all ten. In most cases, the
    additional runtime cost is negligible. If extreme cases, you might wish to
    avoid it; there are two methods for doing so.</p>
<p class="Pp">The first is to define a single instance variable, an array, and
    store all of your instance data in the array. This way, you're only paying
    the declaration penalty for one variable--and you probably need the variable
    most of the time anyway. This method breaks down if your instance variables
    include multiple arrays; in Tcl 8.5, however, the <b>dict</b> command might
    come to your rescue.</p>
<p class="Pp">The second method is to declare your instance variables explicitly
    in your instance code, while <i>not</i> including them in the type
    definition:</p>
<pre>snit::type dog {
    constructor {} {
        variable mood
        set mood happy
    }
    method setmood {newMood} {
        variable mood
        set mood $newMood
    }
    method getmood {} {
        variable mood
        return $mood
    }
}
</pre>
This allows you to ensure that only the required variables are included in each
  method, at the cost of longer code and run-time errors when you forget to
  declare a variable you need.
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_I_PASS_AN_INSTANCE_VARIABLE'S_NAME_TO_ANOTHER_OBJECT?"><a class="permalink" href="#HOW_DO_I_PASS_AN_INSTANCE_VARIABLE'S_NAME_TO_ANOTHER_OBJECT?">HOW
  DO I PASS AN INSTANCE VARIABLE'S NAME TO ANOTHER OBJECT?</a></h2>
<p class="Pp">In Tk, it's common to pass a widget a variable name; for example,
    Tk label widgets have a <b>-textvariable</b> option which names the variable
    which will contain the widget's text. This allows the program to update the
    label's value just by assigning a new value to the variable.</p>
<p class="Pp">If you naively pass the instance variable name to the label
    widget, you'll be confused by the result; Tk will assume that the name names
    a global variable. Instead, you need to provide a fully-qualified variable
    name. From within an instance method or a constructor, you can fully qualify
    the variable's name using the <b>myvar</b> command:</p>
<p class="Pp"></p>
<pre>snit::widget mywidget {
    variable labeltext &quot;&quot;
    constructor {args} {
        # ...
        label $win.label -textvariable [myvar labeltext]
        # ...
    }
}
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_I_MAKE_AN_INSTANCE_VARIABLE_PUBLIC?"><a class="permalink" href="#HOW_DO_I_MAKE_AN_INSTANCE_VARIABLE_PUBLIC?">HOW
  DO I MAKE AN INSTANCE VARIABLE PUBLIC?</a></h2>
<p class="Pp">Practically speaking, you don't. Instead, you'll implement public
    variables as <b>OPTIONS</b>. Alternatively, you can write <b>INSTANCE
    METHODS</b> to set and get the variable's value.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="OPTIONS"><a class="permalink" href="#OPTIONS">OPTIONS</a></h1>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_AN_OPTION?"><a class="permalink" href="#WHAT_IS_AN_OPTION?">WHAT
  IS AN OPTION?</a></h2>
<p class="Pp">A type's options are the equivalent of what other object-oriented
    languages would call public member variables or properties: they are data
    values which can be retrieved and (usually) set by the clients of an
  object.</p>
<p class="Pp">Snit's implementation of options follows the Tk model fairly
    exactly, except that <b>snit::type</b> objects usually don't interact with
    <b>THE TK OPTION DATABASE</b>; <b>snit::widget</b> and
    <b>snit::widgetadaptor</b> objects, on the other hand, always do.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_I_DEFINE_AN_OPTION?"><a class="permalink" href="#HOW_DO_I_DEFINE_AN_OPTION?">HOW
  DO I DEFINE AN OPTION?</a></h2>
<p class="Pp">Options are defined in the type definition using the <b>option</b>
    statement. Consider the following type, to be used in an application that
    manages a list of dogs for a pet store:</p>
<p class="Pp"></p>
<pre>snit::type dog {
    option -breed -default mongrel
    option -color -default brown
    option -akc   -default 0
    option -shots -default 0
}
</pre>
<p class="Pp">According to this, a dog has four notable properties: a breed, a
    color, a flag that says whether it's pedigreed with the American Kennel
    Club, and another flag that says whether it has had its shots. The default
    dog, evidently, is a brown mutt.</p>
<p class="Pp">There are a number of options you can specify when defining an
    option; if <b>-default</b> is the only one, you can omit the word
    <b>-default</b> as follows:</p>
<p class="Pp"></p>
<pre>snit::type dog {
    option -breed mongrel
    option -color brown
    option -akc   0
    option -shots 0
}
</pre>
<p class="Pp">If no <b>-default</b> value is specified, the option's default
    value will be the empty string (but see <b>THE TK OPTION DATABASE</b>).</p>
<p class="Pp">The Snit man page refers to options like these as &quot;locally
    defined&quot; options.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_CAN_A_CLIENT_SET_OPTIONS_AT_OBJECT_CREATION?"><a class="permalink" href="#HOW_CAN_A_CLIENT_SET_OPTIONS_AT_OBJECT_CREATION?">HOW
  CAN A CLIENT SET OPTIONS AT OBJECT CREATION?</a></h2>
<p class="Pp">The normal convention is that the client may pass any number of
    options and their values after the object's name at object creation. For
    example, the <b>::dog</b> command defined in the previous answer can now be
    used to create individual dogs. Any or all of the options may be set at
    creation time.</p>
<p class="Pp"></p>
<pre>% dog spot -breed beagle -color &quot;mottled&quot; -akc 1 -shots 1
::spot
% dog fido -shots 1
::fido
%
</pre>
<p class="Pp">So <b>::spot</b> is a pedigreed beagle; <b>::fido</b> is a typical
    mutt, but his owners evidently take care of him, because he's had his
  shots.</p>
<p class="Pp"><i>Note:</i> If the type defines a constructor, it can specify a
    different object-creation syntax. See <b>CONSTRUCTORS</b> for more
    information.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_CAN_A_CLIENT_RETRIEVE_AN_OPTION'S_VALUE?"><a class="permalink" href="#HOW_CAN_A_CLIENT_RETRIEVE_AN_OPTION'S_VALUE?">HOW
  CAN A CLIENT RETRIEVE AN OPTION'S VALUE?</a></h2>
<p class="Pp">Retrieve option values using the <b>cget</b> method:</p>
<p class="Pp"></p>
<pre>% spot cget -color
mottled
% fido cget -breed
mongrel
%
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_CAN_A_CLIENT_SET_OPTIONS_AFTER_OBJECT_CREATION?"><a class="permalink" href="#HOW_CAN_A_CLIENT_SET_OPTIONS_AFTER_OBJECT_CREATION?">HOW
  CAN A CLIENT SET OPTIONS AFTER OBJECT CREATION?</a></h2>
<p class="Pp">Any number of options may be set at one time using the
    <b>configure</b> instance method. Suppose that closer inspection shows that
    ::fido is not a brown mongrel, but rather a rare Arctic Boar Hound of a
    lovely dun color:</p>
<p class="Pp"></p>
<pre>% fido configure -color dun -breed &quot;Arctic Boar Hound&quot;
% fido cget -color
dun
% fido cget -breed
Arctic Boar Hound
</pre>
<p class="Pp">Alternatively, the <b>configurelist</b> method takes a list of
    options and values; occasionally this is more convenient:</p>
<p class="Pp"></p>
<pre>% set features [list -color dun -breed &quot;Arctic Boar Hound&quot;]
-color dun -breed {Arctic Boar Hound}
% fido configurelist $features
% fido cget -color
dun
% fido cget -breed
Arctic Boar Hound
%
</pre>
<p class="Pp">In Tcl 8.5, the <b>*</b> keyword can be used with <b>configure</b>
    in this case:</p>
<p class="Pp"></p>
<pre>% set features [list -color dun -breed &quot;Arctic Boar Hound&quot;]
-color dun -breed {Arctic Boar Hound}
% fido configure {*}$features
% fido cget -color
dun
% fido cget -breed
Arctic Boar Hound
%
</pre>
<p class="Pp">The results are the same.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_SHOULD_AN_INSTANCE_METHOD_ACCESS_AN_OPTION_VALUE?"><a class="permalink" href="#HOW_SHOULD_AN_INSTANCE_METHOD_ACCESS_AN_OPTION_VALUE?">HOW
  SHOULD AN INSTANCE METHOD ACCESS AN OPTION VALUE?</a></h2>
<p class="Pp">There are two ways an instance method can set and retrieve an
    option's value. One is to use the <b>configure</b> and <b>cget</b> methods,
    as shown below.</p>
<p class="Pp"></p>
<pre>% snit::type dog {
    option -weight 10
    method gainWeight {} {
        set wt [$self cget -weight]
        incr wt
        $self configure -weight $wt
    }
}
::dog
% dog fido
::fido
% fido cget -weight
10
% fido gainWeight
% fido cget -weight
11
%
</pre>
<p class="Pp">Alternatively, Snit provides a built-in array instance variable
    called <b>options</b>. The indices are the option names; the values are the
    option values. The method <b>gainWeight</b> can thus be rewritten as
    follows:</p>
<p class="Pp"></p>
<pre>
    method gainWeight {} {
        incr options(-weight)
    }
</pre>
<p class="Pp">As you can see, using the <b>options</b> variable involves
    considerably less typing and is the usual way to do it. But if you use
    <b>-configuremethod</b> or <b>-cgetmethod</b> (described in the following
    answers), you might wish to use the <b>configure</b> and <b>cget</b> methods
    anyway, just so that any special processing you've implemented is sure to
    get done. Also, if the option is delegated to a component then
    <b>configure</b> and <b>cget</b> are the only way to access it without
    accessing the component directly. See <b>DELEGATION</b> for more
    information.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_CAN_I_MAKE_AN_OPTION_READ-ONLY?"><a class="permalink" href="#HOW_CAN_I_MAKE_AN_OPTION_READ-ONLY?">HOW
  CAN I MAKE AN OPTION READ-ONLY?</a></h2>
<p class="Pp">Define the option with <b>-readonly yes</b>.</p>
<p class="Pp">Suppose you've got an option that determines how instances of your
    type are constructed; it must be set at creation time, after which it's
    constant. For example, a dog never changes its breed; it might or might not
    have had its shots, and if not can have them at a later time. <b>-breed</b>
    should be read-only, but <b>-shots</b> should not be.</p>
<p class="Pp"></p>
<pre>% snit::type dog {
    option -breed -default mongrel -readonly yes
    option -shots -default no
}
::dog
% dog fido -breed retriever
::fido
% fido configure -shots yes
% fido configure -breed terrier
option -breed can only be set at instance creation
%
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_CAN_I_CATCH_ACCESSES_TO_AN_OPTION'S_VALUE?"><a class="permalink" href="#HOW_CAN_I_CATCH_ACCESSES_TO_AN_OPTION'S_VALUE?">HOW
  CAN I CATCH ACCESSES TO AN OPTION'S VALUE?</a></h2>
<p class="Pp">Define a <b>-cgetmethod</b> for the option.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_A_-CGETMETHOD?"><a class="permalink" href="#WHAT_IS_A_-CGETMETHOD?">WHAT
  IS A -CGETMETHOD?</a></h2>
<p class="Pp">A <b>-cgetmethod</b> is a method that's called whenever the
    related option's value is queried via the <b>cget</b> instance method. The
    handler can compute the option's value, retrieve it from a database, or do
    anything else you'd like it to do.</p>
<p class="Pp">Here's what the default behavior would look like if written using
    a <b>-cgetmethod</b>:</p>
<p class="Pp"></p>
<pre>snit::type dog {
    option -color -default brown -cgetmethod GetOption
    method GetOption {option} {
        return $options($option)
    }
}
</pre>
<p class="Pp">Any instance method can be used, provided that it takes one
    argument, the name of the option whose value is to be retrieved.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_CAN_I_CATCH_CHANGES_TO_AN_OPTION'S_VALUE?"><a class="permalink" href="#HOW_CAN_I_CATCH_CHANGES_TO_AN_OPTION'S_VALUE?">HOW
  CAN I CATCH CHANGES TO AN OPTION'S VALUE?</a></h2>
<p class="Pp">Define a <b>-configuremethod</b> for the option.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_A_-CONFIGUREMETHOD?"><a class="permalink" href="#WHAT_IS_A_-CONFIGUREMETHOD?">WHAT
  IS A -CONFIGUREMETHOD?</a></h2>
<p class="Pp">A <b>-configuremethod</b> is a method that's called whenever the
    related option is given a new value via the <b>configure</b> or
    <b>configurelist</b> instance methods. The method can pass the value on to
    some other object, store it in a database, or do anything else you'd like it
    to do.</p>
<p class="Pp">Here's what the default configuration behavior would look like if
    written using a <b>-configuremethod</b>:</p>
<p class="Pp"></p>
<pre>snit::type dog {
    option -color -default brown -configuremethod SetOption
    method SetOption {option value} {
        set options($option) $value
    }
}
</pre>
<p class="Pp">Any instance method can be used, provided that it takes two
    arguments, the name of the option and the new value.</p>
<p class="Pp">Note that if your method doesn't store the value in the
    <b>options</b> array, the <b>options</b> array won't get updated.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_CAN_I_VALIDATE_AN_OPTION'S_VALUE?"><a class="permalink" href="#HOW_CAN_I_VALIDATE_AN_OPTION'S_VALUE?">HOW
  CAN I VALIDATE AN OPTION'S VALUE?</a></h2>
<p class="Pp">Define a <b>-validatemethod</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_A_-VALIDATEMETHOD?"><a class="permalink" href="#WHAT_IS_A_-VALIDATEMETHOD?">WHAT
  IS A -VALIDATEMETHOD?</a></h2>
<p class="Pp">A <b>-validatemethod</b> is a method that's called whenever the
    related option is given a new value via the <b>configure</b> or
    <b>configurelist</b> instance methods. It's the method's responsibility to
    determine whether the new value is valid, and throw an error if it isn't.
    The <b>-validatemethod</b>, if any, is called before the value is stored in
    the <b>options</b> array; in particular, it's called before the
    <b>-configuremethod</b>, if any.</p>
<p class="Pp">For example, suppose an option always takes a Boolean value. You
    can ensure that the value is in fact a valid Boolean like this:</p>
<pre>% snit::type dog {
    option -shots -default no -validatemethod BooleanOption
    method BooleanOption {option value} {
        if {![string is boolean -strict $value]} {
            error &quot;expected a boolean value, got \&quot;$value\&quot;&quot;
        }
    }
}
::dog
% dog fido
% fido configure -shots yes
% fido configure -shots NotABooleanValue
expected a boolean value, got &quot;NotABooleanValue&quot;
%
</pre>
Note that the same <b>-validatemethod</b> can be used to validate any number of
  boolean options.
<p class="Pp">Any method can be a <b>-validatemethod</b> provided that it takes
    two arguments, the option name and the new option value.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TYPE_VARIABLES"><a class="permalink" href="#TYPE_VARIABLES">TYPE
  VARIABLES</a></h1>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_A_TYPE_VARIABLE?"><a class="permalink" href="#WHAT_IS_A_TYPE_VARIABLE?">WHAT
  IS A TYPE VARIABLE?</a></h2>
<p class="Pp">A type variable is a private variable associated with a Snit type
    rather than with a particular instance of the type. In C++ and Java, the
    term <i>static member variable</i> is used for the same notion. Type
    variables can be scalars or arrays.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_IS_A_SCALAR_TYPE_VARIABLE_DEFINED?"><a class="permalink" href="#HOW_IS_A_SCALAR_TYPE_VARIABLE_DEFINED?">HOW
  IS A SCALAR TYPE VARIABLE DEFINED?</a></h2>
<p class="Pp">Scalar type variables are defined in the type definition using the
    <b>typevariable</b> statement. You can simply name it, or you can initialize
    it with a value:</p>
<p class="Pp"></p>
<pre>
snit::type mytype {
    # Define variable &quot;greeting&quot; and initialize it with &quot;Howdy!&quot;
    typevariable greeting &quot;Howdy!&quot;
}
</pre>
<p class="Pp">Every object of type <b>mytype</b> now has access to a single
    variable called <b>greeting</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_IS_AN_ARRAY-VALUED_TYPE_VARIABLE_DEFINED?"><a class="permalink" href="#HOW_IS_AN_ARRAY-VALUED_TYPE_VARIABLE_DEFINED?">HOW
  IS AN ARRAY-VALUED TYPE VARIABLE DEFINED?</a></h2>
<p class="Pp">Array-valued type variables are also defined using the
    <b>typevariable</b> command; to initialize them, include the <b>-array</b>
    option:</p>
<p class="Pp"></p>
<pre>snit::type mytype {
    # Define typearray variable &quot;greetings&quot;
    typevariable greetings -array {
        formal &quot;Good Evening&quot;
        casual &quot;Howdy!&quot;
    }
}
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="WHAT_HAPPENS_IF_I_DON'T_INITIALIZE_A_TYPE_VARIABLE?"><a class="permalink" href="#WHAT_HAPPENS_IF_I_DON'T_INITIALIZE_A_TYPE_VARIABLE?">WHAT
  HAPPENS IF I DON'T INITIALIZE A TYPE VARIABLE?</a></h2>
<p class="Pp">Variables do not really exist until they are given values. If you
    do not initialize a variable when you define it, then you must be sure to
    assign a value to it (in the type constructor, say) before you reference
  it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ARE_THERE_ANY_LIMITATIONS_ON_TYPE_VARIABLE_NAMES?"><a class="permalink" href="#ARE_THERE_ANY_LIMITATIONS_ON_TYPE_VARIABLE_NAMES?">ARE
  THERE ANY LIMITATIONS ON TYPE VARIABLE NAMES?</a></h2>
<p class="Pp">Type variable names have the same restrictions as the names of
    <b>INSTANCE VARIABLES</b> do.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="DO_I_NEED_TO_DECLARE_MY_TYPE_VARIABLES_IN_MY_METHODS?"><a class="permalink" href="#DO_I_NEED_TO_DECLARE_MY_TYPE_VARIABLES_IN_MY_METHODS?">DO
  I NEED TO DECLARE MY TYPE VARIABLES IN MY METHODS?</a></h2>
<p class="Pp">No. Once you've defined a type variable in the type definition, it
    can be used in <b>INSTANCE METHODS</b> or <b>TYPE METHODS</b> without
    declaration. This differs from normal Tcl practice, in which all non-local
    variables in a proc need to be declared.</p>
<p class="Pp">Type variables are subject to the same speed/readability tradeoffs
    as instance variables; see <b>Do I need to declare my instance variables in
    my methods?</b></p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_I_PASS_A_TYPE_VARIABLE'S_NAME_TO_ANOTHER_OBJECT?"><a class="permalink" href="#HOW_DO_I_PASS_A_TYPE_VARIABLE'S_NAME_TO_ANOTHER_OBJECT?">HOW
  DO I PASS A TYPE VARIABLE'S NAME TO ANOTHER OBJECT?</a></h2>
<p class="Pp">In Tk, it's common to pass a widget a variable name; for example,
    Tk label widgets have a <b>-textvariable</b> option which names the variable
    which will contain the widget's text. This allows the program to update the
    label's value just by assigning a new value to the variable.</p>
<p class="Pp">If you naively pass a type variable name to the label widget,
    you'll be confused by the result; Tk will assume that the name names a
    global variable. Instead, you need to provide a fully-qualified variable
    name. From within an instance method or a constructor, you can fully qualify
    the type variable's name using the <b>mytypevar</b> command:</p>
<p class="Pp"></p>
<pre>snit::widget mywidget {
    typevariable labeltext &quot;&quot;
    constructor {args} {
        # ...
        label $win.label -textvariable [mytypevar labeltext]
        # ...
    }
}
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_I_MAKE_A_TYPE_VARIABLE_PUBLIC?"><a class="permalink" href="#HOW_DO_I_MAKE_A_TYPE_VARIABLE_PUBLIC?">HOW
  DO I MAKE A TYPE VARIABLE PUBLIC?</a></h2>
<p class="Pp">There are two ways to do this. The preferred way is to write a
    pair of <b>TYPE METHODS</b> to set and query the type variable's value.</p>
<p class="Pp">Type variables are stored in the type's namespace, which has the
    same name as the type itself. Thus, you can also publicize the type
    variable's name in your documentation so that clients can access it
    directly. For example,</p>
<p class="Pp"></p>
<pre>snit::type mytype {
    typevariable myvariable
}
set ::mytype::myvariable &quot;New Value&quot;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TYPE_METHODS"><a class="permalink" href="#TYPE_METHODS">TYPE
  METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_A_TYPE_METHOD?"><a class="permalink" href="#WHAT_IS_A_TYPE_METHOD?">WHAT
  IS A TYPE METHOD?</a></h2>
<p class="Pp">A type method is a procedure associated with the type itself
    rather than with any specific instance of the type, and called as a
    subcommand of the type command.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_I_DEFINE_A_TYPE_METHOD?"><a class="permalink" href="#HOW_DO_I_DEFINE_A_TYPE_METHOD?">HOW
  DO I DEFINE A TYPE METHOD?</a></h2>
<p class="Pp">Type methods are defined in the type definition using the
    <b>typemethod</b> statement:</p>
<p class="Pp"></p>
<pre>snit::type dog {
    # List of pedigreed dogs
    typevariable pedigreed
    typemethod pedigreedDogs {} {
        return $pedigreed
    }
}
</pre>
<p class="Pp">Suppose the <b>dog</b> type maintains a list of the names of the
    dogs that have pedigrees. The <b>pedigreedDogs</b> type method returns this
    list.</p>
<p class="Pp">The <b>typemethod</b> statement looks just like a normal Tcl
    <b>proc</b>, except that it appears in a <b>snit::type</b> definition.
    Notice that every type method gets an implicit argument called <b>type</b>,
    which contains the fully-qualified type name.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DOES_A_CLIENT_CALL_A_TYPE_METHOD?"><a class="permalink" href="#HOW_DOES_A_CLIENT_CALL_A_TYPE_METHOD?">HOW
  DOES A CLIENT CALL A TYPE METHOD?</a></h2>
<p class="Pp">The type method name becomes a subcommand of the type's command.
    For example, assuming that the constructor adds each pedigreed dog to the
    list of <b>pedigreedDogs</b>,</p>
<p class="Pp"></p>
<pre>snit::type dog {
    option -pedigreed 0
    # List of pedigreed dogs
    typevariable pedigreed
    typemethod pedigreedDogs {} {
        return $pedigreed
    }
    # ...
}
dog spot -pedigreed 1
dog fido
foreach dog [dog pedigreedDogs] { ... }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="ARE_THERE_ANY_LIMITATIONS_ON_TYPE_METHOD_NAMES?"><a class="permalink" href="#ARE_THERE_ANY_LIMITATIONS_ON_TYPE_METHOD_NAMES?">ARE
  THERE ANY LIMITATIONS ON TYPE METHOD NAMES?</a></h2>
<p class="Pp">Not really, so long as you avoid the standard type method names:
    <b>create</b>, <b>destroy</b>, and <b>info</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_I_MAKE_A_TYPE_METHOD_PRIVATE?"><a class="permalink" href="#HOW_DO_I_MAKE_A_TYPE_METHOD_PRIVATE?">HOW
  DO I MAKE A TYPE METHOD PRIVATE?</a></h2>
<p class="Pp">It's sometimes useful to define private type methods, that is,
    type methods intended to be called only by other type or instance methods of
    the same object.</p>
<p class="Pp">Snit doesn't implement any access control on type methods; by
    convention, the names of public methods begin with a lower-case letter, and
    the names of private methods begin with an upper-case letter.</p>
<p class="Pp">Alternatively, a Snit <b>proc</b> can be used as a private type
    method; see <b>PROCS</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ARE_THERE_ANY_LIMITATIONS_ON_TYPE_METHOD_ARGUMENTS?"><a class="permalink" href="#ARE_THERE_ANY_LIMITATIONS_ON_TYPE_METHOD_ARGUMENTS?">ARE
  THERE ANY LIMITATIONS ON TYPE METHOD ARGUMENTS?</a></h2>
<p class="Pp">Method argument lists are defined just like normal Tcl proc
    argument lists; in particular, they can include arguments with default
    values and the <b>args</b> argument.</p>
<p class="Pp">However, every type method is called with an implicit argument
    called <b>type</b> that contains the name of the type command. In addition,
    type methods should by convention avoid using the names of the arguments
    implicitly defined for <b>INSTANCE METHODS</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DOES_AN_INSTANCE_OR_TYPE_METHOD_CALL_A_TYPE_METHOD?"><a class="permalink" href="#HOW_DOES_AN_INSTANCE_OR_TYPE_METHOD_CALL_A_TYPE_METHOD?">HOW
  DOES AN INSTANCE OR TYPE METHOD CALL A TYPE METHOD?</a></h2>
<p class="Pp">If an instance or type method needs to call a type method, it
    should use <b>$type</b> to do so:</p>
<p class="Pp"></p>
<pre>snit::type dog {
    typemethod pedigreedDogs {} { ... }
    typemethod printPedigrees {} {
        foreach obj [$type pedigreedDogs] { ... }
    }
}
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_I_PASS_A_TYPE_METHOD_AS_A_CALLBACK?"><a class="permalink" href="#HOW_DO_I_PASS_A_TYPE_METHOD_AS_A_CALLBACK?">HOW
  DO I PASS A TYPE METHOD AS A CALLBACK?</a></h2>
<p class="Pp">It's common in Tcl to pass a snippet of code to another object,
    for it to call later. Because types cannot be renamed, you can just use the
    type name, or, if the callback is registered from within a type method,
    <b>type</b>. For example, suppose we want to print a list of pedigreed dogs
    when a Tk button is pushed:</p>
<p class="Pp"></p>
<pre>
button .btn -text &quot;Pedigrees&quot; -command [list dog printPedigrees]
pack .btn
</pre>
Alternatively, from a method or type method you can use the <b>mytypemethod</b>
  command, just as you would use <b>mymethod</b> to define a callback command
  for <b>INSTANCE METHODS</b>.
</section>
<section class="Ss">
<h2 class="Ss" id="CAN_TYPE_METHODS_BE_HIERARCHICAL?"><a class="permalink" href="#CAN_TYPE_METHODS_BE_HIERARCHICAL?">CAN
  TYPE METHODS BE HIERARCHICAL?</a></h2>
<p class="Pp">Yes, you can define hierarchical type methods in just the same way
    as you can define hierarchical instance methods. See <b>INSTANCE METHODS</b>
    for more.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="PROCS"><a class="permalink" href="#PROCS">PROCS</a></h1>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_A_PROC?"><a class="permalink" href="#WHAT_IS_A_PROC?">WHAT
  IS A PROC?</a></h2>
<p class="Pp">A Snit <b>proc</b> is really just a Tcl proc defined within the
    type's namespace. You can use procs for private code that isn't related to
    any particular instance.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_I_DEFINE_A_PROC?"><a class="permalink" href="#HOW_DO_I_DEFINE_A_PROC?">HOW
  DO I DEFINE A PROC?</a></h2>
<p class="Pp">Procs are defined by including a <b>proc</b> statement in the type
    definition:</p>
<p class="Pp"></p>
<pre>snit::type mytype {
    # Pops and returns the first item from the list stored in the
    # listvar, updating the listvar
   proc pop {listvar} { ... }
   # ...
}
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="ARE_THERE_ANY_LIMITATIONS_ON_PROC_NAMES?"><a class="permalink" href="#ARE_THERE_ANY_LIMITATIONS_ON_PROC_NAMES?">ARE
  THERE ANY LIMITATIONS ON PROC NAMES?</a></h2>
<p class="Pp">Any name can be used, so long as it does not begin with
    <b>Snit_</b>; names beginning with <b>Snit_</b> are reserved for Snit's own
    use. However, the wise programmer will avoid <b>proc</b> names (<b>set</b>,
    <b>list</b>, <b>if</b>, etc.) that would shadow standard Tcl command
  names.</p>
<p class="Pp"><b>proc</b> names, being private, should begin with a capital
    letter according to convention; however, as there are typically no public
    <b>proc</b>s in the type's namespace it doesn't matter much either way.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DOES_A_METHOD_CALL_A_PROC?"><a class="permalink" href="#HOW_DOES_A_METHOD_CALL_A_PROC?">HOW
  DOES A METHOD CALL A PROC?</a></h2>
<p class="Pp">Just like it calls any Tcl command. For example,</p>
<p class="Pp"></p>
<pre>snit::type mytype {
    # Pops and returns the first item from the list stored in the
    # listvar, updating the listvar
    proc pop {listvar} { ... }
    variable requestQueue {}
    # Get one request from the queue and process it.
    method processRequest {} {
        set req [pop requestQueue]
    }
}
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_CAN_I_PASS_A_PROC_TO_ANOTHER_OBJECT_AS_A_CALLBACK?"><a class="permalink" href="#HOW_CAN_I_PASS_A_PROC_TO_ANOTHER_OBJECT_AS_A_CALLBACK?">HOW
  CAN I PASS A PROC TO ANOTHER OBJECT AS A CALLBACK?</a></h2>
<p class="Pp">The <b>myproc</b> command returns a callback command for the
    <b>proc</b>, just as <b>mymethod</b> does for a method.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TYPE_CONSTRUCTORS"><a class="permalink" href="#TYPE_CONSTRUCTORS">TYPE
  CONSTRUCTORS</a></h1>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_A_TYPE_CONSTRUCTOR?"><a class="permalink" href="#WHAT_IS_A_TYPE_CONSTRUCTOR?">WHAT
  IS A TYPE CONSTRUCTOR?</a></h2>
<p class="Pp">A type constructor is a body of code that initializes the type as
    a whole, rather like a C++ static initializer. The body of a type
    constructor is executed once when the type is defined, and never again.</p>
<p class="Pp">A type can have at most one type constructor.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_I_DEFINE_A_TYPE_CONSTRUCTOR?"><a class="permalink" href="#HOW_DO_I_DEFINE_A_TYPE_CONSTRUCTOR?">HOW
  DO I DEFINE A TYPE CONSTRUCTOR?</a></h2>
<p class="Pp">A type constructor is defined by using the <b>typeconstructor</b>
    statement in the type definition. For example, suppose the type uses an
    array-valued type variable as a look-up table, and the values in the array
    have to be computed at start-up.</p>
<p class="Pp"></p>
<pre>% snit::type mytype {
    typevariable lookupTable
    typeconstructor {
        array set lookupTable {key value...}
    }
}
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CONSTRUCTORS"><a class="permalink" href="#CONSTRUCTORS">CONSTRUCTORS</a></h1>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_A_CONSTRUCTOR?"><a class="permalink" href="#WHAT_IS_A_CONSTRUCTOR?">WHAT
  IS A CONSTRUCTOR?</a></h2>
<p class="Pp">In object-oriented programming, an object's constructor is
    responsible for initializing the object completely at creation time. The
    constructor receives the list of options passed to the <b>snit::type</b>
    command's <b>create</b> method and can then do whatever it likes. That might
    include computing instance variable values, reading data from files,
    creating other objects, updating type and instance variables, and so
  forth.</p>
<p class="Pp">The constructor's return value is ignored (unless it's an error,
    of course).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_I_DEFINE_A_CONSTRUCTOR?"><a class="permalink" href="#HOW_DO_I_DEFINE_A_CONSTRUCTOR?">HOW
  DO I DEFINE A CONSTRUCTOR?</a></h2>
<p class="Pp">A constructor is defined by using the <b>constructor</b> statement
    in the type definition. Suppose that it's desired to keep a list of all
    pedigreed dogs. The list can be maintained in a type variable and retrieved
    by a type method. Whenever a dog is created, it can add itself to the
    list--provided that it's registered with the American Kennel Club.</p>
<p class="Pp"></p>
<pre>% snit::type dog {
    option -akc 0
    typevariable akcList {}
    constructor {args} {
        $self configurelist $args
        if {$options(-akc)} {
            lappend akcList $self
        }
    }
    typemethod akclist {} {
        return $akcList
    }
}
::dog
% dog spot -akc 1
::spot
% dog fido
::fido
% dog akclist
::spot
%
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="WHAT_DOES_THE_DEFAULT_CONSTRUCTOR_DO?"><a class="permalink" href="#WHAT_DOES_THE_DEFAULT_CONSTRUCTOR_DO?">WHAT
  DOES THE DEFAULT CONSTRUCTOR DO?</a></h2>
<p class="Pp">If you don't provide a constructor explicitly, you get the default
    constructor, which is identical to the explicitly-defined constructor shown
    here:</p>
<p class="Pp"></p>
<pre>snit::type dog {
    constructor {args} {
        $self configurelist $args
    }
}
</pre>
<p class="Pp">When the constructor is called, <b>args</b> will be set to the
    list of arguments that follow the object's name. The constructor is allowed
    to interpret this list any way it chooses; the normal convention is to
    assume that it's a list of option names and values, as shown in the example
    above. If you simply want to save the option values, you should use the
    <b>configurelist</b> method, as shown.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="CAN_I_CHOOSE_A_DIFFERENT_SET_OF_ARGUMENTS_FOR_THE_CONSTRUCTOR?"><a class="permalink" href="#CAN_I_CHOOSE_A_DIFFERENT_SET_OF_ARGUMENTS_FOR_THE_CONSTRUCTOR?">CAN
  I CHOOSE A DIFFERENT SET OF ARGUMENTS FOR THE CONSTRUCTOR?</a></h2>
<p class="Pp">Yes, you can. For example, suppose we wanted to be sure that the
    breed was explicitly stated for every dog at creation time, and couldn't be
    changed thereafter. One way to do that is as follows:</p>
<p class="Pp"></p>
<pre>% snit::type dog {
    variable breed
    option -color brown
    option -akc 0
    constructor {theBreed args} {
        set breed $theBreed
        $self configurelist $args
    }
    method breed {} { return $breed }
}
::dog
% dog spot dalmatian -color spotted -akc 1
::spot
% spot breed
dalmatian
</pre>
<p class="Pp">The drawback is that this syntax is non-standard, and may limit
    the compatibility of your new type with other people's code. For example,
    Snit assumes that it can create <b>COMPONENTS</b> using the standard
    creation syntax.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ARE_THERE_ANY_LIMITATIONS_ON_CONSTRUCTOR_ARGUMENTS?"><a class="permalink" href="#ARE_THERE_ANY_LIMITATIONS_ON_CONSTRUCTOR_ARGUMENTS?">ARE
  THERE ANY LIMITATIONS ON CONSTRUCTOR ARGUMENTS?</a></h2>
<p class="Pp">Constructor argument lists are subject to the same limitations as
    those on instance method argument lists. It has the same implicit arguments,
    and can contain default values and the <b>args</b> argument.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="IS_THERE_ANYTHING_SPECIAL_ABOUT_WRITING_THE_CONSTRUCTOR?"><a class="permalink" href="#IS_THERE_ANYTHING_SPECIAL_ABOUT_WRITING_THE_CONSTRUCTOR?">IS
  THERE ANYTHING SPECIAL ABOUT WRITING THE CONSTRUCTOR?</a></h2>
<p class="Pp">Yes. Writing the constructor can be tricky if you're delegating
    options to components, and there are specific issues relating to
    <b>snit::widget</b>s and <b>snit::widgetadaptor</b>s. See <b>DELEGATION</b>,
    <b>WIDGETS</b>, <b>WIDGET ADAPTORS</b>, and <b>THE TK OPTION
  DATABASE</b>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DESTRUCTORS"><a class="permalink" href="#DESTRUCTORS">DESTRUCTORS</a></h1>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_A_DESTRUCTOR?"><a class="permalink" href="#WHAT_IS_A_DESTRUCTOR?">WHAT
  IS A DESTRUCTOR?</a></h2>
<p class="Pp">A destructor is a special kind of method that's called when an
    object is destroyed. It's responsible for doing any necessary clean-up when
    the object goes away: destroying <b>COMPONENTS</b>, closing files, and so
    forth.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_I_DEFINE_A_DESTRUCTOR?"><a class="permalink" href="#HOW_DO_I_DEFINE_A_DESTRUCTOR?">HOW
  DO I DEFINE A DESTRUCTOR?</a></h2>
<p class="Pp">Destructors are defined by using the <b>destructor</b> statement
    in the type definition.</p>
<p class="Pp">Suppose we're maintaining a list of pedigreed dogs; then we'll
    want to remove dogs from it when they are destroyed.</p>
<p class="Pp"></p>
<pre>snit::type dog {
    option -akc 0
    typevariable akcList {}
    constructor {args} {
        $self configurelist $args
        if {$options(-akc)} {
            lappend akcList $self
        }
    }
    destructor {
        set ndx [lsearch $akcList $self]
        if {$ndx != -1} {
            set akcList [lreplace $akcList $ndx $ndx]
        }
    }
    typemethod akclist {} {
        return $akcList
    }
}
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="ARE_THERE_ANY_LIMITATIONS_ON_DESTRUCTOR_ARGUMENTS?"><a class="permalink" href="#ARE_THERE_ANY_LIMITATIONS_ON_DESTRUCTOR_ARGUMENTS?">ARE
  THERE ANY LIMITATIONS ON DESTRUCTOR ARGUMENTS?</a></h2>
<p class="Pp">Yes; a destructor has no explicit arguments.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="WHAT_IMPLICIT_ARGUMENTS_ARE_PASSED_TO_THE_DESTRUCTOR?"><a class="permalink" href="#WHAT_IMPLICIT_ARGUMENTS_ARE_PASSED_TO_THE_DESTRUCTOR?">WHAT
  IMPLICIT ARGUMENTS ARE PASSED TO THE DESTRUCTOR?</a></h2>
<p class="Pp">The destructor gets the same implicit arguments that are passed to
    <b>INSTANCE METHODS</b>: <b>type</b>, <b>selfns</b>, <b>win</b>, and
    <b>self</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="MUST_COMPONENTS_BE_DESTROYED_EXPLICITLY?"><a class="permalink" href="#MUST_COMPONENTS_BE_DESTROYED_EXPLICITLY?">MUST
  COMPONENTS BE DESTROYED EXPLICITLY?</a></h2>
<p class="Pp">Yes and no.</p>
<p class="Pp">Any Tk widgets created by a <b>snit::widget</b> or
    <b>snit::widgetadaptor</b> will be destroyed automatically by Tk when the
    megawidget is destroyed, in keeping with normal Tk behavior (destroying a
    parent widget destroys the whole tree).</p>
<p class="Pp">Components of normal <b>snit::types</b>, on the other hand, are
    never destroyed automatically, nor are non-widget components of Snit
    megawidgets. If your object creates them in its constructor, then it should
    generally destroy them in its destructor.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="IS_THERE_ANY_SPECIAL_ABOUT_WRITING_A_DESTRUCTOR?"><a class="permalink" href="#IS_THERE_ANY_SPECIAL_ABOUT_WRITING_A_DESTRUCTOR?">IS
  THERE ANY SPECIAL ABOUT WRITING A DESTRUCTOR?</a></h2>
<p class="Pp">Yes. If an object's constructor throws an error, the object's
    destructor will be called to clean up; this means that the object might not
    be completely constructed when the destructor is called. This can cause the
    destructor to throw its own error; the result is usually misleading,
    confusing, and unhelpful. Consequently, it's important to write your
    destructor so that it's fail-safe.</p>
<p class="Pp">For example, a <b>dog</b> might create a <b>tail</b> component;
    the component will need to be destroyed. But suppose there's an error while
    processing the creation options--the destructor will be called, and there
    will be no <b>tail</b> to destroy. The simplest solution is generally to
    catch and ignore any errors while destroying components.</p>
<pre>snit::type dog {
    component tail
    constructor {args} {
        $self configurelist $args
        set tail [tail %AUTO%]
    }
    destructor {
        catch {$tail destroy}
    }
}
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="COMPONENTS"><a class="permalink" href="#COMPONENTS">COMPONENTS</a></h1>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_A_COMPONENT?"><a class="permalink" href="#WHAT_IS_A_COMPONENT?">WHAT
  IS A COMPONENT?</a></h2>
<p class="Pp">Often an object will create and manage a number of other objects.
    A Snit megawidget, for example, will often create a number of Tk widgets.
    These objects are part of the main object; it is composed of them, so they
    are called components of the object.</p>
<p class="Pp">But Snit also has a more precise meaning for <b>COMPONENT</b>. The
    components of a Snit object are those objects to which methods or options
    can be delegated. (See <b>DELEGATION</b> for more information about
    delegation.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_I_DECLARE_A_COMPONENT?"><a class="permalink" href="#HOW_DO_I_DECLARE_A_COMPONENT?">HOW
  DO I DECLARE A COMPONENT?</a></h2>
<p class="Pp">First, you must decide what role a component plays within your
    object, and give the role a name. Then, you declare the component using its
    role name and the <b>component</b> statement. The <b>component</b> statement
    declares an <i>instance variable</i> which is used to store the component's
    command name when the component is created.</p>
<p class="Pp">For example, suppose your <b>dog</b> object creates a <b>tail</b>
    object (the better to wag with, no doubt):</p>
<p class="Pp"></p>
<pre>snit::type dog {
    component mytail
    constructor {args} {
        # Create and save the component's command
        set mytail [tail %AUTO% -partof $self]
        $self configurelist $args
    }
    method wag {} {
        $mytail wag
    }
}
</pre>
<p class="Pp">As shown here, it doesn't matter what the <b>tail</b> object's
    real name is; the <b>dog</b> object refers to it by its component name.</p>
<p class="Pp">The above example shows one way to delegate the <b>wag</b> method
    to the <b>mytail</b> component; see <b>DELEGATION</b> for an easier way.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_IS_A_COMPONENT_NAMED?"><a class="permalink" href="#HOW_IS_A_COMPONENT_NAMED?">HOW
  IS A COMPONENT NAMED?</a></h2>
<p class="Pp">A component has two names. The first name is that of the component
    variable; this represents the role the component object plays within the
    Snit object. This is the component name proper, and is the name used to
    refer to the component within Snit code. The second name is the name of the
    actual component object created by the Snit object's constructor. This
    second name is always a Tcl command name, and is referred to as the
    component's object name.</p>
<p class="Pp">In the example in the previous question, the component name is
    <b>mytail</b>; the <b>mytail</b> component's object name is chosen
    automatically by Snit since <b>%AUTO%</b> was used when the component object
    was created.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ARE_THERE_ANY_LIMITATIONS_ON_COMPONENT_NAMES?"><a class="permalink" href="#ARE_THERE_ANY_LIMITATIONS_ON_COMPONENT_NAMES?">ARE
  THERE ANY LIMITATIONS ON COMPONENT NAMES?</a></h2>
<p class="Pp">Yes. <b>snit::widget</b> and <b>snit::widgetadaptor</b> objects
    have a special component called the <b>hull</b> component; thus, the name
    <b>hull</b> should be used for no other purpose.</p>
<p class="Pp">Otherwise, since component names are in fact instance variable
    names they must follow the rules for <b>INSTANCE VARIABLES</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_AN_OWNED_COMPONENT?"><a class="permalink" href="#WHAT_IS_AN_OWNED_COMPONENT?">WHAT
  IS AN OWNED COMPONENT?</a></h2>
<p class="Pp">An <i>owned</i> component is a component whose object command's
    lifetime is controlled by the <b>snit::type</b> or <b>snit::widget</b>.</p>
<p class="Pp">As stated above, a component is an object to which our object can
    delegate methods or options. Under this definition, our object will usually
    create its component objects, but not necessarily. Consider the following: a
    dog object has a tail component; but tail knows that it's part of the
  dog:</p>
<pre>snit::type dog {
    component mytail
    constructor {args} {
        set mytail [tail %AUTO% -partof $self]
        $self configurelist $args
    }
    destructor {
        catch {$mytail destroy}
    }
    delegate method wagtail to mytail as wag
    method bark {} {
        return &quot;$self barked.&quot;
    }
}
 snit::type tail {
     component mydog
     option -partof -readonly yes
     constructor {args} {
         $self configurelist $args
         set mydog $options(-partof)
     }
     method wag {} {
         return &quot;Wag, wag.&quot;
     }
     method pull {} {
         $mydog bark
     }
 }
</pre>
Thus, if you ask a dog to wag its tail, it tells its tail to wag; and if you
  pull the dog's tail, the tail tells the dog to bark. In this scenario, the
  tail is a component of the dog, and the dog is a component of the tail, but
  the dog owns the tail and not the other way around.
</section>
<section class="Ss">
<h2 class="Ss" id="WHAT_DOES_THE_INSTALL_COMMAND_DO?"><a class="permalink" href="#WHAT_DOES_THE_INSTALL_COMMAND_DO?">WHAT
  DOES THE INSTALL COMMAND DO?</a></h2>
<p class="Pp">The <b>install</b> command creates an owned component using a
    specified command, and assigns the result to the component's instance
    variable. For example:</p>
<pre>snit::type dog {
    component mytail
    constructor {args} {
        # set mytail [tail %AUTO% -partof $self]
        install mytail using tail %AUTO% -partof $self
        $self configurelist $args
    }
}
</pre>
<p class="Pp">In a <b>snit::type</b>'s code, the <b>install</b> command shown
    above is equivalent to the <b>set mytail</b> command that's commented out.
    In a <b>snit::widget</b>'s or <b>snit::widgetadaptor</b>'s, code, however,
    the <b>install</b> command also queries <b>THE TK OPTION DATABASE</b> and
    initializes the new component's options accordingly. For consistency, it's a
    good idea to get in the habit of using <b>install</b> for all owned
    components.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="MUST_OWNED_COMPONENTS_BE_CREATED_IN_THE_CONSTRUCTOR?"><a class="permalink" href="#MUST_OWNED_COMPONENTS_BE_CREATED_IN_THE_CONSTRUCTOR?">MUST
  OWNED COMPONENTS BE CREATED IN THE CONSTRUCTOR?</a></h2>
<p class="Pp">No, not necessarily. In fact, there's no reason why an object
    can't destroy and recreate a component multiple times over its own
  lifetime.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ARE_THERE_ANY_LIMITATIONS_ON_COMPONENT_OBJECT_NAMES?"><a class="permalink" href="#ARE_THERE_ANY_LIMITATIONS_ON_COMPONENT_OBJECT_NAMES?">ARE
  THERE ANY LIMITATIONS ON COMPONENT OBJECT NAMES?</a></h2>
<p class="Pp">Yes.</p>
<p class="Pp">Component objects which are Tk widgets or megawidgets must have
    valid Tk window names.</p>
<p class="Pp">Component objects which are not widgets or megawidgets must have
    fully-qualified command names, i.e., names which include the full namespace
    of the command. Note that Snit always creates objects with fully qualified
    names.</p>
<p class="Pp">Next, the object names of components and owned by your object must
    be unique. This is no problem for widget components, since widget names are
    always unique; but consider the following code:</p>
<p class="Pp"></p>
<pre>snit::type tail { ... }
snit::type dog {
    delegate method wag to mytail
    constructor {} {
        install mytail using tail mytail
    }
}
</pre>
<p class="Pp">This code uses the component name, <b>mytail</b>, as the component
    object name. This is not good, and here's why: Snit instance code executes
    in the Snit type's namespace. In this case, the <b>mytail</b> component is
    created in the <b>::dog::</b> namespace, and will thus have the name
    <b>::dog::mytail</b>.</p>
<p class="Pp">Now, suppose you create two dogs. Both dogs will attempt to create
    a tail called <b>::dog::mytail</b>. The first will succeed, and the second
    will fail, since Snit won't let you create an object if its name is already
    a command. Here are two ways to avoid this situation:</p>
<p class="Pp">First, if the component type is a <b>snit::type</b> you can
    specify <b>%AUTO%</b> as its name, and be guaranteed to get a unique name.
    This is the safest thing to do:</p>
<p class="Pp"></p>
<pre>
    install mytail using tail %AUTO%
</pre>
<p class="Pp">If the component type isn't a <b>snit::type</b> you can create the
    component in the object's instance namespace:</p>
<p class="Pp"></p>
<pre>
    install mytail using tail ${selfns}::mytail
</pre>
<p class="Pp">Make sure you pick a unique name within the instance
  namespace.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="MUST_I_DESTROY_THE_COMPONENTS_I_OWN?"><a class="permalink" href="#MUST_I_DESTROY_THE_COMPONENTS_I_OWN?">MUST
  I DESTROY THE COMPONENTS I OWN?</a></h2>
<p class="Pp">That depends. When a parent widget is destroyed, all child widgets
    are destroyed automatically. Thus, if your object is a <b>snit::widget</b>
    or <b>snit::widgetadaptor</b> you don't need to destroy any components that
    are widgets, because they will generally be children or descendants of your
    megawidget.</p>
<p class="Pp">If your object is an instance of <b>snit::type</b>, though, none
    of its owned components will be destroyed automatically, nor will be
    non-widget components of a <b>snit::widget</b> be destroyed automatically.
    All such owned components must be destroyed explicitly, or they won't be
    destroyed at all.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="CAN_I_EXPOSE_A_COMPONENT'S_OBJECT_COMMAND_AS_PART_OF_MY_INTERFACE?"><a class="permalink" href="#CAN_I_EXPOSE_A_COMPONENT'S_OBJECT_COMMAND_AS_PART_OF_MY_INTERFACE?">CAN
  I EXPOSE A COMPONENT'S OBJECT COMMAND AS PART OF MY INTERFACE?</a></h2>
<p class="Pp">Yes, and there are two ways to do it. The most appropriate way is
    usually to use <b>DELEGATION</b>. Delegation allows you to pass the options
    and methods you specify along to particular components. This effectively
    hides the components from the users of your type, and ensures good
    encapsulation.</p>
<p class="Pp">However, there are times when it's appropriate, not to mention
    simpler, just to make the entire component part of your type's public
    interface.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_I_EXPOSE_A_COMPONENT'S_OBJECT_COMMAND?"><a class="permalink" href="#HOW_DO_I_EXPOSE_A_COMPONENT'S_OBJECT_COMMAND?">HOW
  DO I EXPOSE A COMPONENT'S OBJECT COMMAND?</a></h2>
<p class="Pp">When you declare the component, specify the <b>component</b>
    statement's <b>-public</b> option. The value of this option is the name of a
    method which will be delegated to your component's object command.</p>
<p class="Pp">For example, supposed you've written a combobox megawidget which
    owns a listbox widget, and you want to make the listbox's entire interface
    public. You can do it like this:</p>
<p class="Pp"></p>
<pre>snit::widget combobox {
     component listbox -public listbox
     constructor {args} {
         install listbox using listbox $win.listbox ....
     }
}
combobox .mycombo
</pre>
<p class="Pp">Your comobox widget, <b>.mycombo</b>, now has a <b>listbox</b>
    method which has all of the same subcommands as the listbox widget itself.
    Thus, the above code sets the listbox component's width to 30.</p>
<p class="Pp">Usually you'll let the method name be the same as the component
    name; however, you can name it anything you like.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TYPE_COMPONENTS"><a class="permalink" href="#TYPE_COMPONENTS">TYPE
  COMPONENTS</a></h1>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_A_TYPE_COMPONENT?"><a class="permalink" href="#WHAT_IS_A_TYPE_COMPONENT?">WHAT
  IS A TYPE COMPONENT?</a></h2>
<p class="Pp">A type component is a component that belongs to the type itself
    instead of to a particular instance of the type. The relationship between
    components and type components is the same as the relationship between
    <b>INSTANCE VARIABLES</b> and <b>TYPE VARIABLES</b>. Both <b>INSTANCE
    METHODS</b> and <b>TYPE METHODS</b> can be delegated to type components.</p>
<p class="Pp">Once you understand <b>COMPONENTS</b> and <b>DELEGATION</b>, type
    components are just more of the same.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_I_DECLARE_A_TYPE_COMPONENT?"><a class="permalink" href="#HOW_DO_I_DECLARE_A_TYPE_COMPONENT?">HOW
  DO I DECLARE A TYPE COMPONENT?</a></h2>
<p class="Pp">Declare a type component using the <b>typecomponent</b> statement.
    It takes the same options (<b>-inherit</b> and <b>-public</b>) as the
    <b>component</b> statement does, and defines a type variable to hold the
    type component's object command.</p>
<p class="Pp">Suppose in your model you've got many dogs, but only one
    veterinarian. You might make the veterinarian a type component.</p>
<pre>snit::type veterinarian { ... }
snit::type dog {
    typecomponent vet
    # ...
}
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_I_INSTALL_A_TYPE_COMPONENT?"><a class="permalink" href="#HOW_DO_I_INSTALL_A_TYPE_COMPONENT?">HOW
  DO I INSTALL A TYPE COMPONENT?</a></h2>
<p class="Pp">Just use the <b>set</b> command to assign the component's object
    command to the type component. Because types (even <b>snit::widget</b>
    types) are not widgets, and do not have options anyway, the extra features
    of the <b>install</b> command are not needed.</p>
<p class="Pp">You'll usually install type components in the type constructor, as
    shown here:</p>
<pre>snit::type veterinarian { ... }
snit::type dog {
    typecomponent vet
    typeconstructor {
        set vet [veterinarian %AUTO%]
    }
}
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="ARE_THERE_ANY_LIMITATIONS_ON_TYPE_COMPONENT_NAMES?"><a class="permalink" href="#ARE_THERE_ANY_LIMITATIONS_ON_TYPE_COMPONENT_NAMES?">ARE
  THERE ANY LIMITATIONS ON TYPE COMPONENT NAMES?</a></h2>
<p class="Pp">Yes, the same as on <b>INSTANCE VARIABLES</b>, <b>TYPE
    VARIABLES</b>, and normal <b>COMPONENTS</b>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DELEGATION"><a class="permalink" href="#DELEGATION">DELEGATION</a></h1>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_DELEGATION?"><a class="permalink" href="#WHAT_IS_DELEGATION?">WHAT
  IS DELEGATION?</a></h2>
<p class="Pp">Delegation, simply put, is when you pass a task you've been given
    to one of your assistants. (You do have assistants, don't you?) Snit objects
    can do the same thing. The following example shows one way in which the
    <b>dog</b> object can delegate its <b>wag</b> method and its
    <b>-taillength</b> option to its <b>tail</b> component.</p>
<p class="Pp"></p>
<pre>snit::type dog {
    variable mytail
    option -taillength -configuremethod SetTailOption -cgetmethod GetTailOption
    method SetTailOption {option value} {
         $mytail configure $option $value
    }
    method GetTailOption {option} {
         $mytail cget $option
    }
    method wag {} {
        $mytail wag
    }
    constructor {args} {
        install mytail using tail %AUTO% -partof $self
        $self configurelist $args
    }
}
</pre>
<p class="Pp">This is the hard way to do it, by it demonstrates what delegation
    is all about. See the following answers for the easy way to do it.</p>
<p class="Pp">Note that the constructor calls the <b>configurelist</b> method
    <b>after</b> it creates its <b>tail</b>; otherwise, if <b>-taillength</b>
    appeared in the list of <b>args</b> we'd get an error.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_CAN_I_DELEGATE_A_METHOD_TO_A_COMPONENT_OBJECT?"><a class="permalink" href="#HOW_CAN_I_DELEGATE_A_METHOD_TO_A_COMPONENT_OBJECT?">HOW
  CAN I DELEGATE A METHOD TO A COMPONENT OBJECT?</a></h2>
<p class="Pp">Delegation occurs frequently enough that Snit makes it easy. Any
    method can be delegated to any component or type component by placing a
    single <b>delegate</b> statement in the type definition. (See
    <b>COMPONENTS</b> and <b>TYPE COMPONENTS</b> for more information about
    component names.)</p>
<p class="Pp">For example, here's a much better way to delegate the <b>dog</b>
    object's <b>wag</b> method:</p>
<p class="Pp"></p>
<pre>% snit::type dog {
    delegate method wag to mytail
    constructor {} {
        install mytail using tail %AUTO%
    }
}
::dog
% snit::type tail {
    method wag {} { return &quot;Wag, wag, wag.&quot;}
}
::tail
% dog spot
::spot
% spot wag
Wag, wag, wag.
</pre>
<p class="Pp">This code has the same effect as the code shown under the previous
    question: when a <b>dog</b>'s <b>wag</b> method is called, the call and its
    arguments are passed along automatically to the <b>tail</b> object.</p>
<p class="Pp">Note that when a component is mentioned in a <b>delegate</b>
    statement, the component's instance variable is defined implicitly. However,
    it's still good practice to declare it explicitly using the <b>component</b>
    statement.</p>
<p class="Pp">Note also that you can define a method name using the
    <b>method</b> statement, or you can define it using <b>delegate</b>; you
    can't do both.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="CAN_I_DELEGATE_TO_A_METHOD_WITH_A_DIFFERENT_NAME?"><a class="permalink" href="#CAN_I_DELEGATE_TO_A_METHOD_WITH_A_DIFFERENT_NAME?">CAN
  I DELEGATE TO A METHOD WITH A DIFFERENT NAME?</a></h2>
<p class="Pp">Suppose you wanted to delegate the <b>dog</b>'s <b>wagtail</b>
    method to the <b>tail</b>'s <b>wag</b> method. After all you wag the tail,
    not the dog. It's easily done:</p>
<p class="Pp"></p>
<pre>snit::type dog {
    delegate method wagtail to mytail as wag
    constructor {args} {
        install mytail using tail %AUTO% -partof $self
        $self configurelist $args
    }
}
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="CAN_I_DELEGATE_TO_A_METHOD_WITH_ADDITIONAL_ARGUMENTS?"><a class="permalink" href="#CAN_I_DELEGATE_TO_A_METHOD_WITH_ADDITIONAL_ARGUMENTS?">CAN
  I DELEGATE TO A METHOD WITH ADDITIONAL ARGUMENTS?</a></h2>
<p class="Pp">Suppose the <b>tail</b>'s <b>wag</b> method takes as an argument
    the number of times the tail should be wagged. You want to delegate the
    <b>dog</b>'s <b>wagtail</b> method to the <b>tail</b>'s <b>wag</b> method,
    specifying that the tail should be wagged exactly three times. This is
    easily done, too:</p>
<p class="Pp"></p>
<pre>snit::type dog {
    delegate method wagtail to mytail as {wag 3}
    # ...
}
snit::type tail {
    method wag {count} {
        return [string repeat &quot;Wag &quot; $count]
    }
    # ...
}
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="CAN_I_DELEGATE_A_METHOD_TO_SOMETHING_OTHER_THAN_AN_OBJECT?"><a class="permalink" href="#CAN_I_DELEGATE_A_METHOD_TO_SOMETHING_OTHER_THAN_AN_OBJECT?">CAN
  I DELEGATE A METHOD TO SOMETHING OTHER THAN AN OBJECT?</a></h2>
<p class="Pp">Normal method delegation assumes that you're delegating a method
    (a subcommand of an object command) to a method of another object (a
    subcommand of a different object command). But not all Tcl objects follow Tk
    conventions, and not everything you'd to which you'd like to delegate a
    method is necessary an object. Consequently, Snit makes it easy to delegate
    a method to pretty much anything you like using the <b>delegate</b>
    statement's <b>using</b> clause.</p>
<p class="Pp">Suppose your dog simulation stores dogs in a database, each dog as
    a single record. The database API you're using provides a number of commands
    to manage records; each takes the record ID (a string you choose) as its
    first argument. For example, <b>saverec</b> saves a record. If you let the
    record ID be the name of the dog object, you can delegate the dog's
    <b>save</b> method to the <b>saverec</b> command as follows:</p>
<pre>snit::type dog {
    delegate method save using {saverec %s}
}
</pre>
The <b>%s</b> is replaced with the instance name when the <b>save</b> method is
  called; any additional arguments are the appended to the resulting command.
<p class="Pp">The <b>using</b> clause understands a number of other
    %-conversions; in addition to the instance name, you can substitute in the
    method name (<b>%m</b>), the type name (<b>%t</b>), the instance namespace
    (<b>%n</b>), the Tk window name (<b>%w</b>), and, if a component or
    typecomponent name was given in the <b>delegate</b> statement, the
    component's object command (<b>%c</b>).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_CAN_I_DELEGATE_A_METHOD_TO_A_TYPE_COMPONENT_OBJECT?"><a class="permalink" href="#HOW_CAN_I_DELEGATE_A_METHOD_TO_A_TYPE_COMPONENT_OBJECT?">HOW
  CAN I DELEGATE A METHOD TO A TYPE COMPONENT OBJECT?</a></h2>
<p class="Pp">Just exactly as you would to a component object. The <b>delegate
    method</b> statement accepts both component and type component names in its
    <b>to</b> clause.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_CAN_I_DELEGATE_A_TYPE_METHOD_TO_A_TYPE_COMPONENT_OBJECT?"><a class="permalink" href="#HOW_CAN_I_DELEGATE_A_TYPE_METHOD_TO_A_TYPE_COMPONENT_OBJECT?">HOW
  CAN I DELEGATE A TYPE METHOD TO A TYPE COMPONENT OBJECT?</a></h2>
<p class="Pp">Use the <b>delegate typemethod</b> statement. It works like
    <b>delegate method</b>, with these differences: first, it defines a type
    method instead of an instance method; second, the <b>using</b> clause
    ignores the <b>%s</b>, <b>%n</b>, and <b>%w</b> %-conversions.</p>
<p class="Pp">Naturally, you can't delegate a type method to an instance
    component...Snit wouldn't know which instance should receive it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_CAN_I_DELEGATE_AN_OPTION_TO_A_COMPONENT_OBJECT?"><a class="permalink" href="#HOW_CAN_I_DELEGATE_AN_OPTION_TO_A_COMPONENT_OBJECT?">HOW
  CAN I DELEGATE AN OPTION TO A COMPONENT OBJECT?</a></h2>
<p class="Pp">The first question in this section (see <b>DELEGATION</b>) shows
    one way to delegate an option to a component; but this pattern occurs often
    enough that Snit makes it easy. For example, every <b>tail</b> object has a
    <b>-length</b> option; we want to allow the creator of a <b>dog</b> object
    to set the tail's length. We can do this:</p>
<p class="Pp"></p>
<pre>% snit::type dog {
    delegate option -length to mytail
    constructor {args} {
        install mytail using tail %AUTO% -partof $self
        $self configurelist $args
    }
}
::dog
% snit::type tail {
    option -partof
    option -length 5
}
::tail
% dog spot -length 7
::spot
% spot cget -length
7
</pre>
<p class="Pp">This produces nearly the same result as the
    <b>-configuremethod</b> and <b>-cgetmethod</b> shown under the first
    question in this section: whenever a <b>dog</b> object's <b>-length</b>
    option is set or retrieved, the underlying <b>tail</b> object's option is
    set or retrieved in turn.</p>
<p class="Pp">Note that you can define an option name using the <b>option</b>
    statement, or you can define it using <b>delegate</b>; you can't do
  both.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="CAN_I_DELEGATE_TO_AN_OPTION_WITH_A_DIFFERENT_NAME?"><a class="permalink" href="#CAN_I_DELEGATE_TO_AN_OPTION_WITH_A_DIFFERENT_NAME?">CAN
  I DELEGATE TO AN OPTION WITH A DIFFERENT NAME?</a></h2>
<p class="Pp">In the previous answer we delegated the <b>dog</b>'s
    <b>-length</b> option down to its <b>tail</b>. This is, of course, wrong.
    The dog has a length, and the tail has a length, and they are different.
    What we'd really like to do is give the <b>dog</b> a <b>-taillength</b>
    option, but delegate it to the <b>tail</b>'s <b>-length</b> option:</p>
<p class="Pp"></p>
<pre>snit::type dog {
    delegate option -taillength to mytail as -length
    constructor {args} {
        set mytail [tail %AUTO% -partof $self]
        $self configurelist $args
    }
}
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_CAN_I_DELEGATE_ANY_UNRECOGNIZED_METHOD_OR_OPTION_TO_A_COMPONENT_OBJECT?"><a class="permalink" href="#HOW_CAN_I_DELEGATE_ANY_UNRECOGNIZED_METHOD_OR_OPTION_TO_A_COMPONENT_OBJECT?">HOW
  CAN I DELEGATE ANY UNRECOGNIZED METHOD OR OPTION TO A COMPONENT
  OBJECT?</a></h2>
<p class="Pp">It may happen that a Snit object gets most of its behavior from
    one of its components. This often happens with <b>snit::widgetadaptors</b>,
    for example, where we wish to slightly the modify the behavior of an
    existing widget. To carry on with our <b>dog</b> example, however, suppose
    that we have a <b>snit::type</b> called <b>animal</b> that implements a
    variety of animal behaviors--moving, eating, sleeping, and so forth. We want
    our <b>dog</b> objects to inherit these same behaviors, while adding
    dog-like behaviors of its own. Here's how we can give a <b>dog</b> methods
    and options of its own while delegating all other methods and options to its
    <b>animal</b> component:</p>
<p class="Pp"></p>
<pre>snit::type dog {
    delegate option * to animal
    delegate method * to animal
    option -akc 0
    constructor {args} {
        install animal using animal %AUTO% -name $self
        $self configurelist $args
    }
    method wag {} {
        return &quot;$self wags its tail&quot;
    }
}
</pre>
<p class="Pp">That's it. A <b>dog</b> is now an <b>animal</b> that has a
    <b>-akc</b> option and can <b>wag</b> its tail.</p>
<p class="Pp">Note that we don't need to specify the full list of method names
    or option names that <b>animal</b> will receive. It gets anything <b>dog</b>
    doesn't recognize--and if it doesn't recognize it either, it will simply
    throw an error, just as it should.</p>
<p class="Pp">You can also delegate all unknown type methods to a type component
    using <b>delegate typemethod *</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_CAN_I_DELEGATE_ALL_BUT_CERTAIN_METHODS_OR_OPTIONS_TO_A_COMPONENT?"><a class="permalink" href="#HOW_CAN_I_DELEGATE_ALL_BUT_CERTAIN_METHODS_OR_OPTIONS_TO_A_COMPONENT?">HOW
  CAN I DELEGATE ALL BUT CERTAIN METHODS OR OPTIONS TO A COMPONENT?</a></h2>
<p class="Pp">In the previous answer, we said that every <b>dog</b> is an
    <b>animal</b> by delegating all unknown methods and options to the
    <b>animal</b> component. But what if the <b>animal</b> type has some methods
    or options that we'd like to suppress?</p>
<p class="Pp">One solution is to explicitly delegate all the options and
    methods, and forgo the convenience of <b>delegate method *</b> and
    <b>delegate option *</b>. But if we wish to suppress only a few options or
    methods, there's an easier way:</p>
<p class="Pp"></p>
<pre>snit::type dog {
    delegate option * to animal except -numlegs
    delegate method * to animal except {fly climb}
    # ...
    constructor {args} {
        install animal using animal %AUTO% -name $self -numlegs 4
        $self configurelist $args
    }
    # ...
}
</pre>
<p class="Pp">Dogs have four legs, so we specify that explicitly when we create
    the <b>animal</b> component, and explicitly exclude <b>-numlegs</b> from the
    set of delegated options. Similarly, dogs can neither <b>fly</b> nor
    <b>climb</b>, so we exclude those <b>animal</b> methods as shown.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="CAN_A_HIERARCHICAL_METHOD_BE_DELEGATED?"><a class="permalink" href="#CAN_A_HIERARCHICAL_METHOD_BE_DELEGATED?">CAN
  A HIERARCHICAL METHOD BE DELEGATED?</a></h2>
<p class="Pp">Yes; just specify multiple words in the delegated method's
  name:</p>
<p class="Pp"></p>
<pre>snit::type tail {
    method wag {} {return &quot;Wag, wag&quot;}
    method droop {} {return &quot;Droop, droop&quot;}
}
snit::type dog {
    delegate method {tail wag} to mytail
    delegate method {tail droop} to mytail
    # ...
    constructor {args} {
        install mytail using tail %AUTO%
        $self configurelist $args
    }
    # ...
}
</pre>
<p class="Pp">Unrecognized hierarchical methods can also be delegated; the
    following code delegates all subcommands of the &quot;tail&quot; method to
    the &quot;mytail&quot; component:</p>
<p class="Pp"></p>
<pre>snit::type dog {
    delegate method {tail *} to mytail
    # ...
}
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="WIDGETS"><a class="permalink" href="#WIDGETS">WIDGETS</a></h1>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_A_SNIT::WIDGET?"><a class="permalink" href="#WHAT_IS_A_SNIT::WIDGET?">WHAT
  IS A SNIT::WIDGET?</a></h2>
<p class="Pp">A <b>snit::widget</b> is the Snit version of what Tcl programmers
    usually call a <i>megawidget</i>: a widget-like object usually consisting of
    one or more Tk widgets all contained within a Tk frame.</p>
<p class="Pp">A <b>snit::widget</b> is also a special kind of <b>snit::type</b>.
    Just about everything in this FAQ list that relates to <b>snit::types</b>
    also applies to <b>snit::widgets</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_I_DEFINE_A_SNIT::WIDGET?"><a class="permalink" href="#HOW_DO_I_DEFINE_A_SNIT::WIDGET?">HOW
  DO I DEFINE A SNIT::WIDGET?</a></h2>
<p class="Pp"><b>snit::widgets</b> are defined using the <b>snit::widget</b>
    command, just as <b>snit::types</b> are defined by the <b>snit::type</b>
    command.</p>
<p class="Pp">The body of the definition can contain all of the same kinds of
    statements, plus a couple of others which will be mentioned below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_SNIT::WIDGETS_DIFFER_FROM_SNIT::TYPES?"><a class="permalink" href="#HOW_DO_SNIT::WIDGETS_DIFFER_FROM_SNIT::TYPES?">HOW
  DO SNIT::WIDGETS DIFFER FROM SNIT::TYPES?</a></h2>
<ul class="Bl-bullet">
  <li>The name of an instance of a <b>snit::type</b> can be any valid Tcl
      command name, in any namespace. The name of an instance of a
      <b>snit::widget</b> must be a valid Tk widget name, and its parent widget
      must already exist.</li>
  <li>An instance of a <b>snit::type</b> can be destroyed by calling its
      <b>destroy</b> method. Instances of a <b>snit::widget</b> have no destroy
      method; use the Tk <b>destroy</b> command instead.</li>
  <li>Every instance of a <b>snit::widget</b> has one predefined component
      called its <b>hull</b> component. The hull is usually a Tk <b>frame</b> or
      <b>toplevel</b> widget; any other widgets created as part of the
      <b>snit::widget</b> will usually be contained within the hull.</li>
  <li><b>snit::widget</b>s can have their options receive default values from
      <b>THE TK OPTION DATABASE</b>.</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_A_HULL_COMPONENT?"><a class="permalink" href="#WHAT_IS_A_HULL_COMPONENT?">WHAT
  IS A HULL COMPONENT?</a></h2>
<p class="Pp">Snit can't create a Tk widget object; only Tk can do that. Thus,
    every instance of a <b>snit::widget</b> must be wrapped around a genuine Tk
    widget; this Tk widget is called the <i>hull component</i>. Snit effectively
    piggybacks the behavior you define (methods, options, and so forth) on top
    of the hull component so that the whole thing behaves like a standard Tk
    widget.</p>
<p class="Pp">For <b>snit::widget</b>s the hull component must be a Tk widget
    that defines the <b>-class</b> option.</p>
<p class="Pp"><b>snit::widgetadaptor</b>s differ from <b>snit::widget</b>s
    chiefly in that any kind of widget can be used as the hull component; see
    <b>WIDGET ADAPTORS</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_CAN_I_SET_THE_HULL_TYPE_FOR_A_SNIT::WIDGET?"><a class="permalink" href="#HOW_CAN_I_SET_THE_HULL_TYPE_FOR_A_SNIT::WIDGET?">HOW
  CAN I SET THE HULL TYPE FOR A SNIT::WIDGET?</a></h2>
<p class="Pp">A <b>snit::widget</b>'s hull component will usually be a Tk
    <b>frame</b> widget; however, it may be any Tk widget that defines the
    <b>-class</b> option. You can explicitly choose the hull type you prefer by
    including the <b>hulltype</b> command in the widget definition:</p>
<p class="Pp"></p>
<pre>snit::widget mytoplevel {
    hulltype toplevel
    # ...
}
</pre>
<p class="Pp">If no <b>hulltype</b> command appears, the hull will be a
    <b>frame</b>.</p>
<p class="Pp">By default, Snit recognizes the following hull types: the Tk
    widgets <b>frame</b>, <b>labelframe</b>, <b>toplevel</b>, and the Tile
    widgets <b>ttk::frame</b>, <b>ttk::labelframe</b>, and <b>ttk::toplevel</b>.
    To enable the use of some other kind of widget as the hull type, you can
    <b>lappend</b> the widget command to the variable <b>snit::hulltypes</b>
    (always provided the widget defines the <b>-class</b> option. For example,
    suppose Tk gets a new widget type called a <b>prettyframe</b>:</p>
<p class="Pp"></p>
<pre>lappend snit::hulltypes prettyframe
snit::widget mywidget {
    hulltype prettyframe
    # ...
}
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_SHOULD_I_NAME_WIDGETS_WHICH_ARE_COMPONENTS_OF_A_SNIT::WIDGET?"><a class="permalink" href="#HOW_SHOULD_I_NAME_WIDGETS_WHICH_ARE_COMPONENTS_OF_A_SNIT::WIDGET?">HOW
  SHOULD I NAME WIDGETS WHICH ARE COMPONENTS OF A SNIT::WIDGET?</a></h2>
<p class="Pp">Every widget, whether a genuine Tk widget or a Snit megawidget,
    has to have a valid Tk window name. When a <b>snit::widget</b> is first
    created, its instance name, <b>self</b>, is a Tk window name; however, if
    the <b>snit::widget</b> is used as the hull component by a
    <b>snit::widgetadaptor</b> its instance name will be changed to something
    else. For this reason, every <b>snit::widget</b> method, constructor,
    destructor, and so forth is passed another implicit argument, <b>win</b>,
    which is the window name of the megawidget. Any children should be named
    using <b>win</b> as the root.</p>
<p class="Pp">Thus, suppose you're writing a toolbar widget, a frame consisting
    of a number of buttons placed side-by-side. It might look something like
    this:</p>
<p class="Pp"></p>
<pre>snit::widget toolbar {
    delegate option * to hull
    constructor {args} {
        button $win.open -text Open -command [mymethod open]
        button $win.save -text Save -command [mymethod save]
        # ....
        $self configurelist $args
    }
}
</pre>
<p class="Pp">See also the question on renaming objects, toward the top of this
    file.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="WIDGET_ADAPTORS"><a class="permalink" href="#WIDGET_ADAPTORS">WIDGET
  ADAPTORS</a></h1>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_A_SNIT::WIDGETADAPTOR?"><a class="permalink" href="#WHAT_IS_A_SNIT::WIDGETADAPTOR?">WHAT
  IS A SNIT::WIDGETADAPTOR?</a></h2>
<p class="Pp">A <b>snit::widgetadaptor</b> is a kind of <b>snit::widget</b>.
    Whereas a <b>snit::widget</b>'s hull is automatically created and is always
    a Tk frame, a <b>snit::widgetadaptor</b> can be based on any Tk widget--or
    on any Snit megawidget, or even (with luck) on megawidgets defined using
    some other package.</p>
<p class="Pp">It's called a <i>widget adaptor</i> because it allows you to take
    an existing widget and customize its behavior.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_I_DEFINE_A_SNIT::WIDGETADAPTOR?"><a class="permalink" href="#HOW_DO_I_DEFINE_A_SNIT::WIDGETADAPTOR?">HOW
  DO I DEFINE A SNIT::WIDGETADAPTOR?</a></h2>
<p class="Pp">Use the <b>snit::widgetadaptor</b> command. The definition for a
    <b>snit::widgetadaptor</b> looks just like that for a <b>snit::type</b> or
    <b>snit::widget</b>, except that the constructor must create and install the
    hull component.</p>
<p class="Pp">For example, the following code creates a read-only text widget by
    the simple device of turning its <b>insert</b> and <b>delete</b> methods
    into no-ops. Then, we define new methods, <b>ins</b> and <b>del</b>, which
    get delegated to the hull component as <b>insert</b> and <b>delete</b>.
    Thus, we've adapted the text widget and given it new behavior while still
    leaving it fundamentally a text widget.</p>
<p class="Pp"></p>
<pre>::snit::widgetadaptor rotext {
    constructor {args} {
        # Create the text widget; turn off its insert cursor
        installhull using text -insertwidth 0
        # Apply any options passed at creation time.
        $self configurelist $args
    }
    # Disable the text widget's insert and delete methods, to
    # make this readonly.
    method insert {args} {}
    method delete {args} {}
    # Enable ins and del as synonyms, so the program can insert and
    # delete.
    delegate method ins to hull as insert
    delegate method del to hull as delete
    # Pass all other methods and options to the real text widget, so
    # that the remaining behavior is as expected.
    delegate method * to hull
    delegate option * to hull
}
</pre>
<p class="Pp">The most important part is in the constructor. Whereas
    <b>snit::widget</b> creates the hull for you, <b>snit::widgetadaptor</b>
    cannot -- it doesn't know what kind of widget you want. So the first thing
    the constructor does is create the hull component (a Tk text widget in this
    case), and then installs it using the <b>installhull</b> command.</p>
<p class="Pp"><i>Note:</i> There is no instance command until you create one by
    installing a hull component. Any attempt to pass methods to <b>$self</b>
    prior to calling <b>installhull</b> will fail.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="CAN_I_ADAPT_A_WIDGET_CREATED_ELSEWHERE_IN_THE_PROGRAM?"><a class="permalink" href="#CAN_I_ADAPT_A_WIDGET_CREATED_ELSEWHERE_IN_THE_PROGRAM?">CAN
  I ADAPT A WIDGET CREATED ELSEWHERE IN THE PROGRAM?</a></h2>
<p class="Pp">Yes.</p>
<p class="Pp">At times, it can be convenient to adapt a pre-existing widget
    instead of creating your own. For example, the Bwidget <b>PagesManager</b>
    widget manages a set of <b>frame</b> widgets, only one of which is visible
    at a time. The application chooses which <b>frame</b> is visible. All of the
    These <b>frame</b>s are created by the <b>PagesManager</b> itself, using its
    <b>add</b> method. It's convenient to adapt these frames to do what we'd
    like them to do.</p>
<p class="Pp">In a case like this, the Tk widget will already exist when the
    <b>snit::widgetadaptor</b> is created. Snit provides an alternate form of
    the <b>installhull</b> command for this purpose:</p>
<p class="Pp"></p>
<pre>snit::widgetadaptor pageadaptor {
    constructor {args} {
        # The widget already exists; just install it.
        installhull $win
        # ...
    }
}
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="CAN_I_ADAPT_ANOTHER_MEGAWIDGET?"><a class="permalink" href="#CAN_I_ADAPT_ANOTHER_MEGAWIDGET?">CAN
  I ADAPT ANOTHER MEGAWIDGET?</a></h2>
<p class="Pp">Maybe. If the other megawidget is a <b>snit::widget</b> or
    <b>snit::widgetadaptor</b>, then yes. If it isn't then, again, maybe. You'll
    have to try it and see. You're most likely to have trouble with widget
    destruction--you have to make sure that your megawidget code receives the
    <b>&lt;Destroy&gt;</b> event before the megawidget you're adapting does.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="THE_TK_OPTION_DATABASE"><a class="permalink" href="#THE_TK_OPTION_DATABASE">THE
  TK OPTION DATABASE</a></h1>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_THE_TK_OPTION_DATABASE?"><a class="permalink" href="#WHAT_IS_THE_TK_OPTION_DATABASE?">WHAT
  IS THE TK OPTION DATABASE?</a></h2>
<p class="Pp">The Tk option database is a database of default option values
    maintained by Tk itself; every Tk application has one. The concept of the
    option database derives from something called the X Windows resource
    database; however, the option database is available in every Tk
    implementation, including those which do not use the X Windows system (e.g.,
    Microsoft Windows).</p>
<p class="Pp">Full details about the Tk option database are beyond the scope of
    this document; both <i>Practical Programming in Tcl and Tk</i> by Welch,
    Jones, and Hobbs, and <i>Effective Tcl/Tk Programming</i> by Harrison and
    McClennan., have good introductions to it.</p>
<p class="Pp">Snit is implemented so that most of the time it will simply do the
    right thing with respect to the option database, provided that the widget
    developer does the right thing by Snit. The body of this section goes into
    great deal about what Snit requires. The following is a brief statement of
    the requirements, for reference.</p>
<ul class="Bl-bullet">
  <li>If the widget's default widget class is not what is desired, set it
      explicitly using the <b>widgetclass</b> statement in the widget
      definition.</li>
  <li>When defining or delegating options, specify the resource and class names
      explicitly when necessary.</li>
  <li>Use the <b>installhull using</b> command to create and install the hull
      for <b>snit::widgetadaptor</b>s.</li>
  <li>Use the <b>install</b> command to create and install all components which
      are widgets.</li>
  <li>Use the <b>install</b> command to create and install components which
      aren't widgets if you'd like them to receive option values from the option
      database.</li>
</ul>
<p class="Pp">The interaction of Tk widgets with the option database is a
    complex thing; the interaction of Snit with the option database is even more
    so, and repays attention to detail.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="DO_SNIT::TYPES_USE_THE_TK_OPTION_DATABASE?"><a class="permalink" href="#DO_SNIT::TYPES_USE_THE_TK_OPTION_DATABASE?">DO
  SNIT::TYPES USE THE TK OPTION DATABASE?</a></h2>
<p class="Pp">No, they don't; querying the option database requires a Tk window
    name, and <b>snit::type</b>s don't have one.</p>
<p class="Pp">If you create an instance of a <b>snit::type</b> as a component of
    a <b>snit::widget</b> or <b>snit::widgetadaptor</b>, on the other hand, and
    if any options are delegated to the component, and if you use <b>install</b>
    to create and install it, then the megawidget will query the option database
    on the <b>snit::type</b>'s behalf. This might or might not be what you want,
    so take care.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_MY_SNIT::WIDGET'S_WIDGET_CLASS?"><a class="permalink" href="#WHAT_IS_MY_SNIT::WIDGET'S_WIDGET_CLASS?">WHAT
  IS MY SNIT::WIDGET'S WIDGET CLASS?</a></h2>
<p class="Pp">Every Tk widget has a &quot;widget class&quot;: a name that is
    used when adding option settings to the database. For Tk widgets, the widget
    class is the same as the widget command name with an initial capital. For
    example, the widget class of the Tk <b>button</b> widget is
  <b>Button</b>.</p>
<p class="Pp">Similarly, the widget class of a <b>snit::widget</b> defaults to
    the unqualified type name with the first letter capitalized. For example,
    the widget class of</p>
<p class="Pp"></p>
<pre>snit::widget ::mylibrary::scrolledText { ... }
</pre>
<p class="Pp">is <b>ScrolledText</b>.</p>
<p class="Pp">The widget class can also be set explicitly using the
    <b>widgetclass</b> statement within the <b>snit::widget</b> definition:</p>
<p class="Pp"></p>
<pre>snit::widget ::mylibrary::scrolledText {
    widgetclass Text
    # ...
}
</pre>
<p class="Pp">The above definition says that a <b>scrolledText</b> megawidget
    has the same widget class as an ordinary <b>text</b> widget. This might or
    might not be a good idea, depending on how the rest of the megawidget is
    defined, and how its options are delegated.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_MY_SNIT::WIDGETADAPTOR'S_WIDGET_CLASS?"><a class="permalink" href="#WHAT_IS_MY_SNIT::WIDGETADAPTOR'S_WIDGET_CLASS?">WHAT
  IS MY SNIT::WIDGETADAPTOR'S WIDGET CLASS?</a></h2>
<p class="Pp">The widget class of a <b>snit::widgetadaptor</b> is just the
    widget class of its hull widget; Snit has no control over this.</p>
<p class="Pp">Note that the widget class can be changed only for <b>frame</b>
    and <b>toplevel</b> widgets, which is why these are the valid hull types for
    <b>snit::widget</b>s.</p>
<p class="Pp">Try to use <b>snit::widgetadaptor</b>s only to make small
    modifications to another widget's behavior. Then, it will usually not make
    sense to change the widget's widget class anyway.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="WHAT_ARE_OPTION_RESOURCE_AND_CLASS_NAMES?"><a class="permalink" href="#WHAT_ARE_OPTION_RESOURCE_AND_CLASS_NAMES?">WHAT
  ARE OPTION RESOURCE AND CLASS NAMES?</a></h2>
<p class="Pp">Every Tk widget option has three names: the option name, the
    resource name, and the class name. The option name begins with a hyphen and
    is all lowercase; it's used when creating widgets, and with the
    <b>configure</b> and <b>cget</b> commands.</p>
<p class="Pp">The resource and class names are used to initialize option default
    values by querying the option database. The resource name is usually just
    the option name minus the hyphen, but may contain uppercase letters at word
    boundaries; the class name is usually just the resource name with an initial
    capital, but not always. For example, here are the option, resource, and
    class names for several Tk <b>text</b> widget options:</p>
<p class="Pp"></p>
<pre>
    -background         background         Background
    -borderwidth        borderWidth        BorderWidth
    -insertborderwidth  insertBorderWidth  BorderWidth
    -padx               padX               Pad
</pre>
<p class="Pp">As is easily seen, sometimes the resource and class names can be
    inferred from the option name, but not always.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="WHAT_ARE_THE_RESOURCE_AND_CLASS_NAMES_FOR_MY_MEGAWIDGET'S_OPTIONS?"><a class="permalink" href="#WHAT_ARE_THE_RESOURCE_AND_CLASS_NAMES_FOR_MY_MEGAWIDGET'S_OPTIONS?">WHAT
  ARE THE RESOURCE AND CLASS NAMES FOR MY MEGAWIDGET'S OPTIONS?</a></h2>
<p class="Pp">For options implicitly delegated to a component using <b>delegate
    option *</b>, the resource and class names will be exactly those defined by
    the component. The <b>configure</b> method returns these names, along with
    the option's default and current values:</p>
<p class="Pp"></p>
<pre>% snit::widget mytext {
    delegate option * to text
    constructor {args} {
        install text using text .text
        # ...
    }
    # ...
}
::mytext
% mytext .text
% .text configure -padx
-padx padX Pad 1 1
%
</pre>
<p class="Pp">For all other options (whether locally defined or explicitly
    delegated), the resource and class names can be defined explicitly, or they
    can be allowed to have default values.</p>
<p class="Pp">By default, the resource name is just the option name minus the
    hyphen; the the class name is just the option name with an initial capital
    letter. For example, suppose we explicitly delegate &quot;-padx&quot;:</p>
<p class="Pp"></p>
<pre>% snit::widget mytext {
    option -myvalue 5
    delegate option -padx to text
    delegate option * to text
    constructor {args} {
        install text using text .text
        # ...
    }
    # ...
}
::mytext
% mytext .text
% .text configure -myvalue
-myvalue myvalue Myvalue 5 5
% .text configure -padx
-padx padx Padx 1 1
%
</pre>
<p class="Pp">Here the resource and class names are chosen using the default
    rules. Often these rules are sufficient, but in the case of
    &quot;-padx&quot; we'd most likely prefer that the option's resource and
    class names are the same as for the built-in Tk widgets. This is easily
    done:</p>
<p class="Pp"></p>
<pre>% snit::widget mytext {
    delegate option {-padx padX Pad} to text
    # ...
}
::mytext
% mytext .text
% .text configure -padx
-padx padX Pad 1 1
%
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DOES_SNIT_INITIALIZE_MY_MEGAWIDGET'S_LOCALLY-DEFINED_OPTIONS?"><a class="permalink" href="#HOW_DOES_SNIT_INITIALIZE_MY_MEGAWIDGET'S_LOCALLY-DEFINED_OPTIONS?">HOW
  DOES SNIT INITIALIZE MY MEGAWIDGET'S LOCALLY-DEFINED OPTIONS?</a></h2>
<p class="Pp">The option database is queried for each of the megawidget's
    locally-defined options, using the option's resource and class name. If the
    result isn't &quot;&quot;, then it replaces the default value given in
    widget definition. In either case, the default can be overridden by the
    caller. For example,</p>
<p class="Pp"></p>
<pre>option add *Mywidget.texture pebbled
snit::widget mywidget {
    option -texture smooth
    # ...
}
mywidget .mywidget -texture greasy
</pre>
<p class="Pp">Here, <b>-texture</b> would normally default to
    &quot;smooth&quot;, but because of the entry added to the option database it
    defaults to &quot;pebbled&quot;. However, the caller has explicitly
    overridden the default, and so the new widget will be
  &quot;greasy&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DOES_SNIT_INITIALIZE_DELEGATED_OPTIONS?"><a class="permalink" href="#HOW_DOES_SNIT_INITIALIZE_DELEGATED_OPTIONS?">HOW
  DOES SNIT INITIALIZE DELEGATED OPTIONS?</a></h2>
<p class="Pp">That depends on whether the options are delegated to the hull, or
    to some other component.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DOES_SNIT_INITIALIZE_OPTIONS_DELEGATED_TO_THE_HULL?"><a class="permalink" href="#HOW_DOES_SNIT_INITIALIZE_OPTIONS_DELEGATED_TO_THE_HULL?">HOW
  DOES SNIT INITIALIZE OPTIONS DELEGATED TO THE HULL?</a></h2>
<p class="Pp">A <b>snit::widget</b>'s hull is a widget, and given that its class
    has been set it is expected to query the option database for itself. The
    only exception concerns options that are delegated to it with a different
    name. Consider the following code:</p>
<p class="Pp"></p>
<pre>option add *Mywidget.borderWidth 5
option add *Mywidget.relief sunken
option add *Mywidget.hullbackground red
option add *Mywidget.background green
snit::widget mywidget {
    delegate option -borderwidth to hull
    delegate option -hullbackground to hull as -background
    delegate option * to hull
    # ...
}
mywidget .mywidget
set A [.mywidget cget -relief]
set B [.mywidget cget -hullbackground]
set C [.mywidget cget -background]
set D [.mywidget cget -borderwidth]
</pre>
<p class="Pp">The question is, what are the values of variables A, B, C and
  D?</p>
<p class="Pp">The value of A is &quot;sunken&quot;. The hull is a Tk frame which
    has been given the widget class <b>Mywidget</b>; it will automatically query
    the option database and pick up this value. Since the <b>-relief</b> option
    is implicitly delegated to the hull, Snit takes no action.</p>
<p class="Pp">The value of B is &quot;red&quot;. The hull will automatically
    pick up the value &quot;green&quot; for its <b>-background</b> option, just
    as it picked up the <b>-relief</b> value. However, Snit knows that
    <b>-hullbackground</b> is mapped to the hull's <b>-background</b> option;
    hence, it queries the option database for <b>-hullbackground</b> and gets
    &quot;red&quot; and updates the hull accordingly.</p>
<p class="Pp">The value of C is also &quot;red&quot;, because <b>-background</b>
    is implicitly delegated to the hull; thus, retrieving it is the same as
    retrieving <b>-hullbackground</b>. Note that this case is unusual; the
    <b>-background</b> option should probably have been excluded using the
    delegate statement's <b>except</b> clause, or (more likely) delegated to
    some other component.</p>
<p class="Pp">The value of D is &quot;5&quot;, but not for the reason you think.
    Note that as it is defined above, the resource name for <b>-borderwidth</b>
    defaults to <b>borderwidth</b>, whereas the option database entry is
    <b>borderWidth</b>, in accordance with the standard Tk naming for this
    option. As with <b>-relief</b>, the hull picks up its own
    <b>-borderwidth</b> option before Snit does anything. Because the option is
    delegated under its own name, Snit assumes that the correct thing has
    happened, and doesn't worry about it any further. To avoid confusion, the
    <b>-borderwidth</b> option should have been delegated like this:</p>
<p class="Pp"></p>
<pre>
    delegate option {-borderwidth borderWidth BorderWidth} to hull
</pre>
<p class="Pp">For <b>snit::widgetadaptor</b>s, the case is somewhat altered.
    Widget adaptors retain the widget class of their hull, and the hull is not
    created automatically by Snit. Instead, the <b>snit::widgetadaptor</b> must
    call <b>installhull</b> in its constructor. The normal way to do this is as
    follows:</p>
<p class="Pp"></p>
<pre>snit::widgetadaptor mywidget {
    # ...
    constructor {args} {
        # ...
        installhull using text -foreground white
        # ...
    }
    # ...
}
</pre>
<p class="Pp">In this case, the <b>installhull</b> command will create the hull
    using a command like this:</p>
<p class="Pp"></p>
<pre>
    set hull [text $win -foreground white]
</pre>
<p class="Pp">The hull is a <b>text</b> widget, so its widget class is
    <b>Text</b>. Just as with <b>snit::widget</b> hulls, Snit assumes that it
    will pick up all of its normal option values automatically, without help
    from Snit. Options delegated from a different name are initialized from the
    option database in the same way as described above.</p>
<p class="Pp">In earlier versions of Snit, <b>snit::widgetadaptor</b>s were
    expected to call <b>installhull</b> like this:</p>
<p class="Pp"></p>
<pre>
    installhull [text $win -foreground white]
</pre>
<p class="Pp">This form still works--but Snit will not query the option database
    as described above.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DOES_SNIT_INITIALIZE_OPTIONS_DELEGATED_TO_OTHER_COMPONENTS?"><a class="permalink" href="#HOW_DOES_SNIT_INITIALIZE_OPTIONS_DELEGATED_TO_OTHER_COMPONENTS?">HOW
  DOES SNIT INITIALIZE OPTIONS DELEGATED TO OTHER COMPONENTS?</a></h2>
<p class="Pp">For hull components, Snit assumes that Tk will do most of the work
    automatically. Non-hull components are somewhat more complicated, because
    they are matched against the option database twice.</p>
<p class="Pp">A component widget remains a widget still, and is therefore
    initialized from the option database in the usual way. A <b>text</b> widget
    remains a <b>text</b> widget whether it is a component of a megawidget or
    not, and will be created as such.</p>
<p class="Pp">But then, the option database is queried for all options delegated
    to the component, and the component is initialized accordingly--provided
    that the <b>install</b> command is used to create it.</p>
<p class="Pp">Before option database support was added to Snit, the usual way to
    create a component was to simply create it in the constructor and assign its
    command name to the component variable:</p>
<p class="Pp"></p>
<pre>snit::widget mywidget {
    delegate option -background to myComp
    constructor {args} {
        set myComp [text $win.text -foreground black]
    }
}
</pre>
<p class="Pp">The drawback of this method is that Snit has no opportunity to
    initialize the component properly. Hence, the following approach is now
    used:</p>
<p class="Pp"></p>
<pre>snit::widget mywidget {
    delegate option -background to myComp
    constructor {args} {
        install myComp using text $win.text -foreground black
    }
}
</pre>
<p class="Pp">The <b>install</b> command does the following:</p>
<ul class="Bl-bullet">
  <li>Builds a list of the options explicitly included in the <b>install</b>
      command--in this case, <b>-foreground</b>.</li>
  <li>Queries the option database for all options delegated explicitly to the
      named component.</li>
  <li>Creates the component using the specified command, after inserting into it
      a list of options and values read from the option database. Thus, the
      explicitly included options (like <b>-foreground</b>) will override
      anything read from the option database.</li>
  <li>If the widget definition implicitly delegated options to the component
      using <b>delegate option *</b>, then Snit calls the newly created
      component's <b>configure</b> method to receive a list of all of the
      component's options. From this Snit builds a list of options implicitly
      delegated to the component which were not explicitly included in the
      <b>install</b> command. For all such options, Snit queries the option
      database and configures the component accordingly.</li>
</ul>
<p class="Pp">You don't really need to know all of this; just use <b>install</b>
    to install your components, and Snit will try to do the right thing.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="WHAT_HAPPENS_IF_I_INSTALL_A_NON-WIDGET_AS_A_COMPONENT_OF_WIDGET?"><a class="permalink" href="#WHAT_HAPPENS_IF_I_INSTALL_A_NON-WIDGET_AS_A_COMPONENT_OF_WIDGET?">WHAT
  HAPPENS IF I INSTALL A NON-WIDGET AS A COMPONENT OF WIDGET?</a></h2>
<p class="Pp">A <b>snit::type</b> never queries the option database. However, a
    <b>snit::widget</b> can have non-widget components. And if options are
    delegated to those components, and if the <b>install</b> command is used to
    install those components, then they will be initialized from the option
    database just as widget components are.</p>
<p class="Pp">However, when used within a megawidget, <b>install</b> assumes
    that the created component uses a reasonably standard widget-like creation
    syntax. If it doesn't, don't use <b>install</b>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ENSEMBLE_COMMANDS"><a class="permalink" href="#ENSEMBLE_COMMANDS">ENSEMBLE
  COMMANDS</a></h1>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_AN_ENSEMBLE_COMMAND?"><a class="permalink" href="#WHAT_IS_AN_ENSEMBLE_COMMAND?">WHAT
  IS AN ENSEMBLE COMMAND?</a></h2>
<p class="Pp">An ensemble command is a command with subcommands. Snit objects
    are all ensemble commands; however, the term more usually refers to commands
    like the standard Tcl commands <b>string</b>, <b>file</b>, and <b>clock</b>.
    In a sense, these are singleton objects--there's only one instance of
  them.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_CAN_I_CREATE_AN_ENSEMBLE_COMMAND_USING_SNIT?"><a class="permalink" href="#HOW_CAN_I_CREATE_AN_ENSEMBLE_COMMAND_USING_SNIT?">HOW
  CAN I CREATE AN ENSEMBLE COMMAND USING SNIT?</a></h2>
<p class="Pp">There are two ways--as a <b>snit::type</b>, or as an instance of a
    <b>snit::type</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_CAN_I_CREATE_AN_ENSEMBLE_COMMAND_USING_AN_INSTANCE_OF_A_SNIT::TYPE?"><a class="permalink" href="#HOW_CAN_I_CREATE_AN_ENSEMBLE_COMMAND_USING_AN_INSTANCE_OF_A_SNIT::TYPE?">HOW
  CAN I CREATE AN ENSEMBLE COMMAND USING AN INSTANCE OF A SNIT::TYPE?</a></h2>
<p class="Pp">Define a type whose <b>INSTANCE METHODS</b> are the subcommands of
    your ensemble command. Then, create an instance of the type with the desired
    name.</p>
<p class="Pp">For example, the following code uses <b>DELEGATION</b> to create a
    work-alike for the standard <b>string</b> command:</p>
<pre>snit::type ::mynamespace::mystringtype {
    delegate method * to stringhandler
    constructor {} {
        set stringhandler string
    }
}
::mynamespace::mystringtype mystring
</pre>
We create the type in a namespace, so that the type command is hidden; then we
  create a single instance with the desired name-- <b>mystring</b>, in this
  case.
<p class="Pp">This method has two drawbacks. First, it leaves the type command
    floating about. More seriously, your shiny new ensemble command will have
    <b>info</b> and <b>destroy</b> subcommands that you probably have no use
    for. But read on.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_CAN_I_CREATE_AN_ENSEMBLE_COMMAND_USING_A_SNIT::TYPE?"><a class="permalink" href="#HOW_CAN_I_CREATE_AN_ENSEMBLE_COMMAND_USING_A_SNIT::TYPE?">HOW
  CAN I CREATE AN ENSEMBLE COMMAND USING A SNIT::TYPE?</a></h2>
<p class="Pp">Define a type whose <b>TYPE METHODS</b> are the subcommands of
    your ensemble command.</p>
<p class="Pp">For example, the following code uses <b>DELEGATION</b> to create a
    work-alike for the standard <b>string</b> command:</p>
<pre>snit::type mystring {
    delegate typemethod * to stringhandler
    typeconstructor {
        set stringhandler string
    }
}
</pre>
Now the type command itself is your ensemble command.
<p class="Pp">This method has only one drawback, and though it's major, it's
    also surmountable. Your new ensemble command will have <b>create</b>,
    <b>info</b> and <b>destroy</b> subcommands you don't want. And worse yet,
    since the <b>create</b> method can be implicit, users of your command will
    accidentally be creating instances of your <b>mystring</b> type if they
    should mispell one of the subcommands. The command will succeed--the first
    time--but won't do what's wanted. This is very bad.</p>
<p class="Pp">The work around is to set some <b>PRAGMAS</b>, as shown here:</p>
<pre>snit::type mystring {
    pragma -hastypeinfo    no
    pragma -hastypedestroy no
    pragma -hasinstances   no
    delegate typemethod * to stringhandler
    typeconstructor {
        set stringhandler string
    }
}
</pre>
Here we've used the <b>pragma</b> statement to tell Snit that we don't want the
  <b>info</b> typemethod or the <b>destroy</b> typemethod, and that our type has
  no instances; this eliminates the <b>create</b> typemethod and all related
  code. As a result, our ensemble command will be well-behaved, with no
  unexpected subcommands.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="PRAGMAS"><a class="permalink" href="#PRAGMAS">PRAGMAS</a></h1>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_A_PRAGMA?"><a class="permalink" href="#WHAT_IS_A_PRAGMA?">WHAT
  IS A PRAGMA?</a></h2>
<p class="Pp">A pragma is an option you can set in your type definitions that
    affects how the type is defined and how it works once it is defined.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_I_SET_A_PRAGMA?"><a class="permalink" href="#HOW_DO_I_SET_A_PRAGMA?">HOW
  DO I SET A PRAGMA?</a></h2>
<p class="Pp">Use the <b>pragma</b> statement. Each pragma is an option with a
    value; each time you use the <b>pragma</b> statement you can set one or more
    of them.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_CAN_I_GET_RID_OF_THE_INFO__TYPE_METHOD?_"><a class="permalink" href="#HOW_CAN_I_GET_RID_OF_THE_INFO__TYPE_METHOD?_">HOW
  CAN I GET RID OF THE INFO&quot; TYPE METHOD?&quot;</a></h2>
<p class="Pp">Set the <b>-hastypeinfo</b> pragma to <b>no</b>:</p>
<pre>snit::type dog {
    pragma -hastypeinfo no
    # ...
}
</pre>
<p class="Pp">Snit will refrain from defining the <b>info</b> type method.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_CAN_I_GET_RID_OF_THE_DESTROY__TYPE_METHOD?_"><a class="permalink" href="#HOW_CAN_I_GET_RID_OF_THE_DESTROY__TYPE_METHOD?_">HOW
  CAN I GET RID OF THE DESTROY&quot; TYPE METHOD?&quot;</a></h2>
<p class="Pp">Set the <b>-hastypedestroy</b> pragma to <b>no</b>:</p>
<pre>snit::type dog {
    pragma -hastypedestroy no
    # ...
}
</pre>
<p class="Pp">Snit will refrain from defining the <b>destroy</b> type
  method.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_CAN_I_GET_RID_OF_THE_CREATE__TYPE_METHOD?_"><a class="permalink" href="#HOW_CAN_I_GET_RID_OF_THE_CREATE__TYPE_METHOD?_">HOW
  CAN I GET RID OF THE CREATE&quot; TYPE METHOD?&quot;</a></h2>
<p class="Pp">Set the <b>-hasinstances</b> pragma to <b>no</b>:</p>
<pre>snit::type dog {
    pragma -hasinstances no
    # ...
}
</pre>
<p class="Pp">Snit will refrain from defining the <b>create</b> type method; if
    you call the type command with an unknown method name, you'll get an error
    instead of a new instance of the type.</p>
<p class="Pp">This is useful if you wish to use a <b>snit::type</b> to define an
    ensemble command rather than a type with instances.</p>
<p class="Pp">Pragmas <b>-hastypemethods</b> and <b>-hasinstances</b> cannot
    both be false (or there'd be nothing left).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_CAN_I_GET_RID_OF_TYPE_METHODS_ALTOGETHER?"><a class="permalink" href="#HOW_CAN_I_GET_RID_OF_TYPE_METHODS_ALTOGETHER?">HOW
  CAN I GET RID OF TYPE METHODS ALTOGETHER?</a></h2>
<p class="Pp">Normal Tk widget type commands don't have subcommands; all they do
    is create widgets--in Snit terms, the type command calls the <b>create</b>
    type method directly. To get the same behavior from Snit, set the
    <b>-hastypemethods</b> pragma to <b>no</b>:</p>
<pre>snit::type dog {
    pragma -hastypemethods no
    #...
}
# Creates ::spot
dog spot
# Tries to create an instance called ::create
dog create spot
</pre>
<p class="Pp">Pragmas <b>-hastypemethods</b> and <b>-hasinstances</b> cannot
    both be false (or there'd be nothing left).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="WHY_CAN'T_I_CREATE_AN_OBJECT_THAT_REPLACES_AN_OLD_OBJECT_WITH_THE_SAME_NAME?"><a class="permalink" href="#WHY_CAN'T_I_CREATE_AN_OBJECT_THAT_REPLACES_AN_OLD_OBJECT_WITH_THE_SAME_NAME?">WHY
  CAN'T I CREATE AN OBJECT THAT REPLACES AN OLD OBJECT WITH THE SAME
  NAME?</a></h2>
<p class="Pp">Up until Snit 0.95, you could use any name for an instance of a
    <b>snit::type</b>, even if the name was already in use by some other object
    or command. You could do the following, for example:</p>
<pre>snit::type dog { ... }
dog proc
</pre>
<p class="Pp">You now have a new dog named &quot;proc&quot;, which is probably
    not something that you really wanted to do. As a result, Snit now throws an
    error if your chosen instance name names an existing command. To restore the
    old behavior, set the <b>-canreplace</b> pragma to <b>yes</b>:</p>
<pre>snit::type dog {
    pragma -canreplace yes
    # ...
}
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_CAN_I_MAKE_MY_SIMPLE_TYPE_RUN_FASTER?"><a class="permalink" href="#HOW_CAN_I_MAKE_MY_SIMPLE_TYPE_RUN_FASTER?">HOW
  CAN I MAKE MY SIMPLE TYPE RUN FASTER?</a></h2>
<p class="Pp">In Snit 1.x, you can set the <b>-simpledispatch</b> pragma to
    <b>yes</b>.</p>
<p class="Pp">Snit 1.x method dispatch is both flexible and fast, but the
    flexibility comes with a price. If your type doesn't require the
    flexibility, the <b>-simpledispatch</b> pragma allows you to substitute a
    simpler dispatch mechanism that runs quite a bit faster. The limitations are
    these:</p>
<ul class="Bl-bullet">
  <li>Methods cannot be delegated.</li>
  <li><b>uplevel</b> and <b>upvar</b> do not work as expected: the caller's
      scope is two levels up rather than one.</li>
  <li>The option-handling methods (<b>cget</b>, <b>configure</b>, and
      <b>configurelist</b>) are very slightly slower.</li>
</ul>
<p class="Pp">In Snit 2.2, the <b>-simpledispatch</b> macro is obsolete, and
    ignored; all Snit 2.2 method dispatch is faster than Snit 1.x's
    <b>-simpledispatch</b>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="MACROS"><a class="permalink" href="#MACROS">MACROS</a></h1>
<section class="Ss">
<h2 class="Ss" id="WHAT_IS_A_MACRO?"><a class="permalink" href="#WHAT_IS_A_MACRO?">WHAT
  IS A MACRO?</a></h2>
<p class="Pp">A Snit macro is nothing more than a Tcl proc that's defined in the
    Tcl interpreter used to compile Snit type definitions.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="WHAT_ARE_MACROS_GOOD_FOR?"><a class="permalink" href="#WHAT_ARE_MACROS_GOOD_FOR?">WHAT
  ARE MACROS GOOD FOR?</a></h2>
<p class="Pp">You can use Snit macros to define new type definition syntax, and
    to support conditional compilation.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_I_DO_CONDITIONAL_COMPILATION?"><a class="permalink" href="#HOW_DO_I_DO_CONDITIONAL_COMPILATION?">HOW
  DO I DO CONDITIONAL COMPILATION?</a></h2>
<p class="Pp">Suppose you want your type to use a fast C extension if it's
    available; otherwise, you'll fallback to a slower Tcl implementation. You
    want to define one set of methods in the first case, and another set in the
    second case. But how can your type definition know whether the fast C
    extension is available or not?</p>
<p class="Pp">It's easily done. Outside of any type definition, define a macro
    that returns 1 if the extension is available, and 0 otherwise:</p>
<pre>if {$gotFastExtension} {
    snit::macro fastcode {} {return 1}
} else {
    snit::macro fastcode {} {return 0}
}
</pre>
Then, use your macro in your type definition:
<pre>snit::type dog {
    if {[fastcode]} {
        # Fast methods
        method bark {} {...}
        method wagtail {} {...}
    } else {
        # Slow methods
        method bark {} {...}
        method wagtail {} {...}
    }
}
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="HOW_DO_I_DEFINE_NEW_TYPE_DEFINITION_SYNTAX?"><a class="permalink" href="#HOW_DO_I_DEFINE_NEW_TYPE_DEFINITION_SYNTAX?">HOW
  DO I DEFINE NEW TYPE DEFINITION SYNTAX?</a></h2>
<p class="Pp">Use a macro. For example, your <b>snit::widget</b>'s
    <b>-background</b> option should be propagated to a number of component
    widgets. You could implement that like this:</p>
<pre>snit::widget mywidget {
    option -background -default white -configuremethod PropagateBackground
    method PropagateBackground {option value} {
        $comp1 configure $option $value
        $comp2 configure $option $value
        $comp3 configure $option $value
    }
}
</pre>
<p class="Pp">For one option, this is fine; if you've got a number of options,
    it becomes tedious and error prone. So package it as a macro:</p>
<pre>snit::macro propagate {option &quot;to&quot; components} {
    option $option -configuremethod Propagate$option
    set body &quot;\n&quot;
    foreach comp $components {
        append body &quot;\$$comp configure $option \$value\n&quot;
    }
    method Propagate$option {option value} $body
}
</pre>
<p class="Pp">Then you can use it like this:</p>
<pre>snit::widget mywidget {
    option -background default -white
    option -foreground default -black
    propagate -background to {comp1 comp2 comp3}
    propagate -foreground to {comp1 comp2 comp3}
}
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="ARE_THERE_ARE_RESTRICTIONS_ON_MACRO_NAMES?"><a class="permalink" href="#ARE_THERE_ARE_RESTRICTIONS_ON_MACRO_NAMES?">ARE
  THERE ARE RESTRICTIONS ON MACRO NAMES?</a></h2>
<p class="Pp">Yes, there are. You can't redefine any standard Tcl commands or
    Snit type definition statements. You can use any other command name,
    including the name of a previously defined macro.</p>
<p class="Pp">If you're using Snit macros in your application, go ahead and name
    them in the global namespace, as shown above. But if you're using them to
    define types or widgets for use by others, you should define your macros in
    the same namespace as your types or widgets. That way, they won't conflict
    with other people's macros.</p>
<p class="Pp">If my fancy <b>snit::widget</b> is called
    <b>::mylib::mywidget</b>, for example, then I should define my
    <b>propagate</b> macro as <b>::mylib::propagate</b>:</p>
<pre>snit::macro mylib::propagate {option &quot;to&quot; components} { ... }
snit::widget ::mylib::mywidget {
    option -background default -white
    option -foreground default -black
    mylib::propagate -background to {comp1 comp2 comp3}
    mylib::propagate -foreground to {comp1 comp2 comp3}
}
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS,_IDEAS,_FEEDBACK"><a class="permalink" href="#BUGS,_IDEAS,_FEEDBACK">BUGS,
  IDEAS, FEEDBACK</a></h1>
<p class="Pp">This document, and the package it describes, will undoubtedly
    contain bugs and other problems. Please report such in the category
    <i>snit</i> of the <i>Tcllib SF Trackers</i>
    [http://sourceforge.net/tracker/?group_id=12883]. Please also report any
    ideas for enhancements you may have for either package and/or
  documentation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
<p class="Pp">BWidget, C++, Incr Tcl, adaptors, class, mega widget, object,
    object oriented, widget, widget adaptors</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CATEGORY"><a class="permalink" href="#CATEGORY">CATEGORY</a></h1>
<p class="Pp">Programming tools</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<pre>Copyright (c) 2003-2006, by William H. Duquette
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2.2</td>
    <td class="foot-os">snit</td>
  </tr>
</table>
</body>
</html>

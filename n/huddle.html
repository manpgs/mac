<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Generated from file '/AppleInternal/Library/BuildRoots/66382bca-8bca-11ec-aade-6613bcf0e2ee/Library/Caches/com.apple.xbs/Sources/tcl/tcl_ext/tcllib/tcllib/modules/yaml/huddle.man' by tcllib/doctools with format 'nroff'
   Copyright (c) 2008 KATO Kanryu <kanryu6@users.sourceforge.net>
  
   The definitions below are for supplemental macros used in Tcl/Tk
   manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO
  	Start of list of standard options for a Tk widget.  The
  	options follow on successive lines, in four columns separated
  	by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   RCS: @(#) $Id: man.macros,v 1.1 2009/01/30 04:56:47 andreas_kupries Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>huddle(n)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">huddle(n)</td>
    <td class="head-vol">HUDDLE</td>
    <td class="head-rtitle">huddle(n)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>

</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">huddle - Create and manipulate huddle object</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">package require <b>Tcl 8.4</b></p>
<p class="Pp">package require <b>huddle ?0.1.4?</b></p>
<p class="Pp"><b>huddle create</b> <i>key</i> <i>value</i> ?<i>key value
    ...</i>?</p>
<p class="Pp"><b>huddle list</b> ?<i>value value ...</i>?</p>
<p class="Pp"><b>huddle get</b> <i>object</i> <i>key</i> ?<i>key ...</i>?</p>
<p class="Pp"><b>huddle gets</b> <i>object</i> <i>key</i> ?<i>key ...</i>?</p>
<p class="Pp"><b>huddle set</b> <i>objectVar</i> <i>key</i> ?<i>key ...</i>?
    <i>value</i></p>
<p class="Pp"><b>huddle remove</b> <i>object</i> <i>key</i> ?<i>key ...</i>?</p>
<p class="Pp"><b>huddle combine</b> <i>object1</i> <i>object2</i> ?<i>object3
    ...</i>?</p>
<p class="Pp"><b>huddle equal</b> <i>object1</i> <i>object2</i></p>
<p class="Pp"><b>huddle append</b> <i>objectVar</i> <i>key</i> <i>value</i>
    ?<i>key value ...</i>?</p>
<p class="Pp"><b>huddle append</b> <i>objectVar</i> <i>value</i> ?<i>value
    ...</i>?</p>
<p class="Pp"><b>huddle keys</b> <i>object</i></p>
<p class="Pp"><b>huddle llength</b> <i>object</i></p>
<p class="Pp"><b>huddle type</b> <i>object</i> ?<i>key key...</i>?</p>
<p class="Pp"><b>huddle strip</b> <i>object</i></p>
<p class="Pp"><b>huddle jsondump</b> <i>object</i> ?<i>offset</i>?
    ?<i>newline</i>? ?<i>begin_offset</i>?</p>
<p class="Pp"><b>huddle compile</b> <i>spec</i> <i>data</i></p>
<p class="Pp"><b>huddle isHuddle</b> <i>object</i></p>
<p class="Pp"><b>huddle checkHuddle</b> <i>object</i></p>
<p class="Pp"><b>huddle to_node</b> <i>object</i> ?<i>tag</i>?</p>
<p class="Pp"><b>huddle wrap</b> <i>tag</i> <i>src</i></p>
<p class="Pp"><b>huddle call</b> <i>tag</i> <i>command</i> <i>args</i></p>
<p class="Pp"><b>huddle addType</b> <i>callback</i></p>
<p class="Pp"><b>callback</b> <i>command</i> ?<i>args</i>?</p>
<p class="Pp"><b>setting</b></p>
<p class="Pp"><b>get_sub</b> <i>src</i> <i>key</i></p>
<p class="Pp"><b>strip</b> <i>src</i></p>
<p class="Pp"><b>set</b> <i>src</i> <i>key</i> <i>value</i></p>
<p class="Pp"><b>remove</b> <i>src</i> <i>key</i> <i>value</i></p>
<p class="Pp"></p>
<pre>

</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Huddle provides a generic Tcl-based serialization/intermediary
    format. Currently, each node is wrapped in a tag with simple type
    information.</p>
<p class="Pp">When converting huddle-notation to other serialization formats
    like JSON or YAML this type information is used to select the proper
    notation. And when going from JSON/YAML/... to huddle their notation can be
    used to select the proper huddle type.</p>
<p class="Pp">In that manner huddle can serve as a common intermediary
  format.</p>
<pre>
huddle-format: &gt;
  {HUDDLE {huddle-node}}
huddle-node: &gt;
  {tag content}
each content of tag means:
  s: (content is a) string
  L: list, each sub node is a huddle-node
  D: dict, each sub node is a huddle-node
confirmed:
  - JSON
  - YAML(generally, but cannot discribe YAML-tags)
limitation:
  - cannot discribe aliases from a node to other node.
</pre>
<p class="Pp">The <b>huddle</b> package returns data as a Tcl <b>dict</b>.
    Either the <b>dict</b> package or Tcl 8.5 is required for use.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COMMANDS"><a class="permalink" href="#COMMANDS">COMMANDS</a></h1>
<dl class="Bl-tag">
  <dt id="huddle"><a class="permalink" href="#huddle"><b>huddle create</b>
    <i>key</i> <i>value</i> ?<i>key value ...</i>?</a></dt>
  <dd>Create a huddle object as a dict. It can contain other huddle
    objects.</dd>
  <dt id="huddle~2"><a class="permalink" href="#huddle~2"><b>huddle list</b>
    ?<i>value value ...</i>?</a></dt>
  <dd>Create a huddle object as a list. It can contain other huddle
    objects.</dd>
  <dt id="huddle~3"><a class="permalink" href="#huddle~3"><b>huddle get</b>
    <i>object</i> <i>key</i> ?<i>key ...</i>?</a></dt>
  <dd>Almost the same as <b>dict get</b>. Get a sub-object from the huddle
      object. <i>key</i> can be used to huddle-list's index.</dd>
  <dt id="huddle~4"><a class="permalink" href="#huddle~4"><b>huddle gets</b>
    <i>object</i> <i>key</i> ?<i>key ...</i>?</a></dt>
  <dd>Get a sub-object from the huddle object, stripped.</dd>
  <dt id="huddle~5"><a class="permalink" href="#huddle~5"><b>huddle set</b>
    <i>objectVar</i> <i>key</i> ?<i>key ...</i>? <i>value</i></a></dt>
  <dd>Almost the same as <b>dict set</b>. Set a sub-object from the huddle
      object. <i>key</i> can be used to huddle-list's index.</dd>
  <dt id="huddle~6"><a class="permalink" href="#huddle~6"><b>huddle remove</b>
    <i>object</i> <i>key</i> ?<i>key ...</i>?</a></dt>
  <dd>Almost the same as <b>dict remove</b>. Remove a sub-object from the huddle
      object. <i>key</i> can be used to huddle-list's index.</dd>
  <dt id="huddle~7"><a class="permalink" href="#huddle~7"><b>huddle combine</b>
    <i>object1</i> <i>object2</i> ?<i>object3 ...</i>?</a></dt>
  <dd>Merging huddle objects given.
    <pre>
% set aa [huddle create a b c d]
HUDDLE {D {a {s b} c {s d}}}
% set bb [huddle create a k l m]
HUDDLE {D {a {s k} l {s m}}}
% huddle combine $aa $bb
HUDDLE {D {a {s k} c {s d} l {s m}}}
    </pre>
  </dd>
  <dt id="huddle~8"><a class="permalink" href="#huddle~8"><b>huddle equal</b>
    <i>object1</i> <i>object2</i></a></dt>
  <dd>Comparing two huddle objects recursively. When to equal, returns 1,
      otherwise 0.
    <pre>
% set aa [huddle create a b c d]
HUDDLE {D {a {s b} c {s d}}}
% set bb [huddle create c d a b]
HUDDLE {D {c {s d} a {s b}}}
% huddle equal $aa $bb
1
    </pre>
  </dd>
  <dt id="huddle~9"><a class="permalink" href="#huddle~9"><b>huddle append</b>
    <i>objectVar</i> <i>key</i> <i>value</i> ?<i>key value ...</i>?</a></dt>
  <dd></dd>
  <dt id="huddle~10"><a class="permalink" href="#huddle~10"><b>huddle append</b>
    <i>objectVar</i> <i>value</i> ?<i>value ...</i>?</a></dt>
  <dd>Appending child elements. When for dicts, giving key/value. When for
      lists, giving values.
    <pre>
% set aa [huddle create a b c d]
HUDDLE {D {a {s b} c {s d}}}
% huddle append aa a k l m
HUDDLE {D {a {s k} c {s d} l {s m}}}
% set bb [huddle list i j k l]
HUDDLE {L {{s i} {s j} {s k} {s l}}}
% huddle append bb g h i
HUDDLE {L {{s i} {s j} {s k} {s l} {s g} {s h} {s i}}}
    </pre>
  </dd>
  <dt id="huddle~11"><a class="permalink" href="#huddle~11"><b>huddle keys</b>
    <i>object</i></a></dt>
  <dd>The same as <b>dict keys</b>.</dd>
  <dt id="huddle~12"><a class="permalink" href="#huddle~12"><b>huddle
    llength</b> <i>object</i></a></dt>
  <dd>The same as <b>llength</b>.</dd>
  <dt id="huddle~13"><a class="permalink" href="#huddle~13"><b>huddle type</b>
    <i>object</i> ?<i>key key...</i>?</a></dt>
  <dd>Return the element type of specified by keys. if ?key? is not given,
      returns the type of root node.
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="string"><a class="permalink" href="#string"><b></b><b>string</b></a></dt>
  <dd>the node is a tcl's string.</dd>
  <dt id="dict"><a class="permalink" href="#dict"><b></b><b>dict</b></a></dt>
  <dd>the node is a dict.</dd>
  <dt id="list"><a class="permalink" href="#list"><b></b><b>list</b></a></dt>
  <dd>the node is a list.</dd>
</dl>
</div>
<pre>
% huddle type {HUDDLE {s str}}
string
% huddle type {HUDDLE {L {{s a} {s b} {s c}}}}
list
% huddle type {HUDDLE {D {aa {s b} cc {s d}}}} cc
string
</pre>
<dl class="Bl-tag">
  <dt id="huddle~14"><a class="permalink" href="#huddle~14"><b>huddle strip</b>
    <i>object</i></a></dt>
  <dd>Stripped all tags. Converted to normal Tcl's list/dict.</dd>
  <dt id="huddle~15"><a class="permalink" href="#huddle~15"><b>huddle
    jsondump</b> <i>object</i> ?<i>offset</i>? ?<i>newline</i>?
    ?<i>begin_offset</i>?</a></dt>
  <dd>dump a json-stream from the huddle-object.
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="offset"><a class="permalink" href="#offset"><b></b><b>offset</b>
    &quot;&quot;</a></dt>
  <dd>begin offset as spaces &quot; &quot;.</dd>
</dl>
</div>
<pre>
# normal output has some indents. some strings are escaped.
% huddle jsondump {HUDDLE {L {{L {{s i} {s baa} {s \\k} {L {{s 1.0} {s true} {s /g} {s h}}} {L {{s g}}}}} {s t}}}}
[
  [
    &quot;i&quot;,
    &quot;baa&quot;,
    &quot;\\k&quot;,
    [
      1.0,
      true,
      &quot;\/g&quot;,
      &quot;h&quot;
    ],
    [&quot;g&quot;]
  ],
  &quot;t&quot;
]
# stripped output
% huddle jsondump {HUDDLE {D {dd {D {bb {D {a {s baa} c {s {d
a}}}} cc {D {g {s h}}}}} ee {D {i {s j} k {s 1} j {s { m\a}}}}}}} &quot;&quot; &quot;&quot;
{&quot;dd&quot;: {&quot;bb&quot;: {&quot;a&quot;: &quot;baa&quot;,&quot;c&quot;: &quot;d\na&quot;},&quot;cc&quot;: {&quot;g&quot;: &quot;h&quot;}},&quot;ee&quot;: {&quot;i&quot;: &quot;j&quot;,&quot;k&quot;: 1,&quot;j&quot;: &quot; m\\a&quot;}}
</pre>
<dl class="Bl-tag">
  <dt id="huddle~16"><a class="permalink" href="#huddle~16"><b>huddle
    compile</b> <i>spec</i> <i>data</i></a></dt>
  <dd>construct a huddle object from plain old tcl values. <i>spec</i> is
      defined as follows:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="string~2"><a class="permalink" href="#string~2"><b>string</b></a></dt>
  <dd>data is simply a string</dd>
  <dt id="list~2"><a class="permalink" href="#list~2"><b>list</b></a></dt>
  <dd>data is a tcl list of strings</dd>
  <dt id="dict~2"><a class="permalink" href="#dict~2"><b>dict</b></a></dt>
  <dd>data is a tcl dict of strings</dd>
  <dt id="list~3"><a class="permalink" href="#list~3">list list</a></dt>
  <dd>data is a tcl list of lists</dd>
  <dt id="list~4"><a class="permalink" href="#list~4">list dict</a></dt>
  <dd>data is a tcl list of dicts</dd>
  <dt id="dict~3"><a class="permalink" href="#dict~3">dict xx list</a></dt>
  <dd>data is a tcl dict where the value of key xx is a tcl list</dd>
  <dt id="dict~4"><a class="permalink" href="#dict~4">dict * list</a></dt>
  <dd>data is a tcl dict of lists <i>data</i> is plain old tcl values</dd>
</dl>
</div>
<pre>
% huddle compile {dict * list} {a {1 2 3} b {4 5}}
HUDDLE {D {a {L {{s 1} {s 2} {s 3}}} b {L {{s 4} {s 5}}}}}
% huddle compile {dict * {list {dict d list}}} {a {{c 1} {d {2 2 2} e 3}} b {{f 4 g 5}}}
HUDDLE {D {a {L {{D {c {s 1}}} {D {d {L {{s 2} {s 2} {s 2}}} e {s 3}}}}} b {L {{D {f {s 4} g {s 5}}}}}}}
</pre>
<dl class="Bl-tag">
  <dt id="huddle~17"><a class="permalink" href="#huddle~17"><b>huddle
    isHuddle</b> <i>object</i></a></dt>
  <dd>if <i>object</i> is a huddle, returns 1. the other, returns 0.</dd>
  <dt id="huddle~18"><a class="permalink" href="#huddle~18"><b>huddle
    checkHuddle</b> <i>object</i></a></dt>
  <dd>if <i>object</i> is not a huddle, rises an error.</dd>
  <dt id="huddle~19"><a class="permalink" href="#huddle~19"><b>huddle
    to_node</b> <i>object</i> ?<i>tag</i>?</a></dt>
  <dd>for type-callbacks.
    <p class="Pp">if <i>object</i> is a huddle, returns root-node. the other,
        returns <b>[list s $object]</b>.</p>
    <pre>
% huddle to_node str
s str
% huddle to_node str !!str
!!str str
% huddle to_node {HUDDLE {s str}}
s str
% huddle to_node {HUDDLE {l {a b c}}}
l {a b c}
    </pre>
  </dd>
  <dt id="huddle~20"><a class="permalink" href="#huddle~20"><b>huddle wrap</b>
    <i>tag</i> <i>src</i></a></dt>
  <dd>for type-callbacks.
    <p class="Pp">Create a huddle object from <i>src</i> with specified
        <i>tag</i>.</p>
    <pre>
% huddle wrap &quot;&quot; str
HUDDLE str
% huddle wrap s str
HUDDLE {s str}
    </pre>
  </dd>
  <dt id="huddle~21"><a class="permalink" href="#huddle~21"><b>huddle call</b>
    <i>tag</i> <i>command</i> <i>args</i></a></dt>
  <dd>for type-callbacks.
    <p class="Pp">devolving <i>command</i> to default <i>tag</i>-callback</p>
  </dd>
  <dt id="huddle~22"><a class="permalink" href="#huddle~22"><b>huddle
    addType</b> <i>callback</i></a></dt>
  <dd>add a user-specified-type/tag to the huddle library. To see
      &quot;Additional Type&quot;.
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="callback"><a class="permalink" href="#callback"><b>callback</b></a></dt>
  <dd>callback function name for additional type.</dd>
</dl>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="TYPE_CALLBACK"><a class="permalink" href="#TYPE_CALLBACK">TYPE
  CALLBACK</a></h1>
<p class="Pp">The definition of callback for user-type.</p>
<dl class="Bl-tag">
  <dt id="callback~2"><a class="permalink" href="#callback~2"><b>callback</b>
    <i>command</i> ?<i>args</i>?</a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="command"><a class="permalink" href="#command"><b>command</b></a></dt>
  <dd>huddle subcomand which is needed to reply by the callback.</dd>
  <dt id="args"><a class="permalink" href="#args"><b>args</b></a></dt>
  <dd>arguments of subcommand. The number of list of arguments is different for
      each subcommand.</dd>
</dl>
</div>
<p class="Pp">The callback procedure shuould reply the following
  subcommands.</p>
<dl class="Bl-tag">
  <dt id="setting"><a class="permalink" href="#setting"><b>setting</b></a></dt>
  <dd>only returns a fixed dict of the type infomation for setting the
    user-tag.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="type"><a class="permalink" href="#type"><b>type</b> typename</a></dt>
  <dd>typename of the type</dd>
  <dt id="method"><a class="permalink" href="#method"><b>method</b> {method1
    method2 method3 ...}</a></dt>
  <dd>method list as huddle subcommand. Then, you can call <b>[huddle method1
      ...]</b></dd>
  <dt id="tag"><a class="permalink" href="#tag"><b>tag</b> {tag1 child/parent
    tag2 child/parent ...}</a></dt>
  <dd>tag list for huddle-node as a dict. if the type has child-nodes, use
      &quot;parent&quot;, otherwise use &quot;child&quot;.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="get_sub"><a class="permalink" href="#get_sub"><b>get_sub</b>
    <i>src</i> <i>key</i></a></dt>
  <dd>returns a sub node specified by <i>key</i>.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="src"><a class="permalink" href="#src"><b>src</b></a></dt>
  <dd>a node content in huddle object.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="strip"><a class="permalink" href="#strip"><b>strip</b>
    <i>src</i></a></dt>
  <dd>returns stripped node contents. if the type has child nodes, every node
      must be stripped.</dd>
  <dt id="set"><a class="permalink" href="#set"><b>set</b> <i>src</i> <i>key</i>
    <i>value</i></a></dt>
  <dd>sets a sub-node from the tagged-content, and returns self.</dd>
  <dt id="remove"><a class="permalink" href="#remove"><b>remove</b> <i>src</i>
    <i>key</i> <i>value</i></a></dt>
  <dd>removes a sub-node from the tagged-content, and returns self.</dd>
</dl>
<p class="Pp"><b>strip</b> must be defined at all types. <b>get_sub</b> must be
    defined at container types. <b>set/remove</b> shuould be defined, if you
    call them.</p>
<pre>
# callback sample for my-dict
proc my_dict_setting {command args} {
    switch -- $command {
        setting { ; # type definition
            return {
                type dict
                method {create keys}
                tag {d child D parent}
                constructor create
                str s
            }
            # type:   the type-name
            # method: add methods to huddle's subcommand.
            #          &quot;get_sub/strip/set/remove/equal/append&quot; called by huddle module.
            #          &quot;strip&quot; must be defined at all types.
            #          &quot;get_sub&quot; must be defined at container types.
            #          &quot;set/remove/equal/append&quot; shuould be defined, if you call them.
            # tag:    tag definition(&quot;child/parent&quot; word is maybe obsoleted)
        }
        get_sub { ; # get a sub-node specified by &quot;key&quot; from the tagged-content
            foreach {src key} $args break
            return [dict get $src $key]
        }
        strip { ; # strip from the tagged-content
            foreach {src nop} $args break
            foreach {key val} $src {
                lappend result $key [huddle strip $val]
            }
            return $result
        }
        set { ; # set a sub-node from the tagged-content
            foreach {src key value} $args break
            dict set src $key $value
            return $src
        }
        remove { ; # remove a sub-node from the tagged-content
            foreach {src key value} $args break
            return [dict remove $src $key]
        }
        equal { ; # check equal for each node
            foreach {src1 src2} $args break
            if {[llength $src1] != [llength $src2]} {return 0}
            foreach {key1 val1} $src1 {
                if {![dict exists $src2 $key1]} {return 0}
                if {![huddle _equal_subs $val1 [dict get $src2 $key1]]} {return 0}
            }
            return 1
        }
        append { ; # append nodes
            foreach {str src list} $args break
            if {[llength $list] % 2} {error {wrong # args: should be &quot;huddle append objvar ?key value ...?&quot;}}
            set resultL $src
            foreach {key value} $list {
                if {$str ne &quot;&quot;} {
                    lappend resultL $key [huddle to_node $value $str]
                } else {
                    lappend resultL $key $value
                }
            }
            return [eval dict create $resultL]
        }
        create { ; # $args: all arguments after &quot;huddle create&quot;
            if {[llength $args] % 2} {error {wrong # args: should be &quot;huddle create ?key value ...?&quot;}}
            set resultL {}
            foreach {key value} $args {
                lappend resultL $key [huddle to_node $value]
            }
            return [huddle wrap D $resultL]
        }
        keys {
            foreach {src nop} $args break
            return [dict keys [lindex [lindex $src 1] 1]]
        }
        default {
            error &quot;$command is not callback for dict&quot;
        }
    }
}
</pre>
<pre>
# inheritance sample from default dict-callback
proc ::yaml::_huddle_mapping {command args} {
    switch -- $command {
        setting { ; # type definition
            return {
                type dict
                method {mapping}
                tag {!!map parent}
                constructor mapping
                str !!str
            }
        }
        mapping { ; # $args: all arguments after &quot;huddle mapping&quot;
            if {[llength $args] % 2} {error {wrong # args: should be &quot;huddle mapping ?key value ...?&quot;}}
            set resultL {}
            foreach {key value} $args {
                lappend resultL $key [huddle to_node $value !!str]
            }
            return [huddle wrap !!map $resultL]
        }
        default { ; # devolving to default dict-callback
            return [huddle call D $command $args]
        }
    }
}
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="HOW_TO_ADD_TYPE"><a class="permalink" href="#HOW_TO_ADD_TYPE">HOW
  TO ADD TYPE</a></h1>
<p class="Pp">You can add huddle-node types e.g. ::struct::tree. To do so,
    first, define a callback-procedure for additional tagged-type. The proc get
    argments as <i>command</i> and ?<i>args</i>?. It has some
  switch-sections.</p>
<p class="Pp">And, addType subcommand will called.</p>
<pre>
huddle addType my_dict_setting
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="WORKING_SAMPLE"><a class="permalink" href="#WORKING_SAMPLE">WORKING
  SAMPLE</a></h1>
<pre>
# create as a dict
% set bb [huddle create a b c d]
HUDDLE {D {a {s b} c {s d}}}
# create as a list
% set cc [huddle list e f g h]
HUDDLE {L {{s e} {s f} {s g} {s h}}}
% set bbcc [huddle create bb $bb cc $cc]
HUDDLE {D {bb {D {a {s b} c {s d}}} cc {L {{s e} {s f} {s g} {s h}}}}}
% set folding [huddle list $bbcc p [huddle list q r] s]
HUDDLE {L {{D {bb {D {a {s b} c {s d}}} cc {L {{s e} {s f} {s g} {s h}}}}} {s p} {L {{s q} {s r}}} {s s}}}
# normal Tcl's notation
% huddle strip $folding
{bb {a b c d} cc {e f g h}} p {q r} s
# get a sub node
% huddle get $folding 0 bb
HUDDLE {D {a {s b} c {s d}}}
% huddle gets $folding 0 bb
a b c d
# overwrite a node
% huddle set folding 0 bb c kkk
HUDDLE {L {{D {bb {D {a {s b} c {s kkk}}} cc {L {{s e} {s f} {s g} {s h}}}}} {s p} {L {{s q} {s r}}} {s s}}}
# remove a node
% huddle remove $folding 2 1
HUDDLE {L {{D {bb {D {a {s b} c {s kkk}}} cc {L {{s e} {s f} {s g} {s h}}}}} {s p} {L {{s q}}} {s s}}}
% huddle strip $folding
{bb {a b c kkk} cc {e f g h}} p {q r} s
# dump as a JSON stream
% huddle jsondump $folding
[
  {
    &quot;bb&quot;: {
      &quot;a&quot;: &quot;b&quot;,
      &quot;c&quot;: &quot;kkk&quot;
    },
    &quot;cc&quot;: [
      &quot;e&quot;,
      &quot;f&quot;,
      &quot;g&quot;,
      &quot;h&quot;
    ]
  },
  &quot;p&quot;,
  [
    &quot;q&quot;,
    &quot;r&quot;
  ],
  &quot;s&quot;
]
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="LIMITATIONS"><a class="permalink" href="#LIMITATIONS">LIMITATIONS</a></h1>
<p class="Pp">now printing.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS,_IDEAS,_FEEDBACK"><a class="permalink" href="#BUGS,_IDEAS,_FEEDBACK">BUGS,
  IDEAS, FEEDBACK</a></h1>
<p class="Pp">This document, and the package it describes, will undoubtedly
    contain bugs and other problems. Please report such in the category
    <i>huddle</i> of the <i>Tcllib SF Trackers</i>
    [http://sourceforge.net/tracker/?group_id=12883]. Please also report any
    ideas for enhancements you may have for either package and/or
  documentation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">yaml</p>
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
<p class="Pp">data exchange, exchange format, huddle, json, parsing, text
    processing, yaml</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<pre>
Copyright (c) 2008 KATO Kanryu &lt;kanryu6@users.sourceforge.net&gt;
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">0.1.4</td>
    <td class="foot-os">yaml</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Generated from file '/AppleInternal/Library/BuildRoots/66382bca-8bca-11ec-aade-6613bcf0e2ee/Library/Caches/com.apple.xbs/Sources/tcl/tcl_ext/tcllib/tcllib/modules/rcs/rcs.man' by tcllib/doctools with format 'nroff'
   Copyright (c) 2005, Andreas Kupries <andreas_kupries@users.sourceforge.net>
   Copyright (c) 2005, Colin McCormack <coldstore@users.sourceforge.net>
  
   The definitions below are for supplemental macros used in Tcl/Tk
   manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO
  	Start of list of standard options for a Tk widget.  The
  	options follow on successive lines, in four columns separated
  	by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   RCS: @(#) $Id: man.macros,v 1.1 2009/01/30 04:56:47 andreas_kupries Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>rcs(n)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">rcs(n)</td>
    <td class="head-vol">RCS low level utilities</td>
    <td class="head-rtitle">rcs(n)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>

</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">rcs - RCS low level utilities</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">package require <b>Tcl 8.4</b></p>
<p class="Pp">package require <b>rcs ?0.1?</b></p>
<p class="Pp"><b>::rcs::text2dict</b> <i>text</i></p>
<p class="Pp"><b>::rcs::dict2text</b> <i>dict</i></p>
<p class="Pp"><b>::rcs::file2dict</b> <i>filename</i></p>
<p class="Pp"><b>::rcs::dict2file</b> <i>filename</i> <i>dict</i></p>
<p class="Pp"><b>::rcs::decodeRcsPatch</b> <i>text</i></p>
<p class="Pp"><b>::rcs::encodeRcsPatch</b> <i>pcmds</i></p>
<p class="Pp"><b>::rcs::applyRcsPatch</b> <i>text</i> <i>pcmds</i></p>
<p class="Pp"></p>
<pre>

</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The <i>Revision Control System</i>, short <i>RCS</i>, is a set of
    applications and related data formats which allow a system to persist the
    history of changes to a text. It, and its relative SCCS are the basis for
    many other such systems, like <i>CVS</i>, etc.</p>
<p class="Pp">This package <i>does not</i> implement RCS.</p>
<p class="Pp">It only provides a number of low level commands which should be
    useful in the implementation of any revision management system, namely:</p>
<dl class="Bl-tag">
  <dt>[1]</dt>
  <dd>The conversion of texts into and out of a data structures which allow the
      easy modification of such text by <i>patches</i>, i.e. sequences of
      instructions for the transformation of one text into an other.</dd>
  <dt>[2]</dt>
  <dd>And the conversion of one particular format for patches, the so-called
      <i>RCS patches</i>, into and out of data structures which allow their easy
      application to texts.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="COMMANDS"><a class="permalink" href="#COMMANDS">COMMANDS</a></h1>
<dl class="Bl-tag">
  <dt><b>::rcs::text2dict</b> <i>text</i></dt>
  <dd>Converts the argument <i>text</i> into a dictionary containing and
      representing the same text in an indexed form and returns that dictionary
      as its result. More information about the format of the result can be
      found in section <b>TEXT DICT DATA STRUCTURE</b>. This command returns the
      <i>canonical</i> representation of the input.</dd>
  <dt><b>::rcs::dict2text</b> <i>dict</i></dt>
  <dd>This command provides the complementary operation to
      <b>::rcs::text2dict</b>. It converts a dictionary in the form described in
      section <b>TEXT DICT DATA STRUCTURE</b> back into a text and returns that
      text as its result. The command does accept non-canonical representations
      of the text as its input.</dd>
  <dt><b>::rcs::file2dict</b> <i>filename</i></dt>
  <dd>This command is identical to <b>::rcs::text2dict</b>, except that it reads
      the text to convert from the file with path <i>filename</i>. The file has
      to exist and must be readable as well.</dd>
  <dt><b>::rcs::dict2file</b> <i>filename</i> <i>dict</i></dt>
  <dd>This command is identical to <b>::rcs::2dict2text</b>, except that it
      stores the resulting text in the file with path <i>filename</i>. The file
      is created if it did not exist, and must be writable. The result of the
      command is the empty string.</dd>
  <dt><b>::rcs::decodeRcsPatch</b> <i>text</i></dt>
  <dd>Converts the <i>text</i> argument into a patch command list (PCL) as
      specified in the section <b>RCS PATCH COMMAND LIST</b> and returns this
      list as its result. It is assumed that the input text is in <i>diff -n
      format</i>, also known as <i>RCS patch</i> format, as specified in the
      section <b>RCS PATCH FORMAT</b>. Please note that the command ignores
      no-ops in the input, in other words the resulting PCL contains only
      instructions doing something.</dd>
  <dt><b>::rcs::encodeRcsPatch</b> <i>pcmds</i></dt>
  <dd>This command provides the complementary operation to
      <b>::rcs::decodeRcsPatch</b>. It convert a patch comand list (PCL) list as
      specified in the section <b>RCS PATCH COMMAND LIST</b> back into a text in
      <b>RCS PATCH FORMAT</b> and returns that text as its result.
    <p class="Pp">Note that this command and <b>::rcs::decodeRcsPatch</b> are
        not exactly complementary, as the latter strips no-ops from its input,
        which the encoder cannot put back anymore into the generated RCS patch.
        In other words, the result of a decode/encode step may not match the
        original input at the character level, but it will match it at the
        functional level.</p>
  </dd>
  <dt><b>::rcs::applyRcsPatch</b> <i>text</i> <i>pcmds</i></dt>
  <dd>This operation applies a patch in the form of a PCL to a text given in the
      form of a dictionary and returns the modified text, again as dictionary,
      as its result.
    <p class="Pp">To handle actual text use the commands <b>::rcs::text2dict</b>
        (or equivalent) and <b>::rcs::decodeRcsPatch</b> to transform the inputs
        into data structures acceptable to this command. Analogously use the
        command <b>::rcs::dict2text</b> (or equivalent) to transform the result
        of this command into actuall text as required.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="TEXT_DICT_DATA_STRUCTURE"><a class="permalink" href="#TEXT_DICT_DATA_STRUCTURE">TEXT
  DICT DATA STRUCTURE</a></h1>
<p class="Pp">A text dictionary is a dictionary whose keys are integer numbers
    and text strings as the associated values. The keys represent the line
    numbers of a text and the values the text of that line. Note that one text
    can have many representations as a dictionary, as the index values only have
    to be properly ordered for reconstruction, their exact values do not matter.
    Similarly the strings may actually span multiple physical lines.</p>
<p class="Pp">The text</p>
<p class="Pp"></p>
<pre>
Hello World,
how are you ?
Fine, and you ?
</pre>
<p class="Pp">for example can be represented by</p>
<p class="Pp"></p>
<pre>
{{1 {Hello World,}} {2 {how are you ?}} {3 {Fine, and you ?}}}
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre>
{{5 {Hello World,}} {8 {how are you ?}} {9 {Fine, and you ?}}}
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre>
{{-1 {Hello World,
how are you ?}} {4 {Fine, and you ?}}}
</pre>
<p class="Pp">The first dictionary is the <i>canonical</i> representation of the
    text, with line numbers starting at <b>1</b>, increasing in steps of
    <b>1</b> and without gaps, and each value representing exactly one physical
    line.</p>
<p class="Pp">All the commands creating dictionaries from text will return the
    canonical representation of their input text. The commands taking a
    dictionary and returning text will generally accept all representations,
    canonical or not.</p>
<p class="Pp">The result of applying a patch to a text dictionary will in
    general cause the dictionary to become non-canonical.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="RCS_PATCH_FORMAT"><a class="permalink" href="#RCS_PATCH_FORMAT">RCS
  PATCH FORMAT</a></h1>
<p class="Pp">A <i>patch</i> is in general a series of instructions how to
    transform an input text T into a different text T', and also encoded in text
    form as well.</p>
<p class="Pp">The text format for patches understood by this package is a very
    simple one, known under the names <i>RCS patch</i> or <i>diff -n
  format</i>.</p>
<p class="Pp">Patches in this format contain only two different commands, for
    the deletion of old text, and addition of new text. The replacement of some
    text by a different text is handled as combination of a deletion following
    by an addition.</p>
<p class="Pp">The format is line oriented, with each line containing either a
    command or text data associated with the preceding command. The first line
    of a <i>RCS patch</i> is always a command line.</p>
<p class="Pp">The commands are:</p>
<dl class="Bl-tag">
  <dt>&quot;&quot;</dt>
  <dd>The empty line is a command which does nothing.</dd>
  <dt>&quot;a<b>start</b> <b>n</b>&quot;</dt>
  <dd>A line starting with the character <b>a</b> is a command for the addition
      of text to the output. It is followed by <b>n</b> lines of text data. When
      applying the patch the data is added just between the lines <b>start</b>
      and <b>start</b>+1. The same effect is had by appending the data to the
      existing text on line <b>start</b>. A non-existing line <b>start</b> is
      created.</dd>
  <dt>&quot;d<b>start</b> <b>n</b>&quot;</dt>
  <dd>A line starting with the character <b>d</b> is a command for the deletion
      of text from the output. When applied it deletes <b>n</b> lines of text,
      and the first line deleted is at index <b>start</b>.</dd>
</dl>
<p class="Pp">Note that the line indices <b>start</b> always refer to the text
    which is transformed as it is in its original state, without taking the
    precending changes into account.</p>
<p class="Pp">Note also that the instruction have to be applied in the order
    they occur in the patch, or in a manner which produces the same result as
    in-order application.</p>
<p class="Pp">This is the format of results returned by the command
    <b>::rcs::decodeRcsPatch</b> and accepted by the commands
    <b>::rcs::encodeRcsPatch</b> and <b>::rcs::appplyRcsPatch</b> resp. Note
    however that the decoder will strip no-op commands, and the encoder will not
    generate no-ops, making them not fully complementary at the textual level,
    only at the functional level.</p>
<p class="Pp">And example of a RCS patch is</p>
<p class="Pp"></p>
<pre>
d1 2
d4 1
a4 2
The named is the mother of all things.
a11 3
They both may be called deep and profound.
Deeper and more profound,
The door of all subtleties!
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="RCS_PATCH_COMMAND_LIST"><a class="permalink" href="#RCS_PATCH_COMMAND_LIST">RCS
  PATCH COMMAND LIST</a></h1>
<p class="Pp">Patch command lists (sort: PCL's) are the data structures
    generated by patch decoder command and accepted by the patch encoder and
    applicator commands. They represent RCS patches in the form of Tcl data
    structures.</p>
<p class="Pp">A PCL is a list where each element represents a single patch
    instruction, either an addition, or a deletion. The elements are lists
    themselves, where the first item specifies the command and the remainder
    represent the arguments of the command.</p>
<dl class="Bl-tag">
  <dt id="a"><a class="permalink" href="#a">a</a></dt>
  <dd>This is the instruction for the addition of text. It has two arguments,
      the index of the line where to add the text, and the text to add, in this
      order.</dd>
  <dt id="d"><a class="permalink" href="#d">d</a></dt>
  <dd>This is the instruction for the deletion of text. It has two arguments,
      the index of the line where to start deleting text, and the number of
      lines to delete, in this order.</dd>
</dl>
<p class="Pp">This is the format returned by the patch decoder command and
    accepted as input by the patch encoder and applicator commands.</p>
<p class="Pp">An example for a patch command is shown below, it represents the
    example RCS patch found in section <b>RCS PATCH FORMAT</b>.</p>
<p class="Pp"></p>
<pre>
{{d 1 2} {d 4 1} {a 4 {The named is the mother of all things.
}} {a 11 {They both may be called deep and profound.
Deeper and more profound,
The door of all subtleties!}}}
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS,_IDEAS,_FEEDBACK"><a class="permalink" href="#BUGS,_IDEAS,_FEEDBACK">BUGS,
  IDEAS, FEEDBACK</a></h1>
<p class="Pp">This document, and the package it describes, will undoubtedly
    contain bugs and other problems. Please report such in the category
    <i>rcs</i> of the <i>Tcllib SF Trackers</i>
    [http://sourceforge.net/tracker/?group_id=12883]. Please also report any
    ideas for enhancements you may have for either package and/or
  documentation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">struct, textutil</p>
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
<p class="Pp">CVS, RCS, RCS patch, SCCS, diff -n format, patching, text
    conversion, text differences</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CATEGORY"><a class="permalink" href="#CATEGORY">CATEGORY</a></h1>
<p class="Pp">Text processing</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<pre>
Copyright (c) 2005, Andreas Kupries &lt;andreas_kupries@users.sourceforge.net&gt;
Copyright (c) 2005, Colin McCormack &lt;coldstore@users.sourceforge.net&gt;
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2.0.2</td>
    <td class="foot-os">rcs</td>
  </tr>
</table>
</body>
</html>

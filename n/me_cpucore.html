<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Copyright (c) 2005-2006 Andreas Kupries <andreas_kupries@users.sourceforge.net>
  
   The definitions below are for supplemental macros used in Tcl/Tk
   manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO
  	Start of list of standard options for a Tk widget.  The
  	options follow on successive lines, in four columns separated
  	by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   RCS: @(#) $Id: man.macros,v 1.1 2009/01/30 04:56:47 andreas_kupries Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>grammar::me::cpu::core(n)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">grammar::me::cpu::core(n)</td>
    <td class="head-vol"><a href=".">Grammar operations and usage</a></td>
    <td class="head-rtitle">grammar::me::cpu::core(n)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>
</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">grammar::me::cpu::core - ME virtual machine state manipulation</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">package require <b>Tcl 8.4</b></p>
<p class="Pp">package require <b>grammar::me::cpu::core ?0.2?</b></p>
<p class="Pp"><b>::grammar::me::cpu::core</b> <b>disasm</b> <i>asm</i></p>
<p class="Pp"><b>::grammar::me::cpu::core</b> <b>asm</b> <i>asm</i></p>
<p class="Pp"><b>::grammar::me::cpu::core</b> <b>new</b> <i>asm</i></p>
<p class="Pp"><b>::grammar::me::cpu::core</b> <b>lc</b> <i>state</i>
    <i>location</i></p>
<p class="Pp"><b>::grammar::me::cpu::core</b> <b>tok</b> <i>state</i>
    ?<i>from</i> ?<i>to</i>??</p>
<p class="Pp"><b>::grammar::me::cpu::core</b> <b>pc</b> <i>state</i></p>
<p class="Pp"><b>::grammar::me::cpu::core</b> <b>iseof</b> <i>state</i></p>
<p class="Pp"><b>::grammar::me::cpu::core</b> <b>at</b> <i>state</i></p>
<p class="Pp"><b>::grammar::me::cpu::core</b> <b>cc</b> <i>state</i></p>
<p class="Pp"><b>::grammar::me::cpu::core</b> <b>sv</b> <i>state</i></p>
<p class="Pp"><b>::grammar::me::cpu::core</b> <b>ok</b> <i>state</i></p>
<p class="Pp"><b>::grammar::me::cpu::core</b> <b>error</b> <i>state</i></p>
<p class="Pp"><b>::grammar::me::cpu::core</b> <b>lstk</b> <i>state</i></p>
<p class="Pp"><b>::grammar::me::cpu::core</b> <b>astk</b> <i>state</i></p>
<p class="Pp"><b>::grammar::me::cpu::core</b> <b>mstk</b> <i>state</i></p>
<p class="Pp"><b>::grammar::me::cpu::core</b> <b>estk</b> <i>state</i></p>
<p class="Pp"><b>::grammar::me::cpu::core</b> <b>rstk</b> <i>state</i></p>
<p class="Pp"><b>::grammar::me::cpu::core</b> <b>nc</b> <i>state</i></p>
<p class="Pp"><b>::grammar::me::cpu::core</b> <b>ast</b> <i>state</i></p>
<p class="Pp"><b>::grammar::me::cpu::core</b> <b>halted</b> <i>state</i></p>
<p class="Pp"><b>::grammar::me::cpu::core</b> <b>code</b> <i>state</i></p>
<p class="Pp"><b>::grammar::me::cpu::core</b> <b>eof</b> <i>statevar</i></p>
<p class="Pp"><b>::grammar::me::cpu::core</b> <b>put</b> <i>statevar</i>
    <i>tok</i> <i>lex</i> <i>line</i> <i>col</i></p>
<p class="Pp"><b>::grammar::me::cpu::core</b> <b>run</b> <i>statevar</i>
    ?<i>n</i>?</p>
<p class="Pp"></p>
<pre>
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This package provides an implementation of the ME virtual machine.
    Please go and read the document <b>grammar::me_intro</b> first if you do not
    know what a ME virtual machine is.</p>
<p class="Pp">This implementation represents each ME virtual machine as a Tcl
    value and provides commands to manipulate and query such values to show the
    effects of executing instructions, adding tokens, retrieving state, etc.</p>
<p class="Pp">The values fully follow the paradigm of Tcl that every value is a
    string and while also allowing C implementations for a proper Tcl_ObjType to
    keep all the important data in native data structures. Because of the latter
    it is recommended to access the state values <i>only</i> through the
    commands of this package to ensure that internal representation is not
    shimmered away.</p>
<p class="Pp">The actual structure used by all state values is described in
    section <b>CPU STATE</b>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="API"><a class="permalink" href="#API">API</a></h1>
<p class="Pp">The package directly provides only a single command, and all the
    functionality is made available through its methods.</p>
<dl class="Bl-tag">
  <dt><b>::grammar::me::cpu::core</b> <b>disasm</b> <i>asm</i></dt>
  <dd>This method returns a list containing a disassembly of the match
      instructions in <i>asm</i>. The format of <i>asm</i> is specified in the
      section <b>MATCH PROGRAM REPRESENTATION</b>.
    <p class="Pp">Each element of the result contains instruction label,
        instruction name, and the instruction arguments, in this order. The
        label can be the empty string. Jump destinations are shown as labels,
        strings and tokens unencoded. Token names are prefixed with their
        numeric id, if, and only if a tokmap is defined. The two components are
        separated by a colon.</p>
  </dd>
  <dt><b>::grammar::me::cpu::core</b> <b>asm</b> <i>asm</i></dt>
  <dd>This method returns code in the format as specified in section <b>MATCH
      PROGRAM REPRESENTATION</b> generated from ME assembly code <i>asm</i>,
      which is in the format as returned by the method <b>disasm</b>.</dd>
  <dt><b>::grammar::me::cpu::core</b> <b>new</b> <i>asm</i></dt>
  <dd>This method creates state value for a ME virtual machine in its initial
      state and returns it as its result.
    <p class="Pp">The argument <i>matchcode</i> contains a Tcl representation of
        the match instructions the machine has to execute while parsing the
        input stream. Its format is specified in the section <b>MATCH PROGRAM
        REPRESENTATION</b>.</p>
    <p class="Pp">The <i>tokmap</i> argument taken by the implementation
        provided by the package <b>grammar::me::tcl</b> is here hidden inside of
        the match instructions and therefore not needed.</p>
  </dd>
  <dt><b>::grammar::me::cpu::core</b> <b>lc</b> <i>state</i>
    <i>location</i></dt>
  <dd>This method takes the state value of a ME virtual machine and uses it to
      convert a location in the input stream (as offset) into a line number and
      column index. The result of the method is a 2-element list containing the
      two pieces in the order mentioned in the previous sentence.
    <p class="Pp"><i>Note</i> that the method cannot convert locations which the
        machine has not yet read from the input stream. In other words, if the
        machine has read 7 characters so far it is possible to convert the
        offsets <b>0</b> to <b>6</b>, but nothing beyond that. This also shows
        that it is not possible to convert offsets which refer to locations
        before the beginning of the stream.</p>
    <p class="Pp">This utility allows higher levels to convert the location
        offsets found in the error status and the AST into more human readable
        data.</p>
  </dd>
  <dt><b>::grammar::me::cpu::core</b> <b>tok</b> <i>state</i> ?<i>from</i>
    ?<i>to</i>??</dt>
  <dd>This method takes the state value of a ME virtual machine and returns a
      Tcl list containing the part of the input stream between the locations
      <i>from</i> and <i>to</i> (both inclusive). If <i>to</i> is not specified
      it will default to the value of <i>from</i>. If <i>from</i> is not
      specified either the whole input stream is returned.
    <p class="Pp">This method places the same restrictions on its location
        arguments as the method <b>lc</b>.</p>
  </dd>
  <dt><b>::grammar::me::cpu::core</b> <b>pc</b> <i>state</i></dt>
  <dd>This method takes the state value of a ME virtual machine and returns the
      current value of the stored program counter.</dd>
  <dt><b>::grammar::me::cpu::core</b> <b>iseof</b> <i>state</i></dt>
  <dd>This method takes the state value of a ME virtual machine and returns the
      current value of the stored eof flag.</dd>
  <dt><b>::grammar::me::cpu::core</b> <b>at</b> <i>state</i></dt>
  <dd>This method takes the state value of a ME virtual machine and returns the
      current location in the input stream.</dd>
  <dt><b>::grammar::me::cpu::core</b> <b>cc</b> <i>state</i></dt>
  <dd>This method takes the state value of a ME virtual machine and returns the
      current token.</dd>
  <dt><b>::grammar::me::cpu::core</b> <b>sv</b> <i>state</i></dt>
  <dd>This method takes the state value of a ME virtual machine and returns the
      current semantic value stored in it. This is an abstract syntax tree as
      specified in the document <b>grammar::me_ast</b>, section <b>AST
      VALUES</b>.</dd>
  <dt><b>::grammar::me::cpu::core</b> <b>ok</b> <i>state</i></dt>
  <dd>This method takes the state value of a ME virtual machine and returns the
      match status stored in it.</dd>
  <dt><b>::grammar::me::cpu::core</b> <b>error</b> <i>state</i></dt>
  <dd>This method takes the state value of a ME virtual machine and returns the
      current error status stored in it.</dd>
  <dt><b>::grammar::me::cpu::core</b> <b>lstk</b> <i>state</i></dt>
  <dd>This method takes the state value of a ME virtual machine and returns the
      location stack.</dd>
  <dt><b>::grammar::me::cpu::core</b> <b>astk</b> <i>state</i></dt>
  <dd>This method takes the state value of a ME virtual machine and returns the
      AST stack.</dd>
  <dt><b>::grammar::me::cpu::core</b> <b>mstk</b> <i>state</i></dt>
  <dd>This method takes the state value of a ME virtual machine and returns the
      AST marker stack.</dd>
  <dt><b>::grammar::me::cpu::core</b> <b>estk</b> <i>state</i></dt>
  <dd>This method takes the state value of a ME virtual machine and returns the
      error stack.</dd>
  <dt><b>::grammar::me::cpu::core</b> <b>rstk</b> <i>state</i></dt>
  <dd>This method takes the state value of a ME virtual machine and returns the
      subroutine return stack.</dd>
  <dt><b>::grammar::me::cpu::core</b> <b>nc</b> <i>state</i></dt>
  <dd>This method takes the state value of a ME virtual machine and returns the
      nonterminal match cache as a dictionary.</dd>
  <dt><b>::grammar::me::cpu::core</b> <b>ast</b> <i>state</i></dt>
  <dd>This method takes the state value of a ME virtual machine and returns the
      abstract syntax tree currently at the top of the AST stack stored in it.
      This is an abstract syntax tree as specified in the document
      <b>grammar::me_ast</b>, section <b>AST VALUES</b>.</dd>
  <dt><b>::grammar::me::cpu::core</b> <b>halted</b> <i>state</i></dt>
  <dd>This method takes the state value of a ME virtual machine and returns the
      current halt status stored in it, i.e. if the machine has stopped or
    not.</dd>
  <dt><b>::grammar::me::cpu::core</b> <b>code</b> <i>state</i></dt>
  <dd>This method takes the state value of a ME virtual machine and returns the
      code stored in it, i.e. the instructions executed by the machine.</dd>
  <dt><b>::grammar::me::cpu::core</b> <b>eof</b> <i>statevar</i></dt>
  <dd>This method takes the state value of a ME virtual machine as stored in the
      variable named by <i>statevar</i> and modifies it so that the eof flag
      inside is set. This signals to the machine that whatever token are in the
      input queue are the last to be processed. There will be no more.</dd>
  <dt><b>::grammar::me::cpu::core</b> <b>put</b> <i>statevar</i> <i>tok</i>
    <i>lex</i> <i>line</i> <i>col</i></dt>
  <dd>This method takes the state value of a ME virtual machine as stored in the
      variable named by <i>statevar</i> and modifies it so that the token
      <i>tok</i> is added to the end of the input queue, with associated lexeme
      data <i>lex</i> and <i>line</i>/<i>col</i>umn information.
    <p class="Pp">The operation will fail with an error if the eof flag of the
        machine has been set through the method <b>eof</b>.</p>
  </dd>
  <dt><b>::grammar::me::cpu::core</b> <b>run</b> <i>statevar</i> ?<i>n</i>?</dt>
  <dd>This method takes the state value of a ME virtual machine as stored in the
      variable named by <i>statevar</i>, executes a number of instructions and
      stores the state resulting from their modifications back into the
      variable.
    <p class="Pp">The execution loop will run until either</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li><i>n</i> instructions have been executed, or</li>
  <li>a halt instruction was executed, or</li>
  <li>the input queue is empty and the code is asking for more tokens to
      process.</li>
</ul>
</div>
<p class="Pp">If no limit <i>n</i> was set only the last two conditions are
    checked for.</p>
<section class="Ss">
<h2 class="Ss" id="MATCH_PROGRAM_REPRESENTATION"><a class="permalink" href="#MATCH_PROGRAM_REPRESENTATION">MATCH
  PROGRAM REPRESENTATION</a></h2>
<p class="Pp">A match program is represented by nested Tcl list. The first
    element, <i>asm</i>, is a list of integer numbers, the instructions to
    execute, and their arguments. The second element, <i>pool</i>, is a list of
    strings, referenced by the instructions, for error messages, token names,
    etc. The third element, <i>tokmap</i>, provides ordering information for the
    tokens, mapping their names to their numerical rank. This element can be
    empty, forcing lexicographic comparison when matching ranges.</p>
<p class="Pp">All ME instructions are encoded as integer numbers, with the
    mapping given below. A number of the instructions, those which handle error
    messages, have been given an additional argument to supply that message
    explicitly instead of having it constructed from token names, etc. This
    allows the machine state to store only the message ids instead of the full
    strings.</p>
<p class="Pp">Jump destination arguments are absolute indices into the
    <i>asm</i> element, refering to the instruction to jump to. Any string
    arguments are absolute indices into the <i>pool</i> element. Tokens,
    characters, messages, and token (actually character) classes to match are
    coded as references into the <i>pool</i> as well.</p>
<dl class="Bl-tag">
  <dt>[1]</dt>
  <dd>&quot;<b>ict_advance</b> <i>message</i>&quot;</dd>
  <dt>[2]</dt>
  <dd>&quot;<b>ict_match_token</b> <i>tok</i> <i>message</i>&quot;</dd>
  <dt>[3]</dt>
  <dd>&quot;<b>ict_match_tokrange</b> <i>tokbegin</i> <i>tokend</i>
      <i>message</i>&quot;</dd>
  <dt>[4]</dt>
  <dd>&quot;<b>ict_match_tokclass</b> <i>code</i> <i>message</i>&quot;</dd>
  <dt>[5]</dt>
  <dd>&quot;<b>inc_restore</b> <i>branchlabel</i> <i>nt</i>&quot;</dd>
  <dt>[6]</dt>
  <dd>&quot;<b>inc_save</b> <i>nt</i>&quot;</dd>
  <dt>[7]</dt>
  <dd>&quot;<b>icf_ntcall</b> <i>branchlabel</i>&quot;</dd>
  <dt>[8]</dt>
  <dd>&quot;<b>icf_ntreturn</b>&quot;</dd>
  <dt>[9]</dt>
  <dd>&quot;<b>iok_ok</b>&quot;</dd>
  <dt>[10]</dt>
  <dd>&quot;<b>iok_fail</b>&quot;</dd>
  <dt>[11]</dt>
  <dd>&quot;<b>iok_negate</b>&quot;</dd>
  <dt>[12]</dt>
  <dd>&quot;<b>icf_jalways</b> <i>branchlabel</i>&quot;</dd>
  <dt>[13]</dt>
  <dd>&quot;<b>icf_jok</b> <i>branchlabel</i>&quot;</dd>
  <dt>[14]</dt>
  <dd>&quot;<b>icf_jfail</b> <i>branchlabel</i>&quot;</dd>
  <dt>[15]</dt>
  <dd>&quot;<b>icf_halt</b>&quot;</dd>
  <dt>[16]</dt>
  <dd>&quot;<b>icl_push</b>&quot;</dd>
  <dt>[17]</dt>
  <dd>&quot;<b>icl_rewind</b>&quot;</dd>
  <dt>[18]</dt>
  <dd>&quot;<b>icl_pop</b>&quot;</dd>
  <dt>[19]</dt>
  <dd>&quot;<b>ier_push</b>&quot;</dd>
  <dt>[20]</dt>
  <dd>&quot;<b>ier_clear</b>&quot;</dd>
  <dt>[21]</dt>
  <dd>&quot;<b>ier_nonterminal</b> <i>message</i>&quot;</dd>
  <dt>[22]</dt>
  <dd>&quot;<b>ier_merge</b>&quot;</dd>
  <dt>[23]</dt>
  <dd>&quot;<b>isv_clear</b>&quot;</dd>
  <dt>[24]</dt>
  <dd>&quot;<b>isv_terminal</b>&quot;</dd>
  <dt>[25]</dt>
  <dd>&quot;<b>isv_nonterminal_leaf</b> <i>nt</i>&quot;</dd>
  <dt>[26]</dt>
  <dd>&quot;<b>isv_nonterminal_range</b> <i>nt</i>&quot;</dd>
  <dt>[27]</dt>
  <dd>&quot;<b>isv_nonterminal_reduce</b> <i>nt</i>&quot;</dd>
  <dt>[28]</dt>
  <dd>&quot;<b>ias_push</b>&quot;</dd>
  <dt>[29]</dt>
  <dd>&quot;<b>ias_mark</b>&quot;</dd>
  <dt>[30]</dt>
  <dd>&quot;<b>ias_mrewind</b>&quot;</dd>
  <dt>[31]</dt>
  <dd>&quot;<b>ias_mpop</b>&quot;</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CPU_STATE"><a class="permalink" href="#CPU_STATE">CPU
  STATE</a></h1>
<p class="Pp">A state value is a list containing the following elements, in the
    order listed below:</p>
<dl class="Bl-tag">
  <dt>[1]</dt>
  <dd><i>code</i>: Match instructions, see <b>MATCH PROGRAM
    REPRESENTATION</b>.</dd>
  <dt>[2]</dt>
  <dd><i>pc</i>: Program counter, <i>int</i>.</dd>
  <dt>[3]</dt>
  <dd><i>halt</i>: Halt flag, <i>boolean</i>.</dd>
  <dt>[4]</dt>
  <dd><i>eof</i>: Eof flag, <i>boolean</i></dd>
  <dt>[5]</dt>
  <dd><i>tc</i>: Terminal cache, and input queue. Structure see below.</dd>
  <dt>[6]</dt>
  <dd><i>cl</i>: Current location, <i>int</i>.</dd>
  <dt>[7]</dt>
  <dd><i>ct</i>: Current token, <i>string</i>.</dd>
  <dt>[8]</dt>
  <dd><i>ok</i>: Match status, <i>boolean</i>.</dd>
  <dt>[9]</dt>
  <dd><i>sv</i>: Semantic value, <i>list</i>.</dd>
  <dt>[10]</dt>
  <dd><i>er</i>: Error status, <i>list</i>.</dd>
  <dt>[11]</dt>
  <dd><i>ls</i>: Location stack, <i>list</i>.</dd>
  <dt>[12]</dt>
  <dd><i>as</i>: AST stack, <i>list</i>.</dd>
  <dt>[13]</dt>
  <dd><i>ms</i>: AST marker stack, <i>list</i>.</dd>
  <dt>[14]</dt>
  <dd><i>es</i>: Error stack, <i>list</i>.</dd>
  <dt>[15]</dt>
  <dd><i>rs</i>: Return stack, <i>list</i>.</dd>
  <dt>[16]</dt>
  <dd><i>nc</i>: Nonterminal cache, <i>dictionary</i>.</dd>
</dl>
<p class="Pp"><i>tc</i>, the input queue of tokens waiting for processing and
    the terminal cache containing the tokens already processing are one unified
    data structure simply holding all tokens and their information, with the
    current location separating that which has been processed from that which is
    waiting. Each element of the queue/cache is a list containing the token, its
    lexeme information, line number, and column index, in this order.</p>
<p class="Pp">All stacks have their top element aat the end, i.e. pushing an
    item is equivalent to appending to the list representing the stack, and
    popping it removes the last element.</p>
<p class="Pp"><i>er</i>, the error status is either empty or a list of two
    elements, a location in the input, and a list of messages, encoded as
    references into the <i>pool</i> element of the <i>code</i>.</p>
<p class="Pp"><i>nc</i>, the nonterminal cache is keyed by nonterminal name and
    location, each value a four-element list containing current location, match
    status, semantic value, and error status, in this order.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS,_IDEAS,_FEEDBACK"><a class="permalink" href="#BUGS,_IDEAS,_FEEDBACK">BUGS,
  IDEAS, FEEDBACK</a></h1>
<p class="Pp">This document, and the package it describes, will undoubtedly
    contain bugs and other problems. Please report such in the category
    <i>grammar_me</i> of the <i>Tcllib SF Trackers</i>
    [http://sourceforge.net/tracker/?group_id=12883]. Please also report any
    ideas for enhancements you may have for either package and/or
  documentation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
<p class="Pp">grammar, parsing, virtual machine</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CATEGORY"><a class="permalink" href="#CATEGORY">CATEGORY</a></h1>
<p class="Pp">Grammars and finite automata</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<pre>Copyright (c) 2005-2006 Andreas Kupries &lt;andreas_kupries@users.sourceforge.net&gt;
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">0.2</td>
    <td class="foot-os"><a href="..">grammar_me</a></td>
  </tr>
</table>
</body>
</html>

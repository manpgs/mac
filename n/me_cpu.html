<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Copyright (c) 2005-2006 Andreas Kupries <andreas_kupries@users.sourceforge.net>
  
   The definitions below are for supplemental macros used in Tcl/Tk
   manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO
  	Start of list of standard options for a Tk widget.  The
  	options follow on successive lines, in four columns separated
  	by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   RCS: @(#) $Id: man.macros,v 1.1 2009/01/30 04:56:47 andreas_kupries Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>grammar::me::cpu(n)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">grammar::me::cpu(n)</td>
    <td class="head-vol">Grammar operations and usage</td>
    <td class="head-rtitle">grammar::me::cpu(n)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>
</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">grammar::me::cpu - Virtual machine implementation II for parsing
    token streams</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">package require <b>Tcl 8.4</b></p>
<p class="Pp">package require <b>grammar::me::cpu ?0.2?</b></p>
<p class="Pp"><b>::grammar::me::cpu</b> <i>meName</i> <i>matchcode</i></p>
<p class="Pp"><b>meName</b> <b>option</b> ?<i>arg arg ...</i>?</p>
<p class="Pp"><i>meName</i> <b>lc</b> <i>location</i></p>
<p class="Pp"><i>meName</i> <b>tok</b> ?<i>from</i> ?<i>to</i>??</p>
<p class="Pp"><i>meName</i> <b>pc</b> <i>state</i></p>
<p class="Pp"><i>meName</i> <b>iseof</b> <i>state</i></p>
<p class="Pp"><i>meName</i> <b>at</b> <i>state</i></p>
<p class="Pp"><i>meName</i> <b>cc</b> <i>state</i></p>
<p class="Pp"><i>meName</i> <b>sv</b></p>
<p class="Pp"><i>meName</i> <b>ok</b></p>
<p class="Pp"><i>meName</i> <b>error</b></p>
<p class="Pp"><i>meName</i> <b>lstk</b> <i>state</i></p>
<p class="Pp"><i>meName</i> <b>astk</b> <i>state</i></p>
<p class="Pp"><i>meName</i> <b>mstk</b> <i>state</i></p>
<p class="Pp"><i>meName</i> <b>estk</b> <i>state</i></p>
<p class="Pp"><i>meName</i> <b>rstk</b> <i>state</i></p>
<p class="Pp"><i>meName</i> <b>nc</b> <i>state</i></p>
<p class="Pp"><i>meName</i> <b>ast</b></p>
<p class="Pp"><i>meName</i> <b>halted</b></p>
<p class="Pp"><i>meName</i> <b>code</b></p>
<p class="Pp"><i>meName</i> <b>eof</b></p>
<p class="Pp"><i>meName</i> <b>put</b> <i>tok</i> <i>lex</i> <i>line</i>
    <i>col</i></p>
<p class="Pp"><i>meName</i> <b>putstring</b> <i>string</i> <i>lvar</i>
    <i>cvar</i></p>
<p class="Pp"><i>meName</i> <b>run</b> ?<i>n</i>?</p>
<p class="Pp"><i>meName</i> <b>pull</b> <i>nextcmd</i></p>
<p class="Pp"><i>meName</i> <b>reset</b></p>
<p class="Pp"><i>meName</i> <b>destroy</b></p>
<p class="Pp"></p>
<pre>
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This package provides an implementation of the ME virtual machine.
    Please go and read the document <b>grammar::me_intro</b> first if you do not
    know what a ME virtual machine is.</p>
<p class="Pp">This implementation provides an object-based API and the machines
    are not truly tied to Tcl. A C implementation of the same API is quite
    possible.</p>
<p class="Pp">Internally the package actually uses the value-based machine
    manipulation commands as provided by the package
    <b>grammar::me::cpu::core</b> to perform its duties.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="API"><a class="permalink" href="#API">API</a></h1>
<section class="Ss">
<h2 class="Ss" id="CLASS_API"><a class="permalink" href="#CLASS_API">CLASS
  API</a></h2>
<p class="Pp">The package directly provides only a single command for the
    construction of ME virtual machines.</p>
<dl class="Bl-tag">
  <dt><b>::grammar::me::cpu</b> <i>meName</i> <i>matchcode</i></dt>
  <dd>The command creates a new ME machine object with an associated global Tcl
      command whose name is <i>meName</i>. This command may be used to invoke
      various operations on the machine. It has the following general form:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="meName"><a class="permalink" href="#meName"><b>meName</b>
    <b>option</b> ?<i>arg arg ...</i>?</a></dt>
  <dd><i>Option</i> and the <i>arg</i>s determine the exact behavior of the
      command.</dd>
</dl>
</div>
<p class="Pp">The argument <i>matchcode</i> contains the match instructions the
    machine has to execute while parsing the input stream. Please read section
    <b>MATCH CODE REPRESENTATION</b> of the documentation for the package
    <b>grammar::me::cpu::core</b> for the specification of the structure of this
    value.</p>
<p class="Pp">The <i>tokmap</i> argument taken by the implementation provided by
    the package <b>grammar::me::tcl</b> is here hidden inside of the match
    instructions and therefore not needed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="OBJECT_API"><a class="permalink" href="#OBJECT_API">OBJECT
  API</a></h2>
<p class="Pp">All ME virtual machine objects created by the class command
    specified in section <b>CLASS API</b> support the methods listed below.</p>
<p class="Pp">The machines provided by this package provide methods for
    operation in both push- and pull-styles. Push-style means that tokens are
    pushed into the machine state when they arrive, triggering further execution
    until they are consumed. In other words, this allows the machine to be
    suspended and resumed at will and an arbitrary number of times, the
    quasi-parallel operation of several machines, and the operation as part of
    the event loop.</p>
<dl class="Bl-tag">
  <dt id="meName~2"><a class="permalink" href="#meName~2"><i>meName</i>
    <b>lc</b> <i>location</i></a></dt>
  <dd>This method converts the location of a token given as offset in the input
      stream into the associated line number and column index. The result of the
      command is a 2-element list containing the two values, in the order
      mentioned in the previous sentence. This allows higher levels to convert
      the location information found in the error status and the generated AST
      into more human readable data.
    <p class="Pp"><i>Note</i> that the command is not able to convert locations
        which have not been reached by the machine yet. In other words, if the
        machine has read 7 tokens the command is able to convert the offsets
        <b>0</b> to <b>6</b>, but nothing beyond that. This also shows that it
        is not possible to convert offsets which refer to locations before the
        beginning of the stream.</p>
  </dd>
  <dt id="meName~3"><a class="permalink" href="#meName~3"><i>meName</i>
    <b>tok</b> ?<i>from</i> ?<i>to</i>??</a></dt>
  <dd>This method returns a Tcl list containing the part of the input stream
      between the locations <i>from</i> and <i>to</i> (both inclusive). If
      <i>to</i> is not specified it will default to the value of <i>from</i>. If
      <i>from</i> is not specified either the whole input stream is returned.
    <p class="Pp">Each element of the returned list is a list of four elements,
        the token, its associated lexeme, line number, and column index, in this
        order. This command places the same restrictions on its location
        arguments as the method <b>lc</b>.</p>
  </dd>
  <dt id="meName~4"><a class="permalink" href="#meName~4"><i>meName</i>
    <b>pc</b> <i>state</i></a></dt>
  <dd>This method takes the state value of a ME virtual machine and returns the
      current value of the stored program counter.</dd>
  <dt id="meName~5"><a class="permalink" href="#meName~5"><i>meName</i>
    <b>iseof</b> <i>state</i></a></dt>
  <dd>This method takes the state value of a ME virtual machine and returns the
      current value of the stored eof flag.</dd>
  <dt id="meName~6"><a class="permalink" href="#meName~6"><i>meName</i>
    <b>at</b> <i>state</i></a></dt>
  <dd>This method takes the state value of a ME virtual machine and returns the
      current location in the input stream.</dd>
  <dt id="meName~7"><a class="permalink" href="#meName~7"><i>meName</i>
    <b>cc</b> <i>state</i></a></dt>
  <dd>This method takes the state value of a ME virtual machine and returns the
      current token.</dd>
  <dt id="meName~8"><a class="permalink" href="#meName~8"><i>meName</i>
    <b>sv</b></a></dt>
  <dd>This command returns the current semantic value <i>SV</i> stored in the
      machine. This is an abstract syntax tree as specified in the document
      <b>grammar::me_ast</b>, section <b>AST VALUES</b>.</dd>
  <dt id="meName~9"><a class="permalink" href="#meName~9"><i>meName</i>
    <b>ok</b></a></dt>
  <dd>This method returns the current match status <i>OK</i>.</dd>
  <dt id="meName~10"><a class="permalink" href="#meName~10"><i>meName</i>
    <b>error</b></a></dt>
  <dd>This method returns the current error status <i>ER</i>.</dd>
  <dt id="meName~11"><a class="permalink" href="#meName~11"><i>meName</i>
    <b>lstk</b> <i>state</i></a></dt>
  <dd>This method takes the state value of a ME virtual machine and returns the
      location stack.</dd>
  <dt id="meName~12"><a class="permalink" href="#meName~12"><i>meName</i>
    <b>astk</b> <i>state</i></a></dt>
  <dd>This method takes the state value of a ME virtual machine and returns the
      AST stack.</dd>
  <dt id="meName~13"><a class="permalink" href="#meName~13"><i>meName</i>
    <b>mstk</b> <i>state</i></a></dt>
  <dd>This method takes the state value of a ME virtual machine and returns the
      AST marker stack.</dd>
  <dt id="meName~14"><a class="permalink" href="#meName~14"><i>meName</i>
    <b>estk</b> <i>state</i></a></dt>
  <dd>This method takes the state value of a ME virtual machine and returns the
      error stack.</dd>
  <dt id="meName~15"><a class="permalink" href="#meName~15"><i>meName</i>
    <b>rstk</b> <i>state</i></a></dt>
  <dd>This method takes the state value of a ME virtual machine and returns the
      subroutine return stack.</dd>
  <dt id="meName~16"><a class="permalink" href="#meName~16"><i>meName</i>
    <b>nc</b> <i>state</i></a></dt>
  <dd>This method takes the state value of a ME virtual machine and returns the
      nonterminal match cache as a dictionary.</dd>
  <dt id="meName~17"><a class="permalink" href="#meName~17"><i>meName</i>
    <b>ast</b></a></dt>
  <dd>This method returns the current top entry of the AST stack <i>AS</i>. This
      is an abstract syntax tree as specified in the document
      <b>grammar::me_ast</b>, section <b>AST VALUES</b>.</dd>
  <dt id="meName~18"><a class="permalink" href="#meName~18"><i>meName</i>
    <b>halted</b></a></dt>
  <dd>This method returns a boolean value telling the caller whether the engine
      has halted execution or not. Halt means that no further matching is
      possible, and the information retrieved via the other method is final.
      Attempts to <b>run</b> the engine will be ignored, until a <b>reset</b> is
      made.</dd>
  <dt id="meName~19"><a class="permalink" href="#meName~19"><i>meName</i>
    <b>code</b></a></dt>
  <dd>This method returns the <i>code</i> information used to construct the
      object. In other words, the match program executed by the machine.</dd>
  <dt id="meName~20"><a class="permalink" href="#meName~20"><i>meName</i>
    <b>eof</b></a></dt>
  <dd>This method adds an end of file marker to the end of the input stream.
      This signals the machine that the current contents of the input queue are
      the final parts of the input and nothing will come after. Attempts to put
      more characters into the queue will fail.</dd>
  <dt id="meName~21"><a class="permalink" href="#meName~21"><i>meName</i>
    <b>put</b> <i>tok</i> <i>lex</i> <i>line</i> <i>col</i></a></dt>
  <dd>This method adds the token <i>tok</i> to the end of the input stream, with
      associated lexeme data <i>lex</i> and <i>line</i>/<i>col</i>umn
      information.</dd>
  <dt id="meName~22"><a class="permalink" href="#meName~22"><i>meName</i>
    <b>putstring</b> <i>string</i> <i>lvar</i> <i>cvar</i></a></dt>
  <dd>This method adds each individual character in the <i>string</i> as a token
      to the end of the input stream, from first to last. The lexemes will be
      empty and the line/col information is computed based on the characters
      encountered and the data in the variables <i>lvar</i> and
    <i>cvar</i>.</dd>
  <dt id="meName~23"><a class="permalink" href="#meName~23"><i>meName</i>
    <b>run</b> ?<i>n</i>?</a></dt>
  <dd>This methods causes the engine to execute match instructions until
    either</dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li><i>n</i> instructions have been executed, or</li>
  <li>a halt instruction was executed, or</li>
  <li>the input queue is empty and the code is asking for more tokens to
      process.</li>
</ul>
</div>
<p class="Pp">If no limit <i>n</i> was set only the last two conditions are
    checked for.</p>
<dl class="Bl-tag">
  <dt id="meName~24"><a class="permalink" href="#meName~24"><i>meName</i>
    <b>pull</b> <i>nextcmd</i></a></dt>
  <dd>This method implements pull-style operation of the machine. It causes it
      to execute match instructions until either a halt instruction is reached,
      or the command prefix <i>nextcmd</i> ceases to deliver more tokens.
    <p class="Pp">The command prefix <i>nextcmd</i> represents the input stream
        of characters and is invoked by the machine whenever the a new character
        from the stream is required. The instruction for handling this is
        <i>ict_advance</i>. The callback has to return either the empty list, or
        a list of 4 elements containing the token, its lexeme attribute, and its
        location as line number and column index, in this order. The empty list
        is the signal that the end of the input stream has been reached. The
        lexeme attribute is stored in the terminal cache, but otherwise not used
        by the machine.</p>
    <p class="Pp">The end of the input stream for this method does not imply
        that method <b>eof</b> is called for the machine as a whole. By avoiding
        this and still asking for an explicit call of the method it is possible
        to mix push- and pull-style operation during the lifetime of the
        machine.</p>
  </dd>
  <dt id="meName~25"><a class="permalink" href="#meName~25"><i>meName</i>
    <b>reset</b></a></dt>
  <dd>This method resets the machine to its initial state, discarding any state
      it may have.</dd>
  <dt id="meName~26"><a class="permalink" href="#meName~26"><i>meName</i>
    <b>destroy</b></a></dt>
  <dd>This method deletes the object and releases all resurces it claimed.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS,_IDEAS,_FEEDBACK"><a class="permalink" href="#BUGS,_IDEAS,_FEEDBACK">BUGS,
  IDEAS, FEEDBACK</a></h1>
<p class="Pp">This document, and the package it describes, will undoubtedly
    contain bugs and other problems. Please report such in the category
    <i>grammar_me</i> of the <i>Tcllib SF Trackers</i>
    [http://sourceforge.net/tracker/?group_id=12883]. Please also report any
    ideas for enhancements you may have for either package and/or
  documentation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
<p class="Pp">grammar, parsing, virtual machine</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CATEGORY"><a class="permalink" href="#CATEGORY">CATEGORY</a></h1>
<p class="Pp">Grammars and finite automata</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<pre>Copyright (c) 2005-2006 Andreas Kupries &lt;andreas_kupries@users.sourceforge.net&gt;
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">0.2</td>
    <td class="foot-os">grammar_me</td>
  </tr>
</table>
</body>
</html>

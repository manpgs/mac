<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Generated from file '/AppleInternal/Library/BuildRoots/66382bca-8bca-11ec-aade-6613bcf0e2ee/Library/Caches/com.apple.xbs/Sources/tcl/tcl_ext/tcllib/tcllib/modules/comm/comm.man' by tcllib/doctools with format 'nroff'
   Copyright (c) 1995-1998 The Open Group. All Rights Reserved.
   Copyright (c) 2003-2004 ActiveState Corporation.
   Copyright (c) 2006-2009 Andreas Kupries <andreas_kupries@users.sourceforge.net>
  
   The definitions below are for supplemental macros used in Tcl/Tk
   manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO
  	Start of list of standard options for a Tk widget.  The
  	options follow on successive lines, in four columns separated
  	by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   RCS: @(#) $Id: man.macros,v 1.1 2009/01/30 04:56:47 andreas_kupries Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>comm(n)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">comm(n)</td>
    <td class="head-vol">Remote communication</td>
    <td class="head-rtitle">comm(n)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>

</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">comm - A remote communication facility for Tcl (8.3 and later)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">package require <b>Tcl 8.3</b></p>
<p class="Pp">package require <b>comm ?4.6.1?</b></p>
<p class="Pp"><b>::comm::comm send</b> ?-async? ?-command <i>callback</i>?
    <i>id</i> <i>cmd</i> ?<i>arg arg ...</i>?</p>
<p class="Pp"><b>::comm::comm self</b></p>
<p class="Pp"><b>::comm::comm interps</b></p>
<p class="Pp"><b>::comm::comm connect</b> ?<i>id</i>?</p>
<p class="Pp"><b>::comm::comm new</b> <i>chan</i> ?<i>name value ...</i>?</p>
<p class="Pp"><b>::comm::comm channels</b></p>
<p class="Pp"><b>::comm::comm config</b></p>
<p class="Pp"><b>::comm::comm config</b> <i>name</i></p>
<p class="Pp"><b>::comm::comm config</b> ?<i>name</i> <i>value</i>
  <i>...</i>?</p>
<p class="Pp"><b>::comm::comm shutdown</b> <i>id</i></p>
<p class="Pp"><b>::comm::comm abort</b></p>
<p class="Pp"><b>::comm::comm destroy</b></p>
<p class="Pp"><b>::comm::comm hook</b> <i>event</i> ?<b>+</b>?
  ?<i>script</i>?</p>
<p class="Pp"><b>::comm::comm remoteid</b></p>
<p class="Pp"><b>::comm::comm_send</b></p>
<p class="Pp"><b>::comm::comm return_async</b></p>
<p class="Pp"><b>$future</b> <b>return</b> ?<b>-code</b> <i>code</i>?
    ?<i>value</i>?</p>
<p class="Pp"><b>$future</b> <b>configure</b> ?<b>-command</b>
    ?<i>cmdprefix</i>??</p>
<p class="Pp"><b>$future</b> <b>cget</b> <b>-command</b></p>
<p class="Pp"></p>
<pre>

</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The <b>comm</b> command provides an inter-interpreter remote
    execution facility much like Tk's <b>send(n)</b>, except that it uses
    sockets rather than the X server for the communication path. As a result,
    <b>comm</b> works with multiple interpreters, works on Windows and Macintosh
    systems, and provides control over the remote execution path.</p>
<p class="Pp">These commands work just like <b>send</b> and <b>winfo interps</b>
    :</p>
<p class="Pp"></p>
<pre>
    ::comm::comm send ?-async? id cmd ?arg arg ...?
    ::comm::comm interps
</pre>
<p class="Pp">This is all that is really needed to know in order to use
    <b>comm</b></p>
<section class="Ss">
<h2 class="Ss" id="COMMANDS"><a class="permalink" href="#COMMANDS">COMMANDS</a></h2>
<p class="Pp">The package initializes <b>::comm::comm</b> as the default
    <i>chan</i>.</p>
<p class="Pp"><b>comm</b> names communication endpoints with an <i>id</i> unique
    to each machine. Before sending commands, the <i>id</i> of another
    interpreter is needed. Unlike Tk's send, <b>comm</b> doesn't implicitly know
    the <i>id</i>'s of all the interpreters on the system. The following four
    methods make up the basic <b>comm</b> interface.</p>
<dl class="Bl-tag">
  <dt><b>::comm::comm send</b> ?-async? ?-command <i>callback</i>? <i>id</i>
    <i>cmd</i> ?<i>arg arg ...</i>?</dt>
  <dd>This invokes the given command in the interpreter named by <i>id</i>. The
      command waits for the result and remote errors are returned unless the
      <b>-async</b> or <b>-command</b> option is given. If <b>-async</b> is
      given, send returns immediately and there is no further notification of
      result. If <b>-command</b> is used, <i>callback</i> specifies a command to
      invoke when the result is received. These options are mutually exclusive.
      The callback will receive arguments in the form <i>-option value</i>,
      suitable for <b>array set</b>. The options are: <i>-id</i>, the comm id of
      the interpreter that received the command; <i>-serial</i>, a unique serial
      for each command sent to a particular comm interpreter; <i>-chan</i>, the
      comm channel name; <i>-code</i>, the result code of the command;
      <i>-errorcode</i>, the errorcode, if any, of the command;
      <i>-errorinfo</i>, the errorinfo, if any, of the command; and
      <i>-result</i>, the return value of the command. If connection is lost
      before a reply is received, the callback will be invoked with a connection
      lost message with -code equal to -1. When <b>-command</b> is used, the
      command returns the unique serial for the command.</dd>
  <dt><b>::comm::comm self</b></dt>
  <dd>Returns the <i>id</i> for this channel.</dd>
  <dt><b>::comm::comm interps</b></dt>
  <dd>Returns a list of all the remote <i>id</i>'s to which this channel is
      connected. <b>comm</b> learns a new remote <i>id</i> when a command is
      first issued it, or when a remote <i>id</i> first issues a command to this
      comm channel. <b>::comm::comm ids</b> is an alias for this method.</dd>
  <dt><b>::comm::comm connect</b> ?<i>id</i>?</dt>
  <dd>Whereas <b>::comm::comm send</b> will automatically connect to the given
      <i>id</i>, this forces a connection to a remote <i>id</i> without sending
      a command. After this, the remote <i>id</i> will appear in <b>::comm::comm
      interps</b>.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="EVAL_SEMANTICS"><a class="permalink" href="#EVAL_SEMANTICS">EVAL
  SEMANTICS</a></h2>
<p class="Pp">The evaluation semantics of <b>::comm::comm send</b> are intended
    to match Tk's <b>send</b> <i>exactly</i>. This means that <b>comm</b>
    evaluates arguments on the remote side.</p>
<p class="Pp">If you find that <b>::comm::comm send</b> doesn't work for a
    particular command, try the same thing with Tk's send and see if the result
    is different. If there is a problem, please report it. For instance, there
    was had one report that this command produced an error. Note that the
    equivalent <b>send</b> command also produces the same error.</p>
<p class="Pp"></p>
<pre>
    % ::comm::comm send id llength {a b c}
    wrong # args: should be &quot;llength list&quot;
    % send name llength {a b c}
    wrong # args: should be &quot;llength list&quot;
</pre>
<p class="Pp">The <b>eval</b> hook (described below) can be used to change from
    <b>send</b>'s double eval semantics to single eval semantics.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="MULTIPLE_CHANNELS"><a class="permalink" href="#MULTIPLE_CHANNELS">MULTIPLE
  CHANNELS</a></h2>
<p class="Pp">More than one <b>comm</b> channel (or <i>listener</i>) can be
    created in each Tcl interpreter. This allows flexibility to create full and
    restricted channels. For instance, <i>hook</i> scripts are specific to the
    channel they are defined against.</p>
<dl class="Bl-tag">
  <dt><b>::comm::comm new</b> <i>chan</i> ?<i>name value ...</i>?</dt>
  <dd>This creates a new channel and Tcl command with the given channel name.
      This new command controls the new channel and takes all the same arguments
      as <b>::comm::comm</b>. Any remaining arguments are passed to the
      <b>config</b> method. The fully qualified channel name is returned.</dd>
  <dt><b>::comm::comm channels</b></dt>
  <dd>This lists all the channels allocated in this Tcl interpreter.</dd>
</dl>
<p class="Pp">The default configuration parameters for a new channel are:</p>
<p class="Pp"></p>
<pre>
    &quot;-port 0 -local 1 -listen 0 -silent 0&quot;
</pre>
<p class="Pp">The default channel <b>::comm::comm</b> is created with:</p>
<p class="Pp"></p>
<pre>
    &quot;::comm::comm new ::comm::comm -port 0 -local 1 -listen 1 -silent 0&quot;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="CHANNEL_CONFIGURATION"><a class="permalink" href="#CHANNEL_CONFIGURATION">CHANNEL
  CONFIGURATION</a></h2>
<p class="Pp">The <b>config</b> method acts similar to <b>fconfigure</b> in that
    it sets or queries configuration variables associated with a channel.</p>
<dl class="Bl-tag">
  <dt><b>::comm::comm config</b></dt>
  <dd></dd>
  <dt><b>::comm::comm config</b> <i>name</i></dt>
  <dd></dd>
  <dt><b>::comm::comm config</b> ?<i>name</i> <i>value</i> <i>...</i>?</dt>
  <dd>When given no arguments, <b>config</b> returns a list of all variables and
      their value With one argument, <b>config</b> returns the value of just
      that argument. With an even number of arguments, the given variables are
      set to the given values.</dd>
</dl>
<p class="Pp">These configuration variables can be changed (descriptions of them
    are elsewhere in this manual page):</p>
<dl class="Bl-tag">
  <dt id="listen"><a class="permalink" href="#listen"><b>-listen</b>
    ?<i>0|1</i>?</a></dt>
  <dd></dd>
  <dt id="local"><a class="permalink" href="#local"><b>-local</b>
    ?<i>0|1</i>?</a></dt>
  <dd></dd>
  <dt id="port"><a class="permalink" href="#port"><b>-port</b>
    ?<i>port</i>?</a></dt>
  <dd></dd>
  <dt id="silent"><a class="permalink" href="#silent"><b>-silent</b>
    ?<i>0|1</i>?</a></dt>
  <dd></dd>
  <dt id="socketcmd"><a class="permalink" href="#socketcmd"><b>-socketcmd</b>
    ?<i>commandname</i>?</a></dt>
  <dd></dd>
  <dt id="interp"><a class="permalink" href="#interp"><b>-interp</b>
    ?<i>interpreter</i>?</a></dt>
  <dd></dd>
  <dt id="events"><a class="permalink" href="#events"><b>-events</b>
    ?<i>eventlist</i>?</a></dt>
  <dd></dd>
</dl>
<p class="Pp">These configuration variables are read only:</p>
<dl class="Bl-tag">
  <dt id="chan"><a class="permalink" href="#chan"><b>-chan</b>
    <i>chan</i></a></dt>
  <dd></dd>
  <dt id="serial"><a class="permalink" href="#serial"><b>-serial</b>
    <i>n</i></a></dt>
  <dd></dd>
  <dt id="socket"><a class="permalink" href="#socket"><b>-socket</b>
    sock<i>In</i></a></dt>
  <dd></dd>
</dl>
<p class="Pp">When <b>config</b> changes the parameters of an existing channel
    (with the exception of <b>-interp</b> and <b>-events</b>), it closes and
    reopens the listening socket. An automatically assigned channel <i>id</i>
    will change when this happens. Recycling the socket is done by invoking
    <b>::comm::comm abort</b>, which causes all active sends to terminate.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ID/PORT_ASSIGNMENTS"><a class="permalink" href="#ID/PORT_ASSIGNMENTS">ID/PORT
  ASSIGNMENTS</a></h2>
<p class="Pp"><b>comm</b> uses a TCP port for endpoint <i>id</i>. The
    <b>interps</b> (or <b>ids</b>) method merely lists all the TCP ports to
    which the channel is connected. By default, each channel's <i>id</i> is
    randomly assigned by the operating system (but usually starts at a low value
    around 1024 and increases each time a new socket is opened). This behavior
    is accomplished by giving the <b>-port</b> config option a value of 0.
    Alternately, a specific TCP port number may be provided for a given channel.
    As a special case, comm contains code to allocate a a high-numbered TCP port
    (&gt;10000) by using <b>-port {}</b>. Note that a channel won't be created
    and initialized unless the specific port can be allocated.</p>
<p class="Pp">As a special case, if the channel is configured with <b>-listen
    0</b>, then it will not create a listening socket and will use an id of
    <b>0</b> for itself. Such a channel is only good for outgoing connections
    (although once a connection is established, it can carry send traffic in
    both directions). As another special case, if the channel is configured with
    <b>-silent 0</b>, then the listening side will ignore connection attempts
    where the protocol negotiation phase failed, instead of throwing an
  error.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="EXECUTION_ENVIRONMENT"><a class="permalink" href="#EXECUTION_ENVIRONMENT">EXECUTION
  ENVIRONMENT</a></h2>
<p class="Pp">A communication channel in its default configuration will use the
    current interpreter for the execution of all received scripts, and of the
    event scripts associated with the various hooks.</p>
<p class="Pp">This insecure setup can be changed by the user via the two options
    <b>-interp</b>, and <b>-events</b>.</p>
<p class="Pp">When <b>-interp</b> is set all received scripts are executed in
    the slave interpreter specified as the value of the option. This interpreter
    is expected to exist before configuration. I.e. it is the responsibility of
    the user to create it. However afterward the communication channel takes
    ownership of this interpreter, and will destroy it when the communication
    channel is destroyed. Note that reconfiguration of the communication channel
    to either a different interpreter or the empty string will release the
    ownership <i>without</i> destroying the previously configured interpreter.
    The empty string has a special meaning, it restores the default behaviour of
    executing received scripts in the current interpreter.</p>
<p class="Pp"><i>Also of note</i> is that replies and callbacks (a special form
    of reply) are <i>not</i> considered as received scripts. They are trusted,
    part of the internal machinery of comm, and therefore always executed in the
    current interpreter.</p>
<p class="Pp">Even if an interpreter has been configured as the execution
    environment for received scripts the event scripts associated with the
    various hooks will by default still be executed in the current interpreter.
    To change this use the option <b>-events</b> to declare a list of the events
    whose scripts should be executed in the declared interpreter as well. The
    contents of this option are ignored if the communication channel is
    configured to execute received scripts in the current interpreter.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="REMOTE_INTERPRETERS"><a class="permalink" href="#REMOTE_INTERPRETERS">REMOTE
  INTERPRETERS</a></h2>
<p class="Pp">By default, each channel is restricted to accepting connections
    from the local system. This can be overridden by using the <b>-local 0</b>
    configuration option For such channels, the <i>id</i> parameter takes the
    form <i>{ id host }</i>.</p>
<p class="Pp"><i>WARNING</i>: The <i>host</i> must always be specified in the
    same form (e.g., as either a fully qualified domain name, plain hostname or
    an IP address).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="CLOSING_CONNECTIONS"><a class="permalink" href="#CLOSING_CONNECTIONS">CLOSING
  CONNECTIONS</a></h2>
<p class="Pp">These methods give control over closing connections:</p>
<dl class="Bl-tag">
  <dt><b>::comm::comm shutdown</b> <i>id</i></dt>
  <dd>This closes the connection to <i>id</i>, aborting all outstanding commands
      in progress. Note that nothing prevents the connection from being
      immediately reopened by another incoming or outgoing command.</dd>
  <dt><b>::comm::comm abort</b></dt>
  <dd>This invokes shutdown on all open connections in this comm channel.</dd>
  <dt><b>::comm::comm destroy</b></dt>
  <dd>This aborts all connections and then destroys the this comm channel
      itself, including closing the listening socket. Special code allows the
      default <b>::comm::comm</b> channel to be closed such that the
      <b>::comm::comm</b> command it is not destroyed. Doing so closes the
      listening socket, preventing both incoming and outgoing commands on the
      channel. This sequence reinitializes the default channel:
    <p class="Pp"></p>
    <pre>
    &quot;::comm::comm destroy; ::comm::comm new ::comm::comm&quot;
    </pre>
  </dd>
</dl>
<p class="Pp">When a remote connection is lost (because the remote exited or
    called <b>shutdown</b>), <b>comm</b> can invoke an application callback.
    This can be used to cleanup or restart an ancillary process, for instance.
    See the <i>lost</i> callback below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="CALLBACKS"><a class="permalink" href="#CALLBACKS">CALLBACKS</a></h2>
<p class="Pp">This is a mechanism for setting hooks for particular events:</p>
<dl class="Bl-tag">
  <dt><b>::comm::comm hook</b> <i>event</i> ?<b>+</b>? ?<i>script</i>?</dt>
  <dd>This uses a syntax similar to Tk's <b>bind</b> command. Prefixing
      <i>script</i> with a <b>+</b> causes the new script to be appended.
      Without this, a new <i>script</i> replaces any existing script. When
      invoked without a script, no change is made. In all cases, the new hook
      script is returned by the command.
    <p class="Pp">When an <i>event</i> occurs, the <i>script</i> associated with
        it is evaluated with the listed variables in scope and available. The
        return code (<i>not</i> the return value) of the script is commonly used
        decide how to further process after the hook.</p>
    <p class="Pp">Common variables include:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="chan~2"><a class="permalink" href="#chan~2"><b>chan</b></a></dt>
  <dd>the name of the comm channel (and command)</dd>
  <dt id="id"><a class="permalink" href="#id"><b>id</b></a></dt>
  <dd>the id of the remote in question</dd>
  <dt id="fid"><a class="permalink" href="#fid"><b>fid</b></a></dt>
  <dd>the file id for the socket of the connection</dd>
</dl>
</div>
<p class="Pp">These are the defined <i>events</i>:</p>
<dl class="Bl-tag">
  <dt id="connecting"><a class="permalink" href="#connecting"><b>connecting</b></a></dt>
  <dd>Variables: <b>chan</b>, <b>id</b>
    <p class="Pp">This hook is invoked before making a connection to the remote
        named in <i>id</i>. An error return (via <b>error</b>) will abort the
        connection attempt with the error. Example:</p>
    <p class="Pp"></p>
    <pre>
    % ::comm::comm hook connecting {
        if {[string match {*[02468]} $id]} {
            error &quot;Can't connect to even ids&quot;
        }
    }
    % ::comm::comm send 10000 puts ok
    Connect to remote failed: Can't connect to even ids
    %
    </pre>
  </dd>
  <dt id="connected"><a class="permalink" href="#connected"><b>connected</b></a></dt>
  <dd>Variables: <b>chan</b>, <b>fid</b>, <b>id</b>, <b>host</b>, and
      <b>port</b>.
    <p class="Pp">This hook is invoked immediately after making a remote
        connection to <i>id</i>, allowing arbitrary authentication over the
        socket named by <i>fid</i>. An error return (via <b>error</b> ) will
        close the connection with the error. <i>host</i> and <i>port</i> are
        merely extracted from the <i>id</i>; changing any of these will have no
        effect on the connection, however. It is also possible to substitute and
        replace <i>fid</i>.</p>
  </dd>
  <dt id="incoming"><a class="permalink" href="#incoming"><b>incoming</b></a></dt>
  <dd>Variables: <b>chan</b>, <b>fid</b>, <b>addr</b>, and <b>remport</b>.
    <p class="Pp">Hook invoked when receiving an incoming connection, allowing
        arbitrary authentication over socket named by <i>fid</i>. An error
        return (via <b>error</b>) will close the connection with the error. Note
        that the peer is named by <i>remport</i> and <i>addr</i> but that the
        remote <i>id</i> is still unknown. Example:</p>
    <p class="Pp"></p>
    <pre>
    ::comm::comm hook incoming {
        if {[string match 127.0.0.1 $addr]} {
            error &quot;I don't talk to myself&quot;
        }
    }
    </pre>
  </dd>
  <dt id="eval"><a class="permalink" href="#eval"><b>eval</b></a></dt>
  <dd>Variables: <b>chan</b>, <b>id</b>, <b>cmd</b>, and <b>buffer</b>.
    <p class="Pp">This hook is invoked after collecting a complete script from a
        remote but <i>before</i> evaluating it. This allows complete control
        over the processing of incoming commands. <i>cmd</i> contains either
        <b>send</b> or <b>async</b>. <i>buffer</i> holds the script to evaluate.
        At the time the hook is called, <i>$chan remoteid</i> is identical in
        value to <i>id</i>.</p>
    <p class="Pp">By changing <i>buffer</i>, the hook can change the script to
        be evaluated. The hook can short circuit evaluation and cause a value to
        be immediately returned by using <b>return</b> <i>result</i> (or, from
        within a procedure, <b>return -code return</b> <i>result</i>). An error
        return (via <b>error</b>) will return an error result, as is if the
        script caused the error. Any other return will evaluate the script in
        <i>buffer</i> as normal. For compatibility with 3.2, <b>break</b> and
        <b>return -code break</b> <i>result</i> is supported, acting similarly
        to <b>return {}</b> and <b>return -code return</b> <i>result</i>.</p>
    <p class="Pp">Examples:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>[1]</dt>
  <dd>augmenting a command
    <p class="Pp"></p>
    <pre>
    % ::comm::comm send [::comm::comm self] pid
    5013
    % ::comm::comm hook eval {puts &quot;going to execute $buffer&quot;}
    % ::comm::comm send [::comm::comm self] pid
    going to execute pid
    5013
    </pre>
  </dd>
  <dt>[2]</dt>
  <dd>short circuiting a command
    <p class="Pp"></p>
    <pre>
    % ::comm::comm hook eval {puts &quot;would have executed $buffer&quot;; return 0}
    % ::comm::comm send [::comm::comm self] pid
    would have executed pid
    0
    </pre>
  </dd>
  <dt>[3]</dt>
  <dd>Replacing double eval semantics
    <p class="Pp"></p>
    <pre>
    % ::comm::comm send [::comm::comm self] llength {a b c}
    wrong # args: should be &quot;llength list&quot;
    % ::comm::comm hook eval {return [uplevel #0 $buffer]}
    return [uplevel #0 $buffer]
    % ::comm::comm send [::comm::comm self] llength {a b c}
    3
    </pre>
  </dd>
  <dt>[4]</dt>
  <dd>Using a slave interpreter
    <p class="Pp"></p>
    <pre>
    % interp create foo
    % ::comm::comm hook eval {return [foo eval $buffer]}
    % ::comm::comm send [::comm::comm self] set myvar 123
    123
    % set myvar
    can't read &quot;myvar&quot;: no such variable
    % foo eval set myvar
    123
    </pre>
  </dd>
  <dt>[5]</dt>
  <dd>Using a slave interpreter (double eval)
    <p class="Pp"></p>
    <pre>
    % ::comm::comm hook eval {return [eval foo eval $buffer]}
    </pre>
  </dd>
  <dt>[6]</dt>
  <dd>Subverting the script to execute
    <p class="Pp"></p>
    <pre>
    % ::comm::comm hook eval {
        switch -- $buffer {
            a {return A-OK}
            b {return B-OK}
            default {error &quot;$buffer is a no-no&quot;}
        }
    }
    % ::comm::comm send [::comm::comm self] pid
    pid is a no-no
    % ::comm::comm send [::comm::comm self] a
    A-OK
    </pre>
  </dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="reply"><a class="permalink" href="#reply"><b>reply</b></a></dt>
  <dd>Variables: <b>chan</b>, <b>id</b>, <b>buffer</b>, <b>ret</b>, and
      <b>return()</b>.
    <p class="Pp">This hook is invoked after collecting a complete reply script
        from a remote but <i>before</i> evaluating it. This allows complete
        control over the processing of replies to sent commands. The reply
        <i>buffer</i> is in one of the following forms</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>return result</li>
  <li>return -code code result</li>
  <li>return -code code -errorinfo info -errorcode ecode msg</li>
</ul>
</div>
<p class="Pp">For safety reasons, this is decomposed. The return result is in
    <i>ret</i>, and the return switches are in the return array:</p>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li><i>return(-code)</i></li>
  <li><i>return(-errorinfo)</i></li>
  <li><i>return(-errorcode)</i></li>
</ul>
</div>
<p class="Pp">Any of these may be the empty string. Modifying these four
    variables can change the return value, whereas modifying <i>buffer</i> has
    no effect.</p>
<dl class="Bl-tag">
  <dt id="callback"><a class="permalink" href="#callback"><b>callback</b></a></dt>
  <dd>Variables: <b>chan</b>, <b>id</b>, <b>buffer</b>, <b>ret</b>, and
      <b>return()</b>.
    <p class="Pp">Similar to <i>reply</i>, but used for callbacks.</p>
  </dd>
  <dt id="lost"><a class="permalink" href="#lost"><b>lost</b></a></dt>
  <dd>Variables: <b>chan</b>, <b>id</b>, and <b>reason</b>.
    <p class="Pp">This hook is invoked when the connection to <b>id</b> is lost.
        Return value (or thrown error) is ignored. <i>reason</i> is an
        explanatory string indicating why the connection was lost. Example:</p>
    <p class="Pp"></p>
    <pre>
    ::comm::comm hook lost {
        global myvar
        if {$myvar(id) == $id} {
            myfunc
            return
        }
    }
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="UNSUPPORTED"><a class="permalink" href="#UNSUPPORTED">UNSUPPORTED</a></h2>
<p class="Pp">These interfaces may change or go away in subsequence
  releases.</p>
<dl class="Bl-tag">
  <dt><b>::comm::comm remoteid</b></dt>
  <dd>Returns the <i>id</i> of the sender of the last remote command executed on
      this channel. If used by a proc being invoked remotely, it must be called
      before any events are processed. Otherwise, another command may get
      invoked and change the value.</dd>
  <dt><b>::comm::comm_send</b></dt>
  <dd>Invoking this procedure will substitute the Tk <b>send</b> and <b>winfo
      interps</b> commands with these equivalents that use <b>::comm::comm</b>.
    <p class="Pp"></p>
    <pre>
    proc send {args} {
        eval ::comm::comm send $args
    }
    rename winfo tk_winfo
    proc winfo {cmd args} {
        if {![string match in* $cmd]} {
            return [eval [list tk_winfo $cmd] $args]
        }
        return [::comm::comm interps]
    }
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="SECURITY"><a class="permalink" href="#SECURITY">SECURITY</a></h2>
<p class="Pp">Starting with version 4.6 of the package an option
    <b>-socketcmd</b> is supported, allowing the user of a comm channel to
    specify which command to use when opening a socket. Anything which is
    API-compatible with the builtin <b>::socket</b> (the default) can be
  used.</p>
<p class="Pp">The envisioned main use is the specification of the
    <b>tls::socket</b> command, see package <b>tls</b>, to secure the
    communication.</p>
<p class="Pp"></p>
<pre>
	# Load and initialize tls
	package require tls
	tls::init  -cafile /path/to/ca/cert -keyfile ...
	# Create secured comm channel
	::comm::comm new SECURE -socketcmd tls::socket -listen 1
	...
</pre>
<p class="Pp">The sections <b>Execution Environment</b> and <b>Callbacks</b> are
    also relevant to the security of the system, providing means to restrict the
    execution to a specific environment, perform additional authentication, and
    the like.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="BLOCKING_SEMANTICS"><a class="permalink" href="#BLOCKING_SEMANTICS">BLOCKING
  SEMANTICS</a></h2>
<p class="Pp">There is one outstanding difference between <b>comm</b> and
    <b>send</b>. When blocking in a synchronous remote command, <b>send</b> uses
    an internal C hook (Tk_RestrictEvents) to the event loop to look ahead for
    send-related events and only process those without processing any other
    events. In contrast, <b>comm</b> uses the <b>vwait</b> command as a
    semaphore to indicate the return message has arrived. The difference is that
    a synchronous <b>send</b> will block the application and prevent all events
    (including window related ones) from being processed, while a synchronous
    <b>::comm::comm send</b> will block the application but still allow other
    events to get processed. In particular, <b>after idle</b> handlers will fire
    immediately when comm blocks.</p>
<p class="Pp">What can be done about this? First, note that this behavior will
    come from any code using <b>vwait</b> to block and wait for an event to
    occur. At the cost of multiple channel support, <b>comm</b> could be changed
    to do blocking I/O on the socket, giving send-like blocking semantics.
    However, multiple channel support is a very useful feature of comm that it
    is deemed too important to lose. The remaining approaches involve a new
    loadable module written in C (which is somewhat against the philosophy of
    <b>comm</b>) One way would be to create a modified version of the
    <b>vwait</b> command that allow the event flags passed to Tcl_DoOneEvent to
    be specified. For <b>comm</b>, just the TCL_FILE_EVENTS would be processed.
    Another way would be to implement a mechanism like Tk_RestrictEvents, but
    apply it to the Tcl event loop (since <b>comm</b> doesn't require Tk). One
    of these approaches will be available in a future <b>comm</b> release as an
    optional component.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ASYNCHRONOUS_RESULT_GENERATION"><a class="permalink" href="#ASYNCHRONOUS_RESULT_GENERATION">ASYNCHRONOUS
  RESULT GENERATION</a></h2>
<p class="Pp">By default the result returned by a remotely invoked command is
    the result sent back to the invoker. This means that the result is generated
    synchronously, and the server handling the call is blocked for the duration
    of the command.</p>
<p class="Pp">While this is tolerable as long as only short-running commands are
    invoked on the server long-running commands, like database queries make this
    a problem. One command can prevent the processing requests of all other
    clients for an arbitrary period of time.</p>
<p class="Pp">Before version 4.5 of comm the only solution was to rewrite the
    server command to use the Tcl builtin command <b>vwait</b>, or one of its
    relatives like <b>tkwait</b>, to open a new event loop which processes
    requests while the long-running operation is executed. This however has its
    own perils, as this makes it possible to both overflow the Tcl stack with a
    large number of event loop, and to have a newer requests block the return of
    older ones, as the eventloop have to be unwound in the order of their
    creation.</p>
<p class="Pp">The proper solution is to have the invoked command indicate to
    <b>comm</b> that it cannot or will not deliver an immediate, synchronous
    result, but will do so later. At that point the framework can put sending
    the actual result on hold and continue processing requests using the main
    event loop. No blocking, no nesting of event loops. At some future date the
    long running operation delivers the result to comm, via the future object,
    which is then forwarded to the invoker as usual.</p>
<p class="Pp">The necessary support for this solution has been added to comm
    since version 4.5, in the form of the new method <b>return_async</b>.</p>
<dl class="Bl-tag">
  <dt><b>::comm::comm return_async</b></dt>
  <dd>This command is used by a remotely invoked script to notify the comm
      channel which invoked it that the result to send back to the invoker is
      not generated synchronously. If this command is not called the
      default/standard behaviour of comm is to send the synchronously generated
      result of the script itself to the invoker.
    <p class="Pp">The result of <b>return_async</b> is an object. This object,
        called a <i>future</i> is where the result of the script has to be
        delivered to when it becomes ready. When that happens it will take all
        the necessary actions to deliver the result to the invoker of the
        script, and then destroy itself. Should comm have lost the connection to
        the invoker while the result is being computed the future will not try
        to deliver the result it got, but just destroy itself. The future can be
        configured with a command to call when the invoker is lost. This enables
        the user to implement an early abort of the long-running operation,
        should this be supported by it.</p>
    <p class="Pp">An example:</p>
    <pre>
# Procedure invoked by remote clients to run database operations.
proc select {sql} {
    # Signal the async generation of the result
    set future [::comm::comm return_async]
    # Generate an async db operation and tell it where to deliver the result.
    set query [db query -command [list $future return] $sql]
    # Tell the database system which query to cancel if the connection
    # goes away while it is running.
    $future configure -command [list db cancel $query]
    # Note: The above will work without problem only if the async
    # query will nover run its completion callback immediately, but
    # only from the eventloop. Because otherwise the future we wish to
    # configure may already be gone. If that is possible use 'catch'
    # to prevent the error from propagating.
    return
}
    </pre>
    <p class="Pp">The API of a future object is:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>$future</b> <b>return</b> ?<b>-code</b> <i>code</i>?
    ?<i>value</i>?</dt>
  <dd>Use this method to tell the future that long-running operation has
      completed. Arguments are an optional return value (defaults to the empty
      string), and the Tcl return code (defaults to OK).
    <p class="Pp">The future will deliver this information to invoker, if the
        connection was not lost in the meantime, and then destroy itself. If the
        connection was lost it will do nothing but destroy itself.</p>
  </dd>
  <dt><b>$future</b> <b>configure</b> ?<b>-command</b> ?<i>cmdprefix</i>??</dt>
  <dd></dd>
  <dt><b>$future</b> <b>cget</b> <b>-command</b></dt>
  <dd>These methods allow the user to retrieve and set a command to be called if
      the connection the future belongs to has been lost.</dd>
</dl>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="COMPATIBILITY"><a class="permalink" href="#COMPATIBILITY">COMPATIBILITY</a></h2>
<p class="Pp"><b>comm</b> exports itself as a package. The package version
    number is in the form <i>major . minor</i>, where the major version will
    only change when a non-compatible change happens to the API or protocol.
    Minor bug fixes and changes will only affect the minor version. To load
    <b>comm</b> this command is usually used:</p>
<p class="Pp"></p>
<pre>
    package require comm 3
</pre>
<p class="Pp">Note that requiring no version (or a specific version) can also be
    done.</p>
<p class="Pp">The revision history of <b>comm</b> includes these releases:</p>
<dl class="Bl-tag">
  <dt>4.6.1</dt>
  <dd>Changed the implementation of <b>comm::commCollect</b> to emulate lindex's
      pre-Tcl 8 behaviour, i.e. it was given the ability to parse out the first
      word of a list, even if the whole buffer is not a well-formed list.
      Without this change the first word could only be extracted if the whole
      buffer was a well-formed list (ever since Tcl 8), and in a ver-high-load
      situation, i.e. a server sending lots and/or large commands very fast,
      this may never happen, eventually crashing the receiver when it runs out
      of memory. With the change the receiver is always able to process the
      first word when it becomes well-formed, regardless of the structure of the
      remainder of the buffer.</dd>
  <dt>4.6</dt>
  <dd>Added the option <b>-socketcmd</b> enabling users to override how a socket
      is opened. The envisioned main use is the specification of the
      <b>tls::socket</b> command, see package <b>tls</b>, to secure the
      communication.</dd>
  <dt>4.5.7</dt>
  <dd>Changed handling of ports already in use to provide a proper error
      message.</dd>
  <dt>4.5.6</dt>
  <dd>Bugfix in the replacement for <b>vwait</b>, made robust against of
      variable names containing spaces.</dd>
  <dt>4.5.5</dt>
  <dd>Bugfix in the handling of hooks, typo in variable name.</dd>
  <dt>4.5.4</dt>
  <dd>Bugfix in the handling of the result received by the <b>send</b> method.
      Replaced an <i>after idle unset result</i> with an immediate <b>unset</b>,
      with the information saved to a local variable.
    <p class="Pp">The <b>after idle</b> can spill into a forked child process if
        there is no event loop between its setup and the fork. This may bork the
        child if the next event loop is the <b>vwait</b> of <b>comm</b>'s
        <b>send</b> a few lines above the <b>after idle</b>, and the child used
        the same serial number for its next request. In that case the parent's
        <b>after idle unset</b> will delete the very array element the child is
        waiting for, unlocking the <b>vwait</b>, causing it to access a now
        missing array element, instead of the expected result.</p>
  </dd>
  <dt>4.5.3</dt>
  <dd>Bugfixes in the wrappers for the builtin <b>update</b> and <b>vwait</b>
      commands.</dd>
  <dt>4.5.2</dt>
  <dd>Bugfix in the wrapper for the builtin <b>update</b> command.</dd>
  <dt>4.5.1</dt>
  <dd>Bugfixes in the handling of -interp for regular scripts. The handling of
      the buffer was wrong for scripts which are a single statement as list.
      Fixed missing argument to new command <b>commSendReply</b>, introduced by
      version 4.5. Affected debugging.</dd>
  <dt>4.5</dt>
  <dd>New server-side feature. The command invoked on the server can now switch
      comm from the standard synchronous return of its result to an asynchronous
      (defered) return. Due to the use of snit to implement the <i>future</i>
      objects used by this feature from this version on comm requires at least
      Tcl 8.3 to run. Please read the section <b>Asynchronous Result
      Generation</b> for more details.</dd>
  <dt>4.4.1</dt>
  <dd>Bugfix in the execution of hooks.</dd>
  <dt>4.4</dt>
  <dd>Bugfixes in the handling of -interp for regular and hook scripts. Bugfixes
      in channel cleanup.</dd>
  <dt>4.3.1</dt>
  <dd>Introduced -interp and -events to enable easy use of a slave interp for
      execution of received scripts, and of event scripts.</dd>
  <dt>4.3</dt>
  <dd>Bugfixes, and introduces -silent to allow the user to force the
      server/listening side to silently ignore connection attempts where the
      protocol negotiation failed.</dd>
  <dt>4.2</dt>
  <dd>Bugfixes, and most important, switched to utf-8 as default encoding for
      full i18n without any problems.</dd>
  <dt>4.1</dt>
  <dd>Rewrite of internal code to remove old pseudo-object model. Addition of
      send -command asynchronous callback option.</dd>
  <dt>4.0</dt>
  <dd>Per request by John LoVerso. Improved handling of error for async invoked
      commands.</dd>
  <dt>3.7</dt>
  <dd>Moved into tcllib and placed in a proper namespace.</dd>
  <dt>3.6</dt>
  <dd>A bug in the looking up of the remoteid for a executed command could be
      triggered when the connection was closed while several asynchronous sends
      were queued to be executed.</dd>
  <dt>3.5</dt>
  <dd>Internal change to how reply messages from a <b>send</b> are handled.
      Reply messages are now decoded into the <i>value</i> to pass to
      <b>return</b>; a new return statement is then cons'd up to with this
      value. Previously, the return code was passed in from the remote as a
      command to evaluate. Since the wire protocol has not changed, this is
      still the case. Instead, the reply handling code decodes the <b>reply</b>
      message.</dd>
  <dt>3.4</dt>
  <dd>Added more source commentary, as well as documenting config variables in
      this man page. Fixed bug were loss of connection would give error about a
      variable named <b>pending</b> rather than the message about the lost
      connection. <b>comm ids</b> is now an alias for <b>comm interps</b>
      (previously, it an alias for <b>comm chans</b>). Since the method
      invocation change of 3.0, break and other exceptional conditions were not
      being returned correctly from <b>comm send</b>. This has been fixed by
      removing the extra level of indirection into the internal procedure
      <b>commSend</b>. Also added propagation of the <i>errorCode</i> variable.
      This means that these commands return exactly as they would with
      <b>send</b>:
    <p class="Pp"></p>
    <pre>
    comm send id break
    catch {comm send id break}
    comm send id expr 1 / 0
    </pre>
    <p class="Pp">Added a new hook for reply messages. Reworked method
        invocation to avoid the use of comm:* procedures; this also cut the
        invocation time down by 40%. Documented <b>comm config</b> (as this
        manual page still listed the defunct <b>comm init</b>!)</p>
  </dd>
  <dt>3.3</dt>
  <dd>Some minor bugs were corrected and the documentation was cleaned up. Added
      some examples for hooks. The return semantics of the <b>eval</b> hook were
      changed.</dd>
  <dt>3.2</dt>
  <dd>A new wire protocol, version 3, was added. This is backwards compatible
      with version 2 but adds an exchange of supported protocol versions to
      allow protocol negotiation in the future. Several bugs with the hook
      implementation were fixed. A new section of the man page on blocking
      semantics was added.</dd>
  <dt>3.1</dt>
  <dd>All the documented hooks were implemented. <b>commLostHook</b> was
      removed. A bug in <b>comm new</b> was fixed.</dd>
  <dt>3.0</dt>
  <dd>This is a new version of <b>comm</b> with several major changes. There is
      a new way of creating the methods available under the <b>comm</b> command.
      The <b>comm init</b> method has been retired and is replaced by <b>comm
      configure</b> which allows access to many of the well-defined internal
      variables. This also generalizes the options available to <b>comm new</b>.
      Finally, there is now a protocol version exchanged when a connection is
      established. This will allow for future on-wire protocol changes.
      Currently, the protocol version is set to 2.</dd>
  <dt>2.3</dt>
  <dd><b>comm ids</b> was renamed to <b>comm channels</b>. General support for
      <b>comm hook</b> was fully implemented, but only the <i>lost</i> hook
      exists, and it was changed to follow the general hook API.
      <b>commLostHook</b> was unsupported (replaced by <b>comm hook lost</b>)
      and <b>commLost</b> was removed.</dd>
  <dt>2.2</dt>
  <dd>The <i>died</i> hook was renamed <i>lost</i>, to be accessed by
      <b>commLostHook</b> and an early implementation of <b>comm lost hook</b>.
      As such, <b>commDied</b> is now <b>commLost</b>.</dd>
  <dt>2.1</dt>
  <dd>Unsupported method <b>comm remoteid</b> was added.</dd>
  <dt>2.0</dt>
  <dd><b>comm</b> has been rewritten from scratch (but is fully compatible with
      Comm 1.0, without the requirement to use obTcl).</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">John LoVerso, John@LoVerso.Southborough.MA.US</p>
<p class="Pp"><i>http://www.opengroup.org/~loverso/tcl-tk/#comm</i></p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">Please see the file <i>comm.LICENSE</i> that accompanied this
    source, or
    <i>http://www.opengroup.org/www/dist_client/caubweb/COPYRIGHT.free.html</i>.</p>
<p class="Pp">This license for <b>comm</b>, new as of version 3.2, allows it to
    be used for free, without any licensing fee or royalty.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<ul class="Bl-bullet">
  <li>If there is a failure initializing a channel created with <b>::comm::comm
      new</b>, then the channel should be destroyed. Currently, it is left in an
      inconsistent state.</li>
  <li>There should be a way to force a channel to quiesce when changing the
      configuration.</li>
</ul>
<p class="Pp">The following items can be implemented with the existing hooks and
    are listed here as a reminder to provide a sample hook in a future
  version.</p>
<ul class="Bl-bullet">
  <li>Allow easier use of a slave interp for actual command execution
      (especially when operating in &quot;not local&quot; mode).</li>
  <li>Add host list (xhost-like) or &quot;magic cookie&quot; (xauth-like)
      authentication to initial handshake.</li>
</ul>
<p class="Pp">The following are outstanding todo items.</p>
<ul class="Bl-bullet">
  <li>Add an interp discovery and name-&gt;port mapping. This is likely to be in
      a separate, optional nameserver. (See also the related work, below.)</li>
  <li>Fix the <i>{id host}</i> form so as not to be dependent upon canonical
      hostnames. This requires fixes to Tcl to resolve hostnames!</li>
</ul>
<p class="Pp">This man page is bigger than the source file.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ON_USING_OLD_VERSIONS_OF_TCL"><a class="permalink" href="#ON_USING_OLD_VERSIONS_OF_TCL">ON
  USING OLD VERSIONS OF TCL</a></h1>
<p class="Pp">Tcl7.5 under Windows contains a bug that causes the interpreter to
    hang when EOF is reached on non-blocking sockets. This can be triggered with
    a command such as this:</p>
<p class="Pp"></p>
<pre>
    &quot;comm send $other exit&quot;
</pre>
<p class="Pp">Always make sure the channel is quiescent before closing/exiting
    or use at least Tcl7.6 under Windows.</p>
<p class="Pp">Tcl7.6 on the Mac contains several bugs. It is recommended you use
    at least Tcl7.6p2.</p>
<p class="Pp">Tcl8.0 on UNIX contains a socket bug that can crash Tcl. It is
    recommended you use Tcl8.0p1 (or Tcl7.6p2).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="RELATED_WORK"><a class="permalink" href="#RELATED_WORK">RELATED
  WORK</a></h1>
<p class="Pp">Tcl-DP provides an RPC-based remote execution interface, but is a
    compiled Tcl extension. See
    <i>http://www.cs.cornell.edu/Info/Projects/zeno/Projects/Tcl-DP.html</i>.</p>
<p class="Pp">Michael Doyle &lt;miked@eolas.com&gt; has code that implements the
    Tcl-DP RPC interface using standard Tcl sockets, much like <b>comm</b>.</p>
<p class="Pp">Andreas Kupries &lt;andreas_kupries@users.sourceforge.net&gt; uses
    <b>comm</b> and has built a simple nameserver as part of his Pool library.
    See <i>http://www.purl.org/net/akupries/soft/pool/index.htm</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS,_IDEAS,_FEEDBACK"><a class="permalink" href="#BUGS,_IDEAS,_FEEDBACK">BUGS,
  IDEAS, FEEDBACK</a></h1>
<p class="Pp">This document, and the package it describes, will undoubtedly
    contain bugs and other problems. Please report such in the category
    <i>comm</i> of the <i>Tcllib SF Trackers</i>
    [http://sourceforge.net/tracker/?group_id=12883]. Please also report any
    ideas for enhancements you may have for either package and/or
  documentation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">send(n)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
<p class="Pp">comm, communication, ipc, message, remote communication, remote
    execution, rpc, secure, send, socket, ssl, tls</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CATEGORY"><a class="permalink" href="#CATEGORY">CATEGORY</a></h1>
<p class="Pp">Programming tools</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<pre>
Copyright (c) 1995-1998 The Open Group. All Rights Reserved.
Copyright (c) 2003-2004 ActiveState Corporation.
Copyright (c) 2006-2009 Andreas Kupries &lt;andreas_kupries@users.sourceforge.net&gt;
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">4.6.1</td>
    <td class="foot-os">comm</td>
  </tr>
</table>
</body>
</html>

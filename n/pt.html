<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Copyright (c) 2009 Andreas Kupries <andreas_kupries@users.sourceforge.net>
  
   The definitions below are for supplemental macros used in Tcl/Tk
   manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO
  	Start of list of standard options for a Tk widget.  The
  	options follow on successive lines, in four columns separated
  	by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   RCS: @(#) $Id: man.macros,v 1.1 2009/01/30 04:56:47 andreas_kupries Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>pt(n)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">pt(n)</td>
    <td class="head-vol"><a href=".">Parser Tools</a></td>
    <td class="head-rtitle">pt(n)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>
</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">pt - Parser Tools Application</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">package require <b>Tcl 8.5</b></p>
<p class="Pp"><b>pt</b> <b>generate</b> <i>resultformat</i> ?<i>options...</i>?
    <i>resultfile</i> <i>inputformat</i> <i>inputfile</i></p>
<p class="Pp"></p>
<pre>
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Are you lost ? Do you have trouble understanding this document ?
    In that case please read the overview provided by the <i>Introduction to
    Parser Tools</i>. This document is the entrypoint to the whole system the
    current package is a part of.</p>
<p class="Pp">This document describes <b>pt</b>, the main application of the
    module, a <i>parser generator</i>. Its intended audience are people who wish
    to create a parser for some language of theirs. Should you wish to modify
    the application instead, please see the section about the application's
    <b>Internals</b> for the basic references.</p>
<p class="Pp">It resides in the User Application Layer of Parser Tools.</p>
<p class="Pp">IMAGE: arch_user_app</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COMMAND_LINE"><a class="permalink" href="#COMMAND_LINE">COMMAND
  LINE</a></h1>
<dl class="Bl-tag">
  <dt id="pt"><a class="permalink" href="#pt"><b>pt</b> <b>generate</b>
    <i>resultformat</i> ?<i>options...</i>? <i>resultfile</i> <i>inputformat</i>
    <i>inputfile</i></a></dt>
  <dd>This sub-command of the application reads the parsing expression grammar
      stored in the <i>inputfile</i> in the format <i>inputformat</i>, converts
      it to the <i>resultformat</i> under the direction of the (format-specific)
      set of options specified by the user and stores the result in the
      <i>resultfile</i>.
    <p class="Pp">The <i>inputfile</i> has to exist, while the <i>resultfile</i>
        may be created, overwriting any pre-existing content of the file. Any
        missing directory in the path to the <i>resultfile</i> will be created
        as well.</p>
    <p class="Pp">The exact form of the result for, and the set of options
        supported by the known result-formats, are explained in the upcoming
        sections of this document, with the list below providing an index
        mapping between format name and its associated section. In alphabetical
        order:</p>
    <p class="Pp"></p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="c"><a class="permalink" href="#c"><b>c</b></a></dt>
  <dd>A <i>resultformat</i>. See section <b>C Parser</b>.</dd>
  <dt id="container"><a class="permalink" href="#container"><b>container</b></a></dt>
  <dd>A <i>resultformat</i>. See section <b>Grammar Container</b>.</dd>
  <dt id="critcl"><a class="permalink" href="#critcl"><b>critcl</b></a></dt>
  <dd>A <i>resultformat</i>. See section <b>C Parser Embedded In Tcl</b>.</dd>
  <dt id="json"><a class="permalink" href="#json"><b>json</b></a></dt>
  <dd>A <i>input</i>- and <i>resultformat</i>. See section <b>JSON Grammar
      Exchange</b>.</dd>
  <dt id="oo"><a class="permalink" href="#oo"><b>oo</b></a></dt>
  <dd>A <i>resultformat</i>. See section <b>TclOO Parser</b>.</dd>
  <dt id="peg"><a class="permalink" href="#peg"><b>peg</b></a></dt>
  <dd>A <i>input</i>- and <i>resultformat</i>. See section <b>PEG Specification
      Language</b>.</dd>
  <dt id="snit"><a class="permalink" href="#snit"><b>snit</b></a></dt>
  <dd>A <i>resultformat</i>. See section <b>Snit Parser</b>.</dd>
</dl>
</div>
<p class="Pp">Of the seven possible results four are parsers outright (<b>c</b>,
    <b>critcl</b>, <b>oo</b>, and <b>snit</b>), one (<b>container</b>) provides
    code which can be used in conjunction with a generic parser (also known as a
    grammar interpreter), and the last two (<b>json</b> and <b>peg</b>) are
    doing double-duty as input formats, allowing the transformation of grammars
    for exchange, reformatting, and the like.</p>
<p class="Pp">The created parsers fall into three categories:</p>
<p class="Pp">IMAGE: gen_options</p>
<dl class="Bl-tag">
  <dt id="Specialized"><a class="permalink" href="#Specialized"><b>Specialized
    parsers implemented in C</b></a></dt>
  <dd>The fastest parsers are created when using the result formats <b>c</b> and
      <b>critcl</b>. The first returns the raw C code for the parser, while the
      latter wraps it into a Tcl package using <i>CriTcl</i>.
    <p class="Pp">This makes the latter much easier to use than the former. On
        the other hand, the former can be adapted to the users' requirements
        through a multitude of options, allowing for things like usage of the
        parser outside of a Tcl environment, something the <b>critcl</b> format
        doesn't support. As such the <b>c</b> format is meant for more advanced
        users, or users with special needs.</p>
    <p class="Pp">A disadvantage of all the parsers in this section is the need
        to run them through a C compiler to make them actually executable. This
        is not something everyone has the necessary tools for. The parsers in
        the next section are for people under such restrictions.</p>
  </dd>
  <dt id="Specialized~2"><a class="permalink" href="#Specialized~2"><b>Specialized
    parsers implemented in Tcl</b></a></dt>
  <dd>As the parsers in this section are implemented in Tcl they are quite a bit
      slower than anything from the previous section. On the other hand this
      allows them to be used in pure-Tcl environments, or in environments which
      allow only a limited set of binary packages. In the latter case it will be
      advantageous to lobby for the inclusion of the C-based runtime support
      (notes below) into the environment to reduce the impact of Tcl's on the
      speed of these parsers.
    <p class="Pp">The relevant formats are <b>snit</b> and <b>oo</b>. Both place
        their result into a Tcl package containing a <b>snit::type</b>, or TclOO
        <b>class</b> respectively.</p>
    <p class="Pp">Of the supporting runtime, which is the package
        <b>pt::rde</b>, the user has to know nothing but that it does exist and
        that the parsers are dependent on it. Knowledge of the API exported by
        the runtime for the parsers' consumption is <i>not</i> required by the
        parsers' users.</p>
  </dd>
  <dt id="Interpreted"><a class="permalink" href="#Interpreted"><b>Interpreted
    parsing implemented in Tcl</b></a></dt>
  <dd>The last category, grammar interpretation. This means that an interpreter
      for parsing expression grammars takes the description of the grammar to
      parse input for, and uses it guide the parsing process. This is the
      slowest of the available options, as the interpreter has to continually
      run through the configured grammar, whereas the specialized parsers of the
      previous sections have the relevant knowledge about the grammar baked into
      them.
    <p class="Pp">The only places where using interpretation make sense is where
        the grammar for some input may be changed interactively by the user, as
        the interpretation allows for quick turnaround after each change,
        whereas the previous methods require the generation of a whole new
        parser, which is not as fast. On the other hand, wherever the grammar to
        use is fixed, the previous methods are much more advantageous as the
        time to generate the parser is minuscule compared to the time the parser
        code is in use.</p>
    <p class="Pp">The relevant result format is <b>container</b>. It (quickly)
        generates grammar descriptions (instead of a full parser) which match
        the API expected by ParserTools' grammar interpreter. The latter is
        provided by the package <b>pt::peg::interp</b>.</p>
  </dd>
</dl>
<p class="Pp">All the parsers generated by <b>critcl</b>, <b>snit</b>, and
    <b>oo</b>, and the grammar interpreter share a common API for access to the
    actual parsing functionality, making them all plug-compatible. It is
    described in the <i>Parser API</i> specification document.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PEG_SPECIFICATION_LANGUAGE"><a class="permalink" href="#PEG_SPECIFICATION_LANGUAGE">PEG
  SPECIFICATION LANGUAGE</a></h1>
<p class="Pp"><b>peg</b>, a language for the specification of parsing expression
    grammars is meant to be human readable, and writable as well, yet strict
    enough to allow its processing by machine. Like any computer language. It
    was defined to make writing the specification of a grammar easy, something
    the other formats found in the Parser Tools do not lend themselves too.</p>
<p class="Pp">For either an introduction to or the formal specification of the
    language, please go and read the <i>PEG Language Tutorial</i>.</p>
<p class="Pp">When used as a result-format this format supports the following
    options:</p>
<dl class="Bl-tag">
  <dt id="file"><a class="permalink" href="#file"><b>-file</b> string</a></dt>
  <dd>The value of this option is the name of the file or other entity from
      which the grammar came, for which the command is run. The default value is
      <b>unknown</b>.</dd>
  <dt id="name"><a class="permalink" href="#name"><b>-name</b> string</a></dt>
  <dd>The value of this option is the name of the grammar we are processing. The
      default value is <b>a_pe_grammar</b>.</dd>
  <dt id="user"><a class="permalink" href="#user"><b>-user</b> string</a></dt>
  <dd>The value of this option is the name of the user for which the command is
      run. The default value is <b>unknown</b>.</dd>
  <dt id="template"><a class="permalink" href="#template"><b>-template</b>
    string</a></dt>
  <dd>The value of this option is a string into which to put the generated text
      and the values of the other options. The various locations for user-data
      are expected to be specified with the placeholders listed below. The
      default value is &quot;<b>@code@</b>&quot;.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>@user@</b></dt>
  <dd>To be replaced with the value of the option <b>-user</b>.</dd>
  <dt><b>@format@</b></dt>
  <dd>To be replaced with the the constant <b>PEG</b>.</dd>
  <dt><b>@file@</b></dt>
  <dd>To be replaced with the value of the option <b>-file</b>.</dd>
  <dt><b>@name@</b></dt>
  <dd>To be replaced with the value of the option <b>-name</b>.</dd>
  <dt><b>@code@</b></dt>
  <dd>To be replaced with the generated text.</dd>
</dl>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="JSON_GRAMMAR_EXCHANGE"><a class="permalink" href="#JSON_GRAMMAR_EXCHANGE">JSON
  GRAMMAR EXCHANGE</a></h1>
<p class="Pp">The <b>json</b> format for parsing expression grammars was written
    as a data exchange format not bound to Tcl. It was defined to allow the
    exchange of grammars with PackRat/PEG based parser generators for other
    languages.</p>
<p class="Pp">For the formal specification of the JSON grammar exchange format,
    please go and read <i>The JSON Grammar Exchange Format</i>.</p>
<p class="Pp">When used as a result-format this format supports the following
    options:</p>
<dl class="Bl-tag">
  <dt id="file~2"><a class="permalink" href="#file~2"><b>-file</b>
    string</a></dt>
  <dd>The value of this option is the name of the file or other entity from
      which the grammar came, for which the command is run. The default value is
      <b>unknown</b>.</dd>
  <dt id="name~2"><a class="permalink" href="#name~2"><b>-name</b>
    string</a></dt>
  <dd>The value of this option is the name of the grammar we are processing. The
      default value is <b>a_pe_grammar</b>.</dd>
  <dt id="user~2"><a class="permalink" href="#user~2"><b>-user</b>
    string</a></dt>
  <dd>The value of this option is the name of the user for which the command is
      run. The default value is <b>unknown</b>.</dd>
  <dt id="indented"><a class="permalink" href="#indented"><b>-indented</b>
    boolean</a></dt>
  <dd>If this option is set the system will break the generated JSON across
      lines and indent it according to its inner structure, with each key of a
      dictionary on a separate line.
    <p class="Pp">If the option is not set (the default), the whole JSON object
        will be written on a single line, with minimum spacing between all
        elements.</p>
  </dd>
  <dt id="aligned"><a class="permalink" href="#aligned"><b>-aligned</b>
    boolean</a></dt>
  <dd>If this option is set the system will ensure that the values for the keys
      in a dictionary are vertically aligned with each other, for a nice table
      effect. To make this work this also implies that <b>-indented</b> is set.
    <p class="Pp">If the option is not set (the default), the output is
        formatted as per the value of <b>indented</b>, without trying to align
        the values for dictionary keys.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="C_PARSER_EMBEDDED_IN_TCL"><a class="permalink" href="#C_PARSER_EMBEDDED_IN_TCL">C
  PARSER EMBEDDED IN TCL</a></h1>
<p class="Pp">The <b>critcl</b> format is executable code, a parser for the
    grammar. It is a Tcl package with the actual parser implementation written
    in C and embedded in Tcl via the <b>critcl</b> package.</p>
<p class="Pp">This result-format supports the following options:</p>
<dl class="Bl-tag">
  <dt id="file~3"><a class="permalink" href="#file~3"><b>-file</b>
    string</a></dt>
  <dd>The value of this option is the name of the file or other entity from
      which the grammar came, for which the command is run. The default value is
      <b>unknown</b>.</dd>
  <dt id="name~3"><a class="permalink" href="#name~3"><b>-name</b>
    string</a></dt>
  <dd>The value of this option is the name of the grammar we are processing. The
      default value is <b>a_pe_grammar</b>.</dd>
  <dt id="user~3"><a class="permalink" href="#user~3"><b>-user</b>
    string</a></dt>
  <dd>The value of this option is the name of the user for which the command is
      run. The default value is <b>unknown</b>.</dd>
  <dt id="class"><a class="permalink" href="#class"><b>-class</b>
    string</a></dt>
  <dd>The value of this option is the name of the class to generate, without
      leading colons. The default value is <b>CLASS</b>.
    <p class="Pp">For a simple value <b>X</b> without colons, like CLASS, the
        parser command will be <b>X</b>::<b>X</b>. Whereas for a namespaced
        value <b>X::Y</b> the parser command will be <b>X::Y</b>.</p>
  </dd>
  <dt id="package"><a class="permalink" href="#package"><b>-package</b>
    string</a></dt>
  <dd>The value of this option is the name of the package to generate. The
      default value is <b>PACKAGE</b>.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="C_PARSER"><a class="permalink" href="#C_PARSER">C
  PARSER</a></h1>
<p class="Pp">The <b>c</b> format is executable code, a parser for the grammar.
    The parser implementation is written in C and can be tweaked to the users'
    needs through a multitude of options.</p>
<p class="Pp">The <b>critcl</b> format, for example, is implemented as a canned
    configuration of these options on top of the generator for <b>c</b>.</p>
<p class="Pp">This result-format supports the following options:</p>
<dl class="Bl-tag">
  <dt id="file~4"><a class="permalink" href="#file~4"><b>-file</b>
    string</a></dt>
  <dd>The value of this option is the name of the file or other entity from
      which the grammar came, for which the command is run. The default value is
      <b>unknown</b>.</dd>
  <dt id="name~4"><a class="permalink" href="#name~4"><b>-name</b>
    string</a></dt>
  <dd>The value of this option is the name of the grammar we are processing. The
      default value is <b>a_pe_grammar</b>.</dd>
  <dt id="user~4"><a class="permalink" href="#user~4"><b>-user</b>
    string</a></dt>
  <dd>The value of this option is the name of the user for which the command is
      run. The default value is <b>unknown</b>.</dd>
  <dt id="template~2"><a class="permalink" href="#template~2"><b>-template</b>
    string</a></dt>
  <dd>The value of this option is a string into which to put the generated text
      and the other configuration settings. The various locations for user-data
      are expected to be specified with the placeholders listed below. The
      default value is &quot;<b>@code@</b>&quot;.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>@user@</b></dt>
  <dd>To be replaced with the value of the option <b>-user</b>.</dd>
  <dt><b>@format@</b></dt>
  <dd>To be replaced with the the constant <b>C/PARAM</b>.</dd>
  <dt><b>@file@</b></dt>
  <dd>To be replaced with the value of the option <b>-file</b>.</dd>
  <dt><b>@name@</b></dt>
  <dd>To be replaced with the value of the option <b>-name</b>.</dd>
  <dt><b>@code@</b></dt>
  <dd>To be replaced with the generated Tcl code.</dd>
</dl>
</div>
The following options are special, in that they will occur within the generated
  code, and are replaced there as well.
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>@statedecl@</b></dt>
  <dd>To be replaced with the value of the option <b>state-decl</b>.</dd>
  <dt><b>@stateref@</b></dt>
  <dd>To be replaced with the value of the option <b>state-ref</b>.</dd>
  <dt><b>@strings@</b></dt>
  <dd>To be replaced with the value of the option <b>string-varname</b>.</dd>
  <dt><b>@self@</b></dt>
  <dd>To be replaced with the value of the option <b>self-command</b>.</dd>
  <dt><b>@def@</b></dt>
  <dd>To be replaced with the value of the option <b>fun-qualifier</b>.</dd>
  <dt><b>@ns@</b></dt>
  <dd>To be replaced with the value of the option <b>namespace</b>.</dd>
  <dt><b>@main@</b></dt>
  <dd>To be replaced with the value of the option <b>main</b>.</dd>
  <dt><b>@prelude@</b></dt>
  <dd>To be replaced with the value of the option <b>prelude</b>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="state_decl"><a class="permalink" href="#state_decl"><b>-state-decl</b>
    string</a></dt>
  <dd>A C string representing the argument declaration to use in the generated
      parsing functions to refer to the parsing state. In essence type and
      argument name. The default value is the string <b>RDE_PARAM p</b>.</dd>
  <dt id="state_ref"><a class="permalink" href="#state_ref"><b>-state-ref</b>
    string</a></dt>
  <dd>A C string representing the argument named used in the generated parsing
      functions to refer to the parsing state. The default value is the string
      <b>p</b>.</dd>
  <dt id="self_command"><a class="permalink" href="#self_command"><b>-self-command</b>
    string</a></dt>
  <dd>A C string representing the reference needed to call the generated parser
      function (methods ...) from another parser fonction, per the chosen
      framework (template). The default value is the empty string.</dd>
  <dt id="fun_qualifier"><a class="permalink" href="#fun_qualifier"><b>-fun-qualifier</b>
    string</a></dt>
  <dd>A C string containing the attributes to give to the generated functions
      (methods ...), per the chosen framework (template). The default value is
      <b>static</b>.</dd>
  <dt id="namespace"><a class="permalink" href="#namespace"><b>-namespace</b>
    string</a></dt>
  <dd>The name of the C namespace the parser functions (methods, ...) shall
      reside in, or a general prefix to add to the function names. The default
      value is the empty string.</dd>
  <dt id="main"><a class="permalink" href="#main"><b>-main</b> string</a></dt>
  <dd>The name of the main function (method, ...) to be called by the chosen
      framework (template) to start parsing input. The default value is
      <b>__main</b>.</dd>
  <dt id="string_varname"><a class="permalink" href="#string_varname"><b>-string-varname</b>
    string</a></dt>
  <dd>The name of the variable used for the table of strings used by the
      generated parser, i.e. error messages, symbol names, etc. The default
      value is <b>p_string</b>.</dd>
  <dt id="prelude"><a class="permalink" href="#prelude"><b>-prelude</b>
    string</a></dt>
  <dd>A snippet of code to be inserted at the head of each generated parsing
      function. The default value is the empty string.</dd>
  <dt id="indent"><a class="permalink" href="#indent"><b>-indent</b>
    integer</a></dt>
  <dd>The number of characters to indent each line of the generated code by. The
      default value is <b>0</b>.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SNIT_PARSER"><a class="permalink" href="#SNIT_PARSER">SNIT
  PARSER</a></h1>
<p class="Pp">The <b>snit</b> format is executable code, a parser for the
    grammar. It is a Tcl package holding a <b>snit::type</b>, i.e. a class,
    whose instances are parsers for the input grammar.</p>
<p class="Pp">This result-format supports the following options:</p>
<dl class="Bl-tag">
  <dt id="file~5"><a class="permalink" href="#file~5"><b>-file</b>
    string</a></dt>
  <dd>The value of this option is the name of the file or other entity from
      which the grammar came, for which the command is run. The default value is
      <b>unknown</b>.</dd>
  <dt id="name~5"><a class="permalink" href="#name~5"><b>-name</b>
    string</a></dt>
  <dd>The value of this option is the name of the grammar we are processing. The
      default value is <b>a_pe_grammar</b>.</dd>
  <dt id="user~5"><a class="permalink" href="#user~5"><b>-user</b>
    string</a></dt>
  <dd>The value of this option is the name of the user for which the command is
      run. The default value is <b>unknown</b>.</dd>
  <dt id="class~2"><a class="permalink" href="#class~2"><b>-class</b>
    string</a></dt>
  <dd>The value of this option is the name of the class to generate, without
      leading colons. Note, it serves double-duty as the name of the package to
      generate too. The default value is <b>CLASS</b>.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="TCLOO_PARSER"><a class="permalink" href="#TCLOO_PARSER">TCLOO
  PARSER</a></h1>
<p class="Pp">The <b>oo</b> format is executable code, a parser for the grammar.
    It is a Tcl package holding a <b>TclOO</b> class, whose instances are
    parsers for the input grammar.</p>
<p class="Pp">This result-format supports the following options:</p>
<dl class="Bl-tag">
  <dt id="file~6"><a class="permalink" href="#file~6"><b>-file</b>
    string</a></dt>
  <dd>The value of this option is the name of the file or other entity from
      which the grammar came, for which the command is run. The default value is
      <b>unknown</b>.</dd>
  <dt id="name~6"><a class="permalink" href="#name~6"><b>-name</b>
    string</a></dt>
  <dd>The value of this option is the name of the grammar we are processing. The
      default value is <b>a_pe_grammar</b>.</dd>
  <dt id="user~6"><a class="permalink" href="#user~6"><b>-user</b>
    string</a></dt>
  <dd>The value of this option is the name of the user for which the command is
      run. The default value is <b>unknown</b>.</dd>
  <dt id="class~3"><a class="permalink" href="#class~3"><b>-class</b>
    string</a></dt>
  <dd>The value of this option is the name of the class to generate, without
      leading colons. Note, it serves double-duty as the name of the package to
      generate too. The default value is <b>CLASS</b>.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="GRAMMAR_CONTAINER"><a class="permalink" href="#GRAMMAR_CONTAINER">GRAMMAR
  CONTAINER</a></h1>
<p class="Pp">The <b>container</b> format is another form of describing parsing
    expression grammars. While data in this format is executable it does not
    constitute a parser for the grammar. It always has to be used in conjunction
    with the package <b>pt::peg::interp</b>, a grammar interpreter.</p>
<p class="Pp">The format represents grammars by a <b>snit::type</b>, i.e. class,
    whose instances are API-compatible to the instances of the
    <b>pt::peg::container</b> package, and which are preloaded with the grammar
    in question.</p>
<p class="Pp">This result-format supports the following options:</p>
<dl class="Bl-tag">
  <dt id="file~7"><a class="permalink" href="#file~7"><b>-file</b>
    string</a></dt>
  <dd>The value of this option is the name of the file or other entity from
      which the grammar came, for which the command is run. The default value is
      <b>unknown</b>.</dd>
  <dt id="name~7"><a class="permalink" href="#name~7"><b>-name</b>
    string</a></dt>
  <dd>The value of this option is the name of the grammar we are processing. The
      default value is <b>a_pe_grammar</b>.</dd>
  <dt id="user~7"><a class="permalink" href="#user~7"><b>-user</b>
    string</a></dt>
  <dd>The value of this option is the name of the user for which the command is
      run. The default value is <b>unknown</b>.</dd>
  <dt id="mode"><a class="permalink" href="#mode"><b>-mode</b>
    <b>bulk</b>|<b>incremental</b></a></dt>
  <dd>The value of this option controls which methods of
      <b>pt::peg::container</b> instances are used to specify the grammar, i.e.
      preload it into the container. There are two legal values, as listed
      below. The default is <b>bulk</b>.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="bulk"><a class="permalink" href="#bulk"><b>bulk</b></a></dt>
  <dd>In this mode the methods <b>start</b>, <b>add</b>, <b>modes</b>, and
      <b>rules</b> are used to specify the grammar in a bulk manner, i.e. as a
      set of nonterminal symbols, and two dictionaries mapping from the symbols
      to their semantic modes and parsing expressions.
    <p class="Pp">This mode is the default.</p>
  </dd>
  <dt id="incremental"><a class="permalink" href="#incremental"><b>incremental</b></a></dt>
  <dd>In this mode the methods <b>start</b>, <b>add</b>, <b>mode</b>, and
      <b>rule</b> are used to specify the grammar piecemal, with each
      nonterminal having its own block of defining commands.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="template~3"><a class="permalink" href="#template~3"><b>-template</b>
    string</a></dt>
  <dd>The value of this option is a string into which to put the generated code
      and the other configuration settings. The various locations for user-data
      are expected to be specified with the placeholders listed below. The
      default value is &quot;<b>@code@</b>&quot;.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>@user@</b></dt>
  <dd>To be replaced with the value of the option <b>-user</b>.</dd>
  <dt><b>@format@</b></dt>
  <dd>To be replaced with the the constant <b>CONTAINER</b>.</dd>
  <dt><b>@file@</b></dt>
  <dd>To be replaced with the value of the option <b>-file</b>.</dd>
  <dt><b>@name@</b></dt>
  <dd>To be replaced with the value of the option <b>-name</b>.</dd>
  <dt><b>@mode@</b></dt>
  <dd>To be replaced with the value of the option <b>-mode</b>.</dd>
  <dt><b>@code@</b></dt>
  <dd>To be replaced with the generated code.</dd>
</dl>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLE"><a class="permalink" href="#EXAMPLE">EXAMPLE</a></h1>
<p class="Pp">In this section we are working a complete example, starting with a
    PEG grammar and ending with running the parser generated from it over some
    input, following the outline shown in the figure below:</p>
<p class="Pp">IMAGE: flow</p>
<p class="Pp">Our grammar, assumed to the stored in the file
    &quot;<i>calculator.peg</i>&quot; is</p>
<pre>
PEG calculator (Expression)
    Digit      &lt;- '0'/'1'/'2'/'3'/'4'/'5'/'6'/'7'/'8'/'9'	;
    Sign       &lt;- '-' / '+'					;
    Number     &lt;- Sign? Digit+					;
    Expression &lt;- '(' Expression ')' / (Factor (MulOp Factor)*)	;
    MulOp      &lt;- '*' / '/'					;
    Factor     &lt;- Term (AddOp Term)*				;
    AddOp      &lt;- '+'/'-'					;
    Term       &lt;- Number					;
END;
</pre>
From this we create a snit-based parser via
<pre>
pt generate  snit calculator.tcl  -class calculator  -name  calculator  peg calculator.peg
</pre>
which leaves us with the parser package and class written to the file
  &quot;<i>calculator.tcl</i>&quot;. Assuming that this package is then properly
  installed in a place where Tcl can find it we can now use this class via a
  script like
<pre>
    package require calculator
    lassign $argv input
    set channel [open $input r]
    set parser [calculator]
    set ast [$parser parse $channel]
    $parser destroy
    close $channel
    ... now process the returned abstract syntax tree ...
</pre>
where the abstract syntax tree stored in the variable will look like
<p class="Pp"></p>
<pre>
set ast {Expression 0 4
    {Factor 0 4
        {Term 0 2
            {Number 0 2
                {Digit 0 0}
                {Digit 1 1}
                {Digit 2 2}
            }
        }
        {AddOp 3 3}
        {Term 4 4
            {Number 4 4
                {Digit 4 4}
            }
        }
    }
}
</pre>
<p class="Pp">assuming that the input file and channel contained the text</p>
<pre>
 120+5</pre>
A more graphical representation of the tree would be
<p class="Pp">IMAGE: expr_ast</p>
<p class="Pp">Regardless, at this point it is the user's responsibility to work
    with the tree to reach whatever goal she desires. I.e. analyze it, transform
    it, etc. The package <b>pt::ast</b> should be of help here, providing
    commands to walk such ASTs structures in various ways.</p>
<p class="Pp">One important thing to note is that the parsers used here return a
    data structure representing the structure of the input per the grammar
    underlying the parser. There are <i>no</i> callbacks during the parsing
    process, i.e. no <i>parsing actions</i>, as most other parsers will
  have.</p>
<p class="Pp">Going back to the last snippet of code, the execution of the
    parser for some input, note how the parser instance follows the specified
    <i>Parser API</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="INTERNALS"><a class="permalink" href="#INTERNALS">INTERNALS</a></h1>
<p class="Pp">This section is intended for users of the application which wish
    to modify or extend it. Users only interested in the generation of parsers
    can ignore it.</p>
<p class="Pp">The main functionality of the application is encapsulated in the
    package <b>pt::pgen</b>. Please read it for more information.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS,_IDEAS,_FEEDBACK"><a class="permalink" href="#BUGS,_IDEAS,_FEEDBACK">BUGS,
  IDEAS, FEEDBACK</a></h1>
<p class="Pp">This document, and the package it describes, will undoubtedly
    contain bugs and other problems. Please report such in the category
    <i>pt</i> of the <i>Tcllib SF Trackers</i>
    [http://sourceforge.net/tracker/?group_id=12883]. Please also report any
    ideas for enhancements you may have for either package and/or
  documentation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
<p class="Pp">EBNF, LL(k), PEG, TDPL, context-free languages, expression,
    grammar, matching, parser, parsing expression, parsing expression grammar,
    push down automaton, recursive descent, state, top-down parsing languages,
    transducer</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CATEGORY"><a class="permalink" href="#CATEGORY">CATEGORY</a></h1>
<p class="Pp">Parsing and Grammars</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<pre>Copyright (c) 2009 Andreas Kupries &lt;andreas_kupries@users.sourceforge.net&gt;
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">1</td>
    <td class="foot-os"><a href="..">pt</a></td>
  </tr>
</table>
</body>
</html>

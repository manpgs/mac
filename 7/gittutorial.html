<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   t
       Title: gittutorial
      Author: [FIXME: author] [see http://www.docbook.org/tdg5/en/html/author]
   Generator: DocBook XSL Stylesheets vsnapshot <http://docbook.sf.net/>
        Date: 06/27/2022
      Manual: Git Manual
      Source: Git 2.37.0
    Language: English
   -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>GITTUTORIAL(7)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">GITTUTORIAL(7)</td>
    <td class="head-vol">Git Manual</td>
    <td class="head-rtitle">GITTUTORIAL(7)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">gittutorial - A tutorial introduction to Git</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
git *
</pre>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This tutorial explains how to import a new project into Git, make
    changes to it, and share changes with other developers.</p>
<p class="Pp">If you are instead primarily interested in using Git to fetch a
    project, for example, to test the latest version, you may prefer to start
    with the first two chapters of <b>The Git User&#x2019;s Manual</b>[1].</p>
<p class="Pp">First, note that you can get documentation for a command such as
    <b>git log --graph</b> with:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ man git-log
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">or:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git help log
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">With the latter, you can use the manual viewer of your choice; see
    <b>git-help</b>(1) for more information.</p>
<p class="Pp">It is a good idea to introduce yourself to Git with your name and
    public email address before doing any operation. The easiest way to do so
    is:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git config --global user.name &quot;Your Name Comes Here&quot;
$ git config --global user.email you@yourdomain.example.com
</pre>
</div>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="IMPORTING_A_NEW_PROJECT"><a class="permalink" href="#IMPORTING_A_NEW_PROJECT">IMPORTING
  A NEW PROJECT</a></h1>
<p class="Pp">Assume you have a tarball project.tar.gz with your initial work.
    You can place it under Git revision control as follows.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ tar xzf project.tar.gz
$ cd project
$ git init
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">Git will reply</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
Initialized empty Git repository in .git/
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">You&#x2019;ve now initialized the working directory&#x2014;you may
    notice a new directory created, named &quot;.git&quot;.</p>
<p class="Pp">Next, tell Git to take a snapshot of the contents of all files
    under the current directory (note the <i>.</i>), with <i>git add</i>:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git add .
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">This snapshot is now stored in a temporary staging area which Git
    calls the &quot;index&quot;. You can permanently store the contents of the
    index in the repository with <i>git commit</i>:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git commit
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">This will prompt you for a commit message. You&#x2019;ve now
    stored the first version of your project in Git.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MAKING_CHANGES"><a class="permalink" href="#MAKING_CHANGES">MAKING
  CHANGES</a></h1>
<p class="Pp">Modify some files, then add their updated contents to the
  index:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git add file1 file2 file3
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">You are now ready to commit. You can see what is about to be
    committed using <i>git diff</i> with the --cached option:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git diff --cached
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">(Without --cached, <i>git diff</i> will show you any changes that
    you&#x2019;ve made but not yet added to the index.) You can also get a brief
    summary of the situation with <i>git status</i>:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git status
On branch master
Changes to be committed:
Your branch is up to date with 'origin/master'.
  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)
        modified:   file1
        modified:   file2
        modified:   file3
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">If you need to make any further adjustments, do so now, and then
    add any newly modified content to the index. Finally, commit your changes
    with:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git commit
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">This will again prompt you for a message describing the change,
    and then record a new version of the project.</p>
<p class="Pp">Alternatively, instead of running <i>git add</i> beforehand, you
    can use</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git commit -a
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">which will automatically notice any modified (but not new) files,
    add them to the index, and commit, all in one step.</p>
<p class="Pp">A note on commit messages: Though not required, it&#x2019;s a good
    idea to begin the commit message with a single short (less than 50
    character) line summarizing the change, followed by a blank line and then a
    more thorough description. The text up to the first blank line in a commit
    message is treated as the commit title, and that title is used throughout
    Git. For example, <b>git-format-patch</b>(1) turns a commit into email, and
    it uses the title on the Subject line and the rest of the commit in the
    body.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="GIT_TRACKS_CONTENT_NOT_FILES"><a class="permalink" href="#GIT_TRACKS_CONTENT_NOT_FILES">GIT
  TRACKS CONTENT NOT FILES</a></h1>
<p class="Pp">Many revision control systems provide an <b>add</b> command that
    tells the system to start tracking changes to a new file. Git&#x2019;s
    <b>add</b> command does something simpler and more powerful: <i>git add</i>
    is used both for new and newly modified files, and in both cases it takes a
    snapshot of the given files and stages that content in the index, ready for
    inclusion in the next commit.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VIEWING_PROJECT_HISTORY"><a class="permalink" href="#VIEWING_PROJECT_HISTORY">VIEWING
  PROJECT HISTORY</a></h1>
<p class="Pp">At any point you can view the history of your changes using</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git log
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">If you also want to see complete diffs at each step, use</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git log -p
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">Often the overview of the change is useful to get a feel of each
    step</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git log --stat --summary
</pre>
</div>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="MANAGING_BRANCHES"><a class="permalink" href="#MANAGING_BRANCHES">MANAGING
  BRANCHES</a></h1>
<p class="Pp">A single Git repository can maintain multiple branches of
    development. To create a new branch named &quot;experimental&quot;, use</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git branch experimental
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">If you now run</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git branch
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">you&#x2019;ll get a list of all existing branches:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
  experimental
* master
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">The &quot;experimental&quot; branch is the one you just created,
    and the &quot;master&quot; branch is a default branch that was created for
    you automatically. The asterisk marks the branch you are currently on;
  type</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git switch experimental
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">to switch to the experimental branch. Now edit a file, commit the
    change, and switch back to the master branch:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
(edit file)
$ git commit -a
$ git switch master
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">Check that the change you made is no longer visible, since it was
    made on the experimental branch and you&#x2019;re back on the master
  branch.</p>
<p class="Pp">You can make a different change on the master branch:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
(edit file)
$ git commit -a
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">at this point the two branches have diverged, with different
    changes made in each. To merge the changes made in experimental into master,
    run</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git merge experimental
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">If the changes don&#x2019;t conflict, you&#x2019;re done. If there
    are conflicts, markers will be left in the problematic files showing the
    conflict;</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git diff
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">will show this. Once you&#x2019;ve edited the files to resolve the
    conflicts,</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git commit -a
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">will commit the result of the merge. Finally,</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ gitk
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">will show a nice graphical representation of the resulting
    history.</p>
<p class="Pp">At this point you could delete the experimental branch with</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git branch -d experimental
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">This command ensures that the changes in the experimental branch
    are already in the current branch.</p>
<p class="Pp">If you develop on a branch crazy-idea, then regret it, you can
    always delete the branch with</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git branch -D crazy-idea
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">Branches are cheap and easy, so this is a good way to try
    something out.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="USING_GIT_FOR_COLLABORATION"><a class="permalink" href="#USING_GIT_FOR_COLLABORATION">USING
  GIT FOR COLLABORATION</a></h1>
<p class="Pp">Suppose that Alice has started a new project with a Git repository
    in /home/alice/project, and that Bob, who has a home directory on the same
    machine, wants to contribute.</p>
<p class="Pp">Bob begins with:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
bob$ git clone /home/alice/project myrepo
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">This creates a new directory &quot;myrepo&quot; containing a clone
    of Alice&#x2019;s repository. The clone is on an equal footing with the
    original project, possessing its own copy of the original project&#x2019;s
    history.</p>
<p class="Pp">Bob then makes some changes and commits them:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
(edit files)
bob$ git commit -a
(repeat as necessary)
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">When he&#x2019;s ready, he tells Alice to pull changes from the
    repository at /home/bob/myrepo. She does this with:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
alice$ cd /home/alice/project
alice$ git pull /home/bob/myrepo master
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">This merges the changes from Bob&#x2019;s &quot;master&quot;
    branch into Alice&#x2019;s current branch. If Alice has made her own changes
    in the meantime, then she may need to manually fix any conflicts.</p>
<p class="Pp">The &quot;pull&quot; command thus performs two operations: it
    fetches changes from a remote branch, then merges them into the current
    branch.</p>
<p class="Pp">Note that in general, Alice would want her local changes committed
    before initiating this &quot;pull&quot;. If Bob&#x2019;s work conflicts with
    what Alice did since their histories forked, Alice will use her working tree
    and the index to resolve conflicts, and existing local changes will
    interfere with the conflict resolution process (Git will still perform the
    fetch but will refuse to merge &#x2014; Alice will have to get rid of her
    local changes in some way and pull again when this happens).</p>
<p class="Pp">Alice can peek at what Bob did without merging first, using the
    &quot;fetch&quot; command; this allows Alice to inspect what Bob did, using
    a special symbol &quot;FETCH_HEAD&quot;, in order to determine if he has
    anything worth pulling, like this:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
alice$ git fetch /home/bob/myrepo master
alice$ git log -p HEAD..FETCH_HEAD
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">This operation is safe even if Alice has uncommitted local
    changes. The range notation &quot;HEAD..FETCH_HEAD&quot; means &quot;show
    everything that is reachable from the FETCH_HEAD but exclude anything that
    is reachable from HEAD&quot;. Alice already knows everything that leads to
    her current state (HEAD), and reviews what Bob has in his state (FETCH_HEAD)
    that she has not seen with this command.</p>
<p class="Pp">If Alice wants to visualize what Bob did since their histories
    forked she can issue the following command:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ gitk HEAD..FETCH_HEAD
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">This uses the same two-dot range notation we saw earlier with
    <i>git log</i>.</p>
<p class="Pp">Alice may want to view what both of them did since they forked.
    She can use three-dot form instead of the two-dot form:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ gitk HEAD...FETCH_HEAD
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">This means &quot;show everything that is reachable from either
    one, but exclude anything that is reachable from both of them&quot;.</p>
<p class="Pp">Please note that these range notation can be used with both gitk
    and &quot;git log&quot;.</p>
<p class="Pp">After inspecting what Bob did, if there is nothing urgent, Alice
    may decide to continue working without pulling from Bob. If Bob&#x2019;s
    history does have something Alice would immediately need, Alice may choose
    to stash her work-in-progress first, do a &quot;pull&quot;, and then finally
    unstash her work-in-progress on top of the resulting history.</p>
<p class="Pp">When you are working in a small closely knit group, it is not
    unusual to interact with the same repository over and over again. By
    defining <i>remote</i> repository shorthand, you can make it easier:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
alice$ git remote add bob /home/bob/myrepo
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">With this, Alice can perform the first part of the
    &quot;pull&quot; operation alone using the <i>git fetch</i> command without
    merging them with her own branch, using:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
alice$ git fetch bob
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">Unlike the longhand form, when Alice fetches from Bob using a
    remote repository shorthand set up with <i>git remote</i>, what was fetched
    is stored in a remote-tracking branch, in this case <b>bob/master</b>. So
    after this:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
alice$ git log -p master..bob/master
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">shows a list of all the changes that Bob made since he branched
    from Alice&#x2019;s master branch.</p>
<p class="Pp">After examining those changes, Alice could merge the changes into
    her master branch:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
alice$ git merge bob/master
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">This <b>merge</b> can also be done by <i>pulling from her own
    remote-tracking branch</i>, like this:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
alice$ git pull . remotes/bob/master
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">Note that git pull always merges into the current branch,
    regardless of what else is given on the command line.</p>
<p class="Pp">Later, Bob can update his repo with Alice&#x2019;s latest changes
    using</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
bob$ git pull
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">Note that he doesn&#x2019;t need to give the path to
    Alice&#x2019;s repository; when Bob cloned Alice&#x2019;s repository, Git
    stored the location of her repository in the repository configuration, and
    that location is used for pulls:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
bob$ git config --get remote.origin.url
/home/alice/project
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">(The complete configuration created by <i>git clone</i> is visible
    using <b>git config -l</b>, and the <b>git-config</b>(1) man page explains
    the meaning of each option.)</p>
<p class="Pp">Git also keeps a pristine copy of Alice&#x2019;s master branch
    under the name &quot;origin/master&quot;:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
bob$ git branch -r
  origin/master
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">If Bob later decides to work from a different host, he can still
    perform clones and pulls using the ssh protocol:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
bob$ git clone alice.org:/home/alice/project myrepo
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">Alternatively, Git has a native protocol, or can use http; see
    <b>git-pull</b>(1) for details.</p>
<p class="Pp">Git can also be used in a CVS-like mode, with a central repository
    that various users push changes to; see <b>git-push</b>(1) and
    <b>gitcvs-migration</b>(7).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPLORING_HISTORY"><a class="permalink" href="#EXPLORING_HISTORY">EXPLORING
  HISTORY</a></h1>
<p class="Pp">Git history is represented as a series of interrelated commits. We
    have already seen that the <i>git log</i> command can list those commits.
    Note that first line of each git log entry also gives a name for the
  commit:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git log
commit c82a22c39cbc32576f64f5c6b3f24b99ea8149c7
Author: Junio C Hamano &lt;junkio@cox.net&gt;
Date:   Tue May 16 17:18:22 2006 -0700
    merge-base: Clarify the comments on post processing.
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">We can give this name to <i>git show</i> to see the details about
    this commit.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git show c82a22c39cbc32576f64f5c6b3f24b99ea8149c7
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">But there are other ways to refer to commits. You can use any
    initial part of the name that is long enough to uniquely identify the
    commit:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git show c82a22c39c   # the first few characters of the name are
                        # usually enough
$ git show HEAD         # the tip of the current branch
$ git show experimental # the tip of the &quot;experimental&quot; branch
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">Every commit usually has one &quot;parent&quot; commit which
    points to the previous state of the project:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git show HEAD^  # to see the parent of HEAD
$ git show HEAD^^ # to see the grandparent of HEAD
$ git show HEAD~4 # to see the great-great grandparent of HEAD
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">Note that merge commits may have more than one parent:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git show HEAD^1 # show the first parent of HEAD (same as HEAD^)
$ git show HEAD^2 # show the second parent of HEAD
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">You can also give commits names of your own; after running</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git tag v2.5 1b2e1d63ff
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">you can refer to 1b2e1d63ff by the name &quot;v2.5&quot;. If you
    intend to share this name with other people (for example, to identify a
    release version), you should create a &quot;tag&quot; object, and perhaps
    sign it; see <b>git-tag</b>(1) for details.</p>
<p class="Pp">Any Git command that needs to know a commit can take any of these
    names. For example:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git diff v2.5 HEAD     # compare the current HEAD to v2.5
$ git branch stable v2.5 # start a new branch named &quot;stable&quot; based
                         # at v2.5
$ git reset --hard HEAD^ # reset your current branch and working
                         # directory to its state at HEAD^
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">Be careful with that last command: in addition to losing any
    changes in the working directory, it will also remove all later commits from
    this branch. If this branch is the only branch containing those commits,
    they will be lost. Also, don&#x2019;t use <i>git reset</i> on a
    publicly-visible branch that other developers pull from, as it will force
    needless merges on other developers to clean up the history. If you need to
    undo changes that you have pushed, use <i>git revert</i> instead.</p>
<p class="Pp">The <i>git grep</i> command can search for strings in any version
    of your project, so</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git grep &quot;hello&quot; v2.5
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">searches for all occurrences of &quot;hello&quot; in v2.5.</p>
<p class="Pp">If you leave out the commit name, <i>git grep</i> will search any
    of the files it manages in your current directory. So</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git grep &quot;hello&quot;
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">is a quick way to search just the files that are tracked by
  Git.</p>
<p class="Pp">Many Git commands also take sets of commits, which can be
    specified in a number of ways. Here are some examples with <i>git
  log</i>:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git log v2.5..v2.6            # commits between v2.5 and v2.6
$ git log v2.5..                # commits since v2.5
$ git log --since=&quot;2 weeks ago&quot; # commits from the last 2 weeks
$ git log v2.5.. Makefile       # commits since v2.5 which modify
                                # Makefile
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">You can also give <i>git log</i> a &quot;range&quot; of commits
    where the first is not necessarily an ancestor of the second; for example,
    if the tips of the branches &quot;stable&quot; and &quot;master&quot;
    diverged from a common commit some time ago, then</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git log stable..master
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">will list commits made in the master branch but not in the stable
    branch, while</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git log master..stable
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">will show the list of commits made on the stable branch but not
    the master branch.</p>
<p class="Pp">The <i>git log</i> command has a weakness: it must present commits
    in a list. When the history has lines of development that diverged and then
    merged back together, the order in which <i>git log</i> presents those
    commits is meaningless.</p>
<p class="Pp">Most projects with multiple contributors (such as the Linux
    kernel, or Git itself) have frequent merges, and <i>gitk</i> does a better
    job of visualizing their history. For example,</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ gitk --since=&quot;2 weeks ago&quot; drivers/
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">allows you to browse any commits from the last 2 weeks of commits
    that modified files under the &quot;drivers&quot; directory. (Note: you can
    adjust gitk&#x2019;s fonts by holding down the control key while pressing
    &quot;-&quot; or &quot;+&quot;.)</p>
<p class="Pp">Finally, most commands that take filenames will optionally allow
    you to precede any filename by a commit, to specify a particular version of
    the file:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git diff v2.5:Makefile HEAD:Makefile.in
</pre>
</div>
<p class="Pp"></p>
<p class="Pp">You can also use <i>git show</i> to see any such file:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
$ git show v2.5:Makefile
</pre>
</div>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="NEXT_STEPS"><a class="permalink" href="#NEXT_STEPS">NEXT
  STEPS</a></h1>
<p class="Pp">This tutorial should be enough to perform basic distributed
    revision control for your projects. However, to fully understand the depth
    and power of Git you need to understand two simple ideas on which it is
    based:</p>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;The object database is the rather elegant system
  used to store the history of your project&#x2014;files, directories, and
  commits.</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;The index file is a cache of the state of a
  directory tree, used to create commits, check out working directories, and
  hold the various trees involved in a merge.</div>
<p class="Pp">Part two of this tutorial explains the object database, the index
    file, and a few other odds and ends that you&#x2019;ll need to make the most
    of Git. You can find it at <b>gittutorial-2</b>(7).</p>
<p class="Pp">If you don&#x2019;t want to continue with that right away, a few
    other digressions that may be interesting at this point are:</p>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;<b>git-format-patch</b>(1), <b>git-am</b>(1):
  These convert series of git commits into emailed patches, and vice versa,
  useful for projects such as the Linux kernel which rely heavily on emailed
  patches.</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;<b>git-bisect</b>(1): When there is a regression
  in your project, one way to track down the bug is by searching through the
  history to find the exact commit that&#x2019;s to blame. Git bisect can help
  you perform a binary search for that commit. It is smart enough to perform a
  close-to-optimal search even in the case of complex non-linear history with
  lots of merged branches.</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;<b>gitworkflows</b>(7): Gives an overview of
  recommended workflows.</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;<b>giteveryday</b>(7): Everyday Git with 20
  Commands Or So.</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;<b>gitcvs-migration</b>(7): Git for CVS
  users.</div>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>gittutorial-2</b>(7), <b>gitcvs-migration</b>(7),
    <b>gitcore-tutorial</b>(7), <b>gitglossary</b>(7), <b>git-help</b>(1),
    <b>gitworkflows</b>(7), <b>giteveryday</b>(7), <b>The Git User&#x2019;s
    Manual</b>[1]</p>
</section>
<section class="Sh">
<h1 class="Sh" id="GIT"><a class="permalink" href="#GIT">GIT</a></h1>
<p class="Pp">Part of the <b>git</b>(1) suite</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<dl class="Bl-tag">
  <dt> 1.</dt>
  <dd>The Git User&#x2019;s Manual</dd>
</dl>
<div class="Bd-indent">git-htmldocs/user-manual.html</div>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">06/27/2022</td>
    <td class="foot-os">Git 2.37.0</td>
  </tr>
</table>
</body>
</html>

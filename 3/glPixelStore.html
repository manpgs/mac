<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   te
  macro stdmacro
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>GLPIXELSTORE(3G)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">GLPIXELSTORE(3G)</td>
    <td class="head-vol"><a href="."></a></td>
    <td class="head-rtitle">GLPIXELSTORE(3G)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp"><b>glPixelStoref, glPixelStorei</b> - set pixel storage modes</p>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="C_SPECIFICATION"><a class="permalink" href="#C_SPECIFICATION">C
  SPECIFICATION</a></h1>
<p class="Pp">void <b>glPixelStoref</b>( GLenum <i>pname</i>,</p>
<pre>
	GLfloat <i>param</i> )</pre>
<p class="Pp">void <b>glPixelStorei</b>( GLenum <i>pname</i>,</p>
<pre>
	GLint <i>param</i> )</pre>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="PARAMETERS"><a class="permalink" href="#PARAMETERS">PARAMETERS</a></h1>
<dl class="Bl-tag">
  <dt id="pname"><a class="permalink" href="#pname"><i>pname</i></a></dt>
  <dd>Specifies the symbolic name of the parameter to be set. Six values affect
      the packing of pixel data into memory: <b>GL_PACK_SWAP_BYTES</b>,
      <b>GL_PACK_LSB_FIRST</b>, <b>GL_PACK_ROW_LENGTH</b>,
      <b>GL_PACK_IMAGE_HEIGHT</b>, <b>GL_PACK_SKIP_PIXELS</b>,
      <b>GL_PACK_SKIP_ROWS</b>, <b>GL_PACK_SKIP_IMAGES</b>, and
      <b>GL_PACK_ALIGNMENT</b>. Six more affect the unpacking of pixel data
      <i>from</i> memory: <b>GL_UNPACK_SWAP_BYTES</b>,
      <b>GL_UNPACK_LSB_FIRST</b>, <b>GL_UNPACK_ROW_LENGTH</b>,
      <b>GL_UNPACK_IMAGE_HEIGHT</b>, <b>GL_UNPACK_SKIP_PIXELS</b>,
      <b>GL_UNPACK_SKIP_ROWS</b>, <b>GL_UNPACK_SKIP_IMAGES</b>, and
      <b>GL_UNPACK_ALIGNMENT</b>.</dd>
  <dt id="param"><a class="permalink" href="#param"><i>param</i></a></dt>
  <dd>Specifies the value that <i>pname</i> is set to.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><b>glPixelStore</b> sets pixel storage modes that affect the
    operation of subsequent <b>glDrawPixels</b> and <b>glReadPixels</b> as well
    as the unpacking of polygon stipple patterns (see <b>glPolygonStipple</b>),
    bitmaps (see <b>glBitmap</b>), texture patterns (see <b>glTexImage1D</b>,
    <b>glTexImage2D</b>, <b>glTexImage3D</b>, <b>glTexSubImage1D</b>,
    <b>glTexSubImage2D</b>, <b>glTexSubImage3D</b>). Additionally, if the
    <b>GL_ARB_imaging</b> extension is supported, pixel storage modes affect
    convolution filters (see <b>glConvolutionFilter1D</b>,
    <b>glConvolutionFilter2D</b>, and <b>glSeparableFilter2D</b>, color table
    (see <b>glColorTable</b>, and <b>glColorSubTable</b>, and unpacking
    histogram (See <b>glHistogram</b>), and minmax (See <b>glMinmax</b>)
  data.</p>
<p class="Pp"><i>pname</i> is a symbolic constant indicating the parameter to be
    set, and <i>param</i> is the new value. Six of the twelve storage parameters
    affect how pixel data is returned to client memory. They are as follows:</p>
<dl class="Bl-tag">
  <dt id="GL_PACK_SWAP_BYTES"><a class="permalink" href="#GL_PACK_SWAP_BYTES"><b>GL_PACK_SWAP_BYTES</b></a></dt>
  <dd>If true, byte ordering for multibyte color components, depth components,
      color indices, or stencil indices is reversed. That is, if a four-byte
      component consists of bytes b0, b1, b2, b2 it is stored in memory as b3,
      b2, b1, b0 if <b>GL_PACK_SWAP_BYTES</b> is true. <b>GL_PACK_SWAP_BYTES</b>
      has no effect on the memory order of components within a pixel, only on
      the order of bytes within components or indices. For example, the three
      components of a <b>GL_RGB</b> pixel are always stored with red first,
      green second, and blue third, regardless of the value of
      <b>GL_PACK_SWAP_BYTES</b>.</dd>
  <dt id="GL_PACK_LSB_FIRST"><a class="permalink" href="#GL_PACK_LSB_FIRST"><b>GL_PACK_LSB_FIRST</b></a></dt>
  <dd>If true, bits are ordered within a byte from least significant to most
      significant; otherwise, the first bit in each byte is the most significant
      one. This parameter is significant for bitmap data only.</dd>
  <dt id="GL_PACK_ROW_LENGTH"><a class="permalink" href="#GL_PACK_ROW_LENGTH"><b>GL_PACK_ROW_LENGTH</b></a></dt>
  <dd>If greater than 0, <b>GL_PACK_ROW_LENGTH</b> defines the number of pixels
      in a row. If the first pixel of a row is placed at location p in memory,
      then the location of the first pixel of the next row is obtained by
      skipping
    <p class="Pp"></p>
    <p class="Pp">
      <br/>
      k = nl for s&gt;=a, (a/s)(snl/a) for s&lt;a</p>
    <p class="Pp">
      <br/>
      components or indices, where n is the number of components or indices in a
        pixel, l is the number of pixels in a row (<b>GL_PACK_ROW_LENGTH</b> if
        it is greater than 0, the width argument to the pixel routine
        otherwise), a is the value of <b>GL_PACK_ALIGNMENT</b>, and s is the
        size, in bytes, of a single component (if a &lt; s, then it is as if a =
        s). In the case of 1-bit values, the location of the next row is
        obtained by skipping</p>
    <p class="Pp"></p>
    <p class="Pp">
      <br/>
      k = 8a (nl/8a)</p>
    <p class="Pp"></p>
    <p class="Pp">
      <br/>
      components or indices.</p>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The word <i>component</i> in this description refers to the nonindex
      values red, green, blue, alpha, and depth. Storage <b>GL_RGB</b>, for
      example, has three components per pixel: first red, then green, and
      finally blue.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="GL_PACK_IMAGE_HEIGHT"><a class="permalink" href="#GL_PACK_IMAGE_HEIGHT"><b>GL_PACK_IMAGE_HEIGHT</b></a></dt>
  <dd>If greater than 0, <b>GL_PACK_IMAGE_HEIGHT</b> defines the number of
      pixels in an image three-dimensional texture volume. Where ``image'' is
      defined by all pixels sharing the same third dimension index. If the first
      pixel of a row is placed at location p in memory, then the location of the
      first pixel of the next row is obtained by skipping
    <p class="Pp"></p>
    <p class="Pp">
      <br/>
      k = nlh for s&gt;=a, (a/s)(snlh/a) for s&lt;a</p>
    <p class="Pp"></p>
    <p class="Pp">
      <br/>
      components or indices, where n is the number of components or indices in a
        pixel, l is the number of pixels in a row (<b>GL_PACK_ROW_LENGTH</b> if
        it is greater than 0, the width argument to <b>glTexImage3d</b>
        otherwise), h is the number of rows in a pixel image
        (<b>GL_PACK_IMAGE_HEIGHT</b> if it is greater than 0, the height
        arguemnt to the <b>glTexImage3D</b> routine otherwise), a is the value
        of <b>GL_PACK_ALIGNMENT</b>, and s is the size, in bytes, of a single
        component (if a &lt; s, then it is as if a = s).</p>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The word <i>component</i> in this description refers to the nonindex
      values red, green, blue, alpha, and depth. Storage <b>GL_RGB</b>, for
      example, has three components per pixel: first red, then green, and
      finally blue.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="GL_PACK_SKIP_PIXELS"><a class="permalink" href="#GL_PACK_SKIP_PIXELS"><b>GL_PACK_SKIP_PIXELS</b>,
    <b>GL_PACK_SKIP_ROWS</b>, and <b>GL_PACK_SKIP_IMAGES</b></a></dt>
  <dd>These values are provided as a convenience to the programmer; they provide
      no functionality that cannot be duplicated simply by incrementing the
      pointer passed to <b>glReadPixels</b>. Setting <b>GL_PACK_SKIP_PIXELS</b>
      to i is equivalent to incrementing the pointer by i n components or
      indices, where n is the number of components or indices in each pixel.
      Setting <b>GL_PACK_SKIP_ROWS</b> to j is equivalent to incrementing the
      pointer by j m components or indices, where m is the number of components
      or indices per row, as just computed in the <b>GL_PACK_ROW_LENGTH</b>
      section. Setting <b>GL_PACK_SKIP_IMAGES</b> to k is equivalent to
      incrementing the pointer by k p, where p is the number of components or
      indices per image, as computed in the <b>GL_PACK_IMAGE_HEIGHT</b>
    section.</dd>
  <dt id="GL_PACK_ALIGNMENT"><a class="permalink" href="#GL_PACK_ALIGNMENT"><b>GL_PACK_ALIGNMENT</b></a></dt>
  <dd>Specifies the alignment requirements for the start of each pixel row in
      memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to
      even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word
      boundaries).</dd>
</dl>
<p class="Pp">The other six of the twelve storage parameters affect how pixel
    data is read from client memory. These values are significant for
    <b>glDrawPixels</b>, <b>glTexImage1D</b>, <b>glTexImage2D</b>,
    <b>glTexImage3D</b>, <b>glTexSubImage1D</b>, <b>glTexSubImage2D</b>,
    <b>glTexSubImage3D</b>, <b>glBitmap</b>, and <b>glPolygonStipple</b>.</p>
<p class="Pp">Additionally, if the <b>GL_ARB_imaging</b> extension is supported,
    <b>glColorTable</b>, <b>glColorSubTable</b>, <b>glConvolutionFilter1D</b>,
    <b>glConvolutionFilter2D</b>, and <b>glSeparableFilter2D</b>. They are as
    follows:</p>
<dl class="Bl-tag">
  <dt id="GL_UNPACK_SWAP_BYTES"><a class="permalink" href="#GL_UNPACK_SWAP_BYTES"><b>GL_UNPACK_SWAP_BYTES</b></a></dt>
  <dd>If true, byte ordering for multibyte color components, depth components,
      color indices, or stencil indices is reversed. That is, if a four-byte
      component consists of bytes b0, b1, b2, b3, it is taken from memory as b3,
      b2, b1, b0 if <b>GL_UNPACK_SWAP_BYTES</b> is true.
      <b>GL_UNPACK_SWAP_BYTES</b> has no effect on the memory order of
      components within a pixel, only on the order of bytes within components or
      indices. For example, the three components of a <b>GL_RGB</b> pixel are
      always stored with red first, green second, and blue third, regardless of
      the value of <b>GL_UNPACK_SWAP_BYTES</b>.</dd>
  <dt id="GL_UNPACK_LSB_FIRST"><a class="permalink" href="#GL_UNPACK_LSB_FIRST"><b>GL_UNPACK_LSB_FIRST</b></a></dt>
  <dd>If true, bits are ordered within a byte from least significant to most
      significant; otherwise, the first bit in each byte is the most significant
      one. This is relevant only for bitmap data.</dd>
  <dt id="GL_UNPACK_ROW_LENGTH"><a class="permalink" href="#GL_UNPACK_ROW_LENGTH"><b>GL_UNPACK_ROW_LENGTH</b></a></dt>
  <dd>If greater than 0, <b>GL_UNPACK_ROW_LENGTH</b> defines the number of
      pixels in a row. If the first pixel of a row is placed at location p in
      memory, then the location of the first pixel of the next row is obtained
      by skipping
    <p class="Pp"></p>
    <p class="Pp">
      <br/>
      k = nl for s&gt;=a, (a/s)(snl/a) for s&lt;a</p>
    <p class="Pp"></p>
    <p class="Pp">
      <br/>
      components or indices, where n is the number of components or indices in a
        pixel, l is the number of pixels in a row (<b>GL_UNPACK_ROW_LENGTH</b>
        if it is greater than 0, the width argument to the pixel routine
        otherwise), a is the value of <b>GL_UNPACK_ALIGNMENT</b>, and s is the
        size, in bytes, of a single component (if a &lt; s, then it is as if a =
        s). In the case of 1-bit values, the location of the next row is
        obtained by skipping</p>
    <p class="Pp"></p>
    <p class="Pp">
      <br/>
      k = 8a (nl/8a)</p>
    <p class="Pp"></p>
    <p class="Pp">
      <br/>
      components or indices.</p>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The word <i>component</i> in this description refers to the nonindex
      values red, green, blue, alpha, and depth. Storage <b>GL_RGB</b>, for
      example, has three components per pixel: first red, then green, and
      finally blue.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="GL_UNPACK_IMAGE_HEIGHT"><a class="permalink" href="#GL_UNPACK_IMAGE_HEIGHT"><b>GL_UNPACK_IMAGE_HEIGHT</b></a></dt>
  <dd>If greater than 0, <b>GL_UNPACK_IMAGE_HEIGHT</b> defines the number of
      pixels in an image of a three-dimensional texture volume. Where ``image''
      is defined by all pixel sharing the same third dimension index. If the
      first pixel of a row is placed at location p in memory, then the location
      of the first pixel of the next row is obtained by skipping
    <p class="Pp"></p>
    <p class="Pp">
      <br/>
      k = nlh for s&gt;=a, (a/s)(snlh/a) for s&lt;a</p>
    <p class="Pp"></p>
    <p class="Pp">
      <br/>
      components or indices, where n is the number of components or indices in a
        pixel, l is the number of pixels in a row (<b>GL_UNPACK_ROW_LENGTH</b>
        if it is greater than 0, the width argument to <b>glTexImage3D</b>
        otherwise), h is the number of rows in an image
        (<b>GL_UNPACK_IMAGE_HEIGHT</b> if it is greater than 0, the height
        argument to <b>glTexImage3D</b> otherwise), a is the value of
        <b>GL_UNPACK_ALIGNMENT</b>, and s is the size, in bytes, of a single
        component (if a &lt; s, then it is as if a = s).</p>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The word <i>component</i> in this description refers to the nonindex
      values red, green, blue, alpha, and depth. Storage <b>GL_RGB</b>, for
      example, has three components per pixel: first red, then green, and
      finally blue.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="GL_UNPACK_SKIP_PIXELS"><a class="permalink" href="#GL_UNPACK_SKIP_PIXELS"><b>GL_UNPACK_SKIP_PIXELS</b>
    and <b>GL_UNPACK_SKIP_ROWS</b></a></dt>
  <dd>These values are provided as a convenience to the programmer; they provide
      no functionality that cannot be duplicated by incrementing the pointer
      passed to <b>glDrawPixels</b>, <b>glTexImage1D</b>, <b>glTexImage2D</b>,
      <b>glTexSubImage1D</b>, <b>glTexSubImage2D</b>, <b>glBitmap</b>, or
      <b>glPolygonStipple</b>. Setting <b>GL_UNPACK_SKIP_PIXELS</b> to i is
      equivalent to incrementing the pointer by i n components or indices, where
      n is the number of components or indices in each pixel. Setting
      <b>GL_UNPACK_SKIP_ROWS</b> to j is equivalent to incrementing the pointer
      by j k components or indices, where k is the number of components or
      indices per row, as just computed in the <b>GL_UNPACK_ROW_LENGTH</b>
      section.</dd>
  <dt id="GL_UNPACK_ALIGNMENT"><a class="permalink" href="#GL_UNPACK_ALIGNMENT"><b>GL_UNPACK_ALIGNMENT</b></a></dt>
  <dd>Specifies the alignment requirements for the start of each pixel row in
      memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to
      even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word
      boundaries).</dd>
</dl>
<p class="Pp">The following table gives the type, initial value, and range of
    valid values for each storage parameter that can be set with
    <b>glPixelStore</b>.</p>
<p class="Pp"></p>
<p class="Pp">
  <br/>
   pname Type Initial Valid
  <br/>
   Value Range
  <br/>
   GL_PACK_SWAP_BYTES boolean false true or false
  <br/>
   GL_PACK_LSB_FIRST boolean false true or false
  <br/>
   GL_PACK_ROW_LENGTH integer 0 [0,inf]
  <br/>
   GL_PACK_IMAGE_HEIGHT integer 0 [0,inf]
  <br/>
   GL_PACK_SKIP_ROWS integer 0 [0,inf]
  <br/>
   GL_PACK_SKIP_PIXELS integer 0 [0,inf]
  <br/>
   GL_PACK_SKIP_IMAGES integer 0 [0,inf]
  <br/>
   GL_PACK_ALIGNMENT<b> integer 4 1, 2, 4, or 8</b></p>
<p class="Pp">
  <br/>
   GL_UNPACK_SWAP_BYTES boolean false true or false
  <br/>
   GL_UNPACK_LSB_FIRST boolean false true or false
  <br/>
   GL_UNPACK_ROW_LENGTH integer 0 [0,inf]
  <br/>
   GL_UNPACK_IMAGE_HEIGHT integer 0 [0,inf]
  <br/>
   GL_UNPACK_SKIP_ROWS integer 0 [0,inf]
  <br/>
   GL_UNPACK_SKIP_PIXELS integer 0 [0,inf]
  <br/>
   GL_UNPACK_SKIP_IMAGES integer 0 [0,inf]
  <br/>
   GL_UNPACK_ALIGNMENT integer 4 1, 2, 4, or 8</p>
<p class="Pp"></p>
<p class="Pp"><b>glPixelStoref</b> can be used to set any pixel store parameter.
    If the parameter type is boolean, then if <i>param</i> is 0, the parameter
    is false; otherwise it is set to true. If <i>pname</i> is a integer type
    parameter, <i>param</i> is rounded to the nearest integer.</p>
<p class="Pp">Likewise, <b>glPixelStorei</b> can also be used to set any of the
    pixel store parameters. Boolean parameters are set to false if <i>param</i>
    is 0 and true otherwise.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<p class="Pp">The pixel storage modes in effect when <b>glDrawPixels</b>,
    <b>glReadPixels</b>, <b>glTexImage1D</b>, <b>glTexImage2D</b>,
    <b>glTexImage3D</b>, <b>glTexSubImage1D</b>, <b>glTexSubImage2D</b>,
    <b>glTexSubImage3D</b>, <b>glBitmap</b>, or <b>glPolygonStipple</b> is
    placed in a display list control the interpretation of memory data.
    Likewise, if the <b>GL_ARB_imaging</b> extension is supported, the pixel
    storage modes in effect when <b>glColorTable</b>, <b>glColorSubTable</b>,
    <b>glConvolutionFilter1D</b>, <b>glConvolutionFilter2D</b>, of
    <b>glSeparableFilter2D</b> is placed in a display list control the
    intrepretation of memory data. The pixel storage modes in effect when a
    display list is executed are not significant.</p>
<p class="Pp">Pixel storage modes are client state and must be pushed and
    restored using
  <br/>
  <b>glPushClientAttrib</b> and <b>glPopClientAttrib</b>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ERRORS"><a class="permalink" href="#ERRORS">ERRORS</a></h1>
<p class="Pp"><b>GL_INVALID_ENUM</b> is generated if <i>pname</i> is not an
    accepted value.</p>
<p class="Pp"><b>GL_INVALID_VALUE</b> is generated if a negative row length,
    pixel skip, or row skip value is specified, or if alignment is specified as
    other than 1, 2, 4, or 8.</p>
<p class="Pp"><b>GL_INVALID_OPERATION</b> is generated if <b>glPixelStore</b> is
    executed between the execution of <b>glBegin</b> and the corresponding
    execution of <b>glEnd</b>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ASSOCIATED_GETS"><a class="permalink" href="#ASSOCIATED_GETS">ASSOCIATED
  GETS</a></h1>
<p class="Pp"><b>glGet</b> with argument <b>GL_PACK_SWAP_BYTES</b>
  <br/>
  <b>glGet</b> with argument <b>GL_PACK_LSB_FIRST</b>
  <br/>
  <b>glGet</b> with argument <b>GL_PACK_ROW_LENGTH</b>
  <br/>
  <b>glGet</b> with argument <b>GL_PACK_IMAGE_HEIGHT</b>
  <br/>
  <b>glGet</b> with argument <b>GL_PACK_SKIP_ROWS</b>
  <br/>
  <b>glGet</b> with argument <b>GL_PACK_SKIP_PIXELS</b>
  <br/>
  <b>glGet</b> with argument <b>GL_PACK_SKIP_IMAGES</b>
  <br/>
  <b>glGet</b> with argument <b>GL_PACK_ALIGNMENT</b>
  <br/>
  <b>glGet</b> with argument <b>GL_UNPACK_SWAP_BYTES</b>
  <br/>
  <b>glGet</b> with argument <b>GL_UNPACK_LSB_FIRST</b>
  <br/>
  <b>glGet</b> with argument <b>GL_UNPACK_ROW_LENGTH</b>
  <br/>
  <b>glGet</b> with argument <b>GL_UNPACK_IMAGE_HEIGHT</b>
  <br/>
  <b>glGet</b> with argument <b>GL_UNPACK_SKIP_ROWS</b>
  <br/>
  <b>glGet</b> with argument <b>GL_UNPACK_SKIP_PIXELS</b>
  <br/>
  <b>glGet</b> with argument <b>GL_UNPACK_SKIP_IMAGES</b>
  <br/>
  <b>glGet</b> with argument <b>GL_UNPACK_ALIGNMENT</b></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>glBitmap</b>, <b>glColorTable</b>, <b>glColorSubTable</b>,
    <b>glConvolutionFilter1D</b>, <b>glConvolutionFilter2D</b>,
    <b>glSeparableFilter2D</b>, <b>glDrawPixels</b>, <b>glHistogram</b>,
    <b>glMinmax</b>, <b>glPixelMap</b>, <b>glPixelTransfer</b>,
    <b>glPixelZoom</b>, <b>glPolygonStipple</b>, <b>glPushClientAttrib</b>,
    <b>glReadPixels</b>, <b>glTexImage1D</b>, <b>glTexImage2D</b>,
    <b>glTexImage3D</b>, <b>glTexSubImage1D</b>, <b>glTexSubImage2D</b>,
    <b>glTexSubImage3D</b></p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date"></td>
    <td class="foot-os"><a href=".."></a></td>
  </tr>
</table>
</body>
</html>

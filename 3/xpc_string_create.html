<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Copyright (c) 2011, 2016 Apple Inc. All rights reserved.
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>xpc_objects(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">xpc_objects(3)</td>
    <td class="head-vol">Library Functions Manual</td>
    <td class="head-rtitle">xpc_objects(3)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp"><code class="Nm">xpc_objects</code> &#x2014;
    <span class="Nd">boxed XPC objects reference</span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp"><code class="In">#include
    <a class="In">&lt;xpc/xpc.h&gt;</a></code></p>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_null_create</code>(<var class="Fa">void</var>);</p>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_bool_create</code>(<var class="Fa">bool value</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">xpc_bool_get_value</code>(<var class="Fa">xpc_object_t
    xbool</var>);</p>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_int64_create</code>(<var class="Fa">int64_t
  value</var>);</p>
<p class="Pp"><var class="Ft">int64_t</var>
  <br/>
  <code class="Fn">xpc_int64_get_value</code>(<var class="Fa">xpc_object_t
    xint</var>);</p>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_uint64_create</code>(<var class="Fa">uint64_t
    value</var>);</p>
<p class="Pp"><var class="Ft">uint64_t</var>
  <br/>
  <code class="Fn">xpc_uint64_get_value</code>(<var class="Fa">xpc_object_t
    xuint</var>);</p>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_double_create</code>(<var class="Fa">double
  value</var>);</p>
<p class="Pp"><var class="Ft">double</var>
  <br/>
  <code class="Fn">xpc_double_get_value</code>(<var class="Fa">xpc_object_t
    xdouble</var>);</p>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_date_create</code>(<var class="Fa">int64_t
    interval</var>);</p>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_date_create_from_current</code>(<var class="Fa">void</var>);</p>
<p class="Pp"><var class="Ft">int64_t</var>
  <br/>
  <code class="Fn">xpc_date_get_value</code>(<var class="Fa">xpc_object_t
    xdate</var>);</p>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_data_create</code>(<var class="Fa">const void
    *bytes</var>, <var class="Fa">size_t length</var>);</p>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_data_create_with_dispatch_data</code>(<var class="Fa">dispatch_data_t
    ddata</var>);</p>
<p class="Pp"><var class="Ft">size_t</var>
  <br/>
  <code class="Fn">xpc_data_get_length</code>(<var class="Fa">xpc_object_t
    xdata</var>);</p>
<p class="Pp"><var class="Ft">const void *</var>
  <br/>
  <code class="Fn">xpc_data_get_bytes_ptr</code>(<var class="Fa">xpc_object_t
    xdata</var>);</p>
<p class="Pp"><var class="Ft">size_t</var>
  <br/>
  <code class="Fn">xpc_data_get_bytes</code>(<var class="Fa">xpc_object_t
    xdata</var>, <var class="Fa">void *buffer</var>, <var class="Fa">size_t
    off</var>, <var class="Fa">size_t length</var>);</p>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_string_create</code>(<var class="Fa">const char
    *string</var>);</p>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_string_create_with_format</code>(<var class="Fa">const
    char *fmt</var>, <var class="Fa">...</var>);</p>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_string_create_with_format_and_arguments</code>(<var class="Fa">const
    char *fmt</var>, <var class="Fa">va_list ap</var>);</p>
<p class="Pp"><var class="Ft">size_t</var>
  <br/>
  <code class="Fn">xpc_string_get_length</code>(<var class="Fa">xpc_object_t
    xstring</var>);</p>
<p class="Pp"><var class="Ft">const char *</var>
  <br/>
  <code class="Fn">xpc_string_get_string_ptr</code>(<var class="Fa">xpc_object_t
    xstring</var>);</p>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_uuid_create</code>(<var class="Fa">const uuid_t
    uuid</var>);</p>
<p class="Pp"><var class="Ft">const uint8_t *</var>
  <br/>
  <code class="Fn">xpc_uuid_get_bytes</code>(<var class="Fa">xpc_object_t
    xuuid</var>);</p>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_fd_create</code>(<var class="Fa">int fd</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">xpc_fd_dup</code>(<var class="Fa">xpc_object_t
  xfd</var>);</p>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_shmem_create</code>(<var class="Fa">void *region</var>,
    <var class="Fa">size_t length</var>);</p>
<p class="Pp"><var class="Ft">size_t</var>
  <br/>
  <code class="Fn">xpc_shmem_map</code>(<var class="Fa">xpc_object_t
    xshmem</var>, <var class="Fa">void **region</var>);</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Most XPC objects are boxed representations of primitive C language
    types or low-level operating system handles. These boxed objects are
    immutable. In general, the getter methods for each object type will check to
    see if the given object is of the proper type and, if it is not, will return
    a sensible default value as described in
    <a class="Xr" href="../3/xpc_object">xpc_object(3)</a>. If an improper
    object is given to another type of method, the behavior is undefined.</p>
<p class="Pp">See <a class="Xr" href="../3/xpc_object">xpc_object(3)</a> for
    information about functions common to all XPC objects.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PRIMITIVE_TYPES"><a class="permalink" href="#PRIMITIVE_TYPES">PRIMITIVE
  TYPES</a></h1>
<p class="Pp">XPC objects can encapsulate a wide variety of primitive C language
    types:</p>
<section class="Ss">
<h2 class="Ss" id="INTEGERS"><a class="permalink" href="#INTEGERS">INTEGERS</a></h2>
<p class="Pp">Boxed representations of 64-bit wide signed and unsigned integer
    types may be created with
    <a class="permalink" href="#xpc_int64_create"><code class="Fn" id="xpc_int64_create">xpc_int64_create</code></a>()
    and
    <a class="permalink" href="#xpc_uint64_create"><code class="Fn" id="xpc_uint64_create">xpc_uint64_create</code></a>()
    respectively. The boxed values may be retrieved using
    <a class="permalink" href="#xpc_int64_get_value"><code class="Fn" id="xpc_int64_get_value">xpc_int64_get_value</code></a>()
    and
    <a class="permalink" href="#xpc_uint64_get_value"><code class="Fn" id="xpc_uint64_get_value">xpc_uint64_get_value</code></a>().</p>
</section>
<section class="Ss">
<h2 class="Ss" id="FLOATING_POINT"><a class="permalink" href="#FLOATING_POINT">FLOATING
  POINT</a></h2>
<p class="Pp">Boxed representations of double-precision floating point value
    representations may be created with the
    <a class="permalink" href="#xpc_double_create"><code class="Fn" id="xpc_double_create">xpc_double_create</code></a>()
    function and retrieved with the
    <a class="permalink" href="#xpc_double_get_value"><code class="Fn" id="xpc_double_get_value">xpc_double_get_value</code></a>()
    function.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="DATES"><a class="permalink" href="#DATES">DATES</a></h2>
<p class="Pp">Boxed representations of date and time values, expressed as an
    integral number of nanoseconds before or after the Unix epoch, can be
    created with the
    <a class="permalink" href="#xpc_date_create"><code class="Fn" id="xpc_date_create">xpc_date_create</code></a>()
    function and retrieved with the
    <a class="permalink" href="#xpc_date_get_value"><code class="Fn" id="xpc_date_get_value">xpc_date_get_value</code></a>()
    function. A date object representing the current date may be created with
    <a class="permalink" href="#xpc_date_create_from_current"><code class="Fn" id="xpc_date_create_from_current">xpc_date_create_from_current</code></a>()
    convenience function.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="NULL_AND_BOOLEAN_SINGLETONS"><a class="permalink" href="#NULL_AND_BOOLEAN_SINGLETONS">NULL
  AND BOOLEAN SINGLETONS</a></h2>
<p class="Pp">Boxed representations of null and Boolean values are expressed as
    XPC object singletons. The
    <a class="permalink" href="#xpc_bool_create"><code class="Fn" id="xpc_bool_create">xpc_bool_create</code></a>()
    function returns one of two constant singleton Boolean values:</p>
<ul class="Bl-bullet Bd-indent Bl-compact">
  <li><var class="Ft">XPC_BOOL_TRUE</var></li>
  <li><var class="Ft">XPC_BOOL_FALSE</var></li>
</ul>
<p class="Pp">The singleton values may be compared using direct pointer
    equality. Similarly, no type checking is required when retrieving these
    values from collections:</p>
<div class="Bd Pp Bd-indent">
<pre>
xpc_object_t xbool = xpc_dictionary_get_value(dictionary, &quot;key&quot;);
if (xbool == XPC_BOOL_TRUE) {
	// Handle the true case.
} else if (xbool == XPC_BOOL_FALSE)
	// Handle the false case.
} else {
	// Handle the case where there was a type mismatch or where there was no
	// value for the key &quot;key&quot;.
}
</pre>
</div>
<p class="Pp" id="xpc_null_create">The
    <a class="permalink" href="#xpc_null_create"><code class="Fn">xpc_null_create</code></a>()
    function returns a constant singleton representation of a null value. There
    is currently no defined constant for this singleton.</p>
<p class="Pp">It is safe to call
    <a class="Xr" href="../3/xpc_retain">xpc_retain(3)</a> and
    <a class="Xr" href="../3/xpc_release">xpc_release(3)</a> on Boolean and null
    objects.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DATA,_STRINGS_AND_UUIDS"><a class="permalink" href="#DATA,_STRINGS_AND_UUIDS">DATA,
  STRINGS AND UUIDS</a></h1>
<section class="Ss">
<h2 class="Ss" id="DATA"><a class="permalink" href="#DATA">DATA</a></h2>
<p class="Pp">Boxed representations of arbitrary byte values may be created with
    the
    <a class="permalink" href="#xpc_data_create"><code class="Fn" id="xpc_data_create">xpc_data_create</code></a>()
    function which takes a pointer to a <var class="Fa">buffer</var> and
    <var class="Fa">length</var>. A pointer to the underlying storage of the
    data object may be obtained using
    <a class="permalink" href="#xpc_data_get_bytes_ptr"><code class="Fn" id="xpc_data_get_bytes_ptr">xpc_data_get_bytes_ptr</code></a>().</p>
<p class="Pp"><i class="Em">Important</i>: This pointer is only valid for the
    lifetime of the data object. The underlying storage of the pointer value
    must not be modified by the caller. When ARC is enabled, care needs to be
    taken that the data object is not released prematurely, see
    <a class="Xr" href="../3/xpc_object">xpc_object(3)</a> for details.</p>
<p class="Pp" id="xpc_data_get_bytes">The contents of a data object may be
    copied to an external buffer using the
    <a class="permalink" href="#xpc_data_get_bytes"><code class="Fn">xpc_data_get_bytes</code></a>()
    function. This function takes a pointer to a <var class="Fa">buffer</var> of
    size <var class="Fa">length</var> to which the data will be copied. The
    caller may also specify a non-zero <var class="Fa">offset</var> into the
    source data at which to start the copy. The return value of this function is
    the number of bytes that were copied into the <var class="Fa">buffer</var>.
    If the destination <var class="Fa">buffer</var> is smaller than the size of
    the source data, as many bytes as possible will be copied and the return
    value will be equal to the number of bytes specified in
    <var class="Fa">length</var>.</p>
<p class="Pp" id="xpc_data_get_length">The underlying size of the data value may
    be determined using the
    <a class="permalink" href="#xpc_data_get_length"><code class="Fn">xpc_data_get_length</code></a>()
    function.</p>
<p class="Pp" id="xpc_data_create_with_dispatch_data">When creating a data
    object, the contents of the provided buffer are copied into internal
    storage. If the caller wishes to avoid a copy, the buffer may first be
    encapsulated in a <var class="Ft">dispatch_data_t</var> object and passed to
    <a class="permalink" href="#xpc_data_create_with_dispatch_data"><code class="Fn">xpc_data_create_with_dispatch_data</code></a>().
    See
    <a class="Xr" href="../3/dispatch_data_create">dispatch_data_create(3)</a>
    for more information.</p>
<p class="Pp" id="Note"><a class="permalink" href="#Note"><i class="Em">Note</i></a>:
    When the time comes to send a message, the XPC runtime will serialize the
    object graph, which will result in a copy of any data objects contained
    therein. This can be very costly for large amounts of data. To completely
    avoid any copying in the message-send path for large data objects (where
    &quot;large&quot; is defined by the system), you may create a data object
    using
    <a class="Xr" href="../3/dispatch_data_create">dispatch_data_create(3)</a>
    with the <var class="Ft">DISPATCH_DATA_DESTRUCTOR_MUNMAP</var> destructor
    specified. This will hint to the system that the data buffer may be safely
    shared copy-on-write with the recipient of the message.</p>
<p class="Pp" id="only"><i class="Em">Important</i>: Data objects created with
    the intention of eliminating copies can
    <a class="permalink" href="#only"><i class="Em">only</i></a> be safely
    created VM objects that the caller owns. Buffers returned by
    <a class="Xr" href="../3/malloc">malloc(3)</a> do NOT satisfy this condition
    as the caller does not own the underlying VM object associated with an
    allocation returned by <a class="Xr" href="../3/malloc">malloc(3)</a>.
    Similarly, if the caller receives a buffer from an external subsystem across
    an API boundary, this buffer is not owned by the caller unless part of the
    API contract specifies how the buffer should have been created. Sending
    buffers not owned by the caller in this way can result in information
    leakage from elsewhere on the heap.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="STRINGS"><a class="permalink" href="#STRINGS">STRINGS</a></h2>
<p class="Pp">Boxed representations of C string values may be created using the
    <a class="permalink" href="#xpc_string_create"><code class="Fn" id="xpc_string_create">xpc_string_create</code></a>()
    function. The XPC framework assumes all strings are encoded as UTF-8 and
    does not support any other encodings. A pointer to the C string
    representation of a value may be obtained using
    <a class="permalink" href="#xpc_string_get_string_ptr"><code class="Fn" id="xpc_string_get_string_ptr">xpc_string_get_string_ptr</code></a>().</p>
<p class="Pp"><i class="Em">Important</i>: This pointer is only valid for the
    lifetime of the string object. The underlying storage of the pointer value
    must not be modified by the caller. When ARC is enabled, care needs to be
    taken that the string object is not released prematurely, see
    <a class="Xr" href="../3/xpc_object">xpc_object(3)</a> for details.</p>
<p class="Pp" id="xpc_string_get_length">The length of the C string value may be
    determined using the
    <a class="permalink" href="#xpc_string_get_length"><code class="Fn">xpc_string_get_length</code></a>()
    function. This length does not include the NUL terminator character, similar
    to <a class="Xr" href="../3/strlen">strlen(3)</a>.</p>
<p class="Pp" id="xpc_string_create_with_format">String objects may also be
    constructed from <a class="Xr" href="../3/printf">printf(3)</a> -style
    format strings using the
    <a class="permalink" href="#xpc_string_create_with_format"><code class="Fn">xpc_string_create_with_format</code></a>()
    function. Additionally, the
    <a class="permalink" href="#xpc_string_create_with_format_and_arguments"><code class="Fn" id="xpc_string_create_with_format_and_arguments">xpc_string_create_with_format_and_arguments</code></a>()
    function allows the caller to pass an existing <var class="Ft">va_list</var>
    argument with which to construct the formatted string.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="UUIDs"><a class="permalink" href="#UUIDs">UUIDs</a></h2>
<p class="Pp">Boxed representations of UUID byte values may be created using
    <a class="permalink" href="#xpc_uuid_create"><code class="Fn" id="xpc_uuid_create">xpc_uuid_create</code></a>().
    See <a class="Xr" href="../3/uuid">uuid(3)</a> for more information. A
    pointer to storage for the underlying UUID value may be obtained using
    <a class="permalink" href="#xpc_uuid_get_bytes"><code class="Fn" id="xpc_uuid_get_bytes">xpc_uuid_get_bytes</code></a>().
    The returned pointer may be safely passed to the relevant
    <a class="Xr" href="../3/uuid">uuid(3)</a> functions.</p>
<p class="Pp"><i class="Em">Important</i>: This pointer is only valid for the
    lifetime of the UUID object. The underlying storage of the UUID value must
    not be modified by the caller. When ARC is enabled, care needs to be taken
    that the UUID object is not released prematurely, see
    <a class="Xr" href="../3/xpc_object">xpc_object(3)</a> for details.</p>
<p class="Pp">The pattern of returning a pointer instead of copying the result
    into a <var class="Ft">uuid_t</var> enables some convenient code
    simplification. For example:</p>
<div class="Bd Pp Bd-indent">
<pre>
if (uuid_compare(xpc_uuid_get_bytes(uuid_object), expected_uuid) == 0) {
	// They are the same.
}
</pre>
</div>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="OUT-OF-LINE_TYPES"><a class="permalink" href="#OUT-OF-LINE_TYPES">OUT-OF-LINE
  TYPES</a></h1>
<p class="Pp">Boxed representations of low-level operating system primitives
    such as file descriptors and shared memory regions may be created and shared
    between processes as part of an XPC dictionary that is sent as a
  message.</p>
<section class="Ss">
<h2 class="Ss" id="FILE_DESCRIPTORS"><a class="permalink" href="#FILE_DESCRIPTORS">FILE
  DESCRIPTORS</a></h2>
<p class="Pp">Boxed representations of file descriptors may be created using the
    <a class="permalink" href="#xpc_fd_create"><code class="Fn" id="xpc_fd_create">xpc_fd_create</code></a>()
    function. Once created, there is no way to retrieve the original file
    descriptor from the boxed representation. This function performs the
    equivalent of a <a class="Xr" href="../2/dup">dup(2)</a> on the descriptor,
    and thus it is safe to call <a class="Xr" href="../2/close">close(2)</a> on
    the descriptor after boxing it.</p>
<p class="Pp" id="xpc_fd_dup">The
    <a class="permalink" href="#xpc_fd_dup"><code class="Fn">xpc_fd_dup</code></a>()
    function can be used to create a new file descriptor from a boxed
    representation in a similar manner to
    <a class="Xr" href="../2/dup">dup(2)</a>. The caller is responsible for
    calling <a class="Xr" href="../2/close">close(2)</a> on the descriptor
    returned by <code class="Fn">xpc_fd_dup</code>().</p>
<p class="Pp">Multiple calls to <code class="Fn">xpc_fd_dup</code>() will
    produce multiple unique file descriptor values. If a failure occurs (i.e.
    process file descriptor table is full), the invalid file descriptor value -1
    will be returned.</p>
<p class="Pp"><i class="Em">Important</i>: When file descriptors are copied with
    <a class="Xr" href="../2/dup">dup(2)</a>, they share some state, including
    flags and <a class="Xr" href="../2/lseek">lseek(2)</a> file offset. The same
    sharing obtains when these boxing and unboxing functions create copies of
    file descriptors, and when a boxed representation of a file descriptor is
    sent to another process using XPC.</p>
<p class="Pp">For example, suppose one process opens a file and sends the file
    descriptor to another process. Then, the first process uses
    <a class="Xr" href="../2/read">read(2)</a> to read the first 100 bytes from
    the file. If the second process then calls
    <a class="Xr" href="../2/read">read(2)</a> on the descriptor that it
    received from the first process, the data it reads will start at the 101st
    byte of the file, not the 1st.</p>
<p class="Pp">This is not usually the desired behavior.</p>
<p class="Pp">Therefore, if you wish to send a file to another process, it is
    best not to box one shared file descriptor. Instead you should
    <a class="Xr" href="../2/open">open(2)</a> the file afresh for each other
    process you wish to share with.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="SHARED_MEMORY"><a class="permalink" href="#SHARED_MEMORY">SHARED
  MEMORY</a></h2>
<p class="Pp">Boxed representations of shared memory regions allocated using
    <a class="Xr" href="../2/mmap">mmap(2)</a> with the
    <var class="Ft">MAP_SHARED</var> flag passed in the
    <var class="Fa">flags</var> argument may be created using the
    <a class="permalink" href="#xpc_shmem_create"><code class="Fn" id="xpc_shmem_create">xpc_shmem_create</code></a>()
    function. Memory objects created using
    <a class="Xr" href="../3/malloc">malloc(3)</a> are not supported. The
    <var class="Fa">region</var> argument is a pointer to the beginning of the
    shared region and the <var class="Fa">length</var> argument specifies the
    length of the shared region.</p>
<p class="Pp" id="xpc_shmem_map">The recipient of a shared memory object may map
    the underlying region into its address space using the
    <a class="permalink" href="#xpc_shmem_map"><code class="Fn">xpc_shmem_map</code></a>()
    function. As with file descriptor objects, each call to this function
    returns a distinct but equivalent mapping. On output, the
    <var class="Fa">region</var> argument will point to the address of the new
    mapping, and the return value will be the size of that mapping. This size
    will always be an integral page size, as it is not possible to share memory
    regions at less than page granularity. The caller is responsible for
    unmapping the region with <a class="Xr" href="../2/munmap">munmap(2)</a>. If
    the mapping operation failed, 0 will be returned.</p>
<p class="Pp" id="mach_make_memory_entry_64">New mappings will be created with
    the maximum permission as specified by the creator of the region. Currently,
    there is no direct way to modify the permissions that the recipient of a
    region will have. If the caller wishes to maintain read-write permissions to
    a region, for example, while giving others read-only access, it can create
    an equivalent mapping with the desired permissions using a combination of
    <a class="permalink" href="#mach_make_memory_entry_64"><code class="Fn">mach_make_memory_entry_64</code></a>()
    and
    <a class="permalink" href="#mach_vm_remap"><code class="Fn" id="mach_vm_remap">mach_vm_remap</code></a>().
    The details of this procedure are left as an exercise to the reader.</p>
<p class="Pp" id="vm_copy">Certain operations that can operate on subranges of a
    region, such as
    <a class="permalink" href="#vm_copy"><code class="Fn">vm_copy</code></a>(),
    <a class="permalink" href="#vm_read"><code class="Fn" id="vm_read">vm_read</code></a>(),
    and
    <a class="permalink" href="#vm_write"><code class="Fn" id="vm_write">vm_write</code></a>(),
    may fragment the underlying representation of a memory region in order to
    avoid physical copies. After this fragmentation has occurred, it is not safe
    to create a shared memory object out of the region. For this reason, it is
    recommended that any such operations be delayed until after the shared
    memory object has been created, as the existence of the object will hint to
    the VM that the region's internal representation should be kept contiguous.
    Note that this will necessarily defeat these optimizations and force
    physical copies of subranges.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><a class="Xr" href="../3/xpc_object">xpc_object(3)</a>,
    <a class="Xr" href="../3/xpc_dictionary_create">xpc_dictionary_create(3)</a>,
    <a class="Xr" href="../3/xpc_array_create">xpc_array_create(3)</a>,
    <a class="Xr" href="../3/xpc_connection_create">xpc_connection_create(3)</a>,
    <a class="Xr" href="../3/dispatch_data_create">dispatch_data_create(3)</a>,
    <a class="Xr" href="../3/printf">printf(3)</a>,
    <a class="Xr" href="../3/uuid">uuid(3)</a>,
    <a class="Xr" href="../2/dup">dup(2)</a>,
    <a class="Xr" href="../2/close">close(2)</a></p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">1 July, 2011</td>
    <td class="foot-os">Darwin</td>
  </tr>
</table>
</body>
</html>

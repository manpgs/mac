<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>ATOMIC_DEPRECATED(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">ATOMIC_DEPRECATED(3)</td>
    <td class="head-vol">Library Functions Manual</td>
    <td class="head-rtitle">ATOMIC_DEPRECATED(3)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp"><code class="Nm">OSAtomicAdd32</code>,
    <code class="Nm">OSAtomicAdd32Barrier</code>,
    <code class="Nm">OSAtomicIncrement32</code>,
    <code class="Nm">OSAtomicIncrement32Barrier</code>,
    <code class="Nm">OSAtomicDecrement32</code>,
    <code class="Nm">OSAtomicDecrement32Barrier</code>,
    <code class="Nm">OSAtomicOr32</code>,
    <code class="Nm">OSAtomicOr32Barrier</code>,
    <code class="Nm">OSAtomicOr32Orig</code>,
    <code class="Nm">OSAtomicOr32OrigBarrier</code>,
    <code class="Nm">OSAtomicAnd32</code>,
    <code class="Nm">OSAtomicAnd32Barrier</code>,
    <code class="Nm">OSAtomicAnd32Orig</code>,
    <code class="Nm">OSAtomicAnd32OrigBarrier</code>,
    <code class="Nm">OSAtomicXor32</code>,
    <code class="Nm">OSAtomicXor32Barrier</code>,
    <code class="Nm">OSAtomicXor32Orig</code>,
    <code class="Nm">OSAtomicXor32OrigBarrier</code>,
    <code class="Nm">OSAtomicAdd64</code>,
    <code class="Nm">OSAtomicAdd64Barrier</code>,
    <code class="Nm">OSAtomicIncrement64</code>,
    <code class="Nm">OSAtomicIncrement64Barrier</code>,
    <code class="Nm">OSAtomicDecrement64</code>,
    <code class="Nm">OSAtomicDecrement64Barrier</code>,
    <code class="Nm">OSAtomicCompareAndSwapInt</code>,
    <code class="Nm">OSAtomicCompareAndSwapIntBarrier</code>,
    <code class="Nm">OSAtomicCompareAndSwapLong</code>,
    <code class="Nm">OSAtomicCompareAndSwapLongBarrier</code>,
    <code class="Nm">OSAtomicCompareAndSwapPtr</code>,
    <code class="Nm">OSAtomicCompareAndSwapPtrBarrier</code>,
    <code class="Nm">OSAtomicCompareAndSwap32</code>,
    <code class="Nm">OSAtomicCompareAndSwap32Barrier</code>,
    <code class="Nm">OSAtomicCompareAndSwap64</code>,
    <code class="Nm">OSAtomicCompareAndSwap64Barrier</code>,
    <code class="Nm">OSAtomicTestAndSet</code>,
    <code class="Nm">OSAtomicTestAndSetBarrier</code>,
    <code class="Nm">OSAtomicTestAndClear</code>,
    <code class="Nm">OSAtomicTestAndClearBarrier</code>,
    <code class="Nm">OSMemoryBarrier</code> &#x2014; <span class="Nd">deprecated
    atomic add, increment, decrement, or, and, xor, compare and swap, test and
    set, test and clear, and memory barrier</span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp"><code class="In">#include
    &lt;<a class="In">libkern/OSAtomic.h</a>&gt;</code></p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicAdd32</code>(<var class="Fa" style="white-space: nowrap;">int32_t
    theAmount</var>, <var class="Fa" style="white-space: nowrap;">volatile
    int32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicAdd32Barrier</code>(<var class="Fa" style="white-space: nowrap;">int32_t
    theAmount</var>, <var class="Fa" style="white-space: nowrap;">volatile
    int32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicIncrement32</code>(<var class="Fa" style="white-space: nowrap;">volatile
    int32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicIncrement32Barrier</code>(<var class="Fa" style="white-space: nowrap;">volatile
    int32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicDecrement32</code>(<var class="Fa" style="white-space: nowrap;">volatile
    int32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicDecrement32Barrier</code>(<var class="Fa" style="white-space: nowrap;">volatile
    int32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicOr32</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    theMask</var>, <var class="Fa" style="white-space: nowrap;">volatile
    uint32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicOr32Barrier</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    theMask</var>, <var class="Fa" style="white-space: nowrap;">volatile
    uint32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicAnd32</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    theMask</var>, <var class="Fa" style="white-space: nowrap;">volatile
    uint32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicAnd32Barrier</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    theMask</var>, <var class="Fa" style="white-space: nowrap;">volatile
    uint32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicXor32</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    theMask</var>, <var class="Fa" style="white-space: nowrap;">volatile
    uint32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicXor32Barrier</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    theMask</var>, <var class="Fa" style="white-space: nowrap;">volatile
    uint32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicOr32Orig</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    theMask</var>, <var class="Fa" style="white-space: nowrap;">volatile
    uint32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicOr32OrigBarrier</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    theMask</var>, <var class="Fa" style="white-space: nowrap;">volatile
    uint32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicAnd32Orig</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    theMask</var>, <var class="Fa" style="white-space: nowrap;">volatile
    uint32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicAnd32OrigBarrier</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    theMask</var>, <var class="Fa" style="white-space: nowrap;">volatile
    uint32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicXor32Orig</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    theMask</var>, <var class="Fa" style="white-space: nowrap;">volatile
    uint32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicXor32OrigBarrier</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    theMask</var>, <var class="Fa" style="white-space: nowrap;">volatile
    uint32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int64_t</var>
  <br/>
  <code class="Fn">OSAtomicAdd64</code>(<var class="Fa" style="white-space: nowrap;">int64_t
    theAmount</var>, <var class="Fa" style="white-space: nowrap;">volatile
    OSAtomic_int64_aligned64_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int64_t</var>
  <br/>
  <code class="Fn">OSAtomicAdd64Barrier</code>(<var class="Fa" style="white-space: nowrap;">int64_t
    theAmount</var>, <var class="Fa" style="white-space: nowrap;">volatile
    OSAtomic_int64_aligned64_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int64_t</var>
  <br/>
  <code class="Fn">OSAtomicIncrement64</code>(<var class="Fa" style="white-space: nowrap;">volatile
    OSAtomic_int64_aligned64_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int64_t</var>
  <br/>
  <code class="Fn">OSAtomicIncrement64Barrier</code>(<var class="Fa" style="white-space: nowrap;">volatile
    OSAtomic_int64_aligned64_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int64_t</var>
  <br/>
  <code class="Fn">OSAtomicDecrement64</code>(<var class="Fa" style="white-space: nowrap;">volatile
    OSAtomic_int64_aligned64_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int64_t</var>
  <br/>
  <code class="Fn">OSAtomicDecrement64Barrier</code>(<var class="Fa" style="white-space: nowrap;">volatile
    OSAtomic_int64_aligned64_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">OSAtomicCompareAndSwapInt</code>(<var class="Fa" style="white-space: nowrap;">int
    oldValue</var>, <var class="Fa" style="white-space: nowrap;">int
    newValue</var>, <var class="Fa" style="white-space: nowrap;">volatile int
    *theValue</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">OSAtomicCompareAndSwapIntBarrier</code>(<var class="Fa" style="white-space: nowrap;">int
    oldValue</var>, <var class="Fa" style="white-space: nowrap;">int
    newValue</var>, <var class="Fa" style="white-space: nowrap;">volatile int
    *theValue</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">OSAtomicCompareAndSwapLong</code>(<var class="Fa" style="white-space: nowrap;">long
    oldValue</var>, <var class="Fa" style="white-space: nowrap;">long
    newValue</var>, <var class="Fa" style="white-space: nowrap;">volatile long
    *theValue</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">OSAtomicCompareAndSwapLongBarrier</code>(<var class="Fa" style="white-space: nowrap;">long
    oldValue</var>, <var class="Fa" style="white-space: nowrap;">long
    newValue</var>, <var class="Fa" style="white-space: nowrap;">volatile long
    *theValue</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">OSAtomicCompareAndSwapPtr</code>(<var class="Fa" style="white-space: nowrap;">void*
    oldValue</var>, <var class="Fa" style="white-space: nowrap;">void*
    newValue</var>, <var class="Fa" style="white-space: nowrap;">void* volatile
    *theValue</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">OSAtomicCompareAndSwapPtrBarrier</code>(<var class="Fa" style="white-space: nowrap;">void*
    oldValue</var>, <var class="Fa" style="white-space: nowrap;">void*
    newValue</var>, <var class="Fa" style="white-space: nowrap;">void* volatile
    *theValue</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">OSAtomicCompareAndSwap32</code>(<var class="Fa" style="white-space: nowrap;">int32_t
    oldValue</var>, <var class="Fa" style="white-space: nowrap;">int32_t
    newValue</var>, <var class="Fa" style="white-space: nowrap;">volatile
    int32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">OSAtomicCompareAndSwap32Barrier</code>(<var class="Fa" style="white-space: nowrap;">int32_t
    oldValue</var>, <var class="Fa" style="white-space: nowrap;">int32_t
    newValue</var>, <var class="Fa" style="white-space: nowrap;">volatile
    int32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">OSAtomicCompareAndSwap64</code>(<var class="Fa" style="white-space: nowrap;">int64_t
    oldValue</var>, <var class="Fa" style="white-space: nowrap;">int64_t
    newValue</var>, <var class="Fa" style="white-space: nowrap;">volatile
    OSAtomic_int64_aligned64_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">OSAtomicCompareAndSwap64Barrier</code>(<var class="Fa" style="white-space: nowrap;">int64_t
    oldValue</var>, <var class="Fa" style="white-space: nowrap;">int64_t
    newValue</var>, <var class="Fa" style="white-space: nowrap;">volatile
    OSAtomic_int64_aligned64_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">OSAtomicTestAndSet</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    n</var>, <var class="Fa" style="white-space: nowrap;">volatile void
    *theAddress</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">OSAtomicTestAndSetBarrier</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    n</var>, <var class="Fa" style="white-space: nowrap;">volatile void
    *theAddress</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">OSAtomicTestAndClear</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    n</var>, <var class="Fa" style="white-space: nowrap;">volatile void
    *theAddress</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">OSAtomicTestAndClearBarrier</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    n</var>, <var class="Fa" style="white-space: nowrap;">volatile void
    *theAddress</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">OSAtomicEnqueue</code>(<var class="Fa" style="white-space: nowrap;">OSQueueHead
    *list</var>, <var class="Fa" style="white-space: nowrap;">void *new</var>,
    <var class="Fa" style="white-space: nowrap;">size_t offset</var>);</p>
<p class="Pp"><var class="Ft">void*</var>
  <br/>
  <code class="Fn">OSAtomicDequeue</code>(<var class="Fa" style="white-space: nowrap;">OSQueueHead
    *list</var>, <var class="Fa" style="white-space: nowrap;">size_t
    offset</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">OSMemoryBarrier</code>(<var class="Fa" style="white-space: nowrap;">void</var>);</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<div class="Bf Sy">These are deprecated interfaces for atomic and
  synchronization operations, provided for compatibility with legacy code. New
  code should use the C11
  <code class="In">&lt;<a class="In">stdatomic.h</a>&gt;</code> interfaces
  described in <a class="Xr" href="../3/stdatomic">stdatomic(3)</a>.</div>
<p class="Pp">These functions are thread and multiprocessor safe. For each
    function, there is a version which incorporates a memory barrier and another
    version which does not. Barriers strictly order memory access on a
    weakly-ordered architecture such as ARM. All loads and stores executed in
    sequential program order before the barrier will complete before any load or
    store executed after the barrier. On some platforms, such as ARM, the
    barrier operation can be quite expensive.</p>
<p class="Pp" id="OSAtomicIncrement32Barrier">Most code will want to use the
    barrier functions to ensure that memory shared between threads is properly
    synchronized. For example, if you want to initialize a shared data structure
    and then atomically increment a variable to indicate that the initialization
    is complete, then you must use
    <a class="permalink" href="#OSAtomicIncrement32Barrier"><code class="Fn">OSAtomicIncrement32Barrier</code></a>()
    to ensure that the stores to your data structure complete before the atomic
    add. Likewise, the consumer of that data structure must use
    <a class="permalink" href="#OSAtomicDecrement32Barrier"><code class="Fn" id="OSAtomicDecrement32Barrier">OSAtomicDecrement32Barrier</code></a>(),
    in order to ensure that their loads of the structure are not executed before
    the atomic decrement. On the other hand, if you are simply incrementing a
    global counter, then it is safe and potentially much faster to use
    <a class="permalink" href="#OSAtomicIncrement32"><code class="Fn" id="OSAtomicIncrement32">OSAtomicIncrement32</code></a>().
    If you are unsure which version to use, prefer the barrier variants as they
    are safer.</p>
<p class="Pp" id="OSAtomicCompareAndSwap">The logical (and, or, xor) and bit
    test operations are layered on top of the
    <a class="permalink" href="#OSAtomicCompareAndSwap"><code class="Fn">OSAtomicCompareAndSwap</code></a>()
    primitives. There are four versions of each logical operation, depending on
    whether or not there is a barrier, and whether the return value is the
    result of the operation (eg,
    <a class="permalink" href="#OSAtomicOr32"><code class="Fn" id="OSAtomicOr32">OSAtomicOr32</code></a>()
    ) or the original value before the operation (eg,
    <a class="permalink" href="#OSAtomicOr32Orig"><code class="Fn" id="OSAtomicOr32Orig">OSAtomicOr32Orig</code></a>()
    ).</p>
<p class="Pp">The memory address <var class="Fa">theValue</var> must be
    &quot;naturally aligned&quot;, i.e. 32-bit aligned for 32-bit operations and
    64-bit aligned for 64-bit operations. Note that this is not the default
    alignment of the <var class="Vt">int64_t</var> in the iOS ARMv7 ABI, the
    <var class="Vt">OSAtomic_int64_aligned64_t</var> type can be used to declare
    variables with the required alignment.</p>
<p class="Pp" id="OSAtomicCompareAndSwap~2">The
    <a class="permalink" href="#OSAtomicCompareAndSwap~2"><code class="Fn">OSAtomicCompareAndSwap</code></a>()
    operations compare <var class="Fa">oldValue</var> to
    <var class="Fa">*theValue</var>, and set <var class="Fa">*theValue</var> to
    <var class="Fa">newValue</var> if the comparison is equal. The comparison
    and assignment occur as one atomic operation.</p>
<p class="Pp" id="OSAtomicTestAndSet"><a class="permalink" href="#OSAtomicTestAndSet"><code class="Fn">OSAtomicTestAndSet</code></a>()
    and
    <a class="permalink" href="#OSAtomicTestAndClear"><code class="Fn" id="OSAtomicTestAndClear">OSAtomicTestAndClear</code></a>()
    operate on bit (0x80 &gt;&gt; ( <var class="Fa">n</var> &amp; 7)) of byte
    ((char*) <var class="Fa">theAddress</var> + ( <var class="Fa">n</var>
    &gt;&gt; 3)). They set the named bit to either 1 or 0, respectively.
    <var class="Fa">theAddress</var> need not be aligned.</p>
<p class="Pp" id="OSMemoryBarrier">The
    <a class="permalink" href="#OSMemoryBarrier"><code class="Fn">OSMemoryBarrier</code></a>()
    function strictly orders memory accesses in a weakly ordered memory model
    such as with ARM, by creating a barrier. All loads and stores executed in
    sequential program order before the barrier will complete with respect to
    the memory coherence mechanism, before any load or store executed after the
    barrier. Used with an atomic operation, the barrier can be used to create
    custom synchronization protocols as an alternative to the spinlock or
    queue/dequeue operations. Note that this barrier does not order uncached
    loads and stores. On a uniprocessor, the barrier operation is typically
    optimized into a no-op.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_VALUES"><a class="permalink" href="#RETURN_VALUES">RETURN
  VALUES</a></h1>
<p class="Pp">The arithmetic operations return the new value, after the
    operation has been performed. The boolean operations come in two styles, one
    of which returns the new value, and one of which (the &quot;Orig&quot;
    versions) returns the old. The compare-and-swap operations return true if
    the comparison was equal, ie if the swap occured. The bit test and set/clear
    operations return the original value of the bit.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><a class="Xr" href="../3/stdatomic">stdatomic(3)</a>,
    <a class="Xr" href="../3/atomic">atomic(3)</a>,
    <a class="Xr" href="../3/spinlock_deprecated">spinlock_deprecated(3)</a></p>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
<p class="Pp">Most of these functions first appeared in Mac OS 10.4 (Tiger). The
    &quot;Orig&quot; forms of the boolean operations, the &quot;int&quot;,
    &quot;long&quot; and &quot;ptr&quot; forms of compare-and-swap first
    appeared in Mac OS 10.5 (Leopard).</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">March 7, 2016</td>
    <td class="foot-os">Darwin</td>
  </tr>
</table>
</body>
</html>

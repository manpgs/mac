<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   -*- nroff -*-
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>MPSCNNConvolution(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">MPSCNNConvolution(3)</td>
    <td class="head-vol">MetalPerformanceShaders.framework</td>
    <td class="head-rtitle">MPSCNNConvolution(3)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">MPSCNNConvolution</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">#import &lt;MPSCNNConvolution.h&gt;</p>
<p class="Pp">Inherits <b>MPSCNNKernel</b>.</p>
<p class="Pp">Inherited by <b>MPSCNNFullyConnected</b>.</p>
<section class="Ss">
<h2 class="Ss" id="Instance_Methods"><a class="permalink" href="#Instance_Methods">Instance
  Methods</a></h2>
<br/>
<p class="Pp">(nonnull instancetype) - <b>initWithDevice:weights:</b>
  <br/>
  (nonnull instancetype) -
    <b>initWithDevice:convolutionDescriptor:kernelWeights:biasTerms:flags:</b>
  <br/>
  (nullable instancetype) - <b>initWithCoder:device:</b>
  <br/>
  (nonnull instancetype) - <b>initWithDevice:</b>
  <br/>
  (<b>MPSCNNConvolutionGradientState</b> *__nullable) -
    <b>resultStateForSourceImage:sourceStates:destinationImage:</b>
  <br/>
  (<b>MPSCNNConvolutionGradientStateBatch</b> *__nullable) -
    <b>resultStateBatchForSourceImage:sourceStates:destinationImage:</b>
  <br/>
  (<b>MPSCNNConvolutionGradientState</b> *__nullable) -
    <b>temporaryResultStateForCommandBuffer:sourceImage:sourceStates:destinationImage:</b>
  <br/>
  (<b>MPSCNNConvolutionGradientStateBatch</b> *__nullable) -
    <b>temporaryResultStateBatchForCommandBuffer:sourceImage:sourceStates:destinationImage:</b>
  <br/>
  (void) - <b>reloadWeightsAndBiasesFromDataSource</b>
  <br/>
  (void) - <b>reloadWeightsAndBiasesWithDataSource:</b>
  <br/>
  (void) - <b>reloadWeightsAndBiasesWithCommandBuffer:state:</b>
  <br/>
  (<b>MPSCNNConvolutionWeightsAndBiasesState</b> *__nonnull) -
    <b>exportWeightsAndBiasesWithCommandBuffer:resultStateCanBeTemporary:</b>
  <br/>
  <br/>
</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Properties"><a class="permalink" href="#Properties">Properties</a></h2>
<br/>
<p class="Pp">NSUInteger <b>inputFeatureChannels</b>
  <br/>
  NSUInteger <b>outputFeatureChannels</b>
  <br/>
  NSUInteger <b>groups</b>
  <br/>
  id&lt; <b>MPSCNNConvolutionDataSource</b> &gt; <b>dataSource</b>
  <br/>
  NSUInteger <b>subPixelScaleFactor</b>
  <br/>
  const <b>MPSCNNNeuron</b> *__nullable <b>neuron</b>
  <br/>
  const <b>MPSCNNNeuron</b> *__nullable <b>MPSCNNNeuronType</b>
    <b>neuronType</b>
  <br/>
  const <b>MPSCNNNeuron</b> *__nullable <b>MPSCNNNeuronType</b> float
    <b>neuronParameterA</b>
  <br/>
  const <b>MPSCNNNeuron</b> *__nullable <b>MPSCNNNeuronType</b> float float
    <b>neuronParameterB</b>
  <br/>
  const <b>MPSCNNNeuron</b> *__nullable <b>MPSCNNNeuronType</b> float float
    float <b>neuronParameterC</b>
  <br/>
  const <b>MPSCNNNeuron</b> *__nullable <b>MPSCNNNeuronType</b> float float
    float <b>MPSNNNeuronDescriptor</b> *__nullable <b>fusedNeuronDescriptor</b>
  <br/>
  const <b>MPSCNNNeuron</b> *__nullable <b>MPSCNNNeuronType</b> float float
    float <b>MPSNNNeuronDescriptor</b> *__nullable NSUInteger
    <b>channelMultiplier</b>
  <br/>
  <b>MPSNNConvolutionAccumulatorPrecisionOption</b>
    <b>accumulatorPrecisionOption</b>
  <br/>
  <br/>
</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Additional_Inherited_Members"><a class="permalink" href="#Additional_Inherited_Members">Additional
  Inherited Members</a></h2>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Detailed_Description"><a class="permalink" href="#Detailed_Description">Detailed
  Description</a></h1>
<p class="Pp">This depends on Metal.framework The <b>MPSCNNConvolution</b>
    specifies a convolution. The <b>MPSCNNConvolution</b> convolves the input
    image with a set of filters, each producing one feature map in the output
    image.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Method_Documentation"><a class="permalink" href="#Method_Documentation">Method
  Documentation</a></h1>
<section class="Ss">
<h2 class="Ss">- (<b>MPSCNNConvolutionWeightsAndBiasesState</b>* __nonnull)
  exportWeightsAndBiasesWithCommandBuffer: (__nonnull id&lt; MTLCommandBuffer
  &gt;) commandBuffer(BOOL) resultStateCanBeTemporary</h2>
<p class="Pp">GPU side export. Enqueue a kernel to export current weights and
    biases stored in MPSCNNConvoltion's internal buffers into weights and biases
    MTLBuffer returned in <b>MPSCNNConvolutionWeightsAndBiasesState</b>.</p>
<p class="Pp"><b>Parameters:</b></p>
<div class="Bd-indent"><i>commandBuffer</i> Metal command buffer on which export
  kernel is enqueued.
<br/>
<i>resultStateCanBeTemporary</i> If FALSE, state returned will be non-temporary.
  If TRUE, returned state may or may not be temporary.</div>
<p class="Pp"><b>Returns:</b></p>
<div class="Bd-indent"><b>MPSCNNConvolutionWeightsAndBiasesState</b> containing
  weights and biases buffer to which weights got exported. This state and be
  temporary or non-temporary depending on the flag
  resultStateCanBeTemporary</div>
</section>
<section class="Ss">
<h2 class="Ss">- (nullable instancetype) <b>initWithCoder:</b> (NSCoder
  *__nonnull) aDecoder(nonnull id&lt; MTLDevice &gt;) device</h2>
<p class="Pp"><b>NSSecureCoding</b> compatability While the standard
    NSSecureCoding/NSCoding method -initWithCoder: should work, since the file
    can't know which device your data is allocated on, we have to guess and may
    guess incorrectly. To avoid that problem, use initWithCoder:device
  instead.</p>
<p class="Pp"><b>Parameters:</b></p>
<div class="Bd-indent"><i>aDecoder</i> The NSCoder subclass with your serialized
  <b>MPSKernel</b>
<br/>
<i>device</i> The MTLDevice on which to make the <b>MPSKernel</b></div>
<p class="Pp"><b>Returns:</b></p>
<div class="Bd-indent"><b>A</b> new <b>MPSKernel</b> object, or nil if
  failure.</div>
<p class="Pp">Reimplemented from <b>MPSCNNKernel</b>.</p>
<p class="Pp">Reimplemented in <b>MPSCNNFullyConnected</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss">- (nonnull instancetype) initWithDevice: (nonnull id&lt;
  MTLDevice &gt;) device</h2>
<p class="Pp">Standard init with default properties per filter type</p>
<p class="Pp"><b>Parameters:</b></p>
<div class="Bd-indent"><i>device</i> The device that the filter will be used on.
  May not be NULL.</div>
<p class="Pp"><b>Returns:</b></p>
<div class="Bd-indent"><b>A</b> pointer to the newly initialized object. This
  will fail, returning nil if the device is not supported. Devices must be
  MTLFeatureSet_iOS_GPUFamily2_v1 or later.</div>
<p class="Pp">Reimplemented from <b>MPSCNNKernel</b>.</p>
<p class="Pp">Reimplemented in <b>MPSCNNFullyConnected</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss">- (nonnull instancetype) <b>initWithDevice:</b> (nonnull id&lt;
  MTLDevice &gt;) device(const <b>MPSCNNConvolutionDescriptor</b> *__nonnull)
  convolutionDescriptor(const float *__nonnull) kernelWeights(const float
  *__nullable) biasTerms(<b>MPSCNNConvolutionFlags</b>) flags</h2>
<p class="Pp">Initializes a convolution kernel WARNING: This API is depreated
    and will be removed in the future. It cannot be used when training. Also
    serialization/unserialization wont work for <b>MPSCNNConvolution</b> objects
    created with this init. Please move onto using initWithDevice:weights:.</p>
<p class="Pp"><b>Parameters:</b></p>
<div class="Bd-indent"><i>device</i> The MTLDevice on which this
  <b>MPSCNNConvolution</b> filter will be used
<br/>
<i>convolutionDescriptor</i> <b>A</b> pointer to a
  <b>MPSCNNConvolutionDescriptor</b>.
<br/>
<i>kernelWeights</i> <b>A</b> pointer to a weights array. Each entry is a float
  value. The number of entries is = inputFeatureChannels * outputFeatureChannels
  * kernelHeight * kernelWidth The layout of filter weight is so that it can be
  reinterpreted as 4D tensor (array) weight[ outputChannels ][ kernelHeight ][
  kernelWidth ][ inputChannels / groups ] Weights are converted to half float
  (fp16) internally for best performance.
<br/>
<i>biasTerms</i> <b>A</b> pointer to bias terms to be applied to the convolution
  output. Each entry is a float value. The number of entries is =
  numberOfOutputFeatureMaps
<br/>
<i>flags</i> Currently unused. Pass MPSCNNConvolutionFlagsNone</div>
<p class="Pp"><b>Returns:</b></p>
<div class="Bd-indent"><b>A</b> valid <b>MPSCNNConvolution</b> object or nil, if
  failure.</div>
<p class="Pp">Reimplemented in <b>MPSCNNFullyConnected</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss">- (nonnull instancetype) <b>initWithDevice:</b> (nonnull id&lt;
  MTLDevice &gt;) device(nonnull id&lt; <b>MPSCNNConvolutionDataSource</b> &gt;)
  weights</h2>
<p class="Pp">Initializes a convolution kernel</p>
<p class="Pp"><b>Parameters:</b></p>
<div class="Bd-indent"><i>device</i> The MTLDevice on which this
  <b>MPSCNNConvolution</b> filter will be used
<br/>
<i>weights</i> <b>A</b> pointer to a object that conforms to the
  <b>MPSCNNConvolutionDataSource</b> protocol. The
  <b>MPSCNNConvolutionDataSource</b> protocol declares the methods that an
  instance of <b>MPSCNNConvolution</b> uses to obtain the weights and bias terms
  for the CNN convolution filter.</div>
<p class="Pp"><b>Returns:</b></p>
<div class="Bd-indent"><b>A</b> valid <b>MPSCNNConvolution</b> object or nil, if
  failure.</div>
<p class="Pp">Reimplemented in <b>MPSCNNFullyConnected</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss">- (void) reloadWeightsAndBiasesFromDataSource </h2>
<p class="Pp">CPU side reload. Reload the updated weights and biases from data
    provider into internal weights and bias buffers. Weights and biases
    gradients needed for update are obtained from
    <b>MPSCNNConvolutionGradientState</b> object. Data provider passed in init
    call is used for this purpose.</p>
</section>
<section class="Ss">
<h2 class="Ss">- (void) reloadWeightsAndBiasesWithCommandBuffer: (__nonnull
  id&lt; MTLCommandBuffer &gt;)
  commandBuffer(<b>MPSCNNConvolutionWeightsAndBiasesState</b> *__nonnull)
  state</h2>
<p class="Pp">GPU side reload. Reload the updated weights and biases from update
    buffer produced by application enqueued metal kernel into internal weights
    and biases buffer. Weights and biases gradients needed for update are
    obtained from <b>MPSCNNConvolutionGradientState</b> object's
    gradientForWeights and gradientForBiases metal buffer.</p>
<p class="Pp"><b>Parameters:</b></p>
<div class="Bd-indent"><i>commandBuffer</i> Metal command buffer on which
  application update kernel was enqueued consuming
  <b>MPSCNNConvolutionGradientState</b>'s gradientForWeights and
  gradientForBiases buffers and producing updateBuffer metal buffer.
<br/>
<i>state</i> <b>MPSCNNConvolutionWeightsAndBiasesState</b> containing weights
  and biases buffers which have updated weights produced by application's update
  kernel. The state readcount will be decremented.</div>
</section>
<section class="Ss">
<h2 class="Ss">- (void) reloadWeightsAndBiasesWithDataSource: (__nonnull id&lt;
  <b>MPSCNNConvolutionDataSource</b> &gt;) dataSource</h2>
<p class="Pp">Deprecated. dataSource will be ignored.</p>
</section>
<section class="Ss">
<h2 class="Ss">- (<b>MPSCNNConvolutionGradientStateBatch</b> * __nullable)
  resultStateBatchForSourceImage: (<b>MPSImageBatch</b> *__nonnull)
  sourceImage(NSArray&lt; <b>MPSStateBatch</b> * &gt; *__nullable)
  sourceStates(<b>MPSImageBatch</b> *_Nonnull) destinationImage</h2>
</section>
<section class="Ss">
<h2 class="Ss">- (<b>MPSCNNConvolutionGradientState</b> * __nullable)
  resultStateForSourceImage: (<b>MPSImage</b> *__nonnull)
  sourceImage(NSArray&lt; <b>MPSState</b> * &gt; *__nullable)
  sourceStates(<b>MPSImage</b> *__nonnull) destinationImage</h2>
<p class="Pp">Allocate a MPCNNConvolutionGradientSState to hold the results from
    a -encodeBatchToCommandBuffer... operation</p>
<p class="Pp"><b>Parameters:</b></p>
<div class="Bd-indent"><i>sourceImage</i> The <b>MPSImage</b> consumed by the
  associated -encode call.
<br/>
<i>sourceStates</i> The list of MPSStates consumed by the associated -encode
  call, for a batch size of 1.</div>
<p class="Pp"><b>Returns:</b></p>
<div class="Bd-indent">The list of states produced by the -encode call for batch
  size of 1. -isResultStateReusedAcrossBatch returns YES for
  <b>MPSCNNConvolution</b> so same state is used across entire batch. State
  object is not reusasable across batches.</div>
<p class="Pp">Reimplemented from <b>MPSCNNKernel</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss">- (<b>MPSCNNConvolutionGradientStateBatch</b> * __nullable)
  temporaryResultStateBatchForCommandBuffer: (nonnull id&lt; MTLCommandBuffer
  &gt;) commandBuffer(<b>MPSImageBatch</b> *__nonnull) sourceImage(NSArray&lt;
  <b>MPSStateBatch</b> * &gt; *__nullable) sourceStates(<b>MPSImageBatch</b>
  *__nonnull) destinationImage</h2>
<p class="Pp">Reimplemented from <b>MPSCNNKernel</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss">- (<b>MPSCNNConvolutionGradientState</b> * __nullable)
  temporaryResultStateForCommandBuffer: (nonnull id&lt; MTLCommandBuffer &gt;)
  commandBuffer(<b>MPSImage</b> *__nonnull) sourceImage(NSArray&lt;
  <b>MPSState</b> * &gt; *__nullable) sourceStates(<b>MPSImage</b> *__nonnull)
  destinationImage</h2>
<p class="Pp">Allocate a temporary <b>MPSState</b> (subclass) to hold the
    results from a -encodeBatchToCommandBuffer... operation <b>A</b> graph may
    need to allocate storage up front before executing. This may be necessary to
    avoid using too much memory and to manage large batches. The function should
    allocate any <b>MPSState</b> objects that will be produced by an -encode
    call with the indicated sourceImages and sourceStates inputs. Though the
    states can be further adjusted in the ensuing -encode call, the states
    should be initialized with all important data and all MTLResource storage
    allocated. The data stored in the MTLResource need not be initialized,
    unless the ensuing -encode call expects it to be.</p>
<p class="Pp">The MTLDevice used by the result is derived from the command
    buffer. The padding policy will be applied to the filter before this is
    called to give it the chance to configure any properties like
    <b>MPSCNNKernel.offset</b>.</p>
<p class="Pp">CAUTION: The kernel must have all properties set to values that
    will ultimately be passed to the -encode call that writes to the state,
    before -resultStateForSourceImages:sourceStates:destinationImage: is called
    or behavior is undefined. Please note that
    -destinationImageDescriptorForSourceImages:sourceStates:destinationImage:
    will alter some of these properties automatically based on the padding
    policy. If you intend to call that to make the destination image, then you
    should call that before
    -resultStateForSourceImages:sourceStates:destinationImage:. This will ensure
    the properties used in the encode call and in the destination image creation
    match those used to configure the state.</p>
<p class="Pp">The following order is recommended:</p>
<p class="Pp"></p>
<pre>
// Configure MPSCNNKernel properties first
kernel.edgeMode = MPSImageEdgeModeZero;
kernel.destinationFeatureChannelOffset = 128; // concatenation without the copy
// ALERT: will change MPSCNNKernel properties
MPSImageDescriptor * d = [kernel destinationImageDescriptorForSourceImage: source
<br/>
                                                             sourceStates: states];
MPSTemporaryImage * dest = [MPSTemporaryImage temporaryImageWithCommandBuffer: cmdBuf
<br/>
                                                              imageDescriptor: d];
// Now that all properties are configured properly, we can make the result state
// and call encode.
MPSState * __nullable destState = [kernel temporaryResultStateForCommandBuffer: cmdBuf
<br/>
                                                                   sourceImage: source
<br/>
                                                                  sourceStates: states];
// This form of -encode will be declared by the MPSCNNKernel subclass
[kernel encodeToCommandBuffer: cmdBuf
<br/>
                  sourceImage: source
<br/>
             destinationState: destState
<br/>
             destinationImage: dest ];
</pre>
<p class="Pp">Default: returns nil</p>
<p class="Pp"><b>Parameters:</b></p>
<div class="Bd-indent"><i>commandBuffer</i> The command buffer to allocate the
  temporary storage against The state will only be valid on this command buffer.
<br/>
<i>sourceImage</i> The <b>MPSImage</b> consumed by the associated -encode call.
<br/>
<i>sourceStates</i> The list of MPSStates consumed by the associated -encode
  call, for a batch size of 1.
<br/>
<i>destinationImage</i> The destination image for the encode call</div>
<p class="Pp"><b>Returns:</b></p>
<div class="Bd-indent">The list of states produced by the -encode call for batch
  size of 1. When the batch size is not 1, this function will be called
  repeatedly unless -isResultStateReusedAcrossBatch returns YES. If
  -isResultStateReusedAcrossBatch returns YES, then it will be called once per
  batch and the MPSStateBatch array will contain MPSStateBatch.length references
  to the same object.</div>
<p class="Pp">Reimplemented from <b>MPSCNNKernel</b>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Property_Documentation"><a class="permalink" href="#Property_Documentation">Property
  Documentation</a></h1>
<section class="Ss">
<h2 class="Ss">- (<b>MPSNNConvolutionAccumulatorPrecisionOption</b>)
  accumulatorPrecisionOption [read]<b>, [write]</b>, [nonatomic]<b>,
  [assign]</b></h2>
<p class="Pp">Precision of accumulator used in convolution. See
    <b>MPSNeuralNetworkTypes.h</b> for discussion. Default is
    MPSNNConvolutionAccumulatorPrecisionOptionFloat.</p>
</section>
<section class="Ss">
<h2 class="Ss">- (const <b>MPSCNNNeuron</b>* __nullable <b>MPSCNNNeuronType</b>
  float float float <b>MPSNNNeuronDescriptor</b>* __nullable NSUInteger)
  channelMultiplier [read]<b>, [nonatomic]</b>, [assign]<b></b></h2>
<p class="Pp">Channel multiplier. For convolution created with
    <b>MPSCNNDepthWiseConvolutionDescriptor</b>, it is the number of output
    feature channels for each input channel. See
    <b>MPSCNNDepthWiseConvolutionDescriptor</b> for more details. Default is 0
    which means regular CNN convolution.</p>
</section>
<section class="Ss">
<h2 class="Ss">- dataSource [read]<b>, [nonatomic]</b>, [retain]<b></b></h2>
<p class="Pp">dataSource with which convolution object was created</p>
</section>
<section class="Ss">
<h2 class="Ss">- (const <b>MPSCNNNeuron</b>* __nullable <b>MPSCNNNeuronType</b>
  float float float <b>MPSNNNeuronDescriptor</b>* __nullable)
  fusedNeuronDescriptor [read]<b>, [nonatomic]</b>, [assign]<b></b></h2>
<p class="Pp">Fused neuron descritor passed in convolution descriptor for fusion
    with convolution. Please see class description for interpretation of c.</p>
</section>
<section class="Ss">
<h2 class="Ss">- groups [read]<b>, [nonatomic]</b>, [assign]<b></b></h2>
<p class="Pp">Number of groups input and output channels are divided into.</p>
</section>
<section class="Ss">
<h2 class="Ss">- inputFeatureChannels [read]<b>, [nonatomic]</b>,
  [assign]<b></b></h2>
<p class="Pp">The number of feature channels per pixel in the input image.</p>
</section>
<section class="Ss">
<h2 class="Ss">- neuron [read]<b>, [nonatomic]</b>, [assign]<b></b></h2>
<p class="Pp"><b>MPSCNNNeuron</b> filter to be applied as part of convolution.
    Can be nil in wich case no neuron activation fuction is applied.</p>
</section>
<section class="Ss">
<h2 class="Ss">- (const <b>MPSCNNNeuron</b>* __nullable <b>MPSCNNNeuronType</b>
  float) neuronParameterA [read]<b>, [nonatomic]</b>, [assign]<b></b></h2>
<p class="Pp">Parameter 'a' for the neuron. Default: 1.0f Please see class
    description for interpretation of a.</p>
</section>
<section class="Ss">
<h2 class="Ss">- (const <b>MPSCNNNeuron</b>* __nullable <b>MPSCNNNeuronType</b>
  float float) neuronParameterB [read]<b>, [nonatomic]</b>, [assign]<b></b></h2>
<p class="Pp">Parameter 'b' for the neuron. Default: 1.0f Please see class
    description for interpretation of b.</p>
</section>
<section class="Ss">
<h2 class="Ss">- (const <b>MPSCNNNeuron</b>* __nullable <b>MPSCNNNeuronType</b>
  float float float) neuronParameterC [read]<b>, [nonatomic]</b>,
  [assign]<b></b></h2>
<p class="Pp">Parameter 'c' for the neuron. Default: 1.0f Please see class
    description for interpretation of c.</p>
</section>
<section class="Ss">
<h2 class="Ss">- (const <b>MPSCNNNeuron</b>* __nullable <b>MPSCNNNeuronType</b>)
  neuronType [read]<b>, [nonatomic]</b>, [assign]<b></b></h2>
<p class="Pp">The type of neuron to append to the convolution Please see class
    description for a full list. Default is MPSCNNNeuronTypeNone.</p>
</section>
<section class="Ss">
<h2 class="Ss">- outputFeatureChannels [read]<b>, [nonatomic]</b>,
  [assign]<b></b></h2>
<p class="Pp">The number of feature channels per pixel in the output image.</p>
</section>
<section class="Ss">
<h2 class="Ss">- subPixelScaleFactor [read]<b>, [nonatomic]</b>,
  [assign]<b></b></h2>
<p class="Pp">Sub pixel scale factor which was passed in as part of
    <b>MPSCNNConvolutionDescriptor</b> when creating this
    <b>MPSCNNConvolution</b> object.</p>
<p class="Pp"></p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Author"><a class="permalink" href="#Author">Author</a></h1>
<p class="Pp">Generated automatically by Doxygen for
    MetalPerformanceShaders.framework from the source code.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">Mon Jul 9 2018</td>
    <td class="foot-os">Version MetalPerformanceShaders-119.3</td>
  </tr>
</table>
</body>
</html>

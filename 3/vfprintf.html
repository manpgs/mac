<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Copyright (c) 1990, 1991, 1993
  	The Regents of the University of California.  All rights reserved.
  
   This code is derived from software contributed to Berkeley by
   Chris Torek and the American National Standards Committee X3,
   on Information Processing Systems.
  
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:
   1. Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
   2. Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
   4. Neither the name of the University nor the names of its contributors
      may be used to endorse or promote products derived from this software
      without specific prior written permission.
  
   THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
   OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
   LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
   OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
   SUCH DAMAGE.
  
       @(#)printf.3	8.1 (Berkeley) 6/4/93
   $FreeBSD$
   -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PRINTF(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PRINTF(3)</td>
    <td class="head-vol">Library Functions Manual</td>
    <td class="head-rtitle">PRINTF(3)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp"><code class="Nm">printf</code>, <code class="Nm">fprintf</code>,
    <code class="Nm">sprintf</code>, <code class="Nm">snprintf</code>,
    <code class="Nm">asprintf</code>, <code class="Nm">dprintf</code>,
    <code class="Nm">vprintf</code>, <code class="Nm">vfprintf, vsprintf</code>,
    <code class="Nm">vsnprintf</code>, <code class="Nm">vasprintf,
    vdprintf</code> &#x2014; <span class="Nd">formatted output
  conversion</span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="LIBRARY"><a class="permalink" href="#LIBRARY">LIBRARY</a></h1>
<p class="Pp"><span class="Lb">Standard C&#x00A0;Library (libc, -lc)</span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp"><code class="In">#include
  &lt;<a class="In">stdio.h</a>&gt;</code></p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">printf</code>(<var class="Fa" style="white-space: nowrap;">const
    char * restrict format</var>,
    <var class="Fa" style="white-space: nowrap;">...</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">fprintf</code>(<var class="Fa" style="white-space: nowrap;">FILE
    * restrict stream</var>, <var class="Fa" style="white-space: nowrap;">const
    char * restrict format</var>,
    <var class="Fa" style="white-space: nowrap;">...</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">sprintf</code>(<var class="Fa" style="white-space: nowrap;">char
    * restrict str</var>, <var class="Fa" style="white-space: nowrap;">const
    char * restrict format</var>,
    <var class="Fa" style="white-space: nowrap;">...</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">snprintf</code>(<var class="Fa" style="white-space: nowrap;">char
    * restrict str</var>, <var class="Fa" style="white-space: nowrap;">size_t
    size</var>, <var class="Fa" style="white-space: nowrap;">const char *
    restrict format</var>,
    <var class="Fa" style="white-space: nowrap;">...</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">asprintf</code>(<var class="Fa" style="white-space: nowrap;">char
    **ret</var>, <var class="Fa" style="white-space: nowrap;">const char
    *format</var>, <var class="Fa" style="white-space: nowrap;">...</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">dprintf</code>(<var class="Fa" style="white-space: nowrap;">int
    fd</var>, <var class="Fa" style="white-space: nowrap;">const char * restrict
    format</var>, <var class="Fa" style="white-space: nowrap;">...</var>);</p>
<p class="Pp"><code class="In">#include
    &lt;<a class="In">stdarg.h</a>&gt;</code></p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">vprintf</code>(<var class="Fa" style="white-space: nowrap;">const
    char * restrict format</var>,
    <var class="Fa" style="white-space: nowrap;">va_list ap</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">vfprintf</code>(<var class="Fa" style="white-space: nowrap;">FILE
    * restrict stream</var>, <var class="Fa" style="white-space: nowrap;">const
    char * restrict format</var>,
    <var class="Fa" style="white-space: nowrap;">va_list ap</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">vsprintf</code>(<var class="Fa" style="white-space: nowrap;">char
    * restrict str</var>, <var class="Fa" style="white-space: nowrap;">const
    char * restrict format</var>,
    <var class="Fa" style="white-space: nowrap;">va_list ap</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">vsnprintf</code>(<var class="Fa" style="white-space: nowrap;">char
    * restrict str</var>, <var class="Fa" style="white-space: nowrap;">size_t
    size</var>, <var class="Fa" style="white-space: nowrap;">const char *
    restrict format</var>, <var class="Fa" style="white-space: nowrap;">va_list
    ap</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">vasprintf</code>(<var class="Fa" style="white-space: nowrap;">char
    **ret</var>, <var class="Fa" style="white-space: nowrap;">const char
    *format</var>, <var class="Fa" style="white-space: nowrap;">va_list
    ap</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">vdprintf</code>(<var class="Fa" style="white-space: nowrap;">int
    fd</var>, <var class="Fa" style="white-space: nowrap;">const char * restrict
    format</var>, <var class="Fa" style="white-space: nowrap;">va_list
    ap</var>);</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The
    <a class="permalink" href="#printf"><code class="Fn" id="printf">printf</code></a>()
    family of functions produces output according to a
    <var class="Fa">format</var> as described below. The
    <code class="Fn">printf</code>() and
    <a class="permalink" href="#vprintf"><code class="Fn" id="vprintf">vprintf</code></a>()
    functions write output to <code class="Dv">stdout</code>, the standard
    output stream;
    <a class="permalink" href="#fprintf"><code class="Fn" id="fprintf">fprintf</code></a>()
    and
    <a class="permalink" href="#vfprintf"><code class="Fn" id="vfprintf">vfprintf</code></a>()
    write output to the given output <var class="Fa">stream</var>;
    <a class="permalink" href="#dprintf"><code class="Fn" id="dprintf">dprintf</code></a>()
    and
    <a class="permalink" href="#vdprintf"><code class="Fn" id="vdprintf">vdprintf</code></a>()
    write output to the given file descriptor;
    <code class="Fn">sprintf</code>(), <code class="Fn">snprintf</code>(),
    <code class="Fn">vsprintf</code>(), and <code class="Fn">vsnprintf</code>()
    write to the character string <var class="Fa">str</var>; and
    <code class="Fn">asprintf</code>() and <code class="Fn">vasprintf</code>()
    dynamically allocate a new string with
    <a class="Xr" href="../3/malloc">malloc(3)</a>.</p>
<p class="Pp">Extended locale versions of these functions are documented in
    <a class="Xr" href="../3/printf_l">printf_l(3)</a>. See
    <a class="Xr" href="../3/xlocale">xlocale(3)</a> for more information.</p>
<p class="Pp">These functions write the output under the control of a
    <var class="Fa">format</var> string that specifies how subsequent arguments
    (or arguments accessed via the variable-length argument facilities of
    <a class="Xr" href="../3/stdarg">stdarg(3)</a>) are converted for
  output.</p>
<p class="Pp" id="asprintf">The
    <a class="permalink" href="#asprintf"><code class="Fn">asprintf</code></a>()
    and
    <a class="permalink" href="#vasprintf"><code class="Fn" id="vasprintf">vasprintf</code></a>()
    functions set <var class="Fa">*ret</var> to be a pointer to a buffer
    sufficiently large to hold the formatted string. This pointer should be
    passed to <a class="Xr" href="../3/free">free(3)</a> to release the
    allocated storage when it is no longer needed. If sufficient space cannot be
    allocated, <code class="Fn">asprintf</code>() and
    <code class="Fn">vasprintf</code>() will return -1 and set
    <var class="Fa">ret</var> to be a <code class="Dv">NULL</code> pointer.</p>
<p class="Pp" id="snprintf">The
    <a class="permalink" href="#snprintf"><code class="Fn">snprintf</code></a>()
    and
    <a class="permalink" href="#vsnprintf"><code class="Fn" id="vsnprintf">vsnprintf</code></a>()
    functions will write at most <var class="Fa">size</var>-1 of the characters
    printed into the output string (the <var class="Fa">size</var>'th character
    then gets the terminating &#x2018;<code class="Li">\0</code>&#x2019;); if
    the return value is greater than or equal to the <var class="Fa">size</var>
    argument, the string was too short and some of the printed characters were
    discarded. The output is always null-terminated, unless
    <var class="Fa">size</var> is 0.</p>
<p class="Pp" id="sprintf">The
    <a class="permalink" href="#sprintf"><code class="Fn">sprintf</code></a>()
    and
    <a class="permalink" href="#vsprintf"><code class="Fn" id="vsprintf">vsprintf</code></a>()
    functions effectively assume a <var class="Fa">size</var> of
    <code class="Dv">INT_MAX + 1.</code></p>
<p class="Pp">For those routines that write to a user-provided character string,
    that string and the format strings should not overlap, as the behavior is
    undefined.</p>
<p class="Pp">The format string is composed of zero or more directives: ordinary
    characters (not <code class="Cm">%</code>), which are copied unchanged to
    the output stream; and conversion specifications, each of which results in
    fetching zero or more subsequent arguments. Each conversion specification is
    introduced by the <code class="Cm">%</code> character. The arguments must
    correspond properly (after type promotion) with the conversion specifier.
    After the <code class="Cm">%</code>, the following appear in sequence:</p>
<ul class="Bl-bullet">
  <li>An optional field, consisting of a decimal digit string followed by a
      <code class="Cm">$</code>, specifying the next argument to access. If this
      field is not provided, the argument following the last argument accessed
      will be used. Arguments are numbered starting at
      <code class="Cm">1</code>. If unaccessed arguments in the format string
      are interspersed with ones that are accessed the results will be
      indeterminate.</li>
  <li>Zero or more of the following flags:
    <dl class="Bl-tag">
      <dt>&#x2018;<code class="Cm">#</code>&#x2019;</dt>
      <dd>The value should be converted to an &#x201C;alternate form&#x201D;.
          For <code class="Cm">c</code>, <code class="Cm">d</code>,
          <code class="Cm">i</code>, <code class="Cm">n</code>,
          <code class="Cm">p</code>, <code class="Cm">s</code>, and
          <code class="Cm">u</code> conversions, this option has no effect. For
          <code class="Cm">o</code> conversions, the precision of the number is
          increased to force the first character of the output string to a zero.
          For <code class="Cm">x</code> and <code class="Cm">X</code>
          conversions, a non-zero result has the string
          &#x2018;<code class="Li">0x</code>&#x2019; (or
          &#x2018;<code class="Li">0X</code>&#x2019; for
          <code class="Cm">X</code> conversions) prepended to it. For
          <code class="Cm">a</code>, <code class="Cm">A</code>,
          <code class="Cm">e</code>, <code class="Cm">E</code>,
          <code class="Cm">f</code>, <code class="Cm">F</code>,
          <code class="Cm">g</code>, and <code class="Cm">G</code> conversions,
          the result will always contain a decimal point, even if no digits
          follow it (normally, a decimal point appears in the results of those
          conversions only if a digit follows). For <code class="Cm">g</code>
          and <code class="Cm">G</code> conversions, trailing zeros are not
          removed from the result as they would otherwise be.</dd>
      <dt>&#x2018;<code class="Cm">0</code>&#x2019; (zero)</dt>
      <dd>Zero padding. For all conversions except <code class="Cm">n</code>,
          the converted value is padded on the left with zeros rather than
          blanks. If a precision is given with a numeric conversion
          (<code class="Cm">d</code>, <code class="Cm">i</code>,
          <code class="Cm">o</code>, <code class="Cm">u</code>,
          <code class="Cm">i</code>, <code class="Cm">x</code>, and
          <code class="Cm">X</code>), the <code class="Cm">0</code> flag is
          ignored.</dd>
      <dt>&#x2018;<code class="Cm">-</code>&#x2019;</dt>
      <dd>A negative field width flag; the converted value is to be left
          adjusted on the field boundary. Except for <code class="Cm">n</code>
          conversions, the converted value is padded on the right with blanks,
          rather than on the left with blanks or zeros. A
          <code class="Cm">-</code> overrides a <code class="Cm">0</code> if
          both are given.</dd>
      <dt>&#x2018;&#x00A0;&#x2019; (space)</dt>
      <dd>A blank should be left before a positive number produced by a signed
          conversion (<code class="Cm">a</code>, <code class="Cm">A</code>,
          <code class="Cm">d</code>, <code class="Cm">e</code>,
          <code class="Cm">E</code>, <code class="Cm">f</code>,
          <code class="Cm">F</code>, <code class="Cm">g</code>,
          <code class="Cm">G</code>, or <code class="Cm">i</code>).</dd>
      <dt>&#x2018;<code class="Cm">+</code>&#x2019;</dt>
      <dd>A sign must always be placed before a number produced by a signed
          conversion. A <code class="Cm">+</code> overrides a space if both are
          used.</dd>
      <dt>&#x2018;'&#x2019; (apostrophe)</dt>
      <dd>Decimal conversions (<code class="Cm">d</code>,
          <code class="Cm">u</code>, or <code class="Cm">i</code>) or the
          integral portion of a floating point conversion
          (<code class="Cm">f</code> or <code class="Cm">F</code>) should be
          grouped and separated by thousands using the non-monetary separator
          returned by
        <a class="Xr" href="../3/localeconv">localeconv(3)</a>.</dd>
    </dl>
  </li>
  <li id="_">An optional separator character ( <code class="Cm">&#x00A0;,</code>
      | <code class="Cm">;</code> | <code class="Cm">&#x00A0;:</code> |
      <a class="permalink" href="#_"><code class="Cm">_</code></a> ) used for
      separating multiple values when printing an AltiVec or SSE vector, or
      other multi-value unit.
    <p class="Pp" id="printf~2">NOTE: This is an extension to the
        <a class="permalink" href="#printf~2"><code class="Fn">printf</code></a>()
        specification. Behaviour of these values for
        <code class="Fn">printf</code>() is only defined for operating systems
        conforming to the AltiVec Technology Programming Interface Manual. (At
        time of writing this includes only Mac OS X 10.2 and later.)</p>
  </li>
  <li>An optional decimal digit string specifying a minimum field width. If the
      converted value has fewer characters than the field width, it will be
      padded with spaces on the left (or right, if the left-adjustment flag has
      been given) to fill out the field width.</li>
  <li>An optional precision, in the form of a period <code class="Cm">.</code>
      followed by an optional digit string. If the digit string is omitted, the
      precision is taken as zero. This gives the minimum number of digits to
      appear for <code class="Cm">d</code>, <code class="Cm">i</code>,
      <code class="Cm">o</code>, <code class="Cm">u</code>,
      <code class="Cm">x</code>, and <code class="Cm">X</code> conversions, the
      number of digits to appear after the decimal-point for
      <code class="Cm">a</code>, <code class="Cm">A</code>,
      <code class="Cm">e</code>, <code class="Cm">E</code>,
      <code class="Cm">f</code>, and <code class="Cm">F</code> conversions, the
      maximum number of significant digits for <code class="Cm">g</code> and
      <code class="Cm">G</code> conversions, or the maximum number of characters
      to be printed from a string for <code class="Cm">s</code>
    conversions.</li>
  <li>An optional length modifier, that specifies the size of the argument. The
      following length modifiers are valid for the <code class="Cm">d</code>,
      <code class="Cm">i</code>, <code class="Cm">n</code>,
      <code class="Cm">o</code>, <code class="Cm">u</code>,
      <code class="Cm">x</code>, or <code class="Cm">X</code> conversion:
    <table class="Bl-column">
      <tr id="Modifier">
        <td><a class="permalink" href="#Modifier"><b class="Sy">Modifier</b></a></td>
        <td><a class="permalink" href="#d"><code class="Cm" id="d">d</code></a>,
          <code class="Cm">i</code></td>
        <td><a class="permalink" href="#o"><code class="Cm" id="o">o</code></a>,
          <code class="Cm">u</code>, <code class="Cm">x</code>,
          <code class="Cm">X</code></td>
        <td><a class="permalink" href="#n"><code class="Cm" id="n">n</code></a></td>
      </tr>
      <tr id="hh">
        <td><a class="permalink" href="#hh"><code class="Cm">hh</code></a></td>
        <td><var class="Vt">signed char</var></td>
        <td><var class="Vt">unsigned char</var></td>
        <td><var class="Vt">signed char *</var></td>
      </tr>
      <tr id="h">
        <td><a class="permalink" href="#h"><code class="Cm">h</code></a></td>
        <td><var class="Vt">short</var></td>
        <td><var class="Vt">unsigned short</var></td>
        <td><var class="Vt">short *</var></td>
      </tr>
      <tr id="l">
        <td><a class="permalink" href="#l"><code class="Cm">l</code></a>
          <span class="No">(ell)</span></td>
        <td><var class="Vt">long</var></td>
        <td><var class="Vt">unsigned long</var></td>
        <td><var class="Vt">long *</var></td>
      </tr>
      <tr id="ll">
        <td><a class="permalink" href="#ll"><code class="Cm">ll</code></a>
          <span class="No">(ell ell)</span></td>
        <td><var class="Vt">long long</var></td>
        <td><var class="Vt">unsigned long long</var></td>
        <td><var class="Vt">long long *</var></td>
      </tr>
      <tr id="j">
        <td><a class="permalink" href="#j"><code class="Cm">j</code></a></td>
        <td><var class="Vt">intmax_t</var></td>
        <td><var class="Vt">uintmax_t</var></td>
        <td><var class="Vt">intmax_t *</var></td>
      </tr>
      <tr id="t">
        <td><a class="permalink" href="#t"><code class="Cm">t</code></a></td>
        <td><var class="Vt">ptrdiff_t</var></td>
        <td>(see note)</td>
        <td><var class="Vt">ptrdiff_t *</var></td>
      </tr>
      <tr id="z">
        <td><a class="permalink" href="#z"><code class="Cm">z</code></a></td>
        <td>(see note)</td>
        <td><var class="Vt">size_t</var></td>
        <td>(see note)</td>
      </tr>
      <tr id="q">
        <td><a class="permalink" href="#q"><code class="Cm">q</code></a>
          <a class="permalink" href="#(deprecated)"><i class="Em" id="(deprecated)">(deprecated)</i></a></td>
        <td><var class="Vt">quad_t</var></td>
        <td><var class="Vt">u_quad_t</var></td>
        <td><var class="Vt">quad_t *</var></td>
      </tr>
    </table>
    <p class="Pp">Note: the <code class="Cm">t</code> modifier, when applied to
        a <code class="Cm">o</code>, <code class="Cm">u</code>,
        <code class="Cm">x</code>, or <code class="Cm">X</code> conversion,
        indicates that the argument is of an unsigned type equivalent in size to
        a <var class="Vt">ptrdiff_t</var>. The <code class="Cm">z</code>
        modifier, when applied to a <code class="Cm">d</code> or
        <code class="Cm">i</code> conversion, indicates that the argument is of
        a signed type equivalent in size to a <var class="Vt">size_t</var>.
        Similarly, when applied to an <code class="Cm">n</code> conversion, it
        indicates that the argument is a pointer to a signed type equivalent in
        size to a <var class="Vt">size_t</var>.</p>
    <p class="Pp">The following length modifier is valid for the
        <code class="Cm">a</code>, <code class="Cm">A</code>,
        <code class="Cm">e</code>, <code class="Cm">E</code>,
        <code class="Cm">f</code>, <code class="Cm">F</code>,
        <code class="Cm">g</code>, or <code class="Cm">G</code> conversion:</p>
    <table class="Bl-column">
      <tr id="Modifier~2">
        <td><a class="permalink" href="#Modifier~2"><b class="Sy">Modifier</b></a></td>
        <td><a class="permalink" href="#a"><code class="Cm" id="a">a</code></a>,
          <code class="Cm">A</code>, <code class="Cm">e</code>,
          <code class="Cm">E</code>, <code class="Cm">f</code>,
          <code class="Cm">F</code>, <code class="Cm">g</code>,
          <code class="Cm">G</code></td>
      </tr>
      <tr id="l~2">
        <td><a class="permalink" href="#l~2"><code class="Cm">l</code></a>
          <span class="No">(ell)</span></td>
        <td><var class="Vt">double</var> (ignored, same behavior as without
          it)</td>
      </tr>
      <tr id="L">
        <td><a class="permalink" href="#L"><code class="Cm">L</code></a></td>
        <td><var class="Vt">long double</var></td>
      </tr>
    </table>
    <p class="Pp">The following length modifier is valid for the
        <code class="Cm">c</code> or <code class="Cm">s</code> conversion:</p>
    <table class="Bl-column">
      <tr id="Modifier~3">
        <td><a class="permalink" href="#Modifier~3"><b class="Sy">Modifier</b></a></td>
        <td><a class="permalink" href="#c"><code class="Cm" id="c">c</code></a></td>
        <td><a class="permalink" href="#s"><code class="Cm" id="s">s</code></a></td>
      </tr>
      <tr id="l~3">
        <td><a class="permalink" href="#l~3"><code class="Cm">l</code></a>
          <span class="No">(ell)</span></td>
        <td><var class="Vt">wint_t</var></td>
        <td><var class="Vt">wchar_t *</var></td>
      </tr>
    </table>
    <p class="Pp">The AltiVec Technology Programming Interface Manual also
        defines five additional length modifiers which can be used (in place of
        the conventional length modifiers) for the printing of AltiVec or SSE
        vectors:</p>
    <dl class="Bl-tag Bl-compact">
      <dt id="v"><a class="permalink" href="#v"><code class="Cm">v</code></a></dt>
      <dd>Treat the argument as a vector value, unit length will be determined
          by the conversion specifier (default = 16 8-bit units for all integer
          conversions, 4 32-bit units for floating point conversions).</dd>
      <dt id="vh,"><a class="permalink" href="#vh,"><code class="Cm">vh,
        hv</code></a></dt>
      <dd>Treat the argument as a vector of 8 16-bit units.</dd>
      <dt id="vl,"><a class="permalink" href="#vl,"><code class="Cm">vl,
        lv</code></a></dt>
      <dd>Treat the argument as a vector of 4 32-bit units.</dd>
    </dl>
    <p class="Pp" id="printf~3">NOTE: The vector length specifiers are
        extensions to the
        <a class="permalink" href="#printf~3"><code class="Fn">printf</code></a>()
        specification. Behaviour of these values for
        <code class="Fn">printf</code>() is only defined for operating systems
        conforming to the AltiVec Technology Programming Interface Manual. (At
        time of writing this includes only Mac OS X 10.2 and later.)</p>
    <p class="Pp">As a further extension, for SSE2 64-bit units:</p>
    <dl class="Bl-tag Bl-compact">
      <dt id="vll,"><a class="permalink" href="#vll,"><code class="Cm">vll,
        llv</code></a></dt>
      <dd>Treat the argument as a vector of 2 64-bit units.</dd>
    </dl>
  </li>
  <li>A character that specifies the type of conversion to be applied.</li>
</ul>
<p class="Pp">A field width or precision, or both, may be indicated by an
    asterisk &#x2018;<code class="Li">*</code>&#x2019; or an asterisk followed
    by one or more decimal digits and a
    &#x2018;<code class="Li">$</code>&#x2019; instead of a digit string. In this
    case, an <var class="Vt">int</var> argument supplies the field width or
    precision. A negative field width is treated as a left adjustment flag
    followed by a positive field width; a negative precision is treated as
    though it were missing. If a single format directive mixes positional
    (<code class="Li">nn$</code>) and non-positional arguments, the results are
    undefined.</p>
<p class="Pp">The conversion specifiers and their meanings are:</p>
<dl class="Bl-tag">
  <dt id="diouxX"><a class="permalink" href="#diouxX"><code class="Cm">diouxX</code></a></dt>
  <dd>The <var class="Vt">int</var> (or appropriate variant) argument is
      converted to signed decimal (<code class="Cm">d</code> and
      <code class="Cm">i</code>), unsigned octal (<code class="Cm">o</code>),
      unsigned decimal (<code class="Cm">u</code>), or unsigned hexadecimal
      (<code class="Cm">x</code> and <code class="Cm">X</code>) notation. The
      letters &#x201C;<code class="Li">abcdef</code>&#x201D; are used for
      <code class="Cm">x</code> conversions; the letters
      &#x201C;<code class="Li">ABCDEF</code>&#x201D; are used for
      <code class="Cm">X</code> conversions. The precision, if any, gives the
      minimum number of digits that must appear; if the converted value requires
      fewer digits, it is padded on the left with zeros.</dd>
  <dt id="DOU"><a class="permalink" href="#DOU"><code class="Cm">DOU</code></a></dt>
  <dd>The <var class="Vt">long int</var> argument is converted to signed
      decimal, unsigned octal, or unsigned decimal, as if the format had been
      <code class="Cm">ld</code>, <code class="Cm">lo</code>, or
      <code class="Cm">lu</code> respectively. These conversion characters are
      deprecated, and will eventually disappear.</dd>
  <dt id="eE"><a class="permalink" href="#eE"><code class="Cm">eE</code></a></dt>
  <dd>The <var class="Vt">double</var> argument is rounded and converted in the
      style
      [-]<var class="Ar">d</var><code class="Li">.</code><var class="Ar">ddd</var><code class="Li">e&#x00B1;</code><var class="Ar">dd</var>
      where there is one digit before the decimal-point character and the number
      of digits after it is equal to the precision; if the precision is missing,
      it is taken as 6; if the precision is zero, no decimal-point character
      appears. An <code class="Cm">E</code> conversion uses the letter
      &#x2018;<code class="Li">E</code>&#x2019; (rather than
      &#x2018;<code class="Li">e</code>&#x2019;) to introduce the exponent. The
      exponent always contains at least two digits; if the value is zero, the
      exponent is 00.
    <p class="Pp">For <code class="Cm">a</code>, <code class="Cm">A</code>,
        <code class="Cm">e</code>, <code class="Cm">E</code>,
        <code class="Cm">f</code>, <code class="Cm">F</code>,
        <code class="Cm">g</code>, and <code class="Cm">G</code> conversions,
        positive and negative infinity are represented as
        <code class="Li">inf</code> and <code class="Li">-inf</code>
        respectively when using the lowercase conversion character, and
        <code class="Li">INF</code> and <code class="Li">-INF</code>
        respectively when using the uppercase conversion character. Similarly,
        NaN is represented as <code class="Li">nan</code> when using the
        lowercase conversion, and <code class="Li">NAN</code> when using the
        uppercase conversion.</p>
  </dd>
  <dt id="fF"><a class="permalink" href="#fF"><code class="Cm">fF</code></a></dt>
  <dd>The <var class="Vt">double</var> argument is rounded and converted to
      decimal notation in the style
      [-]<var class="Ar">ddd</var><code class="Li">.</code><var class="Ar">ddd</var>,
      where the number of digits after the decimal-point character is equal to
      the precision specification. If the precision is missing, it is taken as
      6; if the precision is explicitly zero, no decimal-point character
      appears. If a decimal point appears, at least one digit appears before
    it.</dd>
  <dt id="gG"><a class="permalink" href="#gG"><code class="Cm">gG</code></a></dt>
  <dd>The <var class="Vt">double</var> argument is converted in style
      <code class="Cm">f</code> or <code class="Cm">e</code> (or
      <code class="Cm">F</code> or <code class="Cm">E</code> for
      <code class="Cm">G</code> conversions). The precision specifies the number
      of significant digits. If the precision is missing, 6 digits are given; if
      the precision is zero, it is treated as 1. Style <code class="Cm">e</code>
      is used if the exponent from its conversion is less than -4 or greater
      than or equal to the precision. Trailing zeros are removed from the
      fractional part of the result; a decimal point appears only if it is
      followed by at least one digit.</dd>
  <dt id="aA"><a class="permalink" href="#aA"><code class="Cm">aA</code></a></dt>
  <dd>The <var class="Vt">double</var> argument is rounded and converted to
      hexadecimal notation in the style
      [-]<code class="Li">0x</code><var class="Ar">h</var><code class="Li">.</code><var class="Ar">hhhp</var>[&#x00B1;]<var class="Ar">d</var>,
      where the number of digits after the hexadecimal-point character is equal
      to the precision specification. If the precision is missing, it is taken
      as enough to represent the floating-point number exactly, and no rounding
      occurs. If the precision is zero, no hexadecimal-point character appears.
      The <code class="Cm">p</code> is a literal character
      &#x2018;<code class="Li">p</code>&#x2019;, and the exponent consists of a
      positive or negative sign followed by a decimal number representing an
      exponent of 2. The <code class="Cm">A</code> conversion uses the prefix
      &#x201C;<code class="Li">0X</code>&#x201D; (rather than
      &#x201C;<code class="Li">0x</code>&#x201D;), the letters
      &#x201C;<code class="Li">ABCDEF</code>&#x201D; (rather than
      &#x201C;<code class="Li">abcdef</code>&#x201D;) to represent the hex
      digits, and the letter &#x2018;<code class="Li">P</code>&#x2019; (rather
      than &#x2018;<code class="Li">p</code>&#x2019;) to separate the mantissa
      and exponent.
    <p class="Pp">Note that there may be multiple valid ways to represent
        floating-point numbers in this hexadecimal format. For example,
        <code class="Li">0x1.92p+1</code>, <code class="Li">0x3.24p+0</code>,
        <code class="Li">0x6.48p-1</code>, and <code class="Li">0xc.9p-2</code>
        are all equivalent. The format chosen depends on the internal
        representation of the number, but the implementation guarantees that the
        length of the mantissa will be minimized. Zeroes are always represented
        with a mantissa of 0 (preceded by a
        &#x2018;<code class="Li">-</code>&#x2019; if appropriate) and an
        exponent of <code class="Li">+0</code>.</p>
  </dd>
  <dt id="C"><a class="permalink" href="#C"><code class="Cm">C</code></a></dt>
  <dd>Treated as <code class="Cm">c</code> with the <code class="Cm">l</code>
      (ell) modifier.</dd>
  <dt id="c~2"><a class="permalink" href="#c~2"><code class="Cm">c</code></a></dt>
  <dd>The <var class="Vt">int</var> argument is converted to an
      <var class="Vt">unsigned char</var>, and the resulting character is
      written.
    <p class="Pp">If the <code class="Cm">l</code> (ell) modifier is used, the
        <var class="Vt">wint_t</var> argument shall be converted to a
        <var class="Vt">wchar_t</var>, and the (potentially multi-byte) sequence
        representing the single wide character is written, including any shift
        sequences. If a shift sequence is used, the shift state is also restored
        to the original state after the character.</p>
  </dd>
  <dt id="S"><a class="permalink" href="#S"><code class="Cm">S</code></a></dt>
  <dd>Treated as <code class="Cm">s</code> with the <code class="Cm">l</code>
      (ell) modifier.</dd>
  <dt id="s~2"><a class="permalink" href="#s~2"><code class="Cm">s</code></a></dt>
  <dd>The <var class="Vt">char *</var> argument is expected to be a pointer to
      an array of character type (pointer to a string). Characters from the
      array are written up to (but not including) a terminating
      <code class="Dv">NUL</code> character; if a precision is specified, no
      more than the number specified are written. If a precision is given, no
      null character need be present; if the precision is not specified, or is
      greater than the size of the array, the array must contain a terminating
      <code class="Dv">NUL</code> character.
    <p class="Pp">If the <code class="Cm">l</code> (ell) modifier is used, the
        <var class="Vt">wchar_t *</var> argument is expected to be a pointer to
        an array of wide characters (pointer to a wide string). For each wide
        character in the string, the (potentially multi-byte) sequence
        representing the wide character is written, including any shift
        sequences. If any shift sequence is used, the shift state is also
        restored to the original state after the string. Wide characters from
        the array are written up to (but not including) a terminating wide
        <code class="Dv">NUL</code> character; if a precision is specified, no
        more than the number of bytes specified are written (including shift
        sequences). Partial characters are never written. If a precision is
        given, no null character need be present; if the precision is not
        specified, or is greater than the number of bytes required to render the
        multibyte representation of the string, the array must contain a
        terminating wide <code class="Dv">NUL</code> character.</p>
  </dd>
  <dt id="p"><a class="permalink" href="#p"><code class="Cm">p</code></a></dt>
  <dd>The <var class="Vt">void *</var> pointer argument is printed in
      hexadecimal (as if by &#x2018;<code class="Li">%#x</code>&#x2019; or
      &#x2018;<code class="Li">%#lx</code>&#x2019;).</dd>
  <dt id="n~2"><a class="permalink" href="#n~2"><code class="Cm">n</code></a></dt>
  <dd>The number of characters written so far is stored into the integer
      indicated by the <var class="Vt">int *</var> (or variant) pointer
      argument. No argument is converted. The <var class="Fa">format</var>
      argument must be in write-protected memory if this specifier is used; see
      <a class="Sx" href="#SECURITY_CONSIDERATIONS">SECURITY CONSIDERATIONS</a>
      below.</dd>
  <dt id="_~2"><a class="permalink" href="#_~2"><code class="Cm">%</code></a></dt>
  <dd>A &#x2018;<code class="Li">%</code>&#x2019; is written. No argument is
      converted. The complete conversion specification is
      &#x2018;<code class="Li">%%</code>&#x2019;.</dd>
</dl>
<p class="Pp">The decimal point character is defined in the program's locale
    (category <code class="Dv">LC_NUMERIC</code>).</p>
<p class="Pp">In no case does a non-existent or small field width cause
    truncation of a numeric field; if the result of a conversion is wider than
    the field width, the field is expanded to contain the conversion result.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_VALUES"><a class="permalink" href="#RETURN_VALUES">RETURN
  VALUES</a></h1>
<p class="Pp">These functions return the number of characters printed (not
    including the trailing &#x2018;<code class="Li">\0</code>&#x2019; used to
    end output to strings), except for <code class="Fn">snprintf</code>() and
    <code class="Fn">vsnprintf</code>(), which return the number of characters
    that would have been printed if the <var class="Fa">size</var> were
    unlimited (again, not including the final
    &#x2018;<code class="Li">\0</code>&#x2019;). These functions return a
    negative value if an error occurs.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">To print a date and time in the form
    &#x201C;<code class="Li">Sunday, July 3, 10:02</code>&#x201D;, where
    <var class="Fa">weekday</var> and <var class="Fa">month</var> are pointers
    to strings:</p>
<div class="Bd Pp Bd-indent Li">
<pre>#include &lt;stdio.h&gt;
fprintf(stdout, &quot;%s, %s %d, %.2d:%.2d\n&quot;,
	weekday, month, day, hour, min);</pre>
</div>
<p class="Pp">To print pi to five decimal places:</p>
<div class="Bd Pp Bd-indent Li">
<pre>#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
fprintf(stdout, &quot;pi = %.5f\n&quot;, 4 * atan(1.0));</pre>
</div>
<p class="Pp">To allocate a 128 byte string and print into it:</p>
<div class="Bd Pp Bd-indent Li">
<pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdarg.h&gt;
char *newfmt(const char *fmt, ...)
{
	char *p;
	va_list ap;
	if ((p = malloc(128)) == NULL)
		return (NULL);
	va_start(ap, fmt);
	(void) vsnprintf(p, 128, fmt, ap);
	va_end(ap);
	return (p);
}</pre>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="COMPATIBILITY"><a class="permalink" href="#COMPATIBILITY">COMPATIBILITY</a></h1>
<p class="Pp">The conversion formats <code class="Cm">%D</code>,
    <code class="Cm">%O</code>, and <code class="Cm">%U</code> are not standard
    and are provided only for backward compatibility. The effect of padding the
    <code class="Cm">%p</code> format with zeros (either by the
    <code class="Cm">0</code> flag or by specifying a precision), and the benign
    effect (i.e., none) of the <code class="Cm">#</code> flag on
    <code class="Cm">%n</code> and <code class="Cm">%p</code> conversions, as
    well as other nonsensical combinations such as <code class="Cm">%Ld</code>,
    are not standard; such combinations should be avoided.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ERRORS"><a class="permalink" href="#ERRORS">ERRORS</a></h1>
<p class="Pp">In addition to the errors documented for the
    <a class="Xr" href="../2/write">write(2)</a> system call, the
    <code class="Fn">printf</code>() family of functions may fail if:</p>
<dl class="Bl-tag">
  <dt id="EILSEQ">[<a class="permalink" href="#EILSEQ"><code class="Er">EILSEQ</code></a>]</dt>
  <dd>An invalid wide character code was encountered.</dd>
  <dt id="ENOMEM">[<a class="permalink" href="#ENOMEM"><code class="Er">ENOMEM</code></a>]</dt>
  <dd>Insufficient storage space is available.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><a class="Xr" href="../1/printf">printf(1)</a>,
    <a class="Xr" href="../3/printf_l">printf_l(3)</a>,
    <a class="Xr" href="../3/fmtcheck">fmtcheck(3)</a>,
    <a class="Xr" href="../3/scanf">scanf(3)</a>,
    <a class="Xr" href="../3/setlocale">setlocale(3)</a>,
    <a class="Xr" href="../3/stdarg">stdarg(3)</a>,
    <a class="Xr" href="../3/wprintf">wprintf(3)</a></p>
</section>
<section class="Sh">
<h1 class="Sh" id="STANDARDS"><a class="permalink" href="#STANDARDS">STANDARDS</a></h1>
<p class="Pp">Subject to the caveats noted in the
    <a class="Sx" href="#BUGS">BUGS</a> section below, the
    <code class="Fn">fprintf</code>(), <code class="Fn">printf</code>(),
    <code class="Fn">sprintf</code>(), <code class="Fn">vprintf</code>(),
    <code class="Fn">vfprintf</code>(), and <code class="Fn">vsprintf</code>()
    functions conform to <span class="St">ANSI X3.159-1989
    (&#x201C;ANSI&#x00A0;C89&#x201D;)</span> and <span class="St">ISO/IEC
    9899:1999 (&#x201C;ISO&#x00A0;C99&#x201D;)</span>. With the same
    reservation, the <code class="Fn">snprintf</code>() and
    <code class="Fn">vsnprintf</code>() functions conform to
    <span class="St">ISO/IEC 9899:1999 (&#x201C;ISO&#x00A0;C99&#x201D;)</span>,
    while <code class="Fn">dprintf</code>() and
    <code class="Fn">vdprintf</code>() conform to <span class="St">IEEE Std
    1003.1-2008 (&#x201C;POSIX.1&#x201D;)</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
<p class="Pp">The functions <code class="Fn">asprintf</code>() and
    <code class="Fn">vasprintf</code>() first appeared in the GNU C library.
    These were implemented by <span class="An">Peter Wemm</span>
    &lt;<a class="Mt" href="mailto:peter@FreeBSD.org">peter@FreeBSD.org</a>&gt;
    in <span class="Ux">FreeBSD 2.2</span>, but were later replaced with a
    different implementation from <span class="Ux">OpenBSD 2.3</span> by
    <span class="An">Todd C. Miller</span>
    &lt;<a class="Mt" href="mailto:Todd.Miller@courtesan.com">Todd.Miller@courtesan.com</a>&gt;.
    The <code class="Fn">dprintf</code>() and <code class="Fn">vdprintf</code>()
    functions were added in <span class="Ux">FreeBSD 8.0</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">The <code class="Nm">printf</code> family of functions do not
    correctly handle multibyte characters in the <var class="Fa">format</var>
    argument.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SECURITY_CONSIDERATIONS"><a class="permalink" href="#SECURITY_CONSIDERATIONS">SECURITY
  CONSIDERATIONS</a></h1>
<p class="Pp">The <code class="Fn">sprintf</code>() and
    <code class="Fn">vsprintf</code>() functions are easily misused in a manner
    which enables malicious users to arbitrarily change a running program's
    functionality through a buffer overflow attack. Because
    <code class="Fn">sprintf</code>() and <code class="Fn">vsprintf</code>()
    assume an infinitely long string, callers must be careful not to overflow
    the actual space; this is often hard to assure. For safety, programmers
    should use the <code class="Fn">snprintf</code>() interface instead. For
    example:</p>
<div class="Bd Pp Li">
<pre>void
foo(const char *arbitrary_string, const char *and_another)
{
	char onstack[8];

#ifdef BAD
	/*
	 * This first sprintf is bad behavior.  Do not use sprintf!
	 */
	sprintf(onstack, &quot;%s, %s&quot;, arbitrary_string, and_another);
#else
	/*
	 * The following two lines demonstrate better use of
	 * snprintf().
	 */
	snprintf(onstack, sizeof(onstack), &quot;%s, %s&quot;, arbitrary_string,
	    and_another);
#endif
}</pre>
</div>
<p class="Pp">The <code class="Fn">printf</code>() and
    <code class="Fn">sprintf</code>() family of functions are also easily
    misused in a manner allowing malicious users to arbitrarily change a running
    program's functionality by either causing the program to print potentially
    sensitive data &#x201C;left on the stack&#x201D;, or causing it to generate
    a memory fault or bus error by dereferencing an invalid pointer.</p>
<p class="Pp"><code class="Cm">%n</code> can be used to write arbitrary data to
    potentially carefully-selected addresses. Programmers are therefore strongly
    advised to never pass untrusted strings as the <var class="Fa">format</var>
    argument, as an attacker can put format specifiers in the string to mangle
    your stack, leading to a possible security hole. This holds true even if the
    string was built using a function like <code class="Fn">snprintf</code>(),
    as the resulting string may still contain user-supplied conversion
    specifiers for later interpolation by <code class="Fn">printf</code>(). For
    this reason, a <var class="Fa">format</var> argument containing
    <code class="Cm">%n</code> is assumed to be untrustworthy if located in
    writable memory (i.e. memory with protection PROT_WRITE; see
    <a class="Xr" href="../2/mprotect">mprotect(2)</a>) and any attempt to use
    such an argument is fatal. Practically, this means that
    <code class="Cm">%n</code> is permitted in literal
    <var class="Fa">format</var> strings but disallowed in
    <var class="Fa">format</var> strings located in normal stack- or
    heap-allocated memory.</p>
<p class="Pp">Always use the proper secure idiom:</p>
<p class="Pp"></p>
<div class="Bd Bd-indent"><code class="Li">snprintf(buffer, sizeof(buffer),
  &quot;%s&quot;, string);</code></div>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">December 2, 2009</td>
    <td class="foot-os">macOS 13.4</td>
  </tr>
</table>
</body>
</html>

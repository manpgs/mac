<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
  	$NetBSD: editline.3,v 1.77 2012/09/11 20:29:58 christos Exp $
  
   Copyright (c) 1997-2003 The NetBSD Foundation, Inc.
   All rights reserved.
  
   This file was contributed to The NetBSD Foundation by Luke Mewburn.
  
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:
   1. Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
   2. Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
  
   THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
   ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
   TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
   BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   POSSIBILITY OF SUCH DAMAGE.
   -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>EDITLINE(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">EDITLINE(3)</td>
    <td class="head-vol">Library Functions Manual</td>
    <td class="head-rtitle">EDITLINE(3)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp"><code class="Nm">editline</code>, <code class="Nm">el_init</code>,
    <code class="Nm">el_end</code>, <code class="Nm">el_reset</code>,
    <code class="Nm">el_gets</code>, <code class="Nm">el_wgets</code>,
    <code class="Nm">el_getc</code>, <code class="Nm">el_wgetc</code>,
    <code class="Nm">el_push</code>, <code class="Nm">el_wpush</code>,
    <code class="Nm">el_parse</code>, <code class="Nm">el_wparse</code>,
    <code class="Nm">el_set</code>, <code class="Nm">el_wset</code>,
    <code class="Nm">el_get</code>, <code class="Nm">el_wget</code>,
    <code class="Nm">el_source</code>, <code class="Nm">el_resize</code>,
    <code class="Nm">el_line</code>, <code class="Nm">el_wline</code>,
    <code class="Nm">el_insertstr</code>, <code class="Nm">el_winsertstr</code>,
    <code class="Nm">el_deletestr</code>, <code class="Nm">el_wdeletestr</code>,
    <code class="Nm">history_init</code>, <code class="Nm">history_winit</code>,
    <code class="Nm">history_end</code>, <code class="Nm">history_wend</code>,
    <code class="Nm">history</code>, <code class="Nm">history_w</code>,
    <code class="Nm">tok_init</code>, <code class="Nm">tok_winit</code>,
    <code class="Nm">tok_end</code>, <code class="Nm">tok_wend</code>,
    <code class="Nm">tok_reset</code>, <code class="Nm">tok_wreset</code>,
    <code class="Nm">tok_line</code>, <code class="Nm">tok_wline</code>,
    <code class="Nm">tok_str</code> <code class="Nm">tok_wstr</code> &#x2014;
    <span class="Nd">line editor, history and tokenization functions</span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="LIBRARY"><a class="permalink" href="#LIBRARY">LIBRARY</a></h1>
<p class="Pp"><span class="Lb">Command Line Editor Library (libedit,
    -ledit)</span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp"><code class="In">#include
    &lt;<a class="In">histedit.h</a>&gt;</code></p>
<p class="Pp"><var class="Ft">EditLine *</var>
  <br/>
  <code class="Fn">el_init</code>(<var class="Fa" style="white-space: nowrap;">const
    char *prog</var>, <var class="Fa" style="white-space: nowrap;">FILE
    *fin</var>, <var class="Fa" style="white-space: nowrap;">FILE *fout</var>,
    <var class="Fa" style="white-space: nowrap;">FILE *ferr</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">el_end</code>(<var class="Fa" style="white-space: nowrap;">EditLine
    *e</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">el_reset</code>(<var class="Fa" style="white-space: nowrap;">EditLine
    *e</var>);</p>
<p class="Pp"><var class="Ft">const char *</var>
  <br/>
  <code class="Fn">el_gets</code>(<var class="Fa" style="white-space: nowrap;">EditLine
    *e</var>, <var class="Fa" style="white-space: nowrap;">int
  *count</var>);</p>
<p class="Pp"><var class="Ft">const wchar_t *</var>
  <br/>
  <code class="Fn">el_wgets</code>(<var class="Fa" style="white-space: nowrap;">EditLine
    *e</var>, <var class="Fa" style="white-space: nowrap;">int
  *count</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">el_getc</code>(<var class="Fa" style="white-space: nowrap;">EditLine
    *e</var>, <var class="Fa" style="white-space: nowrap;">char *ch</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">el_wgetc</code>(<var class="Fa" style="white-space: nowrap;">EditLine
    *e</var>, <var class="Fa" style="white-space: nowrap;">wchar_t
  *ch</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">el_push</code>(<var class="Fa" style="white-space: nowrap;">EditLine
    *e</var>, <var class="Fa" style="white-space: nowrap;">const char
    *str</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">el_wpush</code>(<var class="Fa" style="white-space: nowrap;">EditLine
    *e</var>, <var class="Fa" style="white-space: nowrap;">const wchar_t
    *str</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">el_parse</code>(<var class="Fa" style="white-space: nowrap;">EditLine
    *e</var>, <var class="Fa" style="white-space: nowrap;">int argc</var>,
    <var class="Fa" style="white-space: nowrap;">const char *argv[]</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">el_wparse</code>(<var class="Fa" style="white-space: nowrap;">EditLine
    *e</var>, <var class="Fa" style="white-space: nowrap;">int argc</var>,
    <var class="Fa" style="white-space: nowrap;">const wchar_t
  *argv[]</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">el_set</code>(<var class="Fa" style="white-space: nowrap;">EditLine
    *e</var>, <var class="Fa" style="white-space: nowrap;">int op</var>,
    <var class="Fa" style="white-space: nowrap;">...</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">el_wset</code>(<var class="Fa" style="white-space: nowrap;">EditLine
    *e</var>, <var class="Fa" style="white-space: nowrap;">int op</var>,
    <var class="Fa" style="white-space: nowrap;">...</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">el_get</code>(<var class="Fa" style="white-space: nowrap;">EditLine
    *e</var>, <var class="Fa" style="white-space: nowrap;">int op</var>,
    <var class="Fa" style="white-space: nowrap;">...</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">el_wget</code>(<var class="Fa" style="white-space: nowrap;">EditLine
    *e</var>, <var class="Fa" style="white-space: nowrap;">int op</var>,
    <var class="Fa" style="white-space: nowrap;">...</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">el_source</code>(<var class="Fa" style="white-space: nowrap;">EditLine
    *e</var>, <var class="Fa" style="white-space: nowrap;">const char
    *file</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">el_resize</code>(<var class="Fa" style="white-space: nowrap;">EditLine
    *e</var>);</p>
<p class="Pp"><var class="Ft">const LineInfo *</var>
  <br/>
  <code class="Fn">el_line</code>(<var class="Fa" style="white-space: nowrap;">EditLine
    *e</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">el_insertstr</code>(<var class="Fa" style="white-space: nowrap;">EditLine
    *e</var>, <var class="Fa" style="white-space: nowrap;">const char
    *str</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">el_winsertstr</code>(<var class="Fa" style="white-space: nowrap;">EditLine
    *e</var>, <var class="Fa" style="white-space: nowrap;">const wchar_t
    *str</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">el_deletestr</code>(<var class="Fa" style="white-space: nowrap;">EditLine
    *e</var>, <var class="Fa" style="white-space: nowrap;">int count</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">el_wdeletestr</code>(<var class="Fa" style="white-space: nowrap;">EditLine
    *e</var>, <var class="Fa" style="white-space: nowrap;">int count</var>);</p>
<p class="Pp"><var class="Ft">History *</var>
  <br/>
  <code class="Fn">history_init</code>();</p>
<p class="Pp"><var class="Ft">HistoryW *</var>
  <br/>
  <code class="Fn">history_winit</code>();</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">history_end</code>(<var class="Fa" style="white-space: nowrap;">History
    *h</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">history_wend</code>(<var class="Fa" style="white-space: nowrap;">HistoryW
    *h</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">history</code>(<var class="Fa" style="white-space: nowrap;">History
    *h</var>, <var class="Fa" style="white-space: nowrap;">HistEvent *ev</var>,
    <var class="Fa" style="white-space: nowrap;">int op</var>,
    <var class="Fa" style="white-space: nowrap;">...</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">history_w</code>(<var class="Fa" style="white-space: nowrap;">HistoryW
    *h</var>, <var class="Fa" style="white-space: nowrap;">HistEventW *ev</var>,
    <var class="Fa" style="white-space: nowrap;">int op</var>,
    <var class="Fa" style="white-space: nowrap;">...</var>);</p>
<p class="Pp"><var class="Ft">Tokenizer *</var>
  <br/>
  <code class="Fn">tok_init</code>(<var class="Fa" style="white-space: nowrap;">const
    char *IFS</var>);</p>
<p class="Pp"><var class="Ft">TokenizerW *</var>
  <br/>
  <code class="Fn">tok_winit</code>(<var class="Fa" style="white-space: nowrap;">const
    wchar_t *IFS</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">tok_end</code>(<var class="Fa" style="white-space: nowrap;">Tokenizer
    *t</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">tok_wend</code>(<var class="Fa" style="white-space: nowrap;">TokenizerW
    *t</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">tok_reset</code>(<var class="Fa" style="white-space: nowrap;">Tokenizer
    *t</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">tok_wreset</code>(<var class="Fa" style="white-space: nowrap;">TokenizerW
    *t</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">tok_line</code>(<var class="Fa" style="white-space: nowrap;">Tokenizer
    *t</var>, <var class="Fa" style="white-space: nowrap;">const LineInfo
    *li</var>, <var class="Fa" style="white-space: nowrap;">int *argc</var>,
    <var class="Fa" style="white-space: nowrap;">const char **argv[]</var>,
    <var class="Fa" style="white-space: nowrap;">int *cursorc</var>,
    <var class="Fa" style="white-space: nowrap;">int *cursoro</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">tok_wline</code>(<var class="Fa" style="white-space: nowrap;">TokenizerW
    *t</var>, <var class="Fa" style="white-space: nowrap;">const LineInfoW
    *li</var>, <var class="Fa" style="white-space: nowrap;">int *argc</var>,
    <var class="Fa" style="white-space: nowrap;">const wchar_t **argv[]</var>,
    <var class="Fa" style="white-space: nowrap;">int *cursorc</var>,
    <var class="Fa" style="white-space: nowrap;">int *cursoro</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">tok_str</code>(<var class="Fa" style="white-space: nowrap;">Tokenizer
    *t</var>, <var class="Fa" style="white-space: nowrap;">const char
    *str</var>, <var class="Fa" style="white-space: nowrap;">int *argc</var>,
    <var class="Fa" style="white-space: nowrap;">const char **argv[]</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">tok_wstr</code>(<var class="Fa" style="white-space: nowrap;">TokenizerW
    *t</var>, <var class="Fa" style="white-space: nowrap;">const wchar_t
    *str</var>, <var class="Fa" style="white-space: nowrap;">int *argc</var>,
    <var class="Fa" style="white-space: nowrap;">const wchar_t
  **argv[]</var>);</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The <code class="Nm">editline</code> library provides generic line
    editing, history and tokenization functions, similar to those found in
    <a class="Xr" href="../1/sh">sh(1)</a>.</p>
<p class="Pp">These functions are available in the
    <code class="Nm">libedit</code> library (which needs the
    <code class="Nm">libtermcap</code> library). Programs should be linked with
    <code class="Fl">-ledit</code> <code class="Fl">-ltermcap</code>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LINE_EDITING_FUNCTIONS"><a class="permalink" href="#LINE_EDITING_FUNCTIONS">LINE
  EDITING FUNCTIONS</a></h1>
<p class="Pp">The line editing functions use a common data structure,
    <var class="Fa">EditLine</var>, which is created by
    <a class="permalink" href="#el_init"><code class="Fn" id="el_init">el_init</code></a>()
    and freed by
    <a class="permalink" href="#el_end"><code class="Fn" id="el_end">el_end</code></a>().</p>
<p class="Pp">The wide-character functions behave the same way as their narrow
    counterparts.</p>
<p class="Pp">The following functions are available:</p>
<dl class="Bl-tag">
  <dt id="el_init~2"><a class="permalink" href="#el_init~2"><code class="Fn">el_init</code></a>()</dt>
  <dd>Initialise the line editor, and return a data structure to be used by all
      other line editing functions. <var class="Fa">prog</var> is the name of
      the invoking program, used when reading the
      <a class="Xr" href="../5/editrc">editrc(5)</a> file to determine which
      settings to use. <var class="Fa">fin</var>, <var class="Fa">fout</var> and
      <var class="Fa">ferr</var> are the input, output, and error streams
      (respectively) to use. In this documentation, references to &#x201C;the
      tty&#x201D; are actually to this input/output stream combination.</dd>
  <dt id="el_end~2"><a class="permalink" href="#el_end~2"><code class="Fn">el_end</code></a>()</dt>
  <dd>Clean up and finish with <var class="Fa">e</var>, assumed to have been
      created with <code class="Fn">el_init</code>().</dd>
  <dt id="el_reset"><a class="permalink" href="#el_reset"><code class="Fn">el_reset</code></a>()</dt>
  <dd>Reset the tty and the parser. This should be called after an error which
      may have upset the tty's state.</dd>
  <dt><code class="Fn">el_gets</code>()</dt>
  <dd>Read a line from the tty. <var class="Fa">count</var> is modified to
      contain the number of characters read. Returns the line read if
      successful, or <code class="Dv">NULL</code> if no characters were read or
      if an error occurred. If an error occurred, <var class="Fa">count</var> is
      set to -1 and <code class="Dv">errno</code> contains the error code that
      caused it. The return value may not remain valid across calls to
      <code class="Fn">el_gets</code>() and must be copied if the data is to be
      retained.</dd>
  <dt id="el_getc"><a class="permalink" href="#el_getc"><code class="Fn">el_getc</code></a>()</dt>
  <dd>Read a character from the tty. <var class="Fa">ch</var> is modified to
      contain the character read. Returns the number of characters read if
      successful, -1 otherwise, in which case <code class="Dv">errno</code> can
      be inspected for the cause.</dd>
  <dt id="el_push"><a class="permalink" href="#el_push"><code class="Fn">el_push</code></a>()</dt>
  <dd>Pushes <var class="Fa">str</var> back onto the input stream. This is used
      by the macro expansion mechanism. Refer to the description of
      <code class="Ic">bind</code> <code class="Fl">-s</code> in
      <a class="Xr" href="../5/editrc">editrc(5)</a> for more information.</dd>
  <dt><code class="Fn">el_parse</code>()</dt>
  <dd>Parses the <var class="Fa">argv</var> array (which is
      <var class="Fa">argc</var> elements in size) to execute builtin
      <code class="Nm">editline</code> commands. If the command is prefixed with
      &#x201C;prog&#x201D;: then <code class="Fn">el_parse</code>() will only
      execute the command if &#x201C;prog&#x201D; matches the
      <var class="Fa">prog</var> argument supplied to
      <code class="Fn">el_init</code>(). The return value is -1 if the command
      is unknown, 0 if there was no error or &#x201C;prog&#x201D; didn't match,
      or 1 if the command returned an error. Refer to
      <a class="Xr" href="../5/editrc">editrc(5)</a> for more information.</dd>
  <dt><code class="Fn">el_set</code>()</dt>
  <dd>Set <code class="Nm">editline</code> parameters. <var class="Fa">op</var>
      determines which parameter to set, and each operation has its own
      parameter list.
    <p class="Pp">The following values for <var class="Fa">op</var> are
        supported, along with the required argument list:</p>
    <dl class="Bl-tag">
      <dt id="EL_PROMPT"><a class="permalink" href="#EL_PROMPT"><code class="Dv">EL_PROMPT</code></a>,
        <var class="Fa">char *(*f)(EditLine *)</var></dt>
      <dd>Define prompt printing function as <var class="Fa">f</var>, which is
          to return a string that contains the prompt.</dd>
      <dt id="EL_PROMPT_ESC"><a class="permalink" href="#EL_PROMPT_ESC"><code class="Dv">EL_PROMPT_ESC</code></a>,
        <var class="Fa">char *(*f)(EditLine *)</var>, <var class="Fa">char
        c</var></dt>
      <dd>Same as <code class="Dv">EL_PROMPT</code>, but the
          <var class="Fa">c</var> argument indicates the start/stop literal
          prompt character.
        <p class="Pp">If a start/stop literal character is found in the prompt,
            the character itself is not printed, but characters after it are
            printed directly to the terminal without affecting the state of the
            current line. A subsequent second start/stop literal character ends
            this behavior. This is typically used to embed literal escape
            sequences that change the color/style of the terminal in the prompt.
            <code class="Dv">0</code> unsets it.</p>
      </dd>
      <dt id="EL_REFRESH"><a class="permalink" href="#EL_REFRESH"><code class="Dv">EL_REFRESH</code></a></dt>
      <dd>Re-display the current line on the next terminal line.</dd>
      <dt id="EL_RPROMPT"><a class="permalink" href="#EL_RPROMPT"><code class="Dv">EL_RPROMPT</code></a>,
        <var class="Fa">char *(*f)(EditLine *)</var></dt>
      <dd>Define right side prompt printing function as <var class="Fa">f</var>,
          which is to return a string that contains the prompt.</dd>
      <dt id="EL_RPROMPT_ESC"><a class="permalink" href="#EL_RPROMPT_ESC"><code class="Dv">EL_RPROMPT_ESC</code></a>,
        <var class="Fa">char *(*f)(EditLine *)</var>, <var class="Fa">char
        c</var></dt>
      <dd>Define the right prompt printing function but with a literal escape
          character.</dd>
      <dt id="EL_TERMINAL"><a class="permalink" href="#EL_TERMINAL"><code class="Dv">EL_TERMINAL</code></a>,
        <var class="Fa">const char *type</var></dt>
      <dd>Define terminal type of the tty to be <var class="Fa">type</var>, or
          to <code class="Ev">TERM</code> if <var class="Fa">type</var> is
          <code class="Dv">NULL</code>.</dd>
      <dt id="EL_EDITOR"><a class="permalink" href="#EL_EDITOR"><code class="Dv">EL_EDITOR</code></a>,
        <var class="Fa">const char *mode</var></dt>
      <dd>Set editing mode to <var class="Fa">mode</var>, which must be one of
          &#x201C;emacs&#x201D; or &#x201C;vi&#x201D;.</dd>
      <dt id="EL_SIGNAL"><a class="permalink" href="#EL_SIGNAL"><code class="Dv">EL_SIGNAL</code></a>,
        <var class="Fa">int flag</var></dt>
      <dd>If <var class="Fa">flag</var> is non-zero,
          <code class="Nm">editline</code> will install its own signal handler
          for the following signals when reading command input:
          <code class="Dv">SIGCONT</code>, <code class="Dv">SIGHUP</code>,
          <code class="Dv">SIGINT</code>, <code class="Dv">SIGQUIT</code>,
          <code class="Dv">SIGSTOP</code>, <code class="Dv">SIGTERM</code>,
          <code class="Dv">SIGTSTP</code>, and <code class="Dv">SIGWINCH</code>.
          Otherwise, the current signal handlers will be used.</dd>
      <dt id="EL_BIND"><a class="permalink" href="#EL_BIND"><code class="Dv">EL_BIND</code></a>,
        <var class="Fa">const char *</var>, <var class="Fa">...</var>,
        <code class="Dv">NULL</code></dt>
      <dd>Perform the <code class="Ic">bind</code> builtin command. Refer to
          <a class="Xr" href="../5/editrc">editrc(5)</a> for more
        information.</dd>
      <dt id="EL_ECHOTC"><a class="permalink" href="#EL_ECHOTC"><code class="Dv">EL_ECHOTC</code></a>,
        <var class="Fa">const char *</var>, <var class="Fa">...</var>,
        <code class="Dv">NULL</code></dt>
      <dd>Perform the <code class="Ic">echotc</code> builtin command. Refer to
          <a class="Xr" href="../5/editrc">editrc(5)</a> for more
        information.</dd>
      <dt id="EL_SETTC"><a class="permalink" href="#EL_SETTC"><code class="Dv">EL_SETTC</code></a>,
        <var class="Fa">const char *</var>, <var class="Fa">...</var>,
        <code class="Dv">NULL</code></dt>
      <dd>Perform the <code class="Ic">settc</code> builtin command. Refer to
          <a class="Xr" href="../5/editrc">editrc(5)</a> for more
        information.</dd>
      <dt id="EL_SETTY"><a class="permalink" href="#EL_SETTY"><code class="Dv">EL_SETTY</code></a>,
        <var class="Fa">const char *</var>, <var class="Fa">...</var>,
        <code class="Dv">NULL</code></dt>
      <dd>Perform the <code class="Ic">setty</code> builtin command. Refer to
          <a class="Xr" href="../5/editrc">editrc(5)</a> for more
        information.</dd>
      <dt id="EL_TELLTC"><a class="permalink" href="#EL_TELLTC"><code class="Dv">EL_TELLTC</code></a>,
        <var class="Fa">const char *</var>, <var class="Fa">...</var>,
        <code class="Dv">NULL</code></dt>
      <dd>Perform the <code class="Ic">telltc</code> builtin command. Refer to
          <a class="Xr" href="../5/editrc">editrc(5)</a> for more
        information.</dd>
      <dt id="EL_ADDFN"><a class="permalink" href="#EL_ADDFN"><code class="Dv">EL_ADDFN</code></a>,
        <var class="Fa">const char *name</var>, <var class="Fa">const char
        *help</var>, <var class="Fa">unsigned char (*func)(EditLine *e, int
        ch)</var></dt>
      <dd>Add a user defined function,
          <a class="permalink" href="#func"><code class="Fn" id="func">func</code></a>(),
          referred to as <var class="Fa">name</var> which is invoked when a key
          which is bound to <var class="Fa">name</var> is entered.
          <var class="Fa">help</var> is a description of
          <var class="Fa">name</var>. At invocation time,
          <var class="Fa">ch</var> is the key which caused the invocation. The
          return value of <code class="Fn">func</code>() should be one of:
        <dl class="Bl-tag">
          <dt id="CC_NORM"><a class="permalink" href="#CC_NORM"><code class="Dv">CC_NORM</code></a></dt>
          <dd>Add a normal character.</dd>
          <dt id="CC_NEWLINE"><a class="permalink" href="#CC_NEWLINE"><code class="Dv">CC_NEWLINE</code></a></dt>
          <dd>End of line was entered.</dd>
          <dt id="CC_EOF"><a class="permalink" href="#CC_EOF"><code class="Dv">CC_EOF</code></a></dt>
          <dd>EOF was entered.</dd>
          <dt id="CC_ARGHACK"><a class="permalink" href="#CC_ARGHACK"><code class="Dv">CC_ARGHACK</code></a></dt>
          <dd>Expecting further command input as arguments, do nothing
            visually.</dd>
          <dt id="CC_REFRESH"><a class="permalink" href="#CC_REFRESH"><code class="Dv">CC_REFRESH</code></a></dt>
          <dd>Refresh display.</dd>
          <dt id="CC_REFRESH_BEEP"><a class="permalink" href="#CC_REFRESH_BEEP"><code class="Dv">CC_REFRESH_BEEP</code></a></dt>
          <dd>Refresh display, and beep.</dd>
          <dt id="CC_CURSOR"><a class="permalink" href="#CC_CURSOR"><code class="Dv">CC_CURSOR</code></a></dt>
          <dd>Cursor moved, so update and perform
              <code class="Dv">CC_REFRESH</code>.</dd>
          <dt id="CC_REDISPLAY"><a class="permalink" href="#CC_REDISPLAY"><code class="Dv">CC_REDISPLAY</code></a></dt>
          <dd>Redisplay entire input line. This is useful if a key binding
              outputs extra information.</dd>
          <dt id="CC_ERROR"><a class="permalink" href="#CC_ERROR"><code class="Dv">CC_ERROR</code></a></dt>
          <dd>An error occurred. Beep, and flush tty.</dd>
          <dt id="CC_FATAL"><a class="permalink" href="#CC_FATAL"><code class="Dv">CC_FATAL</code></a></dt>
          <dd>Fatal error, reset tty to known state.</dd>
        </dl>
      </dd>
      <dt id="EL_HIST"><a class="permalink" href="#EL_HIST"><code class="Dv">EL_HIST</code></a>,
        <var class="Fa">History *(*func)(History *, int op, ...)</var>,
        <var class="Fa">const char *ptr</var></dt>
      <dd>Defines which history function to use, which is usually
          <code class="Fn">history</code>(). <var class="Fa">ptr</var> should be
          the value returned by <code class="Fn">history_init</code>().</dd>
      <dt id="EL_EDITMODE"><a class="permalink" href="#EL_EDITMODE"><code class="Dv">EL_EDITMODE</code></a>,
        <var class="Fa">int flag</var></dt>
      <dd>If <var class="Fa">flag</var> is non-zero, editing is enabled (the
          default). Note that this is only an indication, and does not affect
          the operation of <code class="Nm">editline</code>. At this time, it is
          the caller's responsibility to check this (using
          <code class="Fn">el_get</code>()) to determine if editing should be
          enabled or not.</dd>
      <dt id="EL_UNBUFFERED"><a class="permalink" href="#EL_UNBUFFERED"><code class="Dv">EL_UNBUFFERED</code></a>,
        <var class="Fa">int flag</var></dt>
      <dd>If <var class="Fa">flag</var> is zero, unbuffered mode is disabled
          (the default). In unbuffered mode, <code class="Fn">el_gets</code>()
          will return immediately after processing a single character.</dd>
      <dt id="EL_GETCFN"><a class="permalink" href="#EL_GETCFN"><code class="Dv">EL_GETCFN</code></a>,
        <var class="Fa">int (*f)(EditLine *, char *c)</var></dt>
      <dd>Define the character reading function as <var class="Fa">f</var>,
          which is to return the number of characters read and store them in
          <var class="Fa">c</var>. This function is called internally by
          <code class="Fn">el_gets</code>() and
          <code class="Fn">el_getc</code>(). The builtin function can be set or
          restored with the special function name
          &#x201C;<code class="Dv">EL_BUILTIN_GETCFN</code>&#x201D;.</dd>
      <dt id="EL_CLIENTDATA"><a class="permalink" href="#EL_CLIENTDATA"><code class="Dv">EL_CLIENTDATA</code></a>,
        <var class="Fa">void *data</var></dt>
      <dd>Register <var class="Fa">data</var> to be associated with this
          EditLine structure. It can be retrieved with the corresponding
          <code class="Fn">el_get</code>() call.</dd>
      <dt id="EL_SETFP"><a class="permalink" href="#EL_SETFP"><code class="Dv">EL_SETFP</code></a>,
        <var class="Fa">int fd</var>, <var class="Fa">FILE *fp</var></dt>
      <dd>Set the current <code class="Nm">editline</code> file pointer for
          &#x201C;input&#x201D; <var class="Fa">fd</var> =
          <code class="Dv">0</code>, &#x201C;output&#x201D;
          <var class="Fa">fd</var> = <code class="Dv">1</code>, or
          &#x201C;error&#x201D; <var class="Fa">fd</var> =
          <code class="Dv">2</code> from <var class="Fa">fp</var>.</dd>
    </dl>
  </dd>
  <dt><code class="Fn">el_get</code>()</dt>
  <dd>Get <code class="Nm">editline</code> parameters. <var class="Fa">op</var>
      determines which parameter to retrieve into <var class="Fa">result</var>.
      Returns 0 if successful, -1 otherwise.
    <p class="Pp">The following values for <var class="Fa">op</var> are
        supported, along with actual type of <var class="Fa">result</var>:</p>
    <dl class="Bl-tag">
      <dt id="EL_PROMPT~2"><a class="permalink" href="#EL_PROMPT~2"><code class="Dv">EL_PROMPT</code></a>,
        <var class="Fa">char *(*f)(EditLine *)</var>, <var class="Fa">char
        *c</var></dt>
      <dd>Return a pointer to the function that displays the prompt in
          <var class="Fa">f</var>. If <var class="Fa">c</var> is not
          <code class="Dv">NULL</code>, return the start/stop literal prompt
          character in it.</dd>
      <dt id="EL_RPROMPT~2"><a class="permalink" href="#EL_RPROMPT~2"><code class="Dv">EL_RPROMPT</code></a>,
        <var class="Fa">char *(*f)(EditLine *)</var>, <var class="Fa">char
        *c</var></dt>
      <dd>Return a pointer to the function that displays the prompt in
          <var class="Fa">f</var>. If <var class="Fa">c</var> is not
          <code class="Dv">NULL</code>, return the start/stop literal prompt
          character in it.</dd>
      <dt id="EL_EDITOR~2"><a class="permalink" href="#EL_EDITOR~2"><code class="Dv">EL_EDITOR</code></a>,
        <var class="Fa">const char **</var></dt>
      <dd>Return the name of the editor, which will be one of
          &#x201C;emacs&#x201D; or &#x201C;vi&#x201D;.</dd>
      <dt id="EL_GETTC"><a class="permalink" href="#EL_GETTC"><code class="Dv">EL_GETTC</code></a>,
        <var class="Fa">const char *name</var>, <var class="Fa">void
        *value</var></dt>
      <dd>Return non-zero if <var class="Fa">name</var> is a valid
          <a class="Xr" href="../5/termcap">termcap(5)</a> capability and set
          <var class="Fa">value</var> to the current value of that
        capability.</dd>
      <dt id="EL_SIGNAL~2"><a class="permalink" href="#EL_SIGNAL~2"><code class="Dv">EL_SIGNAL</code></a>,
        <var class="Fa">int *</var></dt>
      <dd>Return non-zero if <code class="Nm">editline</code> has installed
          private signal handlers (see
          <a class="permalink" href="#el_get"><code class="Fn" id="el_get">el_get</code></a>()
          above).</dd>
      <dt id="EL_EDITMODE~2"><a class="permalink" href="#EL_EDITMODE~2"><code class="Dv">EL_EDITMODE</code></a>,
        <var class="Fa">int *</var></dt>
      <dd>Return non-zero if editing is enabled.</dd>
      <dt id="EL_GETCFN~2"><a class="permalink" href="#EL_GETCFN~2"><code class="Dv">EL_GETCFN</code></a>,
        <var class="Fa">int (**f)(EditLine *, char *)</var></dt>
      <dd>Return a pointer to the function that read characters, which is equal
          to &#x201C;<code class="Dv">EL_BUILTIN_GETCFN</code>&#x201D; in the
          case of the default builtin function.</dd>
      <dt id="EL_CLIENTDATA~2"><a class="permalink" href="#EL_CLIENTDATA~2"><code class="Dv">EL_CLIENTDATA</code></a>,
        <var class="Fa">void **data</var></dt>
      <dd>Retrieve <var class="Fa">data</var> previously registered with the
          corresponding
          <a class="permalink" href="#el_set"><code class="Fn" id="el_set">el_set</code></a>()
          call.</dd>
      <dt id="EL_UNBUFFERED~2"><a class="permalink" href="#EL_UNBUFFERED~2"><code class="Dv">EL_UNBUFFERED</code></a>,
        <var class="Fa">int</var></dt>
      <dd>Return non-zero if unbuffered mode is enabled.</dd>
      <dt id="EL_PREP_TERM"><a class="permalink" href="#EL_PREP_TERM"><code class="Dv">EL_PREP_TERM</code></a>,
        <var class="Fa">int</var></dt>
      <dd>Sets or clears terminal editing mode.</dd>
      <dt id="EL_GETFP"><a class="permalink" href="#EL_GETFP"><code class="Dv">EL_GETFP</code></a>,
        <var class="Fa">int fd</var>, <var class="Fa">FILE **fp</var></dt>
      <dd>Return in <var class="Fa">fp</var> the current
          <code class="Nm">editline</code> file pointer for
          &#x201C;input&#x201D; <var class="Fa">fd</var> =
          <code class="Dv">0</code>, &#x201C;output&#x201D;
          <var class="Fa">fd</var> = <code class="Dv">1</code>, or
          &#x201C;error&#x201D; <var class="Fa">fd</var> =
          <code class="Dv">2</code>.</dd>
    </dl>
  </dd>
  <dt id="el_source"><a class="permalink" href="#el_source"><code class="Fn">el_source</code></a>()</dt>
  <dd>Initialise <code class="Nm">editline</code> by reading the contents of
      <var class="Fa">file</var>.
      <a class="permalink" href="#el_parse"><code class="Fn" id="el_parse">el_parse</code></a>()
      is called for each line in <var class="Fa">file</var>. If
      <var class="Fa">file</var> is <code class="Dv">NULL</code>, try
      <span class="Pa">$PWD/.editrc</span> then
      <span class="Pa">$HOME/.editrc</span>. Refer to
      <a class="Xr" href="../5/editrc">editrc(5)</a> for details on the format
      of <var class="Fa">file</var>.</dd>
  <dt id="el_resize"><a class="permalink" href="#el_resize"><code class="Fn">el_resize</code></a>()</dt>
  <dd>Must be called if the terminal size changes. If
      <code class="Dv">EL_SIGNAL</code> has been set with
      <code class="Fn">el_set</code>(), then this is done automatically.
      Otherwise, it's the responsibility of the application to call
      <code class="Fn">el_resize</code>() on the appropriate occasions.</dd>
  <dt id="el_line"><a class="permalink" href="#el_line"><code class="Fn">el_line</code></a>()</dt>
  <dd>Return the editing information for the current line in a
      <var class="Fa">LineInfo</var> structure, which is defined as follows:
    <div class="Bd Pp Li">
    <pre>typedef struct lineinfo {
    const char *buffer;    /* address of buffer */
    const char *cursor;    /* address of cursor */
    const char *lastchar;  /* address of last character */
} LineInfo;</pre>
    </div>
    <p class="Pp" id="el_gets"><var class="Fa">buffer</var> is not NUL
        terminated. This function may be called after
        <a class="permalink" href="#el_gets"><code class="Fn">el_gets</code></a>()
        to obtain the <var class="Fa">LineInfo</var> structure pertaining to
        line returned by that function, and from within user defined functions
        added with <code class="Dv">EL_ADDFN</code>.</p>
  </dd>
  <dt id="el_insertstr"><a class="permalink" href="#el_insertstr"><code class="Fn">el_insertstr</code></a>()</dt>
  <dd>Insert <var class="Fa">str</var> into the line at the cursor. Returns -1
      if <var class="Fa">str</var> is empty or won't fit, and 0 otherwise.</dd>
  <dt id="el_deletestr"><a class="permalink" href="#el_deletestr"><code class="Fn">el_deletestr</code></a>()</dt>
  <dd>Delete <var class="Fa">count</var> characters before the cursor.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY_LIST_FUNCTIONS"><a class="permalink" href="#HISTORY_LIST_FUNCTIONS">HISTORY
  LIST FUNCTIONS</a></h1>
<p class="Pp">The history functions use a common data structure,
    <var class="Fa">History</var>, which is created by
    <code class="Fn">history_init</code>() and freed by
    <code class="Fn">history_end</code>().</p>
<p class="Pp">The following functions are available:</p>
<dl class="Bl-tag">
  <dt id="history_init"><a class="permalink" href="#history_init"><code class="Fn">history_init</code></a>()</dt>
  <dd>Initialise the history list, and return a data structure to be used by all
      other history list functions.</dd>
  <dt id="history_end"><a class="permalink" href="#history_end"><code class="Fn">history_end</code></a>()</dt>
  <dd>Clean up and finish with <var class="Fa">h</var>, assumed to have been
      created with <code class="Fn">history_init</code>().</dd>
  <dt><code class="Fn">history</code>()</dt>
  <dd>Perform operation <var class="Fa">op</var> on the history list, with
      optional arguments as needed by the operation. <var class="Fa">ev</var> is
      changed accordingly to operation. The following values for
      <var class="Fa">op</var> are supported, along with the required argument
      list:
    <dl class="Bl-tag">
      <dt id="H_SETSIZE"><a class="permalink" href="#H_SETSIZE"><code class="Dv">H_SETSIZE</code></a>,
        <var class="Fa">int size</var></dt>
      <dd>Set size of history to <var class="Fa">size</var> elements.</dd>
      <dt id="H_GETSIZE"><a class="permalink" href="#H_GETSIZE"><code class="Dv">H_GETSIZE</code></a></dt>
      <dd>Get number of events currently in history.</dd>
      <dt id="H_END"><a class="permalink" href="#H_END"><code class="Dv">H_END</code></a></dt>
      <dd>Cleans up and finishes with <var class="Fa">h</var>, assumed to be
          created with <code class="Fn">history_init</code>().</dd>
      <dt id="H_CLEAR"><a class="permalink" href="#H_CLEAR"><code class="Dv">H_CLEAR</code></a></dt>
      <dd>Clear the history.</dd>
      <dt id="H_FUNC"><a class="permalink" href="#H_FUNC"><code class="Dv">H_FUNC</code></a>,
        <var class="Fa">void *ptr</var>, <var class="Fa">history_gfun_t
        first</var>, <var class="Fa">history_gfun_t next</var>,
        <var class="Fa">history_gfun_t last</var>,
        <var class="Fa">history_gfun_t prev</var>,
        <var class="Fa">history_gfun_t curr</var>,
        <var class="Fa">history_sfun_t set</var>, <var class="Fa">history_vfun_t
        clear</var>, <var class="Fa">history_efun_t enter</var>,
        <var class="Fa">history_efun_t add</var></dt>
      <dd>Define functions to perform various history operations.
          <var class="Fa">ptr</var> is the argument given to a function when
          it's invoked.</dd>
      <dt id="H_FIRST"><a class="permalink" href="#H_FIRST"><code class="Dv">H_FIRST</code></a></dt>
      <dd>Return the first element in the history.</dd>
      <dt id="H_LAST"><a class="permalink" href="#H_LAST"><code class="Dv">H_LAST</code></a></dt>
      <dd>Return the last element in the history.</dd>
      <dt id="H_PREV"><a class="permalink" href="#H_PREV"><code class="Dv">H_PREV</code></a></dt>
      <dd>Return the previous element in the history.</dd>
      <dt id="H_NEXT"><a class="permalink" href="#H_NEXT"><code class="Dv">H_NEXT</code></a></dt>
      <dd>Return the next element in the history.</dd>
      <dt id="H_CURR"><a class="permalink" href="#H_CURR"><code class="Dv">H_CURR</code></a></dt>
      <dd>Return the current element in the history.</dd>
      <dt id="H_SET"><a class="permalink" href="#H_SET"><code class="Dv">H_SET</code></a></dt>
      <dd>Set the cursor to point to the requested element.</dd>
      <dt id="H_ADD"><a class="permalink" href="#H_ADD"><code class="Dv">H_ADD</code></a>,
        <var class="Fa">const char *str</var></dt>
      <dd>Append <var class="Fa">str</var> to the current element of the
          history, or perform the <code class="Dv">H_ENTER</code> operation with
          argument <var class="Fa">str</var> if there is no current
        element.</dd>
      <dt id="H_APPEND"><a class="permalink" href="#H_APPEND"><code class="Dv">H_APPEND</code></a>,
        <var class="Fa">const char *str</var></dt>
      <dd>Append <var class="Fa">str</var> to the last new element of the
          history.</dd>
      <dt id="H_ENTER"><a class="permalink" href="#H_ENTER"><code class="Dv">H_ENTER</code></a>,
        <var class="Fa">const char *str</var></dt>
      <dd>Add <var class="Fa">str</var> as a new element to the history, and, if
          necessary, removing the oldest entry to keep the list to the created
          size. If <code class="Dv">H_SETUNIQUE</code> was has been called with
          a non-zero arguments, the element will not be entered into the history
          if its contents match the ones of the current history element. If the
          element is entered <code class="Fn">history</code>() returns 1, if it
          is ignored as a duplicate returns 0. Finally
          <code class="Fn">history</code>() returns -1 if an error
        occurred.</dd>
      <dt id="H_PREV_STR"><a class="permalink" href="#H_PREV_STR"><code class="Dv">H_PREV_STR</code></a>,
        <var class="Fa">const char *str</var></dt>
      <dd>Return the closest previous event that starts with
          <var class="Fa">str</var>.</dd>
      <dt id="H_NEXT_STR"><a class="permalink" href="#H_NEXT_STR"><code class="Dv">H_NEXT_STR</code></a>,
        <var class="Fa">const char *str</var></dt>
      <dd>Return the closest next event that starts with
          <var class="Fa">str</var>.</dd>
      <dt id="H_PREV_EVENT"><a class="permalink" href="#H_PREV_EVENT"><code class="Dv">H_PREV_EVENT</code></a>,
        <var class="Fa">int e</var></dt>
      <dd>Return the previous event numbered <var class="Fa">e</var>.</dd>
      <dt id="H_NEXT_EVENT"><a class="permalink" href="#H_NEXT_EVENT"><code class="Dv">H_NEXT_EVENT</code></a>,
        <var class="Fa">int e</var></dt>
      <dd>Return the next event numbered <var class="Fa">e</var>.</dd>
      <dt id="H_LOAD"><a class="permalink" href="#H_LOAD"><code class="Dv">H_LOAD</code></a>,
        <var class="Fa">const char *file</var></dt>
      <dd>Load the history list stored in <var class="Fa">file</var>.</dd>
      <dt id="H_SAVE"><a class="permalink" href="#H_SAVE"><code class="Dv">H_SAVE</code></a>,
        <var class="Fa">const char *file</var></dt>
      <dd>Save the history list to <var class="Fa">file</var>.</dd>
      <dt id="H_SETUNIQUE"><a class="permalink" href="#H_SETUNIQUE"><code class="Dv">H_SETUNIQUE</code></a>,
        <var class="Fa">int unique</var></dt>
      <dd>Set flag that adjacent identical event strings should not be entered
          into the history.</dd>
      <dt id="H_GETUNIQUE"><a class="permalink" href="#H_GETUNIQUE"><code class="Dv">H_GETUNIQUE</code></a></dt>
      <dd>Retrieve the current setting if adjacent identical elements should be
          entered into the history.</dd>
      <dt id="H_DEL"><a class="permalink" href="#H_DEL"><code class="Dv">H_DEL</code></a>,
        <var class="Fa">int e</var></dt>
      <dd>Delete the event numbered <var class="Fa">e</var>. This function is
          only provided for <a class="Xr" href="../3/readline">readline(3)</a>
          compatibility. The caller is responsible for free'ing the string in
          the returned <var class="Fa">HistEvent</var>.</dd>
    </dl>
    <p class="Pp" id="history"><a class="permalink" href="#history"><code class="Fn">history</code></a>()
        returns &gt;= 0 if the operation <var class="Fa">op</var> succeeds.
        Otherwise, -1 is returned and <var class="Fa">ev</var> is updated to
        contain more details about the error.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="TOKENIZATION_FUNCTIONS"><a class="permalink" href="#TOKENIZATION_FUNCTIONS">TOKENIZATION
  FUNCTIONS</a></h1>
<p class="Pp">The tokenization functions use a common data structure,
    <var class="Fa">Tokenizer</var>, which is created by
    <code class="Fn">tok_init</code>() and freed by
    <code class="Fn">tok_end</code>().</p>
<p class="Pp">The following functions are available:</p>
<dl class="Bl-tag">
  <dt id="tok_init"><a class="permalink" href="#tok_init"><code class="Fn">tok_init</code></a>()</dt>
  <dd>Initialise the tokenizer, and return a data structure to be used by all
      other tokenizer functions. <var class="Fa">IFS</var> contains the Input
      Field Separators, which defaults to &#x27E8;space&#x27E9;,
      &#x27E8;tab&#x27E9;, and &#x27E8;newline&#x27E9; if
      <code class="Dv">NULL</code>.</dd>
  <dt id="tok_end"><a class="permalink" href="#tok_end"><code class="Fn">tok_end</code></a>()</dt>
  <dd>Clean up and finish with <var class="Fa">t</var>, assumed to have been
      created with <code class="Fn">tok_init</code>().</dd>
  <dt id="tok_reset"><a class="permalink" href="#tok_reset"><code class="Fn">tok_reset</code></a>()</dt>
  <dd>Reset the tokenizer state. Use after a line has been successfully
      tokenized by <code class="Fn">tok_line</code>() or
      <code class="Fn">tok_str</code>() and before a new line is to be
      tokenized.</dd>
  <dt><code class="Fn">tok_line</code>()</dt>
  <dd>Tokenize <var class="Fa">li</var>, If successful, modify:
      <var class="Fa">argv</var> to contain the words,
      <var class="Fa">argc</var> to contain the number of words,
      <var class="Fa">cursorc</var> (if not <code class="Dv">NULL</code>) to
      contain the index of the word containing the cursor, and
      <var class="Fa">cursoro</var> (if not <code class="Dv">NULL</code>) to
      contain the offset within <var class="Fa">argv[cursorc]</var> of the
      cursor.
    <p class="Pp">Returns 0 if successful, -1 for an internal error, 1 for an
        unmatched single quote, 2 for an unmatched double quote, and 3 for a
        backslash quoted &#x27E8;newline&#x27E9;. A positive exit code indicates
        that another line should be read and tokenization attempted again.</p>
  </dd>
  <dt id="tok_str"><a class="permalink" href="#tok_str"><code class="Fn">tok_str</code></a>()</dt>
  <dd>A simpler form of
      <a class="permalink" href="#tok_line"><code class="Fn" id="tok_line">tok_line</code></a>();
      <var class="Fa">str</var> is a NUL terminated string to tokenize.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><a class="Xr" href="../1/sh">sh(1)</a>,
    <a class="Xr" href="../3/signal">signal(3)</a>,
    <a class="Xr" href="../3/termcap">termcap(3)</a>,
    <a class="Xr" href="../5/editrc">editrc(5)</a>,
    <a class="Xr" href="../5/termcap">termcap(5)</a></p>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
<p class="Pp">The <code class="Nm">editline</code> library first appeared in
    <span class="Ux">4.4BSD</span>. <code class="Dv">CC_REDISPLAY</code>
    appeared in <span class="Ux">NetBSD 1.3</span>.
    <code class="Dv">CC_REFRESH_BEEP</code>, <code class="Dv">EL_EDITMODE</code>
    and the readline emulation appeared in <span class="Ux">NetBSD 1.4</span>.
    <code class="Dv">EL_RPROMPT</code> appeared in <span class="Ux">NetBSD
    1.5</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp">The <code class="Nm">editline</code> library was written by
    Christos Zoulas. Luke Mewburn wrote this manual and implemented
    <code class="Dv">CC_REDISPLAY</code>,
    <code class="Dv">CC_REFRESH_BEEP</code>,
    <code class="Dv">EL_EDITMODE</code>, and <code class="Dv">EL_RPROMPT</code>.
    Jaromir Dolecek implemented the readline emulation. Johny Mattsson
    implemented wide-character support.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">At this time, it is the responsibility of the caller to check the
    result of the <code class="Dv">EL_EDITMODE</code> operation of
    <code class="Fn">el_get</code>() (after an
    <code class="Fn">el_source</code>() or <code class="Fn">el_parse</code>())
    to determine if <code class="Nm">editline</code> should be used for further
    input. I.e., <code class="Dv">EL_EDITMODE</code> is purely an indication of
    the result of the most recent <a class="Xr" href="../5/editrc">editrc(5)</a>
    <code class="Ic">edit</code> command.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">September 11, 2012</td>
    <td class="foot-os">macOS 14.3</td>
  </tr>
</table>
</body>
</html>

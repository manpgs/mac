<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Copyright (c) 2017 Apple Inc. All rights reserved.
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>style(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">style(3)</td>
    <td class="head-vol"><a href=".">Library Functions Manual</a></td>
    <td class="head-rtitle">style(3)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp"><code class="Nm">style</code> &#x2014; <span class="Nd">C language
    style guide for Darwin low-level userspace projects</span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This style's primary objective is to be as friendly to the code
    review process as possible. Therefore, the style aims to ensure that code
    changes to the project produce diffs that are</p>
<p class="Pp"></p>
<ul class="Bl-bullet Bd-indent Bl-compact">
  <li>small</li>
  <li>unambiguous</li>
  <li>viewable in side-by-side comparison tools</li>
</ul>
<p class="Pp">As a secondary objective, this style also aims to make code as
    clear as possible for an uninitiated programmer reading it.
    &quot;Clever&quot; syntactic shortcuts are actively discouraged in favor of
    code that is easy to understand, even if it is less concise. Coincidentally,
    this practice also tends to lend itself to generating more readable
  diffs.</p>
<p class="Pp">Like any style, consistent adherence across a project is a virtue
    in and of itself, resulting in less distraction for the reader. However,
    these guidelines should be taken as exactly that: guidelines. No style can
    be completely adhered to all the time. When you have convinced yourself that
    a deviation from the style is called for, just make sure it is for the
    greater good and maintains the style's aims of minimizing diffs and code
    complexity.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="GENERAL_PRINCIPLES"><a class="permalink" href="#GENERAL_PRINCIPLES">GENERAL
  PRINCIPLES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Vertical_space_is_a_commodity"><a class="permalink" href="#Vertical_space_is_a_commodity">Vertical
  space is a commodity</a></h2>
<p class="Pp">Scrolling vertically has always been easier than scrolling
    horizontally. Computer mouse manufacturers went so far as to dedicate
    hardware to the task of scrolling vertically when they came up with scroll
    wheels. Even on modern trackpads, while it is possible to scroll
    horizontally, it is far easier to scroll vertically. You just flick upwards.
    Do not be afraid to introduce extra lines of code if it will result in
    clearer, more human-parseable diffs when those lines are changed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Horizontal_space_is_precious"><a class="permalink" href="#Horizontal_space_is_precious">Horizontal
  space is precious</a></h2>
<p class="Pp">Scrolling horizontally is typically awkward, imprecise, and does
    not lend itself well toward reading on computers or even in print. (Academic
    journals frequently publish with two narrow columns per page to make reading
    easier, for example.) Lines should be wrapped consciously; this should not
    be left to the editor. A soft-wrapping scheme that looks good in your editor
    may not look good in someone else's editor (or with a different
    configuration for the same editor).</p>
<p class="Pp">Just as natural language comments are difficult to read in one,
    long line, so too are lines of code. Both natural languages and programming
    languages deserve conscious, deliberate wrapping to improve readability.</p>
<p class="Pp">Wrap at a column width narrow enough to accommodate side-by-side
    patch review. 80 is more likely to accommodate this, but 120 might be fine
    too. Pick a reasonable column width and stick to it. Think about the lines
    you are wrapping. If you have to wrap a line, do so in a way that is clear,
    and be willing to make changes to accommodate that (e.g. don't be afraid to
    declare a variable separately if having the declaration and assignment on
    the same line causes it to wrap in an unclear way).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Indentation_is_for_scope_indication_and_nothing_else"><a class="permalink" href="#Indentation_is_for_scope_indication_and_nothing_else">Indentation
  is for scope indication and nothing else</a></h2>
<p class="Pp">Indentation's sole purpose is to indicate scope. You should not
    use indentation to align characters on two lines of source code (beyond, of
    course, aligning the first characters of each line if they are both in the
    same scope).</p>
<p class="Pp">Given this aspect of the style, it does not particularly matter
    whether the author chooses spaces or tabs for indentation, and therefore the
    style makes no prescription (other than to pick one and stick with it).</p>
<p class="Pp">This style also has another implication: tabs and spaces should
    never appear in sequence. Each line will be a series of tabs followed by the
    first character of code. Tabs will never appear after the initial
    indentation of the line.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Don't_require_leaving_the_source_to_understand_it"><a class="permalink" href="#Don't_require_leaving_the_source_to_understand_it">Don't
  require leaving the source to understand it</a></h2>
<p class="Pp">Always think of future maintainers and document your thought
    process for them. Remember, a &quot;future maintainer&quot; might be you
    after you've forgotten why you did something. For non-trivial changes, you
    should not rely on linking to a ticket-tracking system to provide context
    and explanation for a piece of code. You should strive to ensure the reader
    of your code does not have to context-switch out of reading it in order to
    understand it.</p>
<p class="Pp">This is not to say that linking to external resources in code is
    bad, but if a change's purpose can be reasonably expressed without
    interrupting how the code reads and flows, just do it. You don't need to
    publish a whitepaper in comments, but don't just give a link or ticket
    number with no context.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Each_line_of_code_should_minimize_entropy"><a class="permalink" href="#Each_line_of_code_should_minimize_entropy">Each
  line of code should minimize entropy</a></h2>
<p class="Pp">It is actually very difficult to construct a hash comparison
    scheme that humans can use without error consistently, and there have been
    successful social engineering attacks on getting humans to read two hashes
    that are &quot;close enough&quot; as identical. This means that humans need
    a lot of help telling the difference between two lines of text.</p>
<p class="Pp" id="only">For any expression, divide it up into fundamental atoms
    (variable declarations, conditionals, etc.) and then assign each of those
    atoms to its own line of code. If you do this, when you change a single
    atom, it is immediately obvious that
    <a class="permalink" href="#only"><i class="Em">only</i></a> that atom
    changed and nothing else did. The more atoms share lines of code, the more
    likely it is that changes to them will generate complex diffs that humans
    will have difficulty understanding.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Don't_assume_a_specific_editor"><a class="permalink" href="#Don't_assume_a_specific_editor">Don't
  assume a specific editor</a></h2>
<p class="Pp">Assume people will be reading your code in a tool that you do not
    control and cannot influence. Try viewing your code in such a tool and make
    sure that it is understandable. If you follow the guidelines of this style,
    your code may appear different in another viewer (in terms of how many
    columns are required to display a single line), but its structure will
    appear identical.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SPECIFIC_GUIDELINES"><a class="permalink" href="#SPECIFIC_GUIDELINES">SPECIFIC
  GUIDELINES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Column_Width_and_Line_Wrap"><a class="permalink" href="#Column_Width_and_Line_Wrap">Column
  Width and Line Wrap</a></h2>
<p class="Pp">80 columns opens the door for a three-way, side-by-side
    comparison, but it could be impractical for a number of reasons. 120 columns
    should provide a nice balance, but really all that matters is that you pick
    a width and stick to it.</p>
<p class="Pp">When indenting a continuation line, indent over by two additional
    tabs. This visually separates the indented line from the next line, which
    may itself be indented. If there is an operator in the middle of the line,
    the operator should <i class="Em">not</i> be wrapped to the continuation
    line.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>if (some_condition &amp;&amp; some_other_condition &amp;&amp;
        yet_another_condition) {
    exit(0);
}</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>if (some_condition &amp;&amp; some_other_condition &amp;&amp;
    yet_another_condition) {
    exit(0);
}

if (some_condition &amp;&amp; some_other_condition
    &amp;&amp; yet_another_condition) {
    exit(0);
}</pre>
</div>
<p class="Pp">Notice on the good example that the
    <code class="Ic">exit(0)</code> line is made obviously distinct from the
    indented conditions above it. It's very clear on quick visual inspection
    that it's not a part of the conditional checks. The
    <code class="Ic">&amp;&amp;</code> is left on the first line because, when
    reviewing a patch to this area, it will be immediately clear to the reviewer
    that that line continues to the next one.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Avoid_prettifying_alignment"><a class="permalink" href="#Avoid_prettifying_alignment">Avoid
  prettifying alignment</a></h2>
<p class="Pp">Indentation is used only for indicating scope, so no consideration
    is given to visual alignment of equal signs, colons, etc. across multiple
    lines.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>typedef enum {
    THING0 = 0,
    THING1 = 1,
    THING_THAT_IS_REALLY_LONG = 2,
} thing_t;</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>enum {
    THING0                    = 0,
    THING1                    = 1,
    THING_THAT_IS_REALLY_LONG = 2,
};</pre>
</div>
<p class="Pp">This creates bloated diffs. If you have to re-align a ton of lines
    after you've added something longer, you get a bunch of whitespace diffs. So
    for variable declarations, enumerations, assignments, etc. just keep every
    line independent.</p>
<p class="Pp">There is one exception to this rule, and that is if you choose to
    define a flagset in terms of its raw hexadecimal values and wish to align
    them. In this case, it is a significant benefit to have these values
    aligned, and you may do so with spaces.</p>
<p class="Pp"><i class="Em">Example</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>typedef enum {
	F_INIT   = 0x00,
	F_FOO    = 0x01,
	F_BARBAZ = 0x02,
	F_CAD    = 0x04,
	F_FAD    = 0x08,
	F_FUD    = 0x10,
	F_FLAME  = 0x20,
	F_FOOD   = 0x40,
} flag_t;</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Only_one_blank_line_at_a_time"><a class="permalink" href="#Only_one_blank_line_at_a_time">Only
  one blank line at a time</a></h2>
<p class="Pp">Use blank lines to separate logical chunks of code. Do not use
    more than one.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Initialization"><a class="permalink" href="#Initialization">Initialization</a></h2>
<p class="Pp">C99 has named initializers for structures. Prefer those to
    initializing members one-by-one later on. Both structures and arrays should
    be initialized in the same style, with each element of the initializer being
    on its own line. This is so that when an element is added to or removed from
    the initialization list, that change gets its own line of diff.</p>
<p class="Pp">The exception to this is the string literal.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>struct my_struct baz = {
    .ms_foo = 1,
    .ms_bar = NULL,
};

char *strings[] = {
    &quot;string&quot;,
    &quot;other string&quot;,
};</pre>
</div>
<i class="Em">Bad</i>
<div class="Bd Pp Bd-indent Li">
<pre>struct my_struct baz = { 1, NULL };

struct my_struct baz = {
    1,
    NULL
};

struct my_struct baz = { .ms_foo = 1, .ms_bar = NULL, };</pre>
</div>
<p class="Pp">The last element of an initializer list should be followed by a
    comma. This is so that when you add a new element to that list, it's a
    one-line diff rather rather than a two-line diff (one line of diff to add
    the , to the previous-last element, and another line of diff to add the
    new-last element).</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>enum {
    THING0,
    THING1,
};

struct my_point p = {
    .x = 1,
    .y = 0,
    .z = 1,
};</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>enum {
    THING0, THING1,
};

enum {
    THING0,
    THING1
};

struct my_point p = { .x = 1, .y = 0, .z = 1 };</pre>
</div>
<p class="Pp">Note that, if your project requires ANSI C compliance, you should
    disregard this guideline, as it will not work under C89.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Avoid_function_name_overloading"><a class="permalink" href="#Avoid_function_name_overloading">Avoid
  function name overloading</a></h2>
<p class="Pp">The <a class="Xr" href="../1/clang">clang(1)</a> compiler supports
    extensions to the C language which allow for function name overloading. Name
    overloading generally leads to code which is difficult to read and
    introspect and should be avoided.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Prefix__struct__members"><a class="permalink" href="#Prefix__struct__members">Prefix
  `struct` members</a></h2>
<p class="Pp">Any <code class="Ic">struct</code> which is shared or exported
    should have a common prefix for each member. This helps avoid collisions
    with preprocessor macros.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>struct foobar {
	int64_t fb_baz;
	char *fb_string;
};</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>struct foobar {
	int64_t baz;
	char *string;
};</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Types_end_with___t_"><a class="permalink" href="#Types_end_with___t_">Types
  end with `_t`</a></h2>
<p class="Pp">A type is indicated with <code class="Ic">_t</code> at the end of
    the <code class="Ic">typedef</code>, whether the type refers to a
    <code class="Ic">struct</code>, <code class="Ic">union</code>,
    <code class="Ic">enum</code>, etc. All types are indicated this way. Types
    are in all lower-case letters.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>typedef uint64_t handle_t;
typedef enum foo foo_t;
typedef union bar bar_t;</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>typedef uint64_t Handle;
typedef enum foo foo_e;
typedef union bar bar_u;</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Use_explicitly-sized_integer_types"><a class="permalink" href="#Use_explicitly-sized_integer_types">Use
  explicitly-sized integer types</a></h2>
<p class="Pp">Avoid integer types whose names do not indicate size, such as
    <code class="Ic">int</code> or <code class="Ic">long</code>. Instead, use
    the types from <code class="Ic">stdint.h</code> (e.g.
    <code class="Ic">int64_t</code>, <code class="Ic">uint32_t</code>, etc.),
    which explicitly indicate size. You may use size-ambiguous integer types if
    an API requires it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Use__sizeof()__on_variables_rather_than_types_where_appropriate"><a class="permalink" href="#Use__sizeof()__on_variables_rather_than_types_where_appropriate">Use
  `sizeof()` on variables rather than types where appropriate</a></h2>
<p class="Pp">The <code class="Ic">sizeof()</code> operator can take both types
    and variables as arguments. Where possible and relevant, always pass a
    variable. This ensures that if the variable's type changes, the proper size
    is used automatically.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>uuid_t ident;
memcpy(ident, buff, sizeof(ident));</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>uuid_t ident;
memcpy(ident, buff, sizeof(uuid_t));</pre>
</div>
<p class="Pp" id="IMPORTANT"><a class="permalink" href="#IMPORTANT"><i class="Em">IMPORTANT</i></a>:
    When applied to a <code class="Ic">char *</code>,
    <code class="Ic">sizeof()</code> will return the width of a pointer,
    <i class="Em">not</i> the size of the string literal it points to, so take
    care to only use <a class="Xr" href="../3/strlen">strlen(3)</a> for such
    cases.</p>
<p class="Pp">Relatedly, when applied to an array variable that is a parameter
    in a function's parameter list, <code class="Ic">sizeof()</code> will return
    the width of a pointer, <i class="Em">not</i> the size of the type.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>char *string = &quot;the quick brown fox&quot;;
size_t len = strlen(string);

void
foo(uuid_t u)
{
	uuid_t u2;
	memcpy(u2, u, sizeof(uuid_t));
}</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>char *string = &quot;the quick brown fox&quot;;
size_t len = sizeof(string) - 1;

void
foo(uuid_t u)
{
	uuid_t u2;

	// sizeof(u) == sizeof(void *) in this context.
	memcpy(u2, u, sizeof(u));
}</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Functions_which_take_no_parameters_have_a_parameter_list_of__void_"><a class="permalink" href="#Functions_which_take_no_parameters_have_a_parameter_list_of__void_">Functions
  which take no parameters have a parameter list of `void`</a></h2>
<p class="Pp">In C, an empty function parameter list means that
    <a class="permalink" href="#any"><i class="Em" id="any">any</i></a> set of
    parameters is acceptable. In virtually all cases where you do this, you mean
    to have a parameter list of <code class="Ic">void</code>.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>void
foo(void)
{
    do_a_thing_without_arguments();
}</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>void
foo()
{
    do_a_thing_without_arguments();
}</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Preprocessor_macros"><a class="permalink" href="#Preprocessor_macros">Preprocessor
  macros</a></h2>
<p class="Pp">Preprocessor definitions are written in all-caps. Macros which are
    function-like may be lower-case provided they do not double-evaluate their
    arguments. Function-like macros that do double-evaluate their arguments
    should be in all-caps.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>#define FOO 1
#define halt() abort()

// Does not double-evaluate _a and _b such that max(i++, j) is safe.
#define max(_a, _b) ({ \
    typeof(_a) a1 = (_a); \
    typeof(_b) b1 = (_b); \
    (a1 &lt; b1 ? b1 : a1); \
})

// Double-evaluates _a and _b, so MAX(i++, j) is not safe.
#define MAX(_a, _b) ((_a) &lt; (_b) ? (_b) : (_a))</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>#define kFoo 1

// Double-evaluates _a and _b.
#define max(_a, _b) ((_a) &lt; (_b) ? (_b) : (_a))</pre>
</div>
<p class="Pp">Where possible, you should prefer inline functions to preprocessor
    macros, or split a macro into a preprocessor piece and an inline function
    piece.</p>
<p class="Pp"><i class="Em">Example</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>static inline void
_debug_uint64_impl(const char *name, uint64_t val)
{
    fprintf(stderr, &quot;%s = %llu\n&quot;, name, val);
}

#define debug_uint64(_v) do { \
	_debug_uint64_impl(#_v, _v); \
} while (0)</pre>
</div>
<p class="Pp">In this example, the preprocessor is used to do something that
    only the preprocessor can do: stringify the input variable's name. But once
    that work is done, the actual logging of the value is done by an inline
    function. This keeps the code much more readable.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Preprocessor_macro_parameters_should_be_distinguished"><a class="permalink" href="#Preprocessor_macro_parameters_should_be_distinguished">Preprocessor
  macro parameters should be distinguished</a></h2>
<p class="Pp">Preprocessor macro expansion can run afoul of naming collisions
    with other variables that are in the same scope as the macro being expanded.
    To help avoid such collisions, parameters to preprocessor macros should have
    a prefix, suffix or both. Another good option is to use a
    <code class="Ic">_[A-Z]</code> prefix, since it is reserved by the C
    standard and will not collide with preprocessor evaluation.</p>
<p class="Pp"><i class="Em">Example</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>#define foo2(_x_) ((_x_) * 2)
#define foo4(_x) ((_x) * 4)
#define foo8(_X) ((_X) * 8)</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Preprocessor_macro_parameters_should_always_be_evaluated"><a class="permalink" href="#Preprocessor_macro_parameters_should_always_be_evaluated">Preprocessor
  macro parameters should always be evaluated</a></h2>
<p class="Pp">When passing a parameter to a preprocessor macro, it should always
    be referred to within parentheses to force evaluation. The exception is for
    parameters intended to be string literals.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>#define add2(__x) ((__x) + 2)
#define println(__fmt, ...) printf(__fmt &quot;\n&quot;, ## __VA_ARGS__)</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>#define add2(__x) x + 2</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Preprocessor_directives_always_start_at_column_0"><a class="permalink" href="#Preprocessor_directives_always_start_at_column_0">Preprocessor
  directives always start at column 0</a></h2>
<p class="Pp">Preprocessor directives do not have scope, and therefore they
    always start at column zero.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>if (do_loop) {
	for (i = 0; i &lt; 10; i++) {
#if CONFIG_FOOBAR
		foobar(i);
#else
		foobaz(i);
#endif
	}
}</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>if (do_loop) {
	for (i = 0; i &lt; 10; i++) {
	#if CONFIG_FOOBAR
		foobar(i);
	#else
		foobaz(i);
	#endif
	}
}</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Always_reference_string_length_directly"><a class="permalink" href="#Always_reference_string_length_directly">Always
  reference string length directly</a></h2>
<p class="Pp">Do not hard-code the size of a string. Use either
    <code class="Ic">sizeof(str) - 1</code> or
    <code class="Ic">strlen(str)</code>. In the latter case,
    <a class="Xr" href="../1/clang">clang(1)</a> is smart enough to recognize
    when a constant string is being passed to
    <a class="Xr" href="../1/strlen(3)">strlen(3)</a> and replace the function
    call with the string's actual length.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>char str[] = &quot;string&quot;;
frob_string(str, sizeof(str) - 1);
frob_string(str, strlen(str));</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>char str[] = &quot;string&quot;;
frob_string(str, 6);</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Don't_pointlessly_validate_inputs"><a class="permalink" href="#Don't_pointlessly_validate_inputs">Don't
  pointlessly validate inputs</a></h2>
<p class="Pp">If you control all call sites for a function, then there is no
    point to validating the inputs to that function. If none of your call sites
    pass <code class="Ic">NULL</code>, to a pointer parameter, for example, then
    the a <code class="Ic">NULL</code> input indicates that there is state
    corruption in your address space. You may think that it's good to catch such
    corruption, but <code class="Ic">NULL</code> is just
    <a class="permalink" href="#one"><i class="Em" id="one">one</i></a> possible
    invalid pointer value. What if the invalid input is
    <code class="Ic">0x1</code>? What if it is <code class="Ic">0x2</code>?
    Should you also check for those?</p>
<p class="Pp">This kind of input checking complicates code. Because it indicates
    state corruption, the only sensible thing to do in that situation would be
    to abort. But the operating system has mechanisms in place to detect the
    reference of an invalid resource, such as virtual memory and use-after-free
    detection. There is no point to you duplicating these mechanisms.</p>
<p class="Pp" id="when">Of course, you should always validate inputs
    <a class="permalink" href="#when"><i class="Em">when they come from
    untrusted external sources</i></a> (such as a file or IPC message), but if
    the inputs only ever comes from your program, you should trust them.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>static foo_t *
get_item(foo_t *arr, size_t idx)
{
	return &amp;arr[idx];
}

int
only_call_site(foo_t *f)
{
	foo_t *arr = calloc(10, sizeof(arr[0]));
	if (!arr) {
		return errno;
	}

	*f = get_item(arr, 0);
	return 0;
}</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>static foo_t *
get_item(foo_t *arr, size_t idx)
{
	if (!arr) {
		// No point to this check since we'll abort immediately below when we
		// try to dereference `arr`. The crash report will have more than enough
		// information to diagnose the NULL pointer dereference if it ever
		// happens.
		abort();
	}
	return &amp;arr[idx];
}

int
only_call_site(foo_t *f)
{
	foo_t *arr = calloc(10, sizeof(arr[0]));
	if (!arr) {
		return errno;
	}

	*f = get_item(arr, 0);
	return 0;
}</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Abort_on_bad_API_inputs"><a class="permalink" href="#Abort_on_bad_API_inputs">Abort
  on bad API inputs</a></h2>
<p class="Pp">The C language provides precious few compile-time validation
    mechanisms, and so in many cases it is not possible to fully describe to the
    compiler the range of expected inputs for an API. So your API should
    validate input from its caller and abort on invalid input. Returning an
    error in such a case is pointless, since the caller probably isn't checking
    the return code anyway. The only sure way to get the programmer's attention
    is to abort the calling process with a helpful message. The
    <code class="Ic">os_crash</code> routine allows you to supply such a message
    that the crash reporter on Darwin will display in its crash report.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>uint8_t
foo_a_bar(uint8_t number)
{
	if (number &gt; (UINT8_MAX / 2)) {
		os_crash(&quot;number given to foo_a_bar() too large&quot;);
	}
	return (number * 2);
}</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>int
foo_a_bar(uint8_t number, uint8_t *new_number)
{
	if (number &gt; (UINT8_MAX / 2)) {
		return EINVAL;
	}
	*new_number = (number * 2);
	return 0;
}</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Don't_mingle_POSIX_return_codes_and_errors"><a class="permalink" href="#Don't_mingle_POSIX_return_codes_and_errors">Don't
  mingle POSIX return codes and errors</a></h2>
<p class="Pp">Some POSIX routines have return values that indicate whether you
    should check <code class="Ic">errno</code>, and others just return the error
    directly. While POSIX generally documents what does what pretty well, there
    are lots of SPIs scattered around the system that use both conventions and
    aren't documented at all, leaving you to spelunk through the implementation
    to find out what's what.</p>
<p class="Pp">To avoid confusion, do not re-use the same variable for the return
    codes from these functions. If an API returns a code indicating that you
    should check <code class="Ic">errno</code>, name it
    <code class="Ic">ret</code> or similar. If it returns the error directly,
    name it <code class="Ic">error</code> or similar and make it of type
    <code class="Ic">errno_t</code>. This makes it very clear to the person
    reading the code that you did the work to find out how the API worked. By
    naming the variable you store the return value in appropriately, a reader of
    your code (possibly Future You) can immediately know what's going on.</p>
<p class="Pp">If you are making new API or SPI that returns an error code, make
    it return <code class="Ic">errno_t</code> and do not use the global
    <code class="Ic">errno</code> for communicating error information.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>#include &lt;sys/types.h&gt;

errno_t error = posix_spawn(NULL, &quot;ls&quot;, NULL, NULL, argv, envp);
switch (error) {
case 0:
    // Handle success.
    break;
case EACCES:
    // Handle &quot;permission denied&quot;.
    break;
}

int ret = reboot(RB_AUTOBOOT);
if (ret == -1) {
    switch (errno) {
    case EPERM:
        // Handle &quot;permission denied&quot;.
        break;
    case EBUSY:
        // Handle &quot;reboot already in progress&quot;.
        break;
    }
}</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>int ret = posix_spawn(NULL, &quot;ls&quot;, NULL, NULL, argv, envp);
switch (error) {
case 0:
    // Handle success.
    break;
case EACCES:
    // Handle &quot;permission denied&quot;.
    break;
}

int error = reboot(RB_AUTOBOOT);
if (error == -1) {
    switch (errno) {
    case EPERM:
        // Handle &quot;permission denied&quot;.
        break;
    case EBUSY:
        // Handle &quot;reboot already in progress&quot;.
        break;
    }
}</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Avoid_complex__if__statements_and_return_distinct_error_codes"><a class="permalink" href="#Avoid_complex__if__statements_and_return_distinct_error_codes">Avoid
  complex `if` statements and return distinct error codes</a></h2>
<p class="Pp">Breaking up a single complex <code class="Ic">if</code> statement
    into multiple distinct checks is both more readable and makes it possible to
    be more granular about handling failure cases. It also leads to smaller
    diffs if one of those conditions turns out to require special handling.</p>
<p class="Pp">Complex <code class="Ic">if</code> statements are often associated
    with input validation and just returning an error code (usually
    <code class="Ic">EINVAL</code>) if any input is invalid. While deciding
    which error to return in which case is more of an art than a science, that
    doesn't mean you should just give up and return a single error every time
    there isn't an immediately obvious fit to the case you've encountered.</p>
<p class="Pp" id="likely">Ideally, every case where your routine may fail should
    be represented by a distinct error code, but this is often not practical.
    Still, you should attempt to distinguish each
    <a class="permalink" href="#likely"><i class="Em">likely</i></a> failure
    case with its own error code. The POSIX error space is fairly rich, and
    error descriptions are brief enough that they can be liberally interpreted.
    For example, <code class="Ic">ESRCH</code> can be used to apply to any
    situation where a resource could not be located, not just conditions where
    there is literally &quot;No such process&quot;.</p>
<p class="Pp">This isn't to say that you should never have compound conditions
    in an <code class="Ic">if</code> statement, but the groupings should almost
    always be small, and the grouped checks should be highly likely to require
    change as a group when change is needed.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>if (foo-&gt;f_int &gt; 10 || foo-&gt;f_int &lt; 5)
	return ERANGE;
}

if (!foo-&gt;f_uaddr) {
	return EFAULT;
}

if (foo-&gt;f_has_idx &amp;&amp; foo-&gt;f_idx &gt; 100) {
	return ERANGE;
}

if (foo-&gt;f_state != FS_INITIALIZED) {
	return EBUSY;
}</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>if (foo-&gt;f_int &gt; 10 || foo-&gt;f_int &lt; 5 || !foo-&gt;f_uaddr || (foo-&gt;f_has_idx &amp;&amp; foo-&gt;f_idx &gt; 100) ||
		foo-&gt;f_state != FS_INITIALIZED) {
	return EINVAL;
}</pre>
</div>
<p class="Pp">See <a class="Xr" href="../2/intro">intro(2)</a>,
    <code class="Ic">&lt;sys/errno.h&gt;</code>, and
    <code class="Ic">&lt;os/error.h&gt;</code> for the error codes supported on
    Darwin.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Don't_NULL-check_when_calling__free(3)_"><a class="permalink" href="#Don't_NULL-check_when_calling__free(3)_">Don't
  NULL-check when calling `free(3)`</a></h2>
<p class="Pp"><code class="Ic">NULL</code> is valid input to
    <a class="Xr" href="../3/free">free(3)</a>. It's part of the API contract.
    Armed with this knowledge, you can do things like avoid conditional memory
    calls, which are always weird.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>char buff[1024];
char *ptr = buff;
char *what2free = NULL;

if (condition) {
    ptr = malloc(8);
    what2free = ptr;
}

free(what2free);</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>char buff[1024];
char *ptr = buff;
bool did_malloc = false;

if (condition) {
    ptr = malloc(8);
    did_malloc = true;
}

if (did_malloc) {
    free(ptr);
}</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Distinguish_exported_and_non-exported_symbols"><a class="permalink" href="#Distinguish_exported_and_non-exported_symbols">Distinguish
  exported and non-exported symbols</a></h2>
<p class="Pp">Any non-exported symbols should be prefixed with a
    <code class="Ic">_</code>. Thus any <code class="Ic">static</code>
    functions, project-local interfaces, etc. should have this prefix. Exported
    symbols (API or SPI) should <i class="Em">not</i> have such a prefix.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>static const char *_thing = &quot;thing&quot;;
static void _foo(void);

void
_project_local_interface(void);</pre>
</div>
<i class="Em">Bad</i>
<div class="Bd Pp Bd-indent Li">
<pre>static const char *thing = &quot;thing&quot;;
static void foo(void);

void
project_local_interface(void);</pre>
</div>
<p class="Pp">Global variables should have a sensible prefix, preferably related
    to the project name -- e.g. globals in the
    <a class="Xr" href="../3/libxpc">libxpc(3)</a> project are prefixed with
    <code class="Ic">xpc_</code>.</p>
<p class="Pp">You may also consider declaring a global structure which contains
    all of your project's shared, unexported global state. This makes it very
    clear when code is referencing that state. Also, if your project is a
    library at the libSystem layer, this is required if you are ever to adopt
    <a class="Xr" href="../3/os_alloc_once">os_alloc_once(3)</a>.</p>
<p class="Pp"><i class="Em">Example</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>typedef struct _foobar_globals {
	uint64_t fg_global_int;
	char *fg_global_string;
} foobar_globals_t;

foobar_globals_t _g;
foobar_globals_t *g = &amp;_g;</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Distinguish_SPIs_meant_for_one_caller"><a class="permalink" href="#Distinguish_SPIs_meant_for_one_caller">Distinguish
  SPIs meant for one caller</a></h2>
<p class="Pp">Sometimes projects must create bespoke SPIs for one particular
    caller, and these SPIs are not considered suitable for general use. Append a
    suffix to these SPIs to indicate their bespokeness and the intended caller
    with <code class="Ic">_4caller</code>. For example, if you add an SPI
    specifically for IOKit, your suffix would likely be
    <code class="Ic">_4IOKit</code>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Use___if__instead_of___ifdef__where_appropriate"><a class="permalink" href="#Use___if__instead_of___ifdef__where_appropriate">Use
  `#if` instead of `#ifdef` where appropriate</a></h2>
<p class="Pp"><code class="Ic">#ifdef</code> is to check if a token is
    <a class="permalink" href="#defined"><i class="Em" id="defined">defined at
    all to anything.</i></a> <code class="Ic">#if</code> is to check the token's
    value. The C standard specifies that when a token is undefined,
    <code class="Ic">#if</code> will evaluate it as <code class="Ic">0</code>.
    When checking for features, it's almost always more appropriate to use
    <code class="Ic">#if</code> since the lack of a feature could still be
    communicated by setting the token's value to <code class="Ic">0</code>,
    which would pass the <code class="Ic">#ifdef</code> check.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Use_Function_Attributes_from___os/base.h__"><a class="permalink" href="#Use_Function_Attributes_from___os/base.h__">Use
  Function Attributes from `&lt;os/base.h&gt;`</a></h2>
<p class="Pp">If you're on Darwin, <code class="Ic">libplatform</code> defines a
    lot of nice macros for compiler attributes. Use them to decorate your
    functions. This gives the compiler lots more information so it can do fancy
    optimizations. Things like <code class="Ic">OS_NONNULL</code> let the
    compiler know that a parameter should never be <code class="Ic">NULL</code>.
    <code class="Ic">OS_WARN_RESULT</code> is great for enforcing that a caller
    always check the return value of a function.</p>
<p class="Pp"><code class="Ic">OS_MALLOC</code> lets the compiler know that the
    function returns a heap allocation, and
    <code class="Ic">OS_OBJECT_RETURNS_RETAINED</code> lets ARC know that the
    function returns an object with a reference that the caller is responsible
    for releasing.</p>
<p class="Pp" id="can">You can avoid having to decorate all your pointer
    parameters by using <code class="Ic">OS_ASSUME_NONNULL_BEGIN</code> and
    <code class="Ic">OS_ASSUME_NONNULL_END</code> and specifically annotating
    variables which <a class="permalink" href="#can"><i class="Em">can</i></a>
    be <code class="Ic">NULL</code> with the <code class="Ic">_Nullable</code>
    keyword. Either approach is acceptable.</p>
<p class="Pp">Generally, use these attributes on functions which will have
    callers who cannot view the implementation. Putting many of these attributes
    on (for example) an inline function is harmless, but the compiler can reason
    about things like <code class="Ic">OS_NONNULL</code> and infer it when it
    can view the implementation at all call sites.</p>
<p class="Pp">So as a rule of thumb, if it's in a header, decorate it
    appropriately. These attributes can also serve as nice implicit
    documentation around API and SPI. For example, if you have a decoration of
    <code class="Ic">OS_NONNULL1</code>, you don't have to spell out in the
    HeaderDoc that you can't pass <code class="Ic">NULL</code> for that
    parameter; it'll be right there in the declaration, and the compiler will
    catch attempts to do so.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Distinguish_C_function_definitions_from_declarations"><a class="permalink" href="#Distinguish_C_function_definitions_from_declarations">Distinguish
  C function definitions from declarations</a></h2>
<p class="Pp">In C, make the definition of a function findable and
    distinguishable from its declaration (if any) through regular expressions.
    This way, you can find the implementation of <code class="Ic">foo</code> by
    doing a regex search for <code class="Ic">^foo</code>, and you won't get the
    declaration as a result.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>static int foo(int bar);

int
foo(int bar)
{
    return bar;
}</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>static int foo(int bar);

int foo(int bar)
{
    return bar;
}</pre>
</div>
<p class="Pp">This has the additional benefit of allowing you to change the
    name/parameter list of a function independently of the return type. A diff
    of either will not be confused with the rest of the function signature.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Use_HeaderDoc_for_API_declarations"><a class="permalink" href="#Use_HeaderDoc_for_API_declarations">Use
  HeaderDoc for API declarations</a></h2>
<p class="Pp">Make them look nice. Include the appropriate decorations
    (including an explicit export attribute such as
    <code class="Ic">OS_EXPORT</code> so it's very, very clear that it's
    intended to be API), availability attributes, and HeaderDoc. Put this stuff
    before the function.</p>
<p class="Pp"><i class="Em">Example</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>/*!
 * @function foo
 * Returns `bar` and ignores another parameter.
 *
 * @param bar
 * The value to return.
 *
 * @param baz
 * The value to ignore.
 *
 * @result
 * The value of `bar`. This routine cannot fail.
 */
__API_AVAILABLE(macos(10.14), ios(12.0), tvos(12.0), watchos(5.0))
OS_EXPORT OS_WARN_RESULT OS_NONNULL2
int
foo(int bar, char *baz);</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Comments"><a class="permalink" href="#Comments">Comments</a></h2>
<p class="Pp">In general, use C++/C99-style comments. But there may be good
    reasons to use the classic C-style comments, such as for HeaderDoc, which
    requires them, e.g.</p>
<div class="Bd Pp Bd-indent Li">
<pre>/*!
 * Documentation
 */</pre>
</div>
<p class="Pp">Long, top-level comments may also use classic C-style
  comments.</p>
<p class="Pp">C++/C99-style comments may directly follow code on the same line
    only if they are extremely brief. Otherwise, in general, comments and code
    should not share a line.</p>
<p class="Pp">Also, do not get cute with <code class="Ic">/* */</code> comments
    and embed them within code.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>// Comment on what the loop does.
for (i = 0; i &lt; cnt; i++) {
    // some code...
}

/*
 * A top-level or very long comment.
 */

int ret = esoteric_spi(); // returns -1 on failure, does not set errno</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>//Comment

int ret = esoteric_spi(); // This SPI returns -1 on failure but does not set
    // errno, so here is a comment explaining that that really should be above
    // the line of code rather than immediately following it.

foo(arg1, /* first argument */, arg2 /* second argument */);</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="_case__and__switch__are_indented_at_the_same_level"><a class="permalink" href="#_case__and__switch__are_indented_at_the_same_level">`case`
  and `switch` are indented at the same level</a></h2>
<p class="Pp"><code class="Ic">case</code> and <code class="Ic">switch</code>
    belong at the same column indent because indentation indicates scope, and
    due to case fall-through, all cases are in the same scope -- one lower than
    the previous. (Unless you scope them explicitly with braces, but you should
    avoid doing that if at all possible.)</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>switch (thing) {
case THING1:
    exit(0);
    break;
case THING2:
    exit(1);
    break;
default:
    __builtin_unreachable();
}</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>switch (thing) {
case THING1: {
    exit(0);
    break;
}
case THING2: {
    exit(1);
    break;
}
default:
    __builtin_unreachable();
}

switch (thing) {
    case THING1:
        exit(0);
        break;
    case THING2:
        exit(1);
        break;
    default: {
        __builtin_unreachable();
    }
}</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Use_typed__enum_s"><a class="permalink" href="#Use_typed__enum_s">Use
  typed `enum`s</a></h2>
<p class="Pp">If you're declaring an <code class="Ic">enum</code>, you should
    <code class="Ic">typedef</code> it so the compiler can reason about valid
    values and know the width of the <code class="Ic">enum</code> type if
    possible. The <code class="Ic">OS_ENUM</code> macro provides the correct
    behavior for C, C++, and Objective-C.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Initialize_all_variables_and_fail_closed"><a class="permalink" href="#Initialize_all_variables_and_fail_closed">Initialize
  all variables and fail closed</a></h2>
<p class="Pp">If you pre-declare a variable before using it, initialize it to a
    sane value. If this value is something like the return value of the
    function, initialize it to a value which indicates failure of the operation.
    You should
    <a class="permalink" href="#always"><i class="Em" id="always">always</i></a>
    do this even if there are no code paths which fail to initialize the
    variable later. It's just good practice, and it gives the person reading
    your code an indication of what ranges of values the variable is expected to
    hold.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>int result = -1;

if (success) {
    result = 0;
}</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>int result;

if (success) {
    result = 0;
}</pre>
</div>
<p class="Pp" id="explicitly">Any error variable should always be initialized to
    a non-success condition. In general, consider success as something that your
    code must <a class="permalink" href="#explicitly"><i class="Em">explicitly
    declare</i></a> and that the absence of such a declaration indicates
    failure.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>int error = -1;

if (is_root()) {
    error = 0;
} else {
    error = EPERM;
}</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>int error = 0;

if (!is_root()) {
    error = EPERM;
}</pre>
</div>
<p class="Pp">Note that you may omit an initializer for a complex
    <code class="Ic">struct</code> type (such as the
    <a class="Xr" href="../2/stat">stat(2)</a> <code class="Ic">struct</code>)
    but then it is incumbent upon you to ensure that that variable is not used
    uninitialized except to populate it. For many <code class="Ic">struct</code>
    types, you can initialize them with <code class="Ic">{0}</code>. This will
    not work for structures with nested structures though. For those you can use
    <a class="Xr" href="../3/bzero">bzero(3)</a> or similar.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using__goto__is_fine"><a class="permalink" href="#Using__goto__is_fine">Using
  `goto` is fine</a></h2>
<p class="Pp"><code class="Ic">goto</code> has gotten a bad rap, but it's
    probably the best way in C to do lots of sequential error handling. You
    don't <a class="permalink" href="#have"><i class="Em" id="have">have</i></a>
    to use <code class="Ic">goto</code> if you don't want to, but if you do,
    just keep a a couple things in mind.</p>
<p class="Pp"></p>
<ul class="Bl-bullet Bd-indent Bl-compact">
  <li>Compile with <code class="Ic">-Wsometimes-uninitialized</code>. With this
      warning, <a class="Xr" href="../1/clang">clang(1)</a> will catch cases
      where a variable may be used uninitialized because a
      <code class="Ic">goto</code> skipped the initialization.</li>
  <li>Never use <code class="Ic">goto</code> as a looping construct. The C
      language has a few different control statements for looping and iteration.
      Use one of those; it's not the 70's anymore.</li>
</ul>
<p class="Pp">These guidelines make it simple to use
    <code class="Ic">goto</code> effectively while avoiding the most common
    pitfalls.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Avoid_magic_Booleans"><a class="permalink" href="#Avoid_magic_Booleans">Avoid
  magic Booleans</a></h2>
<p class="Pp">Sometimes you have to pass a parameter to a function to trigger
    some sort of behavior. Avoid using a magic Boolean for these cases. Instead,
    use an invariant that describes the behavior you are triggering.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>replace_spaces(string, REPLACE_TABS_TOO);
replace_spaces(string, REPLACE_ONLY_SPACES);</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>replace_spaces(string, true);
replace_spaces(string, false);</pre>
</div>
<p class="Pp">If you find yourself creating many such Boolean values for
    function parameters, you should seriously considering defining a set of
    flags and passing that as one parameter instead.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Spaces_around_binary_operators"><a class="permalink" href="#Spaces_around_binary_operators">Spaces
  around binary operators</a></h2>
<p class="Pp">In general, avoid code that looks crunched together, especially
    around operators. Specifically:</p>
<ul class="Bl-bullet Bd-indent Bl-compact">
  <li>Unary operators should <i class="Em">not</i> have spaces around them.</li>
  <li>Binary operators <i class="Em">should</i> have spaces around them.</li>
  <li>The ternary operator <i class="Em">should</i> have spacing around it.</li>
</ul>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>i++;
j = i + k;
k += condition ? i : j;</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>i ++;
j=i+k
k+=condition?i:j;</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Reserve_the_ternary_operator_for_trivial_cases"><a class="permalink" href="#Reserve_the_ternary_operator_for_trivial_cases">Reserve
  the ternary operator for trivial cases</a></h2>
<p class="Pp">Don't use the ternary operator to choose between complex or long
    expressions. Reserve it for very trivial cases that are highly unlikely to
    change. In general if you've found yourself putting the expressions in your
    usage of ternary operator on multiple lines, you should just be using an
    <code class="Ic">if</code> statement.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>i += condition ? j : k;</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>i += (i &lt; j &amp;&amp; j &gt; k || i == j) ? foo(bar, baz, 0, NULL) : frob(bar, 0, NULL, baz);</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Spaces_around_parentheses"><a class="permalink" href="#Spaces_around_parentheses">Spaces
  around parentheses</a></h2>
<ul class="Bl-bullet Bd-indent Bl-compact">
  <li>Put a space between the control statement and the parenthesis indicating
      its condition.</li>
  <li>Do <i class="Em">not</i> put a space between the end of a function name
      and the parenthesis indicating its argument list.</li>
  <li>Do <i class="Em">not</i> put spaces between any parenthesis and its
      following content.</li>
</ul>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>if (condition) {
    do_thing();
}</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>if(condition) {
    do_thing ();
}

if ( condition ) {
    do_thing ( argument );
}</pre>
</div>
<p class="Pp"><i class="Em">Worse</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>while( condition) {
    do_thing( );
}</pre>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Braces_and_statements"><a class="permalink" href="#Braces_and_statements">Braces
  and statements</a></h2>
<p class="Pp">Always, always, always use braces for your control statements.
    Lack of braces can and has led to serious security issues that were missed
    during code review, and putting the braces there from the start means that
    adding new statements to that clause does not require you to also add the
    braces.</p>
<p class="Pp">The clause should be indented on the next line with no blank lines
    in between.</p>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>if (condition) {
    do_thing();
}

while (condition) {
    do_thing();
}</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>if (condition) do_thing();

if (condition)
    do_thing();

while (condition) do_thing();

while (condition) {

    do_thing();
}</pre>
</div>
<p class="Pp">Even trivial uses of braceless <code class="Ic">if</code>
    statements are problematic. Consider the following:</p>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>if (error) i++,
i++;</pre>
</div>
<p class="Pp">This is admittedly contrived, but it would be likely to escape
    code review because it's very easy to miss that the first line ends with a ,
    rather than a ;. Braces in <code class="Ic">if</code> statements are
    sensitive enough to security that the best policy is to simply always use
    them, without exception.</p>
<p class="Pp">Specific rules for braces:</p>
<ul class="Bl-bullet Bd-indent Bl-compact">
  <li id="else"><a class="permalink" href="#else"><code class="Ic">else</code></a>
      goes between two braces on the same line.</li>
  <li>The brace which indicates the expression associated with a control flow
      statement goes on the same line as that statement or the same line as the
      last continuation line of the statement.</li>
  <li>The brace which begins the definition of a <code class="Ic">struct</code>,
      <code class="Ic">union</code>, <code class="Ic">enum</code>, etc. goes on
      the same line as the declaration.</li>
  <li>The brace concluding the expression associated with a control flow
      statement is aligned with the same column as that control flow
    statement.</li>
  <li>The opening brace of a function definition goes on its own line and is
      immediately followed by a new line.</li>
  <li>Control statements with empty bodies should have empty braces.</li>
</ul>
<p class="Pp"><i class="Em">Good</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>if (condition) {
    do_thing();
} else {
    do_other_thing();
}

void
function(void)
{
    return;
}

struct my_struct {
    uint32_t thing;
};

for (cur; cur; cur = cur-&gt;next) { }</pre>
</div>
<p class="Pp"><i class="Em">Bad</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>if (condition)
{
    do_thing();
}
else
{
    do_other_thing();
}

if (condition)
{
    do_thing();
}
else
    do_other_thing();

void
function(void) {
    return;
}

struct my_struct
{
    uint32_t thing;
};

for (cur; cur; cur = cur-&gt;next)</pre>
</div>
<p class="Pp"><i class="Em">Worse</i></p>
<div class="Bd Pp Bd-indent Li">
<pre>if (condition)
    {
    do_thing();
    }

void
function(void)
{ return;
}</pre>
</div>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><a class="Xr" href="../9/style">style(9)</a>,
    <a class="Xr" href="../2/intro">intro(2)</a>,
    <a class="Xr" href="../3/errno">errno(3)</a>,
    <a class="Xr" href="../5/types">types(5)</a></p>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
<p class="Pp">This style was largely derived from the style that evolved through
    the <a class="Xr" href="../8/launchd">launchd(8)</a>,
    <a class="Xr" href="../3/libdispatch">libdispatch(3)</a>, and
    <a class="Xr" href="../3/libxpc">libxpc(3)</a> projects.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">12 January, 2018</td>
    <td class="foot-os"><a href="..">Darwin</a></td>
  </tr>
</table>
</body>
</html>

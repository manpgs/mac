<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   @(#)xdr.3n	2.2 88/08/03 4.0 RPCSRC; from 1.16 88/03/14 SMI
   $FreeBSD: src/lib/libc/xdr/xdr.3,v 1.17 2005/11/24 07:12:01 ru Exp $
   -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>XDR(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">XDR(3)</td>
    <td class="head-vol">Library Functions Manual</td>
    <td class="head-rtitle">XDR(3)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp"><code class="Nm">xdr</code>, <code class="Nm">xdr_array</code>,
    <code class="Nm">xdr_bool</code>, <code class="Nm">xdr_bytes</code>,
    <code class="Nm">xdr_char</code>, <code class="Nm">xdr_destroy</code>,
    <code class="Nm">xdr_double</code>, <code class="Nm">xdr_enum</code>,
    <code class="Nm">xdr_float</code>, <code class="Nm">xdr_free</code>,
    <code class="Nm">xdr_getpos</code>, <code class="Nm">xdr_hyper</code>,
    <code class="Nm">xdr_inline</code>, <code class="Nm">xdr_int</code>,
    <code class="Nm">xdr_long</code>, <code class="Nm">xdr_longlong_t</code>,
    <code class="Nm">xdrmem_create</code>, <code class="Nm">xdr_opaque</code>,
    <code class="Nm">xdr_pointer</code>, <code class="Nm">xdrrec_create</code>,
    <code class="Nm">xdrrec_endofrecord</code>,
    <code class="Nm">xdrrec_eof</code>,
    <code class="Nm">xdrrec_skiprecord</code>,
    <code class="Nm">xdr_reference</code>, <code class="Nm">xdr_setpos</code>,
    <code class="Nm">xdr_short</code>, <code class="Nm">xdrstdio_create</code>,
    <code class="Nm">xdr_string</code>, <code class="Nm">xdr_u_char</code>,
    <code class="Nm">xdr_u_hyper</code>, <code class="Nm">xdr_u_int</code>,
    <code class="Nm">xdr_u_long</code>,
    <code class="Nm">xdr_u_longlong_t</code>,
    <code class="Nm">xdr_u_short</code>, <code class="Nm">xdr_union</code>,
    <code class="Nm">xdr_vector</code>, <code class="Nm">xdr_void</code>,
    <code class="Nm">xdr_wrapstring</code> &#x2014; <span class="Nd">library
    routines for external data representation</span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="LIBRARY"><a class="permalink" href="#LIBRARY">LIBRARY</a></h1>
<p class="Pp"><span class="Lb">Standard C&#x00A0;Library (libc, -lc)</span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp"><code class="In">#include
    &lt;<a class="In">rpc/types.h</a>&gt;</code>
  <br/>
  <code class="In">#include &lt;<a class="In">rpc/xdr.h</a>&gt;</code></p>
<p class="Pp">See <a class="Sx" href="#DESCRIPTION">DESCRIPTION</a> for function
    declarations.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">These routines allow C programmers to describe arbitrary data
    structures in a machine-independent fashion. Data for remote procedure calls
    are transmitted using these routines.</p>
<p class="Pp"></p>
<dl class="Bl-tag Bl-compact">
  <dt><var class="Ft">int</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdr_array"><a class="permalink" href="#xdr_array"><code class="Fn">xdr_array</code></a>(<var class="Fa">XDR
    *xdrs</var>, <var class="Fa">char **arrp</var>, <var class="Fa">u_int
    *sizep</var>, <var class="Fa">u_int maxsize</var>, <var class="Fa">u_int
    elsize</var>, <var class="Fa">xdrproc_t elproc</var>);</dt>
  <dd>
    <p class="Pp">A filter primitive that translates between variable-length
        arrays and their corresponding external representations. The
        <var class="Fa">arrp</var> argument is the address of the pointer to the
        array, while <var class="Fa">sizep</var> is the address of the element
        count of the array; this element count cannot exceed
        <var class="Fa">maxsize</var>. The <var class="Fa">elsize</var> argument
        is the <code class="Ic">sizeof</code> each of the array's elements, and
        <var class="Fa">elproc</var> is an XDR filter that translates between
        the array elements' C form, and their external representation. This
        routine returns one if it succeeds, zero otherwise.</p>
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">int</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdr_bool"><a class="permalink" href="#xdr_bool"><code class="Fn">xdr_bool</code></a>(<var class="Fa">XDR
    *xdrs</var>, <var class="Fa">bool_t *bp</var>)</dt>
  <dd>
    <p class="Pp">A filter primitive that translates between booleans (C
        integers) and their external representations. When encoding data, this
        filter produces values of either one or zero. This routine returns one
        if it succeeds, zero otherwise.</p>
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">int</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdr_bytes"><a class="permalink" href="#xdr_bytes"><code class="Fn">xdr_bytes</code></a>(<var class="Fa">XDR
    *xdrs</var>, <var class="Fa">char **sp</var>, <var class="Fa">u_int
    *sizep</var>, <var class="Fa">u_int maxsize</var>)</dt>
  <dd>
    <p class="Pp">A filter primitive that translates between counted byte
        strings and their external representations. The <var class="Fa">sp</var>
        argument is the address of the string pointer. The length of the string
        is located at address <var class="Fa">sizep</var>; strings cannot be
        longer than <var class="Fa">maxsize</var>. This routine returns one if
        it succeeds, zero otherwise.</p>
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">int</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdr_char"><a class="permalink" href="#xdr_char"><code class="Fn">xdr_char</code></a>(<var class="Fa">XDR
    *xdrs</var>, <var class="Fa">char *cp</var>)</dt>
  <dd>
    <p class="Pp" id="xdr_bytes~2">A filter primitive that translates between C
        characters and their external representations. This routine returns one
        if it succeeds, zero otherwise. Note: encoded characters are not packed,
        and occupy 4 bytes each. For arrays of characters, it is worthwhile to
        consider
        <a class="permalink" href="#xdr_bytes~2"><code class="Fn">xdr_bytes</code></a>(),
        <code class="Fn">xdr_opaque</code>() or
        <code class="Fn">xdr_string</code>().</p>
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">void</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdr_destroy"><a class="permalink" href="#xdr_destroy"><code class="Fn">xdr_destroy</code></a>(<var class="Fa">XDR
    *xdrs</var>)</dt>
  <dd>
    <p class="Pp" id="xdr_destroy~2">A macro that invokes the destroy routine
        associated with the XDR stream, <var class="Fa">xdrs</var>. Destruction
        usually involves freeing private data structures associated with the
        stream. Using <var class="Fa">xdrs</var> after invoking
        <a class="permalink" href="#xdr_destroy~2"><code class="Fn">xdr_destroy</code></a>()
        is undefined.</p>
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">int</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdr_double"><a class="permalink" href="#xdr_double"><code class="Fn">xdr_double</code></a>(<var class="Fa">XDR
    *xdrs</var>, <var class="Fa">double *dp</var>)</dt>
  <dd>
    <p class="Pp">A filter primitive that translates between C
        <var class="Vt">double</var> precision numbers and their external
        representations. This routine returns one if it succeeds, zero
        otherwise.</p>
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">int</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdr_enum"><a class="permalink" href="#xdr_enum"><code class="Fn">xdr_enum</code></a>(<var class="Fa">XDR
    *xdrs</var>, <var class="Fa">enum_t *ep</var>)</dt>
  <dd>
    <p class="Pp">A filter primitive that translates between C
        <var class="Vt">enum</var>s (actually integers) and their external
        representations. This routine returns one if it succeeds, zero
        otherwise.</p>
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">int</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdr_float"><a class="permalink" href="#xdr_float"><code class="Fn">xdr_float</code></a>(<var class="Fa">XDR
    *xdrs</var>, <var class="Fa">float *fp</var>)</dt>
  <dd>
    <p class="Pp">A filter primitive that translates between C
        <var class="Vt">float</var>s and their external representations. This
        routine returns one if it succeeds, zero otherwise.</p>
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">void</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdr_free"><a class="permalink" href="#xdr_free"><code class="Fn">xdr_free</code></a>(<var class="Fa">xdrproc_t
    proc</var>, <var class="Fa">void *objp</var>)</dt>
  <dd>
    <p class="Pp" id="not">Generic freeing routine. The first argument is the
        XDR routine for the object being freed. The second argument is a pointer
        to the object itself. Note: the pointer passed to this routine is
        <a class="permalink" href="#not"><i class="Em">not</i></a> freed, but
        what it points to
        <a class="permalink" href="#is"><i class="Em" id="is">is</i></a> freed
        (recursively).</p>
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">u_int</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdr_getpos"><a class="permalink" href="#xdr_getpos"><code class="Fn">xdr_getpos</code></a>(<var class="Fa">XDR
    *xdrs</var>)</dt>
  <dd>
    <p class="Pp">A macro that invokes the get-position routine associated with
        the XDR stream, <var class="Fa">xdrs</var>. The routine returns an
        unsigned integer, which indicates the position of the XDR byte stream. A
        desirable feature of XDR streams is that simple arithmetic works with
        this number, although the XDR stream instances need not guarantee
      this.</p>
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">int</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdr_hyper"><a class="permalink" href="#xdr_hyper"><code class="Fn">xdr_hyper</code></a>(<var class="Fa">XDR
    *xdrs</var>, <var class="Fa">quad_t *llp</var>)</dt>
  <dd>A filter primitive that translates between ANSI C <var class="Vt">long
      long</var> integers and their external representations. This routine
      returns one if it succeeds, zero otherwise.
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">long *</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdr_inline"><a class="permalink" href="#xdr_inline"><code class="Fn">xdr_inline</code></a>(<var class="Fa">XDR
    *xdrs</var>, <var class="Fa">int len</var>)</dt>
  <dd>
    <p class="Pp">A macro that invokes the in-line routine associated with the
        XDR stream, <var class="Fa">xdrs</var>. The routine returns a pointer to
        a contiguous piece of the stream's buffer; <var class="Fa">len</var> is
        the byte length of the desired buffer. Note: pointer is cast to
        <var class="Vt">long *</var>.</p>
    <p class="Pp" id="xdr_inline~2">Warning:
        <a class="permalink" href="#xdr_inline~2"><code class="Fn">xdr_inline</code></a>()
        may return <code class="Dv">NULL</code> (0) if it cannot allocate a
        contiguous piece of a buffer. Therefore the behavior may vary among
        stream instances; it exists for the sake of efficiency.</p>
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">int</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdr_int"><a class="permalink" href="#xdr_int"><code class="Fn">xdr_int</code></a>(<var class="Fa">XDR
    *xdrs</var>, <var class="Fa">int *ip</var>)</dt>
  <dd>
    <p class="Pp">A filter primitive that translates between C integers and
        their external representations. This routine returns one if it succeeds,
        zero otherwise.</p>
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">int</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdr_long"><a class="permalink" href="#xdr_long"><code class="Fn">xdr_long</code></a>(<var class="Fa">XDR
    *xdrs</var>, <var class="Fa">long *lp</var>)</dt>
  <dd>
    <p class="Pp">A filter primitive that translates between C
        <var class="Vt">long</var> integers and their external representations.
        This routine returns one if it succeeds, zero otherwise.</p>
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">int</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdr_longlong_t"><a class="permalink" href="#xdr_longlong_t"><code class="Fn">xdr_longlong_t</code></a>(<var class="Fa">XDR
    *xdrs</var>, <var class="Fa">quad_t *llp</var>)</dt>
  <dd>A filter primitive that translates between ANSI C <var class="Vt">long
      long</var> integers and their external representations. This routine
      returns one if it succeeds, zero otherwise.
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">void</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdrmem_create"><a class="permalink" href="#xdrmem_create"><code class="Fn">xdrmem_create</code></a>(<var class="Fa">XDR
    *xdrs</var>, <var class="Fa">char *addr</var>, <var class="Fa">u_int
    size</var>, <var class="Fa">enum xdr_op op</var>)</dt>
  <dd>
    <p class="Pp">This routine initializes the XDR stream object pointed to by
        <var class="Fa">xdrs</var>. The stream's data is written to, or read
        from, a chunk of memory at location <var class="Fa">addr</var> whose
        length is no more than <var class="Fa">size</var> bytes long. The
        <var class="Fa">op</var> argument determines the direction of the XDR
        stream (either <code class="Dv">XDR_ENCODE</code>,
        <code class="Dv">XDR_DECODE</code>, or
        <code class="Dv">XDR_FREE</code>).</p>
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">int</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdr_opaque"><a class="permalink" href="#xdr_opaque"><code class="Fn">xdr_opaque</code></a>(<var class="Fa">XDR
    *xdrs</var>, <var class="Fa">char *cp</var>, <var class="Fa">u_int
    cnt</var>)</dt>
  <dd>
    <p class="Pp">A filter primitive that translates between fixed size opaque
        data and its external representation. The <var class="Fa">cp</var>
        argument is the address of the opaque object, and
        <var class="Fa">cnt</var> is its size in bytes. This routine returns one
        if it succeeds, zero otherwise.</p>
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">int</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdr_pointer"><a class="permalink" href="#xdr_pointer"><code class="Fn">xdr_pointer</code></a>(<var class="Fa">XDR
    *xdrs</var>, <var class="Fa">char **objpp</var>, <var class="Fa">u_int
    objsize</var>, <var class="Fa">xdrproc_t xdrobj</var>)</dt>
  <dd>
    <p class="Pp" id="xdr_reference">Like
        <a class="permalink" href="#xdr_reference"><code class="Fn">xdr_reference</code></a>()
        except that it serializes <code class="Dv">NULL</code> pointers, whereas
        <code class="Fn">xdr_reference</code>() does not. Thus,
        <code class="Fn">xdr_pointer</code>() can represent recursive data
        structures, such as binary trees or linked lists.</p>
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">void</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdrrec_create"><a class="permalink" href="#xdrrec_create"><code class="Fn">xdrrec_create</code></a>(<var class="Fa">XDR
    *xdrs</var>, <var class="Fa">u_int sendsize</var>, <var class="Fa">u_int
    recvsize</var>, <var class="Fa">void *handle</var>, <var class="Fa">int
    (*readit)()</var>, <var class="Fa">int (*writeit)()</var>);</dt>
  <dd>
    <p class="Pp" id="writeit">This routine initializes the XDR stream object
        pointed to by <var class="Fa">xdrs</var>. The stream's data is written
        to a buffer of size <var class="Fa">sendsize</var>; a value of zero
        indicates the system should use a suitable default. The stream's data is
        read from a buffer of size <var class="Fa">recvsize</var>; it too can be
        set to a suitable default by passing a zero value. When a stream's
        output buffer is full,
        <a class="permalink" href="#writeit"><code class="Fn">writeit</code></a>()
        is called. Similarly, when a stream's input buffer is empty,
        <a class="permalink" href="#readit"><code class="Fn" id="readit">readit</code></a>()
        is called. The behavior of these two routines is similar to the system
        calls <a class="Xr" href="../2/read">read(2)</a> and
        <a class="Xr" href="../2/write">write(2)</a>, except that
        <var class="Fa">handle</var> is passed to the former routines as the
        first argument. Note: the XDR stream's <var class="Fa">op</var> field
        must be set by the caller.</p>
    <p class="Pp">Warning: this XDR stream implements an intermediate record
        stream. Therefore there are additional bytes in the stream to provide
        record boundary information.</p>
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">int</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdrrec_endofrecord"><a class="permalink" href="#xdrrec_endofrecord"><code class="Fn">xdrrec_endofrecord</code></a>(<var class="Fa">XDR
    *xdrs</var>, <var class="Fa">int sendnow</var>)</dt>
  <dd>
    <p class="Pp" id="xdrrec_create~2">This routine can be invoked only on
        streams created by
        <a class="permalink" href="#xdrrec_create~2"><code class="Fn">xdrrec_create</code></a>().
        The data in the output buffer is marked as a completed record, and the
        output buffer is optionally written out if <var class="Fa">sendnow</var>
        is non-zero. This routine returns one if it succeeds, zero
      otherwise.</p>
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">int</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdrrec_eof"><a class="permalink" href="#xdrrec_eof"><code class="Fn">xdrrec_eof</code></a>(<var class="Fa">XDR
    *xdrs</var>)</dt>
  <dd>
    <p class="Pp" id="xdrrec_create~3">This routine can be invoked only on
        streams created by
        <a class="permalink" href="#xdrrec_create~3"><code class="Fn">xdrrec_create</code></a>().
        After consuming the rest of the current record in the stream, this
        routine returns one if the stream has no more input, zero otherwise.</p>
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">int</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdrrec_skiprecord"><a class="permalink" href="#xdrrec_skiprecord"><code class="Fn">xdrrec_skiprecord</code></a>(<var class="Fa">XDR
    *xdrs</var>)</dt>
  <dd>
    <p class="Pp" id="xdrrec_create~4">This routine can be invoked only on
        streams created by
        <a class="permalink" href="#xdrrec_create~4"><code class="Fn">xdrrec_create</code></a>().
        It tells the XDR implementation that the rest of the current record in
        the stream's input buffer should be discarded. This routine returns one
        if it succeeds, zero otherwise.</p>
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">int</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdr_reference~2"><a class="permalink" href="#xdr_reference~2"><code class="Fn">xdr_reference</code></a>(<var class="Fa">XDR
    *xdrs</var>, <var class="Fa">char **pp</var>, <var class="Fa">u_int
    size</var>, <var class="Fa">xdrproc_t proc</var>)</dt>
  <dd>
    <p class="Pp">A primitive that provides pointer chasing within structures.
        The <var class="Fa">pp</var> argument is the address of the pointer;
        <var class="Fa">size</var> is the <code class="Ic">sizeof</code> the
        structure that <var class="Fa">*pp</var> points to; and
        <var class="Fa">proc</var> is an XDR procedure that filters the
        structure between its C form and its external representation. This
        routine returns one if it succeeds, zero otherwise.</p>
    <p class="Pp" id="xdr_pointer~2">Warning: this routine does not understand
        <code class="Dv">NULL</code> pointers. Use
        <a class="permalink" href="#xdr_pointer~2"><code class="Fn">xdr_pointer</code></a>()
        instead.</p>
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">int</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdr_setpos"><a class="permalink" href="#xdr_setpos"><code class="Fn">xdr_setpos</code></a>(<var class="Fa">XDR
    *xdrs</var>, <var class="Fa">u_int pos</var>)</dt>
  <dd>
    <p class="Pp" id="xdr_getpos~2">A macro that invokes the set position
        routine associated with the XDR stream <var class="Fa">xdrs</var>. The
        <var class="Fa">pos</var> argument is a position value obtained from
        <a class="permalink" href="#xdr_getpos~2"><code class="Fn">xdr_getpos</code></a>().
        This routine returns one if the XDR stream could be repositioned, and
        zero otherwise.</p>
    <p class="Pp">Warning: it is difficult to reposition some types of XDR
        streams, so this routine may fail with one type of stream and succeed
        with another.</p>
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">int</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdr_short"><a class="permalink" href="#xdr_short"><code class="Fn">xdr_short</code></a>(<var class="Fa">XDR
    *xdrs</var>, <var class="Fa">short *sp</var>)</dt>
  <dd>
    <p class="Pp">A filter primitive that translates between C
        <var class="Vt">short</var> integers and their external representations.
        This routine returns one if it succeeds, zero otherwise.</p>
    <p class="Pp"></p>
  </dd>
  <dt id="_ifdef"><a class="permalink" href="#_ifdef"><code class="Li">#ifdef
    _STDIO_H_</code></a></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="/*"><a class="permalink" href="#/*"><code class="Li">/* XDR using
    stdio library */</code></a></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt><var class="Ft">void</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdrstdio_create"><a class="permalink" href="#xdrstdio_create"><code class="Fn">xdrstdio_create</code></a>(<var class="Fa">XDR
    *xdrs</var>, <var class="Fa">FILE *file</var>, <var class="Fa">enum xdr_op
    op</var>)</dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="_endif"><a class="permalink" href="#_endif"><code class="Li">#endif</code></a></dt>
  <dd>
    <p class="Pp">This routine initializes the XDR stream object pointed to by
        <var class="Fa">xdrs</var>. The XDR stream data is written to, or read
        from, the Standard I/O stream <var class="Fa">file</var>. The
        <var class="Fa">op</var> argument determines the direction of the XDR
        stream (either <code class="Dv">XDR_ENCODE</code>,
        <code class="Dv">XDR_DECODE</code>, or
        <code class="Dv">XDR_FREE</code>).</p>
    <p class="Pp">Warning: the destroy routine associated with such XDR streams
        calls <a class="Xr" href="../3/fflush">fflush(3)</a> on the
        <var class="Fa">file</var> stream, but never
        <a class="Xr" href="../3/fclose">fclose(3)</a>.</p>
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">int</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdr_string"><a class="permalink" href="#xdr_string"><code class="Fn">xdr_string</code></a>(<var class="Fa">XDR
    *xdrs</var>, <var class="Fa">char **sp</var>, <var class="Fa">u_int
    maxsize</var>)</dt>
  <dd>
    <p class="Pp">A filter primitive that translates between C strings and their
        corresponding external representations. Strings cannot be longer than
        <var class="Fa">maxsize</var>. Note: <var class="Fa">sp</var> is the
        address of the string's pointer. This routine returns one if it
        succeeds, zero otherwise.</p>
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">int</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdr_u_char"><a class="permalink" href="#xdr_u_char"><code class="Fn">xdr_u_char</code></a>(<var class="Fa">XDR
    *xdrs</var>, <var class="Fa">unsigned char *ucp</var>)</dt>
  <dd>
    <p class="Pp">A filter primitive that translates between
        <var class="Vt">unsigned</var> C characters and their external
        representations. This routine returns one if it succeeds, zero
        otherwise.</p>
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">int</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdr_u_hyper"><a class="permalink" href="#xdr_u_hyper"><code class="Fn">xdr_u_hyper</code></a>(<var class="Fa">XDR
    *xdrs</var>, <var class="Fa">u_quad_t *ullp</var>)</dt>
  <dd>A filter primitive that translates between <var class="Vt">unsigned</var>
      ANSI C <var class="Vt">long long</var> integers and their external
      representations. This routine returns one if it succeeds, zero otherwise.
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">int</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdr_u_int"><a class="permalink" href="#xdr_u_int"><code class="Fn">xdr_u_int</code></a>(<var class="Fa">XDR
    *xdrs</var>, <var class="Fa">unsigned *up</var>)</dt>
  <dd>
    <p class="Pp">A filter primitive that translates between C
        <var class="Vt">unsigned</var> integers and their external
        representations. This routine returns one if it succeeds, zero
        otherwise.</p>
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">int</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdr_u_long"><a class="permalink" href="#xdr_u_long"><code class="Fn">xdr_u_long</code></a>(<var class="Fa">XDR
    *xdrs</var>, <var class="Fa">unsigned long *ulp</var>)</dt>
  <dd>
    <p class="Pp">A filter primitive that translates between C
        <var class="Vt">unsigned long</var> integers and their external
        representations. This routine returns one if it succeeds, zero
        otherwise.</p>
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">int</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdr_u_longlong_t"><a class="permalink" href="#xdr_u_longlong_t"><code class="Fn">xdr_u_longlong_t</code></a>(<var class="Fa">XDR
    *xdrs</var>, <var class="Fa">u_quad_t *ullp</var>)</dt>
  <dd>A filter primitive that translates between <var class="Vt">unsigned</var>
      ANSI C <var class="Vt">long long</var> integers and their external
      representations. This routine returns one if it succeeds, zero otherwise.
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">int</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdr_u_short"><a class="permalink" href="#xdr_u_short"><code class="Fn">xdr_u_short</code></a>(<var class="Fa">XDR
    *xdrs</var>, <var class="Fa">unsigned short *usp</var>)</dt>
  <dd>
    <p class="Pp">A filter primitive that translates between C
        <var class="Vt">unsigned short</var> integers and their external
        representations. This routine returns one if it succeeds, zero
        otherwise.</p>
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">int</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdr_union"><a class="permalink" href="#xdr_union"><code class="Fn">xdr_union</code></a>(<var class="Fa">XDR
    *xdrs</var>, <var class="Fa">enum_t *dscmp</var>, <var class="Fa">char
    *unp</var>, <var class="Fa">const struct xdr_discrim *choices</var>,
    <var class="Fa">xdrproc_t defaultarm</var>);</dt>
  <dd>
    <p class="Pp" id="proc">A filter primitive that translates between a
        discriminated C <var class="Vt">union</var> and its corresponding
        external representation. It first translates the discriminant of the
        union located at <var class="Fa">dscmp</var>. This discriminant is
        always an <var class="Vt">enum_t</var>. Next the union located at
        <var class="Fa">unp</var> is translated. The
        <var class="Fa">choices</var> argument is a pointer to an array of
        <var class="Vt">xdr_discrim</var> structures. Each structure contains an
        ordered pair of [<var class="Va">value</var>,
        <var class="Va">proc</var>]. If the union's discriminant is equal to the
        associated <var class="Va">value</var>, then the
        <a class="permalink" href="#proc"><code class="Fn">proc</code></a>() is
        called to translate the union. The end of the
        <var class="Vt">xdr_discrim</var> structure array is denoted by a
        routine of value <code class="Dv">NULL</code>. If the discriminant is
        not found in the <var class="Fa">choices</var> array, then the
        <a class="permalink" href="#defaultarm"><code class="Fn" id="defaultarm">defaultarm</code></a>()
        procedure is called (if it is not <code class="Dv">NULL</code>). Returns
        one if it succeeds, zero otherwise.</p>
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">int</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdr_vector"><a class="permalink" href="#xdr_vector"><code class="Fn">xdr_vector</code></a>(<var class="Fa">XDR
    *xdrs</var>, <var class="Fa">char *arrp</var>, <var class="Fa">u_int
    size</var>, <var class="Fa">u_int elsize</var>, <var class="Fa">xdrproc_t
    elproc</var>);</dt>
  <dd>
    <p class="Pp">A filter primitive that translates between fixed-length arrays
        and their corresponding external representations. The
        <var class="Fa">arrp</var> argument is the address of the pointer to the
        array, while <var class="Fa">size</var> is the element count of the
        array. The <var class="Fa">elsize</var> argument is the
        <code class="Ic">sizeof</code> each of the array's elements, and
        <var class="Fa">elproc</var> is an XDR filter that translates between
        the array elements' C form, and their external representation. This
        routine returns one if it succeeds, zero otherwise.</p>
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">int</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdr_void"><a class="permalink" href="#xdr_void"><code class="Fn">xdr_void</code></a>(<var class="Fa">void</var>)</dt>
  <dd>
    <p class="Pp">This routine always returns one. It may be passed to RPC
        routines that require a function argument, where nothing is to be
      done.</p>
    <p class="Pp"></p>
  </dd>
  <dt><var class="Ft">int</var></dt>
  <dd style="width: auto;">&#x00A0;</dd>
  <dt id="xdr_wrapstring"><a class="permalink" href="#xdr_wrapstring"><code class="Fn">xdr_wrapstring</code></a>(<var class="Fa">XDR
    *xdrs</var>, <var class="Fa">char **sp</var>)</dt>
  <dd>
    <p class="Pp" id="xdr_string~2">A primitive that calls
        <a class="permalink" href="#xdr_string~2"><code class="Fn">xdr_string</code></a>(<var class="Fa">xdrs</var>,
        <var class="Fa">sp</var>, <var class="Fa">MAXUN.UNSIGNED</var>); where
        <code class="Dv">MAXUN.UNSIGNED</code> is the maximum value of an
        unsigned integer. The <code class="Fn">xdr_wrapstring</code>() function
        is handy because the RPC package passes a maximum of two XDR routines as
        arguments, and <code class="Fn">xdr_string</code>(), one of the most
        frequently used primitives, requires three. Returns one if it succeeds,
        zero otherwise.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><a class="Xr" href="../3/rpc">rpc(3)</a></p>
<p class="Pp"><cite class="Rs"><span class="RsT">eXternal Data Representation
    Standard: Protocol Specification</span>.</cite></p>
<p class="Pp"><cite class="Rs"><span class="RsT">eXternal Data Representation:
    Sun Technical Notes</span>.</cite></p>
<p class="Pp"><cite class="Rs"><span class="RsT">XDR: External Data
    Representation Standard</span>, <span class="RsQ">Sun Microsystems, Inc.,
    USC-ISI</span>, <span class="RsO">RFC1014</span>.</cite></p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">February 16, 1988</td>
    <td class="foot-os">macOS 14.1</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   t
       Title: glMapBuffer
      Author: [FIXME: author] [see http://docbook.sf.net/el/author]
   Generator: DocBook XSL Stylesheets v1.76.1 <http://docbook.sf.net/>
        Date: 03/08/2011
      Manual: OpenGL 3.3
      Source: OpenGL 3.3
    Language: English
   -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>GLMAPBUFFER(3G)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">GLMAPBUFFER(3G)</td>
    <td class="head-vol">OpenGL 3.3</td>
    <td class="head-rtitle">GLMAPBUFFER(3G)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">glMapBuffer - map a buffer object's data store</p>
</section>
<section class="Sh">
<h1 class="Sh">C SPECIFICATION</h1>
<p class="Pp HP"><b>void * glMapBuffer(GLenum&#x00A0;</b><i>target</i><b>,
    GLenum&#x00A0;</b><i>access</i><b>);</b></p>
</section>
<section class="Sh">
<h1 class="Sh" id="PARAMETERS"><a class="permalink" href="#PARAMETERS">PARAMETERS</a></h1>
<p class="Pp"><i>target</i></p>
<div class="Bd-indent">Specifies the target buffer object being mapped. The
  symbolic constant must be <b>GL_ARRAY_BUFFER</b>, <b>GL_COPY_READ_BUFFER</b>,
  <b>GL_COPY_WRITE_BUFFER</b>, <b>GL_ELEMENT_ARRAY_BUFFER</b>,
  <b>GL_PIXEL_PACK_BUFFER</b>, <b>GL_PIXEL_UNPACK_BUFFER</b>,
  <b>GL_TEXTURE_BUFFER</b>, <b>GL_TRANSFORM_FEEDBACK_BUFFER</b> or
  <b>GL_UNIFORM_BUFFER</b>.</div>
<p class="Pp"><i>access</i></p>
<div class="Bd-indent">Specifies the access policy, indicating whether it will
  be possible to read from, write to, or both read from and write to the buffer
  object's mapped data store. The symbolic constant must be <b>GL_READ_ONLY</b>,
  <b>GL_WRITE_ONLY</b>, or <b>GL_READ_WRITE</b>.</div>
</section>
<section class="Sh">
<h1 class="Sh">C SPECIFICATION</h1>
<p class="Pp HP"><b>GLboolean
    glUnmapBuffer(GLenum&#x00A0;</b><i>target</i><b>);</b></p>
</section>
<section class="Sh">
<h1 class="Sh" id="PARAMETERS~2"><a class="permalink" href="#PARAMETERS~2">PARAMETERS</a></h1>
<p class="Pp"><i>target</i></p>
<div class="Bd-indent">Specifies the target buffer object being unmapped. The
  symbolic constant must be <b>GL_ARRAY_BUFFER</b>, <b>GL_COPY_READ_BUFFER</b>,
  <b>GL_COPY_WRITE_BUFFER</b>, <b>GL_ELEMENT_ARRAY_BUFFER</b>,
  <b>GL_PIXEL_PACK_BUFFER</b>, <b>GL_PIXEL_UNPACK_BUFFER</b>,
  <b>GL_TEXTURE_BUFFER</b>, <b>GL_TRANSFORM_FEEDBACK_BUFFER</b> or
  <b>GL_UNIFORM_BUFFER</b>.</div>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><b>glMapBuffer</b> maps to the client's address space the entire
    data store of the buffer object currently bound to <i>target</i>. The data
    can then be directly read and/or written relative to the returned pointer,
    depending on the specified <i>access</i> policy. If the GL is unable to map
    the buffer object's data store, <b>glMapBuffer</b> generates an error and
    returns <b>NULL</b>. This may occur for system-specific reasons, such as low
    virtual memory availability.</p>
<p class="Pp">If a mapped data store is accessed in a way inconsistent with the
    specified <i>access</i> policy, no error is generated, but performance may
    be negatively impacted and system errors, including program termination, may
    result. Unlike the <i>usage</i> parameter of <b>glBufferData</b>,
    <i>access</i> is not a hint, and does in fact constrain the usage of the
    mapped data store on some GL implementations. In order to achieve the
    highest performance available, a buffer object's data store should be used
    in ways consistent with both its specified <i>usage</i> and <i>access</i>
    parameters.</p>
<p class="Pp">A mapped data store must be unmapped with <b>glUnmapBuffer</b>
    before its buffer object is used. Otherwise an error will be generated by
    any GL command that attempts to dereference the buffer object's data store.
    When a data store is unmapped, the pointer to its data store becomes
    invalid. <b>glUnmapBuffer</b> returns <b>GL_TRUE</b> unless the data store
    contents have become corrupt during the time the data store was mapped. This
    can occur for system-specific reasons that affect the availability of
    graphics memory, such as screen mode changes. In such situations,
    <b>GL_FALSE</b> is returned and the data store contents are undefined. An
    application must detect this rare condition and reinitialize the data
  store.</p>
<p class="Pp">A buffer object's mapped data store is automatically unmapped when
    the buffer object is deleted or its data store is recreated with
    <b>glBufferData</b>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<p class="Pp">If an error is generated, <b>glMapBuffer</b> returns <b>NULL</b>,
    and <b>glUnmapBuffer</b> returns <b>GL_FALSE</b>.</p>
<p class="Pp">Parameter values passed to GL commands may not be sourced from the
    returned pointer. No error will be generated, but results will be undefined
    and will likely vary across GL implementations.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ERRORS"><a class="permalink" href="#ERRORS">ERRORS</a></h1>
<p class="Pp"><b>GL_INVALID_ENUM</b> is generated if <i>target</i> is not
    <b>GL_ARRAY_BUFFER</b>, <b>GL_COPY_READ_BUFFER</b>,
    <b>GL_COPY_WRITE_BUFFER</b>, <b>GL_ELEMENT_ARRAY_BUFFER</b>,
    <b>GL_PIXEL_PACK_BUFFER</b>, <b>GL_PIXEL_UNPACK_BUFFER</b>,
    <b>GL_TEXTURE_BUFFER</b>, <b>GL_TRANSFORM_FEEDBACK_BUFFER</b> or
    <b>GL_UNIFORM_BUFFER</b>.</p>
<p class="Pp"><b>GL_INVALID_ENUM</b> is generated if <i>access</i> is not
    <b>GL_READ_ONLY</b>, <b>GL_WRITE_ONLY</b>, or <b>GL_READ_WRITE</b>.</p>
<p class="Pp"><b>GL_OUT_OF_MEMORY</b> is generated when <b>glMapBuffer</b> is
    executed if the GL is unable to map the buffer object's data store. This may
    occur for a variety of system-specific reasons, such as the absence of
    sufficient remaining virtual memory.</p>
<p class="Pp"><b>GL_INVALID_OPERATION</b> is generated if the reserved buffer
    object name 0 is bound to <i>target</i>.</p>
<p class="Pp"><b>GL_INVALID_OPERATION</b> is generated if <b>glMapBuffer</b> is
    executed for a buffer object whose data store is already mapped.</p>
<p class="Pp"><b>GL_INVALID_OPERATION</b> is generated if <b>glUnmapBuffer</b>
    is executed for a buffer object whose data store is not currently
  mapped.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ASSOCIATED_GETS"><a class="permalink" href="#ASSOCIATED_GETS">ASSOCIATED
  GETS</a></h1>
<p class="Pp"><b>glGetBufferPointerv</b>() with argument
    <b>GL_BUFFER_MAP_POINTER</b></p>
<p class="Pp"><b>glGetBufferParameter</b>() with argument
    <b>GL_BUFFER_MAPPED</b>, <b>GL_BUFFER_ACCESS</b>, or
  <b>GL_BUFFER_USAGE</b></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>glBindBuffer</b>(), <b>glBindBufferBase</b>(),
    <b>glBindBufferRange</b>(), <b>glBufferData</b>(), <b>glBufferSubData</b>(),
    <b>glDeleteBuffers</b>()</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright &#x00A9; 2005 Addison-Wesley. This material may be
    distributed subject to the terms and conditions set forth in the Open
    Publication License, v 1.0, 8 June 1999.
    <b>http://opencontent.org/openpub/</b>.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">03/08/2011</td>
    <td class="foot-os">OpenGL 3.3</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   t
       Title: glTexImage2D
      Author: [FIXME: author] [see http://docbook.sf.net/el/author]
   Generator: DocBook XSL Stylesheets v1.76.1 <http://docbook.sf.net/>
        Date: 03/08/2011
      Manual: OpenGL 3.3
      Source: OpenGL 3.3
    Language: English
   -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>GLTEXIMAGE2D(3G)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">GLTEXIMAGE2D(3G)</td>
    <td class="head-vol"><a href=".">OpenGL 3.3</a></td>
    <td class="head-rtitle">GLTEXIMAGE2D(3G)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">glTexImage2D - specify a two-dimensional texture image</p>
</section>
<section class="Sh">
<h1 class="Sh" id="C_SPECIFICATION"><a class="permalink" href="#C_SPECIFICATION">C
  SPECIFICATION</a></h1>
<p class="Pp HP"><b>void glTexImage2D(GLenum&#x00A0;</b><i>target</i><b>,
    GLint&#x00A0;</b><i>level</i><b>, GLint&#x00A0;</b><i>internalFormat</i><b>,
    GLsizei&#x00A0;</b><i>width</i><b>, GLsizei&#x00A0;</b><i>height</i><b>,
    GLint&#x00A0;</b><i>border</i><b>, GLenum&#x00A0;</b><i>format</i><b>,
    GLenum&#x00A0;</b><i>type</i><b>,
    const&#x00A0;GLvoid&#x00A0;*&#x00A0;</b><i>data</i><b>);</b></p>
</section>
<section class="Sh">
<h1 class="Sh" id="PARAMETERS"><a class="permalink" href="#PARAMETERS">PARAMETERS</a></h1>
<p class="Pp"><i>target</i></p>
<div class="Bd-indent">Specifies the target texture. Must be
  <b>GL_TEXTURE_2D</b>, <b>GL_PROXY_TEXTURE_2D</b>, <b>GL_TEXTURE_1D_ARRAY</b>,
  <b>GL_PROXY_TEXTURE_1D_ARRAY</b>, <b>GL_TEXTURE_RECTANGLE</b>,
  <b>GL_PROXY_TEXTURE_RECTANGLE</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>,
  <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>,
  <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>,
  <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>, or
  <b>GL_PROXY_TEXTURE_CUBE_MAP</b>.</div>
<p class="Pp"><i>level</i></p>
<div class="Bd-indent">Specifies the level-of-detail number. Level 0 is the base
  image level. Level <i>n</i> is the <i>n</i>th mipmap reduction image. If
  <i>target</i> is <b>GL_TEXTURE_RECTANGLE</b> or
  <b>GL_PROXY_TEXTURE_RECTANGLE</b>, <i>level</i> must be 0.</div>
<p class="Pp"><i>internalFormat</i></p>
<div class="Bd-indent">Specifies the number of color components in the texture.
  Must be one of the following symbolic constants: <b>GL_COMPRESSED_RED</b>,
  <b>GL_COMPRESSED_RG</b>, <b>GL_COMPRESSED_RGB</b>, <b>GL_COMPRESSED_RGBA</b>,
  <b>GL_COMPRESSED_SRGB</b>, <b>GL_COMPRESSED_SRGB_ALPHA</b>,
  <b>GL_DEPTH_COMPONENT</b>, <b>GL_DEPTH_COMPONENT16</b>,
  <b>GL_DEPTH_COMPONENT24</b>, <b>GL_DEPTH_COMPONENT32</b>, <b>GL_R3_G3_B2</b>,
  <b>GL_RED</b>, <b>GL_RG</b>, <b>GL_RGB</b>, <b>GL_RGB4</b>, <b>GL_RGB5</b>,
  <b>GL_RGB8</b>, <b>GL_RGB10</b>, <b>GL_RGB12</b>, <b>GL_RGB16</b>,
  <b>GL_RGBA</b>, <b>GL_RGBA2</b>, <b>GL_RGBA4</b>, <b>GL_RGB5_A1</b>,
  <b>GL_RGBA8</b>, <b>GL_RGB10_A2</b>, <b>GL_RGBA12</b>, <b>GL_RGBA16</b>,
  <b>GL_SRGB</b>, <b>GL_SRGB8</b>, <b>GL_SRGB_ALPHA</b>, or
  <b>GL_SRGB8_ALPHA8</b>.</div>
<p class="Pp"><i>width</i></p>
<div class="Bd-indent">Specifies the width of the texture image. All
  implementations support texture images that are at least 1024 texels
  wide.</div>
<p class="Pp"><i>height</i></p>
<div class="Bd-indent">Specifies the height of the texture image, or the number
  of layers in a texture array, in the case of the <b>GL_TEXTURE_1D_ARRAY</b>
  and <b>GL_PROXY_TEXTURE_1D_ARRAY</b> targets. All implementations support 2D
  texture images that are at least 1024 texels high, and texture arrays that are
  at least 256 layers deep.</div>
<p class="Pp"><i>border</i></p>
<div class="Bd-indent">This value must be 0.</div>
<p class="Pp"><i>format</i></p>
<div class="Bd-indent">Specifies the format of the pixel data. The following
  symbolic values are accepted: <b>GL_RED</b>, <b>GL_RG</b>, <b>GL_RGB</b>,
  <b>GL_BGR</b>, <b>GL_RGBA</b>, and <b>GL_BGRA</b>.</div>
<p class="Pp"><i>type</i></p>
<div class="Bd-indent">Specifies the data type of the pixel data. The following
  symbolic values are accepted: <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>,
  <b>GL_UNSIGNED_SHORT</b>, <b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>,
  <b>GL_INT</b>, <b>GL_FLOAT</b>, <b>GL_UNSIGNED_BYTE_3_3_2</b>,
  <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>,
  <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4</b>,
  <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>,
  <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>, <b>GL_UNSIGNED_INT_8_8_8_8</b>,
  <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>, and
  <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>.</div>
<p class="Pp"><i>data</i></p>
<div class="Bd-indent">Specifies a pointer to the image data in memory.</div>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Texturing allows elements of an image array to be read by
  shaders.</p>
<p class="Pp">To define texture images, call <b>glTexImage2D</b>. The arguments
    describe the parameters of the texture image, such as height, width, width
    of the border, level-of-detail number (see <b>glTexParameter</b>()), and
    number of color components provided. The last three arguments describe how
    the image is represented in memory.</p>
<p class="Pp">If <i>target</i> is <b>GL_PROXY_TEXTURE_2D</b>,
    <b>GL_PROXY_TEXTURE_1D_ARRAY</b>, <b>GL_PROXY_TEXTURE_CUBE_MAP</b>, or
    <b>GL_PROXY_TEXTURE_RECTANGLE</b>, no data is read from <i>data</i>, but all
    of the texture image state is recalculated, checked for consistency, and
    checked against the implementation's capabilities. If the implementation
    cannot handle a texture of the requested texture size, it sets all of the
    image state to 0, but does not generate an error (see <b>glGetError</b>()).
    To query for an entire mipmap array, use an image array level greater than
    or equal to 1.</p>
<p class="Pp">If <i>target</i> is <b>GL_TEXTURE_2D</b>,
    <b>GL_TEXTURE_RECTANGLE</b> or one of the <b>GL_TEXTURE_CUBE_MAP</b>
    targets, data is read from <i>data</i> as a sequence of signed or unsigned
    bytes, shorts, or longs, or single-precision floating-point values,
    depending on <i>type</i>. These values are grouped into sets of one, two,
    three, or four values, depending on <i>format</i>, to form elements. Each
    data byte is treated as eight 1-bit elements, with bit ordering determined
    by <b>GL_UNPACK_LSB_FIRST</b> (see <b>glPixelStore</b>()).</p>
<p class="Pp">If <i>target</i> is <b>GL_TEXTURE_1D_ARRAY</b>, data is
    interpreted as an array of one-dimensional images.</p>
<p class="Pp">If a non-zero named buffer object is bound to the
    <b>GL_PIXEL_UNPACK_BUFFER</b> target (see <b>glBindBuffer</b>()) while a
    texture image is specified, <i>data</i> is treated as a byte offset into the
    buffer object's data store.</p>
<p class="Pp">The first element corresponds to the lower left corner of the
    texture image. Subsequent elements progress left-to-right through the
    remaining texels in the lowest row of the texture image, and then in
    successively higher rows of the texture image. The final element corresponds
    to the upper right corner of the texture image.</p>
<p class="Pp"><i>format</i> determines the composition of each element in
    <i>data</i>. It can assume one of these symbolic values:</p>
<p class="Pp"><b>GL_RED</b></p>
<div class="Bd-indent">Each element is a single red component. The GL converts
  it to floating point and assembles it into an RGBA element by attaching 0 for
  green and blue, and 1 for alpha. Each component is then multiplied by the
  signed scale factor <b>GL_c_SCALE</b>, added to the signed bias
  <b>GL_c_BIAS</b>, and clamped to the range [0,1].</div>
<p class="Pp"><b>GL_RG</b></p>
<div class="Bd-indent">Each element is a red/green double. The GL converts it to
  floating point and assembles it into an RGBA element by attaching 0 for blue,
  and 1 for alpha. Each component is then multiplied by the signed scale factor
  <b>GL_c_SCALE</b>, added to the signed bias <b>GL_c_BIAS</b>, and clamped to
  the range [0,1].</div>
<p class="Pp"><b>GL_RGB</b></p>
<div class="Bd-indent"></div>
<p class="Pp"><b>GL_BGR</b></p>
<div class="Bd-indent">Each element is an RGB triple. The GL converts it to
  floating point and assembles it into an RGBA element by attaching 1 for alpha.
  Each component is then multiplied by the signed scale factor
  <b>GL_c_SCALE</b>, added to the signed bias <b>GL_c_BIAS</b>, and clamped to
  the range [0,1].</div>
<p class="Pp"><b>GL_RGBA</b></p>
<div class="Bd-indent"></div>
<p class="Pp"><b>GL_BGRA</b></p>
<div class="Bd-indent">Each element contains all four components. Each component
  is multiplied by the signed scale factor <b>GL_c_SCALE</b>, added to the
  signed bias <b>GL_c_BIAS</b>, and clamped to the range [0,1].</div>
<p class="Pp"><b>GL_DEPTH_COMPONENT</b></p>
<div class="Bd-indent">Each element is a single depth value. The GL converts it
  to floating point, multiplies by the signed scale factor
  <b>GL_DEPTH_SCALE</b>, adds the signed bias <b>GL_DEPTH_BIAS</b>, and clamps
  to the range [0,1].</div>
<p class="Pp"><b>GL_DEPTH_STENCIL</b></p>
<div class="Bd-indent">Each element is a pair of depth and stencil values. The
  depth component of the pair is interpreted as in <b>GL_DEPTH_COMPONENT</b>.
  The stencil component is interpreted based on specified the depth + stencil
  internal format.</div>
<p class="Pp">If an application wants to store the texture at a certain
    resolution or in a certain format, it can request the resolution and format
    with <i>internalFormat</i>. The GL will choose an internal representation
    that closely approximates that requested by <i>internalFormat</i>, but it
    may not match exactly. (The representations specified by <b>GL_RED</b>,
    <b>GL_RG</b>, <b>GL_RGB</b>, and <b>GL_RGBA</b> must match exactly.)</p>
<p class="Pp">If the <i>internalFormat</i> parameter is one of the generic
    compressed formats, <b>GL_COMPRESSED_RED</b>, <b>GL_COMPRESSED_RG</b>,
    <b>GL_COMPRESSED_RGB</b>, or <b>GL_COMPRESSED_RGBA</b>, the GL will replace
    the internal format with the symbolic constant for a specific internal
    format and compress the texture before storage. If no corresponding internal
    format is available, or the GL can not compress that image for any reason,
    the internal format is instead replaced with a corresponding base internal
    format.</p>
<p class="Pp">If the <i>internalFormat</i> parameter is <b>GL_SRGB</b>,
    <b>GL_SRGB8</b>, <b>GL_SRGB_ALPHA</b>, or <b>GL_SRGB8_ALPHA8</b>, the
    texture is treated as if the red, green, or blue components are encoded in
    the sRGB color space. Any alpha component is left unchanged. The conversion
    from the sRGB encoded component c s to a linear component c l is:</p>
<p class="Pp">c l = { c s 12.92 if c s &#x2264; 0.04045 ( c s + 0.055 1.055 )
    2.4 if c s &gt; 0.04045</p>
<p class="Pp">Assume c s is the sRGB component in the range [0,1].</p>
<p class="Pp">Use the <b>GL_PROXY_TEXTURE_2D</b>,
    <b>GL_PROXY_TEXTURE_1D_ARRAY</b>, <b>GL_PROXY_TEXTURE_RECTANGLE</b>, or
    <b>GL_PROXY_TEXTURE_CUBE_MAP</b> target to try out a resolution and format.
    The implementation will update and recompute its best match for the
    requested storage resolution and format. To then query this state, call
    <b>glGetTexLevelParameter</b>(). If the texture cannot be accommodated,
    texture state is set to 0.</p>
<p class="Pp">A one-component texture image uses only the red component of the
    RGBA color extracted from <i>data</i>. A two-component image uses the R and
    G values. A three-component image uses the R, G, and B values. A
    four-component image uses all of the RGBA components.</p>
<p class="Pp">Image-based shadowing can be enabled by comparing texture r
    coordinates to depth texture values to generate a boolean result. See
    <b>glTexParameter</b>() for details on texture comparison.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<p class="Pp">The <b>glPixelStore</b>() mode affects texture images.</p>
<p class="Pp"><i>data</i> may be a null pointer. In this case, texture memory is
    allocated to accommodate a texture of width <i>width</i> and height
    <i>height</i>. You can then download subtextures to initialize this texture
    memory. The image is undefined if the user tries to apply an uninitialized
    portion of the texture image to a primitive.</p>
<p class="Pp"><b>glTexImage2D</b> specifies the two-dimensional texture for the
    current texture unit, specified with <b>glActiveTexture</b>().</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ERRORS"><a class="permalink" href="#ERRORS">ERRORS</a></h1>
<p class="Pp"><b>GL_INVALID_ENUM</b> is generated if <i>target</i> is not
    <b>GL_TEXTURE_2D</b>, <b>GL_TEXTURE_1D_ARRAY</b>,
    <b>GL_TEXTURE_RECTANGLE</b>, <b>GL_PROXY_TEXTURE_2D</b>,
    <b>GL_PROXY_TEXTURE_1D_ARRAY</b>, <b>GL_PROXY_TEXTURE_RECTANGLE</b>,
    <b>GL_PROXY_TEXTURE_CUBE_MAP</b>, <b>GL_TEXTURE_CUBE_MAP_POSITIVE_X</b>,
    <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</b>,
    <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</b>,
    <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</b>,
    <b>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</b>, or
    <b>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</b>.</p>
<p class="Pp"><b>GL_INVALID_ENUM</b> is generated if <i>target</i> is one of the
    six cube map 2D image targets and the width and height parameters are not
    equal.</p>
<p class="Pp"><b>GL_INVALID_ENUM</b> is generated if <i>type</i> is not a type
    constant.</p>
<p class="Pp"><b>GL_INVALID_VALUE</b> is generated if <i>width</i> is less than
    0 or greater than <b>GL_MAX_TEXTURE_SIZE</b>.</p>
<p class="Pp"><b>GL_INVALID_VALUE</b> is generated if <i>target</i> is not
    <b>GL_TEXTURE_1D_ARRAY</b> or <b>GL_PROXY_TEXTURE_1D_ARRAY</b> and
    <i>height</i> is less than 0 or greater than <b>GL_MAX_TEXTURE_SIZE</b>.</p>
<p class="Pp"><b>GL_INVALID_VALUE</b> is generated if <i>target</i> is
    <b>GL_TEXTURE_1D_ARRAY</b> or <b>GL_PROXY_TEXTURE_1D_ARRAY</b> and
    <i>height</i> is less than 0 or greater than
    <b>GL_MAX_ARRAY_TEXTURE_LAYERS</b>.</p>
<p class="Pp"><b>GL_INVALID_VALUE</b> is generated if <i>level</i> is less than
    0.</p>
<p class="Pp"><b>GL_INVALID_VALUE</b> may be generated if <i>level</i> is
    greater than log 2 &#x2061; max, where <i>max</i> is the returned value of
    <b>GL_MAX_TEXTURE_SIZE</b>.</p>
<p class="Pp"><b>GL_INVALID_VALUE</b> is generated if <i>internalFormat</i> is
    not one of the accepted resolution and format symbolic constants.</p>
<p class="Pp"><b>GL_INVALID_VALUE</b> is generated if <i>width</i> or
    <i>height</i> is less than 0 or greater than <b>GL_MAX_TEXTURE_SIZE</b>.</p>
<p class="Pp"><b>GL_INVALID_VALUE</b> is generated if non-power-of-two textures
    are not supported and the <i>width</i> or <i>height</i> cannot be
    represented as 2 k + 2 &#x2061; border for some integer value of
  <i>k</i>.</p>
<p class="Pp"><b>GL_INVALID_VALUE</b> is generated if <i>border</i> is not
  0.</p>
<p class="Pp"><b>GL_INVALID_OPERATION</b> is generated if <i>type</i> is one of
    <b>GL_UNSIGNED_BYTE_3_3_2</b>, <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>,
    <b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>, or
    <b>GL_UNSIGNED_INT_10F_11F_11F_REV</b>, and <i>format</i> is not
    <b>GL_RGB</b>.</p>
<p class="Pp"><b>GL_INVALID_OPERATION</b> is generated if <i>type</i> is one of
    <b>GL_UNSIGNED_SHORT_4_4_4_4</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>,
    <b>GL_UNSIGNED_SHORT_5_5_5_1</b>, <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,
    <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>,
    <b>GL_UNSIGNED_INT_10_10_10_2</b>, <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>, or
    <b>GL_UNSIGNED_INT_5_9_9_9_REV</b>, and <i>format</i> is neither
    <b>GL_RGBA</b> nor <b>GL_BGRA</b>.</p>
<p class="Pp"><b>GL_INVALID_OPERATION</b> is generated if <i>target</i> is not
    <b>GL_TEXTURE_2D</b>, <b>GL_PROXY_TEXTURE_2D</b>,
    <b>GL_TEXTURE_RECTANGLE</b>, or <b>GL_PROXY_TEXTURE_RECTANGLE</b>, and
    <i>internalFormat</i> is <b>GL_DEPTH_COMPONENT</b>,
    <b>GL_DEPTH_COMPONENT16</b>, <b>GL_DEPTH_COMPONENT24</b>, or
    <b>GL_DEPTH_COMPONENT32F</b>.</p>
<p class="Pp"><b>GL_INVALID_OPERATION</b> is generated if <i>format</i> is
    <b>GL_DEPTH_COMPONENT</b> and <i>internalFormat</i> is not
    <b>GL_DEPTH_COMPONENT</b>, <b>GL_DEPTH_COMPONENT16</b>,
    <b>GL_DEPTH_COMPONENT24</b>, or <b>GL_DEPTH_COMPONENT32F</b>.</p>
<p class="Pp"><b>GL_INVALID_OPERATION</b> is generated if <i>internalFormat</i>
    is <b>GL_DEPTH_COMPONENT</b>, <b>GL_DEPTH_COMPONENT16</b>,
    <b>GL_DEPTH_COMPONENT24</b>, or <b>GL_DEPTH_COMPONENT32F</b>, and
    <i>format</i> is not <b>GL_DEPTH_COMPONENT</b>.</p>
<p class="Pp"><b>GL_INVALID_OPERATION</b> is generated if a non-zero buffer
    object name is bound to the <b>GL_PIXEL_UNPACK_BUFFER</b> target and the
    buffer object's data store is currently mapped.</p>
<p class="Pp"><b>GL_INVALID_OPERATION</b> is generated if a non-zero buffer
    object name is bound to the <b>GL_PIXEL_UNPACK_BUFFER</b> target and the
    data would be unpacked from the buffer object such that the memory reads
    required would exceed the data store size.</p>
<p class="Pp"><b>GL_INVALID_OPERATION</b> is generated if a non-zero buffer
    object name is bound to the <b>GL_PIXEL_UNPACK_BUFFER</b> target and
    <i>data</i> is not evenly divisible into the number of bytes needed to store
    in memory a datum indicated by <i>type</i>.</p>
<p class="Pp"><b>GL_INVALID_VALUE</b> is generated if <i>target</i> is
    <b>GL_TEXTURE_RECTANGLE</b> or <b>GL_PROXY_TEXTURE_RECTANGLE</b> and
    <i>level</i> is not 0.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ASSOCIATED_GETS"><a class="permalink" href="#ASSOCIATED_GETS">ASSOCIATED
  GETS</a></h1>
<p class="Pp"><b>glGetTexImage</b>()</p>
<p class="Pp"><b>glGet</b>() with argument
  <b>GL_PIXEL_UNPACK_BUFFER_BINDING</b></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>glActiveTexture</b>(), <b>glCopyTexImage1D</b>(),
    <b>glCopyTexImage2D</b>(), <b>glCopyTexSubImage1D</b>(),
    <b>glCopyTexSubImage2D</b>(), <b>glCopyTexSubImage3D</b>(),
    <b>glPixelStore</b>(), <b>glTexImage1D</b>(), <b>glTexImage3D</b>(),
    <b>glTexSubImage1D</b>(), <b>glTexSubImage2D</b>(),
    <b>glTexSubImage3D</b>(), <b>glTexParameter</b>()</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Copyright &#x00A9; 1991-2006 Silicon Graphics, Inc. This document
    is licensed under the SGI Free Software B License. For details, see
    <b>http://oss.sgi.com/projects/FreeB/</b>.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">03/08/2011</td>
    <td class="foot-os"><a href="..">OpenGL 3.3</a></td>
  </tr>
</table>
</body>
</html>

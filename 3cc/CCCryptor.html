<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>CCCryptor(3cc)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">CCCryptor(3cc)</td>
    <td class="head-vol">3cc</td>
    <td class="head-rtitle">CCCryptor(3cc)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp"><code class="Nm">CCCryptorCreate</code>,
    <code class="Nm">CCCryptorCreateFromData</code>,
    <code class="Nm">CCCryptorRelease</code>,
    <code class="Nm">CCCryptorUpdate</code>,
    <code class="Nm">CCCryptorFinal</code>,
    <code class="Nm">CCCryptorGetOutputLength</code>,
    <code class="Nm">CCCryptorReset</code>, <code class="Nm">CCCrypt</code>
    &#x2014; <span class="Nd">Common Cryptographic Algorithm
  Interfaces</span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="LIBRARY"><a class="permalink" href="#LIBRARY">LIBRARY</a></h1>
<p class="Pp">These functions are found in libSystem.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp"><code class="In">#include
    &lt;<a class="In">CommonCrypto/CommonCryptor.h</a>&gt;</code></p>
<p class="Pp"><var class="Ft">CCCryptorStatus</var>
  <br/>
  <code class="Fn">CCCryptorCreate</code>(<var class="Fa" style="white-space: nowrap;">CCOperation
    op</var>, <var class="Fa" style="white-space: nowrap;">CCAlgorithm
    alg</var>, <var class="Fa" style="white-space: nowrap;">CCOptions
    options</var>, <var class="Fa" style="white-space: nowrap;">const void
    *key</var>, <var class="Fa" style="white-space: nowrap;">size_t
    keyLength</var>, <var class="Fa" style="white-space: nowrap;">const void
    *iv</var>, <var class="Fa" style="white-space: nowrap;">CCCryptorRef
    *cryptorRef</var>);</p>
<p class="Pp"><var class="Ft">CCCryptorStatus</var>
  <br/>
  <code class="Fn">CCCryptorCreateFromData</code>(<var class="Fa" style="white-space: nowrap;">CCOperation
    op</var>, <var class="Fa" style="white-space: nowrap;">CCAlgorithm
    alg</var>, <var class="Fa" style="white-space: nowrap;">CCOptions
    options</var>, <var class="Fa" style="white-space: nowrap;">const void
    *key</var>, <var class="Fa" style="white-space: nowrap;">size_t
    keyLength</var>, <var class="Fa" style="white-space: nowrap;">const void
    *iv</var>, <var class="Fa" style="white-space: nowrap;">const void
    *data</var>, <var class="Fa" style="white-space: nowrap;">size_t
    dataLength</var>, <var class="Fa" style="white-space: nowrap;">CCCryptorRef
    *cryptorRef</var>, <var class="Fa" style="white-space: nowrap;">size_t
    *dataUsed</var>);</p>
<p class="Pp"><var class="Ft">CCCryptorStatus</var>
  <br/>
  <code class="Fn">CCCryptorCreateWithMode</code>(<var class="Fa" style="white-space: nowrap;">CCOperation
    op</var>, <var class="Fa" style="white-space: nowrap;">CCMode mode</var>,
    <var class="Fa" style="white-space: nowrap;">CCAlgorithm alg&quot;CCPadding
    padding</var>, <var class="Fa" style="white-space: nowrap;">const void
    *iv</var>, <var class="Fa" style="white-space: nowrap;">const void
    *key</var>, <var class="Fa" style="white-space: nowrap;">size_t
    keyLength</var>, <var class="Fa" style="white-space: nowrap;">const void
    *tweak</var>, <var class="Fa" style="white-space: nowrap;">size_t
    tweakLength</var>, <var class="Fa" style="white-space: nowrap;">int
    numRounds</var>, <var class="Fa" style="white-space: nowrap;">CCModeOptions
    options</var>, <var class="Fa" style="white-space: nowrap;">CCryptorRef
    *cryptorRef</var>);</p>
<p class="Pp"><var class="Ft">CCCryptorStatus</var>
  <br/>
  <code class="Fn">CCCryptorRelease</code>(<var class="Fa" style="white-space: nowrap;">CCCryptorRef
    cryptorRef</var>);</p>
<p class="Pp"><var class="Ft">CCCryptorStatus</var>
  <br/>
  <code class="Fn">CCCryptorUpdate</code>(<var class="Fa" style="white-space: nowrap;">CCCryptorRef
    cryptorRef</var>, <var class="Fa" style="white-space: nowrap;">const void
    *dataIn</var>, <var class="Fa" style="white-space: nowrap;">size_t
    dataInLength</var>, <var class="Fa" style="white-space: nowrap;">void
    *dataOut</var>, <var class="Fa" style="white-space: nowrap;">size_t
    dataOutAvailable</var>, <var class="Fa" style="white-space: nowrap;">size_t
    *dataOutMoved</var>);</p>
<p class="Pp"><var class="Ft">CCCryptorStatus</var>
  <br/>
  <code class="Fn">CCCryptorFinal</code>(<var class="Fa" style="white-space: nowrap;">CCCryptorRef
    cryptorRef</var>, <var class="Fa" style="white-space: nowrap;">void
    *dataOut</var>, <var class="Fa" style="white-space: nowrap;">size_t
    dataOutAvailable</var>, <var class="Fa" style="white-space: nowrap;">size_t
    *dataOutMoved</var>);</p>
<p class="Pp"><var class="Ft">size_t</var>
  <br/>
  <code class="Fn">CCCryptorGetOutputLength</code>(<var class="Fa" style="white-space: nowrap;">CCCryptorRef
    cryptorRef</var>, <var class="Fa" style="white-space: nowrap;">size_t
    inputLength</var>, <var class="Fa" style="white-space: nowrap;">bool
    final</var>);</p>
<p class="Pp"><var class="Ft">CCCryptorStatus</var>
  <br/>
  <code class="Fn">CCCryptorReset</code>(<var class="Fa" style="white-space: nowrap;">CCCryptorRef
    cryptorRef</var>, <var class="Fa" style="white-space: nowrap;">const void
    *iv</var>);</p>
<p class="Pp"><var class="Ft">CCCryptorStatus</var>
  <br/>
  <code class="Fn">CCCrypt</code>(<var class="Fa" style="white-space: nowrap;">CCOperation
    op</var>, <var class="Fa" style="white-space: nowrap;">CCAlgorithm
    alg</var>, <var class="Fa" style="white-space: nowrap;">CCOptions
    options</var>, <var class="Fa" style="white-space: nowrap;">const void
    *key</var>, <var class="Fa" style="white-space: nowrap;">size_t
    keyLength</var>, <var class="Fa" style="white-space: nowrap;">const void
    *iv</var>, <var class="Fa" style="white-space: nowrap;">const void
    *dataIn</var>, <var class="Fa" style="white-space: nowrap;">size_t
    dataInLength</var>, <var class="Fa" style="white-space: nowrap;">void
    *dataOut</var>, <var class="Fa" style="white-space: nowrap;">size_t
    dataOutAvailable</var>, <var class="Fa" style="white-space: nowrap;">size_t
    *dataOutMoved</var>);</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This interface provides access to a number of symmetric encryption
    algorithms. Symmetric encryption algorithms come in two &quot;flavors&quot;
    - block ciphers, and stream ciphers. Block ciphers process data (while both
    encrypting and decrypting) in discrete chunks of data called blocks; stream
    ciphers operate on arbitrary sized data.</p>
<p class="Pp" id="CCCryptor,">The object declared in this interface,
    <a class="permalink" href="#CCCryptor,"><code class="Fn">CCCryptor,</code></a>()
    provides access to both block ciphers and stream ciphers with the same API;
    however some options are available for block ciphers that do not apply to
    stream ciphers.</p>
<p class="Pp" id="CCCryptor">The general operation of a call to
    <a class="permalink" href="#CCCryptor"><code class="Fn">CCCryptor</code></a>()
    is: initialize it with raw key data and other optional fields with
    <code class="Fn">CCCryptorCreate</code>() ; process input data via one or
    more calls to <code class="Fn">CCCryptorUpdate</code>() each of which may
    result in output data being written to caller-supplied memory; and obtain
    possible remaining output data with
    <a class="permalink" href="#CCCryptorFinal."><code class="Fn" id="CCCryptorFinal.">CCCryptorFinal.</code></a>()
    The <var class="Ft">CCCryptor</var> is disposed of via
    <a class="permalink" href="#CCCryptorRelease,"><code class="Fn" id="CCCryptorRelease,">CCCryptorRelease,</code></a>()
    or in CBC and CTR modes (and only those modes), it can be reused (with the
    same key data as provided to <code class="Fn">CCCryptorCreate</code>() ) by
    calling <code class="Fn">CCCryptorReset</code>()
    <code class="Fn">CCCrypt</code>() can be called.</p>
<p class="Pp"><var class="Ft">CCCryptors</var> can be dynamically allocated by
    this module, or their memory can be allocated by the caller.</p>
<p class="Pp" id="CCCryptorCreate">A call to
    <a class="permalink" href="#CCCryptorCreate"><code class="Fn">CCCryptorCreate</code></a>()
    or <code class="Fn">CCCrypt</code>() will require a
    <var class="Ft">CCOperation</var> , which can be either
    <var class="Ft">kCCEncrypt</var> , or <var class="Ft">kCCDecrypt.</var> The
    <var class="Ft">CCAlgorithm</var> choice allows specification of the cipher
    to use, with <var class="Ft">kCCAlgorithmAES</var> being the recommended
    choice. All supported stream ciphers (e.g., RC2 and RC4) are no longer
    considered secure and should not be used.</p>
<p class="Pp">The options parameter is only used when specifying a block-cipher,
    and should be set to 0 if a stream-cipher is being used. Otherwise the
    following options are allowed, and may be ORed together. The options allow
    for the use of PKCS7 padding by setting the flag
    <var class="Ft">kCCOptionPKCS7Padding</var> , and the use of the non-default
    mode of the cipher <var class="Ft">kCCOptionECBMode.</var> This flag puts
    the cipher in Electronic Code Book mode and should not be used for
    encryption as this is known to be insecure, but rather it is provided to
    allow for direct access to the output of the block-cipher.</p>
<p class="Pp">PKCS7; when padding is enabled, the total amount of data encrypted
    does not have to be an even multiple of the block size, and the actual
    length of plaintext is calculated during decryption.</p>
<p class="Pp">If the ECB mode option is not specified, then by default block
    ciphers are used in Cipher Block Chaining mode, also known as CBC mode. When
    using CBC mode, an Initialization Vector (IV) should be provided along with
    the key when starting an encrypt or decrypt operation. The IV should be the
    same length in bytes as the block-cipher's length. If CBC mode is selected
    and no IV is provided, an IV of all zeroes will be used, which in many
    applications will result in security issues.</p>
<p class="Pp" id="CCCryptor~2"><a class="permalink" href="#CCCryptor~2"><code class="Fn">CCCryptor</code></a>()
    also implements block buffering, so that individual calls to
    <code class="Fn">CCCryptorUpdate</code>() do not have to provide data whose
    length is aligned to the block size. (If padding is disabled, encrypting
    with block ciphers does require that the *total* length of data input to
    <code class="Fn">CCCryptorUpdate</code>() call(s) be aligned to the block
    size.)</p>
<p class="Pp" id="CCCryptorUpdate">Encryption and decryption can be performed
    &quot;in-place&quot;, with the same buffer used for input and output. The
    <a class="permalink" href="#CCCryptorUpdate"><code class="Fn">CCCryptorUpdate</code></a>()
    does not support in-place operation for ciphers modes that work with blocks
    of data such as CBC and ECB, because of block buffering.</p>
<p class="Pp" id="CCCryptor~3">A given
    <a class="permalink" href="#CCCryptor~3"><code class="Fn">CCCryptor</code></a>()
    can only be used by one thread at a time; multiple threads can safely use
    different
    <a class="permalink" href="#CCCryptors"><code class="Fn" id="CCCryptors">CCCryptors</code></a>()
    at the same time.</p>
<p class="Pp" id="CCCryptorCreate~2"><var class="Ft">CCCryptorRef</var> objects
    created with
    <a class="permalink" href="#CCCryptorCreate~2"><code class="Fn">CCCryptorCreate</code></a>()
    or <code class="Fn">CCCryptorCreateFromData</code>() must be disposed of via
    <a class="permalink" href="#CCCRyptorRelease"><code class="Fn" id="CCCRyptorRelease">CCCRyptorRelease</code></a>()
    ; which clears sensitive data and deallocates the
    <var class="Ft">CCCryptorRef</var> when the caller is finished using the
    <var class="Ft">CCCryptorRef.</var></p>
<p class="Pp" id="CCCryptorUpdate~2"><a class="permalink" href="#CCCryptorUpdate~2"><code class="Fn">CCCryptorUpdate</code></a>()
    is used to encrypt or decrypt data. This routine can be called multiple
    times. The caller does not need to align input data lengths to block sizes;
    input is buffered as necessary for block ciphers.</p>
<p class="Pp" id="CCCryptFinal">When performing symmetric encryption with block
    ciphers, and padding is enabled via
    <var class="Ft">kCCOptionPKCS7Padding,</var> the total number of bytes
    provided by all the calls to this function when encrypting can be arbitrary
    (i.e., the total number of bytes does not have to be block aligned). However
    if padding is disabled, or when decrypting, the total number of bytes does
    have to be aligned to the block size; otherwise
    <a class="permalink" href="#CCCryptFinal"><code class="Fn">CCCryptFinal</code></a>()
    will return <var class="Ft">kCCAlignmentError.</var></p>
<p class="Pp" id="CCCryptorGetOutputLength">A general rule for the size of the
    output buffer which must be provided by the caller is that for block
    ciphers, the output length is never larger than the input length plus the
    block size. For stream ciphers, the output length is always exactly the same
    as the input length. See the discussion for
    <a class="permalink" href="#CCCryptorGetOutputLength"><code class="Fn">CCCryptorGetOutputLength</code></a>()
    for more information on this topic.</p>
<p class="Pp" id="CCCryptFinal~2"><a class="permalink" href="#CCCryptFinal~2"><code class="Fn">CCCryptFinal</code></a>()
    finishes encryption and decryption operations and obtains the final data
    output. Except when <var class="Ft">kCCBufferTooSmall</var> is returned, the
    <var class="Ft">CCCryptorRef</var> can no longer be used for subsequent
    operations unless <code class="Fn">CCCryptorReset</code>() is called on it,
    but this is only available in CBC or CTR mode.</p>
<p class="Pp" id="CCCryptorFinal">It is not necessary to call
    <a class="permalink" href="#CCCryptorFinal"><code class="Fn">CCCryptorFinal</code></a>()
    when performing symmetric encryption or decryption if padding is disabled,
    or when using a stream cipher.</p>
<p class="Pp" id="CCCryptorFinal~2">It is not necessary to call
    <a class="permalink" href="#CCCryptorFinal~2"><code class="Fn">CCCryptorFinal</code></a>()
    prior to
    <a class="permalink" href="#CCCryptorRelease"><code class="Fn" id="CCCryptorRelease">CCCryptorRelease</code></a>()
    when aborting an operation.</p>
<p class="Pp" id="CCCryptorGetOutputLength~2">Use
    <a class="permalink" href="#CCCryptorGetOutputLength~2"><code class="Fn">CCCryptorGetOutputLength</code></a>()
    to determine output buffer size required to process a given input size. Some
    general rules apply that allow clients of this module to know a priori how
    much output buffer space will be required in a given situation. For stream
    ciphers, the output size is always equal to the input size, and
    <code class="Fn">CCCryptorFinal</code>() never produces any data. For block
    ciphers, the output size will always be less than or equal to the input size
    plus the size of one block. For block ciphers, if the input size provided to
    each call to <code class="Fn">CCCryptorUpdate</code>() is is an integral
    multiple of the block size, then the output size for each call to
    <code class="Fn">CCCryptorUpdate</code>() is less than or equal to the input
    size for that call to <code class="Fn">CCCryptorUpdate</code>().
    <code class="Fn">CCCryptorFinal</code>() only produces output when using a
    block cipher with padding enabled.</p>
<p class="Pp" id="CCCryptorReset"><a class="permalink" href="#CCCryptorReset"><code class="Fn">CCCryptorReset</code></a>()
    reinitializes an existing <var class="Ft">CCCryptorRef</var> with a
    (possibly) new initialization vector. The key contained in the
    <var class="Ft">CCCryptorRef</var> is unchanged. This function is not
    implemented for any modes other than CBC or CTR, nor is it implemented for
    stream ciphers, and will return an error in such cases. This can be called
    on a CCCryptorRef with data pending (i.e. in a padded mode operation before
    <code class="Fn">CCCryptFinal</code>() is called); however any pending data
    will be lost in that case.</p>
<p class="Pp" id="CCCrypt"><a class="permalink" href="#CCCrypt"><code class="Fn">CCCrypt</code></a>()
    is a stateless, one-shot encrypt or decrypt operation. This basically
    performs a sequence of
    <a class="permalink" href="#CCCrytorCreate"><code class="Fn" id="CCCrytorCreate">CCCrytorCreate</code></a>(),
    <code class="Fn">CCCryptorUpdate</code>(),
    <code class="Fn">CCCryptorFinal</code>(), and
    <code class="Fn">CCCryptorRelease</code>().</p>
<p class="Pp" id="CCCryptorCreateWithMode">If a mode other than CBC or ECB is
    desired,
    <a class="permalink" href="#CCCryptorCreateWithMode"><code class="Fn">CCCryptorCreateWithMode</code></a>()
    can be used to specify other modes. Possible modes include Electronic Code
    Book, Cipher Block Chaining, Cipher Feedback, Output Feedback, and Counter
    Modes, which are specified by mode set respectively to:
  <br/>
   kCCModeECB,
  <br/>
   kCCModeCBC,
  <br/>
   kCCModeCFB,
  <br/>
   kCCModeCTR, and
  <br/>
   kCCModeOFB.</p>
<p class="Pp">In such calls, q.Ft tweak should be set to NULL, and
    <var class="Ft">tweakLength, numRounds</var> and
    <var class="Ft">options</var> are reserved for future use and must be set to
    0. Padding is set as either <var class="Ft">ccNoPadding,</var> or
    <var class="Ft">ccPKCS7Padding.</var></p>
<p class="Pp">Formally, the following ciphers are supported in CCCryptor
  <br/>
   kCCAlgorithmAES,
  <br/>
   kCCAlgorithmDES,
  <br/>
   kCCAlgorithm3DES,
  <br/>
   kCCAlgorithmCAST,
  <br/>
   kCCAlgorithmRC4,
  <br/>
   kCCAlgorithmRC2, and
  <br/>
   kCCAlgorithmBlowfish.</p>
<p class="Pp">Caution should be used as several of these ciphers are only
    supported for legacy reasons, and are now often considered broken, or too
    weak for use (ie. DES, CAST, RC4, and RC2). The small block length 3DES,
    CAST and Blowfish requires their use only in specific cases. Similarly, CAST
    should only be used with 16 byte keys.</p>
<p class="Pp">Block sizes, in bytes, for supported Ciphers.
    <var class="Ft">kCCBlockSizeAES128</var> is 16 bytes.
    <var class="Ft">kCCBlockSizeDES,</var>
    <var class="Ft">kCCBlockSize3DES,</var> and
    <var class="Ft">kCCBlockSizeCAST</var> are all 8 bytes.</p>
<p class="Pp">Key sizes supported for various ciphers are defined by the
    following constants, and must be given in fixed byte lengths. The following
    AES key bit length constants, define their corresponding byte equivalents:
  <br/>
   kCCKeySizeAES128 = 16,
  <br/>
   kCCKeySizeAES192 = 24, and
  <br/>
   kCCKeySizeAES256 = 32.</p>
<p class="Pp">DES and 3DES use
  <br/>
   kCCKeySizeDES = 8, and
  <br/>
   kCCKeySize3DES = 16, respectively.</p>
<p class="Pp">For the remaining ciphers:
  <br/>
   kCCKeySizeMinCAST = 5,
  <br/>
   kCCKeySizeMaxCAST = 16,
  <br/>
   kCCKeySizeMinRC4 = 1,
  <br/>
   kCCKeySizeMaxRC4 = 512,
  <br/>
   kCCKeySizeMinRC2 = 1,
  <br/>
   kCCKeySizeMaxRC2 = 128,
  <br/>
   kCCKeySizeMinBlowfish = 8, and
  <br/>
   kCCKeySizeMaxBlowfish = 56,</p>
<p class="Pp">define the relative minimum and maximum lengths of the keys. Note
    that any key shorter than 16 bytes frequently fails to provide suitable
    security guarantees. However, having a key of length 16 bytes does not
    ensure security. As mentioned earlier, many of the supported ciphers and
    modes are no longer considered secure.</p>
<p class="Pp" id="CCCryptorCreateFromData">Minimum context sizes, for
    caller-allocated <var class="Ft">CCCryptorRefs.</var> To minimize dynamic
    allocation memory, a caller can create a by passing caller-supplied memory
    to the
    <a class="permalink" href="#CCCryptorCreateFromData"><code class="Fn">CCCryptorCreateFromData</code></a>()
    function.</p>
<p class="Pp" id="CCCryptorRefs">These constants define the minimum amount of
    memory, in bytes, needed for
    <a class="permalink" href="#CCCryptorRefs"><code class="Fn">CCCryptorRefs</code></a>()
    for each supported cipher.</p>
<p class="Pp" id="CCCryptorCreateFromData.">Note: these constants are valid for
    the current version of this library; they may change in subsequent releases,
    so applications wishing to allocate their own memory for use in creating
    <var class="Ft">CCCryptorRefs</var> must be prepared to deal with a
    <var class="Ft">kCCBufferTooSmall</var> returned from
    <a class="permalink" href="#CCCryptorCreateFromData."><code class="Fn">CCCryptorCreateFromData.</code></a>()</p>
<p class="Pp"><var class="Ft">kCCContextSizeAES128</var> - Minimum context size
    for kCCAlgorithmAES128. <var class="Ft">kCCContextSizeDES</var> - Minimum
    context size for kCCAlgorithmDES. <var class="Ft">kCCContextSize3DES</var> -
    Minimum context size for kCCAlgorithm3DES.
    <var class="Ft">kCCContextSizeCAST</var> - Minimum context size for
    kCCAlgorithmCAST. <var class="Ft">kCCContextSizeRC4</var> - Minimum context
    size for kCCAlgorithmRC4.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_VALUES"><a class="permalink" href="#RETURN_VALUES">RETURN
  VALUES</a></h1>
<p class="Pp">The following values may be returned as a status of type
    <var class="Ft">CCCryptorStatus</var>.</p>
<p class="Pp"><code class="Er">kCCSuccess</code> - Operation completed
  normally.</p>
<p class="Pp"><code class="Er">kCCParamError</code> - Illegal parameter
  value.</p>
<p class="Pp"><code class="Er">kCCBufferTooSmall</code> - Insufficient buffer
    provided for specified operation.</p>
<p class="Pp"><code class="Er">kCCMemoryFailure</code> - Memory allocation
    failure.</p>
<p class="Pp"><code class="Er">kCCAlignmentError</code> - Input size was not
    aligned properly.</p>
<p class="Pp"><code class="Er">kCCDecodeError</code> - Input data did not decode
    or decrypt properly.</p>
<p class="Pp"><code class="Er">kCCUnimplemented</code> - Function not
    implemented for the current algorithm.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
<p class="Pp">These functions are available in OS X 10.5 and later.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><a class="Xr" href="../3cc/CCHmac">CCHmac(3cc)</a>,
    <a class="Xr" href="../3cc/CC_MD5">CC_MD5(3cc)</a>,
    <a class="Xr" href="../3cc/CC_SHA">CC_SHA(3cc)</a>,
    <a class="Xr" href="../3cc/CC_crypto">CC_crypto(3cc)</a></p>
</section>
<section class="Sh">
<h1 class="Sh" id="STANDARDS"><a class="permalink" href="#STANDARDS">STANDARDS</a></h1>
<dl class="Bl-tag">
  <dt>AES:</dt>
  <dd>Federal Information Processing Standard FIPS PUB 197 (Advanced Encryption
      Standard),</dd>
  <dt>DES:</dt>
  <dd>Federal Information Processing Standard FIPS PUB 46-3 (Data Encryption
      Standard)</dd>
  <dt>3DES:</dt>
  <dd>NIST Special PublicationPUB 800-67 (Recommendation for the Triple Data
      Encryption Algorithm (TDEA) Block Cipher)</dd>
</dl>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">March 22, 2007</td>
    <td class="foot-os">macOS 15.1</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
  Modified from man(1) of FreeBSD, the NetBSD mdoc.template, and mdoc.samples.
  See Also:
  man mdoc.samples for a complete listing of options
  man mdoc for the short list of editing options
  /usr/share/misc/mdoc.template
   DATE
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>powermetrics(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">powermetrics(1)</td>
    <td class="head-vol">General Commands Manual</td>
    <td class="head-rtitle">powermetrics(1)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp"><code class="Nm">powermetrics</code></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<table class="Nm">
  <tr>
    <td><code class="Nm">powermetrics</code></td>
    <td>[<code class="Fl">-i</code> <var class="Ar">sample_interval_ms</var>]
      [<code class="Fl">-r</code> <var class="Ar">order</var>]
      [<code class="Fl">-t</code> <var class="Ar">wakeup_cost</var>]
      [<code class="Fl">-o</code> <var class="Ar">output_file</var>]
      [<code class="Fl">-n</code> <var class="Ar">sample_count</var>]</td>
  </tr>
</table>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><code class="Nm">powermetrics</code> gathers and display CPU usage
    statistics (divided into time spent in user mode and supervisor mode), timer
    and interrupt wakeup frequency (total and, for near-idle workloads, those
    that resulted in package idle exits), and on supported platforms, interrupt
    frequencies (categorized by CPU number), package C-state statistics (an
    indication of the time the core complex + integrated graphics, if any, were
    in low-power idle states), CPU frequency distribution during the sample. The
    tool may also display estimated power consumed by various SoC subsystems,
    such as CPU, GPU, ANE (Apple Neural Engine). Note: Average power values
    reported by powermetrics are estimated and may be inaccurate - hence they
    should not be used for any comparison between devices, but can be used to
    help optimize apps for energy efficiency.</p>
<dl class="Bl-tag">
  <dt id="h"><a class="permalink" href="#h"><code class="Fl">-h</code></a>,
    <code class="Fl">--help</code></dt>
  <dd>Print help message.</dd>
  <dt id="s"><a class="permalink" href="#s"><code class="Fl">-s</code></a>
    <var class="Ar">samplers</var>, <code class="Fl">--samplers</code>
    <var class="Ar">samplers</var></dt>
  <dd>Comma separated list of samplers and sampler groups. Run with -h to see a
      list of samplers and sampler groups. Specifying &quot;default&quot; will
      display the default set, and specifying &quot;all&quot; will display all
      supported samplers.</dd>
  <dt id="o"><a class="permalink" href="#o"><code class="Fl">-o</code></a>
    <var class="Ar">file</var>, <code class="Fl">--output-file</code>
    <var class="Ar">file</var></dt>
  <dd>Output to <var class="Ar">file</var> instead of stdout.</dd>
  <dt id="b"><a class="permalink" href="#b"><code class="Fl">-b</code></a>
    <var class="Ar">size</var>, <code class="Fl">--buffer-size</code>
    <var class="Ar">size</var></dt>
  <dd>Set output buffer <var class="Ar">size</var> (0=none, 1=line)</dd>
  <dt id="i"><a class="permalink" href="#i"><code class="Fl">-i</code></a>
    <var class="Ar">N</var>, <code class="Fl">--sample-rate</code>
    <var class="Ar">N</var></dt>
  <dd>sample every <var class="Ar">N</var> ms (0=disabled) [default:
    5000ms]</dd>
  <dt id="n"><a class="permalink" href="#n"><code class="Fl">-n</code></a>
    <var class="Ar">N</var>, <code class="Fl">--sample-count</code>
    <var class="Ar">N</var></dt>
  <dd>Obtain <var class="Ar">N</var> periodic samples (0=infinite) [default:
    0]</dd>
  <dt id="t"><a class="permalink" href="#t"><code class="Fl">-t</code></a>
    <var class="Ar">N</var>, <code class="Fl">--wakeup-cost</code>
    <var class="Ar">N</var></dt>
  <dd>Assume package idle wakeups have a CPU time cost of
      <var class="Ar">N</var> us when using hybrid sort orders using idle
      wakeups with time-based metrics</dd>
  <dt id="r"><a class="permalink" href="#r"><code class="Fl">-r</code></a>
    <var class="Ar">method</var>, <code class="Fl">--order</code>
    <var class="Ar">method</var></dt>
  <dd>Order process list using specified <var class="Ar">method</var> [default:
      composite]
    <p class="Pp"></p>
    <dl class="Bl-tag Bl-compact">
      <dt>[pid]</dt>
      <dd>process identifier</dd>
      <dt>[wakeups]</dt>
      <dd>total package idle wakeups (alias: -W)</dd>
      <dt>[cputime]</dt>
      <dd>total CPU time used (alias: -C)</dd>
      <dt>[composite]</dt>
      <dd>energy number, see --show-process-energy (alias: -O)</dd>
    </dl>
  </dd>
  <dt id="f"><a class="permalink" href="#f"><code class="Fl">-f</code></a>
    <var class="Ar">format</var>, <code class="Fl">--format</code>
    <var class="Ar">format</var></dt>
  <dd>Display data in specified format [default: text]
    <p class="Pp"></p>
    <dl class="Bl-tag Bl-compact">
      <dt>[text]</dt>
      <dd>human-readable text output</dd>
      <dt>[plist]</dt>
      <dd>machine-readable property list, NUL-separated</dd>
    </dl>
  </dd>
  <dt id="a"><a class="permalink" href="#a"><code class="Fl">-a</code></a>
    <var class="Ar">N</var>, <code class="Fl">--poweravg</code>
    <var class="Ar">N</var></dt>
  <dd>Display poweravg every <var class="Ar">N</var> samples (0=disabled)
      [default: 10]</dd>
  <dt id="hide-cpu-duty-cycle"><a class="permalink" href="#hide-cpu-duty-cycle"><code class="Fl">--hide-cpu-duty-cycle</code></a></dt>
  <dd>Hide CPU duty cycle data</dd>
  <dt id="show-initial-usage"><a class="permalink" href="#show-initial-usage"><code class="Fl">--show-initial-usage</code></a></dt>
  <dd>Print initial sample for entire uptime</dd>
  <dt id="show-usage-summary"><a class="permalink" href="#show-usage-summary"><code class="Fl">--show-usage-summary</code></a></dt>
  <dd>Print final usage summary when exiting</dd>
  <dt id="show-pstates"><a class="permalink" href="#show-pstates"><code class="Fl">--show-pstates</code></a></dt>
  <dd>Show pstate distribution. Only available on certain hardware.</dd>
  <dt id="show-plimits"><a class="permalink" href="#show-plimits"><code class="Fl">--show-plimits</code></a></dt>
  <dd>Show plimits, forced idle and RMBS. Only available on certain
    hardware.</dd>
  <dt id="show-cpu-qos"><a class="permalink" href="#show-cpu-qos"><code class="Fl">--show-cpu-qos</code></a></dt>
  <dd>Show per cpu QOS breakdowns.</dd>
  <dt id="show-process-coalition"><a class="permalink" href="#show-process-coalition"><code class="Fl">--show-process-coalition</code></a></dt>
  <dd>Group processes by coalitions and show per coalition information.
      Processes that have exited during the sample will still have their time
      billed to the coalition, making this useful for disambiguating DEAD_TASK
      time.</dd>
  <dt id="show-responsible-pid"><a class="permalink" href="#show-responsible-pid"><code class="Fl">--show-responsible-pid</code></a></dt>
  <dd>Show responsible pid for xpc services and parent pid</dd>
  <dt id="show-process-wait-times"><a class="permalink" href="#show-process-wait-times"><code class="Fl">--show-process-wait-times</code></a></dt>
  <dd>Show per-process sfi wait time info</dd>
  <dt id="show-process-qos-tiers"><a class="permalink" href="#show-process-qos-tiers"><code class="Fl">--show-process-qos-tiers</code></a></dt>
  <dd>Show per-process qos latency and throughput tier</dd>
  <dt id="show-process-io"><a class="permalink" href="#show-process-io"><code class="Fl">--show-process-io</code></a></dt>
  <dd>Show per-process io information</dd>
  <dt id="show-process-gpu"><a class="permalink" href="#show-process-gpu"><code class="Fl">--show-process-gpu</code></a></dt>
  <dd>Show per-process gpu time. This is only available on certain
    hardware.</dd>
  <dt id="show-process-netstats"><a class="permalink" href="#show-process-netstats"><code class="Fl">--show-process-netstats</code></a></dt>
  <dd>Show per-process network information</dd>
  <dt id="show-process-qos"><a class="permalink" href="#show-process-qos"><code class="Fl">--show-process-qos</code></a></dt>
  <dd>Show QOS times aggregated by process. Per thread information is not
      available.</dd>
  <dt id="show-process-energy"><a class="permalink" href="#show-process-energy"><code class="Fl">--show-process-energy</code></a></dt>
  <dd>Show per-process energy impact number. This number is a rough proxy for
      the total energy the process uses, including CPU, GPU, disk io and
      networking. The weighting of each is platform specific. Enabling this
      implicitly enables sampling of all the above per-process statistics.</dd>
  <dt id="show-process-samp-norm"><a class="permalink" href="#show-process-samp-norm"><code class="Fl">--show-process-samp-norm</code></a></dt>
  <dd>Show CPU time normailzed by the sample window, rather than the process
      start time. For example a process that launched 1 second before the end of
      a 5 second sample window and ran continuously until the end of the window
      will show up as 200 ms/s here and 1000 ms/s in the regular column.</dd>
  <dt id="show-process-ipc"><a class="permalink" href="#show-process-ipc"><code class="Fl">--show-process-ipc</code></a></dt>
  <dd>Show per-process Instructions and cycles on ARM machines. Use with
      --show-process-amp to show cluster stats.</dd>
  <dt id="show-all"><a class="permalink" href="#show-all"><code class="Fl">--show-all</code></a></dt>
  <dd>Enables all samplers and displays all the available information for each
      sampler.</dd>
</dl>
<p class="Pp">This tool also implements special behavior upon receipt of certain
    signals to aid with the automated collection of data:</p>
<p class="Pp"></p>
<dl class="Bl-tag Bl-compact">
  <dt id="SIGINFO"><a class="permalink" href="#SIGINFO"><code class="Li">SIGINFO</code></a></dt>
  <dd>take an immediate sample</dd>
  <dt id="SIGIO"><a class="permalink" href="#SIGIO"><code class="Li">SIGIO</code></a></dt>
  <dd>flush any buffered output</dd>
  <dt id="SIGINT/SIGTERM/SIGHUP"><a class="permalink" href="#SIGINT/SIGTERM/SIGHUP"><code class="Li">SIGINT/SIGTERM/SIGHUP</code></a></dt>
  <dd>stop sampling and exit</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="OUTPUT"><a class="permalink" href="#OUTPUT">OUTPUT</a></h1>
<p class="Pp"><a class="permalink" href="#Guidelines"><i class="Em" id="Guidelines">Guidelines
    for energy reduction</i></a></p>
<p class="Pp">CPU time, deadlines and interrupt wakeups: Lower is better</p>
<p class="Pp">Interrupt counts: Lower is better</p>
<p class="Pp">C-state residency: Higher is better</p>
<p class="Pp" id="Running"><a class="permalink" href="#Running"><i class="Em">Running
    Tasks</i></a></p>
<p class="Pp">1. CPU time consumed by threads assigned to that process, broken
    down into time spent in user space and kernel mode.</p>
<p class="Pp">2. Counts of &quot;short&quot; timers (where the time-to-deadline
    was &lt; 5 milliseconds in the future at the point of timer creation) which
    woke up threads from that process. High frequency timers, which typically
    have short time-to-deadlines, can result in significant energy
  consumption.</p>
<p class="Pp">3. A count of total interrupt level wakeups which resulted in
    dispatching a thread from the process in question. For example, if a thread
    were blocked in a usleep() system call, a timer interrupt would cause that
    thread to be dispatched, and would increment this counter. For workloads
    with a significant idle component, this metric is useful to study in
    conjunction with the package idle exit metric reported below.</p>
<p class="Pp">4. A count of &quot;package idle exits&quot; induced by
    timers/device interrupts which awakened threads from the process in
    question. This is a subset of the interrupt wakeup count. Timers and other
    interrupts that trigger &quot;package idle exits&quot; have a greater impact
    on energy consumption relative to other interrupts. With the exception of
    some Mac Pro systems, Mac and iOS systems are typically single package
    systems, wherein all CPUs are part of a single processor complex (typically
    a single IC die) with shared logic that can include (depending on system
    specifics) shared last level caches, an integrated memory controller etc.
    When all CPUs in the package are idle, the hardware can power-gate
    significant portions of the shared logic in addition to each individual
    processor's logic, as well as take measures such as placing DRAM in to
    self-refresh (also referred to as auto-refresh), place interconnects into
    lower-power states etc. Hence a timer or interrupt that triggers an exit
    from this package idle state results in a a greater increase in power than a
    timer that occurred when the CPU in question was already executing. The
    process initiating a package idle wakeup may also be the &quot;prime
    mover&quot;, i.e. it may be the trigger for further activity in its own or
    other processes. This metric is most useful when the system is relatively
    idle, as with typical light workloads such as web browsing and movie
    playback; with heavier workloads, the CPU activity can be high enough such
    that package idle entry is relatively rare, thus masking package idle exits
    due to the process/thread in question.</p>
<p class="Pp">5. If any processes arrived and vanished during the inter-sample
    interval, or a previously sampled process vanished, their statistics are
    reflected in the row labeled &quot;DEAD_TASKS&quot;. This can identify
    issues involving transient processes which may be spawned too frequently.
    dtrace (&quot;execsnoop&quot;) or other tools can then be used to identify
    the transient processes in question. Running powermetrics in coalition mode,
    (see below), will also help track down transient process issues, by billing
    the coalition to which the process belongs.</p>
<p class="Pp" id="Interrupt"><a class="permalink" href="#Interrupt"><i class="Em">Interrupt
    Distribution</i></a></p>
<p class="Pp">The interrupts sampler reports interrupt frequencies, classified
    by interrupt vector and associated device, on a per-CPU basis. Mac OS
    currently assigns all device interrupts to CPU0, but timers and
    interprocessor interrupts can occur on other CPUs. Interrupt frequencies can
    be useful in identifying misconfigured devices or areas of improvement in
    interrupt load, and can serve as a proxy for identifying device activity
    across the sample interval. For example, during a network-heavy workload, an
    increase in interrupts associated with Airport wireless (&quot;ARPT&quot;),
    or wired ethernet (&quot;ETH0&quot; &quot;ETH1&quot; etc.) is not
    unexpected. However, if the interrupt frequency for a given device is
    non-zero when the device is not active (e.g. if &quot;HDAU&quot; interrupts,
    for High Definition Audio, occur even when no audio is playing), that may be
    a driver error. The int_sources sampler attributes interrupts to the
    responsible InterruptEventSources, which helps disambiguate the cause of an
    interrupt if the vector serves more than one source.</p>
<p class="Pp" id="Battery"><a class="permalink" href="#Battery"><i class="Em">Battery
    Statistics</i></a></p>
<p class="Pp">The battery sampler reports battery discharge rates, current and
    maximum charge levels, cycle counts and degradation from design capacity
    across the interval in question, if a delta was reported by the battery
    management unit. Note that the battery controller data may arrive
    out-of-phase with respect to powermetrics samples, which can cause aliasing
    issues across short sample intervals. Discharge rates across discontinuities
    such as sleep/wake may also be inaccurate on some systems; however, the rate
    of change of the total charge level across longer intervals is a useful
    indicator of total system load. Powermetrics does not filter discharge rates
    for A/C connect/disconnect events, system sleep residency etc. Battery
    discharge rates are typically not comparable across machine models.</p>
<p class="Pp" id="Processor"><a class="permalink" href="#Processor"><i class="Em">Processor
    Energy Usage</i></a></p>
<p class="Pp">The cpu_power sampler reports data derived from the Intel energy
    models; as of the Sandy Bridge intel microarchitecture, the Intel power
    control unit internally maintains an energy consumption model whose details
    are proprietary, but are likely based on duty cycles for individual
    execution units, current voltage/frequency etc. These numbers are not
    strictly accurate but are correlated with actual energy consumption. This
    section lists: power dissipated by the processor package which includes the
    CPU cores, the integrated GPU and the system agent (integrated memory
    controller, last level cache), and separately, CPU core power and GT
    (integrated GPU) power (the latter two in a forthcoming version). The energy
    model data is generally not comparable across machine models.</p>
<p class="Pp">The cpu_power sampler next reports, on processors with Nehalem and
    newer microarchitectures, hardware derived processor frequency and idle
    residency information, labeled &quot;P-states&quot; and &quot;C-states&quot;
    respectively in Intel terminology.</p>
<p class="Pp">C-states are further classified in to &quot;package c-states&quot;
    and per-core C-states. The processor enters a &quot;c-state&quot; in the
    scheduler's idle loop, which results in clock-gating or power-gating CPU
    core and, potentially, package logic, considerably reducing power
    dissipation. High package c-state residency is a goal to strive for, as
    energy consumption of the CPU complex, integrated memory controller if any
    and DRAM is significantly reduced when in a package c-state. Package
    c-states occur when all CPU cores within the package are idle, and the
    on-die integrated GPU if any (SandyBridge mobile and beyond), on the system
    is also idle. Powermetrics reports package c-state residency as a fraction
    of the time sampled. This is available on Nehalem microarchitecture and
    newer processors. Note that some systems, such as Mac Pros, do not enable
    &quot;package&quot; c-states.</p>
<p class="Pp">Powermetrics also reports per-core c-state residencies, signifying
    when the core in question (which can include multiple SMTs or
    &quot;hyperthreads&quot;) is idle, as well as active/inactive duty cycle
    histograms for each logical processor within the core. This is available on
    Nehalem microarchitecture and newer processors.</p>
<p class="Pp">This section also lists the average clock frequency at which the
    given logical processor executed when not idle within the sampled interval,
    expressed as both an absolute frequency in MHz and as a percentage of the
    nominal rated frequency. These average frequencies can vary due to the
    operating system's demand based dynamic voltage and frequency scaling. Some
    systems can execute at frequencies greater than the nominal or
    &quot;P1&quot; frequency, which is termed &quot;turbo mode&quot; on Intel
    systems. Such operation will manifest as &gt; 100% of nominal frequency.
    Lengthy execution in turbo mode is typically energy inefficient, as those
    frequencies have high voltage requirements, resulting in a correspondingly
    quadratic increase in power insufficient to outweigh the reduction in
    execution time. Current systems typically have a single voltage/frequency
    domain per-package, but as the processors can execute out-of-phase, they may
    display different average execution frequencies.</p>
<p class="Pp" id="Disk"><a class="permalink" href="#Disk"><i class="Em">Disk
    Usage and Network Activity</i></a></p>
<p class="Pp">The network and disk samplers reports deltas in disk and network
    activity that occured during the sample. Also specifying
    --show-process-netstats and --show-process-io will give you this information
    on a per process basis in the tasks sampler.</p>
<p class="Pp" id="Backlight"><a class="permalink" href="#Backlight"><i class="Em">Backlight
    level</i></a></p>
<p class="Pp">The battery sampler also reports the instantaneous value of the
    backlight luminosity level. This value is likely not comparable across
    systems and machine models, but can be useful when comparing scenarios on a
    given system.</p>
<p class="Pp" id="Devices"><a class="permalink" href="#Devices"><i class="Em">Devices</i></a></p>
<p class="Pp">The devices sampler, for each device, reports the time spent in
    each of the device's states over the course of the sample. The meaning of
    the different states is specific to each device. Powermetrics denotes low
    power states with an &quot;L&quot;, device usable states with a
    &quot;U&quot; and power on states with an &quot;O&quot;.</p>
<p class="Pp" id="SMC"><a class="permalink" href="#SMC"><i class="Em">SMC</i></a></p>
<p class="Pp">The smc sampler displays information supplied by the System
    Management Controller. On supported platforms, this includes fan speed and
    information from various temperature sensors. These are instantaneous values
    taken at the end of the sample window, and do not necessarily reflect the
    values at other times in the window.</p>
<p class="Pp" id="Thermal"><a class="permalink" href="#Thermal"><i class="Em">Thermal</i></a></p>
<p class="Pp">The thermal sampler displays the current thermal pressure the
    system is under. This is an instantaneous value taken at the end of the
    sample window, and does not necessarily reflect the value at other times in
    the window.</p>
<p class="Pp" id="SFI"><a class="permalink" href="#SFI"><i class="Em">SFI</i></a></p>
<p class="Pp">The sfi sampler shows system wide selective forced idle
    statistics. Selective forced idle is a mechanism the operating system uses
    to limit system power while minimizing user impact, by throttling certain
    threads on the system. Each thread belongs to an SFI class, and this sampler
    displays how much each SFI class is currently being throttled or empty if
    none of them is throttled. These are instantaneous values taken at the end
    of the sample window, and do not necessarily reflect the values at other
    times in the window. To get SFI wait time statistics on a per process basis
    use --show-process-wait-times.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="KNOWN_ISSUES"><a class="permalink" href="#KNOWN_ISSUES">KNOWN
  ISSUES</a></h1>
<p class="Pp">Changes in system time and sleep/wake can cause minor inaccuracies
    in reported cpu time.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">5/1/12</td>
    <td class="foot-os">Darwin</td>
  </tr>
</table>
</body>
</html>

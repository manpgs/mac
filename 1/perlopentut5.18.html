<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PERLOPENTUT(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLOPENTUT(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLOPENTUT(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlopentut - tutorial on opening things in Perl</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Perl has two simple, built-in ways to open files: the shell way
    for convenience, and the C way for precision. The shell way also has 2- and
    3-argument forms, which have different semantics for handling the filename.
    The choice is yours.</p>
</section>
<section class="Sh">
<h1 class="Sh">Open a la shell</h1>
<p class="Pp">Perl's <span class="Li">&quot;open&quot;</span> function was
    designed to mimic the way command-line redirection in the shell works. Here
    are some basic examples from the shell:</p>
<p class="Pp"></p>
<pre>
    $ myprogram file1 file2 file3
    $ myprogram    &lt;  inputfile
    $ myprogram    &gt;  outputfile
    $ myprogram    &gt;&gt; outputfile
    $ myprogram    |  otherprogram 
    $ otherprogram |  myprogram
</pre>
<p class="Pp">And here are some more advanced examples:</p>
<p class="Pp"></p>
<pre>
    $ otherprogram      | myprogram f1 - f2
    $ otherprogram 2&gt;&amp;1 | myprogram -
    $ myprogram     &lt;&amp;3
    $ myprogram     &gt;&amp;4
</pre>
<p class="Pp">Programmers accustomed to constructs like those above can take
    comfort in learning that Perl directly supports these familiar constructs
    using virtually the same syntax as the shell.</p>
<section class="Ss">
<h2 class="Ss" id="Simple_Opens"><a class="permalink" href="#Simple_Opens">Simple
  Opens</a></h2>
<p class="Pp">The <span class="Li">&quot;open&quot;</span> function takes two
    arguments: the first is a filehandle, and the second is a single string
    comprising both what to open and how to open it.
    <span class="Li">&quot;open&quot;</span> returns true when it works, and
    when it fails, returns a false value and sets the special variable
    <span class="Li">$!</span> to reflect the system error. If the filehandle
    was previously opened, it will be implicitly closed first.</p>
<p class="Pp">For example:</p>
<p class="Pp"></p>
<pre>
    open(INFO,      &quot;datafile&quot;) || die(&quot;can't open datafile: $!&quot;);
    open(INFO,   &quot;&lt;  datafile&quot;) || die(&quot;can't open datafile: $!&quot;);
    open(RESULTS,&quot;&gt;  runstats&quot;) || die(&quot;can't open runstats: $!&quot;);
    open(LOG,    &quot;&gt;&gt; logfile &quot;) || die(&quot;can't open logfile:  $!&quot;);
</pre>
<p class="Pp">If you prefer the low-punctuation version, you could write that
    this way:</p>
<p class="Pp"></p>
<pre>
    open INFO,   &quot;&lt;  datafile&quot;  or die &quot;can't open datafile: $!&quot;;
    open RESULTS,&quot;&gt;  runstats&quot;  or die &quot;can't open runstats: $!&quot;;
    open LOG,    &quot;&gt;&gt; logfile &quot;  or die &quot;can't open logfile:  $!&quot;;
</pre>
<p class="Pp">A few things to notice. First, the leading
    <span class="Li">&quot;&lt;&quot;</span> is optional. If omitted, Perl
    assumes that you want to open the file for reading.</p>
<p class="Pp">Note also that the first example uses the
    <span class="Li">&quot;||&quot;</span> logical operator, and the second uses
    <span class="Li">&quot;or&quot;</span>, which has lower precedence. Using
    <span class="Li">&quot;||&quot;</span> in the latter examples would
    effectively mean</p>
<p class="Pp"></p>
<pre>
    open INFO, ( &quot;&lt;  datafile&quot;  || die &quot;can't open datafile: $!&quot; );
</pre>
<p class="Pp">which is definitely not what you want.</p>
<p class="Pp">The other important thing to notice is that, just as in the shell,
    any whitespace before or after the filename is ignored. This is good,
    because you wouldn't want these to do different things:</p>
<p class="Pp"></p>
<pre>
    open INFO,   &quot;&lt;datafile&quot;   
    open INFO,   &quot;&lt; datafile&quot; 
    open INFO,   &quot;&lt;  datafile&quot;
</pre>
<p class="Pp">Ignoring surrounding whitespace also helps for when you read a
    filename in from a different file, and forget to trim it before opening:</p>
<p class="Pp"></p>
<pre>
    $filename = &lt;INFO&gt;;         # oops, \n still there
    open(EXTRA, &quot;&lt; $filename&quot;) || die &quot;can't open $filename: $!&quot;;
</pre>
<p class="Pp">This is not a bug, but a feature. Because
    <span class="Li">&quot;open&quot;</span> mimics the shell in its style of
    using redirection arrows to specify how to open the file, it also does so
    with respect to extra whitespace around the filename itself as well. For
    accessing files with naughty names, see &quot;Dispelling the
  Dweomer&quot;.</p>
<p class="Pp">There is also a 3-argument version of
    <span class="Li">&quot;open&quot;</span>, which lets you put the special
    redirection characters into their own argument:</p>
<p class="Pp"></p>
<pre>
    open( INFO, &quot;&gt;&quot;, $datafile ) || die &quot;Can't create $datafile: $!&quot;;
</pre>
<p class="Pp">In this case, the filename to open is the actual string in
    <span class="Li">$datafile</span>, so you don't have to worry about
    <span class="Li">$datafile</span> containing characters that might influence
    the open mode, or whitespace at the beginning of the filename that would be
    absorbed in the 2-argument version. Also, any reduction of unnecessary
    string interpolation is a good thing.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Indirect_Filehandles"><a class="permalink" href="#Indirect_Filehandles">Indirect
  Filehandles</a></h2>
<p class="Pp"><span class="Li">&quot;open&quot;</span>'s first argument can be a
    reference to a filehandle. As of perl 5.6.0, if the argument is
    uninitialized, Perl will automatically create a filehandle and put a
    reference to it in the first argument, like so:</p>
<p class="Pp"></p>
<pre>
    open( my $in, $infile )   or die &quot;Couldn't read $infile: $!&quot;;
    while ( &lt;$in&gt; ) {
        # do something with $_
    }
    close $in;
</pre>
<p class="Pp">Indirect filehandles make namespace management easier. Since
    filehandles are global to the current package, two subroutines trying to
    open <span class="Li">&quot;INFILE&quot;</span> will clash. With two
    functions opening indirect filehandles like <span class="Li">&quot;my
    $infile&quot;</span>, there's no clash and no need to worry about future
    conflicts.</p>
<p class="Pp">Another convenient behavior is that an indirect filehandle
    automatically closes when there are no more references to it:</p>
<p class="Pp"></p>
<pre>
    sub firstline {
        open( my $in, shift ) &amp;&amp; return scalar &lt;$in&gt;;
        # no close() required
    }
</pre>
<p class="Pp">Indirect filehandles also make it easy to pass filehandles to and
    return filehandles from subroutines:</p>
<p class="Pp"></p>
<pre>
    for my $file ( qw(this.conf that.conf) ) {
        my $fin = open_or_throw('&lt;', $file);
        process_conf( $fin );
        # no close() needed
    }

    use Carp;
    sub open_or_throw {
        my ($mode, $filename) = @_;
        open my $h, $mode, $filename
            or croak &quot;Could not open '$filename': $!&quot;;
        return $h;
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Pipe_Opens"><a class="permalink" href="#Pipe_Opens">Pipe
  Opens</a></h2>
<p class="Pp">In C, when you want to open a file using the standard I/O library,
    you use the <span class="Li">&quot;fopen&quot;</span> function, but when
    opening a pipe, you use the <span class="Li">&quot;popen&quot;</span>
    function. But in the shell, you just use a different redirection character.
    That's also the case for Perl. The <span class="Li">&quot;open&quot;</span>
    call remains the same--just its argument differs.</p>
<p class="Pp">If the leading character is a pipe symbol,
    <span class="Li">&quot;open&quot;</span> starts up a new command and opens a
    write-only filehandle leading into that command. This lets you write into
    that handle and have what you write show up on that command's standard
    input. For example:</p>
<p class="Pp"></p>
<pre>
    open(PRINTER, &quot;| lpr -Plp1&quot;)    || die &quot;can't run lpr: $!&quot;;
    print PRINTER &quot;stuff\n&quot;;
    close(PRINTER)                  || die &quot;can't close lpr: $!&quot;;
</pre>
<p class="Pp">If the trailing character is a pipe, you start up a new command
    and open a read-only filehandle leading out of that command. This lets
    whatever that command writes to its standard output show up on your handle
    for reading. For example:</p>
<p class="Pp"></p>
<pre>
    open(NET, &quot;netstat -i -n |&quot;)    || die &quot;can't fork netstat: $!&quot;;
    while (&lt;NET&gt;) { }               # do something with input
    close(NET)                      || die &quot;can't close netstat: $!&quot;;
</pre>
<p class="Pp">What happens if you try to open a pipe to or from a non-existent
    command? If possible, Perl will detect the failure and set
    <span class="Li">$!</span> as usual. But if the command contains special
    shell characters, such as <span class="Li">&quot;&gt;&quot;</span> or
    <span class="Li">&quot;*&quot;</span>, called 'metacharacters', Perl does
    not execute the command directly. Instead, Perl runs the shell, which then
    tries to run the command. This means that it's the shell that gets the error
    indication. In such a case, the <span class="Li">&quot;open&quot;</span>
    call will only indicate failure if Perl can't even run the shell. See
    &quot;How can I capture STDERR from an external command?&quot; in perlfaq8
    to see how to cope with this. There's also an explanation in perlipc.</p>
<p class="Pp">If you would like to open a bidirectional pipe, the IPC::Open2
    library will handle this for you. Check out &quot;Bidirectional
    Communication with Another Process&quot; in perlipc</p>
<p class="Pp">perl-5.6.x introduced a version of piped open that executes a
    process based on its command line arguments without relying on the shell.
    (Similar to the <span class="Li">&quot;system(@LIST)&quot;</span> notation.)
    This is safer and faster than executing a single argument pipe-command, but
    does not allow special shell constructs. (It is also not supported on
    Microsoft Windows, Mac OS Classic or RISC OS.)</p>
<p class="Pp">Here's an example of <span class="Li">&quot;open
    '-|'&quot;</span>, which prints a random Unix fortune cookie as
  uppercase:</p>
<p class="Pp"></p>
<pre>
    my $collection = shift(@ARGV);
    open my $fortune, '-|', 'fortune', $collection
        or die &quot;Could not find fortune - $!&quot;;
    while (&lt;$fortune&gt;)
    {
        print uc($_);
    }
    close($fortune);
</pre>
<p class="Pp">And this <span class="Li">&quot;open '|-'&quot;</span> pipes into
    lpr:</p>
<p class="Pp"></p>
<pre>
    open my $printer, '|-', 'lpr', '-Plp1'
        or die &quot;can't run lpr: $!&quot;;
    print {$printer} &quot;stuff\n&quot;;
    close($printer)
        or die &quot;can't close lpr: $!&quot;;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Minus_File"><a class="permalink" href="#The_Minus_File">The
  Minus File</a></h2>
<p class="Pp">Again following the lead of the standard shell utilities, Perl's
    <span class="Li">&quot;open&quot;</span> function treats a file whose name
    is a single minus, &quot;-&quot;, in a special way. If you open minus for
    reading, it really means to access the standard input. If you open minus for
    writing, it really means to access the standard output.</p>
<p class="Pp">If minus can be used as the default input or default output, what
    happens if you open a pipe into or out of minus? What's the default command
    it would run? The same script as you're currently running! This is actually
    a stealth <span class="Li">&quot;fork&quot;</span> hidden inside an
    <span class="Li">&quot;open&quot;</span> call. See &quot;Safe Pipe
    Opens&quot; in perlipc for details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Mixing_Reads_and_Writes"><a class="permalink" href="#Mixing_Reads_and_Writes">Mixing
  Reads and Writes</a></h2>
<p class="Pp">It is possible to specify both read and write access. All you do
    is add a &quot;+&quot; symbol in front of the redirection. But as in the
    shell, using a less-than on a file never creates a new file; it only opens
    an existing one. On the other hand, using a greater-than always clobbers
    (truncates to zero length) an existing file, or creates a brand-new one if
    there isn't an old one. Adding a &quot;+&quot; for read-write doesn't affect
    whether it only works on existing files or always clobbers existing
  ones.</p>
<p class="Pp"></p>
<pre>
    open(WTMP, &quot;+&lt; /usr/adm/wtmp&quot;) 
        || die &quot;can't open /usr/adm/wtmp: $!&quot;;

    open(SCREEN, &quot;+&gt; lkscreen&quot;)
        || die &quot;can't open lkscreen: $!&quot;;

    open(LOGFILE, &quot;+&gt;&gt; /var/log/applog&quot;)
        || die &quot;can't open /var/log/applog: $!&quot;;
</pre>
<p class="Pp">The first one won't create a new file, and the second one will
    always clobber an old one. The third one will create a new file if necessary
    and not clobber an old one, and it will allow you to read at any point in
    the file, but all writes will always go to the end. In short, the first case
    is substantially more common than the second and third cases, which are
    almost always wrong. (If you know C, the plus in Perl's
    <span class="Li">&quot;open&quot;</span> is historically derived from the
    one in C's fopen(3S), which it ultimately calls.)</p>
<p class="Pp">In fact, when it comes to updating a file, unless you're working
    on a binary file as in the WTMP case above, you probably don't want to use
    this approach for updating. Instead, Perl's <b>-i</b> flag comes to the
    rescue. The following command takes all the C, C++, or yacc source or header
    files and changes all their foo's to bar's, leaving the old version in the
    original filename with a &quot;.orig&quot; tacked on the end:</p>
<p class="Pp"></p>
<pre>
    $ perl -i.orig -pe 's/\bfoo\b/bar/g' *.[Cchy]
</pre>
<p class="Pp">This is a short cut for some renaming games that are really the
    best way to update textfiles. See the second question in perlfaq5 for more
    details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Filters"><a class="permalink" href="#Filters">Filters</a></h2>
<p class="Pp">One of the most common uses for
    <span class="Li">&quot;open&quot;</span> is one you never even notice. When
    you process the ARGV filehandle using
    <span class="Li">&quot;&lt;ARGV&gt;&quot;</span>, Perl actually does an
    implicit open on each file in <span class="Li">@ARGV</span>. Thus a program
    called like this:</p>
<p class="Pp"></p>
<pre>
    $ myprogram file1 file2 file3
</pre>
<p class="Pp">can have all its files opened and processed one at a time using a
    construct no more complex than:</p>
<p class="Pp"></p>
<pre>
    while (&lt;&gt;) {
        # do something with $_
    }
</pre>
<p class="Pp">If <span class="Li">@ARGV</span> is empty when the loop first
    begins, Perl pretends you've opened up minus, that is, the standard input.
    In fact, <span class="Li">$ARGV</span>, the currently open file during
    <span class="Li">&quot;&lt;ARGV&gt;&quot;</span> processing, is even set to
    &quot;-&quot; in these circumstances.</p>
<p class="Pp">You are welcome to pre-process your <span class="Li">@ARGV</span>
    before starting the loop to make sure it's to your liking. One reason to do
    this might be to remove command options beginning with a minus. While you
    can always roll the simple ones by hand, the Getopts modules are good for
    this:</p>
<p class="Pp"></p>
<pre>
    use Getopt::Std;

    # -v, -D, -o ARG, sets $opt_v, $opt_D, $opt_o
    getopts(&quot;vDo:&quot;);            

    # -v, -D, -o ARG, sets $args{v}, $args{D}, $args{o}
    getopts(&quot;vDo:&quot;, \%args);
</pre>
<p class="Pp">Or the standard Getopt::Long module to permit named arguments:</p>
<p class="Pp"></p>
<pre>
    use Getopt::Long;
    GetOptions( &quot;verbose&quot;  =&gt; \$verbose,        # --verbose
                &quot;Debug&quot;    =&gt; \$debug,          # --Debug
                &quot;output=s&quot; =&gt; \$output );       
            # --output=somestring or --output somestring
</pre>
<p class="Pp">Another reason for preprocessing arguments is to make an empty
    argument list default to all files:</p>
<p class="Pp"></p>
<pre>
    @ARGV = glob(&quot;*&quot;) unless @ARGV;
</pre>
<p class="Pp">You could even filter out all but plain, text files. This is a bit
    silent, of course, and you might prefer to mention them on the way.</p>
<p class="Pp"></p>
<pre>
    @ARGV = grep { -f &amp;&amp; -T } @ARGV;
</pre>
<p class="Pp">If you're using the <b>-n</b> or <b>-p</b> command-line options,
    you should put changes to <span class="Li">@ARGV</span> in a
    <span class="Li">&quot;BEGIN{}&quot;</span> block.</p>
<p class="Pp">Remember that a normal <span class="Li">&quot;open&quot;</span>
    has special properties, in that it might call fopen(3S) or it might called
    popen(3S), depending on what its argument looks like; that's why it's
    sometimes called &quot;magic open&quot;. Here's an example:</p>
<p class="Pp"></p>
<pre>
    $pwdinfo = `domainname` =~ /^(\(none\))?$/
                    ? '&lt; /etc/passwd'
                    : 'ypcat passwd |';

    open(PWD, $pwdinfo)                 
                or die &quot;can't open $pwdinfo: $!&quot;;
</pre>
<p class="Pp">This sort of thing also comes into play in filter processing.
    Because <span class="Li">&quot;&lt;ARGV&gt;&quot;</span> processing employs
    the normal, shell-style Perl <span class="Li">&quot;open&quot;</span>, it
    respects all the special things we've already seen:</p>
<p class="Pp"></p>
<pre>
    $ myprogram f1 &quot;cmd1|&quot; - f2 &quot;cmd2|&quot; f3 &lt; tmpfile
</pre>
<p class="Pp">That program will read from the file <i>f1</i>, the process
    <i>cmd1</i>, standard input (<i>tmpfile</i> in this case), the <i>f2</i>
    file, the <i>cmd2</i> command, and finally the <i>f3</i> file.</p>
<p class="Pp">Yes, this also means that if you have files named &quot;-&quot;
    (and so on) in your directory, they won't be processed as literal files by
    <span class="Li">&quot;open&quot;</span>. You'll need to pass them as
    &quot;./-&quot;, much as you would for the <i>rm</i> program, or you could
    use <span class="Li">&quot;sysopen&quot;</span> as described below.</p>
<p class="Pp">One of the more interesting applications is to change files of a
    certain name into pipes. For example, to autoprocess gzipped or compressed
    files by decompressing them with <i>gzip</i>:</p>
<p class="Pp"></p>
<pre>
    @ARGV = map { /\.(gz|Z)$/ ? &quot;gzip -dc $_ |&quot; : $_  } @ARGV;
</pre>
<p class="Pp">Or, if you have the <i>GET</i> program installed from LWP, you can
    fetch URLs before processing them:</p>
<p class="Pp"></p>
<pre>
    @ARGV = map { m#^\w+://# ? &quot;GET $_ |&quot; : $_ } @ARGV;
</pre>
<p class="Pp">It's not for nothing that this is called magic
    <span class="Li">&quot;&lt;ARGV&gt;&quot;</span>. Pretty nifty, eh?</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh">Open a la C</h1>
<p class="Pp">If you want the convenience of the shell, then Perl's
    <span class="Li">&quot;open&quot;</span> is definitely the way to go. On the
    other hand, if you want finer precision than C's simplistic fopen(3S)
    provides you should look to Perl's
    <span class="Li">&quot;sysopen&quot;</span>, which is a direct hook into the
    <i>open</i>(2) system call. That does mean it's a bit more involved, but
    that's the price of precision.</p>
<p class="Pp"><span class="Li">&quot;sysopen&quot;</span> takes 3 (or 4)
    arguments.</p>
<p class="Pp"></p>
<pre>
    sysopen HANDLE, PATH, FLAGS, [MASK]
</pre>
<p class="Pp">The HANDLE argument is a filehandle just as with
    <span class="Li">&quot;open&quot;</span>. The PATH is a literal path, one
    that doesn't pay attention to any greater-thans or less-thans or pipes or
    minuses, nor ignore whitespace. If it's there, it's part of the path. The
    FLAGS argument contains one or more values derived from the Fcntl module
    that have been or'd together using the bitwise &quot;|&quot; operator. The
    final argument, the MASK, is optional; if present, it is combined with the
    user's current umask for the creation mode of the file. You should usually
    omit this.</p>
<p class="Pp">Although the traditional values of read-only, write-only, and
    read-write are 0, 1, and 2 respectively, this is known not to hold true on
    some systems. Instead, it's best to load in the appropriate constants first
    from the Fcntl module, which supplies the following standard flags:</p>
<p class="Pp"></p>
<pre>
    O_RDONLY            Read only
    O_WRONLY            Write only
    O_RDWR              Read and write
    O_CREAT             Create the file if it doesn't exist
    O_EXCL              Fail if the file already exists
    O_APPEND            Append to the file
    O_TRUNC             Truncate the file
    O_NONBLOCK          Non-blocking access
</pre>
<p class="Pp">Less common flags that are sometimes available on some operating
    systems include <span class="Li">&quot;O_BINARY&quot;</span>,
    <span class="Li">&quot;O_TEXT&quot;</span>,
    <span class="Li">&quot;O_SHLOCK&quot;</span>,
    <span class="Li">&quot;O_EXLOCK&quot;</span>,
    <span class="Li">&quot;O_DEFER&quot;</span>,
    <span class="Li">&quot;O_SYNC&quot;</span>,
    <span class="Li">&quot;O_ASYNC&quot;</span>,
    <span class="Li">&quot;O_DSYNC&quot;</span>,
    <span class="Li">&quot;O_RSYNC&quot;</span>,
    <span class="Li">&quot;O_NOCTTY&quot;</span>,
    <span class="Li">&quot;O_NDELAY&quot;</span> and
    <span class="Li">&quot;O_LARGEFILE&quot;</span>. Consult your <i>open</i>(2)
    manpage or its local equivalent for details. (Note: starting from Perl
    release 5.6 the <span class="Li">&quot;O_LARGEFILE&quot;</span> flag, if
    available, is automatically added to the <i>sysopen()</i> flags because
    large files are the default.)</p>
<p class="Pp">Here's how to use <span class="Li">&quot;sysopen&quot;</span> to
    emulate the simple <span class="Li">&quot;open&quot;</span> calls we had
    before. We'll omit the <span class="Li">&quot;|| die $!&quot;</span> checks
    for clarity, but make sure you always check the return values in real code.
    These aren't quite the same, since <span class="Li">&quot;open&quot;</span>
    will trim leading and trailing whitespace, but you'll get the idea.</p>
<p class="Pp">To open a file for reading:</p>
<p class="Pp"></p>
<pre>
    open(FH, &quot;&lt; $path&quot;);
    sysopen(FH, $path, O_RDONLY);
</pre>
<p class="Pp">To open a file for writing, creating a new file if needed or else
    truncating an old file:</p>
<p class="Pp"></p>
<pre>
    open(FH, &quot;&gt; $path&quot;);
    sysopen(FH, $path, O_WRONLY | O_TRUNC | O_CREAT);
</pre>
<p class="Pp">To open a file for appending, creating one if necessary:</p>
<p class="Pp"></p>
<pre>
    open(FH, &quot;&gt;&gt; $path&quot;);
    sysopen(FH, $path, O_WRONLY | O_APPEND | O_CREAT);
</pre>
<p class="Pp">To open a file for update, where the file must already exist:</p>
<p class="Pp"></p>
<pre>
    open(FH, &quot;+&lt; $path&quot;);
    sysopen(FH, $path, O_RDWR);
</pre>
<p class="Pp">And here are things you can do with
    <span class="Li">&quot;sysopen&quot;</span> that you cannot do with a
    regular <span class="Li">&quot;open&quot;</span>. As you'll see, it's just a
    matter of controlling the flags in the third argument.</p>
<p class="Pp">To open a file for writing, creating a new file which must not
    previously exist:</p>
<p class="Pp"></p>
<pre>
    sysopen(FH, $path, O_WRONLY | O_EXCL | O_CREAT);
</pre>
<p class="Pp">To open a file for appending, where that file must already
  exist:</p>
<p class="Pp"></p>
<pre>
    sysopen(FH, $path, O_WRONLY | O_APPEND);
</pre>
<p class="Pp">To open a file for update, creating a new file if necessary:</p>
<p class="Pp"></p>
<pre>
    sysopen(FH, $path, O_RDWR | O_CREAT);
</pre>
<p class="Pp">To open a file for update, where that file must not already
  exist:</p>
<p class="Pp"></p>
<pre>
    sysopen(FH, $path, O_RDWR | O_EXCL | O_CREAT);
</pre>
<p class="Pp">To open a file without blocking, creating one if necessary:</p>
<p class="Pp"></p>
<pre>
    sysopen(FH, $path, O_WRONLY | O_NONBLOCK | O_CREAT);
</pre>
<section class="Ss">
<h2 class="Ss" id="Permissions_a"><a class="permalink" href="#Permissions_a">Permissions
  a la mode</a></h2>
<p class="Pp">If you omit the MASK argument to
    <span class="Li">&quot;sysopen&quot;</span>, Perl uses the octal value 0666.
    The normal MASK to use for executables and directories should be 0777, and
    for anything else, 0666.</p>
<p class="Pp">Why so permissive? Well, it isn't really. The MASK will be
    modified by your process's current
    <span class="Li">&quot;umask&quot;</span>. A umask is a number representing
    <i>disabled</i> permissions bits; that is, bits that will not be turned on
    in the created file's permissions field.</p>
<p class="Pp">For example, if your <span class="Li">&quot;umask&quot;</span>
    were 027, then the 020 part would disable the group from writing, and the
    007 part would disable others from reading, writing, or executing. Under
    these conditions, passing <span class="Li">&quot;sysopen&quot;</span> 0666
    would create a file with mode 0640, since <span class="Li">&quot;0666 &amp;
    ~027&quot;</span> is 0640.</p>
<p class="Pp">You should seldom use the MASK argument to
    <span class="Li">&quot;sysopen()&quot;</span>. That takes away the user's
    freedom to choose what permission new files will have. Denying choice is
    almost always a bad thing. One exception would be for cases where sensitive
    or private data is being stored, such as with mail folders, cookie files,
    and internal temporary files.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Obscure_Open_Tricks"><a class="permalink" href="#Obscure_Open_Tricks">Obscure
  Open Tricks</a></h1>
<section class="Ss">
<h2 class="Ss" id="Re-Opening_Files_(dups)"><a class="permalink" href="#Re-Opening_Files_(dups)">Re-Opening
  Files (dups)</a></h2>
<p class="Pp">Sometimes you already have a filehandle open, and want to make
    another handle that's a duplicate of the first one. In the shell, we place
    an ampersand in front of a file descriptor number when doing redirections.
    For example, <span class="Li">&quot;2&gt;&amp;1&quot;</span> makes
    descriptor 2 (that's STDERR in Perl) be redirected into descriptor 1 (which
    is usually Perl's STDOUT). The same is essentially true in Perl: a filename
    that begins with an ampersand is treated instead as a file descriptor if a
    number, or as a filehandle if a string.</p>
<p class="Pp"></p>
<pre>
    open(SAVEOUT, &quot;&gt;&amp;SAVEERR&quot;) || die &quot;couldn't dup SAVEERR: $!&quot;;
    open(MHCONTEXT, &quot;&lt;&amp;4&quot;)     || die &quot;couldn't dup fd4: $!&quot;;
</pre>
<p class="Pp">That means that if a function is expecting a filename, but you
    don't want to give it a filename because you already have the file open, you
    can just pass the filehandle with a leading ampersand. It's best to use a
    fully qualified handle though, just in case the function happens to be in a
    different package:</p>
<p class="Pp"></p>
<pre>
    somefunction(&quot;&amp;main::LOGFILE&quot;);
</pre>
<p class="Pp">This way if <i>somefunction()</i> is planning on opening its
    argument, it can just use the already opened handle. This differs from
    passing a handle, because with a handle, you don't open the file. Here you
    have something you can pass to open.</p>
<p class="Pp">If you have one of those tricky, newfangled I/O objects that the
    C++ folks are raving about, then this doesn't work because those aren't a
    proper filehandle in the native Perl sense. You'll have to use
    <i>fileno()</i> to pull out the proper descriptor number, assuming you
  can:</p>
<p class="Pp"></p>
<pre>
    use IO::Socket;
    $handle = IO::Socket::INET-&gt;new(&quot;www.perl.com:80&quot;);
    $fd = $handle-&gt;fileno;
    somefunction(&quot;&amp;$fd&quot;);  # not an indirect function call
</pre>
<p class="Pp">It can be easier (and certainly will be faster) just to use real
    filehandles though:</p>
<p class="Pp"></p>
<pre>
    use IO::Socket;
    local *REMOTE = IO::Socket::INET-&gt;new(&quot;www.perl.com:80&quot;);
    die &quot;can't connect&quot; unless defined(fileno(REMOTE));
    somefunction(&quot;&amp;main::REMOTE&quot;);
</pre>
<p class="Pp">If the filehandle or descriptor number is preceded not just with a
    simple &quot;&amp;&quot; but rather with a &quot;&amp;=&quot; combination,
    then Perl will not create a completely new descriptor opened to the same
    place using the <i>dup</i>(2) system call. Instead, it will just make
    something of an alias to the existing one using the fdopen(3S) library call.
    This is slightly more parsimonious of systems resources, although this is
    less a concern these days. Here's an example of that:</p>
<p class="Pp"></p>
<pre>
    $fd = $ENV{&quot;MHCONTEXTFD&quot;};
    open(MHCONTEXT, &quot;&lt;&amp;=$fd&quot;)   or die &quot;couldn't fdopen $fd: $!&quot;;
</pre>
<p class="Pp">If you're using magic
    <span class="Li">&quot;&lt;ARGV&gt;&quot;</span>, you could even pass in as
    a command line argument in <span class="Li">@ARGV</span> something like
    <span class="Li">&quot;&lt;&amp;=$MHCONTEXTFD&quot;</span>, but we've never
    seen anyone actually do this.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Dispelling_the_Dweomer"><a class="permalink" href="#Dispelling_the_Dweomer">Dispelling
  the Dweomer</a></h2>
<p class="Pp">Perl is more of a DWIMmer language than something like Java--where
    DWIM is an acronym for &quot;do what I mean&quot;. But this principle
    sometimes leads to more hidden magic than one knows what to do with. In this
    way, Perl is also filled with <i>dweomer</i>, an obscure word meaning an
    enchantment. Sometimes, Perl's DWIMmer is just too much like dweomer for
    comfort.</p>
<p class="Pp">If magic <span class="Li">&quot;open&quot;</span> is a bit too
    magical for you, you don't have to turn to
    <span class="Li">&quot;sysopen&quot;</span>. To open a file with arbitrary
    weird characters in it, it's necessary to protect any leading and trailing
    whitespace. Leading whitespace is protected by inserting a
    <span class="Li">&quot;./&quot;</span> in front of a filename that starts
    with whitespace. Trailing whitespace is protected by appending an ASCII NUL
    byte (<span class="Li">&quot;\0&quot;</span>) at the end of the string.</p>
<p class="Pp"></p>
<pre>
    $file =~ s#^(\s)#./$1#;
    open(FH, &quot;&lt; $file\0&quot;)   || die &quot;can't open $file: $!&quot;;
</pre>
<p class="Pp">This assumes, of course, that your system considers dot the
    current working directory, slash the directory separator, and disallows
    ASCII NULs within a valid filename. Most systems follow these conventions,
    including all POSIX systems as well as proprietary Microsoft systems. The
    only vaguely popular system that doesn't work this way is the
    &quot;Classic&quot; Macintosh system, which uses a colon where the rest of
    us use a slash. Maybe <span class="Li">&quot;sysopen&quot;</span> isn't such
    a bad idea after all.</p>
<p class="Pp">If you want to use
    <span class="Li">&quot;&lt;ARGV&gt;&quot;</span> processing in a totally
    boring and non-magical way, you could do this first:</p>
<p class="Pp"></p>
<pre>
    #   &quot;Sam sat on the ground and put his head in his hands.  
    #   'I wish I had never come here, and I don't want to see 
    #   no more magic,' he said, and fell silent.&quot;
    for (@ARGV) { 
        s#^([^./])#./$1#;
        $_ .= &quot;\0&quot;;
    } 
    while (&lt;&gt;) {  
        # now process $_
    }
</pre>
<p class="Pp">But be warned that users will not appreciate being unable to use
    &quot;-&quot; to mean standard input, per the standard convention.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Paths_as_Opens"><a class="permalink" href="#Paths_as_Opens">Paths
  as Opens</a></h2>
<p class="Pp">You've probably noticed how Perl's
    <span class="Li">&quot;warn&quot;</span> and
    <span class="Li">&quot;die&quot;</span> functions can produce messages
  like:</p>
<p class="Pp"></p>
<pre>
    Some warning at scriptname line 29, &lt;FH&gt; line 7.
</pre>
<p class="Pp">That's because you opened a filehandle FH, and had read in seven
    records from it. But what was the name of the file, rather than the
  handle?</p>
<p class="Pp">If you aren't running with <span class="Li">&quot;strict
    refs&quot;</span>, or if you've turned them off temporarily, then all you
    have to do is this:</p>
<p class="Pp"></p>
<pre>
    open($path, &quot;&lt; $path&quot;) || die &quot;can't open $path: $!&quot;;
    while (&lt;$path&gt;) {
        # whatever
    }
</pre>
<p class="Pp">Since you're using the pathname of the file as its handle, you'll
    get warnings more like</p>
<p class="Pp"></p>
<pre>
    Some warning at scriptname line 29, &lt;/etc/motd&gt; line 7.
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Single_Argument_Open"><a class="permalink" href="#Single_Argument_Open">Single
  Argument Open</a></h2>
<p class="Pp">Remember how we said that Perl's open took two arguments? That was
    a passive prevarication. You see, it can also take just one argument. If and
    only if the variable is a global variable, not a lexical, you can pass
    <span class="Li">&quot;open&quot;</span> just one argument, the filehandle,
    and it will get the path from the global scalar variable of the same
  name.</p>
<p class="Pp"></p>
<pre>
    $FILE = &quot;/etc/motd&quot;;
    open FILE or die &quot;can't open $FILE: $!&quot;;
    while (&lt;FILE&gt;) {
        # whatever
    }
</pre>
<p class="Pp">Why is this here? Someone has to cater to the hysterical
    porpoises. It's something that's been in Perl since the very beginning, if
    not before.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Playing_with_"><a class="permalink" href="#Playing_with_">Playing
  with STDIN and STDOUT</a></h2>
<p class="Pp">One clever move with STDOUT is to explicitly close it when you're
    done with the program.</p>
<p class="Pp"></p>
<pre>
    END { close(STDOUT) || die &quot;can't close stdout: $!&quot; }
</pre>
<p class="Pp">If you don't do this, and your program fills up the disk partition
    due to a command line redirection, it won't report the error exit with a
    failure status.</p>
<p class="Pp">You don't have to accept the STDIN and STDOUT you were given. You
    are welcome to reopen them if you'd like.</p>
<p class="Pp"></p>
<pre>
    open(STDIN, &quot;&lt; datafile&quot;)
        || die &quot;can't open datafile: $!&quot;;

    open(STDOUT, &quot;&gt; output&quot;)
        || die &quot;can't open output: $!&quot;;
</pre>
<p class="Pp">And then these can be accessed directly or passed on to
    subprocesses. This makes it look as though the program were initially
    invoked with those redirections from the command line.</p>
<p class="Pp">It's probably more interesting to connect these to pipes. For
    example:</p>
<p class="Pp"></p>
<pre>
    $pager = $ENV{PAGER} || &quot;(less || more)&quot;;
    open(STDOUT, &quot;| $pager&quot;)
        || die &quot;can't fork a pager: $!&quot;;
</pre>
<p class="Pp">This makes it appear as though your program were called with its
    stdout already piped into your pager. You can also use this kind of thing in
    conjunction with an implicit fork to yourself. You might do this if you
    would rather handle the post processing in your own program, just in a
    different process:</p>
<p class="Pp"></p>
<pre>
    head(100);
    while (&lt;&gt;) {
        print;
    } 

    sub head {
        my $lines = shift || 20;
        return if $pid = open(STDOUT, &quot;|-&quot;);       # return if parent
        die &quot;cannot fork: $!&quot; unless defined $pid;
        while (&lt;STDIN&gt;) {
            last if --$lines &lt; 0;
            print;
        } 
        exit;
    }
</pre>
<p class="Pp">This technique can be applied to repeatedly push as many filters
    on your output stream as you wish.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Other_I/O_Issues"><a class="permalink" href="#Other_I/O_Issues">Other
  I/O Issues</a></h1>
<p class="Pp">These topics aren't really arguments related to
    <span class="Li">&quot;open&quot;</span> or
    <span class="Li">&quot;sysopen&quot;</span>, but they do affect what you do
    with your open files.</p>
<section class="Ss">
<h2 class="Ss" id="Opening_Non-File_Files"><a class="permalink" href="#Opening_Non-File_Files">Opening
  Non-File Files</a></h2>
<p class="Pp">When is a file not a file? Well, you could say when it exists but
    isn't a plain file. We'll check whether it's a symbolic link first, just in
    case.</p>
<p class="Pp"></p>
<pre>
    if (-l $file || ! -f _) {
        print &quot;$file is not a plain file\n&quot;;
    }
</pre>
<p class="Pp">What other kinds of files are there than, well, files?
    Directories, symbolic links, named pipes, Unix-domain sockets, and block and
    character devices. Those are all files, too--just not <i>plain</i> files.
    This isn't the same issue as being a text file. Not all text files are plain
    files. Not all plain files are text files. That's why there are separate
    <span class="Li">&quot;-f&quot;</span> and
    <span class="Li">&quot;-T&quot;</span> file tests.</p>
<p class="Pp">To open a directory, you should use the
    <span class="Li">&quot;opendir&quot;</span> function, then process it with
    <span class="Li">&quot;readdir&quot;</span>, carefully restoring the
    directory name if necessary:</p>
<p class="Pp"></p>
<pre>
    opendir(DIR, $dirname) or die &quot;can't opendir $dirname: $!&quot;;
    while (defined($file = readdir(DIR))) {
        # do something with &quot;$dirname/$file&quot;
    }
    closedir(DIR);
</pre>
<p class="Pp">If you want to process directories recursively, it's better to use
    the File::Find module. For example, this prints out all files recursively
    and adds a slash to their names if the file is a directory.</p>
<p class="Pp"></p>
<pre>
    @ARGV = qw(.) unless @ARGV;
    use File::Find;
    find sub { print $File::Find::name, -d &amp;&amp; '/', &quot;\n&quot; }, @ARGV;
</pre>
<p class="Pp">This finds all bogus symbolic links beneath a particular
    directory:</p>
<p class="Pp"></p>
<pre>
    find sub { print &quot;$File::Find::name\n&quot; if -l &amp;&amp; !-e }, $dir;
</pre>
<p class="Pp">As you see, with symbolic links, you can just pretend that it is
    what it points to. Or, if you want to know <i>what</i> it points to, then
    <span class="Li">&quot;readlink&quot;</span> is called for:</p>
<p class="Pp"></p>
<pre>
    if (-l $file) {
        if (defined($whither = readlink($file))) {
            print &quot;$file points to $whither\n&quot;;
        } else {
            print &quot;$file points nowhere: $!\n&quot;;
        } 
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Opening_Named_Pipes"><a class="permalink" href="#Opening_Named_Pipes">Opening
  Named Pipes</a></h2>
<p class="Pp">Named pipes are a different matter. You pretend they're regular
    files, but their opens will normally block until there is both a reader and
    a writer. You can read more about them in &quot;Named Pipes&quot; in
    perlipc. Unix-domain sockets are rather different beasts as well; they're
    described in &quot;Unix-Domain TCP Clients and Servers&quot; in perlipc.</p>
<p class="Pp">When it comes to opening devices, it can be easy and it can be
    tricky. We'll assume that if you're opening up a block device, you know what
    you're doing. The character devices are more interesting. These are
    typically used for modems, mice, and some kinds of printers. This is
    described in &quot;How do I read and write the serial port?&quot; in
    perlfaq8 It's often enough to open them carefully:</p>
<p class="Pp"></p>
<pre>
    sysopen(TTYIN, &quot;/dev/ttyS1&quot;, O_RDWR | O_NDELAY | O_NOCTTY)
                # (O_NOCTTY no longer needed on POSIX systems)
        or die &quot;can't open /dev/ttyS1: $!&quot;;
    open(TTYOUT, &quot;+&gt;&amp;TTYIN&quot;)
        or die &quot;can't dup TTYIN: $!&quot;;

    $ofh = select(TTYOUT); $| = 1; select($ofh);

    print TTYOUT &quot;+++at\015&quot;;
    $answer = &lt;TTYIN&gt;;
</pre>
<p class="Pp">With descriptors that you haven't opened using
    <span class="Li">&quot;sysopen&quot;</span>, such as sockets, you can set
    them to be non-blocking using <span class="Li">&quot;fcntl&quot;</span>:</p>
<p class="Pp"></p>
<pre>
    use Fcntl;
    my $old_flags = fcntl($handle, F_GETFL, 0) 
        or die &quot;can't get flags: $!&quot;;
    fcntl($handle, F_SETFL, $old_flags | O_NONBLOCK) 
        or die &quot;can't set non blocking: $!&quot;;
</pre>
<p class="Pp">Rather than losing yourself in a morass of twisting, turning
    <span class="Li">&quot;ioctl&quot;</span>s, all dissimilar, if you're going
    to manipulate ttys, it's best to make calls out to the <i>stty</i>(1)
    program if you have it, or else use the portable POSIX interface. To figure
    this all out, you'll need to read the <i>termios</i>(3) manpage, which
    describes the POSIX interface to tty devices, and then POSIX, which
    describes Perl's interface to POSIX. There are also some high-level modules
    on CPAN that can help you with these games. Check out Term::ReadKey and
    Term::ReadLine.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Opening_Sockets"><a class="permalink" href="#Opening_Sockets">Opening
  Sockets</a></h2>
<p class="Pp">What else can you open? To open a connection using sockets, you
    won't use one of Perl's two open functions. See &quot;Sockets: Client/Server
    Communication&quot; in perlipc for that. Here's an example. Once you have
    it, you can use FH as a bidirectional filehandle.</p>
<p class="Pp"></p>
<pre>
    use IO::Socket;
    local *FH = IO::Socket::INET-&gt;new(&quot;www.perl.com:80&quot;);
</pre>
<p class="Pp">For opening up a URL, the LWP modules from CPAN are just what the
    doctor ordered. There's no filehandle interface, but it's still easy to get
    the contents of a document:</p>
<p class="Pp"></p>
<pre>
    use LWP::Simple;
    $doc = get('http://www.cpan.org/');
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Binary_Files"><a class="permalink" href="#Binary_Files">Binary
  Files</a></h2>
<p class="Pp">On certain legacy systems with what could charitably be called
    terminally convoluted (some would say broken) I/O models, a file isn't a
    file--at least, not with respect to the C standard I/O library. On these old
    systems whose libraries (but not kernels) distinguish between text and
    binary streams, to get files to behave properly you'll have to bend over
    backwards to avoid nasty problems. On such infelicitous systems, sockets and
    pipes are already opened in binary mode, and there is currently no way to
    turn that off. With files, you have more options.</p>
<p class="Pp">Another option is to use the
    <span class="Li">&quot;binmode&quot;</span> function on the appropriate
    handles before doing regular I/O on them:</p>
<p class="Pp"></p>
<pre>
    binmode(STDIN);
    binmode(STDOUT);
    while (&lt;STDIN&gt;) { print }
</pre>
<p class="Pp">Passing <span class="Li">&quot;sysopen&quot;</span> a non-standard
    flag option will also open the file in binary mode on those systems that
    support it. This is the equivalent of opening the file normally, then
    calling <span class="Li">&quot;binmode&quot;</span> on the handle.</p>
<p class="Pp"></p>
<pre>
    sysopen(BINDAT, &quot;records.data&quot;, O_RDWR | O_BINARY)
        || die &quot;can't open records.data: $!&quot;;
</pre>
<p class="Pp">Now you can use <span class="Li">&quot;read&quot;</span> and
    <span class="Li">&quot;print&quot;</span> on that handle without worrying
    about the non-standard system I/O library breaking your data. It's not a
    pretty picture, but then, legacy systems seldom are. CP/M will be with us
    until the end of days, and after.</p>
<p class="Pp">On systems with exotic I/O systems, it turns out that,
    astonishingly enough, even unbuffered I/O using
    <span class="Li">&quot;sysread&quot;</span> and
    <span class="Li">&quot;syswrite&quot;</span> might do sneaky data mutilation
    behind your back.</p>
<p class="Pp"></p>
<pre>
    while (sysread(WHENCE, $buf, 1024)) {
        syswrite(WHITHER, $buf, length($buf));
    }
</pre>
<p class="Pp">Depending on the vicissitudes of your runtime system, even these
    calls may need <span class="Li">&quot;binmode&quot;</span> or
    <span class="Li">&quot;O_BINARY&quot;</span> first. Systems known to be free
    of such difficulties include Unix, the Mac OS, Plan 9, and Inferno.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="File_Locking"><a class="permalink" href="#File_Locking">File
  Locking</a></h2>
<p class="Pp">In a multitasking environment, you may need to be careful not to
    collide with other processes who want to do I/O on the same files as you are
    working on. You'll often need shared or exclusive locks on files for reading
    and writing respectively. You might just pretend that only exclusive locks
    exist.</p>
<p class="Pp">Never use the existence of a file <span class="Li">&quot;-e
    $file&quot;</span> as a locking indication, because there is a race
    condition between the test for the existence of the file and its creation.
    It's possible for another process to create a file in the slice of time
    between your existence check and your attempt to create the file. Atomicity
    is critical.</p>
<p class="Pp">Perl's most portable locking interface is via the
    <span class="Li">&quot;flock&quot;</span> function, whose simplicity is
    emulated on systems that don't directly support it such as SysV or Windows.
    The underlying semantics may affect how it all works, so you should learn
    how <span class="Li">&quot;flock&quot;</span> is implemented on your
    system's port of Perl.</p>
<p class="Pp">File locking <i>does not</i> lock out another process that would
    like to do I/O. A file lock only locks out others trying to get a lock, not
    processes trying to do I/O. Because locks are advisory, if one process uses
    locking and another doesn't, all bets are off.</p>
<p class="Pp">By default, the <span class="Li">&quot;flock&quot;</span> call
    will block until a lock is granted. A request for a shared lock will be
    granted as soon as there is no exclusive locker. A request for an exclusive
    lock will be granted as soon as there is no locker of any kind. Locks are on
    file descriptors, not file names. You can't lock a file until you open it,
    and you can't hold on to a lock once the file has been closed.</p>
<p class="Pp">Here's how to get a blocking shared lock on a file, typically used
    for reading:</p>
<p class="Pp"></p>
<pre>
    use 5.004;
    use Fcntl qw(:DEFAULT :flock);
    open(FH, &quot;&lt; filename&quot;)  or die &quot;can't open filename: $!&quot;;
    flock(FH, LOCK_SH)      or die &quot;can't lock filename: $!&quot;;
    # now read from FH
</pre>
<p class="Pp">You can get a non-blocking lock by using
    <span class="Li">&quot;LOCK_NB&quot;</span>.</p>
<p class="Pp"></p>
<pre>
    flock(FH, LOCK_SH | LOCK_NB)
        or die &quot;can't lock filename: $!&quot;;
</pre>
<p class="Pp">This can be useful for producing more user-friendly behaviour by
    warning if you're going to be blocking:</p>
<p class="Pp"></p>
<pre>
    use 5.004;
    use Fcntl qw(:DEFAULT :flock);
    open(FH, &quot;&lt; filename&quot;)  or die &quot;can't open filename: $!&quot;;
    unless (flock(FH, LOCK_SH | LOCK_NB)) {
        $| = 1;
        print &quot;Waiting for lock...&quot;;
        flock(FH, LOCK_SH)  or die &quot;can't lock filename: $!&quot;;
        print &quot;got it.\n&quot;
    } 
    # now read from FH
</pre>
<p class="Pp">To get an exclusive lock, typically used for writing, you have to
    be careful. We <span class="Li">&quot;sysopen&quot;</span> the file so it
    can be locked before it gets emptied. You can get a nonblocking version
    using <span class="Li">&quot;LOCK_EX | LOCK_NB&quot;</span>.</p>
<p class="Pp"></p>
<pre>
    use 5.004;
    use Fcntl qw(:DEFAULT :flock);
    sysopen(FH, &quot;filename&quot;, O_WRONLY | O_CREAT)
        or die &quot;can't open filename: $!&quot;;
    flock(FH, LOCK_EX)
        or die &quot;can't lock filename: $!&quot;;
    truncate(FH, 0)
        or die &quot;can't truncate filename: $!&quot;;
    # now write to FH
</pre>
<p class="Pp">Finally, due to the uncounted millions who cannot be dissuaded
    from wasting cycles on useless vanity devices called hit counters, here's
    how to increment a number in a file safely:</p>
<p class="Pp"></p>
<pre>
    use Fcntl qw(:DEFAULT :flock);

    sysopen(FH, &quot;numfile&quot;, O_RDWR | O_CREAT)
        or die &quot;can't open numfile: $!&quot;;
    # autoflush FH
    $ofh = select(FH); $| = 1; select ($ofh);
    flock(FH, LOCK_EX)
        or die &quot;can't write-lock numfile: $!&quot;;

    $num = &lt;FH&gt; || 0;
    seek(FH, 0, 0)
        or die &quot;can't rewind numfile : $!&quot;;
    print FH $num+1, &quot;\n&quot;
        or die &quot;can't write numfile: $!&quot;;

    truncate(FH, tell(FH))
        or die &quot;can't truncate numfile: $!&quot;;
    close(FH)
        or die &quot;can't close numfile: $!&quot;;
</pre>
</section>
<section class="Ss">
<h2 class="Ss">IO Layers</h2>
<p class="Pp">In Perl 5.8.0 a new I/O framework called &quot;PerlIO&quot; was
    introduced. This is a new &quot;plumbing&quot; for all the I/O happening in
    Perl; for the most part everything will work just as it did, but PerlIO also
    brought in some new features such as the ability to think of I/O as
    &quot;layers&quot;. One I/O layer may in addition to just moving the data
    also do transformations on the data. Such transformations may include
    compression and decompression, encryption and decryption, and transforming
    between various character encodings.</p>
<p class="Pp">Full discussion about the features of PerlIO is out of scope for
    this tutorial, but here is how to recognize the layers being used:</p>
<ul class="Bl-bullet">
  <li>The three-(or more)-argument form of
      <span class="Li">&quot;open&quot;</span> is being used and the second
      argument contains something else in addition to the usual
      <span class="Li">'&lt;'</span>, <span class="Li">'&gt;'</span>,
      <span class="Li">'&gt;&gt;'</span>, <span class="Li">'|'</span> and their
      variants, for example:
    <p class="Pp"></p>
    <pre>
    open(my $fh, &quot;&lt;:crlf&quot;, $fn);
    </pre>
  </li>
  <li>The two-argument form of <span class="Li">&quot;binmode&quot;</span> is
      being used, for example
    <p class="Pp"></p>
    <pre>
    binmode($fh, &quot;:encoding(utf16)&quot;);
    </pre>
  </li>
</ul>
<p class="Pp">For more detailed discussion about PerlIO see PerlIO; for more
    detailed discussion about Unicode and I/O see perluniintro.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">The <span class="Li">&quot;open&quot;</span> and
    <span class="Li">&quot;sysopen&quot;</span> functions in <i>perlfunc</i>(1);
    the system <i>open</i>(2), <i>dup</i>(2), <i>fopen</i>(3), and
    <i>fdopen</i>(3) manpages; the POSIX documentation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR_and_COPYRIGHT"><a class="permalink" href="#AUTHOR_and_COPYRIGHT">AUTHOR
  and COPYRIGHT</a></h1>
<p class="Pp">Copyright 1998 Tom Christiansen.</p>
<p class="Pp">This documentation is free; you can redistribute it and/or modify
    it under the same terms as Perl itself.</p>
<p class="Pp">Irrespective of its distribution, all code examples in these files
    are hereby placed into the public domain. You are permitted and encouraged
    to use this code in your own programs for fun or for profit as you see fit.
    A simple comment in the code giving credit would be courteous but is not
    required.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
<p class="Pp">First release: Sat Jan 9 08:09:11 MST 1999</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

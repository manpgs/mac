<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PERLRE(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLRE(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLRE(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlre - Perl regular expressions</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This page describes the syntax of regular expressions in Perl.</p>
<p class="Pp">If you haven't used regular expressions before, a tutorial
    introduction is available in perlretut. If you know just a little about
    them, a quick-start introduction is available in perlrequick.</p>
<p class="Pp">Except for &quot;The Basics&quot; section, this page assumes you
    are familiar with regular expression basics, like what is a
    &quot;pattern&quot;, what does it look like, and how it is basically used.
    For a reference on how they are used, plus various examples of the same, see
    discussions of <span class="Li">&quot;m//&quot;</span>,
    <span class="Li">&quot;s///&quot;</span>,
    <span class="Li">&quot;qr//&quot;</span> and
    <span class="Li">&quot;??&quot;</span> in &quot;Regexp Quote-Like
    Operators&quot; in perlop.</p>
<p class="Pp">New in v5.22, <span class="Li">&quot;use re 'strict'&quot;</span>
    applies stricter rules than otherwise when compiling regular expression
    patterns. It can find things that, while legal, may not be what you
    intended.</p>
<section class="Ss">
<h2 class="Ss" id="The_Basics"><a class="permalink" href="#The_Basics">The
  Basics</a></h2>
<p class="Pp">Regular expressions are strings with the very particular syntax
    and meaning described in this document and auxiliary documents referred to
    by this one. The strings are called &quot;patterns&quot;. Patterns are used
    to determine if some other string, called the &quot;target&quot;, has (or
    doesn't have) the characteristics specified by the pattern. We call this
    &quot;matching&quot; the target string against the pattern. Usually the
    match is done by having the target be the first operand, and the pattern be
    the second operand, of one of the two binary operators
    <span class="Li">&quot;=~&quot;</span> and
    <span class="Li">&quot;!~&quot;</span>, listed in &quot;Binding
    Operators&quot; in perlop; and the pattern will have been converted from an
    ordinary string by one of the operators in &quot;Regexp Quote-Like
    Operators&quot; in perlop, like so:</p>
<p class="Pp"></p>
<pre> $foo =~ m/abc/
</pre>
<p class="Pp">This evaluates to true if and only if the string in the variable
    <span class="Li">$foo</span> contains somewhere in it, the sequence of
    characters &quot;a&quot;, &quot;b&quot;, then &quot;c&quot;. (The
    <span class="Li">&quot;=~ m&quot;</span>, or match operator, is described in
    &quot;m/PATTERN/msixpodualngc&quot; in perlop.)</p>
<p class="Pp">Patterns that aren't already stored in some variable must be
    delimitted, at both ends, by delimitter characters. These are often, as in
    the example above, forward slashes, and the typical way a pattern is written
    in documentation is with those slashes. In most cases, the delimitter is the
    same character, fore and aft, but there are a few cases where a character
    looks like it has a mirror-image mate, where the opening version is the
    beginning delimiter, and the closing one is the ending delimiter, like</p>
<p class="Pp"></p>
<pre> $foo =~ m&lt;abc&gt;
</pre>
<p class="Pp">Most times, the pattern is evaluated in double-quotish context,
    but it is possible to choose delimiters to force single-quotish, like</p>
<p class="Pp"></p>
<pre> $foo =~ m'abc'
</pre>
<p class="Pp">If the pattern contains its delimiter within it, that delimiter
    must be escaped. Prefixing it with a backslash (<i>e.g.</i>,
    <span class="Li">&quot;/foo\/bar/&quot;</span>) serves this purpose.</p>
<p class="Pp">Any single character in a pattern matches that same character in
    the target string, unless the character is a <i>metacharacter</i> with a
    special meaning described in this document. A sequence of non-metacharacters
    matches the same sequence in the target string, as we saw above with
    <span class="Li">&quot;m/abc/&quot;</span>.</p>
<p class="Pp">Only a few characters (all of them being ASCII punctuation
    characters) are metacharacters. The most commonly used one is a dot
    <span class="Li">&quot;.&quot;</span>, which normally matches almost any
    character (including a dot itself).</p>
<p class="Pp">You can cause characters that normally function as metacharacters
    to be interpreted literally by prefixing them with a
    <span class="Li">&quot;\&quot;</span>, just like the pattern's delimiter
    must be escaped if it also occurs within the pattern. Thus,
    <span class="Li">&quot;\.&quot;</span> matches just a literal dot,
    <span class="Li">&quot;.&quot;</span> instead of its normal meaning. This
    means that the backslash is also a metacharacter, so
    <span class="Li">&quot;\\&quot;</span> matches a single
    <span class="Li">&quot;\&quot;</span>. And a sequence that contains an
    escaped metacharacter matches the same sequence (but without the escape) in
    the target string. So, the pattern
    <span class="Li">&quot;/blur\\fl/&quot;</span> would match any target string
    that contains the sequence <span class="Li">&quot;blur\fl&quot;</span>.</p>
<p class="Pp">The metacharacter <span class="Li">&quot;|&quot;</span> is used to
    match one thing or another. Thus</p>
<p class="Pp"></p>
<pre> $foo =~ m/this|that/
</pre>
<p class="Pp">is TRUE if and only if <span class="Li">$foo</span> contains
    either the sequence <span class="Li">&quot;this&quot;</span> or the sequence
    <span class="Li">&quot;that&quot;</span>. Like all metacharacters, prefixing
    the <span class="Li">&quot;|&quot;</span> with a backslash makes it match
    the plain punctuation character; in its case, the VERTICAL LINE.</p>
<p class="Pp"></p>
<pre> $foo =~ m/this\|that/
</pre>
<p class="Pp">is TRUE if and only if <span class="Li">$foo</span> contains the
    sequence <span class="Li">&quot;this|that&quot;</span>.</p>
<p class="Pp">You aren't limited to just a single
    <span class="Li">&quot;|&quot;</span>.</p>
<p class="Pp"></p>
<pre> $foo =~ m/fee|fie|foe|fum/
</pre>
<p class="Pp">is TRUE if and only if <span class="Li">$foo</span> contains any
    of those 4 sequences from the children's story &quot;Jack and the
    Beanstalk&quot;.</p>
<p class="Pp">As you can see, the <span class="Li">&quot;|&quot;</span> binds
    less tightly than a sequence of ordinary characters. We can override this by
    using the grouping metacharacters, the parentheses
    <span class="Li">&quot;(&quot;</span> and
    <span class="Li">&quot;)&quot;</span>.</p>
<p class="Pp"></p>
<pre> $foo =~ m/th(is|at) thing/
</pre>
<p class="Pp">is TRUE if and only if <span class="Li">$foo</span> contains
    either the sequence <span class="Li">&quot;this&#x00A0;thing&quot;</span> or
    the sequence <span class="Li">&quot;that&#x00A0;thing&quot;</span>. The
    portions of the string that match the portions of the pattern enclosed in
    parentheses are normally made available separately for use later in the
    pattern, substitution, or program. This is called &quot;capturing&quot;, and
    it can get complicated. See &quot;Capture groups&quot;.</p>
<p class="Pp">The first alternative includes everything from the last pattern
    delimiter (<span class="Li">&quot;(&quot;</span>,
    <span class="Li">&quot;(?:&quot;</span> (described later), <i>etc</i>. or
    the beginning of the pattern) up to the first
    <span class="Li">&quot;|&quot;</span>, and the last alternative contains
    everything from the last <span class="Li">&quot;|&quot;</span> to the next
    closing pattern delimiter. That's why it's common practice to include
    alternatives in parentheses: to minimize confusion about where they start
    and end.</p>
<p class="Pp">Alternatives are tried from left to right, so the first
    alternative found for which the entire expression matches, is the one that
    is chosen. This means that alternatives are not necessarily greedy. For
    example: when matching <span class="Li">&quot;foo|foot&quot;</span> against
    <span class="Li">&quot;barefoot&quot;</span>, only the
    <span class="Li">&quot;foo&quot;</span> part will match, as that is the
    first alternative tried, and it successfully matches the target string.
    (This might not seem important, but it is important when you are capturing
    matched text using parentheses.)</p>
<p class="Pp">Besides taking away the special meaning of a metacharacter, a
    prefixed backslash changes some letter and digit characters away from
    matching just themselves to instead have special meaning. These are called
    &quot;escape sequences&quot;, and all such are described in perlrebackslash.
    A backslash sequence (of a letter or digit) that doesn't currently have
    special meaning to Perl will raise a warning if warnings are enabled, as
    those are reserved for potential future use.</p>
<p class="Pp">One such sequence is <span class="Li">&quot;\b&quot;</span>, which
    matches a boundary of some sort. <span class="Li">&quot;\b{wb}&quot;</span>
    and a few others give specialized types of boundaries. (They are all
    described in detail starting at &quot;\b{}, \b, \B{}, \B&quot; in
    perlrebackslash.) Note that these don't match characters, but the zero-width
    spaces between characters. They are an example of a zero-width assertion.
    Consider again,</p>
<p class="Pp"></p>
<pre> $foo =~ m/fee|fie|foe|fum/
</pre>
<p class="Pp">It evaluates to TRUE if, besides those 4 words, any of the
    sequences &quot;feed&quot;, &quot;field&quot;, &quot;Defoe&quot;,
    &quot;fume&quot;, and many others are in <span class="Li">$foo</span>. By
    judicious use of <span class="Li">&quot;\b&quot;</span> (or better (because
    it is designed to handle natural language)
    <span class="Li">&quot;\b{wb}&quot;</span>), we can make sure that only the
    Giant's words are matched:</p>
<p class="Pp"></p>
<pre> $foo =~ m/\b(fee|fie|foe|fum)\b/
 $foo =~ m/\b{wb}(fee|fie|foe|fum)\b{wb}/
</pre>
<p class="Pp">The final example shows that the characters
    <span class="Li">&quot;{&quot;</span> and
    <span class="Li">&quot;}&quot;</span> are metacharacters.</p>
<p class="Pp">Another use for escape sequences is to specify characters that
    cannot (or which you prefer not to) be written literally. These are
    described in detail in &quot;Character Escapes&quot; in perlrebackslash, but
    the next three paragraphs briefly describe some of them.</p>
<p class="Pp">Various control characters can be written in C language style:
    <span class="Li">&quot;\n&quot;</span> matches a newline,
    <span class="Li">&quot;\t&quot;</span> a tab,
    <span class="Li">&quot;\r&quot;</span> a carriage return,
    <span class="Li">&quot;\f&quot;</span> a form feed, <i>etc</i>.</p>
<p class="Pp">More generally,
    <span class="Li">&quot;\</span><span class="Li"><i>nnn</i></span><span class="Li">&quot;</span>,
    where <i>nnn</i> is a string of three octal digits, matches the character
    whose native code point is <i>nnn</i>. You can easily run into trouble if
    you don't have exactly three digits. So always use three, or since Perl
    5.14, you can use <span class="Li">&quot;\o{...}&quot;</span> to specify any
    number of octal digits.</p>
<p class="Pp">Similarly,
    <span class="Li">&quot;\x</span><span class="Li"><i>nn</i></span><span class="Li">&quot;</span>,
    where <i>nn</i> are hexadecimal digits, matches the character whose native
    ordinal is <i>nn</i>. Again, not using exactly two digits is a recipe for
    disaster, but you can use <span class="Li">&quot;\x{...}&quot;</span> to
    specify any number of hex digits.</p>
<p class="Pp">Besides being a metacharacter, the
    <span class="Li">&quot;.&quot;</span> is an example of a &quot;character
    class&quot;, something that can match any single character of a given set of
    them. In its case, the set is just about all possible characters. Perl
    predefines several character classes besides the
    <span class="Li">&quot;.&quot;</span>; there is a separate reference page
    about just these, perlrecharclass.</p>
<p class="Pp">You can define your own custom character classes, by putting into
    your pattern in the appropriate place(s), a list of all the characters you
    want in the set. You do this by enclosing the list within
    <span class="Li">&quot;[]&quot;</span> bracket characters. These are called
    &quot;bracketed character classes&quot; when we are being precise, but often
    the word &quot;bracketed&quot; is dropped. (Dropping it usually doesn't
    cause confusion.) This means that the <span class="Li">&quot;[&quot;</span>
    character is another metacharacter. It doesn't match anything just by
    itself; it is used only to tell Perl that what follows it is a bracketed
    character class. If you want to match a literal left square bracket, you
    must escape it, like <span class="Li">&quot;\[&quot;</span>. The matching
    <span class="Li">&quot;]&quot;</span> is also a metacharacter; again it
    doesn't match anything by itself, but just marks the end of your custom
    class to Perl. It is an example of a &quot;sometimes metacharacter&quot;. It
    isn't a metacharacter if there is no corresponding
    <span class="Li">&quot;[&quot;</span>, and matches its literal self:</p>
<p class="Pp"></p>
<pre> print &quot;]&quot; =~ /]/;  # prints 1
</pre>
<p class="Pp">The list of characters within the character class gives the set of
    characters matched by the class. <span class="Li">&quot;[abc]&quot;</span>
    matches a single &quot;a&quot; or &quot;b&quot; or &quot;c&quot;. But if the
    first character after the <span class="Li">&quot;[&quot;</span> is
    <span class="Li">&quot;^&quot;</span>, the class instead matches any
    character not in the list. Within a list, the
    <span class="Li">&quot;-&quot;</span> character specifies a range of
    characters, so that <span class="Li">&quot;a-z&quot;</span> represents all
    characters between &quot;a&quot; and &quot;z&quot;, inclusive. If you want
    either <span class="Li">&quot;-&quot;</span> or
    <span class="Li">&quot;]&quot;</span> itself to be a member of a class, put
    it at the start of the list (possibly after a
    <span class="Li">&quot;^&quot;</span>), or escape it with a backslash.
    <span class="Li">&quot;-&quot;</span> is also taken literally when it is at
    the end of the list, just before the closing
    <span class="Li">&quot;]&quot;</span>. (The following all specify the same
    class of three characters: <span class="Li">&quot;[-az]&quot;</span>,
    <span class="Li">&quot;[az-]&quot;</span>, and
    <span class="Li">&quot;[a\-z]&quot;</span>. All are different from
    <span class="Li">&quot;[a-z]&quot;</span>, which specifies a class
    containing twenty-six characters, even on EBCDIC-based character sets.)</p>
<p class="Pp">There is lots more to bracketed character classes; full details
    are in &quot;Bracketed Character Classes&quot; in perlrecharclass.</p>
<p class="Pp"><i>Metacharacters</i></p>
<p class="Pp">&quot;The Basics&quot; introduced some of the metacharacters. This
    section gives them all. Most of them have the same meaning as in the
    <i>egrep</i> command.</p>
<p class="Pp">Only the <span class="Li">&quot;\&quot;</span> is always a
    metacharacter. The others are metacharacters just sometimes. The following
    tables lists all of them, summarizes their use, and gives the contexts where
    they are metacharacters. Outside those contexts or if prefixed by a
    <span class="Li">&quot;\&quot;</span>, they match their corresponding
    punctuation character. In some cases, their meaning varies depending on
    various pattern modifiers that alter the default behaviors. See
    &quot;Modifiers&quot;.</p>
<p class="Pp"></p>
<pre>            PURPOSE                                  WHERE
 \   Escape the next character                    Always, except when
                                                  escaped by another \
 ^   Match the beginning of the string            Not in []
       (or line, if /m is used)
 ^   Complement the [] class                      At the beginning of []
 .   Match any single character except newline    Not in []
       (under /s, includes newline)
 $   Match the end of the string                  Not in [], but can
       (or before newline at the end of the       mean interpolate a
       string; or before any newline if /m is     scalar
       used)
 |   Alternation                                  Not in []
 ()  Grouping                                     Not in []
 [   Start Bracketed Character class              Not in []
 ]   End Bracketed Character class                Only in [], and
                                                    not first
 *   Matches the preceding element 0 or more      Not in []
       times
 +   Matches the preceding element 1 or more      Not in []
       times
 ?   Matches the preceding element 0 or 1         Not in []
       times
 {   Starts a sequence that gives number(s)       Not in []
       of times the preceding element can be
       matched
 {   when following certain escape sequences
       starts a modifier to the meaning of the
       sequence
 }   End sequence started by {
 -   Indicates a range                            Only in [] interior
 #   Beginning of comment, extends to line end    Only with /x modifier
</pre>
<p class="Pp">Notice that most of the metacharacters lose their special meaning
    when they occur in a bracketed character class, except
    <span class="Li">&quot;^&quot;</span> has a different meaning when it is at
    the beginning of such a class. And <span class="Li">&quot;-&quot;</span> and
    <span class="Li">&quot;]&quot;</span> are metacharacters only at restricted
    positions within bracketed character classes; while
    <span class="Li">&quot;}&quot;</span> is a metacharacter only when closing a
    special construct started by <span class="Li">&quot;{&quot;</span>.</p>
<p class="Pp">In double-quotish context, as is usually the case, you need to be
    careful about <span class="Li">&quot;$&quot;</span> and the
    non-metacharacter <span class="Li">&quot;@&quot;</span>. Those could
    interpolate variables, which may or may not be what you intended.</p>
<p class="Pp">These rules were designed for compactness of expression, rather
    than legibility and maintainability. The &quot;/x and /xx&quot; pattern
    modifiers allow you to insert white space to improve readability. And use of
    <span class="Li">&quot;re&#x00A0;'strict'&quot;</span> adds extra checking
    to catch some typos that might silently compile into something
  unintended.</p>
<p class="Pp">By default, the <span class="Li">&quot;^&quot;</span> character is
    guaranteed to match only the beginning of the string, the
    <span class="Li">&quot;$&quot;</span> character only the end (or before the
    newline at the end), and Perl does certain optimizations with the assumption
    that the string contains only one line. Embedded newlines will not be
    matched by <span class="Li">&quot;^&quot;</span> or
    <span class="Li">&quot;$&quot;</span>. You may, however, wish to treat a
    string as a multi-line buffer, such that the
    <span class="Li">&quot;^&quot;</span> will match after any newline within
    the string (except if the newline is the last character in the string), and
    <span class="Li">&quot;$&quot;</span> will match before any newline. At the
    cost of a little more overhead, you can do this by using the
    <span class="Li">&quot;/m&quot;</span> modifier on the pattern match
    operator. (Older programs did this by setting <span class="Li">$*</span>,
    but this option was removed in perl 5.10.)</p>
<p class="Pp">To simplify multi-line substitutions, the
    <span class="Li">&quot;.&quot;</span> character never matches a newline
    unless you use the <span class="Li">&quot;/s&quot;</span> modifier, which in
    effect tells Perl to pretend the string is a single line--even if it
  isn't.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Modifiers"><a class="permalink" href="#Modifiers">Modifiers</a></h2>
<p class="Pp"><i>Overview</i></p>
<p class="Pp">The default behavior for matching can be changed, using various
    modifiers. Modifiers that relate to the interpretation of the pattern are
    listed just below. Modifiers that alter the way a pattern is used by Perl
    are detailed in &quot;Regexp Quote-Like Operators&quot; in perlop and
    &quot;Gory details of parsing quoted constructs&quot; in perlop. Modifiers
    can be added dynamically; see &quot;Extended Patterns&quot; below.</p>
<dl class="Bl-tag">
  <dt><b></b><span class="Li"><b>&quot;m&quot;</b></span><b></b></dt>
  <dd>Treat the string being matched against as multiple lines. That is, change
      <span class="Li">&quot;^&quot;</span> and
      <span class="Li">&quot;$&quot;</span> from matching the start of the
      string's first line and the end of its last line to matching the start and
      end of each line within the string.</dd>
  <dt><b></b><span class="Li"><b>&quot;s&quot;</b></span><b></b></dt>
  <dd>Treat the string as single line. That is, change
      <span class="Li">&quot;.&quot;</span> to match any character whatsoever,
      even a newline, which normally it would not match.
    <p class="Pp">Used together, as <span class="Li">&quot;/ms&quot;</span>,
        they let the <span class="Li">&quot;.&quot;</span> match any character
        whatsoever, while still allowing <span class="Li">&quot;^&quot;</span>
        and <span class="Li">&quot;$&quot;</span> to match, respectively, just
        after and just before newlines within the string.</p>
  </dd>
  <dt><b></b><span class="Li"><b>&quot;i&quot;</b></span><b></b></dt>
  <dd>Do case-insensitive pattern matching. For example, &quot;A&quot; will
      match &quot;a&quot; under <span class="Li">&quot;/i&quot;</span>.
    <p class="Pp">If locale matching rules are in effect, the case map is taken
        from the current locale for code points less than 255, and from Unicode
        rules for larger code points. However, matches that would cross the
        Unicode rules/non-Unicode rules boundary (ords 255/256) will not
        succeed, unless the locale is a UTF-8 one. See perllocale.</p>
    <p class="Pp">There are a number of Unicode characters that match a sequence
        of multiple characters under <span class="Li">&quot;/i&quot;</span>. For
        example, <span class="Li">&quot;LATIN SMALL LIGATURE FI&quot;</span>
        should match the sequence <span class="Li">&quot;fi&quot;</span>. Perl
        is not currently able to do this when the multiple characters are in the
        pattern and are split between groupings, or when one or more are
        quantified. Thus</p>
    <p class="Pp"></p>
    <pre> &quot;\N{LATIN SMALL LIGATURE FI}&quot; =~ /fi/i;          # Matches
 &quot;\N{LATIN SMALL LIGATURE FI}&quot; =~ /[fi][fi]/i;    # Doesn't match!
 &quot;\N{LATIN SMALL LIGATURE FI}&quot; =~ /fi*/i;         # Doesn't match!
 # The below doesn't match, and it isn't clear what $1 and $2 would
 # be even if it did!!
 &quot;\N{LATIN SMALL LIGATURE FI}&quot; =~ /(f)(i)/i;      # Doesn't match!
    </pre>
    <p class="Pp">Perl doesn't match multiple characters in a bracketed
        character class unless the character that maps to them is explicitly
        mentioned, and it doesn't match them at all if the character class is
        inverted, which otherwise could be highly confusing. See &quot;Bracketed
        Character Classes&quot; in perlrecharclass, and &quot;Negation&quot; in
        perlrecharclass.</p>
  </dd>
  <dt><b></b><span class="Li"><b>&quot;x&quot;</b></span><b></b> and
    <b></b><span class="Li"><b>&quot;xx&quot;</b></span><b></b></dt>
  <dd>Extend your pattern's legibility by permitting whitespace and comments.
      Details in &quot;/x and /xx&quot;</dd>
  <dt><b></b><span class="Li"><b>&quot;p&quot;</b></span><b></b></dt>
  <dd>Preserve the string matched such that
      <span class="Li">&quot;${^PREMATCH}&quot;</span>,
      <span class="Li">&quot;${^MATCH}&quot;</span>, and
      <span class="Li">&quot;${^POSTMATCH}&quot;</span> are available for use
      after matching.
    <p class="Pp">In Perl 5.20 and higher this is ignored. Due to a new
        copy-on-write mechanism,
        <span class="Li">&quot;${^PREMATCH}&quot;</span>,
        <span class="Li">&quot;${^MATCH}&quot;</span>, and
        <span class="Li">&quot;${^POSTMATCH}&quot;</span> will be available
        after the match regardless of the modifier.</p>
  </dd>
  <dt><b></b><span class="Li"><b>&quot;a&quot;</b></span><b></b>,
    <b></b><span class="Li"><b>&quot;d&quot;</b></span><b></b>,
    <b></b><span class="Li"><b>&quot;l&quot;</b></span><b></b>, and
    <b></b><span class="Li"><b>&quot;u&quot;</b></span><b></b></dt>
  <dd>These modifiers, all new in 5.14, affect which character-set rules
      (Unicode, <i>etc</i>.) are used, as described below in &quot;Character set
      modifiers&quot;.</dd>
  <dt><b></b><span class="Li"><b>&quot;n&quot;</b></span><b></b></dt>
  <dd>Prevent the grouping metacharacters <span class="Li">&quot;()&quot;</span>
      from capturing. This modifier, new in 5.22, will stop
      <span class="Li">$1</span>, <span class="Li">$2</span>, <i>etc</i>... from
      being filled in.
    <p class="Pp"></p>
    <pre>  &quot;hello&quot; =~ /(hi|hello)/;   # $1 is &quot;hello&quot;
  &quot;hello&quot; =~ /(hi|hello)/n;  # $1 is undef
    </pre>
    <p class="Pp">This is equivalent to putting
        <span class="Li">&quot;?:&quot;</span> at the beginning of every
        capturing group:</p>
    <p class="Pp"></p>
    <pre>  &quot;hello&quot; =~ /(?:hi|hello)/; # $1 is undef
    </pre>
    <p class="Pp"><span class="Li">&quot;/n&quot;</span> can be negated on a
        per-group basis. Alternatively, named captures may still be used.</p>
    <p class="Pp"></p>
    <pre>  &quot;hello&quot; =~ /(?-n:(hi|hello))/n;   # $1 is &quot;hello&quot;
  &quot;hello&quot; =~ /(?&lt;greet&gt;hi|hello)/n; # $1 is &quot;hello&quot;, $+{greet} is
                                    # &quot;hello&quot;
    </pre>
  </dd>
  <dt id="Other"><a class="permalink" href="#Other">Other Modifiers</a></dt>
  <dd>There are a number of flags that can be found at the end of regular
      expression constructs that are <i>not</i> generic regular expression
      flags, but apply to the operation being performed, like matching or
      substitution (<span class="Li">&quot;m//&quot;</span> or
      <span class="Li">&quot;s///&quot;</span> respectively).
    <p class="Pp">Flags described further in &quot;Using regular expressions in
        Perl&quot; in perlretut are:</p>
    <p class="Pp"></p>
    <pre>  c  - keep the current position during repeated matching
  g  - globally match the pattern repeatedly in the string
    </pre>
    <p class="Pp">Substitution-specific modifiers described in
        &quot;s/PATTERN/REPLACEMENT/msixpodualngcer&quot; in perlop are:</p>
    <p class="Pp"></p>
    <pre>  e  - evaluate the right-hand side as an expression
  ee - evaluate the right side as a string then eval the result
  o  - pretend to optimize your code, but actually introduce bugs
  r  - perform non-destructive substitution and return the new value
    </pre>
  </dd>
</dl>
<p class="Pp">Regular expression modifiers are usually written in documentation
    as <i>e.g.</i>, &quot;the <span class="Li">&quot;/x&quot;</span>
    modifier&quot;, even though the delimiter in question might not really be a
    slash. The modifiers <span class="Li">&quot;/imnsxadlup&quot;</span> may
    also be embedded within the regular expression itself using the
    <span class="Li">&quot;(?...)&quot;</span> construct, see &quot;Extended
    Patterns&quot; below.</p>
<p class="Pp"><i>Details on some modifiers</i></p>
<p class="Pp">Some of the modifiers require more explanation than given in the
    &quot;Overview&quot; above.</p>
<p class="Pp"><span class="Li">&quot;/x&quot;</span> and
    <span class="Li">&quot;/xx&quot;</span></p>
<p class="Pp">A single <span class="Li">&quot;/x&quot;</span> tells the regular
    expression parser to ignore most whitespace that is neither backslashed nor
    within a bracketed character class. You can use this to break up your
    regular expression into more readable parts. Also, the
    <span class="Li">&quot;#&quot;</span> character is treated as a
    metacharacter introducing a comment that runs up to the pattern's closing
    delimiter, or to the end of the current line if the pattern extends onto the
    next line. Hence, this is very much like an ordinary Perl code comment. (You
    can include the closing delimiter within the comment only if you precede it
    with a backslash, so be careful!)</p>
<p class="Pp">Use of <span class="Li">&quot;/x&quot;</span> means that if you
    want real whitespace or <span class="Li">&quot;#&quot;</span> characters in
    the pattern (outside a bracketed character class, which is unaffected by
    <span class="Li">&quot;/x&quot;</span>), then you'll either have to escape
    them (using backslashes or <span class="Li">&quot;\Q...\E&quot;</span>) or
    encode them using octal, hex, or <span class="Li">&quot;\N{}&quot;</span> or
    <span class="Li">&quot;\p{name=...}&quot;</span> escapes. It is ineffective
    to try to continue a comment onto the next line by escaping the
    <span class="Li">&quot;\n&quot;</span> with a backslash or
    <span class="Li">&quot;\Q&quot;</span>.</p>
<p class="Pp">You can use &quot;(?#text)&quot; to create a comment that ends
    earlier than the end of the current line, but
    <span class="Li">&quot;text&quot;</span> also can't contain the closing
    delimiter unless escaped with a backslash.</p>
<p class="Pp">A common pitfall is to forget that
    <span class="Li">&quot;#&quot;</span> characters begin a comment under
    <span class="Li">&quot;/x&quot;</span> and are not matched literally. Just
    keep that in mind when trying to puzzle out why a particular
    <span class="Li">&quot;/x&quot;</span> pattern isn't working as
  expected.</p>
<p class="Pp">Starting in Perl v5.26, if the modifier has a second
    <span class="Li">&quot;x&quot;</span> within it, it does everything that a
    single <span class="Li">&quot;/x&quot;</span> does, but additionally
    non-backslashed SPACE and TAB characters within bracketed character classes
    are also generally ignored, and hence can be added to make the classes more
    readable.</p>
<p class="Pp"></p>
<pre>    / [d-e g-i 3-7]/xx
    /[ ! @ &quot; # $ % ^ &amp; * () = ? &lt;&gt; ' ]/xx
</pre>
<p class="Pp">may be easier to grasp than the squashed equivalents</p>
<p class="Pp"></p>
<pre>    /[d-eg-i3-7]/
    /[!@&quot;#$%^&amp;*()=?&lt;&gt;']/
</pre>
<p class="Pp">Taken together, these features go a long way towards making Perl's
    regular expressions more readable. Here's an example:</p>
<p class="Pp"></p>
<pre>    # Delete (most) C comments.
    $program =~ s {
        /\*     # Match the opening delimiter.
        .*?     # Match a minimal number of characters.
        \*/     # Match the closing delimiter.
    } []gsx;
</pre>
<p class="Pp">Note that anything inside a
    <span class="Li">&quot;\Q...\E&quot;</span> stays unaffected by
    <span class="Li">&quot;/x&quot;</span>. And note that
    <span class="Li">&quot;/x&quot;</span> doesn't affect space interpretation
    within a single multi-character construct. For example
    <span class="Li">&quot;(?:...)&quot;</span> can't have a space between the
    <span class="Li">&quot;(&quot;</span>,
    <span class="Li">&quot;?&quot;</span>, and
    <span class="Li">&quot;:&quot;</span>. Within any delimiters for such a
    construct, allowed spaces are not affected by
    <span class="Li">&quot;/x&quot;</span>, and depend on the construct. For
    example, all constructs using curly braces as delimiters, such as
    <span class="Li">&quot;\x{...}&quot;</span> can have blanks within but
    adjacent to the braces, but not elsewhere, and no non-blank space
    characters. An exception are Unicode properties which follow Unicode rules,
    for which see &quot;Properties accessible through \p{} and \P{}&quot; in
    perluniprops.</p>
<p class="Pp">The set of characters that are deemed whitespace are those that
    Unicode calls &quot;Pattern White Space&quot;, namely:</p>
<p class="Pp"></p>
<pre> U+0009 CHARACTER TABULATION
 U+000A LINE FEED
 U+000B LINE TABULATION
 U+000C FORM FEED
 U+000D CARRIAGE RETURN
 U+0020 SPACE
 U+0085 NEXT LINE
 U+200E LEFT-TO-RIGHT MARK
 U+200F RIGHT-TO-LEFT MARK
 U+2028 LINE SEPARATOR
 U+2029 PARAGRAPH SEPARATOR
</pre>
<p class="Pp">Character set modifiers</p>
<p class="Pp"><span class="Li">&quot;/d&quot;</span>,
    <span class="Li">&quot;/u&quot;</span>,
    <span class="Li">&quot;/a&quot;</span>, and
    <span class="Li">&quot;/l&quot;</span>, available starting in 5.14, are
    called the character set modifiers; they affect the character set rules used
    for the regular expression.</p>
<p class="Pp">The <span class="Li">&quot;/d&quot;</span>,
    <span class="Li">&quot;/u&quot;</span>, and
    <span class="Li">&quot;/l&quot;</span> modifiers are not likely to be of
    much use to you, and so you need not worry about them very much. They exist
    for Perl's internal use, so that complex regular expression data structures
    can be automatically serialized and later exactly reconstituted, including
    all their nuances. But, since Perl can't keep a secret, and there may be
    rare instances where they are useful, they are documented here.</p>
<p class="Pp">The <span class="Li">&quot;/a&quot;</span> modifier, on the other
    hand, may be useful. Its purpose is to allow code that is to work mostly on
    ASCII data to not have to concern itself with Unicode.</p>
<p class="Pp">Briefly, <span class="Li">&quot;/l&quot;</span> sets the character
    set to that of whatever <b>L</b>ocale is in effect at the time of the
    execution of the pattern match.</p>
<p class="Pp"><span class="Li">&quot;/u&quot;</span> sets the character set to
    <b>U</b>nicode.</p>
<p class="Pp"><span class="Li">&quot;/a&quot;</span> also sets the character set
    to Unicode, BUT adds several restrictions for <b>A</b>SCII-safe
  matching.</p>
<p class="Pp"><span class="Li">&quot;/d&quot;</span> is the old, problematic,
    pre-5.14 <b>D</b>efault character set behavior. Its only use is to force
    that old behavior.</p>
<p class="Pp">At any given time, exactly one of these modifiers is in effect.
    Their existence allows Perl to keep the originally compiled behavior of a
    regular expression, regardless of what rules are in effect when it is
    actually executed. And if it is interpolated into a larger regex, the
    original's rules continue to apply to it, and don't affect the other
  parts.</p>
<p class="Pp">The <span class="Li">&quot;/l&quot;</span> and
    <span class="Li">&quot;/u&quot;</span> modifiers are automatically selected
    for regular expressions compiled within the scope of various pragmas, and we
    recommend that in general, you use those pragmas instead of specifying these
    modifiers explicitly. For one thing, the modifiers affect only pattern
    matching, and do not extend to even any replacement done, whereas using the
    pragmas gives consistent results for all appropriate operations within their
    scopes. For example,</p>
<p class="Pp"></p>
<pre> s/foo/\Ubar/il
</pre>
<p class="Pp">will match &quot;foo&quot; using the locale's rules for
    case-insensitive matching, but the <span class="Li">&quot;/l&quot;</span>
    does not affect how the <span class="Li">&quot;\U&quot;</span> operates.
    Most likely you want both of them to use locale rules. To do this, instead
    compile the regular expression within the scope of
    <span class="Li">&quot;use locale&quot;</span>. This both implicitly adds
    the <span class="Li">&quot;/l&quot;</span>, and applies locale rules to the
    <span class="Li">&quot;\U&quot;</span>. The lesson is to
    <span class="Li">&quot;use locale&quot;</span>, and not
    <span class="Li">&quot;/l&quot;</span> explicitly.</p>
<p class="Pp">Similarly, it would be better to use <span class="Li">&quot;use
    feature 'unicode_strings'&quot;</span> instead of,</p>
<p class="Pp"></p>
<pre> s/foo/\Lbar/iu
</pre>
<p class="Pp">to get Unicode rules, as the
    <span class="Li">&quot;\L&quot;</span> in the former (but not necessarily
    the latter) would also use Unicode rules.</p>
<p class="Pp">More detail on each of the modifiers follows. Most likely you
    don't need to know this detail for <span class="Li">&quot;/l&quot;</span>,
    <span class="Li">&quot;/u&quot;</span>, and
    <span class="Li">&quot;/d&quot;</span>, and can skip ahead to /a.</p>
<p class="Pp">/l</p>
<p class="Pp">means to use the current locale's rules (see perllocale) when
    pattern matching. For example, <span class="Li">&quot;\w&quot;</span> will
    match the &quot;word&quot; characters of that locale, and
    <span class="Li">&quot;/i&quot;</span> case-insensitive matching will match
    according to the locale's case folding rules. The locale used will be the
    one in effect at the time of execution of the pattern match. This may not be
    the same as the compilation-time locale, and can differ from one match to
    another if there is an intervening call of the <b>setlocale()</b>
  function.</p>
<p class="Pp">Prior to v5.20, Perl did not support multi-byte locales. Starting
    then, UTF-8 locales are supported. No other multi byte locales are ever
    likely to be supported. However, in all locales, one can have code points
    above 255 and these will always be treated as Unicode no matter what locale
    is in effect.</p>
<p class="Pp">Under Unicode rules, there are a few case-insensitive matches that
    cross the 255/256 boundary. Except for UTF-8 locales in Perls v5.20 and
    later, these are disallowed under <span class="Li">&quot;/l&quot;</span>.
    For example, 0xFF (on ASCII platforms) does not caselessly match the
    character at 0x178, <span class="Li">&quot;LATIN</span>
    <span class="Li">CAPITAL LETTER Y WITH DIAERESIS&quot;</span>, because 0xFF
    may not be <span class="Li">&quot;LATIN SMALL</span> <span class="Li">LETTER
    Y WITH DIAERESIS&quot;</span> in the current locale, and Perl has no way of
    knowing if that character even exists in the locale, much less what code
    point it is.</p>
<p class="Pp">In a UTF-8 locale in v5.20 and later, the only visible difference
    between locale and non-locale in regular expressions should be tainting (see
    perlsec).</p>
<p class="Pp">This modifier may be specified to be the default by
    <span class="Li">&quot;use locale&quot;</span>, but see &quot;Which
    character set modifier is in effect?&quot;.</p>
<p class="Pp">/u</p>
<p class="Pp">means to use Unicode rules when pattern matching. On ASCII
    platforms, this means that the code points between 128 and 255 take on their
    Latin-1 (ISO-8859-1) meanings (which are the same as Unicode's). (Otherwise
    Perl considers their meanings to be undefined.) Thus, under this modifier,
    the ASCII platform effectively becomes a Unicode platform; and hence, for
    example, <span class="Li">&quot;\w&quot;</span> will match any of the more
    than 100_000 word characters in Unicode.</p>
<p class="Pp">Unlike most locales, which are specific to a language and country
    pair, Unicode classifies all the characters that are letters
    <i>somewhere</i> in the world as <span class="Li">&quot;\w&quot;</span>. For
    example, your locale might not think that <span class="Li">&quot;LATIN
    SMALL</span> <span class="Li">LETTER ETH&quot;</span> is a letter (unless
    you happen to speak Icelandic), but Unicode does. Similarly, all the
    characters that are decimal digits somewhere in the world will match
    <span class="Li">&quot;\d&quot;</span>; this is hundreds, not 10, possible
    matches. And some of those digits look like some of the 10 ASCII digits, but
    mean a different number, so a human could easily think a number is a
    different quantity than it really is. For example,
    <span class="Li">&quot;BENGALI DIGIT FOUR&quot;</span> (U+09EA) looks very
    much like an <span class="Li">&quot;ASCII DIGIT EIGHT&quot;</span> (U+0038),
    and <span class="Li">&quot;LEPCHA DIGIT SIX&quot;</span> (U+1C46) looks very
    much like an <span class="Li">&quot;ASCII DIGIT FIVE&quot;</span> (U+0035).
    And, <span class="Li">&quot;\d+&quot;</span>, may match strings of digits
    that are a mixture from different writing systems, creating a security
    issue. A fraudulent website, for example, could display the price of
    something using U+1C46, and it would appear to the user that something cost
    500 units, but it really costs 600. A browser that enforced script runs
    (&quot;Script Runs&quot;) would prevent that fraudulent display.
    &quot;<b>num()</b>&quot; in Unicode::UCD can also be used to sort this out.
    Or the <span class="Li">&quot;/a&quot;</span> modifier can be used to force
    <span class="Li">&quot;\d&quot;</span> to match just the ASCII 0 through
  9.</p>
<p class="Pp">Also, under this modifier, case-insensitive matching works on the
    full set of Unicode characters. The <span class="Li">&quot;KELVIN
    SIGN&quot;</span>, for example matches the letters &quot;k&quot; and
    &quot;K&quot;; and <span class="Li">&quot;LATIN SMALL LIGATURE
    FF&quot;</span> matches the sequence &quot;ff&quot;, which, if you're not
    prepared, might make it look like a hexadecimal constant, presenting another
    potential security issue. See &lt;https://unicode.org/reports/tr36&gt; for a
    detailed discussion of Unicode security issues.</p>
<p class="Pp">This modifier may be specified to be the default by
    <span class="Li">&quot;use feature</span>
    <span class="Li">'unicode_strings&quot;</span>, <span class="Li">&quot;use
    locale ':not_characters'&quot;</span>, or <span class="Li">&quot;use
    5.012&quot;</span> (or higher), but see &quot;Which character set modifier
    is in effect?&quot;.</p>
<p class="Pp">/d</p>
<p class="Pp">This modifier means to use the &quot;Default&quot; native rules of
    the platform except when there is cause to use Unicode rules instead, as
    follows:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>the target string is encoded in UTF-8; or</dd>
  <dt>2.</dt>
  <dd>the pattern is encoded in UTF-8; or</dd>
  <dt>3.</dt>
  <dd>the pattern explicitly mentions a code point that is above 255 (say by
      <span class="Li">&quot;\x{100}&quot;</span>); or</dd>
  <dt>4.</dt>
  <dd>the pattern uses a Unicode name
      (<span class="Li">&quot;\N{...}&quot;</span>); or</dd>
  <dt>5.</dt>
  <dd>the pattern uses a Unicode property
      (<span class="Li">&quot;\p{...}&quot;</span> or
      <span class="Li">&quot;\P{...}&quot;</span>); or</dd>
  <dt>6.</dt>
  <dd>the pattern uses a Unicode break
      (<span class="Li">&quot;\b{...}&quot;</span> or
      <span class="Li">&quot;\B{...}&quot;</span>); or</dd>
  <dt>7.</dt>
  <dd>the pattern uses <span class="Li">&quot;(?[ ])&quot;</span></dd>
  <dt>8.</dt>
  <dd>the pattern uses <span class="Li">&quot;(*script_run:
    ...)&quot;</span></dd>
</dl>
<p class="Pp">Another mnemonic for this modifier is &quot;Depends&quot;, as the
    rules actually used depend on various things, and as a result you can get
    unexpected results. See &quot;The &quot;Unicode Bug&quot;&quot; in
    perlunicode. The Unicode Bug has become rather infamous, leading to yet
    other (without swearing) names for this modifier, &quot;Dicey&quot; and
    &quot;Dodgy&quot;.</p>
<p class="Pp">Unless the pattern or string are encoded in UTF-8, only ASCII
    characters can match positively.</p>
<p class="Pp">Here are some examples of how that works on an ASCII platform:</p>
<p class="Pp"></p>
<pre> $str =  &quot;\xDF&quot;;      # $str is not in UTF-8 format.
 $str =~ /^\w/;       # No match, as $str isn't in UTF-8 format.
 $str .= &quot;\x{0e0b}&quot;;  # Now $str is in UTF-8 format.
 $str =~ /^\w/;       # Match! $str is now in UTF-8 format.
 chop $str;
 $str =~ /^\w/;       # Still a match! $str remains in UTF-8 format.
</pre>
<p class="Pp">This modifier is automatically selected by default when none of
    the others are, so yet another name for it is &quot;Default&quot;.</p>
<p class="Pp">Because of the unexpected behaviors associated with this modifier,
    you probably should only explicitly use it to maintain weird backward
    compatibilities.</p>
<p class="Pp">/a (and /aa)</p>
<p class="Pp">This modifier stands for ASCII-restrict (or ASCII-safe). This
    modifier may be doubled-up to increase its effect.</p>
<p class="Pp">When it appears singly, it causes the sequences
    <span class="Li">&quot;\d&quot;</span>,
    <span class="Li">&quot;\s&quot;</span>,
    <span class="Li">&quot;\w&quot;</span>, and the Posix character classes to
    match only in the ASCII range. They thus revert to their pre-5.6,
    pre-Unicode meanings. Under <span class="Li">&quot;/a&quot;</span>,
    <span class="Li">&quot;\d&quot;</span> always means precisely the digits
    <span class="Li">&quot;0&quot;</span> to
    <span class="Li">&quot;9&quot;</span>;
    <span class="Li">&quot;\s&quot;</span> means the five characters
    <span class="Li">&quot;[ \f\n\r\t]&quot;</span>, and starting in Perl v5.18,
    the vertical tab; <span class="Li">&quot;\w&quot;</span> means the 63
    characters <span class="Li">&quot;[A-Za-z0-9_]&quot;</span>; and likewise,
    all the Posix classes such as
    <span class="Li">&quot;[[:print:]]&quot;</span> match only the appropriate
    ASCII-range characters.</p>
<p class="Pp">This modifier is useful for people who only incidentally use
    Unicode, and who do not wish to be burdened with its complexities and
    security concerns.</p>
<p class="Pp">With <span class="Li">&quot;/a&quot;</span>, one can write
    <span class="Li">&quot;\d&quot;</span> with confidence that it will only
    match ASCII characters, and should the need arise to match beyond ASCII, you
    can instead use <span class="Li">&quot;\p{Digit}&quot;</span> (or
    <span class="Li">&quot;\p{Word}&quot;</span> for
    <span class="Li">&quot;\w&quot;</span>). There are similar
    <span class="Li">&quot;\p{...}&quot;</span> constructs that can match beyond
    ASCII both white space (see &quot;Whitespace&quot; in perlrecharclass), and
    Posix classes (see &quot;POSIX Character Classes&quot; in perlrecharclass).
    Thus, this modifier doesn't mean you can't use Unicode, it means that to get
    Unicode matching you must explicitly use a construct
    (<span class="Li">&quot;\p{}&quot;</span>,
    <span class="Li">&quot;\P{}&quot;</span>) that signals Unicode.</p>
<p class="Pp">As you would expect, this modifier causes, for example,
    <span class="Li">&quot;\D&quot;</span> to mean the same thing as
    <span class="Li">&quot;[^0-9]&quot;</span>; in fact, all non-ASCII
    characters match <span class="Li">&quot;\D&quot;</span>,
    <span class="Li">&quot;\S&quot;</span>, and
    <span class="Li">&quot;\W&quot;</span>.
    <span class="Li">&quot;\b&quot;</span> still means to match at the boundary
    between <span class="Li">&quot;\w&quot;</span> and
    <span class="Li">&quot;\W&quot;</span>, using the
    <span class="Li">&quot;/a&quot;</span> definitions of them (similarly for
    <span class="Li">&quot;\B&quot;</span>).</p>
<p class="Pp">Otherwise, <span class="Li">&quot;/a&quot;</span> behaves like the
    <span class="Li">&quot;/u&quot;</span> modifier, in that case-insensitive
    matching uses Unicode rules; for example, &quot;k&quot; will match the
    Unicode <span class="Li">&quot;\N{KELVIN SIGN}&quot;</span> under
    <span class="Li">&quot;/i&quot;</span> matching, and code points in the
    Latin1 range, above ASCII will have Unicode rules when it comes to
    case-insensitive matching.</p>
<p class="Pp">To forbid ASCII/non-ASCII matches (like &quot;k&quot; with
    <span class="Li">&quot;\N{KELVIN SIGN}&quot;</span>), specify the
    <span class="Li">&quot;a&quot;</span> twice, for example
    <span class="Li">&quot;/aai&quot;</span> or
    <span class="Li">&quot;/aia&quot;</span>. (The first occurrence of
    <span class="Li">&quot;a&quot;</span> restricts the
    <span class="Li">&quot;\d&quot;</span>, <i>etc</i>., and the second
    occurrence adds the <span class="Li">&quot;/i&quot;</span> restrictions.)
    But, note that code points outside the ASCII range will use Unicode rules
    for <span class="Li">&quot;/i&quot;</span> matching, so the modifier doesn't
    really restrict things to just ASCII; it just forbids the intermixing of
    ASCII and non-ASCII.</p>
<p class="Pp">To summarize, this modifier provides protection for applications
    that don't wish to be exposed to all of Unicode. Specifying it twice gives
    added protection.</p>
<p class="Pp">This modifier may be specified to be the default by
    <span class="Li">&quot;use re '/a'&quot;</span> or
    <span class="Li">&quot;use re '/aa'&quot;</span>. If you do so, you may
    actually have occasion to use the <span class="Li">&quot;/u&quot;</span>
    modifier explicitly if there are a few regular expressions where you do want
    full Unicode rules (but even here, it's best if everything were under
    feature <span class="Li">&quot;unicode_strings&quot;</span>, along with the
    <span class="Li">&quot;use re '/aa'&quot;</span>). Also see &quot;Which
    character set modifier is in effect?&quot;.</p>
<p class="Pp">Which character set modifier is in effect?</p>
<p class="Pp">Which of these modifiers is in effect at any given point in a
    regular expression depends on a fairly complex set of interactions. These
    have been designed so that in general you don't have to worry about it, but
    this section gives the gory details. As explained below in &quot;Extended
    Patterns&quot; it is possible to explicitly specify modifiers that apply
    only to portions of a regular expression. The innermost always has priority
    over any outer ones, and one applying to the whole expression has priority
    over any of the default settings that are described in the remainder of this
    section.</p>
<p class="Pp">The <span class="Li">&quot;use re '/foo'&quot;</span> pragma can
    be used to set default modifiers (including these) for regular expressions
    compiled within its scope. This pragma has precedence over the other pragmas
    listed below that also change the defaults.</p>
<p class="Pp">Otherwise, <span class="Li">&quot;use locale&quot;</span> sets the
    default modifier to <span class="Li">&quot;/l&quot;</span>; and
    <span class="Li">&quot;use feature 'unicode_strings&quot;</span>, or
    <span class="Li">&quot;use 5.012&quot;</span> (or higher) set the default to
    <span class="Li">&quot;/u&quot;</span> when not in the same scope as either
    <span class="Li">&quot;use locale&quot;</span> or <span class="Li">&quot;use
    bytes&quot;</span>. (<span class="Li">&quot;use locale
    ':not_characters'&quot;</span> also sets the default to
    <span class="Li">&quot;/u&quot;</span>, overriding any plain
    <span class="Li">&quot;use locale&quot;</span>.) Unlike the mechanisms
    mentioned above, these affect operations besides regular expressions pattern
    matching, and so give more consistent results with other operators,
    including using <span class="Li">&quot;\U&quot;</span>,
    <span class="Li">&quot;\l&quot;</span>, <i>etc</i>. in substitution
    replacements.</p>
<p class="Pp">If none of the above apply, for backwards compatibility reasons,
    the <span class="Li">&quot;/d&quot;</span> modifier is the one in effect by
    default. As this can lead to unexpected results, it is best to specify which
    other rule set should be used.</p>
<p class="Pp">Character set modifier behavior prior to Perl 5.14</p>
<p class="Pp">Prior to 5.14, there were no explicit modifiers, but
    <span class="Li">&quot;/l&quot;</span> was implied for regexes compiled
    within the scope of <span class="Li">&quot;use locale&quot;</span>, and
    <span class="Li">&quot;/d&quot;</span> was implied otherwise. However,
    interpolating a regex into a larger regex would ignore the original
    compilation in favor of whatever was in effect at the time of the second
    compilation. There were a number of inconsistencies (bugs) with the
    <span class="Li">&quot;/d&quot;</span> modifier, where Unicode rules would
    be used when inappropriate, and vice versa.
    <span class="Li">&quot;\p{}&quot;</span> did not imply Unicode rules, and
    neither did all occurrences of <span class="Li">&quot;\N{}&quot;</span>,
    until 5.12.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Regular_Expressions"><a class="permalink" href="#Regular_Expressions">Regular
  Expressions</a></h2>
<p class="Pp"><i>Quantifiers</i></p>
<p class="Pp">Quantifiers are used when a particular portion of a pattern needs
    to match a certain number (or numbers) of times. If there isn't a quantifier
    the number of times to match is exactly one. The following standard
    quantifiers are recognized:</p>
<p class="Pp"></p>
<pre>    *           Match 0 or more times
    +           Match 1 or more times
    ?           Match 1 or 0 times
    {n}         Match exactly n times
    {n,}        Match at least n times
    {,n}        Match at most n times
    {n,m}       Match at least n but not more than m times
</pre>
<p class="Pp">(If a non-escaped curly bracket occurs in a context other than one
    of the quantifiers listed above, where it does not form part of a
    backslashed sequence like <span class="Li">&quot;\x{...}&quot;</span>, it is
    either a fatal syntax error, or treated as a regular character, generally
    with a deprecation warning raised. To escape it, you can precede it with a
    backslash (<span class="Li">&quot;\{&quot;</span>) or enclose it within
    square brackets (<span class="Li">&quot;[{]&quot;</span>). This change will
    allow for future syntax extensions (like making the lower bound of a
    quantifier optional), and better error checking of quantifiers).</p>
<p class="Pp">The <span class="Li">&quot;*&quot;</span> quantifier is equivalent
    to <span class="Li">&quot;{0,}&quot;</span>, the
    <span class="Li">&quot;+&quot;</span> quantifier to
    <span class="Li">&quot;{1,}&quot;</span>, and the
    <span class="Li">&quot;?&quot;</span> quantifier to
    <span class="Li">&quot;{0,1}&quot;</span>. <i>n</i> and <i>m</i> are limited
    to non-negative integral values less than a preset limit defined when perl
    is built. This is usually 65534 on the most common platforms. The actual
    limit can be seen in the error message generated by code such as this:</p>
<p class="Pp"></p>
<pre>    $_ **= $_ , / {$_} / for 2 .. 42;
</pre>
<p class="Pp">By default, a quantified subpattern is &quot;greedy&quot;, that
    is, it will match as many times as possible (given a particular starting
    location) while still allowing the rest of the pattern to match. If you want
    it to match the minimum number of times possible, follow the quantifier with
    a <span class="Li">&quot;?&quot;</span>. Note that the meanings don't
    change, just the &quot;greediness&quot;:</p>
<p class="Pp"></p>
<pre>    *?        Match 0 or more times, not greedily
    +?        Match 1 or more times, not greedily
    ??        Match 0 or 1 time, not greedily
    {n}?      Match exactly n times, not greedily (redundant)
    {n,}?     Match at least n times, not greedily
    {,n}?     Match at most n times, not greedily
    {n,m}?    Match at least n but not more than m times, not greedily
</pre>
<p class="Pp">Normally when a quantified subpattern does not allow the rest of
    the overall pattern to match, Perl will backtrack. However, this behaviour
    is sometimes undesirable. Thus Perl provides the &quot;possessive&quot;
    quantifier form as well.</p>
<p class="Pp"></p>
<pre> *+     Match 0 or more times and give nothing back
 ++     Match 1 or more times and give nothing back
 ?+     Match 0 or 1 time and give nothing back
 {n}+   Match exactly n times and give nothing back (redundant)
 {n,}+  Match at least n times and give nothing back
 {,n}+  Match at most n times and give nothing back
 {n,m}+ Match at least n but not more than m times and give nothing back
</pre>
<p class="Pp">For instance,</p>
<p class="Pp"></p>
<pre>   'aaaa' =~ /a++a/
</pre>
<p class="Pp">will never match, as the <span class="Li">&quot;a++&quot;</span>
    will gobble up all the <span class="Li">&quot;a&quot;</span>'s in the string
    and won't leave any for the remaining part of the pattern. This feature can
    be extremely useful to give perl hints about where it shouldn't backtrack.
    For instance, the typical &quot;match a double-quoted string&quot; problem
    can be most efficiently performed when written as:</p>
<p class="Pp"></p>
<pre>   /&quot;(?:[^&quot;\\]++|\\.)*+&quot;/
</pre>
<p class="Pp">as we know that if the final quote does not match, backtracking
    will not help. See the independent subexpression
    <span class="Li">&quot;(?&gt;</span><span class="Li"><i>pattern</i></span><span class="Li">)&quot;</span>
    for more details; possessive quantifiers are just syntactic sugar for that
    construct. For instance the above example could also be written as
  follows:</p>
<p class="Pp"></p>
<pre>   /&quot;(?&gt;(?:(?&gt;[^&quot;\\]+)|\\.)*)&quot;/
</pre>
<p class="Pp">Note that the possessive quantifier modifier can not be combined
    with the non-greedy modifier. This is because it would make no sense.
    Consider the follow equivalency table:</p>
<p class="Pp"></p>
<pre>    Illegal         Legal
    ------------    ------
    X??+            X{0}
    X+?+            X{1}
    X{min,max}?+    X{min}
</pre>
<p class="Pp"><i>Escape sequences</i></p>
<p class="Pp">Because patterns are processed as double-quoted strings, the
    following also work:</p>
<p class="Pp"></p>
<pre> \t          tab                   (HT, TAB)
 \n          newline               (LF, NL)
 \r          return                (CR)
 \f          form feed             (FF)
 \a          alarm (bell)          (BEL)
 \e          escape (think troff)  (ESC)
 \cK         control char          (example: VT)
 \x{}, \x00  character whose ordinal is the given hexadecimal number
 \N{name}    named Unicode character or character sequence
 \N{U+263D}  Unicode character     (example: FIRST QUARTER MOON)
 \o{}, \000  character whose ordinal is the given octal number
 \l          lowercase next char (think vi)
 \u          uppercase next char (think vi)
 \L          lowercase until \E (think vi)
 \U          uppercase until \E (think vi)
 \Q          quote (disable) pattern metacharacters until \E
 \E          end either case modification or quoted section, think vi
</pre>
<p class="Pp">Details are in &quot;Quote and Quote-like Operators&quot; in
    perlop.</p>
<p class="Pp"><i>Character Classes and other Special Escapes</i></p>
<p class="Pp">In addition, Perl defines the following:</p>
<p class="Pp"></p>
<pre> Sequence   Note    Description
  [...]     [1]  Match a character according to the rules of the
                   bracketed character class defined by the &quot;...&quot;.
                   Example: [a-z] matches &quot;a&quot; or &quot;b&quot; or &quot;c&quot; ... or &quot;z&quot;
  [[:...:]] [2]  Match a character according to the rules of the POSIX
                   character class &quot;...&quot; within the outer bracketed
                   character class.  Example: [[:upper:]] matches any
                   uppercase character.
  (?[...])  [8]  Extended bracketed character class
  \w        [3]  Match a &quot;word&quot; character (alphanumeric plus &quot;_&quot;, plus
                   other connector punctuation chars plus Unicode
                   marks)
  \W        [3]  Match a non-&quot;word&quot; character
  \s        [3]  Match a whitespace character
  \S        [3]  Match a non-whitespace character
  \d        [3]  Match a decimal digit character
  \D        [3]  Match a non-digit character
  \pP       [3]  Match P, named property.  Use \p{Prop} for longer names
  \PP       [3]  Match non-P
  \X        [4]  Match Unicode &quot;eXtended grapheme cluster&quot;
  \1        [5]  Backreference to a specific capture group or buffer.
                   '1' may actually be any positive integer.
  \g1       [5]  Backreference to a specific or previous group,
  \g{-1}    [5]  The number may be negative indicating a relative
                   previous group and may optionally be wrapped in
                   curly brackets for safer parsing.
  \g{name}  [5]  Named backreference
  \k&lt;name&gt;  [5]  Named backreference
  \k'name'  [5]  Named backreference
  \k{name}  [5]  Named backreference
  \K        [6]  Keep the stuff left of the \K, don't include it in $&amp;
  \N        [7]  Any character but \n.  Not affected by /s modifier
  \v        [3]  Vertical whitespace
  \V        [3]  Not vertical whitespace
  \h        [3]  Horizontal whitespace
  \H        [3]  Not horizontal whitespace
  \R        [4]  Linebreak
</pre>
<dl class="Bl-tag">
  <dt>[1]</dt>
  <dd>See &quot;Bracketed Character Classes&quot; in perlrecharclass for
      details.</dd>
  <dt>[2]</dt>
  <dd>See &quot;POSIX Character Classes&quot; in perlrecharclass for
    details.</dd>
  <dt>[3]</dt>
  <dd>See &quot;Unicode Character Properties&quot; in perlunicode for
    details</dd>
  <dt>[4]</dt>
  <dd>See &quot;Misc&quot; in perlrebackslash for details.</dd>
  <dt>[5]</dt>
  <dd>See &quot;Capture groups&quot; below for details.</dd>
  <dt>[6]</dt>
  <dd>See &quot;Extended Patterns&quot; below for details.</dd>
  <dt>[7]</dt>
  <dd>Note that <span class="Li">&quot;\N&quot;</span> has two meanings. When of
      the form
      <span class="Li">&quot;\N{</span><span class="Li"><i>NAME</i></span><span class="Li">}&quot;</span>,
      it matches the character or character sequence whose name is <i>NAME</i>;
      and similarly when of the form
      <span class="Li">&quot;\N{U+</span><span class="Li"><i>hex</i></span><span class="Li">}&quot;</span>,
      it matches the character whose Unicode code point is <i>hex</i>. Otherwise
      it matches any character but <span class="Li">&quot;\n&quot;</span>.</dd>
  <dt>[8]</dt>
  <dd>See &quot;Extended Bracketed Character Classes&quot; in perlrecharclass
      for details.</dd>
</dl>
<p class="Pp"><i>Assertions</i></p>
<p class="Pp">Besides <span class="Li">&quot;^&quot;</span> and
    <span class="Li">&quot;$&quot;</span>, Perl defines the following zero-width
    assertions:</p>
<p class="Pp"></p>
<pre> \b{}   Match at Unicode boundary of specified type
 \B{}   Match where corresponding \b{} doesn't match
 \b     Match a \w\W or \W\w boundary
 \B     Match except at a \w\W or \W\w boundary
 \A     Match only at beginning of string
 \Z     Match only at end of string, or before newline at the end
 \z     Match only at end of string
 \G     Match only at pos() (e.g. at the end-of-match position
        of prior m//g)
</pre>
<p class="Pp">A Unicode boundary (<span class="Li">&quot;\b{}&quot;</span>),
    available starting in v5.22, is a spot between two characters, or before the
    first character in the string, or after the final character in the string
    where certain criteria defined by Unicode are met. See &quot;\b{}, \b, \B{},
    \B&quot; in perlrebackslash for details.</p>
<p class="Pp">A word boundary (<span class="Li">&quot;\b&quot;</span>) is a spot
    between two characters that has a <span class="Li">&quot;\w&quot;</span> on
    one side of it and a <span class="Li">&quot;\W&quot;</span> on the other
    side of it (in either order), counting the imaginary characters off the
    beginning and end of the string as matching a
    <span class="Li">&quot;\W&quot;</span>. (Within character classes
    <span class="Li">&quot;\b&quot;</span> represents backspace rather than a
    word boundary, just as it normally does in any double-quoted string.) The
    <span class="Li">&quot;\A&quot;</span> and
    <span class="Li">&quot;\Z&quot;</span> are just like
    <span class="Li">&quot;^&quot;</span> and
    <span class="Li">&quot;$&quot;</span>, except that they won't match multiple
    times when the <span class="Li">&quot;/m&quot;</span> modifier is used,
    while <span class="Li">&quot;^&quot;</span> and
    <span class="Li">&quot;$&quot;</span> will match at every internal line
    boundary. To match the actual end of the string and not ignore an optional
    trailing newline, use <span class="Li">&quot;\z&quot;</span>.</p>
<p class="Pp">The <span class="Li">&quot;\G&quot;</span> assertion can be used
    to chain global matches (using <span class="Li">&quot;m//g&quot;</span>), as
    described in &quot;Regexp Quote-Like Operators&quot; in perlop. It is also
    useful when writing <span class="Li">&quot;lex&quot;</span>-like scanners,
    when you have several patterns that you want to match against consequent
    substrings of your string; see the previous reference. The actual location
    where <span class="Li">&quot;\G&quot;</span> will match can also be
    influenced by using <span class="Li">&quot;pos()&quot;</span> as an lvalue:
    see &quot;pos&quot; in perlfunc. Note that the rule for zero-length matches
    (see &quot;Repeated Patterns Matching a Zero-length Substring&quot;) is
    modified somewhat, in that contents to the left of
    <span class="Li">&quot;\G&quot;</span> are not counted when determining the
    length of the match. Thus the following will not match forever:</p>
<p class="Pp"></p>
<pre>     my $string = 'ABC';
     pos($string) = 1;
     while ($string =~ /(.\G)/g) {
         print $1;
     }
</pre>
<p class="Pp">It will print 'A' and then terminate, as it considers the match to
    be zero-width, and thus will not match at the same position twice in a
  row.</p>
<p class="Pp">It is worth noting that <span class="Li">&quot;\G&quot;</span>
    improperly used can result in an infinite loop. Take care when using
    patterns that include <span class="Li">&quot;\G&quot;</span> in an
    alternation.</p>
<p class="Pp">Note also that <span class="Li">&quot;s///&quot;</span> will
    refuse to overwrite part of a substitution that has already been replaced;
    so for example this will stop after the first iteration, rather than
    iterating its way backwards through the string:</p>
<p class="Pp"></p>
<pre>    $_ = &quot;123456789&quot;;
    pos = 6;
    s/.(?=.\G)/X/g;
    print;      # prints 1234X6789, not XXXXX6789
</pre>
<p class="Pp"><i>Capture groups</i></p>
<p class="Pp">The grouping construct <span class="Li">&quot;( ... )&quot;</span>
    creates capture groups (also referred to as capture buffers). To refer to
    the current contents of a group later on, within the same pattern, use
    <span class="Li">&quot;\g1&quot;</span> (or
    <span class="Li">&quot;\g{1}&quot;</span>) for the first,
    <span class="Li">&quot;\g2&quot;</span> (or
    <span class="Li">&quot;\g{2}&quot;</span>) for the second, and so on. This
    is called a <i>backreference</i>.</p>
<p class="Pp"></p>
<p class="Pp"></p>
<p class="Pp"></p>
<p class="Pp"></p>
<p class="Pp"></p>
<p class="Pp"></p>
<p class="Pp"></p>
<p class="Pp">There is no limit to the number of captured substrings that you
    may use. Groups are numbered with the leftmost open parenthesis being number
    1, <i>etc</i>. If a group did not match, the associated backreference won't
    match either. (This can happen if the group is optional, or in a different
    branch of an alternation.) You can omit the
    <span class="Li">&quot;g&quot;</span>, and write
    <span class="Li">&quot;\1&quot;</span>, <i>etc</i>, but there are some
    issues with this form, described below.</p>
<p class="Pp">You can also refer to capture groups relatively, by using a
    negative number, so that <span class="Li">&quot;\g-1&quot;</span> and
    <span class="Li">&quot;\g{-1}&quot;</span> both refer to the immediately
    preceding capture group, and <span class="Li">&quot;\g-2&quot;</span> and
    <span class="Li">&quot;\g{-2}&quot;</span> both refer to the group before
    it. For example:</p>
<p class="Pp"></p>
<pre>        /
         (Y)            # group 1
         (              # group 2
            (X)         # group 3
            \g{-1}      # backref to group 3
            \g{-3}      # backref to group 1
         )
        /x
</pre>
<p class="Pp">would match the same as <span class="Li">&quot;/(Y) ( (X) \g3 \g1
    )/x&quot;</span>. This allows you to interpolate regexes into larger regexes
    and not have to worry about the capture groups being renumbered.</p>
<p class="Pp">You can dispense with numbers altogether and create named capture
    groups. The notation is
    <span class="Li">&quot;(?&lt;</span><span class="Li"><i>name</i></span><span class="Li">&gt;...)&quot;</span>
    to declare and
    <span class="Li">&quot;\g{</span><span class="Li"><i>name</i></span><span class="Li">}&quot;</span>
    to reference. (To be compatible with .Net regular expressions,
    <span class="Li">&quot;\g{</span><span class="Li"><i>name</i></span><span class="Li">}&quot;</span>
    may also be written as
    <span class="Li">&quot;\k{</span><span class="Li"><i>name</i></span><span class="Li">}&quot;</span>,
    <span class="Li">&quot;\k&lt;</span><span class="Li"><i>name</i></span><span class="Li">&gt;&quot;</span>
    or
    <span class="Li">&quot;\k'</span><span class="Li"><i>name</i></span><span class="Li">'&quot;</span>.)
    <i>name</i> must not begin with a number, nor contain hyphens. When
    different groups within the same pattern have the same name, any reference
    to that name assumes the leftmost defined group. Named groups count in
    absolute and relative numbering, and so can also be referred to by those
    numbers. (It's possible to do things with named capture groups that would
    otherwise require <span class="Li">&quot;(??{})&quot;</span>.)</p>
<p class="Pp">Capture group contents are dynamically scoped and available to you
    outside the pattern until the end of the enclosing block or until the next
    successful match, whichever comes first. (See &quot;Compound
    Statements&quot; in perlsyn.) You can refer to them by absolute number
    (using <span class="Li">&quot;$1&quot;</span> instead of
    <span class="Li">&quot;\g1&quot;</span>, <i>etc</i>); or by name via the
    <span class="Li">&quot;%+&quot;</span> hash, using
    <span class="Li">&quot;$+{</span><span class="Li"><i>name</i></span><span class="Li">}&quot;</span>.</p>
<p class="Pp">Braces are required in referring to named capture groups, but are
    optional for absolute or relative numbered ones. Braces are safer when
    creating a regex by concatenating smaller strings. For example if you have
    <span class="Li">&quot;qr/$a$b/&quot;</span>, and <span class="Li">$a</span>
    contained <span class="Li">&quot;\g1&quot;</span>, and
    <span class="Li">$b</span> contained <span class="Li">&quot;37&quot;</span>,
    you would get <span class="Li">&quot;/\g137/&quot;</span> which is probably
    not what you intended.</p>
<p class="Pp">If you use braces, you may also optionally add any number of blank
    (space or tab) characters within but adjacent to the braces, like
    <span class="Li">&quot;\g{&#x00A0;-1&#x00A0;}&quot;</span>, or
    <span class="Li">&quot;\k{&#x00A0;</span><span class="Li"><i>name</i></span><span class="Li">&#x00A0;}&quot;</span>.</p>
<p class="Pp">The <span class="Li">&quot;\g&quot;</span> and
    <span class="Li">&quot;\k&quot;</span> notations were introduced in Perl
    5.10.0. Prior to that there were no named nor relative numbered capture
    groups. Absolute numbered groups were referred to using
    <span class="Li">&quot;\1&quot;</span>,
    <span class="Li">&quot;\2&quot;</span>, <i>etc</i>., and this notation is
    still accepted (and likely always will be). But it leads to some ambiguities
    if there are more than 9 capture groups, as
    <span class="Li">&quot;\10&quot;</span> could mean either the tenth capture
    group, or the character whose ordinal in octal is 010 (a backspace in
    ASCII). Perl resolves this ambiguity by interpreting
    <span class="Li">&quot;\10&quot;</span> as a backreference only if at least
    10 left parentheses have opened before it. Likewise
    <span class="Li">&quot;\11&quot;</span> is a backreference only if at least
    11 left parentheses have opened before it. And so on.
    <span class="Li">&quot;\1&quot;</span> through
    <span class="Li">&quot;\9&quot;</span> are always interpreted as
    backreferences. There are several examples below that illustrate these
    perils. You can avoid the ambiguity by always using
    <span class="Li">&quot;\g{}&quot;</span> or
    <span class="Li">&quot;\g&quot;</span> if you mean capturing groups; and for
    octal constants always using <span class="Li">&quot;\o{}&quot;</span>, or
    for <span class="Li">&quot;\077&quot;</span> and below, using 3 digits
    padded with leading zeros, since a leading zero implies an octal
  constant.</p>
<p class="Pp">The
    <span class="Li">&quot;\</span><span class="Li"><i>digit</i></span><span class="Li">&quot;</span>
    notation also works in certain circumstances outside the pattern. See
    &quot;Warning on \1 Instead of <span class="Li">$1</span>&quot; below for
    details.</p>
<p class="Pp">Examples:</p>
<p class="Pp"></p>
<pre>    s/^([^ ]*) *([^ ]*)/$2 $1/;     # swap first two words
    /(.)\g1/                        # find first doubled char
         and print &quot;'$1' is the first doubled character\n&quot;;
    /(?&lt;char&gt;.)\k&lt;char&gt;/            # ... a different way
         and print &quot;'$+{char}' is the first doubled character\n&quot;;
    /(?'char'.)\g1/                 # ... mix and match
         and print &quot;'$1' is the first doubled character\n&quot;;
    if (/Time: (..):(..):(..)/) {   # parse out values
        $hours = $1;
        $minutes = $2;
        $seconds = $3;
    }
    /(.)(.)(.)(.)(.)(.)(.)(.)(.)\g10/   # \g10 is a backreference
    /(.)(.)(.)(.)(.)(.)(.)(.)(.)\10/    # \10 is octal
    /((.)(.)(.)(.)(.)(.)(.)(.)(.))\10/  # \10 is a backreference
    /((.)(.)(.)(.)(.)(.)(.)(.)(.))\010/ # \010 is octal
    $a = '(.)\1';        # Creates problems when concatenated.
    $b = '(.)\g{1}';     # Avoids the problems.
    &quot;aa&quot; =~ /${a}/;      # True
    &quot;aa&quot; =~ /${b}/;      # True
    &quot;aa0&quot; =~ /${a}0/;    # False!
    &quot;aa0&quot; =~ /${b}0/;    # True
    &quot;aa\x08&quot; =~ /${a}0/;  # True!
    &quot;aa\x08&quot; =~ /${b}0/;  # False
</pre>
<p class="Pp">Several special variables also refer back to portions of the
    previous match. <span class="Li">$+</span> returns whatever the last bracket
    match matched. <span class="Li">$&amp;</span> returns the entire matched
    string. (At one point <span class="Li">$0</span> did also, but now it
    returns the name of the program.) <span class="Li">&quot;$`&quot;</span>
    returns everything before the matched string.
    <span class="Li">&quot;$'&quot;</span> returns everything after the matched
    string. And <span class="Li">$^N</span> contains whatever was matched by the
    most-recently closed group (submatch). <span class="Li">$^N</span> can be
    used in extended patterns (see below), for example to assign a submatch to a
    variable.</p>
<p class="Pp">These special variables, like the
    <span class="Li">&quot;%+&quot;</span> hash and the numbered match variables
    (<span class="Li">$1</span>, <span class="Li">$2</span>,
    <span class="Li">$3</span>, <i>etc</i>.) are dynamically scoped until the
    end of the enclosing block or until the next successful match, whichever
    comes first. (See &quot;Compound Statements&quot; in perlsyn.)</p>
<p class="Pp"><b>NOTE</b>: Failed matches in Perl do not reset the match
    variables, which makes it easier to write code that tests for a series of
    more specific cases and remembers the best match.</p>
<p class="Pp"><b>WARNING</b>: If your code is to run on Perl 5.16 or earlier,
    beware that once Perl sees that you need one of
    <span class="Li">$&amp;</span>, <span class="Li">&quot;$`&quot;</span>, or
    <span class="Li">&quot;$'&quot;</span> anywhere in the program, it has to
    provide them for every pattern match. This may substantially slow your
    program.</p>
<p class="Pp">Perl uses the same mechanism to produce
    <span class="Li">$1</span>, <span class="Li">$2</span>, <i>etc</i>, so you
    also pay a price for each pattern that contains capturing parentheses. (To
    avoid this cost while retaining the grouping behaviour, use the extended
    regular expression <span class="Li">&quot;(?: ... )&quot;</span> instead.)
    But if you never use <span class="Li">$&amp;</span>,
    <span class="Li">&quot;$`&quot;</span> or
    <span class="Li">&quot;$'&quot;</span>, then patterns <i>without</i>
    capturing parentheses will not be penalized. So avoid
    <span class="Li">$&amp;</span>, <span class="Li">&quot;$'&quot;</span>, and
    <span class="Li">&quot;$`&quot;</span> if you can, but if you can't (and
    some algorithms really appreciate them), once you've used them once, use
    them at will, because you've already paid the price.</p>
<p class="Pp">Perl 5.16 introduced a slightly more efficient mechanism that
    notes separately whether each of <span class="Li">&quot;$`&quot;</span>,
    <span class="Li">$&amp;</span>, and <span class="Li">&quot;$'&quot;</span>
    have been seen, and thus may only need to copy part of the string. Perl 5.20
    introduced a much more efficient copy-on-write mechanism which eliminates
    any slowdown.</p>
<p class="Pp">As another workaround for this problem, Perl 5.10.0 introduced
    <span class="Li">&quot;${^PREMATCH}&quot;</span>,
    <span class="Li">&quot;${^MATCH}&quot;</span> and
    <span class="Li">&quot;${^POSTMATCH}&quot;</span>, which are equivalent to
    <span class="Li">&quot;$`&quot;</span>, <span class="Li">$&amp;</span> and
    <span class="Li">&quot;$'&quot;</span>, <b>except</b> that they are only
    guaranteed to be defined after a successful match that was executed with the
    <span class="Li">&quot;/p&quot;</span> (preserve) modifier. The use of these
    variables incurs no global performance penalty, unlike their punctuation
    character equivalents, however at the trade-off that you have to tell perl
    when you want to use them. As of Perl 5.20, these three variables are
    equivalent to <span class="Li">&quot;$`&quot;</span>,
    <span class="Li">$&amp;</span> and <span class="Li">&quot;$'&quot;</span>,
    and <span class="Li">&quot;/p&quot;</span> is ignored.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Quoting_metacharacters"><a class="permalink" href="#Quoting_metacharacters">Quoting
  metacharacters</a></h2>
<p class="Pp">Backslashed metacharacters in Perl are alphanumeric, such as
    <span class="Li">&quot;\b&quot;</span>,
    <span class="Li">&quot;\w&quot;</span>,
    <span class="Li">&quot;\n&quot;</span>. Unlike some other regular expression
    languages, there are no backslashed symbols that aren't alphanumeric. So
    anything that looks like <span class="Li">&quot;\\&quot;</span>,
    <span class="Li">&quot;\(&quot;</span>,
    <span class="Li">&quot;\)&quot;</span>,
    <span class="Li">&quot;\[&quot;</span>,
    <span class="Li">&quot;\]&quot;</span>,
    <span class="Li">&quot;\{&quot;</span>, or
    <span class="Li">&quot;\}&quot;</span> is always interpreted as a literal
    character, not a metacharacter. This was once used in a common idiom to
    disable or quote the special meanings of regular expression metacharacters
    in a string that you want to use for a pattern. Simply quote all
    non-&quot;word&quot; characters:</p>
<p class="Pp"></p>
<pre>    $pattern =~ s/(\W)/\\$1/g;
</pre>
<p class="Pp">(If <span class="Li">&quot;use locale&quot;</span> is set, then
    this depends on the current locale.) Today it is more common to use the
    <span class="Li">&quot;quotemeta()&quot;</span> function or the
    <span class="Li">&quot;\Q&quot;</span> metaquoting escape sequence to
    disable all metacharacters' special meanings like this:</p>
<p class="Pp"></p>
<pre>    /$unquoted\Q$quoted\E$unquoted/
</pre>
<p class="Pp">Beware that if you put literal backslashes (those not inside
    interpolated variables) between <span class="Li">&quot;\Q&quot;</span> and
    <span class="Li">&quot;\E&quot;</span>, double-quotish backslash
    interpolation may lead to confusing results. If you <i>need</i> to use
    literal backslashes within <span class="Li">&quot;\Q...\E&quot;</span>,
    consult &quot;Gory details of parsing quoted constructs&quot; in perlop.</p>
<p class="Pp"><span class="Li">&quot;quotemeta()&quot;</span> and
    <span class="Li">&quot;\Q&quot;</span> are fully described in
    &quot;quotemeta&quot; in perlfunc.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Extended_Patterns"><a class="permalink" href="#Extended_Patterns">Extended
  Patterns</a></h2>
<p class="Pp">Perl also defines a consistent extension syntax for features not
    found in standard tools like <b>awk</b> and <b>lex</b>. The syntax for most
    of these is a pair of parentheses with a question mark as the first thing
    within the parentheses. The character after the question mark indicates the
    extension.</p>
<p class="Pp">A question mark was chosen for this and for the minimal-matching
    construct because 1) question marks are rare in older regular expressions,
    and 2) whenever you see one, you should stop and &quot;question&quot;
    exactly what is going on. That's psychology....</p>
<dl class="Bl-tag">
  <dt>&quot;(?#<i>text</i>)&quot;</dt>
  <dd>A comment. The <i>text</i> is ignored. Note that Perl closes the comment
      as soon as it sees a <span class="Li">&quot;)&quot;</span>, so there is no
      way to put a literal <span class="Li">&quot;)&quot;</span> in the comment.
      The pattern's closing delimiter must be escaped by a backslash if it
      appears in the comment.
    <p class="Pp">See &quot;/x&quot; for another way to have comments in
        patterns.</p>
    <p class="Pp">Note that a comment can go just about anywhere, except in the
        middle of an escape sequence. Examples:</p>
    <p class="Pp"></p>
    <pre> qr/foo(?#comment)bar/'  # Matches 'foobar'
 # The pattern below matches 'abcd', 'abccd', or 'abcccd'
 qr/abc(?#comment between literal and its quantifier){1,3}d/
 # The pattern below generates a syntax error, because the '\p' must
 # be followed immediately by a '{'.
 qr/\p(?#comment between \p and its property name){Any}/
 # The pattern below generates a syntax error, because the initial
 # '\(' is a literal opening parenthesis, and so there is nothing
 # for the  closing ')' to match
 qr/\(?#the backslash means this isn't a comment)p{Any}/
 # Comments can be used to fold long patterns into multiple lines
 qr/First part of a long regex(?#
   )remaining part/
    </pre>
  </dd>
  <dt>&quot;(?adlupimnsx-imnsx)&quot;</dt>
  <dd></dd>
  <dt>&quot;(?^alupimnsx)&quot;</dt>
  <dd>Zero or more embedded pattern-match modifiers, to be turned on (or turned
      off if preceded by <span class="Li">&quot;-&quot;</span>) for the
      remainder of the pattern or the remainder of the enclosing pattern group
      (if any).
    <p class="Pp">This is particularly useful for dynamically-generated
        patterns, such as those read in from a configuration file, taken from an
        argument, or specified in a table somewhere. Consider the case where
        some patterns want to be case-sensitive and some do not: The
        case-insensitive ones merely need to include
        <span class="Li">&quot;(?i)&quot;</span> at the front of the pattern.
        For example:</p>
    <p class="Pp"></p>
    <pre>    $pattern = &quot;foobar&quot;;
    if ( /$pattern/i ) { }
    # more flexible:
    $pattern = &quot;(?i)foobar&quot;;
    if ( /$pattern/ ) { }
    </pre>
    <p class="Pp">These modifiers are restored at the end of the enclosing
        group. For example,</p>
    <p class="Pp"></p>
    <pre>    ( (?i) blah ) \s+ \g1
    </pre>
    <p class="Pp">will match <span class="Li">&quot;blah&quot;</span> in any
        case, some spaces, and an exact (<i>including the case</i>!) repetition
        of the previous word, assuming the
        <span class="Li">&quot;/x&quot;</span> modifier, and no
        <span class="Li">&quot;/i&quot;</span> modifier outside this group.</p>
    <p class="Pp">These modifiers do not carry over into named subpatterns
        called in the enclosing group. In other words, a pattern such as
        <span class="Li">&quot;((?i)(?&amp;</span><span class="Li"><i>NAME</i></span><span class="Li">))&quot;</span>
        does not change the case-sensitivity of the <i>NAME</i> pattern.</p>
    <p class="Pp">A modifier is overridden by later occurrences of this
        construct in the same scope containing the same modifier, so that</p>
    <p class="Pp"></p>
    <pre>    /((?im)foo(?-m)bar)/
    </pre>
    <p class="Pp">matches all of <span class="Li">&quot;foobar&quot;</span> case
        insensitively, but uses <span class="Li">&quot;/m&quot;</span> rules for
        only the <span class="Li">&quot;foo&quot;</span> portion. The
        <span class="Li">&quot;a&quot;</span> flag overrides
        <span class="Li">&quot;aa&quot;</span> as well; likewise
        <span class="Li">&quot;aa&quot;</span> overrides
        <span class="Li">&quot;a&quot;</span>. The same goes for
        <span class="Li">&quot;x&quot;</span> and
        <span class="Li">&quot;xx&quot;</span>. Hence, in</p>
    <p class="Pp"></p>
    <pre>    /(?-x)foo/xx
    </pre>
    <p class="Pp">both <span class="Li">&quot;/x&quot;</span> and
        <span class="Li">&quot;/xx&quot;</span> are turned off during matching
        <span class="Li">&quot;foo&quot;</span>. And in</p>
    <p class="Pp"></p>
    <pre>    /(?x)foo/x
    </pre>
    <p class="Pp"><span class="Li">&quot;/x&quot;</span> but NOT
        <span class="Li">&quot;/xx&quot;</span> is turned on for matching
        <span class="Li">&quot;foo&quot;</span>. (One might mistakenly think
        that since the inner <span class="Li">&quot;(?x)&quot;</span> is already
        in the scope of <span class="Li">&quot;/x&quot;</span>, that the result
        would effectively be the sum of them, yielding
        <span class="Li">&quot;/xx&quot;</span>. It doesn't work that way.)
        Similarly, doing something like
        <span class="Li">&quot;(?xx-x)foo&quot;</span> turns off all
        <span class="Li">&quot;x&quot;</span> behavior for matching
        <span class="Li">&quot;foo&quot;</span>, it is not that you subtract 1
        <span class="Li">&quot;x&quot;</span> from 2 to get 1
        <span class="Li">&quot;x&quot;</span> remaining.</p>
    <p class="Pp">Any of these modifiers can be set to apply globally to all
        regular expressions compiled within the scope of a
        <span class="Li">&quot;use re&quot;</span>. See &quot;'/flags'
        mode&quot; in re.</p>
    <p class="Pp">Starting in Perl 5.14, a <span class="Li">&quot;^&quot;</span>
        (caret or circumflex accent) immediately after the
        <span class="Li">&quot;?&quot;</span> is a shorthand equivalent to
        <span class="Li">&quot;d-imnsx&quot;</span>. Flags (except
        <span class="Li">&quot;d&quot;</span>) may follow the caret to override
        it. But a minus sign is not legal with it.</p>
    <p class="Pp">Note that the <span class="Li">&quot;a&quot;</span>,
        <span class="Li">&quot;d&quot;</span>,
        <span class="Li">&quot;l&quot;</span>,
        <span class="Li">&quot;p&quot;</span>, and
        <span class="Li">&quot;u&quot;</span> modifiers are special in that they
        can only be enabled, not disabled, and the
        <span class="Li">&quot;a&quot;</span>,
        <span class="Li">&quot;d&quot;</span>,
        <span class="Li">&quot;l&quot;</span>, and
        <span class="Li">&quot;u&quot;</span> modifiers are mutually exclusive:
        specifying one de-specifies the others, and a maximum of one (or two
        <span class="Li">&quot;a&quot;</span>'s) may appear in the construct.
        Thus, for example, <span class="Li">&quot;(?-p)&quot;</span> will warn
        when compiled under <span class="Li">&quot;use warnings&quot;</span>;
        <span class="Li">&quot;(?-d:...)&quot;</span> and
        <span class="Li">&quot;(?dl:...)&quot;</span> are fatal errors.</p>
    <p class="Pp">Note also that the <span class="Li">&quot;p&quot;</span>
        modifier is special in that its presence anywhere in a pattern has a
        global effect.</p>
    <p class="Pp">Having zero modifiers makes this a no-op (so why did you
        specify it, unless it's generated code), and starting in v5.30, warns
        under <span class="Li">&quot;use</span> <span class="Li">re
        'strict'&quot;</span>.</p>
  </dd>
  <dt>&quot;(?:<i>pattern</i>)&quot;</dt>
  <dd></dd>
  <dt>&quot;(?adluimnsx-imnsx:<i>pattern</i>)&quot;</dt>
  <dd></dd>
  <dt>&quot;(?^aluimnsx:<i>pattern</i>)&quot;</dt>
  <dd>This is for clustering, not capturing; it groups subexpressions like
      <span class="Li">&quot;()&quot;</span>, but doesn't make backreferences as
      <span class="Li">&quot;()&quot;</span> does. So
    <p class="Pp"></p>
    <pre>    @fields = split(/\b(?:a|b|c)\b/)
    </pre>
    <p class="Pp">matches the same field delimiters as</p>
    <p class="Pp"></p>
    <pre>    @fields = split(/\b(a|b|c)\b/)
    </pre>
    <p class="Pp">but doesn't spit out the delimiters themselves as extra fields
        (even though that's the behaviour of &quot;split&quot; in perlfunc when
        its pattern contains capturing groups). It's also cheaper not to capture
        characters if you don't need to.</p>
    <p class="Pp">Any letters between <span class="Li">&quot;?&quot;</span> and
        <span class="Li">&quot;:&quot;</span> act as flags modifiers as with
        <span class="Li">&quot;(?adluimnsx-imnsx)&quot;</span>. For example,</p>
    <p class="Pp"></p>
    <pre>    /(?s-i:more.*than).*million/i
    </pre>
    <p class="Pp">is equivalent to the more verbose</p>
    <p class="Pp"></p>
    <pre>    /(?:(?s-i)more.*than).*million/i
    </pre>
    <p class="Pp">Note that any <span class="Li">&quot;()&quot;</span>
        constructs enclosed within this one will still capture unless the
        <span class="Li">&quot;/n&quot;</span> modifier is in effect.</p>
    <p class="Pp">Like the &quot;(?adlupimnsx-imnsx)&quot; construct,
        <span class="Li">&quot;aa&quot;</span> and
        <span class="Li">&quot;a&quot;</span> override each other, as do
        <span class="Li">&quot;xx&quot;</span> and
        <span class="Li">&quot;x&quot;</span>. They are not additive. So, doing
        something like <span class="Li">&quot;(?xx-x:foo)&quot;</span> turns off
        all <span class="Li">&quot;x&quot;</span> behavior for matching
        <span class="Li">&quot;foo&quot;</span>.</p>
    <p class="Pp">Starting in Perl 5.14, a <span class="Li">&quot;^&quot;</span>
        (caret or circumflex accent) immediately after the
        <span class="Li">&quot;?&quot;</span> is a shorthand equivalent to
        <span class="Li">&quot;d-imnsx&quot;</span>. Any positive flags (except
        <span class="Li">&quot;d&quot;</span>) may follow the caret, so</p>
    <p class="Pp"></p>
    <pre>    (?^x:foo)
    </pre>
    <p class="Pp">is equivalent to</p>
    <p class="Pp"></p>
    <pre>    (?x-imns:foo)
    </pre>
    <p class="Pp">The caret tells Perl that this cluster doesn't inherit the
        flags of any surrounding pattern, but uses the system defaults
        (<span class="Li">&quot;d-imnsx&quot;</span>), modified by any flags
        specified.</p>
    <p class="Pp">The caret allows for simpler stringification of compiled
        regular expressions. These look like</p>
    <p class="Pp"></p>
    <pre>    (?^:pattern)
    </pre>
    <p class="Pp">with any non-default flags appearing between the caret and the
        colon. A test that looks at such stringification thus doesn't need to
        have the system default flags hard-coded in it, just the caret. If new
        flags are added to Perl, the meaning of the caret's expansion will
        change to include the default for those flags, so the test will still
        work, unchanged.</p>
    <p class="Pp">Specifying a negative flag after the caret is an error, as the
        flag is redundant.</p>
    <p class="Pp">Mnemonic for <span class="Li">&quot;(?^...)&quot;</span>: A
        fresh beginning since the usual use of a caret is to match at the
        beginning.</p>
  </dd>
  <dt>&quot;(?|<i>pattern</i>)&quot;</dt>
  <dd>This is the &quot;branch reset&quot; pattern, which has the special
      property that the capture groups are numbered from the same starting point
      in each alternation branch. It is available starting from perl 5.10.0.
    <p class="Pp">Capture groups are numbered from left to right, but inside
        this construct the numbering is restarted for each branch.</p>
    <p class="Pp">The numbering within each branch will be as normal, and any
        groups following this construct will be numbered as though the construct
        contained only one branch, that being the one with the most capture
        groups in it.</p>
    <p class="Pp">This construct is useful when you want to capture one of a
        number of alternative matches.</p>
    <p class="Pp">Consider the following pattern. The numbers underneath show in
        which group the captured content will be stored.</p>
    <p class="Pp"></p>
    <pre>    # before  ---------------branch-reset----------- after
    / ( a )  (?| x ( y ) z | (p (q) r) | (t) u (v) ) ( z ) /x
    # 1            2         2  3        2     3     4
    </pre>
    <p class="Pp">Be careful when using the branch reset pattern in combination
        with named captures. Named captures are implemented as being aliases to
        numbered groups holding the captures, and that interferes with the
        implementation of the branch reset pattern. If you are using named
        captures in a branch reset pattern, it's best to use the same names, in
        the same order, in each of the alternations:</p>
    <p class="Pp"></p>
    <pre>   /(?|  (?&lt;a&gt; x ) (?&lt;b&gt; y )
      |  (?&lt;a&gt; z ) (?&lt;b&gt; w )) /x
    </pre>
    <p class="Pp">Not doing so may lead to surprises:</p>
    <p class="Pp"></p>
    <pre>  &quot;12&quot; =~ /(?| (?&lt;a&gt; \d+ ) | (?&lt;b&gt; \D+))/x;
  say $+{a};    # Prints '12'
  say $+{b};    # *Also* prints '12'.
    </pre>
    <p class="Pp">The problem here is that both the group named
        <span class="Li">&quot;a&quot;</span> and the group named
        <span class="Li">&quot;b&quot;</span> are aliases for the group
        belonging to <span class="Li">$1</span>.</p>
  </dd>
  <dt id="Lookaround"><a class="permalink" href="#Lookaround">Lookaround
    Assertions</a></dt>
  <dd>Lookaround assertions are zero-width patterns which match a specific
      pattern without including it in <span class="Li">$&amp;</span>. Positive
      assertions match when their subpattern matches, negative assertions match
      when their subpattern fails. Lookbehind matches text up to the current
      match position, lookahead matches text following the current match
      position.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>&quot;(?=<i>pattern</i>)&quot;</dt>
  <dd></dd>
  <dt>&quot;(*pla:<i>pattern</i>)&quot;</dt>
  <dd></dd>
  <dt>&quot;(*positive_lookahead:<i>pattern</i>)&quot;</dt>
  <dd>A zero-width positive lookahead assertion. For example,
      <span class="Li">&quot;/\w+(?=\t)/&quot;</span> matches a word followed by
      a tab, without including the tab in <span class="Li">$&amp;</span>.</dd>
  <dt>&quot;(?!<i>pattern</i>)&quot;</dt>
  <dd></dd>
  <dt>&quot;(*nla:<i>pattern</i>)&quot;</dt>
  <dd></dd>
  <dt>&quot;(*negative_lookahead:<i>pattern</i>)&quot;</dt>
  <dd>A zero-width negative lookahead assertion. For example
      <span class="Li">&quot;/foo(?!bar)/&quot;</span> matches any occurrence of
      &quot;foo&quot; that isn't followed by &quot;bar&quot;. Note however that
      lookahead and lookbehind are NOT the same thing. You cannot use this for
      lookbehind.
    <p class="Pp">If you are looking for a &quot;bar&quot; that isn't preceded
        by a &quot;foo&quot;, <span class="Li">&quot;/(?!foo)bar/&quot;</span>
        will not do what you want. That's because the
        <span class="Li">&quot;(?!foo)&quot;</span> is just saying that the next
        thing cannot be &quot;foo&quot;--and it's not, it's a &quot;bar&quot;,
        so &quot;foobar&quot; will match. Use lookbehind instead (see
      below).</p>
  </dd>
  <dt>&quot;(?&lt;=<i>pattern</i>)&quot;</dt>
  <dd></dd>
  <dt>&quot;\K&quot;</dt>
  <dd></dd>
  <dt>&quot;(*plb:<i>pattern</i>)&quot;</dt>
  <dd></dd>
  <dt>&quot;(*positive_lookbehind:<i>pattern</i>)&quot;</dt>
  <dd>A zero-width positive lookbehind assertion. For example,
      <span class="Li">&quot;/(?&lt;=\t)\w+/&quot;</span> matches a word that
      follows a tab, without including the tab in
      <span class="Li">$&amp;</span>.
    <p class="Pp">Prior to Perl 5.30, it worked only for fixed-width lookbehind,
        but starting in that release, it can handle variable lengths from 1 to
        255 characters as an experimental feature. The feature is enabled
        automatically if you use a variable length lookbehind assertion, but
        will raise a warning at pattern compilation time, unless turned off, in
        the <span class="Li">&quot;experimental::vlb&quot;</span> category. This
        is to warn you that the exact behavior is subject to change should
        feedback from actual use in the field indicate to do so; or even
        complete removal if the problems found are not practically surmountable.
        You can achieve close to pre-5.30 behavior by fatalizing warnings in
        this category.</p>
    <p class="Pp">There is a special form of this construct, called
        <span class="Li">&quot;\K&quot;</span> (available since Perl 5.10.0),
        which causes the regex engine to &quot;keep&quot; everything it had
        matched prior to the <span class="Li">&quot;\K&quot;</span> and not
        include it in <span class="Li">$&amp;</span>. This effectively provides
        non-experimental variable-length lookbehind of any length.</p>
    <p class="Pp">And, there is a technique that can be used to handle variable
        length lookbehinds on earlier releases, and longer than 255 characters.
        It is described in
        &lt;http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html&gt;.</p>
    <p class="Pp">Note that under <span class="Li">&quot;/i&quot;</span>, a few
        single characters match two or three other characters. This makes them
        variable length, and the 255 length applies to the maximum number of
        characters in the match. For example <span class="Li">&quot;qr/\N{LATIN
        SMALL LETTER SHARP S}/i&quot;</span> matches the sequence
        <span class="Li">&quot;ss&quot;</span>. Your lookbehind assertion could
        contain 127 Sharp S characters under
        <span class="Li">&quot;/i&quot;</span>, but adding a 128th would
        generate a compilation error, as that could match 256
        <span class="Li">&quot;s&quot;</span> characters in a row.</p>
    <p class="Pp">The use of <span class="Li">&quot;\K&quot;</span> inside of
        another lookaround assertion is allowed, but the behaviour is currently
        not well defined.</p>
    <p class="Pp">For various reasons <span class="Li">&quot;\K&quot;</span> may
        be significantly more efficient than the equivalent
        <span class="Li">&quot;(?&lt;=...)&quot;</span> construct, and it is
        especially useful in situations where you want to efficiently remove
        something following something else in a string. For instance</p>
    <p class="Pp"></p>
    <pre>  s/(foo)bar/$1/g;
    </pre>
    <p class="Pp">can be rewritten as the much more efficient</p>
    <p class="Pp"></p>
    <pre>  s/foo\Kbar//g;
    </pre>
    <p class="Pp">Use of the non-greedy modifier
        <span class="Li">&quot;?&quot;</span> may not give you the expected
        results if it is within a capturing group within the construct.</p>
  </dd>
  <dt>&quot;(?&lt;!<i>pattern</i>)&quot;</dt>
  <dd></dd>
  <dt>&quot;(*nlb:<i>pattern</i>)&quot;</dt>
  <dd></dd>
  <dt>&quot;(*negative_lookbehind:<i>pattern</i>)&quot;</dt>
  <dd>A zero-width negative lookbehind assertion. For example
      <span class="Li">&quot;/(?&lt;!bar)foo/&quot;</span> matches any
      occurrence of &quot;foo&quot; that does not follow &quot;bar&quot;.
    <p class="Pp">Prior to Perl 5.30, it worked only for fixed-width lookbehind,
        but starting in that release, it can handle variable lengths from 1 to
        255 characters as an experimental feature. The feature is enabled
        automatically if you use a variable length lookbehind assertion, but
        will raise a warning at pattern compilation time, unless turned off, in
        the <span class="Li">&quot;experimental::vlb&quot;</span> category. This
        is to warn you that the exact behavior is subject to change should
        feedback from actual use in the field indicate to do so; or even
        complete removal if the problems found are not practically surmountable.
        You can achieve close to pre-5.30 behavior by fatalizing warnings in
        this category.</p>
    <p class="Pp">There is a technique that can be used to handle variable
        length lookbehinds on earlier releases, and longer than 255 characters.
        It is described in
        &lt;http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html&gt;.</p>
    <p class="Pp">Note that under <span class="Li">&quot;/i&quot;</span>, a few
        single characters match two or three other characters. This makes them
        variable length, and the 255 length applies to the maximum number of
        characters in the match. For example <span class="Li">&quot;qr/\N{LATIN
        SMALL LETTER SHARP S}/i&quot;</span> matches the sequence
        <span class="Li">&quot;ss&quot;</span>. Your lookbehind assertion could
        contain 127 Sharp S characters under
        <span class="Li">&quot;/i&quot;</span>, but adding a 128th would
        generate a compilation error, as that could match 256
        <span class="Li">&quot;s&quot;</span> characters in a row.</p>
    <p class="Pp">Use of the non-greedy modifier
        <span class="Li">&quot;?&quot;</span> may not give you the expected
        results if it is within a capturing group within the construct.</p>
  </dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>&quot;(?&lt;<i>NAME</i>&gt;<i>pattern</i>)&quot;</dt>
  <dd></dd>
  <dt>&quot;(?'<i>NAME</i>'<i>pattern</i>)&quot;</dt>
  <dd>A named capture group. Identical in every respect to normal capturing
      parentheses <span class="Li">&quot;()&quot;</span> but for the additional
      fact that the group can be referred to by name in various regular
      expression constructs (like
      <span class="Li">&quot;\g{</span><span class="Li"><i>NAME</i></span><span class="Li">}&quot;</span>)
      and can be accessed by name after a successful match via
      <span class="Li">&quot;%+&quot;</span> or
      <span class="Li">&quot;%-&quot;</span>. See perlvar for more details on
      the <span class="Li">&quot;%+&quot;</span> and
      <span class="Li">&quot;%-&quot;</span> hashes.
    <p class="Pp">If multiple distinct capture groups have the same name, then
        <span class="Li">$+{</span><span class="Li"><i>NAME</i></span><span class="Li">}</span>
        will refer to the leftmost defined group in the match.</p>
    <p class="Pp">The forms
        <span class="Li">&quot;(?'</span><span class="Li"><i>NAME</i></span><span class="Li">'</span><span class="Li"><i>pattern</i></span><span class="Li">)&quot;</span>
        and
        <span class="Li">&quot;(?&lt;</span><span class="Li"><i>NAME</i></span><span class="Li">&gt;</span><span class="Li"><i>pattern</i></span><span class="Li">)&quot;</span>
        are equivalent.</p>
    <p class="Pp"><b>NOTE:</b> While the notation of this construct is the same
        as the similar function in .NET regexes, the behavior is not. In Perl
        the groups are numbered sequentially regardless of being named or not.
        Thus in the pattern</p>
    <p class="Pp"></p>
    <pre>  /(x)(?&lt;foo&gt;y)(z)/
    </pre>
    <p class="Pp"><span class="Li">$+{foo}</span> will be the same as
        <span class="Li">$2</span>, and <span class="Li">$3</span> will contain
        'z' instead of the opposite which is what a .NET regex hacker might
        expect.</p>
    <p class="Pp">Currently <i>NAME</i> is restricted to simple identifiers
        only. In other words, it must match
        <span class="Li">&quot;/^[_A-Za-z][_A-Za-z0-9]*\z/&quot;</span> or its
        Unicode extension (see utf8), though it isn't extended by the locale
        (see perllocale).</p>
    <p class="Pp"><b>NOTE:</b> In order to make things easier for programmers
        with experience with the Python or PCRE regex engines, the pattern
        <span class="Li">&quot;(?P&lt;</span><span class="Li"><i>NAME</i></span><span class="Li">&gt;</span><span class="Li"><i>pattern</i></span><span class="Li">)&quot;</span>
        may be used instead of
        <span class="Li">&quot;(?&lt;</span><span class="Li"><i>NAME</i></span><span class="Li">&gt;</span><span class="Li"><i>pattern</i></span><span class="Li">)&quot;</span>;
        however this form does not support the use of single quotes as a
        delimiter for the name.</p>
  </dd>
  <dt>&quot;\k&lt;<i>NAME</i>&gt;&quot;</dt>
  <dd></dd>
  <dt>&quot;\k'<i>NAME</i>'&quot;</dt>
  <dd></dd>
  <dt>&quot;\k{<i>NAME</i>}&quot;</dt>
  <dd>Named backreference. Similar to numeric backreferences, except that the
      group is designated by name and not number. If multiple groups have the
      same name then it refers to the leftmost defined group in the current
      match.
    <p class="Pp">It is an error to refer to a name not defined by a
        <span class="Li">&quot;(?&lt;</span><span class="Li"><i>NAME</i></span><span class="Li">&gt;)&quot;</span>
        earlier in the pattern.</p>
    <p class="Pp">All three forms are equivalent, although with
        <span class="Li">&quot;\k{
        </span><span class="Li"><i>NAME</i></span><span class="Li">
        }&quot;</span>, you may optionally have blanks within but adjacent to
        the braces, as shown.</p>
    <p class="Pp"><b>NOTE:</b> In order to make things easier for programmers
        with experience with the Python or PCRE regex engines, the pattern
        <span class="Li">&quot;(?P=</span><span class="Li"><i>NAME</i></span><span class="Li">)&quot;</span>
        may be used instead of
        <span class="Li">&quot;\k&lt;</span><span class="Li"><i>NAME</i></span><span class="Li">&gt;&quot;</span>.</p>
  </dd>
  <dt>&quot;(?{ <i>code</i> })&quot;</dt>
  <dd><b>WARNING</b>: Using this feature safely requires that you understand its
      limitations. Code executed that has side effects may not perform
      identically from version to version due to the effect of future
      optimisations in the regex engine. For more information on this, see
      &quot;Embedded Code Execution Frequency&quot;.
    <p class="Pp">This zero-width assertion executes any embedded Perl code. It
        always succeeds, and its return value is set as
        <span class="Li">$^R</span>.</p>
    <p class="Pp">In literal patterns, the code is parsed at the same time as
        the surrounding code. While within the pattern, control is passed
        temporarily back to the perl parser, until the logically-balancing
        closing brace is encountered. This is similar to the way that an array
        index expression in a literal string is handled, for example</p>
    <p class="Pp"></p>
    <pre>    &quot;abc$array[ 1 + f('[') + g()]def&quot;
    </pre>
    <p class="Pp">In particular, braces do not need to be balanced:</p>
    <p class="Pp"></p>
    <pre>    s/abc(?{ f('{'); })/def/
    </pre>
    <p class="Pp">Even in a pattern that is interpolated and compiled at
        run-time, literal code blocks will be compiled once, at perl compile
        time; the following prints &quot;ABCD&quot;:</p>
    <p class="Pp"></p>
    <pre>    print &quot;D&quot;;
    my $qr = qr/(?{ BEGIN { print &quot;A&quot; } })/;
    my $foo = &quot;foo&quot;;
    /$foo$qr(?{ BEGIN { print &quot;B&quot; } })/;
    BEGIN { print &quot;C&quot; }
    </pre>
    <p class="Pp">In patterns where the text of the code is derived from
        run-time information rather than appearing literally in a source code
        /pattern/, the code is compiled at the same time that the pattern is
        compiled, and for reasons of security, <span class="Li">&quot;use re
        'eval'&quot;</span> must be in scope. This is to stop user-supplied
        patterns containing code snippets from being executable.</p>
    <p class="Pp">In situations where you need to enable this with
        <span class="Li">&quot;use re 'eval'&quot;</span>, you should also have
        taint checking enabled. Better yet, use the carefully constrained
        evaluation within a Safe compartment. See perlsec for details about both
        these mechanisms.</p>
    <p class="Pp">From the viewpoint of parsing, lexical variable scope and
        closures,</p>
    <p class="Pp"></p>
    <pre>    /AAA(?{ BBB })CCC/
    </pre>
    <p class="Pp">behaves approximately like</p>
    <p class="Pp"></p>
    <pre>    /AAA/ &amp;&amp; do { BBB } &amp;&amp; /CCC/
    </pre>
    <p class="Pp">Similarly,</p>
    <p class="Pp"></p>
    <pre>    qr/AAA(?{ BBB })CCC/
    </pre>
    <p class="Pp">behaves approximately like</p>
    <p class="Pp"></p>
    <pre>    sub { /AAA/ &amp;&amp; do { BBB } &amp;&amp; /CCC/ }
    </pre>
    <p class="Pp">In particular:</p>
    <p class="Pp"></p>
    <pre>    { my $i = 1; $r = qr/(?{ print $i })/ }
    my $i = 2;
    /$r/; # prints &quot;1&quot;
    </pre>
    <p class="Pp">Inside a <span class="Li">&quot;(?{...})&quot;</span> block,
        <span class="Li">$_</span> refers to the string the regular expression
        is matching against. You can also use
        <span class="Li">&quot;pos()&quot;</span> to know what is the current
        position of matching within this string.</p>
    <p class="Pp">The code block introduces a new scope from the perspective of
        lexical variable declarations, but <b>not</b> from the perspective of
        <span class="Li">&quot;local&quot;</span> and similar localizing
        behaviours. So later code blocks within the same pattern will still see
        the values which were localized in earlier blocks. These accumulated
        localizations are undone either at the end of a successful match, or if
        the assertion is backtracked (compare &quot;Backtracking&quot;). For
        example,</p>
    <p class="Pp"></p>
    <pre>  $_ = 'a' x 8;
  m&lt;
     (?{ $cnt = 0 })               # Initialize $cnt.
     (
       a
       (?{
           local $cnt = $cnt + 1;  # Update $cnt,
                                   # backtracking-safe.
       })
     )*
     aaaa
     (?{ $res = $cnt })            # On success copy to
                                   # non-localized location.
   &gt;x;
    </pre>
    <p class="Pp">will initially increment <span class="Li">$cnt</span> up to 8;
        then during backtracking, its value will be unwound back to 4, which is
        the value assigned to <span class="Li">$res</span>. At the end of the
        regex execution, <span class="Li">$cnt</span> will be wound back to its
        initial value of 0.</p>
    <p class="Pp">This assertion may be used as the condition in a</p>
    <p class="Pp"></p>
    <pre>    (?(condition)yes-pattern|no-pattern)
    </pre>
    <p class="Pp">switch. If <i>not</i> used in this way, the result of
        evaluation of <i>code</i> is put into the special variable
        <span class="Li">$^R</span>. This happens immediately, so
        <span class="Li">$^R</span> can be used from other
        <span class="Li">&quot;(?{
        </span><span class="Li"><i>code</i></span><span class="Li">
        })&quot;</span> assertions inside the same regular expression.</p>
    <p class="Pp">The assignment to <span class="Li">$^R</span> above is
        properly localized, so the old value of <span class="Li">$^R</span> is
        restored if the assertion is backtracked; compare
        &quot;Backtracking&quot;.</p>
    <p class="Pp">Note that the special variable <span class="Li">$^N</span> is
        particularly useful with code blocks to capture the results of
        submatches in variables without having to keep track of the number of
        nested parentheses. For example:</p>
    <p class="Pp"></p>
    <pre>  $_ = &quot;The brown fox jumps over the lazy dog&quot;;
  /the (\S+)(?{ $color = $^N }) (\S+)(?{ $animal = $^N })/i;
  print &quot;color = $color, animal = $animal\n&quot;;
    </pre>
  </dd>
  <dt>&quot;(??{ <i>code</i> })&quot;</dt>
  <dd><b>WARNING</b>: Using this feature safely requires that you understand its
      limitations. Code executed that has side effects may not perform
      identically from version to version due to the effect of future
      optimisations in the regex engine. For more information on this, see
      &quot;Embedded Code Execution Frequency&quot;.
    <p class="Pp">This is a &quot;postponed&quot; regular subexpression. It
        behaves in <i>exactly</i> the same way as a <span class="Li">&quot;(?{
        </span><span class="Li"><i>code</i></span><span class="Li">
        })&quot;</span> code block as described above, except that its return
        value, rather than being assigned to <span class="Li">$^R</span>, is
        treated as a pattern, compiled if it's a string (or used as-is if its a
        qr// object), then matched as if it were inserted instead of this
        construct.</p>
    <p class="Pp">During the matching of this sub-pattern, it has its own set of
        captures which are valid during the sub-match, but are discarded once
        control returns to the main pattern. For example, the following matches,
        with the inner pattern capturing &quot;B&quot; and matching
        &quot;BB&quot;, while the outer pattern captures &quot;A&quot;;</p>
    <p class="Pp"></p>
    <pre>    my $inner = '(.)\1';
    &quot;ABBA&quot; =~ /^(.)(??{ $inner })\1/;
    print $1; # prints &quot;A&quot;;
    </pre>
    <p class="Pp">Note that this means that there is no way for the inner
        pattern to refer to a capture group defined outside. (The code block
        itself can use <span class="Li">$1</span>, <i>etc</i>., to refer to the
        enclosing pattern's capture groups.) Thus, although</p>
    <p class="Pp"></p>
    <pre>    ('a' x 100)=~/(??{'(.)' x 100})/
    </pre>
    <p class="Pp"><i>will</i> match, it will <i>not</i> set
        <span class="Li">$1</span> on exit.</p>
    <p class="Pp">The following pattern matches a parenthesized group:</p>
    <p class="Pp"></p>
    <pre> $re = qr{
            \(
            (?:
               (?&gt; [^()]+ )  # Non-parens without backtracking
             |
               (??{ $re })   # Group with matching parens
            )*
            \)
         }x;
    </pre>
    <p class="Pp">See also
        <span class="Li">&quot;(?</span><span class="Li"><i>PARNO</i></span><span class="Li">)&quot;</span>
        for a different, more efficient way to accomplish the same task.</p>
    <p class="Pp">Executing a postponed regular expression too many times
        without consuming any input string will also result in a fatal error.
        The depth at which that happens is compiled into perl, so it can be
        changed with a custom build.</p>
  </dd>
  <dt>&quot;(?<i>PARNO</i>)&quot; &quot;(?-<i>PARNO</i>)&quot;
    &quot;(?+<i>PARNO</i>)&quot; &quot;(?R)&quot; &quot;(?0)&quot;</dt>
  <dd>Recursive subpattern. Treat the contents of a given capture buffer in the
      current pattern as an independent subpattern and attempt to match it at
      the current position in the string. Information about capture state from
      the caller for things like backreferences is available to the subpattern,
      but capture buffers set by the subpattern are not visible to the caller.
    <p class="Pp">Similar to <span class="Li">&quot;(??{
        </span><span class="Li"><i>code</i></span><span class="Li">
        })&quot;</span> except that it does not involve executing any code or
        potentially compiling a returned pattern string; instead it treats the
        part of the current pattern contained within a specified capture group
        as an independent pattern that must match at the current position. Also
        different is the treatment of capture buffers, unlike
        <span class="Li">&quot;(??{
        </span><span class="Li"><i>code</i></span><span class="Li">
        })&quot;</span> recursive patterns have access to their caller's match
        state, so one can use backreferences safely.</p>
    <p class="Pp"><i>PARNO</i> is a sequence of digits (not starting with 0)
        whose value reflects the paren-number of the capture group to recurse
        to. <span class="Li">&quot;(?R)&quot;</span> recurses to the beginning
        of the whole pattern. <span class="Li">&quot;(?0)&quot;</span> is an
        alternate syntax for <span class="Li">&quot;(?R)&quot;</span>. If
        <i>PARNO</i> is preceded by a plus or minus sign then it is assumed to
        be relative, with negative numbers indicating preceding capture groups
        and positive ones following. Thus
        <span class="Li">&quot;(?-1)&quot;</span> refers to the most recently
        declared group, and <span class="Li">&quot;(?+1)&quot;</span> indicates
        the next group to be declared. Note that the counting for relative
        recursion differs from that of relative backreferences, in that with
        recursion unclosed groups <b>are</b> included.</p>
    <p class="Pp">The following pattern matches a function
        <span class="Li">&quot;foo()&quot;</span> which may contain balanced
        parentheses as the argument.</p>
    <p class="Pp"></p>
    <pre>  $re = qr{ (                   # paren group 1 (full function)
              foo
              (                 # paren group 2 (parens)
                \(
                  (             # paren group 3 (contents of parens)
                  (?:
                   (?&gt; [^()]+ ) # Non-parens without backtracking
                  |
                   (?2)         # Recurse to start of paren group 2
                  )*
                  )
                \)
              )
            )
          }x;
    </pre>
    <p class="Pp">If the pattern was used as follows</p>
    <p class="Pp"></p>
    <pre>    'foo(bar(baz)+baz(bop))'=~/$re/
        and print &quot;\$1 = $1\n&quot;,
                  &quot;\$2 = $2\n&quot;,
                  &quot;\$3 = $3\n&quot;;
    </pre>
    <p class="Pp">the output produced should be the following:</p>
    <p class="Pp"></p>
    <pre>    $1 = foo(bar(baz)+baz(bop))
    $2 = (bar(baz)+baz(bop))
    $3 = bar(baz)+baz(bop)
    </pre>
    <p class="Pp">If there is no corresponding capture group defined, then it is
        a fatal error. Recursing deeply without consuming any input string will
        also result in a fatal error. The depth at which that happens is
        compiled into perl, so it can be changed with a custom build.</p>
    <p class="Pp">The following shows how using negative indexing can make it
        easier to embed recursive patterns inside of a
        <span class="Li">&quot;qr//&quot;</span> construct for later use:</p>
    <p class="Pp"></p>
    <pre>    my $parens = qr/(\((?:[^()]++|(?-1))*+\))/;
    if (/foo $parens \s+ \+ \s+ bar $parens/x) {
       # do something here...
    }
    </pre>
    <p class="Pp"><b>Note</b> that this pattern does not behave the same way as
        the equivalent PCRE or Python construct of the same form. In Perl you
        can backtrack into a recursed group, in PCRE and Python the recursed
        into group is treated as atomic. Also, modifiers are resolved at compile
        time, so constructs like <span class="Li">&quot;(?i:(?1))&quot;</span>
        or <span class="Li">&quot;(?:(?i)(?1))&quot;</span> do not affect how
        the sub-pattern will be processed.</p>
  </dd>
  <dt>&quot;(?&amp;<i>NAME</i>)&quot;</dt>
  <dd>Recurse to a named subpattern. Identical to
      <span class="Li">&quot;(?</span><span class="Li"><i>PARNO</i></span><span class="Li">)&quot;</span>
      except that the parenthesis to recurse to is determined by name. If
      multiple parentheses have the same name, then it recurses to the leftmost.
    <p class="Pp">It is an error to refer to a name that is not declared
        somewhere in the pattern.</p>
    <p class="Pp"><b>NOTE:</b> In order to make things easier for programmers
        with experience with the Python or PCRE regex engines the pattern
        <span class="Li">&quot;(?P&gt;</span><span class="Li"><i>NAME</i></span><span class="Li">)&quot;</span>
        may be used instead of
        <span class="Li">&quot;(?&amp;</span><span class="Li"><i>NAME</i></span><span class="Li">)&quot;</span>.</p>
  </dd>
  <dt>&quot;(?(<i>condition</i>)<i>yes-pattern</i>|<i>no-pattern</i>)&quot;</dt>
  <dd></dd>
  <dt>&quot;(?(<i>condition</i>)<i>yes-pattern</i>)&quot;</dt>
  <dd>Conditional expression. Matches <i>yes-pattern</i> if <i>condition</i>
      yields a true value, matches <i>no-pattern</i> otherwise. A missing
      pattern always matches.
    <p class="Pp"><span class="Li">&quot;(</span><span class="Li"><i>condition</i></span><span class="Li">)&quot;</span>
        should be one of:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="an"><a class="permalink" href="#an">an integer in parentheses</a></dt>
  <dd>(which is valid if the corresponding pair of parentheses matched);</dd>
  <dt id="a"><a class="permalink" href="#a">a lookahead/lookbehind/evaluate
    zero-width assertion;</a></dt>
  <dd></dd>
  <dt id="a~2"><a class="permalink" href="#a~2">a name in angle brackets or
    single quotes</a></dt>
  <dd>(which is valid if a group with the given name matched);</dd>
  <dt id="the"><a class="permalink" href="#the">the special symbol
    &quot;(R)&quot;</a></dt>
  <dd>(true when evaluated inside of recursion or eval). Additionally the
      <span class="Li">&quot;R&quot;</span> may be followed by a number, (which
      will be true when evaluated when recursing inside of the appropriate
      group), or by
      <span class="Li">&quot;&amp;</span><span class="Li"><i>NAME</i></span><span class="Li">&quot;</span>,
      in which case it will be true only when evaluated during recursion in the
      named group.</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">Here's a summary of the possible predicates:</p>
<dl class="Bl-tag">
  <dt>&quot;(1)&quot; &quot;(2)&quot; ...</dt>
  <dd>Checks if the numbered capturing group has matched something. Full syntax:
      <span class="Li">&quot;(?(1)then|else)&quot;</span></dd>
  <dt>&quot;(&lt;<i>NAME</i>&gt;)&quot; &quot;('<i>NAME</i>')&quot;</dt>
  <dd>Checks if a group with the given name has matched something. Full syntax:
      <span class="Li">&quot;(?(&lt;name&gt;)then|else)&quot;</span></dd>
  <dt>&quot;(?=...)&quot; &quot;(?!...)&quot; &quot;(?&lt;=...)&quot;
    &quot;(?&lt;!...)&quot;</dt>
  <dd>Checks whether the pattern matches (or does not match, for the
      <span class="Li">&quot;!&quot;</span> variants). Full syntax:
      <span class="Li">&quot;(?(?=</span><span class="Li"><i>lookahead</i></span><span class="Li">)</span><span class="Li"><i>then</i></span><span class="Li">|</span><span class="Li"><i>else</i></span><span class="Li">)&quot;</span></dd>
  <dt>&quot;(?{ <i>CODE</i> })&quot;</dt>
  <dd>Treats the return value of the code block as the condition. Full syntax:
      <span class="Li">&quot;(?(?{
      </span><span class="Li"><i>code</i></span><span class="Li">
      })</span><span class="Li"><i>then</i></span><span class="Li">|</span><span class="Li"><i>else</i></span><span class="Li">)&quot;</span></dd>
  <dt>&quot;(R)&quot;</dt>
  <dd>Checks if the expression has been evaluated inside of recursion. Full
      syntax:
      <span class="Li">&quot;(?(R)</span><span class="Li"><i>then</i></span><span class="Li">|</span><span class="Li"><i>else</i></span><span class="Li">)&quot;</span></dd>
  <dt>&quot;(R1)&quot; &quot;(R2)&quot; ...</dt>
  <dd>Checks if the expression has been evaluated while executing directly
      inside of the n-th capture group. This check is the regex equivalent of
    <p class="Pp"></p>
    <pre>  if ((caller(0))[3] eq 'subname') { ... }
    </pre>
    <p class="Pp">In other words, it does not check the full recursion
      stack.</p>
    <p class="Pp">Full syntax:
        <span class="Li">&quot;(?(R1)</span><span class="Li"><i>then</i></span><span class="Li">|</span><span class="Li"><i>else</i></span><span class="Li">)&quot;</span></p>
  </dd>
  <dt>&quot;(R&amp;<i>NAME</i>)&quot;</dt>
  <dd>Similar to <span class="Li">&quot;(R1)&quot;</span>, this predicate checks
      to see if we're executing directly inside of the leftmost group with a
      given name (this is the same logic used by
      <span class="Li">&quot;(?&amp;</span><span class="Li"><i>NAME</i></span><span class="Li">)&quot;</span>
      to disambiguate). It does not check the full stack, but only the name of
      the innermost active recursion. Full syntax:
      <span class="Li">&quot;(?(R&amp;</span><span class="Li"><i>name</i></span><span class="Li">)</span><span class="Li"><i>then</i></span><span class="Li">|</span><span class="Li"><i>else</i></span><span class="Li">)&quot;</span></dd>
  <dt>&quot;(DEFINE)&quot;</dt>
  <dd>In this case, the yes-pattern is never directly executed, and no
      no-pattern is allowed. Similar in spirit to
      <span class="Li">&quot;(?{0})&quot;</span> but more efficient. See below
      for details. Full syntax:
      <span class="Li">&quot;(?(DEFINE)</span><span class="Li"><i>definitions</i></span><span class="Li">...)&quot;</span></dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">For example:</p>
<p class="Pp"></p>
<pre>    m{ ( \( )?
       [^()]+
       (?(1) \) )
     }x
</pre>
<p class="Pp">matches a chunk of non-parentheses, possibly included in
    parentheses themselves.</p>
<p class="Pp">A special form is the <span class="Li">&quot;(DEFINE)&quot;</span>
    predicate, which never executes its yes-pattern directly, and does not allow
    a no-pattern. This allows one to define subpatterns which will be executed
    only by the recursion mechanism. This way, you can define a set of regular
    expression rules that can be bundled into any pattern you choose.</p>
<p class="Pp">It is recommended that for this usage you put the DEFINE block at
    the end of the pattern, and that you name any subpatterns defined within
  it.</p>
<p class="Pp">Also, it's worth noting that patterns defined this way probably
    will not be as efficient, as the optimizer is not very clever about handling
    them.</p>
<p class="Pp">An example of how this might be used is as follows:</p>
<p class="Pp"></p>
<pre>  /(?&lt;NAME&gt;(?&amp;NAME_PAT))(?&lt;ADDR&gt;(?&amp;ADDRESS_PAT))
   (?(DEFINE)
     (?&lt;NAME_PAT&gt;....)
     (?&lt;ADDRESS_PAT&gt;....)
   )/x
</pre>
<p class="Pp">Note that capture groups matched inside of recursion are not
    accessible after the recursion returns, so the extra layer of capturing
    groups is necessary. Thus <span class="Li">$+{NAME_PAT}</span> would not be
    defined even though <span class="Li">$+{NAME}</span> would be.</p>
<p class="Pp">Finally, keep in mind that subpatterns created inside a DEFINE
    block count towards the absolute and relative number of captures, so
  this:</p>
<p class="Pp"></p>
<pre>    my @captures = &quot;a&quot; =~ /(.)                  # First capture
                           (?(DEFINE)
                               (?&lt;EXAMPLE&gt; 1 )  # Second capture
                           )/x;
    say scalar @captures;
</pre>
<p class="Pp">Will output 2, not 1. This is particularly important if you intend
    to compile the definitions with the <span class="Li">&quot;qr//&quot;</span>
    operator, and later interpolate them in another pattern.</p>
</div>
<dl class="Bl-tag">
  <dt>&quot;(?&gt;<i>pattern</i>)&quot;</dt>
  <dd></dd>
  <dt>&quot;(*atomic:<i>pattern</i>)&quot;</dt>
  <dd>An &quot;independent&quot; subexpression, one which matches the substring
      that a standalone <i>pattern</i> would match if anchored at the given
      position, and it matches <i>nothing other than this substring</i>. This
      construct is useful for optimizations of what would otherwise be
      &quot;eternal&quot; matches, because it will not backtrack (see
      &quot;Backtracking&quot;). It may also be useful in places where the
      &quot;grab all you can, and do not give anything back&quot; semantic is
      desirable.
    <p class="Pp">For example: <span class="Li">&quot;^(?&gt;a*)ab&quot;</span>
        will never match, since <span class="Li">&quot;(?&gt;a*)&quot;</span>
        (anchored at the beginning of string, as above) will match <i>all</i>
        characters <span class="Li">&quot;a&quot;</span> at the beginning of
        string, leaving no <span class="Li">&quot;a&quot;</span> for
        <span class="Li">&quot;ab&quot;</span> to match. In contrast,
        <span class="Li">&quot;a*ab&quot;</span> will match the same as
        <span class="Li">&quot;a+b&quot;</span>, since the match of the subgroup
        <span class="Li">&quot;a*&quot;</span> is influenced by the following
        group <span class="Li">&quot;ab&quot;</span> (see
        &quot;Backtracking&quot;). In particular,
        <span class="Li">&quot;a*&quot;</span> inside
        <span class="Li">&quot;a*ab&quot;</span> will match fewer characters
        than a standalone <span class="Li">&quot;a*&quot;</span>, since this
        makes the tail match.</p>
    <p class="Pp"><span class="Li">&quot;(?&gt;</span><span class="Li"><i>pattern</i></span><span class="Li">)&quot;</span>
        does not disable backtracking altogether once it has matched. It is
        still possible to backtrack past the construct, but not into it. So
        <span class="Li">&quot;((?&gt;a*)|(?&gt;b*))ar&quot;</span> will still
        match &quot;bar&quot;.</p>
    <p class="Pp">An effect similar to
        <span class="Li">&quot;(?&gt;</span><span class="Li"><i>pattern</i></span><span class="Li">)&quot;</span>
        may be achieved by writing
        <span class="Li">&quot;(?=(</span><span class="Li"><i>pattern</i></span><span class="Li">))\g{-1}&quot;</span>.
        This matches the same substring as a standalone
        <span class="Li">&quot;a+&quot;</span>, and the following
        <span class="Li">&quot;\g{-1}&quot;</span> eats the matched string; it
        therefore makes a zero-length assertion into an analogue of
        <span class="Li">&quot;(?&gt;...)&quot;</span>. (The difference between
        these two constructs is that the second one uses a capturing group, thus
        shifting ordinals of backreferences in the rest of a regular
        expression.)</p>
    <p class="Pp">Consider this pattern:</p>
    <p class="Pp"></p>
    <pre>    m{ \(
          (
            [^()]+           # x+
          |
            \( [^()]* \)
          )+
       \)
     }x
    </pre>
    <p class="Pp">That will efficiently match a nonempty group with matching
        parentheses two levels deep or less. However, if there is no such group,
        it will take virtually forever on a long string. That's because there
        are so many different ways to split a long string into several
        substrings. This is what <span class="Li">&quot;(.+)+&quot;</span> is
        doing, and <span class="Li">&quot;(.+)+&quot;</span> is similar to a
        subpattern of the above pattern. Consider how the pattern above detects
        no-match on <span class="Li">&quot;((()aaaaaaaaaaaaaaaaaa&quot;</span>
        in several seconds, but that each extra letter doubles this time. This
        exponential performance will make it appear that your program has hung.
        However, a tiny change to this pattern</p>
    <p class="Pp"></p>
    <pre>    m{ \(
          (
            (?&gt; [^()]+ )        # change x+ above to (?&gt; x+ )
          |
            \( [^()]* \)
          )+
       \)
     }x
    </pre>
    <p class="Pp">which uses <span class="Li">&quot;(?&gt;...)&quot;</span>
        matches exactly when the one above does (verifying this yourself would
        be a productive exercise), but finishes in a fourth the time when used
        on a similar string with 1000000 <span class="Li">&quot;a&quot;</span>s.
        Be aware, however, that, when this construct is followed by a
        quantifier, it currently triggers a warning message under the
        <span class="Li">&quot;use warnings&quot;</span> pragma or <b>-w</b>
        switch saying it <span class="Li">&quot;matches null string many times
        in regex&quot;</span>.</p>
    <p class="Pp">On simple groups, such as the pattern
        <span class="Li">&quot;(?&gt; [^()]+ )&quot;</span>, a comparable effect
        may be achieved by negative lookahead, as in
        <span class="Li">&quot;[^()]+ (?! [^()] )&quot;</span>. This was only 4
        times slower on a string with 1000000
        <span class="Li">&quot;a&quot;</span>s.</p>
    <p class="Pp">The &quot;grab all you can, and do not give anything
        back&quot; semantic is desirable in many situations where on the first
        sight a simple <span class="Li">&quot;()*&quot;</span> looks like the
        correct solution. Suppose we parse text with comments being delimited by
        <span class="Li">&quot;#&quot;</span> followed by some optional
        (horizontal) whitespace. Contrary to its appearance,
        <span class="Li">&quot;#[ \t]*&quot;</span> <i>is not</i> the correct
        subexpression to match the comment delimiter, because it may &quot;give
        up&quot; some whitespace if the remainder of the pattern can be made to
        match that way. The correct answer is either one of these:</p>
    <p class="Pp"></p>
    <pre>    (?&gt;#[ \t]*)
    #[ \t]*(?![ \t])
    </pre>
    <p class="Pp">For example, to grab non-empty comments into
        <span class="Li">$1</span>, one should use either one of these:</p>
    <p class="Pp"></p>
    <pre>    / (?&gt; \# [ \t]* ) (        .+ ) /x;
    /     \# [ \t]*   ( [^ \t] .* ) /x;
    </pre>
    <p class="Pp">Which one you pick depends on which of these expressions
        better reflects the above specification of comments.</p>
    <p class="Pp">In some literature this construct is called &quot;atomic
        matching&quot; or &quot;possessive matching&quot;.</p>
    <p class="Pp">Possessive quantifiers are equivalent to putting the item they
        are applied to inside of one of these constructs. The following
        equivalences apply:</p>
    <p class="Pp"></p>
    <pre>    Quantifier Form     Bracketing Form
    ---------------     ---------------
    PAT*+               (?&gt;PAT*)
    PAT++               (?&gt;PAT+)
    PAT?+               (?&gt;PAT?)
    PAT{min,max}+       (?&gt;PAT{min,max})
    </pre>
    <p class="Pp">Nested <span class="Li">&quot;(?&gt;...)&quot;</span>
        constructs are not no-ops, even if at first glance they might seem to
        be. This is because the nested
        <span class="Li">&quot;(?&gt;...)&quot;</span> can restrict internal
        backtracking that otherwise might occur. For example,</p>
    <p class="Pp"></p>
    <pre> &quot;abc&quot; =~ /(?&gt;a[bc]*c)/
    </pre>
    <p class="Pp">matches, but</p>
    <p class="Pp"></p>
    <pre> &quot;abc&quot; =~ /(?&gt;a(?&gt;[bc]*)c)/
    </pre>
    <p class="Pp">does not.</p>
  </dd>
  <dt>&quot;(?[ ])&quot;</dt>
  <dd>See &quot;Extended Bracketed Character Classes&quot; in perlrecharclass.
    <p class="Pp">Note that this feature is currently experimental; using it
        yields a warning in the
        <span class="Li">&quot;experimental::regex_sets&quot;</span>
      category.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Backtracking"><a class="permalink" href="#Backtracking">Backtracking</a></h2>
<p class="Pp">NOTE: This section presents an abstract approximation of regular
    expression behavior. For a more rigorous (and complicated) view of the rules
    involved in selecting a match among possible alternatives, see
    &quot;Combining RE Pieces&quot;.</p>
<p class="Pp">A fundamental feature of regular expression matching involves the
    notion called <i>backtracking</i>, which is currently used (when needed) by
    all regular non-possessive expression quantifiers, namely
    <span class="Li">&quot;*&quot;</span>,
    <span class="Li">&quot;*?&quot;</span>,
    <span class="Li">&quot;+&quot;</span>,
    <span class="Li">&quot;+?&quot;</span>,
    <span class="Li">&quot;{n,m}&quot;</span>, and
    <span class="Li">&quot;{n,m}?&quot;</span>. Backtracking is often optimized
    internally, but the general principle outlined here is valid.</p>
<p class="Pp">For a regular expression to match, the <i>entire</i> regular
    expression must match, not just part of it. So if the beginning of a pattern
    containing a quantifier succeeds in a way that causes later parts in the
    pattern to fail, the matching engine backs up and recalculates the beginning
    part--that's why it's called backtracking.</p>
<p class="Pp">Here is an example of backtracking: Let's say you want to find the
    word following &quot;foo&quot; in the string &quot;Food is on the foo
    table.&quot;:</p>
<p class="Pp"></p>
<pre>    $_ = &quot;Food is on the foo table.&quot;;
    if ( /\b(foo)\s+(\w+)/i ) {
        print &quot;$2 follows $1.\n&quot;;
    }
</pre>
<p class="Pp">When the match runs, the first part of the regular expression
    (<span class="Li">&quot;\b(foo)&quot;</span>) finds a possible match right
    at the beginning of the string, and loads up <span class="Li">$1</span> with
    &quot;Foo&quot;. However, as soon as the matching engine sees that there's
    no whitespace following the &quot;Foo&quot; that it had saved in
    <span class="Li">$1</span>, it realizes its mistake and starts over again
    one character after where it had the tentative match. This time it goes all
    the way until the next occurrence of &quot;foo&quot;. The complete regular
    expression matches this time, and you get the expected output of &quot;table
    follows foo.&quot;</p>
<p class="Pp">Sometimes minimal matching can help a lot. Imagine you'd like to
    match everything between &quot;foo&quot; and &quot;bar&quot;. Initially, you
    write something like this:</p>
<p class="Pp"></p>
<pre>    $_ =  &quot;The food is under the bar in the barn.&quot;;
    if ( /foo(.*)bar/ ) {
        print &quot;got &lt;$1&gt;\n&quot;;
    }
</pre>
<p class="Pp">Which perhaps unexpectedly yields:</p>
<p class="Pp"></p>
<pre>  got &lt;d is under the bar in the &gt;
</pre>
<p class="Pp">That's because <span class="Li">&quot;.*&quot;</span> was greedy,
    so you get everything between the <i>first</i> &quot;foo&quot; and the
    <i>last</i> &quot;bar&quot;. Here it's more effective to use minimal
    matching to make sure you get the text between a &quot;foo&quot; and the
    first &quot;bar&quot; thereafter.</p>
<p class="Pp"></p>
<pre>    if ( /foo(.*?)bar/ ) { print &quot;got &lt;$1&gt;\n&quot; }
  got &lt;d is under the &gt;
</pre>
<p class="Pp">Here's another example. Let's say you'd like to match a number at
    the end of a string, and you also want to keep the preceding part of the
    match. So you write this:</p>
<p class="Pp"></p>
<pre>    $_ = &quot;I have 2 numbers: 53147&quot;;
    if ( /(.*)(\d*)/ ) {                                # Wrong!
        print &quot;Beginning is &lt;$1&gt;, number is &lt;$2&gt;.\n&quot;;
    }
</pre>
<p class="Pp">That won't work at all, because
    <span class="Li">&quot;.*&quot;</span> was greedy and gobbled up the whole
    string. As <span class="Li">&quot;\d*&quot;</span> can match on an empty
    string the complete regular expression matched successfully.</p>
<p class="Pp"></p>
<pre>    Beginning is &lt;I have 2 numbers: 53147&gt;, number is &lt;&gt;.
</pre>
<p class="Pp">Here are some variants, most of which don't work:</p>
<p class="Pp"></p>
<pre>    $_ = &quot;I have 2 numbers: 53147&quot;;
    @pats = qw{
        (.*)(\d*)
        (.*)(\d+)
        (.*?)(\d*)
        (.*?)(\d+)
        (.*)(\d+)$
        (.*?)(\d+)$
        (.*)\b(\d+)$
        (.*\D)(\d+)$
    };
    for $pat (@pats) {
        printf &quot;%-12s &quot;, $pat;
        if ( /$pat/ ) {
            print &quot;&lt;$1&gt; &lt;$2&gt;\n&quot;;
        } else {
            print &quot;FAIL\n&quot;;
        }
    }
</pre>
<p class="Pp">That will print out:</p>
<p class="Pp"></p>
<pre>    (.*)(\d*)    &lt;I have 2 numbers: 53147&gt; &lt;&gt;
    (.*)(\d+)    &lt;I have 2 numbers: 5314&gt; &lt;7&gt;
    (.*?)(\d*)   &lt;&gt; &lt;&gt;
    (.*?)(\d+)   &lt;I have &gt; &lt;2&gt;
    (.*)(\d+)$   &lt;I have 2 numbers: 5314&gt; &lt;7&gt;
    (.*?)(\d+)$  &lt;I have 2 numbers: &gt; &lt;53147&gt;
    (.*)\b(\d+)$ &lt;I have 2 numbers: &gt; &lt;53147&gt;
    (.*\D)(\d+)$ &lt;I have 2 numbers: &gt; &lt;53147&gt;
</pre>
<p class="Pp">As you see, this can be a bit tricky. It's important to realize
    that a regular expression is merely a set of assertions that gives a
    definition of success. There may be 0, 1, or several different ways that the
    definition might succeed against a particular string. And if there are
    multiple ways it might succeed, you need to understand backtracking to know
    which variety of success you will achieve.</p>
<p class="Pp">When using lookahead assertions and negations, this can all get
    even trickier. Imagine you'd like to find a sequence of non-digits not
    followed by &quot;123&quot;. You might try to write that as</p>
<p class="Pp"></p>
<pre>    $_ = &quot;ABC123&quot;;
    if ( /^\D*(?!123)/ ) {                # Wrong!
        print &quot;Yup, no 123 in $_\n&quot;;
    }
</pre>
<p class="Pp">But that isn't going to match; at least, not the way you're
    hoping. It claims that there is no 123 in the string. Here's a clearer
    picture of why that pattern matches, contrary to popular expectations:</p>
<p class="Pp"></p>
<pre>    $x = 'ABC123';
    $y = 'ABC445';
    print &quot;1: got $1\n&quot; if $x =~ /^(ABC)(?!123)/;
    print &quot;2: got $1\n&quot; if $y =~ /^(ABC)(?!123)/;
    print &quot;3: got $1\n&quot; if $x =~ /^(\D*)(?!123)/;
    print &quot;4: got $1\n&quot; if $y =~ /^(\D*)(?!123)/;
</pre>
<p class="Pp">This prints</p>
<p class="Pp"></p>
<pre>    2: got ABC
    3: got AB
    4: got ABC
</pre>
<p class="Pp">You might have expected test 3 to fail because it seems to a more
    general purpose version of test 1. The important difference between them is
    that test 3 contains a quantifier (<span class="Li">&quot;\D*&quot;</span>)
    and so can use backtracking, whereas test 1 will not. What's happening is
    that you've asked &quot;Is it true that at the start of
    <span class="Li">$x</span>, following 0 or more non-digits, you have
    something that's not 123?&quot; If the pattern matcher had let
    <span class="Li">&quot;\D*&quot;</span> expand to &quot;ABC&quot;, this
    would have caused the whole pattern to fail.</p>
<p class="Pp">The search engine will initially match
    <span class="Li">&quot;\D*&quot;</span> with &quot;ABC&quot;. Then it will
    try to match <span class="Li">&quot;(?!123)&quot;</span> with
    &quot;123&quot;, which fails. But because a quantifier
    (<span class="Li">&quot;\D*&quot;</span>) has been used in the regular
    expression, the search engine can backtrack and retry the match differently
    in the hope of matching the complete regular expression.</p>
<p class="Pp">The pattern really, <i>really</i> wants to succeed, so it uses the
    standard pattern back-off-and-retry and lets
    <span class="Li">&quot;\D*&quot;</span> expand to just &quot;AB&quot; this
    time. Now there's indeed something following &quot;AB&quot; that is not
    &quot;123&quot;. It's &quot;C123&quot;, which suffices.</p>
<p class="Pp">We can deal with this by using both an assertion and a negation.
    We'll say that the first part in <span class="Li">$1</span> must be followed
    both by a digit and by something that's not &quot;123&quot;. Remember that
    the lookaheads are zero-width expressions--they only look, but don't consume
    any of the string in their match. So rewriting this way produces what you'd
    expect; that is, case 5 will fail, but case 6 succeeds:</p>
<p class="Pp"></p>
<pre>    print &quot;5: got $1\n&quot; if $x =~ /^(\D*)(?=\d)(?!123)/;
    print &quot;6: got $1\n&quot; if $y =~ /^(\D*)(?=\d)(?!123)/;
    6: got ABC
</pre>
<p class="Pp">In other words, the two zero-width assertions next to each other
    work as though they're ANDed together, just as you'd use any built-in
    assertions: <span class="Li">&quot;/^$/&quot;</span> matches only if you're
    at the beginning of the line AND the end of the line simultaneously. The
    deeper underlying truth is that juxtaposition in regular expressions always
    means AND, except when you write an explicit OR using the vertical bar.
    <span class="Li">&quot;/ab/&quot;</span> means match &quot;a&quot; AND
    (then) match &quot;b&quot;, although the attempted matches are made at
    different positions because &quot;a&quot; is not a zero-width assertion, but
    a one-width assertion.</p>
<p class="Pp"><b>WARNING</b>: Particularly complicated regular expressions can
    take exponential time to solve because of the immense number of possible
    ways they can use backtracking to try for a match. For example, without
    internal optimizations done by the regular expression engine, this will take
    a painfully long time to run:</p>
<p class="Pp"></p>
<pre>    'aaaaaaaaaaaa' =~ /((a{0,5}){0,5})*[c]/
</pre>
<p class="Pp">And if you used <span class="Li">&quot;*&quot;</span>'s in the
    internal groups instead of limiting them to 0 through 5 matches, then it
    would take forever--or until you ran out of stack space. Moreover, these
    internal optimizations are not always applicable. For example, if you put
    <span class="Li">&quot;{0,5}&quot;</span> instead of
    <span class="Li">&quot;*&quot;</span> on the external group, no current
    optimization is applicable, and the match takes a long time to finish.</p>
<p class="Pp">A powerful tool for optimizing such beasts is what is known as an
    &quot;independent group&quot;, which does not backtrack (see
    <span class="Li">&quot;(?&gt;pattern)&quot;</span>). Note also that
    zero-length lookahead/lookbehind assertions will not backtrack to make the
    tail match, since they are in &quot;logical&quot; context: only whether they
    match is considered relevant. For an example where side-effects of lookahead
    <i>might</i> have influenced the following match, see
    <span class="Li">&quot;(?&gt;pattern)&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Script_Runs"><a class="permalink" href="#Script_Runs">Script
  Runs</a></h2>
<p class="Pp">A script run is basically a sequence of characters, all from the
    same Unicode script (see &quot;Scripts&quot; in perlunicode), such as Latin
    or Greek. In most places a single word would never be written in multiple
    scripts, unless it is a spoofing attack. An infamous example, is</p>
<p class="Pp"></p>
<pre> paypal.com
</pre>
<p class="Pp">Those letters could all be Latin (as in the example just above),
    or they could be all Cyrillic (except for the dot), or they could be a
    mixture of the two. In the case of an internet address the
    <span class="Li">&quot;.com&quot;</span> would be in Latin, And any Cyrillic
    ones would cause it to be a mixture, not a script run. Someone clicking on
    such a link would not be directed to the real Paypal website, but an
    attacker would craft a look-alike one to attempt to gather sensitive
    information from the person.</p>
<p class="Pp">Starting in Perl 5.28, it is now easy to detect strings that
    aren't script runs. Simply enclose just about any pattern like either of
    these:</p>
<p class="Pp"></p>
<pre> (*script_run:pattern)
 (*sr:pattern)
</pre>
<p class="Pp">What happens is that after <i>pattern</i> succeeds in matching, it
    is subjected to the additional criterion that every character in it must be
    from the same script (see exceptions below). If this isn't true,
    backtracking occurs until something all in the same script is found that
    matches, or all possibilities are exhausted. This can cause a lot of
    backtracking, but generally, only malicious input will result in this,
    though the slow down could cause a denial of service attack. If your needs
    permit, it is best to make the pattern atomic to cut down on the amount of
    backtracking. This is so likely to be what you want, that instead of writing
    this:</p>
<p class="Pp"></p>
<pre> (*script_run:(?&gt;pattern))
</pre>
<p class="Pp">you can write either of these:</p>
<p class="Pp"></p>
<pre> (*atomic_script_run:pattern)
 (*asr:pattern)
</pre>
<p class="Pp">(See
    <span class="Li">&quot;(?&gt;</span><span class="Li"><i>pattern</i></span><span class="Li">)&quot;</span>.)</p>
<p class="Pp">In Taiwan, Japan, and Korea, it is common for text to have a
    mixture of characters from their native scripts and base Chinese. Perl
    follows Unicode's UTS 39 (&lt;https://unicode.org/reports/tr39/&gt;) Unicode
    Security Mechanisms in allowing such mixtures. For example, the Japanese
    scripts Katakana and Hiragana are commonly mixed together in practice, along
    with some Chinese characters, and hence are treated as being in a single
    script run by Perl.</p>
<p class="Pp">The rules used for matching decimal digits are slightly stricter.
    Many scripts have their own sets of digits equivalent to the Western
    <span class="Li">0</span> through <span class="Li">9</span> ones. A few,
    such as Arabic, have more than one set. For a string to be considered a
    script run, all digits in it must come from the same set of ten, as
    determined by the first digit encountered. As an example,</p>
<p class="Pp"></p>
<pre> qr/(*script_run: \d+ \b )/x
</pre>
<p class="Pp">guarantees that the digits matched will all be from the same set
    of 10. You won't get a look-alike digit from a different script that has a
    different value than what it appears to be.</p>
<p class="Pp">Unicode has three pseudo scripts that are handled specially.</p>
<p class="Pp">&quot;Unknown&quot; is applied to code points whose meaning has
    yet to be determined. Perl currently will match as a script run, any single
    character string consisting of one of these code points. But any string
    longer than one code point containing one of these will not be considered a
    script run.</p>
<p class="Pp">&quot;Inherited&quot; is applied to characters that modify
    another, such as an accent of some type. These are considered to be in the
    script of the master character, and so never cause a script run to not
    match.</p>
<p class="Pp">The other one is &quot;Common&quot;. This consists of mostly
    punctuation, emoji, and characters used in mathematics and music, the ASCII
    digits <span class="Li">0</span> through <span class="Li">9</span>, and
    full-width forms of these digits. These characters can appear intermixed in
    text in many of the world's scripts. These also don't cause a script run to
    not match. But like other scripts, all digits in a run must come from the
    same set of 10.</p>
<p class="Pp">This construct is non-capturing. You can add parentheses to
    <i>pattern</i> to capture, if desired. You will have to do this if you plan
    to use &quot;(*ACCEPT) (*ACCEPT:arg)&quot; and not have it bypass the script
    run checking.</p>
<p class="Pp">The <span class="Li">&quot;Script_Extensions&quot;</span> property
    as modified by UTS 39 (&lt;https://unicode.org/reports/tr39/&gt;) is used as
    the basis for this feature.</p>
<p class="Pp">To summarize,</p>
<ul class="Bl-bullet">
  <li>All length 0 or length 1 sequences are script runs.</li>
  <li>A longer sequence is a script run if and only if <b>all</b> of the
      following conditions are met:
    <p class="Pp"></p>
    <p class="Pp"></p>
  </li>
</ul>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>No code point in the sequence has the
      <span class="Li">&quot;Script_Extension&quot;</span> property of
      <span class="Li">&quot;Unknown&quot;</span>.
    <p class="Pp">This currently means that all code points in the sequence have
        been assigned by Unicode to be characters that aren't private use nor
        surrogate code points.</p>
  </dd>
  <dt>2.</dt>
  <dd>All characters in the sequence come from the Common script and/or the
      Inherited script and/or a single other script.
    <p class="Pp">The script of a character is determined by the
        <span class="Li">&quot;Script_Extensions&quot;</span> property as
        modified by UTS 39 (&lt;https://unicode.org/reports/tr39/&gt;), as
        described above.</p>
  </dd>
  <dt>3.</dt>
  <dd>All decimal digits in the sequence come from the same block of 10
      consecutive digits.</dd>
</dl>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Ss">
<h2 class="Ss" id="Special_Backtracking_Control_Verbs"><a class="permalink" href="#Special_Backtracking_Control_Verbs">Special
  Backtracking Control Verbs</a></h2>
<p class="Pp">These special patterns are generally of the form
    <span class="Li">&quot;(*</span><span class="Li"><i>VERB</i></span><span class="Li">:</span><span class="Li"><i>arg</i></span><span class="Li">)&quot;</span>.
    Unless otherwise stated the <i>arg</i> argument is optional; in some cases,
    it is mandatory.</p>
<p class="Pp">Any pattern containing a special backtracking verb that allows an
    argument has the special behaviour that when executed it sets the current
    package's <span class="Li">$REGERROR</span> and
    <span class="Li">$REGMARK</span> variables. When doing so the following
    rules apply:</p>
<p class="Pp">On failure, the <span class="Li">$REGERROR</span> variable will be
    set to the <i>arg</i> value of the verb pattern, if the verb was involved in
    the failure of the match. If the <i>arg</i> part of the pattern was omitted,
    then <span class="Li">$REGERROR</span> will be set to the name of the last
    <span class="Li">&quot;(*MARK:</span><span class="Li"><i>NAME</i></span><span class="Li">)&quot;</span>
    pattern executed, or to TRUE if there was none. Also, the
    <span class="Li">$REGMARK</span> variable will be set to FALSE.</p>
<p class="Pp">On a successful match, the <span class="Li">$REGERROR</span>
    variable will be set to FALSE, and the <span class="Li">$REGMARK</span>
    variable will be set to the name of the last
    <span class="Li">&quot;(*MARK:</span><span class="Li"><i>NAME</i></span><span class="Li">)&quot;</span>
    pattern executed. See the explanation for the
    <span class="Li">&quot;(*MARK:</span><span class="Li"><i>NAME</i></span><span class="Li">)&quot;</span>
    verb below for more details.</p>
<p class="Pp"><b>NOTE:</b> <span class="Li">$REGERROR</span> and
    <span class="Li">$REGMARK</span> are not magic variables like
    <span class="Li">$1</span> and most other regex-related variables. They are
    not local to a scope, nor readonly, but instead are volatile package
    variables similar to <span class="Li">$AUTOLOAD</span>. They are set in the
    package containing the code that <i>executed</i> the regex (rather than the
    one that compiled it, where those differ). If necessary, you can use
    <span class="Li">&quot;local&quot;</span> to localize changes to these
    variables to a specific scope before executing a regex.</p>
<p class="Pp">If a pattern does not contain a special backtracking verb that
    allows an argument, then <span class="Li">$REGERROR</span> and
    <span class="Li">$REGMARK</span> are not touched at all.</p>
<dl class="Bl-tag">
  <dt id="Verbs"><a class="permalink" href="#Verbs">Verbs</a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>&quot;(*PRUNE)&quot; &quot;(*PRUNE:<i>NAME</i>)&quot;</dt>
  <dd>This zero-width pattern prunes the backtracking tree at the current point
      when backtracked into on failure. Consider the pattern
      <span class="Li">&quot;/</span><span class="Li"><i>A</i></span><span class="Li">
      (*PRUNE)
      </span><span class="Li"><i>B</i></span><span class="Li">/&quot;</span>,
      where <i>A</i> and <i>B</i> are complex patterns. Until the
      <span class="Li">&quot;(*PRUNE)&quot;</span> verb is reached, <i>A</i> may
      backtrack as necessary to match. Once it is reached, matching continues in
      <i>B</i>, which may also backtrack as necessary; however, should B not
      match, then no further backtracking will take place, and the pattern will
      fail outright at the current starting position.
    <p class="Pp">The following example counts all the possible matching strings
        in a pattern (without actually matching any of them).</p>
    <p class="Pp"></p>
    <pre>    'aaab' =~ /a+b?(?{print &quot;$&amp;\n&quot;; $count++})(*FAIL)/;
    print &quot;Count=$count\n&quot;;
    </pre>
    <p class="Pp">which produces:</p>
    <p class="Pp"></p>
    <pre>    aaab
    aaa
    aa
    a
    aab
    aa
    a
    ab
    a
    Count=9
    </pre>
    <p class="Pp">If we add a <span class="Li">&quot;(*PRUNE)&quot;</span>
        before the count like the following</p>
    <p class="Pp"></p>
    <pre>    'aaab' =~ /a+b?(*PRUNE)(?{print &quot;$&amp;\n&quot;; $count++})(*FAIL)/;
    print &quot;Count=$count\n&quot;;
    </pre>
    <p class="Pp">we prevent backtracking and find the count of the longest
        matching string at each matching starting point like so:</p>
    <p class="Pp"></p>
    <pre>    aaab
    aab
    ab
    Count=3
    </pre>
    <p class="Pp">Any number of <span class="Li">&quot;(*PRUNE)&quot;</span>
        assertions may be used in a pattern.</p>
    <p class="Pp">See also
        <span class="Li">&quot;(?&gt;</span><span class="Li"><i>pattern</i></span><span class="Li">)&quot;</span>
        and possessive quantifiers for other ways to control backtracking. In
        some cases, the use of <span class="Li">&quot;(*PRUNE)&quot;</span> can
        be replaced with a <span class="Li">&quot;(?&gt;pattern)&quot;</span>
        with no functional difference; however,
        <span class="Li">&quot;(*PRUNE)&quot;</span> can be used to handle cases
        that cannot be expressed using a
        <span class="Li">&quot;(?&gt;pattern)&quot;</span> alone.</p>
  </dd>
  <dt>&quot;(*SKIP)&quot; &quot;(*SKIP:<i>NAME</i>)&quot;</dt>
  <dd>This zero-width pattern is similar to
      <span class="Li">&quot;(*PRUNE)&quot;</span>, except that on failure it
      also signifies that whatever text that was matched leading up to the
      <span class="Li">&quot;(*SKIP)&quot;</span> pattern being executed cannot
      be part of <i>any</i> match of this pattern. This effectively means that
      the regex engine &quot;skips&quot; forward to this position on failure and
      tries to match again, (assuming that there is sufficient room to match).
    <p class="Pp">The name of the
        <span class="Li">&quot;(*SKIP:</span><span class="Li"><i>NAME</i></span><span class="Li">)&quot;</span>
        pattern has special significance. If a
        <span class="Li">&quot;(*MARK:</span><span class="Li"><i>NAME</i></span><span class="Li">)&quot;</span>
        was encountered while matching, then it is that position which is used
        as the &quot;skip point&quot;. If no
        <span class="Li">&quot;(*MARK)&quot;</span> of that name was
        encountered, then the <span class="Li">&quot;(*SKIP)&quot;</span>
        operator has no effect. When used without a name the &quot;skip
        point&quot; is where the match point was when executing the
        <span class="Li">&quot;(*SKIP)&quot;</span> pattern.</p>
    <p class="Pp">Compare the following to the examples in
        <span class="Li">&quot;(*PRUNE)&quot;</span>; note the string is twice
        as long:</p>
    <p class="Pp"></p>
    <pre> 'aaabaaab' =~ /a+b?(*SKIP)(?{print &quot;$&amp;\n&quot;; $count++})(*FAIL)/;
 print &quot;Count=$count\n&quot;;
    </pre>
    <p class="Pp">outputs</p>
    <p class="Pp"></p>
    <pre>    aaab
    aaab
    Count=2
    </pre>
    <p class="Pp">Once the 'aaab' at the start of the string has matched, and
        the <span class="Li">&quot;(*SKIP)&quot;</span> executed, the next
        starting point will be where the cursor was when the
        <span class="Li">&quot;(*SKIP)&quot;</span> was executed.</p>
  </dd>
  <dt>&quot;(*MARK:<i>NAME</i>)&quot; &quot;(*:<i>NAME</i>)&quot;</dt>
  <dd>This zero-width pattern can be used to mark the point reached in a string
      when a certain part of the pattern has been successfully matched. This
      mark may be given a name. A later
      <span class="Li">&quot;(*SKIP)&quot;</span> pattern will then skip forward
      to that point if backtracked into on failure. Any number of
      <span class="Li">&quot;(*MARK)&quot;</span> patterns are allowed, and the
      <i>NAME</i> portion may be duplicated.
    <p class="Pp">In addition to interacting with the
        <span class="Li">&quot;(*SKIP)&quot;</span> pattern,
        <span class="Li">&quot;(*MARK:</span><span class="Li"><i>NAME</i></span><span class="Li">)&quot;</span>
        can be used to &quot;label&quot; a pattern branch, so that after
        matching, the program can determine which branches of the pattern were
        involved in the match.</p>
    <p class="Pp">When a match is successful, the
        <span class="Li">$REGMARK</span> variable will be set to the name of the
        most recently executed
        <span class="Li">&quot;(*MARK:</span><span class="Li"><i>NAME</i></span><span class="Li">)&quot;</span>
        that was involved in the match.</p>
    <p class="Pp">This can be used to determine which branch of a pattern was
        matched without using a separate capture group for each branch, which in
        turn can result in a performance improvement, as perl cannot optimize
        <span class="Li">&quot;/(?:(x)|(y)|(z))/&quot;</span> as efficiently as
        something like
        <span class="Li">&quot;/(?:x(*MARK:x)|y(*MARK:y)|z(*MARK:z))/&quot;</span>.</p>
    <p class="Pp">When a match has failed, and unless another verb has been
        involved in failing the match and has provided its own name to use, the
        <span class="Li">$REGERROR</span> variable will be set to the name of
        the most recently executed
        <span class="Li">&quot;(*MARK:</span><span class="Li"><i>NAME</i></span><span class="Li">)&quot;</span>.</p>
    <p class="Pp">See &quot;(*SKIP)&quot; for more details.</p>
    <p class="Pp">As a shortcut
        <span class="Li">&quot;(*MARK:</span><span class="Li"><i>NAME</i></span><span class="Li">)&quot;</span>
        can be written
        <span class="Li">&quot;(*:</span><span class="Li"><i>NAME</i></span><span class="Li">)&quot;</span>.</p>
  </dd>
  <dt>&quot;(*THEN)&quot; &quot;(*THEN:<i>NAME</i>)&quot;</dt>
  <dd>This is similar to the &quot;cut group&quot; operator
      <span class="Li">&quot;::&quot;</span> from Raku. Like
      <span class="Li">&quot;(*PRUNE)&quot;</span>, this verb always matches,
      and when backtracked into on failure, it causes the regex engine to try
      the next alternation in the innermost enclosing group (capturing or
      otherwise) that has alternations. The two branches of a
      <span class="Li">&quot;(?(</span><span class="Li"><i>condition</i></span><span class="Li">)</span><span class="Li"><i>yes-pattern</i></span><span class="Li">|</span><span class="Li"><i>no-pattern</i></span><span class="Li">)&quot;</span>
      do not count as an alternation, as far as
      <span class="Li">&quot;(*THEN)&quot;</span> is concerned.
    <p class="Pp">Its name comes from the observation that this operation
        combined with the alternation operator
        (<span class="Li">&quot;|&quot;</span>) can be used to create what is
        essentially a pattern-based if/then/else block:</p>
    <p class="Pp"></p>
    <pre>  ( COND (*THEN) FOO | COND2 (*THEN) BAR | COND3 (*THEN) BAZ )
    </pre>
    <p class="Pp">Note that if this operator is used and NOT inside of an
        alternation then it acts exactly like the
        <span class="Li">&quot;(*PRUNE)&quot;</span> operator.</p>
    <p class="Pp"></p>
    <pre>  / A (*PRUNE) B /
    </pre>
    <p class="Pp">is the same as</p>
    <p class="Pp"></p>
    <pre>  / A (*THEN) B /
    </pre>
    <p class="Pp">but</p>
    <p class="Pp"></p>
    <pre>  / ( A (*THEN) B | C ) /
    </pre>
    <p class="Pp">is not the same as</p>
    <p class="Pp"></p>
    <pre>  / ( A (*PRUNE) B | C ) /
    </pre>
    <p class="Pp">as after matching the <i>A</i> but failing on the <i>B</i> the
        <span class="Li">&quot;(*THEN)&quot;</span> verb will backtrack and try
        <i>C</i>; but the <span class="Li">&quot;(*PRUNE)&quot;</span> verb will
        simply fail.</p>
  </dd>
  <dt>&quot;(*COMMIT)&quot; &quot;(*COMMIT:<i>arg</i>)&quot;</dt>
  <dd>This is the Raku &quot;commit pattern&quot;
      <span class="Li">&quot;&lt;commit&gt;&quot;</span> or
      <span class="Li">&quot;:::&quot;</span>. It's a zero-width pattern similar
      to <span class="Li">&quot;(*SKIP)&quot;</span>, except that when
      backtracked into on failure it causes the match to fail outright. No
      further attempts to find a valid match by advancing the start pointer will
      occur again. For example,
    <p class="Pp"></p>
    <pre> 'aaabaaab' =~ /a+b?(*COMMIT)(?{print &quot;$&amp;\n&quot;; $count++})(*FAIL)/;
 print &quot;Count=$count\n&quot;;
    </pre>
    <p class="Pp">outputs</p>
    <p class="Pp"></p>
    <pre>    aaab
    Count=1
    </pre>
    <p class="Pp">In other words, once the
        <span class="Li">&quot;(*COMMIT)&quot;</span> has been entered, and if
        the pattern does not match, the regex engine will not try any further
        matching on the rest of the string.</p>
  </dd>
  <dt>&quot;(*FAIL)&quot; &quot;(*F)&quot; &quot;(*FAIL:<i>arg</i>)&quot;</dt>
  <dd>This pattern matches nothing and always fails. It can be used to force the
      engine to backtrack. It is equivalent to
      <span class="Li">&quot;(?!)&quot;</span>, but easier to read. In fact,
      <span class="Li">&quot;(?!)&quot;</span> gets optimised into
      <span class="Li">&quot;(*FAIL)&quot;</span> internally. You can provide an
      argument so that if the match fails because of this
      <span class="Li">&quot;FAIL&quot;</span> directive the argument can be
      obtained from <span class="Li">$REGERROR</span>.
    <p class="Pp">It is probably useful only when combined with
        <span class="Li">&quot;(?{})&quot;</span> or
        <span class="Li">&quot;(??{})&quot;</span>.</p>
  </dd>
  <dt>&quot;(*ACCEPT)&quot; &quot;(*ACCEPT:<i>arg</i>)&quot;</dt>
  <dd>This pattern matches nothing and causes the end of successful matching at
      the point at which the <span class="Li">&quot;(*ACCEPT)&quot;</span>
      pattern was encountered, regardless of whether there is actually more to
      match in the string. When inside of a nested pattern, such as recursion,
      or in a subpattern dynamically generated via
      <span class="Li">&quot;(??{})&quot;</span>, only the innermost pattern is
      ended immediately.
    <p class="Pp">If the <span class="Li">&quot;(*ACCEPT)&quot;</span> is inside
        of capturing groups then the groups are marked as ended at the point at
        which the <span class="Li">&quot;(*ACCEPT)&quot;</span> was encountered.
        For instance:</p>
    <p class="Pp"></p>
    <pre>  'AB' =~ /(A (A|B(*ACCEPT)|C) D)(E)/x;
    </pre>
    <p class="Pp">will match, and <span class="Li">$1</span> will be
        <span class="Li">&quot;AB&quot;</span> and <span class="Li">$2</span>
        will be <span class="Li">&quot;B&quot;</span>,
        <span class="Li">$3</span> will not be set. If another branch in the
        inner parentheses was matched, such as in the string 'ACDE', then the
        <span class="Li">&quot;D&quot;</span> and
        <span class="Li">&quot;E&quot;</span> would have to be matched as
      well.</p>
    <p class="Pp">You can provide an argument, which will be available in the
        var <span class="Li">$REGMARK</span> after the match completes.</p>
  </dd>
</dl>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Ss">
<h2 class="Ss" id="Warning_on__"><a class="permalink" href="#Warning_on__">Warning
  on &quot;\1&quot; Instead of $1</a></h2>
<p class="Pp">Some people get too used to writing things like:</p>
<p class="Pp"></p>
<pre>    $pattern =~ s/(\W)/\\\1/g;
</pre>
<p class="Pp">This is grandfathered (for \1 to \9) for the RHS of a substitute
    to avoid shocking the <b>sed</b> addicts, but it's a dirty habit to get
    into. That's because in PerlThink, the righthand side of an
    <span class="Li">&quot;s///&quot;</span> is a double-quoted string.
    <span class="Li">&quot;\1&quot;</span> in the usual double-quoted string
    means a control-A. The customary Unix meaning of
    <span class="Li">&quot;\1&quot;</span> is kludged in for
    <span class="Li">&quot;s///&quot;</span>. However, if you get into the habit
    of doing that, you get yourself into trouble if you then add an
    <span class="Li">&quot;/e&quot;</span> modifier.</p>
<p class="Pp"></p>
<pre>    s/(\d+)/ \1 + 1 /eg;            # causes warning under -w
</pre>
<p class="Pp">Or if you try to do</p>
<p class="Pp"></p>
<pre>    s/(\d+)/\1000/;
</pre>
<p class="Pp">You can't disambiguate that by saying
    <span class="Li">&quot;\{1}000&quot;</span>, whereas you can fix it with
    <span class="Li">&quot;${1}000&quot;</span>. The operation of interpolation
    should not be confused with the operation of matching a backreference.
    Certainly they mean two different things on the <i>left</i> side of the
    <span class="Li">&quot;s///&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Repeated_Patterns_Matching_a_Zero-length_Substring"><a class="permalink" href="#Repeated_Patterns_Matching_a_Zero-length_Substring">Repeated
  Patterns Matching a Zero-length Substring</a></h2>
<p class="Pp"><b>WARNING</b>: Difficult material (and prose) ahead. This section
    needs a rewrite.</p>
<p class="Pp">Regular expressions provide a terse and powerful programming
    language. As with most other power tools, power comes together with the
    ability to wreak havoc.</p>
<p class="Pp">A common abuse of this power stems from the ability to make
    infinite loops using regular expressions, with something as innocuous
  as:</p>
<p class="Pp"></p>
<pre>    'foo' =~ m{ ( o? )* }x;
</pre>
<p class="Pp">The <span class="Li">&quot;o?&quot;</span> matches at the
    beginning of &quot;<span class="Li">&quot;foo&quot;</span>&quot;, and since
    the position in the string is not moved by the match,
    <span class="Li">&quot;o?&quot;</span> would match again and again because
    of the <span class="Li">&quot;*&quot;</span> quantifier. Another common way
    to create a similar cycle is with the looping modifier
    <span class="Li">&quot;/g&quot;</span>:</p>
<p class="Pp"></p>
<pre>    @matches = ( 'foo' =~ m{ o? }xg );
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre>    print &quot;match: &lt;$&amp;&gt;\n&quot; while 'foo' =~ m{ o? }xg;
</pre>
<p class="Pp">or the loop implied by
    <span class="Li">&quot;split()&quot;</span>.</p>
<p class="Pp">However, long experience has shown that many programming tasks may
    be significantly simplified by using repeated subexpressions that may match
    zero-length substrings. Here's a simple example being:</p>
<p class="Pp"></p>
<pre>    @chars = split //, $string;           # // is not magic in split
    ($whitewashed = $string) =~ s/()/ /g; # parens avoid magic s// /
</pre>
<p class="Pp">Thus Perl allows such constructs, by <i>forcefully breaking</i>
    <i>the infinite loop</i>. The rules for this are different for lower-level
    loops given by the greedy quantifiers
    <span class="Li">&quot;*+{}&quot;</span>, and for higher-level ones like the
    <span class="Li">&quot;/g&quot;</span> modifier or
    <span class="Li">&quot;split()&quot;</span> operator.</p>
<p class="Pp">The lower-level loops are <i>interrupted</i> (that is, the loop is
    broken) when Perl detects that a repeated expression matched a zero-length
    substring. Thus</p>
<p class="Pp"></p>
<pre>   m{ (?: NON_ZERO_LENGTH | ZERO_LENGTH )* }x;
</pre>
<p class="Pp">is made equivalent to</p>
<p class="Pp"></p>
<pre>   m{ (?: NON_ZERO_LENGTH )* (?: ZERO_LENGTH )? }x;
</pre>
<p class="Pp">For example, this program</p>
<p class="Pp"></p>
<pre>   #!perl -l
   &quot;aaaaab&quot; =~ /
     (?:
        a                 # non-zero
        |                 # or
       (?{print &quot;hello&quot;}) # print hello whenever this
                          #    branch is tried
       (?=(b))            # zero-width assertion
     )*  # any number of times
    /x;
   print $&amp;;
   print $1;
</pre>
<p class="Pp">prints</p>
<p class="Pp"></p>
<pre>   hello
   aaaaa
   b
</pre>
<p class="Pp">Notice that &quot;hello&quot; is only printed once, as when Perl
    sees that the sixth iteration of the outermost
    <span class="Li">&quot;(?:)*&quot;</span> matches a zero-length string, it
    stops the <span class="Li">&quot;*&quot;</span>.</p>
<p class="Pp">The higher-level loops preserve an additional state between
    iterations: whether the last match was zero-length. To break the loop, the
    following match after a zero-length match is prohibited to have a length of
    zero. This prohibition interacts with backtracking (see
    &quot;Backtracking&quot;), and so the <i>second best</i> match is chosen if
    the <i>best</i> match is of zero length.</p>
<p class="Pp">For example:</p>
<p class="Pp"></p>
<pre>    $_ = 'bar';
    s/\w??/&lt;$&amp;&gt;/g;
</pre>
<p class="Pp">results in
    <span class="Li">&quot;&lt;&gt;&lt;b&gt;&lt;&gt;&lt;a&gt;&lt;&gt;&lt;r&gt;&lt;&gt;&quot;</span>.
    At each position of the string the best match given by non-greedy
    <span class="Li">&quot;??&quot;</span> is the zero-length match, and the
    <i>second</i> <i>best</i> match is what is matched by
    <span class="Li">&quot;\w&quot;</span>. Thus zero-length matches alternate
    with one-character-long matches.</p>
<p class="Pp">Similarly, for repeated <span class="Li">&quot;m/()/g&quot;</span>
    the second-best match is the match at the position one notch further in the
    string.</p>
<p class="Pp">The additional state of being <i>matched with zero-length</i> is
    associated with the matched string, and is reset by each assignment to
    <span class="Li">&quot;pos()&quot;</span>. Zero-length matches at the end of
    the previous match are ignored during
    <span class="Li">&quot;split&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Combining_"><a class="permalink" href="#Combining_">Combining
  RE Pieces</a></h2>
<p class="Pp">Each of the elementary pieces of regular expressions which were
    described before (such as <span class="Li">&quot;ab&quot;</span> or
    <span class="Li">&quot;\Z&quot;</span>) could match at most one substring at
    the given position of the input string. However, in a typical regular
    expression these elementary pieces are combined into more complicated
    patterns using combining operators <span class="Li">&quot;ST&quot;</span>,
    <span class="Li">&quot;S|T&quot;</span>,
    <span class="Li">&quot;S*&quot;</span> <i>etc</i>. (in these examples
    <span class="Li">&quot;S&quot;</span> and
    <span class="Li">&quot;T&quot;</span> are regular subexpressions).</p>
<p class="Pp">Such combinations can include alternatives, leading to a problem
    of choice: if we match a regular expression
    <span class="Li">&quot;a|ab&quot;</span> against
    <span class="Li">&quot;abc&quot;</span>, will it match substring
    <span class="Li">&quot;a&quot;</span> or
    <span class="Li">&quot;ab&quot;</span>? One way to describe which substring
    is actually matched is the concept of backtracking (see
    &quot;Backtracking&quot;). However, this description is too low-level and
    makes you think in terms of a particular implementation.</p>
<p class="Pp">Another description starts with notions of
    &quot;better&quot;/&quot;worse&quot;. All the substrings which may be
    matched by the given regular expression can be sorted from the
    &quot;best&quot; match to the &quot;worst&quot; match, and it is the
    &quot;best&quot; match which is chosen. This substitutes the question of
    &quot;what is chosen?&quot; by the question of &quot;which matches are
    better, and which are worse?&quot;.</p>
<p class="Pp">Again, for elementary pieces there is no such question, since at
    most one match at a given position is possible. This section describes the
    notion of better/worse for combining operators. In the description below
    <span class="Li">&quot;S&quot;</span> and
    <span class="Li">&quot;T&quot;</span> are regular subexpressions.</p>
<dl class="Bl-tag">
  <dt>&quot;ST&quot;</dt>
  <dd>Consider two possible matches, <span class="Li">&quot;AB&quot;</span> and
      <span class="Li">&quot;A'B'&quot;</span>,
      <span class="Li">&quot;A&quot;</span> and
      <span class="Li">&quot;A'&quot;</span> are substrings which can be matched
      by <span class="Li">&quot;S&quot;</span>,
      <span class="Li">&quot;B&quot;</span> and
      <span class="Li">&quot;B'&quot;</span> are substrings which can be matched
      by <span class="Li">&quot;T&quot;</span>.
    <p class="Pp">If <span class="Li">&quot;A&quot;</span> is a better match for
        <span class="Li">&quot;S&quot;</span> than
        <span class="Li">&quot;A'&quot;</span>,
        <span class="Li">&quot;AB&quot;</span> is a better match than
        <span class="Li">&quot;A'B'&quot;</span>.</p>
    <p class="Pp">If <span class="Li">&quot;A&quot;</span> and
        <span class="Li">&quot;A'&quot;</span> coincide:
        <span class="Li">&quot;AB&quot;</span> is a better match than
        <span class="Li">&quot;AB'&quot;</span> if
        <span class="Li">&quot;B&quot;</span> is a better match for
        <span class="Li">&quot;T&quot;</span> than
        <span class="Li">&quot;B'&quot;</span>.</p>
  </dd>
  <dt>&quot;S|T&quot;</dt>
  <dd>When <span class="Li">&quot;S&quot;</span> can match, it is a better match
      than when only <span class="Li">&quot;T&quot;</span> can match.
    <p class="Pp">Ordering of two matches for
        <span class="Li">&quot;S&quot;</span> is the same as for
        <span class="Li">&quot;S&quot;</span>. Similar for two matches for
        <span class="Li">&quot;T&quot;</span>.</p>
  </dd>
  <dt>&quot;S{REPEAT_COUNT}&quot;</dt>
  <dd>Matches as <span class="Li">&quot;SSS...S&quot;</span> (repeated as many
      times as necessary).</dd>
  <dt>&quot;S{min,max}&quot;</dt>
  <dd>Matches as
      <span class="Li">&quot;S{max}|S{max-1}|...|S{min+1}|S{min}&quot;</span>.</dd>
  <dt>&quot;S{min,max}?&quot;</dt>
  <dd>Matches as
      <span class="Li">&quot;S{min}|S{min+1}|...|S{max-1}|S{max}&quot;</span>.</dd>
  <dt>&quot;S?&quot;, &quot;S*&quot;, &quot;S+&quot;</dt>
  <dd>Same as <span class="Li">&quot;S{0,1}&quot;</span>,
      <span class="Li">&quot;S{0,BIG_NUMBER}&quot;</span>,
      <span class="Li">&quot;S{1,BIG_NUMBER}&quot;</span> respectively.</dd>
  <dt>&quot;S??&quot;, &quot;S*?&quot;, &quot;S+?&quot;</dt>
  <dd>Same as <span class="Li">&quot;S{0,1}?&quot;</span>,
      <span class="Li">&quot;S{0,BIG_NUMBER}?&quot;</span>,
      <span class="Li">&quot;S{1,BIG_NUMBER}?&quot;</span> respectively.</dd>
  <dt>&quot;(?&gt;S)&quot;</dt>
  <dd>Matches the best match for <span class="Li">&quot;S&quot;</span> and only
      that.</dd>
  <dt>&quot;(?=S)&quot;, &quot;(?&lt;=S)&quot;</dt>
  <dd>Only the best match for <span class="Li">&quot;S&quot;</span> is
      considered. (This is important only if
      <span class="Li">&quot;S&quot;</span> has capturing parentheses, and
      backreferences are used somewhere else in the whole regular
    expression.)</dd>
  <dt>&quot;(?!S)&quot;, &quot;(?&lt;!S)&quot;</dt>
  <dd>For this grouping operator there is no need to describe the ordering,
      since only whether or not <span class="Li">&quot;S&quot;</span> can match
      is important.</dd>
  <dt>&quot;(??{ <i>EXPR</i> })&quot;, &quot;(?<i>PARNO</i>)&quot;</dt>
  <dd>The ordering is the same as for the regular expression which is the result
      of <i>EXPR</i>, or the pattern contained by capture group
    <i>PARNO</i>.</dd>
  <dt>&quot;(?(<i>condition</i>)<i>yes-pattern</i>|<i>no-pattern</i>)&quot;</dt>
  <dd>Recall that which of <i>yes-pattern</i> or <i>no-pattern</i> actually
      matches is already determined. The ordering of the matches is the same as
      for the chosen subexpression.</dd>
</dl>
<p class="Pp">The above recipes describe the ordering of matches <i>at a given
    position</i>. One more rule is needed to understand how a match is
    determined for the whole regular expression: a match at an earlier position
    is always better than a match at a later position.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Creating_Custom_"><a class="permalink" href="#Creating_Custom_">Creating
  Custom RE Engines</a></h2>
<p class="Pp">As of Perl 5.10.0, one can create custom regular expression
    engines. This is not for the faint of heart, as they have to plug in at the
    C level. See perlreapi for more details.</p>
<p class="Pp">As an alternative, overloaded constants (see overload) provide a
    simple way to extend the functionality of the RE engine, by substituting one
    pattern for another.</p>
<p class="Pp">Suppose that we want to enable a new RE escape-sequence
    <span class="Li">&quot;\Y|&quot;</span> which matches at a boundary between
    whitespace characters and non-whitespace characters. Note that
    <span class="Li">&quot;(?=\S)(?&lt;!\S)|(?!\S)(?&lt;=\S)&quot;</span>
    matches exactly at these positions, so we want to have each
    <span class="Li">&quot;\Y|&quot;</span> in the place of the more complicated
    version. We can create a module <span class="Li">&quot;customre&quot;</span>
    to do this:</p>
<p class="Pp"></p>
<pre>    package customre;
    use overload;
    sub import {
      shift;
      die &quot;No argument to customre::import allowed&quot; if @_;
      overload::constant 'qr' =&gt; \&amp;convert;
    }
    sub invalid { die &quot;/$_[0]/: invalid escape '\\$_[1]'&quot;}
    # We must also take care of not escaping the legitimate \\Y|
    # sequence, hence the presence of '\\' in the conversion rules.
    my %rules = ( '\\' =&gt; '\\\\',
                  'Y|' =&gt; qr/(?=\S)(?&lt;!\S)|(?!\S)(?&lt;=\S)/ );
    sub convert {
      my $re = shift;
      $re =~ s{
                \\ ( \\ | Y . )
              }
              { $rules{$1} or invalid($re,$1) }sgex;
      return $re;
    }
</pre>
<p class="Pp">Now <span class="Li">&quot;use customre&quot;</span> enables the
    new escape in constant regular expressions, <i>i.e.</i>, those without any
    runtime variable interpolations. As documented in overload, this conversion
    will work only over literal parts of regular expressions. For
    <span class="Li">&quot;\Y|$re\Y|&quot;</span> the variable part of this
    regular expression needs to be converted explicitly (but only if the special
    meaning of <span class="Li">&quot;\Y|&quot;</span> should be enabled inside
    <span class="Li">$re</span>):</p>
<p class="Pp"></p>
<pre>    use customre;
    $re = &lt;&gt;;
    chomp $re;
    $re = customre::convert $re;
    /\Y|$re\Y|/;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Embedded_Code_Execution_Frequency"><a class="permalink" href="#Embedded_Code_Execution_Frequency">Embedded
  Code Execution Frequency</a></h2>
<p class="Pp">The exact rules for how often
    <span class="Li">&quot;(??{})&quot;</span> and
    <span class="Li">&quot;(?{})&quot;</span> are executed in a pattern are
    unspecified. In the case of a successful match you can assume that they DWIM
    and will be executed in left to right order the appropriate number of times
    in the accepting path of the pattern as would any other meta-pattern. How
    non-accepting pathways and match failures affect the number of times a
    pattern is executed is specifically unspecified and may vary depending on
    what optimizations can be applied to the pattern and is likely to change
    from version to version.</p>
<p class="Pp">For instance in</p>
<p class="Pp"></p>
<pre>  &quot;aaabcdeeeee&quot;=~/a(?{print &quot;a&quot;})b(?{print &quot;b&quot;})cde/;
</pre>
<p class="Pp">the exact number of times &quot;a&quot; or &quot;b&quot; are
    printed out is unspecified for failure, but you may assume they will be
    printed at least once during a successful match, additionally you may assume
    that if &quot;b&quot; is printed, it will be preceded by at least one
    &quot;a&quot;.</p>
<p class="Pp">In the case of branching constructs like the following:</p>
<p class="Pp"></p>
<pre>  /a(b|(?{ print &quot;a&quot; }))c(?{ print &quot;c&quot; })/;
</pre>
<p class="Pp">you can assume that the input &quot;ac&quot; will output
    &quot;ac&quot;, and that &quot;abc&quot; will output only &quot;c&quot;.</p>
<p class="Pp">When embedded code is quantified, successful matches will call the
    code once for each matched iteration of the quantifier. For example:</p>
<p class="Pp"></p>
<pre>  &quot;good&quot; =~ /g(?:o(?{print &quot;o&quot;}))*d/;
</pre>
<p class="Pp">will output &quot;o&quot; twice.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="PCRE/Python_Support"><a class="permalink" href="#PCRE/Python_Support">PCRE/Python
  Support</a></h2>
<p class="Pp">As of Perl 5.10.0, Perl supports several Python/PCRE-specific
    extensions to the regex syntax. While Perl programmers are encouraged to use
    the Perl-specific syntax, the following are also accepted:</p>
<dl class="Bl-tag">
  <dt>&quot;(?P&lt;<i>NAME</i>&gt;<i>pattern</i>)&quot;</dt>
  <dd>Define a named capture group. Equivalent to
      <span class="Li">&quot;(?&lt;</span><span class="Li"><i>NAME</i></span><span class="Li">&gt;</span><span class="Li"><i>pattern</i></span><span class="Li">)&quot;</span>.</dd>
  <dt>&quot;(?P=<i>NAME</i>)&quot;</dt>
  <dd>Backreference to a named capture group. Equivalent to
      <span class="Li">&quot;\g{</span><span class="Li"><i>NAME</i></span><span class="Li">}&quot;</span>.</dd>
  <dt>&quot;(?P&gt;<i>NAME</i>)&quot;</dt>
  <dd>Subroutine call to a named capture group. Equivalent to
      <span class="Li">&quot;(?&amp;</span><span class="Li"><i>NAME</i></span><span class="Li">)&quot;</span>.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">There are a number of issues with regard to case-insensitive
    matching in Unicode rules. See <span class="Li">&quot;i&quot;</span> under
    &quot;Modifiers&quot; above.</p>
<p class="Pp">This document varies from difficult to understand to completely
    and utterly opaque. The wandering prose riddled with jargon is hard to
    fathom in several places.</p>
<p class="Pp">This document needs a rewrite that separates the tutorial content
    from the reference content.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">The syntax of patterns used in Perl pattern matching evolved from
    those supplied in the Bell Labs Research Unix 8th Edition (Version 8) regex
    routines. (The code is actually derived (distantly) from Henry Spencer's
    freely redistributable reimplementation of those V8 routines.)</p>
<p class="Pp">perlrequick.</p>
<p class="Pp">perlretut.</p>
<p class="Pp">&quot;Regexp Quote-Like Operators&quot; in perlop.</p>
<p class="Pp">&quot;Gory details of parsing quoted constructs&quot; in
  perlop.</p>
<p class="Pp">perlfaq6.</p>
<p class="Pp">&quot;pos&quot; in perlfunc.</p>
<p class="Pp">perllocale.</p>
<p class="Pp">perlebcdic.</p>
<p class="Pp"><i>Mastering Regular Expressions</i> by Jeffrey Friedl, published
    by O'Reilly and Associates.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2021-02-21</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

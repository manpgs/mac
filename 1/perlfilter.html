<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PERLFILTER(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLFILTER(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLFILTER(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlfilter - Source Filters</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This article is about a little-known feature of Perl called
    <i>source filters</i>. Source filters alter the program text of a module
    before Perl sees it, much as a C preprocessor alters the source text of a C
    program before the compiler sees it. This article tells you more about what
    source filters are, how they work, and how to write your own.</p>
<p class="Pp">The original purpose of source filters was to let you encrypt your
    program source to prevent casual piracy. This isn't all they can do, as
    you'll soon learn. But first, the basics.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONCEPTS"><a class="permalink" href="#CONCEPTS">CONCEPTS</a></h1>
<p class="Pp">Before the Perl interpreter can execute a Perl script, it must
    first read it from a file into memory for parsing and compilation. If that
    script itself includes other scripts with a
    <span class="Li">&quot;use&quot;</span> or
    <span class="Li">&quot;require&quot;</span> statement, then each of those
    scripts will have to be read from their respective files as well.</p>
<p class="Pp">Now think of each logical connection between the Perl parser and
    an individual file as a <i>source stream</i>. A source stream is created
    when the Perl parser opens a file, it continues to exist as the source code
    is read into memory, and it is destroyed when Perl is finished parsing the
    file. If the parser encounters a <span class="Li">&quot;require&quot;</span>
    or <span class="Li">&quot;use&quot;</span> statement in a source stream, a
    new and distinct stream is created just for that file.</p>
<p class="Pp">The diagram below represents a single source stream, with the flow
    of source from a Perl script file on the left into the Perl parser on the
    right. This is how Perl normally operates.</p>
<p class="Pp"></p>
<pre>    file -------&gt; parser
</pre>
<p class="Pp">There are two important points to remember:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>Although there can be any number of source streams in existence at any
      given time, only one will be active.</dd>
  <dt>2.</dt>
  <dd>Every source stream is associated with only one file.</dd>
</dl>
<p class="Pp">A source filter is a special kind of Perl module that intercepts
    and modifies a source stream before it reaches the parser. A source filter
    changes our diagram like this:</p>
<p class="Pp"></p>
<pre>    file ----&gt; filter ----&gt; parser
</pre>
<p class="Pp">If that doesn't make much sense, consider the analogy of a command
    pipeline. Say you have a shell script stored in the compressed file
    <i>trial.gz</i>. The simple pipeline command below runs the script without
    needing to create a temporary file to hold the uncompressed file.</p>
<p class="Pp"></p>
<pre>    gunzip -c trial.gz | sh
</pre>
<p class="Pp">In this case, the data flow from the pipeline can be represented
    as follows:</p>
<p class="Pp"></p>
<pre>    trial.gz ----&gt; gunzip ----&gt; sh
</pre>
<p class="Pp">With source filters, you can store the text of your script
    compressed and use a source filter to uncompress it for Perl's parser:</p>
<p class="Pp"></p>
<pre>     compressed           gunzip
    Perl program ---&gt; source filter ---&gt; parser
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="USING_FILTERS"><a class="permalink" href="#USING_FILTERS">USING
  FILTERS</a></h1>
<p class="Pp">So how do you use a source filter in a Perl script? Above, I said
    that a source filter is just a special kind of module. Like all Perl
    modules, a source filter is invoked with a use statement.</p>
<p class="Pp">Say you want to pass your Perl source through the C preprocessor
    before execution. As it happens, the source filters distribution comes with
    a C preprocessor filter module called Filter::cpp.</p>
<p class="Pp">Below is an example program,
    <span class="Li">&quot;cpp_test&quot;</span>, which makes use of this
    filter. Line numbers have been added to allow specific lines to be
    referenced easily.</p>
<p class="Pp"></p>
<pre>    1: use Filter::cpp;
    2: #define TRUE 1
    3: $a = TRUE;
    4: print &quot;a = $a\n&quot;;
</pre>
<p class="Pp">When you execute this script, Perl creates a source stream for the
    file. Before the parser processes any of the lines from the file, the source
    stream looks like this:</p>
<p class="Pp"></p>
<pre>    cpp_test ---------&gt; parser
</pre>
<p class="Pp">Line 1, <span class="Li">&quot;use Filter::cpp&quot;</span>,
    includes and installs the <span class="Li">&quot;cpp&quot;</span> filter
    module. All source filters work this way. The use statement is compiled and
    executed at compile time, before any more of the file is read, and it
    attaches the cpp filter to the source stream behind the scenes. Now the data
    flow looks like this:</p>
<p class="Pp"></p>
<pre>    cpp_test ----&gt; cpp filter ----&gt; parser
</pre>
<p class="Pp">As the parser reads the second and subsequent lines from the
    source stream, it feeds those lines through the
    <span class="Li">&quot;cpp&quot;</span> source filter before processing
    them. The <span class="Li">&quot;cpp&quot;</span> filter simply passes each
    line through the real C preprocessor. The output from the C preprocessor is
    then inserted back into the source stream by the filter.</p>
<p class="Pp"></p>
<pre>                  .-&gt; cpp --.
                  |         |
                  |         |
                  |       &lt;-'
   cpp_test ----&gt; cpp filter ----&gt; parser
</pre>
<p class="Pp">The parser then sees the following code:</p>
<p class="Pp"></p>
<pre>    use Filter::cpp;
    $a = 1;
    print &quot;a = $a\n&quot;;
</pre>
<p class="Pp">Let's consider what happens when the filtered code includes
    another module with use:</p>
<p class="Pp"></p>
<pre>    1: use Filter::cpp;
    2: #define TRUE 1
    3: use Fred;
    4: $a = TRUE;
    5: print &quot;a = $a\n&quot;;
</pre>
<p class="Pp">The <span class="Li">&quot;cpp&quot;</span> filter does not apply
    to the text of the Fred module, only to the text of the file that used it
    (<span class="Li">&quot;cpp_test&quot;</span>). Although the use statement
    on line 3 will pass through the cpp filter, the module that gets included
    (<span class="Li">&quot;Fred&quot;</span>) will not. The source streams look
    like this after line 3 has been parsed and before line 4 is parsed:</p>
<p class="Pp"></p>
<pre>    cpp_test ---&gt; cpp filter ---&gt; parser (INACTIVE)
    Fred.pm ----&gt; parser
</pre>
<p class="Pp">As you can see, a new stream has been created for reading the
    source from <span class="Li">&quot;Fred.pm&quot;</span>. This stream will
    remain active until all of <span class="Li">&quot;Fred.pm&quot;</span> has
    been parsed. The source stream for
    <span class="Li">&quot;cpp_test&quot;</span> will still exist, but is
    inactive. Once the parser has finished reading Fred.pm, the source stream
    associated with it will be destroyed. The source stream for
    <span class="Li">&quot;cpp_test&quot;</span> then becomes active again and
    the parser reads line 4 and subsequent lines from
    <span class="Li">&quot;cpp_test&quot;</span>.</p>
<p class="Pp">You can use more than one source filter on a single file.
    Similarly, you can reuse the same filter in as many files as you like.</p>
<p class="Pp">For example, if you have a uuencoded and compressed source file,
    it is possible to stack a uudecode filter and an uncompression filter like
    this:</p>
<p class="Pp"></p>
<pre>    use Filter::uudecode; use Filter::uncompress;
    M'XL(&quot;.H&lt;US4''V9I;F%L')Q;&gt;7/;1I;_&gt;_I3=&amp;E=%:F*I&quot;T?22Q/
    M6]9*&lt;IQCO*XFT&quot;0[PL%%'Y+IG?WN^ZYN-$'J.[.JE$,20/?K=_[&gt;
    ...
</pre>
<p class="Pp">Once the first line has been processed, the flow will look like
    this:</p>
<p class="Pp"></p>
<pre>    file ---&gt; uudecode ---&gt; uncompress ---&gt; parser
               filter         filter
</pre>
<p class="Pp">Data flows through filters in the same order they appear in the
    source file. The uudecode filter appeared before the uncompress filter, so
    the source file will be uudecoded before it's uncompressed.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="WRITING_A_SOURCE_FILTER"><a class="permalink" href="#WRITING_A_SOURCE_FILTER">WRITING
  A SOURCE FILTER</a></h1>
<p class="Pp">There are three ways to write your own source filter. You can
    write it in C, use an external program as a filter, or write the filter in
    Perl. I won't cover the first two in any great detail, so I'll get them out
    of the way first. Writing the filter in Perl is most convenient, so I'll
    devote the most space to it.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="WRITING_A_SOURCE_FILTER_IN_C"><a class="permalink" href="#WRITING_A_SOURCE_FILTER_IN_C">WRITING
  A SOURCE FILTER IN C</a></h1>
<p class="Pp">The first of the three available techniques is to write the filter
    completely in C. The external module you create interfaces directly with the
    source filter hooks provided by Perl.</p>
<p class="Pp">The advantage of this technique is that you have complete control
    over the implementation of your filter. The big disadvantage is the
    increased complexity required to write the filter - not only do you need to
    understand the source filter hooks, but you also need a reasonable knowledge
    of Perl guts. One of the few times it is worth going to this trouble is when
    writing a source scrambler. The <span class="Li">&quot;decrypt&quot;</span>
    filter (which unscrambles the source before Perl parses it) included with
    the source filter distribution is an example of a C source filter (see
    Decryption Filters, below).</p>
<dl class="Bl-tag">
  <dt id="Decryption"><a class="permalink" href="#Decryption"><b>Decryption
    Filters</b></a></dt>
  <dd>All decryption filters work on the principle of &quot;security through
      obscurity.&quot; Regardless of how well you write a decryption filter and
      how strong your encryption algorithm is, anyone determined enough can
      retrieve the original source code. The reason is quite simple - once the
      decryption filter has decrypted the source back to its original form,
      fragments of it will be stored in the computer's memory as Perl parses it.
      The source might only be in memory for a short period of time, but anyone
      possessing a debugger, skill, and lots of patience can eventually
      reconstruct your program.
    <p class="Pp">That said, there are a number of steps that can be taken to
        make life difficult for the potential cracker. The most important: Write
        your decryption filter in C and statically link the decryption module
        into the Perl binary. For further tips to make life difficult for the
        potential cracker, see the file <i>decrypt.pm</i> in the source filters
        distribution.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="CREATING_A_SOURCE_FILTER_AS_A_SEPARATE_EXECUTABLE"><a class="permalink" href="#CREATING_A_SOURCE_FILTER_AS_A_SEPARATE_EXECUTABLE">CREATING
  A SOURCE FILTER AS A SEPARATE EXECUTABLE</a></h1>
<p class="Pp">An alternative to writing the filter in C is to create a separate
    executable in the language of your choice. The separate executable reads
    from standard input, does whatever processing is necessary, and writes the
    filtered data to standard output.
    <span class="Li">&quot;Filter::cpp&quot;</span> is an example of a source
    filter implemented as a separate executable - the executable is the C
    preprocessor bundled with your C compiler.</p>
<p class="Pp">The source filter distribution includes two modules that simplify
    this task: <span class="Li">&quot;Filter::exec&quot;</span> and
    <span class="Li">&quot;Filter::sh&quot;</span>. Both allow you to run any
    external executable. Both use a coprocess to control the flow of data into
    and out of the external executable. (For details on coprocesses, see
    Stephens, W.R., &quot;Advanced Programming in the UNIX Environment.&quot;
    Addison-Wesley, ISBN 0-210-56317-7, pages 441-445.) The difference between
    them is that <span class="Li">&quot;Filter::exec&quot;</span> spawns the
    external command directly, while
    <span class="Li">&quot;Filter::sh&quot;</span> spawns a shell to execute the
    external command. (Unix uses the Bourne shell; NT uses the cmd shell.)
    Spawning a shell allows you to make use of the shell metacharacters and
    redirection facilities.</p>
<p class="Pp">Here is an example script that uses
    <span class="Li">&quot;Filter::sh&quot;</span>:</p>
<p class="Pp"></p>
<pre>    use Filter::sh 'tr XYZ PQR';
    $a = 1;
    print &quot;XYZ a = $a\n&quot;;
</pre>
<p class="Pp">The output you'll get when the script is executed:</p>
<p class="Pp"></p>
<pre>    PQR a = 1
</pre>
<p class="Pp">Writing a source filter as a separate executable works fine, but a
    small performance penalty is incurred. For example, if you execute the small
    example above, a separate subprocess will be created to run the Unix
    <span class="Li">&quot;tr&quot;</span> command. Each use of the filter
    requires its own subprocess. If creating subprocesses is expensive on your
    system, you might want to consider one of the other options for creating
    source filters.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="WRITING_A_SOURCE_FILTER_IN_PERL"><a class="permalink" href="#WRITING_A_SOURCE_FILTER_IN_PERL">WRITING
  A SOURCE FILTER IN PERL</a></h1>
<p class="Pp">The easiest and most portable option available for creating your
    own source filter is to write it completely in Perl. To distinguish this
    from the previous two techniques, I'll call it a Perl source filter.</p>
<p class="Pp">To help understand how to write a Perl source filter we need an
    example to study. Here is a complete source filter that performs rot13
    decoding. (Rot13 is a very simple encryption scheme used in Usenet postings
    to hide the contents of offensive posts. It moves every letter forward
    thirteen places, so that A becomes N, B becomes O, and Z becomes M.)</p>
<p class="Pp"></p>
<pre>   package Rot13;
   use Filter::Util::Call;
   sub import {
      my ($type) = @_;
      my ($ref) = [];
      filter_add(bless $ref);
   }
   sub filter {
      my ($self) = @_;
      my ($status);
      tr/n-za-mN-ZA-M/a-zA-Z/
         if ($status = filter_read()) &gt; 0;
      $status;
   }
   1;
</pre>
<p class="Pp">All Perl source filters are implemented as Perl classes and have
    the same basic structure as the example above.</p>
<p class="Pp">First, we include the
    <span class="Li">&quot;Filter::Util::Call&quot;</span> module, which exports
    a number of functions into your filter's namespace. The filter shown above
    uses two of these functions,
    <span class="Li">&quot;filter_add()&quot;</span> and
    <span class="Li">&quot;filter_read()&quot;</span>.</p>
<p class="Pp">Next, we create the filter object and associate it with the source
    stream by defining the <span class="Li">&quot;import&quot;</span> function.
    If you know Perl well enough, you know that
    <span class="Li">&quot;import&quot;</span> is called automatically every
    time a module is included with a use statement. This makes
    <span class="Li">&quot;import&quot;</span> the ideal place to both create
    and install a filter object.</p>
<p class="Pp">In the example filter, the object (<span class="Li">$ref</span>)
    is blessed just like any other Perl object. Our example uses an anonymous
    array, but this isn't a requirement. Because this example doesn't need to
    store any context information, we could have used a scalar or hash reference
    just as well. The next section demonstrates context data.</p>
<p class="Pp">The association between the filter object and the source stream is
    made with the <span class="Li">&quot;filter_add()&quot;</span> function.
    This takes a filter object as a parameter (<span class="Li">$ref</span> in
    this case) and installs it in the source stream.</p>
<p class="Pp">Finally, there is the code that actually does the filtering. For
    this type of Perl source filter, all the filtering is done in a method
    called <span class="Li">&quot;filter()&quot;</span>. (It is also possible to
    write a Perl source filter using a closure. See the
    <span class="Li">&quot;Filter::Util::Call&quot;</span> manual page for more
    details.) It's called every time the Perl parser needs another line of
    source to process. The <span class="Li">&quot;filter()&quot;</span> method,
    in turn, reads lines from the source stream using the
    <span class="Li">&quot;filter_read()&quot;</span> function.</p>
<p class="Pp">If a line was available from the source stream,
    <span class="Li">&quot;filter_read()&quot;</span> returns a status value
    greater than zero and appends the line to <span class="Li">$_</span>. A
    status value of zero indicates end-of-file, less than zero means an error.
    The filter function itself is expected to return its status in the same way,
    and put the filtered line it wants written to the source stream in
    <span class="Li">$_</span>. The use of <span class="Li">$_</span> accounts
    for the brevity of most Perl source filters.</p>
<p class="Pp">In order to make use of the rot13 filter we need some way of
    encoding the source file in rot13 format. The script below,
    <span class="Li">&quot;mkrot13&quot;</span>, does just that.</p>
<p class="Pp"></p>
<pre>    die &quot;usage mkrot13 filename\n&quot; unless @ARGV;
    my $in = $ARGV[0];
    my $out = &quot;$in.tmp&quot;;
    open(IN, &quot;&lt;$in&quot;) or die &quot;Cannot open file $in: $!\n&quot;;
    open(OUT, &quot;&gt;$out&quot;) or die &quot;Cannot open file $out: $!\n&quot;;
    print OUT &quot;use Rot13;\n&quot;;
    while (&lt;IN&gt;) {
       tr/a-zA-Z/n-za-mN-ZA-M/;
       print OUT;
    }
    close IN;
    close OUT;
    unlink $in;
    rename $out, $in;
</pre>
<p class="Pp">If we encrypt this with
    <span class="Li">&quot;mkrot13&quot;</span>:</p>
<p class="Pp"></p>
<pre>    print &quot; hello fred \n&quot;;
</pre>
<p class="Pp">the result will be this:</p>
<p class="Pp"></p>
<pre>    use Rot13;
    cevag &quot;uryyb serq\a&quot;;
</pre>
<p class="Pp">Running it produces this output:</p>
<p class="Pp"></p>
<pre>    hello fred
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="USING_CONTEXT:_THE_DEBUG_FILTER"><a class="permalink" href="#USING_CONTEXT:_THE_DEBUG_FILTER">USING
  CONTEXT: THE DEBUG FILTER</a></h1>
<p class="Pp">The rot13 example was a trivial example. Here's another
    demonstration that shows off a few more features.</p>
<p class="Pp">Say you wanted to include a lot of debugging code in your Perl
    script during development, but you didn't want it available in the released
    product. Source filters offer a solution. In order to keep the example
    simple, let's say you wanted the debugging output to be controlled by an
    environment variable, <span class="Li">&quot;DEBUG&quot;</span>. Debugging
    code is enabled if the variable exists, otherwise it is disabled.</p>
<p class="Pp">Two special marker lines will bracket debugging code, like
  this:</p>
<p class="Pp"></p>
<pre>    ## DEBUG_BEGIN
    if ($year &gt; 1999) {
       warn &quot;Debug: millennium bug in year $year\n&quot;;
    }
    ## DEBUG_END
</pre>
<p class="Pp">The filter ensures that Perl parses the code between the
    &lt;DEBUG_BEGIN&gt; and <span class="Li">&quot;DEBUG_END&quot;</span>
    markers only when the <span class="Li">&quot;DEBUG&quot;</span> environment
    variable exists. That means that when
    <span class="Li">&quot;DEBUG&quot;</span> does exist, the code above should
    be passed through the filter unchanged. The marker lines can also be passed
    through as-is, because the Perl parser will see them as comment lines. When
    <span class="Li">&quot;DEBUG&quot;</span> isn't set, we need a way to
    disable the debug code. A simple way to achieve that is to convert the lines
    between the two markers into comments:</p>
<p class="Pp"></p>
<pre>    ## DEBUG_BEGIN
    #if ($year &gt; 1999) {
    #     warn &quot;Debug: millennium bug in year $year\n&quot;;
    #}
    ## DEBUG_END
</pre>
<p class="Pp">Here is the complete Debug filter:</p>
<p class="Pp"></p>
<pre>    package Debug;
    use strict;
    use warnings;
    use Filter::Util::Call;
    use constant TRUE =&gt; 1;
    use constant FALSE =&gt; 0;
    sub import {
       my ($type) = @_;
       my (%context) = (
         Enabled =&gt; defined $ENV{DEBUG},
         InTraceBlock =&gt; FALSE,
         Filename =&gt; (caller)[1],
         LineNo =&gt; 0,
         LastBegin =&gt; 0,
       );
       filter_add(bless \%context);
    }
    sub Die {
       my ($self) = shift;
       my ($message) = shift;
       my ($line_no) = shift || $self-&gt;{LastBegin};
       die &quot;$message at $self-&gt;{Filename} line $line_no.\n&quot;
    }
    sub filter {
       my ($self) = @_;
       my ($status);
       $status = filter_read();
       ++ $self-&gt;{LineNo};
       # deal with EOF/error first
       if ($status &lt;= 0) {
           $self-&gt;Die(&quot;DEBUG_BEGIN has no DEBUG_END&quot;)
               if $self-&gt;{InTraceBlock};
           return $status;
       }
       if ($self-&gt;{InTraceBlock}) {
          if (/^\s*##\s*DEBUG_BEGIN/ ) {
              $self-&gt;Die(&quot;Nested DEBUG_BEGIN&quot;, $self-&gt;{LineNo})
          } elsif (/^\s*##\s*DEBUG_END/) {
              $self-&gt;{InTraceBlock} = FALSE;
          }
          # comment out the debug lines when the filter is disabled
          s/^/#/ if ! $self-&gt;{Enabled};
       } elsif ( /^\s*##\s*DEBUG_BEGIN/ ) {
          $self-&gt;{InTraceBlock} = TRUE;
          $self-&gt;{LastBegin} = $self-&gt;{LineNo};
       } elsif ( /^\s*##\s*DEBUG_END/ ) {
          $self-&gt;Die(&quot;DEBUG_END has no DEBUG_BEGIN&quot;, $self-&gt;{LineNo});
       }
       return $status;
    }
    1;
</pre>
<p class="Pp">The big difference between this filter and the previous example is
    the use of context data in the filter object. The filter object is based on
    a hash reference, and is used to keep various pieces of context information
    between calls to the filter function. All but two of the hash fields are
    used for error reporting. The first of those two, Enabled, is used by the
    filter to determine whether the debugging code should be given to the Perl
    parser. The second, InTraceBlock, is true when the filter has encountered a
    <span class="Li">&quot;DEBUG_BEGIN&quot;</span> line, but has not yet
    encountered the following <span class="Li">&quot;DEBUG_END&quot;</span>
    line.</p>
<p class="Pp">If you ignore all the error checking that most of the code does,
    the essence of the filter is as follows:</p>
<p class="Pp"></p>
<pre>    sub filter {
       my ($self) = @_;
       my ($status);
       $status = filter_read();
       # deal with EOF/error first
       return $status if $status &lt;= 0;
       if ($self-&gt;{InTraceBlock}) {
          if (/^\s*##\s*DEBUG_END/) {
             $self-&gt;{InTraceBlock} = FALSE
          }
          # comment out debug lines when the filter is disabled
          s/^/#/ if ! $self-&gt;{Enabled};
       } elsif ( /^\s*##\s*DEBUG_BEGIN/ ) {
          $self-&gt;{InTraceBlock} = TRUE;
       }
       return $status;
    }
</pre>
<p class="Pp">Be warned: just as the C-preprocessor doesn't know C, the Debug
    filter doesn't know Perl. It can be fooled quite easily:</p>
<p class="Pp"></p>
<pre>    print &lt;&lt;EOM;
    ##DEBUG_BEGIN
    EOM
</pre>
<p class="Pp">Such things aside, you can see that a lot can be achieved with a
    modest amount of code.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONCLUSION"><a class="permalink" href="#CONCLUSION">CONCLUSION</a></h1>
<p class="Pp">You now have better understanding of what a source filter is, and
    you might even have a possible use for them. If you feel like playing with
    source filters but need a bit of inspiration, here are some extra features
    you could add to the Debug filter.</p>
<p class="Pp">First, an easy one. Rather than having debugging code that is
    all-or-nothing, it would be much more useful to be able to control which
    specific blocks of debugging code get included. Try extending the syntax for
    debug blocks to allow each to be identified. The contents of the
    <span class="Li">&quot;DEBUG&quot;</span> environment variable can then be
    used to control which blocks get included.</p>
<p class="Pp">Once you can identify individual blocks, try allowing them to be
    nested. That isn't difficult either.</p>
<p class="Pp">Here is an interesting idea that doesn't involve the Debug filter.
    Currently Perl subroutines have fairly limited support for formal parameter
    lists. You can specify the number of parameters and their type, but you
    still have to manually take them out of the <span class="Li">@_</span> array
    yourself. Write a source filter that allows you to have a named parameter
    list. Such a filter would turn this:</p>
<p class="Pp"></p>
<pre>    sub MySub ($first, $second, @rest) { ... }
</pre>
<p class="Pp">into this:</p>
<p class="Pp"></p>
<pre>    sub MySub($$@) {
       my ($first) = shift;
       my ($second) = shift;
       my (@rest) = @_;
       ...
    }
</pre>
<p class="Pp">Finally, if you feel like a real challenge, have a go at writing a
    full-blown Perl macro preprocessor as a source filter. Borrow the useful
    features from the C preprocessor and any other macro processors you know.
    The tricky bit will be choosing how much knowledge of Perl's syntax you want
    your filter to have.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LIMITATIONS"><a class="permalink" href="#LIMITATIONS">LIMITATIONS</a></h1>
<p class="Pp">Source filters only work on the string level, thus are highly
    limited in its ability to change source code on the fly. It cannot detect
    comments, quoted strings, heredocs, it is no replacement for a real parser.
    The only stable usage for source filters are encryption, compression, or the
    byteloader, to translate binary code back to source code.</p>
<p class="Pp">See for example the limitations in Switch, which uses source
    filters, and thus is does not work inside a string eval, the presence of
    regexes with embedded newlines that are specified with raw
    <span class="Li">&quot;/.../&quot;</span> delimiters and don't have a
    modifier <span class="Li">&quot;//x&quot;</span> are indistinguishable from
    code chunks beginning with the division operator
    <span class="Li">&quot;/&quot;</span>. As a workaround you must use
    <span class="Li">&quot;m/.../&quot;</span> or
    <span class="Li">&quot;m?...?&quot;</span> for such patterns. Also, the
    presence of regexes specified with raw
    <span class="Li">&quot;?...?&quot;</span> delimiters may cause mysterious
    errors. The workaround is to use <span class="Li">&quot;m?...?&quot;</span>
    instead. See &lt;https://metacpan.org/pod/Switch#LIMITATIONS&gt;.</p>
<p class="Pp">Currently the content of the
    <span class="Li">&quot;__DATA__&quot;</span> block is not filtered.</p>
<p class="Pp">Currently internal buffer lengths are limited to 32-bit only.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="THINGS_TO_LOOK_OUT_FOR"><a class="permalink" href="#THINGS_TO_LOOK_OUT_FOR">THINGS
  TO LOOK OUT FOR</a></h1>
<dl class="Bl-tag">
  <dt id="Some"><a class="permalink" href="#Some">Some Filters Clobber the
    &quot;DATA&quot; Handle</a></dt>
  <dd>Some source filters use the <span class="Li">&quot;DATA&quot;</span>
      handle to read the calling program. When using these source filters you
      cannot rely on this handle, nor expect any particular kind of behavior
      when operating on it. Filters based on Filter::Util::Call (and therefore
      Filter::Simple) do not alter the <span class="Li">&quot;DATA&quot;</span>
      filehandle, but on the other hand totally ignore the text after
      <span class="Li">&quot;__DATA__&quot;</span>.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="REQUIREMENTS"><a class="permalink" href="#REQUIREMENTS">REQUIREMENTS</a></h1>
<p class="Pp">The Source Filters distribution is available on CPAN, in</p>
<p class="Pp"></p>
<pre>    CPAN/modules/by-module/Filter
</pre>
<p class="Pp">Starting from Perl 5.8 Filter::Util::Call (the core part of the
    Source Filters distribution) is part of the standard Perl distribution. Also
    included is a friendlier interface called Filter::Simple, by Damian
  Conway.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Paul Marquess &lt;Paul.Marquess@btinternet.com&gt;</p>
<p class="Pp">Reini Urban &lt;rurban@cpan.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Copyrights"><a class="permalink" href="#Copyrights">Copyrights</a></h1>
<p class="Pp">The first version of this article originally appeared in The Perl
    Journal #11, and is copyright 1998 The Perl Journal. It appears courtesy of
    Jon Orwant and The Perl Journal. This document may be distributed under the
    same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os">perl v5.34.1</td>
  </tr>
</table>
</body>
</html>

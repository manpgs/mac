<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   t
       Title: git-rebase
      Author: [FIXME: author] [see http://www.docbook.org/tdg5/en/html/author]
   Generator: DocBook XSL Stylesheets vsnapshot <http://docbook.sf.net/>
        Date: 12/12/2022
      Manual: Git Manual
      Source: Git 2.39.0
    Language: English
   -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>GIT-REBASE(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">GIT-REBASE(1)</td>
    <td class="head-vol"><a href=".">Git Manual</a></td>
    <td class="head-rtitle">GIT-REBASE(1)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">git-rebase - Reapply commits on top of another base tip</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre><i>git rebase</i> [-i | --interactive] [&lt;options&gt;] [--exec &lt;cmd&gt;]
        [--onto &lt;newbase&gt; | --keep-base] [&lt;upstream&gt; [&lt;branch&gt;]]
<i>git rebase</i> [-i | --interactive] [&lt;options&gt;] [--exec &lt;cmd&gt;] [--onto &lt;newbase&gt;]
        --root [&lt;branch&gt;]
<i>git rebase</i> (--continue | --skip | --abort | --quit | --edit-todo | --show-current-patch)</pre>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">If <b>&lt;branch&gt;</b> is specified, <b>git rebase</b> will
    perform an automatic <b>git switch &lt;branch&gt;</b> before doing anything
    else. Otherwise it remains on the current branch.</p>
<p class="Pp">If <b>&lt;upstream&gt;</b> is not specified, the upstream
    configured in <b>branch.&lt;name&gt;.remote</b> and
    <b>branch.&lt;name&gt;.merge</b> options will be used (see
    <b>git-config</b>(1) for details) and the <b>--fork-point</b> option is
    assumed. If you are currently not on any branch or if the current branch
    does not have a configured upstream, the rebase will abort.</p>
<p class="Pp">All changes made by commits in the current branch but that are not
    in <b>&lt;upstream&gt;</b> are saved to a temporary area. This is the same
    set of commits that would be shown by <b>git log &lt;upstream&gt;..HEAD</b>;
    or by <b>git log 'fork_point'..HEAD</b>, if <b>--fork-point</b> is active
    (see the description on <b>--fork-point</b> below); or by <b>git log
    HEAD</b>, if the <b>--root</b> option is specified.</p>
<p class="Pp">The current branch is reset to <b>&lt;upstream&gt;</b> or
    <b>&lt;newbase&gt;</b> if the <b>--onto</b> option was supplied. This has
    the exact same effect as <b>git reset --hard &lt;upstream&gt;</b> (or
    <b>&lt;newbase&gt;</b>). <b>ORIG_HEAD</b> is set to point at the tip of the
    branch before the reset.</p>
<p class="Pp">The commits that were previously saved into the temporary area are
    then reapplied to the current branch, one by one, in order. Note that any
    commits in <b>HEAD</b> which introduce the same textual changes as a commit
    in <b>HEAD..&lt;upstream&gt;</b> are omitted (i.e., a patch already accepted
    upstream with a different commit message or timestamp will be skipped).</p>
<p class="Pp">It is possible that a merge failure will prevent this process from
    being completely automatic. You will have to resolve any such merge failure
    and run <b>git rebase --continue</b>. Another option is to bypass the commit
    that caused the merge failure with <b>git rebase --skip</b>. To check out
    the original <b>&lt;branch&gt;</b> and remove the <b>.git/rebase-apply</b>
    working files, use the command <b>git rebase --abort</b> instead.</p>
<p class="Pp">Assume the following history exists and the current branch is
    &quot;topic&quot;:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
          A---B---C topic
         /
    D---E---F---G master</pre>
</div>
<p class="Pp"></p>
<p class="Pp">From this point, the result of either of the following
  commands:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>git rebase master
git rebase master topic</pre>
</div>
<p class="Pp">would be:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
                  A'--B'--C' topic
                 /
    D---E---F---G master</pre>
</div>
<p class="Pp"></p>
<p class="Pp"><b>NOTE:</b> The latter form is just a short-hand of <b>git
    checkout topic</b> followed by <b>git rebase master</b>. When rebase exits
    <b>topic</b> will remain the checked-out branch.</p>
<p class="Pp">If the upstream branch already contains a change you have made
    (e.g., because you mailed a patch which was applied upstream), then that
    commit will be skipped and warnings will be issued (if the <i>merge</i>
    backend is used). For example, running <b>git rebase master</b> on the
    following history (in which <b>A'</b> and <b>A</b> introduce the same set of
    changes, but have different committer information):</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
          A---B---C topic
         /
    D---E---A'---F master</pre>
</div>
<p class="Pp"></p>
<p class="Pp">will result in:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
                   B'---C' topic
                  /
    D---E---A'---F master</pre>
</div>
<p class="Pp"></p>
<p class="Pp">Here is how you would transplant a topic branch based on one
    branch to another, to pretend that you forked the topic branch from the
    latter branch, using <b>rebase --onto</b>.</p>
<p class="Pp">First let&#x2019;s assume your <i>topic</i> is based on branch
    <i>next</i>. For example, a feature developed in <i>topic</i> depends on
    some functionality which is found in <i>next</i>.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
    o---o---o---o---o  master
         \
          o---o---o---o---o  next
                           \
                            o---o---o  topic</pre>
</div>
<p class="Pp"></p>
<p class="Pp">We want to make <i>topic</i> forked from branch <i>master</i>; for
    example, because the functionality on which <i>topic</i> depends was merged
    into the more stable <i>master</i> branch. We want our tree to look like
    this:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
    o---o---o---o---o  master
        |            \
        |             o'--o'--o'  topic
         \
          o---o---o---o---o  next</pre>
</div>
<p class="Pp"></p>
<p class="Pp">We can get this using the following command:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>git rebase --onto master next topic</pre>
</div>
<p class="Pp">Another example of --onto option is to rebase part of a branch. If
    we have the following situation:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
                            H---I---J topicB
                           /
                  E---F---G  topicA
                 /
    A---B---C---D  master</pre>
</div>
<p class="Pp"></p>
<p class="Pp">then the command</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>git rebase --onto master topicA topicB</pre>
</div>
<p class="Pp">would result in:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
                 H'--I'--J'  topicB
                /
                | E---F---G  topicA
                |/
    A---B---C---D  master</pre>
</div>
<p class="Pp"></p>
<p class="Pp">This is useful when topicB does not depend on topicA.</p>
<p class="Pp">A range of commits could also be removed with rebase. If we have
    the following situation:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
    E---F---G---H---I---J  topicA</pre>
</div>
<p class="Pp"></p>
<p class="Pp">then the command</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>git rebase --onto topicA~5 topicA~3 topicA</pre>
</div>
<p class="Pp">would result in the removal of commits F and G:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
    E---H'---I'---J'  topicA</pre>
</div>
<p class="Pp"></p>
<p class="Pp">This is useful if F and G were flawed in some way, or should not
    be part of topicA. Note that the argument to <b>--onto</b> and the
    <b>&lt;upstream&gt;</b> parameter can be any valid commit-ish.</p>
<p class="Pp">In case of conflict, <b>git rebase</b> will stop at the first
    problematic commit and leave conflict markers in the tree. You can use
    <b>git diff</b> to locate the markers (&lt;&lt;&lt;&lt;&lt;&lt;) and make
    edits to resolve the conflict. For each file you edit, you need to tell Git
    that the conflict has been resolved, typically this would be done with</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>git add &lt;filename&gt;</pre>
</div>
<p class="Pp">After resolving the conflict manually and updating the index with
    the desired resolution, you can continue the rebasing process with</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>git rebase --continue</pre>
</div>
<p class="Pp">Alternatively, you can undo the <i>git rebase</i> with</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>git rebase --abort</pre>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="OPTIONS"><a class="permalink" href="#OPTIONS">OPTIONS</a></h1>
<p class="Pp">--onto &lt;newbase&gt;</p>
<div class="Bd-indent">Starting point at which to create the new commits. If the
  <b>--onto</b> option is not specified, the starting point is
  <b>&lt;upstream&gt;</b>. May be any valid commit, and not just an existing
  branch name.
<p class="Pp">As a special case, you may use &quot;A...B&quot; as a shortcut for
    the merge base of A and B if there is exactly one merge base. You can leave
    out at most one of A and B, in which case it defaults to HEAD.</p>
</div>
<p class="Pp">--keep-base</p>
<div class="Bd-indent">Set the starting point at which to create the new commits
  to the merge base of <b>&lt;upstream&gt;</b> and <b>&lt;branch&gt;</b>.
  Running <b>git rebase --keep-base &lt;upstream&gt; &lt;branch&gt;</b> is
  equivalent to running <b>git rebase --reapply-cherry-picks --no-fork-point
  --onto &lt;upstream&gt;...&lt;branch&gt; &lt;upstream&gt; &lt;branch&gt;</b>.
<p class="Pp">This option is useful in the case where one is developing a
    feature on top of an upstream branch. While the feature is being worked on,
    the upstream branch may advance and it may not be the best idea to keep
    rebasing on top of the upstream but to keep the base commit as-is. As the
    base commit is unchanged this option implies <b>--reapply-cherry-picks</b>
    to avoid losing commits.</p>
<p class="Pp">Although both this option and <b>--fork-point</b> find the merge
    base between <b>&lt;upstream&gt;</b> and <b>&lt;branch&gt;</b>, this option
    uses the merge base as the <i>starting point</i> on which new commits will
    be created, whereas <b>--fork-point</b> uses the merge base to determine the
    <i>set of commits</i> which will be rebased.</p>
<p class="Pp">See also INCOMPATIBLE OPTIONS below.</p>
</div>
<p class="Pp">&lt;upstream&gt;</p>
<div class="Bd-indent">Upstream branch to compare against. May be any valid
  commit, not just an existing branch name. Defaults to the configured upstream
  for the current branch.</div>
<p class="Pp">&lt;branch&gt;</p>
<div class="Bd-indent">Working branch; defaults to <b>HEAD</b>.</div>
<p class="Pp">--continue</p>
<div class="Bd-indent">Restart the rebasing process after having resolved a
  merge conflict.</div>
<p class="Pp">--abort</p>
<div class="Bd-indent">Abort the rebase operation and reset HEAD to the original
  branch. If <b>&lt;branch&gt;</b> was provided when the rebase operation was
  started, then <b>HEAD</b> will be reset to <b>&lt;branch&gt;</b>. Otherwise
  <b>HEAD</b> will be reset to where it was when the rebase operation was
  started.</div>
<p class="Pp">--quit</p>
<div class="Bd-indent">Abort the rebase operation but <b>HEAD</b> is not reset
  back to the original branch. The index and working tree are also left
  unchanged as a result. If a temporary stash entry was created using
  <b>--autostash</b>, it will be saved to the stash list.</div>
<p class="Pp">--apply</p>
<div class="Bd-indent">Use applying strategies to rebase (calling <b>git-am</b>
  internally). This option may become a no-op in the future once the merge
  backend handles everything the apply one does.
<p class="Pp">See also INCOMPATIBLE OPTIONS below.</p>
</div>
<p class="Pp">--empty={drop,keep,ask}</p>
<div class="Bd-indent">How to handle commits that are not empty to start and are
  not clean cherry-picks of any upstream commit, but which become empty after
  rebasing (because they contain a subset of already upstream changes). With
  drop (the default), commits that become empty are dropped. With keep, such
  commits are kept. With ask (implied by <b>--interactive</b>), the rebase will
  halt when an empty commit is applied allowing you to choose whether to drop
  it, edit files more, or just commit the empty changes. Other options, like
  <b>--exec</b>, will use the default of drop unless
  <b>-i</b>/<b>--interactive</b> is explicitly specified.
<p class="Pp">Note that commits which start empty are kept (unless
    <b>--no-keep-empty</b> is specified), and commits which are clean
    cherry-picks (as determined by <b>git log --cherry-mark ...</b>) are
    detected and dropped as a preliminary step (unless
    <b>--reapply-cherry-picks</b> or <b>--keep-base</b> is passed).</p>
<p class="Pp">See also INCOMPATIBLE OPTIONS below.</p>
</div>
<p class="Pp">--no-keep-empty, --keep-empty</p>
<div class="Bd-indent">Do not keep commits that start empty before the rebase
  (i.e. that do not change anything from its parent) in the result. The default
  is to keep commits which start empty, since creating such commits requires
  passing the <b>--allow-empty</b> override flag to <b>git commit</b>,
  signifying that a user is very intentionally creating such a commit and thus
  wants to keep it.
<p class="Pp">Usage of this flag will probably be rare, since you can get rid of
    commits that start empty by just firing up an interactive rebase and
    removing the lines corresponding to the commits you don&#x2019;t want. This
    flag exists as a convenient shortcut, such as for cases where external tools
    generate many empty commits and you want them all removed.</p>
<p class="Pp">For commits which do not start empty but become empty after
    rebasing, see the <b>--empty</b> flag.</p>
<p class="Pp">See also INCOMPATIBLE OPTIONS below.</p>
</div>
<p class="Pp">--reapply-cherry-picks, --no-reapply-cherry-picks</p>
<div class="Bd-indent">Reapply all clean cherry-picks of any upstream commit
  instead of preemptively dropping them. (If these commits then become empty
  after rebasing, because they contain a subset of already upstream changes, the
  behavior towards them is controlled by the <b>--empty</b> flag.)
<p class="Pp">In the absence of <b>--keep-base</b> (or if
    <b>--no-reapply-cherry-picks</b> is given), these commits will be
    automatically dropped. Because this necessitates reading all upstream
    commits, this can be expensive in repositories with a large number of
    upstream commits that need to be read. When using the <i>merge</i> backend,
    warnings will be issued for each dropped commit (unless <b>--quiet</b> is
    given). Advice will also be issued unless <b>advice.skippedCherryPicks</b>
    is set to false (see <b>git-config</b>(1)).</p>
</div>
<p class="Pp">+ <b>--reapply-cherry-picks</b> allows rebase to forgo reading all
    upstream commits, potentially improving performance.</p>
<p class="Pp">+ See also INCOMPATIBLE OPTIONS below.</p>
<p class="Pp">--allow-empty-message</p>
<div class="Bd-indent">No-op. Rebasing commits with an empty message used to
  fail and this option would override that behavior, allowing commits with empty
  messages to be rebased. Now commits with an empty message do not cause
  rebasing to halt.
<p class="Pp">See also INCOMPATIBLE OPTIONS below.</p>
</div>
<p class="Pp">--skip</p>
<div class="Bd-indent">Restart the rebasing process by skipping the current
  patch.</div>
<p class="Pp">--edit-todo</p>
<div class="Bd-indent">Edit the todo list during an interactive rebase.</div>
<p class="Pp">--show-current-patch</p>
<div class="Bd-indent">Show the current patch in an interactive rebase or when
  rebase is stopped because of conflicts. This is the equivalent of <b>git show
  REBASE_HEAD</b>.</div>
<p class="Pp">-m, --merge</p>
<div class="Bd-indent">Using merging strategies to rebase (default).
<p class="Pp">Note that a rebase merge works by replaying each commit from the
    working branch on top of the <b>&lt;upstream&gt;</b> branch. Because of
    this, when a merge conflict happens, the side reported as <i>ours</i> is the
    so-far rebased series, starting with <b>&lt;upstream&gt;</b>, and
    <i>theirs</i> is the working branch. In other words, the sides are
  swapped.</p>
<p class="Pp">See also INCOMPATIBLE OPTIONS below.</p>
</div>
<p class="Pp">-s &lt;strategy&gt;, --strategy=&lt;strategy&gt;</p>
<div class="Bd-indent">Use the given merge strategy, instead of the default
  <b>ort</b>. This implies <b>--merge</b>.
<p class="Pp">Because <b>git rebase</b> replays each commit from the working
    branch on top of the <b>&lt;upstream&gt;</b> branch using the given
    strategy, using the <b>ours</b> strategy simply empties all patches from the
    <b>&lt;branch&gt;</b>, which makes little sense.</p>
<p class="Pp">See also INCOMPATIBLE OPTIONS below.</p>
</div>
<p class="Pp">-X &lt;strategy-option&gt;,
    --strategy-option=&lt;strategy-option&gt;</p>
<div class="Bd-indent">Pass the &lt;strategy-option&gt; through to the merge
  strategy. This implies <b>--merge</b> and, if no strategy has been specified,
  <b>-s ort</b>. Note the reversal of <i>ours</i> and <i>theirs</i> as noted
  above for the <b>-m</b> option.
<p class="Pp">See also INCOMPATIBLE OPTIONS below.</p>
</div>
<p class="Pp">--rerere-autoupdate, --no-rerere-autoupdate</p>
<div class="Bd-indent">After the rerere mechanism reuses a recorded resolution
  on the current conflict to update the files in the working tree, allow it to
  also update the index with the result of resolution.
  <b>--no-rerere-autoupdate</b> is a good way to double-check what <b>rerere</b>
  did and catch potential mismerges, before committing the result to the index
  with a separate <b>git add</b>.</div>
<p class="Pp">-S[&lt;keyid&gt;], --gpg-sign[=&lt;keyid&gt;], --no-gpg-sign</p>
<div class="Bd-indent">GPG-sign commits. The <b>keyid</b> argument is optional
  and defaults to the committer identity; if specified, it must be stuck to the
  option without a space. <b>--no-gpg-sign</b> is useful to countermand both
  <b>commit.gpgSign</b> configuration variable, and earlier
  <b>--gpg-sign</b>.</div>
<p class="Pp">-q, --quiet</p>
<div class="Bd-indent">Be quiet. Implies <b>--no-stat</b>.</div>
<p class="Pp">-v, --verbose</p>
<div class="Bd-indent">Be verbose. Implies <b>--stat</b>.</div>
<p class="Pp">--stat</p>
<div class="Bd-indent">Show a diffstat of what changed upstream since the last
  rebase. The diffstat is also controlled by the configuration option
  rebase.stat.</div>
<p class="Pp">-n, --no-stat</p>
<div class="Bd-indent">Do not show a diffstat as part of the rebase
  process.</div>
<p class="Pp">--no-verify</p>
<div class="Bd-indent">This option bypasses the pre-rebase hook. See also
  <b>githooks</b>(5).</div>
<p class="Pp">--verify</p>
<div class="Bd-indent">Allows the pre-rebase hook to run, which is the default.
  This option can be used to override <b>--no-verify</b>. See also
  <b>githooks</b>(5).</div>
<p class="Pp">-C&lt;n&gt;</p>
<div class="Bd-indent">Ensure at least <b>&lt;n&gt;</b> lines of surrounding
  context match before and after each change. When fewer lines of surrounding
  context exist they all must match. By default no context is ever ignored.
  Implies <b>--apply</b>.
<p class="Pp">See also INCOMPATIBLE OPTIONS below.</p>
</div>
<p class="Pp">--no-ff, --force-rebase, -f</p>
<div class="Bd-indent">Individually replay all rebased commits instead of
  fast-forwarding over the unchanged ones. This ensures that the entire history
  of the rebased branch is composed of new commits.
<p class="Pp">You may find this helpful after reverting a topic branch merge, as
    this option recreates the topic branch with fresh commits so it can be
    remerged successfully without needing to &quot;revert the reversion&quot;
    (see the <b>revert-a-faulty-merge How-To</b>[1] for details).</p>
</div>
<p class="Pp">--fork-point, --no-fork-point</p>
<div class="Bd-indent">Use reflog to find a better common ancestor between
  <b>&lt;upstream&gt;</b> and <b>&lt;branch&gt;</b> when calculating which
  commits have been introduced by <b>&lt;branch&gt;</b>.
<p class="Pp">When <b>--fork-point</b> is active, <i>fork_point</i> will be used
    instead of <b>&lt;upstream&gt;</b> to calculate the set of commits to
    rebase, where <i>fork_point</i> is the result of <b>git merge-base
    --fork-point &lt;upstream&gt; &lt;branch&gt;</b> command (see
    <b>git-merge-base</b>(1)). If <i>fork_point</i> ends up being empty, the
    <b>&lt;upstream&gt;</b> will be used as a fallback.</p>
<p class="Pp">If <b>&lt;upstream&gt;</b> or <b>--keep-base</b> is given on the
    command line, then the default is <b>--no-fork-point</b>, otherwise the
    default is <b>--fork-point</b>. See also <b>rebase.forkpoint</b> in
    <b>git-config</b>(1).</p>
<p class="Pp">If your branch was based on <b>&lt;upstream&gt;</b> but
    <b>&lt;upstream&gt;</b> was rewound and your branch contains commits which
    were dropped, this option can be used with <b>--keep-base</b> in order to
    drop those commits from your branch.</p>
<p class="Pp">See also INCOMPATIBLE OPTIONS below.</p>
</div>
<p class="Pp">--ignore-whitespace</p>
<div class="Bd-indent">Ignore whitespace differences when trying to reconcile
  differences. Currently, each backend implements an approximation of this
  behavior:
<p class="Pp">apply backend</p>
<div class="Bd-indent">When applying a patch, ignore changes in whitespace in
  context lines. Unfortunately, this means that if the &quot;old&quot; lines
  being replaced by the patch differ only in whitespace from the existing file,
  you will get a merge conflict instead of a successful patch application.</div>
<p class="Pp">merge backend</p>
<div class="Bd-indent">Treat lines with only whitespace changes as unchanged
  when merging. Unfortunately, this means that any patch hunks that were
  intended to modify whitespace and nothing else will be dropped, even if the
  other side had no changes that conflicted.</div>
</div>
<p class="Pp">--whitespace=&lt;option&gt;</p>
<div class="Bd-indent">This flag is passed to the <b>git apply</b> program (see
  <b>git-apply</b>(1)) that applies the patch. Implies <b>--apply</b>.
<p class="Pp">See also INCOMPATIBLE OPTIONS below.</p>
</div>
<p class="Pp">--committer-date-is-author-date</p>
<div class="Bd-indent">Instead of using the current time as the committer date,
  use the author date of the commit being rebased as the committer date. This
  option implies <b>--force-rebase</b>.</div>
<p class="Pp">--ignore-date, --reset-author-date</p>
<div class="Bd-indent">Instead of using the author date of the original commit,
  use the current time as the author date of the rebased commit. This option
  implies <b>--force-rebase</b>.
<p class="Pp">See also INCOMPATIBLE OPTIONS below.</p>
</div>
<p class="Pp">--signoff</p>
<div class="Bd-indent">Add a <b>Signed-off-by</b> trailer to all the rebased
  commits. Note that if <b>--interactive</b> is given then only commits marked
  to be picked, edited or reworded will have the trailer added.
<p class="Pp">See also INCOMPATIBLE OPTIONS below.</p>
</div>
<p class="Pp">-i, --interactive</p>
<div class="Bd-indent">Make a list of the commits which are about to be rebased.
  Let the user edit that list before rebasing. This mode can also be used to
  split commits (see SPLITTING COMMITS below).
<p class="Pp">The commit list format can be changed by setting the configuration
    option rebase.instructionFormat. A customized instruction format will
    automatically have the long commit hash prepended to the format.</p>
<p class="Pp">See also INCOMPATIBLE OPTIONS below.</p>
</div>
<p class="Pp">-r, --rebase-merges[=(rebase-cousins|no-rebase-cousins)]</p>
<div class="Bd-indent">By default, a rebase will simply drop merge commits from
  the todo list, and put the rebased commits into a single, linear branch. With
  <b>--rebase-merges</b>, the rebase will instead try to preserve the branching
  structure within the commits that are to be rebased, by recreating the merge
  commits. Any resolved merge conflicts or manual amendments in these merge
  commits will have to be resolved/re-applied manually.
<p class="Pp">By default, or when <b>no-rebase-cousins</b> was specified,
    commits which do not have <b>&lt;upstream&gt;</b> as direct ancestor will
    keep their original branch point, i.e. commits that would be excluded by
    <b>git-log</b>(1)'s <b>--ancestry-path</b> option will keep their original
    ancestry by default. If the <b>rebase-cousins</b> mode is turned on, such
    commits are instead rebased onto <b>&lt;upstream&gt;</b> (or
    <b>&lt;onto&gt;</b>, if specified).</p>
<p class="Pp">It is currently only possible to recreate the merge commits using
    the <b>ort</b> merge strategy; different merge strategies can be used only
    via explicit <b>exec git merge -s &lt;strategy&gt; [...]</b> commands.</p>
<p class="Pp">See also REBASING MERGES and INCOMPATIBLE OPTIONS below.</p>
</div>
<p class="Pp">-x &lt;cmd&gt;, --exec &lt;cmd&gt;</p>
<div class="Bd-indent">Append &quot;exec &lt;cmd&gt;&quot; after each line
  creating a commit in the final history. <b>&lt;cmd&gt;</b> will be interpreted
  as one or more shell commands. Any command that fails will interrupt the
  rebase, with exit code 1.
<p class="Pp">You may execute several commands by either using one instance of
    <b>--exec</b> with several commands:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>git rebase -i --exec &quot;cmd1 &amp;&amp; cmd2 &amp;&amp; ...&quot;</pre>
</div>
<p class="Pp">or by giving more than one <b>--exec</b>:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>git rebase -i --exec &quot;cmd1&quot; --exec &quot;cmd2&quot; --exec ...</pre>
</div>
<p class="Pp">If <b>--autosquash</b> is used, <b>exec</b> lines will not be
    appended for the intermediate commits, and will only appear at the end of
    each squash/fixup series.</p>
<p class="Pp">This uses the <b>--interactive</b> machinery internally, but it
    can be run without an explicit <b>--interactive</b>.</p>
<p class="Pp">See also INCOMPATIBLE OPTIONS below.</p>
</div>
<p class="Pp">--root</p>
<div class="Bd-indent">Rebase all commits reachable from <b>&lt;branch&gt;</b>,
  instead of limiting them with an <b>&lt;upstream&gt;</b>. This allows you to
  rebase the root commit(s) on a branch. When used with <b>--onto</b>, it will
  skip changes already contained in <b>&lt;newbase&gt;</b> (instead of
  <b>&lt;upstream&gt;</b>) whereas without <b>--onto</b> it will operate on
  every change.
<p class="Pp">See also INCOMPATIBLE OPTIONS below.</p>
</div>
<p class="Pp">--autosquash, --no-autosquash</p>
<div class="Bd-indent">When the commit log message begins with &quot;squash!
  ...&quot; or &quot;fixup! ...&quot; or &quot;amend! ...&quot;, and there is
  already a commit in the todo list that matches the same <b>...</b>,
  automatically modify the todo list of <b>rebase -i</b>, so that the commit
  marked for squashing comes right after the commit to be modified, and change
  the action of the moved commit from <b>pick</b> to <b>squash</b> or
  <b>fixup</b> or <b>fixup -C</b> respectively. A commit matches the <b>...</b>
  if the commit subject matches, or if the <b>...</b> refers to the
  commit&#x2019;s hash. As a fall-back, partial matches of the commit subject
  work, too. The recommended way to create fixup/amend/squash commits is by
  using the <b>--fixup</b>, <b>--fixup=amend:</b> or <b>--fixup=reword:</b> and
  <b>--squash</b> options respectively of <b>git-commit</b>(1).
<p class="Pp">If the <b>--autosquash</b> option is enabled by default using the
    configuration variable <b>rebase.autoSquash</b>, this option can be used to
    override and disable this setting.</p>
<p class="Pp">See also INCOMPATIBLE OPTIONS below.</p>
</div>
<p class="Pp">--autostash, --no-autostash</p>
<div class="Bd-indent">Automatically create a temporary stash entry before the
  operation begins, and apply it after the operation ends. This means that you
  can run rebase on a dirty worktree. However, use with care: the final stash
  application after a successful rebase might result in non-trivial
  conflicts.</div>
<p class="Pp">--reschedule-failed-exec, --no-reschedule-failed-exec</p>
<div class="Bd-indent">Automatically reschedule <b>exec</b> commands that
  failed. This only makes sense in interactive mode (or when an <b>--exec</b>
  option was provided).
<p class="Pp">Even though this option applies once a rebase is started,
    it&#x2019;s set for the whole rebase at the start based on either the
    <b>rebase.rescheduleFailedExec</b> configuration (see <b>git-config</b>(1)
    or &quot;CONFIGURATION&quot; below) or whether this option is provided.
    Otherwise an explicit <b>--no-reschedule-failed-exec</b> at the start would
    be overridden by the presence of <b>rebase.rescheduleFailedExec=true</b>
    configuration.</p>
</div>
<p class="Pp">--update-refs, --no-update-refs</p>
<div class="Bd-indent">Automatically force-update any branches that point to
  commits that are being rebased. Any branches that are checked out in a
  worktree are not updated in this way.
<p class="Pp">If the configuration variable <b>rebase.updateRefs</b> is set,
    then this option can be used to override and disable this setting.</p>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="INCOMPATIBLE_OPTIONS"><a class="permalink" href="#INCOMPATIBLE_OPTIONS">INCOMPATIBLE
  OPTIONS</a></h1>
<p class="Pp">The following options:</p>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;--apply</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;--whitespace</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;-C</div>
<p class="Pp">are incompatible with the following options:</p>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;--merge</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;--strategy</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;--strategy-option</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;--allow-empty-message</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;--[no-]autosquash</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;--rebase-merges</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;--interactive</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;--exec</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;--no-keep-empty</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;--empty=</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;--reapply-cherry-picks</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;--edit-todo</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;--update-refs</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;--root when used in combination with --onto</div>
<p class="Pp">In addition, the following pairs of options are incompatible:</p>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;--keep-base and --onto</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;--keep-base and --root</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;--fork-point and --root</div>
</section>
<section class="Sh">
<h1 class="Sh" id="BEHAVIORAL_DIFFERENCES"><a class="permalink" href="#BEHAVIORAL_DIFFERENCES">BEHAVIORAL
  DIFFERENCES</a></h1>
<p class="Pp"><b>git rebase</b> has two primary backends: <i>apply</i> and
    <i>merge</i>. (The <i>apply</i> backend used to be known as the <i>am</i>
    backend, but the name led to confusion as it looks like a verb instead of a
    noun. Also, the <i>merge</i> backend used to be known as the interactive
    backend, but it is now used for non-interactive cases as well. Both were
    renamed based on lower-level functionality that underpinned each.) There are
    some subtle differences in how these two backends behave:</p>
<section class="Ss">
<h2 class="Ss" id="Empty_commits"><a class="permalink" href="#Empty_commits">Empty
  commits</a></h2>
<p class="Pp">The <i>apply</i> backend unfortunately drops intentionally empty
    commits, i.e. commits that started empty, though these are rare in practice.
    It also drops commits that become empty and has no option for controlling
    this behavior.</p>
<p class="Pp">The <i>merge</i> backend keeps intentionally empty commits by
    default (though with <b>-i</b> they are marked as empty in the todo list
    editor, or they can be dropped automatically with
  <b>--no-keep-empty</b>).</p>
<p class="Pp">Similar to the apply backend, by default the merge backend drops
    commits that become empty unless <b>-i</b>/<b>--interactive</b> is specified
    (in which case it stops and asks the user what to do). The merge backend
    also has an <b>--empty={drop,keep,ask}</b> option for changing the behavior
    of handling commits that become empty.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Directory_rename_detection"><a class="permalink" href="#Directory_rename_detection">Directory
  rename detection</a></h2>
<p class="Pp">Due to the lack of accurate tree information (arising from
    constructing fake ancestors with the limited information available in
    patches), directory rename detection is disabled in the <i>apply</i>
    backend. Disabled directory rename detection means that if one side of
    history renames a directory and the other adds new files to the old
    directory, then the new files will be left behind in the old directory
    without any warning at the time of rebasing that you may want to move these
    files into the new directory.</p>
<p class="Pp">Directory rename detection works with the <i>merge</i> backend to
    provide you warnings in such cases.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Context"><a class="permalink" href="#Context">Context</a></h2>
<p class="Pp">The <i>apply</i> backend works by creating a sequence of patches
    (by calling <b>format-patch</b> internally), and then applying the patches
    in sequence (calling <b>am</b> internally). Patches are composed of multiple
    hunks, each with line numbers, a context region, and the actual changes. The
    line numbers have to be taken with some fuzz, since the other side will
    likely have inserted or deleted lines earlier in the file. The context
    region is meant to help find how to adjust the line numbers in order to
    apply the changes to the right lines. However, if multiple areas of the code
    have the same surrounding lines of context, the wrong one can be picked.
    There are real-world cases where this has caused commits to be reapplied
    incorrectly with no conflicts reported. Setting <b>diff.context</b> to a
    larger value may prevent such types of problems, but increases the chance of
    spurious conflicts (since it will require more lines of matching context to
    apply).</p>
<p class="Pp">The <i>merge</i> backend works with a full copy of each relevant
    file, insulating it from these types of problems.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Labelling_of_conflicts_markers"><a class="permalink" href="#Labelling_of_conflicts_markers">Labelling
  of conflicts markers</a></h2>
<p class="Pp">When there are content conflicts, the merge machinery tries to
    annotate each side&#x2019;s conflict markers with the commits where the
    content came from. Since the <i>apply</i> backend drops the original
    information about the rebased commits and their parents (and instead
    generates new fake commits based off limited information in the generated
    patches), those commits cannot be identified; instead it has to fall back to
    a commit summary. Also, when <b>merge.conflictStyle</b> is set to
    <b>diff3</b> or <b>zdiff3</b>, the <i>apply</i> backend will use
    &quot;constructed merge base&quot; to label the content from the merge base,
    and thus provide no information about the merge base commit whatsoever.</p>
<p class="Pp">The <i>merge</i> backend works with the full commits on both sides
    of history and thus has no such limitations.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Hooks"><a class="permalink" href="#Hooks">Hooks</a></h2>
<p class="Pp">The <i>apply</i> backend has not traditionally called the
    post-commit hook, while the <i>merge</i> backend has. Both have called the
    post-checkout hook, though the <i>merge</i> backend has squelched its
    output. Further, both backends only call the post-checkout hook with the
    starting point commit of the rebase, not the intermediate commits nor the
    final commit. In each case, the calling of these hooks was by accident of
    implementation rather than by design (both backends were originally
    implemented as shell scripts and happened to invoke other commands like
    <b>git checkout</b> or <b>git commit</b> that would call the hooks). Both
    backends should have the same behavior, though it is not entirely clear
    which, if any, is correct. We will likely make rebase stop calling either of
    these hooks in the future.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Interruptability"><a class="permalink" href="#Interruptability">Interruptability</a></h2>
<p class="Pp">The <i>apply</i> backend has safety problems with an ill-timed
    interrupt; if the user presses Ctrl-C at the wrong time to try to abort the
    rebase, the rebase can enter a state where it cannot be aborted with a
    subsequent <b>git rebase --abort</b>. The <i>merge</i> backend does not
    appear to suffer from the same shortcoming. (See
    <b>https://lore.kernel.org/git/20200207132152.GC2868@szeder.dev/</b> for
    details.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Commit_Rewording"><a class="permalink" href="#Commit_Rewording">Commit
  Rewording</a></h2>
<p class="Pp">When a conflict occurs while rebasing, rebase stops and asks the
    user to resolve. Since the user may need to make notable changes while
    resolving conflicts, after conflicts are resolved and the user has run
    <b>git rebase --continue</b>, the rebase should open an editor and ask the
    user to update the commit message. The <i>merge</i> backend does this, while
    the <i>apply</i> backend blindly applies the original commit message.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Miscellaneous_differences"><a class="permalink" href="#Miscellaneous_differences">Miscellaneous
  differences</a></h2>
<p class="Pp">There are a few more behavioral differences that most folks would
    probably consider inconsequential but which are mentioned for
  completeness:</p>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;Reflog: The two backends will use different
  wording when describing the changes made in the reflog, though both will make
  use of the word &quot;rebase&quot;.</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;Progress, informational, and error messages: The
  two backends provide slightly different progress and informational messages.
  Also, the apply backend writes error messages (such as &quot;Your files would
  be overwritten...&quot;) to stdout, while the merge backend writes them to
  stderr.</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;State directories: The two backends keep their
  state in different directories under <b>.git/</b></div>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="MERGE_STRATEGIES"><a class="permalink" href="#MERGE_STRATEGIES">MERGE
  STRATEGIES</a></h1>
<p class="Pp">The merge mechanism (<b>git merge</b> and <b>git pull</b>
    commands) allows the backend <i>merge strategies</i> to be chosen with
    <b>-s</b> option. Some strategies can also take their own options, which can
    be passed by giving <b>-X&lt;option&gt;</b> arguments to <b>git merge</b>
    and/or <b>git pull</b>.</p>
<p class="Pp">ort</p>
<div class="Bd-indent">This is the default merge strategy when pulling or
  merging one branch. This strategy can only resolve two heads using a 3-way
  merge algorithm. When there is more than one common ancestor that can be used
  for 3-way merge, it creates a merged tree of the common ancestors and uses
  that as the reference tree for the 3-way merge. This has been reported to
  result in fewer merge conflicts without causing mismerges by tests done on
  actual merge commits taken from Linux 2.6 kernel development history.
  Additionally this strategy can detect and handle merges involving renames. It
  does not make use of detected copies. The name for this algorithm is an
  acronym (&quot;Ostensibly Recursive&#x2019;s Twin&quot;) and came from the
  fact that it was written as a replacement for the previous default algorithm,
  <b>recursive</b>.
<p class="Pp">The <i>ort</i> strategy can take the following options:</p>
<p class="Pp">ours</p>
<div class="Bd-indent">This option forces conflicting hunks to be auto-resolved
  cleanly by favoring <i>our</i> version. Changes from the other tree that do
  not conflict with our side are reflected in the merge result. For a binary
  file, the entire contents are taken from our side.
<p class="Pp">This should not be confused with the <i>ours</i> merge strategy,
    which does not even look at what the other tree contains at all. It discards
    everything the other tree did, declaring <i>our</i> history contains all
    that happened in it.</p>
</div>
<p class="Pp">theirs</p>
<div class="Bd-indent">This is the opposite of <i>ours</i>; note that, unlike
  <i>ours</i>, there is no <i>theirs</i> merge strategy to confuse this merge
  option with.</div>
<p class="Pp">ignore-space-change, ignore-all-space, ignore-space-at-eol,
    ignore-cr-at-eol</p>
<div class="Bd-indent">Treats lines with the indicated type of whitespace change
  as unchanged for the sake of a three-way merge. Whitespace changes mixed with
  other changes to a line are not ignored. See also <b>git-diff</b>(1)
  <b>-b</b>, <b>-w</b>, <b>--ignore-space-at-eol</b>, and
  <b>--ignore-cr-at-eol</b>.
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;If <i>their</i> version only introduces
  whitespace changes to a line, <i>our</i> version is used;</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;If <i>our</i> version introduces whitespace
  changes but <i>their</i> version includes a substantial change, <i>their</i>
  version is used;</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;Otherwise, the merge proceeds in the usual
  way.</div>
</div>
<p class="Pp">renormalize</p>
<div class="Bd-indent">This runs a virtual check-out and check-in of all three
  stages of a file when resolving a three-way merge. This option is meant to be
  used when merging branches with different clean filters or end-of-line
  normalization rules. See &quot;Merging branches with differing
  checkin/checkout attributes&quot; in <b>gitattributes</b>(5) for
  details.</div>
<p class="Pp">no-renormalize</p>
<div class="Bd-indent">Disables the <b>renormalize</b> option. This overrides
  the <b>merge.renormalize</b> configuration variable.</div>
<p class="Pp">find-renames[=&lt;n&gt;]</p>
<div class="Bd-indent">Turn on rename detection, optionally setting the
  similarity threshold. This is the default. This overrides the
  <i>merge.renames</i> configuration variable. See also <b>git-diff</b>(1)
  <b>--find-renames</b>.</div>
<p class="Pp">rename-threshold=&lt;n&gt;</p>
<div class="Bd-indent">Deprecated synonym for
  <b>find-renames=&lt;n&gt;</b>.</div>
<p class="Pp">subtree[=&lt;path&gt;]</p>
<div class="Bd-indent">This option is a more advanced form of <i>subtree</i>
  strategy, where the strategy makes a guess on how two trees must be shifted to
  match with each other when merging. Instead, the specified path is prefixed
  (or stripped from the beginning) to make the shape of two trees to
  match.</div>
</div>
<p class="Pp">recursive</p>
<div class="Bd-indent">This can only resolve two heads using a 3-way merge
  algorithm. When there is more than one common ancestor that can be used for
  3-way merge, it creates a merged tree of the common ancestors and uses that as
  the reference tree for the 3-way merge. This has been reported to result in
  fewer merge conflicts without causing mismerges by tests done on actual merge
  commits taken from Linux 2.6 kernel development history. Additionally this can
  detect and handle merges involving renames. It does not make use of detected
  copies. This was the default strategy for resolving two heads from Git
  v0.99.9k until v2.33.0.
<p class="Pp">The <i>recursive</i> strategy takes the same options as
    <i>ort</i>. However, there are three additional options that <i>ort</i>
    ignores (not documented above) that are potentially useful with the
    <i>recursive</i> strategy:</p>
<p class="Pp">patience</p>
<div class="Bd-indent">Deprecated synonym for
  <b>diff-algorithm=patience</b>.</div>
<p class="Pp">diff-algorithm=[patience|minimal|histogram|myers]</p>
<div class="Bd-indent">Use a different diff algorithm while merging, which can
  help avoid mismerges that occur due to unimportant matching lines (such as
  braces from distinct functions). See also <b>git-diff</b>(1)
  <b>--diff-algorithm</b>. Note that <b>ort</b> specifically uses
  <b>diff-algorithm=histogram</b>, while <b>recursive</b> defaults to the
  <b>diff.algorithm</b> config setting.</div>
<p class="Pp">no-renames</p>
<div class="Bd-indent">Turn off rename detection. This overrides the
  <b>merge.renames</b> configuration variable. See also <b>git-diff</b>(1)
  <b>--no-renames</b>.</div>
</div>
<p class="Pp">resolve</p>
<div class="Bd-indent">This can only resolve two heads (i.e. the current branch
  and another branch you pulled from) using a 3-way merge algorithm. It tries to
  carefully detect criss-cross merge ambiguities. It does not handle
  renames.</div>
<p class="Pp">octopus</p>
<div class="Bd-indent">This resolves cases with more than two heads, but refuses
  to do a complex merge that needs manual resolution. It is primarily meant to
  be used for bundling topic branch heads together. This is the default merge
  strategy when pulling or merging more than one branch.</div>
<p class="Pp">ours</p>
<div class="Bd-indent">This resolves any number of heads, but the resulting tree
  of the merge is always that of the current branch head, effectively ignoring
  all changes from all other branches. It is meant to be used to supersede old
  development history of side branches. Note that this is different from the
  -Xours option to the <i>recursive</i> merge strategy.</div>
<p class="Pp">subtree</p>
<div class="Bd-indent">This is a modified <b>ort</b> strategy. When merging
  trees A and B, if B corresponds to a subtree of A, B is first adjusted to
  match the tree structure of A, instead of reading the trees at the same level.
  This adjustment is also done to the common ancestor tree.</div>
<p class="Pp">With the strategies that use 3-way merge (including the default,
    <i>ort</i>), if a change is made on both branches, but later reverted on one
    of the branches, that change will be present in the merged result; some
    people find this behavior confusing. It occurs because only the heads and
    the merge base are considered when performing a merge, not the individual
    commits. The merge algorithm therefore considers the reverted change as no
    change at all, and substitutes the changed version instead.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<p class="Pp">You should understand the implications of using <b>git rebase</b>
    on a repository that you share. See also RECOVERING FROM UPSTREAM REBASE
    below.</p>
<p class="Pp">When the rebase is run, it will first execute a <b>pre-rebase</b>
    hook if one exists. You can use this hook to do sanity checks and reject the
    rebase if it isn&#x2019;t appropriate. Please see the template
    <b>pre-rebase</b> hook script for an example.</p>
<p class="Pp">Upon completion, <b>&lt;branch&gt;</b> will be the current
  branch.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="INTERACTIVE_MODE"><a class="permalink" href="#INTERACTIVE_MODE">INTERACTIVE
  MODE</a></h1>
<p class="Pp">Rebasing interactively means that you have a chance to edit the
    commits which are rebased. You can reorder the commits, and you can remove
    them (weeding out bad or otherwise unwanted patches).</p>
<p class="Pp">The interactive mode is meant for this type of workflow:</p>
<p class="Pp"></p>
<div class="Bd-indent"> 1.have a wonderful idea</div>
<p class="Pp"></p>
<div class="Bd-indent"> 2.hack on the code</div>
<p class="Pp"></p>
<div class="Bd-indent"> 3.prepare a series for submission</div>
<p class="Pp"></p>
<div class="Bd-indent"> 4.submit</div>
<p class="Pp">where point 2. consists of several instances of</p>
<p class="Pp">a) regular use</p>
<p class="Pp"></p>
<div class="Bd-indent"> 1.finish something worthy of a commit</div>
<p class="Pp"></p>
<div class="Bd-indent"> 2.commit</div>
<p class="Pp">b) independent fixup</p>
<p class="Pp"></p>
<div class="Bd-indent"> 1.realize that something does not work</div>
<p class="Pp"></p>
<div class="Bd-indent"> 2.fix that</div>
<p class="Pp"></p>
<div class="Bd-indent"> 3.commit it</div>
<p class="Pp">Sometimes the thing fixed in b.2. cannot be amended to the
    not-quite perfect commit it fixes, because that commit is buried deeply in a
    patch series. That is exactly what interactive rebase is for: use it after
    plenty of &quot;a&quot;s and &quot;b&quot;s, by rearranging and editing
    commits, and squashing multiple commits into one.</p>
<p class="Pp">Start it with the last commit you want to retain as-is:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>git rebase -i &lt;after-this-commit&gt;</pre>
</div>
<p class="Pp">An editor will be fired up with all the commits in your current
    branch (ignoring merge commits), which come after the given commit. You can
    reorder the commits in this list to your heart&#x2019;s content, and you can
    remove them. The list looks more or less like this:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>pick deadbee The oneline of this commit
pick fa1afe1 The oneline of the next commit
...</pre>
</div>
<p class="Pp"></p>
<p class="Pp">The oneline descriptions are purely for your pleasure; <i>git
    rebase</i> will not look at them but at the commit names
    (&quot;deadbee&quot; and &quot;fa1afe1&quot; in this example), so do not
    delete or edit the names.</p>
<p class="Pp">By replacing the command &quot;pick&quot; with the command
    &quot;edit&quot;, you can tell <b>git rebase</b> to stop after applying that
    commit, so that you can edit the files and/or the commit message, amend the
    commit, and continue rebasing.</p>
<p class="Pp">To interrupt the rebase (just like an &quot;edit&quot; command
    would do, but without cherry-picking any commit first), use the
    &quot;break&quot; command.</p>
<p class="Pp">If you just want to edit the commit message for a commit, replace
    the command &quot;pick&quot; with the command &quot;reword&quot;.</p>
<p class="Pp">To drop a commit, replace the command &quot;pick&quot; with
    &quot;drop&quot;, or just delete the matching line.</p>
<p class="Pp">If you want to fold two or more commits into one, replace the
    command &quot;pick&quot; for the second and subsequent commits with
    &quot;squash&quot; or &quot;fixup&quot;. If the commits had different
    authors, the folded commit will be attributed to the author of the first
    commit. The suggested commit message for the folded commit is the
    concatenation of the first commit&#x2019;s message with those identified by
    &quot;squash&quot; commands, omitting the messages of commits identified by
    &quot;fixup&quot; commands, unless &quot;fixup -c&quot; is used. In that
    case the suggested commit message is only the message of the &quot;fixup
    -c&quot; commit, and an editor is opened allowing you to edit the message.
    The contents (patch) of the &quot;fixup -c&quot; commit are still
    incorporated into the folded commit. If there is more than one &quot;fixup
    -c&quot; commit, the message from the final one is used. You can also use
    &quot;fixup -C&quot; to get the same behavior as &quot;fixup -c&quot; except
    without opening an editor.</p>
<p class="Pp"><b>git rebase</b> will stop when &quot;pick&quot; has been
    replaced with &quot;edit&quot; or when a command fails due to merge errors.
    When you are done editing and/or resolving conflicts you can continue with
    <b>git rebase --continue</b>.</p>
<p class="Pp">For example, if you want to reorder the last 5 commits, such that
    what was <b>HEAD~4</b> becomes the new <b>HEAD</b>. To achieve that, you
    would call <b>git rebase</b> like this:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>$ git rebase -i HEAD~5</pre>
</div>
<p class="Pp"></p>
<p class="Pp">And move the first patch to the end of the list.</p>
<p class="Pp">You might want to recreate merge commits, e.g. if you have a
    history like this:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
           X
            \
         A---M---B
        /
---o---O---P---Q</pre>
</div>
<p class="Pp"></p>
<p class="Pp">Suppose you want to rebase the side branch starting at
    &quot;A&quot; to &quot;Q&quot;. Make sure that the current <b>HEAD</b> is
    &quot;B&quot;, and call</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>$ git rebase -i -r --onto Q O</pre>
</div>
<p class="Pp"></p>
<p class="Pp">Reordering and editing commits usually creates untested
    intermediate steps. You may want to check that your history editing did not
    break anything by running a test, or at least recompiling at intermediate
    points in history by using the &quot;exec&quot; command (shortcut
    &quot;x&quot;). You may do so by creating a todo list like this one:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>pick deadbee Implement feature XXX
fixup f1a5c00 Fix to feature XXX
exec make
pick c0ffeee The oneline of the next commit
edit deadbab The oneline of the commit after
exec cd subdir; make test
...</pre>
</div>
<p class="Pp"></p>
<p class="Pp">The interactive rebase will stop when a command fails (i.e. exits
    with non-0 status) to give you an opportunity to fix the problem. You can
    continue with <b>git rebase --continue</b>.</p>
<p class="Pp">The &quot;exec&quot; command launches the command in a shell (the
    one specified in <b>$SHELL</b>, or the default shell if <b>$SHELL</b> is not
    set), so you can use shell features (like &quot;cd&quot;, &quot;&gt;&quot;,
    &quot;;&quot; ...). The command is run from the root of the working
  tree.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>$ git rebase -i --exec &quot;make test&quot;</pre>
</div>
<p class="Pp"></p>
<p class="Pp">This command lets you check that intermediate commits are
    compilable. The todo list becomes like that:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>pick 5928aea one
exec make test
pick 04d0fda two
exec make test
pick ba46169 three
exec make test
pick f4593f9 four
exec make test</pre>
</div>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SPLITTING_COMMITS"><a class="permalink" href="#SPLITTING_COMMITS">SPLITTING
  COMMITS</a></h1>
<p class="Pp">In interactive mode, you can mark commits with the action
    &quot;edit&quot;. However, this does not necessarily mean that <b>git
    rebase</b> expects the result of this edit to be exactly one commit. Indeed,
    you can undo the commit, or you can add other commits. This can be used to
    split a commit into two:</p>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;Start an interactive rebase with <b>git rebase -i
  &lt;commit&gt;^</b>, where <b>&lt;commit&gt;</b> is the commit you want to
  split. In fact, any commit range will do, as long as it contains that
  commit.</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;Mark the commit you want to split with the action
  &quot;edit&quot;.</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;When it comes to editing that commit, execute
  <b>git reset HEAD^</b>. The effect is that the <b>HEAD</b> is rewound by one,
  and the index follows suit. However, the working tree stays the same.</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;Now add the changes to the index that you want to
  have in the first commit. You can use <b>git add</b> (possibly interactively)
  or <b>git gui</b> (or both) to do that.</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;Commit the now-current index with whatever commit
  message is appropriate now.</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;Repeat the last two steps until your working tree
  is clean.</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;Continue the rebase with <b>git rebase
  --continue</b>.</div>
<p class="Pp">If you are not absolutely sure that the intermediate revisions are
    consistent (they compile, pass the testsuite, etc.) you should use <b>git
    stash</b> to stash away the not-yet-committed changes after each commit,
    test, and amend the commit if fixes are necessary.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="RECOVERING_FROM_UPSTREAM_REBASE"><a class="permalink" href="#RECOVERING_FROM_UPSTREAM_REBASE">RECOVERING
  FROM UPSTREAM REBASE</a></h1>
<p class="Pp">Rebasing (or any other form of rewriting) a branch that others
    have based work on is a bad idea: anyone downstream of it is forced to
    manually fix their history. This section explains how to do the fix from the
    downstream&#x2019;s point of view. The real fix, however, would be to avoid
    rebasing the upstream in the first place.</p>
<p class="Pp">To illustrate, suppose you are in a situation where someone
    develops a <i>subsystem</i> branch, and you are working on a <i>topic</i>
    that is dependent on this <i>subsystem</i>. You might end up with a history
    like the following:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
    o---o---o---o---o---o---o---o  master
         \
          o---o---o---o---o  subsystem
                           \
                            *---*---*  topic</pre>
</div>
<p class="Pp"></p>
<p class="Pp">If <i>subsystem</i> is rebased against <i>master</i>, the
    following happens:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
    o---o---o---o---o---o---o---o  master
         \                       \
          o---o---o---o---o       o'--o'--o'--o'--o'  subsystem
                           \
                            *---*---*  topic</pre>
</div>
<p class="Pp"></p>
<p class="Pp">If you now continue development as usual, and eventually merge
    <i>topic</i> to <i>subsystem</i>, the commits from <i>subsystem</i> will
    remain duplicated forever:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
    o---o---o---o---o---o---o---o  master
         \                       \
          o---o---o---o---o       o'--o'--o'--o'--o'--M  subsystem
                           \                         /
                            *---*---*-..........-*--*  topic</pre>
</div>
<p class="Pp"></p>
<p class="Pp">Such duplicates are generally frowned upon because they clutter up
    history, making it harder to follow. To clean things up, you need to
    transplant the commits on <i>topic</i> to the new <i>subsystem</i> tip,
    i.e., rebase <i>topic</i>. This becomes a ripple effect: anyone downstream
    from <i>topic</i> is forced to rebase too, and so on!</p>
<p class="Pp">There are two kinds of fixes, discussed in the following
    subsections:</p>
<p class="Pp">Easy case: The changes are literally the same.</p>
<div class="Bd-indent">This happens if the <i>subsystem</i> rebase was a simple
  rebase and had no conflicts.</div>
<p class="Pp">Hard case: The changes are not the same.</p>
<div class="Bd-indent">This happens if the <i>subsystem</i> rebase had
  conflicts, or used <b>--interactive</b> to omit, edit, squash, or fixup
  commits; or if the upstream used one of <b>commit --amend</b>, <b>reset</b>,
  or a full history rewriting command like <b></b><b>filter-repo</b>[2].</div>
<section class="Ss">
<h2 class="Ss" id="The_easy_case"><a class="permalink" href="#The_easy_case">The
  easy case</a></h2>
<p class="Pp">Only works if the changes (patch IDs based on the diff contents)
    on <i>subsystem</i> are literally the same before and after the rebase
    <i>subsystem</i> did.</p>
<p class="Pp">In that case, the fix is easy because <i>git rebase</i> knows to
    skip changes that are already present in the new upstream (unless
    <b>--reapply-cherry-picks</b> is given). So if you say (assuming
    you&#x2019;re on <i>topic</i>)</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
    $ git rebase subsystem</pre>
</div>
<p class="Pp"></p>
<p class="Pp">you will end up with the fixed history</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
    o---o---o---o---o---o---o---o  master
                                 \
                                  o'--o'--o'--o'--o'  subsystem
                                                   \
                                                    *---*---*  topic</pre>
</div>
<p class="Pp"></p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_hard_case"><a class="permalink" href="#The_hard_case">The
  hard case</a></h2>
<p class="Pp">Things get more complicated if the <i>subsystem</i> changes do not
    exactly correspond to the ones before the rebase.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<br/>
<b>Note</b>
<p class="Pp">While an &quot;easy case recovery&quot; sometimes appears to be
    successful even in the hard case, it may have unintended consequences. For
    example, a commit that was removed via <b>git rebase --interactive</b> will
    be <b>resurrected</b>!</p>
<p class="Pp"></p>
</div>
<p class="Pp">The idea is to manually tell <b>git rebase</b> &quot;where the old
    <i>subsystem</i> ended and your <i>topic</i> began&quot;, that is, what the
    old merge base between them was. You will have to find a way to name the
    last commit of the old <i>subsystem</i>, for example:</p>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;With the <i>subsystem</i> reflog: after <b>git
  fetch</b>, the old tip of <i>subsystem</i> is at <b>subsystem@{1}</b>.
  Subsequent fetches will increase the number. (See <b>git-reflog</b>(1).)</div>
<p class="Pp"></p>
<div class="Bd-indent">&#x2022;Relative to the tip of <i>topic</i>: knowing that
  your <i>topic</i> has three commits, the old tip of <i>subsystem</i> must be
  <b>topic~3</b>.</div>
<p class="Pp">You can then transplant the old <b>subsystem..topic</b> to the new
    tip by saying (for the reflog case, and assuming you are on <i>topic</i>
    already):</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
    $ git rebase --onto subsystem subsystem@{1}</pre>
</div>
<p class="Pp"></p>
<p class="Pp">The ripple effect of a &quot;hard case&quot; recovery is
    especially bad: <i>everyone</i> downstream from <i>topic</i> will now have
    to perform a &quot;hard case&quot; recovery too!</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="REBASING_MERGES"><a class="permalink" href="#REBASING_MERGES">REBASING
  MERGES</a></h1>
<p class="Pp">The interactive rebase command was originally designed to handle
    individual patch series. As such, it makes sense to exclude merge commits
    from the todo list, as the developer may have merged the then-current
    <b>master</b> while working on the branch, only to rebase all the commits
    onto <b>master</b> eventually (skipping the merge commits).</p>
<p class="Pp">However, there are legitimate reasons why a developer may want to
    recreate merge commits: to keep the branch structure (or &quot;commit
    topology&quot;) when working on multiple, inter-related branches.</p>
<p class="Pp">In the following example, the developer works on a topic branch
    that refactors the way buttons are defined, and on another topic branch that
    uses that refactoring to implement a &quot;Report a bug&quot; button. The
    output of <b>git log --graph --format=%s -5</b> may look like this:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>*   Merge branch 'report-a-bug'
|\
| * Add the feedback button
* | Merge branch 'refactor-button'
|\ \
| |/
| * Use the Button class for all buttons
| * Extract a generic Button class from the DownloadButton one</pre>
</div>
<p class="Pp"></p>
<p class="Pp">The developer might want to rebase those commits to a newer
    <b>master</b> while keeping the branch topology, for example when the first
    topic branch is expected to be integrated into <b>master</b> much earlier
    than the second one, say, to resolve merge conflicts with changes to the
    DownloadButton class that made it into <b>master</b>.</p>
<p class="Pp">This rebase can be performed using the <b>--rebase-merges</b>
    option. It will generate a todo list looking like this:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>label onto
# Branch: refactor-button
reset onto
pick 123456 Extract a generic Button class from the DownloadButton one
pick 654321 Use the Button class for all buttons
label refactor-button
# Branch: report-a-bug
reset refactor-button # Use the Button class for all buttons
pick abcdef Add the feedback button
label report-a-bug
reset onto
merge -C a1b2c3 refactor-button # Merge 'refactor-button'
merge -C 6f5e4d report-a-bug # Merge 'report-a-bug'</pre>
</div>
<p class="Pp"></p>
<p class="Pp">In contrast to a regular interactive rebase, there are
    <b>label</b>, <b>reset</b> and <b>merge</b> commands in addition to
    <b>pick</b> ones.</p>
<p class="Pp">The <b>label</b> command associates a label with the current HEAD
    when that command is executed. These labels are created as worktree-local
    refs (<b>refs/rewritten/&lt;label&gt;</b>) that will be deleted when the
    rebase finishes. That way, rebase operations in multiple worktrees linked to
    the same repository do not interfere with one another. If the <b>label</b>
    command fails, it is rescheduled immediately, with a helpful message how to
    proceed.</p>
<p class="Pp">The <b>reset</b> command resets the HEAD, index and worktree to
    the specified revision. It is similar to an <b>exec git reset --hard
    &lt;label&gt;</b>, but refuses to overwrite untracked files. If the
    <b>reset</b> command fails, it is rescheduled immediately, with a helpful
    message how to edit the todo list (this typically happens when a
    <b>reset</b> command was inserted into the todo list manually and contains a
    typo).</p>
<p class="Pp">The <b>merge</b> command will merge the specified revision(s) into
    whatever is HEAD at that time. With <b>-C &lt;original-commit&gt;</b>, the
    commit message of the specified merge commit will be used. When the
    <b>-C</b> is changed to a lower-case <b>-c</b>, the message will be opened
    in an editor after a successful merge so that the user can edit the
  message.</p>
<p class="Pp">If a <b>merge</b> command fails for any reason other than merge
    conflicts (i.e. when the merge operation did not even start), it is
    rescheduled immediately.</p>
<p class="Pp">By default, the <b>merge</b> command will use the <b>ort</b> merge
    strategy for regular merges, and <b>octopus</b> for octopus merges. One can
    specify a default strategy for all merges using the <b>--strategy</b>
    argument when invoking rebase, or can override specific merges in the
    interactive list of commands by using an <b>exec</b> command to call <b>git
    merge</b> explicitly with a <b>--strategy</b> argument. Note that when
    calling <b>git merge</b> explicitly like this, you can make use of the fact
    that the labels are worktree-local refs (the ref <b>refs/rewritten/onto</b>
    would correspond to the label <b>onto</b>, for example) in order to refer to
    the branches you want to merge.</p>
<p class="Pp">Note: the first command (<b>label onto</b>) labels the revision
    onto which the commits are rebased; The name <b>onto</b> is just a
    convention, as a nod to the <b>--onto</b> option.</p>
<p class="Pp">It is also possible to introduce completely new merge commits from
    scratch by adding a command of the form <b>merge &lt;merge-head&gt;</b>.
    This form will generate a tentative commit message and always open an editor
    to let the user edit it. This can be useful e.g. when a topic branch turns
    out to address more than a single concern and wants to be split into two or
    even more topic branches. Consider this todo list:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>pick 192837 Switch from GNU Makefiles to CMake
pick 5a6c7e Document the switch to CMake
pick 918273 Fix detection of OpenSSL in CMake
pick afbecd http: add support for TLS v1.3
pick fdbaec Fix detection of cURL in CMake on Windows</pre>
</div>
<p class="Pp"></p>
<p class="Pp">The one commit in this list that is not related to CMake may very
    well have been motivated by working on fixing all those bugs introduced by
    switching to CMake, but it addresses a different concern. To split this
    branch into two topic branches, the todo list could be edited like this:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>label onto
pick afbecd http: add support for TLS v1.3
label tlsv1.3
reset onto
pick 192837 Switch from GNU Makefiles to CMake
pick 918273 Fix detection of OpenSSL in CMake
pick fdbaec Fix detection of cURL in CMake on Windows
pick 5a6c7e Document the switch to CMake
label cmake
reset onto
merge tlsv1.3
merge cmake</pre>
</div>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONFIGURATION"><a class="permalink" href="#CONFIGURATION">CONFIGURATION</a></h1>
<p class="Pp">Everything below this line in this section is selectively included
    from the <b>git-config</b>(1) documentation. The content is the same as
    what&#x2019;s found there:</p>
<p class="Pp">rebase.backend</p>
<div class="Bd-indent">Default backend to use for rebasing. Possible choices are
  <i>apply</i> or <i>merge</i>. In the future, if the merge backend gains all
  remaining capabilities of the apply backend, this setting may become
  unused.</div>
<p class="Pp">rebase.stat</p>
<div class="Bd-indent">Whether to show a diffstat of what changed upstream since
  the last rebase. False by default.</div>
<p class="Pp">rebase.autoSquash</p>
<div class="Bd-indent">If set to true enable <b>--autosquash</b> option by
  default.</div>
<p class="Pp">rebase.autoStash</p>
<div class="Bd-indent">When set to true, automatically create a temporary stash
  entry before the operation begins, and apply it after the operation ends. This
  means that you can run rebase on a dirty worktree. However, use with care: the
  final stash application after a successful rebase might result in non-trivial
  conflicts. This option can be overridden by the <b>--no-autostash</b> and
  <b>--autostash</b> options of <b>git-rebase</b>(1). Defaults to false.</div>
<p class="Pp">rebase.updateRefs</p>
<div class="Bd-indent">If set to true enable <b>--update-refs</b> option by
  default.</div>
<p class="Pp">rebase.missingCommitsCheck</p>
<div class="Bd-indent">If set to &quot;warn&quot;, git rebase -i will print a
  warning if some commits are removed (e.g. a line was deleted), however the
  rebase will still proceed. If set to &quot;error&quot;, it will print the
  previous warning and stop the rebase, <i>git rebase --edit-todo</i> can then
  be used to correct the error. If set to &quot;ignore&quot;, no checking is
  done. To drop a commit without warning or error, use the <b>drop</b> command
  in the todo list. Defaults to &quot;ignore&quot;.</div>
<p class="Pp">rebase.instructionFormat</p>
<div class="Bd-indent">A format string, as specified in <b>git-log</b>(1), to be
  used for the todo list during an interactive rebase. The format will
  automatically have the long commit hash prepended to the format.</div>
<p class="Pp">rebase.abbreviateCommands</p>
<div class="Bd-indent">If set to true, <b>git rebase</b> will use abbreviated
  command names in the todo list resulting in something like this:
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
        p deadbee The oneline of the commit
        p fa1afe1 The oneline of the next commit
        ...</pre>
</div>
<p class="Pp">instead of:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
        pick deadbee The oneline of the commit
        pick fa1afe1 The oneline of the next commit
        ...</pre>
</div>
<p class="Pp">Defaults to false.</p>
</div>
<p class="Pp">rebase.rescheduleFailedExec</p>
<div class="Bd-indent">Automatically reschedule <b>exec</b> commands that
  failed. This only makes sense in interactive mode (or when an <b>--exec</b>
  option was provided). This is the same as specifying the
  <b>--reschedule-failed-exec</b> option.</div>
<p class="Pp">rebase.forkPoint</p>
<div class="Bd-indent">If set to false set <b>--no-fork-point</b> option by
  default.</div>
<p class="Pp">sequence.editor</p>
<div class="Bd-indent">Text editor used by <b>git rebase -i</b> for editing the
  rebase instruction file. The value is meant to be interpreted by the shell
  when it is used. It can be overridden by the <b>GIT_SEQUENCE_EDITOR</b>
  environment variable. When not configured the default commit message editor is
  used instead.</div>
</section>
<section class="Sh">
<h1 class="Sh" id="GIT"><a class="permalink" href="#GIT">GIT</a></h1>
<p class="Pp">Part of the <b>git</b>(1) suite</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES~2"><a class="permalink" href="#NOTES~2">NOTES</a></h1>
<dl class="Bl-tag">
  <dt> 1.</dt>
  <dd>revert-a-faulty-merge How-To</dd>
</dl>
<div class="Bd-indent">git-htmldocs/howto/revert-a-faulty-merge.html</div>
<dl class="Bl-tag">
  <dt> 2.</dt>
  <dd><b>filter-repo</b></dd>
</dl>
<div class="Bd-indent">https://github.com/newren/git-filter-repo</div>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">12/12/2022</td>
    <td class="foot-os"><a href="..">Git 2.39.0</a></td>
  </tr>
</table>
</body>
</html>

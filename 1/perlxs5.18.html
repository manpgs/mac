<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PERLXS(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLXS(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLXS(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlxs - XS language reference manual</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<section class="Ss">
<h2 class="Ss" id="Introduction"><a class="permalink" href="#Introduction">Introduction</a></h2>
<p class="Pp">XS is an interface description file format used to create an
    extension interface between Perl and C code (or a C library) which one
    wishes to use with Perl. The XS interface is combined with the library to
    create a new library which can then be either dynamically loaded or
    statically linked into perl. The XS interface description is written in the
    XS language and is the core component of the Perl extension interface.</p>
<p class="Pp">An <b>XSUB</b> forms the basic unit of the XS interface. After
    compilation by the <b>xsubpp</b> compiler, each XSUB amounts to a C function
    definition which will provide the glue between Perl calling conventions and
    C calling conventions.</p>
<p class="Pp">The glue code pulls the arguments from the Perl stack, converts
    these Perl values to the formats expected by a C function, call this C
    function, transfers the return values of the C function back to Perl. Return
    values here may be a conventional C return value or any C function arguments
    that may serve as output parameters. These return values may be passed back
    to Perl either by putting them on the Perl stack, or by modifying the
    arguments supplied from the Perl side.</p>
<p class="Pp">The above is a somewhat simplified view of what really happens.
    Since Perl allows more flexible calling conventions than C, XSUBs may do
    much more in practice, such as checking input parameters for validity,
    throwing exceptions (or returning undef/empty list) if the return value from
    the C function indicates failure, calling different C functions based on
    numbers and types of the arguments, providing an object-oriented interface,
    etc.</p>
<p class="Pp">Of course, one could write such glue code directly in C. However,
    this would be a tedious task, especially if one needs to write glue for
    multiple C functions, and/or one is not familiar enough with the Perl stack
    discipline and other such arcana. XS comes to the rescue here: instead of
    writing this glue C code in long-hand, one can write a more concise
    short-hand <i>description</i> of what should be done by the glue, and let
    the XS compiler <b>xsubpp</b> handle the rest.</p>
<p class="Pp">The XS language allows one to describe the mapping between how the
    C routine is used, and how the corresponding Perl routine is used. It also
    allows creation of Perl routines which are directly translated to C code and
    which are not related to a pre-existing C function. In cases when the C
    interface coincides with the Perl interface, the XSUB declaration is almost
    identical to a declaration of a C function (in K&amp;R style). In such
    circumstances, there is another tool called
    <span class="Li">&quot;h2xs&quot;</span> that is able to translate an entire
    C header file into a corresponding XS file that will provide glue to the
    functions/macros described in the header file.</p>
<p class="Pp">The XS compiler is called <b>xsubpp</b>. This compiler creates the
    constructs necessary to let an XSUB manipulate Perl values, and creates the
    glue necessary to let Perl call the XSUB. The compiler uses <b>typemaps</b>
    to determine how to map C function parameters and output values to Perl
    values and back. The default typemap (which comes with Perl) handles many
    common C types. A supplementary typemap may also be needed to handle any
    special structures and types for the library being linked. For more
    information on typemaps, see perlxstypemap.</p>
<p class="Pp">A file in XS format starts with a C language section which goes
    until the first <span class="Li">&quot;MODULE =&quot;</span> directive.
    Other XS directives and XSUB definitions may follow this line. The
    &quot;language&quot; used in this part of the file is usually referred to as
    the XS language. <b>xsubpp</b> recognizes and skips POD (see perlpod) in
    both the C and XS language sections, which allows the XS file to contain
    embedded documentation.</p>
<p class="Pp">See perlxstut for a tutorial on the whole extension creation
    process.</p>
<p class="Pp">Note: For some extensions, Dave Beazley's SWIG system may provide
    a significantly more convenient mechanism for creating the extension glue
    code. See &lt;http://www.swig.org/&gt; for more information.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="On_The_Road"><a class="permalink" href="#On_The_Road">On The
  Road</a></h2>
<p class="Pp">Many of the examples which follow will concentrate on creating an
    interface between Perl and the ONC+ RPC bind library functions. The
    <i>rpcb_gettime()</i> function is used to demonstrate many features of the
    XS language. This function has two parameters; the first is an input
    parameter and the second is an output parameter. The function also returns a
    status value.</p>
<p class="Pp"></p>
<pre>
        bool_t rpcb_gettime(const char *host, time_t *timep);
</pre>
<p class="Pp">From C this function will be called with the following
  statements.</p>
<p class="Pp"></p>
<pre>
     #include &lt;rpc/rpc.h&gt;
     bool_t status;
     time_t timep;
     status = rpcb_gettime( &quot;localhost&quot;, &amp;timep );
</pre>
<p class="Pp">If an XSUB is created to offer a direct translation between this
    function and Perl, then this XSUB will be used from Perl with the following
    code. The <span class="Li">$status</span> and <span class="Li">$timep</span>
    variables will contain the output of the function.</p>
<p class="Pp"></p>
<pre>
     use RPC;
     $status = rpcb_gettime( &quot;localhost&quot;, $timep );
</pre>
<p class="Pp">The following XS file shows an XS subroutine, or XSUB, which
    demonstrates one possible interface to the <i>rpcb_gettime()</i> function.
    This XSUB represents a direct translation between C and Perl and so
    preserves the interface even from Perl. This XSUB will be invoked from Perl
    with the usage shown above. Note that the first three #include statements,
    for <span class="Li">&quot;EXTERN.h&quot;</span>,
    <span class="Li">&quot;perl.h&quot;</span>, and
    <span class="Li">&quot;XSUB.h&quot;</span>, will always be present at the
    beginning of an XS file. This approach and others will be expanded later in
    this document.</p>
<p class="Pp"></p>
<pre>
     #include &quot;EXTERN.h&quot;
     #include &quot;perl.h&quot;
     #include &quot;XSUB.h&quot;
     #include &lt;rpc/rpc.h&gt;

     MODULE = RPC  PACKAGE = RPC

     bool_t
     rpcb_gettime(host,timep)
          char *host
          time_t &amp;timep
        OUTPUT:
          timep
</pre>
<p class="Pp">Any extension to Perl, including those containing XSUBs, should
    have a Perl module to serve as the bootstrap which pulls the extension into
    Perl. This module will export the extension's functions and variables to the
    Perl program and will cause the extension's XSUBs to be linked into Perl.
    The following module will be used for most of the examples in this document
    and should be used from Perl with the
    <span class="Li">&quot;use&quot;</span> command as shown earlier. Perl
    modules are explained in more detail later in this document.</p>
<p class="Pp"></p>
<pre>
     package RPC;

     require Exporter;
     require DynaLoader;
     @ISA = qw(Exporter DynaLoader);
     @EXPORT = qw( rpcb_gettime );

     bootstrap RPC;
     1;
</pre>
<p class="Pp">Throughout this document a variety of interfaces to the
    <i>rpcb_gettime()</i> XSUB will be explored. The XSUBs will take their
    parameters in different orders or will take different numbers of parameters.
    In each case the XSUB is an abstraction between Perl and the real C
    <i>rpcb_gettime()</i> function, and the XSUB must always ensure that the
    real <i>rpcb_gettime()</i> function is called with the correct parameters.
    This abstraction will allow the programmer to create a more Perl-like
    interface to the C function.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Anatomy_of_an_"><a class="permalink" href="#The_Anatomy_of_an_">The
  Anatomy of an XSUB</a></h2>
<p class="Pp">The simplest XSUBs consist of 3 parts: a description of the return
    value, the name of the XSUB routine and the names of its arguments, and a
    description of types or formats of the arguments.</p>
<p class="Pp">The following XSUB allows a Perl program to access a C library
    function called <i>sin()</i>. The XSUB will imitate the C function which
    takes a single argument and returns a single value.</p>
<p class="Pp"></p>
<pre>
     double
     sin(x)
       double x
</pre>
<p class="Pp">Optionally, one can merge the description of types and the list of
    argument names, rewriting this as</p>
<p class="Pp"></p>
<pre>
     double
     sin(double x)
</pre>
<p class="Pp">This makes this XSUB look similar to an ANSI C declaration. An
    optional semicolon is allowed after the argument list, as in</p>
<p class="Pp"></p>
<pre>
     double
     sin(double x);
</pre>
<p class="Pp">Parameters with C pointer types can have different semantic: C
    functions with similar declarations</p>
<p class="Pp"></p>
<pre>
     bool string_looks_as_a_number(char *s);
     bool make_char_uppercase(char *c);
</pre>
<p class="Pp">are used in absolutely incompatible manner. Parameters to these
    functions could be described <b>xsubpp</b> like this:</p>
<p class="Pp"></p>
<pre>
     char *  s
     char    &amp;c
</pre>
<p class="Pp">Both these XS declarations correspond to the
    <span class="Li">&quot;char*&quot;</span> C type, but they have different
    semantics, see &quot;The &amp; Unary Operator&quot;.</p>
<p class="Pp">It is convenient to think that the indirection operator
    <span class="Li">&quot;*&quot;</span> should be considered as a part of the
    type and the address operator <span class="Li">&quot;&amp;&quot;</span>
    should be considered part of the variable. See perlxstypemap for more info
    about handling qualifiers and unary operators in C types.</p>
<p class="Pp">The function name and the return type must be placed on separate
    lines and should be flush left-adjusted.</p>
<p class="Pp"></p>
<pre>
  INCORRECT                        CORRECT

  double sin(x)                    double
    double x                       sin(x)
                                     double x
</pre>
<p class="Pp">The rest of the function description may be indented or
    left-adjusted. The following example shows a function with its body
    left-adjusted. Most examples in this document will indent the body for
    better readability.</p>
<p class="Pp"></p>
<pre>
  CORRECT

  double
  sin(x)
  double x
</pre>
<p class="Pp">More complicated XSUBs may contain many other sections. Each
    section of an XSUB starts with the corresponding keyword, such as INIT: or
    CLEANUP:. However, the first two lines of an XSUB always contain the same
    data: descriptions of the return type and the names of the function and its
    parameters. Whatever immediately follows these is considered to be an INPUT:
    section unless explicitly marked with another keyword. (See &quot;The INPUT:
    Keyword&quot;.)</p>
<p class="Pp">An XSUB section continues until another section-start keyword is
    found.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Argument_Stack"><a class="permalink" href="#The_Argument_Stack">The
  Argument Stack</a></h2>
<p class="Pp">The Perl argument stack is used to store the values which are sent
    as parameters to the XSUB and to store the XSUB's return value(s). In
    reality all Perl functions (including non-XSUB ones) keep their values on
    this stack all the same time, each limited to its own range of positions on
    the stack. In this document the first position on that stack which belongs
    to the active function will be referred to as position 0 for that
  function.</p>
<p class="Pp">XSUBs refer to their stack arguments with the macro <b>ST(x)</b>,
    where <i>x</i> refers to a position in this XSUB's part of the stack.
    Position 0 for that function would be known to the XSUB as <i>ST</i>(0). The
    XSUB's incoming parameters and outgoing return values always begin at
    <i>ST</i>(0). For many simple cases the <b>xsubpp</b> compiler will generate
    the code necessary to handle the argument stack by embedding code fragments
    found in the typemaps. In more complex cases the programmer must supply the
    code.</p>
</section>
<section class="Ss">
<h2 class="Ss">The RETVAL Variable</h2>
<p class="Pp">The RETVAL variable is a special C variable that is declared
    automatically for you. The C type of RETVAL matches the return type of the C
    library function. The <b>xsubpp</b> compiler will declare this variable in
    each XSUB with non-<span class="Li">&quot;void&quot;</span> return type. By
    default the generated C function will use RETVAL to hold the return value of
    the C library function being called. In simple cases the value of RETVAL
    will be placed in <i>ST</i>(0) of the argument stack where it can be
    received by Perl as the return value of the XSUB.</p>
<p class="Pp">If the XSUB has a return type of
    <span class="Li">&quot;void&quot;</span> then the compiler will not declare
    a RETVAL variable for that function. When using a PPCODE: section no
    manipulation of the RETVAL variable is required, the section may use direct
    stack manipulation to place output values on the stack.</p>
<p class="Pp">If PPCODE: directive is not used,
    <span class="Li">&quot;void&quot;</span> return value should be used only
    for subroutines which do not return a value, <i>even if</i> CODE: directive
    is used which sets <i>ST</i>(0) explicitly.</p>
<p class="Pp">Older versions of this document recommended to use
    <span class="Li">&quot;void&quot;</span> return value in such cases. It was
    discovered that this could lead to segfaults in cases when XSUB was
    <i>truly</i> <span class="Li">&quot;void&quot;</span>. This practice is now
    deprecated, and may be not supported at some future version. Use the return
    value <span class="Li">&quot;SV *&quot;</span> in such cases. (Currently
    <span class="Li">&quot;xsubpp&quot;</span> contains some heuristic code
    which tries to disambiguate between &quot;truly-void&quot; and
    &quot;old-practice-declared-as-void&quot; functions. Hence your code is at
    mercy of this heuristics unless you use <span class="Li">&quot;SV
    *&quot;</span> as return value.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Returning_SVs,_AVs_and_HVs_through_"><a class="permalink" href="#Returning_SVs,_AVs_and_HVs_through_">Returning
  SVs, AVs and HVs through RETVAL</a></h2>
<p class="Pp">When you're using RETVAL to return an <span class="Li">&quot;SV
    *&quot;</span>, there's some magic going on behind the scenes that should be
    mentioned. When you're manipulating the argument stack using the ST(x)
    macro, for example, you usually have to pay special attention to reference
    counts. (For more about reference counts, see perlguts.) To make your life
    easier, the typemap file automatically makes
    <span class="Li">&quot;RETVAL&quot;</span> mortal when you're returning an
    <span class="Li">&quot;SV *&quot;</span>. Thus, the following two XSUBs are
    more or less equivalent:</p>
<p class="Pp"></p>
<pre>
  void
  alpha()
      PPCODE:
          ST(0) = newSVpv(&quot;Hello World&quot;,0);
          sv_2mortal(ST(0));
          XSRETURN(1);

  SV *
  beta()
      CODE:
          RETVAL = newSVpv(&quot;Hello World&quot;,0);
      OUTPUT:
          RETVAL
</pre>
<p class="Pp">This is quite useful as it usually improves readability. While
    this works fine for an <span class="Li">&quot;SV *&quot;</span>, it's
    unfortunately not as easy to have <span class="Li">&quot;AV *&quot;</span>
    or <span class="Li">&quot;HV *&quot;</span> as a return value. You
    <i>should</i> be able to write:</p>
<p class="Pp"></p>
<pre>
  AV *
  array()
      CODE:
          RETVAL = newAV();
          /* do something with RETVAL */
      OUTPUT:
          RETVAL
</pre>
<p class="Pp">But due to an unfixable bug (fixing it would break lots of
    existing CPAN modules) in the typemap file, the reference count of the
    <span class="Li">&quot;AV *&quot;</span> is not properly decremented. Thus,
    the above XSUB would leak memory whenever it is being called. The same
    problem exists for <span class="Li">&quot;HV *&quot;</span>,
    <span class="Li">&quot;CV *&quot;</span>, and
    <span class="Li">&quot;SVREF&quot;</span> (which indicates a scalar
    reference, not a general <span class="Li">&quot;SV *&quot;</span>). In XS
    code on perls starting with perl 5.16, you can override the typemaps for any
    of these types with a version that has proper handling of refcounts. In your
    <span class="Li">&quot;TYPEMAP&quot;</span> section, do</p>
<p class="Pp"></p>
<pre>
  AV*   T_AVREF_REFCOUNT_FIXED
</pre>
<p class="Pp">to get the repaired variant. For backward compatibility with older
    versions of perl, you can instead decrement the reference count manually
    when you're returning one of the aforementioned types using
    <span class="Li">&quot;sv_2mortal&quot;</span>:</p>
<p class="Pp"></p>
<pre>
  AV *
  array()
      CODE:
          RETVAL = newAV();
          sv_2mortal((SV*)RETVAL);
          /* do something with RETVAL */
      OUTPUT:
          RETVAL
</pre>
<p class="Pp">Remember that you don't have to do this for an
    <span class="Li">&quot;SV *&quot;</span>. The reference documentation for
    all core typemaps can be found in perlxstypemap.</p>
</section>
<section class="Ss">
<h2 class="Ss">The MODULE Keyword</h2>
<p class="Pp">The MODULE keyword is used to start the XS code and to specify the
    package of the functions which are being defined. All text preceding the
    first MODULE keyword is considered C code and is passed through to the
    output with POD stripped, but otherwise untouched. Every XS module will have
    a bootstrap function which is used to hook the XSUBs into Perl. The package
    name of this bootstrap function will match the value of the last MODULE
    statement in the XS source files. The value of MODULE should always remain
    constant within the same XS file, though this is not required.</p>
<p class="Pp">The following example will start the XS code and will place all
    functions in a package named RPC.</p>
<p class="Pp"></p>
<pre>
     MODULE = RPC
</pre>
</section>
<section class="Ss">
<h2 class="Ss">The PACKAGE Keyword</h2>
<p class="Pp">When functions within an XS source file must be separated into
    packages the PACKAGE keyword should be used. This keyword is used with the
    MODULE keyword and must follow immediately after it when used.</p>
<p class="Pp"></p>
<pre>
     MODULE = RPC  PACKAGE = RPC

     [ XS code in package RPC ]

     MODULE = RPC  PACKAGE = RPCB

     [ XS code in package RPCB ]

     MODULE = RPC  PACKAGE = RPC

     [ XS code in package RPC ]
</pre>
<p class="Pp">The same package name can be used more than once, allowing for
    non-contiguous code. This is useful if you have a stronger ordering
    principle than package names.</p>
<p class="Pp">Although this keyword is optional and in some cases provides
    redundant information it should always be used. This keyword will ensure
    that the XSUBs appear in the desired package.</p>
</section>
<section class="Ss">
<h2 class="Ss">The PREFIX Keyword</h2>
<p class="Pp">The PREFIX keyword designates prefixes which should be removed
    from the Perl function names. If the C function is
    <span class="Li">&quot;rpcb_gettime()&quot;</span> and the PREFIX value is
    <span class="Li">&quot;rpcb_&quot;</span> then Perl will see this function
    as <span class="Li">&quot;gettime()&quot;</span>.</p>
<p class="Pp">This keyword should follow the PACKAGE keyword when used. If
    PACKAGE is not used then PREFIX should follow the MODULE keyword.</p>
<p class="Pp"></p>
<pre>
     MODULE = RPC  PREFIX = rpc_

     MODULE = RPC  PACKAGE = RPCB  PREFIX = rpcb_
</pre>
</section>
<section class="Ss">
<h2 class="Ss">The OUTPUT: Keyword</h2>
<p class="Pp">The OUTPUT: keyword indicates that certain function parameters
    should be updated (new values made visible to Perl) when the XSUB terminates
    or that certain values should be returned to the calling Perl function. For
    simple functions which have no CODE: or PPCODE: section, such as the
    <i>sin()</i> function above, the RETVAL variable is automatically designated
    as an output value. For more complex functions the <b>xsubpp</b> compiler
    will need help to determine which variables are output variables.</p>
<p class="Pp">This keyword will normally be used to complement the CODE:
    keyword. The RETVAL variable is not recognized as an output variable when
    the CODE: keyword is present. The OUTPUT: keyword is used in this situation
    to tell the compiler that RETVAL really is an output variable.</p>
<p class="Pp">The OUTPUT: keyword can also be used to indicate that function
    parameters are output variables. This may be necessary when a parameter has
    been modified within the function and the programmer would like the update
    to be seen by Perl.</p>
<p class="Pp"></p>
<pre>
     bool_t
     rpcb_gettime(host,timep)
          char *host
          time_t &amp;timep
        OUTPUT:
          timep
</pre>
<p class="Pp">The OUTPUT: keyword will also allow an output parameter to be
    mapped to a matching piece of code rather than to a typemap.</p>
<p class="Pp"></p>
<pre>
     bool_t
     rpcb_gettime(host,timep)
          char *host
          time_t &amp;timep
        OUTPUT:
          timep sv_setnv(ST(1), (double)timep);
</pre>
<p class="Pp"><b>xsubpp</b> emits an automatic
    <span class="Li">&quot;SvSETMAGIC()&quot;</span> for all parameters in the
    OUTPUT section of the XSUB, except RETVAL. This is the usually desired
    behavior, as it takes care of properly invoking 'set' magic on output
    parameters (needed for hash or array element parameters that must be created
    if they didn't exist). If for some reason, this behavior is not desired, the
    OUTPUT section may contain a <span class="Li">&quot;SETMAGIC:
    DISABLE&quot;</span> line to disable it for the remainder of the parameters
    in the OUTPUT section. Likewise, <span class="Li">&quot;SETMAGIC:
    ENABLE&quot;</span> can be used to reenable it for the remainder of the
    OUTPUT section. See perlguts for more details about 'set' magic.</p>
</section>
<section class="Ss">
<h2 class="Ss">The NO_OUTPUT Keyword</h2>
<p class="Pp">The NO_OUTPUT can be placed as the first token of the XSUB. This
    keyword indicates that while the C subroutine we provide an interface to has
    a non-<span class="Li">&quot;void&quot;</span> return type, the return value
    of this C subroutine should not be returned from the generated Perl
    subroutine.</p>
<p class="Pp">With this keyword present &quot;The RETVAL Variable&quot; is
    created, and in the generated call to the subroutine this variable is
    assigned to, but the value of this variable is not going to be used in the
    auto-generated code.</p>
<p class="Pp">This keyword makes sense only if
    <span class="Li">&quot;RETVAL&quot;</span> is going to be accessed by the
    user-supplied code. It is especially useful to make a function interface
    more Perl-like, especially when the C return value is just an error
    condition indicator. For example,</p>
<p class="Pp"></p>
<pre>
  NO_OUTPUT int
  delete_file(char *name)
    POSTCALL:
      if (RETVAL != 0)
          croak(&quot;Error %d while deleting file '%s'&quot;, RETVAL, name);
</pre>
<p class="Pp">Here the generated XS function returns nothing on success, and
    will <i>die()</i> with a meaningful error message on error.</p>
</section>
<section class="Ss">
<h2 class="Ss">The CODE: Keyword</h2>
<p class="Pp">This keyword is used in more complicated XSUBs which require
    special handling for the C function. The RETVAL variable is still declared,
    but it will not be returned unless it is specified in the OUTPUT:
  section.</p>
<p class="Pp">The following XSUB is for a C function which requires special
    handling of its parameters. The Perl usage is given first.</p>
<p class="Pp"></p>
<pre>
     $status = rpcb_gettime( &quot;localhost&quot;, $timep );
</pre>
<p class="Pp">The XSUB follows.</p>
<p class="Pp"></p>
<pre>
     bool_t
     rpcb_gettime(host,timep)
          char *host
          time_t timep
        CODE:
               RETVAL = rpcb_gettime( host, &amp;timep );
        OUTPUT:
          timep
          RETVAL
</pre>
</section>
<section class="Ss">
<h2 class="Ss">The INIT: Keyword</h2>
<p class="Pp">The INIT: keyword allows initialization to be inserted into the
    XSUB before the compiler generates the call to the C function. Unlike the
    CODE: keyword above, this keyword does not affect the way the compiler
    handles RETVAL.</p>
<p class="Pp"></p>
<pre>
    bool_t
    rpcb_gettime(host,timep)
          char *host
          time_t &amp;timep
        INIT:
          printf(&quot;# Host is %s\n&quot;, host );
        OUTPUT:
          timep
</pre>
<p class="Pp">Another use for the INIT: section is to check for preconditions
    before making a call to the C function:</p>
<p class="Pp"></p>
<pre>
    long long
    lldiv(a,b)
        long long a
        long long b
      INIT:
        if (a == 0 &amp;&amp; b == 0)
            XSRETURN_UNDEF;
        if (b == 0)
            croak(&quot;lldiv: cannot divide by 0&quot;);
</pre>
</section>
<section class="Ss">
<h2 class="Ss">The NO_INIT Keyword</h2>
<p class="Pp">The NO_INIT keyword is used to indicate that a function parameter
    is being used only as an output value. The <b>xsubpp</b> compiler will
    normally generate code to read the values of all function parameters from
    the argument stack and assign them to C variables upon entry to the
    function. NO_INIT will tell the compiler that some parameters will be used
    for output rather than for input and that they will be handled before the
    function terminates.</p>
<p class="Pp">The following example shows a variation of the
    <i>rpcb_gettime()</i> function. This function uses the timep variable only
    as an output variable and does not care about its initial contents.</p>
<p class="Pp"></p>
<pre>
     bool_t
     rpcb_gettime(host,timep)
          char *host
          time_t &amp;timep = NO_INIT
        OUTPUT:
          timep
</pre>
</section>
<section class="Ss">
<h2 class="Ss">The TYPEMAP: Keyword</h2>
<p class="Pp">Starting with Perl 5.16, you can embed typemaps into your XS code
    instead of or in addition to typemaps in a separate file. Multiple such
    embedded typemaps will be processed in order of appearance in the XS code
    and like local typemap files take precendence over the default typemap, the
    embedded typemaps may overwrite previous definitions of TYPEMAP, INPUT, and
    OUTPUT stanzas. The syntax for embedded typemaps is</p>
<p class="Pp"></p>
<pre>
      TYPEMAP: &lt;&lt;HERE
      ... your typemap code here ...
      HERE
</pre>
<p class="Pp">where the <span class="Li">&quot;TYPEMAP&quot;</span> keyword must
    appear in the first column of a new line.</p>
<p class="Pp">Refer to perlxstypemap for details on writing typemaps.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Initializing_Function_Parameters"><a class="permalink" href="#Initializing_Function_Parameters">Initializing
  Function Parameters</a></h2>
<p class="Pp">C function parameters are normally initialized with their values
    from the argument stack (which in turn contains the parameters that were
    passed to the XSUB from Perl). The typemaps contain the code segments which
    are used to translate the Perl values to the C parameters. The programmer,
    however, is allowed to override the typemaps and supply alternate (or
    additional) initialization code. Initialization code starts with the first
    <span class="Li">&quot;=&quot;</span>, <span class="Li">&quot;;&quot;</span>
    or <span class="Li">&quot;+&quot;</span> on a line in the INPUT: section.
    The only exception happens if this <span class="Li">&quot;;&quot;</span>
    terminates the line, then this <span class="Li">&quot;;&quot;</span> is
    quietly ignored.</p>
<p class="Pp">The following code demonstrates how to supply initialization code
    for function parameters. The initialization code is eval'ed within double
    quotes by the compiler before it is added to the output so anything which
    should be interpreted literally [mainly
    <span class="Li">&quot;$&quot;</span>,
    <span class="Li">&quot;@&quot;</span>, or
    <span class="Li">&quot;\\&quot;</span>] must be protected with backslashes.
    The variables <span class="Li">$var</span>, <span class="Li">$arg</span>,
    and <span class="Li">$type</span> can be used as in typemaps.</p>
<p class="Pp"></p>
<pre>
     bool_t
     rpcb_gettime(host,timep)
          char *host = (char *)SvPV_nolen($arg);
          time_t &amp;timep = 0;
        OUTPUT:
          timep
</pre>
<p class="Pp">This should not be used to supply default values for parameters.
    One would normally use this when a function parameter must be processed by
    another library function before it can be used. Default parameters are
    covered in the next section.</p>
<p class="Pp">If the initialization begins with
    <span class="Li">&quot;=&quot;</span>, then it is output in the declaration
    for the input variable, replacing the initialization supplied by the
    typemap. If the initialization begins with
    <span class="Li">&quot;;&quot;</span> or
    <span class="Li">&quot;+&quot;</span>, then it is performed after all of the
    input variables have been declared. In the
    <span class="Li">&quot;;&quot;</span> case the initialization normally
    supplied by the typemap is not performed. For the
    <span class="Li">&quot;+&quot;</span> case, the declaration for the variable
    will include the initialization from the typemap. A global variable,
    <span class="Li">%v</span>, is available for the truly rare case where
    information from one initialization is needed in another initialization.</p>
<p class="Pp">Here's a truly obscure example:</p>
<p class="Pp"></p>
<pre>
     bool_t
     rpcb_gettime(host,timep)
          time_t &amp;timep; /* \$v{timep}=@{[$v{timep}=$arg]} */
          char *host + SvOK($v{timep}) ? SvPV_nolen($arg) : NULL;
        OUTPUT:
          timep
</pre>
<p class="Pp">The construct
    <span class="Li">&quot;\$v{timep}=@{[$v{timep}=$arg]}&quot;</span> used in
    the above example has a two-fold purpose: first, when this line is processed
    by <b>xsubpp</b>, the Perl snippet
    <span class="Li">&quot;$v{timep}=$arg&quot;</span> is evaluated. Second, the
    text of the evaluated snippet is output into the generated C file (inside a
    C comment)! During the processing of <span class="Li">&quot;char
    *host&quot;</span> line, <span class="Li">$arg</span> will evaluate to
    <span class="Li">ST(0)</span>, and <span class="Li">$v{timep}</span> will
    evaluate to <span class="Li">ST(1)</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Default_Parameter_Values"><a class="permalink" href="#Default_Parameter_Values">Default
  Parameter Values</a></h2>
<p class="Pp">Default values for XSUB arguments can be specified by placing an
    assignment statement in the parameter list. The default value may be a
    number, a string or the special string
    <span class="Li">&quot;NO_INIT&quot;</span>. Defaults should always be used
    on the right-most parameters only.</p>
<p class="Pp">To allow the XSUB for <i>rpcb_gettime()</i> to have a default host
    value the parameters to the XSUB could be rearranged. The XSUB will then
    call the real <i>rpcb_gettime()</i> function with the parameters in the
    correct order. This XSUB can be called from Perl with either of the
    following statements:</p>
<p class="Pp"></p>
<pre>
     $status = rpcb_gettime( $timep, $host );

     $status = rpcb_gettime( $timep );
</pre>
<p class="Pp">The XSUB will look like the code which follows. A CODE: block is
    used to call the real <i>rpcb_gettime()</i> function with the parameters in
    the correct order for that function.</p>
<p class="Pp"></p>
<pre>
     bool_t
     rpcb_gettime(timep,host=&quot;localhost&quot;)
          char *host
          time_t timep = NO_INIT
        CODE:
               RETVAL = rpcb_gettime( host, &amp;timep );
        OUTPUT:
          timep
          RETVAL
</pre>
</section>
<section class="Ss">
<h2 class="Ss">The PREINIT: Keyword</h2>
<p class="Pp">The PREINIT: keyword allows extra variables to be declared
    immediately before or after the declarations of the parameters from the
    INPUT: section are emitted.</p>
<p class="Pp">If a variable is declared inside a CODE: section it will follow
    any typemap code that is emitted for the input parameters. This may result
    in the declaration ending up after C code, which is C syntax error. Similar
    errors may happen with an explicit
    <span class="Li">&quot;;&quot;</span>-type or
    <span class="Li">&quot;+&quot;</span>-type initialization of parameters is
    used (see &quot;Initializing Function Parameters&quot;). Declaring these
    variables in an INIT: section will not help.</p>
<p class="Pp">In such cases, to force an additional variable to be declared
    together with declarations of other variables, place the declaration into a
    PREINIT: section. The PREINIT: keyword may be used one or more times within
    an XSUB.</p>
<p class="Pp">The following examples are equivalent, but if the code is using
    complex typemaps then the first example is safer.</p>
<p class="Pp"></p>
<pre>
     bool_t
     rpcb_gettime(timep)
          time_t timep = NO_INIT
        PREINIT:
          char *host = &quot;localhost&quot;;
        CODE:
          RETVAL = rpcb_gettime( host, &amp;timep );
        OUTPUT:
          timep
          RETVAL
</pre>
<p class="Pp">For this particular case an INIT: keyword would generate the same
    C code as the PREINIT: keyword. Another correct, but error-prone
  example:</p>
<p class="Pp"></p>
<pre>
     bool_t
     rpcb_gettime(timep)
          time_t timep = NO_INIT
        CODE:
          char *host = &quot;localhost&quot;;
          RETVAL = rpcb_gettime( host, &amp;timep );
        OUTPUT:
          timep
          RETVAL
</pre>
<p class="Pp">Another way to declare <span class="Li">&quot;host&quot;</span> is
    to use a C block in the CODE: section:</p>
<p class="Pp"></p>
<pre>
     bool_t
     rpcb_gettime(timep)
          time_t timep = NO_INIT
        CODE:
          {
            char *host = &quot;localhost&quot;;
            RETVAL = rpcb_gettime( host, &amp;timep );
          }
        OUTPUT:
          timep
          RETVAL
</pre>
<p class="Pp">The ability to put additional declarations before the typemap
    entries are processed is very handy in the cases when typemap conversions
    manipulate some global state:</p>
<p class="Pp"></p>
<pre>
    MyObject
    mutate(o)
        PREINIT:
            MyState st = global_state;
        INPUT:
            MyObject o;
        CLEANUP:
            reset_to(global_state, st);
</pre>
<p class="Pp">Here we suppose that conversion to
    <span class="Li">&quot;MyObject&quot;</span> in the INPUT: section and from
    MyObject when processing RETVAL will modify a global variable
    <span class="Li">&quot;global_state&quot;</span>. After these conversions
    are performed, we restore the old value of
    <span class="Li">&quot;global_state&quot;</span> (to avoid memory leaks, for
    example).</p>
<p class="Pp">There is another way to trade clarity for compactness: INPUT
    sections allow declaration of C variables which do not appear in the
    parameter list of a subroutine. Thus the above code for <i>mutate()</i> can
    be rewritten as</p>
<p class="Pp"></p>
<pre>
    MyObject
    mutate(o)
          MyState st = global_state;
          MyObject o;
        CLEANUP:
          reset_to(global_state, st);
</pre>
<p class="Pp">and the code for <i>rpcb_gettime()</i> can be rewritten as</p>
<p class="Pp"></p>
<pre>
     bool_t
     rpcb_gettime(timep)
          time_t timep = NO_INIT
          char *host = &quot;localhost&quot;;
        C_ARGS:
          host, &amp;timep
        OUTPUT:
          timep
          RETVAL
</pre>
</section>
<section class="Ss">
<h2 class="Ss">The SCOPE: Keyword</h2>
<p class="Pp">The SCOPE: keyword allows scoping to be enabled for a particular
    XSUB. If enabled, the XSUB will invoke ENTER and LEAVE automatically.</p>
<p class="Pp">To support potentially complex type mappings, if a typemap entry
    used by an XSUB contains a comment like
    <span class="Li">&quot;/*scope*/&quot;</span> then scoping will be
    automatically enabled for that XSUB.</p>
<p class="Pp">To enable scoping:</p>
<p class="Pp"></p>
<pre>
    SCOPE: ENABLE
</pre>
<p class="Pp">To disable scoping:</p>
<p class="Pp"></p>
<pre>
    SCOPE: DISABLE
</pre>
</section>
<section class="Ss">
<h2 class="Ss">The INPUT: Keyword</h2>
<p class="Pp">The XSUB's parameters are usually evaluated immediately after
    entering the XSUB. The INPUT: keyword can be used to force those parameters
    to be evaluated a little later. The INPUT: keyword can be used multiple
    times within an XSUB and can be used to list one or more input variables.
    This keyword is used with the PREINIT: keyword.</p>
<p class="Pp">The following example shows how the input parameter
    <span class="Li">&quot;timep&quot;</span> can be evaluated late, after a
    PREINIT.</p>
<p class="Pp"></p>
<pre>
    bool_t
    rpcb_gettime(host,timep)
          char *host
        PREINIT:
          time_t tt;
        INPUT:
          time_t timep
        CODE:
               RETVAL = rpcb_gettime( host, &amp;tt );
               timep = tt;
        OUTPUT:
          timep
          RETVAL
</pre>
<p class="Pp">The next example shows each input parameter evaluated late.</p>
<p class="Pp"></p>
<pre>
    bool_t
    rpcb_gettime(host,timep)
        PREINIT:
          time_t tt;
        INPUT:
          char *host
        PREINIT:
          char *h;
        INPUT:
          time_t timep
        CODE:
               h = host;
               RETVAL = rpcb_gettime( h, &amp;tt );
               timep = tt;
        OUTPUT:
          timep
          RETVAL
</pre>
<p class="Pp">Since INPUT sections allow declaration of C variables which do not
    appear in the parameter list of a subroutine, this may be shortened to:</p>
<p class="Pp"></p>
<pre>
    bool_t
    rpcb_gettime(host,timep)
          time_t tt;
          char *host;
          char *h = host;
          time_t timep;
        CODE:
          RETVAL = rpcb_gettime( h, &amp;tt );
          timep = tt;
        OUTPUT:
          timep
          RETVAL
</pre>
<p class="Pp">(We used our knowledge that input conversion for
    <span class="Li">&quot;char *&quot;</span> is a &quot;simple&quot; one, thus
    <span class="Li">&quot;host&quot;</span> is initialized on the declaration
    line, and our assignment <span class="Li">&quot;h = host&quot;</span> is not
    performed too early. Otherwise one would need to have the assignment
    <span class="Li">&quot;h = host&quot;</span> in a CODE: or INIT:
  section.)</p>
</section>
<section class="Ss">
<h2 class="Ss">The IN/OUTLIST/IN_OUTLIST/OUT/IN_OUT Keywords</h2>
<p class="Pp">In the list of parameters for an XSUB, one can precede parameter
    names by the
    <span class="Li">&quot;IN&quot;</span>/<span class="Li">&quot;OUTLIST&quot;</span>/<span class="Li">&quot;IN_OUTLIST&quot;</span>/<span class="Li">&quot;OUT&quot;</span>/<span class="Li">&quot;IN_OUT&quot;</span>
    keywords. <span class="Li">&quot;IN&quot;</span> keyword is the default, the
    other keywords indicate how the Perl interface should differ from the C
    interface.</p>
<p class="Pp">Parameters preceded by
    <span class="Li">&quot;OUTLIST&quot;</span>/<span class="Li">&quot;IN_OUTLIST&quot;</span>/<span class="Li">&quot;OUT&quot;</span>/<span class="Li">&quot;IN_OUT&quot;</span>
    keywords are considered to be used by the C subroutine <i>via</i>
    <i>pointers</i>.
    <span class="Li">&quot;OUTLIST&quot;</span>/<span class="Li">&quot;OUT&quot;</span>
    keywords indicate that the C subroutine does not inspect the memory pointed
    by this parameter, but will write through this pointer to provide additional
    return values.</p>
<p class="Pp">Parameters preceded by <span class="Li">&quot;OUTLIST&quot;</span>
    keyword do not appear in the usage signature of the generated Perl
  function.</p>
<p class="Pp">Parameters preceded by
    <span class="Li">&quot;IN_OUTLIST&quot;</span>/<span class="Li">&quot;IN_OUT&quot;</span>/<span class="Li">&quot;OUT&quot;</span>
    <i>do</i> appear as parameters to the Perl function. With the exception of
    <span class="Li">&quot;OUT&quot;</span>-parameters, these parameters are
    converted to the corresponding C type, then pointers to these data are given
    as arguments to the C function. It is expected that the C function will
    write through these pointers.</p>
<p class="Pp">The return list of the generated Perl function consists of the C
    return value from the function (unless the XSUB is of
    <span class="Li">&quot;void&quot;</span> return type or
    <span class="Li">&quot;The NO_OUTPUT Keyword&quot;</span> was used) followed
    by all the <span class="Li">&quot;OUTLIST&quot;</span> and
    <span class="Li">&quot;IN_OUTLIST&quot;</span> parameters (in the order of
    appearance). On the return from the XSUB the
    <span class="Li">&quot;IN_OUT&quot;</span>/<span class="Li">&quot;OUT&quot;</span>
    Perl parameter will be modified to have the values written by the C
    function.</p>
<p class="Pp">For example, an XSUB</p>
<p class="Pp"></p>
<pre>
  void
  day_month(OUTLIST day, IN unix_time, OUTLIST month)
    int day
    int unix_time
    int month
</pre>
<p class="Pp">should be used from Perl as</p>
<p class="Pp"></p>
<pre>
  my ($day, $month) = day_month(time);
</pre>
<p class="Pp">The C signature of the corresponding function should be</p>
<p class="Pp"></p>
<pre>
  void day_month(int *day, int unix_time, int *month);
</pre>
<p class="Pp">The
    <span class="Li">&quot;IN&quot;</span>/<span class="Li">&quot;OUTLIST&quot;</span>/<span class="Li">&quot;IN_OUTLIST&quot;</span>/<span class="Li">&quot;IN_OUT&quot;</span>/<span class="Li">&quot;OUT&quot;</span>
    keywords can be mixed with ANSI-style declarations, as in</p>
<p class="Pp"></p>
<pre>
  void
  day_month(OUTLIST int day, int unix_time, OUTLIST int month)
</pre>
<p class="Pp">(here the optional <span class="Li">&quot;IN&quot;</span> keyword
    is omitted).</p>
<p class="Pp">The <span class="Li">&quot;IN_OUT&quot;</span> parameters are
    identical with parameters introduced with &quot;The &amp; Unary
    Operator&quot; and put into the <span class="Li">&quot;OUTPUT:&quot;</span>
    section (see &quot;The OUTPUT: Keyword&quot;). The
    <span class="Li">&quot;IN_OUTLIST&quot;</span> parameters are very similar,
    the only difference being that the value C function writes through the
    pointer would not modify the Perl parameter, but is put in the output
  list.</p>
<p class="Pp">The
    <span class="Li">&quot;OUTLIST&quot;</span>/<span class="Li">&quot;OUT&quot;</span>
    parameter differ from
    <span class="Li">&quot;IN_OUTLIST&quot;</span>/<span class="Li">&quot;IN_OUT&quot;</span>
    parameters only by the initial value of the Perl parameter not being read
    (and not being given to the C function - which gets some garbage instead).
    For example, the same C function as above can be interfaced with as</p>
<p class="Pp"></p>
<pre>
  void day_month(OUT int day, int unix_time, OUT int month);
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre>
  void
  day_month(day, unix_time, month)
      int &amp;day = NO_INIT
      int  unix_time
      int &amp;month = NO_INIT
    OUTPUT:
      day
      month
</pre>
<p class="Pp">However, the generated Perl function is called in very C-ish
    style:</p>
<p class="Pp"></p>
<pre>
  my ($day, $month);
  day_month($day, time, $month);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The__length(NAME)__Keyword"><a class="permalink" href="#The__length(NAME)__Keyword">The
  &quot;length(NAME)&quot; Keyword</a></h2>
<p class="Pp">If one of the input arguments to the C function is the length of a
    string argument <span class="Li">&quot;NAME&quot;</span>, one can substitute
    the name of the length-argument by
    <span class="Li">&quot;length(NAME)&quot;</span> in the XSUB declaration.
    This argument must be omitted when the generated Perl function is called.
    E.g.,</p>
<p class="Pp"></p>
<pre>
  void
  dump_chars(char *s, short l)
  {
    short n = 0;
    while (n &lt; l) {
        printf(&quot;s[%d] = \&quot;\\%#03o\&quot;\n&quot;, n, (int)s[n]);
        n++;
    }
  }

  MODULE = x            PACKAGE = x

  void dump_chars(char *s, short length(s))
</pre>
<p class="Pp">should be called as
    <span class="Li">&quot;dump_chars($string)&quot;</span>.</p>
<p class="Pp">This directive is supported with ANSI-type function declarations
    only.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Variable-length_Parameter_Lists"><a class="permalink" href="#Variable-length_Parameter_Lists">Variable-length
  Parameter Lists</a></h2>
<p class="Pp">XSUBs can have variable-length parameter lists by specifying an
    ellipsis <span class="Li">&quot;(...)&quot;</span> in the parameter list.
    This use of the ellipsis is similar to that found in ANSI C. The programmer
    is able to determine the number of arguments passed to the XSUB by examining
    the <span class="Li">&quot;items&quot;</span> variable which the
    <b>xsubpp</b> compiler supplies for all XSUBs. By using this mechanism one
    can create an XSUB which accepts a list of parameters of unknown length.</p>
<p class="Pp">The <i>host</i> parameter for the <i>rpcb_gettime()</i> XSUB can
    be optional so the ellipsis can be used to indicate that the XSUB will take
    a variable number of parameters. Perl should be able to call this XSUB with
    either of the following statements.</p>
<p class="Pp"></p>
<pre>
     $status = rpcb_gettime( $timep, $host );

     $status = rpcb_gettime( $timep );
</pre>
<p class="Pp">The XS code, with ellipsis, follows.</p>
<p class="Pp"></p>
<pre>
     bool_t
     rpcb_gettime(timep, ...)
          time_t timep = NO_INIT
        PREINIT:
          char *host = &quot;localhost&quot;;
        CODE:
          if( items &gt; 1 )
               host = (char *)SvPV_nolen(ST(1));
          RETVAL = rpcb_gettime( host, &amp;timep );
        OUTPUT:
          timep
          RETVAL
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="The_C_ARGS:_Keyword"><a class="permalink" href="#The_C_ARGS:_Keyword">The
  C_ARGS: Keyword</a></h2>
<p class="Pp">The C_ARGS: keyword allows creating of XSUBS which have different
    calling sequence from Perl than from C, without a need to write CODE: or
    PPCODE: section. The contents of the C_ARGS: paragraph is put as the
    argument to the called C function without any change.</p>
<p class="Pp">For example, suppose that a C function is declared as</p>
<p class="Pp"></p>
<pre>
    symbolic nth_derivative(int n, symbolic function, int flags);
</pre>
<p class="Pp">and that the default flags are kept in a global C variable
    <span class="Li">&quot;default_flags&quot;</span>. Suppose that you want to
    create an interface which is called as</p>
<p class="Pp"></p>
<pre>
    $second_deriv = $function-&gt;nth_derivative(2);
</pre>
<p class="Pp">To do this, declare the XSUB as</p>
<p class="Pp"></p>
<pre>
    symbolic
    nth_derivative(function, n)
        symbolic        function
        int             n
      C_ARGS:
        n, function, default_flags
</pre>
</section>
<section class="Ss">
<h2 class="Ss">The PPCODE: Keyword</h2>
<p class="Pp">The PPCODE: keyword is an alternate form of the CODE: keyword and
    is used to tell the <b>xsubpp</b> compiler that the programmer is supplying
    the code to control the argument stack for the XSUBs return values.
    Occasionally one will want an XSUB to return a list of values rather than a
    single value. In these cases one must use PPCODE: and then explicitly push
    the list of values on the stack. The PPCODE: and CODE: keywords should not
    be used together within the same XSUB.</p>
<p class="Pp">The actual difference between PPCODE: and CODE: sections is in the
    initialization of <span class="Li">&quot;SP&quot;</span> macro (which stands
    for the <i>current</i> Perl stack pointer), and in the handling of data on
    the stack when returning from an XSUB. In CODE: sections SP preserves the
    value which was on entry to the XSUB: SP is on the function pointer (which
    follows the last parameter). In PPCODE: sections SP is moved backward to the
    beginning of the parameter list, which allows
    <span class="Li">&quot;PUSH*()&quot;</span> macros to place output values in
    the place Perl expects them to be when the XSUB returns back to Perl.</p>
<p class="Pp">The generated trailer for a CODE: section ensures that the number
    of return values Perl will see is either 0 or 1 (depending on the
    <span class="Li">&quot;void&quot;</span>ness of the return value of the C
    function, and heuristics mentioned in &quot;The RETVAL Variable&quot;). The
    trailer generated for a PPCODE: section is based on the number of return
    values and on the number of times <span class="Li">&quot;SP&quot;</span> was
    updated by <span class="Li">&quot;[X]PUSH*()&quot;</span> macros.</p>
<p class="Pp">Note that macros <span class="Li">ST(i)</span>,
    <span class="Li">&quot;XST_m*()&quot;</span> and
    <span class="Li">&quot;XSRETURN*()&quot;</span> work equally well in CODE:
    sections and PPCODE: sections.</p>
<p class="Pp">The following XSUB will call the C <i>rpcb_gettime()</i> function
    and will return its two output values, timep and status, to Perl as a single
    list.</p>
<p class="Pp"></p>
<pre>
     void
     rpcb_gettime(host)
          char *host
        PREINIT:
          time_t  timep;
          bool_t  status;
        PPCODE:
          status = rpcb_gettime( host, &amp;timep );
          EXTEND(SP, 2);
          PUSHs(sv_2mortal(newSViv(status)));
          PUSHs(sv_2mortal(newSViv(timep)));
</pre>
<p class="Pp">Notice that the programmer must supply the C code necessary to
    have the real <i>rpcb_gettime()</i> function called and to have the return
    values properly placed on the argument stack.</p>
<p class="Pp">The <span class="Li">&quot;void&quot;</span> return type for this
    function tells the <b>xsubpp</b> compiler that the RETVAL variable is not
    needed or used and that it should not be created. In most scenarios the void
    return type should be used with the PPCODE: directive.</p>
<p class="Pp">The <i>EXTEND()</i> macro is used to make room on the argument
    stack for 2 return values. The PPCODE: directive causes the <b>xsubpp</b>
    compiler to create a stack pointer available as
    <span class="Li">&quot;SP&quot;</span>, and it is this pointer which is
    being used in the <i>EXTEND()</i> macro. The values are then pushed onto the
    stack with the <i>PUSHs()</i> macro.</p>
<p class="Pp">Now the <i>rpcb_gettime()</i> function can be used from Perl with
    the following statement.</p>
<p class="Pp"></p>
<pre>
     ($status, $timep) = rpcb_gettime(&quot;localhost&quot;);
</pre>
<p class="Pp">When handling output parameters with a PPCODE section, be sure to
    handle 'set' magic properly. See perlguts for details about 'set' magic.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Returning_Undef_And_Empty_Lists"><a class="permalink" href="#Returning_Undef_And_Empty_Lists">Returning
  Undef And Empty Lists</a></h2>
<p class="Pp">Occasionally the programmer will want to return simply
    <span class="Li">&quot;undef&quot;</span> or an empty list if a function
    fails rather than a separate status value. The <i>rpcb_gettime()</i>
    function offers just this situation. If the function succeeds we would like
    to have it return the time and if it fails we would like to have undef
    returned. In the following Perl code the value of
    <span class="Li">$timep</span> will either be undef or it will be a valid
    time.</p>
<p class="Pp"></p>
<pre>
     $timep = rpcb_gettime( &quot;localhost&quot; );
</pre>
<p class="Pp">The following XSUB uses the <span class="Li">&quot;SV
    *&quot;</span> return type as a mnemonic only, and uses a CODE: block to
    indicate to the compiler that the programmer has supplied all the necessary
    code. The <i>sv_newmortal()</i> call will initialize the return value to
    undef, making that the default return value.</p>
<p class="Pp"></p>
<pre>
     SV *
     rpcb_gettime(host)
          char *  host
        PREINIT:
          time_t  timep;
          bool_t x;
        CODE:
          ST(0) = sv_newmortal();
          if( rpcb_gettime( host, &amp;timep ) )
               sv_setnv( ST(0), (double)timep);
</pre>
<p class="Pp">The next example demonstrates how one would place an explicit
    undef in the return value, should the need arise.</p>
<p class="Pp"></p>
<pre>
     SV *
     rpcb_gettime(host)
          char *  host
        PREINIT:
          time_t  timep;
          bool_t x;
        CODE:
          if( rpcb_gettime( host, &amp;timep ) ){
               ST(0) = sv_newmortal();
               sv_setnv( ST(0), (double)timep);
          }
          else{
               ST(0) = &amp;PL_sv_undef;
          }
</pre>
<p class="Pp">To return an empty list one must use a PPCODE: block and then not
    push return values on the stack.</p>
<p class="Pp"></p>
<pre>
     void
     rpcb_gettime(host)
          char *host
        PREINIT:
          time_t  timep;
        PPCODE:
          if( rpcb_gettime( host, &amp;timep ) )
               PUSHs(sv_2mortal(newSViv(timep)));
          else{
              /* Nothing pushed on stack, so an empty
               * list is implicitly returned. */
          }
</pre>
<p class="Pp">Some people may be inclined to include an explicit
    <span class="Li">&quot;return&quot;</span> in the above XSUB, rather than
    letting control fall through to the end. In those situations
    <span class="Li">&quot;XSRETURN_EMPTY&quot;</span> should be used, instead.
    This will ensure that the XSUB stack is properly adjusted. Consult perlapi
    for other <span class="Li">&quot;XSRETURN&quot;</span> macros.</p>
<p class="Pp">Since <span class="Li">&quot;XSRETURN_*&quot;</span> macros can be
    used with CODE blocks as well, one can rewrite this example as:</p>
<p class="Pp"></p>
<pre>
     int
     rpcb_gettime(host)
          char *host
        PREINIT:
          time_t  timep;
        CODE:
          RETVAL = rpcb_gettime( host, &amp;timep );
          if (RETVAL == 0)
                XSRETURN_UNDEF;
        OUTPUT:
          RETVAL
</pre>
<p class="Pp">In fact, one can put this check into a POSTCALL: section as well.
    Together with PREINIT: simplifications, this leads to:</p>
<p class="Pp"></p>
<pre>
     int
     rpcb_gettime(host)
          char *host
          time_t  timep;
        POSTCALL:
          if (RETVAL == 0)
                XSRETURN_UNDEF;
</pre>
</section>
<section class="Ss">
<h2 class="Ss">The REQUIRE: Keyword</h2>
<p class="Pp">The REQUIRE: keyword is used to indicate the minimum version of
    the <b>xsubpp</b> compiler needed to compile the XS module. An XS module
    which contains the following statement will compile with only <b>xsubpp</b>
    version 1.922 or greater:</p>
<p class="Pp"></p>
<pre>
        REQUIRE: 1.922
</pre>
</section>
<section class="Ss">
<h2 class="Ss">The CLEANUP: Keyword</h2>
<p class="Pp">This keyword can be used when an XSUB requires special cleanup
    procedures before it terminates. When the CLEANUP: keyword is used it must
    follow any CODE:, PPCODE:, or OUTPUT: blocks which are present in the XSUB.
    The code specified for the cleanup block will be added as the last
    statements in the XSUB.</p>
</section>
<section class="Ss">
<h2 class="Ss">The POSTCALL: Keyword</h2>
<p class="Pp">This keyword can be used when an XSUB requires special procedures
    executed after the C subroutine call is performed. When the POSTCALL:
    keyword is used it must precede OUTPUT: and CLEANUP: blocks which are
    present in the XSUB.</p>
<p class="Pp">See examples in &quot;The NO_OUTPUT Keyword&quot; and
    &quot;Returning Undef And Empty Lists&quot;.</p>
<p class="Pp">The POSTCALL: block does not make a lot of sense when the C
    subroutine call is supplied by user by providing either CODE: or PPCODE:
    section.</p>
</section>
<section class="Ss">
<h2 class="Ss">The BOOT: Keyword</h2>
<p class="Pp">The BOOT: keyword is used to add code to the extension's bootstrap
    function. The bootstrap function is generated by the <b>xsubpp</b> compiler
    and normally holds the statements necessary to register any XSUBs with Perl.
    With the BOOT: keyword the programmer can tell the compiler to add extra
    statements to the bootstrap function.</p>
<p class="Pp">This keyword may be used any time after the first MODULE keyword
    and should appear on a line by itself. The first blank line after the
    keyword will terminate the code block.</p>
<p class="Pp"></p>
<pre>
     BOOT:
     # The following message will be printed when the
     # bootstrap function executes.
     printf(&quot;Hello from the bootstrap!\n&quot;);
</pre>
</section>
<section class="Ss">
<h2 class="Ss">The VERSIONCHECK: Keyword</h2>
<p class="Pp">The VERSIONCHECK: keyword corresponds to <b>xsubpp</b>'s
    <span class="Li">&quot;-versioncheck&quot;</span> and
    <span class="Li">&quot;-noversioncheck&quot;</span> options. This keyword
    overrides the command line options. Version checking is enabled by default.
    When version checking is enabled the XS module will attempt to verify that
    its version matches the version of the PM module.</p>
<p class="Pp">To enable version checking:</p>
<p class="Pp"></p>
<pre>
    VERSIONCHECK: ENABLE
</pre>
<p class="Pp">To disable version checking:</p>
<p class="Pp"></p>
<pre>
    VERSIONCHECK: DISABLE
</pre>
<p class="Pp">Note that if the version of the PM module is an NV (a floating
    point number), it will be stringified with a possible loss of precision
    (currently chopping to nine decimal places) so that it may not match the
    version of the XS module anymore. Quoting the
    <span class="Li">$VERSION</span> declaration to make it a string is
    recommended if long version numbers are used.</p>
</section>
<section class="Ss">
<h2 class="Ss">The PROTOTYPES: Keyword</h2>
<p class="Pp">The PROTOTYPES: keyword corresponds to <b>xsubpp</b>'s
    <span class="Li">&quot;-prototypes&quot;</span> and
    <span class="Li">&quot;-noprototypes&quot;</span> options. This keyword
    overrides the command line options. Prototypes are enabled by default. When
    prototypes are enabled XSUBs will be given Perl prototypes. This keyword may
    be used multiple times in an XS module to enable and disable prototypes for
    different parts of the module.</p>
<p class="Pp">To enable prototypes:</p>
<p class="Pp"></p>
<pre>
    PROTOTYPES: ENABLE
</pre>
<p class="Pp">To disable prototypes:</p>
<p class="Pp"></p>
<pre>
    PROTOTYPES: DISABLE
</pre>
</section>
<section class="Ss">
<h2 class="Ss">The PROTOTYPE: Keyword</h2>
<p class="Pp">This keyword is similar to the PROTOTYPES: keyword above but can
    be used to force <b>xsubpp</b> to use a specific prototype for the XSUB.
    This keyword overrides all other prototype options and keywords but affects
    only the current XSUB. Consult &quot;Prototypes&quot; in perlsub for
    information about Perl prototypes.</p>
<p class="Pp"></p>
<pre>
    bool_t
    rpcb_gettime(timep, ...)
          time_t timep = NO_INIT
        PROTOTYPE: $;$
        PREINIT:
          char *host = &quot;localhost&quot;;
        CODE:
                  if( items &gt; 1 )
                       host = (char *)SvPV_nolen(ST(1));
                  RETVAL = rpcb_gettime( host, &amp;timep );
        OUTPUT:
          timep
          RETVAL
</pre>
<p class="Pp">If the prototypes are enabled, you can disable it locally for a
    given XSUB as in the following example:</p>
<p class="Pp"></p>
<pre>
    void
    rpcb_gettime_noproto()
        PROTOTYPE: DISABLE
    ...
</pre>
</section>
<section class="Ss">
<h2 class="Ss">The ALIAS: Keyword</h2>
<p class="Pp">The ALIAS: keyword allows an XSUB to have two or more unique Perl
    names and to know which of those names was used when it was invoked. The
    Perl names may be fully-qualified with package names. Each alias is given an
    index. The compiler will setup a variable called
    <span class="Li">&quot;ix&quot;</span> which contain the index of the alias
    which was used. When the XSUB is called with its declared name
    <span class="Li">&quot;ix&quot;</span> will be 0.</p>
<p class="Pp">The following example will create aliases
    <span class="Li">&quot;FOO::gettime()&quot;</span> and
    <span class="Li">&quot;BAR::getit()&quot;</span> for this function.</p>
<p class="Pp"></p>
<pre>
    bool_t
    rpcb_gettime(host,timep)
          char *host
          time_t &amp;timep
        ALIAS:
            FOO::gettime = 1
            BAR::getit = 2
        INIT:
          printf(&quot;# ix = %d\n&quot;, ix );
        OUTPUT:
          timep
</pre>
</section>
<section class="Ss">
<h2 class="Ss">The OVERLOAD: Keyword</h2>
<p class="Pp">Instead of writing an overloaded interface using pure Perl, you
    can also use the OVERLOAD keyword to define additional Perl names for your
    functions (like the ALIAS: keyword above). However, the overloaded functions
    must be defined with three parameters (except for the <i>nomethod()</i>
    function which needs four parameters). If any function has the OVERLOAD:
    keyword, several additional lines will be defined in the c file generated by
    xsubpp in order to register with the overload magic.</p>
<p class="Pp">Since blessed objects are actually stored as RV's, it is useful to
    use the typemap features to preprocess parameters and extract the actual SV
    stored within the blessed RV. See the sample for T_PTROBJ_SPECIAL below.</p>
<p class="Pp">To use the OVERLOAD: keyword, create an XS function which takes
    three input parameters ( or use the c style '...' definition) like this:</p>
<p class="Pp"></p>
<pre>
    SV *
    cmp (lobj, robj, swap)
    My_Module_obj    lobj
    My_Module_obj    robj
    IV               swap
    OVERLOAD: cmp &lt;=&gt;
    { /* function defined here */}
</pre>
<p class="Pp">In this case, the function will overload both of the three way
    comparison operators. For all overload operations using non-alpha
    characters, you must type the parameter without quoting, separating multiple
    overloads with whitespace. Note that &quot;&quot; (the stringify overload)
    should be entered as \&quot;\&quot; (i.e. escaped).</p>
</section>
<section class="Ss">
<h2 class="Ss">The FALLBACK: Keyword</h2>
<p class="Pp">In addition to the OVERLOAD keyword, if you need to control how
    Perl autogenerates missing overloaded operators, you can set the FALLBACK
    keyword in the module header section, like this:</p>
<p class="Pp"></p>
<pre>
    MODULE = RPC  PACKAGE = RPC

    FALLBACK: TRUE
    ...
</pre>
<p class="Pp">where FALLBACK can take any of the three values TRUE, FALSE, or
    UNDEF. If you do not set any FALLBACK value when using OVERLOAD, it defaults
    to UNDEF. FALLBACK is not used except when one or more functions using
    OVERLOAD have been defined. Please see &quot;fallback&quot; in overload for
    more details.</p>
</section>
<section class="Ss">
<h2 class="Ss">The INTERFACE: Keyword</h2>
<p class="Pp">This keyword declares the current XSUB as a keeper of the given
    calling signature. If some text follows this keyword, it is considered as a
    list of functions which have this signature, and should be attached to the
    current XSUB.</p>
<p class="Pp">For example, if you have 4 C functions <i>multiply()</i>,
    <i>divide()</i>, <i>add()</i>, <i>subtract()</i> all having the
  signature:</p>
<p class="Pp"></p>
<pre>
    symbolic f(symbolic, symbolic);
</pre>
<p class="Pp">you can make them all to use the same XSUB using this:</p>
<p class="Pp"></p>
<pre>
    symbolic
    interface_s_ss(arg1, arg2)
        symbolic        arg1
        symbolic        arg2
    INTERFACE:
        multiply divide
        add subtract
</pre>
<p class="Pp">(This is the complete XSUB code for 4 Perl functions!) Four
    generated Perl function share names with corresponding C functions.</p>
<p class="Pp">The advantage of this approach comparing to ALIAS: keyword is that
    there is no need to code a switch statement, each Perl function (which
    shares the same XSUB) knows which C function it should call. Additionally,
    one can attach an extra function <i>remainder()</i> at runtime by using</p>
<p class="Pp"></p>
<pre>
    CV *mycv = newXSproto(&quot;Symbolic::remainder&quot;,
                          XS_Symbolic_interface_s_ss, __FILE__, &quot;$$&quot;);
    XSINTERFACE_FUNC_SET(mycv, remainder);
</pre>
<p class="Pp">say, from another XSUB. (This example supposes that there was no
    INTERFACE_MACRO: section, otherwise one needs to use something else instead
    of <span class="Li">&quot;XSINTERFACE_FUNC_SET&quot;</span>, see the next
    section.)</p>
</section>
<section class="Ss">
<h2 class="Ss">The INTERFACE_MACRO: Keyword</h2>
<p class="Pp">This keyword allows one to define an INTERFACE using a different
    way to extract a function pointer from an XSUB. The text which follows this
    keyword should give the name of macros which would extract/set a function
    pointer. The extractor macro is given return type,
    <span class="Li">&quot;CV*&quot;</span>, and
    <span class="Li">&quot;XSANY.any_dptr&quot;</span> for this
    <span class="Li">&quot;CV*&quot;</span>. The setter macro is given cv, and
    the function pointer.</p>
<p class="Pp">The default value is
    <span class="Li">&quot;XSINTERFACE_FUNC&quot;</span> and
    <span class="Li">&quot;XSINTERFACE_FUNC_SET&quot;</span>. An INTERFACE
    keyword with an empty list of functions can be omitted if INTERFACE_MACRO
    keyword is used.</p>
<p class="Pp">Suppose that in the previous example functions pointers for
    <i>multiply()</i>, <i>divide()</i>, <i>add()</i>, <i>subtract()</i> are kept
    in a global C array <span class="Li">&quot;fp[]&quot;</span> with offsets
    being <span class="Li">&quot;multiply_off&quot;</span>,
    <span class="Li">&quot;divide_off&quot;</span>,
    <span class="Li">&quot;add_off&quot;</span>,
    <span class="Li">&quot;subtract_off&quot;</span>. Then one can use</p>
<p class="Pp"></p>
<pre>
    #define XSINTERFACE_FUNC_BYOFFSET(ret,cv,f) \
        ((XSINTERFACE_CVT_ANON(ret))fp[CvXSUBANY(cv).any_i32])
    #define XSINTERFACE_FUNC_BYOFFSET_set(cv,f) \
        CvXSUBANY(cv).any_i32 = CAT2( f, _off )
</pre>
<p class="Pp">in C section,</p>
<p class="Pp"></p>
<pre>
    symbolic
    interface_s_ss(arg1, arg2)
        symbolic        arg1
        symbolic        arg2
      INTERFACE_MACRO:
        XSINTERFACE_FUNC_BYOFFSET
        XSINTERFACE_FUNC_BYOFFSET_set
      INTERFACE:
        multiply divide
        add subtract
</pre>
<p class="Pp">in XSUB section.</p>
</section>
<section class="Ss">
<h2 class="Ss">The INCLUDE: Keyword</h2>
<p class="Pp">This keyword can be used to pull other files into the XS module.
    The other files may have XS code. INCLUDE: can also be used to run a command
    to generate the XS code to be pulled into the module.</p>
<p class="Pp">The file <i>Rpcb1.xsh</i> contains our
    <span class="Li">&quot;rpcb_gettime()&quot;</span> function:</p>
<p class="Pp"></p>
<pre>
    bool_t
    rpcb_gettime(host,timep)
          char *host
          time_t &amp;timep
        OUTPUT:
          timep
</pre>
<p class="Pp">The XS module can use INCLUDE: to pull that file into it.</p>
<p class="Pp"></p>
<pre>
    INCLUDE: Rpcb1.xsh
</pre>
<p class="Pp">If the parameters to the INCLUDE: keyword are followed by a pipe
    (<span class="Li">&quot;|&quot;</span>) then the compiler will interpret the
    parameters as a command. This feature is mildly deprecated in favour of the
    <span class="Li">&quot;INCLUDE_COMMAND:&quot;</span> directive, as
    documented below.</p>
<p class="Pp"></p>
<pre>
    INCLUDE: cat Rpcb1.xsh |
</pre>
<p class="Pp">Do not use this to run perl: <span class="Li">&quot;INCLUDE: perl
    |&quot;</span> will run the perl that happens to be the first in your path
    and not necessarily the same perl that is used to run
    <span class="Li">&quot;xsubpp&quot;</span>. See &quot;The INCLUDE_COMMAND:
    Keyword&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss">The INCLUDE_COMMAND: Keyword</h2>
<p class="Pp">Runs the supplied command and includes its output into the current
    XS document. <span class="Li">&quot;INCLUDE_COMMAND&quot;</span> assigns
    special meaning to the <span class="Li">$^X</span> token in that it runs the
    same perl interpreter that is running
    <span class="Li">&quot;xsubpp&quot;</span>:</p>
<p class="Pp"></p>
<pre>
    INCLUDE_COMMAND: cat Rpcb1.xsh

    INCLUDE_COMMAND: $^X -e ...
</pre>
</section>
<section class="Ss">
<h2 class="Ss">The CASE: Keyword</h2>
<p class="Pp">The CASE: keyword allows an XSUB to have multiple distinct parts
    with each part acting as a virtual XSUB. CASE: is greedy and if it is used
    then all other XS keywords must be contained within a CASE:. This means
    nothing may precede the first CASE: in the XSUB and anything following the
    last CASE: is included in that case.</p>
<p class="Pp">A CASE: might switch via a parameter of the XSUB, via the
    <span class="Li">&quot;ix&quot;</span> ALIAS: variable (see &quot;The ALIAS:
    Keyword&quot;), or maybe via the <span class="Li">&quot;items&quot;</span>
    variable (see &quot;Variable-length Parameter Lists&quot;). The last CASE:
    becomes the <b>default</b> case if it is not associated with a conditional.
    The following example shows CASE switched via
    <span class="Li">&quot;ix&quot;</span> with a function
    <span class="Li">&quot;rpcb_gettime()&quot;</span> having an alias
    <span class="Li">&quot;x_gettime()&quot;</span>. When the function is called
    as <span class="Li">&quot;rpcb_gettime()&quot;</span> its parameters are the
    usual <span class="Li">&quot;(char *host, time_t *timep)&quot;</span>, but
    when the function is called as
    <span class="Li">&quot;x_gettime()&quot;</span> its parameters are reversed,
    <span class="Li">&quot;(time_t *timep, char *host)&quot;</span>.</p>
<p class="Pp"></p>
<pre>
    long
    rpcb_gettime(a,b)
      CASE: ix == 1
        ALIAS:
          x_gettime = 1
        INPUT:
          # 'a' is timep, 'b' is host
          char *b
          time_t a = NO_INIT
        CODE:
               RETVAL = rpcb_gettime( b, &amp;a );
        OUTPUT:
          a
          RETVAL
      CASE:
          # 'a' is host, 'b' is timep
          char *a
          time_t &amp;b = NO_INIT
        OUTPUT:
          b
          RETVAL
</pre>
<p class="Pp">That function can be called with either of the following
    statements. Note the different argument lists.</p>
<p class="Pp"></p>
<pre>
        $status = rpcb_gettime( $host, $timep );

        $status = x_gettime( $timep, $host );
</pre>
</section>
<section class="Ss">
<h2 class="Ss">The EXPORT_XSUB_SYMBOLS: Keyword</h2>
<p class="Pp">The EXPORT_XSUB_SYMBOLS: keyword is likely something you will
    never need. In perl versions earlier than 5.16.0, this keyword does nothing.
    Starting with 5.16, XSUB symbols are no longer exported by default. That is,
    they are <span class="Li">&quot;static&quot;</span> functions. If you
    include</p>
<p class="Pp"></p>
<pre>
  EXPORT_XSUB_SYMBOLS: ENABLE
</pre>
<p class="Pp">in your XS code, the XSUBs following this line will not be
    declared <span class="Li">&quot;static&quot;</span>. You can later disable
    this with</p>
<p class="Pp"></p>
<pre>
  EXPORT_XSUB_SYMBOLS: DISABLE
</pre>
<p class="Pp">which, again, is the default that you should probably never
    change. You cannot use this keyword on versions of perl before 5.16 to make
    XSUBs <span class="Li">&quot;static&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_&amp;_Unary_Operator"><a class="permalink" href="#The_&amp;_Unary_Operator">The
  &amp; Unary Operator</a></h2>
<p class="Pp">The <span class="Li">&quot;&amp;&quot;</span> unary operator in
    the INPUT: section is used to tell <b>xsubpp</b> that it should convert a
    Perl value to/from C using the C type to the left of
    <span class="Li">&quot;&amp;&quot;</span>, but provide a pointer to this
    value when the C function is called.</p>
<p class="Pp">This is useful to avoid a CODE: block for a C function which takes
    a parameter by reference. Typically, the parameter should be not a pointer
    type (an <span class="Li">&quot;int&quot;</span> or
    <span class="Li">&quot;long&quot;</span> but not an
    <span class="Li">&quot;int*&quot;</span> or
    <span class="Li">&quot;long*&quot;</span>).</p>
<p class="Pp">The following XSUB will generate incorrect C code. The
    <b>xsubpp</b> compiler will turn this into code which calls
    <span class="Li">&quot;rpcb_gettime()&quot;</span> with parameters
    <span class="Li">&quot;(char</span> <span class="Li">*host, time_t
    timep)&quot;</span>, but the real
    <span class="Li">&quot;rpcb_gettime()&quot;</span> wants the
    <span class="Li">&quot;timep&quot;</span> parameter to be of type
    <span class="Li">&quot;time_t*&quot;</span> rather than
    <span class="Li">&quot;time_t&quot;</span>.</p>
<p class="Pp"></p>
<pre>
    bool_t
    rpcb_gettime(host,timep)
          char *host
          time_t timep
        OUTPUT:
          timep
</pre>
<p class="Pp">That problem is corrected by using the
    <span class="Li">&quot;&amp;&quot;</span> operator. The <b>xsubpp</b>
    compiler will now turn this into code which calls
    <span class="Li">&quot;rpcb_gettime()&quot;</span> correctly with parameters
    <span class="Li">&quot;(char *host, time_t *timep)&quot;</span>. It does
    this by carrying the <span class="Li">&quot;&amp;&quot;</span> through, so
    the function call looks like <span class="Li">&quot;rpcb_gettime(host,
    &amp;timep)&quot;</span>.</p>
<p class="Pp"></p>
<pre>
    bool_t
    rpcb_gettime(host,timep)
          char *host
          time_t &amp;timep
        OUTPUT:
          timep
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Inserting_"><a class="permalink" href="#Inserting_">Inserting
  POD, Comments and C Preprocessor Directives</a></h2>
<p class="Pp">C preprocessor directives are allowed within BOOT:, PREINIT:
    INIT:, CODE:, PPCODE:, POSTCALL:, and CLEANUP: blocks, as well as outside
    the functions. Comments are allowed anywhere after the MODULE keyword. The
    compiler will pass the preprocessor directives through untouched and will
    remove the commented lines. POD documentation is allowed at any point, both
    in the C and XS language sections. POD must be terminated with a
    <span class="Li">&quot;=cut&quot;</span> command;
    <span class="Li">&quot;xsubpp&quot;</span> will exit with an error if it
    does not. It is very unlikely that human generated C code will be mistaken
    for POD, as most indenting styles result in whitespace in front of any line
    starting with <span class="Li">&quot;=&quot;</span>. Machine generated XS
    files may fall into this trap unless care is taken to ensure that a space
    breaks the sequence &quot;\n=&quot;.</p>
<p class="Pp">Comments can be added to XSUBs by placing a
    <span class="Li">&quot;#&quot;</span> as the first non-whitespace of a line.
    Care should be taken to avoid making the comment look like a C preprocessor
    directive, lest it be interpreted as such. The simplest way to prevent this
    is to put whitespace in front of the
  <span class="Li">&quot;#&quot;</span>.</p>
<p class="Pp">If you use preprocessor directives to choose one of two versions
    of a function, use</p>
<p class="Pp"></p>
<pre>
    #if ... version1
    #else /* ... version2  */
    #endif
</pre>
<p class="Pp">and not</p>
<p class="Pp"></p>
<pre>
    #if ... version1
    #endif
    #if ... version2
    #endif
</pre>
<p class="Pp">because otherwise <b>xsubpp</b> will believe that you made a
    duplicate definition of the function. Also, put a blank line before the
    #else/#endif so it will not be seen as part of the function body.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_"><a class="permalink" href="#Using_">Using XS With
  C++</a></h2>
<p class="Pp">If an XSUB name contains <span class="Li">&quot;::&quot;</span>,
    it is considered to be a C++ method. The generated Perl function will assume
    that its first argument is an object pointer. The object pointer will be
    stored in a variable called THIS. The object should have been created by C++
    with the <i>new()</i> function and should be blessed by Perl with the
    <i>sv_setref_pv()</i> macro. The blessing of the object by Perl can be
    handled by a typemap. An example typemap is shown at the end of this
    section.</p>
<p class="Pp">If the return type of the XSUB includes
    <span class="Li">&quot;static&quot;</span>, the method is considered to be a
    static method. It will call the C++ function using the
    <i>class::method()</i> syntax. If the method is not static the function will
    be called using the THIS-&gt;<i>method()</i> syntax.</p>
<p class="Pp">The next examples will use the following C++ class.</p>
<p class="Pp"></p>
<pre>
     class color {
          public:
          color();
          ~color();
          int blue();
          void set_blue( int );

          private:
          int c_blue;
     };
</pre>
<p class="Pp">The XSUBs for the <i>blue()</i> and <i>set_blue()</i> methods are
    defined with the class name but the parameter for the object (THIS, or
    &quot;self&quot;) is implicit and is not listed.</p>
<p class="Pp"></p>
<pre>
     int
     color::blue()

     void
     color::set_blue( val )
          int val
</pre>
<p class="Pp">Both Perl functions will expect an object as the first parameter.
    In the generated C++ code the object is called
    <span class="Li">&quot;THIS&quot;</span>, and the method call will be
    performed on this object. So in the C++ code the <i>blue()</i> and
    <i>set_blue()</i> methods will be called as this:</p>
<p class="Pp"></p>
<pre>
     RETVAL = THIS-&gt;blue();

     THIS-&gt;set_blue( val );
</pre>
<p class="Pp">You could also write a single get/set method using an optional
    argument:</p>
<p class="Pp"></p>
<pre>
     int
     color::blue( val = NO_INIT )
         int val
         PROTOTYPE $;$
         CODE:
             if (items &gt; 1)
                 THIS-&gt;set_blue( val );
             RETVAL = THIS-&gt;blue();
         OUTPUT:
             RETVAL
</pre>
<p class="Pp">If the function's name is <b>DESTROY</b> then the C++
    <span class="Li">&quot;delete&quot;</span> function will be called and
    <span class="Li">&quot;THIS&quot;</span> will be given as its parameter. The
    generated C++ code for</p>
<p class="Pp"></p>
<pre>
     void
     color::DESTROY()
</pre>
<p class="Pp">will look like this:</p>
<p class="Pp"></p>
<pre>
     color *THIS = ...; // Initialized as in typemap

     delete THIS;
</pre>
<p class="Pp">If the function's name is <b>new</b> then the C++
    <span class="Li">&quot;new&quot;</span> function will be called to create a
    dynamic C++ object. The XSUB will expect the class name, which will be kept
    in a variable called <span class="Li">&quot;CLASS&quot;</span>, to be given
    as the first argument.</p>
<p class="Pp"></p>
<pre>
     color *
     color::new()
</pre>
<p class="Pp">The generated C++ code will call
    <span class="Li">&quot;new&quot;</span>.</p>
<p class="Pp"></p>
<pre>
     RETVAL = new color();
</pre>
<p class="Pp">The following is an example of a typemap that could be used for
    this C++ example.</p>
<p class="Pp"></p>
<pre>
    TYPEMAP
    color *             O_OBJECT

    OUTPUT
    # The Perl object is blessed into 'CLASS', which should be a
    # char* having the name of the package for the blessing.
    O_OBJECT
        sv_setref_pv( $arg, CLASS, (void*)$var );

    INPUT
    O_OBJECT
        if( sv_isobject($arg) &amp;&amp; (SvTYPE(SvRV($arg)) == SVt_PVMG) )
                $var = ($type)SvIV((SV*)SvRV( $arg ));
        else{
                warn( \&quot;${Package}::$func_name() -- $var is not a blessed SV reference\&quot; );
                XSRETURN_UNDEF;
        }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Interface_Strategy"><a class="permalink" href="#Interface_Strategy">Interface
  Strategy</a></h2>
<p class="Pp">When designing an interface between Perl and a C library a
    straight translation from C to XS (such as created by
    <span class="Li">&quot;h2xs -x&quot;</span>) is often sufficient. However,
    sometimes the interface will look very C-like and occasionally nonintuitive,
    especially when the C function modifies one of its parameters, or returns
    failure inband (as in &quot;negative return values mean failure&quot;). In
    cases where the programmer wishes to create a more Perl-like interface the
    following strategy may help to identify the more critical parts of the
    interface.</p>
<p class="Pp">Identify the C functions with input/output or output parameters.
    The XSUBs for these functions may be able to return lists to Perl.</p>
<p class="Pp">Identify the C functions which use some inband info as an
    indication of failure. They may be candidates to return undef or an empty
    list in case of failure. If the failure may be detected without a call to
    the C function, you may want to use an INIT: section to report the failure.
    For failures detectable after the C function returns one may want to use a
    POSTCALL: section to process the failure. In more complicated cases use
    CODE: or PPCODE: sections.</p>
<p class="Pp">If many functions use the same failure indication based on the
    return value, you may want to create a special typedef to handle this
    situation. Put</p>
<p class="Pp"></p>
<pre>
  typedef int negative_is_failure;
</pre>
<p class="Pp">near the beginning of XS file, and create an OUTPUT typemap entry
    for <span class="Li">&quot;negative_is_failure&quot;</span> which converts
    negative values to <span class="Li">&quot;undef&quot;</span>, or maybe
    <i>croak()</i>s. After this the return value of type
    <span class="Li">&quot;negative_is_failure&quot;</span> will create more
    Perl-like interface.</p>
<p class="Pp">Identify which values are used by only the C and XSUB functions
    themselves, say, when a parameter to a function should be a contents of a
    global variable. If Perl does not need to access the contents of the value
    then it may not be necessary to provide a translation for that value from C
    to Perl.</p>
<p class="Pp">Identify the pointers in the C function parameter lists and return
    values. Some pointers may be used to implement input/output or output
    parameters, they can be handled in XS with the
    <span class="Li">&quot;&amp;&quot;</span> unary operator, and, possibly,
    using the NO_INIT keyword. Some others will require handling of types like
    <span class="Li">&quot;int *&quot;</span>, and one needs to decide what a
    useful Perl translation will do in such a case. When the semantic is clear,
    it is advisable to put the translation into a typemap file.</p>
<p class="Pp">Identify the structures used by the C functions. In many cases it
    may be helpful to use the T_PTROBJ typemap for these structures so they can
    be manipulated by Perl as blessed objects. (This is handled automatically by
    <span class="Li">&quot;h2xs -x&quot;</span>.)</p>
<p class="Pp">If the same C type is used in several different contexts which
    require different translations, <span class="Li">&quot;typedef&quot;</span>
    several new types mapped to this C type, and create separate <i>typemap</i>
    entries for these new types. Use these types in declarations of return type
    and parameters to XSUBs.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Perl_Objects_And_C_Structures"><a class="permalink" href="#Perl_Objects_And_C_Structures">Perl
  Objects And C Structures</a></h2>
<p class="Pp">When dealing with C structures one should select either
    <b>T_PTROBJ</b> or <b>T_PTRREF</b> for the XS type. Both types are designed
    to handle pointers to complex objects. The T_PTRREF type will allow the Perl
    object to be unblessed while the T_PTROBJ type requires that the object be
    blessed. By using T_PTROBJ one can achieve a form of type-checking because
    the XSUB will attempt to verify that the Perl object is of the expected
    type.</p>
<p class="Pp">The following XS code shows the <i>getnetconfigent()</i> function
    which is used with ONC+ TIRPC. The <i>getnetconfigent()</i> function will
    return a pointer to a C structure and has the C prototype shown below. The
    example will demonstrate how the C pointer will become a Perl reference.
    Perl will consider this reference to be a pointer to a blessed object and
    will attempt to call a destructor for the object. A destructor will be
    provided in the XS source to free the memory used by
    <i>getnetconfigent()</i>. Destructors in XS can be created by specifying an
    XSUB function whose name ends with the word <b>DESTROY</b>. XS destructors
    can be used to free memory which may have been malloc'd by another XSUB.</p>
<p class="Pp"></p>
<pre>
     struct netconfig *getnetconfigent(const char *netid);
</pre>
<p class="Pp">A <span class="Li">&quot;typedef&quot;</span> will be created for
    <span class="Li">&quot;struct netconfig&quot;</span>. The Perl object will
    be blessed in a class matching the name of the C type, with the tag
    <span class="Li">&quot;Ptr&quot;</span> appended, and the name should not
    have embedded spaces if it will be a Perl package name. The destructor will
    be placed in a class corresponding to the class of the object and the PREFIX
    keyword will be used to trim the name to the word DESTROY as Perl will
    expect.</p>
<p class="Pp"></p>
<pre>
     typedef struct netconfig Netconfig;

     MODULE = RPC  PACKAGE = RPC

     Netconfig *
     getnetconfigent(netid)
          char *netid

     MODULE = RPC  PACKAGE = NetconfigPtr  PREFIX = rpcb_

     void
     rpcb_DESTROY(netconf)
          Netconfig *netconf
        CODE:
          printf(&quot;Now in NetconfigPtr::DESTROY\n&quot;);
          free( netconf );
</pre>
<p class="Pp">This example requires the following typemap entry. Consult
    perlxstypemap for more information about adding new typemaps for an
    extension.</p>
<p class="Pp"></p>
<pre>
     TYPEMAP
     Netconfig *  T_PTROBJ
</pre>
<p class="Pp">This example will be used with the following Perl statements.</p>
<p class="Pp"></p>
<pre>
     use RPC;
     $netconf = getnetconfigent(&quot;udp&quot;);
</pre>
<p class="Pp">When Perl destroys the object referenced by
    <span class="Li">$netconf</span> it will send the object to the supplied
    XSUB DESTROY function. Perl cannot determine, and does not care, that this
    object is a C struct and not a Perl object. In this sense, there is no
    difference between the object created by the <i>getnetconfigent()</i> XSUB
    and an object created by a normal Perl subroutine.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Safely_Storing_Static_Data_in_"><a class="permalink" href="#Safely_Storing_Static_Data_in_">Safely
  Storing Static Data in XS</a></h2>
<p class="Pp">Starting with Perl 5.8, a macro framework has been defined to
    allow static data to be safely stored in XS modules that will be accessed
    from a multi-threaded Perl.</p>
<p class="Pp">Although primarily designed for use with multi-threaded Perl, the
    macros have been designed so that they will work with non-threaded Perl as
    well.</p>
<p class="Pp">It is therefore strongly recommended that these macros be used by
    all XS modules that make use of static data.</p>
<p class="Pp">The easiest way to get a template set of macros to use is by
    specifying the <span class="Li">&quot;-g&quot;</span>
    (<span class="Li">&quot;--global&quot;</span>) option with h2xs (see
  h2xs).</p>
<p class="Pp">Below is an example module that makes use of the macros.</p>
<p class="Pp"></p>
<pre>
    #include &quot;EXTERN.h&quot;
    #include &quot;perl.h&quot;
    #include &quot;XSUB.h&quot;

    /* Global Data */

    #define MY_CXT_KEY &quot;BlindMice::_guts&quot; XS_VERSION

    typedef struct {
        int count;
        char name[3][100];
    } my_cxt_t;

    START_MY_CXT

    MODULE = BlindMice           PACKAGE = BlindMice

    BOOT:
    {
        MY_CXT_INIT;
        MY_CXT.count = 0;
        strcpy(MY_CXT.name[0], &quot;None&quot;);
        strcpy(MY_CXT.name[1], &quot;None&quot;);
        strcpy(MY_CXT.name[2], &quot;None&quot;);
    }

    int
    newMouse(char * name)
        char * name;
        PREINIT:
          dMY_CXT;
        CODE:
          if (MY_CXT.count &gt;= 3) {
              warn(&quot;Already have 3 blind mice&quot;);
              RETVAL = 0;
          }
          else {
              RETVAL = ++ MY_CXT.count;
              strcpy(MY_CXT.name[MY_CXT.count - 1], name);
          }

    char *
    get_mouse_name(index)
      int index
      CODE:
        dMY_CXT;
        RETVAL = MY_CXT.lives ++;
        if (index &gt; MY_CXT.count)
          croak(&quot;There are only 3 blind mice.&quot;);
        else
          RETVAL = newSVpv(MY_CXT.name[index - 1]);

    void
    CLONE(...)
        CODE:
        MY_CXT_CLONE;
</pre>
<p class="Pp"><b>REFERENCE</b></p>
<dl class="Bl-tag">
  <dt id="MY_CXT_KEY"><a class="permalink" href="#MY_CXT_KEY">MY_CXT_KEY</a></dt>
  <dd>This macro is used to define a unique key to refer to the static data for
      an XS module. The suggested naming scheme, as used by h2xs, is to use a
      string that consists of the module name, the string &quot;::_guts&quot;
      and the module version number.
    <p class="Pp"></p>
    <pre>
    #define MY_CXT_KEY &quot;MyModule::_guts&quot; XS_VERSION
    </pre>
  </dd>
  <dt id="typedef"><a class="permalink" href="#typedef">typedef
    my_cxt_t</a></dt>
  <dd>This struct typedef <i>must</i> always be called
      <span class="Li">&quot;my_cxt_t&quot;</span>. The other
      <span class="Li">&quot;CXT*&quot;</span> macros assume the existence of
      the <span class="Li">&quot;my_cxt_t&quot;</span> typedef name.
    <p class="Pp">Declare a typedef named
        <span class="Li">&quot;my_cxt_t&quot;</span> that is a structure that
        contains all the data that needs to be interpreter-local.</p>
    <p class="Pp"></p>
    <pre>
    typedef struct {
        int some_value;
    } my_cxt_t;
    </pre>
  </dd>
  <dt id="START_MY_CXT"><a class="permalink" href="#START_MY_CXT">START_MY_CXT</a></dt>
  <dd>Always place the START_MY_CXT macro directly after the declaration of
      <span class="Li">&quot;my_cxt_t&quot;</span>.</dd>
  <dt id="MY_CXT_INIT"><a class="permalink" href="#MY_CXT_INIT">MY_CXT_INIT</a></dt>
  <dd>The MY_CXT_INIT macro initialises storage for the
      <span class="Li">&quot;my_cxt_t&quot;</span> struct.
    <p class="Pp">It <i>must</i> be called exactly once, typically in a BOOT:
        section. If you are maintaining multiple interpreters, it should be
        called once in each interpreter instance, except for interpreters cloned
        from existing ones. (But see &quot;MY_CXT_CLONE&quot; below.)</p>
  </dd>
  <dt id="dMY_CXT"><a class="permalink" href="#dMY_CXT">dMY_CXT</a></dt>
  <dd>Use the dMY_CXT macro (a declaration) in all the functions that access
      MY_CXT.</dd>
  <dt id="MY_CXT"><a class="permalink" href="#MY_CXT">MY_CXT</a></dt>
  <dd>Use the MY_CXT macro to access members of the
      <span class="Li">&quot;my_cxt_t&quot;</span> struct. For example, if
      <span class="Li">&quot;my_cxt_t&quot;</span> is
    <p class="Pp"></p>
    <pre>
    typedef struct {
        int index;
    } my_cxt_t;
    </pre>
    <p class="Pp">then use this to access the
        <span class="Li">&quot;index&quot;</span> member</p>
    <p class="Pp"></p>
    <pre>
    dMY_CXT;
    MY_CXT.index = 2;
    </pre>
  </dd>
  <dt id="aMY_CXT/pMY_CXT"><a class="permalink" href="#aMY_CXT/pMY_CXT">aMY_CXT/pMY_CXT</a></dt>
  <dd><span class="Li">&quot;dMY_CXT&quot;</span> may be quite expensive to
      calculate, and to avoid the overhead of invoking it in each function it is
      possible to pass the declaration onto other functions using the
      <span class="Li">&quot;aMY_CXT&quot;</span>/<span class="Li">&quot;pMY_CXT&quot;</span>
      macros, eg
    <p class="Pp"></p>
    <pre>
    void sub1() {
        dMY_CXT;
        MY_CXT.index = 1;
        sub2(aMY_CXT);
    }

    void sub2(pMY_CXT) {
        MY_CXT.index = 2;
    }
    </pre>
    <p class="Pp">Analogously to <span class="Li">&quot;pTHX&quot;</span>, there
        are equivalent forms for when the macro is the first or last in multiple
        arguments, where an underscore represents a comma, i.e.
        <span class="Li">&quot;_aMY_CXT&quot;</span>,
        <span class="Li">&quot;aMY_CXT_&quot;</span>,
        <span class="Li">&quot;_pMY_CXT&quot;</span> and
        <span class="Li">&quot;pMY_CXT_&quot;</span>.</p>
  </dd>
  <dt id="MY_CXT_CLONE"><a class="permalink" href="#MY_CXT_CLONE">MY_CXT_CLONE</a></dt>
  <dd>By default, when a new interpreter is created as a copy of an existing one
      (eg via <span class="Li">&quot;threads-&gt;create()&quot;</span>), both
      interpreters share the same physical my_cxt_t structure. Calling
      <span class="Li">&quot;MY_CXT_CLONE&quot;</span> (typically via the
      package's <span class="Li">&quot;CLONE()&quot;</span> function), causes a
      byte-for-byte copy of the structure to be taken, and any future dMY_CXT
      will cause the copy to be accessed instead.</dd>
  <dt id="MY_CXT_INIT_INTERP"><a class="permalink" href="#MY_CXT_INIT_INTERP">MY_CXT_INIT_INTERP(my_perl)</a></dt>
  <dd></dd>
  <dt id="dMY_CXT_INTERP(my_perl)"><a class="permalink" href="#dMY_CXT_INTERP(my_perl)">dMY_CXT_INTERP(my_perl)</a></dt>
  <dd>These are versions of the macros which take an explicit interpreter as an
      argument.</dd>
</dl>
<p class="Pp">Note that these macros will only work together within the
    <i>same</i> source file; that is, a dMY_CTX in one source file will access a
    different structure than a dMY_CTX in another source file.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Thread-aware_system_interfaces"><a class="permalink" href="#Thread-aware_system_interfaces">Thread-aware
  system interfaces</a></h2>
<p class="Pp">Starting from Perl 5.8, in C/C++ level Perl knows how to wrap
    system/library interfaces that have thread-aware versions (e.g.
    <i>getpwent_r()</i>) into frontend macros (e.g. <i>getpwent()</i>) that
    correctly handle the multithreaded interaction with the Perl interpreter.
    This will happen transparently, the only thing you need to do is to
    instantiate a Perl interpreter.</p>
<p class="Pp">This wrapping happens always when compiling Perl core source
    (PERL_CORE is defined) or the Perl core extensions (PERL_EXT is defined).
    When compiling XS code outside of Perl core the wrapping does not take
    place. Note, however, that intermixing the _r-forms (as Perl compiled for
    multithreaded operation will do) and the _r-less forms is neither
    well-defined (inconsistent results, data corruption, or even crashes become
    more likely), nor is it very portable.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">File <span class="Li">&quot;RPC.xs&quot;</span>: Interface to some
    ONC+ RPC bind library functions.</p>
<p class="Pp"></p>
<pre>
     #include &quot;EXTERN.h&quot;
     #include &quot;perl.h&quot;
     #include &quot;XSUB.h&quot;

     #include &lt;rpc/rpc.h&gt;

     typedef struct netconfig Netconfig;

     MODULE = RPC  PACKAGE = RPC

     SV *
     rpcb_gettime(host=&quot;localhost&quot;)
          char *host
        PREINIT:
          time_t  timep;
        CODE:
          ST(0) = sv_newmortal();
          if( rpcb_gettime( host, &amp;timep ) )
               sv_setnv( ST(0), (double)timep );

     Netconfig *
     getnetconfigent(netid=&quot;udp&quot;)
          char *netid

     MODULE = RPC  PACKAGE = NetconfigPtr  PREFIX = rpcb_

     void
     rpcb_DESTROY(netconf)
          Netconfig *netconf
        CODE:
          printf(&quot;NetconfigPtr::DESTROY\n&quot;);
          free( netconf );
</pre>
<p class="Pp">File <span class="Li">&quot;typemap&quot;</span>: Custom typemap
    for RPC.xs. (cf. perlxstypemap)</p>
<p class="Pp"></p>
<pre>
     TYPEMAP
     Netconfig *  T_PTROBJ
</pre>
<p class="Pp">File <span class="Li">&quot;RPC.pm&quot;</span>: Perl module for
    the RPC extension.</p>
<p class="Pp"></p>
<pre>
     package RPC;

     require Exporter;
     require DynaLoader;
     @ISA = qw(Exporter DynaLoader);
     @EXPORT = qw(rpcb_gettime getnetconfigent);

     bootstrap RPC;
     1;
</pre>
<p class="Pp">File <span class="Li">&quot;rpctest.pl&quot;</span>: Perl test
    program for the RPC extension.</p>
<p class="Pp"></p>
<pre>
     use RPC;

     $netconf = getnetconfigent();
     $a = rpcb_gettime();
     print &quot;time = $a\n&quot;;
     print &quot;netconf = $netconf\n&quot;;

     $netconf = getnetconfigent(&quot;tcp&quot;);
     $a = rpcb_gettime(&quot;poplar&quot;);
     print &quot;time = $a\n&quot;;
     print &quot;netconf = $netconf\n&quot;;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="XS_VERSION"><a class="permalink" href="#XS_VERSION">XS
  VERSION</a></h1>
<p class="Pp">This document covers features supported by
    <span class="Li">&quot;ExtUtils::ParseXS&quot;</span> (also known as
    <span class="Li">&quot;xsubpp&quot;</span>) 3.13_01.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Originally written by Dean Roehrich
    &lt;<i>roehrich@cray.com</i>&gt;.</p>
<p class="Pp">Maintained since 1996 by The Perl Porters
    &lt;<i>perlbug@perl.org</i>&gt;.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

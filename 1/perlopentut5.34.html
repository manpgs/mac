<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PERLOPENTUT(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLOPENTUT(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLOPENTUT(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlopentut - simple recipes for opening files and pipes in
  Perl</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Whenever you do I/O on a file in Perl, you do so through what in
    Perl is called a <b>filehandle</b>. A filehandle is an internal name for an
    external file. It is the job of the <span class="Li">&quot;open&quot;</span>
    function to make the association between the internal name and the external
    name, and it is the job of the <span class="Li">&quot;close&quot;</span>
    function to break that association.</p>
<p class="Pp">For your convenience, Perl sets up a few special filehandles that
    are already open when you run. These include
    <span class="Li">&quot;STDIN&quot;</span>,
    <span class="Li">&quot;STDOUT&quot;</span>,
    <span class="Li">&quot;STDERR&quot;</span>, and
    <span class="Li">&quot;ARGV&quot;</span>. Since those are pre-opened, you
    can use them right away without having to go to the trouble of opening them
    yourself:</p>
<p class="Pp"></p>
<pre>    print STDERR &quot;This is a debugging message.\n&quot;;
    print STDOUT &quot;Please enter something: &quot;;
    $response = &lt;STDIN&gt; // die &quot;how come no input?&quot;;
    print STDOUT &quot;Thank you!\n&quot;;
    while (&lt;ARGV&gt;) { ... }
</pre>
<p class="Pp">As you see from those examples,
    <span class="Li">&quot;STDOUT&quot;</span> and
    <span class="Li">&quot;STDERR&quot;</span> are output handles, and
    <span class="Li">&quot;STDIN&quot;</span> and
    <span class="Li">&quot;ARGV&quot;</span> are input handles. They are in all
    capital letters because they are reserved to Perl, much like the
    <span class="Li">@ARGV</span> array and the <span class="Li">%ENV</span>
    hash are. Their external associations were set up by your shell.</p>
<p class="Pp">You will need to open every other filehandle on your own. Although
    there are many variants, the most common way to call Perl's <b>open()</b>
    function is with three arguments and one return value:</p>
<p class="Pp"><span class="Li">&quot;
    </span><span class="Li"><i>OK</i></span><span class="Li"> =
    open(</span><span class="Li"><i>HANDLE</i></span><span class="Li">,
    </span><span class="Li"><i>MODE</i></span><span class="Li">,
    </span><span class="Li"><i>PATHNAME</i></span><span class="Li">)&quot;</span></p>
<p class="Pp">Where:</p>
<dl class="Bl-tag">
  <dt id="OK"><a class="permalink" href="#OK"><i>OK</i></a></dt>
  <dd>will be some defined value if the open succeeds, but
      <span class="Li">&quot;undef&quot;</span> if it fails;</dd>
  <dt id="HANDLE"><a class="permalink" href="#HANDLE"><i>HANDLE</i></a></dt>
  <dd>should be an undefined scalar variable to be filled in by the
      <span class="Li">&quot;open&quot;</span> function if it succeeds;</dd>
  <dt id="MODE"><a class="permalink" href="#MODE"><i>MODE</i></a></dt>
  <dd>is the access mode and the encoding format to open the file with;</dd>
  <dt id="PATHNAME"><a class="permalink" href="#PATHNAME"><i>PATHNAME</i></a></dt>
  <dd>is the external name of the file you want opened.</dd>
</dl>
<p class="Pp">Most of the complexity of the
    <span class="Li">&quot;open&quot;</span> function lies in the many possible
    values that the <i>MODE</i> parameter can take on.</p>
<p class="Pp">One last thing before we show you how to open files: opening files
    does not (usually) automatically lock them in Perl. See perlfaq5 for how to
    lock.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Opening_Text_Files"><a class="permalink" href="#Opening_Text_Files">Opening
  Text Files</a></h1>
<section class="Ss">
<h2 class="Ss" id="Opening_Text_Files_for_Reading"><a class="permalink" href="#Opening_Text_Files_for_Reading">Opening
  Text Files for Reading</a></h2>
<p class="Pp">If you want to read from a text file, first open it in read-only
    mode like this:</p>
<p class="Pp"></p>
<pre>    my $filename = &quot;/some/path/to/a/textfile/goes/here&quot;;
    my $encoding = &quot;:encoding(UTF-8)&quot;;
    my $handle   = undef;     # this will be filled in on success
    open($handle, &quot;&lt; $encoding&quot;, $filename)
        || die &quot;$0: can't open $filename for reading: $!&quot;;
</pre>
<p class="Pp">As with the shell, in Perl the
    <span class="Li">&quot;&lt;&quot;</span> is used to open the file in
    read-only mode. If it succeeds, Perl allocates a brand new filehandle for
    you and fills in your previously undefined <span class="Li">$handle</span>
    argument with a reference to that handle.</p>
<p class="Pp">Now you may use functions like
    <span class="Li">&quot;readline&quot;</span>,
    <span class="Li">&quot;read&quot;</span>,
    <span class="Li">&quot;getc&quot;</span>, and
    <span class="Li">&quot;sysread&quot;</span> on that handle. Probably the
    most common input function is the one that looks like an operator:</p>
<p class="Pp"></p>
<pre>    $line = readline($handle);
    $line = &lt;$handle&gt;;          # same thing
</pre>
<p class="Pp">Because the <span class="Li">&quot;readline&quot;</span> function
    returns <span class="Li">&quot;undef&quot;</span> at end of file or upon
    error, you will sometimes see it used this way:</p>
<p class="Pp"></p>
<pre>    $line = &lt;$handle&gt;;
    if (defined $line) {
        # do something with $line
    }
    else {
        # $line is not valid, so skip it
    }
</pre>
<p class="Pp">You can also just quickly <span class="Li">&quot;die&quot;</span>
    on an undefined value this way:</p>
<p class="Pp"></p>
<pre>    $line = &lt;$handle&gt; // die &quot;no input found&quot;;
</pre>
<p class="Pp">However, if hitting EOF is an expected and normal event, you do
    not want to exit simply because you have run out of input. Instead, you
    probably just want to exit an input loop. You can then test to see if an
    actual error has caused the loop to terminate, and act accordingly:</p>
<p class="Pp"></p>
<pre>    while (&lt;$handle&gt;) {
        # do something with data in $_
    }
    if ($!) {
        die &quot;unexpected error while reading from $filename: $!&quot;;
    }
</pre>
<p class="Pp"><b>A Note on Encodings</b>: Having to specify the text encoding
    every time might seem a bit of a bother. To set up a default encoding for
    <span class="Li">&quot;open&quot;</span> so that you don't have to supply it
    each time, you can use the <span class="Li">&quot;open&quot;</span>
  pragma:</p>
<p class="Pp"></p>
<pre>    use open qw&lt; :encoding(UTF-8) &gt;;
</pre>
<p class="Pp">Once you've done that, you can safely omit the encoding part of
    the open mode:</p>
<p class="Pp"></p>
<pre>    open($handle, &quot;&lt;&quot;, $filename)
        || die &quot;$0: can't open $filename for reading: $!&quot;;
</pre>
<p class="Pp">But never use the bare <span class="Li">&quot;&lt;&quot;</span>
    without having set up a default encoding first. Otherwise, Perl cannot know
    which of the many, many, many possible flavors of text file you have, and
    Perl will have no idea how to correctly map the data in your file into
    actual characters it can work with. Other common encoding formats including
    <span class="Li">&quot;ASCII&quot;</span>,
    <span class="Li">&quot;ISO-8859-1&quot;</span>,
    <span class="Li">&quot;ISO-8859-15&quot;</span>,
    <span class="Li">&quot;Windows-1252&quot;</span>,
    <span class="Li">&quot;MacRoman&quot;</span>, and even
    <span class="Li">&quot;UTF-16LE&quot;</span>. See perlunitut for more about
    encodings.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Opening_Text_Files_for_Writing"><a class="permalink" href="#Opening_Text_Files_for_Writing">Opening
  Text Files for Writing</a></h2>
<p class="Pp">When you want to write to a file, you first have to decide what to
    do about any existing contents of that file. You have two basic choices
    here: to preserve or to clobber.</p>
<p class="Pp">If you want to preserve any existing contents, then you want to
    open the file in append mode. As in the shell, in Perl you use
    <span class="Li">&quot;&gt;&gt;&quot;</span> to open an existing file in
    append mode. <span class="Li">&quot;&gt;&gt;&quot;</span> creates the file
    if it does not already exist.</p>
<p class="Pp"></p>
<pre>    my $handle   = undef;
    my $filename = &quot;/some/path/to/a/textfile/goes/here&quot;;
    my $encoding = &quot;:encoding(UTF-8)&quot;;
    open($handle, &quot;&gt;&gt; $encoding&quot;, $filename)
        || die &quot;$0: can't open $filename for appending: $!&quot;;
</pre>
<p class="Pp">Now you can write to that filehandle using any of
    <span class="Li">&quot;print&quot;</span>,
    <span class="Li">&quot;printf&quot;</span>,
    <span class="Li">&quot;say&quot;</span>,
    <span class="Li">&quot;write&quot;</span>, or
    <span class="Li">&quot;syswrite&quot;</span>.</p>
<p class="Pp">As noted above, if the file does not already exist, then the
    append-mode open will create it for you. But if the file does already exist,
    its contents are safe from harm because you will be adding your new text
    past the end of the old text.</p>
<p class="Pp">On the other hand, sometimes you want to clobber whatever might
    already be there. To empty out a file before you start writing to it, you
    can open it in write-only mode:</p>
<p class="Pp"></p>
<pre>    my $handle   = undef;
    my $filename = &quot;/some/path/to/a/textfile/goes/here&quot;;
    my $encoding = &quot;:encoding(UTF-8)&quot;;
    open($handle, &quot;&gt; $encoding&quot;, $filename)
        || die &quot;$0: can't open $filename in write-open mode: $!&quot;;
</pre>
<p class="Pp">Here again Perl works just like the shell in that the
    <span class="Li">&quot;&gt;&quot;</span> clobbers an existing file.</p>
<p class="Pp">As with the append mode, when you open a file in write-only mode,
    you can now write to that filehandle using any of
    <span class="Li">&quot;print&quot;</span>,
    <span class="Li">&quot;printf&quot;</span>,
    <span class="Li">&quot;say&quot;</span>,
    <span class="Li">&quot;write&quot;</span>, or
    <span class="Li">&quot;syswrite&quot;</span>.</p>
<p class="Pp">What about read-write mode? You should probably pretend it doesn't
    exist, because opening text files in read-write mode is unlikely to do what
    you would like. See perlfaq5 for details.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Opening_Binary_Files"><a class="permalink" href="#Opening_Binary_Files">Opening
  Binary Files</a></h1>
<p class="Pp">If the file to be opened contains binary data instead of text
    characters, then the <span class="Li">&quot;MODE&quot;</span> argument to
    <span class="Li">&quot;open&quot;</span> is a little different. Instead of
    specifying the encoding, you tell Perl that your data are in raw bytes.</p>
<p class="Pp"></p>
<pre>    my $filename = &quot;/some/path/to/a/binary/file/goes/here&quot;;
    my $encoding = &quot;:raw :bytes&quot;
    my $handle   = undef;     # this will be filled in on success
</pre>
<p class="Pp">And then open as before, choosing
    <span class="Li">&quot;&lt;&quot;</span>,
    <span class="Li">&quot;&gt;&gt;&quot;</span>, or
    <span class="Li">&quot;&gt;&quot;</span> as needed:</p>
<p class="Pp"></p>
<pre>    open($handle, &quot;&lt; $encoding&quot;, $filename)
        || die &quot;$0: can't open $filename for reading: $!&quot;;
    open($handle, &quot;&gt;&gt; $encoding&quot;, $filename)
        || die &quot;$0: can't open $filename for appending: $!&quot;;
    open($handle, &quot;&gt; $encoding&quot;, $filename)
        || die &quot;$0: can't open $filename in write-open mode: $!&quot;;
</pre>
<p class="Pp">Alternately, you can change to binary mode on an existing handle
    this way:</p>
<p class="Pp"></p>
<pre>    binmode($handle)    || die &quot;cannot binmode handle&quot;;
</pre>
<p class="Pp">This is especially handy for the handles that Perl has already
    opened for you.</p>
<p class="Pp"></p>
<pre>    binmode(STDIN)      || die &quot;cannot binmode STDIN&quot;;
    binmode(STDOUT)     || die &quot;cannot binmode STDOUT&quot;;
</pre>
<p class="Pp">You can also pass <span class="Li">&quot;binmode&quot;</span> an
    explicit encoding to change it on the fly. This isn't exactly
    &quot;binary&quot; mode, but we still use
    <span class="Li">&quot;binmode&quot;</span> to do it:</p>
<p class="Pp"></p>
<pre>  binmode(STDIN,  &quot;:encoding(MacRoman)&quot;) || die &quot;cannot binmode STDIN&quot;;
  binmode(STDOUT, &quot;:encoding(UTF-8)&quot;)    || die &quot;cannot binmode STDOUT&quot;;
</pre>
<p class="Pp">Once you have your binary file properly opened in the right mode,
    you can use all the same Perl I/O functions as you used on text files.
    However, you may wish to use the fixed-size
    <span class="Li">&quot;read&quot;</span> instead of the variable-sized
    <span class="Li">&quot;readline&quot;</span> for your input.</p>
<p class="Pp">Here's an example of how to copy a binary file:</p>
<p class="Pp"></p>
<pre>    my $BUFSIZ   = 64 * (2 ** 10);
    my $name_in  = &quot;/some/input/file&quot;;
    my $name_out = &quot;/some/output/flie&quot;;
    my($in_fh, $out_fh, $buffer);
    open($in_fh,  &quot;&lt;&quot;, $name_in)
        || die &quot;$0: cannot open $name_in for reading: $!&quot;;
    open($out_fh, &quot;&gt;&quot;, $name_out)
        || die &quot;$0: cannot open $name_out for writing: $!&quot;;
    for my $fh ($in_fh, $out_fh)  {
        binmode($fh)               || die &quot;binmode failed&quot;;
    }
    while (read($in_fh, $buffer, $BUFSIZ)) {
        unless (print $out_fh $buffer) {
            die &quot;couldn't write to $name_out: $!&quot;;
        }
    }
    close($in_fh)       || die &quot;couldn't close $name_in: $!&quot;;
    close($out_fh)      || die &quot;couldn't close $name_out: $!&quot;;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="Opening_Pipes"><a class="permalink" href="#Opening_Pipes">Opening
  Pipes</a></h1>
<p class="Pp">Perl also lets you open a filehandle into an external program or
    shell command rather than into a file. You can do this in order to pass data
    from your Perl program to an external command for further processing, or to
    receive data from another program for your own Perl program to process.</p>
<p class="Pp">Filehandles into commands are also known as <i>pipes</i>, since
    they work on similar inter-process communication principles as Unix
    pipelines. Such a filehandle has an active program instead of a static file
    on its external end, but in every other sense it works just like a more
    typical file-based filehandle, with all the techniques discussed earlier in
    this article just as applicable.</p>
<p class="Pp">As such, you open a pipe using the same
    <span class="Li">&quot;open&quot;</span> call that you use for opening
    files, setting the second (<span class="Li">&quot;MODE&quot;</span>)
    argument to special characters that indicate either an input or an output
    pipe. Use <span class="Li">&quot;-|&quot;</span> for a filehandle that will
    let your Perl program read data from an external program, and
    <span class="Li">&quot;|-&quot;</span> for a filehandle that will send data
    to that program instead.</p>
<section class="Ss">
<h2 class="Ss" id="Opening_a_pipe_for_reading"><a class="permalink" href="#Opening_a_pipe_for_reading">Opening
  a pipe for reading</a></h2>
<p class="Pp">Let's say you'd like your Perl program to process data stored in a
    nearby directory called <span class="Li">&quot;unsorted&quot;</span>, which
    contains a number of textfiles. You'd also like your program to sort all the
    contents from these files into a single, alphabetically sorted list of
    unique lines before it starts processing them.</p>
<p class="Pp">You could do this through opening an ordinary filehandle into each
    of those files, gradually building up an in-memory array of all the file
    contents you load this way, and finally sorting and filtering that array
    when you've run out of files to load. <i>Or</i>, you could offload all that
    merging and sorting into your operating system's own
    <span class="Li">&quot;sort&quot;</span> command by opening a pipe directly
    into its output, and get to work that much faster.</p>
<p class="Pp">Here's how that might look:</p>
<p class="Pp"></p>
<pre>    open(my $sort_fh, '-|', 'sort -u unsorted/*.txt')
        or die &quot;Couldn't open a pipe into sort: $!&quot;;
    # And right away, we can start reading sorted lines:
    while (my $line = &lt;$sort_fh&gt;) {
        #
        # ... Do something interesting with each $line here ...
        #
    }
</pre>
<p class="Pp">The second argument to <span class="Li">&quot;open&quot;</span>,
    <span class="Li">&quot;-|&quot;</span>, makes it a read-pipe into a separate
    program, rather than an ordinary filehandle into a file.</p>
<p class="Pp">Note that the third argument to
    <span class="Li">&quot;open&quot;</span> is a string containing the program
    name (<span class="Li">&quot;sort&quot;</span>) plus all its arguments: in
    this case, <span class="Li">&quot;-u&quot;</span> to specify unqiue sort,
    and then a fileglob specifying the files to sort. The resulting filehandle
    <span class="Li">$sort_fh</span> works just like a read-only
    (<span class="Li">&quot;&lt;&quot;</span>) filehandle, and your program can
    subsequently read data from it as if it were opened onto an ordinary, single
    file.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Opening_a_pipe_for_writing"><a class="permalink" href="#Opening_a_pipe_for_writing">Opening
  a pipe for writing</a></h2>
<p class="Pp">Continuing the previous example, let's say that your program has
    completed its processing, and the results sit in an array called
    <span class="Li">@processed</span>. You want to print these lines to a file
    called <span class="Li">&quot;numbered.txt&quot;</span> with a neatly
    formatted column of line-numbers.</p>
<p class="Pp">Certainly you could write your own code to do this X or, once
    again, you could kick that work over to another program. In this case,
    <span class="Li">&quot;cat&quot;</span>, running with its own
    <span class="Li">&quot;-n&quot;</span> option to activate line numbering,
    should do the trick:</p>
<p class="Pp"></p>
<pre>    open(my $cat_fh, '|-', 'cat -n &gt; numbered.txt')
        or die &quot;Couldn't open a pipe into cat: $!&quot;;
    for my $line (@processed) {
        print $cat_fh $line;
    }
</pre>
<p class="Pp">Here, we use a second <span class="Li">&quot;open&quot;</span>
    argument of <span class="Li">&quot;|-&quot;</span>, signifying that the
    filehandle assigned to <span class="Li">$cat_fh</span> should be a
    write-pipe. We can then use it just as we would a write-only ordinary
    filehandle, including the basic function of
    <span class="Li">&quot;print&quot;</span>-ing data to it.</p>
<p class="Pp">Note that the third argument, specifying the command that we wish
    to pipe to, sets up <span class="Li">&quot;cat&quot;</span> to redirect its
    output via that <span class="Li">&quot;&gt;&quot;</span> symbol into the
    file <span class="Li">&quot;numbered.txt&quot;</span>. This can start to
    look a little tricky, because that same symbol would have meant something
    entirely different had it showed it in the second argument to
    <span class="Li">&quot;open&quot;</span>! But here in the third argument,
    it's simply part of the shell command that Perl will open the pipe into, and
    Perl itself doesn't invest any special meaning to it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Expressing_the_command_as_a_list"><a class="permalink" href="#Expressing_the_command_as_a_list">Expressing
  the command as a list</a></h2>
<p class="Pp">For opening pipes, Perl offers the option to call
    <span class="Li">&quot;open&quot;</span> with a list comprising the desired
    command and all its own arguments as separate elements, rather than
    combining them into a single string as in the examples above. For instance,
    we could have phrased the <span class="Li">&quot;open&quot;</span> call in
    the first example like this:</p>
<p class="Pp"></p>
<pre>    open(my $sort_fh, '-|', 'sort', '-u', glob('unsorted/*.txt'))
        or die &quot;Couldn't open a pipe into sort: $!&quot;;
</pre>
<p class="Pp">When you call <span class="Li">&quot;open&quot;</span> this way,
    Perl invokes the given command directly, bypassing the shell. As such, the
    shell won't try to interpret any special characters within the command's
    argument list, which might overwise have unwanted effects. This can make for
    safer, less error-prone <span class="Li">&quot;open&quot;</span> calls,
    useful in cases such as passing in variables as arguments, or even just
    referring to filenames with spaces in them.</p>
<p class="Pp">However, when you <i>do</i> want to pass a meaningful
    metacharacter to the shell, such with the
    <span class="Li">&quot;*&quot;</span> inside that final
    <span class="Li">&quot;unsorted/*.txt&quot;</span> argument here, you can't
    use this alternate syntax. In this case, we have worked around it via Perl's
    handy <span class="Li">&quot;glob&quot;</span> built-in function, which
    evaluates its argument into a list of filenames X and we can safely pass
    that resulting list right into <span class="Li">&quot;open&quot;</span>, as
    shown above.</p>
<p class="Pp">Note also that representing piped-command arguments in list form
    like this doesn't work on every platform. It will work on any Unix-based OS
    that provides a real <span class="Li">&quot;fork&quot;</span> function (e.g.
    macOS or Linux), as well as on Windows when running Perl 5.22 or later.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">The full documentation for
    <span class="Li">&quot;open&quot;</span> provides a thorough reference to
    this function, beyond the best-practice basics covered here.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR_and_COPYRIGHT"><a class="permalink" href="#AUTHOR_and_COPYRIGHT">AUTHOR
  and COPYRIGHT</a></h1>
<p class="Pp">Copyright 2013 Tom Christiansen; now maintained by Perl5
  Porters</p>
<p class="Pp">This documentation is free; you can redistribute it and/or modify
    it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-10-04</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PERLINTRO(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLINTRO(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLINTRO(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlintro -- a brief introduction and overview of Perl</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This document is intended to give you a quick overview of the Perl
    programming language, along with pointers to further documentation. It is
    intended as a &quot;bootstrap&quot; guide for those who are new to the
    language, and provides just enough information for you to be able to read
    other peoples' Perl and understand roughly what it's doing, or write your
    own simple scripts.</p>
<p class="Pp">This introductory document does not aim to be complete. It does
    not even aim to be entirely accurate. In some cases perfection has been
    sacrificed in the goal of getting the general idea across. You are
    <i>strongly</i> advised to follow this introduction with more information
    from the full Perl manual, the table of contents to which can be found in
    perltoc.</p>
<p class="Pp">Throughout this document you'll see references to other parts of
    the Perl documentation. You can read that documentation using the
    <span class="Li">&quot;perldoc&quot;</span> command or whatever method
    you're using to read this document.</p>
<p class="Pp">Throughout Perl's documentation, you'll find numerous examples
    intended to help explain the discussed features. Please keep in mind that
    many of them are code fragments rather than complete programs.</p>
<p class="Pp">These examples often reflect the style and preference of the
    author of that piece of the documentation, and may be briefer than a
    corresponding line of code in a real program. Except where otherwise noted,
    you should assume that <span class="Li">&quot;use strict&quot;</span> and
    <span class="Li">&quot;use warnings&quot;</span> statements appear earlier
    in the &quot;program&quot;, and that any variables used have already been
    declared, even if those declarations have been omitted to make the example
    easier to read.</p>
<p class="Pp">Do note that the examples have been written by many different
    authors over a period of several decades. Styles and techniques will
    therefore differ, although some effort has been made to not vary styles too
    widely in the same sections. Do not consider one style to be better than
    others - &quot;There's More Than One Way To Do It&quot; is one of Perl's
    mottos. After all, in your journey as a programmer, you are likely to
    encounter different styles.</p>
<section class="Ss">
<h2 class="Ss" id="What_is_Perl?"><a class="permalink" href="#What_is_Perl?">What
  is Perl?</a></h2>
<p class="Pp">Perl is a general-purpose programming language originally
    developed for text manipulation and now used for a wide range of tasks
    including system administration, web development, network programming, GUI
    development, and more.</p>
<p class="Pp">The language is intended to be practical (easy to use, efficient,
    complete) rather than beautiful (tiny, elegant, minimal). Its major features
    are that it's easy to use, supports both procedural and object-oriented (OO)
    programming, has powerful built-in support for text processing, and has one
    of the world's most impressive collections of third-party modules.</p>
<p class="Pp">Different definitions of Perl are given in perl, perlfaq1 and no
    doubt other places. From this we can determine that Perl is different things
    to different people, but that lots of people think it's at least worth
    writing about.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Running_Perl_programs"><a class="permalink" href="#Running_Perl_programs">Running
  Perl programs</a></h2>
<p class="Pp">To run a Perl program from the Unix command line:</p>
<p class="Pp"></p>
<pre>
 perl progname.pl
</pre>
<p class="Pp">Alternatively, put this as the first line of your script:</p>
<p class="Pp"></p>
<pre>
 #!/usr/bin/env perl
</pre>
<p class="Pp">... and run the script as <i>/path/to/script.pl</i>. Of course,
    it'll need to be executable first, so <span class="Li">&quot;chmod 755
    script.pl&quot;</span> (under Unix).</p>
<p class="Pp">(This start line assumes you have the <b>env</b> program. You can
    also put directly the path to your perl executable, like in
    <span class="Li">&quot;#!/usr/bin/perl&quot;</span>).</p>
<p class="Pp">For more information, including instructions for other platforms
    such as Windows and Mac OS, read perlrun.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Safety_net"><a class="permalink" href="#Safety_net">Safety
  net</a></h2>
<p class="Pp">Perl by default is very forgiving. In order to make it more robust
    it is recommended to start every program with the following lines:</p>
<p class="Pp"></p>
<pre>
 #!/usr/bin/perl
 use strict;
 use warnings;
</pre>
<p class="Pp">The two additional lines request from perl to catch various common
    problems in your code. They check different things so you need both. A
    potential problem caught by <span class="Li">&quot;use strict;&quot;</span>
    will cause your code to stop immediately when it is encountered, while
    <span class="Li">&quot;use warnings;&quot;</span> will merely give a warning
    (like the command-line switch <b>-w</b>) and let your code run. To read more
    about them check their respective manual pages at strict and warnings.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Basic_syntax_overview"><a class="permalink" href="#Basic_syntax_overview">Basic
  syntax overview</a></h2>
<p class="Pp">A Perl script or program consists of one or more statements. These
    statements are simply written in the script in a straightforward fashion.
    There is no need to have a <span class="Li">&quot;main()&quot;</span>
    function or anything of that kind.</p>
<p class="Pp">Perl statements end in a semi-colon:</p>
<p class="Pp"></p>
<pre>
 print &quot;Hello, world&quot;;
</pre>
<p class="Pp">Comments start with a hash symbol and run to the end of the
  line</p>
<p class="Pp"></p>
<pre>
 # This is a comment
</pre>
<p class="Pp">Whitespace is irrelevant:</p>
<p class="Pp"></p>
<pre>
 print
     &quot;Hello, world&quot;
     ;
</pre>
<p class="Pp">... except inside quoted strings:</p>
<p class="Pp"></p>
<pre>
 # this would print with a linebreak in the middle
 print &quot;Hello
 world&quot;;
</pre>
<p class="Pp">Double quotes or single quotes may be used around literal
  strings:</p>
<p class="Pp"></p>
<pre>
 print &quot;Hello, world&quot;;
 print 'Hello, world';
</pre>
<p class="Pp">However, only double quotes &quot;interpolate&quot; variables and
    special characters such as newlines
    (<span class="Li">&quot;\n&quot;</span>):</p>
<p class="Pp"></p>
<pre>
 print &quot;Hello, $name\n&quot;;     # works fine
 print 'Hello, $name\n';     # prints $name\n literally
</pre>
<p class="Pp">Numbers don't need quotes around them:</p>
<p class="Pp"></p>
<pre>
 print 42;
</pre>
<p class="Pp">You can use parentheses for functions' arguments or omit them
    according to your personal taste. They are only required occasionally to
    clarify issues of precedence.</p>
<p class="Pp"></p>
<pre>
 print(&quot;Hello, world\n&quot;);
 print &quot;Hello, world\n&quot;;
</pre>
<p class="Pp">More detailed information about Perl syntax can be found in
    perlsyn.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Perl_variable_types"><a class="permalink" href="#Perl_variable_types">Perl
  variable types</a></h2>
<p class="Pp">Perl has three main variable types: scalars, arrays, and
  hashes.</p>
<dl class="Bl-tag">
  <dt id="Scalars"><a class="permalink" href="#Scalars">Scalars</a></dt>
  <dd>A scalar represents a single value:
    <p class="Pp"></p>
    <pre>
 my $animal = &quot;camel&quot;;
 my $answer = 42;
    </pre>
    <p class="Pp">Scalar values can be strings, integers or floating point
        numbers, and Perl will automatically convert between them as required.
        There is no need to pre-declare your variable types, but you have to
        declare them using the <span class="Li">&quot;my&quot;</span> keyword
        the first time you use them. (This is one of the requirements of
        <span class="Li">&quot;use strict;&quot;</span>.)</p>
    <p class="Pp">Scalar values can be used in various ways:</p>
    <p class="Pp"></p>
    <pre>
 print $animal;
 print &quot;The animal is $animal\n&quot;;
 print &quot;The square of $answer is &quot;, $answer * $answer, &quot;\n&quot;;
    </pre>
    <p class="Pp">There are a number of &quot;magic&quot; scalars with names
        that look like punctuation or line noise. These special variables are
        used for all kinds of purposes, and are documented in perlvar. The only
        one you need to know about for now is <span class="Li">$_</span> which
        is the &quot;default variable&quot;. It's used as the default argument
        to a number of functions in Perl, and it's set implicitly by certain
        looping constructs.</p>
    <p class="Pp"></p>
    <pre>
 print;          # prints contents of $_ by default
    </pre>
  </dd>
  <dt id="Arrays"><a class="permalink" href="#Arrays">Arrays</a></dt>
  <dd>An array represents a list of values:
    <p class="Pp"></p>
    <pre>
 my @animals = (&quot;camel&quot;, &quot;llama&quot;, &quot;owl&quot;);
 my @numbers = (23, 42, 69);
 my @mixed   = (&quot;camel&quot;, 42, 1.23);
    </pre>
    <p class="Pp">Arrays are zero-indexed. Here's how you get at elements in an
        array:</p>
    <p class="Pp"></p>
    <pre>
 print $animals[0];              # prints &quot;camel&quot;
 print $animals[1];              # prints &quot;llama&quot;
    </pre>
    <p class="Pp">The special variable <span class="Li">$#array</span> tells you
        the index of the last element of an array:</p>
    <p class="Pp"></p>
    <pre>
 print $mixed[$#mixed];       # last element, prints 1.23
    </pre>
    <p class="Pp">You might be tempted to use <span class="Li">&quot;$#array +
        1&quot;</span> to tell you how many items there are in an array. Don't
        bother. As it happens, using <span class="Li">@array</span> where Perl
        expects to find a scalar value (&quot;in scalar context&quot;) will give
        you the number of elements in the array:</p>
    <p class="Pp"></p>
    <pre>
 if (@animals &lt; 5) { ... }
    </pre>
    <p class="Pp">The elements we're getting from the array start with a
        <span class="Li">&quot;$&quot;</span> because we're getting just a
        single value out of the array; you ask for a scalar, you get a
      scalar.</p>
    <p class="Pp">To get multiple values from an array:</p>
    <p class="Pp"></p>
    <pre>
 @animals[0,1];                 # gives (&quot;camel&quot;, &quot;llama&quot;);
 @animals[0..2];                # gives (&quot;camel&quot;, &quot;llama&quot;, &quot;owl&quot;);
 @animals[1..$#animals];        # gives all except the first element
    </pre>
    <p class="Pp">This is called an &quot;array slice&quot;.</p>
    <p class="Pp">You can do various useful things to lists:</p>
    <p class="Pp"></p>
    <pre>
 my @sorted    = sort @animals;
 my @backwards = reverse @numbers;
    </pre>
    <p class="Pp">There are a couple of special arrays too, such as
        <span class="Li">@ARGV</span> (the command line arguments to your
        script) and <span class="Li">@_</span> (the arguments passed to a
        subroutine). These are documented in perlvar.</p>
  </dd>
  <dt id="Hashes"><a class="permalink" href="#Hashes">Hashes</a></dt>
  <dd>A hash represents a set of key/value pairs:
    <p class="Pp"></p>
    <pre>
 my %fruit_color = (&quot;apple&quot;, &quot;red&quot;, &quot;banana&quot;, &quot;yellow&quot;);
    </pre>
    <p class="Pp">You can use whitespace and the
        <span class="Li">&quot;=&gt;&quot;</span> operator to lay them out more
        nicely:</p>
    <p class="Pp"></p>
    <pre>
 my %fruit_color = (
     apple  =&gt; &quot;red&quot;,
     banana =&gt; &quot;yellow&quot;,
 );
    </pre>
    <p class="Pp">To get at hash elements:</p>
    <p class="Pp"></p>
    <pre>
 $fruit_color{&quot;apple&quot;};           # gives &quot;red&quot;
    </pre>
    <p class="Pp">You can get at lists of keys and values with
        <span class="Li">&quot;keys()&quot;</span> and
        <span class="Li">&quot;values()&quot;</span>.</p>
    <p class="Pp"></p>
    <pre>
 my @fruits = keys %fruit_colors;
 my @colors = values %fruit_colors;
    </pre>
    <p class="Pp">Hashes have no particular internal order, though you can sort
        the keys and loop through them.</p>
    <p class="Pp">Just like special scalars and arrays, there are also special
        hashes. The most well known of these is <span class="Li">%ENV</span>
        which contains environment variables. Read all about it (and other
        special variables) in perlvar.</p>
  </dd>
</dl>
<p class="Pp">Scalars, arrays and hashes are documented more fully in
  perldata.</p>
<p class="Pp">More complex data types can be constructed using references, which
    allow you to build lists and hashes within lists and hashes.</p>
<p class="Pp">A reference is a scalar value and can refer to any other Perl data
    type. So by storing a reference as the value of an array or hash element,
    you can easily create lists and hashes within lists and hashes. The
    following example shows a 2 level hash of hash structure using anonymous
    hash references.</p>
<p class="Pp"></p>
<pre>
 my $variables = {
     scalar  =&gt;  {
                  description =&gt; &quot;single item&quot;,
                  sigil =&gt; '$',
                 },
     array   =&gt;  {
                  description =&gt; &quot;ordered list of items&quot;,
                  sigil =&gt; '@',
                 },
     hash    =&gt;  {
                  description =&gt; &quot;key/value pairs&quot;,
                  sigil =&gt; '%',
                 },
 };

 print &quot;Scalars begin with a $variables-&gt;{'scalar'}-&gt;{'sigil'}\n&quot;;
</pre>
<p class="Pp">Exhaustive information on the topic of references can be found in
    perlreftut, perllol, perlref and perldsc.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Variable_scoping"><a class="permalink" href="#Variable_scoping">Variable
  scoping</a></h2>
<p class="Pp">Throughout the previous section all the examples have used the
    syntax:</p>
<p class="Pp"></p>
<pre>
 my $var = &quot;value&quot;;
</pre>
<p class="Pp">The <span class="Li">&quot;my&quot;</span> is actually not
    required; you could just use:</p>
<p class="Pp"></p>
<pre>
 $var = &quot;value&quot;;
</pre>
<p class="Pp">However, the above usage will create global variables throughout
    your program, which is bad programming practice.
    <span class="Li">&quot;my&quot;</span> creates lexically scoped variables
    instead. The variables are scoped to the block (i.e. a bunch of statements
    surrounded by curly-braces) in which they are defined.</p>
<p class="Pp"></p>
<pre>
 my $x = &quot;foo&quot;;
 my $some_condition = 1;
 if ($some_condition) {
     my $y = &quot;bar&quot;;
     print $x;           # prints &quot;foo&quot;
     print $y;           # prints &quot;bar&quot;
 }
 print $x;               # prints &quot;foo&quot;
 print $y;               # prints nothing; $y has fallen out of scope
</pre>
<p class="Pp">Using <span class="Li">&quot;my&quot;</span> in combination with a
    <span class="Li">&quot;use strict;&quot;</span> at the top of your Perl
    scripts means that the interpreter will pick up certain common programming
    errors. For instance, in the example above, the final
    <span class="Li">&quot;print $y&quot;</span> would cause a compile-time
    error and prevent you from running the program. Using
    <span class="Li">&quot;strict&quot;</span> is highly recommended.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Conditional_and_looping_constructs"><a class="permalink" href="#Conditional_and_looping_constructs">Conditional
  and looping constructs</a></h2>
<p class="Pp">Perl has most of the usual conditional and looping constructs. As
    of Perl 5.10, it even has a case/switch statement (spelled
    <span class="Li">&quot;given&quot;</span>/<span class="Li">&quot;when&quot;</span>).
    See &quot;Switch Statements&quot; in perlsyn for more details.</p>
<p class="Pp">The conditions can be any Perl expression. See the list of
    operators in the next section for information on comparison and boolean
    logic operators, which are commonly used in conditional statements.</p>
<dl class="Bl-tag">
  <dt id="if"><a class="permalink" href="#if">if</a></dt>
  <dd>
    <pre>
 if ( condition ) {
     ...
 } elsif ( other condition ) {
     ...
 } else {
     ...
 }
    </pre>
    <p class="Pp">There's also a negated version of it:</p>
    <p class="Pp"></p>
    <pre>
 unless ( condition ) {
     ...
 }
    </pre>
    <p class="Pp">This is provided as a more readable version of
        <span class="Li">&quot;if
        (!</span><i>condition</i><span class="Li">)&quot;</span>.</p>
    <p class="Pp">Note that the braces are required in Perl, even if you've only
        got one line in the block. However, there is a clever way of making your
        one-line conditional blocks more English like:</p>
    <p class="Pp"></p>
    <pre>
 # the traditional way
 if ($zippy) {
     print &quot;Yow!&quot;;
 }

 # the Perlish post-condition way
 print &quot;Yow!&quot; if $zippy;
 print &quot;We have no bananas&quot; unless $bananas;
    </pre>
  </dd>
  <dt id="while"><a class="permalink" href="#while">while</a></dt>
  <dd>
    <pre>
 while ( condition ) {
     ...
 }
    </pre>
    <p class="Pp">There's also a negated version, for the same reason we have
        <span class="Li">&quot;unless&quot;</span>:</p>
    <p class="Pp"></p>
    <pre>
 until ( condition ) {
     ...
 }
    </pre>
    <p class="Pp">You can also use <span class="Li">&quot;while&quot;</span> in
        a post-condition:</p>
    <p class="Pp"></p>
    <pre>
 print &quot;LA LA LA\n&quot; while 1;          # loops forever
    </pre>
  </dd>
  <dt id="for"><a class="permalink" href="#for">for</a></dt>
  <dd>Exactly like C:
    <p class="Pp"></p>
    <pre>
 for ($i = 0; $i &lt;= $max; $i++) {
     ...
 }
    </pre>
    <p class="Pp">The C style for loop is rarely needed in Perl since Perl
        provides the more friendly list scanning
        <span class="Li">&quot;foreach&quot;</span> loop.</p>
  </dd>
  <dt id="foreach"><a class="permalink" href="#foreach">foreach</a></dt>
  <dd>
    <pre>
 foreach (@array) {
     print &quot;This element is $_\n&quot;;
 }

 print $list[$_] foreach 0 .. $max;

 # you don't have to use the default $_ either...
 foreach my $key (keys %hash) {
     print &quot;The value of $key is $hash{$key}\n&quot;;
 }
    </pre>
    <p class="Pp">The <span class="Li">&quot;foreach&quot;</span> keyword is
        actually a synonym for the <span class="Li">&quot;for&quot;</span>
        keyword. See <span class="Li">&quot;&quot;Foreach Loops&quot; in
        perlsyn&quot;</span>.</p>
  </dd>
</dl>
<p class="Pp">For more detail on looping constructs (and some that weren't
    mentioned in this overview) see perlsyn.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Builtin_operators_and_functions"><a class="permalink" href="#Builtin_operators_and_functions">Builtin
  operators and functions</a></h2>
<p class="Pp">Perl comes with a wide selection of builtin functions. Some of the
    ones we've already seen include <span class="Li">&quot;print&quot;</span>,
    <span class="Li">&quot;sort&quot;</span> and
    <span class="Li">&quot;reverse&quot;</span>. A list of them is given at the
    start of perlfunc and you can easily read about any given function by using
    <span class="Li">&quot;perldoc -f
    </span><i>functionname</i><span class="Li">&quot;</span>.</p>
<p class="Pp">Perl operators are documented in full in perlop, but here are a
    few of the most common ones:</p>
<dl class="Bl-tag">
  <dt id="Arithmetic"><a class="permalink" href="#Arithmetic">Arithmetic</a></dt>
  <dd>
    <pre>
 +   addition
 -   subtraction
 *   multiplication
 /   division
    </pre>
  </dd>
  <dt id="Numeric"><a class="permalink" href="#Numeric">Numeric
    comparison</a></dt>
  <dd>
    <pre>
 ==  equality
 !=  inequality
 &lt;   less than
 &gt;   greater than
 &lt;=  less than or equal
 &gt;=  greater than or equal
    </pre>
  </dd>
  <dt id="String"><a class="permalink" href="#String">String comparison</a></dt>
  <dd>
    <pre>
 eq  equality
 ne  inequality
 lt  less than
 gt  greater than
 le  less than or equal
 ge  greater than or equal
    </pre>
    <p class="Pp">(Why do we have separate numeric and string comparisons?
        Because we don't have special variable types, and Perl needs to know
        whether to sort numerically (where 99 is less than 100) or
        alphabetically (where 100 comes before 99).</p>
  </dd>
  <dt id="Boolean"><a class="permalink" href="#Boolean">Boolean logic</a></dt>
  <dd>
    <pre>
 &amp;&amp;  and
 ||  or
 !   not
    </pre>
    <p class="Pp">(<span class="Li">&quot;and&quot;</span>,
        <span class="Li">&quot;or&quot;</span> and
        <span class="Li">&quot;not&quot;</span> aren't just in the above table
        as descriptions of the operators. They're also supported as operators in
        their own right. They're more readable than the C-style operators, but
        have different precedence to
        <span class="Li">&quot;&amp;&amp;&quot;</span> and friends. Check perlop
        for more detail.)</p>
  </dd>
  <dt id="Miscellaneous"><a class="permalink" href="#Miscellaneous">Miscellaneous</a></dt>
  <dd>
    <pre>
 =   assignment
 .   string concatenation
 x   string multiplication
 ..  range operator (creates a list of numbers or strings)
    </pre>
  </dd>
</dl>
<p class="Pp">Many operators can be combined with a
    <span class="Li">&quot;=&quot;</span> as follows:</p>
<p class="Pp"></p>
<pre>
 $a += 1;        # same as $a = $a + 1
 $a -= 1;        # same as $a = $a - 1
 $a .= &quot;\n&quot;;     # same as $a = $a . &quot;\n&quot;;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Files_and_I/O"><a class="permalink" href="#Files_and_I/O">Files
  and I/O</a></h2>
<p class="Pp">You can open a file for input or output using the
    <span class="Li">&quot;open()&quot;</span> function. It's documented in
    extravagant detail in perlfunc and perlopentut, but in short:</p>
<p class="Pp"></p>
<pre>
 open(my $in,  &quot;&lt;&quot;,  &quot;input.txt&quot;)  or die &quot;Can't open input.txt: $!&quot;;
 open(my $out, &quot;&gt;&quot;,  &quot;output.txt&quot;) or die &quot;Can't open output.txt: $!&quot;;
 open(my $log, &quot;&gt;&gt;&quot;, &quot;my.log&quot;)     or die &quot;Can't open my.log: $!&quot;;
</pre>
<p class="Pp">You can read from an open filehandle using the
    <span class="Li">&quot;&lt;&gt;&quot;</span> operator. In scalar context it
    reads a single line from the filehandle, and in list context it reads the
    whole file in, assigning each line to an element of the list:</p>
<p class="Pp"></p>
<pre>
 my $line  = &lt;$in&gt;;
 my @lines = &lt;$in&gt;;
</pre>
<p class="Pp">Reading in the whole file at one time is called slurping. It can
    be useful but it may be a memory hog. Most text file processing can be done
    a line at a time with Perl's looping constructs.</p>
<p class="Pp">The <span class="Li">&quot;&lt;&gt;&quot;</span> operator is most
    often seen in a <span class="Li">&quot;while&quot;</span> loop:</p>
<p class="Pp"></p>
<pre>
 while (&lt;$in&gt;) {     # assigns each line in turn to $_
     print &quot;Just read in this line: $_&quot;;
 }
</pre>
<p class="Pp">We've already seen how to print to standard output using
    <span class="Li">&quot;print()&quot;</span>. However,
    <span class="Li">&quot;print()&quot;</span> can also take an optional first
    argument specifying which filehandle to print to:</p>
<p class="Pp"></p>
<pre>
 print STDERR &quot;This is your final warning.\n&quot;;
 print $out $record;
 print $log $logmessage;
</pre>
<p class="Pp">When you're done with your filehandles, you should
    <span class="Li">&quot;close()&quot;</span> them (though to be honest, Perl
    will clean up after you if you forget):</p>
<p class="Pp"></p>
<pre>
 close $in or die &quot;$in: $!&quot;;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Regular_expressions"><a class="permalink" href="#Regular_expressions">Regular
  expressions</a></h2>
<p class="Pp">Perl's regular expression support is both broad and deep, and is
    the subject of lengthy documentation in perlrequick, perlretut, and
    elsewhere. However, in short:</p>
<dl class="Bl-tag">
  <dt id="Simple"><a class="permalink" href="#Simple">Simple matching</a></dt>
  <dd>
    <pre>
 if (/foo/)       { ... }  # true if $_ contains &quot;foo&quot;
 if ($a =~ /foo/) { ... }  # true if $a contains &quot;foo&quot;
    </pre>
    <p class="Pp">The <span class="Li">&quot;//&quot;</span> matching operator
        is documented in perlop. It operates on <span class="Li">$_</span> by
        default, or can be bound to another variable using the
        <span class="Li">&quot;=~&quot;</span> binding operator (also documented
        in perlop).</p>
  </dd>
  <dt id="Simple~2"><a class="permalink" href="#Simple~2">Simple
    substitution</a></dt>
  <dd>
    <pre>
 s/foo/bar/;               # replaces foo with bar in $_
 $a =~ s/foo/bar/;         # replaces foo with bar in $a
 $a =~ s/foo/bar/g;        # replaces ALL INSTANCES of foo with bar
                           # in $a
    </pre>
    <p class="Pp">The <span class="Li">&quot;s///&quot;</span> substitution
        operator is documented in perlop.</p>
  </dd>
  <dt id="More"><a class="permalink" href="#More">More complex regular
    expressions</a></dt>
  <dd>You don't just have to match on fixed strings. In fact, you can match on
      just about anything you could dream of by using more complex regular
      expressions. These are documented at great length in perlre, but for the
      meantime, here's a quick cheat sheet:
    <p class="Pp"></p>
    <pre>
 .                   a single character
 \s                  a whitespace character (space, tab, newline,
                     ...)
 \S                  non-whitespace character
 \d                  a digit (0-9)
 \D                  a non-digit
 \w                  a word character (a-z, A-Z, 0-9, _)
 \W                  a non-word character
 [aeiou]             matches a single character in the given set
 [^aeiou]            matches a single character outside the given
                     set
 (foo|bar|baz)       matches any of the alternatives specified

 ^                   start of string
 $                   end of string
    </pre>
    <p class="Pp">Quantifiers can be used to specify how many of the previous
        thing you want to match on, where &quot;thing&quot; means either a
        literal character, one of the metacharacters listed above, or a group of
        characters or metacharacters in parentheses.</p>
    <p class="Pp"></p>
    <pre>
 *                   zero or more of the previous thing
 +                   one or more of the previous thing
 ?                   zero or one of the previous thing
 {3}                 matches exactly 3 of the previous thing
 {3,6}               matches between 3 and 6 of the previous thing
 {3,}                matches 3 or more of the previous thing
    </pre>
    <p class="Pp">Some brief examples:</p>
    <p class="Pp"></p>
    <pre>
 /^\d+/              string starts with one or more digits
 /^$/                nothing in the string (start and end are
                     adjacent)
 /(\d\s){3}/         three digits, each followed by a whitespace
                     character (eg &quot;3 4 5 &quot;)
 /(a.)+/             matches a string in which every odd-numbered
                     letter is a (eg &quot;abacadaf&quot;)

 # This loop reads from STDIN, and prints non-blank lines:
 while (&lt;&gt;) {
     next if /^$/;
     print;
 }
    </pre>
  </dd>
  <dt id="Parentheses"><a class="permalink" href="#Parentheses">Parentheses for
    capturing</a></dt>
  <dd>As well as grouping, parentheses serve a second purpose. They can be used
      to capture the results of parts of the regexp match for later use. The
      results end up in <span class="Li">$1</span>, <span class="Li">$2</span>
      and so on.
    <p class="Pp"></p>
    <pre>
 # a cheap and nasty way to break an email address up into parts

 if ($email =~ /([^@]+)@(.+)/) {
     print &quot;Username is $1\n&quot;;
     print &quot;Hostname is $2\n&quot;;
 }
    </pre>
  </dd>
  <dt id="Other"><a class="permalink" href="#Other">Other regexp
    features</a></dt>
  <dd>Perl regexps also support backreferences, lookaheads, and all kinds of
      other complex details. Read all about them in perlrequick, perlretut, and
      perlre.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Writing_subroutines"><a class="permalink" href="#Writing_subroutines">Writing
  subroutines</a></h2>
<p class="Pp">Writing subroutines is easy:</p>
<p class="Pp"></p>
<pre>
 sub logger {
    my $logmessage = shift;
    open my $logfile, &quot;&gt;&gt;&quot;, &quot;my.log&quot; or die &quot;Could not open my.log: $!&quot;;
    print $logfile $logmessage;
 }
</pre>
<p class="Pp">Now we can use the subroutine just as any other built-in
  function:</p>
<p class="Pp"></p>
<pre>
 logger(&quot;We have a logger subroutine!&quot;);
</pre>
<p class="Pp">What's that <span class="Li">&quot;shift&quot;</span>? Well, the
    arguments to a subroutine are available to us as a special array called
    <span class="Li">@_</span> (see perlvar for more on that). The default
    argument to the <span class="Li">&quot;shift&quot;</span> function just
    happens to be <span class="Li">@_</span>. So <span class="Li">&quot;my
    $logmessage = shift;&quot;</span> shifts the first item off the list of
    arguments and assigns it to <span class="Li">$logmessage</span>.</p>
<p class="Pp">We can manipulate <span class="Li">@_</span> in other ways
  too:</p>
<p class="Pp"></p>
<pre>
 my ($logmessage, $priority) = @_;       # common
 my $logmessage = $_[0];                 # uncommon, and ugly
</pre>
<p class="Pp">Subroutines can also return values:</p>
<p class="Pp"></p>
<pre>
 sub square {
     my $num = shift;
     my $result = $num * $num;
     return $result;
 }
</pre>
<p class="Pp">Then use it like:</p>
<p class="Pp"></p>
<pre>
 $sq = square(8);
</pre>
<p class="Pp">For more information on writing subroutines, see perlsub.</p>
</section>
<section class="Ss">
<h2 class="Ss">OO Perl</h2>
<p class="Pp">OO Perl is relatively simple and is implemented using references
    which know what sort of object they are based on Perl's concept of packages.
    However, OO Perl is largely beyond the scope of this document. Read
    perlootut and perlobj.</p>
<p class="Pp">As a beginning Perl programmer, your most common use of OO Perl
    will be in using third-party modules, which are documented below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_Perl_modules"><a class="permalink" href="#Using_Perl_modules">Using
  Perl modules</a></h2>
<p class="Pp">Perl modules provide a range of features to help you avoid
    reinventing the wheel, and can be downloaded from CPAN (
    &lt;http://www.cpan.org/&gt; ). A number of popular modules are included
    with the Perl distribution itself.</p>
<p class="Pp">Categories of modules range from text manipulation to network
    protocols to database integration to graphics. A categorized list of modules
    is also available from CPAN.</p>
<p class="Pp">To learn how to install modules you download from CPAN, read
    perlmodinstall.</p>
<p class="Pp">To learn how to use a particular module, use
    <span class="Li">&quot;perldoc
    </span><i>Module::Name</i><span class="Li">&quot;</span>. Typically you will
    want to <span class="Li">&quot;use
    </span><i>Module::Name</i><span class="Li">&quot;</span>, which will then
    give you access to exported functions or an OO interface to the module.</p>
<p class="Pp">perlfaq contains questions and answers related to many common
    tasks, and often provides suggestions for good CPAN modules to use.</p>
<p class="Pp">perlmod describes Perl modules in general. perlmodlib lists the
    modules which came with your Perl installation.</p>
<p class="Pp">If you feel the urge to write Perl modules, perlnewmod will give
    you good advice.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Kirrily &quot;Skud&quot; Robert &lt;skud@cpan.org&gt;</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

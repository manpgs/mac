<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PERLIPC(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLIPC(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLIPC(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlipc - Perl interprocess communication (signals, fifos, pipes,
    safe subprocesses, sockets, and semaphores)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The basic IPC facilities of Perl are built out of the good old
    Unix signals, named pipes, pipe opens, the Berkeley socket routines, and
    SysV IPC calls. Each is used in slightly different situations.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Signals"><a class="permalink" href="#Signals">Signals</a></h1>
<p class="Pp">Perl uses a simple signal handling model: the
    <span class="Li">%SIG</span> hash contains names or references of
    user-installed signal handlers. These handlers will be called with an
    argument which is the name of the signal that triggered it. A signal may be
    generated intentionally from a particular keyboard sequence like control-C
    or control-Z, sent to you from another process, or triggered automatically
    by the kernel when special events transpire, like a child process exiting,
    your own process running out of stack space, or hitting a process file-size
    limit.</p>
<p class="Pp">For example, to trap an interrupt signal, set up a handler like
    this:</p>
<p class="Pp"></p>
<pre>    our $shucks;
    sub catch_zap {
        my $signame = shift;
        $shucks++;
        die &quot;Somebody sent me a SIG$signame&quot;;
    }
    $SIG{INT} = __PACKAGE__ . &quot;::catch_zap&quot;;
    $SIG{INT} = \&amp;catch_zap;  # best strategy
</pre>
<p class="Pp">Prior to Perl 5.8.0 it was necessary to do as little as you
    possibly could in your handler; notice how all we do is set a global
    variable and then raise an exception. That's because on most systems,
    libraries are not re-entrant; particularly, memory allocation and I/O
    routines are not. That meant that doing nearly <i>anything</i> in your
    handler could in theory trigger a memory fault and subsequent core dump -
    see &quot;Deferred Signals (Safe Signals)&quot; below.</p>
<p class="Pp">The names of the signals are the ones listed out by
    <span class="Li">&quot;kill -l&quot;</span> on your system, or you can
    retrieve them using the CPAN module IPC::Signal.</p>
<p class="Pp">You may also choose to assign the strings
    <span class="Li">&quot;IGNORE&quot;</span> or
    <span class="Li">&quot;DEFAULT&quot;</span> as the handler, in which case
    Perl will try to discard the signal or do the default thing.</p>
<p class="Pp">On most Unix platforms, the
    <span class="Li">&quot;CHLD&quot;</span> (sometimes also known as
    <span class="Li">&quot;CLD&quot;</span>) signal has special behavior with
    respect to a value of <span class="Li">&quot;IGNORE&quot;</span>. Setting
    <span class="Li">$SIG{CHLD}</span> to
    <span class="Li">&quot;IGNORE&quot;</span> on such a platform has the effect
    of not creating zombie processes when the parent process fails to
    <span class="Li">&quot;wait()&quot;</span> on its child processes (i.e.,
    child processes are automatically reaped). Calling
    <span class="Li">&quot;wait()&quot;</span> with
    <span class="Li">$SIG{CHLD}</span> set to
    <span class="Li">&quot;IGNORE&quot;</span> usually returns
    <span class="Li">&quot;-1&quot;</span> on such platforms.</p>
<p class="Pp">Some signals can be neither trapped nor ignored, such as the KILL
    and STOP (but not the TSTP) signals. Note that ignoring signals makes them
    disappear. If you only want them blocked temporarily without them getting
    lost you'll have to use POSIX' sigprocmask.</p>
<p class="Pp">Sending a signal to a negative process ID means that you send the
    signal to the entire Unix process group. This code sends a hang-up signal to
    all processes in the current process group, and also sets
    <span class="Li">$SIG</span>{HUP} to
    <span class="Li">&quot;IGNORE&quot;</span> so it doesn't kill itself:</p>
<p class="Pp"></p>
<pre>    # block scope for local
    {
        local $SIG{HUP} = &quot;IGNORE&quot;;
        kill HUP =&gt; -getpgrp();
        # snazzy writing of: kill(&quot;HUP&quot;, -getpgrp())
    }
</pre>
<p class="Pp">Another interesting signal to send is signal number zero. This
    doesn't actually affect a child process, but instead checks whether it's
    alive or has changed its UIDs.</p>
<p class="Pp"></p>
<pre>    unless (kill 0 =&gt; $kid_pid) {
        warn &quot;something wicked happened to $kid_pid&quot;;
    }
</pre>
<p class="Pp">Signal number zero may fail because you lack permission to send
    the signal when directed at a process whose real or saved UID is not
    identical to the real or effective UID of the sending process, even though
    the process is alive. You may be able to determine the cause of failure
    using <span class="Li">$!</span> or
  <span class="Li">&quot;%!&quot;</span>.</p>
<p class="Pp"></p>
<pre>    unless (kill(0 =&gt; $pid) || $!{EPERM}) {
        warn &quot;$pid looks dead&quot;;
    }
</pre>
<p class="Pp">You might also want to employ anonymous functions for simple
    signal handlers:</p>
<p class="Pp"></p>
<pre>    $SIG{INT} = sub { die &quot;\nOutta here!\n&quot; };
</pre>
<p class="Pp">SIGCHLD handlers require some special care. If a second child dies
    while in the signal handler caused by the first death, we won't get another
    signal. So must loop here else we will leave the unreaped child as a zombie.
    And the next time two children die we get another zombie. And so on.</p>
<p class="Pp"></p>
<pre>    use POSIX &quot;:sys_wait_h&quot;;
    $SIG{CHLD} = sub {
        while ((my $child = waitpid(-1, WNOHANG)) &gt; 0) {
            $Kid_Status{$child} = $?;
        }
    };
    # do something that forks...
</pre>
<p class="Pp">Be careful: <b>qx()</b>, <b>system()</b>, and some modules for
    calling external commands do a <b>fork()</b>, then <b>wait()</b> for the
    result. Thus, your signal handler will be called. Because <b>wait()</b> was
    already called by <b>system()</b> or <b>qx()</b>, the <b>wait()</b> in the
    signal handler will see no more zombies and will therefore block.</p>
<p class="Pp">The best way to prevent this issue is to use <b>waitpid()</b>, as
    in the following example:</p>
<p class="Pp"></p>
<pre>    use POSIX &quot;:sys_wait_h&quot;; # for nonblocking read
    my %children;
    $SIG{CHLD} = sub {
        # don't change $! and $? outside handler
        local ($!, $?);
        while ( (my $pid = waitpid(-1, WNOHANG)) &gt; 0 ) {
            delete $children{$pid};
            cleanup_child($pid, $?);
        }
    };
    while (1) {
        my $pid = fork();
        die &quot;cannot fork&quot; unless defined $pid;
        if ($pid == 0) {
            # ...
            exit 0;
        } else {
            $children{$pid}=1;
            # ...
            system($command);
            # ...
       }
    }
</pre>
<p class="Pp">Signal handling is also used for timeouts in Unix. While safely
    protected within an <span class="Li">&quot;eval{}&quot;</span> block, you
    set a signal handler to trap alarm signals and then schedule to have one
    delivered to you in some number of seconds. Then try your blocking
    operation, clearing the alarm when it's done but not before you've exited
    your <span class="Li">&quot;eval{}&quot;</span> block. If it goes off,
    you'll use <b>die()</b> to jump out of the block.</p>
<p class="Pp">Here's an example:</p>
<p class="Pp"></p>
<pre>    my $ALARM_EXCEPTION = &quot;alarm clock restart&quot;;
    eval {
        local $SIG{ALRM} = sub { die $ALARM_EXCEPTION };
        alarm 10;
        flock(FH, 2)    # blocking write lock
                        || die &quot;cannot flock: $!&quot;;
        alarm 0;
    };
    if ($@ &amp;&amp; $@ !~ quotemeta($ALARM_EXCEPTION)) { die }
</pre>
<p class="Pp">If the operation being timed out is <b>system()</b> or
    <b>qx()</b>, this technique is liable to generate zombies. If this matters
    to you, you'll need to do your own <b>fork()</b> and <b>exec()</b>, and kill
    the errant child process.</p>
<p class="Pp">For more complex signal handling, you might see the standard POSIX
    module. Lamentably, this is almost entirely undocumented, but the
    <i>ext/POSIX/t/sigaction.t</i> file from the Perl source distribution has
    some examples in it.</p>
<section class="Ss">
<h2 class="Ss" id="Handling_the_"><a class="permalink" href="#Handling_the_">Handling
  the SIGHUP Signal in Daemons</a></h2>
<p class="Pp">A process that usually starts when the system boots and shuts down
    when the system is shut down is called a daemon (Disk And Execution
    MONitor). If a daemon process has a configuration file which is modified
    after the process has been started, there should be a way to tell that
    process to reread its configuration file without stopping the process. Many
    daemons provide this mechanism using a
    <span class="Li">&quot;SIGHUP&quot;</span> signal handler. When you want to
    tell the daemon to reread the file, simply send it the
    <span class="Li">&quot;SIGHUP&quot;</span> signal.</p>
<p class="Pp">The following example implements a simple daemon, which restarts
    itself every time the <span class="Li">&quot;SIGHUP&quot;</span> signal is
    received. The actual code is located in the subroutine
    <span class="Li">&quot;code()&quot;</span>, which just prints some debugging
    info to show that it works; it should be replaced with the real code.</p>
<p class="Pp"></p>
<pre>  #!/usr/bin/perl
  use strict;
  use warnings;
  use POSIX ();
  use FindBin ();
  use File::Basename ();
  use File::Spec::Functions qw(catfile);
  $| = 1;
  # make the daemon cross-platform, so exec always calls the script
  # itself with the right path, no matter how the script was invoked.
  my $script = File::Basename::basename($0);
  my $SELF  = catfile($FindBin::Bin, $script);
  # POSIX unmasks the sigprocmask properly
  $SIG{HUP} = sub {
      print &quot;got SIGHUP\n&quot;;
      exec($SELF, @ARGV)        || die &quot;$0: couldn't restart: $!&quot;;
  };
  code();
  sub code {
      print &quot;PID: $$\n&quot;;
      print &quot;ARGV: @ARGV\n&quot;;
      my $count = 0;
      while (1) {
          sleep 2;
          print ++$count, &quot;\n&quot;;
      }
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Deferred_Signals_(Safe_Signals)"><a class="permalink" href="#Deferred_Signals_(Safe_Signals)">Deferred
  Signals (Safe Signals)</a></h2>
<p class="Pp">Before Perl 5.8.0, installing Perl code to deal with signals
    exposed you to danger from two things. First, few system library functions
    are re-entrant. If the signal interrupts while Perl is executing one
    function (like <b>malloc</b>(3) or <b>printf</b>(3)), and your signal
    handler then calls the same function again, you could get unpredictable
    behavior--often, a core dump. Second, Perl isn't itself re-entrant at the
    lowest levels. If the signal interrupts Perl while Perl is changing its own
    internal data structures, similarly unpredictable behavior may result.</p>
<p class="Pp">There were two things you could do, knowing this: be paranoid or
    be pragmatic. The paranoid approach was to do as little as possible in your
    signal handler. Set an existing integer variable that already has a value,
    and return. This doesn't help you if you're in a slow system call, which
    will just restart. That means you have to
    <span class="Li">&quot;die&quot;</span> to <b>longjmp</b>(3) out of the
    handler. Even this is a little cavalier for the true paranoiac, who avoids
    <span class="Li">&quot;die&quot;</span> in a handler because the system
    <i>is</i> out to get you. The pragmatic approach was to say &quot;I know the
    risks, but prefer the convenience&quot;, and to do anything you wanted in
    your signal handler, and be prepared to clean up core dumps now and
  again.</p>
<p class="Pp">Perl 5.8.0 and later avoid these problems by &quot;deferring&quot;
    signals. That is, when the signal is delivered to the process by the system
    (to the C code that implements Perl) a flag is set, and the handler returns
    immediately. Then at strategic &quot;safe&quot; points in the Perl
    interpreter (e.g. when it is about to execute a new opcode) the flags are
    checked and the Perl level handler from <span class="Li">%SIG</span> is
    executed. The &quot;deferred&quot; scheme allows much more flexibility in
    the coding of signal handlers as we know the Perl interpreter is in a safe
    state, and that we are not in a system library function when the handler is
    called. However the implementation does differ from previous Perls in the
    following ways:</p>
<dl class="Bl-tag">
  <dt id="Long-running"><a class="permalink" href="#Long-running">Long-running
    opcodes</a></dt>
  <dd>As the Perl interpreter looks at signal flags only when it is about to
      execute a new opcode, a signal that arrives during a long-running opcode
      (e.g. a regular expression operation on a very large string) will not be
      seen until the current opcode completes.
    <p class="Pp">If a signal of any given type fires multiple times during an
        opcode (such as from a fine-grained timer), the handler for that signal
        will be called only once, after the opcode completes; all other
        instances will be discarded. Furthermore, if your system's signal queue
        gets flooded to the point that there are signals that have been raised
        but not yet caught (and thus not deferred) at the time an opcode
        completes, those signals may well be caught and deferred during
        subsequent opcodes, with sometimes surprising results. For example, you
        may see alarms delivered even after calling
        <span class="Li">alarm(0)</span> as the latter stops the raising of
        alarms but does not cancel the delivery of alarms raised but not yet
        caught. Do not depend on the behaviors described in this paragraph as
        they are side effects of the current implementation and may change in
        future versions of Perl.</p>
  </dd>
  <dt id="Interrupting"><a class="permalink" href="#Interrupting">Interrupting
    IO</a></dt>
  <dd>When a signal is delivered (e.g., SIGINT from a control-C) the operating
      system breaks into IO operations like <i>read</i>(2), which is used to
      implement Perl's <b>readline()</b> function, the
      <span class="Li">&quot;&lt;&gt;&quot;</span> operator. On older Perls the
      handler was called immediately (and as
      <span class="Li">&quot;read&quot;</span> is not &quot;unsafe&quot;, this
      worked well). With the &quot;deferred&quot; scheme the handler is
      <i>not</i> called immediately, and if Perl is using the system's
      <span class="Li">&quot;stdio&quot;</span> library that library may restart
      the <span class="Li">&quot;read&quot;</span> without returning to Perl to
      give it a chance to call the <span class="Li">%SIG</span> handler. If this
      happens on your system the solution is to use the
      <span class="Li">&quot;:perlio&quot;</span> layer to do IO--at least on
      those handles that you want to be able to break into with signals. (The
      <span class="Li">&quot;:perlio&quot;</span> layer checks the signal flags
      and calls <span class="Li">%SIG</span> handlers before resuming IO
      operation.)
    <p class="Pp">The default in Perl 5.8.0 and later is to automatically use
        the <span class="Li">&quot;:perlio&quot;</span> layer.</p>
    <p class="Pp">Note that it is not advisable to access a file handle within a
        signal handler where that signal has interrupted an I/O operation on
        that same handle. While perl will at least try hard not to crash, there
        are no guarantees of data integrity; for example, some data might get
        dropped or written twice.</p>
    <p class="Pp">Some networking library functions like <b>gethostbyname()</b>
        are known to have their own implementations of timeouts which may
        conflict with your timeouts. If you have problems with such functions,
        try using the POSIX <b>sigaction()</b> function, which bypasses Perl
        safe signals. Be warned that this does subject you to possible memory
        corruption, as described above.</p>
    <p class="Pp">Instead of setting <span class="Li">$SIG{ALRM}</span>:</p>
    <p class="Pp"></p>
    <pre>   local $SIG{ALRM} = sub { die &quot;alarm&quot; };
    </pre>
    <p class="Pp">try something like the following:</p>
    <p class="Pp"></p>
    <pre> use POSIX qw(SIGALRM);
 POSIX::sigaction(SIGALRM,
                  POSIX::SigAction-&gt;new(sub { die &quot;alarm&quot; }))
          || die &quot;Error setting SIGALRM handler: $!\n&quot;;
    </pre>
    <p class="Pp">Another way to disable the safe signal behavior locally is to
        use the <span class="Li">&quot;Perl::Unsafe::Signals&quot;</span> module
        from CPAN, which affects all signals.</p>
  </dd>
  <dt id="Restartable"><a class="permalink" href="#Restartable">Restartable
    system calls</a></dt>
  <dd>On systems that supported it, older versions of Perl used the SA_RESTART
      flag when installing <span class="Li">%SIG</span> handlers. This meant
      that restartable system calls would continue rather than returning when a
      signal arrived. In order to deliver deferred signals promptly, Perl 5.8.0
      and later do <i>not</i> use SA_RESTART. Consequently, restartable system
      calls can fail (with $! set to <span class="Li">&quot;EINTR&quot;</span>)
      in places where they previously would have succeeded.
    <p class="Pp">The default <span class="Li">&quot;:perlio&quot;</span> layer
        retries <span class="Li">&quot;read&quot;</span>,
        <span class="Li">&quot;write&quot;</span> and
        <span class="Li">&quot;close&quot;</span> as described above;
        interrupted <span class="Li">&quot;wait&quot;</span> and
        <span class="Li">&quot;waitpid&quot;</span> calls will always be
        retried.</p>
  </dd>
  <dt>Signals as &quot;faults&quot;</dt>
  <dd>Certain signals like SEGV, ILL, and BUS are generated by virtual memory
      addressing errors and similar &quot;faults&quot;. These are normally
      fatal: there is little a Perl-level handler can do with them. So Perl
      delivers them immediately rather than attempting to defer them.</dd>
  <dt>Signals triggered by operating system state</dt>
  <dd>On some operating systems certain signal handlers are supposed to &quot;do
      something&quot; before returning. One example can be CHLD or CLD, which
      indicates a child process has completed. On some operating systems the
      signal handler is expected to <span class="Li">&quot;wait&quot;</span> for
      the completed child process. On such systems the deferred signal scheme
      will not work for those signals: it does not do the
      <span class="Li">&quot;wait&quot;</span>. Again the failure will look like
      a loop as the operating system will reissue the signal because there are
      completed child processes that have not yet been
      <span class="Li">&quot;wait&quot;</span>ed for.</dd>
</dl>
<p class="Pp">If you want the old signal behavior back despite possible memory
    corruption, set the environment variable
    <span class="Li">&quot;PERL_SIGNALS&quot;</span> to
    <span class="Li">&quot;unsafe&quot;</span>. This feature first appeared in
    Perl 5.8.1.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Named_Pipes"><a class="permalink" href="#Named_Pipes">Named
  Pipes</a></h1>
<p class="Pp">A named pipe (often referred to as a FIFO) is an old Unix IPC
    mechanism for processes communicating on the same machine. It works just
    like regular anonymous pipes, except that the processes rendezvous using a
    filename and need not be related.</p>
<p class="Pp">To create a named pipe, use the
    <span class="Li">&quot;POSIX::mkfifo()&quot;</span> function.</p>
<p class="Pp"></p>
<pre>    use POSIX qw(mkfifo);
    mkfifo($path, 0700)     ||  die &quot;mkfifo $path failed: $!&quot;;
</pre>
<p class="Pp">You can also use the Unix command <b>mknod</b>(1), or on some
    systems, <b>mkfifo</b>(1). These may not be in your normal path, though.</p>
<p class="Pp"></p>
<pre>    # system return val is backwards, so &amp;&amp; not ||
    #
    $ENV{PATH} .= &quot;:/etc:/usr/etc&quot;;
    if  (      system(&quot;mknod&quot;,  $path, &quot;p&quot;)
            &amp;&amp; system(&quot;mkfifo&quot;, $path) )
    {
        die &quot;mk{nod,fifo} $path failed&quot;;
    }
</pre>
<p class="Pp">A fifo is convenient when you want to connect a process to an
    unrelated one. When you open a fifo, the program will block until there's
    something on the other end.</p>
<p class="Pp">For example, let's say you'd like to have your <i>.signature</i>
    file be a named pipe that has a Perl program on the other end. Now every
    time any program (like a mailer, news reader, finger program, etc.) tries to
    read from that file, the reading program will read the new signature from
    your program. We'll use the pipe-checking file-test operator, <b>-p</b>, to
    find out whether anyone (or anything) has accidentally removed our fifo.</p>
<p class="Pp"></p>
<pre>    chdir();    # go home
    my $FIFO = &quot;.signature&quot;;
    while (1) {
        unless (-p $FIFO) {
            unlink $FIFO;   # discard any failure, will catch later
            require POSIX;  # delayed loading of heavy module
            POSIX::mkfifo($FIFO, 0700)
                                || die &quot;can't mkfifo $FIFO: $!&quot;;
        }
        # next line blocks till there's a reader
        open (FIFO, &quot;&gt; $FIFO&quot;)  || die &quot;can't open $FIFO: $!&quot;;
        print FIFO &quot;John Smith (smith\@host.org)\n&quot;, `fortune -s`;
        close(FIFO)             || die &quot;can't close $FIFO: $!&quot;;
        sleep 2;                # to avoid dup signals
    }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="Using_"><a class="permalink" href="#Using_">Using
  <b>open()</b> for IPC</a></h1>
<p class="Pp">Perl's basic <b>open()</b> statement can also be used for
    unidirectional interprocess communication by either appending or prepending
    a pipe symbol to the second argument to <b>open()</b>. Here's how to start
    something up in a child process you intend to write to:</p>
<p class="Pp"></p>
<pre>    open(SPOOLER, &quot;| cat -v | lpr -h 2&gt;/dev/null&quot;)
                        || die &quot;can't fork: $!&quot;;
    local $SIG{PIPE} = sub { die &quot;spooler pipe broke&quot; };
    print SPOOLER &quot;stuff\n&quot;;
    close SPOOLER       || die &quot;bad spool: $! $?&quot;;
</pre>
<p class="Pp">And here's how to start up a child process you intend to read
    from:</p>
<p class="Pp"></p>
<pre>    open(STATUS, &quot;netstat -an 2&gt;&amp;1 |&quot;)
                        || die &quot;can't fork: $!&quot;;
    while (&lt;STATUS&gt;) {
        next if /^(tcp|udp)/;
        print;
    }
    close STATUS        || die &quot;bad netstat: $! $?&quot;;
</pre>
<p class="Pp">If one can be sure that a particular program is a Perl script
    expecting filenames in <span class="Li">@ARGV</span>, the clever programmer
    can write something like this:</p>
<p class="Pp"></p>
<pre>    % program f1 &quot;cmd1|&quot; - f2 &quot;cmd2|&quot; f3 &lt; tmpfile
</pre>
<p class="Pp">and no matter which sort of shell it's called from, the Perl
    program will read from the file <i>f1</i>, the process <i>cmd1</i>, standard
    input (<i>tmpfile</i> in this case), the <i>f2</i> file, the <i>cmd2</i>
    command, and finally the <i>f3</i> file. Pretty nifty, eh?</p>
<p class="Pp">You might notice that you could use backticks for much the same
    effect as opening a pipe for reading:</p>
<p class="Pp"></p>
<pre>    print grep { !/^(tcp|udp)/ } `netstat -an 2&gt;&amp;1`;
    die &quot;bad netstatus ($?)&quot; if $?;
</pre>
<p class="Pp">While this is true on the surface, it's much more efficient to
    process the file one line or record at a time because then you don't have to
    read the whole thing into memory at once. It also gives you finer control of
    the whole process, letting you kill off the child process early if you'd
    like.</p>
<p class="Pp">Be careful to check the return values from both <b>open()</b> and
    <b>close()</b>. If you're <i>writing</i> to a pipe, you should also trap
    SIGPIPE. Otherwise, think of what happens when you start up a pipe to a
    command that doesn't exist: the <b>open()</b> will in all likelihood succeed
    (it only reflects the <b>fork()</b>'s success), but then your output will
    fail--spectacularly. Perl can't know whether the command worked, because
    your command is actually running in a separate process whose <b>exec()</b>
    might have failed. Therefore, while readers of bogus commands return just a
    quick EOF, writers to bogus commands will get hit with a signal, which
    they'd best be prepared to handle. Consider:</p>
<p class="Pp"></p>
<pre>    open(FH, &quot;|bogus&quot;)      || die &quot;can't fork: $!&quot;;
    print FH &quot;bang\n&quot;;      #  neither necessary nor sufficient
                            #  to check print retval!
    close(FH)               || die &quot;can't close: $!&quot;;
</pre>
<p class="Pp">The reason for not checking the return value from <b>print()</b>
    is because of pipe buffering; physical writes are delayed. That won't blow
    up until the close, and it will blow up with a SIGPIPE. To catch it, you
    could use this:</p>
<p class="Pp"></p>
<pre>    $SIG{PIPE} = &quot;IGNORE&quot;;
    open(FH, &quot;|bogus&quot;)  || die &quot;can't fork: $!&quot;;
    print FH &quot;bang\n&quot;;
    close(FH)           || die &quot;can't close: status=$?&quot;;
</pre>
<section class="Ss">
<h2 class="Ss" id="Filehandles"><a class="permalink" href="#Filehandles">Filehandles</a></h2>
<p class="Pp">Both the main process and any child processes it forks share the
    same STDIN, STDOUT, and STDERR filehandles. If both processes try to access
    them at once, strange things can happen. You may also want to close or
    reopen the filehandles for the child. You can get around this by opening
    your pipe with <b>open()</b>, but on some systems this means that the child
    process cannot outlive the parent.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Background_Processes"><a class="permalink" href="#Background_Processes">Background
  Processes</a></h2>
<p class="Pp">You can run a command in the background with:</p>
<p class="Pp"></p>
<pre>    system(&quot;cmd &amp;&quot;);
</pre>
<p class="Pp">The command's STDOUT and STDERR (and possibly STDIN, depending on
    your shell) will be the same as the parent's. You won't need to catch
    SIGCHLD because of the double-fork taking place; see below for details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Complete_Dissociation_of_Child_from_Parent"><a class="permalink" href="#Complete_Dissociation_of_Child_from_Parent">Complete
  Dissociation of Child from Parent</a></h2>
<p class="Pp">In some cases (starting server processes, for instance) you'll
    want to completely dissociate the child process from the parent. This is
    often called daemonization. A well-behaved daemon will also <b>chdir()</b>
    to the root directory so it doesn't prevent unmounting the filesystem
    containing the directory from which it was launched, and redirect its
    standard file descriptors from and to <i>/dev/null</i> so that random output
    doesn't wind up on the user's terminal.</p>
<p class="Pp"></p>
<pre> use POSIX &quot;setsid&quot;;
 sub daemonize {
     chdir(&quot;/&quot;)                  || die &quot;can't chdir to /: $!&quot;;
     open(STDIN,  &quot;&lt; /dev/null&quot;) || die &quot;can't read /dev/null: $!&quot;;
     open(STDOUT, &quot;&gt; /dev/null&quot;) || die &quot;can't write to /dev/null: $!&quot;;
     defined(my $pid = fork())   || die &quot;can't fork: $!&quot;;
     exit if $pid;               # non-zero now means I am the parent
     (setsid() != -1)            || die &quot;Can't start a new session: $!&quot;;
     open(STDERR, &quot;&gt;&amp;STDOUT&quot;)    || die &quot;can't dup stdout: $!&quot;;
 }
</pre>
<p class="Pp">The <b>fork()</b> has to come before the <b>setsid()</b> to ensure
    you aren't a process group leader; the <b>setsid()</b> will fail if you are.
    If your system doesn't have the <b>setsid()</b> function, open
    <i>/dev/tty</i> and use the <span class="Li">&quot;TIOCNOTTY&quot;</span>
    <b>ioctl()</b> on it instead. See <b>tty</b>(4) for details.</p>
<p class="Pp">Non-Unix users should check their
    <span class="Li">&quot;</span><span class="Li"><i>Your_OS</i></span><span class="Li">::Process&quot;</span>
    module for other possible solutions.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Safe_Pipe_Opens"><a class="permalink" href="#Safe_Pipe_Opens">Safe
  Pipe Opens</a></h2>
<p class="Pp">Another interesting approach to IPC is making your single program
    go multiprocess and communicate between--or even amongst--yourselves. The
    <b>open()</b> function will accept a file argument of either
    <span class="Li">&quot;-|&quot;</span> or
    <span class="Li">&quot;|-&quot;</span> to do a very interesting thing: it
    forks a child connected to the filehandle you've opened. The child is
    running the same program as the parent. This is useful for safely opening a
    file when running under an assumed UID or GID, for example. If you open a
    pipe <i>to</i> minus, you can write to the filehandle you opened and your
    kid will find it in <i>his</i> STDIN. If you open a pipe <i>from</i> minus,
    you can read from the filehandle you opened whatever your kid writes to
    <i>his</i> STDOUT.</p>
<p class="Pp"></p>
<pre>    use English;
    my $PRECIOUS = &quot;/path/to/some/safe/file&quot;;
    my $sleep_count;
    my $pid;
    do {
        $pid = open(KID_TO_WRITE, &quot;|-&quot;);
        unless (defined $pid) {
            warn &quot;cannot fork: $!&quot;;
            die &quot;bailing out&quot; if $sleep_count++ &gt; 6;
            sleep 10;
        }
    } until defined $pid;
    if ($pid) {                 # I am the parent
        print KID_TO_WRITE @some_data;
        close(KID_TO_WRITE)     || warn &quot;kid exited $?&quot;;
    } else {                    # I am the child
        # drop permissions in setuid and/or setgid programs:
        ($EUID, $EGID) = ($UID, $GID);
        open (OUTFILE, &quot;&gt; $PRECIOUS&quot;)
                                || die &quot;can't open $PRECIOUS: $!&quot;;
        while (&lt;STDIN&gt;) {
            print OUTFILE;      # child's STDIN is parent's KID_TO_WRITE
        }
        close(OUTFILE)          || die &quot;can't close $PRECIOUS: $!&quot;;
        exit(0);                # don't forget this!!
    }
</pre>
<p class="Pp">Another common use for this construct is when you need to execute
    something without the shell's interference. With <b>system()</b>, it's
    straightforward, but you can't use a pipe open or backticks safely. That's
    because there's no way to stop the shell from getting its hands on your
    arguments. Instead, use lower-level control to call <b>exec()</b>
  directly.</p>
<p class="Pp">Here's a safe backtick or pipe open for read:</p>
<p class="Pp"></p>
<pre>    my $pid = open(KID_TO_READ, &quot;-|&quot;);
    defined($pid)           || die &quot;can't fork: $!&quot;;
    if ($pid) {             # parent
        while (&lt;KID_TO_READ&gt;) {
                            # do something interesting
        }
        close(KID_TO_READ)  || warn &quot;kid exited $?&quot;;
    } else {                # child
        ($EUID, $EGID) = ($UID, $GID); # suid only
        exec($program, @options, @args)
                            || die &quot;can't exec program: $!&quot;;
        # NOTREACHED
    }
</pre>
<p class="Pp">And here's a safe pipe open for writing:</p>
<p class="Pp"></p>
<pre>    my $pid = open(KID_TO_WRITE, &quot;|-&quot;);
    defined($pid)           || die &quot;can't fork: $!&quot;;
    $SIG{PIPE} = sub { die &quot;whoops, $program pipe broke&quot; };
    if ($pid) {             # parent
        print KID_TO_WRITE @data;
        close(KID_TO_WRITE) || warn &quot;kid exited $?&quot;;
    } else {                # child
        ($EUID, $EGID) = ($UID, $GID);
        exec($program, @options, @args)
                            || die &quot;can't exec program: $!&quot;;
        # NOTREACHED
    }
</pre>
<p class="Pp">It is very easy to dead-lock a process using this form of
    <b>open()</b>, or indeed with any use of <b>pipe()</b> with multiple
    subprocesses. The example above is &quot;safe&quot; because it is simple and
    calls <b>exec()</b>. See &quot;Avoiding Pipe Deadlocks&quot; for general
    safety principles, but there are extra gotchas with Safe Pipe Opens.</p>
<p class="Pp">In particular, if you opened the pipe using
    <span class="Li">&quot;open FH, &quot;|-&quot;&quot;</span>, then you cannot
    simply use <b>close()</b> in the parent process to close an unwanted writer.
    Consider this code:</p>
<p class="Pp"></p>
<pre>    my $pid = open(WRITER, &quot;|-&quot;);        # fork open a kid
    defined($pid)               || die &quot;first fork failed: $!&quot;;
    if ($pid) {
        if (my $sub_pid = fork()) {
            defined($sub_pid)   || die &quot;second fork failed: $!&quot;;
            close(WRITER)       || die &quot;couldn't close WRITER: $!&quot;;
            # now do something else...
        }
        else {
            # first write to WRITER
            # ...
            # then when finished
            close(WRITER)       || die &quot;couldn't close WRITER: $!&quot;;
            exit(0);
        }
    }
    else {
        # first do something with STDIN, then
        exit(0);
    }
</pre>
<p class="Pp">In the example above, the true parent does not want to write to
    the WRITER filehandle, so it closes it. However, because WRITER was opened
    using <span class="Li">&quot;open FH, &quot;|-&quot;&quot;</span>, it has a
    special behavior: closing it calls <b>waitpid()</b> (see &quot;waitpid&quot;
    in perlfunc), which waits for the subprocess to exit. If the child process
    ends up waiting for something happening in the section marked &quot;do
    something else&quot;, you have deadlock.</p>
<p class="Pp">This can also be a problem with intermediate subprocesses in more
    complicated code, which will call <b>waitpid()</b> on all open filehandles
    during global destruction--in no predictable order.</p>
<p class="Pp">To solve this, you must manually use <b>pipe()</b>, <b>fork()</b>,
    and the form of <b>open()</b> which sets one file descriptor to another, as
    shown below:</p>
<p class="Pp"></p>
<pre>    pipe(READER, WRITER)        || die &quot;pipe failed: $!&quot;;
    $pid = fork();
    defined($pid)               || die &quot;first fork failed: $!&quot;;
    if ($pid) {
        close READER;
        if (my $sub_pid = fork()) {
            defined($sub_pid)   || die &quot;first fork failed: $!&quot;;
            close(WRITER)       || die &quot;can't close WRITER: $!&quot;;
        }
        else {
            # write to WRITER...
            # ...
            # then  when finished
            close(WRITER)       || die &quot;can't close WRITER: $!&quot;;
            exit(0);
        }
        # write to WRITER...
    }
    else {
        open(STDIN, &quot;&lt;&amp;READER&quot;) || die &quot;can't reopen STDIN: $!&quot;;
        close(WRITER)           || die &quot;can't close WRITER: $!&quot;;
        # do something...
        exit(0);
    }
</pre>
<p class="Pp">Since Perl 5.8.0, you can also use the list form of
    <span class="Li">&quot;open&quot;</span> for pipes. This is preferred when
    you wish to avoid having the shell interpret metacharacters that may be in
    your command string.</p>
<p class="Pp">So for example, instead of using:</p>
<p class="Pp"></p>
<pre>    open(PS_PIPE, &quot;ps aux|&quot;)    || die &quot;can't open ps pipe: $!&quot;;
</pre>
<p class="Pp">One would use either of these:</p>
<p class="Pp"></p>
<pre>    open(PS_PIPE, &quot;-|&quot;, &quot;ps&quot;, &quot;aux&quot;)
                                || die &quot;can't open ps pipe: $!&quot;;
    @ps_args = qw[ ps aux ];
    open(PS_PIPE, &quot;-|&quot;, @ps_args)
                                || die &quot;can't open @ps_args|: $!&quot;;
</pre>
<p class="Pp">Because there are more than three arguments to <b>open()</b>,
    forks the <b>ps</b>(1) command <i>without</i> spawning a shell, and reads
    its standard output via the <span class="Li">&quot;PS_PIPE&quot;</span>
    filehandle. The corresponding syntax to <i>write</i> to command pipes is to
    use <span class="Li">&quot;|-&quot;</span> in place of
    <span class="Li">&quot;-|&quot;</span>.</p>
<p class="Pp">This was admittedly a rather silly example, because you're using
    string literals whose content is perfectly safe. There is therefore no cause
    to resort to the harder-to-read, multi-argument form of pipe <b>open()</b>.
    However, whenever you cannot be assured that the program arguments are free
    of shell metacharacters, the fancier form of <b>open()</b> should be used.
    For example:</p>
<p class="Pp"></p>
<pre>    @grep_args = (&quot;egrep&quot;, &quot;-i&quot;, $some_pattern, @many_files);
    open(GREP_PIPE, &quot;-|&quot;, @grep_args)
                        || die &quot;can't open @grep_args|: $!&quot;;
</pre>
<p class="Pp">Here the multi-argument form of pipe <b>open()</b> is preferred
    because the pattern and indeed even the filenames themselves might hold
    metacharacters.</p>
<p class="Pp">Be aware that these operations are full Unix forks, which means
    they may not be correctly implemented on all alien systems.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Avoiding_Pipe_Deadlocks"><a class="permalink" href="#Avoiding_Pipe_Deadlocks">Avoiding
  Pipe Deadlocks</a></h2>
<p class="Pp">Whenever you have more than one subprocess, you must be careful
    that each closes whichever half of any pipes created for interprocess
    communication it is not using. This is because any child process reading
    from the pipe and expecting an EOF will never receive it, and therefore
    never exit. A single process closing a pipe is not enough to close it; the
    last process with the pipe open must close it for it to read EOF.</p>
<p class="Pp">Certain built-in Unix features help prevent this most of the time.
    For instance, filehandles have a &quot;close on exec&quot; flag, which is
    set <i>en masse</i> under control of the <span class="Li">$^F</span>
    variable. This is so any filehandles you didn't explicitly route to the
    STDIN, STDOUT or STDERR of a child <i>program</i> will be automatically
    closed.</p>
<p class="Pp">Always explicitly and immediately call <b>close()</b> on the
    writable end of any pipe, unless that process is actually writing to it.
    Even if you don't explicitly call <b>close()</b>, Perl will still
    <b>close()</b> all filehandles during global destruction. As previously
    discussed, if those filehandles have been opened with Safe Pipe Open, this
    will result in calling <b>waitpid()</b>, which may again deadlock.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Bidirectional_Communication_with_Another_Process"><a class="permalink" href="#Bidirectional_Communication_with_Another_Process">Bidirectional
  Communication with Another Process</a></h2>
<p class="Pp">While this works reasonably well for unidirectional communication,
    what about bidirectional communication? The most obvious approach doesn't
    work:</p>
<p class="Pp"></p>
<pre>    # THIS DOES NOT WORK!!
    open(PROG_FOR_READING_AND_WRITING, &quot;| some program |&quot;)
</pre>
<p class="Pp">If you forget to <span class="Li">&quot;use warnings&quot;</span>,
    you'll miss out entirely on the helpful diagnostic message:</p>
<p class="Pp"></p>
<pre>    Can't do bidirectional pipe at -e line 1.
</pre>
<p class="Pp">If you really want to, you can use the standard <b>open2()</b>
    from the <span class="Li">&quot;IPC::Open2&quot;</span> module to catch both
    ends. There's also an <b>open3()</b> in
    <span class="Li">&quot;IPC::Open3&quot;</span> for tridirectional I/O so you
    can also catch your child's STDERR, but doing so would then require an
    awkward <b>select()</b> loop and wouldn't allow you to use normal Perl input
    operations.</p>
<p class="Pp">If you look at its source, you'll see that <b>open2()</b> uses
    low-level primitives like the <b>pipe()</b> and <b>exec()</b> syscalls to
    create all the connections. Although it might have been more efficient by
    using <b>socketpair()</b>, this would have been even less portable than it
    already is. The <b>open2()</b> and <b>open3()</b> functions are unlikely to
    work anywhere except on a Unix system, or at least one purporting POSIX
    compliance.</p>
<p class="Pp">Here's an example of using <b>open2()</b>:</p>
<p class="Pp"></p>
<pre>    use FileHandle;
    use IPC::Open2;
    $pid = open2(*Reader, *Writer, &quot;cat -un&quot;);
    print Writer &quot;stuff\n&quot;;
    $got = &lt;Reader&gt;;
</pre>
<p class="Pp">The problem with this is that buffering is really going to ruin
    your day. Even though your <span class="Li">&quot;Writer&quot;</span>
    filehandle is auto-flushed so the process on the other end gets your data in
    a timely manner, you can't usually do anything to force that process to give
    its data to you in a similarly quick fashion. In this special case, we could
    actually so, because we gave <i>cat</i> a <b>-u</b> flag to make it
    unbuffered. But very few commands are designed to operate over pipes, so
    this seldom works unless you yourself wrote the program on the other end of
    the double-ended pipe.</p>
<p class="Pp">A solution to this is to use a library which uses pseudottys to
    make your program behave more reasonably. This way you don't have to have
    control over the source code of the program you're using. The
    <span class="Li">&quot;Expect&quot;</span> module from CPAN also addresses
    this kind of thing. This module requires two other modules from CPAN,
    <span class="Li">&quot;IO::Pty&quot;</span> and
    <span class="Li">&quot;IO::Stty&quot;</span>. It sets up a pseudo terminal
    to interact with programs that insist on talking to the terminal device
    driver. If your system is supported, this may be your best bet.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Bidirectional_Communication_with_Yourself"><a class="permalink" href="#Bidirectional_Communication_with_Yourself">Bidirectional
  Communication with Yourself</a></h2>
<p class="Pp">If you want, you may make low-level <b>pipe()</b> and
    <b>fork()</b> syscalls to stitch this together by hand. This example only
    talks to itself, but you could reopen the appropriate handles to STDIN and
    STDOUT and call other processes. (The following example lacks proper error
    checking.)</p>
<p class="Pp"></p>
<pre> #!/usr/bin/perl -w
 # pipe1 - bidirectional communication using two pipe pairs
 #         designed for the socketpair-challenged
 use IO::Handle;             # thousands of lines just for autoflush :-(
 pipe(PARENT_RDR, CHILD_WTR);  # XXX: check failure?
 pipe(CHILD_RDR,  PARENT_WTR); # XXX: check failure?
 CHILD_WTR-&gt;autoflush(1);
 PARENT_WTR-&gt;autoflush(1);
 if ($pid = fork()) {
     close PARENT_RDR;
     close PARENT_WTR;
     print CHILD_WTR &quot;Parent Pid $$ is sending this\n&quot;;
     chomp($line = &lt;CHILD_RDR&gt;);
     print &quot;Parent Pid $$ just read this: '$line'\n&quot;;
     close CHILD_RDR; close CHILD_WTR;
     waitpid($pid, 0);
 } else {
     die &quot;cannot fork: $!&quot; unless defined $pid;
     close CHILD_RDR;
     close CHILD_WTR;
     chomp($line = &lt;PARENT_RDR&gt;);
     print &quot;Child Pid $$ just read this: '$line'\n&quot;;
     print PARENT_WTR &quot;Child Pid $$ is sending this\n&quot;;
     close PARENT_RDR;
     close PARENT_WTR;
     exit(0);
 }
</pre>
<p class="Pp">But you don't actually have to make two pipe calls. If you have
    the <b>socketpair()</b> system call, it will do this all for you.</p>
<p class="Pp"></p>
<pre> #!/usr/bin/perl -w
 # pipe2 - bidirectional communication using socketpair
 #   &quot;the best ones always go both ways&quot;
 use Socket;
 use IO::Handle;  # thousands of lines just for autoflush :-(
 # We say AF_UNIX because although *_LOCAL is the
 # POSIX 1003.1g form of the constant, many machines
 # still don't have it.
 socketpair(CHILD, PARENT, AF_UNIX, SOCK_STREAM, PF_UNSPEC)
                             ||  die &quot;socketpair: $!&quot;;
 CHILD-&gt;autoflush(1);
 PARENT-&gt;autoflush(1);
 if ($pid = fork()) {
     close PARENT;
     print CHILD &quot;Parent Pid $$ is sending this\n&quot;;
     chomp($line = &lt;CHILD&gt;);
     print &quot;Parent Pid $$ just read this: '$line'\n&quot;;
     close CHILD;
     waitpid($pid, 0);
 } else {
     die &quot;cannot fork: $!&quot; unless defined $pid;
     close CHILD;
     chomp($line = &lt;PARENT&gt;);
     print &quot;Child Pid $$ just read this: '$line'\n&quot;;
     print PARENT &quot;Child Pid $$ is sending this\n&quot;;
     close PARENT;
     exit(0);
 }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Sockets:_Client/Server_Communication"><a class="permalink" href="#Sockets:_Client/Server_Communication">Sockets:
  Client/Server Communication</a></h1>
<p class="Pp">While not entirely limited to Unix-derived operating systems
    (e.g., WinSock on PCs provides socket support, as do some VMS libraries),
    you might not have sockets on your system, in which case this section
    probably isn't going to do you much good. With sockets, you can do both
    virtual circuits like TCP streams and datagrams like UDP packets. You may be
    able to do even more depending on your system.</p>
<p class="Pp">The Perl functions for dealing with sockets have the same names as
    the corresponding system calls in C, but their arguments tend to differ for
    two reasons. First, Perl filehandles work differently than C file
    descriptors. Second, Perl already knows the length of its strings, so you
    don't need to pass that information.</p>
<p class="Pp">One of the major problems with ancient, antemillennial socket code
    in Perl was that it used hard-coded values for some of the constants, which
    severely hurt portability. If you ever see code that does anything like
    explicitly setting <span class="Li">&quot;$AF_INET = 2&quot;</span>, you
    know you're in for big trouble. An immeasurably superior approach is to use
    the <span class="Li">&quot;Socket&quot;</span> module, which more reliably
    grants access to the various constants and functions you'll need.</p>
<p class="Pp">If you're not writing a server/client for an existing protocol
    like NNTP or SMTP, you should give some thought to how your server will know
    when the client has finished talking, and vice-versa. Most protocols are
    based on one-line messages and responses (so one party knows the other has
    finished when a &quot;\n&quot; is received) or multi-line messages and
    responses that end with a period on an empty line (&quot;\n.\n&quot;
    terminates a message/response).</p>
<section class="Ss">
<h2 class="Ss" id="Internet_Line_Terminators"><a class="permalink" href="#Internet_Line_Terminators">Internet
  Line Terminators</a></h2>
<p class="Pp">The Internet line terminator is &quot;\015\012&quot;. Under ASCII
    variants of Unix, that could usually be written as &quot;\r\n&quot;, but
    under other systems, &quot;\r\n&quot; might at times be
    &quot;\015\015\012&quot;, &quot;\012\012\015&quot;, or something completely
    different. The standards specify writing &quot;\015\012&quot; to be
    conformant (be strict in what you provide), but they also recommend
    accepting a lone &quot;\012&quot; on input (be lenient in what you require).
    We haven't always been very good about that in the code in this manpage, but
    unless you're on a Mac from way back in its pre-Unix dark ages, you'll
    probably be ok.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Internet_"><a class="permalink" href="#Internet_">Internet
  TCP Clients and Servers</a></h2>
<p class="Pp">Use Internet-domain sockets when you want to do client-server
    communication that might extend to machines outside of your own system.</p>
<p class="Pp">Here's a sample TCP client using Internet-domain sockets:</p>
<p class="Pp"></p>
<pre>    #!/usr/bin/perl -w
    use strict;
    use Socket;
    my ($remote, $port, $iaddr, $paddr, $proto, $line);
    $remote  = shift || &quot;localhost&quot;;
    $port    = shift || 2345;  # random port
    if ($port =~ /\D/) { $port = getservbyname($port, &quot;tcp&quot;) }
    die &quot;No port&quot; unless $port;
    $iaddr   = inet_aton($remote)       || die &quot;no host: $remote&quot;;
    $paddr   = sockaddr_in($port, $iaddr);
    $proto   = getprotobyname(&quot;tcp&quot;);
    socket(SOCK, PF_INET, SOCK_STREAM, $proto)  || die &quot;socket: $!&quot;;
    connect(SOCK, $paddr)               || die &quot;connect: $!&quot;;
    while ($line = &lt;SOCK&gt;) {
        print $line;
    }
    close (SOCK)                        || die &quot;close: $!&quot;;
    exit(0);
</pre>
<p class="Pp">And here's a corresponding server to go along with it. We'll leave
    the address as <span class="Li">&quot;INADDR_ANY&quot;</span> so that the
    kernel can choose the appropriate interface on multihomed hosts. If you want
    sit on a particular interface (like the external side of a gateway or
    firewall machine), fill this in with your real address instead.</p>
<p class="Pp"></p>
<pre> #!/usr/bin/perl -Tw
 use strict;
 BEGIN { $ENV{PATH} = &quot;/usr/bin:/bin&quot; }
 use Socket;
 use Carp;
 my $EOL = &quot;\015\012&quot;;
 sub logmsg { print &quot;$0 $$: @_ at &quot;, scalar localtime(), &quot;\n&quot; }
 my $port  = shift || 2345;
 die &quot;invalid port&quot; unless $port =~ /^ \d+ $/x;
 my $proto = getprotobyname(&quot;tcp&quot;);
 socket(Server, PF_INET, SOCK_STREAM, $proto)   || die &quot;socket: $!&quot;;
 setsockopt(Server, SOL_SOCKET, SO_REUSEADDR, pack(&quot;l&quot;, 1))
                                                || die &quot;setsockopt: $!&quot;;
 bind(Server, sockaddr_in($port, INADDR_ANY))   || die &quot;bind: $!&quot;;
 listen(Server, SOMAXCONN)                      || die &quot;listen: $!&quot;;
 logmsg &quot;server started on port $port&quot;;
 my $paddr;
 for ( ; $paddr = accept(Client, Server); close Client) {
     my($port, $iaddr) = sockaddr_in($paddr);
     my $name = gethostbyaddr($iaddr, AF_INET);
     logmsg &quot;connection from $name [&quot;,
             inet_ntoa($iaddr), &quot;]
             at port $port&quot;;
     print Client &quot;Hello there, $name, it's now &quot;,
                     scalar localtime(), $EOL;
 }
</pre>
<p class="Pp">And here's a multitasking version. It's multitasked in that like
    most typical servers, it spawns (<b>fork()</b>s) a slave server to handle
    the client request so that the master server can quickly go back to service
    a new client.</p>
<p class="Pp"></p>
<pre> #!/usr/bin/perl -Tw
 use strict;
 BEGIN { $ENV{PATH} = &quot;/usr/bin:/bin&quot; }
 use Socket;
 use Carp;
 my $EOL = &quot;\015\012&quot;;
 sub spawn;  # forward declaration
 sub logmsg { print &quot;$0 $$: @_ at &quot;, scalar localtime(), &quot;\n&quot; }
 my $port  = shift || 2345;
 die &quot;invalid port&quot; unless $port =~ /^ \d+ $/x;
 my $proto = getprotobyname(&quot;tcp&quot;);
 socket(Server, PF_INET, SOCK_STREAM, $proto)   || die &quot;socket: $!&quot;;
 setsockopt(Server, SOL_SOCKET, SO_REUSEADDR, pack(&quot;l&quot;, 1))
                                                || die &quot;setsockopt: $!&quot;;
 bind(Server, sockaddr_in($port, INADDR_ANY))   || die &quot;bind: $!&quot;;
 listen(Server, SOMAXCONN)                      || die &quot;listen: $!&quot;;
 logmsg &quot;server started on port $port&quot;;
 my $waitedpid = 0;
 my $paddr;
 use POSIX &quot;:sys_wait_h&quot;;
 use Errno;
 sub REAPER {
     local $!;   # don't let waitpid() overwrite current error
     while ((my $pid = waitpid(-1, WNOHANG)) &gt; 0 &amp;&amp; WIFEXITED($?)) {
         logmsg &quot;reaped $waitedpid&quot; . ($? ? &quot; with exit $?&quot; : &quot;&quot;);
     }
     $SIG{CHLD} = \&amp;REAPER;  # loathe SysV
 }
 $SIG{CHLD} = \&amp;REAPER;
 while (1) {
     $paddr = accept(Client, Server) || do {
         # try again if accept() returned because got a signal
         next if $!{EINTR};
         die &quot;accept: $!&quot;;
     };
     my ($port, $iaddr) = sockaddr_in($paddr);
     my $name = gethostbyaddr($iaddr, AF_INET);
     logmsg &quot;connection from $name [&quot;,
            inet_ntoa($iaddr),
            &quot;] at port $port&quot;;
     spawn sub {
         $| = 1;
         print &quot;Hello there, $name, it's now &quot;,
               scalar localtime(),
               $EOL;
         exec &quot;/usr/games/fortune&quot;       # XXX: &quot;wrong&quot; line terminators
             or confess &quot;can't exec fortune: $!&quot;;
     };
     close Client;
 }
 sub spawn {
     my $coderef = shift;
     unless (@_ == 0 &amp;&amp; $coderef &amp;&amp; ref($coderef) eq &quot;CODE&quot;) {
         confess &quot;usage: spawn CODEREF&quot;;
     }
     my $pid;
     unless (defined($pid = fork())) {
         logmsg &quot;cannot fork: $!&quot;;
         return;
     }
     elsif ($pid) {
         logmsg &quot;begat $pid&quot;;
         return; # I'm the parent
     }
     # else I'm the child -- go spawn
     open(STDIN,  &quot;&lt;&amp;Client&quot;)    || die &quot;can't dup client to stdin&quot;;
     open(STDOUT, &quot;&gt;&amp;Client&quot;)    || die &quot;can't dup client to stdout&quot;;
     ## open(STDERR, &quot;&gt;&amp;STDOUT&quot;) || die &quot;can't dup stdout to stderr&quot;;
     exit($coderef-&gt;());
 }
</pre>
<p class="Pp">This server takes the trouble to clone off a child version via
    <b>fork()</b> for each incoming request. That way it can handle many
    requests at once, which you might not always want. Even if you don't
    <b>fork()</b>, the <b>listen()</b> will allow that many pending connections.
    Forking servers have to be particularly careful about cleaning up their dead
    children (called &quot;zombies&quot; in Unix parlance), because otherwise
    you'll quickly fill up your process table. The REAPER subroutine is used
    here to call <b>waitpid()</b> for any child processes that have finished,
    thereby ensuring that they terminate cleanly and don't join the ranks of the
    living dead.</p>
<p class="Pp">Within the while loop we call <b>accept()</b> and check to see if
    it returns a false value. This would normally indicate a system error needs
    to be reported. However, the introduction of safe signals (see
    &quot;Deferred Signals (Safe Signals)&quot; above) in Perl 5.8.0 means that
    <b>accept()</b> might also be interrupted when the process receives a
    signal. This typically happens when one of the forked subprocesses exits and
    notifies the parent process with a CHLD signal.</p>
<p class="Pp">If <b>accept()</b> is interrupted by a signal, $! will be set to
    EINTR. If this happens, we can safely continue to the next iteration of the
    loop and another call to <b>accept()</b>. It is important that your signal
    handling code not modify the value of $!, or else this test will likely
    fail. In the REAPER subroutine we create a local version of $! before
    calling <b>waitpid()</b>. When <b>waitpid()</b> sets $! to ECHILD as it
    inevitably does when it has no more children waiting, it updates the local
    copy and leaves the original unchanged.</p>
<p class="Pp">You should use the <b>-T</b> flag to enable taint checking (see
    perlsec) even if we aren't running setuid or setgid. This is always a good
    idea for servers or any program run on behalf of someone else (like CGI
    scripts), because it lessens the chances that people from the outside will
    be able to compromise your system.</p>
<p class="Pp">Let's look at another TCP client. This one connects to the TCP
    &quot;time&quot; service on a number of different machines and shows how far
    their clocks differ from the system on which it's being run:</p>
<p class="Pp"></p>
<pre>    #!/usr/bin/perl  -w
    use strict;
    use Socket;
    my $SECS_OF_70_YEARS = 2208988800;
    sub ctime { scalar localtime(shift() || time()) }
    my $iaddr = gethostbyname(&quot;localhost&quot;);
    my $proto = getprotobyname(&quot;tcp&quot;);
    my $port = getservbyname(&quot;time&quot;, &quot;tcp&quot;);
    my $paddr = sockaddr_in(0, $iaddr);
    my($host);
    $| = 1;
    printf &quot;%-24s %8s %s\n&quot;, &quot;localhost&quot;, 0, ctime();
    foreach $host (@ARGV) {
        printf &quot;%-24s &quot;, $host;
        my $hisiaddr = inet_aton($host)     || die &quot;unknown host&quot;;
        my $hispaddr = sockaddr_in($port, $hisiaddr);
        socket(SOCKET, PF_INET, SOCK_STREAM, $proto)
                                            || die &quot;socket: $!&quot;;
        connect(SOCKET, $hispaddr)          || die &quot;connect: $!&quot;;
        my $rtime = pack(&quot;C4&quot;, ());
        read(SOCKET, $rtime, 4);
        close(SOCKET);
        my $histime = unpack(&quot;N&quot;, $rtime) - $SECS_OF_70_YEARS;
        printf &quot;%8d %s\n&quot;, $histime - time(), ctime($histime);
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Unix-Domain_"><a class="permalink" href="#Unix-Domain_">Unix-Domain
  TCP Clients and Servers</a></h2>
<p class="Pp">That's fine for Internet-domain clients and servers, but what
    about local communications? While you can use the same setup, sometimes you
    don't want to. Unix-domain sockets are local to the current host, and are
    often used internally to implement pipes. Unlike Internet domain sockets,
    Unix domain sockets can show up in the file system with an <b>ls</b>(1)
    listing.</p>
<p class="Pp"></p>
<pre>    % ls -l /dev/log
    srw-rw-rw-  1 root            0 Oct 31 07:23 /dev/log
</pre>
<p class="Pp">You can test for these with Perl's <b>-S</b> file test:</p>
<p class="Pp"></p>
<pre>    unless (-S &quot;/dev/log&quot;) {
        die &quot;something's wicked with the log system&quot;;
    }
</pre>
<p class="Pp">Here's a sample Unix-domain client:</p>
<p class="Pp"></p>
<pre>    #!/usr/bin/perl -w
    use Socket;
    use strict;
    my ($rendezvous, $line);
    $rendezvous = shift || &quot;catsock&quot;;
    socket(SOCK, PF_UNIX, SOCK_STREAM, 0)     || die &quot;socket: $!&quot;;
    connect(SOCK, sockaddr_un($rendezvous))   || die &quot;connect: $!&quot;;
    while (defined($line = &lt;SOCK&gt;)) {
        print $line;
    }
    exit(0);
</pre>
<p class="Pp">And here's a corresponding server. You don't have to worry about
    silly network terminators here because Unix domain sockets are guaranteed to
    be on the localhost, and thus everything works right.</p>
<p class="Pp"></p>
<pre>    #!/usr/bin/perl -Tw
    use strict;
    use Socket;
    use Carp;
    BEGIN { $ENV{PATH} = &quot;/usr/bin:/bin&quot; }
    sub spawn;  # forward declaration
    sub logmsg { print &quot;$0 $$: @_ at &quot;, scalar localtime(), &quot;\n&quot; }
    my $NAME = &quot;catsock&quot;;
    my $uaddr = sockaddr_un($NAME);
    my $proto = getprotobyname(&quot;tcp&quot;);
    socket(Server, PF_UNIX, SOCK_STREAM, 0) || die &quot;socket: $!&quot;;
    unlink($NAME);
    bind  (Server, $uaddr)                  || die &quot;bind: $!&quot;;
    listen(Server, SOMAXCONN)               || die &quot;listen: $!&quot;;
    logmsg &quot;server started on $NAME&quot;;
    my $waitedpid;
    use POSIX &quot;:sys_wait_h&quot;;
    sub REAPER {
        my $child;
        while (($waitedpid = waitpid(-1, WNOHANG)) &gt; 0) {
            logmsg &quot;reaped $waitedpid&quot; . ($? ? &quot; with exit $?&quot; : &quot;&quot;);
        }
        $SIG{CHLD} = \&amp;REAPER;  # loathe SysV
    }
    $SIG{CHLD} = \&amp;REAPER;
    for ( $waitedpid = 0;
          accept(Client, Server) || $waitedpid;
          $waitedpid = 0, close Client)
    {
        next if $waitedpid;
        logmsg &quot;connection on $NAME&quot;;
        spawn sub {
            print &quot;Hello there, it's now &quot;, scalar localtime(), &quot;\n&quot;;
            exec(&quot;/usr/games/fortune&quot;)  || die &quot;can't exec fortune: $!&quot;;
        };
    }
    sub spawn {
        my $coderef = shift();
        unless (@_ == 0 &amp;&amp; $coderef &amp;&amp; ref($coderef) eq &quot;CODE&quot;) {
            confess &quot;usage: spawn CODEREF&quot;;
        }
        my $pid;
        unless (defined($pid = fork())) {
            logmsg &quot;cannot fork: $!&quot;;
            return;
        }
        elsif ($pid) {
            logmsg &quot;begat $pid&quot;;
            return; # I'm the parent
        }
        else {
            # I'm the child -- go spawn
        }
        open(STDIN,  &quot;&lt;&amp;Client&quot;)    || die &quot;can't dup client to stdin&quot;;
        open(STDOUT, &quot;&gt;&amp;Client&quot;)    || die &quot;can't dup client to stdout&quot;;
        ## open(STDERR, &quot;&gt;&amp;STDOUT&quot;) || die &quot;can't dup stdout to stderr&quot;;
        exit($coderef-&gt;());
    }
</pre>
<p class="Pp">As you see, it's remarkably similar to the Internet domain TCP
    server, so much so, in fact, that we've omitted several duplicate
    functions--<b>spawn()</b>, <b>logmsg()</b>, <b>ctime()</b>, and
    <b>REAPER()</b>--which are the same as in the other server.</p>
<p class="Pp">So why would you ever want to use a Unix domain socket instead of
    a simpler named pipe? Because a named pipe doesn't give you sessions. You
    can't tell one process's data from another's. With socket programming, you
    get a separate session for each client; that's why <b>accept()</b> takes two
    arguments.</p>
<p class="Pp">For example, let's say that you have a long-running database
    server daemon that you want folks to be able to access from the Web, but
    only if they go through a CGI interface. You'd have a small, simple CGI
    program that does whatever checks and logging you feel like, and then acts
    as a Unix-domain client and connects to your private server.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TCP_Clients_with_IO::Socket"><a class="permalink" href="#TCP_Clients_with_IO::Socket">TCP
  Clients with IO::Socket</a></h1>
<p class="Pp">For those preferring a higher-level interface to socket
    programming, the IO::Socket module provides an object-oriented approach. If
    for some reason you lack this module, you can just fetch IO::Socket from
    CPAN, where you'll also find modules providing easy interfaces to the
    following systems: DNS, FTP, Ident (RFC 931), NIS and NISPlus, NNTP, Ping,
    POP3, SMTP, SNMP, SSLeay, Telnet, and Time--to name just a few.</p>
<section class="Ss">
<h2 class="Ss" id="A_Simple_Client"><a class="permalink" href="#A_Simple_Client">A
  Simple Client</a></h2>
<p class="Pp">Here's a client that creates a TCP connection to the
    &quot;daytime&quot; service at port 13 of the host name
    &quot;localhost&quot; and prints out everything that the server there cares
    to provide.</p>
<p class="Pp"></p>
<pre>    #!/usr/bin/perl -w
    use IO::Socket;
    $remote = IO::Socket::INET-&gt;new(
                        Proto    =&gt; &quot;tcp&quot;,
                        PeerAddr =&gt; &quot;localhost&quot;,
                        PeerPort =&gt; &quot;daytime(13)&quot;,
                    )
                 || die &quot;can't connect to daytime service on localhost&quot;;
    while (&lt;$remote&gt;) { print }
</pre>
<p class="Pp">When you run this program, you should get something back that
    looks like this:</p>
<p class="Pp"></p>
<pre>    Wed May 14 08:40:46 MDT 1997
</pre>
<p class="Pp">Here are what those parameters to the <b>new()</b> constructor
    mean:</p>
<dl class="Bl-tag">
  <dt>&quot;Proto&quot;</dt>
  <dd>This is which protocol to use. In this case, the socket handle returned
      will be connected to a TCP socket, because we want a stream-oriented
      connection, that is, one that acts pretty much like a plain old file. Not
      all sockets are this of this type. For example, the UDP protocol can be
      used to make a datagram socket, used for message-passing.</dd>
  <dt>&quot;PeerAddr&quot;</dt>
  <dd>This is the name or Internet address of the remote host the server is
      running on. We could have specified a longer name like
      <span class="Li">&quot;www.perl.com&quot;</span>, or an address like
      <span class="Li">&quot;207.171.7.72&quot;</span>. For demonstration
      purposes, we've used the special hostname
      <span class="Li">&quot;localhost&quot;</span>, which should always mean
      the current machine you're running on. The corresponding Internet address
      for localhost is <span class="Li">&quot;127.0.0.1&quot;</span>, if you'd
      rather use that.</dd>
  <dt>&quot;PeerPort&quot;</dt>
  <dd>This is the service name or port number we'd like to connect to. We could
      have gotten away with using just
      <span class="Li">&quot;daytime&quot;</span> on systems with a
      well-configured system services file,[FOOTNOTE: The system services file
      is found in <i>/etc/services</i> under Unixy systems.] but here we've
      specified the port number (13) in parentheses. Using just the number would
      have also worked, but numeric literals make careful programmers
    nervous.</dd>
</dl>
<p class="Pp">Notice how the return value from the
    <span class="Li">&quot;new&quot;</span> constructor is used as a filehandle
    in the <span class="Li">&quot;while&quot;</span> loop? That's what's called
    an <i>indirect</i> <i>filehandle</i>, a scalar variable containing a
    filehandle. You can use it the same way you would a normal filehandle. For
    example, you can read one line from it this way:</p>
<p class="Pp"></p>
<pre>    $line = &lt;$handle&gt;;
</pre>
<p class="Pp">all remaining lines from is this way:</p>
<p class="Pp"></p>
<pre>    @lines = &lt;$handle&gt;;
</pre>
<p class="Pp">and send a line of data to it this way:</p>
<p class="Pp"></p>
<pre>    print $handle &quot;some data\n&quot;;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="A_Webget_Client"><a class="permalink" href="#A_Webget_Client">A
  Webget Client</a></h2>
<p class="Pp">Here's a simple client that takes a remote host to fetch a
    document from, and then a list of files to get from that host. This is a
    more interesting client than the previous one because it first sends
    something to the server before fetching the server's response.</p>
<p class="Pp"></p>
<pre>    #!/usr/bin/perl -w
    use IO::Socket;
    unless (@ARGV &gt; 1) { die &quot;usage: $0 host url ...&quot; }
    $host = shift(@ARGV);
    $EOL = &quot;\015\012&quot;;
    $BLANK = $EOL x 2;
    for my $document (@ARGV) {
        $remote = IO::Socket::INET-&gt;new( Proto     =&gt; &quot;tcp&quot;,
                                         PeerAddr  =&gt; $host,
                                         PeerPort  =&gt; &quot;http(80)&quot;,
                  )     || die &quot;cannot connect to httpd on $host&quot;;
        $remote-&gt;autoflush(1);
        print $remote &quot;GET $document HTTP/1.0&quot; . $BLANK;
        while ( &lt;$remote&gt; ) { print }
        close $remote;
    }
</pre>
<p class="Pp">The web server handling the HTTP service is assumed to be at its
    standard port, number 80. If the server you're trying to connect to is at a
    different port, like 1080 or 8080, you should specify it as the
    named-parameter pair, <span class="Li">&quot;PeerPort =&gt;
    8080&quot;</span>. The <span class="Li">&quot;autoflush&quot;</span> method
    is used on the socket because otherwise the system would buffer up the
    output we sent it. (If you're on a prehistoric Mac, you'll also need to
    change every <span class="Li">&quot;\n&quot;</span> in your code that sends
    data over the network to be a <span class="Li">&quot;\015\012&quot;</span>
    instead.)</p>
<p class="Pp">Connecting to the server is only the first part of the process:
    once you have the connection, you have to use the server's language. Each
    server on the network has its own little command language that it expects as
    input. The string that we send to the server starting with &quot;GET&quot;
    is in HTTP syntax. In this case, we simply request each specified document.
    Yes, we really are making a new connection for each document, even though
    it's the same host. That's the way you always used to have to speak HTTP.
    Recent versions of web browsers may request that the remote server leave the
    connection open a little while, but the server doesn't have to honor such a
    request.</p>
<p class="Pp">Here's an example of running that program, which we'll call
    <i>webget</i>:</p>
<p class="Pp"></p>
<pre>    % webget www.perl.com /guanaco.html
    HTTP/1.1 404 File Not Found
    Date: Thu, 08 May 1997 18:02:32 GMT
    Server: Apache/1.2b6
    Connection: close
    Content-type: text/html
    &lt;HEAD&gt;&lt;TITLE&gt;404 File Not Found&lt;/TITLE&gt;&lt;/HEAD&gt;
    &lt;BODY&gt;&lt;H1&gt;File Not Found&lt;/H1&gt;
    The requested URL /guanaco.html was not found on this server.&lt;P&gt;
    &lt;/BODY&gt;
</pre>
<p class="Pp">Ok, so that's not very interesting, because it didn't find that
    particular document. But a long response wouldn't have fit on this page.</p>
<p class="Pp">For a more featureful version of this program, you should look to
    the <i>lwp-request</i> program included with the LWP modules from CPAN.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Interactive_Client_with_IO::Socket"><a class="permalink" href="#Interactive_Client_with_IO::Socket">Interactive
  Client with IO::Socket</a></h2>
<p class="Pp">Well, that's all fine if you want to send one command and get one
    answer, but what about setting up something fully interactive, somewhat like
    the way <i>telnet</i> works? That way you can type a line, get the answer,
    type a line, get the answer, etc.</p>
<p class="Pp">This client is more complicated than the two we've done so far,
    but if you're on a system that supports the powerful
    <span class="Li">&quot;fork&quot;</span> call, the solution isn't that
    rough. Once you've made the connection to whatever service you'd like to
    chat with, call <span class="Li">&quot;fork&quot;</span> to clone your
    process. Each of these two identical process has a very simple job to do:
    the parent copies everything from the socket to standard output, while the
    child simultaneously copies everything from standard input to the socket. To
    accomplish the same thing using just one process would be <i>much</i>
    harder, because it's easier to code two processes to do one thing than it is
    to code one process to do two things. (This keep-it-simple principle a
    cornerstones of the Unix philosophy, and good software engineering as well,
    which is probably why it's spread to other systems.)</p>
<p class="Pp">Here's the code:</p>
<p class="Pp"></p>
<pre>    #!/usr/bin/perl -w
    use strict;
    use IO::Socket;
    my ($host, $port, $kidpid, $handle, $line);
    unless (@ARGV == 2) { die &quot;usage: $0 host port&quot; }
    ($host, $port) = @ARGV;
    # create a tcp connection to the specified host and port
    $handle = IO::Socket::INET-&gt;new(Proto     =&gt; &quot;tcp&quot;,
                                    PeerAddr  =&gt; $host,
                                    PeerPort  =&gt; $port)
               || die &quot;can't connect to port $port on $host: $!&quot;;
    $handle-&gt;autoflush(1);       # so output gets there right away
    print STDERR &quot;[Connected to $host:$port]\n&quot;;
    # split the program into two processes, identical twins
    die &quot;can't fork: $!&quot; unless defined($kidpid = fork());
    # the if{} block runs only in the parent process
    if ($kidpid) {
        # copy the socket to standard output
        while (defined ($line = &lt;$handle&gt;)) {
            print STDOUT $line;
        }
        kill(&quot;TERM&quot;, $kidpid);   # send SIGTERM to child
    }
    # the else{} block runs only in the child process
    else {
        # copy standard input to the socket
        while (defined ($line = &lt;STDIN&gt;)) {
            print $handle $line;
        }
        exit(0);                # just in case
    }
</pre>
<p class="Pp">The <span class="Li">&quot;kill&quot;</span> function in the
    parent's <span class="Li">&quot;if&quot;</span> block is there to send a
    signal to our child process, currently running in the
    <span class="Li">&quot;else&quot;</span> block, as soon as the remote server
    has closed its end of the connection.</p>
<p class="Pp">If the remote server sends data a byte at time, and you need that
    data immediately without waiting for a newline (which might not happen), you
    may wish to replace the <span class="Li">&quot;while&quot;</span> loop in
    the parent with the following:</p>
<p class="Pp"></p>
<pre>    my $byte;
    while (sysread($handle, $byte, 1) == 1) {
        print STDOUT $byte;
    }
</pre>
<p class="Pp">Making a system call for each byte you want to read is not very
    efficient (to put it mildly) but is the simplest to explain and works
    reasonably well.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TCP_Servers_with_IO::Socket"><a class="permalink" href="#TCP_Servers_with_IO::Socket">TCP
  Servers with IO::Socket</a></h1>
<p class="Pp">As always, setting up a server is little bit more involved than
    running a client. The model is that the server creates a special kind of
    socket that does nothing but listen on a particular port for incoming
    connections. It does this by calling the
    <span class="Li">&quot;IO::Socket::INET-&gt;new()&quot;</span> method with
    slightly different arguments than the client did.</p>
<dl class="Bl-tag">
  <dt id="Proto"><a class="permalink" href="#Proto">Proto</a></dt>
  <dd>This is which protocol to use. Like our clients, we'll still specify
      <span class="Li">&quot;tcp&quot;</span> here.</dd>
  <dt id="LocalPort"><a class="permalink" href="#LocalPort">LocalPort</a></dt>
  <dd>We specify a local port in the
      <span class="Li">&quot;LocalPort&quot;</span> argument, which we didn't do
      for the client. This is service name or port number for which you want to
      be the server. (Under Unix, ports under 1024 are restricted to the
      superuser.) In our sample, we'll use port 9000, but you can use any port
      that's not currently in use on your system. If you try to use one already
      in used, you'll get an &quot;Address already in use&quot; message. Under
      Unix, the <span class="Li">&quot;netstat -a&quot;</span> command will show
      which services current have servers.</dd>
  <dt id="Listen"><a class="permalink" href="#Listen">Listen</a></dt>
  <dd>The <span class="Li">&quot;Listen&quot;</span> parameter is set to the
      maximum number of pending connections we can accept until we turn away
      incoming clients. Think of it as a call-waiting queue for your telephone.
      The low-level Socket module has a special symbol for the system maximum,
      which is SOMAXCONN.</dd>
  <dt id="Reuse"><a class="permalink" href="#Reuse">Reuse</a></dt>
  <dd>The <span class="Li">&quot;Reuse&quot;</span> parameter is needed so that
      we restart our server manually without waiting a few minutes to allow
      system buffers to clear out.</dd>
</dl>
<p class="Pp">Once the generic server socket has been created using the
    parameters listed above, the server then waits for a new client to connect
    to it. The server blocks in the <span class="Li">&quot;accept&quot;</span>
    method, which eventually accepts a bidirectional connection from the remote
    client. (Make sure to autoflush this handle to circumvent buffering.)</p>
<p class="Pp">To add to user-friendliness, our server prompts the user for
    commands. Most servers don't do this. Because of the prompt without a
    newline, you'll have to use the <span class="Li">&quot;sysread&quot;</span>
    variant of the interactive client above.</p>
<p class="Pp">This server accepts one of five different commands, sending output
    back to the client. Unlike most network servers, this one handles only one
    incoming client at a time. Multitasking servers are covered in Chapter 16 of
    the Camel.</p>
<p class="Pp">Here's the code. We'll</p>
<p class="Pp"></p>
<pre> #!/usr/bin/perl -w
 use IO::Socket;
 use Net::hostent;      # for OOish version of gethostbyaddr
 $PORT = 9000;          # pick something not in use
 $server = IO::Socket::INET-&gt;new( Proto     =&gt; &quot;tcp&quot;,
                                  LocalPort =&gt; $PORT,
                                  Listen    =&gt; SOMAXCONN,
                                  Reuse     =&gt; 1);
 die &quot;can't setup server&quot; unless $server;
 print &quot;[Server $0 accepting clients]\n&quot;;
 while ($client = $server-&gt;accept()) {
   $client-&gt;autoflush(1);
   print $client &quot;Welcome to $0; type help for command list.\n&quot;;
   $hostinfo = gethostbyaddr($client-&gt;peeraddr);
   printf &quot;[Connect from %s]\n&quot;,
          $hostinfo ? $hostinfo-&gt;name : $client-&gt;peerhost;
   print $client &quot;Command? &quot;;
   while ( &lt;$client&gt;) {
     next unless /\S/;     # blank line
     if    (/quit|exit/i)  { last                                      }
     elsif (/date|time/i)  { printf $client &quot;%s\n&quot;, scalar localtime() }
     elsif (/who/i )       { print  $client `who 2&gt;&amp;1`                 }
     elsif (/cookie/i )    { print  $client `/usr/games/fortune 2&gt;&amp;1`  }
     elsif (/motd/i )      { print  $client `cat /etc/motd 2&gt;&amp;1`       }
     else {
       print $client &quot;Commands: quit date who cookie motd\n&quot;;
     }
   } continue {
      print $client &quot;Command? &quot;;
   }
   close $client;
 }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="UDP:_Message_Passing"><a class="permalink" href="#UDP:_Message_Passing">UDP:
  Message Passing</a></h1>
<p class="Pp">Another kind of client-server setup is one that uses not
    connections, but messages. UDP communications involve much lower overhead
    but also provide less reliability, as there are no promises that messages
    will arrive at all, let alone in order and unmangled. Still, UDP offers some
    advantages over TCP, including being able to &quot;broadcast&quot; or
    &quot;multicast&quot; to a whole bunch of destination hosts at once (usually
    on your local subnet). If you find yourself overly concerned about
    reliability and start building checks into your message system, then you
    probably should use just TCP to start with.</p>
<p class="Pp">UDP datagrams are <i>not</i> a bytestream and should not be
    treated as such. This makes using I/O mechanisms with internal buffering
    like stdio (i.e. <b>print()</b> and friends) especially cumbersome. Use
    <b>syswrite()</b>, or better <b>send()</b>, like in the example below.</p>
<p class="Pp">Here's a UDP program similar to the sample Internet TCP client
    given earlier. However, instead of checking one host at a time, the UDP
    version will check many of them asynchronously by simulating a multicast and
    then using <b>select()</b> to do a timed-out wait for I/O. To do something
    similar with TCP, you'd have to use a different socket handle for each
  host.</p>
<p class="Pp"></p>
<pre> #!/usr/bin/perl -w
 use strict;
 use Socket;
 use Sys::Hostname;
 my ( $count, $hisiaddr, $hispaddr, $histime,
      $host, $iaddr, $paddr, $port, $proto,
      $rin, $rout, $rtime, $SECS_OF_70_YEARS);
 $SECS_OF_70_YEARS = 2_208_988_800;
 $iaddr = gethostbyname(hostname());
 $proto = getprotobyname(&quot;udp&quot;);
 $port = getservbyname(&quot;time&quot;, &quot;udp&quot;);
 $paddr = sockaddr_in(0, $iaddr); # 0 means let kernel pick
 socket(SOCKET, PF_INET, SOCK_DGRAM, $proto)   || die &quot;socket: $!&quot;;
 bind(SOCKET, $paddr)                          || die &quot;bind: $!&quot;;
 $| = 1;
 printf &quot;%-12s %8s %s\n&quot;,  &quot;localhost&quot;, 0, scalar localtime();
 $count = 0;
 for $host (@ARGV) {
     $count++;
     $hisiaddr = inet_aton($host)              || die &quot;unknown host&quot;;
     $hispaddr = sockaddr_in($port, $hisiaddr);
     defined(send(SOCKET, 0, 0, $hispaddr))    || die &quot;send $host: $!&quot;;
 }
 $rin = &quot;&quot;;
 vec($rin, fileno(SOCKET), 1) = 1;
 # timeout after 10.0 seconds
 while ($count &amp;&amp; select($rout = $rin, undef, undef, 10.0)) {
     $rtime = &quot;&quot;;
     $hispaddr = recv(SOCKET, $rtime, 4, 0)    || die &quot;recv: $!&quot;;
     ($port, $hisiaddr) = sockaddr_in($hispaddr);
     $host = gethostbyaddr($hisiaddr, AF_INET);
     $histime = unpack(&quot;N&quot;, $rtime) - $SECS_OF_70_YEARS;
     printf &quot;%-12s &quot;, $host;
     printf &quot;%8d %s\n&quot;, $histime - time(), scalar localtime($histime);
     $count--;
 }
</pre>
<p class="Pp">This example does not include any retries and may consequently
    fail to contact a reachable host. The most prominent reason for this is
    congestion of the queues on the sending host if the number of hosts to
    contact is sufficiently large.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SysV_IPC"><a class="permalink" href="#SysV_IPC">SysV
  IPC</a></h1>
<p class="Pp">While System V IPC isn't so widely used as sockets, it still has
    some interesting uses. However, you cannot use SysV IPC or Berkeley
    <b>mmap()</b> to have a variable shared amongst several processes. That's
    because Perl would reallocate your string when you weren't wanting it to.
    You might look into the <span class="Li">&quot;IPC::Shareable&quot;</span>
    or <span class="Li">&quot;threads::shared&quot;</span> modules for that.</p>
<p class="Pp">Here's a small example showing shared memory usage.</p>
<p class="Pp"></p>
<pre>    use IPC::SysV qw(IPC_PRIVATE IPC_RMID S_IRUSR S_IWUSR);
    $size = 2000;
    $id = shmget(IPC_PRIVATE, $size, S_IRUSR | S_IWUSR);
    defined($id)                    || die &quot;shmget: $!&quot;;
    print &quot;shm key $id\n&quot;;
    $message = &quot;Message #1&quot;;
    shmwrite($id, $message, 0, 60)  || die &quot;shmwrite: $!&quot;;
    print &quot;wrote: '$message'\n&quot;;
    shmread($id, $buff, 0, 60)      || die &quot;shmread: $!&quot;;
    print &quot;read : '$buff'\n&quot;;
    # the buffer of shmread is zero-character end-padded.
    substr($buff, index($buff, &quot;\0&quot;)) = &quot;&quot;;
    print &quot;un&quot; unless $buff eq $message;
    print &quot;swell\n&quot;;
    print &quot;deleting shm $id\n&quot;;
    shmctl($id, IPC_RMID, 0)        || die &quot;shmctl: $!&quot;;
</pre>
<p class="Pp">Here's an example of a semaphore:</p>
<p class="Pp"></p>
<pre>    use IPC::SysV qw(IPC_CREAT);
    $IPC_KEY = 1234;
    $id = semget($IPC_KEY, 10, 0666 | IPC_CREAT);
    defined($id)                    || die &quot;semget: $!&quot;;
    print &quot;sem id $id\n&quot;;
</pre>
<p class="Pp">Put this code in a separate file to be run in more than one
    process. Call the file <i>take</i>:</p>
<p class="Pp"></p>
<pre>    # create a semaphore
    $IPC_KEY = 1234;
    $id = semget($IPC_KEY, 0, 0);
    defined($id)                    || die &quot;semget: $!&quot;;
    $semnum  = 0;
    $semflag = 0;
    # &quot;take&quot; semaphore
    # wait for semaphore to be zero
    $semop = 0;
    $opstring1 = pack(&quot;s!s!s!&quot;, $semnum, $semop, $semflag);
    # Increment the semaphore count
    $semop = 1;
    $opstring2 = pack(&quot;s!s!s!&quot;, $semnum, $semop,  $semflag);
    $opstring  = $opstring1 . $opstring2;
    semop($id, $opstring)   || die &quot;semop: $!&quot;;
</pre>
<p class="Pp">Put this code in a separate file to be run in more than one
    process. Call this file <i>give</i>:</p>
<p class="Pp"></p>
<pre>    # &quot;give&quot; the semaphore
    # run this in the original process and you will see
    # that the second process continues
    $IPC_KEY = 1234;
    $id = semget($IPC_KEY, 0, 0);
    die unless defined($id);
    $semnum  = 0;
    $semflag = 0;
    # Decrement the semaphore count
    $semop = -1;
    $opstring = pack(&quot;s!s!s!&quot;, $semnum, $semop, $semflag);
    semop($id, $opstring)   || die &quot;semop: $!&quot;;
</pre>
<p class="Pp">The SysV IPC code above was written long ago, and it's definitely
    clunky looking. For a more modern look, see the IPC::SysV module.</p>
<p class="Pp">A small example demonstrating SysV message queues:</p>
<p class="Pp"></p>
<pre>    use IPC::SysV qw(IPC_PRIVATE IPC_RMID IPC_CREAT S_IRUSR S_IWUSR);
    my $id = msgget(IPC_PRIVATE, IPC_CREAT | S_IRUSR | S_IWUSR);
    defined($id)                || die &quot;msgget failed: $!&quot;;
    my $sent      = &quot;message&quot;;
    my $type_sent = 1234;
    msgsnd($id, pack(&quot;l! a*&quot;, $type_sent, $sent), 0)
                                || die &quot;msgsnd failed: $!&quot;;
    msgrcv($id, my $rcvd_buf, 60, 0, 0)
                                || die &quot;msgrcv failed: $!&quot;;
    my($type_rcvd, $rcvd) = unpack(&quot;l! a*&quot;, $rcvd_buf);
    if ($rcvd eq $sent) {
        print &quot;okay\n&quot;;
    } else {
        print &quot;not okay\n&quot;;
    }
    msgctl($id, IPC_RMID, 0)    || die &quot;msgctl failed: $!\n&quot;;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<p class="Pp">Most of these routines quietly but politely return
    <span class="Li">&quot;undef&quot;</span> when they fail instead of causing
    your program to die right then and there due to an uncaught exception.
    (Actually, some of the new <i>Socket</i> conversion functions do
    <b>croak()</b> on bad arguments.) It is therefore essential to check return
    values from these functions. Always begin your socket programs this way for
    optimal success, and don't forget to add the <b>-T</b> taint-checking flag
    to the <span class="Li">&quot;#!&quot;</span> line for servers:</p>
<p class="Pp"></p>
<pre>    #!/usr/bin/perl -Tw
    use strict;
    use sigtrap;
    use Socket;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">These routines all create system-specific portability problems. As
    noted elsewhere, Perl is at the mercy of your C libraries for much of its
    system behavior. It's probably safest to assume broken SysV semantics for
    signals and to stick with simple TCP and UDP socket operations; e.g., don't
    try to pass open file descriptors over a local UDP datagram socket if you
    want your code to stand a chance of being portable.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Tom Christiansen, with occasional vestiges of Larry Wall's
    original version and suggestions from the Perl Porters.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">There's a lot more to networking than this, but this should get
    you started.</p>
<p class="Pp">For intrepid programmers, the indispensable textbook is <i>Unix
    Network</i> <i>Programming, 2nd Edition, Volume 1</i> by W. Richard Stevens
    (published by Prentice-Hall). Most books on networking address the subject
    from the perspective of a C programmer; translation to Perl is left as an
    exercise for the reader.</p>
<p class="Pp">The <b>IO::Socket</b>(3) manpage describes the object library, and
    the <b>Socket</b>(3) manpage describes the low-level interface to sockets.
    Besides the obvious functions in perlfunc, you should also check out the
    <i>modules</i> file at your nearest CPAN site, especially
    &lt;http://www.cpan.org/modules/00modlist.long.html#ID5_Networking_&gt;. See
    perlmodlib or best yet, the <i>Perl FAQ</i> for a description of what CPAN
    is and where to get it if the previous link doesn't work for you.</p>
<p class="Pp">Section 5 of CPAN's <i>modules</i> file is devoted to
    &quot;Networking, Device Control (modems), and Interprocess
    Communication&quot;, and contains numerous unbundled modules numerous
    networking modules, Chat and Expect operations, CGI programming, DCE, FTP,
    IPC, NNTP, Proxy, Ptty, RPC, SNMP, SMTP, Telnet, Threads, and ToolTalk--to
    name just a few.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

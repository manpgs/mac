<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PERLFAQ3(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLFAQ3(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLFAQ3(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlfaq3 - Programming Tools</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 5.20190126</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This section of the FAQ answers questions related to programmer
    tools and programming support.</p>
<section class="Ss">
<h2 class="Ss" id="How_do_I_do_(anything)?"><a class="permalink" href="#How_do_I_do_(anything)?">How
  do I do (anything)?</a></h2>
<p class="Pp">Have you looked at CPAN (see perlfaq2)? The chances are that
    someone has already written a module that can solve your problem. Have you
    read the appropriate manpages? Here's a brief index:</p>
<dl class="Bl-tag">
  <dt id="Basics"><a class="permalink" href="#Basics">Basics</a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="perldata"><a class="permalink" href="#perldata">perldata - Perl data
    types</a></dt>
  <dd></dd>
  <dt id="perlvar"><a class="permalink" href="#perlvar">perlvar - Perl
    pre-defined variables</a></dt>
  <dd></dd>
  <dt id="perlsyn"><a class="permalink" href="#perlsyn">perlsyn - Perl
    syntax</a></dt>
  <dd></dd>
  <dt id="perlop"><a class="permalink" href="#perlop">perlop - Perl operators
    and precedence</a></dt>
  <dd></dd>
  <dt id="perlsub"><a class="permalink" href="#perlsub">perlsub - Perl
    subroutines</a></dt>
  <dd></dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="Execution"><a class="permalink" href="#Execution">Execution</a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="perlrun"><a class="permalink" href="#perlrun">perlrun - how to execute
    the Perl interpreter</a></dt>
  <dd></dd>
  <dt id="perldebug"><a class="permalink" href="#perldebug">perldebug - Perl
    debugging</a></dt>
  <dd></dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="Functions"><a class="permalink" href="#Functions">Functions</a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="perlfunc"><a class="permalink" href="#perlfunc">perlfunc - Perl
    builtin functions</a></dt>
  <dd></dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="Objects"><a class="permalink" href="#Objects">Objects</a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="perlref"><a class="permalink" href="#perlref">perlref - Perl
    references and nested data structures</a></dt>
  <dd></dd>
  <dt id="perlmod"><a class="permalink" href="#perlmod">perlmod - Perl modules
    (packages and symbol tables)</a></dt>
  <dd></dd>
  <dt id="perlobj"><a class="permalink" href="#perlobj">perlobj - Perl
    objects</a></dt>
  <dd></dd>
  <dt id="perltie"><a class="permalink" href="#perltie">perltie - how to hide an
    object class in a simple variable</a></dt>
  <dd></dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="Data"><a class="permalink" href="#Data">Data Structures</a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="perlref~2"><a class="permalink" href="#perlref~2">perlref - Perl
    references and nested data structures</a></dt>
  <dd></dd>
  <dt id="perllol"><a class="permalink" href="#perllol">perllol - Manipulating
    arrays of arrays in Perl</a></dt>
  <dd></dd>
  <dt id="perldsc"><a class="permalink" href="#perldsc">perldsc - Perl Data
    Structures Cookbook</a></dt>
  <dd></dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="Modules"><a class="permalink" href="#Modules">Modules</a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="perlmod~2"><a class="permalink" href="#perlmod~2">perlmod - Perl
    modules (packages and symbol tables)</a></dt>
  <dd></dd>
  <dt id="perlmodlib"><a class="permalink" href="#perlmodlib">perlmodlib -
    constructing new Perl modules and finding existing ones</a></dt>
  <dd></dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="Regexes"><a class="permalink" href="#Regexes">Regexes</a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="perlre"><a class="permalink" href="#perlre">perlre - Perl regular
    expressions</a></dt>
  <dd></dd>
  <dt id="perlfunc~2"><a class="permalink" href="#perlfunc~2">perlfunc - Perl
    builtin functions&gt;</a></dt>
  <dd></dd>
  <dt id="perlop~2"><a class="permalink" href="#perlop~2">perlop - Perl
    operators and precedence</a></dt>
  <dd></dd>
  <dt id="perllocale"><a class="permalink" href="#perllocale">perllocale - Perl
    locale handling (internationalization and localization)</a></dt>
  <dd></dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="Moving"><a class="permalink" href="#Moving">Moving to perl5</a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="perltrap"><a class="permalink" href="#perltrap">perltrap - Perl traps
    for the unwary</a></dt>
  <dd></dd>
  <dt id="perl"><a class="permalink" href="#perl">perl</a></dt>
  <dd></dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="Linking"><a class="permalink" href="#Linking">Linking with C</a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="perlxstut"><a class="permalink" href="#perlxstut">perlxstut - Tutorial
    for writing XSUBs</a></dt>
  <dd></dd>
  <dt id="perlxs"><a class="permalink" href="#perlxs">perlxs - XS language
    reference manual</a></dt>
  <dd></dd>
  <dt id="perlcall"><a class="permalink" href="#perlcall">perlcall - Perl
    calling conventions from C</a></dt>
  <dd></dd>
  <dt id="perlguts"><a class="permalink" href="#perlguts">perlguts -
    Introduction to the Perl API</a></dt>
  <dd></dd>
  <dt id="perlembed"><a class="permalink" href="#perlembed">perlembed - how to
    embed perl in your C program</a></dt>
  <dd></dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="Various"><a class="permalink" href="#Various">Various</a></dt>
  <dd>&lt;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&gt; (not a man-page but
      still useful, a collection of various essays on Perl techniques)</dd>
</dl>
<p class="Pp">A crude table of contents for the Perl manpage set is found in
    perltoc.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_use_Perl_interactively?"><a class="permalink" href="#How_can_I_use_Perl_interactively?">How
  can I use Perl interactively?</a></h2>
<p class="Pp">The typical approach uses the Perl debugger, described in the
    <b>perldebug</b>(1) manpage, on an &quot;empty&quot; program, like this:</p>
<p class="Pp"></p>
<pre>
    perl -de 42
</pre>
<p class="Pp">Now just type in any legal Perl code, and it will be immediately
    evaluated. You can also examine the symbol table, get stack backtraces,
    check variable values, set breakpoints, and other operations typically found
    in symbolic debuggers.</p>
<p class="Pp">You can also use Devel::REPL which is an interactive shell for
    Perl, commonly known as a REPL - Read, Evaluate, Print, Loop. It provides
    various handy features.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_find_which_modules_are_installed_on_my_system?"><a class="permalink" href="#How_do_I_find_which_modules_are_installed_on_my_system?">How
  do I find which modules are installed on my system?</a></h2>
<p class="Pp">From the command line, you can use the
    <span class="Li">&quot;cpan&quot;</span> command's
    <span class="Li">&quot;-l&quot;</span> switch:</p>
<p class="Pp"></p>
<pre>
    $ cpan -l
</pre>
<p class="Pp">You can also use <span class="Li">&quot;cpan&quot;</span>'s
    <span class="Li">&quot;-a&quot;</span> switch to create an autobundle file
    that <span class="Li">&quot;CPAN.pm&quot;</span> understands and can use to
    re-install every module:</p>
<p class="Pp"></p>
<pre>
    $ cpan -a
</pre>
<p class="Pp">Inside a Perl program, you can use the ExtUtils::Installed module
    to show all installed distributions, although it can take awhile to do its
    magic. The standard library which comes with Perl just shows up as
    &quot;Perl&quot; (although you can get those with Module::CoreList).</p>
<p class="Pp"></p>
<pre>
    use ExtUtils::Installed;

    my $inst    = ExtUtils::Installed-&gt;new();
    my @modules = $inst-&gt;modules();
</pre>
<p class="Pp">If you want a list of all of the Perl module filenames, you can
    use File::Find::Rule:</p>
<p class="Pp"></p>
<pre>
    use File::Find::Rule;

    my @files = File::Find::Rule-&gt;
        extras({follow =&gt; 1})-&gt;
        file()-&gt;
        name( '*.pm' )-&gt;
        in( @INC )
        ;
</pre>
<p class="Pp">If you do not have that module, you can do the same thing with
    File::Find which is part of the standard library:</p>
<p class="Pp"></p>
<pre>
    use File::Find;
    my @files;

    find(
        {
        wanted =&gt; sub {
            push @files, $File::Find::fullname
            if -f $File::Find::fullname &amp;&amp; /\.pm$/
        },
        follow =&gt; 1,
        follow_skip =&gt; 2,
        },
        @INC
    );

    print join &quot;\n&quot;, @files;
</pre>
<p class="Pp">If you simply need to check quickly to see if a module is
    available, you can check for its documentation. If you can read the
    documentation the module is most likely installed. If you cannot read the
    documentation, the module might not have any (in rare cases):</p>
<p class="Pp"></p>
<pre>
    $ perldoc Module::Name
</pre>
<p class="Pp">You can also try to include the module in a one-liner to see if
    perl finds it:</p>
<p class="Pp"></p>
<pre>
    $ perl -MModule::Name -e1
</pre>
<p class="Pp">(If you don't receive a &quot;Can't locate ... in
    <span class="Li">@INC</span>&quot; error message, then Perl found the module
    name you asked for.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_debug_my_Perl_programs?"><a class="permalink" href="#How_do_I_debug_my_Perl_programs?">How
  do I debug my Perl programs?</a></h2>
<p class="Pp">(contributed by brian d foy)</p>
<p class="Pp">Before you do anything else, you can help yourself by ensuring
    that you let Perl tell you about problem areas in your code. By turning on
    warnings and strictures, you can head off many problems before they get too
    big. You can find out more about these in strict and warnings.</p>
<p class="Pp"></p>
<pre>
    #!/usr/bin/perl
    use strict;
    use warnings;
</pre>
<p class="Pp">Beyond that, the simplest debugger is the
    <span class="Li">&quot;print&quot;</span> function. Use it to look at values
    as you run your program:</p>
<p class="Pp"></p>
<pre>
    print STDERR &quot;The value is [$value]\n&quot;;
</pre>
<p class="Pp">The Data::Dumper module can pretty-print Perl data structures:</p>
<p class="Pp"></p>
<pre>
    use Data::Dumper qw( Dumper );
    print STDERR &quot;The hash is &quot; . Dumper( \%hash ) . &quot;\n&quot;;
</pre>
<p class="Pp">Perl comes with an interactive debugger, which you can start with
    the <span class="Li">&quot;-d&quot;</span> switch. It's fully explained in
    perldebug.</p>
<p class="Pp">If you'd like a graphical user interface and you have Tk, you can
    use <span class="Li">&quot;ptkdb&quot;</span>. It's on CPAN and available
    for free.</p>
<p class="Pp">If you need something much more sophisticated and controllable,
    Leon Brocard's Devel::ebug (which you can call with the
    <span class="Li">&quot;-D&quot;</span> switch as
    <span class="Li">&quot;-Debug&quot;</span>) gives you the programmatic hooks
    into everything you need to write your own (without too much pain and
    suffering).</p>
<p class="Pp">You can also use a commercial debugger such as Affrus (Mac OS X),
    Komodo from Activestate (Windows and Mac OS X), or EPIC (most
  platforms).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_profile_my_Perl_programs?"><a class="permalink" href="#How_do_I_profile_my_Perl_programs?">How
  do I profile my Perl programs?</a></h2>
<p class="Pp">(contributed by brian d foy, updated Fri Jul 25 12:22:26 PDT
  2008)</p>
<p class="Pp">The <span class="Li">&quot;Devel&quot;</span> namespace has
    several modules which you can use to profile your Perl programs.</p>
<p class="Pp">The Devel::NYTProf (New York Times Profiler) does both statement
    and subroutine profiling. It's available from CPAN and you also invoke it
    with the <span class="Li">&quot;-d&quot;</span> switch:</p>
<p class="Pp"></p>
<pre>
    perl -d:NYTProf some_perl.pl
</pre>
<p class="Pp">It creates a database of the profile information that you can turn
    into reports. The <span class="Li">&quot;nytprofhtml&quot;</span> command
    turns the data into an HTML report similar to the Devel::Cover report:</p>
<p class="Pp"></p>
<pre>
    nytprofhtml
</pre>
<p class="Pp">You might also be interested in using the Benchmark to measure and
    compare code snippets.</p>
<p class="Pp">You can read more about profiling in <i>Programming Perl</i>,
    chapter 20, or <i>Mastering Perl</i>, chapter 5.</p>
<p class="Pp">perldebguts documents creating a custom debugger if you need to
    create a special sort of profiler. brian d foy describes the process in
    <i>The Perl Journal</i>, &quot;Creating a Perl Debugger&quot;,
    &lt;http://www.ddj.com/184404522&gt; , and &quot;Profiling in Perl&quot;
    &lt;http://www.ddj.com/184404580&gt; .</p>
<p class="Pp">Perl.com has two interesting articles on profiling:
    &quot;Profiling Perl&quot;, by Simon Cozens,
    &lt;http://www.perl.com/lpt/a/850&gt; and &quot;Debugging and Profiling
    mod_perl Applications&quot;, by Frank Wiles,
    &lt;http://www.perl.com/pub/a/2006/02/09/debug_mod_perl.html&gt; .</p>
<p class="Pp">Randal L. Schwartz writes about profiling in &quot;Speeding up
    Your Perl Programs&quot; for <i>Unix Review</i>,
    &lt;http://www.stonehenge.com/merlyn/UnixReview/col49.html&gt; , and
    &quot;Profiling in Template Toolkit via Overriding&quot; for <i>Linux
    Magazine</i>, &lt;http://www.stonehenge.com/merlyn/LinuxMag/col75.html&gt;
  .</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_cross-reference_my_Perl_programs?"><a class="permalink" href="#How_do_I_cross-reference_my_Perl_programs?">How
  do I cross-reference my Perl programs?</a></h2>
<p class="Pp">The B::Xref module can be used to generate cross-reference reports
    for Perl programs.</p>
<p class="Pp"></p>
<pre>
    perl -MO=Xref[,OPTIONS] scriptname.plx
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Is_there_a_pretty-printer_(formatter)_for_Perl?"><a class="permalink" href="#Is_there_a_pretty-printer_(formatter)_for_Perl?">Is
  there a pretty-printer (formatter) for Perl?</a></h2>
<p class="Pp">Perl::Tidy comes with a perl script perltidy which indents and
    reformats Perl scripts to make them easier to read by trying to follow the
    rules of the perlstyle. If you write Perl, or spend much time reading Perl,
    you will probably find it useful.</p>
<p class="Pp">Of course, if you simply follow the guidelines in perlstyle, you
    shouldn't need to reformat. The habit of formatting your code as you write
    it will help prevent bugs. Your editor can and should help you with this.
    The perl-mode or newer cperl-mode for emacs can provide remarkable amounts
    of help with most (but not all) code, and even less programmable editors can
    provide significant assistance. Tom Christiansen and many other VI users
    swear by the following settings in vi and its clones:</p>
<p class="Pp"></p>
<pre>
    set ai sw=4
    map! ^O {^M}^[O^T
</pre>
<p class="Pp">Put that in your <i>.exrc</i> file (replacing the caret characters
    with control characters) and away you go. In insert mode, ^T is for
    indenting, ^D is for undenting, and ^O is for blockdenting--as it were. A
    more complete example, with comments, can be found at
    &lt;http://www.cpan.org/authors/id/TOMC/scripts/toms.exrc.gz&gt;</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Is_there_an_"><a class="permalink" href="#Is_there_an_">Is
  there an IDE or Windows Perl Editor?</a></h2>
<p class="Pp">Perl programs are just plain text, so any editor will do.</p>
<p class="Pp">If you're on Unix, you already have an IDE--Unix itself. The Unix
    philosophy is the philosophy of several small tools that each do one thing
    and do it well. It's like a carpenter's toolbox.</p>
<p class="Pp">If you want an IDE, check the following (in alphabetical order,
    not order of preference):</p>
<dl class="Bl-tag">
  <dt id="Eclipse"><a class="permalink" href="#Eclipse">Eclipse</a></dt>
  <dd>&lt;http://e-p-i-c.sf.net/&gt;
    <p class="Pp">The Eclipse Perl Integration Project integrates Perl
        editing/debugging with Eclipse.</p>
  </dd>
  <dt id="Enginsite"><a class="permalink" href="#Enginsite">Enginsite</a></dt>
  <dd>&lt;http://www.enginsite.com/&gt;
    <p class="Pp">Perl Editor by EngInSite is a complete integrated development
        environment (IDE) for creating, testing, and debugging Perl scripts; the
        tool runs on Windows 9x/NT/2000/XP or later.</p>
  </dd>
  <dt id="IntelliJ"><a class="permalink" href="#IntelliJ">IntelliJ IDEA</a></dt>
  <dd>&lt;https://plugins.jetbrains.com/plugin/7796&gt;
    <p class="Pp">Camelcade plugin provides Perl5 support in IntelliJ IDEA and
        other JetBrains IDEs.</p>
  </dd>
  <dt id="Kephra"><a class="permalink" href="#Kephra">Kephra</a></dt>
  <dd>&lt;http://kephra.sf.net&gt;
    <p class="Pp">GUI editor written in Perl using wxWidgets and Scintilla with
        lots of smaller features. Aims for a UI based on Perl principles like
        TIMTOWTDI and &quot;easy things should be easy, hard things should be
        possible&quot;.</p>
  </dd>
  <dt id="Komodo"><a class="permalink" href="#Komodo">Komodo</a></dt>
  <dd>&lt;http://www.ActiveState.com/Products/Komodo/&gt;
    <p class="Pp">ActiveState's cross-platform (as of October 2004, that's
        Windows, Linux, and Solaris), multi-language IDE has Perl support,
        including a regular expression debugger and remote debugging.</p>
  </dd>
  <dt id="Notepad++"><a class="permalink" href="#Notepad++">Notepad++</a></dt>
  <dd>&lt;http://notepad-plus.sourceforge.net/&gt;</dd>
  <dt id="Open"><a class="permalink" href="#Open">Open Perl IDE</a></dt>
  <dd>&lt;http://open-perl-ide.sourceforge.net/&gt;
    <p class="Pp">Open Perl IDE is an integrated development environment for
        writing and debugging Perl scripts with ActiveState's ActivePerl
        distribution under Windows 95/98/NT/2000.</p>
  </dd>
  <dt id="OptiPerl"><a class="permalink" href="#OptiPerl">OptiPerl</a></dt>
  <dd>&lt;http://www.optiperl.com/&gt;
    <p class="Pp">OptiPerl is a Windows IDE with simulated CGI environment,
        including debugger and syntax-highlighting editor.</p>
  </dd>
  <dt id="Padre"><a class="permalink" href="#Padre">Padre</a></dt>
  <dd>&lt;http://padre.perlide.org/&gt;
    <p class="Pp">Padre is cross-platform IDE for Perl written in Perl using
        wxWidgets to provide a native look and feel. It's open source under the
        Artistic License. It is one of the newer Perl IDEs.</p>
  </dd>
  <dt id="PerlBuilder"><a class="permalink" href="#PerlBuilder">PerlBuilder</a></dt>
  <dd>&lt;http://www.solutionsoft.com/perl.htm&gt;
    <p class="Pp">PerlBuilder is an integrated development environment for
        Windows that supports Perl development.</p>
  </dd>
  <dt id="visiPerl+"><a class="permalink" href="#visiPerl+">visiPerl+</a></dt>
  <dd>&lt;http://helpconsulting.net/visiperl/index.html&gt;
    <p class="Pp">From Help Consulting, for Windows.</p>
  </dd>
  <dt id="Visual"><a class="permalink" href="#Visual">Visual Perl</a></dt>
  <dd>&lt;http://www.activestate.com/Products/Visual_Perl/&gt;
    <p class="Pp">Visual Perl is a Visual Studio.NET plug-in from
      ActiveState.</p>
  </dd>
  <dt id="Zeus"><a class="permalink" href="#Zeus">Zeus</a></dt>
  <dd>&lt;http://www.zeusedit.com/lookmain.html&gt;
    <p class="Pp">Zeus for Windows is another Win32 multi-language editor/IDE
        that comes with support for Perl.</p>
  </dd>
</dl>
<p class="Pp">For editors: if you're on Unix you probably have vi or a vi clone
    already, and possibly an emacs too, so you may not need to download
    anything. In any emacs the cperl-mode (M-x cperl-mode) gives you perhaps the
    best available Perl editing mode in any editor.</p>
<p class="Pp">If you are using Windows, you can use any editor that lets you
    work with plain text, such as NotePad or WordPad. Word processors, such as
    Microsoft Word or WordPerfect, typically do not work since they insert all
    sorts of behind-the-scenes information, although some allow you to save
    files as &quot;Text Only&quot;. You can also download text editors designed
    specifically for programming, such as Textpad (
    &lt;http://www.textpad.com/&gt; ) and UltraEdit (
    &lt;http://www.ultraedit.com/&gt; ), among others.</p>
<p class="Pp">If you are using MacOS, the same concerns apply. MacPerl (for
    Classic environments) comes with a simple editor. Popular external editors
    are BBEdit ( &lt;http://www.barebones.com/products/bbedit/&gt; ) or Alpha (
    &lt;http://www.his.com/~jguyer/Alpha/Alpha8.html&gt; ). MacOS X users can
    use Unix editors as well.</p>
<dl class="Bl-tag">
  <dt id="GNU"><a class="permalink" href="#GNU">GNU Emacs</a></dt>
  <dd>&lt;http://www.gnu.org/software/emacs/windows/ntemacs.html&gt;</dd>
  <dt id="MicroEMACS"><a class="permalink" href="#MicroEMACS">MicroEMACS</a></dt>
  <dd>&lt;http://www.microemacs.de/&gt;</dd>
  <dt id="XEmacs"><a class="permalink" href="#XEmacs">XEmacs</a></dt>
  <dd>&lt;http://www.xemacs.org/Download/index.html&gt;</dd>
  <dt id="Jed"><a class="permalink" href="#Jed">Jed</a></dt>
  <dd>&lt;http://space.mit.edu/~davis/jed/&gt;</dd>
</dl>
<p class="Pp">or a vi clone such as</p>
<dl class="Bl-tag">
  <dt id="Vim"><a class="permalink" href="#Vim">Vim</a></dt>
  <dd>&lt;http://www.vim.org/&gt;</dd>
  <dt id="Vile"><a class="permalink" href="#Vile">Vile</a></dt>
  <dd>&lt;http://dickey.his.com/vile/vile.html&gt;</dd>
</dl>
<p class="Pp">The following are Win32 multilanguage editor/IDEs that support
    Perl:</p>
<dl class="Bl-tag">
  <dt id="MultiEdit"><a class="permalink" href="#MultiEdit">MultiEdit</a></dt>
  <dd>&lt;http://www.MultiEdit.com/&gt;</dd>
  <dt id="SlickEdit"><a class="permalink" href="#SlickEdit">SlickEdit</a></dt>
  <dd>&lt;http://www.slickedit.com/&gt;</dd>
  <dt id="ConTEXT"><a class="permalink" href="#ConTEXT">ConTEXT</a></dt>
  <dd>&lt;http://www.contexteditor.org/&gt;</dd>
</dl>
<p class="Pp">There is also a toyedit Text widget based editor written in Perl
    that is distributed with the Tk module on CPAN. The ptkdb (
    &lt;http://ptkdb.sourceforge.net/&gt; ) is a Perl/Tk-based debugger that
    acts as a development environment of sorts. Perl Composer (
    &lt;http://perlcomposer.sourceforge.net/&gt; ) is an IDE for Perl/Tk GUI
    creation.</p>
<p class="Pp">In addition to an editor/IDE you might be interested in a more
    powerful shell environment for Win32. Your options include</p>
<dl class="Bl-tag">
  <dt id="bash"><a class="permalink" href="#bash">bash</a></dt>
  <dd>from the Cygwin package ( &lt;http://cygwin.com/&gt; )</dd>
  <dt id="zsh"><a class="permalink" href="#zsh">zsh</a></dt>
  <dd>&lt;http://www.zsh.org/&gt;</dd>
</dl>
<p class="Pp">Cygwin is covered by the GNU General Public License (but that
    shouldn't matter for Perl use). Cygwin contains (in addition to the shell) a
    comprehensive set of standard Unix toolkit utilities.</p>
<dl class="Bl-tag">
  <dt id="BBEdit"><a class="permalink" href="#BBEdit">BBEdit and
    TextWrangler</a></dt>
  <dd>are text editors for OS X that have a Perl sensitivity mode (
      &lt;http://www.barebones.com/&gt; ).</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Where_can_I_get_Perl_macros_for_vi?"><a class="permalink" href="#Where_can_I_get_Perl_macros_for_vi?">Where
  can I get Perl macros for vi?</a></h2>
<p class="Pp">For a complete version of Tom Christiansen's vi configuration
    file, see
    &lt;http://www.cpan.org/authors/Tom_Christiansen/scripts/toms.exrc.gz&gt; ,
    the standard benchmark file for vi emulators. The file runs best with nvi,
    the current version of vi out of Berkeley, which incidentally can be built
    with an embedded Perl interpreter--see &lt;http://www.cpan.org/src/misc/&gt;
    .</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Where_can_I_get_perl-mode_or_cperl-mode_for_emacs?"><a class="permalink" href="#Where_can_I_get_perl-mode_or_cperl-mode_for_emacs?">Where
  can I get perl-mode or cperl-mode for emacs?</a></h2>
<p class="Pp">Since Emacs version 19 patchlevel 22 or so, there have been both a
    perl-mode.el and support for the Perl debugger built in. These should come
    with the standard Emacs 19 distribution.</p>
<p class="Pp">Note that the perl-mode of emacs will have fits with
    <span class="Li">&quot;main'foo&quot;</span> (single quote), and mess up the
    indentation and highlighting. You are probably using
    <span class="Li">&quot;main::foo&quot;</span> in new Perl code anyway, so
    this shouldn't be an issue.</p>
<p class="Pp">For CPerlMode, see
    &lt;http://www.emacswiki.org/cgi-bin/wiki/CPerlMode&gt;</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_use_curses_with_Perl?"><a class="permalink" href="#How_can_I_use_curses_with_Perl?">How
  can I use curses with Perl?</a></h2>
<p class="Pp">The Curses module from CPAN provides a dynamically loadable object
    module interface to a curses library. A small demo can be found at the
    directory
    &lt;http://www.cpan.org/authors/Tom_Christiansen/scripts/rep.gz&gt; ; this
    program repeats a command and updates the screen as needed, rendering <b>rep
    ps axu</b> similar to <b>top</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_write_a_"><a class="permalink" href="#How_can_I_write_a_">How
  can I write a GUI (X, Tk, Gtk, etc.) in Perl?</a></h2>
<p class="Pp">(contributed by Ben Morrow)</p>
<p class="Pp">There are a number of modules which let you write GUIs in Perl.
    Most GUI toolkits have a perl interface: an incomplete list follows.</p>
<dl class="Bl-tag">
  <dt id="Tk"><a class="permalink" href="#Tk">Tk</a></dt>
  <dd>This works under Unix and Windows, and the current version doesn't look
      half as bad under Windows as it used to. Some of the gui elements still
      don't 'feel' quite right, though. The interface is very natural and
      'perlish', making it easy to use in small scripts that just need a simple
      gui. It hasn't been updated in a while.</dd>
  <dt id="Wx"><a class="permalink" href="#Wx">Wx</a></dt>
  <dd>This is a Perl binding for the cross-platform wxWidgets toolkit (
      &lt;http://www.wxwidgets.org&gt; ). It works under Unix, Win32 and Mac OS
      X, using native widgets (Gtk under Unix). The interface follows the C++
      interface closely, but the documentation is a little sparse for someone
      who doesn't know the library, mostly just referring you to the C++
      documentation.</dd>
  <dt id="Gtk"><a class="permalink" href="#Gtk">Gtk and Gtk2</a></dt>
  <dd>These are Perl bindings for the Gtk toolkit ( &lt;http://www.gtk.org&gt;
      ). The interface changed significantly between versions 1 and 2 so they
      have separate Perl modules. It runs under Unix, Win32 and Mac OS X
      (currently it requires an X server on Mac OS, but a 'native' port is
      underway), and the widgets look the same on every platform: i.e., they
      don't match the native widgets. As with Wx, the Perl bindings follow the C
      API closely, and the documentation requires you to read the C
      documentation to understand it.</dd>
  <dt id="Win32::GUI"><a class="permalink" href="#Win32::GUI">Win32::GUI</a></dt>
  <dd>This provides access to most of the Win32 GUI widgets from Perl.
      Obviously, it only runs under Win32, and uses native widgets. The Perl
      interface doesn't really follow the C interface: it's been made more
      Perlish, and the documentation is pretty good. More advanced stuff may
      require familiarity with the C Win32 APIs, or reference to MSDN.</dd>
  <dt id="CamelBones"><a class="permalink" href="#CamelBones">CamelBones</a></dt>
  <dd>CamelBones ( &lt;http://camelbones.sourceforge.net&gt; ) is a Perl
      interface to Mac OS X's Cocoa GUI toolkit, and as such can be used to
      produce native GUIs on Mac OS X. It's not on CPAN, as it requires
      frameworks that CPAN.pm doesn't know how to install, but installation is
      via the standard OSX package installer. The Perl API is, again, very close
      to the ObjC API it's wrapping, and the documentation just tells you how to
      translate from one to the other.</dd>
  <dt id="Qt"><a class="permalink" href="#Qt">Qt</a></dt>
  <dd>There is a Perl interface to TrollTech's Qt toolkit, but it does not
      appear to be maintained.</dd>
  <dt id="Athena"><a class="permalink" href="#Athena">Athena</a></dt>
  <dd>Sx is an interface to the Athena widget set which comes with X, but again
      it appears not to be much used nowadays.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_make_my_Perl_program_run_faster?"><a class="permalink" href="#How_can_I_make_my_Perl_program_run_faster?">How
  can I make my Perl program run faster?</a></h2>
<p class="Pp">The best way to do this is to come up with a better algorithm.
    This can often make a dramatic difference. Jon Bentley's book <i>Programming
    Pearls</i> (that's not a misspelling!) has some good tips on optimization,
    too. Advice on benchmarking boils down to: benchmark and profile to make
    sure you're optimizing the right part, look for better algorithms instead of
    microtuning your code, and when all else fails consider just buying faster
    hardware. You will probably want to read the answer to the earlier question
    &quot;How do I profile my Perl programs?&quot; if you haven't done so
    already.</p>
<p class="Pp">A different approach is to autoload seldom-used Perl code. See the
    AutoSplit and AutoLoader modules in the standard distribution for that. Or
    you could locate the bottleneck and think about writing just that part in C,
    the way we used to take bottlenecks in C code and write them in assembler.
    Similar to rewriting in C, modules that have critical sections can be
    written in C (for instance, the PDL module from CPAN).</p>
<p class="Pp">If you're currently linking your perl executable to a shared
    <i>libc.so</i>, you can often gain a 10-25% performance benefit by
    rebuilding it to link with a static libc.a instead. This will make a bigger
    perl executable, but your Perl programs (and programmers) may thank you for
    it. See the <i>INSTALL</i> file in the source distribution for more
    information.</p>
<p class="Pp">The undump program was an ancient attempt to speed up Perl program
    by storing the already-compiled form to disk. This is no longer a viable
    option, as it only worked on a few architectures, and wasn't a good solution
    anyway.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_make_my_Perl_program_take_less_memory?"><a class="permalink" href="#How_can_I_make_my_Perl_program_take_less_memory?">How
  can I make my Perl program take less memory?</a></h2>
<p class="Pp">When it comes to time-space tradeoffs, Perl nearly always prefers
    to throw memory at a problem. Scalars in Perl use more memory than strings
    in C, arrays take more than that, and hashes use even more. While there's
    still a lot to be done, recent releases have been addressing these issues.
    For example, as of 5.004, duplicate hash keys are shared amongst all hashes
    using them, so require no reallocation.</p>
<p class="Pp">In some cases, using <b>substr()</b> or <b>vec()</b> to simulate
    arrays can be highly beneficial. For example, an array of a thousand
    booleans will take at least 20,000 bytes of space, but it can be turned into
    one 125-byte bit vector--a considerable memory savings. The standard
    Tie::SubstrHash module can also help for certain types of data structure. If
    you're working with specialist data structures (matrices, for instance)
    modules that implement these in C may use less memory than equivalent Perl
    modules.</p>
<p class="Pp">Another thing to try is learning whether your Perl was compiled
    with the system malloc or with Perl's builtin malloc. Whichever one it is,
    try using the other one and see whether this makes a difference. Information
    about malloc is in the <i>INSTALL</i> file in the source distribution. You
    can find out whether you are using perl's malloc by typing
    <span class="Li">&quot;perl -V:usemymalloc&quot;</span>.</p>
<p class="Pp">Of course, the best way to save memory is to not do anything to
    waste it in the first place. Good programming practices can go a long way
    toward this:</p>
<dl class="Bl-tag">
  <dt id="Don't"><a class="permalink" href="#Don't">Don't slurp!</a></dt>
  <dd>Don't read an entire file into memory if you can process it line by line.
      Or more concretely, use a loop like this:
    <p class="Pp"></p>
    <pre>
    #
    # Good Idea
    #
    while (my $line = &lt;$file_handle&gt;) {
       # ...
    }
    </pre>
    <p class="Pp">instead of this:</p>
    <p class="Pp"></p>
    <pre>
    #
    # Bad Idea
    #
    my @data = &lt;$file_handle&gt;;
    foreach (@data) {
        # ...
    }
    </pre>
    <p class="Pp">When the files you're processing are small, it doesn't much
        matter which way you do it, but it makes a huge difference when they
        start getting larger.</p>
  </dd>
  <dt id="Use"><a class="permalink" href="#Use">Use map and grep
    selectively</a></dt>
  <dd>Remember that both map and grep expect a LIST argument, so doing this:
    <p class="Pp"></p>
    <pre>
        @wanted = grep {/pattern/} &lt;$file_handle&gt;;
    </pre>
    <p class="Pp">will cause the entire file to be slurped. For large files,
        it's better to loop:</p>
    <p class="Pp"></p>
    <pre>
        while (&lt;$file_handle&gt;) {
                push(@wanted, $_) if /pattern/;
        }
    </pre>
  </dd>
  <dt id="Avoid"><a class="permalink" href="#Avoid">Avoid unnecessary quotes and
    stringification</a></dt>
  <dd>Don't quote large strings unless absolutely necessary:
    <p class="Pp"></p>
    <pre>
        my $copy = &quot;$large_string&quot;;
    </pre>
    <p class="Pp">makes 2 copies of <span class="Li">$large_string</span> (one
        for <span class="Li">$copy</span> and another for the quotes),
      whereas</p>
    <p class="Pp"></p>
    <pre>
        my $copy = $large_string;
    </pre>
    <p class="Pp">only makes one copy.</p>
    <p class="Pp">Ditto for stringifying large arrays:</p>
    <p class="Pp"></p>
    <pre>
    {
    local $, = &quot;\n&quot;;
    print @big_array;
    }
    </pre>
    <p class="Pp">is much more memory-efficient than either</p>
    <p class="Pp"></p>
    <pre>
    print join &quot;\n&quot;, @big_array;
    </pre>
    <p class="Pp">or</p>
    <p class="Pp"></p>
    <pre>
    {
    local $&quot; = &quot;\n&quot;;
    print &quot;@big_array&quot;;
    }
    </pre>
  </dd>
  <dt id="Pass"><a class="permalink" href="#Pass">Pass by reference</a></dt>
  <dd>Pass arrays and hashes by reference, not by value. For one thing, it's the
      only way to pass multiple lists or hashes (or both) in a single
      call/return. It also avoids creating a copy of all the contents. This
      requires some judgement, however, because any changes will be propagated
      back to the original data. If you really want to mangle (er, modify) a
      copy, you'll have to sacrifice the memory needed to make one.</dd>
  <dt id="Tie"><a class="permalink" href="#Tie">Tie large variables to
    disk</a></dt>
  <dd>For &quot;big&quot; data stores (i.e. ones that exceed available memory)
      consider using one of the DB modules to store it on disk instead of in
      RAM. This will incur a penalty in access time, but that's probably better
      than causing your hard disk to thrash due to massive swapping.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Is_it_safe_to_return_a_reference_to_local_or_lexical_data?"><a class="permalink" href="#Is_it_safe_to_return_a_reference_to_local_or_lexical_data?">Is
  it safe to return a reference to local or lexical data?</a></h2>
<p class="Pp">Yes. Perl's garbage collection system takes care of this so
    everything works out right.</p>
<p class="Pp"></p>
<pre>
    sub makeone {
        my @a = ( 1 .. 10 );
        return \@a;
    }

    for ( 1 .. 10 ) {
        push @many, makeone();
    }

    print $many[4][5], &quot;\n&quot;;

    print &quot;@many\n&quot;;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_free_an_array_or_hash_so_my_program_shrinks?"><a class="permalink" href="#How_can_I_free_an_array_or_hash_so_my_program_shrinks?">How
  can I free an array or hash so my program shrinks?</a></h2>
<p class="Pp">(contributed by Michael Carman)</p>
<p class="Pp">You usually can't. Memory allocated to lexicals (i.e. <b>my()</b>
    variables) cannot be reclaimed or reused even if they go out of scope. It is
    reserved in case the variables come back into scope. Memory allocated to
    global variables can be reused (within your program) by using <b>undef()</b>
    and/or <b>delete()</b>.</p>
<p class="Pp">On most operating systems, memory allocated to a program can never
    be returned to the system. That's why long-running programs sometimes re-
    exec themselves. Some operating systems (notably, systems that use
    <b>mmap</b>(2) for allocating large chunks of memory) can reclaim memory
    that is no longer used, but on such systems, perl must be configured and
    compiled to use the OS's malloc, not perl's.</p>
<p class="Pp">In general, memory allocation and de-allocation isn't something
    you can or should be worrying about much in Perl.</p>
<p class="Pp">See also &quot;How can I make my Perl program take less
    memory?&quot;</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_make_my_"><a class="permalink" href="#How_can_I_make_my_">How
  can I make my CGI script more efficient?</a></h2>
<p class="Pp">Beyond the normal measures described to make general Perl programs
    faster or smaller, a CGI program has additional issues. It may be run
    several times per second. Given that each time it runs it will need to be
    re-compiled and will often allocate a megabyte or more of system memory,
    this can be a killer. Compiling into C <b>isn't going to help</b> <b>you</b>
    because the process start-up overhead is where the bottleneck is.</p>
<p class="Pp">There are three popular ways to avoid this overhead. One solution
    involves running the Apache HTTP server (available from
    &lt;http://www.apache.org/&gt; ) with either of the mod_perl or mod_fastcgi
    plugin modules.</p>
<p class="Pp">With mod_perl and the Apache::Registry module (distributed with
    mod_perl), httpd will run with an embedded Perl interpreter which
    pre-compiles your script and then executes it within the same address space
    without forking. The Apache extension also gives Perl access to the internal
    server API, so modules written in Perl can do just about anything a module
    written in C can. For more on mod_perl, see
  &lt;http://perl.apache.org/&gt;</p>
<p class="Pp">With the FCGI module (from CPAN) and the mod_fastcgi module
    (available from &lt;http://www.fastcgi.com/&gt; ) each of your Perl programs
    becomes a permanent CGI daemon process.</p>
<p class="Pp">Finally, Plack is a Perl module and toolkit that contains PSGI
    middleware, helpers and adapters to web servers, allowing you to easily
    deploy scripts which can continue running, and provides flexibility with
    regards to which web server you use. It can allow existing CGI scripts to
    enjoy this flexibility and performance with minimal changes, or can be used
    along with modern Perl web frameworks to make writing and deploying web
    services with Perl a breeze.</p>
<p class="Pp">These solutions can have far-reaching effects on your system and
    on the way you write your CGI programs, so investigate them with care.</p>
<p class="Pp">See also
    &lt;http://www.cpan.org/modules/by-category/15_World_Wide_Web_HTML_HTTP_CGI/&gt;
    .</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_hide_the_source_for_my_Perl_program?"><a class="permalink" href="#How_can_I_hide_the_source_for_my_Perl_program?">How
  can I hide the source for my Perl program?</a></h2>
<p class="Pp">Delete it. :-) Seriously, there are a number of (mostly
    unsatisfactory) solutions with varying levels of &quot;security&quot;.</p>
<p class="Pp">First of all, however, you <i>can't</i> take away read permission,
    because the source code has to be readable in order to be compiled and
    interpreted. (That doesn't mean that a CGI script's source is readable by
    people on the web, though--only by people with access to the filesystem.) So
    you have to leave the permissions at the socially friendly 0755 level.</p>
<p class="Pp">Some people regard this as a security problem. If your program
    does insecure things and relies on people not knowing how to exploit those
    insecurities, it is not secure. It is often possible for someone to
    determine the insecure things and exploit them without viewing the source.
    Security through obscurity, the name for hiding your bugs instead of fixing
    them, is little security indeed.</p>
<p class="Pp">You can try using encryption via source filters (Starting from
    Perl 5.8 the Filter::Simple and Filter::Util::Call modules are included in
    the standard distribution), but any decent programmer will be able to
    decrypt it. You can try using the byte code compiler and interpreter
    described later in perlfaq3, but the curious might still be able to
    de-compile it. You can try using the native-code compiler described later,
    but crackers might be able to disassemble it. These pose varying degrees of
    difficulty to people wanting to get at your code, but none can definitively
    conceal it (true of every language, not just Perl).</p>
<p class="Pp">It is very easy to recover the source of Perl programs. You simply
    feed the program to the perl interpreter and use the modules in the B::
    hierarchy. The B::Deparse module should be able to defeat most attempts to
    hide source. Again, this is not unique to Perl.</p>
<p class="Pp">If you're concerned about people profiting from your code, then
    the bottom line is that nothing but a restrictive license will give you
    legal security. License your software and pepper it with threatening
    statements like &quot;This is unpublished proprietary software of XYZ Corp.
    Your access to it does not give you permission to use it blah blah
    blah.&quot; We are not lawyers, of course, so you should see a lawyer if you
    want to be sure your license's wording will stand up in court.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_compile_my_Perl_program_into_byte_code_or_C?"><a class="permalink" href="#How_can_I_compile_my_Perl_program_into_byte_code_or_C?">How
  can I compile my Perl program into byte code or C?</a></h2>
<p class="Pp">(contributed by brian d foy)</p>
<p class="Pp">In general, you can't do this. There are some things that may work
    for your situation though. People usually ask this question because they
    want to distribute their works without giving away the source code, and most
    solutions trade disk space for convenience. You probably won't see much of a
    speed increase either, since most solutions simply bundle a Perl interpreter
    in the final product (but see &quot;How can I make my Perl program run
    faster?&quot;).</p>
<p class="Pp">The Perl Archive Toolkit is Perl's analog to Java's JAR. It's
    freely available and on CPAN ( &lt;https://metacpan.org/pod/PAR&gt; ).</p>
<p class="Pp">There are also some commercial products that may work for you,
    although you have to buy a license for them.</p>
<p class="Pp">The Perl Dev Kit (
    &lt;http://www.activestate.com/Products/Perl_Dev_Kit/&gt; ) from ActiveState
    can &quot;Turn your Perl programs into ready-to-run executables for HP-UX,
    Linux, Solaris and Windows.&quot;</p>
<p class="Pp">Perl2Exe ( &lt;http://www.indigostar.com/perl2exe.htm&gt; ) is a
    command line program for converting perl scripts to executable files. It
    targets both Windows and Unix platforms.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_get___!perl__to_work_on__"><a class="permalink" href="#How_can_I_get___!perl__to_work_on__">How
  can I get &quot;#!perl&quot; to work on [MS-DOS,NT,...]?</a></h2>
<p class="Pp">For OS/2 just use</p>
<p class="Pp"></p>
<pre>
    extproc perl -S -your_switches
</pre>
<p class="Pp">as the first line in <span class="Li">&quot;*.cmd&quot;</span>
    file (<span class="Li">&quot;-S&quot;</span> due to a bug in cmd.exe's
    &quot;extproc&quot; handling). For DOS one should first invent a
    corresponding batch file and codify it in
    <span class="Li">&quot;ALTERNATE_SHEBANG&quot;</span> (see the
    <i>dosish.h</i> file in the source distribution for more information).</p>
<p class="Pp">The Win95/NT installation, when using the ActiveState port of
    Perl, will modify the Registry to associate the
    <span class="Li">&quot;.pl&quot;</span> extension with the perl interpreter.
    If you install another port, perhaps even building your own Win95/NT Perl
    from the standard sources by using a Windows port of gcc (e.g., with cygwin
    or mingw32), then you'll have to modify the Registry yourself. In addition
    to associating <span class="Li">&quot;.pl&quot;</span> with the interpreter,
    NT people can use: <span class="Li">&quot;SET
    PATHEXT=%PATHEXT%;.PL&quot;</span> to let them run the program
    <span class="Li">&quot;install-linux.pl&quot;</span> merely by typing
    <span class="Li">&quot;install-linux&quot;</span>.</p>
<p class="Pp">Under &quot;Classic&quot; MacOS, a perl program will have the
    appropriate Creator and Type, so that double-clicking them will invoke the
    MacPerl application. Under Mac OS X, clickable apps can be made from any
    <span class="Li">&quot;#!&quot;</span> script using Wil Sanchez' DropScript
    utility: &lt;http://www.wsanchez.net/software/&gt; .</p>
<p class="Pp"><i>IMPORTANT!</i>: Whatever you do, PLEASE don't get frustrated,
    and just throw the perl interpreter into your cgi-bin directory, in order to
    get your programs working for a web server. This is an EXTREMELY big
    security risk. Take the time to figure out how to do it correctly.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Can_I_write_useful_Perl_programs_on_the_command_line?"><a class="permalink" href="#Can_I_write_useful_Perl_programs_on_the_command_line?">Can
  I write useful Perl programs on the command line?</a></h2>
<p class="Pp">Yes. Read perlrun for more information. Some examples follow.
    (These assume standard Unix shell quoting rules.)</p>
<p class="Pp"></p>
<pre>
    # sum first and last fields
    perl -lane 'print $F[0] + $F[-1]' *

    # identify text files
    perl -le 'for(@ARGV) {print if -f &amp;&amp; -T _}' *

    # remove (most) comments from C program
    perl -0777 -pe 's{/\*.*?\*/}{}gs' foo.c

    # make file a month younger than today, defeating reaper daemons
    perl -e '$X=24*60*60; utime(time(),time() + 30 * $X,@ARGV)' *

    # find first unused uid
    perl -le '$i++ while getpwuid($i); print $i'

    # display reasonable manpath
    echo $PATH | perl -nl -072 -e '
    s![^/+]*$!man!&amp;&amp;-d&amp;&amp;!$s{$_}++&amp;&amp;push@m,$_;END{print&quot;@m&quot;}'
</pre>
<p class="Pp">OK, the last one was actually an Obfuscated Perl Contest entry.
    :-)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Why_don't_Perl_one-liners_work_on_my_DOS/Mac/VMS_system?"><a class="permalink" href="#Why_don't_Perl_one-liners_work_on_my_DOS/Mac/VMS_system?">Why
  don't Perl one-liners work on my DOS/Mac/VMS system?</a></h2>
<p class="Pp">The problem is usually that the command interpreters on those
    systems have rather different ideas about quoting than the Unix shells under
    which the one-liners were created. On some systems, you may have to change
    single-quotes to double ones, which you must <i>NOT</i> do on Unix or Plan9
    systems. You might also have to change a single % to a %%.</p>
<p class="Pp">For example:</p>
<p class="Pp"></p>
<pre>
    # Unix (including Mac OS X)
    perl -e 'print &quot;Hello world\n&quot;'

    # DOS, etc.
    perl -e &quot;print \&quot;Hello world\n\&quot;&quot;

    # Mac Classic
    print &quot;Hello world\n&quot;
     (then Run &quot;Myscript&quot; or Shift-Command-R)

    # MPW
    perl -e 'print &quot;Hello world\n&quot;'

    # VMS
    perl -e &quot;print &quot;&quot;Hello world\n&quot;&quot;&quot;
</pre>
<p class="Pp">The problem is that none of these examples are reliable: they
    depend on the command interpreter. Under Unix, the first two often work.
    Under DOS, it's entirely possible that neither works. If 4DOS was the
    command shell, you'd probably have better luck like this:</p>
<p class="Pp"></p>
<pre>
  perl -e &quot;print &lt;Ctrl-x&gt;&quot;Hello world\n&lt;Ctrl-x&gt;&quot;&quot;
</pre>
<p class="Pp">Under the Mac, it depends which environment you are using. The
    MacPerl shell, or MPW, is much like Unix shells in its support for several
    quoting variants, except that it makes free use of the Mac's non-ASCII
    characters as control characters.</p>
<p class="Pp">Using <b>qq()</b>, q(), and <b>qx()</b>, instead of &quot;double
    quotes&quot;, 'single quotes', and `backticks`, may make one-liners easier
    to write.</p>
<p class="Pp">There is no general solution to all of this. It is a mess.</p>
<p class="Pp">[Some of this answer was contributed by Kenneth Albanowski.]</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Where_can_I_learn_about_"><a class="permalink" href="#Where_can_I_learn_about_">Where
  can I learn about CGI or Web programming in Perl?</a></h2>
<p class="Pp">For modules, get the CGI or LWP modules from CPAN. For textbooks,
    see the two especially dedicated to web stuff in the question on books. For
    problems and questions related to the web, like &quot;Why do I get 500
    Errors&quot; or &quot;Why doesn't it run from the browser right when it runs
    fine on the command line&quot;, see the troubleshooting guides and
    references in perlfaq9 or in the CGI MetaFAQ:</p>
<p class="Pp"></p>
<pre>
    L&lt;http://www.perl.org/CGI_MetaFAQ.html&gt;
</pre>
<p class="Pp">Looking in to Plack and modern Perl web frameworks is highly
    recommended, though; web programming in Perl has evolved a long way from the
    old days of simple CGI scripts.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Where_can_I_learn_about_object-oriented_Perl_programming?"><a class="permalink" href="#Where_can_I_learn_about_object-oriented_Perl_programming?">Where
  can I learn about object-oriented Perl programming?</a></h2>
<p class="Pp">A good place to start is perlootut, and you can use perlobj for
    reference.</p>
<p class="Pp">A good book on OO on Perl is the &quot;Object-Oriented Perl&quot;
    by Damian Conway from Manning Publications, or &quot;Intermediate Perl&quot;
    by Randal Schwartz, brian d foy, and Tom Phoenix from O'Reilly Media.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Where_can_I_learn_about_linking_C_with_Perl?"><a class="permalink" href="#Where_can_I_learn_about_linking_C_with_Perl?">Where
  can I learn about linking C with Perl?</a></h2>
<p class="Pp">If you want to call C from Perl, start with perlxstut, moving on
    to perlxs, xsubpp, and perlguts. If you want to call Perl from C, then read
    perlembed, perlcall, and perlguts. Don't forget that you can learn a lot
    from looking at how the authors of existing extension modules wrote their
    code and solved their problems.</p>
<p class="Pp">You might not need all the power of XS. The Inline::C module lets
    you put C code directly in your Perl source. It handles all the magic to
    make it work. You still have to learn at least some of the perl API but you
    won't have to deal with the complexity of the XS support files.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="I've_read_perlembed,_perlguts,_etc.,_but_I_can't_embed_perl_in_my_C_program;_what_am_I_doing_wrong?"><a class="permalink" href="#I've_read_perlembed,_perlguts,_etc.,_but_I_can't_embed_perl_in_my_C_program;_what_am_I_doing_wrong?">I've
  read perlembed, perlguts, etc., but I can't embed perl in my C program; what
  am I doing wrong?</a></h2>
<p class="Pp">Download the ExtUtils::Embed kit from CPAN and run `make test'. If
    the tests pass, read the pods again and again and again. If they fail, see
    perlbug and send a bug report with the output of <span class="Li">&quot;make
    test TEST_VERBOSE=1&quot;</span> along with <span class="Li">&quot;perl
    -V&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="When_I_tried_to_run_my_script,_I_got_this_message._What_does_it_mean?"><a class="permalink" href="#When_I_tried_to_run_my_script,_I_got_this_message._What_does_it_mean?">When
  I tried to run my script, I got this message. What does it mean?</a></h2>
<p class="Pp">A complete list of Perl's error messages and warnings with
    explanatory text can be found in perldiag. You can also use the splain
    program (distributed with Perl) to explain the error messages:</p>
<p class="Pp"></p>
<pre>
    perl program 2&gt;diag.out
    splain [-v] [-p] diag.out
</pre>
<p class="Pp">or change your program to explain the messages for you:</p>
<p class="Pp"></p>
<pre>
    use diagnostics;
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre>
    use diagnostics -verbose;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="What's_MakeMaker?"><a class="permalink" href="#What's_MakeMaker?">What's
  MakeMaker?</a></h2>
<p class="Pp">(contributed by brian d foy)</p>
<p class="Pp">The ExtUtils::MakeMaker module, better known simply as
    &quot;MakeMaker&quot;, turns a Perl script, typically called
    <span class="Li">&quot;Makefile.PL&quot;</span>, into a Makefile. The Unix
    tool <span class="Li">&quot;make&quot;</span> uses this file to manage
    dependencies and actions to process and install a Perl distribution.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR_AND_COPYRIGHT"><a class="permalink" href="#AUTHOR_AND_COPYRIGHT">AUTHOR
  AND COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 1997-2010 Tom Christiansen, Nathan Torkington, and
    other authors as noted. All rights reserved.</p>
<p class="Pp">This documentation is free; you can redistribute it and/or modify
    it under the same terms as Perl itself.</p>
<p class="Pp">Irrespective of its distribution, all code examples here are in
    the public domain. You are permitted and encouraged to use this code and any
    derivatives thereof in your own programs for fun or for profit as you see
    fit. A simple comment in the code giving credit to the FAQ would be
    courteous but is not required.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PERLSUB(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLSUB(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLSUB(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlsub - Perl subroutines</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">To declare subroutines:</p>
<p class="Pp"></p>
<pre>
    sub NAME;                     # A &quot;forward&quot; declaration.
    sub NAME(PROTO);              #  ditto, but with prototypes
    sub NAME : ATTRS;             #  with attributes
    sub NAME(PROTO) : ATTRS;      #  with attributes and prototypes

    sub NAME BLOCK                # A declaration and a definition.
    sub NAME(PROTO) BLOCK         #  ditto, but with prototypes
    sub NAME : ATTRS BLOCK        #  with attributes
    sub NAME(PROTO) : ATTRS BLOCK #  with prototypes and attributes

    use feature 'signatures';
    sub NAME(SIG) BLOCK                    # with signature
    sub NAME :ATTRS (SIG) BLOCK            # with signature, attributes
    sub NAME :prototype(PROTO) (SIG) BLOCK # with signature, prototype
</pre>
<p class="Pp">To define an anonymous subroutine at runtime:</p>
<p class="Pp"></p>
<pre>
    $subref = sub BLOCK;                 # no proto
    $subref = sub (PROTO) BLOCK;         # with proto
    $subref = sub : ATTRS BLOCK;         # with attributes
    $subref = sub (PROTO) : ATTRS BLOCK; # with proto and attributes

    use feature 'signatures';
    $subref = sub (SIG) BLOCK;           # with signature
    $subref = sub : ATTRS(SIG) BLOCK;    # with signature, attributes
</pre>
<p class="Pp">To import subroutines:</p>
<p class="Pp"></p>
<pre>
    use MODULE qw(NAME1 NAME2 NAME3);
</pre>
<p class="Pp">To call subroutines:</p>
<p class="Pp"></p>
<pre>
    NAME(LIST);    # &amp; is optional with parentheses.
    NAME LIST;     # Parentheses optional if predeclared/imported.
    &amp;NAME(LIST);   # Circumvent prototypes.
    &amp;NAME;         # Makes current @_ visible to called subroutine.
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Like many languages, Perl provides for user-defined subroutines.
    These may be located anywhere in the main program, loaded in from other
    files via the <span class="Li">&quot;do&quot;</span>,
    <span class="Li">&quot;require&quot;</span>, or
    <span class="Li">&quot;use&quot;</span> keywords, or generated on the fly
    using <span class="Li">&quot;eval&quot;</span> or anonymous subroutines. You
    can even call a function indirectly using a variable containing its name or
    a CODE reference.</p>
<p class="Pp">The Perl model for function call and return values is simple: all
    functions are passed as parameters one single flat list of scalars, and all
    functions likewise return to their caller one single flat list of scalars.
    Any arrays or hashes in these call and return lists will collapse, losing
    their identities--but you may always use pass-by-reference instead to avoid
    this. Both call and return lists may contain as many or as few scalar
    elements as you'd like. (Often a function without an explicit return
    statement is called a subroutine, but there's really no difference from
    Perl's perspective.)</p>
<p class="Pp">Any arguments passed in show up in the array
    <span class="Li">@_</span>. (They may also show up in lexical variables
    introduced by a signature; see &quot;Signatures&quot; below.) Therefore, if
    you called a function with two arguments, those would be stored in
    <span class="Li">$_[0]</span> and <span class="Li">$_[1]</span>. The array
    <span class="Li">@_</span> is a local array, but its elements are aliases
    for the actual scalar parameters. In particular, if an element
    <span class="Li">$_[0]</span> is updated, the corresponding argument is
    updated (or an error occurs if it is not updatable). If an argument is an
    array or hash element which did not exist when the function was called, that
    element is created only when (and if) it is modified or a reference to it is
    taken. (Some earlier versions of Perl created the element whether or not the
    element was assigned to.) Assigning to the whole array
    <span class="Li">@_</span> removes that aliasing, and does not update any
    arguments.</p>
<p class="Pp">A <span class="Li">&quot;return&quot;</span> statement may be used
    to exit a subroutine, optionally specifying the returned value, which will
    be evaluated in the appropriate context (list, scalar, or void) depending on
    the context of the subroutine call. If you specify no return value, the
    subroutine returns an empty list in list context, the undefined value in
    scalar context, or nothing in void context. If you return one or more
    aggregates (arrays and hashes), these will be flattened together into one
    large indistinguishable list.</p>
<p class="Pp">If no <span class="Li">&quot;return&quot;</span> is found and if
    the last statement is an expression, its value is returned. If the last
    statement is a loop control structure like a
    <span class="Li">&quot;foreach&quot;</span> or a
    <span class="Li">&quot;while&quot;</span>, the returned value is
    unspecified. The empty sub returns the empty list.</p>
<p class="Pp">Aside from an experimental facility (see &quot;Signatures&quot;
    below), Perl does not have named formal parameters. In practice all you do
    is assign to a <span class="Li">&quot;my()&quot;</span> list of these.
    Variables that aren't declared to be private are global variables. For gory
    details on creating private variables, see &quot;Private Variables via
    <b>my()</b>&quot; and &quot;Temporary Values via <b>local()</b>&quot;. To
    create protected environments for a set of functions in a separate package
    (and probably a separate file), see &quot;Packages&quot; in perlmod.</p>
<p class="Pp">Example:</p>
<p class="Pp"></p>
<pre>
    sub max {
        my $max = shift(@_);
        foreach $foo (@_) {
            $max = $foo if $max &lt; $foo;
        }
        return $max;
    }
    $bestday = max($mon,$tue,$wed,$thu,$fri);
</pre>
<p class="Pp">Example:</p>
<p class="Pp"></p>
<pre>
    # get a line, combining continuation lines
    #  that start with whitespace

    sub get_line {
        $thisline = $lookahead;  # global variables!
        LINE: while (defined($lookahead = &lt;STDIN&gt;)) {
            if ($lookahead =~ /^[ \t]/) {
                $thisline .= $lookahead;
            }
            else {
                last LINE;
            }
        }
        return $thisline;
    }

    $lookahead = &lt;STDIN&gt;;       # get first line
    while (defined($line = get_line())) {
        ...
    }
</pre>
<p class="Pp">Assigning to a list of private variables to name your
  arguments:</p>
<p class="Pp"></p>
<pre>
    sub maybeset {
        my($key, $value) = @_;
        $Foo{$key} = $value unless $Foo{$key};
    }
</pre>
<p class="Pp">Because the assignment copies the values, this also has the effect
    of turning call-by-reference into call-by-value. Otherwise a function is
    free to do in-place modifications of <span class="Li">@_</span> and change
    its caller's values.</p>
<p class="Pp"></p>
<pre>
    upcase_in($v1, $v2);  # this changes $v1 and $v2
    sub upcase_in {
        for (@_) { tr/a-z/A-Z/ }
    }
</pre>
<p class="Pp">You aren't allowed to modify constants in this way, of course. If
    an argument were actually literal and you tried to change it, you'd take a
    (presumably fatal) exception. For example, this won't work:</p>
<p class="Pp"></p>
<pre>
    upcase_in(&quot;frederick&quot;);
</pre>
<p class="Pp">It would be much safer if the
    <span class="Li">&quot;upcase_in()&quot;</span> function were written to
    return a copy of its parameters instead of changing them in place:</p>
<p class="Pp"></p>
<pre>
    ($v3, $v4) = upcase($v1, $v2);  # this doesn't change $v1 and $v2
    sub upcase {
        return unless defined wantarray;  # void context, do nothing
        my @parms = @_;
        for (@parms) { tr/a-z/A-Z/ }
        return wantarray ? @parms : $parms[0];
    }
</pre>
<p class="Pp">Notice how this (unprototyped) function doesn't care whether it
    was passed real scalars or arrays. Perl sees all arguments as one big, long,
    flat parameter list in <span class="Li">@_</span>. This is one area where
    Perl's simple argument-passing style shines. The
    <span class="Li">&quot;upcase()&quot;</span> function would work perfectly
    well without changing the <span class="Li">&quot;upcase()&quot;</span>
    definition even if we fed it things like this:</p>
<p class="Pp"></p>
<pre>
    @newlist   = upcase(@list1, @list2);
    @newlist   = upcase( split /:/, $var );
</pre>
<p class="Pp">Do not, however, be tempted to do this:</p>
<p class="Pp"></p>
<pre>
    (@a, @b)   = upcase(@list1, @list2);
</pre>
<p class="Pp">Like the flattened incoming parameter list, the return list is
    also flattened on return. So all you have managed to do here is stored
    everything in <span class="Li">@a</span> and made <span class="Li">@b</span>
    empty. See &quot;Pass by Reference&quot; for alternatives.</p>
<p class="Pp">A subroutine may be called using an explicit
    <span class="Li">&quot;&amp;&quot;</span> prefix. The
    <span class="Li">&quot;&amp;&quot;</span> is optional in modern Perl, as are
    parentheses if the subroutine has been predeclared. The
    <span class="Li">&quot;&amp;&quot;</span> is <i>not</i> optional when just
    naming the subroutine, such as when it's used as an argument to
    <b>defined()</b> or <b>undef()</b>. Nor is it optional when you want to do
    an indirect subroutine call with a subroutine name or reference using the
    <span class="Li">&quot;&amp;$subref()&quot;</span> or
    <span class="Li">&quot;&amp;{$subref}()&quot;</span> constructs, although
    the <span class="Li">&quot;$subref-&gt;()&quot;</span> notation solves that
    problem. See perlref for more about all that.</p>
<p class="Pp">Subroutines may be called recursively. If a subroutine is called
    using the <span class="Li">&quot;&amp;&quot;</span> form, the argument list
    is optional, and if omitted, no <span class="Li">@_</span> array is set up
    for the subroutine: the <span class="Li">@_</span> array at the time of the
    call is visible to subroutine instead. This is an efficiency mechanism that
    new users may wish to avoid.</p>
<p class="Pp"></p>
<pre>
    &amp;foo(1,2,3);        # pass three arguments
    foo(1,2,3);         # the same

    foo();              # pass a null list
    &amp;foo();             # the same

    &amp;foo;               # foo() get current args, like foo(@_) !!
    foo;                # like foo() IFF sub foo predeclared, else &quot;foo&quot;
</pre>
<p class="Pp">Not only does the <span class="Li">&quot;&amp;&quot;</span> form
    make the argument list optional, it also disables any prototype checking on
    arguments you do provide. This is partly for historical reasons, and partly
    for having a convenient way to cheat if you know what you're doing. See
    &quot;Prototypes&quot; below.</p>
<p class="Pp">Since Perl 5.16.0, the <span class="Li">&quot;__SUB__&quot;</span>
    token is available under <span class="Li">&quot;use feature</span>
    <span class="Li">'current_sub'&quot;</span> and <span class="Li">&quot;use
    5.16.0&quot;</span>. It will evaluate to a reference to the
    currently-running sub, which allows for recursive calls without knowing your
    subroutine's name.</p>
<p class="Pp"></p>
<pre>
    use 5.16.0;
    my $factorial = sub {
      my ($x) = @_;
      return 1 if $x == 1;
      return($x * __SUB__-&gt;( $x - 1 ) );
    };
</pre>
<p class="Pp">The behavior of <span class="Li">&quot;__SUB__&quot;</span> within
    a regex code block (such as <span class="Li">&quot;/(?{...})/&quot;</span>)
    is subject to change.</p>
<p class="Pp">Subroutines whose names are in all upper case are reserved to the
    Perl core, as are modules whose names are in all lower case. A subroutine in
    all capitals is a loosely-held convention meaning it will be called
    indirectly by the run-time system itself, usually due to a triggered event.
    Subroutines whose name start with a left parenthesis are also reserved the
    same way. The following is a list of some subroutines that currently do
    special, pre-defined things.</p>
<dl class="Bl-tag">
  <dt id="documented"><a class="permalink" href="#documented">documented later
    in this document</a></dt>
  <dd><span class="Li">&quot;AUTOLOAD&quot;</span></dd>
  <dt id="documented~2"><a class="permalink" href="#documented~2">documented in
    perlmod</a></dt>
  <dd><span class="Li">&quot;CLONE&quot;</span>,
      <span class="Li">&quot;CLONE_SKIP&quot;</span></dd>
  <dt id="documented~3"><a class="permalink" href="#documented~3">documented in
    perlobj</a></dt>
  <dd><span class="Li">&quot;DESTROY&quot;</span>,
      <span class="Li">&quot;DOES&quot;</span></dd>
  <dt id="documented~4"><a class="permalink" href="#documented~4">documented in
    perltie</a></dt>
  <dd><span class="Li">&quot;BINMODE&quot;</span>,
      <span class="Li">&quot;CLEAR&quot;</span>,
      <span class="Li">&quot;CLOSE&quot;</span>,
      <span class="Li">&quot;DELETE&quot;</span>,
      <span class="Li">&quot;DESTROY&quot;</span>,
      <span class="Li">&quot;EOF&quot;</span>,
      <span class="Li">&quot;EXISTS&quot;</span>,
      <span class="Li">&quot;EXTEND&quot;</span>,
      <span class="Li">&quot;FETCH&quot;</span>,
      <span class="Li">&quot;FETCHSIZE&quot;</span>,
      <span class="Li">&quot;FILENO&quot;</span>,
      <span class="Li">&quot;FIRSTKEY&quot;</span>,
      <span class="Li">&quot;GETC&quot;</span>,
      <span class="Li">&quot;NEXTKEY&quot;</span>,
      <span class="Li">&quot;OPEN&quot;</span>,
      <span class="Li">&quot;POP&quot;</span>,
      <span class="Li">&quot;PRINT&quot;</span>,
      <span class="Li">&quot;PRINTF&quot;</span>,
      <span class="Li">&quot;PUSH&quot;</span>,
      <span class="Li">&quot;READ&quot;</span>,
      <span class="Li">&quot;READLINE&quot;</span>,
      <span class="Li">&quot;SCALAR&quot;</span>,
      <span class="Li">&quot;SEEK&quot;</span>,
      <span class="Li">&quot;SHIFT&quot;</span>,
      <span class="Li">&quot;SPLICE&quot;</span>,
      <span class="Li">&quot;STORE&quot;</span>,
      <span class="Li">&quot;STORESIZE&quot;</span>,
      <span class="Li">&quot;TELL&quot;</span>,
      <span class="Li">&quot;TIEARRAY&quot;</span>,
      <span class="Li">&quot;TIEHANDLE&quot;</span>,
      <span class="Li">&quot;TIEHASH&quot;</span>,
      <span class="Li">&quot;TIESCALAR&quot;</span>,
      <span class="Li">&quot;UNSHIFT&quot;</span>,
      <span class="Li">&quot;UNTIE&quot;</span>,
      <span class="Li">&quot;WRITE&quot;</span></dd>
  <dt id="documented~5"><a class="permalink" href="#documented~5">documented in
    PerlIO::via</a></dt>
  <dd><span class="Li">&quot;BINMODE&quot;</span>,
      <span class="Li">&quot;CLEARERR&quot;</span>,
      <span class="Li">&quot;CLOSE&quot;</span>,
      <span class="Li">&quot;EOF&quot;</span>,
      <span class="Li">&quot;ERROR&quot;</span>,
      <span class="Li">&quot;FDOPEN&quot;</span>,
      <span class="Li">&quot;FILENO&quot;</span>,
      <span class="Li">&quot;FILL&quot;</span>,
      <span class="Li">&quot;FLUSH&quot;</span>,
      <span class="Li">&quot;OPEN&quot;</span>,
      <span class="Li">&quot;POPPED&quot;</span>,
      <span class="Li">&quot;PUSHED&quot;</span>,
      <span class="Li">&quot;READ&quot;</span>,
      <span class="Li">&quot;SEEK&quot;</span>,
      <span class="Li">&quot;SETLINEBUF&quot;</span>,
      <span class="Li">&quot;SYSOPEN&quot;</span>,
      <span class="Li">&quot;TELL&quot;</span>,
      <span class="Li">&quot;UNREAD&quot;</span>,
      <span class="Li">&quot;UTF8&quot;</span>,
      <span class="Li">&quot;WRITE&quot;</span></dd>
  <dt id="documented~6"><a class="permalink" href="#documented~6">documented in
    perlfunc</a></dt>
  <dd><span class="Li">&quot;import&quot;</span> ,
      <span class="Li">&quot;unimport&quot;</span> ,
      <span class="Li">&quot;INC&quot;</span></dd>
  <dt id="documented~7"><a class="permalink" href="#documented~7">documented in
    UNIVERSAL</a></dt>
  <dd><span class="Li">&quot;VERSION&quot;</span></dd>
  <dt id="documented~8"><a class="permalink" href="#documented~8">documented in
    perldebguts</a></dt>
  <dd><span class="Li">&quot;DB::DB&quot;</span>,
      <span class="Li">&quot;DB::sub&quot;</span>,
      <span class="Li">&quot;DB::lsub&quot;</span>,
      <span class="Li">&quot;DB::goto&quot;</span>,
      <span class="Li">&quot;DB::postponed&quot;</span></dd>
  <dt id="undocumented,"><a class="permalink" href="#undocumented,">undocumented,
    used internally by the overload feature</a></dt>
  <dd>any starting with <span class="Li">&quot;(&quot;</span></dd>
</dl>
<p class="Pp">The <span class="Li">&quot;BEGIN&quot;</span>,
    <span class="Li">&quot;UNITCHECK&quot;</span>,
    <span class="Li">&quot;CHECK&quot;</span>,
    <span class="Li">&quot;INIT&quot;</span> and
    <span class="Li">&quot;END&quot;</span> subroutines are not so much
    subroutines as named special code blocks, of which you can have more than
    one in a package, and which you can <b>not</b> call explicitly. See
    &quot;BEGIN, UNITCHECK, CHECK, INIT and END&quot; in perlmod</p>
<section class="Ss">
<h2 class="Ss" id="Signatures"><a class="permalink" href="#Signatures">Signatures</a></h2>
<p class="Pp"><b>WARNING</b>: Subroutine signatures are experimental. The
    feature may be modified or removed in future versions of Perl.</p>
<p class="Pp">Perl has an experimental facility to allow a subroutine's formal
    parameters to be introduced by special syntax, separate from the procedural
    code of the subroutine body. The formal parameter list is known as a
    <i>signature</i>. The facility must be enabled first by a pragmatic
    declaration, <span class="Li">&quot;use feature 'signatures'&quot;</span>,
    and it will produce a warning unless the
    &quot;experimental::signatures&quot; warnings category is disabled.</p>
<p class="Pp">The signature is part of a subroutine's body. Normally the body of
    a subroutine is simply a braced block of code, but when using a signature,
    the signature is a parenthesised list that goes immediately before the
    block, after any name or attributes.</p>
<p class="Pp">For example,</p>
<p class="Pp"></p>
<pre>
    sub foo :lvalue ($a, $b = 1, @c) { .... }
</pre>
<p class="Pp">The signature declares lexical variables that are in scope for the
    block. When the subroutine is called, the signature takes control first. It
    populates the signature variables from the list of arguments that were
    passed. If the argument list doesn't meet the requirements of the signature,
    then it will throw an exception. When the signature processing is complete,
    control passes to the block.</p>
<p class="Pp">Positional parameters are handled by simply naming scalar
    variables in the signature. For example,</p>
<p class="Pp"></p>
<pre>
    sub foo ($left, $right) {
        return $left + $right;
    }
</pre>
<p class="Pp">takes two positional parameters, which must be filled at runtime
    by two arguments. By default the parameters are mandatory, and it is not
    permitted to pass more arguments than expected. So the above is equivalent
    to</p>
<p class="Pp"></p>
<pre>
    sub foo {
        die &quot;Too many arguments for subroutine&quot; unless @_ &lt;= 2;
        die &quot;Too few arguments for subroutine&quot; unless @_ &gt;= 2;
        my $left = $_[0];
        my $right = $_[1];
        return $left + $right;
    }
</pre>
<p class="Pp">An argument can be ignored by omitting the main part of the name
    from a parameter declaration, leaving just a bare
    <span class="Li">&quot;$&quot;</span> sigil. For example,</p>
<p class="Pp"></p>
<pre>
    sub foo ($first, $, $third) {
        return &quot;first=$first, third=$third&quot;;
    }
</pre>
<p class="Pp">Although the ignored argument doesn't go into a variable, it is
    still mandatory for the caller to pass it.</p>
<p class="Pp">A positional parameter is made optional by giving a default value,
    separated from the parameter name by
  <span class="Li">&quot;=&quot;</span>:</p>
<p class="Pp"></p>
<pre>
    sub foo ($left, $right = 0) {
        return $left + $right;
    }
</pre>
<p class="Pp">The above subroutine may be called with either one or two
    arguments. The default value expression is evaluated when the subroutine is
    called, so it may provide different default values for different calls. It
    is only evaluated if the argument was actually omitted from the call. For
    example,</p>
<p class="Pp"></p>
<pre>
    my $auto_id = 0;
    sub foo ($thing, $id = $auto_id++) {
        print &quot;$thing has ID $id&quot;;
    }
</pre>
<p class="Pp">automatically assigns distinct sequential IDs to things for which
    no ID was supplied by the caller. A default value expression may also refer
    to parameters earlier in the signature, making the default for one parameter
    vary according to the earlier parameters. For example,</p>
<p class="Pp"></p>
<pre>
    sub foo ($first_name, $surname, $nickname = $first_name) {
        print &quot;$first_name $surname is known as \&quot;$nickname\&quot;&quot;;
    }
</pre>
<p class="Pp">An optional parameter can be nameless just like a mandatory
    parameter. For example,</p>
<p class="Pp"></p>
<pre>
    sub foo ($thing, $ = 1) {
        print $thing;
    }
</pre>
<p class="Pp">The parameter's default value will still be evaluated if the
    corresponding argument isn't supplied, even though the value won't be stored
    anywhere. This is in case evaluating it has important side effects. However,
    it will be evaluated in void context, so if it doesn't have side effects and
    is not trivial it will generate a warning if the &quot;void&quot; warning
    category is enabled. If a nameless optional parameter's default value is not
    important, it may be omitted just as the parameter's name was:</p>
<p class="Pp"></p>
<pre>
    sub foo ($thing, $=) {
        print $thing;
    }
</pre>
<p class="Pp">Optional positional parameters must come after all mandatory
    positional parameters. (If there are no mandatory positional parameters then
    an optional positional parameters can be the first thing in the signature.)
    If there are multiple optional positional parameters and not enough
    arguments are supplied to fill them all, they will be filled from left to
    right.</p>
<p class="Pp">After positional parameters, additional arguments may be captured
    in a slurpy parameter. The simplest form of this is just an array
  variable:</p>
<p class="Pp"></p>
<pre>
    sub foo ($filter, @inputs) {
        print $filter-&gt;($_) foreach @inputs;
    }
</pre>
<p class="Pp">With a slurpy parameter in the signature, there is no upper limit
    on how many arguments may be passed. A slurpy array parameter may be
    nameless just like a positional parameter, in which case its only effect is
    to turn off the argument limit that would otherwise apply:</p>
<p class="Pp"></p>
<pre>
    sub foo ($thing, @) {
        print $thing;
    }
</pre>
<p class="Pp">A slurpy parameter may instead be a hash, in which case the
    arguments available to it are interpreted as alternating keys and values.
    There must be as many keys as values: if there is an odd argument then an
    exception will be thrown. Keys will be stringified, and if there are
    duplicates then the later instance takes precedence over the earlier, as
    with standard hash construction.</p>
<p class="Pp"></p>
<pre>
    sub foo ($filter, %inputs) {
        print $filter-&gt;($_, $inputs{$_}) foreach sort keys %inputs;
    }
</pre>
<p class="Pp">A slurpy hash parameter may be nameless just like other kinds of
    parameter. It still insists that the number of arguments available to it be
    even, even though they're not being put into a variable.</p>
<p class="Pp"></p>
<pre>
    sub foo ($thing, %) {
        print $thing;
    }
</pre>
<p class="Pp">A slurpy parameter, either array or hash, must be the last thing
    in the signature. It may follow mandatory and optional positional
    parameters; it may also be the only thing in the signature. Slurpy
    parameters cannot have default values: if no arguments are supplied for them
    then you get an empty array or empty hash.</p>
<p class="Pp">A signature may be entirely empty, in which case all it does is
    check that the caller passed no arguments:</p>
<p class="Pp"></p>
<pre>
    sub foo () {
        return 123;
    }
</pre>
<p class="Pp">When using a signature, the arguments are still available in the
    special array variable <span class="Li">@_</span>, in addition to the
    lexical variables of the signature. There is a difference between the two
    ways of accessing the arguments: <span class="Li">@_</span> <i>aliases</i>
    the arguments, but the signature variables get <i>copies</i> of the
    arguments. So writing to a signature variable only changes that variable,
    and has no effect on the caller's variables, but writing to an element of
    <span class="Li">@_</span> modifies whatever the caller used to supply that
    argument.</p>
<p class="Pp">There is a potential syntactic ambiguity between signatures and
    prototypes (see &quot;Prototypes&quot;), because both start with an opening
    parenthesis and both can appear in some of the same places, such as just
    after the name in a subroutine declaration. For historical reasons, when
    signatures are not enabled, any opening parenthesis in such a context will
    trigger very forgiving prototype parsing. Most signatures will be
    interpreted as prototypes in those circumstances, but won't be valid
    prototypes. (A valid prototype cannot contain any alphabetic character.)
    This will lead to somewhat confusing error messages.</p>
<p class="Pp">To avoid ambiguity, when signatures are enabled the special syntax
    for prototypes is disabled. There is no attempt to guess whether a
    parenthesised group was intended to be a prototype or a signature. To give a
    subroutine a prototype under these circumstances, use a prototype attribute.
    For example,</p>
<p class="Pp"></p>
<pre>
    sub foo :prototype($) { $_[0] }
</pre>
<p class="Pp">It is entirely possible for a subroutine to have both a prototype
    and a signature. They do different jobs: the prototype affects compilation
    of calls to the subroutine, and the signature puts argument values into
    lexical variables at runtime. You can therefore write</p>
<p class="Pp"></p>
<pre>
    sub foo :prototype($$) ($left, $right) {
        return $left + $right;
    }
</pre>
<p class="Pp">The prototype attribute, and any other attributes, must come
    before the signature. The signature always immediately precedes the block of
    the subroutine's body.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Private_Variables_via_"><a class="permalink" href="#Private_Variables_via_">Private
  Variables via <b>my()</b></a></h2>
<p class="Pp">Synopsis:</p>
<p class="Pp"></p>
<pre>
    my $foo;            # declare $foo lexically local
    my (@wid, %get);    # declare list of variables local
    my $foo = &quot;flurp&quot;;  # declare $foo lexical, and init it
    my @oof = @bar;     # declare @oof lexical, and init it
    my $x : Foo = $y;   # similar, with an attribute applied
</pre>
<p class="Pp"><b>WARNING</b>: The use of attribute lists on
    <span class="Li">&quot;my&quot;</span> declarations is still evolving. The
    current semantics and interface are subject to change. See attributes and
    Attribute::Handlers.</p>
<p class="Pp">The <span class="Li">&quot;my&quot;</span> operator declares the
    listed variables to be lexically confined to the enclosing block,
    conditional
    (<span class="Li">&quot;if&quot;</span>/<span class="Li">&quot;unless&quot;</span>/<span class="Li">&quot;elsif&quot;</span>/<span class="Li">&quot;else&quot;</span>),
    loop
    (<span class="Li">&quot;for&quot;</span>/<span class="Li">&quot;foreach&quot;</span>/<span class="Li">&quot;while&quot;</span>/<span class="Li">&quot;until&quot;</span>/<span class="Li">&quot;continue&quot;</span>),
    subroutine, <span class="Li">&quot;eval&quot;</span>, or
    <span class="Li">&quot;do&quot;</span>/<span class="Li">&quot;require&quot;</span>/<span class="Li">&quot;use&quot;</span>'d
    file. If more than one value is listed, the list must be placed in
    parentheses. All listed elements must be legal lvalues. Only alphanumeric
    identifiers may be lexically scoped--magical built-ins like
    <span class="Li">$/</span> must currently be
    <span class="Li">&quot;local&quot;</span>ized with
    <span class="Li">&quot;local&quot;</span> instead.</p>
<p class="Pp">Unlike dynamic variables created by the
    <span class="Li">&quot;local&quot;</span> operator, lexical variables
    declared with <span class="Li">&quot;my&quot;</span> are totally hidden from
    the outside world, including any called subroutines. This is true if it's
    the same subroutine called from itself or elsewhere--every call gets its own
    copy.</p>
<p class="Pp">This doesn't mean that a <span class="Li">&quot;my&quot;</span>
    variable declared in a statically enclosing lexical scope would be
    invisible. Only dynamic scopes are cut off. For example, the
    <span class="Li">&quot;bumpx()&quot;</span> function below has access to the
    lexical <span class="Li">$x</span> variable because both the
    <span class="Li">&quot;my&quot;</span> and the
    <span class="Li">&quot;sub&quot;</span> occurred at the same scope,
    presumably file scope.</p>
<p class="Pp"></p>
<pre>
    my $x = 10;
    sub bumpx { $x++ }
</pre>
<p class="Pp">An <span class="Li">&quot;eval()&quot;</span>, however, can see
    lexical variables of the scope it is being evaluated in, so long as the
    names aren't hidden by declarations within the
    <span class="Li">&quot;eval()&quot;</span> itself. See perlref.</p>
<p class="Pp">The parameter list to <b>my()</b> may be assigned to if desired,
    which allows you to initialize your variables. (If no initializer is given
    for a particular variable, it is created with the undefined value.) Commonly
    this is used to name input parameters to a subroutine. Examples:</p>
<p class="Pp"></p>
<pre>
    $arg = &quot;fred&quot;;        # &quot;global&quot; variable
    $n = cube_root(27);
    print &quot;$arg thinks the root is $n\n&quot;;
 fred thinks the root is 3

    sub cube_root {
        my $arg = shift;  # name doesn't matter
        $arg **= 1/3;
        return $arg;
    }
</pre>
<p class="Pp">The <span class="Li">&quot;my&quot;</span> is simply a modifier on
    something you might assign to. So when you do assign to variables in its
    argument list, <span class="Li">&quot;my&quot;</span> doesn't change whether
    those variables are viewed as a scalar or an array. So</p>
<p class="Pp"></p>
<pre>
    my ($foo) = &lt;STDIN&gt;;                # WRONG?
    my @FOO = &lt;STDIN&gt;;
</pre>
<p class="Pp">both supply a list context to the right-hand side, while</p>
<p class="Pp"></p>
<pre>
    my $foo = &lt;STDIN&gt;;
</pre>
<p class="Pp">supplies a scalar context. But the following declares only one
    variable:</p>
<p class="Pp"></p>
<pre>
    my $foo, $bar = 1;                  # WRONG
</pre>
<p class="Pp">That has the same effect as</p>
<p class="Pp"></p>
<pre>
    my $foo;
    $bar = 1;
</pre>
<p class="Pp">The declared variable is not introduced (is not visible) until
    after the current statement. Thus,</p>
<p class="Pp"></p>
<pre>
    my $x = $x;
</pre>
<p class="Pp">can be used to initialize a new <span class="Li">$x</span> with
    the value of the old <span class="Li">$x</span>, and the expression</p>
<p class="Pp"></p>
<pre>
    my $x = 123 and $x == 123
</pre>
<p class="Pp">is false unless the old <span class="Li">$x</span> happened to
    have the value <span class="Li">123</span>.</p>
<p class="Pp">Lexical scopes of control structures are not bounded precisely by
    the braces that delimit their controlled blocks; control expressions are
    part of that scope, too. Thus in the loop</p>
<p class="Pp"></p>
<pre>
    while (my $line = &lt;&gt;) {
        $line = lc $line;
    } continue {
        print $line;
    }
</pre>
<p class="Pp">the scope of <span class="Li">$line</span> extends from its
    declaration throughout the rest of the loop construct (including the
    <span class="Li">&quot;continue&quot;</span> clause), but not beyond it.
    Similarly, in the conditional</p>
<p class="Pp"></p>
<pre>
    if ((my $answer = &lt;STDIN&gt;) =~ /^yes$/i) {
        user_agrees();
    } elsif ($answer =~ /^no$/i) {
        user_disagrees();
    } else {
        chomp $answer;
        die &quot;'$answer' is neither 'yes' nor 'no'&quot;;
    }
</pre>
<p class="Pp">the scope of <span class="Li">$answer</span> extends from its
    declaration through the rest of that conditional, including any
    <span class="Li">&quot;elsif&quot;</span> and
    <span class="Li">&quot;else&quot;</span> clauses, but not beyond it. See
    &quot;Simple Statements&quot; in perlsyn for information on the scope of
    variables in statements with modifiers.</p>
<p class="Pp">The <span class="Li">&quot;foreach&quot;</span> loop defaults to
    scoping its index variable dynamically in the manner of
    <span class="Li">&quot;local&quot;</span>. However, if the index variable is
    prefixed with the keyword <span class="Li">&quot;my&quot;</span>, or if
    there is already a lexical by that name in scope, then a new lexical is
    created instead. Thus in the loop</p>
<p class="Pp"></p>
<pre>
    for my $i (1, 2, 3) {
        some_function();
    }
</pre>
<p class="Pp">the scope of <span class="Li">$i</span> extends to the end of the
    loop, but not beyond it, rendering the value of <span class="Li">$i</span>
    inaccessible within <span class="Li">&quot;some_function()&quot;</span>.</p>
<p class="Pp">Some users may wish to encourage the use of lexically scoped
    variables. As an aid to catching implicit uses to package variables, which
    are always global, if you say</p>
<p class="Pp"></p>
<pre>
    use strict 'vars';
</pre>
<p class="Pp">then any variable mentioned from there to the end of the enclosing
    block must either refer to a lexical variable, be predeclared via
    <span class="Li">&quot;our&quot;</span> or <span class="Li">&quot;use
    vars&quot;</span>, or else must be fully qualified with the package name. A
    compilation error results otherwise. An inner block may countermand this
    with <span class="Li">&quot;no strict 'vars'&quot;</span>.</p>
<p class="Pp">A <span class="Li">&quot;my&quot;</span> has both a compile-time
    and a run-time effect. At compile time, the compiler takes notice of it. The
    principal usefulness of this is to quiet <span class="Li">&quot;use strict
    'vars'&quot;</span>, but it is also essential for generation of closures as
    detailed in perlref. Actual initialization is delayed until run time,
    though, so it gets executed at the appropriate time, such as each time
    through a loop, for example.</p>
<p class="Pp">Variables declared with <span class="Li">&quot;my&quot;</span> are
    not part of any package and are therefore never fully qualified with the
    package name. In particular, you're not allowed to try to make a package
    variable (or other global) lexical:</p>
<p class="Pp"></p>
<pre>
    my $pack::var;      # ERROR!  Illegal syntax
</pre>
<p class="Pp">In fact, a dynamic variable (also known as package or global
    variables) are still accessible using the fully qualified
    <span class="Li">&quot;::&quot;</span> notation even while a lexical of the
    same name is also visible:</p>
<p class="Pp"></p>
<pre>
    package main;
    local $x = 10;
    my    $x = 20;
    print &quot;$x and $::x\n&quot;;
</pre>
<p class="Pp">That will print out <span class="Li">20</span> and
    <span class="Li">10</span>.</p>
<p class="Pp">You may declare <span class="Li">&quot;my&quot;</span> variables
    at the outermost scope of a file to hide any such identifiers from the world
    outside that file. This is similar in spirit to C's static variables when
    they are used at the file level. To do this with a subroutine requires the
    use of a closure (an anonymous function that accesses enclosing lexicals).
    If you want to create a private subroutine that cannot be called from
    outside that block, it can declare a lexical variable containing an
    anonymous sub reference:</p>
<p class="Pp"></p>
<pre>
    my $secret_version = '1.001-beta';
    my $secret_sub = sub { print $secret_version };
    &amp;$secret_sub();
</pre>
<p class="Pp">As long as the reference is never returned by any function within
    the module, no outside module can see the subroutine, because its name is
    not in any package's symbol table. Remember that it's not <i>REALLY</i>
    called <span class="Li">$some_pack::secret_version</span> or anything; it's
    just <span class="Li">$secret_version</span>, unqualified and
  unqualifiable.</p>
<p class="Pp">This does not work with object methods, however; all object
    methods have to be in the symbol table of some package to be found. See
    &quot;Function Templates&quot; in perlref for something of a work-around to
    this.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Persistent_Private_Variables"><a class="permalink" href="#Persistent_Private_Variables">Persistent
  Private Variables</a></h2>
<p class="Pp">There are two ways to build persistent private variables in Perl
    5.10. First, you can simply use the
    <span class="Li">&quot;state&quot;</span> feature. Or, you can use closures,
    if you want to stay compatible with releases older than 5.10.</p>
<p class="Pp"><i>Persistent variables via </i><b><i>state()</i></b><i></i></p>
<p class="Pp">Beginning with Perl 5.10.0, you can declare variables with the
    <span class="Li">&quot;state&quot;</span> keyword in place of
    <span class="Li">&quot;my&quot;</span>. For that to work, though, you must
    have enabled that feature beforehand, either by using the
    <span class="Li">&quot;feature&quot;</span> pragma, or by using
    <span class="Li">&quot;-E&quot;</span> on one-liners (see feature).
    Beginning with Perl 5.16, the
    <span class="Li">&quot;CORE::state&quot;</span> form does not require the
    <span class="Li">&quot;feature&quot;</span> pragma.</p>
<p class="Pp">The <span class="Li">&quot;state&quot;</span> keyword creates a
    lexical variable (following the same scoping rules as
    <span class="Li">&quot;my&quot;</span>) that persists from one subroutine
    call to the next. If a state variable resides inside an anonymous
    subroutine, then each copy of the subroutine has its own copy of the state
    variable. However, the value of the state variable will still persist
    between calls to the same copy of the anonymous subroutine. (Don't forget
    that <span class="Li">&quot;sub { ... }&quot;</span> creates a new
    subroutine each time it is executed.)</p>
<p class="Pp">For example, the following code maintains a private counter,
    incremented each time the <b>gimme_another()</b> function is called:</p>
<p class="Pp"></p>
<pre>
    use feature 'state';
    sub gimme_another { state $x; return ++$x }
</pre>
<p class="Pp">And this example uses anonymous subroutines to create separate
    counters:</p>
<p class="Pp"></p>
<pre>
    use feature 'state';
    sub create_counter {
        return sub { state $x; return ++$x }
    }
</pre>
<p class="Pp">Also, since <span class="Li">$x</span> is lexical, it can't be
    reached or modified by any Perl code outside.</p>
<p class="Pp">When combined with variable declaration, simple assignment to
    <span class="Li">&quot;state&quot;</span> variables (as in
    <span class="Li">&quot;state $x = 42&quot;</span>) is executed only the
    first time. When such statements are evaluated subsequent times, the
    assignment is ignored. The behavior of assignment to
    <span class="Li">&quot;state&quot;</span> declarations where the left hand
    side of the assignment involves any parentheses is currently undefined.</p>
<p class="Pp"><i>Persistent variables with closures</i></p>
<p class="Pp">Just because a lexical variable is lexically (also called
    statically) scoped to its enclosing block,
    <span class="Li">&quot;eval&quot;</span>, or
    <span class="Li">&quot;do&quot;</span> FILE, this doesn't mean that within a
    function it works like a C static. It normally works more like a C auto, but
    with implicit garbage collection.</p>
<p class="Pp">Unlike local variables in C or C++, Perl's lexical variables don't
    necessarily get recycled just because their scope has exited. If something
    more permanent is still aware of the lexical, it will stick around. So long
    as something else references a lexical, that lexical won't be freed--which
    is as it should be. You wouldn't want memory being free until you were done
    using it, or kept around once you were done. Automatic garbage collection
    takes care of this for you.</p>
<p class="Pp">This means that you can pass back or save away references to
    lexical variables, whereas to return a pointer to a C auto is a grave error.
    It also gives us a way to simulate C's function statics. Here's a mechanism
    for giving a function private variables with both lexical scoping and a
    static lifetime. If you do want to create something like C's static
    variables, just enclose the whole function in an extra block, and put the
    static variable outside the function but in the block.</p>
<p class="Pp"></p>
<pre>
    {
        my $secret_val = 0;
        sub gimme_another {
            return ++$secret_val;
        }
    }
    # $secret_val now becomes unreachable by the outside
    # world, but retains its value between calls to gimme_another
</pre>
<p class="Pp">If this function is being sourced in from a separate file via
    <span class="Li">&quot;require&quot;</span> or
    <span class="Li">&quot;use&quot;</span>, then this is probably just fine. If
    it's all in the main program, you'll need to arrange for the
    <span class="Li">&quot;my&quot;</span> to be executed early, either by
    putting the whole block above your main program, or more likely, placing
    merely a <span class="Li">&quot;BEGIN&quot;</span> code block around it to
    make sure it gets executed before your program starts to run:</p>
<p class="Pp"></p>
<pre>
    BEGIN {
        my $secret_val = 0;
        sub gimme_another {
            return ++$secret_val;
        }
    }
</pre>
<p class="Pp">See &quot;BEGIN, UNITCHECK, CHECK, INIT and END&quot; in perlmod
    about the special triggered code blocks,
    <span class="Li">&quot;BEGIN&quot;</span>,
    <span class="Li">&quot;UNITCHECK&quot;</span>,
    <span class="Li">&quot;CHECK&quot;</span>,
    <span class="Li">&quot;INIT&quot;</span> and
    <span class="Li">&quot;END&quot;</span>.</p>
<p class="Pp">If declared at the outermost scope (the file scope), then lexicals
    work somewhat like C's file statics. They are available to all functions in
    that same file declared below them, but are inaccessible from outside that
    file. This strategy is sometimes used in modules to create private variables
    that the whole module can see.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Temporary_Values_via_"><a class="permalink" href="#Temporary_Values_via_">Temporary
  Values via <b>local()</b></a></h2>
<p class="Pp"><b>WARNING</b>: In general, you should be using
    <span class="Li">&quot;my&quot;</span> instead of
    <span class="Li">&quot;local&quot;</span>, because it's faster and safer.
    Exceptions to this include the global punctuation variables, global
    filehandles and formats, and direct manipulation of the Perl symbol table
    itself. <span class="Li">&quot;local&quot;</span> is mostly used when the
    current value of a variable must be visible to called subroutines.</p>
<p class="Pp">Synopsis:</p>
<p class="Pp"></p>
<pre>
    # localization of values

    local $foo;                # make $foo dynamically local
    local (@wid, %get);        # make list of variables local
    local $foo = &quot;flurp&quot;;      # make $foo dynamic, and init it
    local @oof = @bar;         # make @oof dynamic, and init it

    local $hash{key} = &quot;val&quot;;  # sets a local value for this hash entry
    delete local $hash{key};   # delete this entry for the current block
    local ($cond ? $v1 : $v2); # several types of lvalues support
                               # localization

    # localization of symbols

    local *FH;                 # localize $FH, @FH, %FH, &amp;FH  ...
    local *merlyn = *randal;   # now $merlyn is really $randal, plus
                               #     @merlyn is really @randal, etc
    local *merlyn = 'randal';  # SAME THING: promote 'randal' to *randal
    local *merlyn = \$randal;  # just alias $merlyn, not @merlyn etc
</pre>
<p class="Pp">A <span class="Li">&quot;local&quot;</span> modifies its listed
    variables to be &quot;local&quot; to the enclosing block,
    <span class="Li">&quot;eval&quot;</span>, or <span class="Li">&quot;do
    FILE&quot;</span>--and to <i>any subroutine</i> <i>called from within that
    block</i>. A <span class="Li">&quot;local&quot;</span> just gives temporary
    values to global (meaning package) variables. It does <i>not</i> create a
    local variable. This is known as dynamic scoping. Lexical scoping is done
    with <span class="Li">&quot;my&quot;</span>, which works more like C's auto
    declarations.</p>
<p class="Pp">Some types of lvalues can be localized as well: hash and array
    elements and slices, conditionals (provided that their result is always
    localizable), and symbolic references. As for simple variables, this creates
    new, dynamically scoped values.</p>
<p class="Pp">If more than one variable or expression is given to
    <span class="Li">&quot;local&quot;</span>, they must be placed in
    parentheses. This operator works by saving the current values of those
    variables in its argument list on a hidden stack and restoring them upon
    exiting the block, subroutine, or eval. This means that called subroutines
    can also reference the local variable, but not the global one. The argument
    list may be assigned to if desired, which allows you to initialize your
    local variables. (If no initializer is given for a particular variable, it
    is created with an undefined value.)</p>
<p class="Pp">Because <span class="Li">&quot;local&quot;</span> is a run-time
    operator, it gets executed each time through a loop. Consequently, it's more
    efficient to localize your variables outside the loop.</p>
<p class="Pp"><i>Grammatical note on </i><b><i>local()</i></b><i></i></p>
<p class="Pp">A <span class="Li">&quot;local&quot;</span> is simply a modifier
    on an lvalue expression. When you assign to a
    <span class="Li">&quot;local&quot;</span>ized variable, the
    <span class="Li">&quot;local&quot;</span> doesn't change whether its list is
    viewed as a scalar or an array. So</p>
<p class="Pp"></p>
<pre>
    local($foo) = &lt;STDIN&gt;;
    local @FOO = &lt;STDIN&gt;;
</pre>
<p class="Pp">both supply a list context to the right-hand side, while</p>
<p class="Pp"></p>
<pre>
    local $foo = &lt;STDIN&gt;;
</pre>
<p class="Pp">supplies a scalar context.</p>
<p class="Pp"><i>Localization of special variables</i></p>
<p class="Pp">If you localize a special variable, you'll be giving a new value
    to it, but its magic won't go away. That means that all side-effects related
    to this magic still work with the localized value.</p>
<p class="Pp">This feature allows code like this to work :</p>
<p class="Pp"></p>
<pre>
    # Read the whole contents of FILE in $slurp
    { local $/ = undef; $slurp = &lt;FILE&gt;; }
</pre>
<p class="Pp">Note, however, that this restricts localization of some values ;
    for example, the following statement dies, as of perl 5.10.0, with an error
    <i>Modification of a read-only value attempted</i>, because the
    <span class="Li">$1</span> variable is magical and read-only :</p>
<p class="Pp"></p>
<pre>
    local $1 = 2;
</pre>
<p class="Pp">One exception is the default scalar variable: starting with perl
    5.14 <span class="Li">&quot;local($_)&quot;</span> will always strip all
    magic from <span class="Li">$_</span>, to make it possible to safely reuse
    <span class="Li">$_</span> in a subroutine.</p>
<p class="Pp"><b>WARNING</b>: Localization of tied arrays and hashes does not
    currently work as described. This will be fixed in a future release of Perl;
    in the meantime, avoid code that relies on any particular behavior of
    localising tied arrays or hashes (localising individual elements is still
    okay). See &quot;Localising Tied Arrays and Hashes Is Broken&quot; in
    perl58delta for more details.</p>
<p class="Pp"><i>Localization of globs</i></p>
<p class="Pp">The construct</p>
<p class="Pp"></p>
<pre>
    local *name;
</pre>
<p class="Pp">creates a whole new symbol table entry for the glob
    <span class="Li">&quot;name&quot;</span> in the current package. That means
    that all variables in its glob slot ($name, <span class="Li">@name</span>,
    <span class="Li">%name</span>, &amp;name, and the
    <span class="Li">&quot;name&quot;</span> filehandle) are dynamically
  reset.</p>
<p class="Pp">This implies, among other things, that any magic eventually
    carried by those variables is locally lost. In other words, saying
    <span class="Li">&quot;local */&quot;</span> will not have any effect on the
    internal value of the input record separator.</p>
<p class="Pp"><i>Localization of elements of composite types</i></p>
<p class="Pp">It's also worth taking a moment to explain what happens when you
    <span class="Li">&quot;local&quot;</span>ize a member of a composite type
    (i.e. an array or hash element). In this case, the element is
    <span class="Li">&quot;local&quot;</span>ized <i>by name</i>. This means
    that when the scope of the <span class="Li">&quot;local()&quot;</span> ends,
    the saved value will be restored to the hash element whose key was named in
    the <span class="Li">&quot;local()&quot;</span>, or the array element whose
    index was named in the <span class="Li">&quot;local()&quot;</span>. If that
    element was deleted while the <span class="Li">&quot;local()&quot;</span>
    was in effect (e.g. by a <span class="Li">&quot;delete()&quot;</span> from a
    hash or a <span class="Li">&quot;shift()&quot;</span> of an array), it will
    spring back into existence, possibly extending an array and filling in the
    skipped elements with <span class="Li">&quot;undef&quot;</span>. For
    instance, if you say</p>
<p class="Pp"></p>
<pre>
    %hash = ( 'This' =&gt; 'is', 'a' =&gt; 'test' );
    @ary  = ( 0..5 );
    {
         local($ary[5]) = 6;
         local($hash{'a'}) = 'drill';
         while (my $e = pop(@ary)) {
             print &quot;$e . . .\n&quot;;
             last unless $e &gt; 3;
         }
         if (@ary) {
             $hash{'only a'} = 'test';
             delete $hash{'a'};
         }
    }
    print join(' ', map { &quot;$_ $hash{$_}&quot; } sort keys %hash),&quot;.\n&quot;;
    print &quot;The array has &quot;,scalar(@ary),&quot; elements: &quot;,
          join(', ', map { defined $_ ? $_ : 'undef' } @ary),&quot;\n&quot;;
</pre>
<p class="Pp">Perl will print</p>
<p class="Pp"></p>
<pre>
    6 . . .
    4 . . .
    3 . . .
    This is a test only a test.
    The array has 6 elements: 0, 1, 2, undef, undef, 5
</pre>
<p class="Pp">The behavior of <b>local()</b> on non-existent members of
    composite types is subject to change in future. The behavior of
    <b>local()</b> on array elements specified using negative indexes is
    particularly surprising, and is very likely to change.</p>
<p class="Pp"><i>Localized deletion of elements of composite types</i></p>
<p class="Pp">You can use the <span class="Li">&quot;delete local
    $array[$idx]&quot;</span> and <span class="Li">&quot;delete local
    $hash{key}&quot;</span> constructs to delete a composite type entry for the
    current block and restore it when it ends. They return the array/hash value
    before the localization, which means that they are respectively equivalent
    to</p>
<p class="Pp"></p>
<pre>
    do {
        my $val = $array[$idx];
        local  $array[$idx];
        delete $array[$idx];
        $val
    }
</pre>
<p class="Pp">and</p>
<p class="Pp"></p>
<pre>
    do {
        my $val = $hash{key};
        local  $hash{key};
        delete $hash{key};
        $val
    }
</pre>
<p class="Pp">except that for those the
    <span class="Li">&quot;local&quot;</span> is scoped to the
    <span class="Li">&quot;do&quot;</span> block. Slices are also accepted.</p>
<p class="Pp"></p>
<pre>
    my %hash = (
     a =&gt; [ 7, 8, 9 ],
     b =&gt; 1,
    )

    {
     my $a = delete local $hash{a};
     # $a is [ 7, 8, 9 ]
     # %hash is (b =&gt; 1)

     {
      my @nums = delete local @$a[0, 2]
      # @nums is (7, 9)
      # $a is [ undef, 8 ]

      $a[0] = 999; # will be erased when the scope ends
     }
     # $a is back to [ 7, 8, 9 ]

    }
    # %hash is back to its original state
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Lvalue_subroutines"><a class="permalink" href="#Lvalue_subroutines">Lvalue
  subroutines</a></h2>
<p class="Pp">It is possible to return a modifiable value from a subroutine. To
    do this, you have to declare the subroutine to return an lvalue.</p>
<p class="Pp"></p>
<pre>
    my $val;
    sub canmod : lvalue {
        $val;  # or:  return $val;
    }
    sub nomod {
        $val;
    }

    canmod() = 5;   # assigns to $val
    nomod()  = 5;   # ERROR
</pre>
<p class="Pp">The scalar/list context for the subroutine and for the right-hand
    side of assignment is determined as if the subroutine call is replaced by a
    scalar. For example, consider:</p>
<p class="Pp"></p>
<pre>
    data(2,3) = get_data(3,4);
</pre>
<p class="Pp">Both subroutines here are called in a scalar context, while
  in:</p>
<p class="Pp"></p>
<pre>
    (data(2,3)) = get_data(3,4);
</pre>
<p class="Pp">and in:</p>
<p class="Pp"></p>
<pre>
    (data(2),data(3)) = get_data(3,4);
</pre>
<p class="Pp">all the subroutines are called in a list context.</p>
<p class="Pp">Lvalue subroutines are convenient, but you have to keep in mind
    that, when used with objects, they may violate encapsulation. A normal
    mutator can check the supplied argument before setting the attribute it is
    protecting, an lvalue subroutine cannot. If you require any special
    processing when storing and retrieving the values, consider using the CPAN
    module Sentinel or something similar.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Lexical_Subroutines"><a class="permalink" href="#Lexical_Subroutines">Lexical
  Subroutines</a></h2>
<p class="Pp">Beginning with Perl 5.18, you can declare a private subroutine
    with <span class="Li">&quot;my&quot;</span> or
    <span class="Li">&quot;state&quot;</span>. As with state variables, the
    <span class="Li">&quot;state&quot;</span> keyword is only available under
    <span class="Li">&quot;use feature 'state'&quot;</span> or
    <span class="Li">&quot;use 5.010&quot;</span> or higher.</p>
<p class="Pp">Prior to Perl 5.26, lexical subroutines were deemed experimental
    and were available only under the <span class="Li">&quot;use feature
    'lexical_subs'&quot;</span> pragma. They also produced a warning unless the
    &quot;experimental::lexical_subs&quot; warnings category was disabled.</p>
<p class="Pp">These subroutines are only visible within the block in which they
    are declared, and only after that declaration:</p>
<p class="Pp"></p>
<pre>
    # Include these two lines if your code is intended to run under Perl
    # versions earlier than 5.26.
    no warnings &quot;experimental::lexical_subs&quot;;
    use feature 'lexical_subs';

    foo();              # calls the package/global subroutine
    state sub foo {
        foo();          # also calls the package subroutine
    }
    foo();              # calls &quot;state&quot; sub
    my $ref = \&amp;foo;    # take a reference to &quot;state&quot; sub

    my sub bar { ... }
    bar();              # calls &quot;my&quot; sub
</pre>
<p class="Pp">You can't (directly) write a recursive lexical subroutine:</p>
<p class="Pp"></p>
<pre>
    # WRONG
    my sub baz {
        baz();
    }
</pre>
<p class="Pp">This example fails because
    <span class="Li">&quot;baz()&quot;</span> refers to the package/global
    subroutine <span class="Li">&quot;baz&quot;</span>, not the lexical
    subroutine currently being defined.</p>
<p class="Pp">The solution is to use
    <span class="Li">&quot;__SUB__&quot;</span>:</p>
<p class="Pp"></p>
<pre>
    my sub baz {
        __SUB__-&gt;();    # calls itself
    }
</pre>
<p class="Pp">It is possible to predeclare a lexical subroutine. The
    <span class="Li">&quot;sub foo {...}&quot;</span> subroutine definition
    syntax respects any previous <span class="Li">&quot;my sub;&quot;</span> or
    <span class="Li">&quot;state sub;&quot;</span> declaration. Using this to
    define recursive subroutines is a bad idea, however:</p>
<p class="Pp"></p>
<pre>
    my sub baz;         # predeclaration
    sub baz {           # define the &quot;my&quot; sub
        baz();          # WRONG: calls itself, but leaks memory
    }
</pre>
<p class="Pp">Just like <span class="Li">&quot;my $f; $f = sub { $f-&gt;()
    }&quot;</span>, this example leaks memory. The name
    <span class="Li">&quot;baz&quot;</span> is a reference to the subroutine,
    and the subroutine uses the name <span class="Li">&quot;baz&quot;</span>;
    they keep each other alive (see &quot;Circular References&quot; in
  perlref).</p>
<p class="Pp"><i></i><i>&quot;state sub&quot;</i><i> vs </i><i>&quot;my
    sub&quot;</i><i></i></p>
<p class="Pp">What is the difference between &quot;state&quot; subs and
    &quot;my&quot; subs? Each time that execution enters a block when
    &quot;my&quot; subs are declared, a new copy of each sub is created.
    &quot;State&quot; subroutines persist from one execution of the containing
    block to the next.</p>
<p class="Pp">So, in general, &quot;state&quot; subroutines are faster. But
    &quot;my&quot; subs are necessary if you want to create closures:</p>
<p class="Pp"></p>
<pre>
    sub whatever {
        my $x = shift;
        my sub inner {
            ... do something with $x ...
        }
        inner();
    }
</pre>
<p class="Pp">In this example, a new <span class="Li">$x</span> is created when
    <span class="Li">&quot;whatever&quot;</span> is called, and also a new
    <span class="Li">&quot;inner&quot;</span>, which can see the new
    <span class="Li">$x</span>. A &quot;state&quot; sub will only see the
    <span class="Li">$x</span> from the first call to
    <span class="Li">&quot;whatever&quot;</span>.</p>
<p class="Pp"><i></i><i>&quot;our&quot;</i><i> subroutines</i></p>
<p class="Pp">Like <span class="Li">&quot;our $variable&quot;</span>,
    <span class="Li">&quot;our sub&quot;</span> creates a lexical alias to the
    package subroutine of the same name.</p>
<p class="Pp">The two main uses for this are to switch back to using the package
    sub inside an inner scope:</p>
<p class="Pp"></p>
<pre>
    sub foo { ... }

    sub bar {
        my sub foo { ... }
        {
            # need to use the outer foo here
            our sub foo;
            foo();
        }
    }
</pre>
<p class="Pp">and to make a subroutine visible to other packages in the same
    scope:</p>
<p class="Pp"></p>
<pre>
    package MySneakyModule;

    our sub do_something { ... }

    sub do_something_with_caller {
        package DB;
        () = caller 1;          # sets @DB::args
        do_something(@args);    # uses MySneakyModule::do_something
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Passing_Symbol_Table_Entries_(typeglobs)"><a class="permalink" href="#Passing_Symbol_Table_Entries_(typeglobs)">Passing
  Symbol Table Entries (typeglobs)</a></h2>
<p class="Pp"><b>WARNING</b>: The mechanism described in this section was
    originally the only way to simulate pass-by-reference in older versions of
    Perl. While it still works fine in modern versions, the new reference
    mechanism is generally easier to work with. See below.</p>
<p class="Pp">Sometimes you don't want to pass the value of an array to a
    subroutine but rather the name of it, so that the subroutine can modify the
    global copy of it rather than working with a local copy. In perl you can
    refer to all objects of a particular name by prefixing the name with a star:
    <span class="Li">*foo</span>. This is often known as a &quot;typeglob&quot;,
    because the star on the front can be thought of as a wildcard match for all
    the funny prefix characters on variables and subroutines and such.</p>
<p class="Pp">When evaluated, the typeglob produces a scalar value that
    represents all the objects of that name, including any filehandle, format,
    or subroutine. When assigned to, it causes the name mentioned to refer to
    whatever <span class="Li">&quot;*&quot;</span> value was assigned to it.
    Example:</p>
<p class="Pp"></p>
<pre>
    sub doubleary {
        local(*someary) = @_;
        foreach $elem (@someary) {
            $elem *= 2;
        }
    }
    doubleary(*foo);
    doubleary(*bar);
</pre>
<p class="Pp">Scalars are already passed by reference, so you can modify scalar
    arguments without using this mechanism by referring explicitly to
    <span class="Li">$_[0]</span> etc. You can modify all the elements of an
    array by passing all the elements as scalars, but you have to use the
    <span class="Li">&quot;*&quot;</span> mechanism (or the equivalent reference
    mechanism) to <span class="Li">&quot;push&quot;</span>,
    <span class="Li">&quot;pop&quot;</span>, or change the size of an array. It
    will certainly be faster to pass the typeglob (or reference).</p>
<p class="Pp">Even if you don't want to modify an array, this mechanism is
    useful for passing multiple arrays in a single LIST, because normally the
    LIST mechanism will merge all the array values so that you can't extract out
    the individual arrays. For more on typeglobs, see &quot;Typeglobs and
    Filehandles&quot; in perldata.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="When_to_Still_Use_"><a class="permalink" href="#When_to_Still_Use_">When
  to Still Use <b>local()</b></a></h2>
<p class="Pp">Despite the existence of <span class="Li">&quot;my&quot;</span>,
    there are still three places where the
    <span class="Li">&quot;local&quot;</span> operator still shines. In fact, in
    these three places, you <i>must</i> use
    <span class="Li">&quot;local&quot;</span> instead of
    <span class="Li">&quot;my&quot;</span>.</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>You need to give a global variable a temporary value, especially
      <span class="Li">$_</span>.
    <p class="Pp">The global variables, like <span class="Li">@ARGV</span> or
        the punctuation variables, must be
        <span class="Li">&quot;local&quot;</span>ized with
        <span class="Li">&quot;local()&quot;</span>. This block reads in
        <i>/etc/motd</i>, and splits it up into chunks separated by lines of
        equal signs, which are placed in <span class="Li">@Fields</span>.</p>
    <p class="Pp"></p>
    <pre>
    {
        local @ARGV = (&quot;/etc/motd&quot;);
        local $/ = undef;
        local $_ = &lt;&gt;;  
        @Fields = split /^\s*=+\s*$/;
    }
    </pre>
    <p class="Pp">It particular, it's important to
        <span class="Li">&quot;local&quot;</span>ize <span class="Li">$_</span>
        in any routine that assigns to it. Look out for implicit assignments in
        <span class="Li">&quot;while&quot;</span> conditionals.</p>
  </dd>
  <dt>2.</dt>
  <dd>You need to create a local file or directory handle or a local function.
    <p class="Pp">A function that needs a filehandle of its own must use
        <span class="Li">&quot;local()&quot;</span> on a complete typeglob. This
        can be used to create new symbol table entries:</p>
    <p class="Pp"></p>
    <pre>
    sub ioqueue {
        local  (*READER, *WRITER);    # not my!
        pipe    (READER,  WRITER)     or die &quot;pipe: $!&quot;;
        return (*READER, *WRITER);
    }
    ($head, $tail) = ioqueue();
    </pre>
    <p class="Pp">See the Symbol module for a way to create anonymous symbol
        table entries.</p>
    <p class="Pp">Because assignment of a reference to a typeglob creates an
        alias, this can be used to create what is effectively a local function,
        or at least, a local alias.</p>
    <p class="Pp"></p>
    <pre>
    {
        local *grow = \&amp;shrink; # only until this block exits
        grow();                # really calls shrink()
        move();                # if move() grow()s, it shrink()s too
    }
    grow();                    # get the real grow() again
    </pre>
    <p class="Pp">See &quot;Function Templates&quot; in perlref for more about
        manipulating functions by name in this way.</p>
  </dd>
  <dt>3.</dt>
  <dd>You want to temporarily change just one element of an array or hash.
    <p class="Pp">You can <span class="Li">&quot;local&quot;</span>ize just one
        element of an aggregate. Usually this is done on dynamics:</p>
    <p class="Pp"></p>
    <pre>
    {
        local $SIG{INT} = 'IGNORE';
        funct();                            # uninterruptible
    } 
    # interruptibility automatically restored here
    </pre>
    <p class="Pp">But it also works on lexically declared aggregates.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Pass_by_Reference"><a class="permalink" href="#Pass_by_Reference">Pass
  by Reference</a></h2>
<p class="Pp">If you want to pass more than one array or hash into a
    function--or return them from it--and have them maintain their integrity,
    then you're going to have to use an explicit pass-by-reference. Before you
    do that, you need to understand references as detailed in perlref. This
    section may not make much sense to you otherwise.</p>
<p class="Pp">Here are a few simple examples. First, let's pass in several
    arrays to a function and have it <span class="Li">&quot;pop&quot;</span> all
    of then, returning a new list of all their former last elements:</p>
<p class="Pp"></p>
<pre>
    @tailings = popmany ( \@a, \@b, \@c, \@d );

    sub popmany {
        my $aref;
        my @retlist;
        foreach $aref ( @_ ) {
            push @retlist, pop @$aref;
        }
        return @retlist;
    }
</pre>
<p class="Pp">Here's how you might write a function that returns a list of keys
    occurring in all the hashes passed to it:</p>
<p class="Pp"></p>
<pre>
    @common = inter( \%foo, \%bar, \%joe );
    sub inter {
        my ($k, $href, %seen); # locals
        foreach $href (@_) {
            while ( $k = each %$href ) {
                $seen{$k}++;
            }
        }
        return grep { $seen{$_} == @_ } keys %seen;
    }
</pre>
<p class="Pp">So far, we're using just the normal list return mechanism. What
    happens if you want to pass or return a hash? Well, if you're using only one
    of them, or you don't mind them concatenating, then the normal calling
    convention is ok, although a little expensive.</p>
<p class="Pp">Where people get into trouble is here:</p>
<p class="Pp"></p>
<pre>
    (@a, @b) = func(@c, @d);
or
    (%a, %b) = func(%c, %d);
</pre>
<p class="Pp">That syntax simply won't work. It sets just
    <span class="Li">@a</span> or <span class="Li">%a</span> and clears the
    <span class="Li">@b</span> or <span class="Li">%b</span>. Plus the function
    didn't get passed into two separate arrays or hashes: it got one long list
    in <span class="Li">@_</span>, as always.</p>
<p class="Pp">If you can arrange for everyone to deal with this through
    references, it's cleaner code, although not so nice to look at. Here's a
    function that takes two array references as arguments, returning the two
    array elements in order of how many elements they have in them:</p>
<p class="Pp"></p>
<pre>
    ($aref, $bref) = func(\@c, \@d);
    print &quot;@$aref has more than @$bref\n&quot;;
    sub func {
        my ($cref, $dref) = @_;
        if (@$cref &gt; @$dref) {
            return ($cref, $dref);
        } else {
            return ($dref, $cref);
        }
    }
</pre>
<p class="Pp">It turns out that you can actually do this also:</p>
<p class="Pp"></p>
<pre>
    (*a, *b) = func(\@c, \@d);
    print &quot;@a has more than @b\n&quot;;
    sub func {
        local (*c, *d) = @_;
        if (@c &gt; @d) {
            return (\@c, \@d);
        } else {
            return (\@d, \@c);
        }
    }
</pre>
<p class="Pp">Here we're using the typeglobs to do symbol table aliasing. It's a
    tad subtle, though, and also won't work if you're using
    <span class="Li">&quot;my&quot;</span> variables, because only globals (even
    in disguise as <span class="Li">&quot;local&quot;</span>s) are in the symbol
    table.</p>
<p class="Pp">If you're passing around filehandles, you could usually just use
    the bare typeglob, like <span class="Li">*STDOUT</span>, but typeglobs
    references work, too. For example:</p>
<p class="Pp"></p>
<pre>
    splutter(\*STDOUT);
    sub splutter {
        my $fh = shift;
        print $fh &quot;her um well a hmmm\n&quot;;
    }

    $rec = get_rec(\*STDIN);
    sub get_rec {
        my $fh = shift;
        return scalar &lt;$fh&gt;;
    }
</pre>
<p class="Pp">If you're planning on generating new filehandles, you could do
    this. Notice to pass back just the bare *FH, not its reference.</p>
<p class="Pp"></p>
<pre>
    sub openit {
        my $path = shift;
        local *FH;
        return open (FH, $path) ? *FH : undef;
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Prototypes"><a class="permalink" href="#Prototypes">Prototypes</a></h2>
<p class="Pp">Perl supports a very limited kind of compile-time argument
    checking using function prototyping. This can be declared in either the
    PROTO section or with a prototype attribute. If you declare either of</p>
<p class="Pp"></p>
<pre>
    sub mypush (\@@)
    sub mypush :prototype(\@@)
</pre>
<p class="Pp">then <span class="Li">&quot;mypush()&quot;</span> takes arguments
    exactly like <span class="Li">&quot;push()&quot;</span> does.</p>
<p class="Pp">If subroutine signatures are enabled (see &quot;Signatures&quot;),
    then the shorter PROTO syntax is unavailable, because it would clash with
    signatures. In that case, a prototype can only be declared in the form of an
    attribute.</p>
<p class="Pp">The function declaration must be visible at compile time. The
    prototype affects only interpretation of new-style calls to the function,
    where new-style is defined as not using the
    <span class="Li">&quot;&amp;&quot;</span> character. In other words, if you
    call it like a built-in function, then it behaves like a built-in function.
    If you call it like an old-fashioned subroutine, then it behaves like an
    old-fashioned subroutine. It naturally falls out from this rule that
    prototypes have no influence on subroutine references like
    <span class="Li">&quot;\&amp;foo&quot;</span> or on indirect subroutine
    calls like <span class="Li">&quot;&amp;{$subref}&quot;</span> or
    <span class="Li">&quot;$subref-&gt;()&quot;</span>.</p>
<p class="Pp">Method calls are not influenced by prototypes either, because the
    function to be called is indeterminate at compile time, since the exact code
    called depends on inheritance.</p>
<p class="Pp">Because the intent of this feature is primarily to let you define
    subroutines that work like built-in functions, here are prototypes for some
    other functions that parse almost exactly like the corresponding
  built-in.</p>
<p class="Pp"></p>
<pre>
   Declared as             Called as

   sub mylink ($$)         mylink $old, $new
   sub myvec ($$$)         myvec $var, $offset, 1
   sub myindex ($$;$)      myindex &amp;getstring, &quot;substr&quot;
   sub mysyswrite ($$$;$)  mysyswrite $buf, 0, length($buf) - $off, $off
   sub myreverse (@)       myreverse $a, $b, $c
   sub myjoin ($@)         myjoin &quot;:&quot;, $a, $b, $c
   sub mypop (\@)          mypop @array
   sub mysplice (\@$$@)    mysplice @array, 0, 2, @pushme
   sub mykeys (\[%@])      mykeys %{$hashref}
   sub myopen (*;$)        myopen HANDLE, $name
   sub mypipe (**)         mypipe READHANDLE, WRITEHANDLE
   sub mygrep (&amp;@)         mygrep { /foo/ } $a, $b, $c
   sub myrand (;$)         myrand 42
   sub mytime ()           mytime
</pre>
<p class="Pp">Any backslashed prototype character represents an actual argument
    that must start with that character (optionally preceded by
    <span class="Li">&quot;my&quot;</span>,
    <span class="Li">&quot;our&quot;</span> or
    <span class="Li">&quot;local&quot;</span>), with the exception of
    <span class="Li">&quot;$&quot;</span>, which will accept any scalar lvalue
    expression, such as <span class="Li">&quot;$foo = 7&quot;</span> or
    <span class="Li">&quot;my_function()-&gt;[0]&quot;</span>. The value passed
    as part of <span class="Li">@_</span> will be a reference to the actual
    argument given in the subroutine call, obtained by applying
    <span class="Li">&quot;\&quot;</span> to that argument.</p>
<p class="Pp">You can use the <span class="Li">&quot;\[]&quot;</span> backslash
    group notation to specify more than one allowed argument type. For
  example:</p>
<p class="Pp"></p>
<pre>
    sub myref (\[$@%&amp;*])
</pre>
<p class="Pp">will allow calling <b>myref()</b> as</p>
<p class="Pp"></p>
<pre>
    myref $var
    myref @array
    myref %hash
    myref &amp;sub
    myref *glob
</pre>
<p class="Pp">and the first argument of <b>myref()</b> will be a reference to a
    scalar, an array, a hash, a code, or a glob.</p>
<p class="Pp">Unbackslashed prototype characters have special meanings. Any
    unbackslashed <span class="Li">&quot;@&quot;</span> or
    <span class="Li">&quot;%&quot;</span> eats all remaining arguments, and
    forces list context. An argument represented by
    <span class="Li">&quot;$&quot;</span> forces scalar context. An
    <span class="Li">&quot;&amp;&quot;</span> requires an anonymous subroutine,
    which, if passed as the first argument, does not require the
    <span class="Li">&quot;sub&quot;</span> keyword or a subsequent comma.</p>
<p class="Pp">A <span class="Li">&quot;*&quot;</span> allows the subroutine to
    accept a bareword, constant, scalar expression, typeglob, or a reference to
    a typeglob in that slot. The value will be available to the subroutine
    either as a simple scalar, or (in the latter two cases) as a reference to
    the typeglob. If you wish to always convert such arguments to a typeglob
    reference, use <b>Symbol::qualify_to_ref()</b> as follows:</p>
<p class="Pp"></p>
<pre>
    use Symbol 'qualify_to_ref';

    sub foo (*) {
        my $fh = qualify_to_ref(shift, caller);
        ...
    }
</pre>
<p class="Pp">The <span class="Li">&quot;+&quot;</span> prototype is a special
    alternative to <span class="Li">&quot;$&quot;</span> that will act like
    <span class="Li">&quot;\[@%]&quot;</span> when given a literal array or hash
    variable, but will otherwise force scalar context on the argument. This is
    useful for functions which should accept either a literal array or an array
    reference as the argument:</p>
<p class="Pp"></p>
<pre>
    sub mypush (+@) {
        my $aref = shift;
        die &quot;Not an array or arrayref&quot; unless ref $aref eq 'ARRAY';
        push @$aref, @_;
    }
</pre>
<p class="Pp">When using the <span class="Li">&quot;+&quot;</span> prototype,
    your function must check that the argument is of an acceptable type.</p>
<p class="Pp">A semicolon (<span class="Li">&quot;;&quot;</span>) separates
    mandatory arguments from optional arguments. It is redundant before
    <span class="Li">&quot;@&quot;</span> or
    <span class="Li">&quot;%&quot;</span>, which gobble up everything else.</p>
<p class="Pp">As the last character of a prototype, or just before a semicolon,
    a <span class="Li">&quot;@&quot;</span> or a
    <span class="Li">&quot;%&quot;</span>, you can use
    <span class="Li">&quot;_&quot;</span> in place of
    <span class="Li">&quot;$&quot;</span>: if this argument is not provided,
    <span class="Li">$_</span> will be used instead.</p>
<p class="Pp">Note how the last three examples in the table above are treated
    specially by the parser. <span class="Li">&quot;mygrep()&quot;</span> is
    parsed as a true list operator, <span class="Li">&quot;myrand()&quot;</span>
    is parsed as a true unary operator with unary precedence the same as
    <span class="Li">&quot;rand()&quot;</span>, and
    <span class="Li">&quot;mytime()&quot;</span> is truly without arguments,
    just like <span class="Li">&quot;time()&quot;</span>. That is, if you
  say</p>
<p class="Pp"></p>
<pre>
    mytime +2;
</pre>
<p class="Pp">you'll get <span class="Li">&quot;mytime() + 2&quot;</span>, not
    <span class="Li">mytime(2)</span>, which is how it would be parsed without a
    prototype. If you want to force a unary function to have the same precedence
    as a list operator, add <span class="Li">&quot;;&quot;</span> to the end of
    the prototype:</p>
<p class="Pp"></p>
<pre>
    sub mygetprotobynumber($;);
    mygetprotobynumber $a &gt; $b; # parsed as mygetprotobynumber($a &gt; $b)
</pre>
<p class="Pp">The interesting thing about
    <span class="Li">&quot;&amp;&quot;</span> is that you can generate new
    syntax with it, provided it's in the initial position:</p>
<p class="Pp"></p>
<pre>
    sub try (&amp;@) {
        my($try,$catch) = @_;
        eval { &amp;$try };
        if ($@) {
            local $_ = $@;
            &amp;$catch;
        }
    }
    sub catch (&amp;) { $_[0] }

    try {
        die &quot;phooey&quot;;
    } catch {
        /phooey/ and print &quot;unphooey\n&quot;;
    };
</pre>
<p class="Pp">That prints <span class="Li">&quot;unphooey&quot;</span>. (Yes,
    there are still unresolved issues having to do with visibility of
    <span class="Li">@_</span>. I'm ignoring that question for the moment. (But
    note that if we make <span class="Li">@_</span> lexically scoped, those
    anonymous subroutines can act like closures... (Gee, is this sounding a
    little Lispish? (Never mind.))))</p>
<p class="Pp">And here's a reimplementation of the Perl
    <span class="Li">&quot;grep&quot;</span> operator:</p>
<p class="Pp"></p>
<pre>
    sub mygrep (&amp;@) {
        my $code = shift;
        my @result;
        foreach $_ (@_) {
            push(@result, $_) if &amp;$code;
        }
        @result;
    }
</pre>
<p class="Pp">Some folks would prefer full alphanumeric prototypes.
    Alphanumerics have been intentionally left out of prototypes for the express
    purpose of someday in the future adding named, formal parameters. The
    current mechanism's main goal is to let module writers provide better
    diagnostics for module users. Larry feels the notation quite understandable
    to Perl programmers, and that it will not intrude greatly upon the meat of
    the module, nor make it harder to read. The line noise is visually
    encapsulated into a small pill that's easy to swallow.</p>
<p class="Pp">If you try to use an alphanumeric sequence in a prototype you will
    generate an optional warning - &quot;Illegal character in
    prototype...&quot;. Unfortunately earlier versions of Perl allowed the
    prototype to be used as long as its prefix was a valid prototype. The
    warning may be upgraded to a fatal error in a future version of Perl once
    the majority of offending code is fixed.</p>
<p class="Pp">It's probably best to prototype new functions, not retrofit
    prototyping into older ones. That's because you must be especially careful
    about silent impositions of differing list versus scalar contexts. For
    example, if you decide that a function should take just one parameter, like
    this:</p>
<p class="Pp"></p>
<pre>
    sub func ($) {
        my $n = shift;
        print &quot;you gave me $n\n&quot;;
    }
</pre>
<p class="Pp">and someone has been calling it with an array or expression
    returning a list:</p>
<p class="Pp"></p>
<pre>
    func(@foo);
    func( $text =~ /\w+/g );
</pre>
<p class="Pp">Then you've just supplied an automatic
    <span class="Li">&quot;scalar&quot;</span> in front of their argument, which
    can be more than a bit surprising. The old <span class="Li">@foo</span>
    which used to hold one thing doesn't get passed in. Instead,
    <span class="Li">&quot;func()&quot;</span> now gets passed in a
    <span class="Li">1</span>; that is, the number of elements in
    <span class="Li">@foo</span>. And the
    <span class="Li">&quot;m//g&quot;</span> gets called in scalar context so
    instead of a list of words it returns a boolean result and advances
    <span class="Li">&quot;pos($text)&quot;</span>. Ouch!</p>
<p class="Pp">If a sub has both a PROTO and a BLOCK, the prototype is not
    applied until after the BLOCK is completely defined. This means that a
    recursive function with a prototype has to be predeclared for the prototype
    to take effect, like so:</p>
<p class="Pp"></p>
<pre>
        sub foo($$);
        sub foo($$) {
                foo 1, 2;
        }
</pre>
<p class="Pp">This is all very powerful, of course, and should be used only in
    moderation to make the world a better place.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Constant_Functions"><a class="permalink" href="#Constant_Functions">Constant
  Functions</a></h2>
<p class="Pp">Functions with a prototype of
    <span class="Li">&quot;()&quot;</span> are potential candidates for
    inlining. If the result after optimization and constant folding is either a
    constant or a lexically-scoped scalar which has no other references, then it
    will be used in place of function calls made without
    <span class="Li">&quot;&amp;&quot;</span>. Calls made using
    <span class="Li">&quot;&amp;&quot;</span> are never inlined. (See
    <i>constant.pm</i> for an easy way to declare most constants.)</p>
<p class="Pp">The following functions would all be inlined:</p>
<p class="Pp"></p>
<pre>
    sub pi ()           { 3.14159 }             # Not exact, but close.
    sub PI ()           { 4 * atan2 1, 1 }      # As good as it gets,
                                                # and it's inlined, too!
    sub ST_DEV ()       { 0 }
    sub ST_INO ()       { 1 }

    sub FLAG_FOO ()     { 1 &lt;&lt; 8 }
    sub FLAG_BAR ()     { 1 &lt;&lt; 9 }
    sub FLAG_MASK ()    { FLAG_FOO | FLAG_BAR }

    sub OPT_BAZ ()      { not (0x1B58 &amp; FLAG_MASK) }

    sub N () { int(OPT_BAZ) / 3 }

    sub FOO_SET () { 1 if FLAG_MASK &amp; FLAG_FOO }
    sub FOO_SET2 () { if (FLAG_MASK &amp; FLAG_FOO) { 1 } }
</pre>
<p class="Pp">(Be aware that the last example was not always inlined in Perl
    5.20 and earlier, which did not behave consistently with subroutines
    containing inner scopes.) You can countermand inlining by using an explicit
    <span class="Li">&quot;return&quot;</span>:</p>
<p class="Pp"></p>
<pre>
    sub baz_val () {
        if (OPT_BAZ) {
            return 23;
        }
        else {
            return 42;
        }
    }
    sub bonk_val () { return 12345 }
</pre>
<p class="Pp">As alluded to earlier you can also declare inlined subs
    dynamically at BEGIN time if their body consists of a lexically-scoped
    scalar which has no other references. Only the first example here will be
    inlined:</p>
<p class="Pp"></p>
<pre>
    BEGIN {
        my $var = 1;
        no strict 'refs';
        *INLINED = sub () { $var };
    }

    BEGIN {
        my $var = 1;
        my $ref = \$var;
        no strict 'refs';
        *NOT_INLINED = sub () { $var };
    }
</pre>
<p class="Pp">A not so obvious caveat with this (see [RT #79908]) is that the
    variable will be immediately inlined, and will stop behaving like a normal
    lexical variable, e.g. this will print <span class="Li">79907</span>, not
    <span class="Li">79908</span>:</p>
<p class="Pp"></p>
<pre>
    BEGIN {
        my $x = 79907;
        *RT_79908 = sub () { $x };
        $x++;
    }
    print RT_79908(); # prints 79907
</pre>
<p class="Pp">As of Perl 5.22, this buggy behavior, while preserved for backward
    compatibility, is detected and emits a deprecation warning. If you want the
    subroutine to be inlined (with no warning), make sure the variable is not
    used in a context where it could be modified aside from where it is
    declared.</p>
<p class="Pp"></p>
<pre>
    # Fine, no warning
    BEGIN {
        my $x = 54321;
        *INLINED = sub () { $x };
    }
    # Warns.  Future Perl versions will stop inlining it.
    BEGIN {
        my $x;
        $x = 54321;
        *ALSO_INLINED = sub () { $x };
    }
</pre>
<p class="Pp">Perl 5.22 also introduces the experimental &quot;const&quot;
    attribute as an alternative. (Disable the
    &quot;experimental::const_attr&quot; warnings if you want to use it.) When
    applied to an anonymous subroutine, it forces the sub to be called when the
    <span class="Li">&quot;sub&quot;</span> expression is evaluated. The return
    value is captured and turned into a constant subroutine:</p>
<p class="Pp"></p>
<pre>
    my $x = 54321;
    *INLINED = sub : const { $x };
    $x++;
</pre>
<p class="Pp">The return value of <span class="Li">&quot;INLINED&quot;</span> in
    this example will always be 54321, regardless of later modifications to
    <span class="Li">$x</span>. You can also put any arbitrary code inside the
    sub, at it will be executed immediately and its return value captured the
    same way.</p>
<p class="Pp">If you really want a subroutine with a
    <span class="Li">&quot;()&quot;</span> prototype that returns a lexical
    variable you can easily force it to not be inlined by adding an explicit
    <span class="Li">&quot;return&quot;</span>:</p>
<p class="Pp"></p>
<pre>
    BEGIN {
        my $x = 79907;
        *RT_79908 = sub () { return $x };
        $x++;
    }
    print RT_79908(); # prints 79908
</pre>
<p class="Pp">The easiest way to tell if a subroutine was inlined is by using
    B::Deparse. Consider this example of two subroutines returning
    <span class="Li">1</span>, one with a <span class="Li">&quot;()&quot;</span>
    prototype causing it to be inlined, and one without (with deparse output
    truncated for clarity):</p>
<p class="Pp"></p>
<pre>
 $ perl -MO=Deparse -le 'sub ONE { 1 } if (ONE) { print ONE if ONE }'
 sub ONE {
     1;
 }
 if (ONE ) {
     print ONE() if ONE ;
 }
 $ perl -MO=Deparse -le 'sub ONE () { 1 } if (ONE) { print ONE if ONE }'
 sub ONE () { 1 }
 do {
     print 1
 };
</pre>
<p class="Pp">If you redefine a subroutine that was eligible for inlining,
    you'll get a warning by default. You can use this warning to tell whether or
    not a particular subroutine is considered inlinable, since it's different
    than the warning for overriding non-inlined subroutines:</p>
<p class="Pp"></p>
<pre>
    $ perl -e 'sub one () {1} sub one () {2}'
    Constant subroutine one redefined at -e line 1.
    $ perl -we 'sub one {1} sub one {2}'
    Subroutine one redefined at -e line 1.
</pre>
<p class="Pp">The warning is considered severe enough not to be affected by the
    <b>-w</b> switch (or its absence) because previously compiled invocations of
    the function will still be using the old value of the function. If you need
    to be able to redefine the subroutine, you need to ensure that it isn't
    inlined, either by dropping the <span class="Li">&quot;()&quot;</span>
    prototype (which changes calling semantics, so beware) or by thwarting the
    inlining mechanism in some other way, e.g. by adding an explicit
    <span class="Li">&quot;return&quot;</span>, as mentioned above:</p>
<p class="Pp"></p>
<pre>
    sub not_inlined () { return 23 }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Overriding_Built-in_Functions"><a class="permalink" href="#Overriding_Built-in_Functions">Overriding
  Built-in Functions</a></h2>
<p class="Pp">Many built-in functions may be overridden, though this should be
    tried only occasionally and for good reason. Typically this might be done by
    a package attempting to emulate missing built-in functionality on a non-Unix
    system.</p>
<p class="Pp">Overriding may be done only by importing the name from a module at
    compile time--ordinary predeclaration isn't good enough. However, the
    <span class="Li">&quot;use subs&quot;</span> pragma lets you, in effect,
    predeclare subs via the import syntax, and these names may then override
    built-in ones:</p>
<p class="Pp"></p>
<pre>
    use subs 'chdir', 'chroot', 'chmod', 'chown';
    chdir $somewhere;
    sub chdir { ... }
</pre>
<p class="Pp">To unambiguously refer to the built-in form, precede the built-in
    name with the special package qualifier
    <span class="Li">&quot;CORE::&quot;</span>. For example, saying
    <span class="Li">&quot;CORE::open()&quot;</span> always refers to the
    built-in <span class="Li">&quot;open()&quot;</span>, even if the current
    package has imported some other subroutine called
    <span class="Li">&quot;&amp;open()&quot;</span> from elsewhere. Even though
    it looks like a regular function call, it isn't: the CORE:: prefix in that
    case is part of Perl's syntax, and works for any keyword, regardless of what
    is in the CORE package. Taking a reference to it, that is,
    <span class="Li">&quot;\&amp;CORE::open&quot;</span>, only works for some
    keywords. See CORE.</p>
<p class="Pp">Library modules should not in general export built-in names like
    <span class="Li">&quot;open&quot;</span> or
    <span class="Li">&quot;chdir&quot;</span> as part of their default
    <span class="Li">@EXPORT</span> list, because these may sneak into someone
    else's namespace and change the semantics unexpectedly. Instead, if the
    module adds that name to <span class="Li">@EXPORT_OK</span>, then it's
    possible for a user to import the name explicitly, but not implicitly. That
    is, they could say</p>
<p class="Pp"></p>
<pre>
    use Module 'open';
</pre>
<p class="Pp">and it would import the <span class="Li">&quot;open&quot;</span>
    override. But if they said</p>
<p class="Pp"></p>
<pre>
    use Module;
</pre>
<p class="Pp">they would get the default imports without overrides.</p>
<p class="Pp">The foregoing mechanism for overriding built-in is restricted,
    quite deliberately, to the package that requests the import. There is a
    second method that is sometimes applicable when you wish to override a
    built-in everywhere, without regard to namespace boundaries. This is
    achieved by importing a sub into the special namespace
    <span class="Li">&quot;CORE::GLOBAL::&quot;</span>. Here is an example that
    quite brazenly replaces the <span class="Li">&quot;glob&quot;</span>
    operator with something that understands regular expressions.</p>
<p class="Pp"></p>
<pre>
    package REGlob;
    require Exporter;
    @ISA = 'Exporter';
    @EXPORT_OK = 'glob';

    sub import {
        my $pkg = shift;
        return unless @_;
        my $sym = shift;
        my $where = ($sym =~ s/^GLOBAL_// ? 'CORE::GLOBAL' : caller(0));
        $pkg-&gt;export($where, $sym, @_);
    }

    sub glob {
        my $pat = shift;
        my @got;
        if (opendir my $d, '.') { 
            @got = grep /$pat/, readdir $d; 
            closedir $d;   
        }
        return @got;
    }
    1;
</pre>
<p class="Pp">And here's how it could be (ab)used:</p>
<p class="Pp"></p>
<pre>
    #use REGlob 'GLOBAL_glob';      # override glob() in ALL namespaces
    package Foo;
    use REGlob 'glob';              # override glob() in Foo:: only
    print for &lt;^[a-z_]+\.pm\$&gt;;     # show all pragmatic modules
</pre>
<p class="Pp">The initial comment shows a contrived, even dangerous example. By
    overriding <span class="Li">&quot;glob&quot;</span> globally, you would be
    forcing the new (and subversive) behavior for the
    <span class="Li">&quot;glob&quot;</span> operator for <i>every</i>
    namespace, without the complete cognizance or cooperation of the modules
    that own those namespaces. Naturally, this should be done with extreme
    caution--if it must be done at all.</p>
<p class="Pp">The <span class="Li">&quot;REGlob&quot;</span> example above does
    not implement all the support needed to cleanly override perl's
    <span class="Li">&quot;glob&quot;</span> operator. The built-in
    <span class="Li">&quot;glob&quot;</span> has different behaviors depending
    on whether it appears in a scalar or list context, but our
    <span class="Li">&quot;REGlob&quot;</span> doesn't. Indeed, many perl
    built-in have such context sensitive behaviors, and these must be adequately
    supported by a properly written override. For a fully functional example of
    overriding <span class="Li">&quot;glob&quot;</span>, study the
    implementation of <span class="Li">&quot;File::DosGlob&quot;</span> in the
    standard library.</p>
<p class="Pp">When you override a built-in, your replacement should be
    consistent (if possible) with the built-in native syntax. You can achieve
    this by using a suitable prototype. To get the prototype of an overridable
    built-in, use the <span class="Li">&quot;prototype&quot;</span> function
    with an argument of <span class="Li">&quot;CORE::builtin_name&quot;</span>
    (see &quot;prototype&quot; in perlfunc).</p>
<p class="Pp">Note however that some built-ins can't have their syntax expressed
    by a prototype (such as <span class="Li">&quot;system&quot;</span> or
    <span class="Li">&quot;chomp&quot;</span>). If you override them you won't
    be able to fully mimic their original syntax.</p>
<p class="Pp">The built-ins <span class="Li">&quot;do&quot;</span>,
    <span class="Li">&quot;require&quot;</span> and
    <span class="Li">&quot;glob&quot;</span> can also be overridden, but due to
    special magic, their original syntax is preserved, and you don't have to
    define a prototype for their replacements. (You can't override the
    <span class="Li">&quot;do BLOCK&quot;</span> syntax, though).</p>
<p class="Pp"><span class="Li">&quot;require&quot;</span> has special additional
    dark magic: if you invoke your <span class="Li">&quot;require&quot;</span>
    replacement as <span class="Li">&quot;require Foo::Bar&quot;</span>, it will
    actually receive the argument <span class="Li">&quot;Foo/Bar.pm&quot;</span>
    in <span class="Li">@_</span>. See &quot;require&quot; in perlfunc.</p>
<p class="Pp">And, as you'll have noticed from the previous example, if you
    override <span class="Li">&quot;glob&quot;</span>, the
    <span class="Li">&quot;&lt;*&gt;&quot;</span> glob operator is overridden as
    well.</p>
<p class="Pp">In a similar fashion, overriding the
    <span class="Li">&quot;readline&quot;</span> function also overrides the
    equivalent I/O operator
    <span class="Li">&quot;&lt;FILEHANDLE&gt;&quot;</span>. Also, overriding
    <span class="Li">&quot;readpipe&quot;</span> also overrides the operators
    <span class="Li">&quot;``&quot;</span> and
    <span class="Li">&quot;qx//&quot;</span>.</p>
<p class="Pp">Finally, some built-ins (e.g.
    <span class="Li">&quot;exists&quot;</span> or
    <span class="Li">&quot;grep&quot;</span>) can't be overridden.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Autoloading"><a class="permalink" href="#Autoloading">Autoloading</a></h2>
<p class="Pp">If you call a subroutine that is undefined, you would ordinarily
    get an immediate, fatal error complaining that the subroutine doesn't exist.
    (Likewise for subroutines being used as methods, when the method doesn't
    exist in any base class of the class's package.) However, if an
    <span class="Li">&quot;AUTOLOAD&quot;</span> subroutine is defined in the
    package or packages used to locate the original subroutine, then that
    <span class="Li">&quot;AUTOLOAD&quot;</span> subroutine is called with the
    arguments that would have been passed to the original subroutine. The fully
    qualified name of the original subroutine magically appears in the global
    <span class="Li">$AUTOLOAD</span> variable of the same package as the
    <span class="Li">&quot;AUTOLOAD&quot;</span> routine. The name is not passed
    as an ordinary argument because, er, well, just because, that's why. (As an
    exception, a method call to a nonexistent
    <span class="Li">&quot;import&quot;</span> or
    <span class="Li">&quot;unimport&quot;</span> method is just skipped instead.
    Also, if the AUTOLOAD subroutine is an XSUB, there are other ways to
    retrieve the subroutine name. See &quot;Autoloading with XSUBs&quot; in
    perlguts for details.)</p>
<p class="Pp">Many <span class="Li">&quot;AUTOLOAD&quot;</span> routines load in
    a definition for the requested subroutine using <b>eval()</b>, then execute
    that subroutine using a special form of <b>goto()</b> that erases the stack
    frame of the <span class="Li">&quot;AUTOLOAD&quot;</span> routine without a
    trace. (See the source to the standard module documented in AutoLoader, for
    example.) But an <span class="Li">&quot;AUTOLOAD&quot;</span> routine can
    also just emulate the routine and never define it. For example, let's
    pretend that a function that wasn't defined should just invoke
    <span class="Li">&quot;system&quot;</span> with those arguments. All you'd
    do is:</p>
<p class="Pp"></p>
<pre>
    sub AUTOLOAD {
        our $AUTOLOAD;              # keep 'use strict' happy
        my $program = $AUTOLOAD;
        $program =~ s/.*:://;
        system($program, @_);
    }
    date();
    who();
    ls('-l');
</pre>
<p class="Pp">In fact, if you predeclare functions you want to call that way,
    you don't even need parentheses:</p>
<p class="Pp"></p>
<pre>
    use subs qw(date who ls);
    date;
    who;
    ls '-l';
</pre>
<p class="Pp">A more complete example of this is the Shell module on CPAN, which
    can treat undefined subroutine calls as calls to external programs.</p>
<p class="Pp">Mechanisms are available to help modules writers split their
    modules into autoloadable files. See the standard AutoLoader module
    described in AutoLoader and in AutoSplit, the standard SelfLoader modules in
    SelfLoader, and the document on adding C functions to Perl code in
  perlxs.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Subroutine_Attributes"><a class="permalink" href="#Subroutine_Attributes">Subroutine
  Attributes</a></h2>
<p class="Pp">A subroutine declaration or definition may have a list of
    attributes associated with it. If such an attribute list is present, it is
    broken up at space or colon boundaries and treated as though a
    <span class="Li">&quot;use attributes&quot;</span> had been seen. See
    attributes for details about what attributes are currently supported. Unlike
    the limitation with the obsolescent <span class="Li">&quot;use
    attrs&quot;</span>, the <span class="Li">&quot;sub : ATTRLIST&quot;</span>
    syntax works to associate the attributes with a pre-declaration, and not
    just with a subroutine definition.</p>
<p class="Pp">The attributes must be valid as simple identifier names (without
    any punctuation other than the '_' character). They may have a parameter
    list appended, which is only checked for whether its parentheses ('(',')')
    nest properly.</p>
<p class="Pp">Examples of valid syntax (even though the attributes are
  unknown):</p>
<p class="Pp"></p>
<pre>
    sub fnord (&amp;\%) : switch(10,foo(7,3))  :  expensive;
    sub plugh () : Ugly('\(&quot;) :Bad;
    sub xyzzy : _5x5 { ... }
</pre>
<p class="Pp">Examples of invalid syntax:</p>
<p class="Pp"></p>
<pre>
    sub fnord : switch(10,foo(); # ()-string not balanced
    sub snoid : Ugly('(');        # ()-string not balanced
    sub xyzzy : 5x5;              # &quot;5x5&quot; not a valid identifier
    sub plugh : Y2::north;        # &quot;Y2::north&quot; not a simple identifier
    sub snurt : foo + bar;        # &quot;+&quot; not a colon or space
</pre>
<p class="Pp">The attribute list is passed as a list of constant strings to the
    code which associates them with the subroutine. In particular, the second
    example of valid syntax above currently looks like this in terms of how it's
    parsed and invoked:</p>
<p class="Pp"></p>
<pre>
    use attributes __PACKAGE__, \&amp;plugh, q[Ugly('\(&quot;)], 'Bad';
</pre>
<p class="Pp">For further details on attribute lists and their manipulation, see
    attributes and Attribute::Handlers.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">See &quot;Function Templates&quot; in perlref for more about
    references and closures. See perlxs if you'd like to learn about calling C
    subroutines from Perl. See perlembed if you'd like to learn about calling
    Perl subroutines from C. See perlmod to learn about bundling up your
    functions in separate files. See perlmodlib to learn what library modules
    come standard on your system. See perlootut to learn how to make object
    method calls.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

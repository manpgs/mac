<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PERLFAQ5(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLFAQ5(1)</td>
    <td class="head-vol"><a href=".">Perl Programmers Reference Guide</a></td>
    <td class="head-rtitle">PERLFAQ5(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlfaq5 - Files and Formats</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 5.20210411</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This section deals with I/O and the &quot;f&quot; issues:
    filehandles, flushing, formats, and footers.</p>
<section class="Ss">
<h2 class="Ss" id="How_do_I_flush/unbuffer_an_output_filehandle?_Why_must_I_do_this?"><a class="permalink" href="#How_do_I_flush/unbuffer_an_output_filehandle?_Why_must_I_do_this?">How
  do I flush/unbuffer an output filehandle? Why must I do this?</a></h2>
<p class="Pp">(contributed by brian d foy)</p>
<p class="Pp">You might like to read Mark Jason Dominus's &quot;Suffering From
    Buffering&quot; at &lt;http://perl.plover.com/FAQs/Buffering.html&gt; .</p>
<p class="Pp">Perl normally buffers output so it doesn't make a system call for
    every bit of output. By saving up output, it makes fewer expensive system
    calls. For instance, in this little bit of code, you want to print a dot to
    the screen for every line you process to watch the progress of your program.
    Instead of seeing a dot for every line, Perl buffers the output and you have
    a long wait before you see a row of 50 dots all at once:</p>
<p class="Pp"></p>
<pre>    # long wait, then row of dots all at once
    while( &lt;&gt; ) {
        print &quot;.&quot;;
        print &quot;\n&quot; unless ++$count % 50;
        #... expensive line processing operations
    }
</pre>
<p class="Pp">To get around this, you have to unbuffer the output filehandle, in
    this case, <span class="Li">&quot;STDOUT&quot;</span>. You can set the
    special variable <span class="Li">$|</span> to a true value (mnemonic:
    making your filehandles &quot;piping hot&quot;):</p>
<p class="Pp"></p>
<pre>    $|++;
    # dot shown immediately
    while( &lt;&gt; ) {
        print &quot;.&quot;;
        print &quot;\n&quot; unless ++$count % 50;
        #... expensive line processing operations
    }
</pre>
<p class="Pp">The <span class="Li">$|</span> is one of the per-filehandle
    special variables, so each filehandle has its own copy of its value. If you
    want to merge standard output and standard error for instance, you have to
    unbuffer each (although STDERR might be unbuffered by default):</p>
<p class="Pp"></p>
<pre>    {
        my $previous_default = select(STDOUT);  # save previous default
        $|++;                                   # autoflush STDOUT
        select(STDERR);
        $|++;                                   # autoflush STDERR, to be sure
        select($previous_default);              # restore previous default
    }
    # now should alternate . and +
    while( 1 ) {
        sleep 1;
        print STDOUT &quot;.&quot;;
        print STDERR &quot;+&quot;;
        print STDOUT &quot;\n&quot; unless ++$count % 25;
    }
</pre>
<p class="Pp">Besides the <span class="Li">$|</span> special variable, you can
    use <span class="Li">&quot;binmode&quot;</span> to give your filehandle a
    <span class="Li">&quot;:unix&quot;</span> layer, which is unbuffered:</p>
<p class="Pp"></p>
<pre>    binmode( STDOUT, &quot;:unix&quot; );
    while( 1 ) {
        sleep 1;
        print &quot;.&quot;;
        print &quot;\n&quot; unless ++$count % 50;
    }
</pre>
<p class="Pp">For more information on output layers, see the entries for
    <span class="Li">&quot;binmode&quot;</span> and open in perlfunc, and the
    PerlIO module documentation.</p>
<p class="Pp">If you are using IO::Handle or one of its subclasses, you can call
    the <span class="Li">&quot;autoflush&quot;</span> method to change the
    settings of the filehandle:</p>
<p class="Pp"></p>
<pre>    use IO::Handle;
    open my( $io_fh ), &quot;&gt;&quot;, &quot;output.txt&quot;;
    $io_fh-&gt;autoflush(1);
</pre>
<p class="Pp">The IO::Handle objects also have a
    <span class="Li">&quot;flush&quot;</span> method. You can flush the buffer
    any time you want without auto-buffering</p>
<p class="Pp"></p>
<pre>    $io_fh-&gt;flush;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_change,_delete,_or_insert_a_line_in_a_file,_or_append_to_the_beginning_of_a_file?"><a class="permalink" href="#How_do_I_change,_delete,_or_insert_a_line_in_a_file,_or_append_to_the_beginning_of_a_file?">How
  do I change, delete, or insert a line in a file, or append to the beginning of
  a file?</a></h2>
<p class="Pp">(contributed by brian d foy)</p>
<p class="Pp">The basic idea of inserting, changing, or deleting a line from a
    text file involves reading and printing the file to the point you want to
    make the change, making the change, then reading and printing the rest of
    the file. Perl doesn't provide random access to lines (especially since the
    record input separator, <span class="Li">$/</span>, is mutable), although
    modules such as Tie::File can fake it.</p>
<p class="Pp">A Perl program to do these tasks takes the basic form of opening a
    file, printing its lines, then closing the file:</p>
<p class="Pp"></p>
<pre>    open my $in,  '&lt;',  $file      or die &quot;Can't read old file: $!&quot;;
    open my $out, '&gt;', &quot;$file.new&quot; or die &quot;Can't write new file: $!&quot;;
    while( &lt;$in&gt; ) {
            print $out $_;
    }
    close $out;
</pre>
<p class="Pp">Within that basic form, add the parts that you need to insert,
    change, or delete lines.</p>
<p class="Pp">To prepend lines to the beginning, print those lines before you
    enter the loop that prints the existing lines.</p>
<p class="Pp"></p>
<pre>    open my $in,  '&lt;',  $file      or die &quot;Can't read old file: $!&quot;;
    open my $out, '&gt;', &quot;$file.new&quot; or die &quot;Can't write new file: $!&quot;;
    print $out &quot;# Add this line to the top\n&quot;; # &lt;--- HERE'S THE MAGIC
    while( &lt;$in&gt; ) {
            print $out $_;
    }
    close $out;
</pre>
<p class="Pp">To change existing lines, insert the code to modify the lines
    inside the <span class="Li">&quot;while&quot;</span> loop. In this case, the
    code finds all lowercased versions of &quot;perl&quot; and uppercases them.
    The happens for every line, so be sure that you're supposed to do that on
    every line!</p>
<p class="Pp"></p>
<pre>    open my $in,  '&lt;',  $file      or die &quot;Can't read old file: $!&quot;;
    open my $out, '&gt;', &quot;$file.new&quot; or die &quot;Can't write new file: $!&quot;;
    print $out &quot;# Add this line to the top\n&quot;;
    while( &lt;$in&gt; ) {
        s/\b(perl)\b/Perl/g;
        print $out $_;
    }
    close $out;
</pre>
<p class="Pp">To change only a particular line, the input line number,
    <span class="Li">$.</span>, is useful. First read and print the lines up to
    the one you want to change. Next, read the single line you want to change,
    change it, and print it. After that, read the rest of the lines and print
    those:</p>
<p class="Pp"></p>
<pre>    while( &lt;$in&gt; ) { # print the lines before the change
        print $out $_;
        last if $. == 4; # line number before change
    }
    my $line = &lt;$in&gt;;
    $line =~ s/\b(perl)\b/Perl/g;
    print $out $line;
    while( &lt;$in&gt; ) { # print the rest of the lines
        print $out $_;
    }
</pre>
<p class="Pp">To skip lines, use the looping controls. The
    <span class="Li">&quot;next&quot;</span> in this example skips comment
    lines, and the <span class="Li">&quot;last&quot;</span> stops all processing
    once it encounters either <span class="Li">&quot;__END__&quot;</span> or
    <span class="Li">&quot;__DATA__&quot;</span>.</p>
<p class="Pp"></p>
<pre>    while( &lt;$in&gt; ) {
        next if /^\s+#/;             # skip comment lines
        last if /^__(END|DATA)__$/;  # stop at end of code marker
        print $out $_;
    }
</pre>
<p class="Pp">Do the same sort of thing to delete a particular line by using
    <span class="Li">&quot;next&quot;</span> to skip the lines you don't want to
    show up in the output. This example skips every fifth line:</p>
<p class="Pp"></p>
<pre>    while( &lt;$in&gt; ) {
        next unless $. % 5;
        print $out $_;
    }
</pre>
<p class="Pp">If, for some odd reason, you really want to see the whole file at
    once rather than processing line-by-line, you can slurp it in (as long as
    you can fit the whole thing in memory!):</p>
<p class="Pp"></p>
<pre>    open my $in,  '&lt;',  $file      or die &quot;Can't read old file: $!&quot;
    open my $out, '&gt;', &quot;$file.new&quot; or die &quot;Can't write new file: $!&quot;;
    my $content = do { local $/; &lt;$in&gt; }; # slurp!
        # do your magic here
    print $out $content;
</pre>
<p class="Pp">Modules such as Path::Tiny and Tie::File can help with that too.
    If you can, however, avoid reading the entire file at once. Perl won't give
    that memory back to the operating system until the process finishes.</p>
<p class="Pp">You can also use Perl one-liners to modify a file in-place. The
    following changes all 'Fred' to 'Barney' in <i>inFile.txt</i>, overwriting
    the file with the new contents. With the
    <span class="Li">&quot;-p&quot;</span> switch, Perl wraps a
    <span class="Li">&quot;while&quot;</span> loop around the code you specify
    with <span class="Li">&quot;-e&quot;</span>, and
    <span class="Li">&quot;-i&quot;</span> turns on in-place editing. The
    current line is in <span class="Li">$_</span>. With
    <span class="Li">&quot;-p&quot;</span>, Perl automatically prints the value
    of <span class="Li">$_</span> at the end of the loop. See perlrun for more
    details.</p>
<p class="Pp"></p>
<pre>    perl -pi -e 's/Fred/Barney/' inFile.txt
</pre>
<p class="Pp">To make a backup of
    <span class="Li">&quot;inFile.txt&quot;</span>, give
    <span class="Li">&quot;-i&quot;</span> a file extension to add:</p>
<p class="Pp"></p>
<pre>    perl -pi.bak -e 's/Fred/Barney/' inFile.txt
</pre>
<p class="Pp">To change only the fifth line, you can add a test checking
    <span class="Li">$.</span>, the input line number, then only perform the
    operation when the test passes:</p>
<p class="Pp"></p>
<pre>    perl -pi -e 's/Fred/Barney/ if $. == 5' inFile.txt
</pre>
<p class="Pp">To add lines before a certain line, you can add a line (or lines!)
    before Perl prints <span class="Li">$_</span>:</p>
<p class="Pp"></p>
<pre>    perl -pi -e 'print &quot;Put before third line\n&quot; if $. == 3' inFile.txt
</pre>
<p class="Pp">You can even add a line to the beginning of a file, since the
    current line prints at the end of the loop:</p>
<p class="Pp"></p>
<pre>    perl -pi -e 'print &quot;Put before first line\n&quot; if $. == 1' inFile.txt
</pre>
<p class="Pp">To insert a line after one already in the file, use the
    <span class="Li">&quot;-n&quot;</span> switch. It's just like
    <span class="Li">&quot;-p&quot;</span> except that it doesn't print
    <span class="Li">$_</span> at the end of the loop, so you have to do that
    yourself. In this case, print <span class="Li">$_</span> first, then print
    the line that you want to add.</p>
<p class="Pp"></p>
<pre>    perl -ni -e 'print; print &quot;Put after fifth line\n&quot; if $. == 5' inFile.txt
</pre>
<p class="Pp">To delete lines, only print the ones that you want.</p>
<p class="Pp"></p>
<pre>    perl -ni -e 'print if /d/' inFile.txt
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_count_the_number_of_lines_in_a_file?"><a class="permalink" href="#How_do_I_count_the_number_of_lines_in_a_file?">How
  do I count the number of lines in a file?</a></h2>
<p class="Pp">(contributed by brian d foy)</p>
<p class="Pp">Conceptually, the easiest way to count the lines in a file is to
    simply read them and count them:</p>
<p class="Pp"></p>
<pre>    my $count = 0;
    while( &lt;$fh&gt; ) { $count++; }
</pre>
<p class="Pp">You don't really have to count them yourself, though, since Perl
    already does that with the <span class="Li">$.</span> variable, which is the
    current line number from the last filehandle read:</p>
<p class="Pp"></p>
<pre>    1 while( &lt;$fh&gt; );
    my $count = $.;
</pre>
<p class="Pp">If you want to use <span class="Li">$.</span>, you can reduce it
    to a simple one-liner, like one of these:</p>
<p class="Pp"></p>
<pre>    % perl -lne '} print $.; {'    file
    % perl -lne 'END { print $. }' file
</pre>
<p class="Pp">Those can be rather inefficient though. If they aren't fast enough
    for you, you might just read chunks of data and count the number of
    newlines:</p>
<p class="Pp"></p>
<pre>    my $lines = 0;
    open my($fh), '&lt;:raw', $filename or die &quot;Can't open $filename: $!&quot;;
    while( sysread $fh, $buffer, 4096 ) {
        $lines += ( $buffer =~ tr/\n// );
    }
    close $fh;
</pre>
<p class="Pp">However, that doesn't work if the line ending isn't a newline. You
    might change that <span class="Li">&quot;tr///&quot;</span> to a
    <span class="Li">&quot;s///&quot;</span> so you can count the number of
    times the input record separator, <span class="Li">$/</span>, shows up:</p>
<p class="Pp"></p>
<pre>    my $lines = 0;
    open my($fh), '&lt;:raw', $filename or die &quot;Can't open $filename: $!&quot;;
    while( sysread $fh, $buffer, 4096 ) {
        $lines += ( $buffer =~ s|$/||g; );
    }
    close $fh;
</pre>
<p class="Pp">If you don't mind shelling out, the
    <span class="Li">&quot;wc&quot;</span> command is usually the fastest, even
    with the extra interprocess overhead. Ensure that you have an untainted
    filename though:</p>
<p class="Pp"></p>
<pre>    #!perl -T
    $ENV{PATH} = undef;
    my $lines;
    if( $filename =~ /^([0-9a-z_.]+)\z/ ) {
        $lines = `/usr/bin/wc -l $1`
        chomp $lines;
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_delete_the_last_N_lines_from_a_file?"><a class="permalink" href="#How_do_I_delete_the_last_N_lines_from_a_file?">How
  do I delete the last N lines from a file?</a></h2>
<p class="Pp">(contributed by brian d foy)</p>
<p class="Pp">The easiest conceptual solution is to count the lines in the file
    then start at the beginning and print the number of lines (minus the last N)
    to a new file.</p>
<p class="Pp">Most often, the real question is how you can delete the last N
    lines without making more than one pass over the file, or how to do it
    without a lot of copying. The easy concept is the hard reality when you
    might have millions of lines in your file.</p>
<p class="Pp">One trick is to use File::ReadBackwards, which starts at the end
    of the file. That module provides an object that wraps the real filehandle
    to make it easy for you to move around the file. Once you get to the spot
    you need, you can get the actual filehandle and work with it as normal. In
    this case, you get the file position at the end of the last line you want to
    keep and truncate the file to that point:</p>
<p class="Pp"></p>
<pre>    use File::ReadBackwards;
    my $filename = 'test.txt';
    my $Lines_to_truncate = 2;
    my $bw = File::ReadBackwards-&gt;new( $filename )
        or die &quot;Could not read backwards in [$filename]: $!&quot;;
    my $lines_from_end = 0;
    until( $bw-&gt;eof or $lines_from_end == $Lines_to_truncate ) {
        print &quot;Got: &quot;, $bw-&gt;readline;
        $lines_from_end++;
    }
    truncate( $filename, $bw-&gt;tell );
</pre>
<p class="Pp">The File::ReadBackwards module also has the advantage of setting
    the input record separator to a regular expression.</p>
<p class="Pp">You can also use the Tie::File module which lets you access the
    lines through a tied array. You can use normal array operations to modify
    your file, including setting the last index and using
    <span class="Li">&quot;splice&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_use_Perl's__"><a class="permalink" href="#How_can_I_use_Perl's__">How
  can I use Perl's &quot;-i&quot; option from within a program?</a></h2>
<p class="Pp"><span class="Li">&quot;-i&quot;</span> sets the value of Perl's
    <span class="Li">$^I</span> variable, which in turn affects the behavior of
    <span class="Li">&quot;&lt;&gt;&quot;</span>; see perlrun for more details.
    By modifying the appropriate variables directly, you can get the same
    behavior within a larger program. For example:</p>
<p class="Pp"></p>
<pre>    # ...
    {
        local($^I, @ARGV) = ('.orig', glob(&quot;*.c&quot;));
        while (&lt;&gt;) {
            if ($. == 1) {
                print &quot;This line should appear at the top of each file\n&quot;;
            }
            s/\b(p)earl\b/${1}erl/i;        # Correct typos, preserving case
            print;
            close ARGV if eof;              # Reset $.
        }
    }
    # $^I and @ARGV return to their old values here
</pre>
<p class="Pp">This block modifies all the <span class="Li">&quot;.c&quot;</span>
    files in the current directory, leaving a backup of the original data from
    each file in a new <span class="Li">&quot;.c.orig&quot;</span> file.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_copy_a_file?"><a class="permalink" href="#How_can_I_copy_a_file?">How
  can I copy a file?</a></h2>
<p class="Pp">(contributed by brian d foy)</p>
<p class="Pp">Use the File::Copy module. It comes with Perl and can do a true
    copy across file systems, and it does its magic in a portable fashion.</p>
<p class="Pp"></p>
<pre>    use File::Copy;
    copy( $original, $new_copy ) or die &quot;Copy failed: $!&quot;;
</pre>
<p class="Pp">If you can't use File::Copy, you'll have to do the work yourself:
    open the original file, open the destination file, then print to the
    destination file as you read the original. You also have to remember to copy
    the permissions, owner, and group to the new file.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_make_a_temporary_file_name?"><a class="permalink" href="#How_do_I_make_a_temporary_file_name?">How
  do I make a temporary file name?</a></h2>
<p class="Pp">If you don't need to know the name of the file, you can use
    <span class="Li">&quot;open()&quot;</span> with
    <span class="Li">&quot;undef&quot;</span> in place of the file name. In Perl
    5.8 or later, the <span class="Li">&quot;open()&quot;</span> function
    creates an anonymous temporary file:</p>
<p class="Pp"></p>
<pre>    open my $tmp, '+&gt;', undef or die $!;
</pre>
<p class="Pp">Otherwise, you can use the File::Temp module.</p>
<p class="Pp"></p>
<pre>    use File::Temp qw/ tempfile tempdir /;
    my $dir = tempdir( CLEANUP =&gt; 1 );
    ($fh, $filename) = tempfile( DIR =&gt; $dir );
    # or if you don't need to know the filename
    my $fh = tempfile( DIR =&gt; $dir );
</pre>
<p class="Pp">The File::Temp has been a standard module since Perl 5.6.1. If you
    don't have a modern enough Perl installed, use the
    <span class="Li">&quot;new_tmpfile&quot;</span> class method from the
    IO::File module to get a filehandle opened for reading and writing. Use it
    if you don't need to know the file's name:</p>
<p class="Pp"></p>
<pre>    use IO::File;
    my $fh = IO::File-&gt;new_tmpfile()
        or die &quot;Unable to make new temporary file: $!&quot;;
</pre>
<p class="Pp">If you're committed to creating a temporary file by hand, use the
    process ID and/or the current time-value. If you need to have many temporary
    files in one process, use a counter:</p>
<p class="Pp"></p>
<pre>    BEGIN {
        use Fcntl;
        use File::Spec;
        my $temp_dir  = File::Spec-&gt;tmpdir();
        my $file_base = sprintf &quot;%d-%d-0000&quot;, $$, time;
        my $base_name = File::Spec-&gt;catfile($temp_dir, $file_base);
        sub temp_file {
            my $fh;
            my $count = 0;
            until( defined(fileno($fh)) || $count++ &gt; 100 ) {
                $base_name =~ s/-(\d+)$/&quot;-&quot; . (1 + $1)/e;
                # O_EXCL is required for security reasons.
                sysopen $fh, $base_name, O_WRONLY|O_EXCL|O_CREAT;
            }
            if( defined fileno($fh) ) {
                return ($fh, $base_name);
            }
            else {
                return ();
            }
        }
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_manipulate_fixed-record-length_files?"><a class="permalink" href="#How_can_I_manipulate_fixed-record-length_files?">How
  can I manipulate fixed-record-length files?</a></h2>
<p class="Pp">The most efficient way is using <b>pack()</b> and <b>unpack()</b>.
    This is faster than using <b>substr()</b> when taking many, many strings. It
    is slower for just a few.</p>
<p class="Pp">Here is a sample chunk of code to break up and put back together
    again some fixed-format input lines, in this case from the output of a
    normal, Berkeley-style ps:</p>
<p class="Pp"></p>
<pre>    # sample input line:
    #   15158 p5  T      0:00 perl /home/tchrist/scripts/now-what
    my $PS_T = 'A6 A4 A7 A5 A*';
    open my $ps, '-|', 'ps';
    print scalar &lt;$ps&gt;;
    my @fields = qw( pid tt stat time command );
    while (&lt;$ps&gt;) {
        my %process;
        @process{@fields} = unpack($PS_T, $_);
        for my $field ( @fields ) {
            print &quot;$field: &lt;$process{$field}&gt;\n&quot;;
        }
        print 'line=', pack($PS_T, @process{@fields} ), &quot;\n&quot;;
    }
</pre>
<p class="Pp">We've used a hash slice in order to easily handle the fields of
    each row. Storing the keys in an array makes it easy to operate on them as a
    group or loop over them with <span class="Li">&quot;for&quot;</span>. It
    also avoids polluting the program with global variables and using symbolic
    references.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_make_a_filehandle_local_to_a_subroutine?_How_do_I_pass_filehandles_between_subroutines?_How_do_I_make_an_array_of_filehandles?"><a class="permalink" href="#How_can_I_make_a_filehandle_local_to_a_subroutine?_How_do_I_pass_filehandles_between_subroutines?_How_do_I_make_an_array_of_filehandles?">How
  can I make a filehandle local to a subroutine? How do I pass filehandles
  between subroutines? How do I make an array of filehandles?</a></h2>
<p class="Pp">As of perl5.6, <b>open()</b> autovivifies file and directory
    handles as references if you pass it an uninitialized scalar variable. You
    can then pass these references just like any other scalar, and use them in
    the place of named handles.</p>
<p class="Pp"></p>
<pre>    open my    $fh, $file_name;
    open local $fh, $file_name;
    print $fh &quot;Hello World!\n&quot;;
    process_file( $fh );
</pre>
<p class="Pp">If you like, you can store these filehandles in an array or a
    hash. If you access them directly, they aren't simple scalars and you need
    to give <span class="Li">&quot;print&quot;</span> a little help by placing
    the filehandle reference in braces. Perl can only figure it out on its own
    when the filehandle reference is a simple scalar.</p>
<p class="Pp"></p>
<pre>    my @fhs = ( $fh1, $fh2, $fh3 );
    for( $i = 0; $i &lt;= $#fhs; $i++ ) {
        print {$fhs[$i]} &quot;just another Perl answer, \n&quot;;
    }
</pre>
<p class="Pp">Before perl5.6, you had to deal with various typeglob idioms which
    you may see in older code.</p>
<p class="Pp"></p>
<pre>    open FILE, &quot;&gt; $filename&quot;;
    process_typeglob(   *FILE );
    process_reference( \*FILE );
    sub process_typeglob  { local *FH = shift; print FH  &quot;Typeglob!&quot; }
    sub process_reference { local $fh = shift; print $fh &quot;Reference!&quot; }
</pre>
<p class="Pp">If you want to create many anonymous handles, you should check out
    the Symbol or IO::Handle modules.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_use_a_filehandle_indirectly?"><a class="permalink" href="#How_can_I_use_a_filehandle_indirectly?">How
  can I use a filehandle indirectly?</a></h2>
<p class="Pp">An indirect filehandle is the use of something other than a symbol
    in a place that a filehandle is expected. Here are ways to get indirect
    filehandles:</p>
<p class="Pp"></p>
<pre>    $fh =   SOME_FH;       # bareword is strict-subs hostile
    $fh =  &quot;SOME_FH&quot;;      # strict-refs hostile; same package only
    $fh =  *SOME_FH;       # typeglob
    $fh = \*SOME_FH;       # ref to typeglob (bless-able)
    $fh =  *SOME_FH{IO};   # blessed IO::Handle from *SOME_FH typeglob
</pre>
<p class="Pp">Or, you can use the <span class="Li">&quot;new&quot;</span> method
    from one of the IO::* modules to create an anonymous filehandle and store
    that in a scalar variable.</p>
<p class="Pp"></p>
<pre>    use IO::Handle;                     # 5.004 or higher
    my $fh = IO::Handle-&gt;new();
</pre>
<p class="Pp">Then use any of those as you would a normal filehandle. Anywhere
    that Perl is expecting a filehandle, an indirect filehandle may be used
    instead. An indirect filehandle is just a scalar variable that contains a
    filehandle. Functions like <span class="Li">&quot;print&quot;</span>,
    <span class="Li">&quot;open&quot;</span>,
    <span class="Li">&quot;seek&quot;</span>, or the
    <span class="Li">&quot;&lt;FH&gt;&quot;</span> diamond operator will accept
    either a named filehandle or a scalar variable containing one:</p>
<p class="Pp"></p>
<pre>    ($ifh, $ofh, $efh) = (*STDIN, *STDOUT, *STDERR);
    print $ofh &quot;Type it: &quot;;
    my $got = &lt;$ifh&gt;
    print $efh &quot;What was that: $got&quot;;
</pre>
<p class="Pp">If you're passing a filehandle to a function, you can write the
    function in two ways:</p>
<p class="Pp"></p>
<pre>    sub accept_fh {
        my $fh = shift;
        print $fh &quot;Sending to indirect filehandle\n&quot;;
    }
</pre>
<p class="Pp">Or it can localize a typeglob and use the filehandle directly:</p>
<p class="Pp"></p>
<pre>    sub accept_fh {
        local *FH = shift;
        print  FH &quot;Sending to localized filehandle\n&quot;;
    }
</pre>
<p class="Pp">Both styles work with either objects or typeglobs of real
    filehandles. (They might also work with strings under some circumstances,
    but this is risky.)</p>
<p class="Pp"></p>
<pre>    accept_fh(*STDOUT);
    accept_fh($handle);
</pre>
<p class="Pp">In the examples above, we assigned the filehandle to a scalar
    variable before using it. That is because only simple scalar variables, not
    expressions or subscripts of hashes or arrays, can be used with built-ins
    like <span class="Li">&quot;print&quot;</span>,
    <span class="Li">&quot;printf&quot;</span>, or the diamond operator. Using
    something other than a simple scalar variable as a filehandle is illegal and
    won't even compile:</p>
<p class="Pp"></p>
<pre>    my @fd = (*STDIN, *STDOUT, *STDERR);
    print $fd[1] &quot;Type it: &quot;;                           # WRONG
    my $got = &lt;$fd[0]&gt;                                  # WRONG
    print $fd[2] &quot;What was that: $got&quot;;                 # WRONG
</pre>
<p class="Pp">With <span class="Li">&quot;print&quot;</span> and
    <span class="Li">&quot;printf&quot;</span>, you get around this by using a
    block and an expression where you would place the filehandle:</p>
<p class="Pp"></p>
<pre>    print  { $fd[1] } &quot;funny stuff\n&quot;;
    printf { $fd[1] } &quot;Pity the poor %x.\n&quot;, 3_735_928_559;
    # Pity the poor deadbeef.
</pre>
<p class="Pp">That block is a proper block like any other, so you can put more
    complicated code there. This sends the message out to one of two places:</p>
<p class="Pp"></p>
<pre>    my $ok = -x &quot;/bin/cat&quot;;
    print { $ok ? $fd[1] : $fd[2] } &quot;cat stat $ok\n&quot;;
    print { $fd[ 1+ ($ok || 0) ]  } &quot;cat stat $ok\n&quot;;
</pre>
<p class="Pp">This approach of treating
    <span class="Li">&quot;print&quot;</span> and
    <span class="Li">&quot;printf&quot;</span> like object methods calls doesn't
    work for the diamond operator. That's because it's a real operator, not just
    a function with a comma-less argument. Assuming you've been storing
    typeglobs in your structure as we did above, you can use the built-in
    function named <span class="Li">&quot;readline&quot;</span> to read a record
    just as <span class="Li">&quot;&lt;&gt;&quot;</span> does. Given the
    initialization shown above for <span class="Li">@fd</span>, this would work,
    but only because <b>readline()</b> requires a typeglob. It doesn't work with
    objects or strings, which might be a bug we haven't fixed yet.</p>
<p class="Pp"></p>
<pre>    $got = readline($fd[0]);
</pre>
<p class="Pp">Let it be noted that the flakiness of indirect filehandles is not
    related to whether they're strings, typeglobs, objects, or anything else.
    It's the syntax of the fundamental operators. Playing the object game
    doesn't help you at all here.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_open_a_filehandle_to_a_string?"><a class="permalink" href="#How_can_I_open_a_filehandle_to_a_string?">How
  can I open a filehandle to a string?</a></h2>
<p class="Pp">(contributed by Peter J. Holzer, hjp-usenet2@hjp.at)</p>
<p class="Pp">Since Perl 5.8.0 a file handle referring to a string can be
    created by calling open with a reference to that string instead of the
    filename. This file handle can then be used to read from or write to the
    string:</p>
<p class="Pp"></p>
<pre>    open(my $fh, '&gt;', \$string) or die &quot;Could not open string for writing&quot;;
    print $fh &quot;foo\n&quot;;
    print $fh &quot;bar\n&quot;;    # $string now contains &quot;foo\nbar\n&quot;
    open(my $fh, '&lt;', \$string) or die &quot;Could not open string for reading&quot;;
    my $x = &lt;$fh&gt;;    # $x now contains &quot;foo\n&quot;
</pre>
<p class="Pp">With older versions of Perl, the IO::String module provides
    similar functionality.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_set_up_a_footer_format_to_be_used_with_"><a class="permalink" href="#How_can_I_set_up_a_footer_format_to_be_used_with_">How
  can I set up a footer format to be used with <b>write()</b>?</a></h2>
<p class="Pp">There's no builtin way to do this, but perlform has a couple of
    techniques to make it possible for the intrepid hacker.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_"><a class="permalink" href="#How_can_I_">How can I
  <b>write()</b> into a string?</a></h2>
<p class="Pp">(contributed by brian d foy)</p>
<p class="Pp">If you want to <span class="Li">&quot;write&quot;</span> into a
    string, you just have to &lt;open&gt; a filehandle to a string, which Perl
    has been able to do since Perl 5.6:</p>
<p class="Pp"></p>
<pre>    open FH, '&gt;', \my $string;
    write( FH );
</pre>
<p class="Pp">Since you want to be a good programmer, you probably want to use a
    lexical filehandle, even though formats are designed to work with bareword
    filehandles since the default format names take the filehandle name.
    However, you can control this with some Perl special per-filehandle
    variables: <span class="Li">$^</span>, which names the top-of-page format,
    and <span class="Li">$~</span> which shows the line format. You have to
    change the default filehandle to set these variables:</p>
<p class="Pp"></p>
<pre>    open my($fh), '&gt;', \my $string;
    { # set per-filehandle variables
        my $old_fh = select( $fh );
        $~ = 'ANIMAL';
        $^ = 'ANIMAL_TOP';
        select( $old_fh );
    }
    format ANIMAL_TOP =
     ID  Type    Name
    .
    format ANIMAL =
    @##   @&lt;&lt;&lt;    @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
    $id,  $type,  $name
    .
</pre>
<p class="Pp">Although write can work with lexical or package variables,
    whatever variables you use have to scope in the format. That most likely
    means you'll want to localize some package variables:</p>
<p class="Pp"></p>
<pre>    {
        local( $id, $type, $name ) = qw( 12 cat Buster );
        write( $fh );
    }
    print $string;
</pre>
<p class="Pp">There are also some tricks that you can play with
    <span class="Li">&quot;formline&quot;</span> and the accumulator variable
    <span class="Li">$^A</span>, but you lose a lot of the value of formats
    since <span class="Li">&quot;formline&quot;</span> won't handle paging and
    so on. You end up reimplementing formats when you use them.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_output_my_numbers_with_commas_added?"><a class="permalink" href="#How_can_I_output_my_numbers_with_commas_added?">How
  can I output my numbers with commas added?</a></h2>
<p class="Pp">(contributed by brian d foy and Benjamin Goldberg)</p>
<p class="Pp">You can use Number::Format to separate places in a number. It
    handles locale information for those of you who want to insert full stops
    instead (or anything else that they want to use, really).</p>
<p class="Pp">This subroutine will add commas to your number:</p>
<p class="Pp"></p>
<pre>    sub commify {
        local $_  = shift;
        1 while s/^([-+]?\d+)(\d{3})/$1,$2/;
        return $_;
    }
</pre>
<p class="Pp">This regex from Benjamin Goldberg will add commas to numbers:</p>
<p class="Pp"></p>
<pre>    s/(^[-+]?\d+?(?=(?&gt;(?:\d{3})+)(?!\d))|\G\d{3}(?=\d))/$1,/g;
</pre>
<p class="Pp">It is easier to see with comments:</p>
<p class="Pp"></p>
<pre>    s/(
        ^[-+]?             # beginning of number.
        \d+?               # first digits before first comma
        (?=                # followed by, (but not included in the match) :
            (?&gt;(?:\d{3})+) # some positive multiple of three digits.
            (?!\d)         # an *exact* multiple, not x * 3 + 1 or whatever.
        )
        |                  # or:
        \G\d{3}            # after the last group, get three digits
        (?=\d)             # but they have to have more digits after them.
    )/$1,/xg;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_translate_tildes_(_)_in_a_filename?"><a class="permalink" href="#How_can_I_translate_tildes_(_)_in_a_filename?">How
  can I translate tildes (~) in a filename?</a></h2>
<p class="Pp">Use the &lt;&gt; (<span class="Li">&quot;glob()&quot;</span>)
    operator, documented in perlfunc. Versions of Perl older than 5.6 require
    that you have a shell installed that groks tildes. Later versions of Perl
    have this feature built in. The File::KGlob module (available from CPAN)
    gives more portable glob functionality.</p>
<p class="Pp">Within Perl, you may use this directly:</p>
<p class="Pp"></p>
<pre>    $filename =~ s{
      ^ ~             # find a leading tilde
      (               # save this in $1
          [^/]        # a non-slash character
                *     # repeated 0 or more times (0 means me)
      )
    }{
      $1
          ? (getpwnam($1))[7]
          : ( $ENV{HOME} || $ENV{LOGDIR} )
    }ex;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="How_come_when_I_open_a_file_read-write_it_wipes_it_out?"><a class="permalink" href="#How_come_when_I_open_a_file_read-write_it_wipes_it_out?">How
  come when I open a file read-write it wipes it out?</a></h2>
<p class="Pp">Because you're using something like this, which truncates the file
    <i>then</i> gives you read-write access:</p>
<p class="Pp"></p>
<pre>    open my $fh, '+&gt;', '/path/name'; # WRONG (almost always)
</pre>
<p class="Pp">Whoops. You should instead use this, which will fail if the file
    doesn't exist:</p>
<p class="Pp"></p>
<pre>    open my $fh, '+&lt;', '/path/name'; # open for update
</pre>
<p class="Pp">Using &quot;&gt;&quot; always clobbers or creates. Using
    &quot;&lt;&quot; never does either. The &quot;+&quot; doesn't change
  this.</p>
<p class="Pp">Here are examples of many kinds of file opens. Those using
    <span class="Li">&quot;sysopen&quot;</span> all assume that you've pulled in
    the constants from Fcntl:</p>
<p class="Pp"></p>
<pre>    use Fcntl;
</pre>
<p class="Pp">To open file for reading:</p>
<p class="Pp"></p>
<pre>    open my $fh, '&lt;', $path                               or die $!;
    sysopen my $fh, $path, O_RDONLY                       or die $!;
</pre>
<p class="Pp">To open file for writing, create new file if needed or else
    truncate old file:</p>
<p class="Pp"></p>
<pre>    open my $fh, '&gt;', $path                               or die $!;
    sysopen my $fh, $path, O_WRONLY|O_TRUNC|O_CREAT       or die $!;
    sysopen my $fh, $path, O_WRONLY|O_TRUNC|O_CREAT, 0666 or die $!;
</pre>
<p class="Pp">To open file for writing, create new file, file must not
  exist:</p>
<p class="Pp"></p>
<pre>    sysopen my $fh, $path, O_WRONLY|O_EXCL|O_CREAT        or die $!;
    sysopen my $fh, $path, O_WRONLY|O_EXCL|O_CREAT, 0666  or die $!;
</pre>
<p class="Pp">To open file for appending, create if necessary:</p>
<p class="Pp"></p>
<pre>    open my $fh, '&gt;&gt;', $path                              or die $!;
    sysopen my $fh, $path, O_WRONLY|O_APPEND|O_CREAT      or die $!;
    sysopen my $fh, $path, O_WRONLY|O_APPEND|O_CREAT, 0666 or die $!;
</pre>
<p class="Pp">To open file for appending, file must exist:</p>
<p class="Pp"></p>
<pre>    sysopen my $fh, $path, O_WRONLY|O_APPEND              or die $!;
</pre>
<p class="Pp">To open file for update, file must exist:</p>
<p class="Pp"></p>
<pre>    open my $fh, '+&lt;', $path                              or die $!;
    sysopen my $fh, $path, O_RDWR                         or die $!;
</pre>
<p class="Pp">To open file for update, create file if necessary:</p>
<p class="Pp"></p>
<pre>    sysopen my $fh, $path, O_RDWR|O_CREAT                 or die $!;
    sysopen my $fh, $path, O_RDWR|O_CREAT, 0666           or die $!;
</pre>
<p class="Pp">To open file for update, file must not exist:</p>
<p class="Pp"></p>
<pre>    sysopen my $fh, $path, O_RDWR|O_EXCL|O_CREAT          or die $!;
    sysopen my $fh, $path, O_RDWR|O_EXCL|O_CREAT, 0666    or die $!;
</pre>
<p class="Pp">To open a file without blocking, creating if necessary:</p>
<p class="Pp"></p>
<pre>    sysopen my $fh, '/foo/somefile', O_WRONLY|O_NDELAY|O_CREAT
        or die &quot;can't open /foo/somefile: $!&quot;:
</pre>
<p class="Pp">Be warned that neither creation nor deletion of files is
    guaranteed to be an atomic operation over NFS. That is, two processes might
    both successfully create or unlink the same file! Therefore O_EXCL isn't as
    exclusive as you might wish.</p>
<p class="Pp">See also perlopentut.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Why_do_I_sometimes_get_an__Argument_list_too_long__when_I_use__*_?"><a class="permalink" href="#Why_do_I_sometimes_get_an__Argument_list_too_long__when_I_use__*_?">Why
  do I sometimes get an &quot;Argument list too long&quot; when I use
  &lt;*&gt;?</a></h2>
<p class="Pp">The <span class="Li">&quot;&lt;&gt;&quot;</span> operator performs
    a globbing operation (see above). In Perl versions earlier than v5.6.0, the
    internal <b>glob()</b> operator forks <b>csh</b>(1) to do the actual glob
    expansion, but csh can't handle more than 127 items and so gives the error
    message <span class="Li">&quot;Argument list too long&quot;</span>. People
    who installed tcsh as csh won't have this problem, but their users may be
    surprised by it.</p>
<p class="Pp">To get around this, either upgrade to Perl v5.6.0 or later, do the
    glob yourself with <b>readdir()</b> and patterns, or use a module like
    File::Glob, one that doesn't use the shell to do globbing.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_open_a_file_named_with_a_leading_____or_trailing_blanks?"><a class="permalink" href="#How_can_I_open_a_file_named_with_a_leading_____or_trailing_blanks?">How
  can I open a file named with a leading &quot;&gt;&quot; or trailing
  blanks?</a></h2>
<p class="Pp">(contributed by Brian McCauley)</p>
<p class="Pp">The special two-argument form of Perl's <b>open()</b> function
    ignores trailing blanks in filenames and infers the mode from certain
    leading characters (or a trailing &quot;|&quot;). In older versions of Perl
    this was the only version of <b>open()</b> and so it is prevalent in old
    code and books.</p>
<p class="Pp">Unless you have a particular reason to use the two-argument form
    you should use the three-argument form of <b>open()</b> which does not treat
    any characters in the filename as special.</p>
<p class="Pp"></p>
<pre>    open my $fh, &quot;&lt;&quot;, &quot;  file  &quot;;  # filename is &quot;   file   &quot;
    open my $fh, &quot;&gt;&quot;, &quot;&gt;file&quot;;     # filename is &quot;&gt;file&quot;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_reliably_rename_a_file?"><a class="permalink" href="#How_can_I_reliably_rename_a_file?">How
  can I reliably rename a file?</a></h2>
<p class="Pp">If your operating system supports a proper <b>mv</b>(1) utility or
    its functional equivalent, this works:</p>
<p class="Pp"></p>
<pre>    rename($old, $new) or system(&quot;mv&quot;, $old, $new);
</pre>
<p class="Pp">It may be more portable to use the File::Copy module instead. You
    just copy to the new file to the new name (checking return values), then
    delete the old one. This isn't really the same semantically as a
    <span class="Li">&quot;rename()&quot;</span>, which preserves
    meta-information like permissions, timestamps, inode info, etc.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_lock_a_file?"><a class="permalink" href="#How_can_I_lock_a_file?">How
  can I lock a file?</a></h2>
<p class="Pp">Perl's builtin <b>flock()</b> function (see perlfunc for details)
    will call <b>flock</b>(2) if that exists, <b>fcntl</b>(2) if it doesn't (on
    perl version 5.004 and later), and <b>lockf</b>(3) if neither of the two
    previous system calls exists. On some systems, it may even use a different
    form of native locking. Here are some gotchas with Perl's
  <b>flock()</b>:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>Produces a fatal error if none of the three system calls (or their close
      equivalent) exists.</dd>
  <dt>2.</dt>
  <dd><b>lockf</b>(3) does not provide shared locking, and requires that the
      filehandle be open for writing (or appending, or read/writing).</dd>
  <dt>3.</dt>
  <dd>Some versions of <b>flock()</b> can't lock files over a network (e.g. on
      NFS file systems), so you'd need to force the use of <b>fcntl</b>(2) when
      you build Perl. But even this is dubious at best. See the flock entry of
      perlfunc and the <i>INSTALL</i> file in the source distribution for
      information on building Perl to do this.
    <p class="Pp">Two potentially non-obvious but traditional flock semantics
        are that it waits indefinitely until the lock is granted, and that its
        locks are <i>merely advisory</i>. Such discretionary locks are more
        flexible, but offer fewer guarantees. This means that files locked with
        <b>flock()</b> may be modified by programs that do not also use
        <b>flock()</b>. Cars that stop for red lights get on well with each
        other, but not with cars that don't stop for red lights. See the
        perlport manpage, your port's specific documentation, or your
        system-specific local manpages for details. It's best to assume
        traditional behavior if you're writing portable programs. (If you're
        not, you should as always feel perfectly free to write for your own
        system's idiosyncrasies (sometimes called &quot;features&quot;). Slavish
        adherence to portability concerns shouldn't get in the way of your
        getting your job done.)</p>
    <p class="Pp">For more information on file locking, see also &quot;File
        Locking&quot; in perlopentut if you have it (new for 5.6).</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Why_can't_I_just_open("><a class="permalink" href="#Why_can't_I_just_open(">Why
  can't I just open(FH, &quot;&gt;file.lock&quot;)?</a></h2>
<p class="Pp">A common bit of code <b>NOT TO USE</b> is this:</p>
<p class="Pp"></p>
<pre>    sleep(3) while -e 'file.lock';    # PLEASE DO NOT USE
    open my $lock, '&gt;', 'file.lock'; # THIS BROKEN CODE
</pre>
<p class="Pp">This is a classic race condition: you take two steps to do
    something which must be done in one. That's why computer hardware provides
    an atomic test-and-set instruction. In theory, this &quot;ought&quot; to
    work:</p>
<p class="Pp"></p>
<pre>    sysopen my $fh, &quot;file.lock&quot;, O_WRONLY|O_EXCL|O_CREAT
        or die &quot;can't open  file.lock: $!&quot;;
</pre>
<p class="Pp">except that lamentably, file creation (and deletion) is not atomic
    over NFS, so this won't work (at least, not every time) over the net.
    Various schemes involving <b>link()</b> have been suggested, but these tend
    to involve busy-wait, which is also less than desirable.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="I_still_don't_get_locking._I_just_want_to_increment_the_number_in_the_file._How_can_I_do_this?"><a class="permalink" href="#I_still_don't_get_locking._I_just_want_to_increment_the_number_in_the_file._How_can_I_do_this?">I
  still don't get locking. I just want to increment the number in the file. How
  can I do this?</a></h2>
<p class="Pp">Didn't anyone ever tell you web-page hit counters were useless?
    They don't count number of hits, they're a waste of time, and they serve
    only to stroke the writer's vanity. It's better to pick a random number;
    they're more realistic.</p>
<p class="Pp">Anyway, this is what you can do if you can't help yourself.</p>
<p class="Pp"></p>
<pre>    use Fcntl qw(:DEFAULT :flock);
    sysopen my $fh, &quot;numfile&quot;, O_RDWR|O_CREAT or die &quot;can't open numfile: $!&quot;;
    flock $fh, LOCK_EX                        or die &quot;can't flock numfile: $!&quot;;
    my $num = &lt;$fh&gt; || 0;
    seek $fh, 0, 0                            or die &quot;can't rewind numfile: $!&quot;;
    truncate $fh, 0                           or die &quot;can't truncate numfile: $!&quot;;
    (print $fh $num+1, &quot;\n&quot;)                  or die &quot;can't write numfile: $!&quot;;
    close $fh                                 or die &quot;can't close numfile: $!&quot;;
</pre>
<p class="Pp">Here's a much better web-page hit counter:</p>
<p class="Pp"></p>
<pre>    $hits = int( (time() - 850_000_000) / rand(1_000) );
</pre>
<p class="Pp">If the count doesn't impress your friends, then the code might.
    :-)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="All_I_want_to_do_is_append_a_small_amount_of_text_to_the_end_of_a_file._Do_I_still_have_to_use_locking?"><a class="permalink" href="#All_I_want_to_do_is_append_a_small_amount_of_text_to_the_end_of_a_file._Do_I_still_have_to_use_locking?">All
  I want to do is append a small amount of text to the end of a file. Do I still
  have to use locking?</a></h2>
<p class="Pp">If you are on a system that correctly implements
    <span class="Li">&quot;flock&quot;</span> and you use the example appending
    code from &quot;perldoc -f flock&quot; everything will be OK even if the OS
    you are on doesn't implement append mode correctly (if such a system
    exists). So if you are happy to restrict yourself to OSs that implement
    <span class="Li">&quot;flock&quot;</span> (and that's not really much of a
    restriction) then that is what you should do.</p>
<p class="Pp">If you know you are only going to use a system that does correctly
    implement appending (i.e. not Win32) then you can omit the
    <span class="Li">&quot;seek&quot;</span> from the code in the previous
    answer.</p>
<p class="Pp">If you know you are only writing code to run on an OS and
    filesystem that does implement append mode correctly (a local filesystem on
    a modern Unix for example), and you keep the file in block-buffered mode and
    you write less than one buffer-full of output between each manual flushing
    of the buffer then each bufferload is almost guaranteed to be written to the
    end of the file in one chunk without getting intermingled with anyone else's
    output. You can also use the <span class="Li">&quot;syswrite&quot;</span>
    function which is simply a wrapper around your system's
    <span class="Li">write(2)</span> system call.</p>
<p class="Pp">There is still a small theoretical chance that a signal will
    interrupt the system-level <span class="Li">&quot;write()&quot;</span>
    operation before completion. There is also a possibility that some STDIO
    implementations may call multiple system level
    <span class="Li">&quot;write()&quot;</span>s even if the buffer was empty to
    start. There may be some systems where this probability is reduced to zero,
    and this is not a concern when using
    <span class="Li">&quot;:perlio&quot;</span> instead of your system's
  STDIO.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_randomly_update_a_binary_file?"><a class="permalink" href="#How_do_I_randomly_update_a_binary_file?">How
  do I randomly update a binary file?</a></h2>
<p class="Pp">If you're just trying to patch a binary, in many cases something
    as simple as this works:</p>
<p class="Pp"></p>
<pre>    perl -i -pe 's{window manager}{window mangler}g' /usr/bin/emacs
</pre>
<p class="Pp">However, if you have fixed sized records, then you might do
    something more like this:</p>
<p class="Pp"></p>
<pre>    my $RECSIZE = 220; # size of record, in bytes
    my $recno   = 37;  # which record to update
    open my $fh, '+&lt;', 'somewhere' or die &quot;can't update somewhere: $!&quot;;
    seek $fh, $recno * $RECSIZE, 0;
    read $fh, $record, $RECSIZE == $RECSIZE or die &quot;can't read record $recno: $!&quot;;
    # munge the record
    seek $fh, -$RECSIZE, 1;
    print $fh $record;
    close $fh;
</pre>
<p class="Pp">Locking and error checking are left as an exercise for the reader.
    Don't forget them or you'll be quite sorry.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_get_a_file's_timestamp_in_perl?"><a class="permalink" href="#How_do_I_get_a_file's_timestamp_in_perl?">How
  do I get a file's timestamp in perl?</a></h2>
<p class="Pp">If you want to retrieve the time at which the file was last read,
    written, or had its meta-data (owner, etc) changed, you use the <b>-A</b>,
    <b>-M</b>, or <b>-C</b> file test operations as documented in perlfunc.
    These retrieve the age of the file (measured against the start-time of your
    program) in days as a floating point number. Some platforms may not have all
    of these times. See perlport for details. To retrieve the &quot;raw&quot;
    time in seconds since the epoch, you would call the stat function, then use
    <span class="Li">&quot;localtime()&quot;</span>,
    <span class="Li">&quot;gmtime()&quot;</span>, or
    <span class="Li">&quot;POSIX::strftime()&quot;</span> to convert this into
    human-readable form.</p>
<p class="Pp">Here's an example:</p>
<p class="Pp"></p>
<pre>    my $write_secs = (stat($file))[9];
    printf &quot;file %s updated at %s\n&quot;, $file,
        scalar localtime($write_secs);
</pre>
<p class="Pp">If you prefer something more legible, use the File::stat module
    (part of the standard distribution in version 5.004 and later):</p>
<p class="Pp"></p>
<pre>    # error checking left as an exercise for reader.
    use File::stat;
    use Time::localtime;
    my $date_string = ctime(stat($file)-&gt;mtime);
    print &quot;file $file updated at $date_string\n&quot;;
</pre>
<p class="Pp">The <b>POSIX::strftime()</b> approach has the benefit of being, in
    theory, independent of the current locale. See perllocale for details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_set_a_file's_timestamp_in_perl?"><a class="permalink" href="#How_do_I_set_a_file's_timestamp_in_perl?">How
  do I set a file's timestamp in perl?</a></h2>
<p class="Pp">You use the <b>utime()</b> function documented in
    &quot;utime&quot; in perlfunc. By way of example, here's a little program
    that copies the read and write times from its first argument to all the rest
    of them.</p>
<p class="Pp"></p>
<pre>    if (@ARGV &lt; 2) {
        die &quot;usage: cptimes timestamp_file other_files ...\n&quot;;
    }
    my $timestamp = shift;
    my($atime, $mtime) = (stat($timestamp))[8,9];
    utime $atime, $mtime, @ARGV;
</pre>
<p class="Pp">Error checking is, as usual, left as an exercise for the
  reader.</p>
<p class="Pp">The perldoc for utime also has an example that has the same effect
    as <b>touch</b>(1) on files that <i>already exist</i>.</p>
<p class="Pp">Certain file systems have a limited ability to store the times on
    a file at the expected level of precision. For example, the FAT and HPFS
    filesystem are unable to create dates on files with a finer granularity than
    two seconds. This is a limitation of the filesystems, not of
  <b>utime()</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_print_to_more_than_one_file_at_once?"><a class="permalink" href="#How_do_I_print_to_more_than_one_file_at_once?">How
  do I print to more than one file at once?</a></h2>
<p class="Pp">To connect one filehandle to several output filehandles, you can
    use the IO::Tee or Tie::FileHandle::Multiplex modules.</p>
<p class="Pp">If you only have to do this once, you can print individually to
    each filehandle.</p>
<p class="Pp"></p>
<pre>    for my $fh ($fh1, $fh2, $fh3) { print $fh &quot;whatever\n&quot; }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_read_in_an_entire_file_all_at_once?"><a class="permalink" href="#How_can_I_read_in_an_entire_file_all_at_once?">How
  can I read in an entire file all at once?</a></h2>
<p class="Pp">The customary Perl approach for processing all the lines in a file
    is to do so one line at a time:</p>
<p class="Pp"></p>
<pre>    open my $input, '&lt;', $file or die &quot;can't open $file: $!&quot;;
    while (&lt;$input&gt;) {
        chomp;
        # do something with $_
    }
    close $input or die &quot;can't close $file: $!&quot;;
</pre>
<p class="Pp">This is tremendously more efficient than reading the entire file
    into memory as an array of lines and then processing it one element at a
    time, which is often--if not almost always--the wrong approach. Whenever you
    see someone do this:</p>
<p class="Pp"></p>
<pre>    my @lines = &lt;INPUT&gt;;
</pre>
<p class="Pp">You should think long and hard about why you need everything
    loaded at once. It's just not a scalable solution.</p>
<p class="Pp">If you &quot;mmap&quot; the file with the File::Map module from
    CPAN, you can virtually load the entire file into a string without actually
    storing it in memory:</p>
<p class="Pp"></p>
<pre>    use File::Map qw(map_file);
    map_file my $string, $filename;
</pre>
<p class="Pp">Once mapped, you can treat <span class="Li">$string</span> as you
    would any other string. Since you don't necessarily have to load the data,
    mmap-ing can be very fast and may not increase your memory footprint.</p>
<p class="Pp">You might also find it more fun to use the standard Tie::File
    module, or the DB_File module's <span class="Li">$DB_RECNO</span> bindings,
    which allow you to tie an array to a file so that accessing an element of
    the array actually accesses the corresponding line in the file.</p>
<p class="Pp">If you want to load the entire file, you can use the Path::Tiny
    module to do it in one simple and efficient step:</p>
<p class="Pp"></p>
<pre>    use Path::Tiny;
    my $all_of_it = path($filename)-&gt;slurp; # entire file in scalar
    my @all_lines = path($filename)-&gt;lines; # one line per element
</pre>
<p class="Pp">Or you can read the entire file contents into a scalar like
  this:</p>
<p class="Pp"></p>
<pre>    my $var;
    {
        local $/;
        open my $fh, '&lt;', $file or die &quot;can't open $file: $!&quot;;
        $var = &lt;$fh&gt;;
    }
</pre>
<p class="Pp">That temporarily undefs your record separator, and will
    automatically close the file at block exit. If the file is already open,
    just use this:</p>
<p class="Pp"></p>
<pre>    my $var = do { local $/; &lt;$fh&gt; };
</pre>
<p class="Pp">You can also use a localized <span class="Li">@ARGV</span> to
    eliminate the <span class="Li">&quot;open&quot;</span>:</p>
<p class="Pp"></p>
<pre>    my $var = do { local( @ARGV, $/ ) = $file; &lt;&gt; };
</pre>
<p class="Pp">For ordinary files you can also use the
    <span class="Li">&quot;read&quot;</span> function.</p>
<p class="Pp"></p>
<pre>    read( $fh, $var, -s $fh );
</pre>
<p class="Pp">That third argument tests the byte size of the data on the
    <span class="Li">$fh</span> filehandle and reads that many bytes into the
    buffer <span class="Li">$var</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_read_in_a_file_by_paragraphs?"><a class="permalink" href="#How_can_I_read_in_a_file_by_paragraphs?">How
  can I read in a file by paragraphs?</a></h2>
<p class="Pp">Use the <span class="Li">$/</span> variable (see perlvar for
    details). You can either set it to <span class="Li">&quot;&quot;</span> to
    eliminate empty paragraphs
    (<span class="Li">&quot;abc\n\n\n\ndef&quot;</span>, for instance, gets
    treated as two paragraphs and not three), or
    <span class="Li">&quot;\n\n&quot;</span> to accept empty paragraphs.</p>
<p class="Pp">Note that a blank line must have no blanks in it. Thus
    <span class="Li">&quot;fred\n&#x00A0;\nstuff\n\n&quot;</span> is one
    paragraph, but <span class="Li">&quot;fred\n\nstuff\n\n&quot;</span> is
  two.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_read_a_single_character_from_a_file?_From_the_keyboard?"><a class="permalink" href="#How_can_I_read_a_single_character_from_a_file?_From_the_keyboard?">How
  can I read a single character from a file? From the keyboard?</a></h2>
<p class="Pp">You can use the builtin <span class="Li">&quot;getc()&quot;</span>
    function for most filehandles, but it won't (easily) work on a terminal
    device. For STDIN, either use the Term::ReadKey module from CPAN or use the
    sample code in &quot;getc&quot; in perlfunc.</p>
<p class="Pp">If your system supports the portable operating system programming
    interface (POSIX), you can use the following code, which you'll note turns
    off echo processing as well.</p>
<p class="Pp"></p>
<pre>    #!/usr/bin/perl -w
    use strict;
    $| = 1;
    for (1..4) {
        print &quot;gimme: &quot;;
        my $got = getone();
        print &quot;--&gt; $got\n&quot;;
    }
    exit;
    BEGIN {
        use POSIX qw(:termios_h);
        my ($term, $oterm, $echo, $noecho, $fd_stdin);
        my $fd_stdin = fileno(STDIN);
        $term     = POSIX::Termios-&gt;new();
        $term-&gt;getattr($fd_stdin);
        $oterm     = $term-&gt;getlflag();
        $echo     = ECHO | ECHOK | ICANON;
        $noecho   = $oterm &amp; ~$echo;
        sub cbreak {
            $term-&gt;setlflag($noecho);
            $term-&gt;setcc(VTIME, 1);
            $term-&gt;setattr($fd_stdin, TCSANOW);
        }
        sub cooked {
            $term-&gt;setlflag($oterm);
            $term-&gt;setcc(VTIME, 0);
            $term-&gt;setattr($fd_stdin, TCSANOW);
        }
        sub getone {
            my $key = '';
            cbreak();
            sysread(STDIN, $key, 1);
            cooked();
            return $key;
        }
    }
    END { cooked() }
</pre>
<p class="Pp">The Term::ReadKey module from CPAN may be easier to use. Recent
    versions include also support for non-portable systems as well.</p>
<p class="Pp"></p>
<pre>    use Term::ReadKey;
    open my $tty, '&lt;', '/dev/tty';
    print &quot;Gimme a char: &quot;;
    ReadMode &quot;raw&quot;;
    my $key = ReadKey 0, $tty;
    ReadMode &quot;normal&quot;;
    printf &quot;\nYou said %s, char number %03d\n&quot;,
        $key, ord $key;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_tell_whether_there's_a_character_waiting_on_a_filehandle?"><a class="permalink" href="#How_can_I_tell_whether_there's_a_character_waiting_on_a_filehandle?">How
  can I tell whether there's a character waiting on a filehandle?</a></h2>
<p class="Pp">The very first thing you should do is look into getting the
    Term::ReadKey extension from CPAN. As we mentioned earlier, it now even has
    limited support for non-portable (read: not open systems, closed,
    proprietary, not POSIX, not Unix, etc.) systems.</p>
<p class="Pp">You should also check out the Frequently Asked Questions list in
    comp.unix.* for things like this: the answer is essentially the same. It's
    very system-dependent. Here's one solution that works on BSD systems:</p>
<p class="Pp"></p>
<pre>    sub key_ready {
        my($rin, $nfd);
        vec($rin, fileno(STDIN), 1) = 1;
        return $nfd = select($rin,undef,undef,0);
    }
</pre>
<p class="Pp">If you want to find out how many characters are waiting, there's
    also the FIONREAD ioctl call to be looked at. The <i>h2ph</i> tool that
    comes with Perl tries to convert C include files to Perl code, which can be
    <span class="Li">&quot;require&quot;</span>d. FIONREAD ends up defined as a
    function in the <i>sys/ioctl.ph</i> file:</p>
<p class="Pp"></p>
<pre>    require './sys/ioctl.ph';
    $size = pack(&quot;L&quot;, 0);
    ioctl(FH, FIONREAD(), $size)    or die &quot;Couldn't call ioctl: $!\n&quot;;
    $size = unpack(&quot;L&quot;, $size);
</pre>
<p class="Pp">If <i>h2ph</i> wasn't installed or doesn't work for you, you can
    <i>grep</i> the include files by hand:</p>
<p class="Pp"></p>
<pre>    % grep FIONREAD /usr/include/*/*
    /usr/include/asm/ioctls.h:#define FIONREAD      0x541B
</pre>
<p class="Pp">Or write a small C program using the editor of champions:</p>
<p class="Pp"></p>
<pre>    % cat &gt; fionread.c
    #include &lt;sys/ioctl.h&gt;
    main() {
        printf(&quot;%#08x\n&quot;, FIONREAD);
    }
    ^D
    % cc -o fionread fionread.c
    % ./fionread
    0x4004667f
</pre>
<p class="Pp">And then hard-code it, leaving porting as an exercise to your
    successor.</p>
<p class="Pp"></p>
<pre>    $FIONREAD = 0x4004667f;         # XXX: opsys dependent
    $size = pack(&quot;L&quot;, 0);
    ioctl(FH, $FIONREAD, $size)     or die &quot;Couldn't call ioctl: $!\n&quot;;
    $size = unpack(&quot;L&quot;, $size);
</pre>
<p class="Pp">FIONREAD requires a filehandle connected to a stream, meaning that
    sockets, pipes, and tty devices work, but <i>not</i> files.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_do_a__tail_"><a class="permalink" href="#How_do_I_do_a__tail_">How
  do I do a &quot;tail -f&quot; in perl?</a></h2>
<p class="Pp">First try</p>
<p class="Pp"></p>
<pre>    seek($gw_fh, 0, 1);
</pre>
<p class="Pp">The statement <span class="Li">&quot;seek($gw_fh, 0,
    1)&quot;</span> doesn't change the current position, but it does clear the
    end-of-file condition on the handle, so that the next
    <span class="Li">&quot;&lt;$gw_fh&gt;&quot;</span> makes Perl try again to
    read something.</p>
<p class="Pp">If that doesn't work (it relies on features of your stdio
    implementation), then you need something more like this:</p>
<p class="Pp"></p>
<pre>    for (;;) {
      for ($curpos = tell($gw_fh); &lt;$gw_fh&gt;; $curpos =tell($gw_fh)) {
        # search for some stuff and put it into files
      }
      # sleep for a while
      seek($gw_fh, $curpos, 0);  # seek to where we had been
    }
</pre>
<p class="Pp">If this still doesn't work, look into the
    <span class="Li">&quot;clearerr&quot;</span> method from IO::Handle, which
    resets the error and end-of-file states on the handle.</p>
<p class="Pp">There's also a File::Tail module from CPAN.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_"><a class="permalink" href="#How_do_I_">How do I
  <b>dup()</b> a filehandle in Perl?</a></h2>
<p class="Pp">If you check &quot;open&quot; in perlfunc, you'll see that several
    of the ways to call <b>open()</b> should do the trick. For example:</p>
<p class="Pp"></p>
<pre>    open my $log, '&gt;&gt;', '/foo/logfile';
    open STDERR, '&gt;&amp;', $log;
</pre>
<p class="Pp">Or even with a literal numeric descriptor:</p>
<p class="Pp"></p>
<pre>    my $fd = $ENV{MHCONTEXTFD};
    open $mhcontext, &quot;&lt;&amp;=$fd&quot;;  # like fdopen(3S)
</pre>
<p class="Pp">Note that &quot;&lt;&amp;STDIN&quot; makes a copy, but
    &quot;&lt;&amp;=STDIN&quot; makes an alias. That means if you close an
    aliased handle, all aliases become inaccessible. This is not true with a
    copied one.</p>
<p class="Pp">Error checking, as always, has been left as an exercise for the
    reader.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_close_a_file_descriptor_by_number?"><a class="permalink" href="#How_do_I_close_a_file_descriptor_by_number?">How
  do I close a file descriptor by number?</a></h2>
<p class="Pp">If, for some reason, you have a file descriptor instead of a
    filehandle (perhaps you used
    <span class="Li">&quot;POSIX::open&quot;</span>), you can use the
    <span class="Li">&quot;close()&quot;</span> function from the POSIX
  module:</p>
<p class="Pp"></p>
<pre>    use POSIX ();
    POSIX::close( $fd );
</pre>
<p class="Pp">This should rarely be necessary, as the Perl
    <span class="Li">&quot;close()&quot;</span> function is to be used for
    things that Perl opened itself, even if it was a dup of a numeric descriptor
    as with <span class="Li">&quot;MHCONTEXT&quot;</span> above. But if you
    really have to, you may be able to do this:</p>
<p class="Pp"></p>
<pre>    require './sys/syscall.ph';
    my $rc = syscall(SYS_close(), $fd + 0);  # must force numeric
    die &quot;can't sysclose $fd: $!&quot; unless $rc == -1;
</pre>
<p class="Pp">Or, just use the fdopen(3S) feature of
    <span class="Li">&quot;open()&quot;</span>:</p>
<p class="Pp"></p>
<pre>    {
        open my $fh, &quot;&lt;&amp;=$fd&quot; or die &quot;Cannot reopen fd=$fd: $!&quot;;
        close $fh;
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Why_can't_I_use__C:"><a class="permalink" href="#Why_can't_I_use__C:">Why
  can't I use &quot;C:\temp\foo&quot; in DOS paths? Why doesn't
  `C:\temp\foo.exe` work?</a></h2>
<p class="Pp">Whoops! You just put a tab and a formfeed into that filename!
    Remember that within double quoted strings (&quot;like\this&quot;), the
    backslash is an escape character. The full list of these is in &quot;Quote
    and Quote-like Operators&quot; in perlop. Unsurprisingly, you don't have a
    file called &quot;c:(tab)emp(formfeed)oo&quot; or
    &quot;c:(tab)emp(formfeed)oo.exe&quot; on your legacy DOS filesystem.</p>
<p class="Pp">Either single-quote your strings, or (preferably) use forward
    slashes. Since all DOS and Windows versions since something like MS-DOS 2.0
    or so have treated <span class="Li">&quot;/&quot;</span> and
    <span class="Li">&quot;\&quot;</span> the same in a path, you might as well
    use the one that doesn't clash with Perl--or the POSIX shell, ANSI C and
    C++, awk, Tcl, Java, or Python, just to mention a few. POSIX paths are more
    portable, too.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Why_doesn't_glob(_*.*_)_get_all_the_files?"><a class="permalink" href="#Why_doesn't_glob(_*.*_)_get_all_the_files?">Why
  doesn't glob(&quot;*.*&quot;) get all the files?</a></h2>
<p class="Pp">Because even on non-Unix ports, Perl's glob function follows
    standard Unix globbing semantics. You'll need
    <span class="Li">&quot;glob(&quot;*&quot;)&quot;</span> to get all
    (non-hidden) files. This makes <b>glob()</b> portable even to legacy
    systems. Your port may include proprietary globbing functions as well. Check
    its documentation for details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Why_does_Perl_let_me_delete_read-only_files?_Why_does__"><a class="permalink" href="#Why_does_Perl_let_me_delete_read-only_files?_Why_does__">Why
  does Perl let me delete read-only files? Why does &quot;-i&quot; clobber
  protected files? Isn't this a bug in Perl?</a></h2>
<p class="Pp">This is elaborately and painstakingly described in the
    <i>file-dir-perms</i> article in the &quot;Far More Than You Ever Wanted To
    Know&quot; collection in
    &lt;http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz&gt; .</p>
<p class="Pp">The executive summary: learn how your filesystem works. The
    permissions on a file say what can happen to the data in that file. The
    permissions on a directory say what can happen to the list of files in that
    directory. If you delete a file, you're removing its name from the directory
    (so the operation depends on the permissions of the directory, not of the
    file). If you try to write to the file, the permissions of the file govern
    whether you're allowed to.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_select_a_random_line_from_a_file?"><a class="permalink" href="#How_do_I_select_a_random_line_from_a_file?">How
  do I select a random line from a file?</a></h2>
<p class="Pp">Short of loading the file into a database or pre-indexing the
    lines in the file, there are a couple of things that you can do.</p>
<p class="Pp">Here's a reservoir-sampling algorithm from the Camel Book:</p>
<p class="Pp"></p>
<pre>    srand;
    rand($.) &lt; 1 &amp;&amp; ($line = $_) while &lt;&gt;;
</pre>
<p class="Pp">This has a significant advantage in space over reading the whole
    file in. You can find a proof of this method in <i>The Art of Computer</i>
    <i>Programming</i>, Volume 2, Section 3.4.2, by Donald E. Knuth.</p>
<p class="Pp">You can use the File::Random module which provides a function for
    that algorithm:</p>
<p class="Pp"></p>
<pre>    use File::Random qw/random_line/;
    my $line = random_line($filename);
</pre>
<p class="Pp">Another way is to use the Tie::File module, which treats the
    entire file as an array. Simply access a random array element.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Why_do_I_get_weird_spaces_when_I_print_an_array_of_lines?"><a class="permalink" href="#Why_do_I_get_weird_spaces_when_I_print_an_array_of_lines?">Why
  do I get weird spaces when I print an array of lines?</a></h2>
<p class="Pp">(contributed by brian d foy)</p>
<p class="Pp">If you are seeing spaces between the elements of your array when
    you print the array, you are probably interpolating the array in double
    quotes:</p>
<p class="Pp"></p>
<pre>    my @animals = qw(camel llama alpaca vicuna);
    print &quot;animals are: @animals\n&quot;;
</pre>
<p class="Pp">It's the double quotes, not the
    <span class="Li">&quot;print&quot;</span>, doing this. Whenever you
    interpolate an array in a double quote context, Perl joins the elements with
    spaces (or whatever is in <span class="Li">$&quot;</span>, which is a space
    by default):</p>
<p class="Pp"></p>
<pre>    animals are: camel llama alpaca vicuna
</pre>
<p class="Pp">This is different than printing the array without the
    interpolation:</p>
<p class="Pp"></p>
<pre>    my @animals = qw(camel llama alpaca vicuna);
    print &quot;animals are: &quot;, @animals, &quot;\n&quot;;
</pre>
<p class="Pp">Now the output doesn't have the spaces between the elements
    because the elements of <span class="Li">@animals</span> simply become part
    of the list to <span class="Li">&quot;print&quot;</span>:</p>
<p class="Pp"></p>
<pre>    animals are: camelllamaalpacavicuna
</pre>
<p class="Pp">You might notice this when each of the elements of
    <span class="Li">@array</span> end with a newline. You expect to print one
    element per line, but notice that every line after the first is
  indented:</p>
<p class="Pp"></p>
<pre>    this is a line
     this is another line
     this is the third line
</pre>
<p class="Pp">That extra space comes from the interpolation of the array. If you
    don't want to put anything between your array elements, don't use the array
    in double quotes. You can send it to print without them:</p>
<p class="Pp"></p>
<pre>    print @lines;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_traverse_a_directory_tree?"><a class="permalink" href="#How_do_I_traverse_a_directory_tree?">How
  do I traverse a directory tree?</a></h2>
<p class="Pp">(contributed by brian d foy)</p>
<p class="Pp">The File::Find module, which comes with Perl, does all of the hard
    work to traverse a directory structure. It comes with Perl. You simply call
    the <span class="Li">&quot;find&quot;</span> subroutine with a callback
    subroutine and the directories you want to traverse:</p>
<p class="Pp"></p>
<pre>    use File::Find;
    find( \&amp;wanted, @directories );
    sub wanted {
        # full path in $File::Find::name
        # just filename in $_
        ... do whatever you want to do ...
    }
</pre>
<p class="Pp">The File::Find::Closures, which you can download from CPAN,
    provides many ready-to-use subroutines that you can use with File::Find.</p>
<p class="Pp">The File::Finder, which you can download from CPAN, can help you
    create the callback subroutine using something closer to the syntax of the
    <span class="Li">&quot;find&quot;</span> command-line utility:</p>
<p class="Pp"></p>
<pre>    use File::Find;
    use File::Finder;
    my $deep_dirs = File::Finder-&gt;depth-&gt;type('d')-&gt;ls-&gt;exec('rmdir','{}');
    find( $deep_dirs-&gt;as_options, @places );
</pre>
<p class="Pp">The File::Find::Rule module, which you can download from CPAN, has
    a similar interface, but does the traversal for you too:</p>
<p class="Pp"></p>
<pre>    use File::Find::Rule;
    my @files = File::Find::Rule-&gt;file()
                             -&gt;name( '*.pm' )
                             -&gt;in( @INC );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_delete_a_directory_tree?"><a class="permalink" href="#How_do_I_delete_a_directory_tree?">How
  do I delete a directory tree?</a></h2>
<p class="Pp">(contributed by brian d foy)</p>
<p class="Pp">If you have an empty directory, you can use Perl's built-in
    <span class="Li">&quot;rmdir&quot;</span>. If the directory is not empty
    (so, with files or subdirectories), you either have to empty it yourself (a
    lot of work) or use a module to help you.</p>
<p class="Pp">The File::Path module, which comes with Perl, has a
    <span class="Li">&quot;remove_tree&quot;</span> which can take care of all
    of the hard work for you:</p>
<p class="Pp"></p>
<pre>    use File::Path qw(remove_tree);
    remove_tree( @directories );
</pre>
<p class="Pp">The File::Path module also has a legacy interface to the older
    <span class="Li">&quot;rmtree&quot;</span> subroutine.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_copy_an_entire_directory?"><a class="permalink" href="#How_do_I_copy_an_entire_directory?">How
  do I copy an entire directory?</a></h2>
<p class="Pp">(contributed by Shlomi Fish)</p>
<p class="Pp">To do the equivalent of <span class="Li">&quot;cp -R&quot;</span>
    (i.e. copy an entire directory tree recursively) in portable Perl, you'll
    either need to write something yourself or find a good CPAN module such as
    File::Copy::Recursive.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR_AND_COPYRIGHT"><a class="permalink" href="#AUTHOR_AND_COPYRIGHT">AUTHOR
  AND COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 1997-2010 Tom Christiansen, Nathan Torkington, and
    other authors as noted. All rights reserved.</p>
<p class="Pp">This documentation is free; you can redistribute it and/or modify
    it under the same terms as Perl itself.</p>
<p class="Pp">Irrespective of its distribution, all code examples here are in
    the public domain. You are permitted and encouraged to use this code and any
    derivatives thereof in your own programs for fun or for profit as you see
    fit. A simple comment in the code giving credit to the FAQ would be
    courteous but is not required.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os"><a href="..">perl v5.34.1</a></td>
  </tr>
</table>
</body>
</html>

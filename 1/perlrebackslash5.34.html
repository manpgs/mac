<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PERLREBACKSLASH(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLREBACKSLASH(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLREBACKSLASH(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlrebackslash - Perl Regular Expression Backslash Sequences and
    Escapes</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The top level documentation about Perl regular expressions is
    found in perlre.</p>
<p class="Pp">This document describes all backslash and escape sequences. After
    explaining the role of the backslash, it lists all the sequences that have a
    special meaning in Perl regular expressions (in alphabetical order), then
    describes each of them.</p>
<p class="Pp">Most sequences are described in detail in different documents; the
    primary purpose of this document is to have a quick reference guide
    describing all backslash and escape sequences.</p>
<section class="Ss">
<h2 class="Ss" id="The_backslash"><a class="permalink" href="#The_backslash">The
  backslash</a></h2>
<p class="Pp">In a regular expression, the backslash can perform one of two
    tasks: it either takes away the special meaning of the character following
    it (for instance, <span class="Li">&quot;\|&quot;</span> matches a vertical
    bar, it's not an alternation), or it is the start of a backslash or escape
    sequence.</p>
<p class="Pp">The rules determining what it is are quite simple: if the
    character following the backslash is an ASCII punctuation (non-word)
    character (that is, anything that is not a letter, digit, or underscore),
    then the backslash just takes away any special meaning of the character
    following it.</p>
<p class="Pp">If the character following the backslash is an ASCII letter or an
    ASCII digit, then the sequence may be special; if so, it's listed below. A
    few letters have not been used yet, so escaping them with a backslash
    doesn't change them to be special. A future version of Perl may assign a
    special meaning to them, so if you have warnings turned on, Perl issues a
    warning if you use such a sequence. [1].</p>
<p class="Pp">It is however guaranteed that backslash or escape sequences never
    have a punctuation character following the backslash, not now, and not in a
    future version of Perl 5. So it is safe to put a backslash in front of a
    non-word character.</p>
<p class="Pp">Note that the backslash itself is special; if you want to match a
    backslash, you have to escape the backslash with a backslash:
    <span class="Li">&quot;/\\/&quot;</span> matches a single backslash.</p>
<dl class="Bl-tag">
  <dt>[1]</dt>
  <dd>There is one exception. If you use an alphanumeric character as the
      delimiter of your pattern (which you probably shouldn't do for readability
      reasons), you have to escape the delimiter if you want to match it. Perl
      won't warn then. See also &quot;Gory details of parsing quoted
      constructs&quot; in perlop.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="All_the_sequences_and_escapes"><a class="permalink" href="#All_the_sequences_and_escapes">All
  the sequences and escapes</a></h2>
<p class="Pp">Those not usable within a bracketed character class (like
    <span class="Li">&quot;[\da-z]&quot;</span>) are marked as
    <span class="Li">&quot;Not in [].&quot;</span></p>
<p class="Pp"></p>
<pre> \000              Octal escape sequence.  See also \o{}.
 \1                Absolute backreference.  Not in [].
 \a                Alarm or bell.
 \A                Beginning of string.  Not in [].
 \b{}, \b          Boundary. (\b is a backspace in []).
 \B{}, \B          Not a boundary.  Not in [].
 \cX               Control-X.
 \d                Match any digit character.
 \D                Match any character that isn't a digit.
 \e                Escape character.
 \E                Turn off \Q, \L and \U processing.  Not in [].
 \f                Form feed.
 \F                Foldcase till \E.  Not in [].
 \g{}, \g1         Named, absolute or relative backreference.
                   Not in [].
 \G                Pos assertion.  Not in [].
 \h                Match any horizontal whitespace character.
 \H                Match any character that isn't horizontal whitespace.
 \k{}, \k&lt;&gt;, \k''  Named backreference.  Not in [].
 \K                Keep the stuff left of \K.  Not in [].
 \l                Lowercase next character.  Not in [].
 \L                Lowercase till \E.  Not in [].
 \n                (Logical) newline character.
 \N                Match any character but newline.  Not in [].
 \N{}              Named or numbered (Unicode) character or sequence.
 \o{}              Octal escape sequence.
 \p{}, \pP         Match any character with the given Unicode property.
 \P{}, \PP         Match any character without the given property.
 \Q                Quote (disable) pattern metacharacters till \E.  Not
                   in [].
 \r                Return character.
 \R                Generic new line.  Not in [].
 \s                Match any whitespace character.
 \S                Match any character that isn't a whitespace.
 \t                Tab character.
 \u                Titlecase next character.  Not in [].
 \U                Uppercase till \E.  Not in [].
 \v                Match any vertical whitespace character.
 \V                Match any character that isn't vertical whitespace
 \w                Match any word character.
 \W                Match any character that isn't a word character.
 \x{}, \x00        Hexadecimal escape sequence.
 \X                Unicode &quot;extended grapheme cluster&quot;.  Not in [].
 \z                End of string.  Not in [].
 \Z                End of string.  Not in [].
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Character_Escapes"><a class="permalink" href="#Character_Escapes">Character
  Escapes</a></h2>
<p class="Pp"><i>Fixed characters</i></p>
<p class="Pp">A handful of characters have a dedicated <i>character escape</i>.
    The following table shows them, along with their ASCII code points (in
    decimal and hex), their ASCII name, the control escape on ASCII platforms
    and a short description. (For EBCDIC platforms, see &quot;OPERATOR
    DIFFERENCES&quot; in perlebcdic.)</p>
<p class="Pp"></p>
<pre> Seq.  Code Point  ASCII   Cntrl   Description.
       Dec    Hex
  \a     7     07    BEL    \cG    alarm or bell
  \b     8     08     BS    \cH    backspace [1]
  \e    27     1B    ESC    \c[    escape character
  \f    12     0C     FF    \cL    form feed
  \n    10     0A     LF    \cJ    line feed [2]
  \r    13     0D     CR    \cM    carriage return
  \t     9     09    TAB    \cI    tab
</pre>
<dl class="Bl-tag">
  <dt>[1]</dt>
  <dd><span class="Li">&quot;\b&quot;</span> is the backspace character only
      inside a character class. Outside a character class,
      <span class="Li">&quot;\b&quot;</span> alone is a
      word-character/non-word-character boundary, and
      <span class="Li">&quot;\b{}&quot;</span> is some other type of
    boundary.</dd>
  <dt>[2]</dt>
  <dd><span class="Li">&quot;\n&quot;</span> matches a logical newline. Perl
      converts between <span class="Li">&quot;\n&quot;</span> and your OS's
      native newline character when reading from or writing to text files.</dd>
</dl>
<p class="Pp">Example</p>
<p class="Pp"></p>
<pre> $str =~ /\t/;   # Matches if $str contains a (horizontal) tab.
</pre>
<p class="Pp"><i>Control characters</i></p>
<p class="Pp"><span class="Li">&quot;\c&quot;</span> is used to denote a control
    character; the character following <span class="Li">&quot;\c&quot;</span>
    determines the value of the construct. For example the value of
    <span class="Li">&quot;\cA&quot;</span> is <span class="Li">chr(1)</span>,
    and the value of <span class="Li">&quot;\cb&quot;</span> is
    <span class="Li">chr(2)</span>, etc. The gory details are in &quot;Regexp
    Quote-Like Operators&quot; in perlop. A complete list of what
    <span class="Li">chr(1)</span>, etc. means for ASCII and EBCDIC platforms is
    in &quot;OPERATOR DIFFERENCES&quot; in perlebcdic.</p>
<p class="Pp">Note that <span class="Li">&quot;\c\&quot;</span> alone at the end
    of a regular expression (or doubled-quoted string) is not valid. The
    backslash must be followed by another character. That is,
    <span class="Li">&quot;\c\</span><span class="Li"><i>X</i></span><span class="Li">&quot;</span>
    means <span class="Li">&quot;chr(28) .
    '</span><span class="Li"><i>X</i></span><span class="Li">'&quot;</span> for
    all characters <i>X</i>.</p>
<p class="Pp">To write platform-independent code, you must use
    <span class="Li">&quot;\N{</span><span class="Li"><i>NAME</i></span><span class="Li">}&quot;</span>
    instead, like <span class="Li">&quot;\N{ESCAPE}&quot;</span> or
    <span class="Li">&quot;\N{U+001B}&quot;</span>, see charnames.</p>
<p class="Pp">Mnemonic: <i>c</i>ontrol character.</p>
<p class="Pp">Example</p>
<p class="Pp"></p>
<pre> $str =~ /\cK/;  # Matches if $str contains a vertical tab (control-K).
</pre>
<p class="Pp"><i>Named or numbered characters and character sequences</i></p>
<p class="Pp">Unicode characters have a Unicode name and numeric code point
    (ordinal) value. Use the <span class="Li">&quot;\N{}&quot;</span> construct
    to specify a character by either of these values. Certain sequences of
    characters also have names.</p>
<p class="Pp">To specify by name, the name of the character or character
    sequence goes between the curly braces.</p>
<p class="Pp">To specify a character by Unicode code point, use the form
    <span class="Li">&quot;\N{U+</span><span class="Li"><i>code</i></span>
    <span class="Li"><i>point</i></span><span class="Li">}&quot;</span>, where
    <i>code point</i> is a number in hexadecimal that gives the code point that
    Unicode has assigned to the desired character. It is customary but not
    required to use leading zeros to pad the number to 4 digits. Thus
    <span class="Li">&quot;\N{U+0041}&quot;</span> means
    <span class="Li">&quot;LATIN CAPITAL LETTER A&quot;</span>, and you will
    rarely see it written without the two leading zeros.
    <span class="Li">&quot;\N{U+0041}&quot;</span> means &quot;A&quot; even on
    EBCDIC machines (where the ordinal value of &quot;A&quot; is not 0x41).</p>
<p class="Pp">Blanks may freely be inserted adjacent to but within the braces
    enclosing the name or code point. So
    <span class="Li">&quot;\N{&#x00A0;U+0041&#x00A0;}&quot;</span> is perfectly
    legal.</p>
<p class="Pp">It is even possible to give your own names to characters and
    character sequences by using the charnames module. These custom names are
    lexically scoped, and so a given code point may have different names in
    different scopes. The name used is what is in effect at the time the
    <span class="Li">&quot;\N{}&quot;</span> is expanded. For patterns in
    double-quotish context, that means at the time the pattern is parsed. But
    for patterns that are delimitted by single quotes, the expansion is deferred
    until pattern compilation time, which may very well have a different
    <span class="Li">&quot;charnames&quot;</span> translator in effect.</p>
<p class="Pp">(There is an expanded internal form that you may see in debug
    output: <span class="Li">&quot;\N{U+</span><span class="Li"><i>code
    point</i></span><span class="Li">.</span><span class="Li"><i>code
    point</i></span><span class="Li">...}&quot;</span>. The
    <span class="Li">&quot;...&quot;</span> means any number of these <i>code
    point</i>s separated by dots. This represents the sequence formed by the
    characters. This is an internal form only, subject to change, and you should
    not try to use it yourself.)</p>
<p class="Pp">Mnemonic: <i>N</i>amed character.</p>
<p class="Pp">Note that a character or character sequence expressed as a named
    or numbered character is considered a character without special meaning by
    the regex engine, and will match &quot;as is&quot;.</p>
<p class="Pp">Example</p>
<p class="Pp"></p>
<pre> $str =~ /\N{THAI CHARACTER SO SO}/;  # Matches the Thai SO SO character
 use charnames 'Cyrillic';            # Loads Cyrillic names.
 $str =~ /\N{ZHE}\N{KA}/;             # Match &quot;ZHE&quot; followed by &quot;KA&quot;.
</pre>
<p class="Pp"><i>Octal escapes</i></p>
<p class="Pp">There are two forms of octal escapes. Each is used to specify a
    character by its code point specified in base 8.</p>
<p class="Pp">One form, available starting in Perl 5.14 looks like
    <span class="Li">&quot;\o{...}&quot;</span>, where the dots represent one or
    more octal digits. It can be used for any Unicode character.</p>
<p class="Pp">It was introduced to avoid the potential problems with the other
    form, available in all Perls. That form consists of a backslash followed by
    three octal digits. One problem with this form is that it can look exactly
    like an old-style backreference (see &quot;Disambiguation rules between
    old-style octal escapes and backreferences&quot; below.) You can avoid this
    by making the first of the three digits always a zero, but that makes \077
    the largest code point specifiable.</p>
<p class="Pp">In some contexts, a backslash followed by two or even one octal
    digits may be interpreted as an octal escape, sometimes with a warning, and
    because of some bugs, sometimes with surprising results. Also, if you are
    creating a regex out of smaller snippets concatenated together, and you use
    fewer than three digits, the beginning of one snippet may be interpreted as
    adding digits to the ending of the snippet before it. See &quot;Absolute
    referencing&quot; for more discussion and examples of the snippet
  problem.</p>
<p class="Pp">Note that a character expressed as an octal escape is considered a
    character without special meaning by the regex engine, and will match
    &quot;as is&quot;.</p>
<p class="Pp">To summarize, the <span class="Li">&quot;\o{}&quot;</span> form is
    always safe to use, and the other form is safe to use for code points
    through \077 when you use exactly three digits to specify them.</p>
<p class="Pp">Mnemonic: <i>0</i>ctal or <i>o</i>ctal.</p>
<p class="Pp">Examples (assuming an ASCII platform)</p>
<p class="Pp"></p>
<pre> $str = &quot;Perl&quot;;
 $str =~ /\o{120}/;  # Match, &quot;\120&quot; is &quot;P&quot;.
 $str =~ /\120/;     # Same.
 $str =~ /\o{120}+/; # Match, &quot;\120&quot; is &quot;P&quot;,
                     # it's repeated at least once.
 $str =~ /\120+/;    # Same.
 $str =~ /P\053/;    # No match, &quot;\053&quot; is &quot;+&quot; and taken literally.
 /\o{23073}/         # Black foreground, white background smiling face.
 /\o{4801234567}/    # Raises a warning, and yields chr(4).
 /\o{ 400}/          # LATIN CAPITAL LETTER A WITH MACRON
 /\o{ 400 }/         # Same. These show blanks are allowed adjacent to
                     # the braces
</pre>
<p class="Pp">Disambiguation rules between old-style octal escapes and
    backreferences</p>
<p class="Pp">Octal escapes of the <span class="Li">&quot;\000&quot;</span> form
    outside of bracketed character classes potentially clash with old-style
    backreferences (see &quot;Absolute referencing&quot; below). They both
    consist of a backslash followed by numbers. So Perl has to use heuristics to
    determine whether it is a backreference or an octal escape. Perl uses the
    following rules to disambiguate:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>If the backslash is followed by a single digit, it's a backreference.</dd>
  <dt>2.</dt>
  <dd>If the first digit following the backslash is a 0, it's an octal
    escape.</dd>
  <dt>3.</dt>
  <dd>If the number following the backslash is N (in decimal), and Perl already
      has seen N capture groups, Perl considers this a backreference. Otherwise,
      it considers it an octal escape. If N has more than three digits, Perl
      takes only the first three for the octal escape; the rest are matched as
      is.
    <p class="Pp"></p>
    <pre> my $pat  = &quot;(&quot; x 999;
    $pat .= &quot;a&quot;;
    $pat .= &quot;)&quot; x 999;
 /^($pat)\1000$/;   #  Matches 'aa'; there are 1000 capture groups.
 /^$pat\1000$/;     #  Matches 'a@0'; there are 999 capture groups
                    #  and \1000 is seen as \100 (a '@') and a '0'.
    </pre>
  </dd>
</dl>
<p class="Pp">You can force a backreference interpretation always by using the
    <span class="Li">&quot;\g{...}&quot;</span> form. You can the force an octal
    interpretation always by using the
    <span class="Li">&quot;\o{...}&quot;</span> form, or for numbers up through
    \077 (= 63 decimal), by using three digits, beginning with a
  &quot;0&quot;.</p>
<p class="Pp"><i>Hexadecimal escapes</i></p>
<p class="Pp">Like octal escapes, there are two forms of hexadecimal escapes,
    but both start with the sequence <span class="Li">&quot;\x&quot;</span>.
    This is followed by either exactly two hexadecimal digits forming a number,
    or a hexadecimal number of arbitrary length surrounded by curly braces. The
    hexadecimal number is the code point of the character you want to
  express.</p>
<p class="Pp">Note that a character expressed as one of these escapes is
    considered a character without special meaning by the regex engine, and will
    match &quot;as is&quot;.</p>
<p class="Pp">Mnemonic: he<i>x</i>adecimal.</p>
<p class="Pp">Examples (assuming an ASCII platform)</p>
<p class="Pp"></p>
<pre> $str = &quot;Perl&quot;;
 $str =~ /\x50/;    # Match, &quot;\x50&quot; is &quot;P&quot;.
 $str =~ /\x50+/;   # Match, &quot;\x50&quot; is &quot;P&quot;, it is repeated at least once
 $str =~ /P\x2B/;   # No match, &quot;\x2B&quot; is &quot;+&quot; and taken literally.
 /\x{2603}\x{2602}/ # Snowman with an umbrella.
                    # The Unicode character 2603 is a snowman,
                    # the Unicode character 2602 is an umbrella.
 /\x{263B}/         # Black smiling face.
 /\x{263b}/         # Same, the hex digits A - F are case insensitive.
 /\x{ 263b }/       # Same, showing optional blanks adjacent to the
                    # braces
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Modifiers"><a class="permalink" href="#Modifiers">Modifiers</a></h2>
<p class="Pp">A number of backslash sequences have to do with changing the
    character, or characters following them.
    <span class="Li">&quot;\l&quot;</span> will lowercase the character
    following it, while <span class="Li">&quot;\u&quot;</span> will uppercase
    (or, more accurately, titlecase) the character following it. They provide
    functionality similar to the functions
    <span class="Li">&quot;lcfirst&quot;</span> and
    <span class="Li">&quot;ucfirst&quot;</span>.</p>
<p class="Pp">To uppercase or lowercase several characters, one might want to
    use <span class="Li">&quot;\L&quot;</span> or
    <span class="Li">&quot;\U&quot;</span>, which will lowercase/uppercase all
    characters following them, until either the end of the pattern or the next
    occurrence of <span class="Li">&quot;\E&quot;</span>, whichever comes first.
    They provide functionality similar to what the functions
    <span class="Li">&quot;lc&quot;</span> and
    <span class="Li">&quot;uc&quot;</span> provide.</p>
<p class="Pp"><span class="Li">&quot;\Q&quot;</span> is used to quote (disable)
    pattern metacharacters, up to the next
    <span class="Li">&quot;\E&quot;</span> or the end of the pattern.
    <span class="Li">&quot;\Q&quot;</span> adds a backslash to any character
    that could have special meaning to Perl. In the ASCII range, it quotes every
    character that isn't a letter, digit, or underscore. See
    &quot;quotemeta&quot; in perlfunc for details on what gets quoted for
    non-ASCII code points. Using this ensures that any character between
    <span class="Li">&quot;\Q&quot;</span> and
    <span class="Li">&quot;\E&quot;</span> will be matched literally, not
    interpreted as a metacharacter by the regex engine.</p>
<p class="Pp"><span class="Li">&quot;\F&quot;</span> can be used to casefold all
    characters following, up to the next <span class="Li">&quot;\E&quot;</span>
    or the end of the pattern. It provides the functionality similar to the
    <span class="Li">&quot;fc&quot;</span> function.</p>
<p class="Pp">Mnemonic: <i>L</i>owercase, <i>U</i>ppercase, <i>F</i>old-case,
    <i>Q</i>uotemeta, <i>E</i>nd.</p>
<p class="Pp">Examples</p>
<p class="Pp"></p>
<pre> $sid     = &quot;sid&quot;;
 $greg    = &quot;GrEg&quot;;
 $miranda = &quot;(Miranda)&quot;;
 $str     =~ /\u$sid/;        # Matches 'Sid'
 $str     =~ /\L$greg/;       # Matches 'greg'
 $str     =~ /\Q$miranda\E/;  # Matches '(Miranda)', as if the pattern
                              #   had been written as /\(Miranda\)/
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Character_classes"><a class="permalink" href="#Character_classes">Character
  classes</a></h2>
<p class="Pp">Perl regular expressions have a large range of character classes.
    Some of the character classes are written as a backslash sequence. We will
    briefly discuss those here; full details of character classes can be found
    in perlrecharclass.</p>
<p class="Pp"><span class="Li">&quot;\w&quot;</span> is a character class that
    matches any single <i>word</i> character (letters, digits, Unicode marks,
    and connector punctuation (like the underscore)).
    <span class="Li">&quot;\d&quot;</span> is a character class that matches any
    decimal digit, while the character class
    <span class="Li">&quot;\s&quot;</span> matches any whitespace character. New
    in perl 5.10.0 are the classes <span class="Li">&quot;\h&quot;</span> and
    <span class="Li">&quot;\v&quot;</span> which match horizontal and vertical
    whitespace characters.</p>
<p class="Pp">The exact set of characters matched by
    <span class="Li">&quot;\d&quot;</span>,
    <span class="Li">&quot;\s&quot;</span>, and
    <span class="Li">&quot;\w&quot;</span> varies depending on various pragma
    and regular expression modifiers. It is possible to restrict the match to
    the ASCII range by using the <span class="Li">&quot;/a&quot;</span> regular
    expression modifier. See perlrecharclass.</p>
<p class="Pp">The uppercase variants (<span class="Li">&quot;\W&quot;</span>,
    <span class="Li">&quot;\D&quot;</span>,
    <span class="Li">&quot;\S&quot;</span>,
    <span class="Li">&quot;\H&quot;</span>, and
    <span class="Li">&quot;\V&quot;</span>) are character classes that match,
    respectively, any character that isn't a word character, digit, whitespace,
    horizontal whitespace, or vertical whitespace.</p>
<p class="Pp">Mnemonics: <i>w</i>ord, <i>d</i>igit, <i>s</i>pace,
    <i>h</i>orizontal, <i>v</i>ertical.</p>
<p class="Pp"><i>Unicode classes</i></p>
<p class="Pp"><span class="Li">&quot;\pP&quot;</span> (where
    <span class="Li">&quot;P&quot;</span> is a single letter) and
    <span class="Li">&quot;\p{Property}&quot;</span> are used to match a
    character that matches the given Unicode property; properties include things
    like &quot;letter&quot;, or &quot;thai character&quot;. Capitalizing the
    sequence to <span class="Li">&quot;\PP&quot;</span> and
    <span class="Li">&quot;\P{Property}&quot;</span> make the sequence match a
    character that doesn't match the given Unicode property. For more details,
    see &quot;Backslash sequences&quot; in perlrecharclass and &quot;Unicode
    Character Properties&quot; in perlunicode.</p>
<p class="Pp">Mnemonic: <i>p</i>roperty.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Referencing"><a class="permalink" href="#Referencing">Referencing</a></h2>
<p class="Pp">If capturing parenthesis are used in a regular expression, we can
    refer to the part of the source string that was matched, and match exactly
    the same thing. There are three ways of referring to such
    <i>backreference</i>: absolutely, relatively, and by name.</p>
<p class="Pp"><i>Absolute referencing</i></p>
<p class="Pp">Either
    <span class="Li">&quot;\g</span><span class="Li"><i>N</i></span><span class="Li">&quot;</span>
    (starting in Perl 5.10.0), or
    <span class="Li">&quot;\</span><span class="Li"><i>N</i></span><span class="Li">&quot;</span>
    (old-style) where <i>N</i> is a positive (unsigned) decimal number of any
    length is an absolute reference to a capturing group.</p>
<p class="Pp"><i>N</i> refers to the Nth set of parentheses, so
    <span class="Li">&quot;\g</span><span class="Li"><i>N</i></span><span class="Li">&quot;</span>
    refers to whatever has been matched by that set of parentheses. Thus
    <span class="Li">&quot;\g1&quot;</span> refers to the first capture group in
    the regex.</p>
<p class="Pp">The
    <span class="Li">&quot;\g</span><span class="Li"><i>N</i></span><span class="Li">&quot;</span>
    form can be equivalently written as
    <span class="Li">&quot;\g{</span><span class="Li"><i>N</i></span><span class="Li">}&quot;</span>
    which avoids ambiguity when building a regex by concatenating shorter
    strings. Otherwise if you had a regex
    <span class="Li">&quot;qr/$a$b/&quot;</span>, and <span class="Li">$a</span>
    contained <span class="Li">&quot;\g1&quot;</span>, and
    <span class="Li">$b</span> contained <span class="Li">&quot;37&quot;</span>,
    you would get <span class="Li">&quot;/\g137/&quot;</span> which is probably
    not what you intended.</p>
<p class="Pp">In the
    <span class="Li">&quot;\</span><span class="Li"><i>N</i></span><span class="Li">&quot;</span>
    form, <i>N</i> must not begin with a &quot;0&quot;, and there must be at
    least <i>N</i> capturing groups, or else <i>N</i> is considered an octal
    escape (but something like <span class="Li">&quot;\18&quot;</span> is the
    same as <span class="Li">&quot;\0018&quot;</span>; that is, the octal escape
    <span class="Li">&quot;\001&quot;</span> followed by a literal digit
    <span class="Li">&quot;8&quot;</span>).</p>
<p class="Pp">Mnemonic: <i>g</i>roup.</p>
<p class="Pp">Examples</p>
<p class="Pp"></p>
<pre> /(\w+) \g1/;    # Finds a duplicated word, (e.g. &quot;cat cat&quot;).
 /(\w+) \1/;     # Same thing; written old-style.
 /(\w+) \g{1}/;  # Same, using the safer braced notation
 /(\w+) \g{ 1 }/;# Same, showing optional blanks adjacent to the braces
 /(.)(.)\g2\g1/; # Match a four letter palindrome (e.g. &quot;ABBA&quot;).
</pre>
<p class="Pp"><i>Relative referencing</i></p>
<p class="Pp"><span class="Li">&quot;\g-</span><span class="Li"><i>N</i></span><span class="Li">&quot;</span>
    (starting in Perl 5.10.0) is used for relative addressing. (It can be
    written as
    <span class="Li">&quot;\g{-</span><span class="Li"><i>N</i></span><span class="Li">}&quot;</span>.)
    It refers to the <i>N</i>th group before the
    <span class="Li">&quot;\g{-</span><span class="Li"><i>N</i></span><span class="Li">}&quot;</span>.</p>
<p class="Pp">The big advantage of this form is that it makes it much easier to
    write patterns with references that can be interpolated in larger patterns,
    even if the larger pattern also contains capture groups.</p>
<p class="Pp">Examples</p>
<p class="Pp"></p>
<pre> /(A)        # Group 1
  (          # Group 2
    (B)      # Group 3
    \g{-1}   # Refers to group 3 (B)
    \g{-3}   # Refers to group 1 (A)
    \g{ -3 } # Same, showing optional blanks adjacent to the braces
  )
 /x;         # Matches &quot;ABBA&quot;.
 my $qr = qr /(.)(.)\g{-2}\g{-1}/;  # Matches 'abab', 'cdcd', etc.
 /$qr$qr/                           # Matches 'ababcdcd'.
</pre>
<p class="Pp"><i>Named referencing</i></p>
<p class="Pp"><span class="Li">&quot;\g{</span><span class="Li"><i>name</i></span><span class="Li">}&quot;</span>
    (starting in Perl 5.10.0) can be used to back refer to a named capture
    group, dispensing completely with having to think about capture buffer
    positions.</p>
<p class="Pp">To be compatible with .Net regular expressions,
    <span class="Li">&quot;\g{name}&quot;</span> may also be written as
    <span class="Li">&quot;\k{name}&quot;</span>,
    <span class="Li">&quot;\k&lt;name&gt;&quot;</span> or
    <span class="Li">&quot;\k'name'&quot;</span>.</p>
<p class="Pp">To prevent any ambiguity, <i>name</i> must not start with a digit
    nor contain a hyphen.</p>
<p class="Pp">Examples</p>
<p class="Pp"></p>
<pre> /(?&lt;word&gt;\w+) \g{word}/   # Finds duplicated word, (e.g. &quot;cat cat&quot;)
 /(?&lt;word&gt;\w+) \k{word}/   # Same.
 /(?&lt;word&gt;\w+) \g{ word }/ # Same, showing optional blanks adjacent to
                           # the braces
 /(?&lt;word&gt;\w+) \k{ word }/ # Same.
 /(?&lt;word&gt;\w+) \k&lt;word&gt;/   # Same.  There are no braces, so no blanks
                           # are permitted
 /(?&lt;letter1&gt;.)(?&lt;letter2&gt;.)\g{letter2}\g{letter1}/
                           # Match a four letter palindrome (e.g.
                           # &quot;ABBA&quot;)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Assertions"><a class="permalink" href="#Assertions">Assertions</a></h2>
<p class="Pp">Assertions are conditions that have to be true; they don't
    actually match parts of the substring. There are six assertions that are
    written as backslash sequences.</p>
<dl class="Bl-tag">
  <dt id="A"><a class="permalink" href="#A">\A</a></dt>
  <dd><span class="Li">&quot;\A&quot;</span> only matches at the beginning of
      the string. If the <span class="Li">&quot;/m&quot;</span> modifier isn't
      used, then <span class="Li">&quot;/\A/&quot;</span> is equivalent to
      <span class="Li">&quot;/^/&quot;</span>. However, if the
      <span class="Li">&quot;/m&quot;</span> modifier is used, then
      <span class="Li">&quot;/^/&quot;</span> matches internal newlines, but the
      meaning of <span class="Li">&quot;/\A/&quot;</span> isn't changed by the
      <span class="Li">&quot;/m&quot;</span> modifier.
      <span class="Li">&quot;\A&quot;</span> matches at the beginning of the
      string regardless whether the <span class="Li">&quot;/m&quot;</span>
      modifier is used.</dd>
  <dt id="z,"><a class="permalink" href="#z,">\z, \Z</a></dt>
  <dd><span class="Li">&quot;\z&quot;</span> and
      <span class="Li">&quot;\Z&quot;</span> match at the end of the string. If
      the <span class="Li">&quot;/m&quot;</span> modifier isn't used, then
      <span class="Li">&quot;/\Z/&quot;</span> is equivalent to
      <span class="Li">&quot;/$/&quot;</span>; that is, it matches at the end of
      the string, or one before the newline at the end of the string. If the
      <span class="Li">&quot;/m&quot;</span> modifier is used, then
      <span class="Li">&quot;/$/&quot;</span> matches at internal newlines, but
      the meaning of <span class="Li">&quot;/\Z/&quot;</span> isn't changed by
      the <span class="Li">&quot;/m&quot;</span> modifier.
      <span class="Li">&quot;\Z&quot;</span> matches at the end of the string
      (or just before a trailing newline) regardless whether the
      <span class="Li">&quot;/m&quot;</span> modifier is used.
    <p class="Pp"><span class="Li">&quot;\z&quot;</span> is just like
        <span class="Li">&quot;\Z&quot;</span>, except that it does not match
        before a trailing newline. <span class="Li">&quot;\z&quot;</span>
        matches at the end of the string only, regardless of the modifiers used,
        and not just before a newline. It is how to anchor the match to the true
        end of the string under all conditions.</p>
  </dd>
  <dt id="G"><a class="permalink" href="#G">\G</a></dt>
  <dd><span class="Li">&quot;\G&quot;</span> is usually used only in combination
      with the <span class="Li">&quot;/g&quot;</span> modifier. If the
      <span class="Li">&quot;/g&quot;</span> modifier is used and the match is
      done in scalar context, Perl remembers where in the source string the last
      match ended, and the next time, it will start the match from where it
      ended the previous time.
    <p class="Pp"><span class="Li">&quot;\G&quot;</span> matches the point where
        the previous match on that string ended, or the beginning of that string
        if there was no previous match.</p>
    <p class="Pp">Mnemonic: <i>G</i>lobal.</p>
  </dd>
  <dt id="b__,"><a class="permalink" href="#b__,">\b{}, \b, \B{}, \B</a></dt>
  <dd><span class="Li">&quot;\b{...}&quot;</span>, available starting in v5.22,
      matches a boundary (between two characters, or before the first character
      of the string, or after the final character of the string) based on the
      Unicode rules for the boundary type specified inside the braces. The
      boundary types are given a few paragraphs below.
      <span class="Li">&quot;\B{...}&quot;</span> matches at any place between
      characters where <span class="Li">&quot;\b{...}&quot;</span> of the same
      type doesn't match.
    <p class="Pp"><span class="Li">&quot;\b&quot;</span> when not immediately
        followed by a <span class="Li">&quot;{&quot;</span> is available in all
        Perls. It matches at any place between a word (something matched by
        <span class="Li">&quot;\w&quot;</span>) and a non-word character
        (<span class="Li">&quot;\W&quot;</span>);
        <span class="Li">&quot;\B&quot;</span> when not immediately followed by
        a <span class="Li">&quot;{&quot;</span> matches at any place between
        characters where <span class="Li">&quot;\b&quot;</span> doesn't match.
        To get better word matching of natural language text, see
        &quot;\b{wb}&quot; below.</p>
    <p class="Pp"><span class="Li">&quot;\b&quot;</span> and
        <span class="Li">&quot;\B&quot;</span> assume there's a non-word
        character before the beginning and after the end of the source string;
        so <span class="Li">&quot;\b&quot;</span> will match at the beginning
        (or end) of the source string if the source string begins (or ends) with
        a word character. Otherwise, <span class="Li">&quot;\B&quot;</span> will
        match.</p>
    <p class="Pp">Do not use something like
        <span class="Li">&quot;\b=head\d\b&quot;</span> and expect it to match
        the beginning of a line. It can't, because for there to be a boundary
        before the non-word &quot;=&quot;, there must be a word character
        immediately previous. All plain <span class="Li">&quot;\b&quot;</span>
        and <span class="Li">&quot;\B&quot;</span> boundary determinations look
        for word characters alone, not for non-word characters nor for string
        ends. It may help to understand how
        <span class="Li">&quot;\b&quot;</span> and
        <span class="Li">&quot;\B&quot;</span> work by equating them as
      follows:</p>
    <p class="Pp"></p>
    <pre>    \b  really means    (?:(?&lt;=\w)(?!\w)|(?&lt;!\w)(?=\w))
    \B  really means    (?:(?&lt;=\w)(?=\w)|(?&lt;!\w)(?!\w))
    </pre>
    <p class="Pp">In contrast, <span class="Li">&quot;\b{...}&quot;</span> and
        <span class="Li">&quot;\B{...}&quot;</span> may or may not match at the
        beginning and end of the line, depending on the boundary type. These
        implement the Unicode default boundaries, specified in
        &lt;https://www.unicode.org/reports/tr14/&gt; and
        &lt;https://www.unicode.org/reports/tr29/&gt;. The boundary types
      are:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>&quot;\b{gcb}&quot; or &quot;\b{g}&quot;</dt>
  <dd>This matches a Unicode &quot;Grapheme Cluster Boundary&quot;. (Actually
      Perl always uses the improved &quot;extended&quot; grapheme
      cluster&quot;). These are explained below under
      <span class="Li">&quot;\X&quot;</span>. In fact,
      <span class="Li">&quot;\X&quot;</span> is another way to get the same
      functionality. It is equivalent to
      <span class="Li">&quot;/.+?\b{gcb}/&quot;</span>. Use whichever is most
      convenient for your situation.</dd>
  <dt>&quot;\b{lb}&quot;</dt>
  <dd>This matches according to the default Unicode Line Breaking Algorithm
      (&lt;https://www.unicode.org/reports/tr14/&gt;), as customized in that
      document (Example 7 of revision 35
      &lt;https://www.unicode.org/reports/tr14/tr14-35.html#Example7&gt;) for
      better handling of numeric expressions.
    <p class="Pp">This is suitable for many purposes, but the Unicode::LineBreak
        module is available on CPAN that provides many more features, including
        customization.</p>
  </dd>
  <dt>&quot;\b{sb}&quot;</dt>
  <dd>This matches a Unicode &quot;Sentence Boundary&quot;. This is an aid to
      parsing natural language sentences. It gives good, but imperfect results.
      For example, it thinks that &quot;Mr. Smith&quot; is two sentences. More
      details are at &lt;https://www.unicode.org/reports/tr29/&gt;. Note also
      that it thinks that anything matching &quot;\R&quot; (except form feed and
      vertical tab) is a sentence boundary.
      <span class="Li">&quot;\b{sb}&quot;</span> works with text designed for
      word-processors which wrap lines automatically for display, but hard-coded
      line boundaries are considered to be essentially the ends of text blocks
      (paragraphs really), and hence the ends of sentences.
      <span class="Li">&quot;\b{sb}&quot;</span> doesn't do well with text
      containing embedded newlines, like the source text of the document you are
      reading. Such text needs to be preprocessed to get rid of the line
      separators before looking for sentence boundaries. Some people view this
      as a bug in the Unicode standard, and this behavior is quite subject to
      change in future Perl versions.</dd>
  <dt>&quot;\b{wb}&quot;</dt>
  <dd>This matches a Unicode &quot;Word Boundary&quot;, but tailored to Perl
      expectations. This gives better (though not perfect) results for natural
      language processing than plain <span class="Li">&quot;\b&quot;</span>
      (without braces) does. For example, it understands that apostrophes can be
      in the middle of words and that parentheses aren't (see the examples
      below). More details are at &lt;https://www.unicode.org/reports/tr29/&gt;.
    <p class="Pp">The current Unicode definition of a Word Boundary matches
        between every white space character. Perl tailors this, starting in
        version 5.24, to generally not break up spans of white space, just as
        plain <span class="Li">&quot;\b&quot;</span> has always functioned. This
        allows <span class="Li">&quot;\b{wb}&quot;</span> to be a drop-in
        replacement for <span class="Li">&quot;\b&quot;</span>, but with
        generally better results for natural language processing. (The exception
        to this tailoring is when a span of white space is immediately followed
        by something like U+0303, COMBINING TILDE. If the final space character
        in the span is a horizontal white space, it is broken out so that it
        attaches instead to the combining character. To be precise, if a span of
        white space that ends in a horizontal space has the character
        immediately following it have any of the Word Boundary property values
        &quot;Extend&quot;, &quot;Format&quot; or &quot;ZWJ&quot;, the boundary
        between the final horizontal space character and the rest of the span
        matches <span class="Li">&quot;\b{wb}&quot;</span>. In all other cases
        the boundary between two white space characters matches
        <span class="Li">&quot;\B{wb}&quot;</span>.)</p>
  </dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">It is important to realize when you use these Unicode boundaries,
    that you are taking a risk that a future version of Perl which contains a
    later version of the Unicode Standard will not work precisely the same way
    as it did when your code was written. These rules are not considered stable
    and have been somewhat more subject to change than the rest of the Standard.
    Unicode reserves the right to change them at will, and Perl reserves the
    right to update its implementation to Unicode's new rules. In the past, some
    changes have been because new characters have been added to the Standard
    which have different characteristics than all previous characters, so new
    rules are formulated for handling them. These should not cause any backward
    compatibility issues. But some changes have changed the treatment of
    existing characters because the Unicode Technical Committee has decided that
    the change is warranted for whatever reason. This could be to fix a bug, or
    because they think better results are obtained with the new rule.</p>
<p class="Pp">It is also important to realize that these are default boundary
    definitions, and that implementations may wish to tailor the results for
    particular purposes and locales. For example, some languages, such as
    Japanese and Thai, require dictionary lookup to accurately determine word
    boundaries.</p>
<p class="Pp">Mnemonic: <i>b</i>oundary.</p>
</div>
<p class="Pp">Examples</p>
<p class="Pp"></p>
<pre>  &quot;cat&quot;   =~ /\Acat/;     # Match.
  &quot;cat&quot;   =~ /cat\Z/;     # Match.
  &quot;cat\n&quot; =~ /cat\Z/;     # Match.
  &quot;cat\n&quot; =~ /cat\z/;     # No match.
  &quot;cat&quot;   =~ /\bcat\b/;   # Matches.
  &quot;cats&quot;  =~ /\bcat\b/;   # No match.
  &quot;cat&quot;   =~ /\bcat\B/;   # No match.
  &quot;cats&quot;  =~ /\bcat\B/;   # Match.
  while (&quot;cat dog&quot; =~ /(\w+)/g) {
      print $1;           # Prints 'catdog'
  }
  while (&quot;cat dog&quot; =~ /\G(\w+)/g) {
      print $1;           # Prints 'cat'
  }
  my $s = &quot;He said, \&quot;Is pi 3.14? (I'm not sure).\&quot;&quot;;
  print join(&quot;|&quot;, $s =~ m/ ( .+? \b     ) /xg), &quot;\n&quot;;
  print join(&quot;|&quot;, $s =~ m/ ( .+? \b{wb} ) /xg), &quot;\n&quot;;
 prints
  He| |said|, &quot;|Is| |pi| |3|.|14|? (|I|'|m| |not| |sure
  He| |said|,| |&quot;|Is| |pi| |3.14|?| |(|I'm| |not| |sure|)|.|&quot;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Misc"><a class="permalink" href="#Misc">Misc</a></h2>
<p class="Pp">Here we document the backslash sequences that don't fall in one of
    the categories above. These are:</p>
<dl class="Bl-tag">
  <dt id="K"><a class="permalink" href="#K">\K</a></dt>
  <dd>This appeared in perl 5.10.0. Anything matched left of
      <span class="Li">&quot;\K&quot;</span> is not included in
      <span class="Li">$&amp;</span>, and will not be replaced if the pattern is
      used in a substitution. This lets you write <span class="Li">&quot;s/PAT1
      \K PAT2/REPL/x&quot;</span> instead of <span class="Li">&quot;s/(PAT1)
      PAT2/${1}REPL/x&quot;</span> or <span class="Li">&quot;s/(?&lt;=PAT1)
      PAT2/REPL/x&quot;</span>.
    <p class="Pp">Mnemonic: <i>K</i>eep.</p>
  </dd>
  <dt id="N"><a class="permalink" href="#N">\N</a></dt>
  <dd>This feature, available starting in v5.12, matches any character that is
      <b>not</b> a newline. It is a short-hand for writing
      <span class="Li">&quot;[^\n]&quot;</span>, and is identical to the
      <span class="Li">&quot;.&quot;</span> metasymbol, except under the
      <span class="Li">&quot;/s&quot;</span> flag, which changes the meaning of
      <span class="Li">&quot;.&quot;</span>, but not
      <span class="Li">&quot;\N&quot;</span>.
    <p class="Pp">Note that <span class="Li">&quot;\N{...}&quot;</span> can mean
        a named or numbered character .</p>
    <p class="Pp">Mnemonic: Complement of <i>\n</i>.</p>
  </dd>
  <dt id="R"><a class="permalink" href="#R">\R</a></dt>
  <dd><span class="Li">&quot;\R&quot;</span> matches a <i>generic newline</i>;
      that is, anything considered a linebreak sequence by Unicode. This
      includes all characters matched by <span class="Li">&quot;\v&quot;</span>
      (vertical whitespace), and the multi character sequence
      <span class="Li">&quot;\x0D\x0A&quot;</span> (carriage return followed by
      a line feed, sometimes called the network newline; it's the end of line
      sequence used in Microsoft text files opened in binary mode).
      <span class="Li">&quot;\R&quot;</span> is equivalent to
      <span class="Li">&quot;(?&gt;\x0D\x0A|\v)&quot;</span>. (The reason it
      doesn't backtrack is that the sequence is considered inseparable. That
      means that
    <p class="Pp"></p>
    <pre> &quot;\x0D\x0A&quot; =~ /^\R\x0A$/   # No match
    </pre>
    <p class="Pp">fails, because the <span class="Li">&quot;\R&quot;</span>
        matches the entire string, and won't backtrack to match just the
        <span class="Li">&quot;\x0D&quot;</span>.) Since
        <span class="Li">&quot;\R&quot;</span> can match a sequence of more than
        one character, it cannot be put inside a bracketed character class;
        <span class="Li">&quot;/[\R]/&quot;</span> is an error; use
        <span class="Li">&quot;\v&quot;</span> instead.
        <span class="Li">&quot;\R&quot;</span> was introduced in perl
      5.10.0.</p>
    <p class="Pp">Note that this does not respect any locale that might be in
        effect; it matches according to the platform's native character set.</p>
    <p class="Pp">Mnemonic: none really. <span class="Li">&quot;\R&quot;</span>
        was picked because PCRE already uses
        <span class="Li">&quot;\R&quot;</span>, and more importantly because
        Unicode recommends such a regular expression metacharacter, and suggests
        <span class="Li">&quot;\R&quot;</span> as its notation.</p>
  </dd>
  <dt id="X"><a class="permalink" href="#X">\X</a></dt>
  <dd>This matches a Unicode <i>extended grapheme cluster</i>.
    <p class="Pp"><span class="Li">&quot;\X&quot;</span> matches quite well what
        normal (non-Unicode-programmer) usage would consider a single character.
        As an example, consider a G with some sort of diacritic mark, such as an
        arrow. There is no such single character in Unicode, but one can be
        composed by using a G followed by a Unicode &quot;COMBINING UPWARDS
        ARROW BELOW&quot;, and would be displayed by Unicode-aware software as
        if it were a single character.</p>
    <p class="Pp">The match is greedy and non-backtracking, so that the cluster
        is never broken up into smaller components.</p>
    <p class="Pp">See also <span class="Li">&quot;\b{gcb}&quot;</span>.</p>
    <p class="Pp">Mnemonic: e<i>X</i>tended Unicode character.</p>
  </dd>
</dl>
<p class="Pp">Examples</p>
<p class="Pp"></p>
<pre> $str =~ s/foo\Kbar/baz/g; # Change any 'bar' following a 'foo' to 'baz'
 $str =~ s/(.)\K\g1//g;    # Delete duplicated characters.
 &quot;\n&quot;   =~ /^\R$/;         # Match, \n   is a generic newline.
 &quot;\r&quot;   =~ /^\R$/;         # Match, \r   is a generic newline.
 &quot;\r\n&quot; =~ /^\R$/;         # Match, \r\n is a generic newline.
 &quot;P\x{307}&quot; =~ /^\X$/     # \X matches a P with a dot above.
</pre>
</section>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os">perl v5.34.1</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PERLVMS(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLVMS(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLVMS(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlvms - VMS-specific documentation for Perl</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Gathered below are notes describing details of Perl 5's behavior
    on VMS. They are a supplement to the regular Perl 5 documentation, so we
    have focussed on the ways in which Perl 5 functions differently under VMS
    than it does under Unix, and on the interactions between Perl and the rest
    of the operating system. We haven't tried to duplicate complete descriptions
    of Perl features from the main Perl documentation, which can be found in the
    <i>[.pod]</i> subdirectory of the Perl distribution.</p>
<p class="Pp">We hope these notes will save you from confusion and lost sleep
    when writing Perl scripts on VMS. If you find we've missed something you
    think should appear here, please don't hesitate to drop a line to
    vmsperl@perl.org.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Installation"><a class="permalink" href="#Installation">Installation</a></h1>
<p class="Pp">Directions for building and installing Perl 5 can be found in the
    file <i>README.vms</i> in the main source directory of the Perl
    distribution.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Organization_of_Perl_Images"><a class="permalink" href="#Organization_of_Perl_Images">Organization
  of Perl Images</a></h1>
<section class="Ss">
<h2 class="Ss" id="Core_Images"><a class="permalink" href="#Core_Images">Core
  Images</a></h2>
<p class="Pp">During the build process, three Perl images are produced.
    <i>Miniperl.Exe</i> is an executable image which contains all of the basic
    functionality of Perl, but cannot take advantage of Perl XS extensions and
    has a hard-wired list of library locations for loading pure-Perl modules. It
    is used extensively to build and test Perl and various extensions, but is
    not installed.</p>
<p class="Pp">Most of the complete Perl resides in the shareable image
    <i>PerlShr.Exe</i>, which provides a core to which the Perl executable image
    and all Perl extensions are linked. It is generally located via the logical
    name <i>PERLSHR</i>. While it's possible to put the image in
    <i>SYS$SHARE</i> to make it loadable, that's not recommended. And while you
    may wish to INSTALL the image for performance reasons, you should not
    install it with privileges; if you do, the result will not be what you
    expect as image privileges are disabled during Perl start-up.</p>
<p class="Pp">Finally, <i>Perl.Exe</i> is an executable image containing the
    main entry point for Perl, as well as some initialization code. It should be
    placed in a public directory, and made world executable. In order to run
    Perl with command line arguments, you should define a foreign command to
    invoke this image.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Perl_Extensions"><a class="permalink" href="#Perl_Extensions">Perl
  Extensions</a></h2>
<p class="Pp">Perl extensions are packages which provide both XS and Perl code
    to add new functionality to perl. (XS is a meta-language which simplifies
    writing C code which interacts with Perl, see perlxs for more details.) The
    Perl code for an extension is treated like any other library module - it's
    made available in your script through the appropriate
    <span class="Li">&quot;use&quot;</span> or
    <span class="Li">&quot;require&quot;</span> statement, and usually defines a
    Perl package containing the extension.</p>
<p class="Pp">The portion of the extension provided by the XS code may be
    connected to the rest of Perl in either of two ways. In the <b>static</b>
    configuration, the object code for the extension is linked directly into
    <i>PerlShr.Exe</i>, and is initialized whenever Perl is invoked. In the
    <b>dynamic</b> configuration, the extension's machine code is placed into a
    separate shareable image, which is mapped by Perl's DynaLoader when the
    extension is <span class="Li">&quot;use&quot;</span>d or
    <span class="Li">&quot;require&quot;</span>d in your script. This allows you
    to maintain the extension as a separate entity, at the cost of keeping track
    of the additional shareable image. Most extensions can be set up as either
    static or dynamic.</p>
<p class="Pp">The source code for an extension usually resides in its own
    directory. At least three files are generally provided:
    <i>Extshortname</i><i>.xs</i> (where <i>Extshortname</i> is the portion of
    the extension's name following the last
    <span class="Li">&quot;::&quot;</span>), containing the XS code,
    <i>Extshortname</i><i>.pm</i>, the Perl library module for the extension,
    and <i>Makefile.PL</i>, a Perl script which uses the
    <span class="Li">&quot;MakeMaker&quot;</span> library modules supplied with
    Perl to generate a <i>Descrip.MMS</i> file for the extension.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Installing_static_extensions"><a class="permalink" href="#Installing_static_extensions">Installing
  static extensions</a></h2>
<p class="Pp">Since static extensions are incorporated directly into
    <i>PerlShr.Exe</i>, you'll have to rebuild Perl to incorporate a new
    extension. You should edit the main <i>Descrip.MMS</i> or <i>Makefile</i>
    you use to build Perl, adding the extension's name to the
    <span class="Li">&quot;ext&quot;</span> macro, and the extension's object
    file to the <span class="Li">&quot;extobj&quot;</span> macro. You'll also
    need to build the extension's object file, either by adding dependencies to
    the main <i>Descrip.MMS</i>, or using a separate <i>Descrip.MMS</i> for the
    extension. Then, rebuild <i>PerlShr.Exe</i> to incorporate the new code.</p>
<p class="Pp">Finally, you'll need to copy the extension's Perl library module
    to the <i>[.</i><i>Extname</i><i>]</i> subdirectory under one of the
    directories in <span class="Li">@INC</span>, where <i>Extname</i> is the
    name of the extension, with all <span class="Li">&quot;::&quot;</span>
    replaced by <span class="Li">&quot;.&quot;</span> (e.g. the library module
    for extension Foo::Bar would be copied to a <i>[.Foo.Bar]</i>
  subdirectory).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Installing_dynamic_extensions"><a class="permalink" href="#Installing_dynamic_extensions">Installing
  dynamic extensions</a></h2>
<p class="Pp">In general, the distributed kit for a Perl extension includes a
    file named Makefile.PL, which is a Perl program which is used to create a
    <i>Descrip.MMS</i> file which can be used to build and install the files
    required by the extension. The kit should be unpacked into a directory tree
    <b>not</b> under the main Perl source directory, and the procedure for
    building the extension is simply</p>
<p class="Pp"></p>
<pre>
    $ perl Makefile.PL  ! Create Descrip.MMS
    $ mmk               ! Build necessary files
    $ mmk test          ! Run test code, if supplied
    $ mmk install       ! Install into public Perl tree
</pre>
<p class="Pp">VMS support for this process in the current release of Perl is
    sufficient to handle most extensions. (See the MakeMaker documentation for
    more details on installation options for extensions.)</p>
<ul class="Bl-bullet">
  <li>the
      <i>[.Lib.Auto.</i><i>Arch</i><i></i><i>$PVers</i><i></i><i>Extname</i><i>]</i>
      subdirectory of one of the directories in <span class="Li">@INC</span>
      (where <i>PVers</i> is the version of Perl you're using, as supplied in
      <span class="Li">$]</span>, with '.' converted to '_'), or</li>
  <li>one of the directories in <span class="Li">@INC</span>, or</li>
  <li>a directory which the extensions Perl library module passes to the
      DynaLoader when asking it to map the shareable image, or</li>
  <li><i>Sys$Share</i> or <i>Sys$Library</i>.</li>
</ul>
<p class="Pp">If the shareable image isn't in any of these places, you'll need
    to define a logical name <i>Extshortname</i>, where <i>Extshortname</i> is
    the portion of the extension's name after the last
    <span class="Li">&quot;::&quot;</span>, which translates to the full file
    specification of the shareable image.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="File_specifications"><a class="permalink" href="#File_specifications">File
  specifications</a></h1>
<section class="Ss">
<h2 class="Ss" id="Syntax"><a class="permalink" href="#Syntax">Syntax</a></h2>
<p class="Pp">We have tried to make Perl aware of both VMS-style and Unix-style
    file specifications wherever possible. You may use either style, or both, on
    the command line and in scripts, but you may not combine the two styles
    within a single file specification. VMS Perl interprets Unix pathnames in
    much the same way as the CRTL (<i>e.g.</i> the first component of an
    absolute path is read as the device name for the VMS file specification).
    There are a set of functions provided in the
    <span class="Li">&quot;VMS::Filespec&quot;</span> package for explicit
    interconversion between VMS and Unix syntax; its documentation provides more
    details.</p>
<p class="Pp">We've tried to minimize the dependence of Perl library modules on
    Unix syntax, but you may find that some of these, as well as some scripts
    written for Unix systems, will require that you use Unix syntax, since they
    will assume that '/' is the directory separator, <i>etc.</i> If you find
    instances of this in the Perl distribution itself, please let us know, so we
    can try to work around them.</p>
<p class="Pp">Also when working on Perl programs on VMS, if you need a syntax in
    a specific operating system format, then you need either to check the
    appropriate DECC$ feature logical, or call a conversion routine to force it
    to that format.</p>
<p class="Pp">The feature logical name DECC$FILENAME_UNIX_REPORT modifies
    traditional Perl behavior in the conversion of file specifications from Unix
    to VMS format in order to follow the extended character handling rules now
    expected by the CRTL. Specifically, when this feature is in effect, the
    <span class="Li">&quot;./.../&quot;</span> in a Unix path is now translated
    to <span class="Li">&quot;[.^.^.^.]&quot;</span> instead of the traditional
    VMS <span class="Li">&quot;[...]&quot;</span>. To be compatible with what
    MakeMaker expects, if a VMS path cannot be translated to a Unix path, it is
    passed through unchanged, so
    <span class="Li">&quot;unixify(&quot;[...]&quot;)&quot;</span> will return
    <span class="Li">&quot;[...]&quot;</span>.</p>
<p class="Pp">There are several ambiguous cases where a conversion routine
    cannot determine whether an input filename is in Unix format or in VMS
    format, since now both VMS and Unix file specifications may have characters
    in them that could be mistaken for syntax delimiters of the other type. So
    some pathnames simply cannot be used in a mode that allows either type of
    pathname to be present. Perl will tend to assume that an ambiguous filename
    is in Unix format.</p>
<p class="Pp">Allowing &quot;.&quot; as a version delimiter is simply
    incompatible with determining whether a pathname is in VMS format or in Unix
    format with extended file syntax. There is no way to know whether
    &quot;perl-5.8.6&quot; is a Unix &quot;perl-5.8.6&quot; or a VMS
    &quot;perl-5.8;6&quot; when passing it to <b>unixify()</b> or
    <b>vmsify()</b>.</p>
<p class="Pp">The DECC$FILENAME_UNIX_REPORT logical name controls how Perl
    interprets filenames to the extent that Perl uses the CRTL internally for
    many purposes, and attempts to follow CRTL conventions for reporting
    filenames. The DECC$FILENAME_UNIX_ONLY feature differs in that it expects
    all filenames passed to the C run-time to be already in Unix format. This
    feature is not yet supported in Perl since Perl uses traditional OpenVMS
    file specifications internally and in the test harness, and it is not yet
    clear whether this mode will be useful or useable. The feature logical name
    DECC$POSIX_COMPLIANT_PATHNAMES is new with the RMS Symbolic Link SDK and
    included with OpenVMS v8.3, but is not yet supported in Perl.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Filename_Case"><a class="permalink" href="#Filename_Case">Filename
  Case</a></h2>
<p class="Pp">Perl enables DECC$EFS_CASE_PRESERVE and DECC$ARGV_PARSE_STYLE by
    default. Note that the latter only takes effect when extended parse is set
    in the process in which Perl is running. When these features are explicitly
    disabled in the environment or the CRTL does not support them, Perl follows
    the traditional CRTL behavior of downcasing command-line arguments and
    returning file specifications in lower case only.</p>
<p class="Pp"><i>N. B.</i> It is very easy to get tripped up using a mixture of
    other programs, external utilities, and Perl scripts that are in varying
    states of being able to handle case preservation. For example, a file
    created by an older version of an archive utility or a build utility such as
    MMK or MMS may generate a filename in all upper case even on an ODS-5
    volume. If this filename is later retrieved by a Perl script or module in a
    case preserving environment, that upper case name may not match the
    mixed-case or lower-case expectations of the Perl code. Your best bet is to
    follow an all-or-nothing approach to case preservation: either don't use it
    at all, or make sure your entire toolchain and application environment
    support and use it.</p>
<p class="Pp">OpenVMS Alpha v7.3-1 and later and all version of OpenVMS I64
    support case sensitivity as a process setting (see
    <span class="Li">&quot;SET PROCESS</span>
    <span class="Li">/CASE_LOOKUP=SENSITIVE&quot;</span>). Perl does not
    currently support case sensitivity on VMS, but it may in the future, so Perl
    programs should use the
    <span class="Li">&quot;File::Spec-&gt;case_tolerant&quot;</span> method to
    determine the state, and not the <span class="Li">$^O</span> variable.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Symbolic_Links"><a class="permalink" href="#Symbolic_Links">Symbolic
  Links</a></h2>
<p class="Pp">When built on an ODS-5 volume with symbolic links enabled, Perl by
    default supports symbolic links when the requisite support is available in
    the filesystem and CRTL (generally 64-bit OpenVMS v8.3 and later). There are
    a number of limitations and caveats to be aware of when working with
    symbolic links on VMS. Most notably, the target of a valid symbolic link
    must be expressed as a Unix-style path and it must exist on a volume visible
    from your POSIX root (see the <span class="Li">&quot;SHOW ROOT&quot;</span>
    command in DCL help). For further details on symbolic link capabilities and
    requirements, see chapter 12 of the CRTL manual that ships with OpenVMS v8.3
    or later.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Wildcard_expansion"><a class="permalink" href="#Wildcard_expansion">Wildcard
  expansion</a></h2>
<p class="Pp">File specifications containing wildcards are allowed both on the
    command line and within Perl globs (e.g.
    <span class="Li">&quot;&lt;*.c&gt;&quot;</span>). If the wildcard filespec
    uses VMS syntax, the resultant filespecs will follow VMS syntax; if a
    Unix-style filespec is passed in, Unix-style filespecs will be returned.
    Similar to the behavior of wildcard globbing for a Unix shell, one can
    escape command line wildcards with double quotation marks
    <span class="Li">&quot;&quot;&quot;</span> around a perl program command
    line argument. However, owing to the stripping of
    <span class="Li">&quot;&quot;&quot;</span> characters carried out by the C
    handling of argv you will need to escape a construct such as this one (in a
    directory containing the files <i>PERL.C</i>, <i>PERL.EXE</i>,
    <i>PERL.H</i>, and <i>PERL.OBJ</i>):</p>
<p class="Pp"></p>
<pre>
    $ perl -e &quot;print join(' ',@ARGV)&quot; perl.*
    perl.c perl.exe perl.h perl.obj
</pre>
<p class="Pp">in the following triple quoted manner:</p>
<p class="Pp"></p>
<pre>
    $ perl -e &quot;print join(' ',@ARGV)&quot; &quot;&quot;&quot;perl.*&quot;&quot;&quot;
    perl.*
</pre>
<p class="Pp">In both the case of unquoted command line arguments or in calls to
    <span class="Li">&quot;glob()&quot;</span> VMS wildcard expansion is
    performed. (csh-style wildcard expansion is available if you use
    <span class="Li">&quot;File::Glob::glob&quot;</span>.) If the wildcard
    filespec contains a device or directory specification, then the resultant
    filespecs will also contain a device and directory; otherwise, device and
    directory information are removed. VMS-style resultant filespecs will
    contain a full device and directory, while Unix-style resultant filespecs
    will contain only as much of a directory path as was present in the input
    filespec. For example, if your default directory is Perl_Root:[000000], the
    expansion of <span class="Li">&quot;[.t]*.*&quot;</span> will yield
    filespecs like &quot;perl_root:[t]base.dir&quot;, while the expansion of
    <span class="Li">&quot;t/*/*&quot;</span> will yield filespecs like
    &quot;t/base.dir&quot;. (This is done to match the behavior of glob
    expansion performed by Unix shells.)</p>
<p class="Pp">Similarly, the resultant filespec will contain the file version
    only if one was present in the input filespec.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Pipes"><a class="permalink" href="#Pipes">Pipes</a></h2>
<p class="Pp">Input and output pipes to Perl filehandles are supported; the
    &quot;file name&quot; is passed to lib$<b>spawn()</b> for asynchronous
    execution. You should be careful to close any pipes you have opened in a
    Perl script, lest you leave any &quot;orphaned&quot; subprocesses around
    when Perl exits.</p>
<p class="Pp">You may also use backticks to invoke a DCL subprocess, whose
    output is used as the return value of the expression. The string between the
    backticks is handled as if it were the argument to the
    <span class="Li">&quot;system&quot;</span> operator (see below). In this
    case, Perl will wait for the subprocess to complete before continuing.</p>
<p class="Pp">The mailbox (MBX) that perl can create to communicate with a pipe
    defaults to a buffer size of 8192 on 64-bit systems, 512 on VAX. The default
    buffer size is adjustable via the logical name PERL_MBX_SIZE provided that
    the value falls between 128 and the SYSGEN parameter MAXBUF inclusive. For
    example, to set the mailbox size to 32767 use
    <span class="Li">&quot;$ENV{'PERL_MBX_SIZE'} = 32767;&quot;</span> and then
    open and use pipe constructs. An alternative would be to issue the
  command:</p>
<p class="Pp"></p>
<pre>
    $ Define PERL_MBX_SIZE 32767
</pre>
<p class="Pp">before running your wide record pipe program. A larger value may
    improve performance at the expense of the BYTLM UAF quota.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="PERL5LIB_and_PERLLIB"><a class="permalink" href="#PERL5LIB_and_PERLLIB">PERL5LIB
  and PERLLIB</a></h1>
<p class="Pp">The PERL5LIB and PERLLIB environment elements work as documented
    in perl, except that the element separator is, by default, '|' instead of
    ':'. However, when running under a Unix shell as determined by the logical
    name <span class="Li">&quot;GNV$UNIX_SHELL&quot;</span>, the separator will
    be ':' as on Unix systems. The directory specifications may use either VMS
    or Unix syntax.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="The_Perl_Forked_Debugger"><a class="permalink" href="#The_Perl_Forked_Debugger">The
  Perl Forked Debugger</a></h1>
<p class="Pp">The Perl forked debugger places the debugger commands and output
    in a separate X-11 terminal window so that commands and output from multiple
    processes are not mixed together.</p>
<p class="Pp">Perl on VMS supports an emulation of the forked debugger when Perl
    is run on a VMS system that has X11 support installed.</p>
<p class="Pp">To use the forked debugger, you need to have the default display
    set to an X-11 Server and some environment variables set that Unix
  expects.</p>
<p class="Pp">The forked debugger requires the environment variable
    <span class="Li">&quot;TERM&quot;</span> to be
    <span class="Li">&quot;xterm&quot;</span>, and the environment variable
    <span class="Li">&quot;DISPLAY&quot;</span> to exist.
    <span class="Li">&quot;xterm&quot;</span> must be in lower case.</p>
<p class="Pp"></p>
<pre>
  $define TERM &quot;xterm&quot;

  $define DISPLAY &quot;hostname:0.0&quot;
</pre>
<p class="Pp">Currently the value of <span class="Li">&quot;DISPLAY&quot;</span>
    is ignored. It is recommended that it be set to be the hostname of the
    display, the server and screen in Unix notation. In the future the value of
    DISPLAY may be honored by Perl instead of using the default display.</p>
<p class="Pp">It may be helpful to always use the forked debugger so that script
    I/O is separated from debugger I/O. You can force the debugger to be forked
    by assigning a value to the logical name &lt;PERLDB_PIDS&gt; that is not a
    process identification number.</p>
<p class="Pp"></p>
<pre>
  $define PERLDB_PIDS XXXX
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="PERL_VMS_EXCEPTION_DEBUG"><a class="permalink" href="#PERL_VMS_EXCEPTION_DEBUG">PERL_VMS_EXCEPTION_DEBUG</a></h1>
<p class="Pp">The PERL_VMS_EXCEPTION_DEBUG being defined as &quot;ENABLE&quot;
    will cause the VMS debugger to be invoked if a fatal exception that is not
    otherwise handled is raised. The purpose of this is to allow debugging of
    internal Perl problems that would cause such a condition.</p>
<p class="Pp">This allows the programmer to look at the execution stack and
    variables to find out the cause of the exception. As the debugger is being
    invoked as the Perl interpreter is about to do a fatal exit, continuing the
    execution in debug mode is usually not practical.</p>
<p class="Pp">Starting Perl in the VMS debugger may change the program execution
    profile in a way that such problems are not reproduced.</p>
<p class="Pp">The <span class="Li">&quot;kill&quot;</span> function can be used
    to test this functionality from within a program.</p>
<p class="Pp">In typical VMS style, only the first letter of the value of this
    logical name is actually checked in a case insensitive mode, and it is
    considered enabled if it is the value &quot;T&quot;,&quot;1&quot; or
    &quot;E&quot;.</p>
<p class="Pp">This logical name must be defined before Perl is started.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Command_line"><a class="permalink" href="#Command_line">Command
  line</a></h1>
<section class="Ss">
<h2 class="Ss" id="I/O_redirection_and_backgrounding"><a class="permalink" href="#I/O_redirection_and_backgrounding">I/O
  redirection and backgrounding</a></h2>
<p class="Pp">Perl for VMS supports redirection of input and output on the
    command line, using a subset of Bourne shell syntax:</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;&lt;file&quot;</span> reads stdin from
      <span class="Li">&quot;file&quot;</span>,</li>
  <li><span class="Li">&quot;&gt;file&quot;</span> writes stdout to
      <span class="Li">&quot;file&quot;</span>,</li>
  <li><span class="Li">&quot;&gt;&gt;file&quot;</span> appends stdout to
      <span class="Li">&quot;file&quot;</span>,</li>
  <li><span class="Li">&quot;2&gt;file&quot;</span> writes stderr to
      <span class="Li">&quot;file&quot;</span>,</li>
  <li><span class="Li">&quot;2&gt;&gt;file&quot;</span> appends stderr to
      <span class="Li">&quot;file&quot;</span>, and</li>
  <li><span class="Li">&quot;2&gt;&amp;1&quot;</span> redirects stderr to
      stdout.</li>
</ul>
<p class="Pp">In addition, output may be piped to a subprocess, using the
    character '|'. Anything after this character on the command line is passed
    to a subprocess for execution; the subprocess takes the output of Perl as
    its input.</p>
<p class="Pp">Finally, if the command line ends with '&amp;', the entire command
    is run in the background as an asynchronous subprocess.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Command_line_switches"><a class="permalink" href="#Command_line_switches">Command
  line switches</a></h2>
<p class="Pp">The following command line switches behave differently under VMS
    than described in perlrun. Note also that in order to pass uppercase
    switches to Perl, you need to enclose them in double-quotes on the command
    line, since the CRTL downcases all unquoted strings.</p>
<p class="Pp">On newer 64 bit versions of OpenVMS, a process setting now
    controls if the quoting is needed to preserve the case of command line
    arguments.</p>
<dl class="Bl-tag">
  <dt id="i"><a class="permalink" href="#i">-i</a></dt>
  <dd>If the <span class="Li">&quot;-i&quot;</span> switch is present but no
      extension for a backup copy is given, then inplace editing creates a new
      version of a file; the existing copy is not deleted. (Note that if an
      extension is given, an existing file is renamed to the backup file, as is
      the case under other operating systems, so it does not remain as a
      previous version under the original filename.)</dd>
  <dt id="S"><a class="permalink" href="#S">-S</a></dt>
  <dd>If the <span class="Li">&quot;-S&quot;</span> or
      <span class="Li">&quot;-&quot;S&quot;&quot;</span> switch is present
      <i>and</i> the script name does not contain a directory, then Perl
      translates the logical name DCL$PATH as a searchlist, using each
      translation as a directory in which to look for the script. In addition,
      if no file type is specified, Perl looks in each directory for a file
      matching the name specified, with a blank type, a type of <i>.pl</i>, and
      a type of <i>.com</i>, in that order.</dd>
  <dt id="u"><a class="permalink" href="#u">-u</a></dt>
  <dd>The <span class="Li">&quot;-u&quot;</span> switch causes the VMS debugger
      to be invoked after the Perl program is compiled, but before it has run.
      It does not create a core dump file.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Perl_functions"><a class="permalink" href="#Perl_functions">Perl
  functions</a></h1>
<p class="Pp">As of the time this document was last revised, the following Perl
    functions were implemented in the VMS port of Perl (functions marked with *
    are discussed in more detail below):</p>
<p class="Pp"></p>
<pre>
    file tests*, abs, alarm, atan, backticks*, binmode*, bless,
    caller, chdir, chmod, chown, chomp, chop, chr,
    close, closedir, cos, crypt*, defined, delete, die, do, dump*, 
    each, endgrent, endpwent, eof, eval, exec*, exists, exit, exp, 
    fileno, flock  getc, getgrent*, getgrgid*, getgrnam, getlogin,
    getppid, getpwent*, getpwnam*, getpwuid*, glob, gmtime*, goto,
    grep, hex, ioctl, import, index, int, join, keys, kill*,
    last, lc, lcfirst, lchown*, length, link*, local, localtime, log,
    lstat, m//, map, mkdir, my, next, no, oct, open, opendir, ord,
    pack, pipe, pop, pos, print, printf, push, q//, qq//, qw//,
    qx//*, quotemeta, rand, read, readdir, readlink*, redo, ref,
    rename, require, reset, return, reverse, rewinddir, rindex,
    rmdir, s///, scalar, seek, seekdir, select(internal),
    select (system call)*, setgrent, setpwent, shift, sin, sleep,
    socketpair, sort, splice, split, sprintf, sqrt, srand, stat,
    study, substr, symlink*, sysread, system*, syswrite, tell,
    telldir, tie, time, times*, tr///, uc, ucfirst, umask,
    undef, unlink*, unpack, untie, unshift, use, utime*,
    values, vec, wait, waitpid*, wantarray, warn, write, y///
</pre>
<p class="Pp">The following functions were not implemented in the VMS port, and
    calling them produces a fatal error (usually) or undefined behavior (rarely,
    we hope):</p>
<p class="Pp"></p>
<pre>
    chroot, dbmclose, dbmopen, fork*, getpgrp, getpriority,  
    msgctl, msgget, msgsend, msgrcv, semctl,
    semget, semop, setpgrp, setpriority, shmctl, shmget,
    shmread, shmwrite, syscall
</pre>
<p class="Pp">The following functions are available on Perls compiled with Dec C
    5.2 or greater and running VMS 7.0 or greater:</p>
<p class="Pp"></p>
<pre>
    truncate
</pre>
<p class="Pp">The following functions are available on Perls built on VMS 7.2 or
    greater:</p>
<p class="Pp"></p>
<pre>
    fcntl (without locking)
</pre>
<p class="Pp">The following functions may or may not be implemented, depending
    on what type of socket support you've built into your copy of Perl:</p>
<p class="Pp"></p>
<pre>
    accept, bind, connect, getpeername,
    gethostbyname, getnetbyname, getprotobyname,
    getservbyname, gethostbyaddr, getnetbyaddr,
    getprotobynumber, getservbyport, gethostent,
    getnetent, getprotoent, getservent, sethostent,
    setnetent, setprotoent, setservent, endhostent,
    endnetent, endprotoent, endservent, getsockname,
    getsockopt, listen, recv, select(system call)*,
    send, setsockopt, shutdown, socket
</pre>
<p class="Pp">The following function is available on Perls built on 64 bit
    OpenVMS v8.2 with hard links enabled on an ODS-5 formatted build disk. CRTL
    support is in principle available as of OpenVMS v7.3-1, and better
    configuration support could detect this.</p>
<p class="Pp"></p>
<pre>
    link
</pre>
<p class="Pp">The following functions are available on Perls built on 64 bit
    OpenVMS v8.2 and later. CRTL support is in principle available as of OpenVMS
    v7.3-2, and better configuration support could detect this.</p>
<p class="Pp"></p>
<pre>
   getgrgid, getgrnam, getpwnam, getpwuid,
   setgrent, ttyname
</pre>
<p class="Pp">The following functions are available on Perls built on 64 bit
    OpenVMS v8.2 and later.</p>
<p class="Pp"></p>
<pre>
   statvfs, socketpair
</pre>
<dl class="Bl-tag">
  <dt id="File"><a class="permalink" href="#File">File tests</a></dt>
  <dd>The tests <span class="Li">&quot;-b&quot;</span>,
      <span class="Li">&quot;-B&quot;</span>,
      <span class="Li">&quot;-c&quot;</span>,
      <span class="Li">&quot;-C&quot;</span>,
      <span class="Li">&quot;-d&quot;</span>,
      <span class="Li">&quot;-e&quot;</span>,
      <span class="Li">&quot;-f&quot;</span>,
      <span class="Li">&quot;-o&quot;</span>,
      <span class="Li">&quot;-M&quot;</span>,
      <span class="Li">&quot;-s&quot;</span>,
      <span class="Li">&quot;-S&quot;</span>,
      <span class="Li">&quot;-t&quot;</span>,
      <span class="Li">&quot;-T&quot;</span>, and
      <span class="Li">&quot;-z&quot;</span> work as advertised. The return
      values for <span class="Li">&quot;-r&quot;</span>,
      <span class="Li">&quot;-w&quot;</span>, and
      <span class="Li">&quot;-x&quot;</span> tell you whether you can actually
      access the file; this may not reflect the UIC-based file protections.
      Since real and effective UIC don't differ under VMS,
      <span class="Li">&quot;-O&quot;</span>,
      <span class="Li">&quot;-R&quot;</span>,
      <span class="Li">&quot;-W&quot;</span>, and
      <span class="Li">&quot;-X&quot;</span> are equivalent to
      <span class="Li">&quot;-o&quot;</span>,
      <span class="Li">&quot;-r&quot;</span>,
      <span class="Li">&quot;-w&quot;</span>, and
      <span class="Li">&quot;-x&quot;</span>. Similarly, several other tests,
      including <span class="Li">&quot;-A&quot;</span>,
      <span class="Li">&quot;-g&quot;</span>,
      <span class="Li">&quot;-k&quot;</span>,
      <span class="Li">&quot;-l&quot;</span>,
      <span class="Li">&quot;-p&quot;</span>, and
      <span class="Li">&quot;-u&quot;</span>, aren't particularly meaningful
      under VMS, and the values returned by these tests reflect whatever your
      CRTL <span class="Li">&quot;stat()&quot;</span> routine does to the
      equivalent bits in the st_mode field. Finally,
      <span class="Li">&quot;-d&quot;</span> returns true if passed a device
      specification without an explicit directory (e.g.
      <span class="Li">&quot;DUA1:&quot;</span>), as well as if passed a
      directory.
    <p class="Pp">There are DECC feature logical names AND ODS-5 volume
        attributes that also control what values are returned for the date
        fields.</p>
    <p class="Pp">Note: Some sites have reported problems when using the
        file-access tests (<span class="Li">&quot;-r&quot;</span>,
        <span class="Li">&quot;-w&quot;</span>, and
        <span class="Li">&quot;-x&quot;</span>) on files accessed via DEC's DFS.
        Specifically, since DFS does not currently provide access to the
        extended file header of files on remote volumes, attempts to examine the
        ACL fail, and the file tests will return false, with
        <span class="Li">$!</span> indicating that the file does not exist. You
        can use <span class="Li">&quot;stat&quot;</span> on these files, since
        that checks UIC-based protection only, and then manually check the
        appropriate bits, as defined by your C compiler's <i>stat.h</i>, in the
        mode value it returns, if you need an approximation of the file's
        protections.</p>
  </dd>
  <dt id="backticks"><a class="permalink" href="#backticks">backticks</a></dt>
  <dd>Backticks create a subprocess, and pass the enclosed string to it for
      execution as a DCL command. Since the subprocess is created directly via
      <span class="Li">&quot;lib$spawn()&quot;</span>, any valid DCL command
      string may be specified.</dd>
  <dt id="binmode"><a class="permalink" href="#binmode">binmode
    FILEHANDLE</a></dt>
  <dd>The <span class="Li">&quot;binmode&quot;</span> operator will attempt to
      insure that no translation of carriage control occurs on input from or
      output to this filehandle. Since this involves reopening the file and then
      restoring its file position indicator, if this function returns FALSE, the
      underlying filehandle may no longer point to an open file, or may point to
      a different position in the file than before
      <span class="Li">&quot;binmode&quot;</span> was called.
    <p class="Pp">Note that <span class="Li">&quot;binmode&quot;</span> is
        generally not necessary when using normal filehandles; it is provided so
        that you can control I/O to existing record-structured files when
        necessary. You can also use the
        <span class="Li">&quot;vmsfopen&quot;</span> function in the VMS::Stdio
        extension to gain finer control of I/O to files and devices with
        different record structures.</p>
  </dd>
  <dt id="crypt"><a class="permalink" href="#crypt">crypt PLAINTEXT,
    USER</a></dt>
  <dd>The <span class="Li">&quot;crypt&quot;</span> operator uses the
      <span class="Li">&quot;sys$hash_password&quot;</span> system service to
      generate the hashed representation of PLAINTEXT. If USER is a valid
      username, the algorithm and salt values are taken from that user's UAF
      record. If it is not, then the preferred algorithm and a salt of 0 are
      used. The quadword encrypted value is returned as an 8-character string.
    <p class="Pp">The value returned by
        <span class="Li">&quot;crypt&quot;</span> may be compared against the
        encrypted password from the UAF returned by the
        <span class="Li">&quot;getpw*&quot;</span> functions, in order to
        authenticate users. If you're going to do this, remember that the
        encrypted password in the UAF was generated using uppercase username and
        password strings; you'll have to upcase the arguments to
        <span class="Li">&quot;crypt&quot;</span> to insure that you'll get the
        proper value:</p>
    <p class="Pp"></p>
    <pre>
    sub validate_passwd {
        my($user,$passwd) = @_;
        my($pwdhash);
        if ( !($pwdhash = (getpwnam($user))[1]) ||
               $pwdhash ne crypt(&quot;\U$passwd&quot;,&quot;\U$name&quot;) ) {
            intruder_alert($name);
        }
        return 1;
    }
    </pre>
  </dd>
  <dt id="die"><a class="permalink" href="#die">die</a></dt>
  <dd><span class="Li">&quot;die&quot;</span> will force the native VMS exit
      status to be an SS$_ABORT code if neither of the $! or $? status values
      are ones that would cause the native status to be interpreted as being
      what VMS classifies as SEVERE_ERROR severity for DCL error handling.
    <p class="Pp">When <span class="Li">&quot;PERL_VMS_POSIX_EXIT&quot;</span>
        is active (see &quot;$?&quot; below), the native VMS exit status value
        will have either one of the <span class="Li">$!</span> or
        <span class="Li">$?</span> or <span class="Li">$^E</span> or the Unix
        value 255 encoded into it in a way that the effective original value can
        be decoded by other programs written in C, including Perl and the GNV
        package. As per the normal non-VMS behavior of
        <span class="Li">&quot;die&quot;</span> if either
        <span class="Li">$!</span> or <span class="Li">$?</span> are non-zero,
        one of those values will be encoded into a native VMS status value. If
        both of the Unix status values are 0, and the
        <span class="Li">$^E</span> value is set one of ERROR or SEVERE_ERROR
        severity, then the <span class="Li">$^E</span> value will be used as the
        exit code as is. If none of the above apply, the Unix value of 255 will
        be encoded into a native VMS exit status value.</p>
    <p class="Pp">Please note a significant difference in the behavior of
        <span class="Li">&quot;die&quot;</span> in the
        <span class="Li">&quot;PERL_VMS_POSIX_EXIT&quot;</span> mode is that it
        does not force a VMS SEVERE_ERROR status on exit. The Unix exit values
        of 2 through 255 will be encoded in VMS status values with severity
        levels of SUCCESS. The Unix exit value of 1 will be encoded in a VMS
        status value with a severity level of ERROR. This is to be compatible
        with how the VMS C library encodes these values.</p>
    <p class="Pp">The minimum severity level set by
        <span class="Li">&quot;die&quot;</span> in
        <span class="Li">&quot;PERL_VMS_POSIX_EXIT&quot;</span> mode may be
        changed to be ERROR or higher in the future depending on the results of
        testing and further review.</p>
    <p class="Pp">See &quot;$?&quot; for a description of the encoding of the
        Unix value to produce a native VMS status containing it.</p>
  </dd>
  <dt id="dump"><a class="permalink" href="#dump">dump</a></dt>
  <dd>Rather than causing Perl to abort and dump core, the
      <span class="Li">&quot;dump&quot;</span> operator invokes the VMS
      debugger. If you continue to execute the Perl program under the debugger,
      control will be transferred to the label specified as the argument to
      <span class="Li">&quot;dump&quot;</span>, or, if no label was specified,
      back to the beginning of the program. All other state of the program
      (<i>e.g.</i> values of variables, open file handles) are not affected by
      calling <span class="Li">&quot;dump&quot;</span>.</dd>
  <dt id="exec"><a class="permalink" href="#exec">exec LIST</a></dt>
  <dd>A call to <span class="Li">&quot;exec&quot;</span> will cause Perl to
      exit, and to invoke the command given as an argument to
      <span class="Li">&quot;exec&quot;</span> via
      <span class="Li">&quot;lib$do_command&quot;</span>. If the argument begins
      with '@' or '$' (other than as part of a filespec), then it is executed as
      a DCL command. Otherwise, the first token on the command line is treated
      as the filespec of an image to run, and an attempt is made to invoke it
      (using <i>.Exe</i> and the process defaults to expand the filespec) and
      pass the rest of <span class="Li">&quot;exec&quot;</span>'s argument to it
      as parameters. If the token has no file type, and matches a file with null
      type, then an attempt is made to determine whether the file is an
      executable image which should be invoked using
      <span class="Li">&quot;MCR&quot;</span> or a text file which should be
      passed to DCL as a command procedure.</dd>
  <dt id="fork"><a class="permalink" href="#fork">fork</a></dt>
  <dd>While in principle the <span class="Li">&quot;fork&quot;</span> operator
      could be implemented via (and with the same rather severe limitations as)
      the CRTL <span class="Li">&quot;vfork()&quot;</span> routine, and while
      some internal support to do just that is in place, the implementation has
      never been completed, making <span class="Li">&quot;fork&quot;</span>
      currently unavailable. A true kernel
      <span class="Li">&quot;fork()&quot;</span> is expected in a future version
      of VMS, and the pseudo-fork based on interpreter threads may be available
      in a future version of Perl on VMS (see perlfork). In the meantime, use
      <span class="Li">&quot;system&quot;</span>, backticks, or piped
      filehandles to create subprocesses.</dd>
  <dt id="getpwent"><a class="permalink" href="#getpwent">getpwent</a></dt>
  <dd></dd>
  <dt id="getpwnam"><a class="permalink" href="#getpwnam">getpwnam</a></dt>
  <dd></dd>
  <dt id="getpwuid"><a class="permalink" href="#getpwuid">getpwuid</a></dt>
  <dd>These operators obtain the information described in perlfunc, if you have
      the privileges necessary to retrieve the named user's UAF information via
      <span class="Li">&quot;sys$getuai&quot;</span>. If not, then only the
      <span class="Li">$name</span>, <span class="Li">$uid</span>, and
      <span class="Li">$gid</span> items are returned. The
      <span class="Li">$dir</span> item contains the login directory in VMS
      syntax, while the <span class="Li">$comment</span> item contains the login
      directory in Unix syntax. The <span class="Li">$gcos</span> item contains
      the owner field from the UAF record. The <span class="Li">$quota</span>
      item is not used.</dd>
  <dt id="gmtime"><a class="permalink" href="#gmtime">gmtime</a></dt>
  <dd>The <span class="Li">&quot;gmtime&quot;</span> operator will function
      properly if you have a working CRTL
      <span class="Li">&quot;gmtime()&quot;</span> routine, or if the logical
      name SYS$TIMEZONE_DIFFERENTIAL is defined as the number of seconds which
      must be added to UTC to yield local time. (This logical name is defined
      automatically if you are running a version of VMS with built-in UTC
      support.) If neither of these cases is true, a warning message is printed,
      and <span class="Li">&quot;undef&quot;</span> is returned.</dd>
  <dt id="kill"><a class="permalink" href="#kill">kill</a></dt>
  <dd>In most cases, <span class="Li">&quot;kill&quot;</span> is implemented via
      the undocumented system service <span class="Li">$SIGPRC</span>, which has
      the same calling sequence as <span class="Li">$FORCEX</span>, but throws
      an exception in the target process rather than forcing it to call
      <span class="Li">$EXIT</span>. Generally speaking,
      <span class="Li">&quot;kill&quot;</span> follows the behavior of the
      CRTL's <span class="Li">&quot;kill()&quot;</span> function, but unlike
      that function can be called from within a signal handler. Also, unlike the
      <span class="Li">&quot;kill&quot;</span> in some versions of the CRTL,
      Perl's <span class="Li">&quot;kill&quot;</span> checks the validity of the
      signal passed in and returns an error rather than attempting to send an
      unrecognized signal.
    <p class="Pp">Also, negative signal values don't do anything special under
        VMS; they're just converted to the corresponding positive value.</p>
  </dd>
  <dt id="qx//"><a class="permalink" href="#qx//">qx//</a></dt>
  <dd>See the entry on <span class="Li">&quot;backticks&quot;</span> above.</dd>
  <dt id="select"><a class="permalink" href="#select">select (system
    call)</a></dt>
  <dd>If Perl was not built with socket support, the system call version of
      <span class="Li">&quot;select&quot;</span> is not available at all. If
      socket support is present, then the system call version of
      <span class="Li">&quot;select&quot;</span> functions only for file
      descriptors attached to sockets. It will not provide information about
      regular files or pipes, since the CRTL
      <span class="Li">&quot;select()&quot;</span> routine does not provide this
      functionality.</dd>
  <dt id="stat"><a class="permalink" href="#stat">stat EXPR</a></dt>
  <dd>Since VMS keeps track of files according to a different scheme than Unix,
      it's not really possible to represent the file's ID in the
      <span class="Li">&quot;st_dev&quot;</span> and
      <span class="Li">&quot;st_ino&quot;</span> fields of a
      <span class="Li">&quot;struct stat&quot;</span>. Perl tries its best,
      though, and the values it uses are pretty unlikely to be the same for two
      different files. We can't guarantee this, though, so caveat scriptor.</dd>
  <dt id="system"><a class="permalink" href="#system">system LIST</a></dt>
  <dd>The <span class="Li">&quot;system&quot;</span> operator creates a
      subprocess, and passes its arguments to the subprocess for execution as a
      DCL command. Since the subprocess is created directly via
      <span class="Li">&quot;lib$spawn()&quot;</span>, any valid DCL command
      string may be specified. If the string begins with '@', it is treated as a
      DCL command unconditionally. Otherwise, if the first token contains a
      character used as a delimiter in file specification (e.g.
      <span class="Li">&quot;:&quot;</span> or
      <span class="Li">&quot;]&quot;</span>), an attempt is made to expand it
      using a default type of <i>.Exe</i> and the process defaults, and if
      successful, the resulting file is invoked via
      <span class="Li">&quot;MCR&quot;</span>. This allows you to invoke an
      image directly simply by passing the file specification to
      <span class="Li">&quot;system&quot;</span>, a common Unixish idiom. If the
      token has no file type, and matches a file with null type, then an attempt
      is made to determine whether the file is an executable image which should
      be invoked using <span class="Li">&quot;MCR&quot;</span> or a text file
      which should be passed to DCL as a command procedure.
    <p class="Pp">If LIST consists of the empty string,
        <span class="Li">&quot;system&quot;</span> spawns an interactive DCL
        subprocess, in the same fashion as typing <b>SPAWN</b> at the DCL
        prompt.</p>
    <p class="Pp">Perl waits for the subprocess to complete before continuing
        execution in the current process. As described in perlfunc, the return
        value of <span class="Li">&quot;system&quot;</span> is a fake
        &quot;status&quot; which follows POSIX semantics unless the pragma
        <span class="Li">&quot;use vmsish 'status'&quot;</span> is in effect;
        see the description of <span class="Li">$?</span> in this document for
        more detail.</p>
  </dd>
  <dt id="time"><a class="permalink" href="#time">time</a></dt>
  <dd>The value returned by <span class="Li">&quot;time&quot;</span> is the
      offset in seconds from 01-JAN-1970 00:00:00 (just like the CRTL's
      <b>times()</b> routine), in order to make life easier for code coming in
      from the POSIX/Unix world.</dd>
  <dt id="times"><a class="permalink" href="#times">times</a></dt>
  <dd>The array returned by the <span class="Li">&quot;times&quot;</span>
      operator is divided up according to the same rules the CRTL
      <span class="Li">&quot;times()&quot;</span> routine. Therefore, the
      &quot;system time&quot; elements will always be 0, since there is no
      difference between &quot;user time&quot; and &quot;system&quot; time under
      VMS, and the time accumulated by a subprocess may or may not appear
      separately in the &quot;child time&quot; field, depending on whether
      <span class="Li">&quot;times()&quot;</span> keeps track of subprocesses
      separately. Note especially that the VAXCRTL (at least) keeps track only
      of subprocesses spawned using <span class="Li">&quot;fork()&quot;</span>
      and <span class="Li">&quot;exec()&quot;</span>; it will not accumulate the
      times of subprocesses spawned via pipes,
      <span class="Li">&quot;system()&quot;</span>, or backticks.</dd>
  <dt id="unlink"><a class="permalink" href="#unlink">unlink LIST</a></dt>
  <dd><span class="Li">&quot;unlink&quot;</span> will delete the highest version
      of a file only; in order to delete all versions, you need to say
    <p class="Pp"></p>
    <pre>
    1 while unlink LIST;
    </pre>
    <p class="Pp">You may need to make this change to scripts written for a Unix
        system which expect that after a call to
        <span class="Li">&quot;unlink&quot;</span>, no files with the names
        passed to <span class="Li">&quot;unlink&quot;</span> will exist. (Note:
        This can be changed at compile time; if you <span class="Li">&quot;use
        Config&quot;</span> and
        <span class="Li">$Config{'d_unlink_all_versions'}</span> is
        <span class="Li">&quot;define&quot;</span>, then
        <span class="Li">&quot;unlink&quot;</span> will delete all versions of a
        file on the first call.)</p>
    <p class="Pp"><span class="Li">&quot;unlink&quot;</span> will delete a file
        if at all possible, even if it requires changing file protection (though
        it won't try to change the protection of the parent directory). You can
        tell whether you've got explicit delete access to a file by using the
        <span class="Li">&quot;VMS::Filespec::candelete&quot;</span> operator.
        For instance, in order to delete only files to which you have delete
        access, you could say something like</p>
    <p class="Pp"></p>
    <pre>
    sub safe_unlink {
        my($file,$num);
        foreach $file (@_) {
            next unless VMS::Filespec::candelete($file);
            $num += unlink $file;
        }
        $num;
    }
    </pre>
    <p class="Pp">(or you could just use
        <span class="Li">&quot;VMS::Stdio::remove&quot;</span>, if you've
        installed the VMS::Stdio extension distributed with Perl). If
        <span class="Li">&quot;unlink&quot;</span> has to change the file
        protection to delete the file, and you interrupt it in midstream, the
        file may be left intact, but with a changed ACL allowing you delete
        access.</p>
    <p class="Pp">This behavior of <span class="Li">&quot;unlink&quot;</span> is
        to be compatible with POSIX behavior and not traditional VMS
      behavior.</p>
  </dd>
  <dt id="utime"><a class="permalink" href="#utime">utime LIST</a></dt>
  <dd>This operator changes only the modification time of the file (VMS revision
      date) on ODS-2 volumes and ODS-5 volumes without access dates enabled. On
      ODS-5 volumes with access dates enabled, the true access time is
    modified.</dd>
  <dt id="waitpid"><a class="permalink" href="#waitpid">waitpid
    PID,FLAGS</a></dt>
  <dd>If PID is a subprocess started by a piped
      <span class="Li">&quot;open()&quot;</span> (see open),
      <span class="Li">&quot;waitpid&quot;</span> will wait for that subprocess,
      and return its final status value in <span class="Li">$?</span>. If PID is
      a subprocess created in some other way (e.g. SPAWNed before Perl was
      invoked), <span class="Li">&quot;waitpid&quot;</span> will simply check
      once per second whether the process has completed, and return when it has.
      (If PID specifies a process that isn't a subprocess of the current
      process, and you invoked Perl with the
      <span class="Li">&quot;-w&quot;</span> switch, a warning will be issued.)
    <p class="Pp">Returns PID on success, -1 on error. The FLAGS argument is
        ignored in all cases.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Perl_variables"><a class="permalink" href="#Perl_variables">Perl
  variables</a></h1>
<p class="Pp">The following VMS-specific information applies to the indicated
    &quot;special&quot; Perl variables, in addition to the general information
    in perlvar. Where there is a conflict, this information takes
  precedence.</p>
<dl class="Bl-tag">
  <dt>%ENV</dt>
  <dd>The operation of the <span class="Li">%ENV</span> array depends on the
      translation of the logical name <i>PERL_ENV_TABLES</i>. If defined, it
      should be a search list, each element of which specifies a location for
      <span class="Li">%ENV</span> elements. If you tell Perl to read or set the
      element
      <span class="Li">&quot;$ENV{&quot;</span><i>name</i><span class="Li">&quot;}&quot;</span>,
      then Perl uses the translations of <i>PERL_ENV_TABLES</i> as follows:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="CRTL_ENV"><a class="permalink" href="#CRTL_ENV">CRTL_ENV</a></dt>
  <dd>This string tells Perl to consult the CRTL's internal
      <span class="Li">&quot;environ&quot;</span> array of key-value pairs,
      using <i>name</i> as the key. In most cases, this contains only a few
      keys, but if Perl was invoked via the C
      <span class="Li">&quot;exec[lv]e()&quot;</span> function, as is the case
      for some embedded Perl applications or when running under a shell such as
      GNV bash, the <span class="Li">&quot;environ&quot;</span> array may have
      been populated by the calling program.</dd>
  <dt id="CLISYM__"><a class="permalink" href="#CLISYM__">CLISYM_[LOCAL]</a></dt>
  <dd>A string beginning with <span class="Li">&quot;CLISYM_&quot;</span>tells
      Perl to consult the CLI's symbol tables, using <i>name</i> as the name of
      the symbol. When reading an element of <span class="Li">%ENV</span>, the
      local symbol table is scanned first, followed by the global symbol table..
      The characters following <span class="Li">&quot;CLISYM_&quot;</span> are
      significant when an element of <span class="Li">%ENV</span> is set or
      deleted: if the complete string is
      <span class="Li">&quot;CLISYM_LOCAL&quot;</span>, the change is made in
      the local symbol table; otherwise the global symbol table is changed.</dd>
  <dt id="Any"><a class="permalink" href="#Any">Any other string</a></dt>
  <dd>If an element of <i>PERL_ENV_TABLES</i> translates to any other string,
      that string is used as the name of a logical name table, which is
      consulted using <i>name</i> as the logical name. The normal search order
      of access modes is used.</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp"><i>PERL_ENV_TABLES</i> is translated once when Perl starts up; any
    changes you make while Perl is running do not affect the behavior of
    <span class="Li">%ENV</span>. If <i>PERL_ENV_TABLES</i> is not defined, then
    Perl defaults to consulting first the logical name tables specified by
    <i>LNM$FILE_DEV</i>, and then the CRTL
    <span class="Li">&quot;environ&quot;</span> array. This default order is
    reversed when the logical name <i>GNV$UNIX_SHELL</i> is defined, such as
    when running under GNV bash.</p>
<p class="Pp">For operations on <span class="Li">%ENV</span> entries based on
    logical names or DCL symbols, the key string is treated as if it were
    entirely uppercase, regardless of the case actually specified in the Perl
    expression. Entries in <span class="Li">%ENV</span> based on the CRTL's
    environ array preserve the case of the key string when stored, and lookups
    are case sensitive.</p>
<p class="Pp">When an element of <span class="Li">%ENV</span> is read, the
    locations to which <i>PERL_ENV_TABLES</i> points are checked in order, and
    the value obtained from the first successful lookup is returned. If the name
    of the <span class="Li">%ENV</span> element contains a semi-colon, it and
    any characters after it are removed. These are ignored when the CRTL
    <span class="Li">&quot;environ&quot;</span> array or a CLI symbol table is
    consulted. However, the name is looked up in a logical name table, the
    suffix after the semi-colon is treated as the translation index to be used
    for the lookup. This lets you look up successive values for search list
    logical names. For instance, if you say</p>
<p class="Pp"></p>
<pre>
   $  Define STORY  once,upon,a,time,there,was
   $  perl -e &quot;for ($i = 0; $i &lt;= 6; $i++) &quot; -
   _$ -e &quot;{ print $ENV{'story;'.$i},' '}&quot;
</pre>
<p class="Pp">Perl will print <span class="Li">&quot;ONCE UPON A TIME THERE
    WAS&quot;</span>, assuming, of course, that <i>PERL_ENV_TABLES</i> is set up
    so that the logical name <span class="Li">&quot;story&quot;</span> is found,
    rather than a CLI symbol or CRTL <span class="Li">&quot;environ&quot;</span>
    element with the same name.</p>
<p class="Pp">When an element of <span class="Li">%ENV</span> is set to a
    defined string, the corresponding definition is made in the location to
    which the first translation of <i>PERL_ENV_TABLES</i> points. If this causes
    a logical name to be created, it is defined in supervisor mode. (The same is
    done if an existing logical name was defined in executive or kernel mode; an
    existing user or supervisor mode logical name is reset to the new value.) If
    the value is an empty string, the logical name's translation is defined as a
    single <span class="Li">&quot;NUL&quot;</span> (ASCII
    <span class="Li">&quot;\0&quot;</span>) character, since a logical name
    cannot translate to a zero-length string. (This restriction does not apply
    to CLI symbols or CRTL <span class="Li">&quot;environ&quot;</span> values;
    they are set to the empty string.)</p>
<p class="Pp">When an element of <span class="Li">%ENV</span> is set to
    <span class="Li">&quot;undef&quot;</span>, the element is looked up as if it
    were being read, and if it is found, it is deleted. (An item
    &quot;deleted&quot; from the CRTL
    <span class="Li">&quot;environ&quot;</span> array is set to the empty
    string.) Using <span class="Li">&quot;delete&quot;</span> to remove an
    element from <span class="Li">%ENV</span> has a similar effect, but after
    the element is deleted, another attempt is made to look up the element, so
    an inner-mode logical name or a name in another location will replace the
    logical name just deleted. In either case, only the first value found
    searching PERL_ENV_TABLES is altered. It is not possible at present to
    define a search list logical name via <span class="Li">%ENV</span>.</p>
<p class="Pp">The element <span class="Li">$ENV{DEFAULT}</span> is special: when
    read, it returns Perl's current default device and directory, and when set,
    it resets them, regardless of the definition of <i>PERL_ENV_TABLES</i>. It
    cannot be cleared or deleted; attempts to do so are silently ignored.</p>
<p class="Pp">Note that if you want to pass on any elements of the C-local
    environ array to a subprocess which isn't started by fork/exec, or isn't
    running a C program, you can &quot;promote&quot; them to logical names in
    the current process, which will then be inherited by all subprocesses, by
    saying</p>
<p class="Pp"></p>
<pre>
    foreach my $key (qw[C-local keys you want promoted]) {
        my $temp = $ENV{$key}; # read from C-local array
        $ENV{$key} = $temp;    # and define as logical name
    }
</pre>
<p class="Pp">(You can't just say <span class="Li">$ENV{$key} =
    $ENV{$key}</span>, since the Perl optimizer is smart enough to elide the
    expression.)</p>
<p class="Pp">Don't try to clear <span class="Li">%ENV</span> by saying
    <span class="Li">&quot;%ENV = ();&quot;</span>, it will throw a fatal error.
    This is equivalent to doing the following from DCL:</p>
<p class="Pp"></p>
<pre>
    DELETE/LOGICAL *
</pre>
<p class="Pp">You can imagine how bad things would be if, for example, the
    SYS$MANAGER or SYS$SYSTEM logical names were deleted.</p>
<p class="Pp">At present, the first time you iterate over
    <span class="Li">%ENV</span> using <span class="Li">&quot;keys&quot;</span>,
    or <span class="Li">&quot;values&quot;</span>, you will incur a time penalty
    as all logical names are read, in order to fully populate
    <span class="Li">%ENV</span>. Subsequent iterations will not reread logical
    names, so they won't be as slow, but they also won't reflect any changes to
    logical name tables caused by other programs.</p>
<p class="Pp">You do need to be careful with the logical names representing
    process-permanent files, such as
    <span class="Li">&quot;SYS$INPUT&quot;</span> and
    <span class="Li">&quot;SYS$OUTPUT&quot;</span>. The translations for these
    logical names are prepended with a two-byte binary value (0x1B 0x00) that
    needs to be stripped off if you want to use it. (In previous versions of
    Perl it wasn't possible to get the values of these logical names, as the
    null byte acted as an end-of-string marker)</p>
</div>
<dl class="Bl-tag">
  <dt>$!</dt>
  <dd>The string value of <span class="Li">$!</span> is that returned by the
      CRTL's <b>strerror()</b> function, so it will include the VMS message for
      VMS-specific errors. The numeric value of <span class="Li">$!</span> is
      the value of <span class="Li">&quot;errno&quot;</span>, except if errno is
      EVMSERR, in which case <span class="Li">$!</span> contains the value of
      vaxc$errno. Setting <span class="Li">$!</span> always sets errno to the
      value specified. If this value is EVMSERR, it also sets vaxc$errno to 4
      (NONAME-F-NOMSG), so that the string value of <span class="Li">$!</span>
      won't reflect the VMS error message from before <span class="Li">$!</span>
      was set.</dd>
  <dt>$^E</dt>
  <dd>This variable provides direct access to VMS status values in vaxc$errno,
      which are often more specific than the generic Unix-style error messages
      in <span class="Li">$!</span>. Its numeric value is the value of
      vaxc$errno, and its string value is the corresponding VMS message string,
      as retrieved by sys$<b>getmsg()</b>. Setting <span class="Li">$^E</span>
      sets vaxc$errno to the value specified.
    <p class="Pp">While Perl attempts to keep the vaxc$errno value to be
        current, if errno is not EVMSERR, it may not be from the current
        operation.</p>
  </dd>
  <dt>$?</dt>
  <dd>The &quot;status value&quot; returned in <span class="Li">$?</span> is
      synthesized from the actual exit status of the subprocess in a way that
      approximates POSIX <b>wait</b>(5) semantics, in order to allow Perl
      programs to portably test for successful completion of subprocesses. The
      low order 8 bits of <span class="Li">$?</span> are always 0 under VMS,
      since the termination status of a process may or may not have been
      generated by an exception.
    <p class="Pp">The next 8 bits contain the termination status of the
      program.</p>
    <p class="Pp">If the child process follows the convention of C programs
        compiled with the _POSIX_EXIT macro set, the status value will contain
        the actual value of 0 to 255 returned by that program on a normal
      exit.</p>
    <p class="Pp">With the _POSIX_EXIT macro set, the Unix exit value of zero is
        represented as a VMS native status of 1, and the Unix values from 2 to
        255 are encoded by the equation:</p>
    <p class="Pp"></p>
    <pre>
   VMS_status = 0x35a000 + (unix_value * 8) + 1.
    </pre>
    <p class="Pp">And in the special case of Unix value 1 the encoding is:</p>
    <p class="Pp"></p>
    <pre>
   VMS_status = 0x35a000 + 8 + 2 + 0x10000000.
    </pre>
    <p class="Pp">For other termination statuses, the severity portion of the
        subprocess's exit status is used: if the severity was success or
        informational, these bits are all 0; if the severity was warning, they
        contain a value of 1; if the severity was error or fatal error, they
        contain the actual severity bits, which turns out to be a value of 2 for
        error and 4 for severe_error. Fatal is another term for the severe_error
        status.</p>
    <p class="Pp">As a result, <span class="Li">$?</span> will always be zero if
        the subprocess's exit status indicated successful completion, and
        non-zero if a warning or error occurred or a program compliant with
        encoding _POSIX_EXIT values was run and set a status.</p>
    <p class="Pp">How can you tell the difference between a non-zero status that
        is the result of a VMS native error status or an encoded Unix status?
        You can not unless you look at the ${^CHILD_ERROR_NATIVE} value. The
        ${^CHILD_ERROR_NATIVE} value returns the actual VMS status value and
        check the severity bits. If the severity bits are equal to 1, then if
        the numeric value for <span class="Li">$?</span> is between 2 and 255 or
        0, then <span class="Li">$?</span> accurately reflects a value passed
        back from a Unix application. If <span class="Li">$?</span> is 1, and
        the severity bits indicate a VMS error (2), then
        <span class="Li">$?</span> is from a Unix application exit value.</p>
    <p class="Pp">In practice, Perl scripts that call programs that return
        _POSIX_EXIT type status values will be expecting those values, and
        programs that call traditional VMS programs will either be expecting the
        previous behavior or just checking for a non-zero status.</p>
    <p class="Pp">And success is always the value 0 in all behaviors.</p>
    <p class="Pp">When the actual VMS termination status of the child is an
        error, internally the <span class="Li">$!</span> value will be set to
        the closest Unix errno value to that error so that Perl scripts that
        test for error messages will see the expected Unix style error message
        instead of a VMS message.</p>
    <p class="Pp">Conversely, when setting <span class="Li">$?</span> in an END
        block, an attempt is made to convert the POSIX value into a native
        status intelligible to the operating system upon exiting Perl. What this
        boils down to is that setting <span class="Li">$?</span> to zero results
        in the generic success value SS$_NORMAL, and setting
        <span class="Li">$?</span> to a non-zero value results in the generic
        failure status SS$_ABORT. See also &quot;exit&quot; in perlport.</p>
    <p class="Pp">With the
        <span class="Li">&quot;PERL_VMS_POSIX_EXIT&quot;</span> logical name
        defined as &quot;ENABLE&quot;, setting <span class="Li">$?</span> will
        cause the new value to be encoded into <span class="Li">$^E</span> so
        that either the original parent or child exit status values
      <br/>
       0 to 255 can be automatically recovered by C programs expecting
        _POSIX_EXIT behavior. If both a parent and a child exit value are
        non-zero, then it will be assumed that this is actually a VMS native
        status value to be passed through. The special value of 0xFFFF is almost
        a NOOP as it will cause the current native VMS status in the C library
        to become the current native Perl VMS status, and is handled this way as
        it is known to not be a valid native VMS status value. It is recommend
        that only values in the range of normal Unix parent or child status
        numbers, 0 to 255 are used.</p>
    <p class="Pp">The pragma <span class="Li">&quot;use vmsish
        'status'&quot;</span> makes <span class="Li">$?</span> reflect the
        actual VMS exit status instead of the default emulation of POSIX status
        described above. This pragma also disables the conversion of non-zero
        values to SS$_ABORT when setting <span class="Li">$?</span> in an END
        block (but zero will still be converted to SS$_NORMAL).</p>
    <p class="Pp">Do not use the pragma <span class="Li">&quot;use vmsish
        'status'&quot;</span> with
        <span class="Li">&quot;PERL_VMS_POSIX_EXIT&quot;</span> enabled, as they
        are at times requesting conflicting actions and the consequence of
        ignoring this advice will be undefined to allow future improvements in
        the POSIX exit handling.</p>
    <p class="Pp">In general, with
        <span class="Li">&quot;PERL_VMS_POSIX_EXIT&quot;</span> enabled, more
        detailed information will be available in the exit status for DCL
        scripts or other native VMS tools, and will give the expected
        information for Posix programs. It has not been made the default in
        order to preserve backward compatibility.</p>
    <p class="Pp">N.B. Setting
        <span class="Li">&quot;DECC$FILENAME_UNIX_REPORT&quot;</span> implicitly
        enables <span class="Li">&quot;PERL_VMS_POSIX_EXIT&quot;</span>.</p>
  </dd>
  <dt>$|</dt>
  <dd>Setting <span class="Li">$|</span> for an I/O stream causes data to be
      flushed all the way to disk on each write (<i>i.e.</i> not just to the
      underlying RMS buffers for a file). In other words, it's equivalent to
      calling <b>fflush()</b> and <b>fsync()</b> from C.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Standard_modules_with_VMS-specific_differences"><a class="permalink" href="#Standard_modules_with_VMS-specific_differences">Standard
  modules with VMS-specific differences</a></h1>
<section class="Ss">
<h2 class="Ss" id="SDBM_File"><a class="permalink" href="#SDBM_File">SDBM_File</a></h2>
<p class="Pp">SDBM_File works properly on VMS. It has, however, one minor
    difference. The database directory file created has a <i>.sdbm_dir</i>
    extension rather than a <i>.dir</i> extension. <i>.dir</i> files are VMS
    filesystem directory files, and using them for other purposes could cause
    unacceptable problems.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Revision_date"><a class="permalink" href="#Revision_date">Revision
  date</a></h1>
<p class="Pp">Please see the git repository for revision history.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Charles Bailey bailey@cor.newman.upenn.edu Craig Berry
    craigberry@mac.com Dan Sugalski dan@sidhe.org John Malmberg
  wb8tyw@qsl.net</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

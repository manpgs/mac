<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PERLRETUT(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLRETUT(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLRETUT(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlretut - Perl regular expressions tutorial</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This page provides a basic tutorial on understanding, creating and
    using regular expressions in Perl. It serves as a complement to the
    reference page on regular expressions perlre. Regular expressions are an
    integral part of the <span class="Li">&quot;m//&quot;</span>,
    <span class="Li">&quot;s///&quot;</span>,
    <span class="Li">&quot;qr//&quot;</span> and
    <span class="Li">&quot;split&quot;</span> operators and so this tutorial
    also overlaps with &quot;Regexp Quote-Like Operators&quot; in perlop and
    &quot;split&quot; in perlfunc.</p>
<p class="Pp">Perl is widely renowned for excellence in text processing, and
    regular expressions are one of the big factors behind this fame. Perl
    regular expressions display an efficiency and flexibility unknown in most
    other computer languages. Mastering even the basics of regular expressions
    will allow you to manipulate text with surprising ease.</p>
<p class="Pp">What is a regular expression? At its most basic, a regular
    expression is a template that is used to determine if a string has certain
    characteristics. The string is most often some text, such as a line,
    sentence, web page, or even a whole book, but less commonly it could be some
    binary data as well. Suppose we want to determine if the text in variable,
    <span class="Li">$var</span> contains the sequence of characters
    <span class="Li">&quot;m&#x00A0;u&#x00A0;s&#x00A0;h&#x00A0;r&#x00A0;o&#x00A0;o&#x00A0;m&quot;</span>
    (blanks added for legibility). We can write in Perl</p>
<p class="Pp"></p>
<pre> $var =~ m/mushroom/
</pre>
<p class="Pp">The value of this expression will be TRUE if
    <span class="Li">$var</span> contains that sequence of characters, and FALSE
    otherwise. The portion enclosed in <span class="Li">'/'</span> characters
    denotes the characteristic we are looking for. We use the term
    <i>pattern</i> for it. The process of looking to see if the pattern occurs
    in the string is called <i>matching</i>, and the
    <span class="Li">&quot;=~&quot;</span> operator along with the
    <span class="Li">&quot;m//&quot;</span> tell Perl to try to match the
    pattern against the string. Note that the pattern is also a string, but a
    very special kind of one, as we will see. Patterns are in common use these
    days; examples are the patterns typed into a search engine to find web pages
    and the patterns used to list files in a directory, <i>e.g.</i>,
    &quot;<span class="Li">&quot;ls *.txt&quot;</span>&quot; or
    &quot;<span class="Li">&quot;dir *.*&quot;</span>&quot;. In Perl, the
    patterns described by regular expressions are used not only to search
    strings, but to also extract desired parts of strings, and to do search and
    replace operations.</p>
<p class="Pp">Regular expressions have the undeserved reputation of being
    abstract and difficult to understand. This really stems simply because the
    notation used to express them tends to be terse and dense, and not because
    of inherent complexity. We recommend using the
    <span class="Li">&quot;/x&quot;</span> regular expression modifier
    (described below) along with plenty of white space to make them less dense,
    and easier to read. Regular expressions are constructed using simple
    concepts like conditionals and loops and are no more difficult to understand
    than the corresponding <span class="Li">&quot;if&quot;</span> conditionals
    and <span class="Li">&quot;while&quot;</span> loops in the Perl language
    itself.</p>
<p class="Pp">This tutorial flattens the learning curve by discussing regular
    expression concepts, along with their notation, one at a time and with many
    examples. The first part of the tutorial will progress from the simplest
    word searches to the basic regular expression concepts. If you master the
    first part, you will have all the tools needed to solve about 98% of your
    needs. The second part of the tutorial is for those comfortable with the
    basics and hungry for more power tools. It discusses the more advanced
    regular expression operators and introduces the latest cutting-edge
    innovations.</p>
<p class="Pp">A note: to save time, &quot;regular expression&quot; is often
    abbreviated as regexp or regex. Regexp is a more natural abbreviation than
    regex, but is harder to pronounce. The Perl pod documentation is evenly
    split on regexp vs regex; in Perl, there is more than one way to abbreviate
    it. We'll use regexp in this tutorial.</p>
<p class="Pp">New in v5.22, <span class="Li">&quot;use re 'strict'&quot;</span>
    applies stricter rules than otherwise when compiling regular expression
    patterns. It can find things that, while legal, may not be what you
    intended.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Part_1:_The_basics"><a class="permalink" href="#Part_1:_The_basics">Part
  1: The basics</a></h1>
<section class="Ss">
<h2 class="Ss" id="Simple_word_matching"><a class="permalink" href="#Simple_word_matching">Simple
  word matching</a></h2>
<p class="Pp">The simplest regexp is simply a word, or more generally, a string
    of characters. A regexp consisting of just a word matches any string that
    contains that word:</p>
<p class="Pp"></p>
<pre>    &quot;Hello World&quot; =~ /World/;  # matches
</pre>
<p class="Pp">What is this Perl statement all about?
    <span class="Li">&quot;Hello World&quot;</span> is a simple double-quoted
    string. <span class="Li">&quot;World&quot;</span> is the regular expression
    and the <span class="Li">&quot;//&quot;</span> enclosing
    <span class="Li">&quot;/World/&quot;</span> tells Perl to search a string
    for a match. The operator <span class="Li">&quot;=~&quot;</span> associates
    the string with the regexp match and produces a true value if the regexp
    matched, or false if the regexp did not match. In our case,
    <span class="Li">&quot;World&quot;</span> matches the second word in
    <span class="Li">&quot;Hello World&quot;</span>, so the expression is true.
    Expressions like this are useful in conditionals:</p>
<p class="Pp"></p>
<pre>    if (&quot;Hello World&quot; =~ /World/) {
        print &quot;It matches\n&quot;;
    }
    else {
        print &quot;It doesn't match\n&quot;;
    }
</pre>
<p class="Pp">There are useful variations on this theme. The sense of the match
    can be reversed by using the <span class="Li">&quot;!~&quot;</span>
    operator:</p>
<p class="Pp"></p>
<pre>    if (&quot;Hello World&quot; !~ /World/) {
        print &quot;It doesn't match\n&quot;;
    }
    else {
        print &quot;It matches\n&quot;;
    }
</pre>
<p class="Pp">The literal string in the regexp can be replaced by a
  variable:</p>
<p class="Pp"></p>
<pre>    my $greeting = &quot;World&quot;;
    if (&quot;Hello World&quot; =~ /$greeting/) {
        print &quot;It matches\n&quot;;
    }
    else {
        print &quot;It doesn't match\n&quot;;
    }
</pre>
<p class="Pp">If you're matching against the special default variable
    <span class="Li">$_</span>, the <span class="Li">&quot;$_ =~&quot;</span>
    part can be omitted:</p>
<p class="Pp"></p>
<pre>    $_ = &quot;Hello World&quot;;
    if (/World/) {
        print &quot;It matches\n&quot;;
    }
    else {
        print &quot;It doesn't match\n&quot;;
    }
</pre>
<p class="Pp">And finally, the <span class="Li">&quot;//&quot;</span> default
    delimiters for a match can be changed to arbitrary delimiters by putting an
    <span class="Li">'m'</span> out front:</p>
<p class="Pp"></p>
<pre>    &quot;Hello World&quot; =~ m!World!;   # matches, delimited by '!'
    &quot;Hello World&quot; =~ m{World};   # matches, note the matching '{}'
    &quot;/usr/bin/perl&quot; =~ m&quot;/perl&quot;; # matches after '/usr/bin',
                                 # '/' becomes an ordinary char
</pre>
<p class="Pp"><span class="Li">&quot;/World/&quot;</span>,
    <span class="Li">&quot;m!World!&quot;</span>, and
    <span class="Li">&quot;m{World}&quot;</span> all represent the same thing.
    When, <i>e.g.</i>, the quote (<span class="Li">'&quot;'</span>) is used as a
    delimiter, the forward slash <span class="Li">'/'</span> becomes an ordinary
    character and can be used in this regexp without trouble.</p>
<p class="Pp">Let's consider how different regexps would match
    <span class="Li">&quot;Hello World&quot;</span>:</p>
<p class="Pp"></p>
<pre>    &quot;Hello World&quot; =~ /world/;  # doesn't match
    &quot;Hello World&quot; =~ /o W/;    # matches
    &quot;Hello World&quot; =~ /oW/;     # doesn't match
    &quot;Hello World&quot; =~ /World /; # doesn't match
</pre>
<p class="Pp">The first regexp <span class="Li">&quot;world&quot;</span> doesn't
    match because regexps are case-sensitive. The second regexp matches because
    the substring <span class="Li">'o&#x00A0;W'</span> occurs in the string
    <span class="Li">&quot;Hello&#x00A0;World&quot;</span>. The space character
    <span class="Li">' '</span> is treated like any other character in a regexp
    and is needed to match in this case. The lack of a space character is the
    reason the third regexp <span class="Li">'oW'</span> doesn't match. The
    fourth regexp &quot;<span class="Li">&quot;World &quot;</span>&quot; doesn't
    match because there is a space at the end of the regexp, but not at the end
    of the string. The lesson here is that regexps must match a part of the
    string <i>exactly</i> in order for the statement to be true.</p>
<p class="Pp">If a regexp matches in more than one place in the string, Perl
    will always match at the earliest possible point in the string:</p>
<p class="Pp"></p>
<pre>    &quot;Hello World&quot; =~ /o/;       # matches 'o' in 'Hello'
    &quot;That hat is red&quot; =~ /hat/; # matches 'hat' in 'That'
</pre>
<p class="Pp">With respect to character matching, there are a few more points
    you need to know about. First of all, not all characters can be used
    &quot;as is&quot; in a match. Some characters, called <i>metacharacters</i>,
    are generally reserved for use in regexp notation. The metacharacters
  are</p>
<p class="Pp"></p>
<pre>    {}[]()^$.|*+?-#\
</pre>
<p class="Pp">This list is not as definitive as it may appear (or be claimed to
    be in other documentation). For example,
    <span class="Li">&quot;#&quot;</span> is a metacharacter only when the
    <span class="Li">&quot;/x&quot;</span> pattern modifier (described below) is
    used, and both <span class="Li">&quot;}&quot;</span> and
    <span class="Li">&quot;]&quot;</span> are metacharacters only when paired
    with opening <span class="Li">&quot;{&quot;</span> or
    <span class="Li">&quot;[&quot;</span> respectively; other gotchas apply.</p>
<p class="Pp">The significance of each of these will be explained in the rest of
    the tutorial, but for now, it is important only to know that a metacharacter
    can be matched as-is by putting a backslash before it:</p>
<p class="Pp"></p>
<pre>    &quot;2+2=4&quot; =~ /2+2/;    # doesn't match, + is a metacharacter
    &quot;2+2=4&quot; =~ /2\+2/;   # matches, \+ is treated like an ordinary +
    &quot;The interval is [0,1).&quot; =~ /[0,1)./     # is a syntax error!
    &quot;The interval is [0,1).&quot; =~ /\[0,1\)\./  # matches
    &quot;#!/usr/bin/perl&quot; =~ /#!\/usr\/bin\/perl/;  # matches
</pre>
<p class="Pp">In the last regexp, the forward slash <span class="Li">'/'</span>
    is also backslashed, because it is used to delimit the regexp. This can lead
    to LTS (leaning toothpick syndrome), however, and it is often more readable
    to change delimiters.</p>
<p class="Pp"></p>
<pre>    &quot;#!/usr/bin/perl&quot; =~ m!#\!/usr/bin/perl!;  # easier to read
</pre>
<p class="Pp">The backslash character <span class="Li">'\'</span> is a
    metacharacter itself and needs to be backslashed:</p>
<p class="Pp"></p>
<pre>    'C:\WIN32' =~ /C:\\WIN/;   # matches
</pre>
<p class="Pp">In situations where it doesn't make sense for a particular
    metacharacter to mean what it normally does, it automatically loses its
    metacharacter-ness and becomes an ordinary character that is to be matched
    literally. For example, the <span class="Li">'}'</span> is a metacharacter
    only when it is the mate of a <span class="Li">'{'</span> metacharacter.
    Otherwise it is treated as a literal RIGHT CURLY BRACKET. This may lead to
    unexpected results. <span class="Li">&quot;use re 'strict'&quot;</span> can
    catch some of these.</p>
<p class="Pp">In addition to the metacharacters, there are some ASCII characters
    which don't have printable character equivalents and are instead represented
    by <i>escape sequences</i>. Common examples are
    <span class="Li">&quot;\t&quot;</span> for a tab,
    <span class="Li">&quot;\n&quot;</span> for a newline,
    <span class="Li">&quot;\r&quot;</span> for a carriage return and
    <span class="Li">&quot;\a&quot;</span> for a bell (or alert). If your string
    is better thought of as a sequence of arbitrary bytes, the octal escape
    sequence, <i>e.g.</i>, <span class="Li">&quot;\033&quot;</span>, or
    hexadecimal escape sequence, <i>e.g.</i>,
    <span class="Li">&quot;\x1B&quot;</span> may be a more natural
    representation for your bytes. Here are some examples of escapes:</p>
<p class="Pp"></p>
<pre>    &quot;1000\t2000&quot; =~ m(0\t2)   # matches
    &quot;1000\n2000&quot; =~ /0\n20/   # matches
    &quot;1000\t2000&quot; =~ /\000\t2/ # doesn't match, &quot;0&quot; ne &quot;\000&quot;
    &quot;cat&quot;   =~ /\o{143}\x61\x74/ # matches in ASCII, but a weird way
                                 # to spell cat
</pre>
<p class="Pp">If you've been around Perl a while, all this talk of escape
    sequences may seem familiar. Similar escape sequences are used in
    double-quoted strings and in fact the regexps in Perl are mostly treated as
    double-quoted strings. This means that variables can be used in regexps as
    well. Just like double-quoted strings, the values of the variables in the
    regexp will be substituted in before the regexp is evaluated for matching
    purposes. So we have:</p>
<p class="Pp"></p>
<pre>    $foo = 'house';
    'housecat' =~ /$foo/;      # matches
    'cathouse' =~ /cat$foo/;   # matches
    'housecat' =~ /${foo}cat/; # matches
</pre>
<p class="Pp">So far, so good. With the knowledge above you can already perform
    searches with just about any literal string regexp you can dream up. Here is
    a <i>very simple</i> emulation of the Unix grep program:</p>
<p class="Pp"></p>
<pre>    % cat &gt; simple_grep
    #!/usr/bin/perl
    $regexp = shift;
    while (&lt;&gt;) {
        print if /$regexp/;
    }
    ^D
    % chmod +x simple_grep
    % simple_grep abba /usr/dict/words
    Babbage
    cabbage
    cabbages
    sabbath
    Sabbathize
    Sabbathizes
    sabbatical
    scabbard
    scabbards
</pre>
<p class="Pp">This program is easy to understand.
    <span class="Li">&quot;#!/usr/bin/perl&quot;</span> is the standard way to
    invoke a perl program from the shell.
    <span class="Li">&quot;$regexp&#x00A0;=&#x00A0;shift;&quot;</span> saves the
    first command line argument as the regexp to be used, leaving the rest of
    the command line arguments to be treated as files.
    <span class="Li">&quot;while&#x00A0;(&lt;&gt;)&quot;</span> loops over all
    the lines in all the files. For each line,
    <span class="Li">&quot;print&#x00A0;if&#x00A0;/$regexp/;&quot;</span> prints
    the line if the regexp matches the line. In this line, both
    <span class="Li">&quot;print&quot;</span> and
    <span class="Li">&quot;/$regexp/&quot;</span> use the default variable
    <span class="Li">$_</span> implicitly.</p>
<p class="Pp">With all of the regexps above, if the regexp matched anywhere in
    the string, it was considered a match. Sometimes, however, we'd like to
    specify <i>where</i> in the string the regexp should try to match. To do
    this, we would use the <i>anchor</i> metacharacters
    <span class="Li">'^'</span> and <span class="Li">'$'</span>. The anchor
    <span class="Li">'^'</span> means match at the beginning of the string and
    the anchor <span class="Li">'$'</span> means match at the end of the string,
    or before a newline at the end of the string. Here is how they are used:</p>
<p class="Pp"></p>
<pre>    &quot;housekeeper&quot; =~ /keeper/;    # matches
    &quot;housekeeper&quot; =~ /^keeper/;   # doesn't match
    &quot;housekeeper&quot; =~ /keeper$/;   # matches
    &quot;housekeeper\n&quot; =~ /keeper$/; # matches
</pre>
<p class="Pp">The second regexp doesn't match because
    <span class="Li">'^'</span> constrains
    <span class="Li">&quot;keeper&quot;</span> to match only at the beginning of
    the string, but <span class="Li">&quot;housekeeper&quot;</span> has keeper
    starting in the middle. The third regexp does match, since the
    <span class="Li">'$'</span> constrains
    <span class="Li">&quot;keeper&quot;</span> to match only at the end of the
    string.</p>
<p class="Pp">When both <span class="Li">'^'</span> and
    <span class="Li">'$'</span> are used at the same time, the regexp has to
    match both the beginning and the end of the string, <i>i.e.</i>, the regexp
    matches the whole string. Consider</p>
<p class="Pp"></p>
<pre>    &quot;keeper&quot; =~ /^keep$/;      # doesn't match
    &quot;keeper&quot; =~ /^keeper$/;    # matches
    &quot;&quot;       =~ /^$/;          # ^$ matches an empty string
</pre>
<p class="Pp">The first regexp doesn't match because the string has more to it
    than <span class="Li">&quot;keep&quot;</span>. Since the second regexp is
    exactly the string, it matches. Using both <span class="Li">'^'</span> and
    <span class="Li">'$'</span> in a regexp forces the complete string to match,
    so it gives you complete control over which strings match and which don't.
    Suppose you are looking for a fellow named bert, off in a string by
  himself:</p>
<p class="Pp"></p>
<pre>    &quot;dogbert&quot; =~ /bert/;   # matches, but not what you want
    &quot;dilbert&quot; =~ /^bert/;  # doesn't match, but ..
    &quot;bertram&quot; =~ /^bert/;  # matches, so still not good enough
    &quot;bertram&quot; =~ /^bert$/; # doesn't match, good
    &quot;dilbert&quot; =~ /^bert$/; # doesn't match, good
    &quot;bert&quot;    =~ /^bert$/; # matches, perfect
</pre>
<p class="Pp">Of course, in the case of a literal string, one could just as
    easily use the string comparison
    <span class="Li">&quot;$string&#x00A0;eq&#x00A0;'bert'&quot;</span> and it
    would be more efficient. The <span class="Li">&quot;^...$&quot;</span>
    regexp really becomes useful when we add in the more powerful regexp tools
    below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_character_classes"><a class="permalink" href="#Using_character_classes">Using
  character classes</a></h2>
<p class="Pp">Although one can already do quite a lot with the literal string
    regexps above, we've only scratched the surface of regular expression
    technology. In this and subsequent sections we will introduce regexp
    concepts (and associated metacharacter notations) that will allow a regexp
    to represent not just a single character sequence, but a <i>whole</i>
    <i>class</i> of them.</p>
<p class="Pp">One such concept is that of a <i>character class</i>. A character
    class allows a set of possible characters, rather than just a single
    character, to match at a particular point in a regexp. You can define your
    own custom character classes. These are denoted by brackets
    <span class="Li">&quot;[...]&quot;</span>, with the set of characters to be
    possibly matched inside. Here are some examples:</p>
<p class="Pp"></p>
<pre>    /cat/;       # matches 'cat'
    /[bcr]at/;   # matches 'bat, 'cat', or 'rat'
    /item[0123456789]/;  # matches 'item0' or ... or 'item9'
    &quot;abc&quot; =~ /[cab]/;    # matches 'a'
</pre>
<p class="Pp">In the last statement, even though <span class="Li">'c'</span> is
    the first character in the class, <span class="Li">'a'</span> matches
    because the first character position in the string is the earliest point at
    which the regexp can match.</p>
<p class="Pp"></p>
<pre>    /[yY][eE][sS]/;      # match 'yes' in a case-insensitive way
                         # 'yes', 'Yes', 'YES', etc.
</pre>
<p class="Pp">This regexp displays a common task: perform a case-insensitive
    match. Perl provides a way of avoiding all those brackets by simply
    appending an <span class="Li">'i'</span> to the end of the match. Then
    <span class="Li">&quot;/[yY][eE][sS]/;&quot;</span> can be rewritten as
    <span class="Li">&quot;/yes/i;&quot;</span>. The <span class="Li">'i'</span>
    stands for case-insensitive and is an example of a <i>modifier</i> of the
    matching operation. We will meet other modifiers later in the tutorial.</p>
<p class="Pp">We saw in the section above that there were ordinary characters,
    which represented themselves, and special characters, which needed a
    backslash <span class="Li">'\'</span> to represent themselves. The same is
    true in a character class, but the sets of ordinary and special characters
    inside a character class are different than those outside a character class.
    The special characters for a character class are
    <span class="Li">&quot;-]\^$&quot;</span> (and the pattern delimiter,
    whatever it is). <span class="Li">']'</span> is special because it denotes
    the end of a character class. <span class="Li">'$'</span> is special because
    it denotes a scalar variable. <span class="Li">'\'</span> is special because
    it is used in escape sequences, just like above. Here is how the special
    characters <span class="Li">&quot;]$\&quot;</span> are handled:</p>
<p class="Pp"></p>
<pre>   /[\]c]def/; # matches ']def' or 'cdef'
   $x = 'bcr';
   /[$x]at/;   # matches 'bat', 'cat', or 'rat'
   /[\$x]at/;  # matches '$at' or 'xat'
   /[\\$x]at/; # matches '\at', 'bat, 'cat', or 'rat'
</pre>
<p class="Pp">The last two are a little tricky. In
    <span class="Li">&quot;[\$x]&quot;</span>, the backslash protects the dollar
    sign, so the character class has two members <span class="Li">'$'</span> and
    <span class="Li">'x'</span>. In <span class="Li">&quot;[\\$x]&quot;</span>,
    the backslash is protected, so <span class="Li">$x</span> is treated as a
    variable and substituted in double quote fashion.</p>
<p class="Pp">The special character <span class="Li">'-'</span> acts as a range
    operator within character classes, so that a contiguous set of characters
    can be written as a range. With ranges, the unwieldy
    <span class="Li">&quot;[0123456789]&quot;</span> and
    <span class="Li">&quot;[abc...xyz]&quot;</span> become the svelte
    <span class="Li">&quot;[0-9]&quot;</span> and
    <span class="Li">&quot;[a-z]&quot;</span>. Some examples are</p>
<p class="Pp"></p>
<pre>    /item[0-9]/;  # matches 'item0' or ... or 'item9'
    /[0-9bx-z]aa/;  # matches '0aa', ..., '9aa',
                    # 'baa', 'xaa', 'yaa', or 'zaa'
    /[0-9a-fA-F]/;  # matches a hexadecimal digit
    /[0-9a-zA-Z_]/; # matches a &quot;word&quot; character,
                    # like those in a Perl variable name
</pre>
<p class="Pp">If <span class="Li">'-'</span> is the first or last character in a
    character class, it is treated as an ordinary character;
    <span class="Li">&quot;[-ab]&quot;</span>,
    <span class="Li">&quot;[ab-]&quot;</span> and
    <span class="Li">&quot;[a\-b]&quot;</span> are all equivalent.</p>
<p class="Pp">The special character <span class="Li">'^'</span> in the first
    position of a character class denotes a <i>negated character class</i>,
    which matches any character but those in the brackets. Both
    <span class="Li">&quot;[...]&quot;</span> and
    <span class="Li">&quot;[^...]&quot;</span> must match a character, or the
    match fails. Then</p>
<p class="Pp"></p>
<pre>    /[^a]at/;  # doesn't match 'aat' or 'at', but matches
               # all other 'bat', 'cat, '0at', '%at', etc.
    /[^0-9]/;  # matches a non-numeric character
    /[a^]at/;  # matches 'aat' or '^at'; here '^' is ordinary
</pre>
<p class="Pp">Now, even <span class="Li">&quot;[0-9]&quot;</span> can be a
    bother to write multiple times, so in the interest of saving keystrokes and
    making regexps more readable, Perl has several abbreviations for common
    character classes, as shown below. Since the introduction of Unicode, unless
    the <span class="Li">&quot;/a&quot;</span> modifier is in effect, these
    character classes match more than just a few characters in the ASCII
  range.</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;\d&quot;</span> matches a digit, not just
      <span class="Li">&quot;[0-9]&quot;</span> but also digits from non-roman
      scripts</li>
  <li><span class="Li">&quot;\s&quot;</span> matches a whitespace character, the
      set <span class="Li">&quot;[\ \t\r\n\f]&quot;</span> and others</li>
  <li><span class="Li">&quot;\w&quot;</span> matches a word character
      (alphanumeric or <span class="Li">'_'</span>), not just
      <span class="Li">&quot;[0-9a-zA-Z_]&quot;</span> but also digits and
      characters from non-roman scripts</li>
  <li><span class="Li">&quot;\D&quot;</span> is a negated
      <span class="Li">&quot;\d&quot;</span>; it represents any other character
      than a digit, or <span class="Li">&quot;[^\d]&quot;</span></li>
  <li><span class="Li">&quot;\S&quot;</span> is a negated
      <span class="Li">&quot;\s&quot;</span>; it represents any non-whitespace
      character <span class="Li">&quot;[^\s]&quot;</span></li>
  <li><span class="Li">&quot;\W&quot;</span> is a negated
      <span class="Li">&quot;\w&quot;</span>; it represents any non-word
      character <span class="Li">&quot;[^\w]&quot;</span></li>
  <li>The period <span class="Li">'.'</span> matches any character but
      <span class="Li">&quot;\n&quot;</span> (unless the modifier
      <span class="Li">&quot;/s&quot;</span> is in effect, as explained
    below).</li>
  <li><span class="Li">&quot;\N&quot;</span>, like the period, matches any
      character but <span class="Li">&quot;\n&quot;</span>, but it does so
      regardless of whether the modifier <span class="Li">&quot;/s&quot;</span>
      is in effect.</li>
</ul>
<p class="Pp">The <span class="Li">&quot;/a&quot;</span> modifier, available
    starting in Perl 5.14, is used to restrict the matches of
    <span class="Li">&quot;\d&quot;</span>,
    <span class="Li">&quot;\s&quot;</span>, and
    <span class="Li">&quot;\w&quot;</span> to just those in the ASCII range. It
    is useful to keep your program from being needlessly exposed to full Unicode
    (and its accompanying security considerations) when all you want is to
    process English-like text. (The &quot;a&quot; may be doubled,
    <span class="Li">&quot;/aa&quot;</span>, to provide even more restrictions,
    preventing case-insensitive matching of ASCII with non-ASCII characters;
    otherwise a Unicode &quot;Kelvin Sign&quot; would caselessly match a
    &quot;k&quot; or &quot;K&quot;.)</p>
<p class="Pp">The <span class="Li">&quot;\d\s\w\D\S\W&quot;</span> abbreviations
    can be used both inside and outside of bracketed character classes. Here are
    some in use:</p>
<p class="Pp"></p>
<pre>    /\d\d:\d\d:\d\d/; # matches a hh:mm:ss time format
    /[\d\s]/;         # matches any digit or whitespace character
    /\w\W\w/;         # matches a word char, followed by a
                      # non-word char, followed by a word char
    /..rt/;           # matches any two chars, followed by 'rt'
    /end\./;          # matches 'end.'
    /end[.]/;         # same thing, matches 'end.'
</pre>
<p class="Pp">Because a period is a metacharacter, it needs to be escaped to
    match as an ordinary period. Because, for example,
    <span class="Li">&quot;\d&quot;</span> and
    <span class="Li">&quot;\w&quot;</span> are sets of characters, it is
    incorrect to think of <span class="Li">&quot;[^\d\w]&quot;</span> as
    <span class="Li">&quot;[\D\W]&quot;</span>; in fact
    <span class="Li">&quot;[^\d\w]&quot;</span> is the same as
    <span class="Li">&quot;[^\w]&quot;</span>, which is the same as
    <span class="Li">&quot;[\W]&quot;</span>. Think DeMorgan's laws.</p>
<p class="Pp">In actuality, the period and
    <span class="Li">&quot;\d\s\w\D\S\W&quot;</span> abbreviations are
    themselves types of character classes, so the ones surrounded by brackets
    are just one type of character class. When we need to make a distinction, we
    refer to them as &quot;bracketed character classes.&quot;</p>
<p class="Pp">An anchor useful in basic regexps is the <i>word anchor</i>
    <span class="Li">&quot;\b&quot;</span>. This matches a boundary between a
    word character and a non-word character
    <span class="Li">&quot;\w\W&quot;</span> or
    <span class="Li">&quot;\W\w&quot;</span>:</p>
<p class="Pp"></p>
<pre>    $x = &quot;Housecat catenates house and cat&quot;;
    $x =~ /cat/;    # matches cat in 'housecat'
    $x =~ /\bcat/;  # matches cat in 'catenates'
    $x =~ /cat\b/;  # matches cat in 'housecat'
    $x =~ /\bcat\b/;  # matches 'cat' at end of string
</pre>
<p class="Pp">Note in the last example, the end of the string is considered a
    word boundary.</p>
<p class="Pp">For natural language processing (so that, for example, apostrophes
    are included in words), use instead
    <span class="Li">&quot;\b{wb}&quot;</span></p>
<p class="Pp"></p>
<pre>    &quot;don't&quot; =~ / .+? \b{wb} /x;  # matches the whole string
</pre>
<p class="Pp">You might wonder why <span class="Li">'.'</span> matches
    everything but <span class="Li">&quot;\n&quot;</span> - why not every
    character? The reason is that often one is matching against lines and would
    like to ignore the newline characters. For instance, while the string
    <span class="Li">&quot;\n&quot;</span> represents one line, we would like to
    think of it as empty. Then</p>
<p class="Pp"></p>
<pre>    &quot;&quot;   =~ /^$/;    # matches
    &quot;\n&quot; =~ /^$/;    # matches, $ anchors before &quot;\n&quot;
    &quot;&quot;   =~ /./;      # doesn't match; it needs a char
    &quot;&quot;   =~ /^.$/;    # doesn't match; it needs a char
    &quot;\n&quot; =~ /^.$/;    # doesn't match; it needs a char other than &quot;\n&quot;
    &quot;a&quot;  =~ /^.$/;    # matches
    &quot;a\n&quot;  =~ /^.$/;  # matches, $ anchors before &quot;\n&quot;
</pre>
<p class="Pp">This behavior is convenient, because we usually want to ignore
    newlines when we count and match characters in a line. Sometimes, however,
    we want to keep track of newlines. We might even want
    <span class="Li">'^'</span> and <span class="Li">'$'</span> to anchor at the
    beginning and end of lines within the string, rather than just the beginning
    and end of the string. Perl allows us to choose between ignoring and paying
    attention to newlines by using the <span class="Li">&quot;/s&quot;</span>
    and <span class="Li">&quot;/m&quot;</span> modifiers.
    <span class="Li">&quot;/s&quot;</span> and
    <span class="Li">&quot;/m&quot;</span> stand for single line and multi-line
    and they determine whether a string is to be treated as one continuous
    string, or as a set of lines. The two modifiers affect two aspects of how
    the regexp is interpreted: 1) how the <span class="Li">'.'</span> character
    class is defined, and 2) where the anchors <span class="Li">'^'</span> and
    <span class="Li">'$'</span> are able to match. Here are the four possible
    combinations:</p>
<ul class="Bl-bullet">
  <li>no modifiers: Default behavior. <span class="Li">'.'</span> matches any
      character except <span class="Li">&quot;\n&quot;</span>.
      <span class="Li">'^'</span> matches only at the beginning of the string
      and <span class="Li">'$'</span> matches only at the end or before a
      newline at the end.</li>
  <li>s modifier (<span class="Li">&quot;/s&quot;</span>): Treat string as a
      single long line. <span class="Li">'.'</span> matches any character, even
      <span class="Li">&quot;\n&quot;</span>. <span class="Li">'^'</span>
      matches only at the beginning of the string and
      <span class="Li">'$'</span> matches only at the end or before a newline at
      the end.</li>
  <li>m modifier (<span class="Li">&quot;/m&quot;</span>): Treat string as a set
      of multiple lines. <span class="Li">'.'</span> matches any character
      except <span class="Li">&quot;\n&quot;</span>. <span class="Li">'^'</span>
      and <span class="Li">'$'</span> are able to match at the start or end of
      <i>any</i> line within the string.</li>
  <li>both s and m modifiers (<span class="Li">&quot;/sm&quot;</span>): Treat
      string as a single long line, but detect multiple lines.
      <span class="Li">'.'</span> matches any character, even
      <span class="Li">&quot;\n&quot;</span>. <span class="Li">'^'</span> and
      <span class="Li">'$'</span>, however, are able to match at the start or
      end of <i>any</i> line within the string.</li>
</ul>
<p class="Pp">Here are examples of <span class="Li">&quot;/s&quot;</span> and
    <span class="Li">&quot;/m&quot;</span> in action:</p>
<p class="Pp"></p>
<pre>    $x = &quot;There once was a girl\nWho programmed in Perl\n&quot;;
    $x =~ /^Who/;   # doesn't match, &quot;Who&quot; not at start of string
    $x =~ /^Who/s;  # doesn't match, &quot;Who&quot; not at start of string
    $x =~ /^Who/m;  # matches, &quot;Who&quot; at start of second line
    $x =~ /^Who/sm; # matches, &quot;Who&quot; at start of second line
    $x =~ /girl.Who/;   # doesn't match, &quot;.&quot; doesn't match &quot;\n&quot;
    $x =~ /girl.Who/s;  # matches, &quot;.&quot; matches &quot;\n&quot;
    $x =~ /girl.Who/m;  # doesn't match, &quot;.&quot; doesn't match &quot;\n&quot;
    $x =~ /girl.Who/sm; # matches, &quot;.&quot; matches &quot;\n&quot;
</pre>
<p class="Pp">Most of the time, the default behavior is what is wanted, but
    <span class="Li">&quot;/s&quot;</span> and
    <span class="Li">&quot;/m&quot;</span> are occasionally very useful. If
    <span class="Li">&quot;/m&quot;</span> is being used, the start of the
    string can still be matched with <span class="Li">&quot;\A&quot;</span> and
    the end of the string can still be matched with the anchors
    <span class="Li">&quot;\Z&quot;</span> (matches both the end and the newline
    before, like <span class="Li">'$'</span>), and
    <span class="Li">&quot;\z&quot;</span> (matches only the end):</p>
<p class="Pp"></p>
<pre>    $x =~ /^Who/m;   # matches, &quot;Who&quot; at start of second line
    $x =~ /\AWho/m;  # doesn't match, &quot;Who&quot; is not at start of string
    $x =~ /girl$/m;  # matches, &quot;girl&quot; at end of first line
    $x =~ /girl\Z/m; # doesn't match, &quot;girl&quot; is not at end of string
    $x =~ /Perl\Z/m; # matches, &quot;Perl&quot; is at newline before end
    $x =~ /Perl\z/m; # doesn't match, &quot;Perl&quot; is not at end of string
</pre>
<p class="Pp">We now know how to create choices among classes of characters in a
    regexp. What about choices among words or character strings? Such choices
    are described in the next section.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Matching_this_or_that"><a class="permalink" href="#Matching_this_or_that">Matching
  this or that</a></h2>
<p class="Pp">Sometimes we would like our regexp to be able to match different
    possible words or character strings. This is accomplished by using the
    <i>alternation</i> metacharacter <span class="Li">'|'</span>. To match
    <span class="Li">&quot;dog&quot;</span> or
    <span class="Li">&quot;cat&quot;</span>, we form the regexp
    <span class="Li">&quot;dog|cat&quot;</span>. As before, Perl will try to
    match the regexp at the earliest possible point in the string. At each
    character position, Perl will first try to match the first alternative,
    <span class="Li">&quot;dog&quot;</span>. If
    <span class="Li">&quot;dog&quot;</span> doesn't match, Perl will then try
    the next alternative, <span class="Li">&quot;cat&quot;</span>. If
    <span class="Li">&quot;cat&quot;</span> doesn't match either, then the match
    fails and Perl moves to the next position in the string. Some examples:</p>
<p class="Pp"></p>
<pre>    &quot;cats and dogs&quot; =~ /cat|dog|bird/;  # matches &quot;cat&quot;
    &quot;cats and dogs&quot; =~ /dog|cat|bird/;  # matches &quot;cat&quot;
</pre>
<p class="Pp">Even though <span class="Li">&quot;dog&quot;</span> is the first
    alternative in the second regexp, <span class="Li">&quot;cat&quot;</span> is
    able to match earlier in the string.</p>
<p class="Pp"></p>
<pre>    &quot;cats&quot;          =~ /c|ca|cat|cats/; # matches &quot;c&quot;
    &quot;cats&quot;          =~ /cats|cat|ca|c/; # matches &quot;cats&quot;
</pre>
<p class="Pp">Here, all the alternatives match at the first string position, so
    the first alternative is the one that matches. If some of the alternatives
    are truncations of the others, put the longest ones first to give them a
    chance to match.</p>
<p class="Pp"></p>
<pre>    &quot;cab&quot; =~ /a|b|c/ # matches &quot;c&quot;
                     # /a|b|c/ == /[abc]/
</pre>
<p class="Pp">The last example points out that character classes are like
    alternations of characters. At a given character position, the first
    alternative that allows the regexp match to succeed will be the one that
    matches.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Grouping_things_and_hierarchical_matching"><a class="permalink" href="#Grouping_things_and_hierarchical_matching">Grouping
  things and hierarchical matching</a></h2>
<p class="Pp">Alternation allows a regexp to choose among alternatives, but by
    itself it is unsatisfying. The reason is that each alternative is a whole
    regexp, but sometime we want alternatives for just part of a regexp. For
    instance, suppose we want to search for housecats or housekeepers. The
    regexp <span class="Li">&quot;housecat|housekeeper&quot;</span> fits the
    bill, but is inefficient because we had to type
    <span class="Li">&quot;house&quot;</span> twice. It would be nice to have
    parts of the regexp be constant, like
    <span class="Li">&quot;house&quot;</span>, and some parts have alternatives,
    like <span class="Li">&quot;cat|keeper&quot;</span>.</p>
<p class="Pp">The <i>grouping</i> metacharacters
    <span class="Li">&quot;()&quot;</span> solve this problem. Grouping allows
    parts of a regexp to be treated as a single unit. Parts of a regexp are
    grouped by enclosing them in parentheses. Thus we could solve the
    <span class="Li">&quot;housecat|housekeeper&quot;</span> by forming the
    regexp as <span class="Li">&quot;house(cat|keeper)&quot;</span>. The regexp
    <span class="Li">&quot;house(cat|keeper)&quot;</span> means match
    <span class="Li">&quot;house&quot;</span> followed by either
    <span class="Li">&quot;cat&quot;</span> or
    <span class="Li">&quot;keeper&quot;</span>. Some more examples are</p>
<p class="Pp"></p>
<pre>    /(a|b)b/;    # matches 'ab' or 'bb'
    /(ac|b)b/;   # matches 'acb' or 'bb'
    /(^a|b)c/;   # matches 'ac' at start of string or 'bc' anywhere
    /(a|[bc])d/; # matches 'ad', 'bd', or 'cd'
    /house(cat|)/;  # matches either 'housecat' or 'house'
    /house(cat(s|)|)/;  # matches either 'housecats' or 'housecat' or
                        # 'house'.  Note groups can be nested.
    /(19|20|)\d\d/;  # match years 19xx, 20xx, or the Y2K problem, xx
    &quot;20&quot; =~ /(19|20|)\d\d/;  # matches the null alternative '()\d\d',
                             # because '20\d\d' can't match
</pre>
<p class="Pp">Alternations behave the same way in groups as out of them: at a
    given string position, the leftmost alternative that allows the regexp to
    match is taken. So in the last example at the first string position,
    <span class="Li">&quot;20&quot;</span> matches the second alternative, but
    there is nothing left over to match the next two digits
    <span class="Li">&quot;\d\d&quot;</span>. So Perl moves on to the next
    alternative, which is the null alternative and that works, since
    <span class="Li">&quot;20&quot;</span> is two digits.</p>
<p class="Pp">The process of trying one alternative, seeing if it matches, and
    moving on to the next alternative, while going back in the string from where
    the previous alternative was tried, if it doesn't, is called
    <i>backtracking</i>. The term &quot;backtracking&quot; comes from the idea
    that matching a regexp is like a walk in the woods. Successfully matching a
    regexp is like arriving at a destination. There are many possible
    trailheads, one for each string position, and each one is tried in order,
    left to right. From each trailhead there may be many paths, some of which
    get you there, and some which are dead ends. When you walk along a trail and
    hit a dead end, you have to backtrack along the trail to an earlier point to
    try another trail. If you hit your destination, you stop immediately and
    forget about trying all the other trails. You are persistent, and only if
    you have tried all the trails from all the trailheads and not arrived at
    your destination, do you declare failure. To be concrete, here is a
    step-by-step analysis of what Perl does when it tries to match the
  regexp</p>
<p class="Pp"></p>
<pre>    &quot;abcde&quot; =~ /(abd|abc)(df|d|de)/;
</pre>
<dl class="Bl-tag">
  <dt>0. Start with the first letter in the string 'a'.</dt>
  <dd>&#x00A0;</dd>
  <dt>1. Try the first alternative in the first group 'abd'.</dt>
  <dd>&#x00A0;</dd>
  <dt>2. Match 'a' followed by 'b'. So far so good.</dt>
  <dd>&#x00A0;</dd>
  <dt>3. 'd' in the regexp doesn't match 'c' in the string - a dead end. So
    backtrack two characters and pick the second alternative in the first group
    'abc'.</dt>
  <dd>&#x00A0;</dd>
  <dt>4. Match 'a' followed by 'b' followed by 'c'. We are on a roll and have
    satisfied the first group. Set $1 to 'abc'.</dt>
  <dd>&#x00A0;</dd>
  <dt>5 Move on to the second group and pick the first alternative 'df'.</dt>
  <dd>&#x00A0;</dd>
  <dt>6 Match the 'd'.</dt>
  <dd>&#x00A0;</dd>
  <dt>7. 'f' in the regexp doesn't match 'e' in the string, so a dead end.
    Backtrack one character and pick the second alternative in the second group
    'd'.</dt>
  <dd>&#x00A0;</dd>
  <dt>8. 'd' matches. The second grouping is satisfied, so set $2 to 'd'.</dt>
  <dd>&#x00A0;</dd>
  <dt>9. We are at the end of the regexp, so we are done! We have matched 'abcd'
    out of the string &quot;abcde&quot;.</dt>
  <dd></dd>
</dl>
<p class="Pp">There are a couple of things to note about this analysis. First,
    the third alternative in the second group <span class="Li">'de'</span> also
    allows a match, but we stopped before we got to it - at a given character
    position, leftmost wins. Second, we were able to get a match at the first
    character position of the string <span class="Li">'a'</span>. If there were
    no matches at the first position, Perl would move to the second character
    position <span class="Li">'b'</span> and attempt the match all over again.
    Only when all possible paths at all possible character positions have been
    exhausted does Perl give up and declare
    <span class="Li">&quot;$string&#x00A0;=~&#x00A0;/(abd|abc)(df|d|de)/;&quot;</span>
    to be false.</p>
<p class="Pp">Even with all this work, regexp matching happens remarkably fast.
    To speed things up, Perl compiles the regexp into a compact sequence of
    opcodes that can often fit inside a processor cache. When the code is
    executed, these opcodes can then run at full throttle and search very
    quickly.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Extracting_matches"><a class="permalink" href="#Extracting_matches">Extracting
  matches</a></h2>
<p class="Pp">The grouping metacharacters <span class="Li">&quot;()&quot;</span>
    also serve another completely different function: they allow the extraction
    of the parts of a string that matched. This is very useful to find out what
    matched and for text processing in general. For each grouping, the part that
    matched inside goes into the special variables <span class="Li">$1</span>,
    <span class="Li">$2</span>, <i>etc</i>. They can be used just as ordinary
    variables:</p>
<p class="Pp"></p>
<pre>    # extract hours, minutes, seconds
    if ($time =~ /(\d\d):(\d\d):(\d\d)/) {    # match hh:mm:ss format
        $hours = $1;
        $minutes = $2;
        $seconds = $3;
    }
</pre>
<p class="Pp">Now, we know that in scalar context,
    <span class="Li">&quot;$time&#x00A0;=~&#x00A0;/(\d\d):(\d\d):(\d\d)/&quot;</span>
    returns a true or false value. In list context, however, it returns the list
    of matched values <span class="Li">&quot;($1,$2,$3)&quot;</span>. So we
    could write the code more compactly as</p>
<p class="Pp"></p>
<pre>    # extract hours, minutes, seconds
    ($hours, $minutes, $second) = ($time =~ /(\d\d):(\d\d):(\d\d)/);
</pre>
<p class="Pp">If the groupings in a regexp are nested,
    <span class="Li">$1</span> gets the group with the leftmost opening
    parenthesis, <span class="Li">$2</span> the next opening parenthesis,
    <i>etc</i>. Here is a regexp with nested groups:</p>
<p class="Pp"></p>
<pre>    /(ab(cd|ef)((gi)|j))/;
     1  2      34
</pre>
<p class="Pp">If this regexp matches, <span class="Li">$1</span> contains a
    string starting with <span class="Li">'ab'</span>,
    <span class="Li">$2</span> is either set to <span class="Li">'cd'</span> or
    <span class="Li">'ef'</span>, <span class="Li">$3</span> equals either
    <span class="Li">'gi'</span> or <span class="Li">'j'</span>, and
    <span class="Li">$4</span> is either set to <span class="Li">'gi'</span>,
    just like <span class="Li">$3</span>, or it remains undefined.</p>
<p class="Pp">For convenience, Perl sets <span class="Li">$+</span> to the
    string held by the highest numbered <span class="Li">$1</span>,
    <span class="Li">$2</span>,... that got assigned (and, somewhat related,
    <span class="Li">$^N</span> to the value of the <span class="Li">$1</span>,
    <span class="Li">$2</span>,... most-recently assigned; <i>i.e.</i> the
    <span class="Li">$1</span>, <span class="Li">$2</span>,... associated with
    the rightmost closing parenthesis used in the match).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Backreferences"><a class="permalink" href="#Backreferences">Backreferences</a></h2>
<p class="Pp">Closely associated with the matching variables
    <span class="Li">$1</span>, <span class="Li">$2</span>, ... are the
    <i>backreferences</i> <span class="Li">&quot;\g1&quot;</span>,
    <span class="Li">&quot;\g2&quot;</span>,... Backreferences are simply
    matching variables that can be used <i>inside</i> a regexp. This is a really
    nice feature; what matches later in a regexp is made to depend on what
    matched earlier in the regexp. Suppose we wanted to look for doubled words
    in a text, like &quot;the the&quot;. The following regexp finds all 3-letter
    doubles with a space in between:</p>
<p class="Pp"></p>
<pre>    /\b(\w\w\w)\s\g1\b/;
</pre>
<p class="Pp">The grouping assigns a value to
    <span class="Li">&quot;\g1&quot;</span>, so that the same 3-letter sequence
    is used for both parts.</p>
<p class="Pp">A similar task is to find words consisting of two identical
  parts:</p>
<p class="Pp"></p>
<pre>    % simple_grep '^(\w\w\w\w|\w\w\w|\w\w|\w)\g1$' /usr/dict/words
    beriberi
    booboo
    coco
    mama
    murmur
    papa
</pre>
<p class="Pp">The regexp has a single grouping which considers 4-letter
    combinations, then 3-letter combinations, <i>etc</i>., and uses
    <span class="Li">&quot;\g1&quot;</span> to look for a repeat. Although
    <span class="Li">$1</span> and <span class="Li">&quot;\g1&quot;</span>
    represent the same thing, care should be taken to use matched variables
    <span class="Li">$1</span>, <span class="Li">$2</span>,... only
    <i>outside</i> a regexp and backreferences
    <span class="Li">&quot;\g1&quot;</span>,
    <span class="Li">&quot;\g2&quot;</span>,... only <i>inside</i> a regexp; not
    doing so may lead to surprising and unsatisfactory results.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Relative_backreferences"><a class="permalink" href="#Relative_backreferences">Relative
  backreferences</a></h2>
<p class="Pp">Counting the opening parentheses to get the correct number for a
    backreference is error-prone as soon as there is more than one capturing
    group. A more convenient technique became available with Perl 5.10: relative
    backreferences. To refer to the immediately preceding capture group one now
    may write <span class="Li">&quot;\g{-1}&quot;</span>, the next but last is
    available via <span class="Li">&quot;\g{-2}&quot;</span>, and so on.</p>
<p class="Pp">Another good reason in addition to readability and maintainability
    for using relative backreferences is illustrated by the following example,
    where a simple pattern for matching peculiar strings is used:</p>
<p class="Pp"></p>
<pre>    $a99a = '([a-z])(\d)\g2\g1';   # matches a11a, g22g, x33x, etc.
</pre>
<p class="Pp">Now that we have this pattern stored as a handy string, we might
    feel tempted to use it as a part of some other pattern:</p>
<p class="Pp"></p>
<pre>    $line = &quot;code=e99e&quot;;
    if ($line =~ /^(\w+)=$a99a$/){   # unexpected behavior!
        print &quot;$1 is valid\n&quot;;
    } else {
        print &quot;bad line: '$line'\n&quot;;
    }
</pre>
<p class="Pp">But this doesn't match, at least not the way one might expect.
    Only after inserting the interpolated <span class="Li">$a99a</span> and
    looking at the resulting full text of the regexp is it obvious that the
    backreferences have backfired. The subexpression
    <span class="Li">&quot;(\w+)&quot;</span> has snatched number 1 and demoted
    the groups in <span class="Li">$a99a</span> by one rank. This can be avoided
    by using relative backreferences:</p>
<p class="Pp"></p>
<pre>    $a99a = '([a-z])(\d)\g{-1}\g{-2}';  # safe for being interpolated
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Named_backreferences"><a class="permalink" href="#Named_backreferences">Named
  backreferences</a></h2>
<p class="Pp">Perl 5.10 also introduced named capture groups and named
    backreferences. To attach a name to a capturing group, you write either
    <span class="Li">&quot;(?&lt;name&gt;...)&quot;</span> or
    <span class="Li">&quot;(?'name'...)&quot;</span>. The backreference may then
    be written as <span class="Li">&quot;\g{name}&quot;</span>. It is
    permissible to attach the same name to more than one group, but then only
    the leftmost one of the eponymous set can be referenced. Outside of the
    pattern a named capture group is accessible through the
    <span class="Li">&quot;%+&quot;</span> hash.</p>
<p class="Pp">Assuming that we have to match calendar dates which may be given
    in one of the three formats yyyy-mm-dd, mm/dd/yyyy or dd.mm.yyyy, we can
    write three suitable patterns where we use <span class="Li">'d'</span>,
    <span class="Li">'m'</span> and <span class="Li">'y'</span> respectively as
    the names of the groups capturing the pertaining components of a date. The
    matching operation combines the three patterns as alternatives:</p>
<p class="Pp"></p>
<pre>    $fmt1 = '(?&lt;y&gt;\d\d\d\d)-(?&lt;m&gt;\d\d)-(?&lt;d&gt;\d\d)';
    $fmt2 = '(?&lt;m&gt;\d\d)/(?&lt;d&gt;\d\d)/(?&lt;y&gt;\d\d\d\d)';
    $fmt3 = '(?&lt;d&gt;\d\d)\.(?&lt;m&gt;\d\d)\.(?&lt;y&gt;\d\d\d\d)';
    for my $d (qw(2006-10-21 15.01.2007 10/31/2005)) {
        if ( $d =~ m{$fmt1|$fmt2|$fmt3} ){
            print &quot;day=$+{d} month=$+{m} year=$+{y}\n&quot;;
        }
    }
</pre>
<p class="Pp">If any of the alternatives matches, the hash
    <span class="Li">&quot;%+&quot;</span> is bound to contain the three
    key-value pairs.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Alternative_capture_group_numbering"><a class="permalink" href="#Alternative_capture_group_numbering">Alternative
  capture group numbering</a></h2>
<p class="Pp">Yet another capturing group numbering technique (also as from Perl
    5.10) deals with the problem of referring to groups within a set of
    alternatives. Consider a pattern for matching a time of the day, civil or
    military style:</p>
<p class="Pp"></p>
<pre>    if ( $time =~ /(\d\d|\d):(\d\d)|(\d\d)(\d\d)/ ){
        # process hour and minute
    }
</pre>
<p class="Pp">Processing the results requires an additional if statement to
    determine whether <span class="Li">$1</span> and <span class="Li">$2</span>
    or <span class="Li">$3</span> and <span class="Li">$4</span> contain the
    goodies. It would be easier if we could use group numbers 1 and 2 in second
    alternative as well, and this is exactly what the parenthesized construct
    <span class="Li">&quot;(?|...)&quot;</span>, set around an alternative
    achieves. Here is an extended version of the previous pattern:</p>
<p class="Pp"></p>
<pre>  if($time =~ /(?|(\d\d|\d):(\d\d)|(\d\d)(\d\d))\s+([A-Z][A-Z][A-Z])/){
      print &quot;hour=$1 minute=$2 zone=$3\n&quot;;
  }
</pre>
<p class="Pp">Within the alternative numbering group, group numbers start at the
    same position for each alternative. After the group, numbering continues
    with one higher than the maximum reached across all the alternatives.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Position_information"><a class="permalink" href="#Position_information">Position
  information</a></h2>
<p class="Pp">In addition to what was matched, Perl also provides the positions
    of what was matched as contents of the
    <span class="Li">&quot;@-&quot;</span> and
    <span class="Li">&quot;@+&quot;</span> arrays.
    <span class="Li">&quot;$-[0]&quot;</span> is the position of the start of
    the entire match and <span class="Li">$+[0]</span> is the position of the
    end. Similarly, <span class="Li">&quot;$-[n]&quot;</span> is the position of
    the start of the <span class="Li">$n</span> match and
    <span class="Li">$+[n]</span> is the position of the end. If
    <span class="Li">$n</span> is undefined, so are
    <span class="Li">&quot;$-[n]&quot;</span> and <span class="Li">$+[n]</span>.
    Then this code</p>
<p class="Pp"></p>
<pre>    $x = &quot;Mmm...donut, thought Homer&quot;;
    $x =~ /^(Mmm|Yech)\.\.\.(donut|peas)/; # matches
    foreach $exp (1..$#-) {
        print &quot;Match $exp: '${$exp}' at position ($-[$exp],$+[$exp])\n&quot;;
    }
</pre>
<p class="Pp">prints</p>
<p class="Pp"></p>
<pre>    Match 1: 'Mmm' at position (0,3)
    Match 2: 'donut' at position (6,11)
</pre>
<p class="Pp">Even if there are no groupings in a regexp, it is still possible
    to find out what exactly matched in a string. If you use them, Perl will set
    <span class="Li">&quot;$`&quot;</span> to the part of the string before the
    match, will set <span class="Li">$&amp;</span> to the part of the string
    that matched, and will set <span class="Li">'$'</span> to the part of the
    string after the match. An example:</p>
<p class="Pp"></p>
<pre>    $x = &quot;the cat caught the mouse&quot;;
    $x =~ /cat/;  # $` = 'the ', $&amp; = 'cat', $' = ' caught the mouse'
    $x =~ /the/;  # $` = '', $&amp; = 'the', $' = ' cat caught the mouse'
</pre>
<p class="Pp">In the second match, <span class="Li">&quot;$`&quot;</span> equals
    <span class="Li">''</span> because the regexp matched at the first character
    position in the string and stopped; it never saw the second
  &quot;the&quot;.</p>
<p class="Pp">If your code is to run on Perl versions earlier than 5.20, it is
    worthwhile to note that using <span class="Li">&quot;$`&quot;</span> and
    <span class="Li">'$'</span> slows down regexp matching quite a bit, while
    <span class="Li">$&amp;</span> slows it down to a lesser extent, because if
    they are used in one regexp in a program, they are generated for <i>all</i>
    regexps in the program. So if raw performance is a goal of your application,
    they should be avoided. If you need to extract the corresponding substrings,
    use <span class="Li">&quot;@-&quot;</span> and
    <span class="Li">&quot;@+&quot;</span> instead:</p>
<p class="Pp"></p>
<pre>    $` is the same as substr( $x, 0, $-[0] )
    $&amp; is the same as substr( $x, $-[0], $+[0]-$-[0] )
    $' is the same as substr( $x, $+[0] )
</pre>
<p class="Pp">As of Perl 5.10, the
    <span class="Li">&quot;${^PREMATCH}&quot;</span>,
    <span class="Li">&quot;${^MATCH}&quot;</span> and
    <span class="Li">&quot;${^POSTMATCH}&quot;</span> variables may be used.
    These are only set if the <span class="Li">&quot;/p&quot;</span> modifier is
    present. Consequently they do not penalize the rest of the program. In Perl
    5.20, <span class="Li">&quot;${^PREMATCH}&quot;</span>,
    <span class="Li">&quot;${^MATCH}&quot;</span> and
    <span class="Li">&quot;${^POSTMATCH}&quot;</span> are available whether the
    <span class="Li">&quot;/p&quot;</span> has been used or not (the modifier is
    ignored), and <span class="Li">&quot;$`&quot;</span>,
    <span class="Li">'$'</span> and <span class="Li">$&amp;</span> do not cause
    any speed difference.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Non-capturing_groupings"><a class="permalink" href="#Non-capturing_groupings">Non-capturing
  groupings</a></h2>
<p class="Pp">A group that is required to bundle a set of alternatives may or
    may not be useful as a capturing group. If it isn't, it just creates a
    superfluous addition to the set of available capture group values, inside as
    well as outside the regexp. Non-capturing groupings, denoted by
    <span class="Li">&quot;(?:regexp)&quot;</span>, still allow the regexp to be
    treated as a single unit, but don't establish a capturing group at the same
    time. Both capturing and non-capturing groupings are allowed to co-exist in
    the same regexp. Because there is no extraction, non-capturing groupings are
    faster than capturing groupings. Non-capturing groupings are also handy for
    choosing exactly which parts of a regexp are to be extracted to matching
    variables:</p>
<p class="Pp"></p>
<pre>    # match a number, $1-$4 are set, but we only want $1
    /([+-]?\ *(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?)/;
    # match a number faster , only $1 is set
    /([+-]?\ *(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?)/;
    # match a number, get $1 = whole number, $2 = exponent
    /([+-]?\ *(?:\d+(?:\.\d*)?|\.\d+)(?:[eE]([+-]?\d+))?)/;
</pre>
<p class="Pp">Non-capturing groupings are also useful for removing nuisance
    elements gathered from a split operation where parentheses are required for
    some reason:</p>
<p class="Pp"></p>
<pre>    $x = '12aba34ba5';
    @num = split /(a|b)+/, $x;    # @num = ('12','a','34','a','5')
    @num = split /(?:a|b)+/, $x;  # @num = ('12','34','5')
</pre>
<p class="Pp">In Perl 5.22 and later, all groups within a regexp can be set to
    non-capturing by using the new <span class="Li">&quot;/n&quot;</span>
  flag:</p>
<p class="Pp"></p>
<pre>    &quot;hello&quot; =~ /(hi|hello)/n; # $1 is not set!
</pre>
<p class="Pp">See &quot;n&quot; in perlre for more information.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Matching_repetitions"><a class="permalink" href="#Matching_repetitions">Matching
  repetitions</a></h2>
<p class="Pp">The examples in the previous section display an annoying weakness.
    We were only matching 3-letter words, or chunks of words of 4 letters or
    less. We'd like to be able to match words or, more generally, strings of any
    length, without writing out tedious alternatives like
    <span class="Li">&quot;\w\w\w\w|\w\w\w|\w\w|\w&quot;</span>.</p>
<p class="Pp">This is exactly the problem the <i>quantifier</i> metacharacters
    <span class="Li">'?'</span>, <span class="Li">'*'</span>,
    <span class="Li">'+'</span>, and <span class="Li">&quot;{}&quot;</span> were
    created for. They allow us to delimit the number of repeats for a portion of
    a regexp we consider to be a match. Quantifiers are put immediately after
    the character, character class, or grouping that we want to specify. They
    have the following meanings:</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;a?&quot;</span> means: match
      <span class="Li">'a'</span> 1 or 0 times</li>
  <li><span class="Li">&quot;a*&quot;</span> means: match
      <span class="Li">'a'</span> 0 or more times, <i>i.e.</i>, any number of
      times</li>
  <li><span class="Li">&quot;a+&quot;</span> means: match
      <span class="Li">'a'</span> 1 or more times, <i>i.e.</i>, at least
    once</li>
  <li><span class="Li">&quot;a{n,m}&quot;</span> means: match at least
      <span class="Li">&quot;n&quot;</span> times, but not more than
      <span class="Li">&quot;m&quot;</span> times.</li>
  <li><span class="Li">&quot;a{n,}&quot;</span> means: match at least
      <span class="Li">&quot;n&quot;</span> or more times</li>
  <li><span class="Li">&quot;a{n}&quot;</span> means: match exactly
      <span class="Li">&quot;n&quot;</span> times</li>
</ul>
<p class="Pp">Here are some examples:</p>
<p class="Pp"></p>
<pre>    /[a-z]+\s+\d*/;  # match a lowercase word, at least one space, and
                     # any number of digits
    /(\w+)\s+\g1/;    # match doubled words of arbitrary length
    /y(es)?/i;       # matches 'y', 'Y', or a case-insensitive 'yes'
    $year =~ /^\d{2,4}$/;  # make sure year is at least 2 but not more
                           # than 4 digits
    $year =~ /^\d{4}$|^\d{2}$/; # better match; throw out 3-digit dates
    $year =~ /^\d{2}(\d{2})?$/; # same thing written differently.
                                # However, this captures the last two
                                # digits in $1 and the other does not.
    % simple_grep '^(\w+)\g1$' /usr/dict/words   # isn't this easier?
    beriberi
    booboo
    coco
    mama
    murmur
    papa
</pre>
<p class="Pp">For all of these quantifiers, Perl will try to match as much of
    the string as possible, while still allowing the regexp to succeed. Thus
    with <span class="Li">&quot;/a?.../&quot;</span>, Perl will first try to
    match the regexp with the <span class="Li">'a'</span> present; if that
    fails, Perl will try to match the regexp without the
    <span class="Li">'a'</span> present. For the quantifier
    <span class="Li">'*'</span>, we get the following:</p>
<p class="Pp"></p>
<pre>    $x = &quot;the cat in the hat&quot;;
    $x =~ /^(.*)(cat)(.*)$/; # matches,
                             # $1 = 'the '
                             # $2 = 'cat'
                             # $3 = ' in the hat'
</pre>
<p class="Pp">Which is what we might expect, the match finds the only
    <span class="Li">&quot;cat&quot;</span> in the string and locks onto it.
    Consider, however, this regexp:</p>
<p class="Pp"></p>
<pre>    $x =~ /^(.*)(at)(.*)$/; # matches,
                            # $1 = 'the cat in the h'
                            # $2 = 'at'
                            # $3 = ''   (0 characters match)
</pre>
<p class="Pp">One might initially guess that Perl would find the
    <span class="Li">&quot;at&quot;</span> in
    <span class="Li">&quot;cat&quot;</span> and stop there, but that wouldn't
    give the longest possible string to the first quantifier
    <span class="Li">&quot;.*&quot;</span>. Instead, the first quantifier
    <span class="Li">&quot;.*&quot;</span> grabs as much of the string as
    possible while still having the regexp match. In this example, that means
    having the <span class="Li">&quot;at&quot;</span> sequence with the final
    <span class="Li">&quot;at&quot;</span> in the string. The other important
    principle illustrated here is that, when there are two or more elements in a
    regexp, the <i>leftmost</i> quantifier, if there is one, gets to grab as
    much of the string as possible, leaving the rest of the regexp to fight over
    scraps. Thus in our example, the first quantifier
    <span class="Li">&quot;.*&quot;</span> grabs most of the string, while the
    second quantifier <span class="Li">&quot;.*&quot;</span> gets the empty
    string. Quantifiers that grab as much of the string as possible are called
    <i>maximal match</i> or <i>greedy</i> quantifiers.</p>
<p class="Pp">When a regexp can match a string in several different ways, we can
    use the principles above to predict which way the regexp will match:</p>
<ul class="Bl-bullet">
  <li>Principle 0: Taken as a whole, any regexp will be matched at the earliest
      possible position in the string.</li>
  <li>Principle 1: In an alternation
      <span class="Li">&quot;a|b|c...&quot;</span>, the leftmost alternative
      that allows a match for the whole regexp will be the one used.</li>
  <li>Principle 2: The maximal matching quantifiers <span class="Li">'?'</span>,
      <span class="Li">'*'</span>, <span class="Li">'+'</span> and
      <span class="Li">&quot;{n,m}&quot;</span> will in general match as much of
      the string as possible while still allowing the whole regexp to
    match.</li>
  <li>Principle 3: If there are two or more elements in a regexp, the leftmost
      greedy quantifier, if any, will match as much of the string as possible
      while still allowing the whole regexp to match. The next leftmost greedy
      quantifier, if any, will try to match as much of the string remaining
      available to it as possible, while still allowing the whole regexp to
      match. And so on, until all the regexp elements are satisfied.</li>
</ul>
<p class="Pp">As we have seen above, Principle 0 overrides the others. The
    regexp will be matched as early as possible, with the other principles
    determining how the regexp matches at that earliest character position.</p>
<p class="Pp">Here is an example of these principles in action:</p>
<p class="Pp"></p>
<pre>    $x = &quot;The programming republic of Perl&quot;;
    $x =~ /^(.+)(e|r)(.*)$/;  # matches,
                              # $1 = 'The programming republic of Pe'
                              # $2 = 'r'
                              # $3 = 'l'
</pre>
<p class="Pp">This regexp matches at the earliest string position,
    <span class="Li">'T'</span>. One might think that
    <span class="Li">'e'</span>, being leftmost in the alternation, would be
    matched, but <span class="Li">'r'</span> produces the longest string in the
    first quantifier.</p>
<p class="Pp"></p>
<pre>    $x =~ /(m{1,2})(.*)$/;  # matches,
                            # $1 = 'mm'
                            # $2 = 'ing republic of Perl'
</pre>
<p class="Pp">Here, The earliest possible match is at the first
    <span class="Li">'m'</span> in
    <span class="Li">&quot;programming&quot;</span>.
    <span class="Li">&quot;m{1,2}&quot;</span> is the first quantifier, so it
    gets to match a maximal <span class="Li">&quot;mm&quot;</span>.</p>
<p class="Pp"></p>
<pre>    $x =~ /.*(m{1,2})(.*)$/;  # matches,
                              # $1 = 'm'
                              # $2 = 'ing republic of Perl'
</pre>
<p class="Pp">Here, the regexp matches at the start of the string. The first
    quantifier <span class="Li">&quot;.*&quot;</span> grabs as much as possible,
    leaving just a single <span class="Li">'m'</span> for the second quantifier
    <span class="Li">&quot;m{1,2}&quot;</span>.</p>
<p class="Pp"></p>
<pre>    $x =~ /(.?)(m{1,2})(.*)$/;  # matches,
                                # $1 = 'a'
                                # $2 = 'mm'
                                # $3 = 'ing republic of Perl'
</pre>
<p class="Pp">Here, <span class="Li">&quot;.?&quot;</span> eats its maximal one
    character at the earliest possible position in the string,
    <span class="Li">'a'</span> in
    <span class="Li">&quot;programming&quot;</span>, leaving
    <span class="Li">&quot;m{1,2}&quot;</span> the opportunity to match both
    <span class="Li">'m'</span>'s. Finally,</p>
<p class="Pp"></p>
<pre>    &quot;aXXXb&quot; =~ /(X*)/; # matches with $1 = ''
</pre>
<p class="Pp">because it can match zero copies of <span class="Li">'X'</span> at
    the beginning of the string. If you definitely want to match at least one
    <span class="Li">'X'</span>, use <span class="Li">&quot;X+&quot;</span>, not
    <span class="Li">&quot;X*&quot;</span>.</p>
<p class="Pp">Sometimes greed is not good. At times, we would like quantifiers
    to match a <i>minimal</i> piece of string, rather than a maximal piece. For
    this purpose, Larry Wall created the <i>minimal match</i> or
    <i>non-greedy</i> quantifiers <span class="Li">&quot;??&quot;</span>,
    <span class="Li">&quot;*?&quot;</span>,
    <span class="Li">&quot;+?&quot;</span>, and
    <span class="Li">&quot;{}?&quot;</span>. These are the usual quantifiers
    with a <span class="Li">'?'</span> appended to them. They have the following
    meanings:</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;a??&quot;</span> means: match
      <span class="Li">'a'</span> 0 or 1 times. Try 0 first, then 1.</li>
  <li><span class="Li">&quot;a*?&quot;</span> means: match
      <span class="Li">'a'</span> 0 or more times, <i>i.e.</i>, any number of
      times, but as few times as possible</li>
  <li><span class="Li">&quot;a+?&quot;</span> means: match
      <span class="Li">'a'</span> 1 or more times, <i>i.e.</i>, at least once,
      but as few times as possible</li>
  <li><span class="Li">&quot;a{n,m}?&quot;</span> means: match at least
      <span class="Li">&quot;n&quot;</span> times, not more than
      <span class="Li">&quot;m&quot;</span> times, as few times as possible</li>
  <li><span class="Li">&quot;a{n,}?&quot;</span> means: match at least
      <span class="Li">&quot;n&quot;</span> times, but as few times as
    possible</li>
  <li><span class="Li">&quot;a{n}?&quot;</span> means: match exactly
      <span class="Li">&quot;n&quot;</span> times. Because we match exactly
      <span class="Li">&quot;n&quot;</span> times,
      <span class="Li">&quot;a{n}?&quot;</span> is equivalent to
      <span class="Li">&quot;a{n}&quot;</span> and is just there for notational
      consistency.</li>
</ul>
<p class="Pp">Let's look at the example above, but with minimal quantifiers:</p>
<p class="Pp"></p>
<pre>    $x = &quot;The programming republic of Perl&quot;;
    $x =~ /^(.+?)(e|r)(.*)$/; # matches,
                              # $1 = 'Th'
                              # $2 = 'e'
                              # $3 = ' programming republic of Perl'
</pre>
<p class="Pp">The minimal string that will allow both the start of the string
    <span class="Li">'^'</span> and the alternation to match is
    <span class="Li">&quot;Th&quot;</span>, with the alternation
    <span class="Li">&quot;e|r&quot;</span> matching
    <span class="Li">'e'</span>. The second quantifier
    <span class="Li">&quot;.*&quot;</span> is free to gobble up the rest of the
    string.</p>
<p class="Pp"></p>
<pre>    $x =~ /(m{1,2}?)(.*?)$/;  # matches,
                              # $1 = 'm'
                              # $2 = 'ming republic of Perl'
</pre>
<p class="Pp">The first string position that this regexp can match is at the
    first <span class="Li">'m'</span> in
    <span class="Li">&quot;programming&quot;</span>. At this position, the
    minimal <span class="Li">&quot;m{1,2}?&quot;</span> matches just one
    <span class="Li">'m'</span>. Although the second quantifier
    <span class="Li">&quot;.*?&quot;</span> would prefer to match no characters,
    it is constrained by the end-of-string anchor <span class="Li">'$'</span> to
    match the rest of the string.</p>
<p class="Pp"></p>
<pre>    $x =~ /(.*?)(m{1,2}?)(.*)$/;  # matches,
                                  # $1 = 'The progra'
                                  # $2 = 'm'
                                  # $3 = 'ming republic of Perl'
</pre>
<p class="Pp">In this regexp, you might expect the first minimal quantifier
    <span class="Li">&quot;.*?&quot;</span> to match the empty string, because
    it is not constrained by a <span class="Li">'^'</span> anchor to match the
    beginning of the word. Principle 0 applies here, however. Because it is
    possible for the whole regexp to match at the start of the string, it
    <i>will</i> match at the start of the string. Thus the first quantifier has
    to match everything up to the first <span class="Li">'m'</span>. The second
    minimal quantifier matches just one <span class="Li">'m'</span> and the
    third quantifier matches the rest of the string.</p>
<p class="Pp"></p>
<pre>    $x =~ /(.??)(m{1,2})(.*)$/;  # matches,
                                 # $1 = 'a'
                                 # $2 = 'mm'
                                 # $3 = 'ing republic of Perl'
</pre>
<p class="Pp">Just as in the previous regexp, the first quantifier
    <span class="Li">&quot;.??&quot;</span> can match earliest at position
    <span class="Li">'a'</span>, so it does. The second quantifier is greedy, so
    it matches <span class="Li">&quot;mm&quot;</span>, and the third matches the
    rest of the string.</p>
<p class="Pp">We can modify principle 3 above to take into account non-greedy
    quantifiers:</p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>Principle 3: If there are two or more elements in a regexp, the leftmost
      greedy (non-greedy) quantifier, if any, will match as much (little) of the
      string as possible while still allowing the whole regexp to match. The
      next leftmost greedy (non-greedy) quantifier, if any, will try to match as
      much (little) of the string remaining available to it as possible, while
      still allowing the whole regexp to match. And so on, until all the regexp
      elements are satisfied.</dd>
</dl>
<p class="Pp">Just like alternation, quantifiers are also susceptible to
    backtracking. Here is a step-by-step analysis of the example</p>
<p class="Pp"></p>
<pre>    $x = &quot;the cat in the hat&quot;;
    $x =~ /^(.*)(at)(.*)$/; # matches,
                            # $1 = 'the cat in the h'
                            # $2 = 'at'
                            # $3 = ''   (0 matches)
</pre>
<dl class="Bl-tag">
  <dt>0. Start with the first letter in the string 't'.</dt>
  <dd>&#x00A0;</dd>
  <dt>1. The first quantifier '.*' starts out by matching the whole string
    &quot;&quot;the cat in the hat&quot;&quot;.</dt>
  <dd>&#x00A0;</dd>
  <dt>2. 'a' in the regexp element 'at' doesn't match the end of the string.
    Backtrack one character.</dt>
  <dd>&#x00A0;</dd>
  <dt>3. 'a' in the regexp element 'at' still doesn't match the last letter of
    the string 't', so backtrack one more character.</dt>
  <dd>&#x00A0;</dd>
  <dt>4. Now we can match the 'a' and the 't'.</dt>
  <dd>&#x00A0;</dd>
  <dt>5. Move on to the third element '.*'. Since we are at the end of the
    string and '.*' can match 0 times, assign it the empty string.</dt>
  <dd>&#x00A0;</dd>
  <dt>6. We are done!</dt>
  <dd></dd>
</dl>
<p class="Pp">Most of the time, all this moving forward and backtracking happens
    quickly and searching is fast. There are some pathological regexps, however,
    whose execution time exponentially grows with the size of the string. A
    typical structure that blows up in your face is of the form</p>
<p class="Pp"></p>
<pre>    /(a|b+)*/;
</pre>
<p class="Pp">The problem is the nested indeterminate quantifiers. There are
    many different ways of partitioning a string of length n between the
    <span class="Li">'+'</span> and <span class="Li">'*'</span>: one repetition
    with <span class="Li">&quot;b+&quot;</span> of length n, two repetitions
    with the first <span class="Li">&quot;b+&quot;</span> length k and the
    second with length n-k, m repetitions whose bits add up to length n,
    <i>etc</i>. In fact there are an exponential number of ways to partition a
    string as a function of its length. A regexp may get lucky and match early
    in the process, but if there is no match, Perl will try <i>every</i>
    possibility before giving up. So be careful with nested
    <span class="Li">'*'</span>'s, <span class="Li">&quot;{n,m}&quot;</span>'s,
    and <span class="Li">'+'</span>'s. The book <i>Mastering Regular
    Expressions</i> by Jeffrey Friedl gives a wonderful discussion of this and
    other efficiency issues.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Possessive_quantifiers"><a class="permalink" href="#Possessive_quantifiers">Possessive
  quantifiers</a></h2>
<p class="Pp">Backtracking during the relentless search for a match may be a
    waste of time, particularly when the match is bound to fail. Consider the
    simple pattern</p>
<p class="Pp"></p>
<pre>    /^\w+\s+\w+$/; # a word, spaces, a word
</pre>
<p class="Pp">Whenever this is applied to a string which doesn't quite meet the
    pattern's expectations such as
    <span class="Li">&quot;abc&#x00A0;&#x00A0;&quot;</span> or
    <span class="Li">&quot;abc&#x00A0;&#x00A0;def&#x00A0;&quot;</span>, the
    regexp engine will backtrack, approximately once for each character in the
    string. But we know that there is no way around taking <i>all</i> of the
    initial word characters to match the first repetition, that <i>all</i>
    spaces must be eaten by the middle part, and the same goes for the second
    word.</p>
<p class="Pp">With the introduction of the <i>possessive quantifiers</i> in Perl
    5.10, we have a way of instructing the regexp engine not to backtrack, with
    the usual quantifiers with a <span class="Li">'+'</span> appended to them.
    This makes them greedy as well as stingy; once they succeed they won't give
    anything back to permit another solution. They have the following
  meanings:</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;a{n,m}+&quot;</span> means: match at least
      <span class="Li">&quot;n&quot;</span> times, not more than
      <span class="Li">&quot;m&quot;</span> times, as many times as possible,
      and don't give anything up. <span class="Li">&quot;a?+&quot;</span> is
      short for <span class="Li">&quot;a{0,1}+&quot;</span></li>
  <li><span class="Li">&quot;a{n,}+&quot;</span> means: match at least
      <span class="Li">&quot;n&quot;</span> times, but as many times as
      possible, and don't give anything up.
      <span class="Li">&quot;a*+&quot;</span> is short for
      <span class="Li">&quot;a{0,}+&quot;</span> and
      <span class="Li">&quot;a++&quot;</span> is short for
      <span class="Li">&quot;a{1,}+&quot;</span>.</li>
  <li><span class="Li">&quot;a{n}+&quot;</span> means: match exactly
      <span class="Li">&quot;n&quot;</span> times. It is just there for
      notational consistency.</li>
</ul>
<p class="Pp">These possessive quantifiers represent a special case of a more
    general concept, the <i>independent subexpression</i>, see below.</p>
<p class="Pp">As an example where a possessive quantifier is suitable we
    consider matching a quoted string, as it appears in several programming
    languages. The backslash is used as an escape character that indicates that
    the next character is to be taken literally, as another character for the
    string. Therefore, after the opening quote, we expect a (possibly empty)
    sequence of alternatives: either some character except an unescaped quote or
    backslash or an escaped character.</p>
<p class="Pp"></p>
<pre>    /&quot;(?:[^&quot;\\]++|\\.)*+&quot;/;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Building_a_regexp"><a class="permalink" href="#Building_a_regexp">Building
  a regexp</a></h2>
<p class="Pp">At this point, we have all the basic regexp concepts covered, so
    let's give a more involved example of a regular expression. We will build a
    regexp that matches numbers.</p>
<p class="Pp">The first task in building a regexp is to decide what we want to
    match and what we want to exclude. In our case, we want to match both
    integers and floating point numbers and we want to reject any string that
    isn't a number.</p>
<p class="Pp">The next task is to break the problem down into smaller problems
    that are easily converted into a regexp.</p>
<p class="Pp">The simplest case is integers. These consist of a sequence of
    digits, with an optional sign in front. The digits we can represent with
    <span class="Li">&quot;\d+&quot;</span> and the sign can be matched with
    <span class="Li">&quot;[+-]&quot;</span>. Thus the integer regexp is</p>
<p class="Pp"></p>
<pre>    /[+-]?\d+/;  # matches integers
</pre>
<p class="Pp">A floating point number potentially has a sign, an integral part,
    a decimal point, a fractional part, and an exponent. One or more of these
    parts is optional, so we need to check out the different possibilities.
    Floating point numbers which are in proper form include 123., 0.345, .34,
    -1e6, and 25.4E-72. As with integers, the sign out front is completely
    optional and can be matched by <span class="Li">&quot;[+-]?&quot;</span>. We
    can see that if there is no exponent, floating point numbers must have a
    decimal point, otherwise they are integers. We might be tempted to model
    these with <span class="Li">&quot;\d*\.\d*&quot;</span>, but this would also
    match just a single decimal point, which is not a number. So the three cases
    of floating point number without exponent are</p>
<p class="Pp"></p>
<pre>   /[+-]?\d+\./;  # 1., 321., etc.
   /[+-]?\.\d+/;  # .1, .234, etc.
   /[+-]?\d+\.\d+/;  # 1.0, 30.56, etc.
</pre>
<p class="Pp">These can be combined into a single regexp with a three-way
    alternation:</p>
<p class="Pp"></p>
<pre>   /[+-]?(\d+\.\d+|\d+\.|\.\d+)/;  # floating point, no exponent
</pre>
<p class="Pp">In this alternation, it is important to put
    <span class="Li">'\d+\.\d+'</span> before <span class="Li">'\d+\.'</span>.
    If <span class="Li">'\d+\.'</span> were first, the regexp would happily
    match that and ignore the fractional part of the number.</p>
<p class="Pp">Now consider floating point numbers with exponents. The key
    observation here is that <i>both</i> integers and numbers with decimal
    points are allowed in front of an exponent. Then exponents, like the overall
    sign, are independent of whether we are matching numbers with or without
    decimal points, and can be &quot;decoupled&quot; from the mantissa. The
    overall form of the regexp now becomes clear:</p>
<p class="Pp"></p>
<pre>    /^(optional sign)(integer | f.p. mantissa)(optional exponent)$/;
</pre>
<p class="Pp">The exponent is an <span class="Li">'e'</span> or
    <span class="Li">'E'</span>, followed by an integer. So the exponent regexp
    is</p>
<p class="Pp"></p>
<pre>   /[eE][+-]?\d+/;  # exponent
</pre>
<p class="Pp">Putting all the parts together, we get a regexp that matches
    numbers:</p>
<p class="Pp"></p>
<pre>   /^[+-]?(\d+\.\d+|\d+\.|\.\d+|\d+)([eE][+-]?\d+)?$/;  # Ta da!
</pre>
<p class="Pp">Long regexps like this may impress your friends, but can be hard
    to decipher. In complex situations like this, the
    <span class="Li">&quot;/x&quot;</span> modifier for a match is invaluable.
    It allows one to put nearly arbitrary whitespace and comments into a regexp
    without affecting their meaning. Using it, we can rewrite our
    &quot;extended&quot; regexp in the more pleasing form</p>
<p class="Pp"></p>
<pre>   /^
      [+-]?         # first, match an optional sign
      (             # then match integers or f.p. mantissas:
          \d+\.\d+  # mantissa of the form a.b
         |\d+\.     # mantissa of the form a.
         |\.\d+     # mantissa of the form .b
         |\d+       # integer of the form a
      )
      ( [eE] [+-]? \d+ )?  # finally, optionally match an exponent
   $/x;
</pre>
<p class="Pp">If whitespace is mostly irrelevant, how does one include space
    characters in an extended regexp? The answer is to backslash it
    <span class="Li">'\&#x00A0;'</span> or put it in a character class
    <span class="Li">&quot;[&#x00A0;]&quot;</span>. The same thing goes for
    pound signs: use <span class="Li">&quot;\#&quot;</span> or
    <span class="Li">&quot;[#]&quot;</span>. For instance, Perl allows a space
    between the sign and the mantissa or integer, and we could add this to our
    regexp as follows:</p>
<p class="Pp"></p>
<pre>   /^
      [+-]?\ *      # first, match an optional sign *and space*
      (             # then match integers or f.p. mantissas:
          \d+\.\d+  # mantissa of the form a.b
         |\d+\.     # mantissa of the form a.
         |\.\d+     # mantissa of the form .b
         |\d+       # integer of the form a
      )
      ( [eE] [+-]? \d+ )?  # finally, optionally match an exponent
   $/x;
</pre>
<p class="Pp">In this form, it is easier to see a way to simplify the
    alternation. Alternatives 1, 2, and 4 all start with
    <span class="Li">&quot;\d+&quot;</span>, so it could be factored out:</p>
<p class="Pp"></p>
<pre>   /^
      [+-]?\ *      # first, match an optional sign
      (             # then match integers or f.p. mantissas:
          \d+       # start out with a ...
          (
              \.\d* # mantissa of the form a.b or a.
          )?        # ? takes care of integers of the form a
         |\.\d+     # mantissa of the form .b
      )
      ( [eE] [+-]? \d+ )?  # finally, optionally match an exponent
   $/x;
</pre>
<p class="Pp">Starting in Perl v5.26, specifying
    <span class="Li">&quot;/xx&quot;</span> changes the square-bracketed
    portions of a pattern to ignore tabs and space characters unless they are
    escaped by preceding them with a backslash. So, we could write</p>
<p class="Pp"></p>
<pre>   /^
      [ + - ]?\ *   # first, match an optional sign
      (             # then match integers or f.p. mantissas:
          \d+       # start out with a ...
          (
              \.\d* # mantissa of the form a.b or a.
          )?        # ? takes care of integers of the form a
         |\.\d+     # mantissa of the form .b
      )
      ( [ e E ] [ + - ]? \d+ )?  # finally, optionally match an exponent
   $/xx;
</pre>
<p class="Pp">This doesn't really improve the legibility of this example, but
    it's available in case you want it. Squashing the pattern down to the
    compact form, we have</p>
<p class="Pp"></p>
<pre>    /^[+-]?\ *(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?$/;
</pre>
<p class="Pp">This is our final regexp. To recap, we built a regexp by</p>
<ul class="Bl-bullet">
  <li>specifying the task in detail,</li>
  <li>breaking down the problem into smaller parts,</li>
  <li>translating the small parts into regexps,</li>
  <li>combining the regexps,</li>
  <li>and optimizing the final combined regexp.</li>
</ul>
<p class="Pp">These are also the typical steps involved in writing a computer
    program. This makes perfect sense, because regular expressions are
    essentially programs written in a little computer language that specifies
    patterns.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_regular_expressions_in_Perl"><a class="permalink" href="#Using_regular_expressions_in_Perl">Using
  regular expressions in Perl</a></h2>
<p class="Pp">The last topic of Part 1 briefly covers how regexps are used in
    Perl programs. Where do they fit into Perl syntax?</p>
<p class="Pp">We have already introduced the matching operator in its default
    <span class="Li">&quot;/regexp/&quot;</span> and arbitrary delimiter
    <span class="Li">&quot;m!regexp!&quot;</span> forms. We have used the
    binding operator <span class="Li">&quot;=~&quot;</span> and its negation
    <span class="Li">&quot;!~&quot;</span> to test for string matches.
    Associated with the matching operator, we have discussed the single line
    <span class="Li">&quot;/s&quot;</span>, multi-line
    <span class="Li">&quot;/m&quot;</span>, case-insensitive
    <span class="Li">&quot;/i&quot;</span> and extended
    <span class="Li">&quot;/x&quot;</span> modifiers. There are a few more
    things you might want to know about matching operators.</p>
<p class="Pp"><i>Prohibiting substitution</i></p>
<p class="Pp">If you change <span class="Li">$pattern</span> after the first
    substitution happens, Perl will ignore it. If you don't want any
    substitutions at all, use the special delimiter
    <span class="Li">&quot;m''&quot;</span>:</p>
<p class="Pp"></p>
<pre>    @pattern = ('Seuss');
    while (&lt;&gt;) {
        print if m'@pattern';  # matches literal '@pattern', not 'Seuss'
    }
</pre>
<p class="Pp">Similar to strings, <span class="Li">&quot;m''&quot;</span> acts
    like apostrophes on a regexp; all other <span class="Li">'m'</span>
    delimiters act like quotes. If the regexp evaluates to the empty string, the
    regexp in the <i>last successful match</i> is used instead. So we have</p>
<p class="Pp"></p>
<pre>    &quot;dog&quot; =~ /d/;  # 'd' matches
    &quot;dogbert =~ //;  # this matches the 'd' regexp used before
</pre>
<p class="Pp"><i>Global matching</i></p>
<p class="Pp">The final two modifiers we will discuss here,
    <span class="Li">&quot;/g&quot;</span> and
    <span class="Li">&quot;/c&quot;</span>, concern multiple matches. The
    modifier <span class="Li">&quot;/g&quot;</span> stands for global matching
    and allows the matching operator to match within a string as many times as
    possible. In scalar context, successive invocations against a string will
    have <span class="Li">&quot;/g&quot;</span> jump from match to match,
    keeping track of position in the string as it goes along. You can get or set
    the position with the <span class="Li">&quot;pos()&quot;</span>
  function.</p>
<p class="Pp">The use of <span class="Li">&quot;/g&quot;</span> is shown in the
    following example. Suppose we have a string that consists of words separated
    by spaces. If we know how many words there are in advance, we could extract
    the words using groupings:</p>
<p class="Pp"></p>
<pre>    $x = &quot;cat dog house&quot;; # 3 words
    $x =~ /^\s*(\w+)\s+(\w+)\s+(\w+)\s*$/; # matches,
                                           # $1 = 'cat'
                                           # $2 = 'dog'
                                           # $3 = 'house'
</pre>
<p class="Pp">But what if we had an indeterminate number of words? This is the
    sort of task <span class="Li">&quot;/g&quot;</span> was made for. To extract
    all words, form the simple regexp <span class="Li">&quot;(\w+)&quot;</span>
    and loop over all matches with
  <span class="Li">&quot;/(\w+)/g&quot;</span>:</p>
<p class="Pp"></p>
<pre>    while ($x =~ /(\w+)/g) {
        print &quot;Word is $1, ends at position &quot;, pos $x, &quot;\n&quot;;
    }
</pre>
<p class="Pp">prints</p>
<p class="Pp"></p>
<pre>    Word is cat, ends at position 3
    Word is dog, ends at position 7
    Word is house, ends at position 13
</pre>
<p class="Pp">A failed match or changing the target string resets the position.
    If you don't want the position reset after failure to match, add the
    <span class="Li">&quot;/c&quot;</span>, as in
    <span class="Li">&quot;/regexp/gc&quot;</span>. The current position in the
    string is associated with the string, not the regexp. This means that
    different strings have different positions and their respective positions
    can be set or read independently.</p>
<p class="Pp">In list context, <span class="Li">&quot;/g&quot;</span> returns a
    list of matched groupings, or if there are no groupings, a list of matches
    to the whole regexp. So if we wanted just the words, we could use</p>
<p class="Pp"></p>
<pre>    @words = ($x =~ /(\w+)/g);  # matches,
                                # $words[0] = 'cat'
                                # $words[1] = 'dog'
                                # $words[2] = 'house'
</pre>
<p class="Pp">Closely associated with the <span class="Li">&quot;/g&quot;</span>
    modifier is the <span class="Li">&quot;\G&quot;</span> anchor. The
    <span class="Li">&quot;\G&quot;</span> anchor matches at the point where the
    previous <span class="Li">&quot;/g&quot;</span> match left off.
    <span class="Li">&quot;\G&quot;</span> allows us to easily do
    context-sensitive matching:</p>
<p class="Pp"></p>
<pre>    $metric = 1;  # use metric units
    ...
    $x = &lt;FILE&gt;;  # read in measurement
    $x =~ /^([+-]?\d+)\s*/g;  # get magnitude
    $weight = $1;
    if ($metric) { # error checking
        print &quot;Units error!&quot; unless $x =~ /\Gkg\./g;
    }
    else {
        print &quot;Units error!&quot; unless $x =~ /\Glbs\./g;
    }
    $x =~ /\G\s+(widget|sprocket)/g;  # continue processing
</pre>
<p class="Pp">The combination of <span class="Li">&quot;/g&quot;</span> and
    <span class="Li">&quot;\G&quot;</span> allows us to process the string a bit
    at a time and use arbitrary Perl logic to decide what to do next. Currently,
    the <span class="Li">&quot;\G&quot;</span> anchor is only fully supported
    when used to anchor to the start of the pattern.</p>
<p class="Pp"><span class="Li">&quot;\G&quot;</span> is also invaluable in
    processing fixed-length records with regexps. Suppose we have a snippet of
    coding region DNA, encoded as base pair letters
    <span class="Li">&quot;ATCGTTGAAT...&quot;</span> and we want to find all
    the stop codons <span class="Li">&quot;TGA&quot;</span>. In a coding region,
    codons are 3-letter sequences, so we can think of the DNA snippet as a
    sequence of 3-letter records. The naive regexp</p>
<p class="Pp"></p>
<pre>    # expanded, this is &quot;ATC GTT GAA TGC AAA TGA CAT GAC&quot;
    $dna = &quot;ATCGTTGAATGCAAATGACATGAC&quot;;
    $dna =~ /TGA/;
</pre>
<p class="Pp">doesn't work; it may match a
    <span class="Li">&quot;TGA&quot;</span>, but there is no guarantee that the
    match is aligned with codon boundaries, <i>e.g.</i>, the substring
    <span class="Li">&quot;GTT&#x00A0;GAA&quot;</span> gives a match. A better
    solution is</p>
<p class="Pp"></p>
<pre>    while ($dna =~ /(\w\w\w)*?TGA/g) {  # note the minimal *?
        print &quot;Got a TGA stop codon at position &quot;, pos $dna, &quot;\n&quot;;
    }
</pre>
<p class="Pp">which prints</p>
<p class="Pp"></p>
<pre>    Got a TGA stop codon at position 18
    Got a TGA stop codon at position 23
</pre>
<p class="Pp">Position 18 is good, but position 23 is bogus. What happened?</p>
<p class="Pp">The answer is that our regexp works well until we get past the
    last real match. Then the regexp will fail to match a synchronized
    <span class="Li">&quot;TGA&quot;</span> and start stepping ahead one
    character position at a time, not what we want. The solution is to use
    <span class="Li">&quot;\G&quot;</span> to anchor the match to the codon
    alignment:</p>
<p class="Pp"></p>
<pre>    while ($dna =~ /\G(\w\w\w)*?TGA/g) {
        print &quot;Got a TGA stop codon at position &quot;, pos $dna, &quot;\n&quot;;
    }
</pre>
<p class="Pp">This prints</p>
<p class="Pp"></p>
<pre>    Got a TGA stop codon at position 18
</pre>
<p class="Pp">which is the correct answer. This example illustrates that it is
    important not only to match what is desired, but to reject what is not
    desired.</p>
<p class="Pp">(There are other regexp modifiers that are available, such as
    <span class="Li">&quot;/o&quot;</span>, but their specialized uses are
    beyond the scope of this introduction. )</p>
<p class="Pp"><i>Search and replace</i></p>
<p class="Pp">Regular expressions also play a big role in <i>search and
    replace</i> operations in Perl. Search and replace is accomplished with the
    <span class="Li">&quot;s///&quot;</span> operator. The general form is
    <span class="Li">&quot;s/regexp/replacement/modifiers&quot;</span>, with
    everything we know about regexps and modifiers applying in this case as
    well. The <i>replacement</i> is a Perl double-quoted string that replaces in
    the string whatever is matched with the
    <span class="Li">&quot;regexp&quot;</span>. The operator
    <span class="Li">&quot;=~&quot;</span> is also used here to associate a
    string with <span class="Li">&quot;s///&quot;</span>. If matching against
    <span class="Li">$_</span>, the
    <span class="Li">&quot;$_&#x00A0;=~&quot;</span> can be dropped. If there is
    a match, <span class="Li">&quot;s///&quot;</span> returns the number of
    substitutions made; otherwise it returns false. Here are a few examples:</p>
<p class="Pp"></p>
<pre>    $x = &quot;Time to feed the cat!&quot;;
    $x =~ s/cat/hacker/;   # $x contains &quot;Time to feed the hacker!&quot;
    if ($x =~ s/^(Time.*hacker)!$/$1 now!/) {
        $more_insistent = 1;
    }
    $y = &quot;'quoted words'&quot;;
    $y =~ s/^'(.*)'$/$1/;  # strip single quotes,
                           # $y contains &quot;quoted words&quot;
</pre>
<p class="Pp">In the last example, the whole string was matched, but only the
    part inside the single quotes was grouped. With the
    <span class="Li">&quot;s///&quot;</span> operator, the matched variables
    <span class="Li">$1</span>, <span class="Li">$2</span>, <i>etc</i>. are
    immediately available for use in the replacement expression, so we use
    <span class="Li">$1</span> to replace the quoted string with just what was
    quoted. With the global modifier, <span class="Li">&quot;s///g&quot;</span>
    will search and replace all occurrences of the regexp in the string:</p>
<p class="Pp"></p>
<pre>    $x = &quot;I batted 4 for 4&quot;;
    $x =~ s/4/four/;   # doesn't do it all:
                       # $x contains &quot;I batted four for 4&quot;
    $x = &quot;I batted 4 for 4&quot;;
    $x =~ s/4/four/g;  # does it all:
                       # $x contains &quot;I batted four for four&quot;
</pre>
<p class="Pp">If you prefer &quot;regex&quot; over &quot;regexp&quot; in this
    tutorial, you could use the following program to replace it:</p>
<p class="Pp"></p>
<pre>    % cat &gt; simple_replace
    #!/usr/bin/perl
    $regexp = shift;
    $replacement = shift;
    while (&lt;&gt;) {
        s/$regexp/$replacement/g;
        print;
    }
    ^D
    % simple_replace regexp regex perlretut.pod
</pre>
<p class="Pp">In <span class="Li">&quot;simple_replace&quot;</span> we used the
    <span class="Li">&quot;s///g&quot;</span> modifier to replace all
    occurrences of the regexp on each line. (Even though the regular expression
    appears in a loop, Perl is smart enough to compile it only once.) As with
    <span class="Li">&quot;simple_grep&quot;</span>, both the
    <span class="Li">&quot;print&quot;</span> and the
    <span class="Li">&quot;s/$regexp/$replacement/g&quot;</span> use
    <span class="Li">$_</span> implicitly.</p>
<p class="Pp">If you don't want <span class="Li">&quot;s///&quot;</span> to
    change your original variable you can use the non-destructive substitute
    modifier, <span class="Li">&quot;s///r&quot;</span>. This changes the
    behavior so that <span class="Li">&quot;s///r&quot;</span> returns the final
    substituted string (instead of the number of substitutions):</p>
<p class="Pp"></p>
<pre>    $x = &quot;I like dogs.&quot;;
    $y = $x =~ s/dogs/cats/r;
    print &quot;$x $y\n&quot;;
</pre>
<p class="Pp">That example will print &quot;I like dogs. I like cats&quot;.
    Notice the original <span class="Li">$x</span> variable has not been
    affected. The overall result of the substitution is instead stored in
    <span class="Li">$y</span>. If the substitution doesn't affect anything then
    the original string is returned:</p>
<p class="Pp"></p>
<pre>    $x = &quot;I like dogs.&quot;;
    $y = $x =~ s/elephants/cougars/r;
    print &quot;$x $y\n&quot;; # prints &quot;I like dogs. I like dogs.&quot;
</pre>
<p class="Pp">One other interesting thing that the
    <span class="Li">&quot;s///r&quot;</span> flag allows is chaining
    substitutions:</p>
<p class="Pp"></p>
<pre>    $x = &quot;Cats are great.&quot;;
    print $x =~ s/Cats/Dogs/r =~ s/Dogs/Frogs/r =~
        s/Frogs/Hedgehogs/r, &quot;\n&quot;;
    # prints &quot;Hedgehogs are great.&quot;
</pre>
<p class="Pp">A modifier available specifically to search and replace is the
    <span class="Li">&quot;s///e&quot;</span> evaluation modifier.
    <span class="Li">&quot;s///e&quot;</span> treats the replacement text as
    Perl code, rather than a double-quoted string. The value that the code
    returns is substituted for the matched substring.
    <span class="Li">&quot;s///e&quot;</span> is useful if you need to do a bit
    of computation in the process of replacing text. This example counts
    character frequencies in a line:</p>
<p class="Pp"></p>
<pre>    $x = &quot;Bill the cat&quot;;
    $x =~ s/(.)/$chars{$1}++;$1/eg; # final $1 replaces char with itself
    print &quot;frequency of '$_' is $chars{$_}\n&quot;
        foreach (sort {$chars{$b} &lt;=&gt; $chars{$a}} keys %chars);
</pre>
<p class="Pp">This prints</p>
<p class="Pp"></p>
<pre>    frequency of ' ' is 2
    frequency of 't' is 2
    frequency of 'l' is 2
    frequency of 'B' is 1
    frequency of 'c' is 1
    frequency of 'e' is 1
    frequency of 'h' is 1
    frequency of 'i' is 1
    frequency of 'a' is 1
</pre>
<p class="Pp">As with the match <span class="Li">&quot;m//&quot;</span>
    operator, <span class="Li">&quot;s///&quot;</span> can use other delimiters,
    such as <span class="Li">&quot;s!!!&quot;</span> and
    <span class="Li">&quot;s{}{}&quot;</span>, and even
    <span class="Li">&quot;s{}//&quot;</span>. If single quotes are used
    <span class="Li">&quot;s'''&quot;</span>, then the regexp and replacement
    are treated as single-quoted strings and there are no variable
    substitutions. <span class="Li">&quot;s///&quot;</span> in list context
    returns the same thing as in scalar context, <i>i.e.</i>, the number of
    matches.</p>
<p class="Pp"><i>The split function</i></p>
<p class="Pp">The <span class="Li">&quot;split()&quot;</span> function is
    another place where a regexp is used. <span class="Li">&quot;split /regexp/,
    string, limit&quot;</span> separates the
    <span class="Li">&quot;string&quot;</span> operand into a list of substrings
    and returns that list. The regexp must be designed to match whatever
    constitutes the separators for the desired substrings. The
    <span class="Li">&quot;limit&quot;</span>, if present, constrains splitting
    into no more than <span class="Li">&quot;limit&quot;</span> number of
    strings. For example, to split a string into words, use</p>
<p class="Pp"></p>
<pre>    $x = &quot;Calvin and Hobbes&quot;;
    @words = split /\s+/, $x;  # $word[0] = 'Calvin'
                               # $word[1] = 'and'
                               # $word[2] = 'Hobbes'
</pre>
<p class="Pp">If the empty regexp <span class="Li">&quot;//&quot;</span> is
    used, the regexp always matches and the string is split into individual
    characters. If the regexp has groupings, then the resulting list contains
    the matched substrings from the groupings as well. For instance,</p>
<p class="Pp"></p>
<pre>    $x = &quot;/usr/bin/perl&quot;;
    @dirs = split m!/!, $x;  # $dirs[0] = ''
                             # $dirs[1] = 'usr'
                             # $dirs[2] = 'bin'
                             # $dirs[3] = 'perl'
    @parts = split m!(/)!, $x;  # $parts[0] = ''
                                # $parts[1] = '/'
                                # $parts[2] = 'usr'
                                # $parts[3] = '/'
                                # $parts[4] = 'bin'
                                # $parts[5] = '/'
                                # $parts[6] = 'perl'
</pre>
<p class="Pp">Since the first character of <span class="Li">$x</span> matched
    the regexp, <span class="Li">&quot;split&quot;</span> prepended an empty
    initial element to the list.</p>
<p class="Pp">If you have read this far, congratulations! You now have all the
    basic tools needed to use regular expressions to solve a wide range of text
    processing problems. If this is your first time through the tutorial, why
    not stop here and play around with regexps a while.... Part&#x00A0;2
    concerns the more esoteric aspects of regular expressions and those concepts
    certainly aren't needed right at the start.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Part_2:_Power_tools"><a class="permalink" href="#Part_2:_Power_tools">Part
  2: Power tools</a></h1>
<p class="Pp">OK, you know the basics of regexps and you want to know more. If
    matching regular expressions is analogous to a walk in the woods, then the
    tools discussed in Part 1 are analogous to topo maps and a compass, basic
    tools we use all the time. Most of the tools in part 2 are analogous to
    flare guns and satellite phones. They aren't used too often on a hike, but
    when we are stuck, they can be invaluable.</p>
<p class="Pp">What follows are the more advanced, less used, or sometimes
    esoteric capabilities of Perl regexps. In Part 2, we will assume you are
    comfortable with the basics and concentrate on the advanced features.</p>
<section class="Ss">
<h2 class="Ss" id="More_on_characters,_strings,_and_character_classes"><a class="permalink" href="#More_on_characters,_strings,_and_character_classes">More
  on characters, strings, and character classes</a></h2>
<p class="Pp">There are a number of escape sequences and character classes that
    we haven't covered yet.</p>
<p class="Pp">There are several escape sequences that convert characters or
    strings between upper and lower case, and they are also available within
    patterns. <span class="Li">&quot;\l&quot;</span> and
    <span class="Li">&quot;\u&quot;</span> convert the next character to lower
    or upper case, respectively:</p>
<p class="Pp"></p>
<pre>    $x = &quot;perl&quot;;
    $string =~ /\u$x/;  # matches 'Perl' in $string
    $x = &quot;M(rs?|s)\\.&quot;; # note the double backslash
    $string =~ /\l$x/;  # matches 'mr.', 'mrs.', and 'ms.',
</pre>
<p class="Pp">A <span class="Li">&quot;\L&quot;</span> or
    <span class="Li">&quot;\U&quot;</span> indicates a lasting conversion of
    case, until terminated by <span class="Li">&quot;\E&quot;</span> or thrown
    over by another <span class="Li">&quot;\U&quot;</span> or
    <span class="Li">&quot;\L&quot;</span>:</p>
<p class="Pp"></p>
<pre>    $x = &quot;This word is in lower case:\L SHOUT\E&quot;;
    $x =~ /shout/;       # matches
    $x = &quot;I STILL KEYPUNCH CARDS FOR MY 360&quot;
    $x =~ /\Ukeypunch/;  # matches punch card string
</pre>
<p class="Pp">If there is no <span class="Li">&quot;\E&quot;</span>, case is
    converted until the end of the string. The regexps
    <span class="Li">&quot;\L\u$word&quot;</span> or
    <span class="Li">&quot;\u\L$word&quot;</span> convert the first character of
    <span class="Li">$word</span> to uppercase and the rest of the characters to
    lowercase.</p>
<p class="Pp">Control characters can be escaped with
    <span class="Li">&quot;\c&quot;</span>, so that a control-Z character would
    be matched with <span class="Li">&quot;\cZ&quot;</span>. The escape sequence
    <span class="Li">&quot;\Q&quot;</span>...<span class="Li">&quot;\E&quot;</span>
    quotes, or protects most non-alphabetic characters. For instance,</p>
<p class="Pp"></p>
<pre>    $x = &quot;\QThat !^*&amp;%~&amp; cat!&quot;;
    $x =~ /\Q!^*&amp;%~&amp;\E/;  # check for rough language
</pre>
<p class="Pp">It does not protect <span class="Li">'$'</span> or
    <span class="Li">'@'</span>, so that variables can still be substituted.</p>
<p class="Pp"><span class="Li">&quot;\Q&quot;</span>,
    <span class="Li">&quot;\L&quot;</span>,
    <span class="Li">&quot;\l&quot;</span>,
    <span class="Li">&quot;\U&quot;</span>,
    <span class="Li">&quot;\u&quot;</span> and
    <span class="Li">&quot;\E&quot;</span> are actually part of double-quotish
    syntax, and not part of regexp syntax proper. They will work if they appear
    in a regular expression embedded directly in a program, but not when
    contained in a string that is interpolated in a pattern.</p>
<p class="Pp">Perl regexps can handle more than just the standard ASCII
    character set. Perl supports <i>Unicode</i>, a standard for representing the
    alphabets from virtually all of the world's written languages, and a host of
    symbols. Perl's text strings are Unicode strings, so they can contain
    characters with a value (codepoint or character number) higher than 255.</p>
<p class="Pp">What does this mean for regexps? Well, regexp users don't need to
    know much about Perl's internal representation of strings. But they do need
    to know 1) how to represent Unicode characters in a regexp and 2) that a
    matching operation will treat the string to be searched as a sequence of
    characters, not bytes. The answer to 1) is that Unicode characters greater
    than <span class="Li">&quot;chr(255)&quot;</span> are represented using the
    <span class="Li">&quot;\x{hex}&quot;</span> notation, because
    <span class="Li">&quot;\x&quot;</span><i>XY</i> (without curly braces and
    <i>XY</i> are two hex digits) doesn't go further than 255. (Starting in Perl
    5.14, if you're an octal fan, you can also use
    <span class="Li">&quot;\o{oct}&quot;</span>.)</p>
<p class="Pp"></p>
<pre>    /\x{263a}/;  # match a Unicode smiley face :)
</pre>
<p class="Pp"><b>NOTE</b>: In Perl 5.6.0 it used to be that one needed to say
    <span class="Li">&quot;use</span> <span class="Li">utf8&quot;</span> to use
    any Unicode features. This is no more the case: for almost all Unicode
    processing, the explicit <span class="Li">&quot;utf8&quot;</span> pragma is
    not needed. (The only case where it matters is if your Perl script is in
    Unicode and encoded in UTF-8, then an explicit <span class="Li">&quot;use
    utf8&quot;</span> is needed.)</p>
<p class="Pp">Figuring out the hexadecimal sequence of a Unicode character you
    want or deciphering someone else's hexadecimal Unicode regexp is about as
    much fun as programming in machine code. So another way to specify Unicode
    characters is to use the <i>named character</i> escape sequence
    <span class="Li">&quot;\N{</span><span class="Li"><i>name</i></span><span class="Li">}&quot;</span>.
    <i>name</i> is a name for the Unicode character, as specified in the Unicode
    standard. For instance, if we wanted to represent or match the astrological
    sign for the planet Mercury, we could use</p>
<p class="Pp"></p>
<pre>    $x = &quot;abc\N{MERCURY}def&quot;;
    $x =~ /\N{MERCURY}/;   # matches
</pre>
<p class="Pp">One can also use &quot;short&quot; names:</p>
<p class="Pp"></p>
<pre>    print &quot;\N{GREEK SMALL LETTER SIGMA} is called sigma.\n&quot;;
    print &quot;\N{greek:Sigma} is an upper-case sigma.\n&quot;;
</pre>
<p class="Pp">You can also restrict names to a certain alphabet by specifying
    the charnames pragma:</p>
<p class="Pp"></p>
<pre>    use charnames qw(greek);
    print &quot;\N{sigma} is Greek sigma\n&quot;;
</pre>
<p class="Pp">An index of character names is available on-line from the Unicode
    Consortium, &lt;http://www.unicode.org/charts/charindex.html&gt;;
    explanatory material with links to other resources at
    &lt;http://www.unicode.org/standard/where&gt;.</p>
<p class="Pp">The answer to requirement 2) is that a regexp (mostly) uses
    Unicode characters. The &quot;mostly&quot; is for messy backward
    compatibility reasons, but starting in Perl 5.14, any regexp compiled in the
    scope of a <span class="Li">&quot;use feature 'unicode_strings'&quot;</span>
    (which is automatically turned on within the scope of a
    <span class="Li">&quot;use 5.012&quot;</span> or higher) will turn that
    &quot;mostly&quot; into &quot;always&quot;. If you want to handle Unicode
    properly, you should ensure that <span class="Li">'unicode_strings'</span>
    is turned on. Internally, this is encoded to bytes using either UTF-8 or a
    native 8 bit encoding, depending on the history of the string, but
    conceptually it is a sequence of characters, not bytes. See perlunitut for a
    tutorial about that.</p>
<p class="Pp">Let us now discuss Unicode character classes, most usually called
    &quot;character properties&quot;. These are represented by the
    <span class="Li">&quot;\p{</span><span class="Li"><i>name</i></span><span class="Li">}&quot;</span>
    escape sequence. The negation of this is
    <span class="Li">&quot;\P{</span><span class="Li"><i>name</i></span><span class="Li">}&quot;</span>.
    For example, to match lower and uppercase characters,</p>
<p class="Pp"></p>
<pre>    $x = &quot;BOB&quot;;
    $x =~ /^\p{IsUpper}/;   # matches, uppercase char class
    $x =~ /^\P{IsUpper}/;   # doesn't match, char class sans uppercase
    $x =~ /^\p{IsLower}/;   # doesn't match, lowercase char class
    $x =~ /^\P{IsLower}/;   # matches, char class sans lowercase
</pre>
<p class="Pp">(The &quot;<span class="Li">&quot;Is&quot;</span>&quot; is
    optional.)</p>
<p class="Pp">There are many, many Unicode character properties. For the full
    list see perluniprops. Most of them have synonyms with shorter names, also
    listed there. Some synonyms are a single character. For these, you can drop
    the braces. For instance, <span class="Li">&quot;\pM&quot;</span> is the
    same thing as <span class="Li">&quot;\p{Mark}&quot;</span>, meaning things
    like accent marks.</p>
<p class="Pp">The Unicode <span class="Li">&quot;\p{Script}&quot;</span> and
    <span class="Li">&quot;\p{Script_Extensions}&quot;</span> properties are
    used to categorize every Unicode character into the language script it is
    written in. (<span class="Li">&quot;Script_Extensions&quot;</span> is an
    improved version of <span class="Li">&quot;Script&quot;</span>, which is
    retained for backward compatibility, and so you should generally use
    <span class="Li">&quot;Script_Extensions&quot;</span>.) For example,
    English, French, and a bunch of other European languages are written in the
    Latin script. But there is also the Greek script, the Thai script, the
    Katakana script, <i>etc</i>. You can test whether a character is in a
    particular script (based on
    <span class="Li">&quot;Script_Extensions&quot;</span>) with, for example
    <span class="Li">&quot;\p{Latin}&quot;</span>,
    <span class="Li">&quot;\p{Greek}&quot;</span>, or
    <span class="Li">&quot;\p{Katakana}&quot;</span>. To test if it isn't in the
    Balinese script, you would use
    <span class="Li">&quot;\P{Balinese}&quot;</span>.</p>
<p class="Pp">What we have described so far is the single form of the
    <span class="Li">&quot;\p{...}&quot;</span> character classes. There is also
    a compound form which you may run into. These look like
    <span class="Li">&quot;\p{</span><span class="Li"><i>name</i></span><span class="Li">=</span><span class="Li"><i>value</i></span><span class="Li">}&quot;</span>
    or
    <span class="Li">&quot;\p{</span><span class="Li"><i>name</i></span><span class="Li">:</span><span class="Li"><i>value</i></span><span class="Li">}&quot;</span>
    (the equals sign and colon can be used interchangeably). These are more
    general than the single form, and in fact most of the single forms are just
    Perl-defined shortcuts for common compound forms. For example, the script
    examples in the previous paragraph could be written equivalently as
    <span class="Li">&quot;\p{Script_Extensions=Latin}&quot;</span>,
    <span class="Li">&quot;\p{Script_Extensions:Greek}&quot;</span>,
    <span class="Li">&quot;\p{script_extensions=katakana}&quot;</span>, and
    <span class="Li">&quot;\P{script_extensions=balinese}&quot;</span> (case is
    irrelevant between the <span class="Li">&quot;{}&quot;</span> braces). You
    may never have to use the compound forms, but sometimes it is necessary, and
    their use can make your code easier to understand.</p>
<p class="Pp"><span class="Li">&quot;\X&quot;</span> is an abbreviation for a
    character class that comprises a Unicode <i>extended grapheme cluster</i>.
    This represents a &quot;logical character&quot;: what appears to be a single
    character, but may be represented internally by more than one. As an
    example, using the Unicode full names, <i>e.g.</i>,
    &quot;A&#x00A0;+&#x00A0;COMBINING&#x00A0;RING&quot; is a grapheme cluster
    with base character &quot;A&quot; and combining character
    &quot;COMBINING&#x00A0;RING, which translates in Danish to &quot;A&quot;
    with the circle atop it, as in the word Aangstrom.</p>
<p class="Pp">For the full and latest information about Unicode see the latest
    Unicode standard, or the Unicode Consortium's website
    &lt;http://www.unicode.org&gt;</p>
<p class="Pp">As if all those classes weren't enough, Perl also defines
    POSIX-style character classes. These have the form
    <span class="Li">&quot;[:</span><span class="Li"><i>name</i></span><span class="Li">:]&quot;</span>,
    with <i>name</i> the name of the POSIX class. The POSIX classes are
    <span class="Li">&quot;alpha&quot;</span>,
    <span class="Li">&quot;alnum&quot;</span>,
    <span class="Li">&quot;ascii&quot;</span>,
    <span class="Li">&quot;cntrl&quot;</span>,
    <span class="Li">&quot;digit&quot;</span>,
    <span class="Li">&quot;graph&quot;</span>,
    <span class="Li">&quot;lower&quot;</span>,
    <span class="Li">&quot;print&quot;</span>,
    <span class="Li">&quot;punct&quot;</span>,
    <span class="Li">&quot;space&quot;</span>,
    <span class="Li">&quot;upper&quot;</span>, and
    <span class="Li">&quot;xdigit&quot;</span>, and two extensions,
    <span class="Li">&quot;word&quot;</span> (a Perl extension to match
    <span class="Li">&quot;\w&quot;</span>), and
    <span class="Li">&quot;blank&quot;</span> (a GNU extension). The
    <span class="Li">&quot;/a&quot;</span> modifier restricts these to matching
    just in the ASCII range; otherwise they can match the same as their
    corresponding Perl Unicode classes:
    <span class="Li">&quot;[:upper:]&quot;</span> is the same as
    <span class="Li">&quot;\p{IsUpper}&quot;</span>, <i>etc</i>. (There are some
    exceptions and gotchas with this; see perlrecharclass for a full
    discussion.) The <span class="Li">&quot;[:digit:]&quot;</span>,
    <span class="Li">&quot;[:word:]&quot;</span>, and
    <span class="Li">&quot;[:space:]&quot;</span> correspond to the familiar
    <span class="Li">&quot;\d&quot;</span>,
    <span class="Li">&quot;\w&quot;</span>, and
    <span class="Li">&quot;\s&quot;</span> character classes. To negate a POSIX
    class, put a <span class="Li">'^'</span> in front of the name, so that,
    <i>e.g.</i>, <span class="Li">&quot;[:^digit:]&quot;</span> corresponds to
    <span class="Li">&quot;\D&quot;</span> and, under Unicode,
    <span class="Li">&quot;\P{IsDigit}&quot;</span>. The Unicode and POSIX
    character classes can be used just like
    <span class="Li">&quot;\d&quot;</span>, with the exception that POSIX
    character classes can only be used inside of a character class:</p>
<p class="Pp"></p>
<pre>    /\s+[abc[:digit:]xyz]\s*/;  # match a,b,c,x,y,z, or a digit
    /^=item\s[[:digit:]]/;      # match '=item',
                                # followed by a space and a digit
    /\s+[abc\p{IsDigit}xyz]\s+/;  # match a,b,c,x,y,z, or a digit
    /^=item\s\p{IsDigit}/;        # match '=item',
                                  # followed by a space and a digit
</pre>
<p class="Pp">Whew! That is all the rest of the characters and character
    classes.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Compiling_and_saving_regular_expressions"><a class="permalink" href="#Compiling_and_saving_regular_expressions">Compiling
  and saving regular expressions</a></h2>
<p class="Pp">In Part 1 we mentioned that Perl compiles a regexp into a compact
    sequence of opcodes. Thus, a compiled regexp is a data structure that can be
    stored once and used again and again. The regexp quote
    <span class="Li">&quot;qr//&quot;</span> does exactly that:
    <span class="Li">&quot;qr/string/&quot;</span> compiles the
    <span class="Li">&quot;string&quot;</span> as a regexp and transforms the
    result into a form that can be assigned to a variable:</p>
<p class="Pp"></p>
<pre>    $reg = qr/foo+bar?/;  # reg contains a compiled regexp
</pre>
<p class="Pp">Then <span class="Li">$reg</span> can be used as a regexp:</p>
<p class="Pp"></p>
<pre>    $x = &quot;fooooba&quot;;
    $x =~ $reg;     # matches, just like /foo+bar?/
    $x =~ /$reg/;   # same thing, alternate form
</pre>
<p class="Pp"><span class="Li">$reg</span> can also be interpolated into a
    larger regexp:</p>
<p class="Pp"></p>
<pre>    $x =~ /(abc)?$reg/;  # still matches
</pre>
<p class="Pp">As with the matching operator, the regexp quote can use different
    delimiters, <i>e.g.</i>, <span class="Li">&quot;qr!!&quot;</span>,
    <span class="Li">&quot;qr{}&quot;</span> or
    <span class="Li">&quot;qr~~&quot;</span>. Apostrophes as delimiters
    (<span class="Li">&quot;qr''&quot;</span>) inhibit any interpolation.</p>
<p class="Pp">Pre-compiled regexps are useful for creating dynamic matches that
    don't need to be recompiled each time they are encountered. Using
    pre-compiled regexps, we write a
    <span class="Li">&quot;grep_step&quot;</span> program which greps for a
    sequence of patterns, advancing to the next pattern as soon as one has been
    satisfied.</p>
<p class="Pp"></p>
<pre>    % cat &gt; grep_step
    #!/usr/bin/perl
    # grep_step - match &lt;number&gt; regexps, one after the other
    # usage: multi_grep &lt;number&gt; regexp1 regexp2 ... file1 file2 ...
    $number = shift;
    $regexp[$_] = shift foreach (0..$number-1);
    @compiled = map qr/$_/, @regexp;
    while ($line = &lt;&gt;) {
        if ($line =~ /$compiled[0]/) {
            print $line;
            shift @compiled;
            last unless @compiled;
        }
    }
    ^D
    % grep_step 3 shift print last grep_step
    $number = shift;
            print $line;
            last unless @compiled;
</pre>
<p class="Pp">Storing pre-compiled regexps in an array
    <span class="Li">@compiled</span> allows us to simply loop through the
    regexps without any recompilation, thus gaining flexibility without
    sacrificing speed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Composing_regular_expressions_at_runtime"><a class="permalink" href="#Composing_regular_expressions_at_runtime">Composing
  regular expressions at runtime</a></h2>
<p class="Pp">Backtracking is more efficient than repeated tries with different
    regular expressions. If there are several regular expressions and a match
    with any of them is acceptable, then it is possible to combine them into a
    set of alternatives. If the individual expressions are input data, this can
    be done by programming a join operation. We'll exploit this idea in an
    improved version of the <span class="Li">&quot;simple_grep&quot;</span>
    program: a program that matches multiple patterns:</p>
<p class="Pp"></p>
<pre>    % cat &gt; multi_grep
    #!/usr/bin/perl
    # multi_grep - match any of &lt;number&gt; regexps
    # usage: multi_grep &lt;number&gt; regexp1 regexp2 ... file1 file2 ...
    $number = shift;
    $regexp[$_] = shift foreach (0..$number-1);
    $pattern = join '|', @regexp;
    while ($line = &lt;&gt;) {
        print $line if $line =~ /$pattern/;
    }
    ^D
    % multi_grep 2 shift for multi_grep
    $number = shift;
    $regexp[$_] = shift foreach (0..$number-1);
</pre>
<p class="Pp">Sometimes it is advantageous to construct a pattern from the
    <i>input</i> that is to be analyzed and use the permissible values on the
    left hand side of the matching operations. As an example for this somewhat
    paradoxical situation, let's assume that our input contains a command verb
    which should match one out of a set of available command verbs, with the
    additional twist that commands may be abbreviated as long as the given
    string is unique. The program below demonstrates the basic algorithm.</p>
<p class="Pp"></p>
<pre>    % cat &gt; keymatch
    #!/usr/bin/perl
    $kwds = 'copy compare list print';
    while( $cmd = &lt;&gt; ){
        $cmd =~ s/^\s+|\s+$//g;  # trim leading and trailing spaces
        if( ( @matches = $kwds =~ /\b$cmd\w*/g ) == 1 ){
            print &quot;command: '@matches'\n&quot;;
        } elsif( @matches == 0 ){
            print &quot;no such command: '$cmd'\n&quot;;
        } else {
            print &quot;not unique: '$cmd' (could be one of: @matches)\n&quot;;
        }
    }
    ^D
    % keymatch
    li
    command: 'list'
    co
    not unique: 'co' (could be one of: copy compare)
    printer
    no such command: 'printer'
</pre>
<p class="Pp">Rather than trying to match the input against the keywords, we
    match the combined set of keywords against the input. The pattern matching
    operation
    <span class="Li">&quot;$kwds&#x00A0;=~&#x00A0;/\b($cmd\w*)/g&quot;</span>
    does several things at the same time. It makes sure that the given command
    begins where a keyword begins (<span class="Li">&quot;\b&quot;</span>). It
    tolerates abbreviations due to the added
    <span class="Li">&quot;\w*&quot;</span>. It tells us the number of matches
    (<span class="Li">&quot;scalar @matches&quot;</span>) and all the keywords
    that were actually matched. You could hardly ask for more.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Embedding_comments_and_modifiers_in_a_regular_expression"><a class="permalink" href="#Embedding_comments_and_modifiers_in_a_regular_expression">Embedding
  comments and modifiers in a regular expression</a></h2>
<p class="Pp">Starting with this section, we will be discussing Perl's set of
    <i>extended patterns</i>. These are extensions to the traditional regular
    expression syntax that provide powerful new tools for pattern matching. We
    have already seen extensions in the form of the minimal matching constructs
    <span class="Li">&quot;??&quot;</span>,
    <span class="Li">&quot;*?&quot;</span>,
    <span class="Li">&quot;+?&quot;</span>,
    <span class="Li">&quot;{n,m}?&quot;</span>, and
    <span class="Li">&quot;{n,}?&quot;</span>. Most of the extensions below have
    the form <span class="Li">&quot;(?char...)&quot;</span>, where the
    <span class="Li">&quot;char&quot;</span> is a character that determines the
    type of extension.</p>
<p class="Pp">The first extension is an embedded comment
    <span class="Li">&quot;(?#text)&quot;</span>. This embeds a comment into the
    regular expression without affecting its meaning. The comment should not
    have any closing parentheses in the text. An example is</p>
<p class="Pp"></p>
<pre>    /(?# Match an integer:)[+-]?\d+/;
</pre>
<p class="Pp">This style of commenting has been largely superseded by the raw,
    freeform commenting that is allowed with the
    <span class="Li">&quot;/x&quot;</span> modifier.</p>
<p class="Pp">Most modifiers, such as <span class="Li">&quot;/i&quot;</span>,
    <span class="Li">&quot;/m&quot;</span>,
    <span class="Li">&quot;/s&quot;</span> and
    <span class="Li">&quot;/x&quot;</span> (or any combination thereof) can also
    be embedded in a regexp using <span class="Li">&quot;(?i)&quot;</span>,
    <span class="Li">&quot;(?m)&quot;</span>,
    <span class="Li">&quot;(?s)&quot;</span>, and
    <span class="Li">&quot;(?x)&quot;</span>. For instance,</p>
<p class="Pp"></p>
<pre>    /(?i)yes/;  # match 'yes' case insensitively
    /yes/i;     # same thing
    /(?x)(          # freeform version of an integer regexp
             [+-]?  # match an optional sign
             \d+    # match a sequence of digits
         )
    /x;
</pre>
<p class="Pp">Embedded modifiers can have two important advantages over the
    usual modifiers. Embedded modifiers allow a custom set of modifiers for
    <i>each</i> regexp pattern. This is great for matching an array of regexps
    that must have different modifiers:</p>
<p class="Pp"></p>
<pre>    $pattern[0] = '(?i)doctor';
    $pattern[1] = 'Johnson';
    ...
    while (&lt;&gt;) {
        foreach $patt (@pattern) {
            print if /$patt/;
        }
    }
</pre>
<p class="Pp">The second advantage is that embedded modifiers (except
    <span class="Li">&quot;/p&quot;</span>, which modifies the entire regexp)
    only affect the regexp inside the group the embedded modifier is contained
    in. So grouping can be used to localize the modifier's effects:</p>
<p class="Pp"></p>
<pre>    /Answer: ((?i)yes)/;  # matches 'Answer: yes', 'Answer: YES', etc.
</pre>
<p class="Pp">Embedded modifiers can also turn off any modifiers already present
    by using, <i>e.g.</i>, <span class="Li">&quot;(?-i)&quot;</span>. Modifiers
    can also be combined into a single expression, <i>e.g.</i>,
    <span class="Li">&quot;(?s-i)&quot;</span> turns on single line mode and
    turns off case insensitivity.</p>
<p class="Pp">Embedded modifiers may also be added to a non-capturing grouping.
    <span class="Li">&quot;(?i-m:regexp)&quot;</span> is a non-capturing
    grouping that matches <span class="Li">&quot;regexp&quot;</span> case
    insensitively and turns off multi-line mode.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Looking_ahead_and_looking_behind"><a class="permalink" href="#Looking_ahead_and_looking_behind">Looking
  ahead and looking behind</a></h2>
<p class="Pp">This section concerns the lookahead and lookbehind assertions.
    First, a little background.</p>
<p class="Pp">In Perl regular expressions, most regexp elements &quot;eat
    up&quot; a certain amount of string when they match. For instance, the
    regexp element <span class="Li">&quot;[abc]&quot;</span> eats up one
    character of the string when it matches, in the sense that Perl moves to the
    next character position in the string after the match. There are some
    elements, however, that don't eat up characters (advance the character
    position) if they match. The examples we have seen so far are the anchors.
    The anchor <span class="Li">'^'</span> matches the beginning of the line,
    but doesn't eat any characters. Similarly, the word boundary anchor
    <span class="Li">&quot;\b&quot;</span> matches wherever a character matching
    <span class="Li">&quot;\w&quot;</span> is next to a character that doesn't,
    but it doesn't eat up any characters itself. Anchors are examples of
    <i>zero-width assertions</i>: zero-width, because they consume no
    characters, and assertions, because they test some property of the string.
    In the context of our walk in the woods analogy to regexp matching, most
    regexp elements move us along a trail, but anchors have us stop a moment and
    check our surroundings. If the local environment checks out, we can proceed
    forward. But if the local environment doesn't satisfy us, we must
  backtrack.</p>
<p class="Pp">Checking the environment entails either looking ahead on the
    trail, looking behind, or both. <span class="Li">'^'</span> looks behind, to
    see that there are no characters before. <span class="Li">'$'</span> looks
    ahead, to see that there are no characters after.
    <span class="Li">&quot;\b&quot;</span> looks both ahead and behind, to see
    if the characters on either side differ in their &quot;word-ness&quot;.</p>
<p class="Pp">The lookahead and lookbehind assertions are generalizations of the
    anchor concept. Lookahead and lookbehind are zero-width assertions that let
    us specify which characters we want to test for. The lookahead assertion is
    denoted by <span class="Li">&quot;(?=regexp)&quot;</span> and the lookbehind
    assertion is denoted by
    <span class="Li">&quot;(?&lt;=fixed-regexp)&quot;</span>. Some examples
  are</p>
<p class="Pp"></p>
<pre>    $x = &quot;I catch the housecat 'Tom-cat' with catnip&quot;;
    $x =~ /cat(?=\s)/;   # matches 'cat' in 'housecat'
    @catwords = ($x =~ /(?&lt;=\s)cat\w+/g);  # matches,
                                           # $catwords[0] = 'catch'
                                           # $catwords[1] = 'catnip'
    $x =~ /\bcat\b/;  # matches 'cat' in 'Tom-cat'
    $x =~ /(?&lt;=\s)cat(?=\s)/; # doesn't match; no isolated 'cat' in
                              # middle of $x
</pre>
<p class="Pp">Note that the parentheses in
    <span class="Li">&quot;(?=regexp)&quot;</span> and
    <span class="Li">&quot;(?&lt;=regexp)&quot;</span> are non-capturing, since
    these are zero-width assertions. Thus in the second regexp, the substrings
    captured are those of the whole regexp itself. Lookahead
    <span class="Li">&quot;(?=regexp)&quot;</span> can match arbitrary regexps,
    but lookbehind <span class="Li">&quot;(?&lt;=fixed-regexp)&quot;</span> only
    works for regexps of fixed width, <i>i.e.</i>, a fixed number of characters
    long. Thus <span class="Li">&quot;(?&lt;=(ab|bc))&quot;</span> is fine, but
    <span class="Li">&quot;(?&lt;=(ab)*)&quot;</span> is not. The negated
    versions of the lookahead and lookbehind assertions are denoted by
    <span class="Li">&quot;(?!regexp)&quot;</span> and
    <span class="Li">&quot;(?&lt;!fixed-regexp)&quot;</span> respectively. They
    evaluate true if the regexps do <i>not</i> match:</p>
<p class="Pp"></p>
<pre>    $x = &quot;foobar&quot;;
    $x =~ /foo(?!bar)/;  # doesn't match, 'bar' follows 'foo'
    $x =~ /foo(?!baz)/;  # matches, 'baz' doesn't follow 'foo'
    $x =~ /(?&lt;!\s)foo/;  # matches, there is no \s before 'foo'
</pre>
<p class="Pp">Here is an example where a string containing blank-separated
    words, numbers and single dashes is to be split into its components. Using
    <span class="Li">&quot;/\s+/&quot;</span> alone won't work, because spaces
    are not required between dashes, or a word or a dash. Additional places for
    a split are established by looking ahead and behind:</p>
<p class="Pp"></p>
<pre>    $str = &quot;one two - --6-8&quot;;
    @toks = split / \s+              # a run of spaces
                  | (?&lt;=\S) (?=-)    # any non-space followed by '-'
                  | (?&lt;=-)  (?=\S)   # a '-' followed by any non-space
                  /x, $str;          # @toks = qw(one two - - - 6 - 8)
</pre>
<p class="Pp">Starting in Perl 5.28, experimentally, alphabetic equivalents to
    these assertions are added, so you can use whichever is most memorable for
    your tastes.</p>
<p class="Pp"></p>
<pre> (?=...)        (*pla:...) or (*positive_lookahead:...)
 (?!...)        (*nla:...) or (*negative_lookahead:...)
 (?&lt;=...)       (*plb:...) or (*positive_lookbehind:...)
 (?&lt;!...)       (*nlb:...) or (*negative_lookbehind:...)
 (?&gt;...)        (*atomic:...)
</pre>
<p class="Pp">Using any of these will raise (unless turned off) a warning in the
    <span class="Li">&quot;experimental::alpha_assertions&quot;</span>
  category.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_independent_subexpressions_to_prevent_backtracking"><a class="permalink" href="#Using_independent_subexpressions_to_prevent_backtracking">Using
  independent subexpressions to prevent backtracking</a></h2>
<p class="Pp"><i>Independent subexpressions</i> are regular expressions, in the
    context of a larger regular expression, that function independently of the
    larger regular expression. That is, they consume as much or as little of the
    string as they wish without regard for the ability of the larger regexp to
    match. Independent subexpressions are represented by
    <span class="Li">&quot;(?&gt;regexp)&quot;</span>. We can illustrate their
    behavior by first considering an ordinary regexp:</p>
<p class="Pp"></p>
<pre>    $x = &quot;ab&quot;;
    $x =~ /a*ab/;  # matches
</pre>
<p class="Pp">This obviously matches, but in the process of matching, the
    subexpression <span class="Li">&quot;a*&quot;</span> first grabbed the
    <span class="Li">'a'</span>. Doing so, however, wouldn't allow the whole
    regexp to match, so after backtracking,
    <span class="Li">&quot;a*&quot;</span> eventually gave back the
    <span class="Li">'a'</span> and matched the empty string. Here, what
    <span class="Li">&quot;a*&quot;</span> matched was <i>dependent</i> on what
    the rest of the regexp matched.</p>
<p class="Pp">Contrast that with an independent subexpression:</p>
<p class="Pp"></p>
<pre>    $x =~ /(?&gt;a*)ab/;  # doesn't match!
</pre>
<p class="Pp">The independent subexpression
    <span class="Li">&quot;(?&gt;a*)&quot;</span> doesn't care about the rest of
    the regexp, so it sees an <span class="Li">'a'</span> and grabs it. Then the
    rest of the regexp <span class="Li">&quot;ab&quot;</span> cannot match.
    Because <span class="Li">&quot;(?&gt;a*)&quot;</span> is independent, there
    is no backtracking and the independent subexpression does not give up its
    <span class="Li">'a'</span>. Thus the match of the regexp as a whole fails.
    A similar behavior occurs with completely independent regexps:</p>
<p class="Pp"></p>
<pre>    $x = &quot;ab&quot;;
    $x =~ /a*/g;   # matches, eats an 'a'
    $x =~ /\Gab/g; # doesn't match, no 'a' available
</pre>
<p class="Pp">Here <span class="Li">&quot;/g&quot;</span> and
    <span class="Li">&quot;\G&quot;</span> create a &quot;tag team&quot; handoff
    of the string from one regexp to the other. Regexps with an independent
    subexpression are much like this, with a handoff of the string to the
    independent subexpression, and a handoff of the string back to the enclosing
    regexp.</p>
<p class="Pp">The ability of an independent subexpression to prevent
    backtracking can be quite useful. Suppose we want to match a non-empty
    string enclosed in parentheses up to two levels deep. Then the following
    regexp matches:</p>
<p class="Pp"></p>
<pre>    $x = &quot;abc(de(fg)h&quot;;  # unbalanced parentheses
    $x =~ /\( ( [ ^ () ]+ | \( [ ^ () ]* \) )+ \)/xx;
</pre>
<p class="Pp">The regexp matches an open parenthesis, one or more copies of an
    alternation, and a close parenthesis. The alternation is two-way, with the
    first alternative <span class="Li">&quot;[^()]+&quot;</span> matching a
    substring with no parentheses and the second alternative
    <span class="Li">&quot;\([^()]*\)&quot;</span> matching a substring
    delimited by parentheses. The problem with this regexp is that it is
    pathological: it has nested indeterminate quantifiers of the form
    <span class="Li">&quot;(a+|b)+&quot;</span>. We discussed in Part 1 how
    nested quantifiers like this could take an exponentially long time to
    execute if there was no match possible. To prevent the exponential blowup,
    we need to prevent useless backtracking at some point. This can be done by
    enclosing the inner quantifier as an independent subexpression:</p>
<p class="Pp"></p>
<pre>    $x =~ /\( ( (?&gt; [ ^ () ]+ ) | \([ ^ () ]* \) )+ \)/xx;
</pre>
<p class="Pp">Here, <span class="Li">&quot;(?&gt;[^()]+)&quot;</span> breaks the
    degeneracy of string partitioning by gobbling up as much of the string as
    possible and keeping it. Then match failures fail much more quickly.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Conditional_expressions"><a class="permalink" href="#Conditional_expressions">Conditional
  expressions</a></h2>
<p class="Pp">A <i>conditional expression</i> is a form of if-then-else
    statement that allows one to choose which patterns are to be matched, based
    on some condition. There are two types of conditional expression:
    <span class="Li">&quot;(?(</span><span class="Li"><i>condition</i></span><span class="Li">)</span><span class="Li"><i>yes-regexp</i></span><span class="Li">)&quot;</span>
    and
    <span class="Li">&quot;(?(condition)</span><span class="Li"><i>yes-regexp</i></span><span class="Li">|</span><span class="Li"><i>no-regexp</i></span><span class="Li">)&quot;</span>.
    <span class="Li">&quot;(?(</span><span class="Li"><i>condition</i></span><span class="Li">)</span><span class="Li"><i>yes-regexp</i></span><span class="Li">)&quot;</span>
    is like an <span class="Li">'if&#x00A0;()&#x00A0;{}'</span> statement in
    Perl. If the <i>condition</i> is true, the <i>yes-regexp</i> will be
    matched. If the <i>condition</i> is false, the <i>yes-regexp</i> will be
    skipped and Perl will move onto the next regexp element. The second form is
    like an
    <span class="Li">'if&#x00A0;()&#x00A0;{}&#x00A0;else&#x00A0;{}'</span>
    statement in Perl. If the <i>condition</i> is true, the <i>yes-regexp</i>
    will be matched, otherwise the <i>no-regexp</i> will be matched.</p>
<p class="Pp">The <i>condition</i> can have several forms. The first form is
    simply an integer in parentheses
    <span class="Li">&quot;(</span><span class="Li"><i>integer</i></span><span class="Li">)&quot;</span>.
    It is true if the corresponding backreference
    <span class="Li">&quot;\</span><span class="Li"><i>integer</i></span><span class="Li">&quot;</span>
    matched earlier in the regexp. The same thing can be done with a name
    associated with a capture group, written as
    <span class="Li">&quot;(&lt;</span><span class="Li"><i>name</i></span><span class="Li">&gt;)&quot;</span>
    or
    <span class="Li">&quot;('</span><span class="Li"><i>name</i></span><span class="Li">')&quot;</span>.
    The second form is a bare zero-width assertion
    <span class="Li">&quot;(?...)&quot;</span>, either a lookahead, a
    lookbehind, or a code assertion (discussed in the next section). The third
    set of forms provides tests that return true if the expression is executed
    within a recursion (<span class="Li">&quot;(R)&quot;</span>) or is being
    called from some capturing group, referenced either by number
    (<span class="Li">&quot;(R1)&quot;</span>,
    <span class="Li">&quot;(R2)&quot;</span>,...) or by name
    (<span class="Li">&quot;(R&amp;</span><span class="Li"><i>name</i></span><span class="Li">)&quot;</span>).</p>
<p class="Pp">The integer or name form of the
    <span class="Li">&quot;condition&quot;</span> allows us to choose, with more
    flexibility, what to match based on what matched earlier in the regexp. This
    searches for words of the form <span class="Li">&quot;$x$x&quot;</span> or
    <span class="Li">&quot;$x$y$y$x&quot;</span>:</p>
<p class="Pp"></p>
<pre>    % simple_grep '^(\w+)(\w+)?(?(2)\g2\g1|\g1)$' /usr/dict/words
    beriberi
    coco
    couscous
    deed
    ...
    toot
    toto
    tutu
</pre>
<p class="Pp">The lookbehind <span class="Li">&quot;condition&quot;</span>
    allows, along with backreferences, an earlier part of the match to influence
    a later part of the match. For instance,</p>
<p class="Pp"></p>
<pre>    /[ATGC]+(?(?&lt;=AA)G|C)$/;
</pre>
<p class="Pp">matches a DNA sequence such that it either ends in
    <span class="Li">&quot;AAG&quot;</span>, or some other base pair combination
    and <span class="Li">'C'</span>. Note that the form is
    <span class="Li">&quot;(?(?&lt;=AA)G|C)&quot;</span> and not
    <span class="Li">&quot;(?((?&lt;=AA))G|C)&quot;</span>; for the lookahead,
    lookbehind or code assertions, the parentheses around the conditional are
    not needed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Defining_named_patterns"><a class="permalink" href="#Defining_named_patterns">Defining
  named patterns</a></h2>
<p class="Pp">Some regular expressions use identical subpatterns in several
    places. Starting with Perl 5.10, it is possible to define named subpatterns
    in a section of the pattern so that they can be called up by name anywhere
    in the pattern. This syntactic pattern for this definition group is
    <span class="Li">&quot;(?(DEFINE)(?&lt;</span><span class="Li"><i>name</i></span><span class="Li">&gt;</span><span class="Li"><i>pattern</i></span><span class="Li">)...)&quot;</span>.
    An insertion of a named pattern is written as
    <span class="Li">&quot;(?&amp;</span><span class="Li"><i>name</i></span><span class="Li">)&quot;</span>.</p>
<p class="Pp">The example below illustrates this feature using the pattern for
    floating point numbers that was presented earlier on. The three subpatterns
    that are used more than once are the optional sign, the digit sequence for
    an integer and the decimal fraction. The
    <span class="Li">&quot;DEFINE&quot;</span> group at the end of the pattern
    contains their definition. Notice that the decimal fraction pattern is the
    first place where we can reuse the integer pattern.</p>
<p class="Pp"></p>
<pre>   /^ (?&amp;osg)\ * ( (?&amp;int)(?&amp;dec)? | (?&amp;dec) )
      (?: [eE](?&amp;osg)(?&amp;int) )?
    $
    (?(DEFINE)
      (?&lt;osg&gt;[-+]?)         # optional sign
      (?&lt;int&gt;\d++)          # integer
      (?&lt;dec&gt;\.(?&amp;int))     # decimal fraction
    )/x
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Recursive_patterns"><a class="permalink" href="#Recursive_patterns">Recursive
  patterns</a></h2>
<p class="Pp">This feature (introduced in Perl 5.10) significantly extends the
    power of Perl's pattern matching. By referring to some other capture group
    anywhere in the pattern with the construct
    <span class="Li">&quot;(?</span><span class="Li"><i>group-ref</i></span><span class="Li">)&quot;</span>,
    the <i>pattern</i> within the referenced group is used as an independent
    subpattern in place of the group reference itself. Because the group
    reference may be contained <i>within</i> the group it refers to, it is now
    possible to apply pattern matching to tasks that hitherto required a
    recursive parser.</p>
<p class="Pp">To illustrate this feature, we'll design a pattern that matches if
    a string contains a palindrome. (This is a word or a sentence that, while
    ignoring spaces, interpunctuation and case, reads the same backwards as
    forwards. We begin by observing that the empty string or a string containing
    just one word character is a palindrome. Otherwise it must have a word
    character up front and the same at its end, with another palindrome in
    between.</p>
<p class="Pp"></p>
<pre>    /(?: (\w) (?...Here be a palindrome...) \g{-1} | \w? )/x
</pre>
<p class="Pp">Adding <span class="Li">&quot;\W*&quot;</span> at either end to
    eliminate what is to be ignored, we already have the full pattern:</p>
<p class="Pp"></p>
<pre>    my $pp = qr/^(\W* (?: (\w) (?1) \g{-1} | \w? ) \W*)$/ix;
    for $s ( &quot;saippuakauppias&quot;, &quot;A man, a plan, a canal: Panama!&quot; ){
        print &quot;'$s' is a palindrome\n&quot; if $s =~ /$pp/;
    }
</pre>
<p class="Pp">In <span class="Li">&quot;(?...)&quot;</span> both absolute and
    relative backreferences may be used. The entire pattern can be reinserted
    with <span class="Li">&quot;(?R)&quot;</span> or
    <span class="Li">&quot;(?0)&quot;</span>. If you prefer to name your groups,
    you can use
    <span class="Li">&quot;(?&amp;</span><span class="Li"><i>name</i></span><span class="Li">)&quot;</span>
    to recurse into that group.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="A_bit_of_magic:_executing_Perl_code_in_a_regular_expression"><a class="permalink" href="#A_bit_of_magic:_executing_Perl_code_in_a_regular_expression">A
  bit of magic: executing Perl code in a regular expression</a></h2>
<p class="Pp">Normally, regexps are a part of Perl expressions. <i>Code
    evaluation</i> expressions turn that around by allowing arbitrary Perl code
    to be a part of a regexp. A code evaluation expression is denoted
    <span class="Li">&quot;(?{</span><span class="Li"><i>code</i></span><span class="Li">})&quot;</span>,
    with <i>code</i> a string of Perl statements.</p>
<p class="Pp">Code expressions are zero-width assertions, and the value they
    return depends on their environment. There are two possibilities: either the
    code expression is used as a conditional in a conditional expression
    <span class="Li">&quot;(?(</span><span class="Li"><i>condition</i></span><span class="Li">)...)&quot;</span>,
    or it is not. If the code expression is a conditional, the code is evaluated
    and the result (<i>i.e.</i>, the result of the last statement) is used to
    determine truth or falsehood. If the code expression is not used as a
    conditional, the assertion always evaluates true and the result is put into
    the special variable <span class="Li">$^R</span>. The variable
    <span class="Li">$^R</span> can then be used in code expressions later in
    the regexp. Here are some silly examples:</p>
<p class="Pp"></p>
<pre>    $x = &quot;abcdef&quot;;
    $x =~ /abc(?{print &quot;Hi Mom!&quot;;})def/; # matches,
                                         # prints 'Hi Mom!'
    $x =~ /aaa(?{print &quot;Hi Mom!&quot;;})def/; # doesn't match,
                                         # no 'Hi Mom!'
</pre>
<p class="Pp">Pay careful attention to the next example:</p>
<p class="Pp"></p>
<pre>    $x =~ /abc(?{print &quot;Hi Mom!&quot;;})ddd/; # doesn't match,
                                         # no 'Hi Mom!'
                                         # but why not?
</pre>
<p class="Pp">At first glance, you'd think that it shouldn't print, because
    obviously the <span class="Li">&quot;ddd&quot;</span> isn't going to match
    the target string. But look at this example:</p>
<p class="Pp"></p>
<pre>    $x =~ /abc(?{print &quot;Hi Mom!&quot;;})[dD]dd/; # doesn't match,
                                            # but _does_ print
</pre>
<p class="Pp">Hmm. What happened here? If you've been following along, you know
    that the above pattern should be effectively (almost) the same as the last
    one; enclosing the <span class="Li">'d'</span> in a character class isn't
    going to change what it matches. So why does the first not print while the
    second one does?</p>
<p class="Pp">The answer lies in the optimizations the regexp engine makes. In
    the first case, all the engine sees are plain old characters (aside from the
    <span class="Li">&quot;?{}&quot;</span> construct). It's smart enough to
    realize that the string <span class="Li">'ddd'</span> doesn't occur in our
    target string before actually running the pattern through. But in the second
    case, we've tricked it into thinking that our pattern is more complicated.
    It takes a look, sees our character class, and decides that it will have to
    actually run the pattern to determine whether or not it matches, and in the
    process of running it hits the print statement before it discovers that we
    don't have a match.</p>
<p class="Pp">To take a closer look at how the engine does optimizations, see
    the section &quot;Pragmas and debugging&quot; below.</p>
<p class="Pp">More fun with <span class="Li">&quot;?{}&quot;</span>:</p>
<p class="Pp"></p>
<pre>    $x =~ /(?{print &quot;Hi Mom!&quot;;})/;       # matches,
                                         # prints 'Hi Mom!'
    $x =~ /(?{$c = 1;})(?{print &quot;$c&quot;;})/;  # matches,
                                           # prints '1'
    $x =~ /(?{$c = 1;})(?{print &quot;$^R&quot;;})/; # matches,
                                           # prints '1'
</pre>
<p class="Pp">The bit of magic mentioned in the section title occurs when the
    regexp backtracks in the process of searching for a match. If the regexp
    backtracks over a code expression and if the variables used within are
    localized using <span class="Li">&quot;local&quot;</span>, the changes in
    the variables produced by the code expression are undone! Thus, if we wanted
    to count how many times a character got matched inside a group, we could
    use, <i>e.g.</i>,</p>
<p class="Pp"></p>
<pre>    $x = &quot;aaaa&quot;;
    $count = 0;  # initialize 'a' count
    $c = &quot;bob&quot;;  # test if $c gets clobbered
    $x =~ /(?{local $c = 0;})         # initialize count
           ( a                        # match 'a'
             (?{local $c = $c + 1;})  # increment count
           )*                         # do this any number of times,
           aa                         # but match 'aa' at the end
           (?{$count = $c;})          # copy local $c var into $count
          /x;
    print &quot;'a' count is $count, \$c variable is '$c'\n&quot;;
</pre>
<p class="Pp">This prints</p>
<p class="Pp"></p>
<pre>    'a' count is 2, $c variable is 'bob'
</pre>
<p class="Pp">If we replace the
    <span class="Li">&quot;&#x00A0;(?{local&#x00A0;$c&#x00A0;=&#x00A0;$c&#x00A0;+&#x00A0;1;})&quot;</span>
    with
    <span class="Li">&quot;&#x00A0;(?{$c&#x00A0;=&#x00A0;$c&#x00A0;+&#x00A0;1;})&quot;</span>,
    the variable changes are <i>not</i> undone during backtracking, and we
  get</p>
<p class="Pp"></p>
<pre>    'a' count is 4, $c variable is 'bob'
</pre>
<p class="Pp">Note that only localized variable changes are undone. Other side
    effects of code expression execution are permanent. Thus</p>
<p class="Pp"></p>
<pre>    $x = &quot;aaaa&quot;;
    $x =~ /(a(?{print &quot;Yow\n&quot;;}))*aa/;
</pre>
<p class="Pp">produces</p>
<p class="Pp"></p>
<pre>   Yow
   Yow
   Yow
   Yow
</pre>
<p class="Pp">The result <span class="Li">$^R</span> is automatically localized,
    so that it will behave properly in the presence of backtracking.</p>
<p class="Pp">This example uses a code expression in a conditional to match a
    definite article, either <span class="Li">'the'</span> in English or
    <span class="Li">'der|die|das'</span> in German:</p>
<p class="Pp"></p>
<pre>    $lang = 'DE';  # use German
    ...
    $text = &quot;das&quot;;
    print &quot;matched\n&quot;
        if $text =~ /(?(?{
                          $lang eq 'EN'; # is the language English?
                         })
                       the |             # if so, then match 'the'
                       (der|die|das)     # else, match 'der|die|das'
                     )
                    /xi;
</pre>
<p class="Pp">Note that the syntax here is
    <span class="Li">&quot;(?(?{...})</span><span class="Li"><i>yes-regexp</i></span><span class="Li">|</span><span class="Li"><i>no-regexp</i></span><span class="Li">)&quot;</span>,
    not
    <span class="Li">&quot;(?((?{...}))</span><span class="Li"><i>yes-regexp</i></span><span class="Li">|</span><span class="Li"><i>no-regexp</i></span><span class="Li">)&quot;</span>.
    In other words, in the case of a code expression, we don't need the extra
    parentheses around the conditional.</p>
<p class="Pp">If you try to use code expressions where the code text is
    contained within an interpolated variable, rather than appearing literally
    in the pattern, Perl may surprise you:</p>
<p class="Pp"></p>
<pre>    $bar = 5;
    $pat = '(?{ 1 })';
    /foo(?{ $bar })bar/; # compiles ok, $bar not interpolated
    /foo(?{ 1 })$bar/;   # compiles ok, $bar interpolated
    /foo${pat}bar/;      # compile error!
    $pat = qr/(?{ $foo = 1 })/;  # precompile code regexp
    /foo${pat}bar/;      # compiles ok
</pre>
<p class="Pp">If a regexp has a variable that interpolates a code expression,
    Perl treats the regexp as an error. If the code expression is precompiled
    into a variable, however, interpolating is ok. The question is, why is this
    an error?</p>
<p class="Pp">The reason is that variable interpolation and code expressions
    together pose a security risk. The combination is dangerous because many
    programmers who write search engines often take user input and plug it
    directly into a regexp:</p>
<p class="Pp"></p>
<pre>    $regexp = &lt;&gt;;       # read user-supplied regexp
    $chomp $regexp;     # get rid of possible newline
    $text =~ /$regexp/; # search $text for the $regexp
</pre>
<p class="Pp">If the <span class="Li">$regexp</span> variable contains a code
    expression, the user could then execute arbitrary Perl code. For instance,
    some joker could search for
    <span class="Li">&quot;system('rm&#x00A0;-rf&#x00A0;*');&quot;</span> to
    erase your files. In this sense, the combination of interpolation and code
    expressions <i>taints</i> your regexp. So by default, using both
    interpolation and code expressions in the same regexp is not allowed. If
    you're not concerned about malicious users, it is possible to bypass this
    security check by invoking
    <span class="Li">&quot;use&#x00A0;re&#x00A0;'eval'&quot;</span>:</p>
<p class="Pp"></p>
<pre>    use re 'eval';       # throw caution out the door
    $bar = 5;
    $pat = '(?{ 1 })';
    /foo${pat}bar/;      # compiles ok
</pre>
<p class="Pp">Another form of code expression is the <i>pattern code
    expression</i>. The pattern code expression is like a regular code
    expression, except that the result of the code evaluation is treated as a
    regular expression and matched immediately. A simple example is</p>
<p class="Pp"></p>
<pre>    $length = 5;
    $char = 'a';
    $x = 'aaaaabb';
    $x =~ /(??{$char x $length})/x; # matches, there are 5 of 'a'
</pre>
<p class="Pp">This final example contains both ordinary and pattern code
    expressions. It detects whether a binary string
    <span class="Li">1101010010001...</span> has a Fibonacci spacing
    0,1,1,2,3,5,... of the <span class="Li">'1'</span>'s:</p>
<p class="Pp"></p>
<pre>    $x = &quot;1101010010001000001&quot;;
    $z0 = ''; $z1 = '0';   # initial conditions
    print &quot;It is a Fibonacci sequence\n&quot;
        if $x =~ /^1         # match an initial '1'
                    (?:
                       ((??{ $z0 })) # match some '0'
                       1             # and then a '1'
                       (?{ $z0 = $z1; $z1 .= $^N; })
                    )+   # repeat as needed
                  $      # that is all there is
                 /x;
    printf &quot;Largest sequence matched was %d\n&quot;, length($z1)-length($z0);
</pre>
<p class="Pp">Remember that <span class="Li">$^N</span> is set to whatever was
    matched by the last completed capture group. This prints</p>
<p class="Pp"></p>
<pre>    It is a Fibonacci sequence
    Largest sequence matched was 5
</pre>
<p class="Pp">Ha! Try that with your garden variety regexp package...</p>
<p class="Pp">Note that the variables <span class="Li">$z0</span> and
    <span class="Li">$z1</span> are not substituted when the regexp is compiled,
    as happens for ordinary variables outside a code expression. Rather, the
    whole code block is parsed as perl code at the same time as perl is
    compiling the code containing the literal regexp pattern.</p>
<p class="Pp">This regexp without the <span class="Li">&quot;/x&quot;</span>
    modifier is</p>
<p class="Pp"></p>
<pre>    /^1(?:((??{ $z0 }))1(?{ $z0 = $z1; $z1 .= $^N; }))+$/
</pre>
<p class="Pp">which shows that spaces are still possible in the code parts.
    Nevertheless, when working with code and conditional expressions, the
    extended form of regexps is almost necessary in creating and debugging
    regexps.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Backtracking_control_verbs"><a class="permalink" href="#Backtracking_control_verbs">Backtracking
  control verbs</a></h2>
<p class="Pp">Perl 5.10 introduced a number of control verbs intended to provide
    detailed control over the backtracking process, by directly influencing the
    regexp engine and by providing monitoring techniques. See &quot;Special
    Backtracking Control Verbs&quot; in perlre for a detailed description.</p>
<p class="Pp">Below is just one example, illustrating the control verb
    <span class="Li">&quot;(*FAIL)&quot;</span>, which may be abbreviated as
    <span class="Li">&quot;(*F)&quot;</span>. If this is inserted in a regexp it
    will cause it to fail, just as it would at some mismatch between the pattern
    and the string. Processing of the regexp continues as it would after any
    &quot;normal&quot; failure, so that, for instance, the next position in the
    string or another alternative will be tried. As failing to match doesn't
    preserve capture groups or produce results, it may be necessary to use this
    in combination with embedded code.</p>
<p class="Pp"></p>
<pre>   %count = ();
   &quot;supercalifragilisticexpialidocious&quot; =~
       /([aeiou])(?{ $count{$1}++; })(*FAIL)/i;
   printf &quot;%3d '%s'\n&quot;, $count{$_}, $_ for (sort keys %count);
</pre>
<p class="Pp">The pattern begins with a class matching a subset of letters.
    Whenever this matches, a statement like
    <span class="Li">&quot;$count{'a'}++;&quot;</span> is executed, incrementing
    the letter's counter. Then <span class="Li">&quot;(*FAIL)&quot;</span> does
    what it says, and the regexp engine proceeds according to the book: as long
    as the end of the string hasn't been reached, the position is advanced
    before looking for another vowel. Thus, match or no match makes no
    difference, and the regexp engine proceeds until the entire string has been
    inspected. (It's remarkable that an alternative solution using something
    like</p>
<p class="Pp"></p>
<pre>   $count{lc($_)}++ for split('', &quot;supercalifragilisticexpialidocious&quot;);
   printf &quot;%3d '%s'\n&quot;, $count2{$_}, $_ for ( qw{ a e i o u } );
</pre>
<p class="Pp">is considerably slower.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Pragmas_and_debugging"><a class="permalink" href="#Pragmas_and_debugging">Pragmas
  and debugging</a></h2>
<p class="Pp">Speaking of debugging, there are several pragmas available to
    control and debug regexps in Perl. We have already encountered one pragma in
    the previous section,
    <span class="Li">&quot;use&#x00A0;re&#x00A0;'eval';&quot;</span>, that
    allows variable interpolation and code expressions to coexist in a regexp.
    The other pragmas are</p>
<p class="Pp"></p>
<pre>    use re 'taint';
    $tainted = &lt;&gt;;
    @parts = ($tainted =~ /(\w+)\s+(\w+)/; # @parts is now tainted
</pre>
<p class="Pp">The <span class="Li">&quot;taint&quot;</span> pragma causes any
    substrings from a match with a tainted variable to be tainted as well. This
    is not normally the case, as regexps are often used to extract the safe bits
    from a tainted variable. Use <span class="Li">&quot;taint&quot;</span> when
    you are not extracting safe bits, but are performing some other processing.
    Both <span class="Li">&quot;taint&quot;</span> and
    <span class="Li">&quot;eval&quot;</span> pragmas are lexically scoped, which
    means they are in effect only until the end of the block enclosing the
    pragmas.</p>
<p class="Pp"></p>
<pre>    use re '/m';  # or any other flags
    $multiline_string =~ /^foo/; # /m is implied
</pre>
<p class="Pp">The <span class="Li">&quot;re '/flags'&quot;</span> pragma
    (introduced in Perl 5.14) turns on the given regular expression flags until
    the end of the lexical scope. See &quot;'/flags' mode&quot; in re for more
    detail.</p>
<p class="Pp"></p>
<pre>    use re 'debug';
    /^(.*)$/s;       # output debugging info
    use re 'debugcolor';
    /^(.*)$/s;       # output debugging info in living color
</pre>
<p class="Pp">The global <span class="Li">&quot;debug&quot;</span> and
    <span class="Li">&quot;debugcolor&quot;</span> pragmas allow one to get
    detailed debugging info about regexp compilation and execution.
    <span class="Li">&quot;debugcolor&quot;</span> is the same as debug, except
    the debugging information is displayed in color on terminals that can
    display termcap color sequences. Here is example output:</p>
<p class="Pp"></p>
<pre>    % perl -e 'use re &quot;debug&quot;; &quot;abc&quot; =~ /a*b+c/;'
    Compiling REx 'a*b+c'
    size 9 first at 1
       1: STAR(4)
       2:   EXACT &lt;a&gt;(0)
       4: PLUS(7)
       5:   EXACT &lt;b&gt;(0)
       7: EXACT &lt;c&gt;(9)
       9: END(0)
    floating 'bc' at 0..2147483647 (checking floating) minlen 2
    Guessing start of match, REx 'a*b+c' against 'abc'...
    Found floating substr 'bc' at offset 1...
    Guessed: match at offset 0
    Matching REx 'a*b+c' against 'abc'
      Setting an EVAL scope, savestack=3
       0 &lt;&gt; &lt;abc&gt;           |  1:  STAR
                             EXACT &lt;a&gt; can match 1 times out of 32767...
      Setting an EVAL scope, savestack=3
       1 &lt;a&gt; &lt;bc&gt;           |  4:    PLUS
                             EXACT &lt;b&gt; can match 1 times out of 32767...
      Setting an EVAL scope, savestack=3
       2 &lt;ab&gt; &lt;c&gt;           |  7:      EXACT &lt;c&gt;
       3 &lt;abc&gt; &lt;&gt;           |  9:      END
    Match successful!
    Freeing REx: 'a*b+c'
</pre>
<p class="Pp">If you have gotten this far into the tutorial, you can probably
    guess what the different parts of the debugging output tell you. The first
    part</p>
<p class="Pp"></p>
<pre>    Compiling REx 'a*b+c'
    size 9 first at 1
       1: STAR(4)
       2:   EXACT &lt;a&gt;(0)
       4: PLUS(7)
       5:   EXACT &lt;b&gt;(0)
       7: EXACT &lt;c&gt;(9)
       9: END(0)
</pre>
<p class="Pp">describes the compilation stage. <span class="Li">STAR(4)</span>
    means that there is a starred object, in this case
    <span class="Li">'a'</span>, and if it matches, goto line 4, <i>i.e.</i>,
    <span class="Li">PLUS(7)</span>. The middle lines describe some heuristics
    and optimizations performed before a match:</p>
<p class="Pp"></p>
<pre>    floating 'bc' at 0..2147483647 (checking floating) minlen 2
    Guessing start of match, REx 'a*b+c' against 'abc'...
    Found floating substr 'bc' at offset 1...
    Guessed: match at offset 0
</pre>
<p class="Pp">Then the match is executed and the remaining lines describe the
    process:</p>
<p class="Pp"></p>
<pre>    Matching REx 'a*b+c' against 'abc'
      Setting an EVAL scope, savestack=3
       0 &lt;&gt; &lt;abc&gt;           |  1:  STAR
                             EXACT &lt;a&gt; can match 1 times out of 32767...
      Setting an EVAL scope, savestack=3
       1 &lt;a&gt; &lt;bc&gt;           |  4:    PLUS
                             EXACT &lt;b&gt; can match 1 times out of 32767...
      Setting an EVAL scope, savestack=3
       2 &lt;ab&gt; &lt;c&gt;           |  7:      EXACT &lt;c&gt;
       3 &lt;abc&gt; &lt;&gt;           |  9:      END
    Match successful!
    Freeing REx: 'a*b+c'
</pre>
<p class="Pp">Each step is of the form
    <span class="Li">&quot;n&#x00A0;&lt;x&gt;&#x00A0;&lt;y&gt;&quot;</span>,
    with <span class="Li">&quot;&lt;x&gt;&quot;</span> the part of the string
    matched and <span class="Li">&quot;&lt;y&gt;&quot;</span> the part not yet
    matched. The
    <span class="Li">&quot;|&#x00A0;&#x00A0;1:&#x00A0;&#x00A0;STAR&quot;</span>
    says that Perl is at line number 1 in the compilation list above. See
    &quot;Debugging Regular Expressions&quot; in perldebguts for much more
    detail.</p>
<p class="Pp">An alternative method of debugging regexps is to embed
    <span class="Li">&quot;print&quot;</span> statements within the regexp. This
    provides a blow-by-blow account of the backtracking in an alternation:</p>
<p class="Pp"></p>
<pre>    &quot;that this&quot; =~ m@(?{print &quot;Start at position &quot;, pos, &quot;\n&quot;;})
                     t(?{print &quot;t1\n&quot;;})
                     h(?{print &quot;h1\n&quot;;})
                     i(?{print &quot;i1\n&quot;;})
                     s(?{print &quot;s1\n&quot;;})
                         |
                     t(?{print &quot;t2\n&quot;;})
                     h(?{print &quot;h2\n&quot;;})
                     a(?{print &quot;a2\n&quot;;})
                     t(?{print &quot;t2\n&quot;;})
                     (?{print &quot;Done at position &quot;, pos, &quot;\n&quot;;})
                    @x;
</pre>
<p class="Pp">prints</p>
<p class="Pp"></p>
<pre>    Start at position 0
    t1
    h1
    t2
    h2
    a2
    t2
    Done at position 4
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">This is just a tutorial. For the full story on Perl regular
    expressions, see the perlre regular expressions reference page.</p>
<p class="Pp">For more information on the matching
    <span class="Li">&quot;m//&quot;</span> and substitution
    <span class="Li">&quot;s///&quot;</span> operators, see &quot;Regexp
    Quote-Like Operators&quot; in perlop. For information on the
    <span class="Li">&quot;split&quot;</span> operation, see &quot;split&quot;
    in perlfunc.</p>
<p class="Pp">For an excellent all-around resource on the care and feeding of
    regular expressions, see the book <i>Mastering Regular Expressions</i> by
    Jeffrey Friedl (published by O'Reilly, ISBN 1556592-257-3).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR_AND_COPYRIGHT"><a class="permalink" href="#AUTHOR_AND_COPYRIGHT">AUTHOR
  AND COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 2000 Mark Kvale. All rights reserved. Now maintained
    by Perl porters.</p>
<p class="Pp">This document may be distributed under the same terms as Perl
    itself.</p>
<section class="Ss">
<h2 class="Ss" id="Acknowledgments"><a class="permalink" href="#Acknowledgments">Acknowledgments</a></h2>
<p class="Pp">The inspiration for the stop codon DNA example came from the ZIP
    code example in chapter 7 of <i>Mastering Regular Expressions</i>.</p>
<p class="Pp">The author would like to thank Jeff Pinyan, Andrew Johnson, Peter
    Haworth, Ronald J Kimball, and Joe Smith for all their helpful comments.</p>
</section>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

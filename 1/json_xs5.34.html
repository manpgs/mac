<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>JSON_XS(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">JSON_XS(1)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">JSON_XS(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">json_xs - JSON::XS commandline utility</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>   json_xs [-v] [-f inputformat] [-t outputformat]
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><i>json_xs</i> converts between some input and output formats (one
    of them is JSON).</p>
<p class="Pp">The default input format is
    <span class="Li">&quot;json&quot;</span> and the default output format is
    <span class="Li">&quot;json-pretty&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OPTIONS"><a class="permalink" href="#OPTIONS">OPTIONS</a></h1>
<dl class="Bl-tag">
  <dt id="v"><a class="permalink" href="#v">-v</a></dt>
  <dd>Be slightly more verbose.</dd>
  <dt id="f"><a class="permalink" href="#f">-f fromformat</a></dt>
  <dd>Read a file in the given format from STDIN.
    <p class="Pp"><span class="Li">&quot;fromformat&quot;</span> can be one
      of:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="json"><a class="permalink" href="#json">json - a json text encoded,
    either utf-8, utf16-be/le, utf32-be/le</a></dt>
  <dd></dd>
  <dt id="cbor"><a class="permalink" href="#cbor">cbor - CBOR (RFC 7049,
    CBOR::XS), a kind of binary JSON</a></dt>
  <dd></dd>
  <dt id="storable"><a class="permalink" href="#storable">storable - a Storable
    frozen value</a></dt>
  <dd></dd>
  <dt id="storable-file"><a class="permalink" href="#storable-file">storable-file
    - a Storable file (Storable has two incompatible formats)</a></dt>
  <dd></dd>
  <dt id="bencode"><a class="permalink" href="#bencode">bencode - use
    Convert::Bencode, if available (used by torrent files, among
    others)</a></dt>
  <dd></dd>
  <dt id="clzf"><a class="permalink" href="#clzf">clzf - Compress::LZF format
    (requires that module to be installed)</a></dt>
  <dd></dd>
  <dt id="eval"><a class="permalink" href="#eval">eval - evaluate the given code
    as (non-utf-8) Perl, basically the reverse of &quot;-t dump&quot;</a></dt>
  <dd></dd>
  <dt id="yaml"><a class="permalink" href="#yaml">yaml - YAML format (requires
    that module to be installed)</a></dt>
  <dd></dd>
  <dt id="string"><a class="permalink" href="#string">string - do not attempt to
    decode the file data</a></dt>
  <dd></dd>
  <dt id="none"><a class="permalink" href="#none">none - nothing is read,
    creates an &quot;undef&quot; scalar - mainly useful with
    &quot;-e&quot;</a></dt>
  <dd></dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="t"><a class="permalink" href="#t">-t toformat</a></dt>
  <dd>Write the file in the given format to STDOUT.
    <p class="Pp"><span class="Li">&quot;toformat&quot;</span> can be one
      of:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="json,"><a class="permalink" href="#json,">json, json-utf-8 - json,
    utf-8 encoded</a></dt>
  <dd></dd>
  <dt id="json-pretty"><a class="permalink" href="#json-pretty">json-pretty - as
    above, but pretty-printed</a></dt>
  <dd></dd>
  <dt id="json~2"><a class="permalink" href="#json~2">json-utf-16le,
    json-utf-16be - little endian/big endian utf-16</a></dt>
  <dd></dd>
  <dt id="json~3"><a class="permalink" href="#json~3">json-utf-32le,
    json-utf-32be - little endian/big endian utf-32</a></dt>
  <dd></dd>
  <dt id="cbor~2"><a class="permalink" href="#cbor~2">cbor - CBOR (RFC 7049,
    CBOR::XS), a kind of binary JSON</a></dt>
  <dd></dd>
  <dt id="cbor-packed"><a class="permalink" href="#cbor-packed">cbor-packed -
    CBOR using extensions to make it smaller</a></dt>
  <dd></dd>
  <dt id="storable~2"><a class="permalink" href="#storable~2">storable - a
    Storable frozen value in network format</a></dt>
  <dd></dd>
  <dt id="storable-file~2"><a class="permalink" href="#storable-file~2">storable-file
    - a Storable file in network format (Storable has two incompatible
    formats)</a></dt>
  <dd></dd>
  <dt id="bencode~2"><a class="permalink" href="#bencode~2">bencode - use
    Convert::Bencode, if available (used by torrent files, among
    others)</a></dt>
  <dd></dd>
  <dt id="clzf~2"><a class="permalink" href="#clzf~2">clzf - Compress::LZF
    format</a></dt>
  <dd></dd>
  <dt id="yaml~2"><a class="permalink" href="#yaml~2">yaml - YAML::XS
    format</a></dt>
  <dd></dd>
  <dt id="dump"><a class="permalink" href="#dump">dump - Data::Dump</a></dt>
  <dd></dd>
  <dt id="dumper"><a class="permalink" href="#dumper">dumper -
    Data::Dumper</a></dt>
  <dd></dd>
  <dt id="string~2"><a class="permalink" href="#string~2">string - writes the
    data out as if it were a string</a></dt>
  <dd></dd>
  <dt id="none~2"><a class="permalink" href="#none~2">none - nothing gets
    written, mainly useful together with &quot;-e&quot;</a></dt>
  <dd>Note that Data::Dumper doesn't handle self-referential data structures
      correctly - use &quot;dump&quot; instead.</dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="e"><a class="permalink" href="#e">-e code</a></dt>
  <dd>Evaluate perl code after reading the data and before writing it out again
      - can be used to filter, create or extract data. The data that has been
      written is in <span class="Li">$_</span>, and whatever is in there is
      written out afterwards.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<pre>   json_xs -t none &lt;isitreally.json
</pre>
<p class="Pp">&quot;JSON Lint&quot; - tries to parse the file
    <i>isitreally.json</i> as JSON - if it is valid JSON, the command outputs
    nothing, otherwise it will print an error message and exit with non-zero
    exit status.</p>
<p class="Pp"></p>
<pre>   &lt;src.json json_xs &gt;pretty.json
</pre>
<p class="Pp">Prettify the JSON file <i>src.json</i> to <i>dst.json</i>.</p>
<p class="Pp"></p>
<pre>   json_xs -f storable-file &lt;file
</pre>
<p class="Pp">Read the serialised Storable file <i>file</i> and print a
    human-readable JSON version of it to STDOUT.</p>
<p class="Pp"></p>
<pre>   json_xs -f storable-file -t yaml &lt;file
</pre>
<p class="Pp">Same as above, but write YAML instead (not using JSON at all
  :)</p>
<p class="Pp"></p>
<pre>   json_xs -f none -e '$_ = [1, 2, 3]'
</pre>
<p class="Pp">Dump the perl array as UTF-8 encoded JSON text.</p>
<p class="Pp"></p>
<pre>   &lt;torrentfile json_xs -f bencode -e '$_ = join &quot;\n&quot;, map @$_, @{$_-&gt;{&quot;announce-list&quot;}}' -t string
</pre>
<p class="Pp">Print the tracker list inside a torrent file.</p>
<p class="Pp"></p>
<pre>   lwp-request http://cpantesters.perl.org/show/JSON-XS.json | json_xs
</pre>
<p class="Pp">Fetch the cpan-testers result summary
    <span class="Li">&quot;JSON::XS&quot;</span> and pretty-print it.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Copyright (C) 2008 Marc Lehmann &lt;json@schmorp.de&gt;</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-11-15</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

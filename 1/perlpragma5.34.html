<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PERLPRAGMA(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLPRAGMA(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLPRAGMA(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlpragma - how to write a user pragma</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">A pragma is a module which influences some aspect of the compile
    time or run time behaviour of Perl, such as
    <span class="Li">&quot;strict&quot;</span> or
    <span class="Li">&quot;warnings&quot;</span>. With Perl 5.10 you are no
    longer limited to the built in pragmata; you can now create user pragmata
    that modify the behaviour of user functions within a lexical scope.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="A_basic_example"><a class="permalink" href="#A_basic_example">A
  basic example</a></h1>
<p class="Pp">For example, say you need to create a class implementing
    overloaded mathematical operators, and would like to provide your own pragma
    that functions much like <span class="Li">&quot;use integer;&quot;</span>
    You'd like this code</p>
<p class="Pp"></p>
<pre>    use MyMaths;
    my $l = MyMaths-&gt;new(1.2);
    my $r = MyMaths-&gt;new(3.4);
    print &quot;A: &quot;, $l + $r, &quot;\n&quot;;
    use myint;
    print &quot;B: &quot;, $l + $r, &quot;\n&quot;;
    {
        no myint;
        print &quot;C: &quot;, $l + $r, &quot;\n&quot;;
    }
    print &quot;D: &quot;, $l + $r, &quot;\n&quot;;
    no myint;
    print &quot;E: &quot;, $l + $r, &quot;\n&quot;;
</pre>
<p class="Pp">to give the output</p>
<p class="Pp"></p>
<pre>    A: 4.6
    B: 4
    C: 4.6
    D: 4
    E: 4.6
</pre>
<p class="Pp"><i>i.e.</i>, where <span class="Li">&quot;use myint;&quot;</span>
    is in effect, addition operations are forced to integer, whereas by default
    they are not, with the default behaviour being restored via
    <span class="Li">&quot;no myint;&quot;</span></p>
<p class="Pp">The minimal implementation of the package
    <span class="Li">&quot;MyMaths&quot;</span> would be something like
  this:</p>
<p class="Pp"></p>
<pre>    package MyMaths;
    use warnings;
    use strict;
    use myint();
    use overload '+' =&gt; sub {
        my ($l, $r) = @_;
        # Pass 1 to check up one call level from here
        if (myint::in_effect(1)) {
            int($$l) + int($$r);
        } else {
            $$l + $$r;
        }
    };
    sub new {
        my ($class, $value) = @_;
        bless \$value, $class;
    }
    1;
</pre>
<p class="Pp">Note how we load the user pragma
    <span class="Li">&quot;myint&quot;</span> with an empty list
    <span class="Li">&quot;()&quot;</span> to prevent its
    <span class="Li">&quot;import&quot;</span> being called.</p>
<p class="Pp">The interaction with the Perl compilation happens inside package
    <span class="Li">&quot;myint&quot;</span>:</p>
<p class="Pp"></p>
<pre>    package myint;
    use strict;
    use warnings;
    sub import {
        $^H{&quot;myint/in_effect&quot;} = 1;
    }
    sub unimport {
        $^H{&quot;myint/in_effect&quot;} = 0;
    }
    sub in_effect {
        my $level = shift // 0;
        my $hinthash = (caller($level))[10];
        return $hinthash-&gt;{&quot;myint/in_effect&quot;};
    }
    1;
</pre>
<p class="Pp">As pragmata are implemented as modules, like any other module,
    <span class="Li">&quot;use myint;&quot;</span> becomes</p>
<p class="Pp"></p>
<pre>    BEGIN {
        require myint;
        myint-&gt;import();
    }
</pre>
<p class="Pp">and <span class="Li">&quot;no myint;&quot;</span> is</p>
<p class="Pp"></p>
<pre>    BEGIN {
        require myint;
        myint-&gt;unimport();
    }
</pre>
<p class="Pp">Hence the <span class="Li">&quot;import&quot;</span> and
    <span class="Li">&quot;unimport&quot;</span> routines are called at
    <b>compile time</b> for the user's code.</p>
<p class="Pp">User pragmata store their state by writing to the magical hash
    <span class="Li">&quot;%^H&quot;</span>, hence these two routines manipulate
    it. The state information in <span class="Li">&quot;%^H&quot;</span> is
    stored in the optree, and can be retrieved read-only at runtime with
    <span class="Li">&quot;caller()&quot;</span>, at index 10 of the list of
    returned results. In the example pragma, retrieval is encapsulated into the
    routine <span class="Li">&quot;in_effect()&quot;</span>, which takes as
    parameter the number of call frames to go up to find the value of the pragma
    in the user's script. This uses <span class="Li">&quot;caller()&quot;</span>
    to determine the value of
    <span class="Li">$^H{&quot;myint/in_effect&quot;}</span> when each line of
    the user's script was called, and therefore provide the correct semantics in
    the subroutine implementing the overloaded addition.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Key_naming"><a class="permalink" href="#Key_naming">Key
  naming</a></h1>
<p class="Pp">There is only a single <span class="Li">&quot;%^H&quot;</span>,
    but arbitrarily many modules that want to use its scoping semantics. To
    avoid stepping on each other's toes, they need to be sure to use different
    keys in the hash. It is therefore conventional for a module to use only keys
    that begin with the module's name (the name of its main package) and a
    &quot;/&quot; character. After this module-identifying prefix, the rest of
    the key is entirely up to the module: it may include any characters
    whatsoever. For example, a module
    <span class="Li">&quot;Foo::Bar&quot;</span> should use keys such as
    <span class="Li">&quot;Foo::Bar/baz&quot;</span> and
    <span class="Li">&quot;Foo::Bar/$%/_!&quot;</span>. Modules following this
    convention all play nicely with each other.</p>
<p class="Pp">The Perl core uses a handful of keys in
    <span class="Li">&quot;%^H&quot;</span> which do not follow this convention,
    because they predate it. Keys that follow the convention won't conflict with
    the core's historical keys.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Implementation_details"><a class="permalink" href="#Implementation_details">Implementation
  details</a></h1>
<p class="Pp">The optree is shared between threads. This means there is a
    possibility that the optree will outlive the particular thread (and
    therefore the interpreter instance) that created it, so true Perl scalars
    cannot be stored in the optree. Instead a compact form is used, which can
    only store values that are integers (signed and unsigned), strings or
    <span class="Li">&quot;undef&quot;</span> - references and floating point
    values are stringified. If you need to store multiple values or complex
    structures, you should serialise them, for example with
    <span class="Li">&quot;pack&quot;</span>. The deletion of a hash key from
    <span class="Li">&quot;%^H&quot;</span> is recorded, and as ever can be
    distinguished from the existence of a key with value
    <span class="Li">&quot;undef&quot;</span> with
    <span class="Li">&quot;exists&quot;</span>.</p>
<p class="Pp"><b>Don't</b> attempt to store references to data structures as
    integers which are retrieved via <span class="Li">&quot;caller&quot;</span>
    and converted back, as this will not be threadsafe. Accesses would be to the
    structure without locking (which is not safe for Perl's scalars), and either
    the structure has to leak, or it has to be freed when its creating thread
    terminates, which may be before the optree referencing it is deleted, if
    other threads outlive it.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os">perl v5.34.1</td>
  </tr>
</table>
</body>
</html>

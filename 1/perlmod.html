<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PERLMOD(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLMOD(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLMOD(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlmod - Perl modules (packages and symbol tables)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<section class="Ss">
<h2 class="Ss" id="Is_this_the_document_you_were_after?"><a class="permalink" href="#Is_this_the_document_you_were_after?">Is
  this the document you were after?</a></h2>
<p class="Pp">There are other documents which might contain the information that
    you're looking for:</p>
<dl class="Bl-tag">
  <dt id="This"><a class="permalink" href="#This">This doc</a></dt>
  <dd>Perl's packages, namespaces, and some info on classes.</dd>
  <dt id="perlnewmod"><a class="permalink" href="#perlnewmod">perlnewmod</a></dt>
  <dd>Tutorial on making a new module.</dd>
  <dt id="perlmodstyle"><a class="permalink" href="#perlmodstyle">perlmodstyle</a></dt>
  <dd>Best practices for making a new module.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Packages"><a class="permalink" href="#Packages">Packages</a></h2>
<p class="Pp">Unlike Perl 4, in which all the variables were dynamic and shared
    one global name space, causing maintainability problems, Perl 5 provides two
    mechanisms for protecting code from having its variables stomped on by other
    code: lexically scoped variables created with
    <span class="Li">&quot;my&quot;</span> or
    <span class="Li">&quot;state&quot;</span> and namespaced global variables,
    which are exposed via the <span class="Li">&quot;vars&quot;</span> pragma,
    or the <span class="Li">&quot;our&quot;</span> keyword. Any global variable
    is considered to be part of a namespace and can be accessed via a
    &quot;fully qualified form&quot;. Conversely, any lexically scoped variable
    is considered to be part of that lexical-scope, and does not have a
    &quot;fully qualified form&quot;.</p>
<p class="Pp">In perl namespaces are called &quot;packages&quot; and the
    <span class="Li">&quot;package&quot;</span> declaration tells the compiler
    which namespace to prefix to <span class="Li">&quot;our&quot;</span>
    variables and unqualified dynamic names. This both protects against
    accidental stomping and provides an interface for deliberately clobbering
    global dynamic variables declared and used in other scopes or packages, when
    that is what you want to do.</p>
<p class="Pp">The scope of the <span class="Li">&quot;package&quot;</span>
    declaration is from the declaration itself through the end of the enclosing
    block, <span class="Li">&quot;eval&quot;</span>, or file, whichever comes
    first (the same scope as the <b>my()</b>, <b>our()</b>, <b>state()</b>, and
    <b>local()</b> operators, and also the effect of the experimental
    &quot;reference aliasing,&quot; which may change), or until the next
    <span class="Li">&quot;package&quot;</span> declaration. Unqualified dynamic
    identifiers will be in this namespace, except for those few identifiers
    that, if unqualified, default to the main package instead of the current one
    as described below. A <span class="Li">&quot;package&quot;</span> statement
    affects only dynamic global symbols, including subroutine names, and
    variables you've used <b>local()</b> on, but <i>not</i> lexical variables
    created with <b>my()</b>, <b>our()</b> or <b>state()</b>.</p>
<p class="Pp">Typically, a <span class="Li">&quot;package&quot;</span> statement
    is the first declaration in a file included in a program by one of the
    <span class="Li">&quot;do&quot;</span>,
    <span class="Li">&quot;require&quot;</span>, or
    <span class="Li">&quot;use&quot;</span> operators. You can switch into a
    package in more than one place: <span class="Li">&quot;package&quot;</span>
    has no effect beyond specifying which symbol table the compiler will use for
    dynamic symbols for the rest of that block or until the next
    <span class="Li">&quot;package&quot;</span> statement. You can refer to
    variables and filehandles in other packages by prefixing the identifier with
    the package name and a double colon:
    <span class="Li">$Package::Variable</span>. If the package name is null, the
    <span class="Li">&quot;main&quot;</span> package is assumed. That is,
    <span class="Li">$::sail</span> is equivalent to
    <span class="Li">$main::sail</span>.</p>
<p class="Pp">The old package delimiter was a single quote, but double colon is
    now the preferred delimiter, in part because it's more readable to humans,
    and in part because it's more readable to <b>emacs</b> macros. It also makes
    C++ programmers feel like they know what's going on--as opposed to using the
    single quote as separator, which was there to make Ada programmers feel like
    they knew what was going on. Because the old-fashioned syntax is still
    supported for backwards compatibility, if you try to use a string like
    <span class="Li">&quot;This is $owner's house&quot;</span>, you'll be
    accessing <span class="Li">$owner::s</span>; that is, the
    <span class="Li">$s</span> variable in package
    <span class="Li">&quot;owner&quot;</span>, which is probably not what you
    meant. Use braces to disambiguate, as in <span class="Li">&quot;This is
    ${owner}'s house&quot;</span>.</p>
<p class="Pp">Packages may themselves contain package separators, as in
    <span class="Li">$OUTER::INNER::var</span>. This implies nothing about the
    order of name lookups, however. There are no relative packages: all symbols
    are either local to the current package, or must be fully qualified from the
    outer package name down. For instance, there is nowhere within package
    <span class="Li">&quot;OUTER&quot;</span> that
    <span class="Li">$INNER::var</span> refers to
    <span class="Li">$OUTER::INNER::var</span>.
    <span class="Li">&quot;INNER&quot;</span> refers to a totally separate
    global package. The custom of treating package names as a hierarchy is very
    strong, but the language in no way enforces it.</p>
<p class="Pp">Only identifiers starting with letters (or underscore) are stored
    in a package's symbol table. All other symbols are kept in package
    <span class="Li">&quot;main&quot;</span>, including all punctuation
    variables, like <span class="Li">$_</span>. In addition, when unqualified,
    the identifiers STDIN, STDOUT, STDERR, ARGV, ARGVOUT, ENV, INC, and SIG are
    forced to be in package <span class="Li">&quot;main&quot;</span>, even when
    used for other purposes than their built-in ones. If you have a package
    called <span class="Li">&quot;m&quot;</span>,
    <span class="Li">&quot;s&quot;</span>, or
    <span class="Li">&quot;y&quot;</span>, then you can't use the qualified form
    of an identifier because it would be instead interpreted as a pattern match,
    a substitution, or a transliteration.</p>
<p class="Pp">Variables beginning with underscore used to be forced into package
    main, but we decided it was more useful for package writers to be able to
    use leading underscore to indicate private variables and method names.
    However, variables and functions named with a single
    <span class="Li">&quot;_&quot;</span>, such as <span class="Li">$_</span>
    and <span class="Li">&quot;sub _&quot;</span>, are still forced into the
    package <span class="Li">&quot;main&quot;</span>. See also &quot;The Syntax
    of Variable Names&quot; in perlvar.</p>
<p class="Pp"><span class="Li">&quot;eval&quot;</span>ed strings are compiled in
    the package in which the <b>eval()</b> was compiled. (Assignments to
    <span class="Li">$SIG{}</span>, however, assume the signal handler specified
    is in the <span class="Li">&quot;main&quot;</span> package. Qualify the
    signal handler name if you wish to have a signal handler in a package.) For
    an example, examine <i>perldb.pl</i> in the Perl library. It initially
    switches to the <span class="Li">&quot;DB&quot;</span> package so that the
    debugger doesn't interfere with variables in the program you are trying to
    debug. At various points, however, it temporarily switches back to the
    <span class="Li">&quot;main&quot;</span> package to evaluate various
    expressions in the context of the <span class="Li">&quot;main&quot;</span>
    package (or wherever you came from). See perldebug.</p>
<p class="Pp">The special symbol <span class="Li">&quot;__PACKAGE__&quot;</span>
    contains the current package, but cannot (easily) be used to construct
    variable names. After <span class="Li">&quot;my($foo)&quot;</span> has
    hidden package variable <span class="Li">$foo</span>, it can still be
    accessed, without knowing what package you are in, as
    <span class="Li">&quot;${__PACKAGE__.'::foo'}&quot;</span>.</p>
<p class="Pp">See perlsub for other scoping issues related to <b>my()</b> and
    <b>local()</b>, and perlref regarding closures.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Symbol_Tables"><a class="permalink" href="#Symbol_Tables">Symbol
  Tables</a></h2>
<p class="Pp">The symbol table for a package happens to be stored in the hash of
    that name with two colons appended. The main symbol table's name is thus
    <span class="Li">%main::</span>, or <span class="Li">%::</span> for short.
    Likewise the symbol table for the nested package mentioned earlier is named
    <span class="Li">%OUTER::INNER::</span>.</p>
<p class="Pp">The value in each entry of the hash is what you are referring to
    when you use the <span class="Li">*name</span> typeglob notation.</p>
<p class="Pp"></p>
<pre>    local *main::foo    = *main::bar;
</pre>
<p class="Pp">You can use this to print out all the variables in a package, for
    instance. The standard but antiquated <i>dumpvar.pl</i> library and the CPAN
    module Devel::Symdump make use of this.</p>
<p class="Pp">The results of creating new symbol table entries directly or
    modifying any entries that are not already typeglobs are undefined and
    subject to change between releases of perl.</p>
<p class="Pp">Assignment to a typeglob performs an aliasing operation, i.e.,</p>
<p class="Pp"></p>
<pre>    *dick = *richard;
</pre>
<p class="Pp">causes variables, subroutines, formats, and file and directory
    handles accessible via the identifier
    <span class="Li">&quot;richard&quot;</span> also to be accessible via the
    identifier <span class="Li">&quot;dick&quot;</span>. If you want to alias
    only a particular variable or subroutine, assign a reference instead:</p>
<p class="Pp"></p>
<pre>    *dick = \$richard;
</pre>
<p class="Pp">Which makes <span class="Li">$richard</span> and
    <span class="Li">$dick</span> the same variable, but leaves
    <span class="Li">@richard</span> and <span class="Li">@dick</span> as
    separate arrays. Tricky, eh?</p>
<p class="Pp">There is one subtle difference between the following
  statements:</p>
<p class="Pp"></p>
<pre>    *foo = *bar;
    *foo = \$bar;
</pre>
<p class="Pp"><span class="Li">&quot;*foo = *bar&quot;</span> makes the
    typeglobs themselves synonymous while <span class="Li">&quot;*foo =
    \$bar&quot;</span> makes the SCALAR portions of two distinct typeglobs refer
    to the same scalar value. This means that the following code:</p>
<p class="Pp"></p>
<pre>    $bar = 1;
    *foo = \$bar;       # Make $foo an alias for $bar
    {
        local $bar = 2; # Restrict changes to block
        print $foo;     # Prints '1'!
    }
</pre>
<p class="Pp">Would print '1', because <span class="Li">$foo</span> holds a
    reference to the <i>original</i> <span class="Li">$bar</span>. The one that
    was stuffed away by <span class="Li">&quot;local()&quot;</span> and which
    will be restored when the block ends. Because variables are accessed through
    the typeglob, you can use <span class="Li">&quot;*foo = *bar&quot;</span> to
    create an alias which can be localized. (But be aware that this means you
    can't have a separate <span class="Li">@foo</span> and
    <span class="Li">@bar</span>, etc.)</p>
<p class="Pp">What makes all of this important is that the Exporter module uses
    glob aliasing as the import/export mechanism. Whether or not you can
    properly localize a variable that has been exported from a module depends on
    how it was exported:</p>
<p class="Pp"></p>
<pre>    @EXPORT = qw($FOO); # Usual form, can't be localized
    @EXPORT = qw(*FOO); # Can be localized
</pre>
<p class="Pp">You can work around the first case by using the fully qualified
    name (<span class="Li">$Package::FOO</span>) where you need a local value,
    or by overriding it by saying <span class="Li">&quot;*FOO =
    *Package::FOO&quot;</span> in your script.</p>
<p class="Pp">The <span class="Li">&quot;*x = \$y&quot;</span> mechanism may be
    used to pass and return cheap references into or from subroutines if you
    don't want to copy the whole thing. It only works when assigning to dynamic
    variables, not lexicals.</p>
<p class="Pp"></p>
<pre>    %some_hash = ();                    # can't be my()
    *some_hash = fn( \%another_hash );
    sub fn {
        local *hashsym = shift;
        # now use %hashsym normally, and you
        # will affect the caller's %another_hash
        my %nhash = (); # do what you want
        return \%nhash;
    }
</pre>
<p class="Pp">On return, the reference will overwrite the hash slot in the
    symbol table specified by the *some_hash typeglob. This is a somewhat tricky
    way of passing around references cheaply when you don't want to have to
    remember to dereference variables explicitly.</p>
<p class="Pp">Another use of symbol tables is for making &quot;constant&quot;
    scalars.</p>
<p class="Pp"></p>
<pre>    *PI = \3.14159265358979;
</pre>
<p class="Pp">Now you cannot alter <span class="Li">$PI</span>, which is
    probably a good thing all in all. This isn't the same as a constant
    subroutine, which is subject to optimization at compile-time. A constant
    subroutine is one prototyped to take no arguments and to return a constant
    expression. See perlsub for details on these. The <span class="Li">&quot;use
    constant&quot;</span> pragma is a convenient shorthand for these.</p>
<p class="Pp">You can say <span class="Li">*foo{PACKAGE}</span> and
    <span class="Li">*foo{NAME}</span> to find out what name and package the
    *foo symbol table entry comes from. This may be useful in a subroutine that
    gets passed typeglobs as arguments:</p>
<p class="Pp"></p>
<pre>    sub identify_typeglob {
        my $glob = shift;
        print 'You gave me ', *{$glob}{PACKAGE},
            '::', *{$glob}{NAME}, &quot;\n&quot;;
    }
    identify_typeglob *foo;
    identify_typeglob *bar::baz;
</pre>
<p class="Pp">This prints</p>
<p class="Pp"></p>
<pre>    You gave me main::foo
    You gave me bar::baz
</pre>
<p class="Pp">The <span class="Li">*foo{THING}</span> notation can also be used
    to obtain references to the individual elements of *foo. See perlref.</p>
<p class="Pp">Subroutine definitions (and declarations, for that matter) need
    not necessarily be situated in the package whose symbol table they occupy.
    You can define a subroutine outside its package by explicitly qualifying the
    name of the subroutine:</p>
<p class="Pp"></p>
<pre>    package main;
    sub Some_package::foo { ... }   # &amp;foo defined in Some_package
</pre>
<p class="Pp">This is just a shorthand for a typeglob assignment at compile
    time:</p>
<p class="Pp"></p>
<pre>    BEGIN { *Some_package::foo = sub { ... } }
</pre>
<p class="Pp">and is <i>not</i> the same as writing:</p>
<p class="Pp"></p>
<pre>    {
        package Some_package;
        sub foo { ... }
    }
</pre>
<p class="Pp">In the first two versions, the body of the subroutine is lexically
    in the main package, <i>not</i> in Some_package. So something like this:</p>
<p class="Pp"></p>
<pre>    package main;
    $Some_package::name = &quot;fred&quot;;
    $main::name = &quot;barney&quot;;
    sub Some_package::foo {
        print &quot;in &quot;, __PACKAGE__, &quot;: \$name is '$name'\n&quot;;
    }
    Some_package::foo();
</pre>
<p class="Pp">prints:</p>
<p class="Pp"></p>
<pre>    in main: $name is 'barney'
</pre>
<p class="Pp">rather than:</p>
<p class="Pp"></p>
<pre>    in Some_package: $name is 'fred'
</pre>
<p class="Pp">This also has implications for the use of the SUPER:: qualifier
    (see perlobj).</p>
</section>
<section class="Ss">
<h2 class="Ss">BEGIN, UNITCHECK, CHECK, INIT and END</h2>
<p class="Pp">Five specially named code blocks are executed at the beginning and
    at the end of a running Perl program. These are the
    <span class="Li">&quot;BEGIN&quot;</span>,
    <span class="Li">&quot;UNITCHECK&quot;</span>,
    <span class="Li">&quot;CHECK&quot;</span>,
    <span class="Li">&quot;INIT&quot;</span>, and
    <span class="Li">&quot;END&quot;</span> blocks.</p>
<p class="Pp">These code blocks can be prefixed with
    <span class="Li">&quot;sub&quot;</span> to give the appearance of a
    subroutine (although this is not considered good style). One should note
    that these code blocks don't really exist as named subroutines (despite
    their appearance). The thing that gives this away is the fact that you can
    have <b>more than one</b> of these code blocks in a program, and they will
    get <b>all</b> executed at the appropriate moment. So you can't execute any
    of these code blocks by name.</p>
<p class="Pp">A <span class="Li">&quot;BEGIN&quot;</span> code block is executed
    as soon as possible, that is, the moment it is completely defined, even
    before the rest of the containing file (or string) is parsed. You may have
    multiple <span class="Li">&quot;BEGIN&quot;</span> blocks within a file (or
    eval'ed string); they will execute in order of definition. Because a
    <span class="Li">&quot;BEGIN&quot;</span> code block executes immediately,
    it can pull in definitions of subroutines and such from other files in time
    to be visible to the rest of the compile and run time. Once a
    <span class="Li">&quot;BEGIN&quot;</span> has run, it is immediately
    undefined and any code it used is returned to Perl's memory pool.</p>
<p class="Pp">An <span class="Li">&quot;END&quot;</span> code block is executed
    as late as possible, that is, after perl has finished running the program
    and just before the interpreter is being exited, even if it is exiting as a
    result of a <b>die()</b> function. (But not if it's morphing into another
    program via <span class="Li">&quot;exec&quot;</span>, or being blown out of
    the water by a signal--you have to trap that yourself (if you can).) You may
    have multiple <span class="Li">&quot;END&quot;</span> blocks within a
    file--they will execute in reverse order of definition; that is: last in,
    first out (LIFO). <span class="Li">&quot;END&quot;</span> blocks are not
    executed when you run perl with the <span class="Li">&quot;-c&quot;</span>
    switch, or if compilation fails.</p>
<p class="Pp">Note that <span class="Li">&quot;END&quot;</span> code blocks are
    <b>not</b> executed at the end of a string
    <span class="Li">&quot;eval()&quot;</span>: if any
    <span class="Li">&quot;END&quot;</span> code blocks are created in a string
    <span class="Li">&quot;eval()&quot;</span>, they will be executed just as
    any other <span class="Li">&quot;END&quot;</span> code block of that package
    in LIFO order just before the interpreter is being exited.</p>
<p class="Pp">Inside an <span class="Li">&quot;END&quot;</span> code block,
    <span class="Li">$?</span> contains the value that the program is going to
    pass to <span class="Li">&quot;exit()&quot;</span>. You can modify
    <span class="Li">$?</span> to change the exit value of the program. Beware
    of changing <span class="Li">$?</span> by accident (e.g. by running
    something via <span class="Li">&quot;system&quot;</span>).</p>
<p class="Pp">Inside of a <span class="Li">&quot;END&quot;</span> block, the
    value of <span class="Li">&quot;${^GLOBAL_PHASE}&quot;</span> will be
    <span class="Li">&quot;END&quot;</span>.</p>
<p class="Pp"><span class="Li">&quot;UNITCHECK&quot;</span>,
    <span class="Li">&quot;CHECK&quot;</span> and
    <span class="Li">&quot;INIT&quot;</span> code blocks are useful to catch the
    transition between the compilation phase and the execution phase of the main
    program.</p>
<p class="Pp"><span class="Li">&quot;UNITCHECK&quot;</span> blocks are run just
    after the unit which defined them has been compiled. The main program file
    and each module it loads are compilation units, as are string
    <span class="Li">&quot;eval&quot;</span>s, run-time code compiled using the
    <span class="Li">&quot;(?{ })&quot;</span> construct in a regex, calls to
    <span class="Li">&quot;do FILE&quot;</span>, <span class="Li">&quot;require
    FILE&quot;</span>, and code after the <span class="Li">&quot;-e&quot;</span>
    switch on the command line.</p>
<p class="Pp"><span class="Li">&quot;BEGIN&quot;</span> and
    <span class="Li">&quot;UNITCHECK&quot;</span> blocks are not directly
    related to the phase of the interpreter. They can be created and executed
    during any phase.</p>
<p class="Pp"><span class="Li">&quot;CHECK&quot;</span> code blocks are run just
    after the <b>initial</b> Perl compile phase ends and before the run time
    begins, in LIFO order. <span class="Li">&quot;CHECK&quot;</span> code blocks
    are used in the Perl compiler suite to save the compiled state of the
    program.</p>
<p class="Pp">Inside of a <span class="Li">&quot;CHECK&quot;</span> block, the
    value of <span class="Li">&quot;${^GLOBAL_PHASE}&quot;</span> will be
    <span class="Li">&quot;CHECK&quot;</span>.</p>
<p class="Pp"><span class="Li">&quot;INIT&quot;</span> blocks are run just
    before the Perl runtime begins execution, in &quot;first in, first out&quot;
    (FIFO) order.</p>
<p class="Pp">Inside of an <span class="Li">&quot;INIT&quot;</span> block, the
    value of <span class="Li">&quot;${^GLOBAL_PHASE}&quot;</span> will be
    <span class="Li">&quot;INIT&quot;</span>.</p>
<p class="Pp">The <span class="Li">&quot;CHECK&quot;</span> and
    <span class="Li">&quot;INIT&quot;</span> blocks in code compiled by
    <span class="Li">&quot;require&quot;</span>, string
    <span class="Li">&quot;do&quot;</span>, or string
    <span class="Li">&quot;eval&quot;</span> will not be executed if they occur
    after the end of the main compilation phase; that can be a problem in
    mod_perl and other persistent environments which use those functions to load
    code at runtime.</p>
<p class="Pp">When you use the <b>-n</b> and <b>-p</b> switches to Perl,
    <span class="Li">&quot;BEGIN&quot;</span> and
    <span class="Li">&quot;END&quot;</span> work just as they do in <b>awk</b>,
    as a degenerate case. Both <span class="Li">&quot;BEGIN&quot;</span> and
    <span class="Li">&quot;CHECK&quot;</span> blocks are run when you use the
    <b>-c</b> switch for a compile-only syntax check, although your main code is
    not.</p>
<p class="Pp">The <b>begincheck</b> program makes it all clear, eventually:</p>
<p class="Pp"></p>
<pre>  #!/usr/bin/perl
  # begincheck
  print         &quot;10. Ordinary code runs at runtime.\n&quot;;
  END { print   &quot;16.   So this is the end of the tale.\n&quot; }
  INIT { print  &quot; 7. INIT blocks run FIFO just before runtime.\n&quot; }
  UNITCHECK {
    print       &quot; 4.   And therefore before any CHECK blocks.\n&quot;
  }
  CHECK { print &quot; 6.   So this is the sixth line.\n&quot; }
  print         &quot;11.   It runs in order, of course.\n&quot;;
  BEGIN { print &quot; 1. BEGIN blocks run FIFO during compilation.\n&quot; }
  END { print   &quot;15.   Read perlmod for the rest of the story.\n&quot; }
  CHECK { print &quot; 5. CHECK blocks run LIFO after all compilation.\n&quot; }
  INIT { print  &quot; 8.   Run this again, using Perl's -c switch.\n&quot; }
  print         &quot;12.   This is anti-obfuscated code.\n&quot;;
  END { print   &quot;14. END blocks run LIFO at quitting time.\n&quot; }
  BEGIN { print &quot; 2.   So this line comes out second.\n&quot; }
  UNITCHECK {
   print &quot; 3. UNITCHECK blocks run LIFO after each file is compiled.\n&quot;
  }
  INIT { print  &quot; 9.   You'll see the difference right away.\n&quot; }
  print         &quot;13.   It only _looks_ like it should be confusing.\n&quot;;
  __END__
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Perl_Classes"><a class="permalink" href="#Perl_Classes">Perl
  Classes</a></h2>
<p class="Pp">There is no special class syntax in Perl, but a package may act as
    a class if it provides subroutines to act as methods. Such a package may
    also derive some of its methods from another class (package) by listing the
    other package name(s) in its global <span class="Li">@ISA</span> array
    (which must be a package global, not a lexical).</p>
<p class="Pp">For more on this, see perlootut and perlobj.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Perl_Modules"><a class="permalink" href="#Perl_Modules">Perl
  Modules</a></h2>
<p class="Pp">A module is just a set of related functions in a library file,
    i.e., a Perl package with the same name as the file. It is specifically
    designed to be reusable by other modules or programs. It may do this by
    providing a mechanism for exporting some of its symbols into the symbol
    table of any package using it, or it may function as a class definition and
    make its semantics available implicitly through method calls on the class
    and its objects, without explicitly exporting anything. Or it can do a
    little of both.</p>
<p class="Pp">For example, to start a traditional, non-OO module called
    Some::Module, create a file called <i>Some/Module.pm</i> and start with this
    template:</p>
<p class="Pp"></p>
<pre>    package Some::Module;  # assumes Some/Module.pm
    use strict;
    use warnings;
    # Get the import method from Exporter to export functions and
    # variables
    use Exporter 5.57 'import';
    # set the version for version checking
    our $VERSION     = '1.00';
    # Functions and variables which are exported by default
    our @EXPORT      = qw(func1 func2);
    # Functions and variables which can be optionally exported
    our @EXPORT_OK   = qw($Var1 %Hashit func3);
    # exported package globals go here
    our $Var1    = '';
    our %Hashit  = ();
    # non-exported package globals go here
    # (they are still accessible as $Some::Module::stuff)
    our @more    = ();
    our $stuff   = '';
    # file-private lexicals go here, before any functions which use them
    my $priv_var    = '';
    my %secret_hash = ();
    # here's a file-private function as a closure,
    # callable as $priv_func-&gt;();
    my $priv_func = sub {
        ...
    };
    # make all your functions, whether exported or not;
    # remember to put something interesting in the {} stubs
    sub func1      { ... }
    sub func2      { ... }
    # this one isn't always exported, but could be called directly
    # as Some::Module::func3()
    sub func3      { ... }
    END { ... }       # module clean-up code here (global destructor)
    1;  # don't forget to return a true value from the file
</pre>
<p class="Pp">Then go on to declare and use your variables in functions without
    any qualifications. See Exporter and the perlmodlib for details on mechanics
    and style issues in module creation.</p>
<p class="Pp">Perl modules are included into your program by saying</p>
<p class="Pp"></p>
<pre>    use Module;
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre>    use Module LIST;
</pre>
<p class="Pp">This is exactly equivalent to</p>
<p class="Pp"></p>
<pre>    BEGIN { require 'Module.pm'; 'Module'-&gt;import; }
</pre>
<p class="Pp">or</p>
<p class="Pp"></p>
<pre>    BEGIN { require 'Module.pm'; 'Module'-&gt;import( LIST ); }
</pre>
<p class="Pp">As a special case</p>
<p class="Pp"></p>
<pre>    use Module ();
</pre>
<p class="Pp">is exactly equivalent to</p>
<p class="Pp"></p>
<pre>    BEGIN { require 'Module.pm'; }
</pre>
<p class="Pp">All Perl module files have the extension <i>.pm</i>. The
    <span class="Li">&quot;use&quot;</span> operator assumes this so you don't
    have to spell out &quot;<i>Module.pm</i>&quot; in quotes. This also helps to
    differentiate new modules from old <i>.pl</i> and <i>.ph</i> files. Module
    names are also capitalized unless they're functioning as pragmas; pragmas
    are in effect compiler directives, and are sometimes called &quot;pragmatic
    modules&quot; (or even &quot;pragmata&quot; if you're a classicist).</p>
<p class="Pp">The two statements:</p>
<p class="Pp"></p>
<pre>    require SomeModule;
    require &quot;SomeModule.pm&quot;;
</pre>
<p class="Pp">differ from each other in two ways. In the first case, any double
    colons in the module name, such as
    <span class="Li">&quot;Some::Module&quot;</span>, are translated into your
    system's directory separator, usually &quot;/&quot;. The second case does
    not, and would have to be specified literally. The other difference is that
    seeing the first <span class="Li">&quot;require&quot;</span> clues in the
    compiler that uses of indirect object notation involving
    &quot;SomeModule&quot;, as in <span class="Li">&quot;$ob = purge
    SomeModule&quot;</span>, are method calls, not function calls. (Yes, this
    really can make a difference.)</p>
<p class="Pp">Because the <span class="Li">&quot;use&quot;</span> statement
    implies a <span class="Li">&quot;BEGIN&quot;</span> block, the importing of
    semantics happens as soon as the <span class="Li">&quot;use&quot;</span>
    statement is compiled, before the rest of the file is compiled. This is how
    it is able to function as a pragma mechanism, and also how modules are able
    to declare subroutines that are then visible as list or unary operators for
    the rest of the current file. This will not work if you use
    <span class="Li">&quot;require&quot;</span> instead of
    <span class="Li">&quot;use&quot;</span>. With
    <span class="Li">&quot;require&quot;</span> you can get into this
  problem:</p>
<p class="Pp"></p>
<pre>    require Cwd;                # make Cwd:: accessible
    $here = Cwd::getcwd();
    use Cwd;                    # import names from Cwd::
    $here = getcwd();
    require Cwd;                # make Cwd:: accessible
    $here = getcwd();           # oops! no main::getcwd()
</pre>
<p class="Pp">In general, <span class="Li">&quot;use Module ()&quot;</span> is
    recommended over <span class="Li">&quot;require Module&quot;</span>, because
    it determines module availability at compile time, not in the middle of your
    program's execution. An exception would be if two modules each tried to
    <span class="Li">&quot;use&quot;</span> each other, and each also called a
    function from that other module. In that case, it's easy to use
    <span class="Li">&quot;require&quot;</span> instead.</p>
<p class="Pp">Perl packages may be nested inside other package names, so we can
    have package names containing <span class="Li">&quot;::&quot;</span>. But if
    we used that package name directly as a filename it would make for unwieldy
    or impossible filenames on some systems. Therefore, if a module's name is,
    say, <span class="Li">&quot;Text::Soundex&quot;</span>, then its definition
    is actually found in the library file <i>Text/Soundex.pm</i>.</p>
<p class="Pp">Perl modules always have a <i>.pm</i> file, but there may also be
    dynamically linked executables (often ending in <i>.so</i>) or autoloaded
    subroutine definitions (often ending in <i>.al</i>) associated with the
    module. If so, these will be entirely transparent to the user of the module.
    It is the responsibility of the <i>.pm</i> file to load (or arrange to
    autoload) any additional functionality. For example, although the POSIX
    module happens to do both dynamic loading and autoloading, the user can say
    just <span class="Li">&quot;use POSIX&quot;</span> to get it all.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Making_your_module_threadsafe"><a class="permalink" href="#Making_your_module_threadsafe">Making
  your module threadsafe</a></h2>
<p class="Pp">Perl supports a type of threads called interpreter threads
    (ithreads). These threads can be used explicitly and implicitly.</p>
<p class="Pp">Ithreads work by cloning the data tree so that no data is shared
    between different threads. These threads can be used by using the
    <span class="Li">&quot;threads&quot;</span> module or by doing <b>fork()</b>
    on win32 (fake <b>fork()</b> support). When a thread is cloned all Perl data
    is cloned, however non-Perl data cannot be cloned automatically. Perl after
    5.8.0 has support for the <span class="Li">&quot;CLONE&quot;</span> special
    subroutine. In <span class="Li">&quot;CLONE&quot;</span> you can do whatever
    you need to do, like for example handle the cloning of non-Perl data, if
    necessary. <span class="Li">&quot;CLONE&quot;</span> will be called once as
    a class method for every package that has it defined (or inherits it). It
    will be called in the context of the new thread, so all modifications are
    made in the new area. Currently CLONE is called with no parameters other
    than the invocant package name, but code should not assume that this will
    remain unchanged, as it is likely that in future extra parameters will be
    passed in to give more information about the state of cloning.</p>
<p class="Pp">If you want to CLONE all objects you will need to keep track of
    them per package. This is simply done using a hash and
    <b>Scalar::Util::weaken()</b>.</p>
<p class="Pp">Perl after 5.8.7 has support for the
    <span class="Li">&quot;CLONE_SKIP&quot;</span> special subroutine. Like
    <span class="Li">&quot;CLONE&quot;</span>,
    <span class="Li">&quot;CLONE_SKIP&quot;</span> is called once per package;
    however, it is called just before cloning starts, and in the context of the
    parent thread. If it returns a true value, then no objects of that class
    will be cloned; or rather, they will be copied as unblessed, undef values.
    For example: if in the parent there are two references to a single blessed
    hash, then in the child there will be two references to a single undefined
    scalar value instead. This provides a simple mechanism for making a module
    threadsafe; just add <span class="Li">&quot;sub CLONE_SKIP { 1
    }&quot;</span> at the top of the class, and
    <span class="Li">&quot;DESTROY()&quot;</span> will now only be called once
    per object. Of course, if the child thread needs to make use of the objects,
    then a more sophisticated approach is needed.</p>
<p class="Pp">Like <span class="Li">&quot;CLONE&quot;</span>,
    <span class="Li">&quot;CLONE_SKIP&quot;</span> is currently called with no
    parameters other than the invocant package name, although that may change.
    Similarly, to allow for future expansion, the return value should be a
    single <span class="Li">0</span> or <span class="Li">1</span> value.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">See perlmodlib for general style issues related to building Perl
    modules and classes, as well as descriptions of the standard library and
    CPAN, Exporter for how Perl's standard import/export mechanism works,
    perlootut and perlobj for in-depth information on creating classes, perlobj
    for a hard-core reference document on objects, perlsub for an explanation of
    functions and scoping, and perlxstut and perlguts for more information on
    writing extension modules.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os">perl v5.34.1</td>
  </tr>
</table>
</body>
</html>

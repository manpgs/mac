<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>LSM(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">LSM(1)</td>
    <td class="head-vol"><a href=".">Latent Semantic Mapping</a></td>
    <td class="head-rtitle">LSM(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">lsm - Latent Semantic Mapping tool</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">lsm <i>lsm_command</i> [<i>command_options</i>] <i>map_file</i>
    [<i>input_files</i>]</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The Latent Semantic Mapping framework is a language independent,
    Unicode based technology that builds <i>maps</i> and uses them to classify
    <i>texts</i> into one of a number of <i>categories</i>.</p>
<p class="Pp"><b>lsm</b> is a tool to create, manipulate, test, and dump Latent
    Semantic Mapping maps. It is designed to provide access to a large subset of
    the functionality of the Latent Semantic Mapping API, mainly for rapid
    prototyping and diagnostic purposes, but possibly also for simple shell
    script based applications of Latent Semantic Mapping.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COMMANDS"><a class="permalink" href="#COMMANDS">COMMANDS</a></h1>
<p class="Pp"><b>lsm</b> provides a variety of commands (<i>lsm_command</i> in
    the Synopsis), each of which often has a wealth of options (see the Command
    Options below). Command names may be abbreviated to unambiguous
  prefixes.</p>
<dl class="Bl-tag">
  <dt id="lsm"><a class="permalink" href="#lsm"><b>lsm create</b>
    <i>map_file</i> <i>input_files</i></a></dt>
  <dd>Create a new LSM map from the specified <i>input_files</i>.</dd>
  <dt id="lsm~2"><a class="permalink" href="#lsm~2"><b>lsm update</b>
    <i>map_file</i> <i>input_files</i></a></dt>
  <dd>Add the specified <i>input_files</i> to an existing LSM map.</dd>
  <dt id="lsm~3"><a class="permalink" href="#lsm~3"><b>lsm evaluate</b>
    <i>map_file</i> <i>input_files</i></a></dt>
  <dd>Classify the specified <i>input_files</i> into the categories of the LSM
      map.</dd>
  <dt id="lsm~4"><a class="permalink" href="#lsm~4"><b>lsm cluster</b>
    <b>[--k-means=N | --agglomerative=N] [--apply]</b></a></dt>
  <dd>Compute clusters for the map, and, if the <b>--apply</b> option is
      specified, transform the map accordingly. Multiple levels of clustering
      may be applied for faster performance on large maps, e.g.
    <p class="Pp"></p>
    <pre>   lsm cluster --k-means=100 --each --agglomerative=100 --agglomerative=1000 my.map
    </pre>
    <p class="Pp">first computes 100 clusters using (fast) k-means clustering,
        computes 100 subclusters for each first stage cluster using
        agglomerative clustering, and finally reduces those 10000 clusters to
        1000 using agglomerative clustering.</p>
  </dd>
  <dt id="lsm~5"><a class="permalink" href="#lsm~5"><b>lsm dump</b>
    <i>map_file</i> [<i>input_files</i>]</a></dt>
  <dd>Without <i>input_files</i>, dumps all words in the map with their counts.
      With <i>input_files</i>, dump, for each file, the words that appear in the
      map, their counts in the map, and their relative frequencies in the input
      file.</dd>
  <dt id="lsm~6"><a class="permalink" href="#lsm~6"><b>lsm info</b>
    <i>map_file</i></a></dt>
  <dd>Bypass the Latent Semantic Mapping framework to extract and print
      information about the file and perform a number of consistency checks on
      it. <b>(NOT IMPLEMENTED YET)</b></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="COMMAND_OPTIONS"><a class="permalink" href="#COMMAND_OPTIONS">COMMAND
  OPTIONS</a></h1>
<p class="Pp">This section describes the <i>command_options</i> that are
    available for the <b>lsm</b> commands. Not all commands support all of these
    options; each option is only supported for commands where it makes sense.
    However, when a command has one of these options you can count on the same
    meaning for the option as in other commands.</p>
<dl class="Bl-tag">
  <dt id="append"><a class="permalink" href="#append"><b>--append-categories</b></a></dt>
  <dd>Directs the <b>update</b> command to put the data into new categories
      appended after the existing ones, instead of adding the data to the
      existing categories.</dd>
  <dt id="categories"><a class="permalink" href="#categories"><b>--categories</b>
    <i>count</i></a></dt>
  <dd>Directs the <b>evaluate</b> command to only list the top <i>count</i>
      categories.</dd>
  <dt id="category"><a class="permalink" href="#category"><b>--category-delimiter</b>
    <i>delimiter</i></a></dt>
  <dd>Specify the delimiter to be used to between categories in the
      <i>input_files</i> passed to the <b>create</b> and <b>update</b>
    commands.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="group"><a class="permalink" href="#group"><b>group</b></a></dt>
  <dd>Categories are separated by a `;' argument.</dd>
  <dt id="file"><a class="permalink" href="#file"><b>file</b></a></dt>
  <dd>Each <i>input_file</i> represents a separate category. This is the default
      if the <b>--category-delimiter</b> option is not given.</dd>
  <dt id="line"><a class="permalink" href="#line"><b>line</b></a></dt>
  <dd>Each line represents a separate category.</dd>
  <dt id="string"><a class="permalink" href="#string"><i>string</i></a></dt>
  <dd>Categories are separated by the specified <i>string</i>.</dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="clobber"><a class="permalink" href="#clobber"><b>--clobber</b></a></dt>
  <dd>When creating a map, overwrite an existing file at the path, even if it's
      not an LSM map. By default, <b>create</b> will only overwrite an existing
      file if it's believed to be an LSM map, which guards against frequent
      operator errors such as:
    <p class="Pp"></p>
    <pre>   lsm create /usr/include/*.h
    </pre>
  </dd>
  <dt id="dimensions"><a class="permalink" href="#dimensions"><b>--dimensions</b>
    <i>dim</i></a></dt>
  <dd>Direct the <b>create</b> and <b>update</b> commands to use the given
      number of dimensions for computing the map (Defaults to the number of
      categories). This option is useful to manage the size and computational
      overhead of maps with large number of categories.</dd>
  <dt id="discard"><a class="permalink" href="#discard"><b>--discard-counts</b></a></dt>
  <dd>Direct the <b>create</b> and <b>update</b> commands to omit the raw word /
      token counts when writing the map. This results in a map that is more
      compact, but cannot be updated any further.</dd>
  <dt id="hash"><a class="permalink" href="#hash"><b>--hash</b></a></dt>
  <dd>Direct the <b>create</b> and <b>update</b> commands to write the map in a
      format that is not human readable with default file manipulation tools
      like <b>cat</b> or <b>hexdump</b>. This is useful in applications such as
      junk mail filtering, where input data may contain naughty words and where
      the contents of the map may tip off spammers what words to avoid.</dd>
  <dt id="help"><a class="permalink" href="#help"><b>--help</b></a></dt>
  <dd>List an overview of the options available for a command. Available for all
      commands.</dd>
  <dt id="html"><a class="permalink" href="#html"><b>--html</b></a></dt>
  <dd>Strip HTML codes from the <i>input_files</i>. Useful for mail and web
      input. Available for the <b>create</b>, <b>update</b>, <b>evaluate</b>,
      and <b>dump</b> commands.</dd>
  <dt id="junk"><a class="permalink" href="#junk"><b>--junk-mail</b></a></dt>
  <dd>When parsing the input files, apply heuristics to counteract common
      methods used by spammers to disguise incriminating words such as:
    <p class="Pp"></p>
    <pre>   Zer0 1nt3rest l0ans     Substituting letters with digits
   W E A L T H             Adding spaces between letters
   m.o.r.t.g.a.g.e         Adding punctuation between letters
    </pre>
    <p class="Pp">Available for the <b>create</b>, <b>update</b>,
        <b>evaluate</b>, and <b>dump</b> commands.</p>
  </dd>
  <dt id="pairs"><a class="permalink" href="#pairs"><b>--pairs</b></a></dt>
  <dd>If specified with the <b>create</b> command when building the map, store
      counts for pairs of words as well as the words themselves. This can
      increase accuracy for certain classes of problems, but will generate
      unreasonably large maps unless the vocabulary is fairly limited.</dd>
  <dt id="stop"><a class="permalink" href="#stop"><b>--stop-words</b>
    <i>stop_word_file</i></a></dt>
  <dd>If specified with the <b>create</b> command, <i>stop_word_file</i> is
      parsed and all words found are excluded from texts evaluated against the
      map. This is useful for excluding frequent, semantically meaningless
      words.</dd>
  <dt id="sweep"><a class="permalink" href="#sweep"><b>--sweep-cutoff</b>
    <i>threshold</i></a></dt>
  <dd></dd>
  <dt id="sweep~2"><a class="permalink" href="#sweep~2"><b>--sweep-frequency</b>
    <i>days</i></a></dt>
  <dd>Available for the <b>create</b> and <b>update</b> commands. Every
      specified number of <i>days</i> (by default 7), scan the map and remove
      from it any entries that have been in the map for at least 2 previous
      scans and whose total counts are smaller than <i>threshold</i>.
      <i>threshold</i> defaults to 0, so by default the map is not scanned.</dd>
  <dt id="text"><a class="permalink" href="#text"><b>--text-delimiter</b>
    <i>delimiter</i></a></dt>
  <dd>Specify the delimiter to be used to between texts in the
      <i>input_files</i> passed to the <b>create</b>, <b>update</b>,
      <b>evaluate</b>, and <b>dump</b> commands.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="file~2"><a class="permalink" href="#file~2"><b>file</b></a></dt>
  <dd>Each <i>input_file</i> represents a separate text. This is the default if
      the <b>--text-delimiter</b> option is not given.</dd>
  <dt id="line~2"><a class="permalink" href="#line~2"><b>line</b></a></dt>
  <dd>Each line represents a separate text.</dd>
  <dt id="string~2"><a class="permalink" href="#string~2"><i>string</i></a></dt>
  <dd>Texts are separated by the specified <i>string</i>.</dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="triplets"><a class="permalink" href="#triplets"><b>--triplets</b></a></dt>
  <dd>If specified with the <b>create</b> command when building the map, store
      counts for triplets and pairs of words as well as the words themselves.
      This can increase accuracy for certain classes of problems, but will
      generate unreasonably large maps unless the vocabulary is fairly
    limited.</dd>
  <dt id="weight"><a class="permalink" href="#weight"><b>--weight</b>
    <i>weight</i></a></dt>
  <dd>Scale counts of input words for the <b>create</b> and <b>update</b>
      commands by the specified <i>weight</i>, which may be a positive or
      negative floating point number.</dd>
  <dt id="words"><a class="permalink" href="#words"><b>--words</b></a></dt>
  <dd>Directs the <b>evaluate</b> or <b>cluster</b> commands to apply to words,
      instead of categories.</dd>
  <dt id="words~2"><a class="permalink" href="#words~2"><b>--words</b>=<i>count</i></a></dt>
  <dd>Directs the <b>evaluate</b> command to list the top <i>count</i> words,
      instead of categories.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<dl class="Bl-tag">
  <dt>&quot;lsm evaluate --html --junk-mail ~/Library/Mail/V2/MailData/LSMMap2
    msg*.txt&quot;</dt>
  <dd>Simulate the <b>Mail.app</b> junk mail filter by evaluating the specified
      files (assumed to each hold the raw text of one mail message) against the
      user's junk mail map.</dd>
  <dt>&quot;lsm dump ~/Library/Mail/V2/MailData/LSMMap2&quot;</dt>
  <dd>Dump the words accumulated in the junk mail map and their counts.</dd>
  <dt>&quot;lsm create --category-delimiter=group c_vs_h *.c ';' *.h&quot;</dt>
  <dd>Create an LSM map trained to distinguish C header files from C source
      files.</dd>
  <dt>&quot;lsm update --weight 2.0 --cat=group c_vs_h ';' ../xy/*.h&quot;</dt>
  <dd>Add some additional header files with an increased weight to the
    training.</dd>
  <dt>&quot;lsm create --help&quot;</dt>
  <dd>List the options available for the <b>lsm create</b> command.</dd>
</dl>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2024-05-10</td>
    <td class="foot-os"><a href="..">1.0</a></td>
  </tr>
</table>
</body>
</html>

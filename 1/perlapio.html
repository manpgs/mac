<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PERLAPIO(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLAPIO(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLAPIO(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlapio - perl's IO abstraction interface.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>  #define PERLIO_NOT_STDIO 0    /* For co-existence with stdio only */
  #include &lt;perlio.h&gt;           /* Usually via #include &lt;perl.h&gt; */
  PerlIO *PerlIO_stdin(void);
  PerlIO *PerlIO_stdout(void);
  PerlIO *PerlIO_stderr(void);
  PerlIO *PerlIO_open(const char *path,const char *mode);
  PerlIO *PerlIO_fdopen(int fd, const char *mode);
  PerlIO *PerlIO_reopen(const char *path, /* deprecated */
          const char *mode, PerlIO *old);
  int     PerlIO_close(PerlIO *f);
  int     PerlIO_stdoutf(const char *fmt,...)
  int     PerlIO_puts(PerlIO *f,const char *string);
  int     PerlIO_putc(PerlIO *f,int ch);
  SSize_t PerlIO_write(PerlIO *f,const void *buf,size_t numbytes);
  int     PerlIO_printf(PerlIO *f, const char *fmt,...);
  int     PerlIO_vprintf(PerlIO *f, const char *fmt, va_list args);
  int     PerlIO_flush(PerlIO *f);
  int     PerlIO_eof(PerlIO *f);
  int     PerlIO_error(PerlIO *f);
  void    PerlIO_clearerr(PerlIO *f);
  int     PerlIO_getc(PerlIO *d);
  int     PerlIO_ungetc(PerlIO *f,int ch);
  SSize_t PerlIO_read(PerlIO *f, void *buf, size_t numbytes);
  int     PerlIO_fileno(PerlIO *f);
  void    PerlIO_setlinebuf(PerlIO *f);
  Off_t   PerlIO_tell(PerlIO *f);
  int     PerlIO_seek(PerlIO *f, Off_t offset, int whence);
  void    PerlIO_rewind(PerlIO *f);
  int     PerlIO_getpos(PerlIO *f, SV *save);    /* prototype changed */
  int     PerlIO_setpos(PerlIO *f, SV *saved);   /* prototype changed */
  int     PerlIO_fast_gets(PerlIO *f);
  int     PerlIO_has_cntptr(PerlIO *f);
  SSize_t PerlIO_get_cnt(PerlIO *f);
  char   *PerlIO_get_ptr(PerlIO *f);
  void    PerlIO_set_ptrcnt(PerlIO *f, char *ptr, SSize_t count);
  int     PerlIO_canset_cnt(PerlIO *f);              /* deprecated */
  void    PerlIO_set_cnt(PerlIO *f, int count);      /* deprecated */
  int     PerlIO_has_base(PerlIO *f);
  char   *PerlIO_get_base(PerlIO *f);
  SSize_t PerlIO_get_bufsiz(PerlIO *f);
  PerlIO *PerlIO_importFILE(FILE *stdio, const char *mode);
  FILE   *PerlIO_exportFILE(PerlIO *f, const char *mode);
  FILE   *PerlIO_findFILE(PerlIO *f);
  void    PerlIO_releaseFILE(PerlIO *f,FILE *stdio);
  int     PerlIO_apply_layers(PerlIO *f, const char *mode,
                                                    const char *layers);
  int     PerlIO_binmode(PerlIO *f, int ptype, int imode,
                                                    const char *layers);
  void    PerlIO_debug(const char *fmt,...);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Perl's source code, and extensions that want maximum portability,
    should use the above functions instead of those defined in ANSI C's
    <i>stdio.h</i>. The perl headers (in particular &quot;perlio.h&quot;) will
    <span class="Li">&quot;#define&quot;</span> them to the I/O mechanism
    selected at Configure time.</p>
<p class="Pp">The functions are modeled on those in <i>stdio.h</i>, but
    parameter order has been &quot;tidied up a little&quot;.</p>
<p class="Pp"><span class="Li">&quot;PerlIO *&quot;</span> takes the place of
    FILE *. Like FILE * it should be treated as opaque (it is probably safe to
    assume it is a pointer to something).</p>
<p class="Pp">There are currently two implementations:</p>
<dl class="Bl-tag">
  <dt>1. USE_STDIO</dt>
  <dd>All above are #define'd to stdio functions or are trivial wrapper
      functions which call stdio. In this case <i>only</i> PerlIO * is a FILE *.
      This has been the default implementation since the abstraction was
      introduced in perl5.003_02.</dd>
  <dt>2. USE_PERLIO</dt>
  <dd>Introduced just after perl5.7.0, this is a re-implementation of the above
      abstraction which allows perl more control over how IO is done as it
      decouples IO from the way the operating system and C library choose to do
      things. For USE_PERLIO PerlIO * has an extra layer of indirection - it is
      a pointer-to-a-pointer. This allows the PerlIO * to remain with a known
      value while swapping the implementation around underneath <i>at run
      time</i>. In this case all the above are true (but very simple) functions
      which call the underlying implementation.
    <p class="Pp">This is the only implementation for which
        <span class="Li">&quot;PerlIO_apply_layers()&quot;</span> does anything
        &quot;interesting&quot;.</p>
    <p class="Pp">The USE_PERLIO implementation is described in perliol.</p>
  </dd>
</dl>
<p class="Pp">Because &quot;perlio.h&quot; is a thin layer (for efficiency) the
    semantics of these functions are somewhat dependent on the underlying
    implementation. Where these variations are understood they are noted
  below.</p>
<p class="Pp">Unless otherwise noted, functions return 0 on success, or a
    negative value (usually <span class="Li">&quot;EOF&quot;</span> which is
    usually -1) and set <span class="Li">&quot;errno&quot;</span> on error.</p>
<dl class="Bl-tag">
  <dt id="PerlIO_stdin()"><a class="permalink" href="#PerlIO_stdin()"><b></b><b>PerlIO_stdin()</b><b></b>,
    <b></b><b>PerlIO_stdout()</b><b></b>,
    <b></b><b>PerlIO_stderr()</b><b></b></a></dt>
  <dd>Use these rather than <span class="Li">&quot;stdin&quot;</span>,
      <span class="Li">&quot;stdout&quot;</span>,
      <span class="Li">&quot;stderr&quot;</span>. They are written to look like
      &quot;function calls&quot; rather than variables because this makes it
      easier to <i>make them</i> function calls if platform cannot export data
      to loaded modules, or if (say) different &quot;threads&quot; might have
      different values.</dd>
  <dt id="PerlIO_open(path,"><a class="permalink" href="#PerlIO_open(path,"><b>PerlIO_open(path,
    mode)</b>, <b>PerlIO_fdopen(fd,mode)</b></a></dt>
  <dd>These correspond to <b>fopen()</b>/<b>fdopen()</b> and the arguments are
      the same. Return <span class="Li">&quot;NULL&quot;</span> and set
      <span class="Li">&quot;errno&quot;</span> if there is an error. There may
      be an implementation limit on the number of open handles, which may be
      lower than the limit on the number of open files -
      <span class="Li">&quot;errno&quot;</span> may not be set when
      <span class="Li">&quot;NULL&quot;</span> is returned if this limit is
      exceeded.</dd>
  <dt id="PerlIO_reopen(path,mode,f)"><a class="permalink" href="#PerlIO_reopen(path,mode,f)"><b>PerlIO_reopen(path,mode,f)</b></a></dt>
  <dd>While this currently exists in both implementations, perl itself does not
      use it. <i>As perl does not use it, it is not well tested.</i>
    <p class="Pp">Perl prefers to <span class="Li">&quot;dup&quot;</span> the
        new low-level descriptor to the descriptor used by the existing PerlIO.
        This may become the behaviour of this function in the future.</p>
  </dd>
  <dt id="PerlIO_printf(f,fmt,...)"><a class="permalink" href="#PerlIO_printf(f,fmt,...)"><b>PerlIO_printf(f,fmt,...)</b>,
    <b>PerlIO_vprintf(f,fmt,a)</b></a></dt>
  <dd>These are <b>fprintf()</b>/<b>vfprintf()</b> equivalents.</dd>
  <dt id="PerlIO_stdoutf(fmt,...)"><a class="permalink" href="#PerlIO_stdoutf(fmt,...)"><b>PerlIO_stdoutf(fmt,...)</b></a></dt>
  <dd>This is <b>printf()</b> equivalent. printf is #defined to this function,
      so it is (currently) legal to use
      <span class="Li">&quot;printf(fmt,...)&quot;</span> in perl sources.</dd>
  <dt id="PerlIO_read(f,buf,count)"><a class="permalink" href="#PerlIO_read(f,buf,count)"><b>PerlIO_read(f,buf,count)</b>,
    <b>PerlIO_write(f,buf,count)</b></a></dt>
  <dd>These correspond functionally to <b>fread()</b> and <b>fwrite()</b> but
      the arguments and return values are different. The <b>PerlIO_read()</b>
      and <b>PerlIO_write()</b> signatures have been modeled on the more sane
      low level <b>read()</b> and <b>write()</b> functions instead: The
      &quot;file&quot; argument is passed first, there is only one
      &quot;count&quot;, and the return value can distinguish between error and
      <span class="Li">&quot;EOF&quot;</span>.
    <p class="Pp">Returns a byte count if successful (which may be zero or
        positive), returns negative value and sets
        <span class="Li">&quot;errno&quot;</span> on error. Depending on
        implementation <span class="Li">&quot;errno&quot;</span> may be
        <span class="Li">&quot;EINTR&quot;</span> if operation was interrupted
        by a signal.</p>
  </dd>
  <dt id="PerlIO_close(f)"><a class="permalink" href="#PerlIO_close(f)"><b>PerlIO_close(f)</b></a></dt>
  <dd>Depending on implementation <span class="Li">&quot;errno&quot;</span> may
      be <span class="Li">&quot;EINTR&quot;</span> if operation was interrupted
      by a signal.</dd>
  <dt id="PerlIO_puts(f,s)"><a class="permalink" href="#PerlIO_puts(f,s)"><b>PerlIO_puts(f,s)</b>,
    <b>PerlIO_putc(f,c)</b></a></dt>
  <dd>These correspond to <b>fputs()</b> and <b>fputc()</b>. Note that arguments
      have been revised to have &quot;file&quot; first.</dd>
  <dt id="PerlIO_ungetc(f,c)"><a class="permalink" href="#PerlIO_ungetc(f,c)"><b>PerlIO_ungetc(f,c)</b></a></dt>
  <dd>This corresponds to <b>ungetc()</b>. Note that arguments have been revised
      to have &quot;file&quot; first. Arranges that next read operation will
      return the byte <b>c</b>. Despite the implied &quot;character&quot; in the
      name only values in the range 0..0xFF are defined. Returns the byte
      <b>c</b> on success or -1 (<span class="Li">&quot;EOF&quot;</span>) on
      error. The number of bytes that can be &quot;pushed back&quot; may vary,
      only 1 character is certain, and then only if it is the last character
      that was read from the handle.</dd>
  <dt id="PerlIO_getc(f)"><a class="permalink" href="#PerlIO_getc(f)"><b>PerlIO_getc(f)</b></a></dt>
  <dd>This corresponds to <b>getc()</b>. Despite the c in the name only byte
      range 0..0xFF is supported. Returns the character read or -1
      (<span class="Li">&quot;EOF&quot;</span>) on error.</dd>
  <dt id="PerlIO_eof(f)"><a class="permalink" href="#PerlIO_eof(f)"><b>PerlIO_eof(f)</b></a></dt>
  <dd>This corresponds to <b>feof()</b>. Returns a true/false indication of
      whether the handle is at end of file. For terminal devices this may or may
      not be &quot;sticky&quot; depending on the implementation. The flag is
      cleared by <b>PerlIO_seek()</b>, or <b>PerlIO_rewind()</b>.</dd>
  <dt id="PerlIO_error(f)"><a class="permalink" href="#PerlIO_error(f)"><b>PerlIO_error(f)</b></a></dt>
  <dd>This corresponds to <b>ferror()</b>. Returns a true/false indication of
      whether there has been an IO error on the handle.</dd>
  <dt id="PerlIO_fileno(f)"><a class="permalink" href="#PerlIO_fileno(f)"><b>PerlIO_fileno(f)</b></a></dt>
  <dd>This corresponds to <b>fileno()</b>, note that on some platforms, the
      meaning of &quot;fileno&quot; may not match Unix. Returns -1 if the handle
      has no open descriptor associated with it.</dd>
  <dt id="PerlIO_clearerr(f)"><a class="permalink" href="#PerlIO_clearerr(f)"><b>PerlIO_clearerr(f)</b></a></dt>
  <dd>This corresponds to <b>clearerr()</b>, i.e., clears 'error' and (usually)
      'eof' flags for the &quot;stream&quot;. Does not return a value.</dd>
  <dt id="PerlIO_flush(f)"><a class="permalink" href="#PerlIO_flush(f)"><b>PerlIO_flush(f)</b></a></dt>
  <dd>This corresponds to <b>fflush()</b>. Sends any buffered write data to the
      underlying file. If called with <span class="Li">&quot;NULL&quot;</span>
      this may flush all open streams (or core dump with some USE_STDIO
      implementations). Calling on a handle open for read only, or on which last
      operation was a read of some kind may lead to undefined behaviour on some
      USE_STDIO implementations. The USE_PERLIO (layers) implementation tries to
      behave better: it flushes all open streams when passed
      <span class="Li">&quot;NULL&quot;</span>, and attempts to retain data on
      read streams either in the buffer or by seeking the handle to the current
      logical position.</dd>
  <dt id="PerlIO_seek(f,offset,whence)"><a class="permalink" href="#PerlIO_seek(f,offset,whence)"><b>PerlIO_seek(f,offset,whence)</b></a></dt>
  <dd>This corresponds to <b>fseek()</b>. Sends buffered write data to the
      underlying file, or discards any buffered read data, then positions the
      file descriptor as specified by <b>offset</b> and <b>whence</b> (sic).
      This is the correct thing to do when switching between read and write on
      the same handle (see issues with <b>PerlIO_flush()</b> above). Offset is
      of type <span class="Li">&quot;Off_t&quot;</span> which is a perl
      Configure value which may not be same as stdio's
      <span class="Li">&quot;off_t&quot;</span>.</dd>
  <dt id="PerlIO_tell(f)"><a class="permalink" href="#PerlIO_tell(f)"><b>PerlIO_tell(f)</b></a></dt>
  <dd>This corresponds to <b>ftell()</b>. Returns the current file position, or
      (Off_t) -1 on error. May just return value system &quot;knows&quot;
      without making a system call or checking the underlying file descriptor
      (so use on shared file descriptors is not safe without a
      <b>PerlIO_seek()</b>). Return value is of type
      <span class="Li">&quot;Off_t&quot;</span> which is a perl Configure value
      which may not be same as stdio's
      <span class="Li">&quot;off_t&quot;</span>.</dd>
  <dt id="PerlIO_getpos(f,p)"><a class="permalink" href="#PerlIO_getpos(f,p)"><b>PerlIO_getpos(f,p)</b>,
    <b>PerlIO_setpos(f,p)</b></a></dt>
  <dd>These correspond (loosely) to <b>fgetpos()</b> and <b>fsetpos()</b>.
      Rather than stdio's Fpos_t they expect a &quot;Perl Scalar Value&quot; to
      be passed. What is stored there should be considered opaque. The layout of
      the data may vary from handle to handle. When not using stdio or if
      platform does not have the stdio calls then they are implemented in terms
      of <b>PerlIO_tell()</b> and <b>PerlIO_seek()</b>.</dd>
  <dt id="PerlIO_rewind(f)"><a class="permalink" href="#PerlIO_rewind(f)"><b>PerlIO_rewind(f)</b></a></dt>
  <dd>This corresponds to <b>rewind()</b>. It is usually defined as being
    <p class="Pp"></p>
    <pre>    PerlIO_seek(f,(Off_t)0L, SEEK_SET);
    PerlIO_clearerr(f);
    </pre>
  </dd>
  <dt id="PerlIO_tmpfile()"><a class="permalink" href="#PerlIO_tmpfile()"><b></b><b>PerlIO_tmpfile()</b><b></b></a></dt>
  <dd>This corresponds to <b>tmpfile()</b>, i.e., returns an anonymous PerlIO or
      NULL on error. The system will attempt to automatically delete the file
      when closed. On Unix the file is usually
      <span class="Li">&quot;unlink&quot;</span>-ed just after it is created so
      it does not matter how it gets closed. On other systems the file may only
      be deleted if closed via <b>PerlIO_close()</b> and/or the program exits
      via <span class="Li">&quot;exit&quot;</span>. Depending on the
      implementation there may be &quot;race conditions&quot; which allow other
      processes access to the file, though in general it will be safer in this
      regard than ad. hoc. schemes.</dd>
  <dt id="PerlIO_setlinebuf(f)"><a class="permalink" href="#PerlIO_setlinebuf(f)"><b>PerlIO_setlinebuf(f)</b></a></dt>
  <dd>This corresponds to <b>setlinebuf()</b>. Does not return a value. What
      constitutes a &quot;line&quot; is implementation dependent but usually
      means that writing &quot;\n&quot; flushes the buffer. What happens with
      things like &quot;this\nthat&quot; is uncertain. (Perl core uses it
      <i>only</i> when &quot;dumping&quot;; it has nothing to do with $|
      auto-flush.)</dd>
</dl>
<section class="Ss">
<h2 class="Ss" id="Co-existence_with_stdio"><a class="permalink" href="#Co-existence_with_stdio">Co-existence
  with stdio</a></h2>
<p class="Pp">There is outline support for co-existence of PerlIO with stdio.
    Obviously if PerlIO is implemented in terms of stdio there is no problem.
    However in other cases then mechanisms must exist to create a FILE * which
    can be passed to library code which is going to use stdio calls.</p>
<p class="Pp">The first step is to add this line:</p>
<p class="Pp"></p>
<pre>   #define PERLIO_NOT_STDIO 0
</pre>
<p class="Pp"><i>before</i> including any perl header files. (This will probably
    become the default at some point). That prevents &quot;perlio.h&quot; from
    attempting to #define stdio functions onto PerlIO functions.</p>
<p class="Pp">XS code is probably better using &quot;typemap&quot; if it expects
    FILE * arguments. The standard typemap will be adjusted to comprehend any
    changes in this area.</p>
<dl class="Bl-tag">
  <dt id="PerlIO_importFILE(f,mode)"><a class="permalink" href="#PerlIO_importFILE(f,mode)"><b>PerlIO_importFILE(f,mode)</b></a></dt>
  <dd>Used to get a PerlIO * from a FILE *.
    <p class="Pp">The mode argument should be a string as would be passed to
        fopen/PerlIO_open. If it is NULL then - for legacy support - the code
        will (depending upon the platform and the implementation) either attempt
        to empirically determine the mode in which <i>f</i> is open, or use
        &quot;r+&quot; to indicate a read/write stream.</p>
    <p class="Pp">Once called the FILE * should <i>ONLY</i> be closed by calling
        <span class="Li">&quot;PerlIO_close()&quot;</span> on the returned
        PerlIO *.</p>
    <p class="Pp">The PerlIO is set to textmode. Use PerlIO_binmode if this is
        not the desired mode.</p>
    <p class="Pp">This is <b>not</b> the reverse of
      <b>PerlIO_exportFILE()</b>.</p>
  </dd>
  <dt id="PerlIO_exportFILE(f,mode)"><a class="permalink" href="#PerlIO_exportFILE(f,mode)"><b>PerlIO_exportFILE(f,mode)</b></a></dt>
  <dd>Given a PerlIO * create a 'native' FILE * suitable for passing to code
      expecting to be compiled and linked with ANSI C <i>stdio.h</i>. The mode
      argument should be a string as would be passed to fopen/PerlIO_open. If it
      is NULL then - for legacy support - the FILE * is opened in same mode as
      the PerlIO *.
    <p class="Pp">The fact that such a FILE * has been 'exported' is recorded,
        (normally by pushing a new :stdio &quot;layer&quot; onto the PerlIO *),
        which may affect future PerlIO operations on the original PerlIO *. You
        should not call <span class="Li">&quot;fclose()&quot;</span> on the file
        unless you call <span class="Li">&quot;PerlIO_releaseFILE()&quot;</span>
        to disassociate it from the PerlIO *. (Do not use
        <b>PerlIO_importFILE()</b> for doing the disassociation.)</p>
    <p class="Pp">Calling this function repeatedly will create a FILE * on each
        call (and will push an :stdio layer each time as well).</p>
  </dd>
  <dt id="PerlIO_releaseFILE(p,f)"><a class="permalink" href="#PerlIO_releaseFILE(p,f)"><b>PerlIO_releaseFILE(p,f)</b></a></dt>
  <dd>Calling PerlIO_releaseFILE informs PerlIO that all use of FILE * is
      complete. It is removed from the list of 'exported' FILE *s, and the
      associated PerlIO * should revert to its original behaviour.
    <p class="Pp">Use this to disassociate a file from a PerlIO * that was
        associated using <b>PerlIO_exportFILE()</b>.</p>
  </dd>
  <dt id="PerlIO_findFILE(f)"><a class="permalink" href="#PerlIO_findFILE(f)"><b>PerlIO_findFILE(f)</b></a></dt>
  <dd>Returns a native FILE * used by a stdio layer. If there is none, it will
      create one with PerlIO_exportFILE. In either case the FILE * should be
      considered as belonging to PerlIO subsystem and should only be closed by
      calling <span class="Li">&quot;PerlIO_close()&quot;</span>.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_Fast_gets__Functions"><a class="permalink" href="#_Fast_gets__Functions">&quot;Fast
  gets&quot; Functions</a></h2>
<p class="Pp">In addition to standard-like API defined so far above there is an
    &quot;implementation&quot; interface which allows perl to get at internals
    of PerlIO. The following calls correspond to the various FILE_xxx macros
    determined by Configure - or their equivalent in other implementations. This
    section is really of interest to only those concerned with detailed
    perl-core behaviour, implementing a PerlIO mapping or writing code which can
    make use of the &quot;read ahead&quot; that has been done by the IO system
    in the same way perl does. Note that any code that uses these interfaces
    must be prepared to do things the traditional way if a handle does not
    support them.</p>
<dl class="Bl-tag">
  <dt id="PerlIO_fast_gets(f)"><a class="permalink" href="#PerlIO_fast_gets(f)"><b>PerlIO_fast_gets(f)</b></a></dt>
  <dd>Returns true if implementation has all the interfaces required to allow
      perl's <span class="Li">&quot;sv_gets&quot;</span> to &quot;bypass&quot;
      normal IO mechanism. This can vary from handle to handle.
    <p class="Pp"></p>
    <pre>  PerlIO_fast_gets(f) = PerlIO_has_cntptr(f) &amp;&amp; \
                        PerlIO_canset_cnt(f) &amp;&amp; \
                        'Can set pointer into buffer'
    </pre>
  </dd>
  <dt id="PerlIO_has_cntptr(f)"><a class="permalink" href="#PerlIO_has_cntptr(f)"><b>PerlIO_has_cntptr(f)</b></a></dt>
  <dd>Implementation can return pointer to current position in the
      &quot;buffer&quot; and a count of bytes available in the buffer. Do not
      use this - use PerlIO_fast_gets.</dd>
  <dt id="PerlIO_get_cnt(f)"><a class="permalink" href="#PerlIO_get_cnt(f)"><b>PerlIO_get_cnt(f)</b></a></dt>
  <dd>Return count of readable bytes in the buffer. Zero or negative return
      means no more bytes available.</dd>
  <dt id="PerlIO_get_ptr(f)"><a class="permalink" href="#PerlIO_get_ptr(f)"><b>PerlIO_get_ptr(f)</b></a></dt>
  <dd>Return pointer to next readable byte in buffer, accessing via the pointer
      (dereferencing) is only safe if <b>PerlIO_get_cnt()</b> has returned a
      positive value. Only positive offsets up to value returned by
      <b>PerlIO_get_cnt()</b> are allowed.</dd>
  <dt id="PerlIO_set_ptrcnt(f,p,c)"><a class="permalink" href="#PerlIO_set_ptrcnt(f,p,c)"><b>PerlIO_set_ptrcnt(f,p,c)</b></a></dt>
  <dd>Set pointer into buffer, and a count of bytes still in the buffer. Should
      be used only to set pointer to within range implied by previous calls to
      <span class="Li">&quot;PerlIO_get_ptr&quot;</span> and
      <span class="Li">&quot;PerlIO_get_cnt&quot;</span>. The two values
      <i>must</i> be consistent with each other (implementation may only use one
      or the other or may require both).</dd>
  <dt id="PerlIO_canset_cnt(f)"><a class="permalink" href="#PerlIO_canset_cnt(f)"><b>PerlIO_canset_cnt(f)</b></a></dt>
  <dd>Implementation can adjust its idea of number of bytes in the buffer. Do
      not use this - use PerlIO_fast_gets.</dd>
  <dt id="PerlIO_set_cnt(f,c)"><a class="permalink" href="#PerlIO_set_cnt(f,c)"><b>PerlIO_set_cnt(f,c)</b></a></dt>
  <dd>Obscure - set count of bytes in the buffer. Deprecated. Only usable if
      <b>PerlIO_canset_cnt()</b> returns true. Currently used in only doio.c to
      force count less than -1 to -1. Perhaps should be PerlIO_set_empty or
      similar. This call may actually do nothing if &quot;count&quot; is deduced
      from pointer and a &quot;limit&quot;. Do not use this - use
      <b>PerlIO_set_ptrcnt()</b>.</dd>
  <dt id="PerlIO_has_base(f)"><a class="permalink" href="#PerlIO_has_base(f)"><b>PerlIO_has_base(f)</b></a></dt>
  <dd>Returns true if implementation has a buffer, and can return pointer to
      whole buffer and its size. Used by perl for <b>-T</b> / <b>-B</b> tests.
      Other uses would be very obscure...</dd>
  <dt id="PerlIO_get_base(f)"><a class="permalink" href="#PerlIO_get_base(f)"><b>PerlIO_get_base(f)</b></a></dt>
  <dd>Return <i>start</i> of buffer. Access only positive offsets in the buffer
      up to the value returned by <b>PerlIO_get_bufsiz()</b>.</dd>
  <dt id="PerlIO_get_bufsiz(f)"><a class="permalink" href="#PerlIO_get_bufsiz(f)"><b>PerlIO_get_bufsiz(f)</b></a></dt>
  <dd>Return the <i>total number of bytes</i> in the buffer, this is neither the
      number that can be read, nor the amount of memory allocated to the buffer.
      Rather it is what the operating system and/or implementation happened to
      <span class="Li">&quot;read()&quot;</span> (or whatever) last time IO was
      requested.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Other_Functions"><a class="permalink" href="#Other_Functions">Other
  Functions</a></h2>
<dl class="Bl-tag">
  <dt id="PerlIO_apply_layers(f,mode,layers)"><a class="permalink" href="#PerlIO_apply_layers(f,mode,layers)">PerlIO_apply_layers(f,mode,layers)</a></dt>
  <dd>The new interface to the USE_PERLIO implementation. The layers
      &quot;:crlf&quot; and &quot;:raw&quot; are only ones allowed for other
      implementations and those are silently ignored. (As of perl5.8
      &quot;:raw&quot; is deprecated.) Use <b>PerlIO_binmode()</b> below for the
      portable case.</dd>
  <dt id="PerlIO_binmode(f,ptype,imode,layers)"><a class="permalink" href="#PerlIO_binmode(f,ptype,imode,layers)">PerlIO_binmode(f,ptype,imode,layers)</a></dt>
  <dd>The hook used by perl's <span class="Li">&quot;binmode&quot;</span>
      operator. <b>ptype</b> is perl's character for the kind of IO:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>'&lt;' read</dt>
  <dd></dd>
  <dt>'&gt;' write</dt>
  <dd></dd>
  <dt>'+' read/write</dt>
  <dd></dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp"><b>imode</b> is <span class="Li">&quot;O_BINARY&quot;</span> or
    <span class="Li">&quot;O_TEXT&quot;</span>.</p>
<p class="Pp"><b>layers</b> is a string of layers to apply, only
    &quot;:crlf&quot; makes sense in the non USE_PERLIO case. (As of perl5.8
    &quot;:raw&quot; is deprecated in favour of passing NULL.)</p>
<p class="Pp">Portable cases are:</p>
<p class="Pp"></p>
<pre>    PerlIO_binmode(f,ptype,O_BINARY,NULL);
and
    PerlIO_binmode(f,ptype,O_TEXT,&quot;:crlf&quot;);
</pre>
<p class="Pp">On Unix these calls probably have no effect whatsoever. Elsewhere
    they alter &quot;\n&quot; to CR,LF translation and possibly cause a special
    text &quot;end of file&quot; indicator to be written or honoured on read.
    The effect of making the call after doing any IO to the handle depends on
    the implementation. (It may be ignored, affect any data which is already
    buffered as well, or only apply to subsequent data.)</p>
</div>
<dl class="Bl-tag">
  <dt id="PerlIO_debug(fmt,...)"><a class="permalink" href="#PerlIO_debug(fmt,...)">PerlIO_debug(fmt,...)</a></dt>
  <dd>PerlIO_debug is a <b>printf()</b>-like function which can be used for
      debugging. No return value. Its main use is inside PerlIO where using real
      printf, <b>warn()</b> etc. would recursively call PerlIO and be a problem.
    <p class="Pp">PerlIO_debug writes to the file named by
        <span class="Li">$ENV</span>{'PERLIO_DEBUG'} or defaults to stderr if
        the environment variable is not defined. Typical use might be</p>
    <p class="Pp"></p>
    <pre>  Bourne shells (sh, ksh, bash, zsh, ash, ...):
   PERLIO_DEBUG=/tmp/perliodebug.log ./perl -Di somescript some args
  Csh/Tcsh:
   setenv PERLIO_DEBUG /tmp/perliodebug.log
   ./perl -Di somescript some args
  If you have the &quot;env&quot; utility:
   env PERLIO_DEBUG=/tmp/perliodebug.log ./perl -Di somescript args
  Win32:
   set PERLIO_DEBUG=perliodebug.log
   perl -Di somescript some args
    </pre>
    <p class="Pp">On a Perl built without
        <span class="Li">&quot;-DDEBUGGING&quot;</span>, or when the
        <span class="Li">&quot;-Di&quot;</span> command-line switch is not
        specified, or under taint, <b>PerlIO_debug()</b> is a no-op.</p>
  </dd>
</dl>
</section>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os">perl v5.34.1</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PERLFAQ6(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLFAQ6(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLFAQ6(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlfaq6 - Regular Expressions</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp">version 5.20210411</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This section is surprisingly small because the rest of the FAQ is
    littered with answers involving regular expressions. For example, decoding a
    URL and checking whether something is a number can be handled with regular
    expressions, but those answers are found elsewhere in this document (in
    perlfaq9: &quot;How do I decode or create those %-encodings on the web&quot;
    and perlfaq4: &quot;How do I determine whether a scalar is a
    number/whole/integer/float&quot;, to be precise).</p>
<section class="Ss">
<h2 class="Ss" id="How_can_I_hope_to_use_regular_expressions_without_creating_illegible_and_unmaintainable_code?"><a class="permalink" href="#How_can_I_hope_to_use_regular_expressions_without_creating_illegible_and_unmaintainable_code?">How
  can I hope to use regular expressions without creating illegible and
  unmaintainable code?</a></h2>
<p class="Pp">Three techniques can make regular expressions maintainable and
    understandable.</p>
<dl class="Bl-tag">
  <dt id="Comments"><a class="permalink" href="#Comments">Comments Outside the
    Regex</a></dt>
  <dd>Describe what you're doing and how you're doing it, using normal Perl
      comments.
    <p class="Pp"></p>
    <pre>    # turn the line into the first word, a colon, and the
    # number of characters on the rest of the line
    s/^(\w+)(.*)/ lc($1) . &quot;:&quot; . length($2) /meg;
    </pre>
  </dd>
  <dt id="Comments~2"><a class="permalink" href="#Comments~2">Comments Inside
    the Regex</a></dt>
  <dd>The <span class="Li">&quot;/x&quot;</span> modifier causes whitespace to
      be ignored in a regex pattern (except in a character class and a few other
      places), and also allows you to use normal comments there, too. As you can
      imagine, whitespace and comments help a lot.
    <p class="Pp"><span class="Li">&quot;/x&quot;</span> lets you turn this:</p>
    <p class="Pp"></p>
    <pre>    s{&lt;(?:[^&gt;'&quot;]*|&quot;.*?&quot;|'.*?')+&gt;}{}gs;
    </pre>
    <p class="Pp">into this:</p>
    <p class="Pp"></p>
    <pre>    s{ &lt;                    # opening angle bracket
        (?:                 # Non-backreffing grouping paren
            [^&gt;'&quot;] *        # 0 or more things that are neither &gt; nor ' nor &quot;
                |           #    or else
            &quot;.*?&quot;           # a section between double quotes (stingy match)
                |           #    or else
            '.*?'           # a section between single quotes (stingy match)
        ) +                 #   all occurring one or more times
        &gt;                   # closing angle bracket
    }{}gsx;                 # replace with nothing, i.e. delete
    </pre>
    <p class="Pp">It's still not quite so clear as prose, but it is very useful
        for describing the meaning of each part of the pattern.</p>
  </dd>
  <dt id="Different"><a class="permalink" href="#Different">Different
    Delimiters</a></dt>
  <dd>While we normally think of patterns as being delimited with
      <span class="Li">&quot;/&quot;</span> characters, they can be delimited by
      almost any character. perlre describes this. For example, the
      <span class="Li">&quot;s///&quot;</span> above uses braces as delimiters.
      Selecting another delimiter can avoid quoting the delimiter within the
      pattern:
    <p class="Pp"></p>
    <pre>    s/\/usr\/local/\/usr\/share/g;    # bad delimiter choice
    s#/usr/local#/usr/share#g;        # better
    </pre>
    <p class="Pp">Using logically paired delimiters can be even more
      readable:</p>
    <p class="Pp"></p>
    <pre>    s{/usr/local/}{/usr/share}g;      # better still
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="I'm_having_trouble_matching_over_more_than_one_line._What's_wrong?"><a class="permalink" href="#I'm_having_trouble_matching_over_more_than_one_line._What's_wrong?">I'm
  having trouble matching over more than one line. What's wrong?</a></h2>
<p class="Pp">Either you don't have more than one line in the string you're
    looking at (probably), or else you aren't using the correct modifier(s) on
    your pattern (possibly).</p>
<p class="Pp">There are many ways to get multiline data into a string. If you
    want it to happen automatically while reading input, you'll want to set $/
    (probably to '' for paragraphs or <span class="Li">&quot;undef&quot;</span>
    for the whole file) to allow you to read more than one line at a time.</p>
<p class="Pp">Read perlre to help you decide which of
    <span class="Li">&quot;/s&quot;</span> and
    <span class="Li">&quot;/m&quot;</span> (or both) you might want to use:
    <span class="Li">&quot;/s&quot;</span> allows dot to include newline, and
    <span class="Li">&quot;/m&quot;</span> allows caret and dollar to match next
    to a newline, not just at the end of the string. You do need to make sure
    that you've actually got a multiline string in there.</p>
<p class="Pp">For example, this program detects duplicate words, even when they
    span line breaks (but not paragraph ones). For this example, we don't need
    <span class="Li">&quot;/s&quot;</span> because we aren't using dot in a
    regular expression that we want to cross line boundaries. Neither do we need
    <span class="Li">&quot;/m&quot;</span> because we don't want caret or dollar
    to match at any point inside the record next to newlines. But it's
    imperative that $/ be set to something other than the default, or else we
    won't actually ever have a multiline record read in.</p>
<p class="Pp"></p>
<pre>    $/ = '';          # read in whole paragraph, not just one line
    while ( &lt;&gt; ) {
        while ( /\b([\w'-]+)(\s+\g1)+\b/gi ) {     # word starts alpha
            print &quot;Duplicate $1 at paragraph $.\n&quot;;
        }
    }
</pre>
<p class="Pp">Here's some code that finds sentences that begin with &quot;From
    &quot; (which would be mangled by many mailers):</p>
<p class="Pp"></p>
<pre>    $/ = '';          # read in whole paragraph, not just one line
    while ( &lt;&gt; ) {
        while ( /^From /gm ) { # /m makes ^ match next to \n
        print &quot;leading From in paragraph $.\n&quot;;
        }
    }
</pre>
<p class="Pp">Here's code that finds everything between START and END in a
    paragraph:</p>
<p class="Pp"></p>
<pre>    undef $/;          # read in whole file, not just one line or paragraph
    while ( &lt;&gt; ) {
        while ( /START(.*?)END/sgm ) { # /s makes . cross line boundaries
            print &quot;$1\n&quot;;
        }
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_pull_out_lines_between_two_patterns_that_are_themselves_on_different_lines?"><a class="permalink" href="#How_can_I_pull_out_lines_between_two_patterns_that_are_themselves_on_different_lines?">How
  can I pull out lines between two patterns that are themselves on different
  lines?</a></h2>
<p class="Pp">You can use Perl's somewhat exotic
    <span class="Li">&quot;..&quot;</span> operator (documented in perlop):</p>
<p class="Pp"></p>
<pre>    perl -ne 'print if /START/ .. /END/' file1 file2 ...
</pre>
<p class="Pp">If you wanted text and not lines, you would use</p>
<p class="Pp"></p>
<pre>    perl -0777 -ne 'print &quot;$1\n&quot; while /START(.*?)END/gs' file1 file2 ...
</pre>
<p class="Pp">But if you want nested occurrences of
    <span class="Li">&quot;START&quot;</span> through
    <span class="Li">&quot;END&quot;</span>, you'll run up against the problem
    described in the question in this section on matching balanced text.</p>
<p class="Pp">Here's another example of using
    <span class="Li">&quot;..&quot;</span>:</p>
<p class="Pp"></p>
<pre>    while (&lt;&gt;) {
        my $in_header =   1  .. /^$/;
        my $in_body   = /^$/ .. eof;
    # now choose between them
    } continue {
        $. = 0 if eof;    # fix $.
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_match_"><a class="permalink" href="#How_do_I_match_">How
  do I match XML, HTML, or other nasty, ugly things with a regex?</a></h2>
<p class="Pp">Do not use regexes. Use a module and forget about the regular
    expressions. The XML::LibXML, HTML::TokeParser and HTML::TreeBuilder modules
    are good starts, although each namespace has other parsing modules
    specialized for certain tasks and different ways of doing it. Start at CPAN
    Search ( &lt;http://metacpan.org/&gt; ) and wonder at all the work people
    have done for you already! :)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="I_put_a_regular_expression_into_$/_but_it_didn't_work._What's_wrong?"><a class="permalink" href="#I_put_a_regular_expression_into_$/_but_it_didn't_work._What's_wrong?">I
  put a regular expression into $/ but it didn't work. What's wrong?</a></h2>
<p class="Pp">$/ has to be a string. You can use these examples if you really
    need to do this.</p>
<p class="Pp">If you have File::Stream, this is easy.</p>
<p class="Pp"></p>
<pre>    use File::Stream;
    my $stream = File::Stream-&gt;new(
        $filehandle,
        separator =&gt; qr/\s*,\s*/,
        );
    print &quot;$_\n&quot; while &lt;$stream&gt;;
</pre>
<p class="Pp">If you don't have File::Stream, you have to do a little more
  work.</p>
<p class="Pp">You can use the four-argument form of sysread to continually add
    to a buffer. After you add to the buffer, you check if you have a complete
    line (using your regular expression).</p>
<p class="Pp"></p>
<pre>    local $_ = &quot;&quot;;
    while( sysread FH, $_, 8192, length ) {
        while( s/^((?s).*?)your_pattern// ) {
            my $record = $1;
            # do stuff here.
        }
    }
</pre>
<p class="Pp">You can do the same thing with foreach and a match using the c
    flag and the \G anchor, if you do not mind your entire file being in memory
    at the end.</p>
<p class="Pp"></p>
<pre>    local $_ = &quot;&quot;;
    while( sysread FH, $_, 8192, length ) {
        foreach my $record ( m/\G((?s).*?)your_pattern/gc ) {
            # do stuff here.
        }
        substr( $_, 0, pos ) = &quot;&quot; if pos;
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_substitute_case-insensitively_on_the_"><a class="permalink" href="#How_do_I_substitute_case-insensitively_on_the_">How
  do I substitute case-insensitively on the LHS while preserving case on the
  RHS?</a></h2>
<p class="Pp">Here's a lovely Perlish solution by Larry Rosler. It exploits
    properties of bitwise xor on ASCII strings.</p>
<p class="Pp"></p>
<pre>    $_= &quot;this is a TEsT case&quot;;
    $old = 'test';
    $new = 'success';
    s{(\Q$old\E)}
    { uc $new | (uc $1 ^ $1) .
        (uc(substr $1, -1) ^ substr $1, -1) x
        (length($new) - length $1)
    }egi;
    print;
</pre>
<p class="Pp">And here it is as a subroutine, modeled after the above:</p>
<p class="Pp"></p>
<pre>    sub preserve_case {
        my ($old, $new) = @_;
        my $mask = uc $old ^ $old;
        uc $new | $mask .
            substr($mask, -1) x (length($new) - length($old))
    }
    $string = &quot;this is a TEsT case&quot;;
    $string =~ s/(test)/preserve_case($1, &quot;success&quot;)/egi;
    print &quot;$string\n&quot;;
</pre>
<p class="Pp">This prints:</p>
<p class="Pp"></p>
<pre>    this is a SUcCESS case
</pre>
<p class="Pp">As an alternative, to keep the case of the replacement word if it
    is longer than the original, you can use this code, by Jeff Pinyan:</p>
<p class="Pp"></p>
<pre>    sub preserve_case {
        my ($from, $to) = @_;
        my ($lf, $lt) = map length, @_;
        if ($lt &lt; $lf) { $from = substr $from, 0, $lt }
        else { $from .= substr $to, $lf }
        return uc $to | ($from ^ uc $from);
    }
</pre>
<p class="Pp">This changes the sentence to &quot;this is a SUcCess
  case.&quot;</p>
<p class="Pp">Just to show that C programmers can write C in any programming
    language, if you prefer a more C-like solution, the following script makes
    the substitution have the same case, letter by letter, as the original. (It
    also happens to run about 240% slower than the Perlish solution runs.) If
    the substitution has more characters than the string being substituted, the
    case of the last character is used for the rest of the substitution.</p>
<p class="Pp"></p>
<pre>    # Original by Nathan Torkington, massaged by Jeffrey Friedl
    #
    sub preserve_case
    {
        my ($old, $new) = @_;
        my $state = 0; # 0 = no change; 1 = lc; 2 = uc
        my ($i, $oldlen, $newlen, $c) = (0, length($old), length($new));
        my $len = $oldlen &lt; $newlen ? $oldlen : $newlen;
        for ($i = 0; $i &lt; $len; $i++) {
            if ($c = substr($old, $i, 1), $c =~ /[\W\d_]/) {
                $state = 0;
            } elsif (lc $c eq $c) {
                substr($new, $i, 1) = lc(substr($new, $i, 1));
                $state = 1;
            } else {
                substr($new, $i, 1) = uc(substr($new, $i, 1));
                $state = 2;
            }
        }
        # finish up with any remaining new (for when new is longer than old)
        if ($newlen &gt; $oldlen) {
            if ($state == 1) {
                substr($new, $oldlen) = lc(substr($new, $oldlen));
            } elsif ($state == 2) {
                substr($new, $oldlen) = uc(substr($new, $oldlen));
            }
        }
        return $new;
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_make__"><a class="permalink" href="#How_can_I_make__">How
  can I make &quot;\w&quot; match national character sets?</a></h2>
<p class="Pp">Put <span class="Li">&quot;use locale;&quot;</span> in your
    script. The \w character class is taken from the current locale.</p>
<p class="Pp">See perllocale for details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_match_a_locale-smart_version_of__/_a"><a class="permalink" href="#How_can_I_match_a_locale-smart_version_of__/_a">How
  can I match a locale-smart version of &quot;/[a-zA-Z]/&quot;?</a></h2>
<p class="Pp">You can use the POSIX character class syntax
    <span class="Li">&quot;/[[:alpha:]]/&quot;</span> documented in perlre.</p>
<p class="Pp">No matter which locale you are in, the alphabetic characters are
    the characters in \w without the digits and the underscore. As a regex, that
    looks like <span class="Li">&quot;/[^\W\d_]/&quot;</span>. Its complement,
    the non-alphabetics, is then everything in \W along with the digits and the
    underscore, or <span class="Li">&quot;/[\W\d_]/&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_quote_a_variable_to_use_in_a_regex?"><a class="permalink" href="#How_can_I_quote_a_variable_to_use_in_a_regex?">How
  can I quote a variable to use in a regex?</a></h2>
<p class="Pp">The Perl parser will expand <span class="Li">$variable</span> and
    <span class="Li">@variable</span> references in regular expressions unless
    the delimiter is a single quote. Remember, too, that the right-hand side of
    a <span class="Li">&quot;s///&quot;</span> substitution is considered a
    double-quoted string (see perlop for more details). Remember also that any
    regex special characters will be acted on unless you precede the
    substitution with \Q. Here's an example:</p>
<p class="Pp"></p>
<pre>    $string = &quot;Placido P. Octopus&quot;;
    $regex  = &quot;P.&quot;;
    $string =~ s/$regex/Polyp/;
    # $string is now &quot;Polypacido P. Octopus&quot;
</pre>
<p class="Pp">Because <span class="Li">&quot;.&quot;</span> is special in
    regular expressions, and can match any single character, the regex
    <span class="Li">&quot;P.&quot;</span> here has matched the &lt;Pl&gt; in
    the original string.</p>
<p class="Pp">To escape the special meaning of
    <span class="Li">&quot;.&quot;</span>, we use
    <span class="Li">&quot;\Q&quot;</span>:</p>
<p class="Pp"></p>
<pre>    $string = &quot;Placido P. Octopus&quot;;
    $regex  = &quot;P.&quot;;
    $string =~ s/\Q$regex/Polyp/;
    # $string is now &quot;Placido Polyp Octopus&quot;
</pre>
<p class="Pp">The use of <span class="Li">&quot;\Q&quot;</span> causes the
    <span class="Li">&quot;.&quot;</span> in the regex to be treated as a
    regular character, so that <span class="Li">&quot;P.&quot;</span> matches a
    <span class="Li">&quot;P&quot;</span> followed by a dot.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="What_is__/o__really_for?"><a class="permalink" href="#What_is__/o__really_for?">What
  is &quot;/o&quot; really for?</a></h2>
<p class="Pp">(contributed by brian d foy)</p>
<p class="Pp">The <span class="Li">&quot;/o&quot;</span> option for regular
    expressions (documented in perlop and perlreref) tells Perl to compile the
    regular expression only once. This is only useful when the pattern contains
    a variable. Perls 5.6 and later handle this automatically if the pattern
    does not change.</p>
<p class="Pp">Since the match operator <span class="Li">&quot;m//&quot;</span>,
    the substitution operator <span class="Li">&quot;s///&quot;</span>, and the
    regular expression quoting operator <span class="Li">&quot;qr//&quot;</span>
    are double-quotish constructs, you can interpolate variables into the
    pattern. See the answer to &quot;How can I quote a variable to use in a
    regex?&quot; for more details.</p>
<p class="Pp">This example takes a regular expression from the argument list and
    prints the lines of input that match it:</p>
<p class="Pp"></p>
<pre>    my $pattern = shift @ARGV;
    while( &lt;&gt; ) {
        print if m/$pattern/;
    }
</pre>
<p class="Pp">Versions of Perl prior to 5.6 would recompile the regular
    expression for each iteration, even if <span class="Li">$pattern</span> had
    not changed. The <span class="Li">&quot;/o&quot;</span> would prevent this
    by telling Perl to compile the pattern the first time, then reuse that for
    subsequent iterations:</p>
<p class="Pp"></p>
<pre>    my $pattern = shift @ARGV;
    while( &lt;&gt; ) {
        print if m/$pattern/o; # useful for Perl &lt; 5.6
    }
</pre>
<p class="Pp">In versions 5.6 and later, Perl won't recompile the regular
    expression if the variable hasn't changed, so you probably don't need the
    <span class="Li">&quot;/o&quot;</span> option. It doesn't hurt, but it
    doesn't help either. If you want any version of Perl to compile the regular
    expression only once even if the variable changes (thus, only using its
    initial value), you still need the
  <span class="Li">&quot;/o&quot;</span>.</p>
<p class="Pp">You can watch Perl's regular expression engine at work to verify
    for yourself if Perl is recompiling a regular expression. The
    <span class="Li">&quot;use re</span> <span class="Li">'debug'&quot;</span>
    pragma (comes with Perl 5.005 and later) shows the details. With Perls
    before 5.6, you should see <span class="Li">&quot;re&quot;</span> reporting
    that its compiling the regular expression on each iteration. With Perl 5.6
    or later, you should only see <span class="Li">&quot;re&quot;</span> report
    that for the first iteration.</p>
<p class="Pp"></p>
<pre>    use re 'debug';
    my $regex = 'Perl';
    foreach ( qw(Perl Java Ruby Python) ) {
        print STDERR &quot;-&quot; x 73, &quot;\n&quot;;
        print STDERR &quot;Trying $_...\n&quot;;
        print STDERR &quot;\t$_ is good!\n&quot; if m/$regex/;
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_use_a_regular_expression_to_strip_C"><a class="permalink" href="#How_do_I_use_a_regular_expression_to_strip_C">How
  do I use a regular expression to strip C-style comments from a file?</a></h2>
<p class="Pp">While this actually can be done, it's much harder than you'd
    think. For example, this one-liner</p>
<p class="Pp"></p>
<pre>    perl -0777 -pe 's{/\*.*?\*/}{}gs' foo.c
</pre>
<p class="Pp">will work in many but not all cases. You see, it's too
    simple-minded for certain kinds of C programs, in particular, those with
    what appear to be comments in quoted strings. For that, you'd need something
    like this, created by Jeffrey Friedl and later modified by Fred Curtis.</p>
<p class="Pp"></p>
<pre>    $/ = undef;
    $_ = &lt;&gt;;
    s#/\*[^*]*\*+([^/*][^*]*\*+)*/|(&quot;(\\.|[^&quot;\\])*&quot;|'(\\.|[^'\\])*'|.[^/&quot;'\\]*)#defined $2 ? $2 : &quot;&quot;#gse;
    print;
</pre>
<p class="Pp">This could, of course, be more legibly written with the
    <span class="Li">&quot;/x&quot;</span> modifier, adding whitespace and
    comments. Here it is expanded, courtesy of Fred Curtis.</p>
<p class="Pp"></p>
<pre>    s{
       /\*         ##  Start of /* ... */ comment
       [^*]*\*+    ##  Non-* followed by 1-or-more *'s
       (
         [^/*][^*]*\*+
       )*          ##  0-or-more things which don't start with /
                   ##    but do end with '*'
       /           ##  End of /* ... */ comment
     |         ##     OR  various things which aren't comments:
       (
         &quot;           ##  Start of &quot; ... &quot; string
         (
           \\.           ##  Escaped char
         |               ##    OR
           [^&quot;\\]        ##  Non &quot;\
         )*
         &quot;           ##  End of &quot; ... &quot; string
       |         ##     OR
         '           ##  Start of ' ... ' string
         (
           \\.           ##  Escaped char
         |               ##    OR
           [^'\\]        ##  Non '\
         )*
         '           ##  End of ' ... ' string
       |         ##     OR
         .           ##  Anything other char
         [^/&quot;'\\]*   ##  Chars which doesn't start a comment, string or escape
       )
     }{defined $2 ? $2 : &quot;&quot;}gxse;
</pre>
<p class="Pp">A slight modification also removes C++ comments, possibly spanning
    multiple lines using a continuation character:</p>
<p class="Pp"></p>
<pre> s#/\*[^*]*\*+([^/*][^*]*\*+)*/|//([^\\]|[^\n][\n]?)*?\n|(&quot;(\\.|[^&quot;\\])*&quot;|'(\\.|[^'\\])*'|.[^/&quot;'\\]*)#defined $3 ? $3 : &quot;&quot;#gse;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Can_I_use_Perl_regular_expressions_to_match_balanced_text?"><a class="permalink" href="#Can_I_use_Perl_regular_expressions_to_match_balanced_text?">Can
  I use Perl regular expressions to match balanced text?</a></h2>
<p class="Pp">(contributed by brian d foy)</p>
<p class="Pp">Your first try should probably be the Text::Balanced module, which
    is in the Perl standard library since Perl 5.8. It has a variety of
    functions to deal with tricky text. The Regexp::Common module can also help
    by providing canned patterns you can use.</p>
<p class="Pp">As of Perl 5.10, you can match balanced text with regular
    expressions using recursive patterns. Before Perl 5.10, you had to resort to
    various tricks such as using Perl code in
    <span class="Li">&quot;(??{})&quot;</span> sequences.</p>
<p class="Pp">Here's an example using a recursive regular expression. The goal
    is to capture all of the text within angle brackets, including the text in
    nested angle brackets. This sample text has two &quot;major&quot; groups: a
    group with one level of nesting and a group with two levels of nesting.
    There are five total groups in angle brackets:</p>
<p class="Pp"></p>
<pre>    I have some &lt;brackets in &lt;nested brackets&gt; &gt; and
    &lt;another group &lt;nested once &lt;nested twice&gt; &gt; &gt;
    and that's it.
</pre>
<p class="Pp">The regular expression to match the balanced text uses two new (to
    Perl 5.10) regular expression features. These are covered in perlre and this
    example is a modified version of one in that documentation.</p>
<p class="Pp">First, adding the new possessive
    <span class="Li">&quot;+&quot;</span> to any quantifier finds the longest
    match and does not backtrack. That's important since you want to handle any
    angle brackets through the recursion, not backtracking. The group
    <span class="Li">&quot;[^&lt;&gt;]++&quot;</span> finds one or more
    non-angle brackets without backtracking.</p>
<p class="Pp">Second, the new <span class="Li">&quot;(?PARNO)&quot;</span>
    refers to the sub-pattern in the particular capture group given by
    <span class="Li">&quot;PARNO&quot;</span>. In the following regex, the first
    capture group finds (and remembers) the balanced text, and you need that
    same pattern within the first buffer to get past the nested text. That's the
    recursive part. The <span class="Li">&quot;(?1)&quot;</span> uses the
    pattern in the outer capture group as an independent part of the regex.</p>
<p class="Pp">Putting it all together, you have:</p>
<p class="Pp"></p>
<pre>    #!/usr/local/bin/perl5.10.0
    my $string =&lt;&lt;&quot;HERE&quot;;
    I have some &lt;brackets in &lt;nested brackets&gt; &gt; and
    &lt;another group &lt;nested once &lt;nested twice&gt; &gt; &gt;
    and that's it.
    HERE
    my @groups = $string =~ m/
            (                   # start of capture group 1
            &lt;                   # match an opening angle bracket
                (?:
                    [^&lt;&gt;]++     # one or more non angle brackets, non backtracking
                      |
                    (?1)        # found &lt; or &gt;, so recurse to capture group 1
                )*
            &gt;                   # match a closing angle bracket
            )                   # end of capture group 1
            /xg;
    $&quot; = &quot;\n\t&quot;;
    print &quot;Found:\n\t@groups\n&quot;;
</pre>
<p class="Pp">The output shows that Perl found the two major groups:</p>
<p class="Pp"></p>
<pre>    Found:
        &lt;brackets in &lt;nested brackets&gt; &gt;
        &lt;another group &lt;nested once &lt;nested twice&gt; &gt; &gt;
</pre>
<p class="Pp">With a little extra work, you can get all of the groups in angle
    brackets even if they are in other angle brackets too. Each time you get a
    balanced match, remove its outer delimiter (that's the one you just matched
    so don't match it again) and add it to a queue of strings to process. Keep
    doing that until you get no matches:</p>
<p class="Pp"></p>
<pre>    #!/usr/local/bin/perl5.10.0
    my @queue =&lt;&lt;&quot;HERE&quot;;
    I have some &lt;brackets in &lt;nested brackets&gt; &gt; and
    &lt;another group &lt;nested once &lt;nested twice&gt; &gt; &gt;
    and that's it.
    HERE
    my $regex = qr/
            (                   # start of bracket 1
            &lt;                   # match an opening angle bracket
                (?:
                    [^&lt;&gt;]++     # one or more non angle brackets, non backtracking
                      |
                    (?1)        # recurse to bracket 1
                )*
            &gt;                   # match a closing angle bracket
            )                   # end of bracket 1
            /x;
    $&quot; = &quot;\n\t&quot;;
    while( @queue ) {
        my $string = shift @queue;
        my @groups = $string =~ m/$regex/g;
        print &quot;Found:\n\t@groups\n\n&quot; if @groups;
        unshift @queue, map { s/^&lt;//; s/&gt;$//; $_ } @groups;
    }
</pre>
<p class="Pp">The output shows all of the groups. The outermost matches show up
    first and the nested matches show up later:</p>
<p class="Pp"></p>
<pre>    Found:
        &lt;brackets in &lt;nested brackets&gt; &gt;
        &lt;another group &lt;nested once &lt;nested twice&gt; &gt; &gt;
    Found:
        &lt;nested brackets&gt;
    Found:
        &lt;nested once &lt;nested twice&gt; &gt;
    Found:
        &lt;nested twice&gt;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="What_does_it_mean_that_regexes_are_greedy?_How_can_I_get_around_it?"><a class="permalink" href="#What_does_it_mean_that_regexes_are_greedy?_How_can_I_get_around_it?">What
  does it mean that regexes are greedy? How can I get around it?</a></h2>
<p class="Pp">Most people mean that greedy regexes match as much as they can.
    Technically speaking, it's actually the quantifiers
    (<span class="Li">&quot;?&quot;</span>,
    <span class="Li">&quot;*&quot;</span>,
    <span class="Li">&quot;+&quot;</span>,
    <span class="Li">&quot;{}&quot;</span>) that are greedy rather than the
    whole pattern; Perl prefers local greed and immediate gratification to
    overall greed. To get non-greedy versions of the same quantifiers, use
    (<span class="Li">&quot;??&quot;</span>,
    <span class="Li">&quot;*?&quot;</span>,
    <span class="Li">&quot;+?&quot;</span>,
    <span class="Li">&quot;{}?&quot;</span>).</p>
<p class="Pp">An example:</p>
<p class="Pp"></p>
<pre>    my $s1 = my $s2 = &quot;I am very very cold&quot;;
    $s1 =~ s/ve.*y //;      # I am cold
    $s2 =~ s/ve.*?y //;     # I am very cold
</pre>
<p class="Pp">Notice how the second substitution stopped matching as soon as it
    encountered &quot;y &quot;. The <span class="Li">&quot;*?&quot;</span>
    quantifier effectively tells the regular expression engine to find a match
    as quickly as possible and pass control on to whatever is next in line, as
    you would if you were playing hot potato.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_process_each_word_on_each_line?"><a class="permalink" href="#How_do_I_process_each_word_on_each_line?">How
  do I process each word on each line?</a></h2>
<p class="Pp">Use the split function:</p>
<p class="Pp"></p>
<pre>    while (&lt;&gt;) {
        foreach my $word ( split ) {
            # do something with $word here
        }
    }
</pre>
<p class="Pp">Note that this isn't really a word in the English sense; it's just
    chunks of consecutive non-whitespace characters.</p>
<p class="Pp">To work with only alphanumeric sequences (including underscores),
    you might consider</p>
<p class="Pp"></p>
<pre>    while (&lt;&gt;) {
        foreach $word (m/(\w+)/g) {
            # do something with $word here
        }
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_print_out_a_word-frequency_or_line-frequency_summary?"><a class="permalink" href="#How_can_I_print_out_a_word-frequency_or_line-frequency_summary?">How
  can I print out a word-frequency or line-frequency summary?</a></h2>
<p class="Pp">To do this, you have to parse out each word in the input stream.
    We'll pretend that by word you mean chunk of alphabetics, hyphens, or
    apostrophes, rather than the non-whitespace chunk idea of a word given in
    the previous question:</p>
<p class="Pp"></p>
<pre>    my (%seen);
    while (&lt;&gt;) {
        while ( /(\b[^\W_\d][\w'-]+\b)/g ) {   # misses &quot;`sheep'&quot;
            $seen{$1}++;
        }
    }
    while ( my ($word, $count) = each %seen ) {
        print &quot;$count $word\n&quot;;
    }
</pre>
<p class="Pp">If you wanted to do the same thing for lines, you wouldn't need a
    regular expression:</p>
<p class="Pp"></p>
<pre>    my (%seen);
    while (&lt;&gt;) {
        $seen{$_}++;
    }
    while ( my ($line, $count) = each %seen ) {
        print &quot;$count $line&quot;;
    }
</pre>
<p class="Pp">If you want these output in a sorted order, see perlfaq4:
    &quot;How do I sort a hash (optionally by value instead of key)?&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_do_approximate_matching?"><a class="permalink" href="#How_can_I_do_approximate_matching?">How
  can I do approximate matching?</a></h2>
<p class="Pp">See the module String::Approx available from CPAN.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_efficiently_match_many_regular_expressions_at_once?"><a class="permalink" href="#How_do_I_efficiently_match_many_regular_expressions_at_once?">How
  do I efficiently match many regular expressions at once?</a></h2>
<p class="Pp">(contributed by brian d foy)</p>
<p class="Pp">You want to avoid compiling a regular expression every time you
    want to match it. In this example, perl must recompile the regular
    expression for every iteration of the
    <span class="Li">&quot;foreach&quot;</span> loop since
    <span class="Li">$pattern</span> can change:</p>
<p class="Pp"></p>
<pre>    my @patterns = qw( fo+ ba[rz] );
    LINE: while( my $line = &lt;&gt; ) {
        foreach my $pattern ( @patterns ) {
            if( $line =~ m/\b$pattern\b/i ) {
                print $line;
                next LINE;
            }
        }
    }
</pre>
<p class="Pp">The <span class="Li">&quot;qr//&quot;</span> operator compiles a
    regular expression, but doesn't apply it. When you use the pre-compiled
    version of the regex, perl does less work. In this example, I inserted a
    <span class="Li">&quot;map&quot;</span> to turn each pattern into its
    pre-compiled form. The rest of the script is the same, but faster:</p>
<p class="Pp"></p>
<pre>    my @patterns = map { qr/\b$_\b/i } qw( fo+ ba[rz] );
    LINE: while( my $line = &lt;&gt; ) {
        foreach my $pattern ( @patterns ) {
            if( $line =~ m/$pattern/ ) {
                print $line;
                next LINE;
            }
        }
    }
</pre>
<p class="Pp">In some cases, you may be able to make several patterns into a
    single regular expression. Beware of situations that require backtracking
    though. In this example, the regex is only compiled once because
    <span class="Li">$regex</span> doesn't change between iterations:</p>
<p class="Pp"></p>
<pre>    my $regex = join '|', qw( fo+ ba[rz] );
    while( my $line = &lt;&gt; ) {
        print if $line =~ m/\b(?:$regex)\b/i;
    }
</pre>
<p class="Pp">The function &quot;list2re&quot; in Data::Munge on CPAN can also
    be used to form a single regex that matches a list of literal strings (not
    regexes).</p>
<p class="Pp">For more details on regular expression efficiency, see
    <i>Mastering</i> <i>Regular Expressions</i> by Jeffrey Friedl. He explains
    how the regular expressions engine works and why some patterns are
    surprisingly inefficient. Once you understand how perl applies regular
    expressions, you can tune them for individual situations.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Why_don't_word-boundary_searches_with__"><a class="permalink" href="#Why_don't_word-boundary_searches_with__">Why
  don't word-boundary searches with &quot;\b&quot; work for me?</a></h2>
<p class="Pp">(contributed by brian d foy)</p>
<p class="Pp">Ensure that you know what \b really does: it's the boundary
    between a word character, \w, and something that isn't a word character.
    That thing that isn't a word character might be \W, but it can also be the
    start or end of the string.</p>
<p class="Pp">It's not (not!) the boundary between whitespace and
    non-whitespace, and it's not the stuff between words we use to create
    sentences.</p>
<p class="Pp">In regex speak, a word boundary (\b) is a &quot;zero width
    assertion&quot;, meaning that it doesn't represent a character in the
    string, but a condition at a certain position.</p>
<p class="Pp">For the regular expression, /\bPerl\b/, there has to be a word
    boundary before the &quot;P&quot; and after the &quot;l&quot;. As long as
    something other than a word character precedes the &quot;P&quot; and
    succeeds the &quot;l&quot;, the pattern will match. These strings match
    /\bPerl\b/.</p>
<p class="Pp"></p>
<pre>    &quot;Perl&quot;    # no word char before &quot;P&quot; or after &quot;l&quot;
    &quot;Perl &quot;   # same as previous (space is not a word char)
    &quot;'Perl'&quot;  # the &quot;'&quot; char is not a word char
    &quot;Perl's&quot;  # no word char before &quot;P&quot;, non-word char after &quot;l&quot;
</pre>
<p class="Pp">These strings do not match /\bPerl\b/.</p>
<p class="Pp"></p>
<pre>    &quot;Perl_&quot;   # &quot;_&quot; is a word char!
    &quot;Perler&quot;  # no word char before &quot;P&quot;, but one after &quot;l&quot;
</pre>
<p class="Pp">You don't have to use \b to match words though. You can look for
    non-word characters surrounded by word characters. These strings match the
    pattern /\b'\b/.</p>
<p class="Pp"></p>
<pre>    &quot;don't&quot;   # the &quot;'&quot; char is surrounded by &quot;n&quot; and &quot;t&quot;
    &quot;qep'a'&quot;  # the &quot;'&quot; char is surrounded by &quot;p&quot; and &quot;a&quot;
</pre>
<p class="Pp">These strings do not match /\b'\b/.</p>
<p class="Pp"></p>
<pre>    &quot;foo'&quot;    # there is no word char after non-word &quot;'&quot;
</pre>
<p class="Pp">You can also use the complement of \b, \B, to specify that there
    should not be a word boundary.</p>
<p class="Pp">In the pattern /\Bam\B/, there must be a word character before the
    &quot;a&quot; and after the &quot;m&quot;. These patterns match
  /\Bam\B/:</p>
<p class="Pp"></p>
<pre>    &quot;llama&quot;   # &quot;am&quot; surrounded by word chars
    &quot;Samuel&quot;  # same
</pre>
<p class="Pp">These strings do not match /\Bam\B/</p>
<p class="Pp"></p>
<pre>    &quot;Sam&quot;      # no word boundary before &quot;a&quot;, but one after &quot;m&quot;
    &quot;I am Sam&quot; # &quot;am&quot; surrounded by non-word chars
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Why_does_using_$&amp;,_$_,_or_$'_slow_my_program_down?"><a class="permalink" href="#Why_does_using_$&amp;,_$_,_or_$'_slow_my_program_down?">Why
  does using $&amp;, $`, or $' slow my program down?</a></h2>
<p class="Pp">(contributed by Anno Siegel)</p>
<p class="Pp">Once Perl sees that you need one of these variables anywhere in
    the program, it provides them on each and every pattern match. That means
    that on every pattern match the entire string will be copied, part of it to
    $`, part to $&amp;, and part to $'. Thus the penalty is most severe with
    long strings and patterns that match often. Avoid $&amp;, $', and $` if you
    can, but if you can't, once you've used them at all, use them at will
    because you've already paid the price. Remember that some algorithms really
    appreciate them. As of the 5.005 release, the $&amp; variable is no longer
    &quot;expensive&quot; the way the other two are.</p>
<p class="Pp">Since Perl 5.6.1 the special variables @- and @+ can functionally
    replace $`, $&amp; and $'. These arrays contain pointers to the beginning
    and end of each match (see perlvar for the full story), so they give you
    essentially the same information, but without the risk of excessive string
    copying.</p>
<p class="Pp">Perl 5.10 added three specials,
    <span class="Li">&quot;${^MATCH}&quot;</span>,
    <span class="Li">&quot;${^PREMATCH}&quot;</span>, and
    <span class="Li">&quot;${^POSTMATCH}&quot;</span> to do the same job but
    without the global performance penalty. Perl 5.10 only sets these variables
    if you compile or execute the regular expression with the
    <span class="Li">&quot;/p&quot;</span> modifier.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="What_good_is__"><a class="permalink" href="#What_good_is__">What
  good is &quot;\G&quot; in a regular expression?</a></h2>
<p class="Pp">You use the <span class="Li">&quot;\G&quot;</span> anchor to start
    the next match on the same string where the last match left off. The regular
    expression engine cannot skip over any characters to find the next match
    with this anchor, so <span class="Li">&quot;\G&quot;</span> is similar to
    the beginning of string anchor, <span class="Li">&quot;^&quot;</span>. The
    <span class="Li">&quot;\G&quot;</span> anchor is typically used with the
    <span class="Li">&quot;g&quot;</span> modifier. It uses the value of
    <span class="Li">&quot;pos()&quot;</span> as the position to start the next
    match. As the match operator makes successive matches, it updates
    <span class="Li">&quot;pos()&quot;</span> with the position of the next
    character past the last match (or the first character of the next match,
    depending on how you like to look at it). Each string has its own
    <span class="Li">&quot;pos()&quot;</span> value.</p>
<p class="Pp">Suppose you want to match all of consecutive pairs of digits in a
    string like &quot;1122a44&quot; and stop matching when you encounter
    non-digits. You want to match <span class="Li">11</span> and
    <span class="Li">22</span> but the letter
    <span class="Li">&quot;a&quot;</span> shows up between
    <span class="Li">22</span> and <span class="Li">44</span> and you want to
    stop at <span class="Li">&quot;a&quot;</span>. Simply matching pairs of
    digits skips over the <span class="Li">&quot;a&quot;</span> and still
    matches <span class="Li">44</span>.</p>
<p class="Pp"></p>
<pre>    $_ = &quot;1122a44&quot;;
    my @pairs = m/(\d\d)/g;   # qw( 11 22 44 )
</pre>
<p class="Pp">If you use the <span class="Li">&quot;\G&quot;</span> anchor, you
    force the match after <span class="Li">22</span> to start with the
    <span class="Li">&quot;a&quot;</span>. The regular expression cannot match
    there since it does not find a digit, so the next match fails and the match
    operator returns the pairs it already found.</p>
<p class="Pp"></p>
<pre>    $_ = &quot;1122a44&quot;;
    my @pairs = m/\G(\d\d)/g; # qw( 11 22 )
</pre>
<p class="Pp">You can also use the <span class="Li">&quot;\G&quot;</span> anchor
    in scalar context. You still need the <span class="Li">&quot;g&quot;</span>
    modifier.</p>
<p class="Pp"></p>
<pre>    $_ = &quot;1122a44&quot;;
    while( m/\G(\d\d)/g ) {
        print &quot;Found $1\n&quot;;
    }
</pre>
<p class="Pp">After the match fails at the letter
    <span class="Li">&quot;a&quot;</span>, perl resets
    <span class="Li">&quot;pos()&quot;</span> and the next match on the same
    string starts at the beginning.</p>
<p class="Pp"></p>
<pre>    $_ = &quot;1122a44&quot;;
    while( m/\G(\d\d)/g ) {
        print &quot;Found $1\n&quot;;
    }
    print &quot;Found $1 after while&quot; if m/(\d\d)/g; # finds &quot;11&quot;
</pre>
<p class="Pp">You can disable <span class="Li">&quot;pos()&quot;</span> resets
    on fail with the <span class="Li">&quot;c&quot;</span> modifier, documented
    in perlop and perlreref. Subsequent matches start where the last successful
    match ended (the value of <span class="Li">&quot;pos()&quot;</span>) even if
    a match on the same string has failed in the meantime. In this case, the
    match after the <span class="Li">&quot;while()&quot;</span> loop starts at
    the <span class="Li">&quot;a&quot;</span> (where the last match stopped),
    and since it does not use any anchor it can skip over the
    <span class="Li">&quot;a&quot;</span> to find
  <span class="Li">44</span>.</p>
<p class="Pp"></p>
<pre>    $_ = &quot;1122a44&quot;;
    while( m/\G(\d\d)/gc ) {
        print &quot;Found $1\n&quot;;
    }
    print &quot;Found $1 after while&quot; if m/(\d\d)/g; # finds &quot;44&quot;
</pre>
<p class="Pp">Typically you use the <span class="Li">&quot;\G&quot;</span>
    anchor with the <span class="Li">&quot;c&quot;</span> modifier when you want
    to try a different match if one fails, such as in a tokenizer. Jeffrey
    Friedl offers this example which works in 5.004 or later.</p>
<p class="Pp"></p>
<pre>    while (&lt;&gt;) {
        chomp;
        PARSER: {
            m/ \G( \d+\b    )/gcx   &amp;&amp; do { print &quot;number: $1\n&quot;;  redo; };
            m/ \G( \w+      )/gcx   &amp;&amp; do { print &quot;word:   $1\n&quot;;  redo; };
            m/ \G( \s+      )/gcx   &amp;&amp; do { print &quot;space:  $1\n&quot;;  redo; };
            m/ \G( [^\w\d]+ )/gcx   &amp;&amp; do { print &quot;other:  $1\n&quot;;  redo; };
        }
    }
</pre>
<p class="Pp">For each line, the <span class="Li">&quot;PARSER&quot;</span> loop
    first tries to match a series of digits followed by a word boundary. This
    match has to start at the place the last match left off (or the beginning of
    the string on the first match). Since <span class="Li">&quot;m/ \G(
    \d+\b</span> <span class="Li">)/gcx&quot;</span> uses the
    <span class="Li">&quot;c&quot;</span> modifier, if the string does not match
    that regular expression, perl does not reset <b>pos()</b> and the next match
    starts at the same position to try a different pattern.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Are_Perl_regexes_DFAs_or_NFAs?_Are_they_"><a class="permalink" href="#Are_Perl_regexes_DFAs_or_NFAs?_Are_they_">Are
  Perl regexes DFAs or NFAs? Are they POSIX compliant?</a></h2>
<p class="Pp">While it's true that Perl's regular expressions resemble the DFAs
    (deterministic finite automata) of the <b>egrep</b>(1) program, they are in
    fact implemented as NFAs (non-deterministic finite automata) to allow
    backtracking and backreferencing. And they aren't POSIX-style either,
    because those guarantee worst-case behavior for all cases. (It seems that
    some people prefer guarantees of consistency, even when what's guaranteed is
    slowness.) See the book &quot;Mastering Regular Expressions&quot; (from
    O'Reilly) by Jeffrey Friedl for all the details you could ever hope to know
    on these matters (a full citation appears in perlfaq2).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="What's_wrong_with_using_grep_in_a_void_context?"><a class="permalink" href="#What's_wrong_with_using_grep_in_a_void_context?">What's
  wrong with using grep in a void context?</a></h2>
<p class="Pp">The problem is that grep builds a return list, regardless of the
    context. This means you're making Perl go to the trouble of building a list
    that you then just throw away. If the list is large, you waste both time and
    space. If your intent is to iterate over the list, then use a for loop for
    this purpose.</p>
<p class="Pp">In perls older than 5.8.1, map suffers from this problem as well.
    But since 5.8.1, this has been fixed, and map is context aware - in void
    context, no lists are constructed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_can_I_match_strings_with_multibyte_characters?"><a class="permalink" href="#How_can_I_match_strings_with_multibyte_characters?">How
  can I match strings with multibyte characters?</a></h2>
<p class="Pp">Starting from Perl 5.6 Perl has had some level of multibyte
    character support. Perl 5.8 or later is recommended. Supported multibyte
    character repertoires include Unicode, and legacy encodings through the
    Encode module. See perluniintro, perlunicode, and Encode.</p>
<p class="Pp">If you are stuck with older Perls, you can do Unicode with the
    Unicode::String module, and character conversions using the Unicode::Map8
    and Unicode::Map modules. If you are using Japanese encodings, you might try
    using the jperl 5.005_03.</p>
<p class="Pp">Finally, the following set of approaches was offered by Jeffrey
    Friedl, whose article in issue #5 of The Perl Journal talks about this very
    matter.</p>
<p class="Pp">Let's suppose you have some weird Martian encoding where pairs of
    ASCII uppercase letters encode single Martian letters (i.e. the two bytes
    &quot;CV&quot; make a single Martian letter, as do the two bytes
    &quot;SG&quot;, &quot;VS&quot;, &quot;XX&quot;, etc.). Other bytes represent
    single characters, just like ASCII.</p>
<p class="Pp">So, the string of Martian &quot;I am CVSGXX!&quot; uses 12 bytes
    to encode the nine characters 'I', ' ', 'a', 'm', ' ', 'CV', 'SG', 'XX',
    '!'.</p>
<p class="Pp">Now, say you want to search for the single character
    <span class="Li">&quot;/GX/&quot;</span>. Perl doesn't know about Martian,
    so it'll find the two bytes &quot;GX&quot; in the &quot;I am CVSGXX!&quot;
    string, even though that character isn't there: it just looks like it is
    because &quot;SG&quot; is next to &quot;XX&quot;, but there's no real
    &quot;GX&quot;. This is a big problem.</p>
<p class="Pp">Here are a few ways, all painful, to deal with it:</p>
<p class="Pp"></p>
<pre>    # Make sure adjacent &quot;martian&quot; bytes are no longer adjacent.
    $martian =~ s/([A-Z][A-Z])/ $1 /g;
    print &quot;found GX!\n&quot; if $martian =~ /GX/;
</pre>
<p class="Pp">Or like this:</p>
<p class="Pp"></p>
<pre>    my @chars = $martian =~ m/([A-Z][A-Z]|[^A-Z])/g;
    # above is conceptually similar to:     my @chars = $text =~ m/(.)/g;
    #
    foreach my $char (@chars) {
        print &quot;found GX!\n&quot;, last if $char eq 'GX';
    }
</pre>
<p class="Pp">Or like this:</p>
<p class="Pp"></p>
<pre>    while ($martian =~ m/\G([A-Z][A-Z]|.)/gs) {  # \G probably unneeded
        if ($1 eq 'GX') {
            print &quot;found GX!\n&quot;;
            last;
        }
    }
</pre>
<p class="Pp">Here's another, slightly less painful, way to do it from Benjamin
    Goldberg, who uses a zero-width negative look-behind assertion.</p>
<p class="Pp"></p>
<pre>    print &quot;found GX!\n&quot; if    $martian =~ m/
        (?&lt;![A-Z])
        (?:[A-Z][A-Z])*?
        GX
        /x;
</pre>
<p class="Pp">This succeeds if the &quot;martian&quot; character GX is in the
    string, and fails otherwise. If you don't like using (?&lt;!), a zero-width
    negative look-behind assertion, you can replace (?&lt;![A-Z]) with
    (?:^|[^A-Z]).</p>
<p class="Pp">It does have the drawback of putting the wrong thing in $-[0] and
    $+[0], but this usually can be worked around.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_match_a_regular_expression_that's_in_a_variable?"><a class="permalink" href="#How_do_I_match_a_regular_expression_that's_in_a_variable?">How
  do I match a regular expression that's in a variable?</a></h2>
<p class="Pp">(contributed by brian d foy)</p>
<p class="Pp">We don't have to hard-code patterns into the match operator (or
    anything else that works with regular expressions). We can put the pattern
    in a variable for later use.</p>
<p class="Pp">The match operator is a double quote context, so you can
    interpolate your variable just like a double quoted string. In this case,
    you read the regular expression as user input and store it in
    <span class="Li">$regex</span>. Once you have the pattern in
    <span class="Li">$regex</span>, you use that variable in the match
  operator.</p>
<p class="Pp"></p>
<pre>    chomp( my $regex = &lt;STDIN&gt; );
    if( $string =~ m/$regex/ ) { ... }
</pre>
<p class="Pp">Any regular expression special characters in
    <span class="Li">$regex</span> are still special, and the pattern still has
    to be valid or Perl will complain. For instance, in this pattern there is an
    unpaired parenthesis.</p>
<p class="Pp"></p>
<pre>    my $regex = &quot;Unmatched ( paren&quot;;
    &quot;Two parens to bind them all&quot; =~ m/$regex/;
</pre>
<p class="Pp">When Perl compiles the regular expression, it treats the
    parenthesis as the start of a memory match. When it doesn't find the closing
    parenthesis, it complains:</p>
<p class="Pp"></p>
<pre>    Unmatched ( in regex; marked by &lt;-- HERE in m/Unmatched ( &lt;-- HERE  paren/ at script line 3.
</pre>
<p class="Pp">You can get around this in several ways depending on our
    situation. First, if you don't want any of the characters in the string to
    be special, you can escape them with
    <span class="Li">&quot;quotemeta&quot;</span> before you use the string.</p>
<p class="Pp"></p>
<pre>    chomp( my $regex = &lt;STDIN&gt; );
    $regex = quotemeta( $regex );
    if( $string =~ m/$regex/ ) { ... }
</pre>
<p class="Pp">You can also do this directly in the match operator using the
    <span class="Li">&quot;\Q&quot;</span> and
    <span class="Li">&quot;\E&quot;</span> sequences. The
    <span class="Li">&quot;\Q&quot;</span> tells Perl where to start escaping
    special characters, and the <span class="Li">&quot;\E&quot;</span> tells it
    where to stop (see perlop for more details).</p>
<p class="Pp"></p>
<pre>    chomp( my $regex = &lt;STDIN&gt; );
    if( $string =~ m/\Q$regex\E/ ) { ... }
</pre>
<p class="Pp">Alternately, you can use <span class="Li">&quot;qr//&quot;</span>,
    the regular expression quote operator (see perlop for more details). It
    quotes and perhaps compiles the pattern, and you can apply regular
    expression flags to the pattern.</p>
<p class="Pp"></p>
<pre>    chomp( my $input = &lt;STDIN&gt; );
    my $regex = qr/$input/is;
    $string =~ m/$regex/  # same as m/$input/is;
</pre>
<p class="Pp">You might also want to trap any errors by wrapping an
    <span class="Li">&quot;eval&quot;</span> block around the whole thing.</p>
<p class="Pp"></p>
<pre>    chomp( my $input = &lt;STDIN&gt; );
    eval {
        if( $string =~ m/\Q$input\E/ ) { ... }
    };
    warn $@ if $@;
</pre>
<p class="Pp">Or...</p>
<p class="Pp"></p>
<pre>    my $regex = eval { qr/$input/is };
    if( defined $regex ) {
        $string =~ m/$regex/;
    }
    else {
        warn $@;
    }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR_AND_COPYRIGHT"><a class="permalink" href="#AUTHOR_AND_COPYRIGHT">AUTHOR
  AND COPYRIGHT</a></h1>
<p class="Pp">Copyright (c) 1997-2010 Tom Christiansen, Nathan Torkington, and
    other authors as noted. All rights reserved.</p>
<p class="Pp">This documentation is free; you can redistribute it and/or modify
    it under the same terms as Perl itself.</p>
<p class="Pp">Irrespective of its distribution, all code examples in this file
    are hereby placed into the public domain. You are permitted and encouraged
    to use this code in your own programs for fun or for profit as you see fit.
    A simple comment in the code giving credit would be courteous but is not
    required.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os">perl v5.34.1</td>
  </tr>
</table>
</body>
</html>

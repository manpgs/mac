<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PERLREAPI(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLREAPI(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLREAPI(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlreapi - Perl regular expression plugin interface</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">As of Perl 5.9.5 there is a new interface for plugging and using
    regular expression engines other than the default one.</p>
<p class="Pp">Each engine is supposed to provide access to a constant structure
    of the following format:</p>
<p class="Pp"></p>
<pre>    typedef struct regexp_engine {
        REGEXP* (*comp) (pTHX_
                         const SV * const pattern, const U32 flags);
        I32     (*exec) (pTHX_
                         REGEXP * const rx,
                         char* stringarg,
                         char* strend, char* strbeg,
                         SSize_t minend, SV* sv,
                         void* data, U32 flags);
        char*   (*intuit) (pTHX_
                           REGEXP * const rx, SV *sv,
                           const char * const strbeg,
                           char *strpos, char *strend, U32 flags,
                           struct re_scream_pos_data_s *data);
        SV*     (*checkstr) (pTHX_ REGEXP * const rx);
        void    (*free) (pTHX_ REGEXP * const rx);
        void    (*numbered_buff_FETCH) (pTHX_
                                        REGEXP * const rx,
                                        const I32 paren,
                                        SV * const sv);
        void    (*numbered_buff_STORE) (pTHX_
                                        REGEXP * const rx,
                                        const I32 paren,
                                        SV const * const value);
        I32     (*numbered_buff_LENGTH) (pTHX_
                                         REGEXP * const rx,
                                         const SV * const sv,
                                         const I32 paren);
        SV*     (*named_buff) (pTHX_
                               REGEXP * const rx,
                               SV * const key,
                               SV * const value,
                               U32 flags);
        SV*     (*named_buff_iter) (pTHX_
                                    REGEXP * const rx,
                                    const SV * const lastkey,
                                    const U32 flags);
        SV*     (*qr_package)(pTHX_ REGEXP * const rx);
    #ifdef USE_ITHREADS
        void*   (*dupe) (pTHX_ REGEXP * const rx, CLONE_PARAMS *param);
    #endif
        REGEXP* (*op_comp) (...);
</pre>
<p class="Pp">When a regexp is compiled, its
    <span class="Li">&quot;engine&quot;</span> field is then set to point at the
    appropriate structure, so that when it needs to be used Perl can find the
    right routines to do so.</p>
<p class="Pp">In order to install a new regexp handler,
    <span class="Li">$^H{regcomp}</span> is set to an integer which (when casted
    appropriately) resolves to one of these structures. When compiling, the
    <span class="Li">&quot;comp&quot;</span> method is executed, and the
    resulting <span class="Li">&quot;regexp&quot;</span> structure's engine
    field is expected to point back at the same structure.</p>
<p class="Pp">The pTHX_ symbol in the definition is a macro used by Perl under
    threading to provide an extra argument to the routine holding a pointer back
    to the interpreter that is executing the regexp. So under threading all
    routines get an extra argument.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Callbacks"><a class="permalink" href="#Callbacks">Callbacks</a></h1>
<section class="Ss">
<h2 class="Ss" id="comp"><a class="permalink" href="#comp">comp</a></h2>
<pre>    REGEXP* comp(pTHX_ const SV * const pattern, const U32 flags);
</pre>
<p class="Pp">Compile the pattern stored in
    <span class="Li">&quot;pattern&quot;</span> using the given
    <span class="Li">&quot;flags&quot;</span> and return a pointer to a prepared
    <span class="Li">&quot;REGEXP&quot;</span> structure that can perform the
    match. See &quot;The REGEXP structure&quot; below for an explanation of the
    individual fields in the REGEXP struct.</p>
<p class="Pp">The <span class="Li">&quot;pattern&quot;</span> parameter is the
    scalar that was used as the pattern. Previous versions of Perl would pass
    two <span class="Li">&quot;char*&quot;</span> indicating the start and end
    of the stringified pattern; the following snippet can be used to get the old
    parameters:</p>
<p class="Pp"></p>
<pre>    STRLEN plen;
    char*  exp = SvPV(pattern, plen);
    char* xend = exp + plen;
</pre>
<p class="Pp">Since any scalar can be passed as a pattern, it's possible to
    implement an engine that does something with an array
    (<span class="Li">&quot;&quot;ook&quot; =~ [ qw/ eek</span>
    <span class="Li">hlagh / ]&quot;</span>) or with the non-stringified form of
    a compiled regular expression (<span class="Li">&quot;&quot;ook&quot; =~
    qr/eek/&quot;</span>). Perl's own engine will always stringify everything
    using the snippet above, but that doesn't mean other engines have to.</p>
<p class="Pp">The <span class="Li">&quot;flags&quot;</span> parameter is a
    bitfield which indicates which of the
    <span class="Li">&quot;msixpn&quot;</span> flags the regex was compiled
    with. It also contains additional info, such as if
    <span class="Li">&quot;use locale&quot;</span> is in effect.</p>
<p class="Pp">The <span class="Li">&quot;eogc&quot;</span> flags are stripped
    out before being passed to the comp routine. The regex engine does not need
    to know if any of these are set, as those flags should only affect what Perl
    does with the pattern and its match variables, not how it gets compiled and
    executed.</p>
<p class="Pp">By the time the comp callback is called, some of these flags have
    already had effect (noted below where applicable). However most of their
    effect occurs after the comp callback has run, in routines that read the
    <span class="Li">&quot;rx-&gt;extflags&quot;</span> field which it
    populates.</p>
<p class="Pp">In general the flags should be preserved in
    <span class="Li">&quot;rx-&gt;extflags&quot;</span> after compilation,
    although the regex engine might want to add or delete some of them to invoke
    or disable some special behavior in Perl. The flags along with any special
    behavior they cause are documented below:</p>
<p class="Pp">The pattern modifiers:</p>
<dl class="Bl-tag">
  <dt>&quot;/m&quot; - RXf_PMf_MULTILINE</dt>
  <dd>If this is in <span class="Li">&quot;rx-&gt;extflags&quot;</span> it will
      be passed to <span class="Li">&quot;Perl_fbm_instr&quot;</span> by
      <span class="Li">&quot;pp_split&quot;</span> which will treat the subject
      string as a multi-line string.</dd>
  <dt>&quot;/s&quot; - RXf_PMf_SINGLELINE</dt>
  <dd></dd>
  <dt>&quot;/i&quot; - RXf_PMf_FOLD</dt>
  <dd></dd>
  <dt>&quot;/x&quot; - RXf_PMf_EXTENDED</dt>
  <dd>If present on a regex, <span class="Li">&quot;#&quot;</span> comments will
      be handled differently by the tokenizer in some cases.
    <p class="Pp">TODO: Document those cases.</p>
  </dd>
  <dt>&quot;/p&quot; - RXf_PMf_KEEPCOPY</dt>
  <dd>TODO: Document this</dd>
  <dt id="Character"><a class="permalink" href="#Character">Character
    set</a></dt>
  <dd>The character set rules are determined by an enum that is contained in
      this field. This is still experimental and subject to change, but the
      current interface returns the rules by use of the in-line function
      <span class="Li">&quot;get_regex_charset(const U32 flags)&quot;</span>.
      The only currently documented value returned from it is
      REGEX_LOCALE_CHARSET, which is set if <span class="Li">&quot;use
      locale&quot;</span> is in effect. If present in
      <span class="Li">&quot;rx-&gt;extflags&quot;</span>,
      <span class="Li">&quot;split&quot;</span> will use the locale dependent
      definition of whitespace when RXf_SKIPWHITE or RXf_WHITE is in effect.
      ASCII whitespace is defined as per isSPACE, and by the internal macros
      <span class="Li">&quot;is_utf8_space&quot;</span> under UTF-8, and
      <span class="Li">&quot;isSPACE_LC&quot;</span> under
      <span class="Li">&quot;use</span>
    <span class="Li">locale&quot;</span>.</dd>
</dl>
<p class="Pp">Additional flags:</p>
<dl class="Bl-tag">
  <dt id="RXf_SPLIT"><a class="permalink" href="#RXf_SPLIT">RXf_SPLIT</a></dt>
  <dd>This flag was removed in perl 5.18.0. <span class="Li">&quot;split '
      '&quot;</span> is now special-cased solely in the parser. RXf_SPLIT is
      still #defined, so you can test for it. This is how it used to work:
    <p class="Pp">If <span class="Li">&quot;split&quot;</span> is invoked as
        <span class="Li">&quot;split ' '&quot;</span> or with no arguments
        (which really means <span class="Li">&quot;split(' ', $_)&quot;</span>,
        see split), Perl will set this flag. The regex engine can then check for
        it and set the SKIPWHITE and WHITE extflags. To do this, the Perl engine
        does:</p>
    <p class="Pp"></p>
    <pre>    if (flags &amp; RXf_SPLIT &amp;&amp; r-&gt;prelen == 1 &amp;&amp; r-&gt;precomp[0] == ' ')
        r-&gt;extflags |= (RXf_SKIPWHITE|RXf_WHITE);
    </pre>
  </dd>
</dl>
<p class="Pp">These flags can be set during compilation to enable optimizations
    in the <span class="Li">&quot;split&quot;</span> operator.</p>
<dl class="Bl-tag">
  <dt id="RXf_SKIPWHITE"><a class="permalink" href="#RXf_SKIPWHITE">RXf_SKIPWHITE</a></dt>
  <dd>This flag was removed in perl 5.18.0. It is still #defined, so you can set
      it, but doing so will have no effect. This is how it used to work:
    <p class="Pp">If the flag is present in
        <span class="Li">&quot;rx-&gt;extflags&quot;</span>
        <span class="Li">&quot;split&quot;</span> will delete whitespace from
        the start of the subject string before it's operated on. What is
        considered whitespace depends on if the subject is a UTF-8 string and if
        the <span class="Li">&quot;RXf_PMf_LOCALE&quot;</span> flag is set.</p>
    <p class="Pp">If RXf_WHITE is set in addition to this flag,
        <span class="Li">&quot;split&quot;</span> will behave like
        <span class="Li">&quot;split &quot; &quot;&quot;</span> under the Perl
        engine.</p>
  </dd>
  <dt id="RXf_START_ONLY"><a class="permalink" href="#RXf_START_ONLY">RXf_START_ONLY</a></dt>
  <dd>Tells the split operator to split the target string on newlines
      (<span class="Li">&quot;\n&quot;</span>) without invoking the regex
      engine.
    <p class="Pp">Perl's engine sets this if the pattern is
        <span class="Li">&quot;/^/&quot;</span> (<span class="Li">&quot;plen ==
        1 &amp;&amp; *exp</span> <span class="Li">== '^'&quot;</span>), even
        under <span class="Li">&quot;/^/s&quot;</span>; see split. Of course a
        different regex engine might want to use the same optimizations with a
        different syntax.</p>
  </dd>
  <dt id="RXf_WHITE"><a class="permalink" href="#RXf_WHITE">RXf_WHITE</a></dt>
  <dd>Tells the split operator to split the target string on whitespace without
      invoking the regex engine. The definition of whitespace varies depending
      on if the target string is a UTF-8 string and on if RXf_PMf_LOCALE is set.
    <p class="Pp">Perl's engine sets this flag if the pattern is
        <span class="Li">&quot;\s+&quot;</span>.</p>
  </dd>
  <dt id="RXf_NULL"><a class="permalink" href="#RXf_NULL">RXf_NULL</a></dt>
  <dd>Tells the split operator to split the target string on characters. The
      definition of character varies depending on if the target string is a
      UTF-8 string.
    <p class="Pp">Perl's engine sets this flag on empty patterns, this
        optimization makes <span class="Li">&quot;split //&quot;</span> much
        faster than it would otherwise be. It's even faster than
        <span class="Li">&quot;unpack&quot;</span>.</p>
  </dd>
  <dt id="RXf_NO_INPLACE_SUBST"><a class="permalink" href="#RXf_NO_INPLACE_SUBST">RXf_NO_INPLACE_SUBST</a></dt>
  <dd>Added in perl 5.18.0, this flag indicates that a regular expression might
      perform an operation that would interfere with inplace substitution. For
      instance it might contain lookbehind, or assign to non-magical variables
      (such as <span class="Li">$REGMARK</span> and
      <span class="Li">$REGERROR</span>) during matching.
      <span class="Li">&quot;s///&quot;</span> will skip certain optimisations
      when this is set.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="exec"><a class="permalink" href="#exec">exec</a></h2>
<pre>    I32 exec(pTHX_ REGEXP * const rx,
             char *stringarg, char* strend, char* strbeg,
             SSize_t minend, SV* sv,
             void* data, U32 flags);
</pre>
<p class="Pp">Execute a regexp. The arguments are</p>
<dl class="Bl-tag">
  <dt id="rx"><a class="permalink" href="#rx">rx</a></dt>
  <dd>The regular expression to execute.</dd>
  <dt id="sv"><a class="permalink" href="#sv">sv</a></dt>
  <dd>This is the SV to be matched against. Note that the actual char array to
      be matched against is supplied by the arguments described below; the SV is
      just used to determine UTF8ness, <span class="Li">&quot;pos()&quot;</span>
      etc.</dd>
  <dt id="strbeg"><a class="permalink" href="#strbeg">strbeg</a></dt>
  <dd>Pointer to the physical start of the string.</dd>
  <dt id="strend"><a class="permalink" href="#strend">strend</a></dt>
  <dd>Pointer to the character following the physical end of the string (i.e.
      the <span class="Li">&quot;\0&quot;</span>, if any).</dd>
  <dt id="stringarg"><a class="permalink" href="#stringarg">stringarg</a></dt>
  <dd>Pointer to the position in the string where matching should start; it
      might not be equal to <span class="Li">&quot;strbeg&quot;</span> (for
      example in a later iteration of
      <span class="Li">&quot;/.../g&quot;</span>).</dd>
  <dt id="minend"><a class="permalink" href="#minend">minend</a></dt>
  <dd>Minimum length of string (measured in bytes from
      <span class="Li">&quot;stringarg&quot;</span>) that must match; if the
      engine reaches the end of the match but hasn't reached this position in
      the string, it should fail.</dd>
  <dt id="data"><a class="permalink" href="#data">data</a></dt>
  <dd>Optimisation data; subject to change.</dd>
  <dt id="flags"><a class="permalink" href="#flags">flags</a></dt>
  <dd>Optimisation flags; subject to change.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="intuit"><a class="permalink" href="#intuit">intuit</a></h2>
<pre>    char* intuit(pTHX_
                REGEXP * const rx,
                SV *sv,
                const char * const strbeg,
                char *strpos,
                char *strend,
                const U32 flags,
                struct re_scream_pos_data_s *data);
</pre>
<p class="Pp">Find the start position where a regex match should be attempted,
    or possibly if the regex engine should not be run because the pattern can't
    match. This is called, as appropriate, by the core, depending on the values
    of the <span class="Li">&quot;extflags&quot;</span> member of the
    <span class="Li">&quot;regexp&quot;</span> structure.</p>
<p class="Pp">Arguments:</p>
<p class="Pp"></p>
<pre>    rx:     the regex to match against
    sv:     the SV being matched: only used for utf8 flag; the string
            itself is accessed via the pointers below. Note that on
            something like an overloaded SV, SvPOK(sv) may be false
            and the string pointers may point to something unrelated to
            the SV itself.
    strbeg: real beginning of string
    strpos: the point in the string at which to begin matching
    strend: pointer to the byte following the last char of the string
    flags   currently unused; set to 0
    data:   currently unused; set to NULL
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="checkstr"><a class="permalink" href="#checkstr">checkstr</a></h2>
<pre>    SV* checkstr(pTHX_ REGEXP * const rx);
</pre>
<p class="Pp">Return a SV containing a string that must appear in the pattern.
    Used by <span class="Li">&quot;split&quot;</span> for optimising
  matches.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="free"><a class="permalink" href="#free">free</a></h2>
<pre>    void free(pTHX_ REGEXP * const rx);
</pre>
<p class="Pp">Called by Perl when it is freeing a regexp pattern so that the
    engine can release any resources pointed to by the
    <span class="Li">&quot;pprivate&quot;</span> member of the
    <span class="Li">&quot;regexp&quot;</span> structure. This is only
    responsible for freeing private data; Perl will handle releasing anything
    else contained in the <span class="Li">&quot;regexp&quot;</span>
  structure.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Numbered_capture_callbacks"><a class="permalink" href="#Numbered_capture_callbacks">Numbered
  capture callbacks</a></h2>
<p class="Pp">Called to get/set the value of
    <span class="Li">&quot;$`&quot;</span>,
    <span class="Li">&quot;$'&quot;</span>, <span class="Li">$&amp;</span> and
    their named equivalents, ${^PREMATCH}, ${^POSTMATCH} and ${^MATCH}, as well
    as the numbered capture groups (<span class="Li">$1</span>,
    <span class="Li">$2</span>, ...).</p>
<p class="Pp">The <span class="Li">&quot;paren&quot;</span> parameter will be
    <span class="Li">1</span> for <span class="Li">$1</span>,
    <span class="Li">2</span> for <span class="Li">$2</span> and so forth, and
    have these symbolic values for the special variables:</p>
<p class="Pp"></p>
<pre>    ${^PREMATCH}  RX_BUFF_IDX_CARET_PREMATCH
    ${^POSTMATCH} RX_BUFF_IDX_CARET_POSTMATCH
    ${^MATCH}     RX_BUFF_IDX_CARET_FULLMATCH
    $`            RX_BUFF_IDX_PREMATCH
    $'            RX_BUFF_IDX_POSTMATCH
    $&amp;            RX_BUFF_IDX_FULLMATCH
</pre>
<p class="Pp">Note that in Perl 5.17.3 and earlier, the last three constants
    were also used for the caret variants of the variables.</p>
<p class="Pp">The names have been chosen by analogy with Tie::Scalar methods
    names with an additional <b>LENGTH</b> callback for efficiency. However
    named capture variables are currently not tied internally but implemented
    via magic.</p>
<p class="Pp"><i>numbered_buff_FETCH</i></p>
<p class="Pp"></p>
<pre>    void numbered_buff_FETCH(pTHX_ REGEXP * const rx, const I32 paren,
                             SV * const sv);
</pre>
<p class="Pp">Fetch a specified numbered capture.
    <span class="Li">&quot;sv&quot;</span> should be set to the scalar to
    return, the scalar is passed as an argument rather than being returned from
    the function because when it's called Perl already has a scalar to store the
    value, creating another one would be redundant. The scalar can be set with
    <span class="Li">&quot;sv_setsv&quot;</span>,
    <span class="Li">&quot;sv_setpvn&quot;</span> and friends, see perlapi.</p>
<p class="Pp">This callback is where Perl untaints its own capture variables
    under taint mode (see perlsec). See the
    <span class="Li">&quot;Perl_reg_numbered_buff_fetch&quot;</span> function in
    <i>regcomp.c</i> for how to untaint capture variables if that's something
    you'd like your engine to do as well.</p>
<p class="Pp"><i>numbered_buff_STORE</i></p>
<p class="Pp"></p>
<pre>    void    (*numbered_buff_STORE) (pTHX_
                                    REGEXP * const rx,
                                    const I32 paren,
                                    SV const * const value);
</pre>
<p class="Pp">Set the value of a numbered capture variable.
    <span class="Li">&quot;value&quot;</span> is the scalar that is to be used
    as the new value. It's up to the engine to make sure this is used as the new
    value (or reject it).</p>
<p class="Pp">Example:</p>
<p class="Pp"></p>
<pre>    if (&quot;ook&quot; =~ /(o*)/) {
        # 'paren' will be '1' and 'value' will be 'ee'
        $1 =~ tr/o/e/;
    }
</pre>
<p class="Pp">Perl's own engine will croak on any attempt to modify the capture
    variables, to do this in another engine use the following callback (copied
    from <span class="Li">&quot;Perl_reg_numbered_buff_store&quot;</span>):</p>
<p class="Pp"></p>
<pre>    void
    Example_reg_numbered_buff_store(pTHX_
                                    REGEXP * const rx,
                                    const I32 paren,
                                    SV const * const value)
    {
        PERL_UNUSED_ARG(rx);
        PERL_UNUSED_ARG(paren);
        PERL_UNUSED_ARG(value);
        if (!PL_localizing)
            Perl_croak(aTHX_ PL_no_modify);
    }
</pre>
<p class="Pp">Actually Perl will not <i>always</i> croak in a statement that
    looks like it would modify a numbered capture variable. This is because the
    STORE callback will not be called if Perl can determine that it doesn't have
    to modify the value. This is exactly how tied variables behave in the same
    situation:</p>
<p class="Pp"></p>
<pre>    package CaptureVar;
    use parent 'Tie::Scalar';
    sub TIESCALAR { bless [] }
    sub FETCH { undef }
    sub STORE { die &quot;This doesn't get called&quot; }
    package main;
    tie my $sv =&gt; &quot;CaptureVar&quot;;
    $sv =~ y/a/b/;
</pre>
<p class="Pp">Because <span class="Li">$sv</span> is
    <span class="Li">&quot;undef&quot;</span> when the
    <span class="Li">&quot;y///&quot;</span> operator is applied to it, the
    transliteration won't actually execute and the program won't
    <span class="Li">&quot;die&quot;</span>. This is different to how 5.8 and
    earlier versions behaved since the capture variables were READONLY variables
    then; now they'll just die when assigned to in the default engine.</p>
<p class="Pp"><i>numbered_buff_LENGTH</i></p>
<p class="Pp"></p>
<pre>    I32 numbered_buff_LENGTH (pTHX_
                              REGEXP * const rx,
                              const SV * const sv,
                              const I32 paren);
</pre>
<p class="Pp">Get the <span class="Li">&quot;length&quot;</span> of a capture
    variable. There's a special callback for this so that Perl doesn't have to
    do a FETCH and run <span class="Li">&quot;length&quot;</span> on the result,
    since the length is (in Perl's case) known from an offset stored in
    <span class="Li">&quot;rx-&gt;offs&quot;</span>, this is much more
    efficient:</p>
<p class="Pp"></p>
<pre>    I32 s1  = rx-&gt;offs[paren].start;
    I32 s2  = rx-&gt;offs[paren].end;
    I32 len = t1 - s1;
</pre>
<p class="Pp">This is a little bit more complex in the case of UTF-8, see what
    <span class="Li">&quot;Perl_reg_numbered_buff_length&quot;</span> does with
    is_utf8_string_loclen.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Named_capture_callbacks"><a class="permalink" href="#Named_capture_callbacks">Named
  capture callbacks</a></h2>
<p class="Pp">Called to get/set the value of
    <span class="Li">&quot;%+&quot;</span> and
    <span class="Li">&quot;%-&quot;</span>, as well as by some utility functions
    in re.</p>
<p class="Pp">There are two callbacks,
    <span class="Li">&quot;named_buff&quot;</span> is called in all the cases
    the FETCH, STORE, DELETE, CLEAR, EXISTS and SCALAR Tie::Hash callbacks would
    be on changes to <span class="Li">&quot;%+&quot;</span> and
    <span class="Li">&quot;%-&quot;</span> and
    <span class="Li">&quot;named_buff_iter&quot;</span> in the same cases as
    FIRSTKEY and NEXTKEY.</p>
<p class="Pp">The <span class="Li">&quot;flags&quot;</span> parameter can be
    used to determine which of these operations the callbacks should respond to.
    The following flags are currently defined:</p>
<p class="Pp">Which Tie::Hash operation is being performed from the Perl level
    on <span class="Li">&quot;%+&quot;</span> or
    <span class="Li">&quot;%+&quot;</span>, if any:</p>
<p class="Pp"></p>
<pre>    RXapif_FETCH
    RXapif_STORE
    RXapif_DELETE
    RXapif_CLEAR
    RXapif_EXISTS
    RXapif_SCALAR
    RXapif_FIRSTKEY
    RXapif_NEXTKEY
</pre>
<p class="Pp">If <span class="Li">&quot;%+&quot;</span> or
    <span class="Li">&quot;%-&quot;</span> is being operated on, if any.</p>
<p class="Pp"></p>
<pre>    RXapif_ONE /* %+ */
    RXapif_ALL /* %- */
</pre>
<p class="Pp">If this is being called as
    <span class="Li">&quot;re::regname&quot;</span>,
    <span class="Li">&quot;re::regnames&quot;</span> or
    <span class="Li">&quot;re::regnames_count&quot;</span>, if any. The first
    two will be combined with <span class="Li">&quot;RXapif_ONE&quot;</span> or
    <span class="Li">&quot;RXapif_ALL&quot;</span>.</p>
<p class="Pp"></p>
<pre>    RXapif_REGNAME
    RXapif_REGNAMES
    RXapif_REGNAMES_COUNT
</pre>
<p class="Pp">Internally <span class="Li">&quot;%+&quot;</span> and
    <span class="Li">&quot;%-&quot;</span> are implemented with a real tied
    interface via Tie::Hash::NamedCapture. The methods in that package will call
    back into these functions. However the usage of Tie::Hash::NamedCapture for
    this purpose might change in future releases. For instance this might be
    implemented by magic instead (would need an extension to mgvtbl).</p>
<p class="Pp"><i>named_buff</i></p>
<p class="Pp"></p>
<pre>    SV*     (*named_buff) (pTHX_ REGEXP * const rx, SV * const key,
                           SV * const value, U32 flags);
</pre>
<p class="Pp"><i>named_buff_iter</i></p>
<p class="Pp"></p>
<pre>    SV*     (*named_buff_iter) (pTHX_
                                REGEXP * const rx,
                                const SV * const lastkey,
                                const U32 flags);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="qr_package"><a class="permalink" href="#qr_package">qr_package</a></h2>
<pre>    SV* qr_package(pTHX_ REGEXP * const rx);
</pre>
<p class="Pp">The package the qr// magic object is blessed into (as seen by
    <span class="Li">&quot;ref</span> <span class="Li">qr//&quot;</span>). It is
    recommended that engines change this to their package name for
    identification regardless of if they implement methods on the object.</p>
<p class="Pp">The package this method returns should also have the internal
    <span class="Li">&quot;Regexp&quot;</span> package in its
    <span class="Li">@ISA</span>.
    <span class="Li">&quot;qr//-&gt;isa(&quot;Regexp&quot;)&quot;</span> should
    always be true regardless of what engine is being used.</p>
<p class="Pp">Example implementation might be:</p>
<p class="Pp"></p>
<pre>    SV*
    Example_qr_package(pTHX_ REGEXP * const rx)
    {
        PERL_UNUSED_ARG(rx);
        return newSVpvs(&quot;re::engine::Example&quot;);
    }
</pre>
<p class="Pp">Any method calls on an object created with
    <span class="Li">&quot;qr//&quot;</span> will be dispatched to the package
    as a normal object.</p>
<p class="Pp"></p>
<pre>    use re::engine::Example;
    my $re = qr//;
    $re-&gt;meth; # dispatched to re::engine::Example::meth()
</pre>
<p class="Pp">To retrieve the <span class="Li">&quot;REGEXP&quot;</span> object
    from the scalar in an XS function use the
    <span class="Li">&quot;SvRX&quot;</span> macro, see &quot;REGEXP
    Functions&quot; in perlapi.</p>
<p class="Pp"></p>
<pre>    void meth(SV * rv)
    PPCODE:
        REGEXP * re = SvRX(sv);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="dupe"><a class="permalink" href="#dupe">dupe</a></h2>
<pre>    void* dupe(pTHX_ REGEXP * const rx, CLONE_PARAMS *param);
</pre>
<p class="Pp">On threaded builds a regexp may need to be duplicated so that the
    pattern can be used by multiple threads. This routine is expected to handle
    the duplication of any private data pointed to by the
    <span class="Li">&quot;pprivate&quot;</span> member of the
    <span class="Li">&quot;regexp&quot;</span> structure. It will be called with
    the preconstructed new <span class="Li">&quot;regexp&quot;</span> structure
    as an argument, the <span class="Li">&quot;pprivate&quot;</span> member will
    point at the <b>old</b> private structure, and it is this routine's
    responsibility to construct a copy and return a pointer to it (which Perl
    will then use to overwrite the field as passed to this routine.)</p>
<p class="Pp">This allows the engine to dupe its private data but also if
    necessary modify the final structure if it really must.</p>
<p class="Pp">On unthreaded builds this field doesn't exist.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="op_comp"><a class="permalink" href="#op_comp">op_comp</a></h2>
<p class="Pp">This is private to the Perl core and subject to change. Should be
    left null.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="The_REGEXP_structure"><a class="permalink" href="#The_REGEXP_structure">The
  REGEXP structure</a></h1>
<p class="Pp">The REGEXP struct is defined in <i>regexp.h</i>. All regex engines
    must be able to correctly build such a structure in their &quot;comp&quot;
    routine.</p>
<p class="Pp">The REGEXP structure contains all the data that Perl needs to be
    aware of to properly work with the regular expression. It includes data
    about optimisations that Perl can use to determine if the regex engine
    should really be used, and various other control info that is needed to
    properly execute patterns in various contexts, such as if the pattern
    anchored in some way, or what flags were used during the compile, or if the
    program contains special constructs that Perl needs to be aware of.</p>
<p class="Pp">In addition it contains two fields that are intended for the
    private use of the regex engine that compiled the pattern. These are the
    <span class="Li">&quot;intflags&quot;</span> and
    <span class="Li">&quot;pprivate&quot;</span> members.
    <span class="Li">&quot;pprivate&quot;</span> is a void pointer to an
    arbitrary structure, whose use and management is the responsibility of the
    compiling engine. Perl will never modify either of these values.</p>
<p class="Pp"></p>
<pre>    typedef struct regexp {
        /* what engine created this regexp? */
        const struct regexp_engine* engine;
        /* what re is this a lightweight copy of? */
        struct regexp* mother_re;
        /* Information about the match that the Perl core uses to manage
         * things */
        U32 extflags;   /* Flags used both externally and internally */
        I32 minlen;     /* mininum possible number of chars in */
                           string to match */
        I32 minlenret;  /* mininum possible number of chars in $&amp; */
        U32 gofs;       /* chars left of pos that we search from */
        /* substring data about strings that must appear
           in the final match, used for optimisations */
        struct reg_substr_data *substrs;
        U32 nparens;  /* number of capture groups */
        /* private engine specific data */
        U32 intflags;   /* Engine Specific Internal flags */
        void *pprivate; /* Data private to the regex engine which 
                           created this object. */
        /* Data about the last/current match. These are modified during
         * matching*/
        U32 lastparen;            /* highest close paren matched ($+) */
        U32 lastcloseparen;       /* last close paren matched ($^N) */
        regexp_paren_pair *offs;  /* Array of offsets for (@-) and
                                     (@+) */
        char *subbeg;  /* saved or original string so \digit works
                          forever. */
        SV_SAVED_COPY  /* If non-NULL, SV which is COW from original */
        I32 sublen;    /* Length of string pointed by subbeg */
        I32 suboffset;  /* byte offset of subbeg from logical start of
                           str */
        I32 subcoffset; /* suboffset equiv, but in chars (for @-/@+) */
        /* Information about the match that isn't often used */
        I32 prelen;           /* length of precomp */
        const char *precomp;  /* pre-compilation regular expression */
        char *wrapped;  /* wrapped version of the pattern */
        I32 wraplen;    /* length of wrapped */
        I32 seen_evals;   /* number of eval groups in the pattern - for
                             security checks */
        HV *paren_names;  /* Optional hash of paren names */
        /* Refcount of this regexp */
        I32 refcnt;             /* Refcount of this regexp */
    } regexp;
</pre>
<p class="Pp">The fields are discussed in more detail below:</p>
<section class="Ss">
<h2 class="Ss" id="_engine_"><a class="permalink" href="#_engine_">&quot;engine&quot;</a></h2>
<p class="Pp">This field points at a
    <span class="Li">&quot;regexp_engine&quot;</span> structure which contains
    pointers to the subroutines that are to be used for performing a match. It
    is the compiling routine's responsibility to populate this field before
    returning the regexp object.</p>
<p class="Pp">Internally this is set to <span class="Li">&quot;NULL&quot;</span>
    unless a custom engine is specified in <span class="Li">$^H{regcomp}</span>,
    Perl's own set of callbacks can be accessed in the struct pointed to by
    <span class="Li">&quot;RE_ENGINE_PTR&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_mother_re_"><a class="permalink" href="#_mother_re_">&quot;mother_re&quot;</a></h2>
<p class="Pp">TODO, see commit 28d8d7f41a.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_extflags_"><a class="permalink" href="#_extflags_">&quot;extflags&quot;</a></h2>
<p class="Pp">This will be used by Perl to see what flags the regexp was
    compiled with, this will normally be set to the value of the flags parameter
    by the comp callback. See the comp documentation for valid flags.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_minlen___minlenret_"><a class="permalink" href="#_minlen___minlenret_">&quot;minlen&quot;
  &quot;minlenret&quot;</a></h2>
<p class="Pp">The minimum string length (in characters) required for the pattern
    to match. This is used to prune the search space by not bothering to match
    any closer to the end of a string than would allow a match. For instance
    there is no point in even starting the regex engine if the minlen is 10 but
    the string is only 5 characters long. There is no way that the pattern can
    match.</p>
<p class="Pp"><span class="Li">&quot;minlenret&quot;</span> is the minimum
    length (in characters) of the string that would be found in $&amp; after a
    match.</p>
<p class="Pp">The difference between <span class="Li">&quot;minlen&quot;</span>
    and <span class="Li">&quot;minlenret&quot;</span> can be seen in the
    following pattern:</p>
<p class="Pp"></p>
<pre>    /ns(?=\d)/
</pre>
<p class="Pp">where the <span class="Li">&quot;minlen&quot;</span> would be 3
    but <span class="Li">&quot;minlenret&quot;</span> would only be 2 as the \d
    is required to match but is not actually included in the matched content.
    This distinction is particularly important as the substitution logic uses
    the <span class="Li">&quot;minlenret&quot;</span> to tell if it can do
    in-place substitutions (these can result in considerable speed-up).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_gofs_"><a class="permalink" href="#_gofs_">&quot;gofs&quot;</a></h2>
<p class="Pp">Left offset from <b>pos()</b> to start match at.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_substrs_"><a class="permalink" href="#_substrs_">&quot;substrs&quot;</a></h2>
<p class="Pp">Substring data about strings that must appear in the final match.
    This is currently only used internally by Perl's engine, but might be used
    in the future for all engines for optimisations.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_nparens_,__lastparen_,_and__lastcloseparen_"><a class="permalink" href="#_nparens_,__lastparen_,_and__lastcloseparen_">&quot;nparens&quot;,
  &quot;lastparen&quot;, and &quot;lastcloseparen&quot;</a></h2>
<p class="Pp">These fields are used to keep track of: how many paren capture
    groups there are in the pattern; which was the highest paren to be closed
    (see &quot;$+&quot; in perlvar); and which was the most recent paren to be
    closed (see &quot;$^N&quot; in perlvar).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_intflags_"><a class="permalink" href="#_intflags_">&quot;intflags&quot;</a></h2>
<p class="Pp">The engine's private copy of the flags the pattern was compiled
    with. Usually this is the same as
    <span class="Li">&quot;extflags&quot;</span> unless the engine chose to
    modify one of them.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_pprivate_"><a class="permalink" href="#_pprivate_">&quot;pprivate&quot;</a></h2>
<p class="Pp">A void* pointing to an engine-defined data structure. The Perl
    engine uses the <span class="Li">&quot;regexp_internal&quot;</span>
    structure (see &quot;Base Structures&quot; in perlreguts) but a custom
    engine should use something else.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_offs_"><a class="permalink" href="#_offs_">&quot;offs&quot;</a></h2>
<p class="Pp">A <span class="Li">&quot;regexp_paren_pair&quot;</span> structure
    which defines offsets into the string being matched which correspond to the
    <span class="Li">$&amp;</span> and <span class="Li">$1</span>,
    <span class="Li">$2</span> etc. captures, the
    <span class="Li">&quot;regexp_paren_pair&quot;</span> struct is defined as
    follows:</p>
<p class="Pp"></p>
<pre>    typedef struct regexp_paren_pair {
        I32 start;
        I32 end;
    } regexp_paren_pair;
</pre>
<p class="Pp">If <span class="Li">&quot;-&gt;offs[num].start&quot;</span> or
    <span class="Li">&quot;-&gt;offs[num].end&quot;</span> is
    <span class="Li">&quot;-1&quot;</span> then that capture group did not
    match. <span class="Li">&quot;-&gt;offs[0].start/end&quot;</span> represents
    <span class="Li">$&amp;</span> (or
    <span class="Li">&quot;${^MATCH}&quot;</span> under
    <span class="Li">&quot;/p&quot;</span>) and
    <span class="Li">&quot;-&gt;offs[paren].end&quot;</span> matches
    <span class="Li">$$paren</span> where <span class="Li">$paren </span>=
    1&gt;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_precomp___prelen_"><a class="permalink" href="#_precomp___prelen_">&quot;precomp&quot;
  &quot;prelen&quot;</a></h2>
<p class="Pp">Used for optimisations.
    <span class="Li">&quot;precomp&quot;</span> holds a copy of the pattern that
    was compiled and <span class="Li">&quot;prelen&quot;</span> its length. When
    a new pattern is to be compiled (such as inside a loop) the internal
    <span class="Li">&quot;regcomp&quot;</span> operator checks if the last
    compiled <span class="Li">&quot;REGEXP&quot;</span>'s
    <span class="Li">&quot;precomp&quot;</span> and
    <span class="Li">&quot;prelen&quot;</span> are equivalent to the new one,
    and if so uses the old pattern instead of compiling a new one.</p>
<p class="Pp">The relevant snippet from
    <span class="Li">&quot;Perl_pp_regcomp&quot;</span>:</p>
<p class="Pp"></p>
<pre>        if (!re || !re-&gt;precomp || re-&gt;prelen != (I32)len ||
            memNE(re-&gt;precomp, t, len))
        /* Compile a new pattern */
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_paren_names_"><a class="permalink" href="#_paren_names_">&quot;paren_names&quot;</a></h2>
<p class="Pp">This is a hash used internally to track named capture groups and
    their offsets. The keys are the names of the buffers the values are
    dualvars, with the IV slot holding the number of buffers with the given name
    and the pv being an embedded array of I32. The values may also be contained
    independently in the data array in cases where named backreferences are
    used.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_substrs_~2"><a class="permalink" href="#_substrs_~2">&quot;substrs&quot;</a></h2>
<p class="Pp">Holds information on the longest string that must occur at a fixed
    offset from the start of the pattern, and the longest string that must occur
    at a floating offset from the start of the pattern. Used to do
    Fast-Boyer-Moore searches on the string to find out if its worth using the
    regex engine at all, and if so where in the string to search.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_subbeg___sublen___saved_copy___suboffset___subcoffset_"><a class="permalink" href="#_subbeg___sublen___saved_copy___suboffset___subcoffset_">&quot;subbeg&quot;
  &quot;sublen&quot; &quot;saved_copy&quot; &quot;suboffset&quot;
  &quot;subcoffset&quot;</a></h2>
<p class="Pp">Used during the execution phase for managing search and replace
    patterns, and for providing the text for <span class="Li">$&amp;</span>,
    <span class="Li">$1</span> etc. <span class="Li">&quot;subbeg&quot;</span>
    points to a buffer (either the original string, or a copy in the case of
    <span class="Li">&quot;RX_MATCH_COPIED(rx)&quot;</span>), and
    <span class="Li">&quot;sublen&quot;</span> is the length of the buffer. The
    <span class="Li">&quot;RX_OFFS&quot;</span> start and end indices index into
    this buffer.</p>
<p class="Pp">In the presence of the
    <span class="Li">&quot;REXEC_COPY_STR&quot;</span> flag, but with the
    addition of the <span class="Li">&quot;REXEC_COPY_SKIP_PRE&quot;</span> or
    <span class="Li">&quot;REXEC_COPY_SKIP_POST&quot;</span> flags, an engine
    can choose not to copy the full buffer (although it must still do so in the
    presence of <span class="Li">&quot;RXf_PMf_KEEPCOPY&quot;</span> or the
    relevant bits being set in
    <span class="Li">&quot;PL_sawampersand&quot;</span>). In this case, it may
    set <span class="Li">&quot;suboffset&quot;</span> to indicate the number of
    bytes from the logical start of the buffer to the physical start (i.e.
    <span class="Li">&quot;subbeg&quot;</span>). It should also set
    <span class="Li">&quot;subcoffset&quot;</span>, the number of characters in
    the offset. The latter is needed to support
    <span class="Li">&quot;@-&quot;</span> and
    <span class="Li">&quot;@+&quot;</span> which work in characters, not
  bytes.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_wrapped___wraplen_"><a class="permalink" href="#_wrapped___wraplen_">&quot;wrapped&quot;
  &quot;wraplen&quot;</a></h2>
<p class="Pp">Stores the string <span class="Li">&quot;qr//&quot;</span>
    stringifies to. The Perl engine for example stores
    <span class="Li">&quot;(?^:eek)&quot;</span> in the case of
    <span class="Li">&quot;qr/eek/&quot;</span>.</p>
<p class="Pp">When using a custom engine that doesn't support the
    <span class="Li">&quot;(?:)&quot;</span> construct for inline modifiers,
    it's probably best to have <span class="Li">&quot;qr//&quot;</span>
    stringify to the supplied pattern, note that this will create undesired
    patterns in cases such as:</p>
<p class="Pp"></p>
<pre>    my $x = qr/a|b/;  # &quot;a|b&quot;
    my $y = qr/c/i;   # &quot;c&quot;
    my $z = qr/$x$y/; # &quot;a|bc&quot;
</pre>
<p class="Pp">There's no solution for this problem other than making the custom
    engine understand a construct like
  <span class="Li">&quot;(?:)&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_seen_evals_"><a class="permalink" href="#_seen_evals_">&quot;seen_evals&quot;</a></h2>
<p class="Pp">This stores the number of eval groups in the pattern. This is used
    for security purposes when embedding compiled regexes into larger patterns
    with <span class="Li">&quot;qr//&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_refcnt_"><a class="permalink" href="#_refcnt_">&quot;refcnt&quot;</a></h2>
<p class="Pp">The number of times the structure is referenced. When this falls
    to 0, the regexp is automatically freed by a call to
    <span class="Li">&quot;pregfree&quot;</span>. This should be set to 1 in
    each engine's &quot;comp&quot; routine.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
<p class="Pp">Originally part of perlreguts.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp">Originally written by Yves Orton, expanded by AEvar Arnfjoerd`
    Bjarmason.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">Copyright 2006 Yves Orton and 2007 AEvar Arnfjoerd` Bjarmason.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-10-04</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PERLNUMBER(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLNUMBER(1)</td>
    <td class="head-vol"><a href=".">Perl Programmers Reference Guide</a></td>
    <td class="head-rtitle">PERLNUMBER(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlnumber - semantics of numbers and numeric operations in
  Perl</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>    $n = 1234;              # decimal integer
    $n = 0b1110011;         # binary integer
    $n = 01234;             # octal integer
    $n = 0x1234;            # hexadecimal integer
    $n = 12.34e-56;         # exponential notation
    $n = &quot;-12.34e56&quot;;       # number specified as a string
    $n = &quot;1234&quot;;            # number specified as a string
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This document describes how Perl internally handles numeric
    values.</p>
<p class="Pp">Perl's operator overloading facility is completely ignored here.
    Operator overloading allows user-defined behaviors for numbers, such as
    operations over arbitrarily large integers, floating points numbers with
    arbitrary precision, operations over &quot;exotic&quot; numbers such as
    modular arithmetic or p-adic arithmetic, and so on. See overload for
    details.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Storing_numbers"><a class="permalink" href="#Storing_numbers">Storing
  numbers</a></h1>
<p class="Pp">Perl can internally represent numbers in 3 different ways: as
    native integers, as native floating point numbers, and as decimal strings.
    Decimal strings may have an exponential notation part, as in
    <span class="Li">&quot;12.34e-56&quot;</span>. <i>Native</i> here means
    &quot;a format supported by the C compiler which was used to build
    perl&quot;.</p>
<p class="Pp">The term &quot;native&quot; does not mean quite as much when we
    talk about native integers, as it does when native floating point numbers
    are involved. The only implication of the term &quot;native&quot; on
    integers is that the limits for the maximal and the minimal supported true
    integral quantities are close to powers of 2. However, &quot;native&quot;
    floats have a most fundamental restriction: they may represent only those
    numbers which have a relatively &quot;short&quot; representation when
    converted to a binary fraction. For example, 0.9 cannot be represented by a
    native float, since the binary fraction for 0.9 is infinite:</p>
<p class="Pp"></p>
<pre>  binary0.1110011001100...
</pre>
<p class="Pp">with the sequence <span class="Li">1100</span> repeating again and
    again. In addition to this limitation, the exponent of the binary number is
    also restricted when it is represented as a floating point number. On
    typical hardware, floating point values can store numbers with up to 53
    binary digits, and with binary exponents between -1024 and 1024. In decimal
    representation this is close to 16 decimal digits and decimal exponents in
    the range of -304..304. The upshot of all this is that Perl cannot store a
    number like 12345678901234567 as a floating point number on such
    architectures without loss of information.</p>
<p class="Pp">Similarly, decimal strings can represent only those numbers which
    have a finite decimal expansion. Being strings, and thus of arbitrary
    length, there is no practical limit for the exponent or number of decimal
    digits for these numbers. (But realize that what we are discussing the rules
    for just the <i>storage</i> of these numbers. The fact that you can store
    such &quot;large&quot; numbers does not mean that the <i>operations</i> over
    these numbers will use all of the significant digits. See &quot;Numeric
    operators and numeric conversions&quot; for details.)</p>
<p class="Pp">In fact numbers stored in the native integer format may be stored
    either in the signed native form, or in the unsigned native form. Thus the
    limits for Perl numbers stored as native integers would typically be
    -2**31..2**32-1, with appropriate modifications in the case of 64-bit
    integers. Again, this does not mean that Perl can do operations only over
    integers in this range: it is possible to store many more integers in
    floating point format.</p>
<p class="Pp">Summing up, Perl numeric values can store only those numbers which
    have a finite decimal expansion or a &quot;short&quot; binary expansion.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Numeric_operators_and_numeric_conversions"><a class="permalink" href="#Numeric_operators_and_numeric_conversions">Numeric
  operators and numeric conversions</a></h1>
<p class="Pp">As mentioned earlier, Perl can store a number in any one of three
    formats, but most operators typically understand only one of those formats.
    When a numeric value is passed as an argument to such an operator, it will
    be converted to the format understood by the operator.</p>
<p class="Pp">Six such conversions are possible:</p>
<p class="Pp"></p>
<pre>  native integer        --&gt; native floating point       (*)
  native integer        --&gt; decimal string
  native floating_point --&gt; native integer              (*)
  native floating_point --&gt; decimal string              (*)
  decimal string        --&gt; native integer
  decimal string        --&gt; native floating point       (*)
</pre>
<p class="Pp">These conversions are governed by the following general rules:</p>
<ul class="Bl-bullet">
  <li>If the source number can be represented in the target form, that
      representation is used.</li>
  <li>If the source number is outside of the limits representable in the target
      form, a representation of the closest limit is used. (<i>Loss of
      information</i>)</li>
  <li>If the source number is between two numbers representable in the target
      form, a representation of one of these numbers is used. (<i>Loss of
      information</i>)</li>
  <li>In <span class="Li">&quot;native floating point --&gt; native
      integer&quot;</span> conversions the magnitude of the result is less than
      or equal to the magnitude of the source. (<i>&quot;Rounding to
      zero&quot;.</i>)</li>
  <li>If the <span class="Li">&quot;decimal string --&gt; native
      integer&quot;</span> conversion cannot be done without loss of
      information, the result is compatible with the conversion sequence
      <span class="Li">&quot;decimal_string --&gt; native_floating_point --&gt;
      native_integer&quot;</span>. In particular, rounding is strongly biased to
      0, though a number like
      <span class="Li">&quot;0.99999999999999999999&quot;</span> has a chance of
      being rounded to 1.</li>
</ul>
<p class="Pp"><b>RESTRICTION</b>: The conversions marked with
    <span class="Li">&quot;(*)&quot;</span> above involve steps performed by the
    C compiler. In particular, bugs/features of the compiler used may lead to
    breakage of some of the above rules.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Flavors_of_Perl_numeric_operations"><a class="permalink" href="#Flavors_of_Perl_numeric_operations">Flavors
  of Perl numeric operations</a></h1>
<p class="Pp">Perl operations which take a numeric argument treat that argument
    in one of four different ways: they may force it to one of the
    integer/floating/ string formats, or they may behave differently depending
    on the format of the operand. Forcing a numeric value to a particular format
    does not change the number stored in the value.</p>
<p class="Pp">All the operators which need an argument in the integer format
    treat the argument as in modular arithmetic, e.g.,
    <span class="Li">&quot;mod 2**32&quot;</span> on a 32-bit architecture.
    <span class="Li">&quot;sprintf &quot;%u&quot;, -1&quot;</span> therefore
    provides the same result as <span class="Li">&quot;sprintf &quot;%u&quot;,
    ~0&quot;</span>.</p>
<dl class="Bl-tag">
  <dt id="Arithmetic"><a class="permalink" href="#Arithmetic">Arithmetic
    operators</a></dt>
  <dd>The binary operators <span class="Li">&quot;+&quot;</span>
      <span class="Li">&quot;-&quot;</span>
      <span class="Li">&quot;*&quot;</span>
      <span class="Li">&quot;/&quot;</span>
      <span class="Li">&quot;%&quot;</span>
      <span class="Li">&quot;==&quot;</span>
      <span class="Li">&quot;!=&quot;</span>
      <span class="Li">&quot;&gt;&quot;</span>
      <span class="Li">&quot;&lt;&quot;</span>
      <span class="Li">&quot;&gt;=&quot;</span>
      <span class="Li">&quot;&lt;=&quot;</span> and the unary operators
      <span class="Li">&quot;-&quot;</span>
      <span class="Li">&quot;abs&quot;</span> and
      <span class="Li">&quot;--&quot;</span> will attempt to convert arguments
      to integers. If both conversions are possible without loss of precision,
      and the operation can be performed without loss of precision then the
      integer result is used. Otherwise arguments are converted to floating
      point format and the floating point result is used. The caching of
      conversions (as described above) means that the integer conversion does
      not throw away fractional parts on floating point numbers.</dd>
  <dt>++</dt>
  <dd><span class="Li">&quot;++&quot;</span> behaves as the other operators
      above, except that if it is a string matching the format
      <span class="Li">&quot;/^[a-zA-Z]*[0-9]*\z/&quot;</span> the string
      increment described in perlop is used.</dd>
  <dt id="Arithmetic~2"><a class="permalink" href="#Arithmetic~2">Arithmetic
    operators during &quot;use integer&quot;</a></dt>
  <dd>In scopes where <span class="Li">&quot;use integer;&quot;</span> is in
      force, nearly all the operators listed above will force their argument(s)
      into integer format, and return an integer result. The exceptions,
      <span class="Li">&quot;abs&quot;</span>,
      <span class="Li">&quot;++&quot;</span> and
      <span class="Li">&quot;--&quot;</span>, do not change their behavior with
      <span class="Li">&quot;use integer;&quot;</span></dd>
  <dt id="Other"><a class="permalink" href="#Other">Other mathematical
    operators</a></dt>
  <dd>Operators such as <span class="Li">&quot;**&quot;</span>,
      <span class="Li">&quot;sin&quot;</span> and
      <span class="Li">&quot;exp&quot;</span> force arguments to floating point
      format.</dd>
  <dt id="Bitwise"><a class="permalink" href="#Bitwise">Bitwise
    operators</a></dt>
  <dd>Arguments are forced into the integer format if not strings.</dd>
  <dt id="Bitwise~2"><a class="permalink" href="#Bitwise~2">Bitwise operators
    during &quot;use integer&quot;</a></dt>
  <dd>forces arguments to integer format. Also shift operations internally use
      signed integers rather than the default unsigned.</dd>
  <dt id="Operators"><a class="permalink" href="#Operators">Operators which
    expect an integer</a></dt>
  <dd>force the argument into the integer format. This is applicable to the
      third and fourth arguments of <span class="Li">&quot;sysread&quot;</span>,
      for example.</dd>
  <dt id="Operators~2"><a class="permalink" href="#Operators~2">Operators which
    expect a string</a></dt>
  <dd>force the argument into the string format. For example, this is applicable
      to <span class="Li">&quot;printf &quot;%s&quot;, $value&quot;</span>.</dd>
</dl>
<p class="Pp">Though forcing an argument into a particular form does not change
    the stored number, Perl remembers the result of such conversions. In
    particular, though the first such conversion may be time-consuming, repeated
    operations will not need to redo the conversion.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Ilya Zakharevich
    <span class="Li">&quot;ilya@math.ohio-state.edu&quot;</span></p>
<p class="Pp">Editorial adjustments by Gurusamy Sarathy
    &lt;gsar@ActiveState.com&gt;</p>
<p class="Pp">Updates for 5.8.0 by Nicholas Clark &lt;nick@ccl4.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">overload, perlop</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os"><a href="..">perl v5.34.1</a></td>
  </tr>
</table>
</body>
</html>

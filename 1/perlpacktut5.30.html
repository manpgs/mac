<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PERLPACKTUT(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLPACKTUT(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLPACKTUT(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlpacktut - tutorial on &quot;pack&quot; and
  &quot;unpack&quot;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><span class="Li">&quot;pack&quot;</span> and
    <span class="Li">&quot;unpack&quot;</span> are two functions for
    transforming data according to a user-defined template, between the guarded
    way Perl stores values and some well-defined representation as might be
    required in the environment of a Perl program. Unfortunately, they're also
    two of the most misunderstood and most often overlooked functions that Perl
    provides. This tutorial will demystify them for you.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="The_Basic_Principle"><a class="permalink" href="#The_Basic_Principle">The
  Basic Principle</a></h1>
<p class="Pp">Most programming languages don't shelter the memory where
    variables are stored. In C, for instance, you can take the address of some
    variable, and the <span class="Li">&quot;sizeof&quot;</span> operator tells
    you how many bytes are allocated to the variable. Using the address and the
    size, you may access the storage to your heart's content.</p>
<p class="Pp">In Perl, you just can't access memory at random, but the
    structural and representational conversion provided by
    <span class="Li">&quot;pack&quot;</span> and
    <span class="Li">&quot;unpack&quot;</span> is an excellent alternative. The
    <span class="Li">&quot;pack&quot;</span> function converts values to a byte
    sequence containing representations according to a given specification, the
    so-called &quot;template&quot; argument.
    <span class="Li">&quot;unpack&quot;</span> is the reverse process, deriving
    some values from the contents of a string of bytes. (Be cautioned, however,
    that not all that has been packed together can be neatly unpacked - a very
    common experience as seasoned travellers are likely to confirm.)</p>
<p class="Pp">Why, you may ask, would you need a chunk of memory containing some
    values in binary representation? One good reason is input and output
    accessing some file, a device, or a network connection, whereby this binary
    representation is either forced on you or will give you some benefit in
    processing. Another cause is passing data to some system call that is not
    available as a Perl function: <span class="Li">&quot;syscall&quot;</span>
    requires you to provide parameters stored in the way it happens in a C
    program. Even text processing (as shown in the next section) may be
    simplified with judicious usage of these two functions.</p>
<p class="Pp">To see how (un)packing works, we'll start with a simple template
    code where the conversion is in low gear: between the contents of a byte
    sequence and a string of hexadecimal digits. Let's use
    <span class="Li">&quot;unpack&quot;</span>, since this is likely to remind
    you of a dump program, or some desperate last message unfortunate programs
    are wont to throw at you before they expire into the wild blue yonder.
    Assuming that the variable <span class="Li">$mem</span> holds a sequence of
    bytes that we'd like to inspect without assuming anything about its meaning,
    we can write</p>
<p class="Pp"></p>
<pre>   my( $hex ) = unpack( 'H*', $mem );
   print &quot;$hex\n&quot;;
</pre>
<p class="Pp">whereupon we might see something like this, with each pair of hex
    digits corresponding to a byte:</p>
<p class="Pp"></p>
<pre>   41204d414e204120504c414e20412043414e414c2050414e414d41
</pre>
<p class="Pp">What was in this chunk of memory? Numbers, characters, or a
    mixture of both? Assuming that we're on a computer where ASCII (or some
    similar) encoding is used: hexadecimal values in the range
    <span class="Li">0x40</span> - <span class="Li">0x5A</span> indicate an
    uppercase letter, and <span class="Li">0x20</span> encodes a space. So we
    might assume it is a piece of text, which some are able to read like a
    tabloid; but others will have to get hold of an ASCII table and relive that
    firstgrader feeling. Not caring too much about which way to read this, we
    note that <span class="Li">&quot;unpack&quot;</span> with the template code
    <span class="Li">&quot;H&quot;</span> converts the contents of a sequence of
    bytes into the customary hexadecimal notation. Since &quot;a sequence
    of&quot; is a pretty vague indication of quantity,
    <span class="Li">&quot;H&quot;</span> has been defined to convert just a
    single hexadecimal digit unless it is followed by a repeat count. An
    asterisk for the repeat count means to use whatever remains.</p>
<p class="Pp">The inverse operation - packing byte contents from a string of
    hexadecimal digits - is just as easily written. For instance:</p>
<p class="Pp"></p>
<pre>   my $s = pack( 'H2' x 10, 30..39 );
   print &quot;$s\n&quot;;
</pre>
<p class="Pp">Since we feed a list of ten 2-digit hexadecimal strings to
    <span class="Li">&quot;pack&quot;</span>, the pack template should contain
    ten pack codes. If this is run on a computer with ASCII character coding, it
    will print <span class="Li">0123456789</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Packing_Text"><a class="permalink" href="#Packing_Text">Packing
  Text</a></h1>
<p class="Pp">Let's suppose you've got to read in a data file like this:</p>
<p class="Pp"></p>
<pre>    Date      |Description                | Income|Expenditure
    01/24/2001 Zed's Camel Emporium                    1147.99
    01/28/2001 Flea spray                                24.99
    01/29/2001 Camel rides to tourists      235.00
</pre>
<p class="Pp">How do we do it? You might think first to use
    <span class="Li">&quot;split&quot;</span>; however, since
    <span class="Li">&quot;split&quot;</span> collapses blank fields, you'll
    never know whether a record was income or expenditure. Oops. Well, you could
    always use <span class="Li">&quot;substr&quot;</span>:</p>
<p class="Pp"></p>
<pre>    while (&lt;&gt;) { 
        my $date   = substr($_,  0, 11);
        my $desc   = substr($_, 12, 27);
        my $income = substr($_, 40,  7);
        my $expend = substr($_, 52,  7);
        ...
    }
</pre>
<p class="Pp">It's not really a barrel of laughs, is it? In fact, it's worse
    than it may seem; the eagle-eyed may notice that the first field should only
    be 10 characters wide, and the error has propagated right through the other
    numbers - which we've had to count by hand. So it's error-prone as well as
    horribly unfriendly.</p>
<p class="Pp">Or maybe we could use regular expressions:</p>
<p class="Pp"></p>
<pre>    while (&lt;&gt;) { 
        my($date, $desc, $income, $expend) = 
            m|(\d\d/\d\d/\d{4}) (.{27}) (.{7})(.*)|;
        ...
    }
</pre>
<p class="Pp">Urgh. Well, it's a bit better, but - well, would you want to
    maintain that?</p>
<p class="Pp">Hey, isn't Perl supposed to make this sort of thing easy? Well, it
    does, if you use the right tools. <span class="Li">&quot;pack&quot;</span>
    and <span class="Li">&quot;unpack&quot;</span> are designed to help you out
    when dealing with fixed-width data like the above. Let's have a look at a
    solution with <span class="Li">&quot;unpack&quot;</span>:</p>
<p class="Pp"></p>
<pre>    while (&lt;&gt;) { 
        my($date, $desc, $income, $expend) = unpack(&quot;A10xA27xA7A*&quot;, $_);
        ...
    }
</pre>
<p class="Pp">That looks a bit nicer; but we've got to take apart that weird
    template. Where did I pull that out of?</p>
<p class="Pp">OK, let's have a look at some of our data again; in fact, we'll
    include the headers, and a handy ruler so we can keep track of where we
  are.</p>
<p class="Pp"></p>
<pre>             1         2         3         4         5        
    1234567890123456789012345678901234567890123456789012345678
    Date      |Description                | Income|Expenditure
    01/28/2001 Flea spray                                24.99
    01/29/2001 Camel rides to tourists      235.00
</pre>
<p class="Pp">From this, we can see that the date column stretches from column 1
    to column 10 - ten characters wide. The
    <span class="Li">&quot;pack&quot;</span>-ese for &quot;character&quot; is
    <span class="Li">&quot;A&quot;</span>, and ten of them are
    <span class="Li">&quot;A10&quot;</span>. So if we just wanted to extract the
    dates, we could say this:</p>
<p class="Pp"></p>
<pre>    my($date) = unpack(&quot;A10&quot;, $_);
</pre>
<p class="Pp">OK, what's next? Between the date and the description is a blank
    column; we want to skip over that. The <span class="Li">&quot;x&quot;</span>
    template means &quot;skip forward&quot;, so we want one of those. Next, we
    have another batch of characters, from 12 to 38. That's 27 more characters,
    hence <span class="Li">&quot;A27&quot;</span>. (Don't make the fencepost
    error - there are 27 characters between 12 and 38, not 26. Count 'em!)</p>
<p class="Pp">Now we skip another character and pick up the next 7
  characters:</p>
<p class="Pp"></p>
<pre>    my($date,$description,$income) = unpack(&quot;A10xA27xA7&quot;, $_);
</pre>
<p class="Pp">Now comes the clever bit. Lines in our ledger which are just
    income and not expenditure might end at column 46. Hence, we don't want to
    tell our <span class="Li">&quot;unpack&quot;</span> pattern that we
    <b>need</b> to find another 12 characters; we'll just say &quot;if there's
    anything left, take it&quot;. As you might guess from regular expressions,
    that's what the <span class="Li">&quot;*&quot;</span> means: &quot;use
    everything remaining&quot;.</p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>Be warned, though, that unlike regular expressions, if the
      <span class="Li">&quot;unpack&quot;</span> template doesn't match the
      incoming data, Perl will scream and die.</dd>
</dl>
<p class="Pp">Hence, putting it all together:</p>
<p class="Pp"></p>
<pre>    my ($date, $description, $income, $expend) =
        unpack(&quot;A10xA27xA7xA*&quot;, $_);
</pre>
<p class="Pp">Now, that's our data parsed. I suppose what we might want to do
    now is total up our income and expenditure, and add another line to the end
    of our ledger - in the same format - saying how much we've brought in and
    how much we've spent:</p>
<p class="Pp"></p>
<pre>    while (&lt;&gt;) {
        my ($date, $desc, $income, $expend) =
            unpack(&quot;A10xA27xA7xA*&quot;, $_);
        $tot_income += $income;
        $tot_expend += $expend;
    }
    $tot_income = sprintf(&quot;%.2f&quot;, $tot_income); # Get them into 
    $tot_expend = sprintf(&quot;%.2f&quot;, $tot_expend); # &quot;financial&quot; format
    $date = POSIX::strftime(&quot;%m/%d/%Y&quot;, localtime); 
    # OK, let's go:
    print pack(&quot;A10xA27xA7xA*&quot;, $date, &quot;Totals&quot;,
        $tot_income, $tot_expend);
</pre>
<p class="Pp">Oh, hmm. That didn't quite work. Let's see what happened:</p>
<p class="Pp"></p>
<pre>    01/24/2001 Zed's Camel Emporium                     1147.99
    01/28/2001 Flea spray                                 24.99
    01/29/2001 Camel rides to tourists     1235.00
    03/23/2001Totals                     1235.001172.98
</pre>
<p class="Pp">OK, it's a start, but what happened to the spaces? We put
    <span class="Li">&quot;x&quot;</span>, didn't we? Shouldn't it skip forward?
    Let's look at what &quot;pack&quot; in perlfunc says:</p>
<p class="Pp"></p>
<pre>    x   A null byte.
</pre>
<p class="Pp">Urgh. No wonder. There's a big difference between &quot;a null
    byte&quot;, character zero, and &quot;a space&quot;, character 32. Perl's
    put something between the date and the description - but unfortunately, we
    can't see it!</p>
<p class="Pp">What we actually need to do is expand the width of the fields. The
    <span class="Li">&quot;A&quot;</span> format pads any non-existent
    characters with spaces, so we can use the additional spaces to line up our
    fields, like this:</p>
<p class="Pp"></p>
<pre>    print pack(&quot;A11 A28 A8 A*&quot;, $date, &quot;Totals&quot;,
        $tot_income, $tot_expend);
</pre>
<p class="Pp">(Note that you can put spaces in the template to make it more
    readable, but they don't translate to spaces in the output.) Here's what we
    got this time:</p>
<p class="Pp"></p>
<pre>    01/24/2001 Zed's Camel Emporium                     1147.99
    01/28/2001 Flea spray                                 24.99
    01/29/2001 Camel rides to tourists     1235.00
    03/23/2001 Totals                      1235.00 1172.98
</pre>
<p class="Pp">That's a bit better, but we still have that last column which
    needs to be moved further over. There's an easy way to fix this up:
    unfortunately, we can't get <span class="Li">&quot;pack&quot;</span> to
    right-justify our fields, but we can get
    <span class="Li">&quot;sprintf&quot;</span> to do it:</p>
<p class="Pp"></p>
<pre>    $tot_income = sprintf(&quot;%.2f&quot;, $tot_income); 
    $tot_expend = sprintf(&quot;%12.2f&quot;, $tot_expend);
    $date = POSIX::strftime(&quot;%m/%d/%Y&quot;, localtime); 
    print pack(&quot;A11 A28 A8 A*&quot;, $date, &quot;Totals&quot;,
        $tot_income, $tot_expend);
</pre>
<p class="Pp">This time we get the right answer:</p>
<p class="Pp"></p>
<pre>    01/28/2001 Flea spray                                 24.99
    01/29/2001 Camel rides to tourists     1235.00
    03/23/2001 Totals                      1235.00      1172.98
</pre>
<p class="Pp">So that's how we consume and produce fixed-width data. Let's recap
    what we've seen of <span class="Li">&quot;pack&quot;</span> and
    <span class="Li">&quot;unpack&quot;</span> so far:</p>
<ul class="Bl-bullet">
  <li>Use <span class="Li">&quot;pack&quot;</span> to go from several pieces of
      data to one fixed-width version; use
      <span class="Li">&quot;unpack&quot;</span> to turn a fixed-width-format
      string into several pieces of data.</li>
  <li>The pack format <span class="Li">&quot;A&quot;</span> means &quot;any
      character&quot;; if you're <span class="Li">&quot;pack&quot;</span>ing and
      you've run out of things to pack, <span class="Li">&quot;pack&quot;</span>
      will fill the rest up with spaces.</li>
  <li><span class="Li">&quot;x&quot;</span> means &quot;skip a byte&quot; when
      <span class="Li">&quot;unpack&quot;</span>ing; when
      <span class="Li">&quot;pack&quot;</span>ing, it means &quot;introduce a
      null byte&quot; - that's probably not what you mean if you're dealing with
      plain text.</li>
  <li>You can follow the formats with numbers to say how many characters should
      be affected by that format: <span class="Li">&quot;A12&quot;</span> means
      &quot;take 12 characters&quot;; <span class="Li">&quot;x6&quot;</span>
      means &quot;skip 6 bytes&quot; or &quot;character 0, 6 times&quot;.</li>
  <li>Instead of a number, you can use <span class="Li">&quot;*&quot;</span> to
      mean &quot;consume everything else left&quot;.
    <p class="Pp"><b>Warning</b>: when packing multiple pieces of data,
        <span class="Li">&quot;*&quot;</span> only means &quot;consume all of
        the current piece of data&quot;. That's to say</p>
    <p class="Pp"></p>
    <pre>    pack(&quot;A*A*&quot;, $one, $two)
    </pre>
    <p class="Pp">packs all of <span class="Li">$one</span> into the first
        <span class="Li">&quot;A*&quot;</span> and then all of
        <span class="Li">$two</span> into the second. This is a general
        principle: each format character corresponds to one piece of data to be
        <span class="Li">&quot;pack&quot;</span>ed.</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="Packing_Numbers"><a class="permalink" href="#Packing_Numbers">Packing
  Numbers</a></h1>
<p class="Pp">So much for textual data. Let's get onto the meaty stuff that
    <span class="Li">&quot;pack&quot;</span> and
    <span class="Li">&quot;unpack&quot;</span> are best at: handling binary
    formats for numbers. There is, of course, not just one binary format - life
    would be too simple - but Perl will do all the finicky labor for you.</p>
<section class="Ss">
<h2 class="Ss" id="Integers"><a class="permalink" href="#Integers">Integers</a></h2>
<p class="Pp">Packing and unpacking numbers implies conversion to and from some
    <i>specific</i> binary representation. Leaving floating point numbers aside
    for the moment, the salient properties of any such representation are:</p>
<ul class="Bl-bullet">
  <li>the number of bytes used for storing the integer,</li>
  <li>whether the contents are interpreted as a signed or unsigned number,</li>
  <li>the byte ordering: whether the first byte is the least or most significant
      byte (or: little-endian or big-endian, respectively).</li>
</ul>
<p class="Pp">So, for instance, to pack 20302 to a signed 16 bit integer in your
    computer's representation you write</p>
<p class="Pp"></p>
<pre>   my $ps = pack( 's', 20302 );
</pre>
<p class="Pp">Again, the result is a string, now containing 2 bytes. If you
    print this string (which is, generally, not recommended) you might see
    <span class="Li">&quot;ON&quot;</span> or
    <span class="Li">&quot;NO&quot;</span> (depending on your system's byte
    ordering) - or something entirely different if your computer doesn't use
    ASCII character encoding. Unpacking <span class="Li">$ps</span> with the
    same template returns the original integer value:</p>
<p class="Pp"></p>
<pre>   my( $s ) = unpack( 's', $ps );
</pre>
<p class="Pp">This is true for all numeric template codes. But don't expect
    miracles: if the packed value exceeds the allotted byte capacity, high order
    bits are silently discarded, and unpack certainly won't be able to pull them
    back out of some magic hat. And, when you pack using a signed template code
    such as <span class="Li">&quot;s&quot;</span>, an excess value may result in
    the sign bit getting set, and unpacking this will smartly return a negative
    value.</p>
<p class="Pp">16 bits won't get you too far with integers, but there is
    <span class="Li">&quot;l&quot;</span> and
    <span class="Li">&quot;L&quot;</span> for signed and unsigned 32-bit
    integers. And if this is not enough and your system supports 64 bit integers
    you can push the limits much closer to infinity with pack codes
    <span class="Li">&quot;q&quot;</span> and
    <span class="Li">&quot;Q&quot;</span>. A notable exception is provided by
    pack codes <span class="Li">&quot;i&quot;</span> and
    <span class="Li">&quot;I&quot;</span> for signed and unsigned integers of
    the &quot;local custom&quot; variety: Such an integer will take up as many
    bytes as a local C compiler returns for
    <span class="Li">&quot;sizeof(int)&quot;</span>, but it'll use <i>at
    least</i> 32 bits.</p>
<p class="Pp">Each of the integer pack codes
    <span class="Li">&quot;sSlLqQ&quot;</span> results in a fixed number of
    bytes, no matter where you execute your program. This may be useful for some
    applications, but it does not provide for a portable way to pass data
    structures between Perl and C programs (bound to happen when you call XS
    extensions or the Perl function
    <span class="Li">&quot;syscall&quot;</span>), or when you read or write
    binary files. What you'll need in this case are template codes that depend
    on what your local C compiler compiles when you code
    <span class="Li">&quot;short&quot;</span> or <span class="Li">&quot;unsigned
    long&quot;</span>, for instance. These codes and their corresponding byte
    lengths are shown in the table below. Since the C standard leaves much
    leeway with respect to the relative sizes of these data types, actual values
    may vary, and that's why the values are given as expressions in C and Perl.
    (If you'd like to use values from <span class="Li">%Config</span> in your
    program you have to import it with <span class="Li">&quot;use
    Config&quot;</span>.)</p>
<p class="Pp"></p>
<pre>   signed unsigned  byte length in C   byte length in Perl       
     s!     S!      sizeof(short)      $Config{shortsize}
     i!     I!      sizeof(int)        $Config{intsize}
     l!     L!      sizeof(long)       $Config{longsize}
     q!     Q!      sizeof(long long)  $Config{longlongsize}
</pre>
<p class="Pp">The <span class="Li">&quot;i!&quot;</span> and
    <span class="Li">&quot;I!&quot;</span> codes aren't different from
    <span class="Li">&quot;i&quot;</span> and
    <span class="Li">&quot;I&quot;</span>; they are tolerated for completeness'
    sake.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Unpacking_a_Stack_Frame"><a class="permalink" href="#Unpacking_a_Stack_Frame">Unpacking
  a Stack Frame</a></h2>
<p class="Pp">Requesting a particular byte ordering may be necessary when you
    work with binary data coming from some specific architecture whereas your
    program could run on a totally different system. As an example, assume you
    have 24 bytes containing a stack frame as it happens on an Intel 8086:</p>
<p class="Pp"></p>
<pre>      +---------+        +----+----+               +---------+
 TOS: |   IP    |  TOS+4:| FL | FH | FLAGS  TOS+14:|   SI    |
      +---------+        +----+----+               +---------+
      |   CS    |        | AL | AH | AX            |   DI    |
      +---------+        +----+----+               +---------+
                         | BL | BH | BX            |   BP    |
                         +----+----+               +---------+
                         | CL | CH | CX            |   DS    |
                         +----+----+               +---------+
                         | DL | DH | DX            |   ES    |
                         +----+----+               +---------+
</pre>
<p class="Pp">First, we note that this time-honored 16-bit CPU uses
    little-endian order, and that's why the low order byte is stored at the
    lower address. To unpack such a (unsigned) short we'll have to use code
    <span class="Li">&quot;v&quot;</span>. A repeat count unpacks all 12
  shorts:</p>
<p class="Pp"></p>
<pre>   my( $ip, $cs, $flags, $ax, $bx, $cd, $dx, $si, $di, $bp, $ds, $es ) =
     unpack( 'v12', $frame );
</pre>
<p class="Pp">Alternatively, we could have used
    <span class="Li">&quot;C&quot;</span> to unpack the individually accessible
    byte registers FL, FH, AL, AH, etc.:</p>
<p class="Pp"></p>
<pre>   my( $fl, $fh, $al, $ah, $bl, $bh, $cl, $ch, $dl, $dh ) =
     unpack( 'C10', substr( $frame, 4, 10 ) );
</pre>
<p class="Pp">It would be nice if we could do this in one fell swoop: unpack a
    short, back up a little, and then unpack 2 bytes. Since Perl <i>is</i> nice,
    it proffers the template code <span class="Li">&quot;X&quot;</span> to back
    up one byte. Putting this all together, we may now write:</p>
<p class="Pp"></p>
<pre>   my( $ip, $cs,
       $flags,$fl,$fh,
       $ax,$al,$ah, $bx,$bl,$bh, $cx,$cl,$ch, $dx,$dl,$dh, 
       $si, $di, $bp, $ds, $es ) =
   unpack( 'v2' . ('vXXCC' x 5) . 'v5', $frame );
</pre>
<p class="Pp">(The clumsy construction of the template can be avoided - just
    read on!)</p>
<p class="Pp">We've taken some pains to construct the template so that it
    matches the contents of our frame buffer. Otherwise we'd either get
    undefined values, or <span class="Li">&quot;unpack&quot;</span> could not
    unpack all. If <span class="Li">&quot;pack&quot;</span> runs out of items,
    it will supply null strings (which are coerced into zeroes whenever the pack
    code says so).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="How_to_Eat_an_Egg_on_a_Net"><a class="permalink" href="#How_to_Eat_an_Egg_on_a_Net">How
  to Eat an Egg on a Net</a></h2>
<p class="Pp">The pack code for big-endian (high order byte at the lowest
    address) is <span class="Li">&quot;n&quot;</span> for 16 bit and
    <span class="Li">&quot;N&quot;</span> for 32 bit integers. You use these
    codes if you know that your data comes from a compliant architecture, but,
    surprisingly enough, you should also use these pack codes if you exchange
    binary data, across the network, with some system that you know next to
    nothing about. The simple reason is that this order has been chosen as the
    <i>network order</i>, and all standard-fearing programs ought to follow this
    convention. (This is, of course, a stern backing for one of the Lilliputian
    parties and may well influence the political development there.) So, if the
    protocol expects you to send a message by sending the length first, followed
    by just so many bytes, you could write:</p>
<p class="Pp"></p>
<pre>   my $buf = pack( 'N', length( $msg ) ) . $msg;
</pre>
<p class="Pp">or even:</p>
<p class="Pp"></p>
<pre>   my $buf = pack( 'NA*', length( $msg ), $msg );
</pre>
<p class="Pp">and pass <span class="Li">$buf</span> to your send routine. Some
    protocols demand that the count should include the length of the count
    itself: then just add 4 to the data length. (But make sure to read
    &quot;Lengths and Widths&quot; before you really code this!)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Byte-order_modifiers"><a class="permalink" href="#Byte-order_modifiers">Byte-order
  modifiers</a></h2>
<p class="Pp">In the previous sections we've learned how to use
    <span class="Li">&quot;n&quot;</span>,
    <span class="Li">&quot;N&quot;</span>, <span class="Li">&quot;v&quot;</span>
    and <span class="Li">&quot;V&quot;</span> to pack and unpack integers with
    big- or little-endian byte-order. While this is nice, it's still rather
    limited because it leaves out all kinds of signed integers as well as 64-bit
    integers. For example, if you wanted to unpack a sequence of signed
    big-endian 16-bit integers in a platform-independent way, you would have to
    write:</p>
<p class="Pp"></p>
<pre>   my @data = unpack 's*', pack 'S*', unpack 'n*', $buf;
</pre>
<p class="Pp">This is ugly. As of Perl 5.9.2, there's a much nicer way to
    express your desire for a certain byte-order: the
    <span class="Li">&quot;&gt;&quot;</span> and
    <span class="Li">&quot;&lt;&quot;</span> modifiers.
    <span class="Li">&quot;&gt;&quot;</span> is the big-endian modifier, while
    <span class="Li">&quot;&lt;&quot;</span> is the little-endian modifier.
    Using them, we could rewrite the above code as:</p>
<p class="Pp"></p>
<pre>   my @data = unpack 's&gt;*', $buf;
</pre>
<p class="Pp">As you can see, the &quot;big end&quot; of the arrow touches the
    <span class="Li">&quot;s&quot;</span>, which is a nice way to remember that
    <span class="Li">&quot;&gt;&quot;</span> is the big-endian modifier. The
    same obviously works for <span class="Li">&quot;&lt;&quot;</span>, where the
    &quot;little end&quot; touches the code.</p>
<p class="Pp">You will probably find these modifiers even more useful if you
    have to deal with big- or little-endian C structures. Be sure to read
    &quot;Packing and Unpacking C Structures&quot; for more on that.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Floating_point_Numbers"><a class="permalink" href="#Floating_point_Numbers">Floating
  point Numbers</a></h2>
<p class="Pp">For packing floating point numbers you have the choice between the
    pack codes <span class="Li">&quot;f&quot;</span>,
    <span class="Li">&quot;d&quot;</span>, <span class="Li">&quot;F&quot;</span>
    and <span class="Li">&quot;D&quot;</span>.
    <span class="Li">&quot;f&quot;</span> and
    <span class="Li">&quot;d&quot;</span> pack into (or unpack from)
    single-precision or double-precision representation as it is provided by
    your system. If your systems supports it,
    <span class="Li">&quot;D&quot;</span> can be used to pack and unpack
    (<span class="Li">&quot;long double&quot;</span>) values, which can offer
    even more resolution than <span class="Li">&quot;f&quot;</span> or
    <span class="Li">&quot;d&quot;</span>. <b>Note that there are different long
    double formats.</b></p>
<p class="Pp"><span class="Li">&quot;F&quot;</span> packs an
    <span class="Li">&quot;NV&quot;</span>, which is the floating point type
    used by Perl internally.</p>
<p class="Pp">There is no such thing as a network representation for reals, so
    if you want to send your real numbers across computer boundaries, you'd
    better stick to text representation, possibly using the hexadecimal float
    format (avoiding the decimal conversion loss), unless you're absolutely sure
    what's on the other end of the line. For the even more adventuresome, you
    can use the byte-order modifiers from the previous section also on floating
    point codes.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Exotic_Templates"><a class="permalink" href="#Exotic_Templates">Exotic
  Templates</a></h1>
<section class="Ss">
<h2 class="Ss" id="Bit_Strings"><a class="permalink" href="#Bit_Strings">Bit
  Strings</a></h2>
<p class="Pp">Bits are the atoms in the memory world. Access to individual bits
    may have to be used either as a last resort or because it is the most
    convenient way to handle your data. Bit string (un)packing converts between
    strings containing a series of <span class="Li">0</span> and
    <span class="Li">1</span> characters and a sequence of bytes each containing
    a group of 8 bits. This is almost as simple as it sounds, except that there
    are two ways the contents of a byte may be written as a bit string. Let's
    have a look at an annotated byte:</p>
<p class="Pp"></p>
<pre>     7 6 5 4 3 2 1 0
   +-----------------+
   | 1 0 0 0 1 1 0 0 |
   +-----------------+
    MSB           LSB
</pre>
<p class="Pp">It's egg-eating all over again: Some think that as a bit string
    this should be written &quot;10001100&quot; i.e. beginning with the most
    significant bit, others insist on &quot;00110001&quot;. Well, Perl isn't
    biased, so that's why we have two bit string codes:</p>
<p class="Pp"></p>
<pre>   $byte = pack( 'B8', '10001100' ); # start with MSB
   $byte = pack( 'b8', '00110001' ); # start with LSB
</pre>
<p class="Pp">It is not possible to pack or unpack bit fields - just integral
    bytes. <span class="Li">&quot;pack&quot;</span> always starts at the next
    byte boundary and &quot;rounds up&quot; to the next multiple of 8 by adding
    zero bits as required. (If you do want bit fields, there is &quot;vec&quot;
    in perlfunc. Or you could implement bit field handling at the character
    string level, using split, substr, and concatenation on unpacked bit
    strings.)</p>
<p class="Pp">To illustrate unpacking for bit strings, we'll decompose a simple
    status register (a &quot;-&quot; stands for a &quot;reserved&quot; bit):</p>
<p class="Pp"></p>
<pre>   +-----------------+-----------------+
   | S Z - A - P - C | - - - - O D I T |
   +-----------------+-----------------+
    MSB           LSB MSB           LSB
</pre>
<p class="Pp">Converting these two bytes to a string can be done with the unpack
    template <span class="Li">'b16'</span>. To obtain the individual bit values
    from the bit string we use <span class="Li">&quot;split&quot;</span> with
    the &quot;empty&quot; separator pattern which dissects into individual
    characters. Bit values from the &quot;reserved&quot; positions are simply
    assigned to <span class="Li">&quot;undef&quot;</span>, a convenient notation
    for &quot;I don't care where this goes&quot;.</p>
<p class="Pp"></p>
<pre>   ($carry, undef, $parity, undef, $auxcarry, undef, $zero, $sign,
    $trace, $interrupt, $direction, $overflow) =
      split( //, unpack( 'b16', $status ) );
</pre>
<p class="Pp">We could have used an unpack template
    <span class="Li">'b12'</span> just as well, since the last 4 bits can be
    ignored anyway.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Uuencoding"><a class="permalink" href="#Uuencoding">Uuencoding</a></h2>
<p class="Pp">Another odd-man-out in the template alphabet is
    <span class="Li">&quot;u&quot;</span>, which packs a &quot;uuencoded
    string&quot;. (&quot;uu&quot; is short for Unix-to-Unix.) Chances are that
    you won't ever need this encoding technique which was invented to overcome
    the shortcomings of old-fashioned transmission mediums that do not support
    other than simple ASCII data. The essential recipe is simple: Take three
    bytes, or 24 bits. Split them into 4 six-packs, adding a space (0x20) to
    each. Repeat until all of the data is blended. Fold groups of 4 bytes into
    lines no longer than 60 and garnish them in front with the original byte
    count (incremented by 0x20) and a <span class="Li">&quot;\n&quot;</span> at
    the end. - The <span class="Li">&quot;pack&quot;</span> chef will prepare
    this for you, a la minute, when you select pack code
    <span class="Li">&quot;u&quot;</span> on the menu:</p>
<p class="Pp"></p>
<pre>   my $uubuf = pack( 'u', $bindat );
</pre>
<p class="Pp">A repeat count after <span class="Li">&quot;u&quot;</span> sets
    the number of bytes to put into an uuencoded line, which is the maximum of
    45 by default, but could be set to some (smaller) integer multiple of three.
    <span class="Li">&quot;unpack&quot;</span> simply ignores the repeat
  count.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Doing_Sums"><a class="permalink" href="#Doing_Sums">Doing
  Sums</a></h2>
<p class="Pp">An even stranger template code is
    <span class="Li">&quot;%&quot;</span>&lt;<i>number</i>&gt;. First, because
    it's used as a prefix to some other template code. Second, because it cannot
    be used in <span class="Li">&quot;pack&quot;</span> at all, and third, in
    <span class="Li">&quot;unpack&quot;</span>, doesn't return the data as
    defined by the template code it precedes. Instead it'll give you an integer
    of <i>number</i> bits that is computed from the data value by doing sums.
    For numeric unpack codes, no big feat is achieved:</p>
<p class="Pp"></p>
<pre>    my $buf = pack( 'iii', 100, 20, 3 );
    print unpack( '%32i3', $buf ), &quot;\n&quot;;  # prints 123
</pre>
<p class="Pp">For string values, <span class="Li">&quot;%&quot;</span> returns
    the sum of the byte values saving you the trouble of a sum loop with
    <span class="Li">&quot;substr&quot;</span> and
    <span class="Li">&quot;ord&quot;</span>:</p>
<p class="Pp"></p>
<pre>    print unpack( '%32A*', &quot;\x01\x10&quot; ), &quot;\n&quot;;  # prints 17
</pre>
<p class="Pp">Although the <span class="Li">&quot;%&quot;</span> code is
    documented as returning a &quot;checksum&quot;: don't put your trust in such
    values! Even when applied to a small number of bytes, they won't guarantee a
    noticeable Hamming distance.</p>
<p class="Pp">In connection with <span class="Li">&quot;b&quot;</span> or
    <span class="Li">&quot;B&quot;</span>, <span class="Li">&quot;%&quot;</span>
    simply adds bits, and this can be put to good use to count set bits
    efficiently:</p>
<p class="Pp"></p>
<pre>    my $bitcount = unpack( '%32b*', $mask );
</pre>
<p class="Pp">And an even parity bit can be determined like this:</p>
<p class="Pp"></p>
<pre>    my $evenparity = unpack( '%1b*', $mask );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Unicode"><a class="permalink" href="#Unicode">Unicode</a></h2>
<p class="Pp">Unicode is a character set that can represent most characters in
    most of the world's languages, providing room for over one million different
    characters. Unicode 3.1 specifies 94,140 characters: The Basic Latin
    characters are assigned to the numbers 0 - 127. The Latin-1 Supplement with
    characters that are used in several European languages is in the next range,
    up to 255. After some more Latin extensions we find the character sets from
    languages using non-Roman alphabets, interspersed with a variety of symbol
    sets such as currency symbols, Zapf Dingbats or Braille. (You might want to
    visit &lt;http://www.unicode.org/&gt; for a look at some of them - my
    personal favourites are Telugu and Kannada.)</p>
<p class="Pp">The Unicode character sets associates characters with integers.
    Encoding these numbers in an equal number of bytes would more than double
    the requirements for storing texts written in Latin alphabets. The UTF-8
    encoding avoids this by storing the most common (from a western point of
    view) characters in a single byte while encoding the rarer ones in three or
    more bytes.</p>
<p class="Pp">Perl uses UTF-8, internally, for most Unicode strings.</p>
<p class="Pp">So what has this got to do with
    <span class="Li">&quot;pack&quot;</span>? Well, if you want to compose a
    Unicode string (that is internally encoded as UTF-8), you can do so by using
    template code <span class="Li">&quot;U&quot;</span>. As an example, let's
    produce the Euro currency symbol (code number 0x20AC):</p>
<p class="Pp"></p>
<pre>   $UTF8{Euro} = pack( 'U', 0x20AC );
   # Equivalent to: $UTF8{Euro} = &quot;\x{20ac}&quot;;
</pre>
<p class="Pp">Inspecting <span class="Li">$UTF8{Euro}</span> shows that it
    contains 3 bytes: &quot;\xe2\x82\xac&quot;. However, it contains only 1
    character, number 0x20AC. The round trip can be completed with
    <span class="Li">&quot;unpack&quot;</span>:</p>
<p class="Pp"></p>
<pre>   $Unicode{Euro} = unpack( 'U', $UTF8{Euro} );
</pre>
<p class="Pp">Unpacking using the <span class="Li">&quot;U&quot;</span> template
    code also works on UTF-8 encoded byte strings.</p>
<p class="Pp">Usually you'll want to pack or unpack UTF-8 strings:</p>
<p class="Pp"></p>
<pre>   # pack and unpack the Hebrew alphabet
   my $alefbet = pack( 'U*', 0x05d0..0x05ea );
   my @hebrew = unpack( 'U*', $utf );
</pre>
<p class="Pp">Please note: in the general case, you're better off using
    <span class="Li">&quot;Encode::decode('UTF-8', $utf)&quot;</span> to decode
    a UTF-8 encoded byte string to a Perl Unicode string, and
    <span class="Li">&quot;Encode::encode('UTF-8', $str)&quot;</span> to encode
    a Perl Unicode string to UTF-8 bytes. These functions provide means of
    handling invalid byte sequences and generally have a friendlier
  interface.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Another_Portable_Binary_Encoding"><a class="permalink" href="#Another_Portable_Binary_Encoding">Another
  Portable Binary Encoding</a></h2>
<p class="Pp">The pack code <span class="Li">&quot;w&quot;</span> has been added
    to support a portable binary data encoding scheme that goes way beyond
    simple integers. (Details can be found at &lt;http://Casbah.org/&gt;, the
    Scarab project.) A BER (Binary Encoded Representation) compressed unsigned
    integer stores base 128 digits, most significant digit first, with as few
    digits as possible. Bit eight (the high bit) is set on each byte except the
    last. There is no size limit to BER encoding, but Perl won't go to
  extremes.</p>
<p class="Pp"></p>
<pre>   my $berbuf = pack( 'w*', 1, 128, 128+1, 128*128+127 );
</pre>
<p class="Pp">A hex dump of <span class="Li">$berbuf</span>, with spaces
    inserted at the right places, shows 01 8100 8101 81807F. Since the last byte
    is always less than 128, <span class="Li">&quot;unpack&quot;</span> knows
    where to stop.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Template_Grouping"><a class="permalink" href="#Template_Grouping">Template
  Grouping</a></h1>
<p class="Pp">Prior to Perl 5.8, repetitions of templates had to be made by
    <span class="Li">&quot;x&quot;</span>-multiplication of template strings.
    Now there is a better way as we may use the pack codes
    <span class="Li">&quot;(&quot;</span> and
    <span class="Li">&quot;)&quot;</span> combined with a repeat count. The
    <span class="Li">&quot;unpack&quot;</span> template from the Stack Frame
    example can simply be written like this:</p>
<p class="Pp"></p>
<pre>   unpack( 'v2 (vXXCC)5 v5', $frame )
</pre>
<p class="Pp">Let's explore this feature a little more. We'll begin with the
    equivalent of</p>
<p class="Pp"></p>
<pre>   join( '', map( substr( $_, 0, 1 ), @str ) )
</pre>
<p class="Pp">which returns a string consisting of the first character from each
    string. Using pack, we can write</p>
<p class="Pp"></p>
<pre>   pack( '(A)'.@str, @str )
</pre>
<p class="Pp">or, because a repeat count <span class="Li">&quot;*&quot;</span>
    means &quot;repeat as often as required&quot;, simply</p>
<p class="Pp"></p>
<pre>   pack( '(A)*', @str )
</pre>
<p class="Pp">(Note that the template <span class="Li">&quot;A*&quot;</span>
    would only have packed <span class="Li">$str[0]</span> in full length.)</p>
<p class="Pp">To pack dates stored as triplets ( day, month, year ) in an array
    <span class="Li">@dates</span> into a sequence of byte, byte, short integer
    we can write</p>
<p class="Pp"></p>
<pre>   $pd = pack( '(CCS)*', map( @$_, @dates ) );
</pre>
<p class="Pp">To swap pairs of characters in a string (with even length) one
    could use several techniques. First, let's use
    <span class="Li">&quot;x&quot;</span> and
    <span class="Li">&quot;X&quot;</span> to skip forward and back:</p>
<p class="Pp"></p>
<pre>   $s = pack( '(A)*', unpack( '(xAXXAx)*', $s ) );
</pre>
<p class="Pp">We can also use <span class="Li">&quot;@&quot;</span> to jump to
    an offset, with 0 being the position where we were when the last
    <span class="Li">&quot;(&quot;</span> was encountered:</p>
<p class="Pp"></p>
<pre>   $s = pack( '(A)*', unpack( '(@1A @0A @2)*', $s ) );
</pre>
<p class="Pp">Finally, there is also an entirely different approach by unpacking
    big endian shorts and packing them in the reverse byte order:</p>
<p class="Pp"></p>
<pre>   $s = pack( '(v)*', unpack( '(n)*', $s );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="Lengths_and_Widths"><a class="permalink" href="#Lengths_and_Widths">Lengths
  and Widths</a></h1>
<section class="Ss">
<h2 class="Ss" id="String_Lengths"><a class="permalink" href="#String_Lengths">String
  Lengths</a></h2>
<p class="Pp">In the previous section we've seen a network message that was
    constructed by prefixing the binary message length to the actual message.
    You'll find that packing a length followed by so many bytes of data is a
    frequently used recipe since appending a null byte won't work if a null byte
    may be part of the data. Here is an example where both techniques are used:
    after two null terminated strings with source and destination address, a
    Short Message (to a mobile phone) is sent after a length byte:</p>
<p class="Pp"></p>
<pre>   my $msg = pack( 'Z*Z*CA*', $src, $dst, length( $sm ), $sm );
</pre>
<p class="Pp">Unpacking this message can be done with the same template:</p>
<p class="Pp"></p>
<pre>   ( $src, $dst, $len, $sm ) = unpack( 'Z*Z*CA*', $msg );
</pre>
<p class="Pp">There's a subtle trap lurking in the offing: Adding another field
    after the Short Message (in variable <span class="Li">$sm</span>) is all
    right when packing, but this cannot be unpacked naively:</p>
<p class="Pp"></p>
<pre>   # pack a message
   my $msg = pack( 'Z*Z*CA*C', $src, $dst, length( $sm ), $sm, $prio );
   # unpack fails - $prio remains undefined!
   ( $src, $dst, $len, $sm, $prio ) = unpack( 'Z*Z*CA*C', $msg );
</pre>
<p class="Pp">The pack code <span class="Li">&quot;A*&quot;</span> gobbles up
    all remaining bytes, and <span class="Li">$prio</span> remains undefined!
    Before we let disappointment dampen the morale: Perl's got the trump card to
    make this trick too, just a little further up the sleeve. Watch this:</p>
<p class="Pp"></p>
<pre>   # pack a message: ASCIIZ, ASCIIZ, length/string, byte
   my $msg = pack( 'Z* Z* C/A* C', $src, $dst, $sm, $prio );
   # unpack
   ( $src, $dst, $sm, $prio ) = unpack( 'Z* Z* C/A* C', $msg );
</pre>
<p class="Pp">Combining two pack codes with a slash
    (<span class="Li">&quot;/&quot;</span>) associates them with a single value
    from the argument list. In <span class="Li">&quot;pack&quot;</span>, the
    length of the argument is taken and packed according to the first code while
    the argument itself is added after being converted with the template code
    after the slash. This saves us the trouble of inserting the
    <span class="Li">&quot;length&quot;</span> call, but it is in
    <span class="Li">&quot;unpack&quot;</span> where we really score: The value
    of the length byte marks the end of the string to be taken from the buffer.
    Since this combination doesn't make sense except when the second pack code
    isn't <span class="Li">&quot;a*&quot;</span>,
    <span class="Li">&quot;A*&quot;</span> or
    <span class="Li">&quot;Z*&quot;</span>, Perl won't let you.</p>
<p class="Pp">The pack code preceding <span class="Li">&quot;/&quot;</span> may
    be anything that's fit to represent a number: All the numeric binary pack
    codes, and even text codes such as <span class="Li">&quot;A4&quot;</span> or
    <span class="Li">&quot;Z*&quot;</span>:</p>
<p class="Pp"></p>
<pre>   # pack/unpack a string preceded by its length in ASCII
   my $buf = pack( 'A4/A*', &quot;Humpty-Dumpty&quot; );
   # unpack $buf: '13  Humpty-Dumpty'
   my $txt = unpack( 'A4/A*', $buf );
</pre>
<p class="Pp"><span class="Li">&quot;/&quot;</span> is not implemented in Perls
    before 5.6, so if your code is required to work on ancient Perls you'll need
    to <span class="Li">&quot;unpack( 'Z* Z* C')&quot;</span> to get the length,
    then use it to make a new unpack string. For example</p>
<p class="Pp"></p>
<pre>   # pack a message: ASCIIZ, ASCIIZ, length, string, byte
   # (5.005 compatible)
   my $msg = pack( 'Z* Z* C A* C', $src, $dst, length $sm, $sm, $prio );
   # unpack
   ( undef, undef, $len) = unpack( 'Z* Z* C', $msg );
   ($src, $dst, $sm, $prio) = unpack ( &quot;Z* Z* x A$len C&quot;, $msg );
</pre>
<p class="Pp">But that second <span class="Li">&quot;unpack&quot;</span> is
    rushing ahead. It isn't using a simple literal string for the template. So
    maybe we should introduce...</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Dynamic_Templates"><a class="permalink" href="#Dynamic_Templates">Dynamic
  Templates</a></h2>
<p class="Pp">So far, we've seen literals used as templates. If the list of pack
    items doesn't have fixed length, an expression constructing the template is
    required (whenever, for some reason, <span class="Li">&quot;()*&quot;</span>
    cannot be used). Here's an example: To store named string values in a way
    that can be conveniently parsed by a C program, we create a sequence of
    names and null terminated ASCII strings, with
    <span class="Li">&quot;=&quot;</span> between the name and the value,
    followed by an additional delimiting null byte. Here's how:</p>
<p class="Pp"></p>
<pre>   my $env = pack( '(A*A*Z*)' . keys( %Env ) . 'C',
                   map( { ( $_, '=', $Env{$_} ) } keys( %Env ) ), 0 );
</pre>
<p class="Pp">Let's examine the cogs of this byte mill, one by one. There's the
    <span class="Li">&quot;map&quot;</span> call, creating the items we intend
    to stuff into the <span class="Li">$env</span> buffer: to each key (in
    <span class="Li">$_</span>) it adds the
    <span class="Li">&quot;=&quot;</span> separator and the hash entry value.
    Each triplet is packed with the template code sequence
    <span class="Li">&quot;A*A*Z*&quot;</span> that is repeated according to the
    number of keys. (Yes, that's what the
    <span class="Li">&quot;keys&quot;</span> function returns in scalar
    context.) To get the very last null byte, we add a <span class="Li">0</span>
    at the end of the <span class="Li">&quot;pack&quot;</span> list, to be
    packed with <span class="Li">&quot;C&quot;</span>. (Attentive readers may
    have noticed that we could have omitted the 0.)</p>
<p class="Pp">For the reverse operation, we'll have to determine the number of
    items in the buffer before we can let
    <span class="Li">&quot;unpack&quot;</span> rip it apart:</p>
<p class="Pp"></p>
<pre>   my $n = $env =~ tr/\0// - 1;
   my %env = map( split( /=/, $_ ), unpack( &quot;(Z*)$n&quot;, $env ) );
</pre>
<p class="Pp">The <span class="Li">&quot;tr&quot;</span> counts the null bytes.
    The <span class="Li">&quot;unpack&quot;</span> call returns a list of
    name-value pairs each of which is taken apart in the
    <span class="Li">&quot;map&quot;</span> block.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Counting_Repetitions"><a class="permalink" href="#Counting_Repetitions">Counting
  Repetitions</a></h2>
<p class="Pp">Rather than storing a sentinel at the end of a data item (or a
    list of items), we could precede the data with a count. Again, we pack keys
    and values of a hash, preceding each with an unsigned short length count,
    and up front we store the number of pairs:</p>
<p class="Pp"></p>
<pre>   my $env = pack( 'S(S/A* S/A*)*', scalar keys( %Env ), %Env );
</pre>
<p class="Pp">This simplifies the reverse operation as the number of repetitions
    can be unpacked with the <span class="Li">&quot;/&quot;</span> code:</p>
<p class="Pp"></p>
<pre>   my %env = unpack( 'S/(S/A* S/A*)', $env );
</pre>
<p class="Pp">Note that this is one of the rare cases where you cannot use the
    same template for <span class="Li">&quot;pack&quot;</span> and
    <span class="Li">&quot;unpack&quot;</span> because
    <span class="Li">&quot;pack&quot;</span> can't determine a repeat count for
    a <span class="Li">&quot;()&quot;</span>-group.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Intel_"><a class="permalink" href="#Intel_">Intel
  HEX</a></h2>
<p class="Pp">Intel HEX is a file format for representing binary data, mostly
    for programming various chips, as a text file. (See
    &lt;http://en.wikipedia.org/wiki/.hex&gt; for a detailed description, and
    &lt;http://en.wikipedia.org/wiki/SREC_(file_format)&gt; for the Motorola
    S-record format, which can be unravelled using the same technique.) Each
    line begins with a colon (':') and is followed by a sequence of hexadecimal
    characters, specifying a byte count <i>n</i> (8 bit), an address (16 bit,
    big endian), a record type (8 bit), <i>n</i> data bytes and a checksum (8
    bit) computed as the least significant byte of the two's complement sum of
    the preceding bytes. Example:
    <span class="Li">&quot;:0300300002337A1E&quot;</span>.</p>
<p class="Pp">The first step of processing such a line is the conversion, to
    binary, of the hexadecimal data, to obtain the four fields, while checking
    the checksum. No surprise here: we'll start with a simple
    <span class="Li">&quot;pack&quot;</span> call to convert everything to
    binary:</p>
<p class="Pp"></p>
<pre>   my $binrec = pack( 'H*', substr( $hexrec, 1 ) );
</pre>
<p class="Pp">The resulting byte sequence is most convenient for checking the
    checksum. Don't slow your program down with a for loop adding the
    <span class="Li">&quot;ord&quot;</span> values of this string's bytes - the
    <span class="Li">&quot;unpack&quot;</span> code
    <span class="Li">&quot;%&quot;</span> is the thing to use for computing the
    8-bit sum of all bytes, which must be equal to zero:</p>
<p class="Pp"></p>
<pre>   die unless unpack( &quot;%8C*&quot;, $binrec ) == 0;
</pre>
<p class="Pp">Finally, let's get those four fields. By now, you shouldn't have
    any problems with the first three fields - but how can we use the byte count
    of the data in the first field as a length for the data field? Here the
    codes <span class="Li">&quot;x&quot;</span> and
    <span class="Li">&quot;X&quot;</span> come to the rescue, as they permit
    jumping back and forth in the string to unpack.</p>
<p class="Pp"></p>
<pre>   my( $addr, $type, $data ) = unpack( &quot;x n C X4 C x3 /a&quot;, $bin );
</pre>
<p class="Pp">Code <span class="Li">&quot;x&quot;</span> skips a byte, since we
    don't need the count yet. Code <span class="Li">&quot;n&quot;</span> takes
    care of the 16-bit big-endian integer address, and
    <span class="Li">&quot;C&quot;</span> unpacks the record type. Being at
    offset 4, where the data begins, we need the count.
    <span class="Li">&quot;X4&quot;</span> brings us back to square one, which
    is the byte at offset 0. Now we pick up the count, and zoom forth to offset
    4, where we are now fully furnished to extract the exact number of data
    bytes, leaving the trailing checksum byte alone.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Packing_and_Unpacking_C_Structures"><a class="permalink" href="#Packing_and_Unpacking_C_Structures">Packing
  and Unpacking C Structures</a></h1>
<p class="Pp">In previous sections we have seen how to pack numbers and
    character strings. If it were not for a couple of snags we could conclude
    this section right away with the terse remark that C structures don't
    contain anything else, and therefore you already know all there is to it.
    Sorry, no: read on, please.</p>
<p class="Pp">If you have to deal with a lot of C structures, and don't want to
    hack all your template strings manually, you'll probably want to have a look
    at the CPAN module <span class="Li">&quot;Convert::Binary::C&quot;</span>.
    Not only can it parse your C source directly, but it also has built-in
    support for all the odds and ends described further on in this section.</p>
<section class="Ss">
<h2 class="Ss" id="The_Alignment_Pit"><a class="permalink" href="#The_Alignment_Pit">The
  Alignment Pit</a></h2>
<p class="Pp">In the consideration of speed against memory requirements the
    balance has been tilted in favor of faster execution. This has influenced
    the way C compilers allocate memory for structures: On architectures where a
    16-bit or 32-bit operand can be moved faster between places in memory, or to
    or from a CPU register, if it is aligned at an even or multiple-of-four or
    even at a multiple-of eight address, a C compiler will give you this speed
    benefit by stuffing extra bytes into structures. If you don't cross the C
    shoreline this is not likely to cause you any grief (although you should
    care when you design large data structures, or you want your code to be
    portable between architectures (you do want that, don't you?)).</p>
<p class="Pp">To see how this affects <span class="Li">&quot;pack&quot;</span>
    and <span class="Li">&quot;unpack&quot;</span>, we'll compare these two C
    structures:</p>
<p class="Pp"></p>
<pre>   typedef struct {
     char     c1;
     short    s;
     char     c2;
     long     l;
   } gappy_t;
   typedef struct {
     long     l;
     short    s;
     char     c1;
     char     c2;
   } dense_t;
</pre>
<p class="Pp">Typically, a C compiler allocates 12 bytes to a
    <span class="Li">&quot;gappy_t&quot;</span> variable, but requires only 8
    bytes for a <span class="Li">&quot;dense_t&quot;</span>. After investigating
    this further, we can draw memory maps, showing where the extra 4 bytes are
    hidden:</p>
<p class="Pp"></p>
<pre>   0           +4          +8          +12
   +--+--+--+--+--+--+--+--+--+--+--+--+
   |c1|xx|  s  |c2|xx|xx|xx|     l     |    xx = fill byte
   +--+--+--+--+--+--+--+--+--+--+--+--+
   gappy_t
   0           +4          +8
   +--+--+--+--+--+--+--+--+
   |     l     |  h  |c1|c2|
   +--+--+--+--+--+--+--+--+
   dense_t
</pre>
<p class="Pp">And that's where the first quirk strikes:
    <span class="Li">&quot;pack&quot;</span> and
    <span class="Li">&quot;unpack&quot;</span> templates have to be stuffed with
    <span class="Li">&quot;x&quot;</span> codes to get those extra fill
  bytes.</p>
<p class="Pp">The natural question: &quot;Why can't Perl compensate for the
    gaps?&quot; warrants an answer. One good reason is that C compilers might
    provide (non-ANSI) extensions permitting all sorts of fancy control over the
    way structures are aligned, even at the level of an individual structure
    field. And, if this were not enough, there is an insidious thing called
    <span class="Li">&quot;union&quot;</span> where the amount of fill bytes
    cannot be derived from the alignment of the next item alone.</p>
<p class="Pp">OK, so let's bite the bullet. Here's one way to get the alignment
    right by inserting template codes <span class="Li">&quot;x&quot;</span>,
    which don't take a corresponding item from the list:</p>
<p class="Pp"></p>
<pre>  my $gappy = pack( 'cxs cxxx l!', $c1, $s, $c2, $l );
</pre>
<p class="Pp">Note the <span class="Li">&quot;!&quot;</span> after
    <span class="Li">&quot;l&quot;</span>: We want to make sure that we pack a
    long integer as it is compiled by our C compiler. And even now, it will only
    work for the platforms where the compiler aligns things as above. And
    somebody somewhere has a platform where it doesn't. [Probably a Cray, where
    <span class="Li">&quot;short&quot;</span>s,
    <span class="Li">&quot;int&quot;</span>s and
    <span class="Li">&quot;long&quot;</span>s are all 8 bytes. :-)]</p>
<p class="Pp">Counting bytes and watching alignments in lengthy structures is
    bound to be a drag. Isn't there a way we can create the template with a
    simple program? Here's a C program that does the trick:</p>
<p class="Pp"></p>
<pre>   #include &lt;stdio.h&gt;
   #include &lt;stddef.h&gt;
   typedef struct {
     char     fc1;
     short    fs;
     char     fc2;
     long     fl;
   } gappy_t;
   #define Pt(struct,field,tchar) \
     printf( &quot;@%d%s &quot;, offsetof(struct,field), # tchar );
   int main() {
     Pt( gappy_t, fc1, c  );
     Pt( gappy_t, fs,  s! );
     Pt( gappy_t, fc2, c  );
     Pt( gappy_t, fl,  l! );
     printf( &quot;\n&quot; );
   }
</pre>
<p class="Pp">The output line can be used as a template in a
    <span class="Li">&quot;pack&quot;</span> or
    <span class="Li">&quot;unpack&quot;</span> call:</p>
<p class="Pp"></p>
<pre>  my $gappy = pack( '@0c @2s! @4c @8l!', $c1, $s, $c2, $l );
</pre>
<p class="Pp">Gee, yet another template code - as if we hadn't plenty. But
    <span class="Li">&quot;@&quot;</span> saves our day by enabling us to
    specify the offset from the beginning of the pack buffer to the next item:
    This is just the value the <span class="Li">&quot;offsetof&quot;</span>
    macro (defined in <span class="Li">&quot;&lt;stddef.h&gt;&quot;</span>)
    returns when given a <span class="Li">&quot;struct&quot;</span> type and one
    of its field names (&quot;member-designator&quot; in C standardese).</p>
<p class="Pp">Neither using offsets nor adding
    <span class="Li">&quot;x&quot;</span>'s to bridge the gaps is satisfactory.
    (Just imagine what happens if the structure changes.) What we really need is
    a way of saying &quot;skip as many bytes as required to the next multiple of
    N&quot;. In fluent Templatese, you say this with
    <span class="Li">&quot;x!N&quot;</span> where N is replaced by the
    appropriate value. Here's the next version of our struct packaging:</p>
<p class="Pp"></p>
<pre>  my $gappy = pack( 'c x!2 s c x!4 l!', $c1, $s, $c2, $l );
</pre>
<p class="Pp">That's certainly better, but we still have to know how long all
    the integers are, and portability is far away. Rather than
    <span class="Li">2</span>, for instance, we want to say &quot;however long a
    short is&quot;. But this can be done by enclosing the appropriate pack code
    in brackets: <span class="Li">&quot;[s]&quot;</span>. So, here's the very
    best we can do:</p>
<p class="Pp"></p>
<pre>  my $gappy = pack( 'c x![s] s c x![l!] l!', $c1, $s, $c2, $l );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Dealing_with_Endian-ness"><a class="permalink" href="#Dealing_with_Endian-ness">Dealing
  with Endian-ness</a></h2>
<p class="Pp">Now, imagine that we want to pack the data for a machine with a
    different byte-order. First, we'll have to figure out how big the data types
    on the target machine really are. Let's assume that the longs are 32 bits
    wide and the shorts are 16 bits wide. You can then rewrite the template
  as:</p>
<p class="Pp"></p>
<pre>  my $gappy = pack( 'c x![s] s c x![l] l', $c1, $s, $c2, $l );
</pre>
<p class="Pp">If the target machine is little-endian, we could write:</p>
<p class="Pp"></p>
<pre>  my $gappy = pack( 'c x![s] s&lt; c x![l] l&lt;', $c1, $s, $c2, $l );
</pre>
<p class="Pp">This forces the short and the long members to be little-endian,
    and is just fine if you don't have too many struct members. But we could
    also use the byte-order modifier on a group and write the following:</p>
<p class="Pp"></p>
<pre>  my $gappy = pack( '( c x![s] s c x![l] l )&lt;', $c1, $s, $c2, $l );
</pre>
<p class="Pp">This is not as short as before, but it makes it more obvious that
    we intend to have little-endian byte-order for a whole group, not only for
    individual template codes. It can also be more readable and easier to
    maintain.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Alignment,_Take_2"><a class="permalink" href="#Alignment,_Take_2">Alignment,
  Take 2</a></h2>
<p class="Pp">I'm afraid that we're not quite through with the alignment catch
    yet. The hydra raises another ugly head when you pack arrays of
  structures:</p>
<p class="Pp"></p>
<pre>   typedef struct {
     short    count;
     char     glyph;
   } cell_t;
   typedef cell_t buffer_t[BUFLEN];
</pre>
<p class="Pp">Where's the catch? Padding is neither required before the first
    field <span class="Li">&quot;count&quot;</span>, nor between this and the
    next field <span class="Li">&quot;glyph&quot;</span>, so why can't we simply
    pack like this:</p>
<p class="Pp"></p>
<pre>   # something goes wrong here:
   pack( 's!a' x @buffer,
         map{ ( $_-&gt;{count}, $_-&gt;{glyph} ) } @buffer );
</pre>
<p class="Pp">This packs <span class="Li">&quot;3*@buffer&quot;</span> bytes,
    but it turns out that the size of
    <span class="Li">&quot;buffer_t&quot;</span> is four times
    <span class="Li">&quot;BUFLEN&quot;</span>! The moral of the story is that
    the required alignment of a structure or array is propagated to the next
    higher level where we have to consider padding <i>at the end</i> of each
    component as well. Thus the correct template is:</p>
<p class="Pp"></p>
<pre>   pack( 's!ax' x @buffer,
         map{ ( $_-&gt;{count}, $_-&gt;{glyph} ) } @buffer );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Alignment,_Take_3"><a class="permalink" href="#Alignment,_Take_3">Alignment,
  Take 3</a></h2>
<p class="Pp">And even if you take all the above into account, ANSI still lets
    this:</p>
<p class="Pp"></p>
<pre>   typedef struct {
     char     foo[2];
   } foo_t;
</pre>
<p class="Pp">vary in size. The alignment constraint of the structure can be
    greater than any of its elements. [And if you think that this doesn't affect
    anything common, dismember the next cellphone that you see. Many have ARM
    cores, and the ARM structure rules make <span class="Li">&quot;sizeof
    (foo_t)&quot;</span> == 4]</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Pointers_for_How_to_Use_Them"><a class="permalink" href="#Pointers_for_How_to_Use_Them">Pointers
  for How to Use Them</a></h2>
<p class="Pp">The title of this section indicates the second problem you may run
    into sooner or later when you pack C structures. If the function you intend
    to call expects a, say, <span class="Li">&quot;void *&quot;</span> value,
    you <i>cannot</i> simply take a reference to a Perl variable. (Although that
    value certainly is a memory address, it's not the address where the
    variable's contents are stored.)</p>
<p class="Pp">Template code <span class="Li">&quot;P&quot;</span> promises to
    pack a &quot;pointer to a fixed length string&quot;. Isn't this what we
    want? Let's try:</p>
<p class="Pp"></p>
<pre>    # allocate some storage and pack a pointer to it
    my $memory = &quot;\x00&quot; x $size;
    my $memptr = pack( 'P', $memory );
</pre>
<p class="Pp">But wait: doesn't <span class="Li">&quot;pack&quot;</span> just
    return a sequence of bytes? How can we pass this string of bytes to some C
    code expecting a pointer which is, after all, nothing but a number? The
    answer is simple: We have to obtain the numeric address from the bytes
    returned by <span class="Li">&quot;pack&quot;</span>.</p>
<p class="Pp"></p>
<pre>    my $ptr = unpack( 'L!', $memptr );
</pre>
<p class="Pp">Obviously this assumes that it is possible to typecast a pointer
    to an unsigned long and vice versa, which frequently works but should not be
    taken as a universal law. - Now that we have this pointer the next question
    is: How can we put it to good use? We need a call to some C function where a
    pointer is expected. The <b>read</b>(2) system call comes to mind:</p>
<p class="Pp"></p>
<pre>    ssize_t read(int fd, void *buf, size_t count);
</pre>
<p class="Pp">After reading perlfunc explaining how to use
    <span class="Li">&quot;syscall&quot;</span> we can write this Perl function
    copying a file to standard output:</p>
<p class="Pp"></p>
<pre>    require 'syscall.ph'; # run h2ph to generate this file
    sub cat($){
        my $path = shift();
        my $size = -s $path;
        my $memory = &quot;\x00&quot; x $size;  # allocate some memory
        my $ptr = unpack( 'L', pack( 'P', $memory ) );
        open( F, $path ) || die( &quot;$path: cannot open ($!)\n&quot; );
        my $fd = fileno(F);
        my $res = syscall( &amp;SYS_read, fileno(F), $ptr, $size );
        print $memory;
        close( F );
    }
</pre>
<p class="Pp">This is neither a specimen of simplicity nor a paragon of
    portability but it illustrates the point: We are able to sneak behind the
    scenes and access Perl's otherwise well-guarded memory! (Important note:
    Perl's <span class="Li">&quot;syscall&quot;</span> does <i>not</i> require
    you to construct pointers in this roundabout way. You simply pass a string
    variable, and Perl forwards the address.)</p>
<p class="Pp">How does <span class="Li">&quot;unpack&quot;</span> with
    <span class="Li">&quot;P&quot;</span> work? Imagine some pointer in the
    buffer about to be unpacked: If it isn't the null pointer (which will
    smartly produce the <span class="Li">&quot;undef&quot;</span> value) we have
    a start address - but then what? Perl has no way of knowing how long this
    &quot;fixed length string&quot; is, so it's up to you to specify the actual
    size as an explicit length after <span class="Li">&quot;P&quot;</span>.</p>
<p class="Pp"></p>
<pre>   my $mem = &quot;abcdefghijklmn&quot;;
   print unpack( 'P5', pack( 'P', $mem ) ); # prints &quot;abcde&quot;
</pre>
<p class="Pp">As a consequence, <span class="Li">&quot;pack&quot;</span> ignores
    any number or <span class="Li">&quot;*&quot;</span> after
    <span class="Li">&quot;P&quot;</span>.</p>
<p class="Pp">Now that we have seen <span class="Li">&quot;P&quot;</span> at
    work, we might as well give <span class="Li">&quot;p&quot;</span> a whirl.
    Why do we need a second template code for packing pointers at all? The
    answer lies behind the simple fact that an
    <span class="Li">&quot;unpack&quot;</span> with
    <span class="Li">&quot;p&quot;</span> promises a null-terminated string
    starting at the address taken from the buffer, and that implies a length for
    the data item to be returned:</p>
<p class="Pp"></p>
<pre>   my $buf = pack( 'p', &quot;abc\x00efhijklmn&quot; );
   print unpack( 'p', $buf );    # prints &quot;abc&quot;
</pre>
<p class="Pp">Albeit this is apt to be confusing: As a consequence of the length
    being implied by the string's length, a number after pack code
    <span class="Li">&quot;p&quot;</span> is a repeat count, not a length as
    after <span class="Li">&quot;P&quot;</span>.</p>
<p class="Pp">Using <span class="Li">&quot;pack(..., $x)&quot;</span> with
    <span class="Li">&quot;P&quot;</span> or
    <span class="Li">&quot;p&quot;</span> to get the address where
    <span class="Li">$x</span> is actually stored must be used with
    circumspection. Perl's internal machinery considers the relation between a
    variable and that address as its very own private matter and doesn't really
    care that we have obtained a copy. Therefore:</p>
<ul class="Bl-bullet">
  <li>Do not use <span class="Li">&quot;pack&quot;</span> with
      <span class="Li">&quot;p&quot;</span> or
      <span class="Li">&quot;P&quot;</span> to obtain the address of variable
      that's bound to go out of scope (and thereby freeing its memory) before
      you are done with using the memory at that address.</li>
  <li>Be very careful with Perl operations that change the value of the
      variable. Appending something to the variable, for instance, might require
      reallocation of its storage, leaving you with a pointer into no-man's
      land.</li>
  <li>Don't think that you can get the address of a Perl variable when it is
      stored as an integer or double number! <span class="Li">&quot;pack('P',
      $x)&quot;</span> will force the variable's internal representation to
      string, just as if you had written something like
      <span class="Li">&quot;$x .= ''&quot;</span>.</li>
</ul>
<p class="Pp">It's safe, however, to P- or p-pack a string literal, because Perl
    simply allocates an anonymous variable.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Pack_Recipes"><a class="permalink" href="#Pack_Recipes">Pack
  Recipes</a></h1>
<p class="Pp">Here are a collection of (possibly) useful canned recipes for
    <span class="Li">&quot;pack&quot;</span> and
    <span class="Li">&quot;unpack&quot;</span>:</p>
<p class="Pp"></p>
<pre>    # Convert IP address for socket functions
    pack( &quot;C4&quot;, split /\./, &quot;123.4.5.6&quot; ); 
    # Count the bits in a chunk of memory (e.g. a select vector)
    unpack( '%32b*', $mask );
    # Determine the endianness of your system
    $is_little_endian = unpack( 'c', pack( 's', 1 ) );
    $is_big_endian = unpack( 'xc', pack( 's', 1 ) );
    # Determine the number of bits in a native integer
    $bits = unpack( '%32I!', ~0 );
    # Prepare argument for the nanosleep system call
    my $timespec = pack( 'L!L!', $secs, $nanosecs );
</pre>
<p class="Pp">For a simple memory dump we unpack some bytes into just as many
    pairs of hex digits, and use <span class="Li">&quot;map&quot;</span> to
    handle the traditional spacing - 16 bytes to a line:</p>
<p class="Pp"></p>
<pre>    my $i;
    print map( ++$i % 16 ? &quot;$_ &quot; : &quot;$_\n&quot;,
               unpack( 'H2' x length( $mem ), $mem ) ),
          length( $mem ) % 16 ? &quot;\n&quot; : '';
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="Funnies_Section"><a class="permalink" href="#Funnies_Section">Funnies
  Section</a></h1>
<pre>    # Pulling digits out of nowhere...
    print unpack( 'C', pack( 'x' ) ),
          unpack( '%B*', pack( 'A' ) ),
          unpack( 'H', pack( 'A' ) ),
          unpack( 'A', unpack( 'C', pack( 'A' ) ) ), &quot;\n&quot;;
    # One for the road ;-)
    my $advice = pack( 'all u can in a van' );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="Authors"><a class="permalink" href="#Authors">Authors</a></h1>
<p class="Pp">Simon Cozens and Wolfgang Laun.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

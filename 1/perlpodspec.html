<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PERLPODSPEC(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLPODSPEC(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLPODSPEC(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlpodspec - Plain Old Documentation: format specification and
    notes</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This document is detailed notes on the Pod markup language. Most
    people will only have to read perlpod to know how to write in Pod, but this
    document may answer some incidental questions to do with parsing and
    rendering Pod.</p>
<p class="Pp">In this document, &quot;must&quot; / &quot;must not&quot;,
    &quot;should&quot; / &quot;should not&quot;, and &quot;may&quot; have their
    conventional (cf. RFC 2119) meanings: &quot;X must do Y&quot; means that if
    X doesn't do Y, it's against this specification, and should really be fixed.
    &quot;X should do Y&quot; means that it's recommended, but X may fail to do
    Y, if there's a good reason. &quot;X may do Y&quot; is merely a note that X
    can do Y at will (although it is up to the reader to detect any connotation
    of &quot;and I think it would be <i>nice</i> if X did Y&quot; versus
    &quot;it wouldn't really <i>bother</i> me if X did Y&quot;).</p>
<p class="Pp">Notably, when I say &quot;the parser should do Y&quot;, the parser
    may fail to do Y, if the calling application explicitly requests that the
    parser <i>not</i> do Y. I often phrase this as &quot;the parser should, by
    default, do Y.&quot; This doesn't <i>require</i> the parser to provide an
    option for turning off whatever feature Y is (like expanding tabs in
    verbatim paragraphs), although it implicates that such an option <i>may</i>
    be provided.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Pod_Definitions"><a class="permalink" href="#Pod_Definitions">Pod
  Definitions</a></h1>
<p class="Pp">Pod is embedded in files, typically Perl source files, although
    you can write a file that's nothing but Pod.</p>
<p class="Pp">A <b>line</b> in a file consists of zero or more non-newline
    characters, terminated by either a newline or the end of the file.</p>
<p class="Pp">A <b>newline sequence</b> is usually a platform-dependent concept,
    but Pod parsers should understand it to mean any of CR (ASCII 13), LF (ASCII
    10), or a CRLF (ASCII 13 followed immediately by ASCII 10), in addition to
    any other system-specific meaning. The first CR/CRLF/LF sequence in the file
    may be used as the basis for identifying the newline sequence for parsing
    the rest of the file.</p>
<p class="Pp">A <b>blank line</b> is a line consisting entirely of zero or more
    spaces (ASCII 32) or tabs (ASCII 9), and terminated by a newline or
    end-of-file. A <b>non-blank line</b> is a line containing one or more
    characters other than space or tab (and terminated by a newline or
    end-of-file).</p>
<p class="Pp">(<i>Note:</i> Many older Pod parsers did not accept a line
    consisting of spaces/tabs and then a newline as a blank line. The only lines
    they considered blank were lines consisting of <i>no characters at all</i>,
    terminated by a newline.)</p>
<p class="Pp"><b>Whitespace</b> is used in this document as a blanket term for
    spaces, tabs, and newline sequences. (By itself, this term usually refers to
    literal whitespace. That is, sequences of whitespace characters in Pod
    source, as opposed to &quot;E&lt;32&gt;&quot;, which is a formatting code
    that <i>denotes</i> a whitespace character.)</p>
<p class="Pp">A <b>Pod parser</b> is a module meant for parsing Pod (regardless
    of whether this involves calling callbacks or building a parse tree or
    directly formatting it). A <b>Pod formatter</b> (or <b>Pod translator</b>)
    is a module or program that converts Pod to some other format (HTML,
    plaintext, TeX, PostScript, RTF). A <b>Pod processor</b> might be a
    formatter or translator, or might be a program that does something else with
    the Pod (like counting words, scanning for index points, etc.).</p>
<p class="Pp">Pod content is contained in <b>Pod blocks</b>. A Pod block starts
    with a line that matches <span class="Li">&quot;m/\A=[a-zA-Z]/&quot;</span>,
    and continues up to the next line that matches
    <span class="Li">&quot;m/\A=cut/&quot;</span> or up to the end of the file
    if there is no <span class="Li">&quot;m/\A=cut/&quot;</span> line.</p>
<p class="Pp">Note that a parser is not expected to distinguish between
    something that looks like pod, but is in a quoted string, such as a here
    document.</p>
<p class="Pp">Within a Pod block, there are <b>Pod paragraphs</b>. A Pod
    paragraph consists of non-blank lines of text, separated by one or more
    blank lines.</p>
<p class="Pp">For purposes of Pod processing, there are four types of paragraphs
    in a Pod block:</p>
<ul class="Bl-bullet">
  <li>A command paragraph (also called a &quot;directive&quot;). The first line
      of this paragraph must match
      <span class="Li">&quot;m/\A=[a-zA-Z]/&quot;</span>. Command paragraphs are
      typically one line, as in:
    <p class="Pp"></p>
    <pre>  =head1 NOTES
  =item *
    </pre>
    <p class="Pp">But they may span several (non-blank) lines:</p>
    <p class="Pp"></p>
    <pre>  =for comment
  Hm, I wonder what it would look like if
  you tried to write a BNF for Pod from this.
  =head3 Dr. Strangelove, or: How I Learned to
  Stop Worrying and Love the Bomb
    </pre>
    <p class="Pp"><i>Some</i> command paragraphs allow formatting codes in their
        content (i.e., after the part that matches
        <span class="Li">&quot;m/\A=[a-zA-Z]\S*\s*/&quot;</span>), as in:</p>
    <p class="Pp"></p>
    <pre>  =head1 Did You Remember to C&lt;use strict;&gt;?
    </pre>
    <p class="Pp">In other words, the Pod processing handler for
        &quot;head1&quot; will apply the same processing to &quot;Did You
        Remember to C&lt;use strict;&gt;?&quot; that it would to an ordinary
        paragraph (i.e., formatting codes like &quot;C&lt;...&gt;&quot;) are
        parsed and presumably formatted appropriately, and whitespace in the
        form of literal spaces and/or tabs is not significant.</p>
  </li>
  <li>A <b>verbatim paragraph</b>. The first line of this paragraph must be a
      literal space or tab, and this paragraph must not be inside a &quot;=begin
      <i>identifier</i>&quot;, ... &quot;=end <i>identifier</i>&quot; sequence
      unless &quot;<i>identifier</i>&quot; begins with a colon (&quot;:&quot;).
      That is, if a paragraph starts with a literal space or tab, but <i>is</i>
      inside a &quot;=begin <i>identifier</i>&quot;, ... &quot;=end
      <i>identifier</i>&quot; region, then it's a data paragraph, unless
      &quot;<i>identifier</i>&quot; begins with a colon.
    <p class="Pp">Whitespace <i>is</i> significant in verbatim paragraphs
        (although, in processing, tabs are probably expanded).</p>
  </li>
  <li>An <b>ordinary paragraph</b>. A paragraph is an ordinary paragraph if its
      first line matches neither
      <span class="Li">&quot;m/\A=[a-zA-Z]/&quot;</span> nor
      <span class="Li">&quot;m/\A[ \t]/&quot;</span>, <i>and</i> if it's not
      inside a &quot;=begin <i>identifier</i>&quot;, ... &quot;=end
      <i>identifier</i>&quot; sequence unless &quot;<i>identifier</i>&quot;
      begins with a colon (&quot;:&quot;).</li>
  <li>A <b>data paragraph</b>. This is a paragraph that <i>is</i> inside a
      &quot;=begin <i>identifier</i>&quot; ... &quot;=end
      <i>identifier</i>&quot; sequence where &quot;<i>identifier</i>&quot; does
      <i>not</i> begin with a literal colon (&quot;:&quot;). In some sense, a
      data paragraph is not part of Pod at all (i.e., effectively it's
      &quot;out-of-band&quot;), since it's not subject to most kinds of Pod
      parsing; but it is specified here, since Pod parsers need to be able to
      call an event for it, or store it in some form in a parse tree, or at
      least just parse <i>around</i> it.</li>
</ul>
<p class="Pp">For example: consider the following paragraphs:</p>
<p class="Pp"></p>
<pre>  # &lt;- that's the 0th column
  =head1 Foo
  Stuff
    $foo-&gt;bar
  =cut
</pre>
<p class="Pp">Here, &quot;=head1 Foo&quot; and &quot;=cut&quot; are command
    paragraphs because the first line of each matches
    <span class="Li">&quot;m/\A=[a-zA-Z]/&quot;</span>.
    &quot;<i>[space][space]</i><span class="Li">$foo</span>-&gt;bar&quot; is a
    verbatim paragraph, because its first line starts with a literal whitespace
    character (and there's no &quot;=begin&quot;...&quot;=end&quot; region
    around).</p>
<p class="Pp">The &quot;=begin <i>identifier</i>&quot; ... &quot;=end
    <i>identifier</i>&quot; commands stop paragraphs that they surround from
    being parsed as ordinary or verbatim paragraphs, if <i>identifier</i>
    doesn't begin with a colon. This is discussed in detail in the section
    &quot;About Data Paragraphs and &quot;=begin/=end&quot; Regions&quot;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Pod_Commands"><a class="permalink" href="#Pod_Commands">Pod
  Commands</a></h1>
<p class="Pp">This section is intended to supplement and clarify the discussion
    in &quot;Command Paragraph&quot; in perlpod. These are the currently
    recognized Pod commands:</p>
<dl class="Bl-tag">
  <dt>&quot;=head1&quot;, &quot;=head2&quot;, &quot;=head3&quot;,
    &quot;=head4&quot;</dt>
  <dd>This command indicates that the text in the remainder of the paragraph is
      a heading. That text may contain formatting codes. Examples:
    <p class="Pp"></p>
    <pre>  =head1 Object Attributes
  =head3 What B&lt;Not&gt; to Do!
    </pre>
  </dd>
  <dt>&quot;=pod&quot;</dt>
  <dd>This command indicates that this paragraph begins a Pod block. (If we are
      already in the middle of a Pod block, this command has no effect at all.)
      If there is any text in this command paragraph after &quot;=pod&quot;, it
      must be ignored. Examples:
    <p class="Pp"></p>
    <pre>  =pod
  This is a plain Pod paragraph.
  =pod This text is ignored.
    </pre>
  </dd>
  <dt>&quot;=cut&quot;</dt>
  <dd>This command indicates that this line is the end of this previously
      started Pod block. If there is any text after &quot;=cut&quot; on the
      line, it must be ignored. Examples:
    <p class="Pp"></p>
    <pre>  =cut
  =cut The documentation ends here.
  =cut
  # This is the first line of program text.
  sub foo { # This is the second.
    </pre>
    <p class="Pp">It is an error to try to <i>start</i> a Pod block with a
        &quot;=cut&quot; command. In that case, the Pod processor must halt
        parsing of the input file, and must by default emit a warning.</p>
  </dd>
  <dt>&quot;=over&quot;</dt>
  <dd>This command indicates that this is the start of a list/indent region. If
      there is any text following the &quot;=over&quot;, it must consist of only
      a nonzero positive numeral. The semantics of this numeral is explained in
      the &quot;About =over...=back Regions&quot; section, further below.
      Formatting codes are not expanded. Examples:
    <p class="Pp"></p>
    <pre>  =over 3
  =over 3.5
  =over
    </pre>
  </dd>
  <dt>&quot;=item&quot;</dt>
  <dd>This command indicates that an item in a list begins here. Formatting
      codes are processed. The semantics of the (optional) text in the remainder
      of this paragraph are explained in the &quot;About =over...=back
      Regions&quot; section, further below. Examples:
    <p class="Pp"></p>
    <pre>  =item
  =item *
  =item      *    
  =item 14
  =item   3.
  =item C&lt;&lt; $thing-&gt;stuff(I&lt;dodad&gt;) &gt;&gt;
  =item For transporting us beyond seas to be tried for pretended
  offenses
  =item He is at this time transporting large armies of foreign
  mercenaries to complete the works of death, desolation and
  tyranny, already begun with circumstances of cruelty and perfidy
  scarcely paralleled in the most barbarous ages, and totally
  unworthy the head of a civilized nation.
    </pre>
  </dd>
  <dt>&quot;=back&quot;</dt>
  <dd>This command indicates that this is the end of the region begun by the
      most recent &quot;=over&quot; command. It permits no text after the
      &quot;=back&quot; command.</dd>
  <dt>&quot;=begin formatname&quot;</dt>
  <dd></dd>
  <dt>&quot;=begin formatname parameter&quot;</dt>
  <dd>This marks the following paragraphs (until the matching &quot;=end
      formatname&quot;) as being for some special kind of processing. Unless
      &quot;formatname&quot; begins with a colon, the contained non-command
      paragraphs are data paragraphs. But if &quot;formatname&quot; <i>does</i>
      begin with a colon, then non-command paragraphs are ordinary paragraphs or
      data paragraphs. This is discussed in detail in the section &quot;About
      Data Paragraphs and &quot;=begin/=end&quot; Regions&quot;.
    <p class="Pp">It is advised that formatnames match the regexp
        <span class="Li">&quot;m/\A:?[-a-zA-Z0-9_]+\z/&quot;</span>. Everything
        following whitespace after the formatname is a parameter that may be
        used by the formatter when dealing with this region. This parameter must
        not be repeated in the &quot;=end&quot; paragraph. Implementors should
        anticipate future expansion in the semantics and syntax of the first
        parameter to &quot;=begin&quot;/&quot;=end&quot;/&quot;=for&quot;.</p>
  </dd>
  <dt>&quot;=end formatname&quot;</dt>
  <dd>This marks the end of the region opened by the matching &quot;=begin
      formatname&quot; region. If &quot;formatname&quot; is not the formatname
      of the most recent open &quot;=begin formatname&quot; region, then this is
      an error, and must generate an error message. This is discussed in detail
      in the section &quot;About Data Paragraphs and &quot;=begin/=end&quot;
      Regions&quot;.</dd>
  <dt>&quot;=for formatname text...&quot;</dt>
  <dd>This is synonymous with:
    <p class="Pp"></p>
    <pre>     =begin formatname
     text...
     =end formatname
    </pre>
    <p class="Pp">That is, it creates a region consisting of a single paragraph;
        that paragraph is to be treated as a normal paragraph if
        &quot;formatname&quot; begins with a &quot;:&quot;; if
        &quot;formatname&quot; <i>doesn't</i> begin with a colon, then
        &quot;text...&quot; will constitute a data paragraph. There is no way to
        use &quot;=for formatname text...&quot; to express &quot;text...&quot;
        as a verbatim paragraph.</p>
  </dd>
  <dt>&quot;=encoding encodingname&quot;</dt>
  <dd>This command, which should occur early in the document (at least before
      any non-US-ASCII data!), declares that this document is encoded in the
      encoding <i>encodingname</i>, which must be an encoding name that Encode
      recognizes. (Encode's list of supported encodings, in Encode::Supported,
      is useful here.) If the Pod parser cannot decode the declared encoding, it
      should emit a warning and may abort parsing the document altogether.
    <p class="Pp">A document having more than one &quot;=encoding&quot; line
        should be considered an error. Pod processors may silently tolerate this
        if the not-first &quot;=encoding&quot; lines are just duplicates of the
        first one (e.g., if there's a &quot;=encoding utf8&quot; line, and later
        on another &quot;=encoding utf8&quot; line). But Pod processors should
        complain if there are contradictory &quot;=encoding&quot; lines in the
        same document (e.g., if there is a &quot;=encoding utf8&quot; early in
        the document and &quot;=encoding big5&quot; later). Pod processors that
        recognize BOMs may also complain if they see an &quot;=encoding&quot;
        line that contradicts the BOM (e.g., if a document with a UTF-16LE BOM
        has an &quot;=encoding shiftjis&quot; line).</p>
  </dd>
</dl>
<p class="Pp">If a Pod processor sees any command other than the ones listed
    above (like &quot;=head&quot;, or &quot;=haed1&quot;, or &quot;=stuff&quot;,
    or &quot;=cuttlefish&quot;, or &quot;=w123&quot;), that processor must by
    default treat this as an error. It must not process the paragraph beginning
    with that command, must by default warn of this as an error, and may abort
    the parse. A Pod parser may allow a way for particular applications to add
    to the above list of known commands, and to stipulate, for each additional
    command, whether formatting codes should be processed.</p>
<p class="Pp">Future versions of this specification may add additional
  commands.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Pod_Formatting_Codes"><a class="permalink" href="#Pod_Formatting_Codes">Pod
  Formatting Codes</a></h1>
<p class="Pp">(Note that in previous drafts of this document and of perlpod,
    formatting codes were referred to as &quot;interior sequences&quot;, and
    this term may still be found in the documentation for Pod parsers, and in
    error messages from Pod processors.)</p>
<p class="Pp">There are two syntaxes for formatting codes:</p>
<ul class="Bl-bullet">
  <li>A formatting code starts with a capital letter (just US-ASCII [A-Z])
      followed by a &quot;&lt;&quot;, any number of characters, and ending with
      the first matching &quot;&gt;&quot;. Examples:
    <p class="Pp"></p>
    <pre>    That's what I&lt;you&gt; think!
    What's C&lt;CORE::dump()&gt; for?
    X&lt;C&lt;chmod&gt; and C&lt;unlink()&gt; Under Different Operating Systems&gt;
    </pre>
  </li>
  <li>A formatting code starts with a capital letter (just US-ASCII [A-Z])
      followed by two or more &quot;&lt;&quot;'s, one or more whitespace
      characters, any number of characters, one or more whitespace characters,
      and ending with the first matching sequence of two or more
      &quot;&gt;&quot;'s, where the number of &quot;&gt;&quot;'s equals the
      number of &quot;&lt;&quot;'s in the opening of this formatting code.
      Examples:
    <p class="Pp"></p>
    <pre>    That's what I&lt;&lt; you &gt;&gt; think!
    C&lt;&lt;&lt; open(X, &quot;&gt;&gt;thing.dat&quot;) || die $! &gt;&gt;&gt;
    B&lt;&lt; $foo-&gt;bar(); &gt;&gt;
    </pre>
    <p class="Pp">With this syntax, the whitespace character(s) after the
        &quot;C&lt;&lt;&lt;&quot; and before the &quot;&gt;&gt;&gt;&quot; (or
        whatever letter) are <i>not</i> renderable. They do not signify
        whitespace, are merely part of the formatting codes themselves. That is,
        these are all synonymous:</p>
    <p class="Pp"></p>
    <pre>    C&lt;thing&gt;
    C&lt;&lt; thing &gt;&gt;
    C&lt;&lt;           thing     &gt;&gt;
    C&lt;&lt;&lt;   thing &gt;&gt;&gt;
    C&lt;&lt;&lt;&lt;
    thing
               &gt;&gt;&gt;&gt;
    </pre>
    <p class="Pp">and so on.</p>
    <p class="Pp">Finally, the multiple-angle-bracket form does <i>not</i> alter
        the interpretation of nested formatting codes, meaning that the
        following four example lines are identical in meaning:</p>
    <p class="Pp"></p>
    <pre>  B&lt;example: C&lt;$a E&lt;lt&gt;=E&lt;gt&gt; $b&gt;&gt;
  B&lt;example: C&lt;&lt; $a &lt;=&gt; $b &gt;&gt;&gt;
  B&lt;example: C&lt;&lt; $a E&lt;lt&gt;=E&lt;gt&gt; $b &gt;&gt;&gt;
  B&lt;&lt;&lt; example: C&lt;&lt; $a E&lt;lt&gt;=E&lt;gt&gt; $b &gt;&gt; &gt;&gt;&gt;
    </pre>
  </li>
</ul>
<p class="Pp">In parsing Pod, a notably tricky part is the correct parsing of
    (potentially nested!) formatting codes. Implementors should consult the code
    in the <span class="Li">&quot;parse_text&quot;</span> routine in Pod::Parser
    as an example of a correct implementation.</p>
<dl class="Bl-tag">
  <dt>&quot;I&lt;text&gt;&quot; -- italic text</dt>
  <dd>See the brief discussion in &quot;Formatting Codes&quot; in perlpod.</dd>
  <dt>&quot;B&lt;text&gt;&quot; -- bold text</dt>
  <dd>See the brief discussion in &quot;Formatting Codes&quot; in perlpod.</dd>
  <dt>&quot;C&lt;code&gt;&quot; -- code text</dt>
  <dd>See the brief discussion in &quot;Formatting Codes&quot; in perlpod.</dd>
  <dt>&quot;F&lt;filename&gt;&quot; -- style for filenames</dt>
  <dd>See the brief discussion in &quot;Formatting Codes&quot; in perlpod.</dd>
  <dt>&quot;X&lt;topic name&gt;&quot; -- an index entry</dt>
  <dd>See the brief discussion in &quot;Formatting Codes&quot; in perlpod.
    <p class="Pp">This code is unusual in that most formatters completely
        discard this code and its content. Other formatters will render it with
        invisible codes that can be used in building an index of the current
        document.</p>
  </dd>
  <dt>&quot;Z&lt;&gt;&quot; -- a null (zero-effect) formatting code</dt>
  <dd>Discussed briefly in &quot;Formatting Codes&quot; in perlpod.
    <p class="Pp">This code is unusual in that it should have no content. That
        is, a processor may complain if it sees
        <span class="Li">&quot;Z&lt;potatoes&gt;&quot;</span>. Whether or not it
        complains, the <i>potatoes</i> text should ignored.</p>
  </dd>
  <dt>&quot;L&lt;name&gt;&quot; -- a hyperlink</dt>
  <dd>The complicated syntaxes of this code are discussed at length in
      &quot;Formatting Codes&quot; in perlpod, and implementation details are
      discussed below, in &quot;About L&lt;...&gt; Codes&quot;. Parsing the
      contents of L&lt;content&gt; is tricky. Notably, the content has to be
      checked for whether it looks like a URL, or whether it has to be split on
      literal &quot;|&quot; and/or &quot;/&quot; (in the right order!), and so
      on, <i>before</i> E&lt;...&gt; codes are resolved.</dd>
  <dt>&quot;E&lt;escape&gt;&quot; -- a character escape</dt>
  <dd>See &quot;Formatting Codes&quot; in perlpod, and several points in
      &quot;Notes on Implementing Pod Processors&quot;.</dd>
  <dt>&quot;S&lt;text&gt;&quot; -- text contains non-breaking spaces</dt>
  <dd>This formatting code is syntactically simple, but semantically complex.
      What it means is that each space in the printable content of this code
      signifies a non-breaking space.
    <p class="Pp">Consider:</p>
    <p class="Pp"></p>
    <pre>    C&lt;$x ? $y    :  $z&gt;
    S&lt;C&lt;$x ? $y     :  $z&gt;&gt;
    </pre>
    <p class="Pp">Both signify the monospace (c[ode] style) text consisting of
        &quot;$x&quot;, one space, &quot;?&quot;, one space, &quot;:&quot;, one
        space, &quot;$z&quot;. The difference is that in the latter, with the S
        code, those spaces are not &quot;normal&quot; spaces, but instead are
        non-breaking spaces.</p>
  </dd>
</dl>
<p class="Pp">If a Pod processor sees any formatting code other than the ones
    listed above (as in &quot;N&lt;...&gt;&quot;, or &quot;Q&lt;...&gt;&quot;,
    etc.), that processor must by default treat this as an error. A Pod parser
    may allow a way for particular applications to add to the above list of
    known formatting codes; a Pod parser might even allow a way to stipulate,
    for each additional command, whether it requires some form of special
    processing, as L&lt;...&gt; does.</p>
<p class="Pp">Future versions of this specification may add additional
    formatting codes.</p>
<p class="Pp">Historical note: A few older Pod processors would not see a
    &quot;&gt;&quot; as closing a &quot;C&lt;&quot; code, if the
    &quot;&gt;&quot; was immediately preceded by a &quot;-&quot;. This was so
    that this:</p>
<p class="Pp"></p>
<pre>    C&lt;$foo-&gt;bar&gt;
</pre>
<p class="Pp">would parse as equivalent to this:</p>
<p class="Pp"></p>
<pre>    C&lt;$foo-E&lt;gt&gt;bar&gt;
</pre>
<p class="Pp">instead of as equivalent to a &quot;C&quot; formatting code
    containing only &quot;$foo-&quot;, and then a &quot;bar&gt;&quot; outside
    the &quot;C&quot; formatting code. This problem has since been solved by the
    addition of syntaxes like this:</p>
<p class="Pp"></p>
<pre>    C&lt;&lt; $foo-&gt;bar &gt;&gt;
</pre>
<p class="Pp">Compliant parsers must not treat &quot;-&gt;&quot; as special.</p>
<p class="Pp">Formatting codes absolutely cannot span paragraphs. If a code is
    opened in one paragraph, and no closing code is found by the end of that
    paragraph, the Pod parser must close that formatting code, and should
    complain (as in &quot;Unterminated I code in the paragraph starting at line
    123: 'Time objects are not...'&quot;). So these two paragraphs:</p>
<p class="Pp"></p>
<pre>  I&lt;I told you not to do this!
  Don't make me say it again!&gt;
</pre>
<p class="Pp">...must <i>not</i> be parsed as two paragraphs in italics (with
    the I code starting in one paragraph and starting in another.) Instead, the
    first paragraph should generate a warning, but that aside, the above code
    must parse as if it were:</p>
<p class="Pp"></p>
<pre>  I&lt;I told you not to do this!&gt;
  Don't make me say it again!E&lt;gt&gt;
</pre>
<p class="Pp">(In SGMLish jargon, all Pod commands are like block-level
    elements, whereas all Pod formatting codes are like inline-level
  elements.)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Notes_on_Implementing_Pod_Processors"><a class="permalink" href="#Notes_on_Implementing_Pod_Processors">Notes
  on Implementing Pod Processors</a></h1>
<p class="Pp">The following is a long section of miscellaneous requirements and
    suggestions to do with Pod processing.</p>
<ul class="Bl-bullet">
  <li>Pod formatters should tolerate lines in verbatim blocks that are of any
      length, even if that means having to break them (possibly several times,
      for very long lines) to avoid text running off the side of the page. Pod
      formatters may warn of such line-breaking. Such warnings are particularly
      appropriate for lines are over 100 characters long, which are usually not
      intentional.</li>
  <li>Pod parsers must recognize <i>all</i> of the three well-known newline
      formats: CR, LF, and CRLF. See perlport.</li>
  <li>Pod parsers should accept input lines that are of any length.</li>
  <li>Since Perl recognizes a Unicode Byte Order Mark at the start of files as
      signaling that the file is Unicode encoded as in UTF-16 (whether
      big-endian or little-endian) or UTF-8, Pod parsers should do the same.
      Otherwise, the character encoding should be understood as being UTF-8 if
      the first highbit byte sequence in the file seems valid as a UTF-8
      sequence, or otherwise as CP-1252 (earlier versions of this specification
      used Latin-1 instead of CP-1252).
    <p class="Pp">Future versions of this specification may specify how Pod can
        accept other encodings. Presumably treatment of other encodings in Pod
        parsing would be as in XML parsing: whatever the encoding declared by a
        particular Pod file, content is to be stored in memory as Unicode
        characters.</p>
  </li>
  <li>The well known Unicode Byte Order Marks are as follows: if the file begins
      with the two literal byte values 0xFE 0xFF, this is the BOM for big-endian
      UTF-16. If the file begins with the two literal byte value 0xFF 0xFE, this
      is the BOM for little-endian UTF-16. On an ASCII platform, if the file
      begins with the three literal byte values 0xEF 0xBB 0xBF, this is the BOM
      for UTF-8. A mechanism portable to EBCDIC platforms is to:
    <p class="Pp"></p>
    <pre>  my $utf8_bom = &quot;\x{FEFF}&quot;;
  utf8::encode($utf8_bom);
    </pre>
  </li>
  <li>A naive, but often sufficient heuristic on ASCII platforms, for testing
      the first highbit byte-sequence in a BOM-less file (whether in code or in
      Pod!), to see whether that sequence is valid as UTF-8 (RFC 2279) is to
      check whether that the first byte in the sequence is in the range 0xC2 -
      0xFD <i>and</i> whether the next byte is in the range 0x80 - 0xBF. If so,
      the parser may conclude that this file is in UTF-8, and all highbit
      sequences in the file should be assumed to be UTF-8. Otherwise the parser
      should treat the file as being in CP-1252. (A better check, and which
      works on EBCDIC platforms as well, is to pass a copy of the sequence to
      <b>utf8::decode()</b> which performs a full validity check on the sequence
      and returns TRUE if it is valid UTF-8, FALSE otherwise. This function is
      always pre-loaded, is fast because it is written in C, and will only get
      called at most once, so you don't need to avoid it out of performance
      concerns.) In the unlikely circumstance that the first highbit sequence in
      a truly non-UTF-8 file happens to appear to be UTF-8, one can cater to our
      heuristic (as well as any more intelligent heuristic) by prefacing that
      line with a comment line containing a highbit sequence that is clearly
      <i>not</i> valid as UTF-8. A line consisting of simply &quot;#&quot;, an
      e-acute, and any non-highbit byte, is sufficient to establish this file's
      encoding.</li>
  <li>Pod processors must treat a &quot;=for [label] [content...]&quot;
      paragraph as meaning the same thing as a &quot;=begin [label]&quot;
      paragraph, content, and an &quot;=end [label]&quot; paragraph. (The parser
      may conflate these two constructs, or may leave them distinct, in the
      expectation that the formatter will nevertheless treat them the
    same.)</li>
  <li>When rendering Pod to a format that allows comments (i.e., to nearly any
      format other than plaintext), a Pod formatter must insert comment text
      identifying its name and version number, and the name and version numbers
      of any modules it might be using to process the Pod. Minimal examples:
    <p class="Pp"></p>
    <pre> %% POD::Pod2PS v3.14159, using POD::Parser v1.92
 &lt;!-- Pod::HTML v3.14159, using POD::Parser v1.92 --&gt;
 {\doccomm generated by Pod::Tree::RTF 3.14159 using Pod::Tree 1.08}
 .\&quot; Pod::Man version 3.14159, using POD::Parser version 1.92
    </pre>
    <p class="Pp">Formatters may also insert additional comments, including: the
        release date of the Pod formatter program, the contact address for the
        author(s) of the formatter, the current time, the name of input file,
        the formatting options in effect, version of Perl used, etc.</p>
    <p class="Pp">Formatters may also choose to note errors/warnings as
        comments, besides or instead of emitting them otherwise (as in messages
        to STDERR, or <span class="Li">&quot;die&quot;</span>ing).</p>
  </li>
  <li>Pod parsers <i>may</i> emit warnings or error messages (&quot;Unknown E
      code E&lt;zslig&gt;!&quot;) to STDERR (whether through printing to STDERR,
      or
      <span class="Li">&quot;warn&quot;</span>ing/<span class="Li">&quot;carp&quot;</span>ing,
      or
      <span class="Li">&quot;die&quot;</span>ing/<span class="Li">&quot;croak&quot;</span>ing),
      but <i>must</i> allow suppressing all such STDERR output, and instead
      allow an option for reporting errors/warnings in some other way, whether
      by triggering a callback, or noting errors in some attribute of the
      document object, or some similarly unobtrusive mechanism -- or even by
      appending a &quot;Pod Errors&quot; section to the end of the parsed form
      of the document.</li>
  <li>In cases of exceptionally aberrant documents, Pod parsers may abort the
      parse. Even then, using
      <span class="Li">&quot;die&quot;</span>ing/<span class="Li">&quot;croak&quot;</span>ing
      is to be avoided; where possible, the parser library may simply close the
      input file and add text like &quot;*** Formatting Aborted ***&quot; to the
      end of the (partial) in-memory document.</li>
  <li>In paragraphs where formatting codes (like E&lt;...&gt;, B&lt;...&gt;) are
      understood (i.e., <i>not</i> verbatim paragraphs, but <i>including</i>
      ordinary paragraphs, and command paragraphs that produce renderable text,
      like &quot;=head1&quot;), literal whitespace should generally be
      considered &quot;insignificant&quot;, in that one literal space has the
      same meaning as any (nonzero) number of literal spaces, literal newlines,
      and literal tabs (as long as this produces no blank lines, since those
      would terminate the paragraph). Pod parsers should compact literal
      whitespace in each processed paragraph, but may provide an option for
      overriding this (since some processing tasks do not require it), or may
      follow additional special rules (for example, specially treating
      period-space-space or period-newline sequences).</li>
  <li>Pod parsers should not, by default, try to coerce apostrophe (') and quote
      (&quot;) into smart quotes (little 9's, 66's, 99's, etc), nor try to turn
      backtick (`) into anything else but a single backtick character (distinct
      from an open quote character!), nor &quot;--&quot; into anything but two
      minus signs. They <i>must never</i> do any of those things to text in
      C&lt;...&gt; formatting codes, and never <i>ever</i> to text in verbatim
      paragraphs.</li>
  <li>When rendering Pod to a format that has two kinds of hyphens (-), one
      that's a non-breaking hyphen, and another that's a breakable hyphen (as in
      &quot;object-oriented&quot;, which can be split across lines as
      &quot;object-&quot;, newline, &quot;oriented&quot;), formatters are
      encouraged to generally translate &quot;-&quot; to non-breaking hyphen,
      but may apply heuristics to convert some of these to breaking
    hyphens.</li>
  <li>Pod formatters should make reasonable efforts to keep words of Perl code
      from being broken across lines. For example, &quot;Foo::Bar&quot; in some
      formatting systems is seen as eligible for being broken across lines as
      &quot;Foo::&quot; newline &quot;Bar&quot; or even &quot;Foo::-&quot;
      newline &quot;Bar&quot;. This should be avoided where possible, either by
      disabling all line-breaking in mid-word, or by wrapping particular words
      with internal punctuation in &quot;don't break this across lines&quot;
      codes (which in some formats may not be a single code, but might be a
      matter of inserting non-breaking zero-width spaces between every pair of
      characters in a word.)</li>
  <li>Pod parsers should, by default, expand tabs in verbatim paragraphs as they
      are processed, before passing them to the formatter or other processor.
      Parsers may also allow an option for overriding this.</li>
  <li>Pod parsers should, by default, remove newlines from the end of ordinary
      and verbatim paragraphs before passing them to the formatter. For example,
      while the paragraph you're reading now could be considered, in Pod source,
      to end with (and contain) the newline(s) that end it, it should be
      processed as ending with (and containing) the period character that ends
      this sentence.</li>
  <li>Pod parsers, when reporting errors, should make some effort to report an
      approximate line number (&quot;Nested E&lt;&gt;'s in Paragraph #52, near
      line 633 of Thing/Foo.pm!&quot;), instead of merely noting the paragraph
      number (&quot;Nested E&lt;&gt;'s in Paragraph #52 of Thing/Foo.pm!&quot;).
      Where this is problematic, the paragraph number should at least be
      accompanied by an excerpt from the paragraph (&quot;Nested E&lt;&gt;'s in
      Paragraph #52 of Thing/Foo.pm, which begins 'Read/write accessor for the
      C&lt;interest rate&gt; attribute...'&quot;).</li>
  <li>Pod parsers, when processing a series of verbatim paragraphs one after
      another, should consider them to be one large verbatim paragraph that
      happens to contain blank lines. I.e., these two lines, which have a blank
      line between them:
    <p class="Pp"></p>
    <pre>        use Foo;
        print Foo-&gt;VERSION
    </pre>
    <p class="Pp">should be unified into one paragraph (&quot;\tuse
        Foo;\n\n\tprint Foo-&gt;VERSION&quot;) before being passed to the
        formatter or other processor. Parsers may also allow an option for
        overriding this.</p>
    <p class="Pp">While this might be too cumbersome to implement in event-based
        Pod parsers, it is straightforward for parsers that return parse
      trees.</p>
  </li>
  <li>Pod formatters, where feasible, are advised to avoid splitting short
      verbatim paragraphs (under twelve lines, say) across pages.</li>
  <li>Pod parsers must treat a line with only spaces and/or tabs on it as a
      &quot;blank line&quot; such as separates paragraphs. (Some older parsers
      recognized only two adjacent newlines as a &quot;blank line&quot; but
      would not recognize a newline, a space, and a newline, as a blank line.
      This is noncompliant behavior.)</li>
  <li>Authors of Pod formatters/processors should make every effort to avoid
      writing their own Pod parser. There are already several in CPAN, with a
      wide range of interface styles -- and one of them, Pod::Simple, comes with
      modern versions of Perl.</li>
  <li>Characters in Pod documents may be conveyed either as literals, or by
      number in E&lt;n&gt; codes, or by an equivalent mnemonic, as in
      E&lt;eacute&gt; which is exactly equivalent to E&lt;233&gt;. The numbers
      are the Latin1/Unicode values, even on EBCDIC platforms.
    <p class="Pp">When referring to characters by using a E&lt;n&gt; numeric
        code, numbers in the range 32-126 refer to those well known US-ASCII
        characters (also defined there by Unicode, with the same meaning), which
        all Pod formatters must render faithfully. Characters whose E&lt;&gt;
        numbers are in the ranges 0-31 and 127-159 should not be used (neither
        as literals, nor as E&lt;number&gt; codes), except for the literal
        byte-sequences for newline (ASCII 13, ASCII 13 10, or ASCII 10), and tab
        (ASCII 9).</p>
    <p class="Pp">Numbers in the range 160-255 refer to Latin-1 characters (also
        defined there by Unicode, with the same meaning). Numbers above 255
        should be understood to refer to Unicode characters.</p>
  </li>
  <li>Be warned that some formatters cannot reliably render characters outside
      32-126; and many are able to handle 32-126 and 160-255, but nothing above
      255.</li>
  <li>Besides the well-known &quot;E&lt;lt&gt;&quot; and &quot;E&lt;gt&gt;&quot;
      codes for less-than and greater-than, Pod parsers must understand
      &quot;E&lt;sol&gt;&quot; for &quot;/&quot; (solidus, slash), and
      &quot;E&lt;verbar&gt;&quot; for &quot;|&quot; (vertical bar, pipe). Pod
      parsers should also understand &quot;E&lt;lchevron&gt;&quot; and
      &quot;E&lt;rchevron&gt;&quot; as legacy codes for characters 171 and 187,
      i.e., &quot;left-pointing double angle quotation mark&quot; = &quot;left
      pointing guillemet&quot; and &quot;right-pointing double angle quotation
      mark&quot; = &quot;right pointing guillemet&quot;. (These look like little
      &quot;&lt;&lt;&quot; and &quot;&gt;&gt;&quot;, and they are now preferably
      expressed with the HTML/XHTML codes &quot;E&lt;laquo&gt;&quot; and
      &quot;E&lt;raquo&gt;&quot;.)</li>
  <li>Pod parsers should understand all &quot;E&lt;html&gt;&quot; codes as
      defined in the entity declarations in the most recent XHTML specification
      at <span class="Li">&quot;www.W3.org&quot;</span>. Pod parsers must
      understand at least the entities that define characters in the range
      160-255 (Latin-1). Pod parsers, when faced with some unknown
      &quot;E&lt;<i>identifier</i>&gt;&quot; code, shouldn't simply replace it
      with nullstring (by default, at least), but may pass it through as a
      string consisting of the literal characters E, less-than,
      <i>identifier</i>, greater-than. Or Pod parsers may offer the alternative
      option of processing such unknown &quot;E&lt;<i>identifier</i>&gt;&quot;
      codes by firing an event especially for such codes, or by adding a special
      node-type to the in-memory document tree. Such
      &quot;E&lt;<i>identifier</i>&gt;&quot; may have special meaning to some
      processors, or some processors may choose to add them to a special error
      report.</li>
  <li>Pod parsers must also support the XHTML codes &quot;E&lt;quot&gt;&quot;
      for character 34 (doublequote, &quot;), &quot;E&lt;amp&gt;&quot; for
      character 38 (ampersand, &amp;), and &quot;E&lt;apos&gt;&quot; for
      character 39 (apostrophe, ').</li>
  <li>Note that in all cases of &quot;E&lt;whatever&gt;&quot;, <i>whatever</i>
      (whether an htmlname, or a number in any base) must consist only of
      alphanumeric characters -- that is, <i>whatever</i> must match
      <span class="Li">&quot;m/\A\w+\z/&quot;</span>. So
      &quot;E&lt;&#x00A0;0&#x00A0;1&#x00A0;2&#x00A0;3&#x00A0;&gt;&quot; is
      invalid, because it contains spaces, which aren't alphanumeric characters.
      This presumably does not <i>need</i> special treatment by a Pod processor;
      &quot;&#x00A0;0&#x00A0;1&#x00A0;2&#x00A0;3&#x00A0;&quot; doesn't look like
      a number in any base, so it would presumably be looked up in the table of
      HTML-like names. Since there isn't (and cannot be) an HTML-like entity
      called &quot;&#x00A0;0&#x00A0;1&#x00A0;2&#x00A0;3&#x00A0;&quot;, this will
      be treated as an error. However, Pod processors may treat
      &quot;E&lt;&#x00A0;0&#x00A0;1&#x00A0;2&#x00A0;3&#x00A0;&gt;&quot; or
      &quot;E&lt;e-acute&gt;&quot; as <i>syntactically</i> invalid, potentially
      earning a different error message than the error message (or warning, or
      event) generated by a merely unknown (but theoretically valid) htmlname,
      as in &quot;E&lt;qacute&gt;&quot; [sic]. However, Pod parsers are not
      required to make this distinction.</li>
  <li>Note that E&lt;number&gt; <i>must not</i> be interpreted as simply
      &quot;codepoint <i>number</i> in the current/native character set&quot;.
      It always means only &quot;the character represented by codepoint
      <i>number</i> in Unicode.&quot; (This is identical to the semantics of
      &amp;#<i>number</i>; in XML.)
    <p class="Pp">This will likely require many formatters to have tables
        mapping from treatable Unicode codepoints (such as the &quot;\xE9&quot;
        for the e-acute character) to the escape sequences or codes necessary
        for conveying such sequences in the target output format. A converter to
        *roff would, for example know that &quot;\xE9&quot; (whether conveyed
        literally, or via a E&lt;...&gt; sequence) is to be conveyed as
        &quot;e\\*'&quot;. Similarly, a program rendering Pod in a Mac OS
        application window, would presumably need to know that &quot;\xE9&quot;
        maps to codepoint 142 in MacRoman encoding that (at time of writing) is
        native for Mac OS. Such Unicode2whatever mappings are presumably already
        widely available for common output formats. (Such mappings may be
        incomplete! Implementers are not expected to bend over backwards in an
        attempt to render Cherokee syllabics, Etruscan runes, Byzantine musical
        symbols, or any of the other weird things that Unicode can encode.) And
        if a Pod document uses a character not found in such a mapping, the
        formatter should consider it an unrenderable character.</p>
  </li>
  <li>If, surprisingly, the implementor of a Pod formatter can't find a
      satisfactory pre-existing table mapping from Unicode characters to escapes
      in the target format (e.g., a decent table of Unicode characters to *roff
      escapes), it will be necessary to build such a table. If you are in this
      circumstance, you should begin with the characters in the range 0x00A0 -
      0x00FF, which is mostly the heavily used accented characters. Then proceed
      (as patience permits and fastidiousness compels) through the characters
      that the (X)HTML standards groups judged important enough to merit
      mnemonics for. These are declared in the (X)HTML specifications at the
      www.W3.org site. At time of writing (September 2001), the most recent
      entity declaration files are:
    <p class="Pp"></p>
    <pre>  http://www.w3.org/TR/xhtml1/DTD/xhtml-lat1.ent
  http://www.w3.org/TR/xhtml1/DTD/xhtml-special.ent
  http://www.w3.org/TR/xhtml1/DTD/xhtml-symbol.ent
    </pre>
    <p class="Pp">Then you can progress through any remaining notable Unicode
        characters in the range 0x2000-0x204D (consult the character tables at
        www.unicode.org), and whatever else strikes your fancy. For example, in
        <i>xhtml-symbol.ent</i>, there is the entry:</p>
    <p class="Pp"></p>
    <pre>  &lt;!ENTITY infin    &quot;&amp;#8734;&quot;&gt; &lt;!-- infinity, U+221E ISOtech --&gt;
    </pre>
    <p class="Pp">While the mapping &quot;infin&quot; to the character
        &quot;\x{221E}&quot; will (hopefully) have been already handled by the
        Pod parser, the presence of the character in this file means that it's
        reasonably important enough to include in a formatter's table that maps
        from notable Unicode characters to the codes necessary for rendering
        them. So for a Unicode-to-*roff mapping, for example, this would merit
        the entry:</p>
    <p class="Pp"></p>
    <pre>  &quot;\x{221E}&quot; =&gt; '\(in',
    </pre>
    <p class="Pp">It is eagerly hoped that in the future, increasing numbers of
        formats (and formatters) will support Unicode characters directly (as
        (X)HTML does with <span class="Li">&quot;&amp;infin;&quot;</span>,
        <span class="Li">&quot;&amp;#8734;&quot;</span>, or
        <span class="Li">&quot;&amp;#x221E;&quot;</span>), reducing the need for
        idiosyncratic mappings of Unicode-to-<i>my_escapes</i>.</p>
  </li>
  <li>It is up to individual Pod formatter to display good judgement when
      confronted with an unrenderable character (which is distinct from an
      unknown E&lt;thing&gt; sequence that the parser couldn't resolve to
      anything, renderable or not). It is good practice to map Latin letters
      with diacritics (like
      &quot;E&lt;eacute&gt;&quot;/&quot;E&lt;233&gt;&quot;) to the corresponding
      unaccented US-ASCII letters (like a simple character 101, &quot;e&quot;),
      but clearly this is often not feasible, and an unrenderable character may
      be represented as &quot;?&quot;, or the like. In attempting a sane
      fallback (as from E&lt;233&gt; to &quot;e&quot;), Pod formatters may use
      the <span class="Li">%Latin1Code_to_fallback</span> table in Pod::Escapes,
      or Text::Unidecode, if available.
    <p class="Pp">For example, this Pod text:</p>
    <p class="Pp"></p>
    <pre>  magic is enabled if you set C&lt;$Currency&gt; to 'E&lt;euro&gt;'.
    </pre>
    <p class="Pp">may be rendered as: &quot;magic is enabled if you set
        <span class="Li">$Currency</span> to '<i>?</i>'&quot; or as &quot;magic
        is enabled if you set <span class="Li">$Currency</span> to
        '<b>[euro]</b>'&quot;, or as &quot;magic is enabled if you set
        <span class="Li">$Currency</span> to '[x20AC]', etc.</p>
    <p class="Pp">A Pod formatter may also note, in a comment or warning, a list
        of what unrenderable characters were encountered.</p>
  </li>
  <li>E&lt;...&gt; may freely appear in any formatting code (other than in
      another E&lt;...&gt; or in an Z&lt;&gt;). That is, &quot;X&lt;The
      E&lt;euro&gt;1,000,000 Solution&gt;&quot; is valid, as is &quot;L&lt;The
      E&lt;euro&gt;1,000,000 Solution|Million::Euros&gt;&quot;.</li>
  <li>Some Pod formatters output to formats that implement non-breaking spaces
      as an individual character (which I'll call &quot;NBSP&quot;), and others
      output to formats that implement non-breaking spaces just as spaces
      wrapped in a &quot;don't break this across lines&quot; code. Note that at
      the level of Pod, both sorts of codes can occur: Pod can contain a NBSP
      character (whether as a literal, or as a &quot;E&lt;160&gt;&quot; or
      &quot;E&lt;nbsp&gt;&quot; code); and Pod can contain &quot;S&lt;foo
      I&lt;bar&gt; baz&gt;&quot; codes, where &quot;mere spaces&quot; (character
      32) in such codes are taken to represent non-breaking spaces. Pod parsers
      should consider supporting the optional parsing of &quot;S&lt;foo
      I&lt;bar&gt; baz&gt;&quot; as if it were
      &quot;foo<i>NBSP</i>I&lt;bar&gt;<i>NBSP</i>baz&quot;, and, going the other
      way, the optional parsing of groups of words joined by NBSP's as if each
      group were in a S&lt;...&gt; code, so that formatters may use the
      representation that maps best to what the output format demands.</li>
  <li>Some processors may find that the
      <span class="Li">&quot;S&lt;...&gt;&quot;</span> code is easiest to
      implement by replacing each space in the parse tree under the content of
      the S, with an NBSP. But note: the replacement should apply <i>not</i> to
      spaces in <i>all</i> text, but <i>only</i> to spaces in <i>printable</i>
      text. (This distinction may or may not be evident in the particular
      tree/event model implemented by the Pod parser.) For example, consider
      this unusual case:
    <p class="Pp"></p>
    <pre>   S&lt;L&lt;/Autoloaded Functions&gt;&gt;
    </pre>
    <p class="Pp">This means that the space in the middle of the visible link
        text must not be broken across lines. In other words, it's the same as
        this:</p>
    <p class="Pp"></p>
    <pre>   L&lt;&quot;AutoloadedE&lt;160&gt;Functions&quot;/Autoloaded Functions&gt;
    </pre>
    <p class="Pp">However, a misapplied space-to-NBSP replacement could
        (wrongly) produce something equivalent to this:</p>
    <p class="Pp"></p>
    <pre>   L&lt;&quot;AutoloadedE&lt;160&gt;Functions&quot;/AutoloadedE&lt;160&gt;Functions&gt;
    </pre>
    <p class="Pp">...which is almost definitely not going to work as a hyperlink
        (assuming this formatter outputs a format supporting hypertext).</p>
    <p class="Pp">Formatters may choose to just not support the S format code,
        especially in cases where the output format simply has no NBSP
        character/code and no code for &quot;don't break this stuff across
        lines&quot;.</p>
  </li>
  <li>Besides the NBSP character discussed above, implementors are reminded of
      the existence of the other &quot;special&quot; character in Latin-1, the
      &quot;soft hyphen&quot; character, also known as &quot;discretionary
      hyphen&quot;, i.e. <span class="Li">&quot;E&lt;173&gt;&quot;</span> =
      <span class="Li">&quot;E&lt;0xAD&gt;&quot;</span> =
      <span class="Li">&quot;E&lt;shy&gt;&quot;</span>). This character
      expresses an optional hyphenation point. That is, it normally renders as
      nothing, but may render as a &quot;-&quot; if a formatter breaks the word
      at that point. Pod formatters should, as appropriate, do one of the
      following: 1) render this with a code with the same meaning (e.g.,
      &quot;\-&quot; in RTF), 2) pass it through in the expectation that the
      formatter understands this character as such, or 3) delete it.
    <p class="Pp">For example:</p>
    <p class="Pp"></p>
    <pre>  sigE&lt;shy&gt;action
  manuE&lt;shy&gt;script
  JarkE&lt;shy&gt;ko HieE&lt;shy&gt;taE&lt;shy&gt;nieE&lt;shy&gt;mi
    </pre>
    <p class="Pp">These signal to a formatter that if it is to hyphenate
        &quot;sigaction&quot; or &quot;manuscript&quot;, then it should be done
        as &quot;sig-<i>[linebreak]</i>action&quot; or
        &quot;manu-<i>[linebreak]</i>script&quot; (and if it doesn't hyphenate
        it, then the <span class="Li">&quot;E&lt;shy&gt;&quot;</span> doesn't
        show up at all). And if it is to hyphenate &quot;Jarkko&quot; and/or
        &quot;Hietaniemi&quot;, it can do so only at the points where there is a
        <span class="Li">&quot;E&lt;shy&gt;&quot;</span> code.</p>
    <p class="Pp">In practice, it is anticipated that this character will not be
        used often, but formatters should either support it, or delete it.</p>
  </li>
  <li>If you think that you want to add a new command to Pod (like, say, a
      &quot;=biblio&quot; command), consider whether you could get the same
      effect with a for or begin/end sequence: &quot;=for biblio ...&quot; or
      &quot;=begin biblio&quot; ... &quot;=end biblio&quot;. Pod processors that
      don't understand &quot;=for biblio&quot;, etc, will simply ignore it,
      whereas they may complain loudly if they see &quot;=biblio&quot;.</li>
  <li>Throughout this document, &quot;Pod&quot; has been the preferred spelling
      for the name of the documentation format. One may also use &quot;POD&quot;
      or &quot;pod&quot;. For the documentation that is (typically) in the Pod
      format, you may use &quot;pod&quot;, or &quot;Pod&quot;, or
      &quot;POD&quot;. Understanding these distinctions is useful; but obsessing
      over how to spell them, usually is not.</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="About_L_...__Codes"><a class="permalink" href="#About_L_...__Codes">About
  L&lt;...&gt; Codes</a></h1>
<p class="Pp">As you can tell from a glance at perlpod, the L&lt;...&gt; code is
    the most complex of the Pod formatting codes. The points below will
    hopefully clarify what it means and how processors should deal with it.</p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>In parsing an L&lt;...&gt; code, Pod parsers must distinguish at least
      four attributes:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="First:"><a class="permalink" href="#First:">First:</a></dt>
  <dd>The link-text. If there is none, this must be
      <span class="Li">&quot;undef&quot;</span>. (E.g., in &quot;L&lt;Perl
      Functions|perlfunc&gt;&quot;, the link-text is &quot;Perl Functions&quot;.
      In &quot;L&lt;Time::HiRes&gt;&quot; and even
      &quot;L&lt;|Time::HiRes&gt;&quot;, there is no link text. Note that link
      text may contain formatting.)</dd>
  <dt id="Second:"><a class="permalink" href="#Second:">Second:</a></dt>
  <dd>The possibly inferred link-text; i.e., if there was no real link text,
      then this is the text that we'll infer in its place. (E.g., for
      &quot;L&lt;Getopt::Std&gt;&quot;, the inferred link text is
      &quot;Getopt::Std&quot;.)</dd>
  <dt id="Third:"><a class="permalink" href="#Third:">Third:</a></dt>
  <dd>The name or URL, or <span class="Li">&quot;undef&quot;</span> if none.
      (E.g., in &quot;L&lt;Perl Functions|perlfunc&gt;&quot;, the name (also
      sometimes called the page) is &quot;perlfunc&quot;. In
      &quot;L&lt;/CAVEATS&gt;&quot;, the name is
      <span class="Li">&quot;undef&quot;</span>.)</dd>
  <dt id="Fourth:"><a class="permalink" href="#Fourth:">Fourth:</a></dt>
  <dd>The section (AKA &quot;item&quot; in older perlpods), or
      <span class="Li">&quot;undef&quot;</span> if none. E.g., in
      &quot;L&lt;Getopt::Std/DESCRIPTION&gt;&quot;, &quot;DESCRIPTION&quot; is
      the section. (Note that this is not the same as a manpage section like the
      &quot;5&quot; in &quot;man 5 crontab&quot;. &quot;Section Foo&quot; in the
      Pod sense means the part of the text that's introduced by the heading or
      item whose text is &quot;Foo&quot;.)</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">Pod parsers may also note additional attributes including:</p>
<dl class="Bl-tag">
  <dt id="Fifth:"><a class="permalink" href="#Fifth:">Fifth:</a></dt>
  <dd>A flag for whether item 3 (if present) is a URL (like
      &quot;http://lists.perl.org&quot; is), in which case there should be no
      section attribute; a Pod name (like &quot;perldoc&quot; and
      &quot;Getopt::Std&quot; are); or possibly a man page name (like
      &quot;<b>crontab</b>(5)&quot; is).</dd>
  <dt id="Sixth:"><a class="permalink" href="#Sixth:">Sixth:</a></dt>
  <dd>The raw original L&lt;...&gt; content, before text is split on
      &quot;|&quot;, &quot;/&quot;, etc, and before E&lt;...&gt; codes are
      expanded.</dd>
</dl>
</div>
<div class="Bd-indent">
<p class="Pp">(The above were numbered only for concise reference below. It is
    not a requirement that these be passed as an actual list or array.)</p>
<p class="Pp">For example:</p>
<p class="Pp"></p>
<pre>  L&lt;Foo::Bar&gt;
    =&gt;  undef,                         # link text
        &quot;Foo::Bar&quot;,                    # possibly inferred link text
        &quot;Foo::Bar&quot;,                    # name
        undef,                         # section
        'pod',                         # what sort of link
        &quot;Foo::Bar&quot;                     # original content
  L&lt;Perlport's section on NL's|perlport/Newlines&gt;
    =&gt;  &quot;Perlport's section on NL's&quot;,  # link text
        &quot;Perlport's section on NL's&quot;,  # possibly inferred link text
        &quot;perlport&quot;,                    # name
        &quot;Newlines&quot;,                    # section
        'pod',                         # what sort of link
        &quot;Perlport's section on NL's|perlport/Newlines&quot;
                                       # original content
  L&lt;perlport/Newlines&gt;
    =&gt;  undef,                         # link text
        '&quot;Newlines&quot; in perlport',      # possibly inferred link text
        &quot;perlport&quot;,                    # name
        &quot;Newlines&quot;,                    # section
        'pod',                         # what sort of link
        &quot;perlport/Newlines&quot;            # original content
  L&lt;crontab(5)/&quot;DESCRIPTION&quot;&gt;
    =&gt;  undef,                         # link text
        '&quot;DESCRIPTION&quot; in crontab(5)', # possibly inferred link text
        &quot;crontab(5)&quot;,                  # name
        &quot;DESCRIPTION&quot;,                 # section
        'man',                         # what sort of link
        'crontab(5)/&quot;DESCRIPTION&quot;'     # original content
  L&lt;/Object Attributes&gt;
    =&gt;  undef,                         # link text
        '&quot;Object Attributes&quot;',         # possibly inferred link text
        undef,                         # name
        &quot;Object Attributes&quot;,           # section
        'pod',                         # what sort of link
        &quot;/Object Attributes&quot;           # original content
  L&lt;https://www.perl.org/&gt;
    =&gt;  undef,                         # link text
        &quot;https://www.perl.org/&quot;,       # possibly inferred link text
        &quot;https://www.perl.org/&quot;,       # name
        undef,                         # section
        'url',                         # what sort of link
        &quot;https://www.perl.org/&quot;         # original content
  L&lt;Perl.org|https://www.perl.org/&gt;
    =&gt;  &quot;Perl.org&quot;,                    # link text
        &quot;https://www.perl.org/&quot;,       # possibly inferred link text
        &quot;https://www.perl.org/&quot;,       # name
        undef,                         # section
        'url',                         # what sort of link
        &quot;Perl.org|https://www.perl.org/&quot; # original content
</pre>
<p class="Pp">Note that you can distinguish URL-links from anything else by the
    fact that they match
    <span class="Li">&quot;m/\A\w+:[^:\s]\S*\z/&quot;</span>. So
    <span class="Li">&quot;L&lt;http://www.perl.com&gt;&quot;</span> is a URL,
    but <span class="Li">&quot;L&lt;HTTP::Response&gt;&quot;</span> isn't.</p>
</div>
<ul class="Bl-bullet">
  <li>In case of L&lt;...&gt; codes with no &quot;text|&quot; part in them,
      older formatters have exhibited great variation in actually displaying the
      link or cross reference. For example, L&lt;<b>crontab</b>(5)&gt; would
      render as &quot;the <span class="Li">crontab(5)</span> manpage&quot;, or
      &quot;in the <span class="Li">crontab(5)</span> manpage&quot; or just
      &quot;<span class="Li">crontab(5)</span>&quot;.
    <p class="Pp">Pod processors must now treat &quot;text|&quot;-less links as
        follows:</p>
    <p class="Pp"></p>
    <pre>  L&lt;name&gt;         =&gt;  L&lt;name|name&gt;
  L&lt;/section&gt;     =&gt;  L&lt;&quot;section&quot;|/section&gt;
  L&lt;name/section&gt; =&gt;  L&lt;&quot;section&quot; in name|name/section&gt;
    </pre>
  </li>
  <li>Note that section names might contain markup. I.e., if a section starts
      with:
    <p class="Pp"></p>
    <pre>  =head2 About the C&lt;-M&gt; Operator
    </pre>
    <p class="Pp">or with:</p>
    <p class="Pp"></p>
    <pre>  =item About the C&lt;-M&gt; Operator
    </pre>
    <p class="Pp">then a link to it would look like this:</p>
    <p class="Pp"></p>
    <pre>  L&lt;somedoc/About the C&lt;-M&gt; Operator&gt;
    </pre>
    <p class="Pp">Formatters may choose to ignore the markup for purposes of
        resolving the link and use only the renderable characters in the section
        name, as in:</p>
    <p class="Pp"></p>
    <pre>  &lt;h1&gt;&lt;a name=&quot;About_the_-M_Operator&quot;&gt;About the &lt;code&gt;-M&lt;/code&gt;
  Operator&lt;/h1&gt;
  ...
  &lt;a href=&quot;somedoc#About_the_-M_Operator&quot;&gt;About the &lt;code&gt;-M&lt;/code&gt;
  Operator&quot; in somedoc&lt;/a&gt;
    </pre>
  </li>
  <li>Previous versions of perlpod distinguished
      <span class="Li">&quot;L&lt;name/&quot;section&quot;&gt;&quot;</span>
      links from <span class="Li">&quot;L&lt;name/item&gt;&quot;</span> links
      (and their targets). These have been merged syntactically and semantically
      in the current specification, and <i>section</i> can refer either to a
      &quot;=head<i>n</i> Heading Content&quot; command or to a &quot;=item Item
      Content&quot; command. This specification does not specify what behavior
      should be in the case of a given document having several things all
      seeming to produce the same <i>section</i> identifier (e.g., in HTML,
      several things all producing the same <i>anchorname</i> in &lt;a
      name=&quot;<i>anchorname</i>&quot;&gt;...&lt;/a&gt; elements). Where Pod
      processors can control this behavior, they should use the first such
      anchor. That is, <span class="Li">&quot;L&lt;Foo/Bar&gt;&quot;</span>
      refers to the <i>first</i> &quot;Bar&quot; section in Foo.
    <p class="Pp">But for some processors/formats this cannot be easily
        controlled; as with the HTML example, the behavior of multiple ambiguous
        &lt;a name=&quot;<i>anchorname</i>&quot;&gt;...&lt;/a&gt; is most easily
        just left up to browsers to decide.</p>
  </li>
  <li>In a <span class="Li">&quot;L&lt;text|...&gt;&quot;</span> code, text may
      contain formatting codes for formatting or for E&lt;...&gt; escapes, as
      in:
    <p class="Pp"></p>
    <pre>  L&lt;B&lt;ummE&lt;234&gt;stuff&gt;|...&gt;
    </pre>
    <p class="Pp">For <span class="Li">&quot;L&lt;...&gt;&quot;</span> codes
        without a &quot;name|&quot; part, only
        <span class="Li">&quot;E&lt;...&gt;&quot;</span> and
        <span class="Li">&quot;Z&lt;&gt;&quot;</span> codes may occur. That is,
        authors should not use
        &quot;<span class="Li">&quot;L&lt;B&lt;Foo::Bar&gt;&gt;&quot;</span>&quot;.</p>
    <p class="Pp">Note, however, that formatting codes and Z&lt;&gt;'s can occur
        in any and all parts of an L&lt;...&gt; (i.e., in <i>name</i>,
        <i>section</i>, <i>text</i>, and <i>url</i>).</p>
    <p class="Pp">Authors must not nest L&lt;...&gt; codes. For example,
        &quot;L&lt;The L&lt;Foo::Bar&gt; man page&gt;&quot; should be treated as
        an error.</p>
  </li>
  <li>Note that Pod authors may use formatting codes inside the &quot;text&quot;
      part of &quot;L&lt;text|name&gt;&quot; (and so on for
      L&lt;text|/&quot;sec&quot;&gt;).
    <p class="Pp">In other words, this is valid:</p>
    <p class="Pp"></p>
    <pre>  Go read L&lt;the docs on C&lt;$.&gt;|perlvar/&quot;$.&quot;&gt;
    </pre>
    <p class="Pp">Some output formats that do allow rendering
        &quot;L&lt;...&gt;&quot; codes as hypertext, might not allow the
        link-text to be formatted; in that case, formatters will have to just
        ignore that formatting.</p>
  </li>
  <li>At time of writing, <span class="Li">&quot;L&lt;name&gt;&quot;</span>
      values are of two types: either the name of a Pod page like
      <span class="Li">&quot;L&lt;Foo::Bar&gt;&quot;</span> (which might be a
      real Perl module or program in an <span class="Li">@INC</span> / PATH
      directory, or a .pod file in those places); or the name of a Unix man
      page, like <span class="Li">&quot;L&lt;crontab(5)&gt;&quot;</span>. In
      theory, <span class="Li">&quot;L&lt;chmod&gt;&quot;</span> is ambiguous
      between a Pod page called &quot;chmod&quot;, or the Unix man page
      &quot;chmod&quot; (in whatever man-section). However, the presence of a
      string in parens, as in &quot;<b>crontab</b>(5)&quot;, is sufficient to
      signal that what is being discussed is not a Pod page, and so is
      presumably a Unix man page. The distinction is of no importance to many
      Pod processors, but some processors that render to hypertext formats may
      need to distinguish them in order to know how to render a given
      <span class="Li">&quot;L&lt;foo&gt;&quot;</span> code.</li>
  <li>Previous versions of perlpod allowed for a
      <span class="Li">&quot;L&lt;section&gt;&quot;</span> syntax (as in
      <span class="Li">&quot;L&lt;Object Attributes&gt;&quot;</span>), which was
      not easily distinguishable from
      <span class="Li">&quot;L&lt;name&gt;&quot;</span> syntax and for
      <span class="Li">&quot;L&lt;&quot;section&quot;&gt;&quot;</span> which was
      only slightly less ambiguous. This syntax is no longer in the
      specification, and has been replaced by the
      <span class="Li">&quot;L&lt;/section&gt;&quot;</span> syntax (where the
      slash was formerly optional). Pod parsers should tolerate the
      <span class="Li">&quot;L&lt;&quot;section&quot;&gt;&quot;</span> syntax,
      for a while at least. The suggested heuristic for distinguishing
      <span class="Li">&quot;L&lt;section&gt;&quot;</span> from
      <span class="Li">&quot;L&lt;name&gt;&quot;</span> is that if it contains
      any whitespace, it's a <i>section</i>. Pod processors should warn about
      this being deprecated syntax.</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="About_=over...=back_Regions"><a class="permalink" href="#About_=over...=back_Regions">About
  =over...=back Regions</a></h1>
<p class="Pp">&quot;=over&quot;...&quot;=back&quot; regions are used for various
    kinds of list-like structures. (I use the term &quot;region&quot; here
    simply as a collective term for everything from the &quot;=over&quot; to the
    matching &quot;=back&quot;.)</p>
<ul class="Bl-bullet">
  <li>The non-zero numeric <i>indentlevel</i> in &quot;=over
      <i>indentlevel</i>&quot; ... &quot;=back&quot; is used for giving the
      formatter a clue as to how many &quot;spaces&quot; (ems, or roughly
      equivalent units) it should tab over, although many formatters will have
      to convert this to an absolute measurement that may not exactly match with
      the size of spaces (or M's) in the document's base font. Other formatters
      may have to completely ignore the number. The lack of any explicit
      <i>indentlevel</i> parameter is equivalent to an <i>indentlevel</i> value
      of 4. Pod processors may complain if <i>indentlevel</i> is present but is
      not a positive number matching
      <span class="Li">&quot;m/\A(\d*\.)?\d+\z/&quot;</span>.</li>
  <li>Authors of Pod formatters are reminded that &quot;=over&quot; ...
      &quot;=back&quot; may map to several different constructs in your output
      format. For example, in converting Pod to (X)HTML, it can map to any of
      &lt;ul&gt;...&lt;/ul&gt;, &lt;ol&gt;...&lt;/ol&gt;,
      &lt;dl&gt;...&lt;/dl&gt;, or &lt;blockquote&gt;...&lt;/blockquote&gt;.
      Similarly, &quot;=item&quot; can map to &lt;li&gt; or &lt;dt&gt;.</li>
  <li>Each &quot;=over&quot; ... &quot;=back&quot; region should be one of the
      following:</li>
</ul>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>An &quot;=over&quot; ... &quot;=back&quot; region containing only
      &quot;=item *&quot; commands, each followed by some number of
      ordinary/verbatim paragraphs, other nested &quot;=over&quot; ...
      &quot;=back&quot; regions, &quot;=for...&quot; paragraphs, and
      &quot;=begin&quot;...&quot;=end&quot; regions.
    <p class="Pp">(Pod processors must tolerate a bare &quot;=item&quot; as if
        it were &quot;=item *&quot;.) Whether &quot;*&quot; is rendered as a
        literal asterisk, an &quot;o&quot;, or as some kind of real bullet
        character, is left up to the Pod formatter, and may depend on the level
        of nesting.</p>
  </li>
  <li>An &quot;=over&quot; ... &quot;=back&quot; region containing only
      <span class="Li">&quot;m/\A=item\s+\d+\.?\s*\z/&quot;</span> paragraphs,
      each one (or each group of them) followed by some number of
      ordinary/verbatim paragraphs, other nested &quot;=over&quot; ...
      &quot;=back&quot; regions, &quot;=for...&quot; paragraphs, and/or
      &quot;=begin&quot;...&quot;=end&quot; codes. Note that the numbers must
      start at 1 in each section, and must proceed in order and without skipping
      numbers.
    <p class="Pp">(Pod processors must tolerate lines like &quot;=item 1&quot;
        as if they were &quot;=item 1.&quot;, with the period.)</p>
  </li>
  <li>An &quot;=over&quot; ... &quot;=back&quot; region containing only
      &quot;=item [text]&quot; commands, each one (or each group of them)
      followed by some number of ordinary/verbatim paragraphs, other nested
      &quot;=over&quot; ... &quot;=back&quot; regions, or &quot;=for...&quot;
      paragraphs, and &quot;=begin&quot;...&quot;=end&quot; regions.
    <p class="Pp">The &quot;=item [text]&quot; paragraph should not match
        <span class="Li">&quot;m/\A=item\s+\d+\.?\s*\z/&quot;</span> or
        <span class="Li">&quot;m/\A=item\s+\*\s*\z/&quot;</span>, nor should it
        match just <span class="Li">&quot;m/\A=item\s*\z/&quot;</span>.</p>
  </li>
  <li>An &quot;=over&quot; ... &quot;=back&quot; region containing no
      &quot;=item&quot; paragraphs at all, and containing only some number of
      ordinary/verbatim paragraphs, and possibly also some nested
      &quot;=over&quot; ... &quot;=back&quot; regions, &quot;=for...&quot;
      paragraphs, and &quot;=begin&quot;...&quot;=end&quot; regions. Such an
      itemless &quot;=over&quot; ... &quot;=back&quot; region in Pod is
      equivalent in meaning to a
      &quot;&lt;blockquote&gt;...&lt;/blockquote&gt;&quot; element in HTML.</li>
</ul>
</div>
<div class="Bd-indent">
<p class="Pp">Note that with all the above cases, you can determine which type
    of &quot;=over&quot; ... &quot;=back&quot; you have, by examining the first
    (non-&quot;=cut&quot;, non-&quot;=pod&quot;) Pod paragraph after the
    &quot;=over&quot; command.</p>
</div>
<ul class="Bl-bullet">
  <li>Pod formatters <i>must</i> tolerate arbitrarily large amounts of text in
      the &quot;=item <i>text...</i>&quot; paragraph. In practice, most such
      paragraphs are short, as in:
    <p class="Pp"></p>
    <pre>  =item For cutting off our trade with all parts of the world
    </pre>
    <p class="Pp">But they may be arbitrarily long:</p>
    <p class="Pp"></p>
    <pre>  =item For transporting us beyond seas to be tried for pretended
  offenses
  =item He is at this time transporting large armies of foreign
  mercenaries to complete the works of death, desolation and
  tyranny, already begun with circumstances of cruelty and perfidy
  scarcely paralleled in the most barbarous ages, and totally
  unworthy the head of a civilized nation.
    </pre>
  </li>
  <li>Pod processors should tolerate &quot;=item *&quot; / &quot;=item
      <i>number</i>&quot; commands with no accompanying paragraph. The middle
      item is an example:
    <p class="Pp"></p>
    <pre>  =over
  =item 1
  Pick up dry cleaning.
  =item 2
  =item 3
  Stop by the store.  Get Abba Zabas, Stoli, and cheap lawn chairs.
  =back
    </pre>
  </li>
  <li>No &quot;=over&quot; ... &quot;=back&quot; region can contain headings.
      Processors may treat such a heading as an error.</li>
  <li>Note that an &quot;=over&quot; ... &quot;=back&quot; region should have
      some content. That is, authors should not have an empty region like this:
    <p class="Pp"></p>
    <pre>  =over
  =back
    </pre>
    <p class="Pp">Pod processors seeing such a contentless &quot;=over&quot; ...
        &quot;=back&quot; region, may ignore it, or may report it as an
      error.</p>
  </li>
  <li>Processors must tolerate an &quot;=over&quot; list that goes off the end
      of the document (i.e., which has no matching &quot;=back&quot;), but they
      may warn about such a list.</li>
  <li>Authors of Pod formatters should note that this construct:
    <p class="Pp"></p>
    <pre>  =item Neque
  =item Porro
  =item Quisquam Est
  Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci 
  velit, sed quia non numquam eius modi tempora incidunt ut
  labore et dolore magnam aliquam quaerat voluptatem.
  =item Ut Enim
    </pre>
    <p class="Pp">is semantically ambiguous, in a way that makes formatting
        decisions a bit difficult. On the one hand, it could be mention of an
        item &quot;Neque&quot;, mention of another item &quot;Porro&quot;, and
        mention of another item &quot;Quisquam Est&quot;, with just the last one
        requiring the explanatory paragraph &quot;Qui dolorem ipsum quia
        dolor...&quot;; and then an item &quot;Ut Enim&quot;. In that case,
        you'd want to format it like so:</p>
    <p class="Pp"></p>
    <pre>  Neque
  Porro
  Quisquam Est
    Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci
    velit, sed quia non numquam eius modi tempora incidunt ut
    labore et dolore magnam aliquam quaerat voluptatem.
  Ut Enim
    </pre>
    <p class="Pp">But it could equally well be a discussion of three (related or
        equivalent) items, &quot;Neque&quot;, &quot;Porro&quot;, and
        &quot;Quisquam Est&quot;, followed by a paragraph explaining them all,
        and then a new item &quot;Ut Enim&quot;. In that case, you'd probably
        want to format it like so:</p>
    <p class="Pp"></p>
    <pre>  Neque
  Porro
  Quisquam Est
    Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci
    velit, sed quia non numquam eius modi tempora incidunt ut
    labore et dolore magnam aliquam quaerat voluptatem.
  Ut Enim
    </pre>
    <p class="Pp">But (for the foreseeable future), Pod does not provide any way
        for Pod authors to distinguish which grouping is meant by the above
        &quot;=item&quot;-cluster structure. So formatters should format it like
        so:</p>
    <p class="Pp"></p>
    <pre>  Neque
  Porro
  Quisquam Est
    Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci
    velit, sed quia non numquam eius modi tempora incidunt ut
    labore et dolore magnam aliquam quaerat voluptatem.
  Ut Enim
    </pre>
    <p class="Pp">That is, there should be (at least roughly) equal spacing
        between items as between paragraphs (although that spacing may well be
        less than the full height of a line of text). This leaves it to the
        reader to use (con)textual cues to figure out whether the &quot;Qui
        dolorem ipsum...&quot; paragraph applies to the &quot;Quisquam Est&quot;
        item or to all three items &quot;Neque&quot;, &quot;Porro&quot;, and
        &quot;Quisquam Est&quot;. While not an ideal situation, this is
        preferable to providing formatting cues that may be actually contrary to
        the author's intent.</p>
  </li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="About_Data_Paragraphs_and__=begin/=end__Regions"><a class="permalink" href="#About_Data_Paragraphs_and__=begin/=end__Regions">About
  Data Paragraphs and &quot;=begin/=end&quot; Regions</a></h1>
<p class="Pp">Data paragraphs are typically used for inlining non-Pod data that
    is to be used (typically passed through) when rendering the document to a
    specific format:</p>
<p class="Pp"></p>
<pre>  =begin rtf
  \par{\pard\qr\sa4500{\i Printed\~\chdate\~\chtime}\par}
  =end rtf
</pre>
<p class="Pp">The exact same effect could, incidentally, be achieved with a
    single &quot;=for&quot; paragraph:</p>
<p class="Pp"></p>
<pre>  =for rtf \par{\pard\qr\sa4500{\i Printed\~\chdate\~\chtime}\par}
</pre>
<p class="Pp">(Although that is not formally a data paragraph, it has the same
    meaning as one, and Pod parsers may parse it as one.)</p>
<p class="Pp">Another example of a data paragraph:</p>
<p class="Pp"></p>
<pre>  =begin html
  I like &lt;em&gt;PIE&lt;/em&gt;!
  &lt;hr&gt;Especially pecan pie!
  =end html
</pre>
<p class="Pp">If these were ordinary paragraphs, the Pod parser would try to
    expand the &quot;E&lt;/em&gt;&quot; (in the first paragraph) as a formatting
    code, just like &quot;E&lt;lt&gt;&quot; or &quot;E&lt;eacute&gt;&quot;. But
    since this is in a &quot;=begin <i>identifier</i>&quot;...&quot;=end
    <i>identifier</i>&quot; region <i>and</i> the identifier &quot;html&quot;
    doesn't begin have a &quot;:&quot; prefix, the contents of this region are
    stored as data paragraphs, instead of being processed as ordinary paragraphs
    (or if they began with a spaces and/or tabs, as verbatim paragraphs).</p>
<p class="Pp">As a further example: At time of writing, no &quot;biblio&quot;
    identifier is supported, but suppose some processor were written to
    recognize it as a way of (say) denoting a bibliographic reference
    (necessarily containing formatting codes in ordinary paragraphs). The fact
    that &quot;biblio&quot; paragraphs were meant for ordinary processing would
    be indicated by prefacing each &quot;biblio&quot; identifier with a
  colon:</p>
<p class="Pp"></p>
<pre>  =begin :biblio
  Wirth, Niklaus.  1976.  I&lt;Algorithms + Data Structures =
  Programs.&gt;  Prentice-Hall, Englewood Cliffs, NJ.
  =end :biblio
</pre>
<p class="Pp">This would signal to the parser that paragraphs in this
    begin...end region are subject to normal handling as ordinary/verbatim
    paragraphs (while still tagged as meant only for processors that understand
    the &quot;biblio&quot; identifier). The same effect could be had with:</p>
<p class="Pp"></p>
<pre>  =for :biblio
  Wirth, Niklaus.  1976.  I&lt;Algorithms + Data Structures =
  Programs.&gt;  Prentice-Hall, Englewood Cliffs, NJ.
</pre>
<p class="Pp">The &quot;:&quot; on these identifiers means simply &quot;process
    this stuff normally, even though the result will be for some special
    target&quot;. I suggest that parser APIs report &quot;biblio&quot; as the
    target identifier, but also report that it had a &quot;:&quot; prefix. (And
    similarly, with the above &quot;html&quot;, report &quot;html&quot; as the
    target identifier, and note the <i>lack</i> of a &quot;:&quot; prefix.)</p>
<p class="Pp">Note that a &quot;=begin <i>identifier</i>&quot;...&quot;=end
    <i>identifier</i>&quot; region where <i>identifier</i> begins with a colon,
    <i>can</i> contain commands. For example:</p>
<p class="Pp"></p>
<pre>  =begin :biblio
  Wirth's classic is available in several editions, including:
  =for comment
   hm, check abebooks.com for how much used copies cost.
  =over
  =item
  Wirth, Niklaus.  1975.  I&lt;Algorithmen und Datenstrukturen.&gt;
  Teubner, Stuttgart.  [Yes, it's in German.]
  =item
  Wirth, Niklaus.  1976.  I&lt;Algorithms + Data Structures =
  Programs.&gt;  Prentice-Hall, Englewood Cliffs, NJ.
  =back
  =end :biblio
</pre>
<p class="Pp">Note, however, a &quot;=begin <i>identifier</i>&quot;...&quot;=end
    <i>identifier</i>&quot; region where <i>identifier</i> does <i>not</i> begin
    with a colon, should not directly contain &quot;=head1&quot; ...
    &quot;=head4&quot; commands, nor &quot;=over&quot;, nor &quot;=back&quot;,
    nor &quot;=item&quot;. For example, this may be considered invalid:</p>
<p class="Pp"></p>
<pre>  =begin somedata
  This is a data paragraph.
  =head1 Don't do this!
  This is a data paragraph too.
  =end somedata
</pre>
<p class="Pp">A Pod processor may signal that the above (specifically the
    &quot;=head1&quot; paragraph) is an error. Note, however, that the following
    should <i>not</i> be treated as an error:</p>
<p class="Pp"></p>
<pre>  =begin somedata
  This is a data paragraph.
  =cut
  # Yup, this isn't Pod anymore.
  sub excl { (rand() &gt; .5) ? &quot;hoo!&quot; : &quot;hah!&quot; }
  =pod
  This is a data paragraph too.
  =end somedata
</pre>
<p class="Pp">And this too is valid:</p>
<p class="Pp"></p>
<pre>  =begin someformat
  This is a data paragraph.
    And this is a data paragraph.
  =begin someotherformat
  This is a data paragraph too.
    And this is a data paragraph too.
  =begin :yetanotherformat
  =head2 This is a command paragraph!
  This is an ordinary paragraph!
    And this is a verbatim paragraph!
  =end :yetanotherformat
  =end someotherformat
  Another data paragraph!
  =end someformat
</pre>
<p class="Pp">The contents of the above &quot;=begin :yetanotherformat&quot; ...
    &quot;=end :yetanotherformat&quot; region <i>aren't</i> data paragraphs,
    because the immediately containing region's identifier
    (&quot;:yetanotherformat&quot;) begins with a colon. In practice, most
    regions that contain data paragraphs will contain <i>only</i> data
    paragraphs; however, the above nesting is syntactically valid as Pod, even
    if it is rare. However, the handlers for some formats, like
    &quot;html&quot;, will accept only data paragraphs, not nested regions; and
    they may complain if they see (targeted for them) nested regions, or
    commands, other than &quot;=end&quot;, &quot;=pod&quot;, and
    &quot;=cut&quot;.</p>
<p class="Pp">Also consider this valid structure:</p>
<p class="Pp"></p>
<pre>  =begin :biblio
  Wirth's classic is available in several editions, including:
  =over
  =item
  Wirth, Niklaus.  1975.  I&lt;Algorithmen und Datenstrukturen.&gt;
  Teubner, Stuttgart.  [Yes, it's in German.]
  =item
  Wirth, Niklaus.  1976.  I&lt;Algorithms + Data Structures =
  Programs.&gt;  Prentice-Hall, Englewood Cliffs, NJ.
  =back
  Buy buy buy!
  =begin html
  &lt;img src='wirth_spokesmodeling_book.png'&gt;
  &lt;hr&gt;
  =end html
  Now now now!
  =end :biblio
</pre>
<p class="Pp">There, the &quot;=begin html&quot;...&quot;=end html&quot; region
    is nested inside the larger &quot;=begin :biblio&quot;...&quot;=end
    :biblio&quot; region. Note that the content of the &quot;=begin
    html&quot;...&quot;=end html&quot; region is data paragraph(s), because the
    immediately containing region's identifier (&quot;html&quot;) <i>doesn't</i>
    begin with a colon.</p>
<p class="Pp">Pod parsers, when processing a series of data paragraphs one after
    another (within a single region), should consider them to be one large data
    paragraph that happens to contain blank lines. So the content of the above
    &quot;=begin html&quot;...&quot;=end html&quot; <i>may</i> be stored as two
    data paragraphs (one consisting of &quot;&lt;img
    src='wirth_spokesmodeling_book.png'&gt;\n&quot; and another consisting of
    &quot;&lt;hr&gt;\n&quot;), but <i>should</i> be stored as a single data
    paragraph (consisting of &quot;&lt;img
    src='wirth_spokesmodeling_book.png'&gt;\n\n&lt;hr&gt;\n&quot;).</p>
<p class="Pp">Pod processors should tolerate empty &quot;=begin
    <i>something</i>&quot;...&quot;=end <i>something</i>&quot; regions, empty
    &quot;=begin :<i>something</i>&quot;...&quot;=end :<i>something</i>&quot;
    regions, and contentless &quot;=for <i>something</i>&quot; and &quot;=for
    :<i>something</i>&quot; paragraphs. I.e., these should be tolerated:</p>
<p class="Pp"></p>
<pre>  =for html
  =begin html
  =end html
  =begin :biblio
  =end :biblio
</pre>
<p class="Pp">Incidentally, note that there's no easy way to express a data
    paragraph starting with something that looks like a command. Consider:</p>
<p class="Pp"></p>
<pre>  =begin stuff
  =shazbot
  =end stuff
</pre>
<p class="Pp">There, &quot;=shazbot&quot; will be parsed as a Pod command
    &quot;shazbot&quot;, not as a data paragraph &quot;=shazbot\n&quot;.
    However, you can express a data paragraph consisting of
    &quot;=shazbot\n&quot; using this code:</p>
<p class="Pp"></p>
<pre>  =for stuff =shazbot
</pre>
<p class="Pp">The situation where this is necessary, is presumably quite
  rare.</p>
<p class="Pp">Note that =end commands must match the currently open =begin
    command. That is, they must properly nest. For example, this is valid:</p>
<p class="Pp"></p>
<pre>  =begin outer
  X
  =begin inner
  Y
  =end inner
  Z
  =end outer
</pre>
<p class="Pp">while this is invalid:</p>
<p class="Pp"></p>
<pre>  =begin outer
  X
  =begin inner
  Y
  =end outer
  Z
  =end inner
</pre>
<p class="Pp">This latter is improper because when the &quot;=end outer&quot;
    command is seen, the currently open region has the formatname
    &quot;inner&quot;, not &quot;outer&quot;. (It just happens that
    &quot;outer&quot; is the format name of a higher-up region.) This is an
    error. Processors must by default report this as an error, and may halt
    processing the document containing that error. A corollary of this is that
    regions cannot &quot;overlap&quot;. That is, the latter block above does not
    represent a region called &quot;outer&quot; which contains X and Y,
    overlapping a region called &quot;inner&quot; which contains Y and Z. But
    because it is invalid (as all apparently overlapping regions would be), it
    doesn't represent that, or anything at all.</p>
<p class="Pp">Similarly, this is invalid:</p>
<p class="Pp"></p>
<pre>  =begin thing
  =end hting
</pre>
<p class="Pp">This is an error because the region is opened by
    &quot;thing&quot;, and the &quot;=end&quot; tries to close &quot;hting&quot;
    [sic].</p>
<p class="Pp">This is also invalid:</p>
<p class="Pp"></p>
<pre>  =begin thing
  =end
</pre>
<p class="Pp">This is invalid because every &quot;=end&quot; command must have a
    formatname parameter.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">perlpod, &quot;PODs: Embedded Documentation&quot; in perlsyn,
    podchecker</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Sean M. Burke</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os">perl v5.34.1</td>
  </tr>
</table>
</body>
</html>

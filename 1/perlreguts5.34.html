<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PERLREGUTS(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLREGUTS(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLREGUTS(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlreguts - Description of the Perl regular expression
  engine.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This document is an attempt to shine some light on the guts of the
    regex engine and how it works. The regex engine represents a significant
    chunk of the perl codebase, but is relatively poorly understood. This
    document is a meagre attempt at addressing this situation. It is derived
    from the author's experience, comments in the source code, other papers on
    the regex engine, feedback on the perl5-porters mail list, and no doubt
    other places as well.</p>
<p class="Pp"><b>NOTICE!</b> It should be clearly understood that the behavior
    and structures discussed in this represents the state of the engine as the
    author understood it at the time of writing. It is <b>NOT</b> an API
    definition, it is purely an internals guide for those who want to hack the
    regex engine, or understand how the regex engine works. Readers of this
    document are expected to understand perl's regex syntax and its usage in
    detail. If you want to learn about the basics of Perl's regular expressions,
    see perlre. And if you want to replace the regex engine with your own, see
    perlreapi.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OVERVIEW"><a class="permalink" href="#OVERVIEW">OVERVIEW</a></h1>
<section class="Ss">
<h2 class="Ss" id="A_quick_note_on_terms"><a class="permalink" href="#A_quick_note_on_terms">A
  quick note on terms</a></h2>
<p class="Pp">There is some debate as to whether to say &quot;regexp&quot; or
    &quot;regex&quot;. In this document we will use the term &quot;regex&quot;
    unless there is a special reason not to, in which case we will explain
  why.</p>
<p class="Pp">When speaking about regexes we need to distinguish between their
    source code form and their internal form. In this document we will use the
    term &quot;pattern&quot; when we speak of their textual, source code form,
    and the term &quot;program&quot; when we speak of their internal
    representation. These correspond to the terms <i>S-regex</i> and
    <i>B-regex</i> that Mark Jason Dominus employs in his paper on
    &quot;Rx&quot; ([1] in &quot;REFERENCES&quot;).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="What_is_a_regular_expression_engine?"><a class="permalink" href="#What_is_a_regular_expression_engine?">What
  is a regular expression engine?</a></h2>
<p class="Pp">A regular expression engine is a program that takes a set of
    constraints specified in a mini-language, and then applies those constraints
    to a target string, and determines whether or not the string satisfies the
    constraints. See perlre for a full definition of the language.</p>
<p class="Pp">In less grandiose terms, the first part of the job is to turn a
    pattern into something the computer can efficiently use to find the matching
    point in the string, and the second part is performing the search
  itself.</p>
<p class="Pp">To do this we need to produce a program by parsing the text. We
    then need to execute the program to find the point in the string that
    matches. And we need to do the whole thing efficiently.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Structure_of_a_Regexp_Program"><a class="permalink" href="#Structure_of_a_Regexp_Program">Structure
  of a Regexp Program</a></h2>
<p class="Pp"><i>High Level</i></p>
<p class="Pp">Although it is a bit confusing and some people object to the
    terminology, it is worth taking a look at a comment that has been in
    <i>regexp.h</i> for years:</p>
<p class="Pp"><i>This is essentially a linear encoding of a nondeterministic</i>
    <i>finite-state machine (aka syntax charts or &quot;railroad normal
    form&quot; in</i> <i>parsing technology).</i></p>
<p class="Pp">The term &quot;railroad normal form&quot; is a bit esoteric, with
    &quot;syntax diagram/charts&quot;, or &quot;railroad diagram/charts&quot;
    being more common terms. Nevertheless it provides a useful mental image of a
    regex program: each node can be thought of as a unit of track, with a single
    entry and in most cases a single exit point (there are pieces of track that
    fork, but statistically not many), and the whole forms a layout with a
    single entry and single exit point. The matching process can be thought of
    as a car that moves along the track, with the particular route through the
    system being determined by the character read at each possible connector
    point. A car can fall off the track at any point but it may only proceed as
    long as it matches the track.</p>
<p class="Pp">Thus the pattern
    <span class="Li">&quot;/foo(?:\w+|\d+|\s+)bar/&quot;</span> can be thought
    of as the following chart:</p>
<p class="Pp"></p>
<pre>                      [start]
                         |
                       &lt;foo&gt;
                         |
                   +-----+-----+
                   |     |     |
                 &lt;\w+&gt; &lt;\d+&gt; &lt;\s+&gt;
                   |     |     |
                   +-----+-----+
                         |
                       &lt;bar&gt;
                         |
                       [end]
</pre>
<p class="Pp">The truth of the matter is that perl's regular expressions these
    days are much more complex than this kind of structure, but visualising it
    this way can help when trying to get your bearings, and it matches the
    current implementation pretty closely.</p>
<p class="Pp">To be more precise, we will say that a regex program is an
    encoding of a graph. Each node in the graph corresponds to part of the
    original regex pattern, such as a literal string or a branch, and has a
    pointer to the nodes representing the next component to be matched. Since
    &quot;node&quot; and &quot;opcode&quot; already have other meanings in the
    perl source, we will call the nodes in a regex program
  &quot;regops&quot;.</p>
<p class="Pp">The program is represented by an array of
    <span class="Li">&quot;regnode&quot;</span> structures, one or more of which
    represent a single regop of the program. Struct
    <span class="Li">&quot;regnode&quot;</span> is the smallest struct needed,
    and has a field structure which is shared with all the other larger
    structures. (Outside this document, the term &quot;regnode&quot; is
    sometimes used to mean &quot;regop&quot;, which could be confusing.)</p>
<p class="Pp">The &quot;next&quot; pointers of all regops except
    <span class="Li">&quot;BRANCH&quot;</span> implement concatenation; a
    &quot;next&quot; pointer with a <span class="Li">&quot;BRANCH&quot;</span>
    on both ends of it is connecting two alternatives. [Here we have one of the
    subtle syntax dependencies: an individual
    <span class="Li">&quot;BRANCH&quot;</span> (as opposed to a collection of
    them) is never concatenated with anything because of operator
  precedence.]</p>
<p class="Pp">The operand of some types of regop is a literal string; for
    others, it is a regop leading into a sub-program. In particular, the operand
    of a <span class="Li">&quot;BRANCH&quot;</span> node is the first regop of
    the branch.</p>
<p class="Pp"><b>NOTE</b>: As the railroad metaphor suggests, this is <b>not</b>
    a tree structure: the tail of the branch connects to the thing following the
    set of <span class="Li">&quot;BRANCH&quot;</span>es. It is a like a single
    line of railway track that splits as it goes into a station or railway yard
    and rejoins as it comes out the other side.</p>
<p class="Pp"><i>Regops</i></p>
<p class="Pp">The base structure of a regop is defined in <i>regexp.h</i> as
    follows:</p>
<p class="Pp"></p>
<pre>    struct regnode {
        U8  flags;    /* Various purposes, sometimes overridden */
        U8  type;     /* Opcode value as specified by regnodes.h */
        U16 next_off; /* Offset in size regnode */
    };
</pre>
<p class="Pp">Other larger <span class="Li">&quot;regnode&quot;</span>-like
    structures are defined in <i>regcomp.h</i>. They are almost like subclasses
    in that they have the same fields as
    <span class="Li">&quot;regnode&quot;</span>, with possibly additional fields
    following in the structure, and in some cases the specific meaning (and
    name) of some of base fields are overridden. The following is a more
    complete description.</p>
<dl class="Bl-tag">
  <dt>&quot;regnode_1&quot;</dt>
  <dd></dd>
  <dt>&quot;regnode_2&quot;</dt>
  <dd><span class="Li">&quot;regnode_1&quot;</span> structures have the same
      header, followed by a single four-byte argument;
      <span class="Li">&quot;regnode_2&quot;</span> structures contain two
      two-byte arguments instead:
    <p class="Pp"></p>
    <pre>    regnode_1                U32 arg1;
    regnode_2                U16 arg1;  U16 arg2;
    </pre>
  </dd>
  <dt>&quot;regnode_string&quot;</dt>
  <dd><span class="Li">&quot;regnode_string&quot;</span> structures, used for
      literal strings, follow the header with a one-byte length and then the
      string data. Strings are padded on the tail end with zero bytes so that
      the total length of the node is a multiple of four bytes:
    <p class="Pp"></p>
    <pre>    regnode_string           char string[1];
                             U8 str_len; /* overrides flags */
    </pre>
  </dd>
  <dt>&quot;regnode_charclass&quot;</dt>
  <dd>Bracketed character classes are represented by
      <span class="Li">&quot;regnode_charclass&quot;</span> structures, which
      have a four-byte argument and then a 32-byte (256-bit) bitmap indicating
      which characters in the Latin1 range are included in the class.
    <p class="Pp"></p>
    <pre>    regnode_charclass        U32 arg1;
                             char bitmap[ANYOF_BITMAP_SIZE];
    </pre>
    <p class="Pp">Various flags whose names begin with
        <span class="Li">&quot;ANYOF_&quot;</span> are used for special
        situations. Above Latin1 matches and things not known until run-time are
        stored in &quot;Perl's pprivate structure&quot;.</p>
  </dd>
  <dt>&quot;regnode_charclass_posixl&quot;</dt>
  <dd>There is also a larger form of a char class structure used to represent
      POSIX char classes under <span class="Li">&quot;/l&quot;</span> matching,
      called <span class="Li">&quot;regnode_charclass_posixl&quot;</span> which
      has an additional 32-bit bitmap indicating which POSIX char classes have
      been included.
    <p class="Pp"></p>
    <pre>   regnode_charclass_posixl U32 arg1;
                            char bitmap[ANYOF_BITMAP_SIZE];
                            U32 classflags;
    </pre>
  </dd>
</dl>
<p class="Pp"><i>regnodes.h</i> defines an array called
    <span class="Li">&quot;regarglen[]&quot;</span> which gives the size of each
    opcode in units of <span class="Li">&quot;size regnode&quot;</span>
    (4-byte). A macro is used to calculate the size of an
    <span class="Li">&quot;EXACT&quot;</span> node based on its
    <span class="Li">&quot;str_len&quot;</span> field.</p>
<p class="Pp">The regops are defined in <i>regnodes.h</i> which is generated
    from <i>regcomp.sym</i> by <i>regcomp.pl</i>. Currently the maximum possible
    number of distinct regops is restricted to 256, with about a quarter already
    used.</p>
<p class="Pp">A set of macros makes accessing the fields easier and more
    consistent. These include <span class="Li">&quot;OP()&quot;</span>, which is
    used to determine the type of a
    <span class="Li">&quot;regnode&quot;</span>-like structure;
    <span class="Li">&quot;NEXT_OFF()&quot;</span>, which is the offset to the
    next node (more on this later); <span class="Li">&quot;ARG()&quot;</span>,
    <span class="Li">&quot;ARG1()&quot;</span>,
    <span class="Li">&quot;ARG2()&quot;</span>,
    <span class="Li">&quot;ARG_SET()&quot;</span>, and equivalents for reading
    and setting the arguments; and
    <span class="Li">&quot;STR_LEN()&quot;</span>,
    <span class="Li">&quot;STRING()&quot;</span> and
    <span class="Li">&quot;OPERAND()&quot;</span> for manipulating strings and
    regop bearing types.</p>
<p class="Pp"><i>What regop is next?</i></p>
<p class="Pp">There are three distinct concepts of &quot;next&quot; in the regex
    engine, and it is important to keep them clear.</p>
<ul class="Bl-bullet">
  <li>There is the &quot;next regnode&quot; from a given regnode, a value which
      is rarely useful except that sometimes it matches up in terms of value
      with one of the others, and that sometimes the code assumes this to always
      be so.</li>
  <li>There is the &quot;next regop&quot; from a given regop/regnode. This is
      the regop physically located after the current one, as determined by the
      size of the current regop. This is often useful, such as when dumping the
      structure we use this order to traverse. Sometimes the code assumes that
      the &quot;next regnode&quot; is the same as the &quot;next regop&quot;, or
      in other words assumes that the sizeof a given regop type is always going
      to be one regnode large.</li>
  <li>There is the &quot;regnext&quot; from a given regop. This is the regop
      which is reached by jumping forward by the value of
      <span class="Li">&quot;NEXT_OFF()&quot;</span>, or in a few cases for
      longer jumps by the <span class="Li">&quot;arg1&quot;</span> field of the
      <span class="Li">&quot;regnode_1&quot;</span> structure. The subroutine
      <span class="Li">&quot;regnext()&quot;</span> handles this transparently.
      This is the logical successor of the node, which in some cases, like that
      of the <span class="Li">&quot;BRANCH&quot;</span> regop, has special
      meaning.</li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Process_Overview"><a class="permalink" href="#Process_Overview">Process
  Overview</a></h1>
<p class="Pp">Broadly speaking, performing a match of a string against a pattern
    involves the following steps:</p>
<dl class="Bl-tag">
  <dt id="A."><a class="permalink" href="#A.">A. Compilation</a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>1. Parsing</dt>
  <dd></dd>
  <dt>2. Peep-hole optimisation and analysis</dt>
  <dd></dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="B."><a class="permalink" href="#B.">B. Execution</a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>3. Start position and no-match optimisations</dt>
  <dd></dd>
  <dt>4. Program execution</dt>
  <dd></dd>
</dl>
</div>
<div class="Bd-indent"></div>
<p class="Pp">Where these steps occur in the actual execution of a perl program
    is determined by whether the pattern involves interpolating any string
    variables. If interpolation occurs, then compilation happens at run time. If
    it does not, then compilation is performed at compile time. (The
    <span class="Li">&quot;/o&quot;</span> modifier changes this, as does
    <span class="Li">&quot;qr//&quot;</span> to a certain extent.) The engine
    doesn't really care that much.</p>
<section class="Ss">
<h2 class="Ss" id="Compilation"><a class="permalink" href="#Compilation">Compilation</a></h2>
<p class="Pp">This code resides primarily in <i>regcomp.c</i>, along with the
    header files <i>regcomp.h</i>, <i>regexp.h</i> and <i>regnodes.h</i>.</p>
<p class="Pp">Compilation starts with
    <span class="Li">&quot;pregcomp()&quot;</span>, which is mostly an
    initialisation wrapper which farms work out to two other routines for the
    heavy lifting: the first is <span class="Li">&quot;reg()&quot;</span>, which
    is the start point for parsing; the second,
    <span class="Li">&quot;study_chunk()&quot;</span>, is responsible for
    optimisation.</p>
<p class="Pp">Initialisation in <span class="Li">&quot;pregcomp()&quot;</span>
    mostly involves the creation and data-filling of a special structure,
    <span class="Li">&quot;RExC_state_t&quot;</span> (defined in
    <i>regcomp.c</i>). Almost all internally-used routines in <i>regcomp.h</i>
    take a pointer to one of these structures as their first argument, with the
    name <span class="Li">&quot;pRExC_state&quot;</span>. This structure is used
    to store the compilation state and contains many fields. Likewise there are
    many macros which operate on this variable: anything that looks like
    <span class="Li">&quot;RExC_xxxx&quot;</span> is a macro that operates on
    this pointer/structure.</p>
<p class="Pp"><span class="Li">&quot;reg()&quot;</span> is the start of the
    parse process. It is responsible for parsing an arbitrary chunk of pattern
    up to either the end of the string, or the first closing parenthesis it
    encounters in the pattern. This means it can be used to parse the top-level
    regex, or any section inside of a grouping parenthesis. It also handles the
    &quot;special parens&quot; that perl's regexes have. For instance when
    parsing <span class="Li">&quot;/x(?:foo)y/&quot;</span>,
    <span class="Li">&quot;reg()&quot;</span> will at one point be called to
    parse from the &quot;?&quot; symbol up to and including the
  &quot;)&quot;.</p>
<p class="Pp">Additionally, <span class="Li">&quot;reg()&quot;</span> is
    responsible for parsing the one or more branches from the pattern, and for
    &quot;finishing them off&quot; by correctly setting their next pointers. In
    order to do the parsing, it repeatedly calls out to
    <span class="Li">&quot;regbranch()&quot;</span>, which is responsible for
    handling up to the first <span class="Li">&quot;|&quot;</span> symbol it
    sees.</p>
<p class="Pp"><span class="Li">&quot;regbranch()&quot;</span> in turn calls
    <span class="Li">&quot;regpiece()&quot;</span> which handles
    &quot;things&quot; followed by a quantifier. In order to parse the
    &quot;things&quot;, <span class="Li">&quot;regatom()&quot;</span> is called.
    This is the lowest level routine, which parses out constant strings,
    character classes, and the various special symbols like
    <span class="Li">&quot;$&quot;</span>. If
    <span class="Li">&quot;regatom()&quot;</span> encounters a &quot;(&quot;
    character it in turn calls <span class="Li">&quot;reg()&quot;</span>.</p>
<p class="Pp">There used to be two main passes involved in parsing, the first to
    calculate the size of the compiled program, and the second to actually
    compile it. But now there is only one main pass, with an initial crude guess
    based on the length of the input pattern, which is increased if necessary as
    parsing proceeds, and afterwards, trimmed to the actual amount used.</p>
<p class="Pp">However, it may happen that parsing must be restarted at the
    beginning when various circumstances occur along the way. An example is if
    the program turns out to be so large that there are jumps in it that won't
    fit in the normal 16 bits available. There are two special regops that can
    hold bigger jump destinations, BRANCHJ and LONGBRANCH. The parse is
    restarted, and these are used instead of the normal shorter ones. Whenever
    restarting the parse is required, the function returns failure and sets a
    flag as to what needs to be done. This is passed up to the top level routine
    which takes the appropriate action and restarts from scratch. In the case of
    needing longer jumps, the
    <span class="Li">&quot;RExC_use_BRANCHJ&quot;</span> flag is set in the
    <span class="Li">&quot;RExC_state_t&quot;</span> structure, which the
    functions know to inspect before deciding how to do branches.</p>
<p class="Pp">In most instances, the function that discovers the issue sets the
    causal flag and returns failure immediately. &quot;Parsing
    complications&quot; contains an explicit example of how this works. In other
    cases, such as a forward reference to a numbered parenthetical grouping, we
    need to finish the parse to know if that numbered grouping actually appears
    in the pattern. In those cases, the parse is just redone at the end, with
    the knowledge of how many groupings occur in it.</p>
<p class="Pp">The routine <span class="Li">&quot;regtail()&quot;</span> is
    called by both <span class="Li">&quot;reg()&quot;</span> and
    <span class="Li">&quot;regbranch()&quot;</span> in order to &quot;set the
    tail pointer&quot; correctly. When executing and we get to the end of a
    branch, we need to go to the node following the grouping parens. When
    parsing, however, we don't know where the end will be until we get there, so
    when we do we must go back and update the offsets as appropriate.
    <span class="Li">&quot;regtail&quot;</span> is used to make this easier.</p>
<p class="Pp">A subtlety of the parsing process means that a regex like
    <span class="Li">&quot;/foo/&quot;</span> is originally parsed into an
    alternation with a single branch. It is only afterwards that the optimiser
    converts single branch alternations into the simpler form.</p>
<p class="Pp"><i>Parse Call Graph and a Grammar</i></p>
<p class="Pp">The call graph looks like this:</p>
<p class="Pp"></p>
<pre> reg()                        # parse a top level regex, or inside of
                              # parens
     regbranch()              # parse a single branch of an alternation
         regpiece()           # parse a pattern followed by a quantifier
             regatom()        # parse a simple pattern
                 regclass()   #   used to handle a class
                 reg()        #   used to handle a parenthesised
                              #   subpattern
                 ....
         ...
         regtail()            # finish off the branch
     ...
     regtail()                # finish off the branch sequence. Tie each
                              # branch's tail to the tail of the
                              # sequence
                              # (NEW) In Debug mode this is
                              # regtail_study().
</pre>
<p class="Pp">A grammar form might be something like this:</p>
<p class="Pp"></p>
<pre>    atom  : constant | class
    quant : '*' | '+' | '?' | '{min,max}'
    _branch: piece
           | piece _branch
           | nothing
    branch: _branch
          | _branch '|' branch
    group : '(' branch ')'
    _piece: atom | group
    piece : _piece
          | _piece quant
</pre>
<p class="Pp"><i>Parsing complications</i></p>
<p class="Pp">The implication of the above description is that a pattern
    containing nested parentheses will result in a call graph which cycles
    through <span class="Li">&quot;reg()&quot;</span>,
    <span class="Li">&quot;regbranch()&quot;</span>,
    <span class="Li">&quot;regpiece()&quot;</span>,
    <span class="Li">&quot;regatom()&quot;</span>,
    <span class="Li">&quot;reg()&quot;</span>,
    <span class="Li">&quot;regbranch()&quot;</span> <i>etc</i> multiple times,
    until the deepest level of nesting is reached. All the above routines return
    a pointer to a <span class="Li">&quot;regnode&quot;</span>, which is usually
    the last regnode added to the program. However, one complication is that
    <b>reg()</b> returns NULL for parsing
    <span class="Li">&quot;(?:)&quot;</span> syntax for embedded modifiers,
    setting the flag <span class="Li">&quot;TRYAGAIN&quot;</span>. The
    <span class="Li">&quot;TRYAGAIN&quot;</span> propagates upwards until it is
    captured, in some cases by <span class="Li">&quot;regatom()&quot;</span>,
    but otherwise unconditionally by
    <span class="Li">&quot;regbranch()&quot;</span>. Hence it will never be
    returned by <span class="Li">&quot;regbranch()&quot;</span> to
    <span class="Li">&quot;reg()&quot;</span>. This flag permits patterns such
    as <span class="Li">&quot;(?i)+&quot;</span> to be detected as errors
    (<i>Quantifier follows nothing in regex; marked by &lt;-- HERE in
    m/(?i)+</i> <i>&lt;-- HERE /</i>).</p>
<p class="Pp">Another complication is that the representation used for the
    program differs if it needs to store Unicode, but it's not always possible
    to know for sure whether it does until midway through parsing. The Unicode
    representation for the program is larger, and cannot be matched as
    efficiently. (See &quot;Unicode and Localisation Support&quot; below for
    more details as to why.) If the pattern contains literal Unicode, it's
    obvious that the program needs to store Unicode. Otherwise, the parser
    optimistically assumes that the more efficient representation can be used,
    and starts sizing on this basis. However, if it then encounters something in
    the pattern which must be stored as Unicode, such as an
    <span class="Li">&quot;\x{...}&quot;</span> escape sequence representing a
    character literal, then this means that all previously calculated sizes need
    to be redone, using values appropriate for the Unicode representation. This
    is another instance where the parsing needs to be restarted, and it can and
    is done immediately. The function returns failure, and sets the flag
    <span class="Li">&quot;RESTART_UTF8&quot;</span> (encapsulated by using the
    macro <span class="Li">&quot;REQUIRE_UTF8&quot;</span>). This restart
    request is propagated up the call chain in a similar fashion, until it is
    &quot;caught&quot; in
    <span class="Li">&quot;Perl_re_op_compile()&quot;</span>, which marks the
    pattern as containing Unicode, and restarts the sizing pass. It is also
    possible for constructions within run-time code blocks to turn out to need
    Unicode representation., which is signalled by
    <span class="Li">&quot;S_compile_runtime_code()&quot;</span> returning false
    to <span class="Li">&quot;Perl_re_op_compile()&quot;</span>.</p>
<p class="Pp">The restart was previously implemented using a
    <span class="Li">&quot;longjmp&quot;</span> in
    <span class="Li">&quot;regatom()&quot;</span> back to a
    <span class="Li">&quot;setjmp&quot;</span> in
    <span class="Li">&quot;Perl_re_op_compile()&quot;</span>, but this proved to
    be problematic as the latter is a large function containing many automatic
    variables, which interact badly with the emergent control flow of
    <span class="Li">&quot;setjmp&quot;</span>.</p>
<p class="Pp"><i>Debug Output</i></p>
<p class="Pp">Starting in the 5.9.x development version of perl you can
    <span class="Li">&quot;use re</span> <span class="Li">Debug =&gt;
    'PARSE'&quot;</span> to see some trace information about the parse process.
    We will start with some simple patterns and build up to more complex
    patterns.</p>
<p class="Pp">So when we parse <span class="Li">&quot;/foo/&quot;</span> we see
    something like the following table. The left shows what is being parsed, and
    the number indicates where the next regop would go. The stuff on the right
    is the trace output of the graph. The names are chosen to be short to make
    it less dense on the screen. 'tsdy' is a special form of
    <span class="Li">&quot;regtail()&quot;</span> which does some extra
    analysis.</p>
<p class="Pp"></p>
<pre> &gt;foo&lt;             1    reg
                          brnc
                            piec
                              atom
 &gt;&lt;                4      tsdy~ EXACT &lt;foo&gt; (EXACT) (1)
                              ~ attach to END (3) offset to 2
</pre>
<p class="Pp">The resulting program then looks like:</p>
<p class="Pp"></p>
<pre>   1: EXACT &lt;foo&gt;(3)
   3: END(0)
</pre>
<p class="Pp">As you can see, even though we parsed out a branch and a piece, it
    was ultimately only an atom. The final program shows us how things work. We
    have an <span class="Li">&quot;EXACT&quot;</span> regop, followed by an
    <span class="Li">&quot;END&quot;</span> regop. The number in parens
    indicates where the <span class="Li">&quot;regnext&quot;</span> of the node
    goes. The <span class="Li">&quot;regnext&quot;</span> of an
    <span class="Li">&quot;END&quot;</span> regop is unused, as
    <span class="Li">&quot;END&quot;</span> regops mean we have successfully
    matched. The number on the left indicates the position of the regop in the
    regnode array.</p>
<p class="Pp">Now let's try a harder pattern. We will add a quantifier, so now
    we have the pattern <span class="Li">&quot;/foo+/&quot;</span>. We will see
    that <span class="Li">&quot;regbranch()&quot;</span> calls
    <span class="Li">&quot;regpiece()&quot;</span> twice.</p>
<p class="Pp"></p>
<pre> &gt;foo+&lt;            1    reg
                          brnc
                            piec
                              atom
 &gt;o+&lt;              3        piec
                              atom
 &gt;&lt;                6        tail~ EXACT &lt;fo&gt; (1)
                   7      tsdy~ EXACT &lt;fo&gt; (EXACT) (1)
                              ~ PLUS (END) (3)
                              ~ attach to END (6) offset to 3
</pre>
<p class="Pp">And we end up with the program:</p>
<p class="Pp"></p>
<pre>   1: EXACT &lt;fo&gt;(3)
   3: PLUS(6)
   4:   EXACT &lt;o&gt;(0)
   6: END(0)
</pre>
<p class="Pp">Now we have a special case. The
    <span class="Li">&quot;EXACT&quot;</span> regop has a
    <span class="Li">&quot;regnext&quot;</span> of 0. This is because if it
    matches it should try to match itself again. The
    <span class="Li">&quot;PLUS&quot;</span> regop handles the actual failure of
    the <span class="Li">&quot;EXACT&quot;</span> regop and acts appropriately
    (going to regnode 6 if the <span class="Li">&quot;EXACT&quot;</span> matched
    at least once, or failing if it didn't).</p>
<p class="Pp">Now for something much more complex:
    <span class="Li">&quot;/x(?:foo*|b[a][rR])(foo|bar)$/&quot;</span></p>
<p class="Pp"></p>
<pre> &gt;x(?:foo*|b...    1    reg
                          brnc
                            piec
                              atom
 &gt;(?:foo*|b[...    3        piec
                              atom
 &gt;?:foo*|b[a...                 reg
 &gt;foo*|b[a][...                   brnc
                                    piec
                                      atom
 &gt;o*|b[a][rR...    5                piec
                                      atom
 &gt;|b[a][rR])...    8                tail~ EXACT &lt;fo&gt; (3)
 &gt;b[a][rR])(...    9              brnc
                  10                piec
                                      atom
 &gt;[a][rR])(f...   12                piec
                                      atom
 &gt;a][rR])(fo...                         clas
 &gt;[rR])(foo|...   14                tail~ EXACT &lt;b&gt; (10)
                                    piec
                                      atom
 &gt;rR])(foo|b...                         clas
 &gt;)(foo|bar)...   25                tail~ EXACT &lt;a&gt; (12)
                                  tail~ BRANCH (3)
                  26              tsdy~ BRANCH (END) (9)
                                      ~ attach to TAIL (25) offset to 16
                                  tsdy~ EXACT &lt;fo&gt; (EXACT) (4)
                                      ~ STAR (END) (6)
                                      ~ attach to TAIL (25) offset to 19
                                  tsdy~ EXACT &lt;b&gt; (EXACT) (10)
                                      ~ EXACT &lt;a&gt; (EXACT) (12)
                                      ~ ANYOF[Rr] (END) (14)
                                      ~ attach to TAIL (25) offset to 11
 &gt;(foo|bar)$&lt;               tail~ EXACT &lt;x&gt; (1)
                            piec
                              atom
 &gt;foo|bar)$&lt;                    reg
                  28              brnc
                                    piec
                                      atom
 &gt;|bar)$&lt;         31              tail~ OPEN1 (26)
 &gt;bar)$&lt;                          brnc
                  32                piec
                                      atom
 &gt;)$&lt;             34              tail~ BRANCH (28)
                  36              tsdy~ BRANCH (END) (31)
                                     ~ attach to CLOSE1 (34) offset to 3
                                  tsdy~ EXACT &lt;foo&gt; (EXACT) (29)
                                     ~ attach to CLOSE1 (34) offset to 5
                                  tsdy~ EXACT &lt;bar&gt; (EXACT) (32)
                                     ~ attach to CLOSE1 (34) offset to 2
 &gt;$&lt;                        tail~ BRANCH (3)
                                ~ BRANCH (9)
                                ~ TAIL (25)
                            piec
                              atom
 &gt;&lt;               37        tail~ OPEN1 (26)
                                ~ BRANCH (28)
                                ~ BRANCH (31)
                                ~ CLOSE1 (34)
                  38      tsdy~ EXACT &lt;x&gt; (EXACT) (1)
                              ~ BRANCH (END) (3)
                              ~ BRANCH (END) (9)
                              ~ TAIL (END) (25)
                              ~ OPEN1 (END) (26)
                              ~ BRANCH (END) (28)
                              ~ BRANCH (END) (31)
                              ~ CLOSE1 (END) (34)
                              ~ EOL (END) (36)
                              ~ attach to END (37) offset to 1
</pre>
<p class="Pp">Resulting in the program</p>
<p class="Pp"></p>
<pre>   1: EXACT &lt;x&gt;(3)
   3: BRANCH(9)
   4:   EXACT &lt;fo&gt;(6)
   6:   STAR(26)
   7:     EXACT &lt;o&gt;(0)
   9: BRANCH(25)
  10:   EXACT &lt;ba&gt;(14)
  12:   OPTIMIZED (2 nodes)
  14:   ANYOF[Rr](26)
  25: TAIL(26)
  26: OPEN1(28)
  28:   TRIE-EXACT(34)
        [StS:1 Wds:2 Cs:6 Uq:5 #Sts:7 Mn:3 Mx:3 Stcls:bf]
          &lt;foo&gt;
          &lt;bar&gt;
  30:   OPTIMIZED (4 nodes)
  34: CLOSE1(36)
  36: EOL(37)
  37: END(0)
</pre>
<p class="Pp">Here we can see a much more complex program, with various
    optimisations in play. At regnode 10 we see an example where a character
    class with only one character in it was turned into an
    <span class="Li">&quot;EXACT&quot;</span> node. We can also see where an
    entire alternation was turned into a
    <span class="Li">&quot;TRIE-EXACT&quot;</span> node. As a consequence, some
    of the regnodes have been marked as optimised away. We can see that the
    <span class="Li">&quot;$&quot;</span> symbol has been converted into an
    <span class="Li">&quot;EOL&quot;</span> regop, a special piece of code that
    looks for <span class="Li">&quot;\n&quot;</span> or the end of the
  string.</p>
<p class="Pp">The next pointer for <span class="Li">&quot;BRANCH&quot;</span>es
    is interesting in that it points at where execution should go if the branch
    fails. When executing, if the engine tries to traverse from a branch to a
    <span class="Li">&quot;regnext&quot;</span> that isn't a branch then the
    engine will know that the entire set of branches has failed.</p>
<p class="Pp"><i>Peep-hole Optimisation and Analysis</i></p>
<p class="Pp">The regular expression engine can be a weighty tool to wield. On
    long strings and complex patterns it can end up having to do a lot of work
    to find a match, and even more to decide that no match is possible. Consider
    a situation like the following pattern.</p>
<p class="Pp"></p>
<pre>   'ababababababababababab' =~ /(a|b)*z/
</pre>
<p class="Pp">The <span class="Li">&quot;(a|b)*&quot;</span> part can match at
    every char in the string, and then fail every time because there is no
    <span class="Li">&quot;z&quot;</span> in the string. So obviously we can
    avoid using the regex engine unless there is a
    <span class="Li">&quot;z&quot;</span> in the string. Likewise in a pattern
    like:</p>
<p class="Pp"></p>
<pre>   /foo(\w+)bar/
</pre>
<p class="Pp">In this case we know that the string must contain a
    <span class="Li">&quot;foo&quot;</span> which must be followed by
    <span class="Li">&quot;bar&quot;</span>. We can use Fast Boyer-Moore
    matching as implemented in <span class="Li">&quot;fbm_instr()&quot;</span>
    to find the location of these strings. If they don't exist then we don't
    need to resort to the much more expensive regex engine. Even better, if they
    do exist then we can use their positions to reduce the search space that the
    regex engine needs to cover to determine if the entire pattern matches.</p>
<p class="Pp">There are various aspects of the pattern that can be used to
    facilitate optimisations along these lines:</p>
<ul class="Bl-bullet">
  <li>anchored fixed strings</li>
  <li>floating fixed strings</li>
  <li>minimum and maximum length requirements</li>
  <li>start class</li>
  <li>Beginning/End of line positions</li>
</ul>
<p class="Pp">Another form of optimisation that can occur is the post-parse
    &quot;peep-hole&quot; optimisation, where inefficient constructs are
    replaced by more efficient constructs. The
    <span class="Li">&quot;TAIL&quot;</span> regops which are used during
    parsing to mark the end of branches and the end of groups are examples of
    this. These regops are used as place-holders during construction and
    &quot;always match&quot; so they can be &quot;optimised away&quot; by making
    the things that point to the <span class="Li">&quot;TAIL&quot;</span> point
    to the thing that <span class="Li">&quot;TAIL&quot;</span> points to, thus
    &quot;skipping&quot; the node.</p>
<p class="Pp">Another optimisation that can occur is that of
    &quot;<span class="Li">&quot;EXACT&quot;</span> merging&quot; which is where
    two consecutive <span class="Li">&quot;EXACT&quot;</span> nodes are merged
    into a single regop. An even more aggressive form of this is that a branch
    sequence of the form <span class="Li">&quot;EXACT BRANCH ...
    EXACT&quot;</span> can be converted into a
    <span class="Li">&quot;TRIE-EXACT&quot;</span> regop.</p>
<p class="Pp">All of this occurs in the routine
    <span class="Li">&quot;study_chunk()&quot;</span> which uses a special
    structure <span class="Li">&quot;scan_data_t&quot;</span> to store the
    analysis that it has performed, and does the &quot;peep-hole&quot;
    optimisations as it goes.</p>
<p class="Pp">The code involved in
    <span class="Li">&quot;study_chunk()&quot;</span> is extremely cryptic. Be
    careful. :-)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Execution"><a class="permalink" href="#Execution">Execution</a></h2>
<p class="Pp">Execution of a regex generally involves two phases, the first
    being finding the start point in the string where we should match from, and
    the second being running the regop interpreter.</p>
<p class="Pp">If we can tell that there is no valid start point then we don't
    bother running the interpreter at all. Likewise, if we know from the
    analysis phase that we cannot detect a short-cut to the start position, we
    go straight to the interpreter.</p>
<p class="Pp">The two entry points are
    <span class="Li">&quot;re_intuit_start()&quot;</span> and
    <span class="Li">&quot;pregexec()&quot;</span>. These routines have a
    somewhat incestuous relationship with overlap between their functions, and
    <span class="Li">&quot;pregexec()&quot;</span> may even call
    <span class="Li">&quot;re_intuit_start()&quot;</span> on its own.
    Nevertheless other parts of the perl source code may call into either, or
    both.</p>
<p class="Pp">Execution of the interpreter itself used to be recursive, but
    thanks to the efforts of Dave Mitchell in the 5.9.x development track, that
    has changed: now an internal stack is maintained on the heap and the routine
    is fully iterative. This can make it tricky as the code is quite
    conservative about what state it stores, with the result that two
    consecutive lines in the code can actually be running in totally different
    contexts due to the simulated recursion.</p>
<p class="Pp"><i>Start position and no-match optimisations</i></p>
<p class="Pp"><span class="Li">&quot;re_intuit_start()&quot;</span> is
    responsible for handling start points and no-match optimisations as
    determined by the results of the analysis done by
    <span class="Li">&quot;study_chunk()&quot;</span> (and described in
    &quot;Peep-hole Optimisation and Analysis&quot;).</p>
<p class="Pp">The basic structure of this routine is to try to find the start-
    and/or end-points of where the pattern could match, and to ensure that the
    string is long enough to match the pattern. It tries to use more efficient
    methods over less efficient methods and may involve considerable
    cross-checking of constraints to find the place in the string that matches.
    For instance it may try to determine that a given fixed string must be not
    only present but a certain number of chars before the end of the string, or
    whatever.</p>
<p class="Pp">It calls several other routines, such as
    <span class="Li">&quot;fbm_instr()&quot;</span> which does Fast Boyer Moore
    matching and <span class="Li">&quot;find_byclass()&quot;</span> which is
    responsible for finding the start using the first mandatory regop in the
    program.</p>
<p class="Pp">When the optimisation criteria have been satisfied,
    <span class="Li">&quot;reg_try()&quot;</span> is called to perform the
    match.</p>
<p class="Pp"><i>Program execution</i></p>
<p class="Pp"><span class="Li">&quot;pregexec()&quot;</span> is the main entry
    point for running a regex. It contains support for initialising the regex
    interpreter's state, running
    <span class="Li">&quot;re_intuit_start()&quot;</span> if needed, and running
    the interpreter on the string from various start positions as needed. When
    it is necessary to use the regex interpreter
    <span class="Li">&quot;pregexec()&quot;</span> calls
    <span class="Li">&quot;regtry()&quot;</span>.</p>
<p class="Pp"><span class="Li">&quot;regtry()&quot;</span> is the entry point
    into the regex interpreter. It expects as arguments a pointer to a
    <span class="Li">&quot;regmatch_info&quot;</span> structure and a pointer to
    a string. It returns an integer 1 for success and a 0 for failure. It is
    basically a set-up wrapper around
    <span class="Li">&quot;regmatch()&quot;</span>.</p>
<p class="Pp"><span class="Li">&quot;regmatch&quot;</span> is the main
    &quot;recursive loop&quot; of the interpreter. It is basically a giant
    switch statement that implements a state machine, where the possible states
    are the regops themselves, plus a number of additional intermediate and
    failure states. A few of the states are implemented as subroutines but the
    bulk are inline code.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="MISCELLANEOUS"><a class="permalink" href="#MISCELLANEOUS">MISCELLANEOUS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Unicode_and_Localisation_Support"><a class="permalink" href="#Unicode_and_Localisation_Support">Unicode
  and Localisation Support</a></h2>
<p class="Pp">When dealing with strings containing characters that cannot be
    represented using an eight-bit character set, perl uses an internal
    representation that is a permissive version of Unicode's UTF-8 encoding[2].
    This uses single bytes to represent characters from the ASCII character set,
    and sequences of two or more bytes for all other characters. (See perlunitut
    for more information about the relationship between UTF-8 and perl's
    encoding, utf8. The difference isn't important for this discussion.)</p>
<p class="Pp">No matter how you look at it, Unicode support is going to be a
    pain in a regex engine. Tricks that might be fine when you have 256 possible
    characters often won't scale to handle the size of the UTF-8 character set.
    Things you can take for granted with ASCII may not be true with Unicode. For
    instance, in ASCII, it is safe to assume that
    <span class="Li">&quot;sizeof(char1) == sizeof(char2)&quot;</span>, but in
    UTF-8 it isn't. Unicode case folding is vastly more complex than the simple
    rules of ASCII, and even when not using Unicode but only localised single
    byte encodings, things can get tricky (for example, <b>LATIN SMALL LETTER
    SHARP S</b> (U+00DF, ss) should match 'SS' in localised case-insensitive
    matching).</p>
<p class="Pp">Making things worse is that UTF-8 support was a later addition to
    the regex engine (as it was to perl) and this necessarily made things a lot
    more complicated. Obviously it is easier to design a regex engine with
    Unicode support in mind from the beginning than it is to retrofit it to one
    that wasn't.</p>
<p class="Pp">Nearly all regops that involve looking at the input string have
    two cases, one for UTF-8, and one not. In fact, it's often more complex than
    that, as the pattern may be UTF-8 as well.</p>
<p class="Pp">Care must be taken when making changes to make sure that you
    handle UTF-8 properly, both at compile time and at execution time, including
    when the string and pattern are mismatched.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Base_Structures"><a class="permalink" href="#Base_Structures">Base
  Structures</a></h2>
<p class="Pp">The <span class="Li">&quot;regexp&quot;</span> structure described
    in perlreapi is common to all regex engines. Two of its fields are intended
    for the private use of the regex engine that compiled the pattern. These are
    the <span class="Li">&quot;intflags&quot;</span> and pprivate members. The
    <span class="Li">&quot;pprivate&quot;</span> is a void pointer to an
    arbitrary structure whose use and management is the responsibility of the
    compiling engine. perl will never modify either of these values. In the case
    of the stock engine the structure pointed to by
    <span class="Li">&quot;pprivate&quot;</span> is called
    <span class="Li">&quot;regexp_internal&quot;</span>.</p>
<p class="Pp">Its <span class="Li">&quot;pprivate&quot;</span> and
    <span class="Li">&quot;intflags&quot;</span> fields contain data specific to
    each engine.</p>
<p class="Pp">There are two structures used to store a compiled regular
    expression. One, the <span class="Li">&quot;regexp&quot;</span> structure
    described in perlreapi is populated by the engine currently being. used and
    some of its fields read by perl to implement things such as the
    stringification of <span class="Li">&quot;qr//&quot;</span>.</p>
<p class="Pp">The other structure is pointed to by the
    <span class="Li">&quot;regexp&quot;</span> struct's
    <span class="Li">&quot;pprivate&quot;</span> and is in addition to
    <span class="Li">&quot;intflags&quot;</span> in the same struct considered
    to be the property of the regex engine which compiled the regular
    expression;</p>
<p class="Pp">The regexp structure contains all the data that perl needs to be
    aware of to properly work with the regular expression. It includes data
    about optimisations that perl can use to determine if the regex engine
    should really be used, and various other control info that is needed to
    properly execute patterns in various contexts such as is the pattern
    anchored in some way, or what flags were used during the compile, or whether
    the program contains special constructs that perl needs to be aware of.</p>
<p class="Pp">In addition it contains two fields that are intended for the
    private use of the regex engine that compiled the pattern. These are the
    <span class="Li">&quot;intflags&quot;</span> and pprivate members. The
    <span class="Li">&quot;pprivate&quot;</span> is a void pointer to an
    arbitrary structure whose use and management is the responsibility of the
    compiling engine. perl will never modify either of these values.</p>
<p class="Pp">As mentioned earlier, in the case of the default engines, the
    <span class="Li">&quot;pprivate&quot;</span> will be a pointer to a
    regexp_internal structure which holds the compiled program and any
    additional data that is private to the regex engine implementation.</p>
<p class="Pp"><i>Perl's
    </i><span class="Li"><i>&quot;pprivate&quot;</i></span><i> structure</i></p>
<p class="Pp">The following structure is used as the
    <span class="Li">&quot;pprivate&quot;</span> struct by perl's regex engine.
    Since it is specific to perl it is only of curiosity value to other engine
    implementations.</p>
<p class="Pp"></p>
<pre> typedef struct regexp_internal {
         U32 *offsets;           /* offset annotations 20001228 MJD
                                  * data about mapping the program to
                                  * the string*/
         regnode *regstclass;    /* Optional startclass as identified or
                                  * constructed by the optimiser */
         struct reg_data *data;  /* Additional miscellaneous data used
                                  * by the program.  Used to make it
                                  * easier to clone and free arbitrary
                                  * data that the regops need. Often the
                                  * ARG field of a regop is an index
                                  * into this structure */
         regnode program[1];     /* Unwarranted chumminess with
                                  * compiler. */
 } regexp_internal;
</pre>
<dl class="Bl-tag">
  <dt>&quot;offsets&quot;</dt>
  <dd>Offsets holds a mapping of offset in the
      <span class="Li">&quot;program&quot;</span> to offset in the
      <span class="Li">&quot;precomp&quot;</span> string. This is only used by
      ActiveState's visual regex debugger.</dd>
  <dt>&quot;regstclass&quot;</dt>
  <dd>Special regop that is used by
      <span class="Li">&quot;re_intuit_start()&quot;</span> to check if a
      pattern can match at a certain position. For instance if the regex engine
      knows that the pattern must start with a 'Z' then it can scan the string
      until it finds one and then launch the regex engine from there. The
      routine that handles this is called
      <span class="Li">&quot;find_by_class()&quot;</span>. Sometimes this field
      points at a regop embedded in the program, and sometimes it points at an
      independent synthetic regop that has been constructed by the
    optimiser.</dd>
  <dt>&quot;data&quot;</dt>
  <dd>This field points at a <span class="Li">&quot;reg_data&quot;</span>
      structure, which is defined as follows
    <p class="Pp"></p>
    <pre>    struct reg_data {
        U32 count;
        U8 *what;
        void* data[1];
    };
    </pre>
    <p class="Pp">This structure is used for handling data structures that the
        regex engine needs to handle specially during a clone or free operation
        on the compiled product. Each element in the data array has a
        corresponding element in the what array. During compilation regops that
        need special structures stored will add an element to each array using
        the <b>add_data()</b> routine and then store the index in the regop.</p>
  </dd>
  <dt>&quot;program&quot;</dt>
  <dd>Compiled program. Inlined into the structure so the entire struct can be
      treated as a single blob.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">perlreapi</p>
<p class="Pp">perlre</p>
<p class="Pp">perlunitut</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">by Yves Orton, 2006.</p>
<p class="Pp">With excerpts from Perl, and contributions and suggestions from
    Ronald J. Kimball, Dave Mitchell, Dominic Dunlop, Mark Jason Dominus,
    Stephen McCamant, and David Landgren.</p>
<p class="Pp">Now maintained by Perl 5 Porters.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENCE"><a class="permalink" href="#LICENCE">LICENCE</a></h1>
<p class="Pp">Same terms as Perl.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="REFERENCES"><a class="permalink" href="#REFERENCES">REFERENCES</a></h1>
<p class="Pp">[1] &lt;https://perl.plover.com/Rx/paper/&gt;</p>
<p class="Pp">[2] &lt;https://www.unicode.org/&gt;</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os">perl v5.34.1</td>
  </tr>
</table>
</body>
</html>

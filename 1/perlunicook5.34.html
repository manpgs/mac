<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PERLUNICOOK(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLUNICOOK(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLUNICOOK(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlunicook - cookbookish examples of handling Unicode in Perl</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This manpage contains short recipes demonstrating how to handle
    common Unicode operations in Perl, plus one complete program at the end. Any
    undeclared variables in individual recipes are assumed to have a previous
    appropriate value in them.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<section class="Ss">
<h2 class="Ss" id="X_0:_Standard_preamble"><a class="permalink" href="#X_0:_Standard_preamble">X
  0: Standard preamble</a></h2>
<p class="Pp">Unless otherwise notes, all examples below require this standard
    preamble to work correctly, with the <span class="Li">&quot;#!&quot;</span>
    adjusted to work on your system:</p>
<p class="Pp"></p>
<pre> #!/usr/bin/env perl
 use utf8;      # so literals and identifiers can be in UTF-8
 use v5.12;     # or later to get &quot;unicode_strings&quot; feature
 use strict;    # quote strings, declare variables
 use warnings;  # on by default
 use warnings  qw(FATAL utf8);    # fatalize encoding glitches
 use open      qw(:std :encoding(UTF-8)); # undeclared streams in UTF-8
 use charnames qw(:full :short);  # unneeded in v5.16
</pre>
<p class="Pp">This <i>does</i> make even Unix programmers
    <span class="Li">&quot;binmode&quot;</span> your binary streams, or open
    them with <span class="Li">&quot;:raw&quot;</span>, but that's the only way
    to get at them portably anyway.</p>
<p class="Pp"><b>WARNING</b>: <span class="Li">&quot;use autodie&quot;</span>
    (pre 2.26) and <span class="Li">&quot;use open&quot;</span> do not get along
    with each other.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="X_1:_Generic_Unicode-savvy_filter"><a class="permalink" href="#X_1:_Generic_Unicode-savvy_filter">X
  1: Generic Unicode-savvy filter</a></h2>
<p class="Pp">Always decompose on the way in, then recompose on the way out.</p>
<p class="Pp"></p>
<pre> use Unicode::Normalize;
 while (&lt;&gt;) {
     $_ = NFD($_);   # decompose + reorder canonically
     ...
 } continue {
     print NFC($_);  # recompose (where possible) + reorder canonically
 }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_2:_Fine-tuning_Unicode_warnings"><a class="permalink" href="#X_2:_Fine-tuning_Unicode_warnings">X
  2: Fine-tuning Unicode warnings</a></h2>
<p class="Pp">As of v5.14, Perl distinguishes three subclasses of UTFX8
    warnings.</p>
<p class="Pp"></p>
<pre> use v5.14;                  # subwarnings unavailable any earlier
 no warnings &quot;nonchar&quot;;      # the 66 forbidden non-characters
 no warnings &quot;surrogate&quot;;    # UTF-16/CESU-8 nonsense
 no warnings &quot;non_unicode&quot;;  # for codepoints over 0x10_FFFF
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_3:_Declare_source_in_utf8_for_identifiers_and_literals"><a class="permalink" href="#X_3:_Declare_source_in_utf8_for_identifiers_and_literals">X
  3: Declare source in utf8 for identifiers and literals</a></h2>
<p class="Pp">Without the all-critical <span class="Li">&quot;use
    utf8&quot;</span> declaration, putting UTFX8 in your literals and
    identifiers wonXt work right. If you used the standard preamble just given
    above, this already happened. If you did, you can do things like this:</p>
<p class="Pp"></p>
<pre> use utf8;
 my $measure   = &quot;Aangstroem&quot;;
 my @Xsoft     = qw( cp852 cp1251 cp1252 );
 my @XXXXXXXXX = qw( XXXX  XXXXX );
 my @X        = qw( koi8-f koi8-u koi8-r );
 my $motto     = &quot;X X X&quot;; # FAMILY, GROWING HEART, DROMEDARY CAMEL
</pre>
<p class="Pp">If you forget <span class="Li">&quot;use utf8&quot;</span>, high
    bytes will be misunderstood as separate characters, and nothing will work
    right.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="X_4:_Characters_and_their_numbers"><a class="permalink" href="#X_4:_Characters_and_their_numbers">X
  4: Characters and their numbers</a></h2>
<p class="Pp">The <span class="Li">&quot;ord&quot;</span> and
    <span class="Li">&quot;chr&quot;</span> functions work transparently on all
    codepoints, not just on ASCII alone X nor in fact, not even just on Unicode
    alone.</p>
<p class="Pp"></p>
<pre> # ASCII characters
 ord(&quot;A&quot;)
 chr(65)
 # characters from the Basic Multilingual Plane
 ord(&quot;X&quot;)
 chr(0x3A3)
 # beyond the BMP
 ord(&quot;X&quot;)               # MATHEMATICAL ITALIC SMALL N
 chr(0x1D45B)
 # beyond Unicode! (up to MAXINT)
 ord(&quot;\x{20_0000}&quot;)
 chr(0x20_0000)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_5:_Unicode_literals_by_character_number"><a class="permalink" href="#X_5:_Unicode_literals_by_character_number">X
  5: Unicode literals by character number</a></h2>
<p class="Pp">In an interpolated literal, whether a double-quoted string or a
    regex, you may specify a character by its number using the
    <span class="Li">&quot;\x{</span><span class="Li"><i>HHHHHH</i></span><span class="Li">}&quot;</span>
    escape.</p>
<p class="Pp"></p>
<pre> String: &quot;\x{3a3}&quot;
 Regex:  /\x{3a3}/
 String: &quot;\x{1d45b}&quot;
 Regex:  /\x{1d45b}/
 # even non-BMP ranges in regex work fine
 /[\x{1D434}-\x{1D467}]/
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_6:_Get_character_name_by_number"><a class="permalink" href="#X_6:_Get_character_name_by_number">X
  6: Get character name by number</a></h2>
<pre> use charnames ();
 my $name = charnames::viacode(0x03A3);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_7:_Get_character_number_by_name"><a class="permalink" href="#X_7:_Get_character_number_by_name">X
  7: Get character number by name</a></h2>
<pre> use charnames ();
 my $number = charnames::vianame(&quot;GREEK CAPITAL LETTER SIGMA&quot;);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_8:_Unicode_named_characters"><a class="permalink" href="#X_8:_Unicode_named_characters">X
  8: Unicode named characters</a></h2>
<p class="Pp">Use the
    <span class="Li">&quot;\N{</span><span class="Li"><i>charname</i></span><span class="Li">}&quot;</span>
    notation to get the character by that name for use in interpolated literals
    (double-quoted strings and regexes). In v5.16, there is an implicit</p>
<p class="Pp"></p>
<pre> use charnames qw(:full :short);
</pre>
<p class="Pp">But prior to v5.16, you must be explicit about which set of
    charnames you want. The <span class="Li">&quot;:full&quot;</span> names are
    the official Unicode character name, alias, or sequence, which all share a
    namespace.</p>
<p class="Pp"></p>
<pre> use charnames qw(:full :short latin greek);
 &quot;\N{MATHEMATICAL ITALIC SMALL N}&quot;      # :full
 &quot;\N{GREEK CAPITAL LETTER SIGMA}&quot;       # :full
</pre>
<p class="Pp">Anything else is a Perl-specific convenience abbreviation. Specify
    one or more scripts by names if you want short names that are
    script-specific.</p>
<p class="Pp"></p>
<pre> &quot;\N{Greek:Sigma}&quot;                      # :short
 &quot;\N{ae}&quot;                               #  latin
 &quot;\N{epsilon}&quot;                          #  greek
</pre>
<p class="Pp">The v5.16 release also supports a
    <span class="Li">&quot;:loose&quot;</span> import for loose matching of
    character names, which works just like loose matching of property names:
    that is, it disregards case, whitespace, and underscores:</p>
<p class="Pp"></p>
<pre> &quot;\N{euro sign}&quot;                        # :loose (from v5.16)
</pre>
<p class="Pp">Starting in v5.32, you can also use</p>
<p class="Pp"></p>
<pre> qr/\p{name=euro sign}/
</pre>
<p class="Pp">to get official Unicode named characters in regular expressions.
    Loose matching is always done for these.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="X_9:_Unicode_named_sequences"><a class="permalink" href="#X_9:_Unicode_named_sequences">X
  9: Unicode named sequences</a></h2>
<p class="Pp">These look just like character names but return multiple
    codepoints. Notice the <span class="Li">%vx</span> vector-print
    functionality in <span class="Li">&quot;printf&quot;</span>.</p>
<p class="Pp"></p>
<pre> use charnames qw(:full);
 my $seq = &quot;\N{LATIN CAPITAL LETTER A WITH MACRON AND GRAVE}&quot;;
 printf &quot;U+%v04X\n&quot;, $seq;
 U+0100.0300
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_10:_Custom_named_characters"><a class="permalink" href="#X_10:_Custom_named_characters">X
  10: Custom named characters</a></h2>
<p class="Pp">Use <span class="Li">&quot;:alias&quot;</span> to give your own
    lexically scoped nicknames to existing characters, or even to give unnamed
    private-use characters useful names.</p>
<p class="Pp"></p>
<pre> use charnames &quot;:full&quot;, &quot;:alias&quot; =&gt; {
     ecute =&gt; &quot;LATIN SMALL LETTER E WITH ACUTE&quot;,
     &quot;APPLE LOGO&quot; =&gt; 0xF8FF, # private use character
 };
 &quot;\N{ecute}&quot;
 &quot;\N{APPLE LOGO}&quot;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_11:_Names_of_"><a class="permalink" href="#X_11:_Names_of_">X
  11: Names of CJK codepoints</a></h2>
<p class="Pp">Sinograms like XXXX come back with character names of
    <span class="Li">&quot;CJK UNIFIED IDEOGRAPH-6771&quot;</span> and
    <span class="Li">&quot;CJK UNIFIED IDEOGRAPH-4EAC&quot;</span>, because
    their XnamesX vary. The CPAN
    <span class="Li">&quot;Unicode::Unihan&quot;</span> module has a large
    database for decoding these (and a whole lot more), provided you know how to
    understand its output.</p>
<p class="Pp"></p>
<pre> # cpan -i Unicode::Unihan
 use Unicode::Unihan;
 my $str = &quot;XX&quot;;
 my $unhan = Unicode::Unihan-&gt;new;
 for my $lang (qw(Mandarin Cantonese Korean JapaneseOn JapaneseKun)) {
     printf &quot;CJK $str in %-12s is &quot;, $lang;
     say $unhan-&gt;$lang($str);
 }
</pre>
<p class="Pp">prints:</p>
<p class="Pp"></p>
<pre> CJK XX in Mandarin     is DONG1JING1
 CJK XX in Cantonese    is dung1ging1
 CJK XX in Korean       is TONGKYENG
 CJK XX in JapaneseOn   is TOUKYOU KEI KIN
 CJK XX in JapaneseKun  is HIGASHI AZUMAMIYAKO
</pre>
<p class="Pp">If you have a specific romanization scheme in mind, use the
    specific module:</p>
<p class="Pp"></p>
<pre> # cpan -i Lingua::JA::Romanize::Japanese
 use Lingua::JA::Romanize::Japanese;
 my $k2r = Lingua::JA::Romanize::Japanese-&gt;new;
 my $str = &quot;XX&quot;;
 say &quot;Japanese for $str is &quot;, $k2r-&gt;chars($str);
</pre>
<p class="Pp">prints</p>
<p class="Pp"></p>
<pre> Japanese for XX is toukyou
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_12:_Explicit_encode/decode"><a class="permalink" href="#X_12:_Explicit_encode/decode">X
  12: Explicit encode/decode</a></h2>
<p class="Pp">On rare occasion, such as a database read, you may be given
    encoded text you need to decode.</p>
<p class="Pp"></p>
<pre>  use Encode qw(encode decode);
  my $chars = decode(&quot;shiftjis&quot;, $bytes, 1);
 # OR
  my $bytes = encode(&quot;MIME-Header-ISO_2022_JP&quot;, $chars, 1);
</pre>
<p class="Pp">For streams all in the same encoding, don't use encode/decode;
    instead set the file encoding when you open the file or immediately after
    with <span class="Li">&quot;binmode&quot;</span> as described later
  below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="X_13:_Decode_program_arguments_as_utf8"><a class="permalink" href="#X_13:_Decode_program_arguments_as_utf8">X
  13: Decode program arguments as utf8</a></h2>
<pre>     $ perl -CA ...
 or
     $ export PERL_UNICODE=A
 or
    use Encode qw(decode);
    @ARGV = map { decode('UTF-8', $_, 1) } @ARGV;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_14:_Decode_program_arguments_as_locale_encoding"><a class="permalink" href="#X_14:_Decode_program_arguments_as_locale_encoding">X
  14: Decode program arguments as locale encoding</a></h2>
<pre>    # cpan -i Encode::Locale
    use Encode qw(locale);
    use Encode::Locale;
    # use &quot;locale&quot; as an arg to encode/decode
    @ARGV = map { decode(locale =&gt; $_, 1) } @ARGV;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_15:_Declare_STD_"><a class="permalink" href="#X_15:_Declare_STD_">X
  15: Declare STD{IN,OUT,ERR} to be utf8</a></h2>
<p class="Pp">Use a command-line option, an environment variable, or else call
    <span class="Li">&quot;binmode&quot;</span> explicitly:</p>
<p class="Pp"></p>
<pre>     $ perl -CS ...
 or
     $ export PERL_UNICODE=S
 or
     use open qw(:std :encoding(UTF-8));
 or
     binmode(STDIN,  &quot;:encoding(UTF-8)&quot;);
     binmode(STDOUT, &quot;:utf8&quot;);
     binmode(STDERR, &quot;:utf8&quot;);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_16:_Declare_STD_"><a class="permalink" href="#X_16:_Declare_STD_">X
  16: Declare STD{IN,OUT,ERR} to be in locale encoding</a></h2>
<pre>    # cpan -i Encode::Locale
    use Encode;
    use Encode::Locale;
    # or as a stream for binmode or open
    binmode STDIN,  &quot;:encoding(console_in)&quot;  if -t STDIN;
    binmode STDOUT, &quot;:encoding(console_out)&quot; if -t STDOUT;
    binmode STDERR, &quot;:encoding(console_out)&quot; if -t STDERR;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_17:_Make_file_I/O_default_to_utf8"><a class="permalink" href="#X_17:_Make_file_I/O_default_to_utf8">X
  17: Make file I/O default to utf8</a></h2>
<p class="Pp">Files opened without an encoding argument will be in UTF-8:</p>
<p class="Pp"></p>
<pre>     $ perl -CD ...
 or
     $ export PERL_UNICODE=D
 or
     use open qw(:encoding(UTF-8));
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_18:_Make_all_I/O_and_args_default_to_utf8"><a class="permalink" href="#X_18:_Make_all_I/O_and_args_default_to_utf8">X
  18: Make all I/O and args default to utf8</a></h2>
<pre>     $ perl -CSDA ...
 or
     $ export PERL_UNICODE=SDA
 or
     use open qw(:std :encoding(UTF-8));
     use Encode qw(decode);
     @ARGV = map { decode('UTF-8', $_, 1) } @ARGV;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_19:_Open_file_with_specific_encoding"><a class="permalink" href="#X_19:_Open_file_with_specific_encoding">X
  19: Open file with specific encoding</a></h2>
<p class="Pp">Specify stream encoding. This is the normal way to deal with
    encoded text, not by calling low-level functions.</p>
<p class="Pp"></p>
<pre> # input file
     open(my $in_file, &quot;&lt; :encoding(UTF-16)&quot;, &quot;wintext&quot;);
 OR
     open(my $in_file, &quot;&lt;&quot;, &quot;wintext&quot;);
     binmode($in_file, &quot;:encoding(UTF-16)&quot;);
 THEN
     my $line = &lt;$in_file&gt;;
 # output file
     open($out_file, &quot;&gt; :encoding(cp1252)&quot;, &quot;wintext&quot;);
 OR
     open(my $out_file, &quot;&gt;&quot;, &quot;wintext&quot;);
     binmode($out_file, &quot;:encoding(cp1252)&quot;);
 THEN
     print $out_file &quot;some text\n&quot;;
</pre>
<p class="Pp">More layers than just the encoding can be specified here. For
    example, the incantation <span class="Li">&quot;:raw :encoding(UTF-16LE)
    :crlf&quot;</span> includes implicit CRLF handling.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="X_20:_Unicode_casing"><a class="permalink" href="#X_20:_Unicode_casing">X
  20: Unicode casing</a></h2>
<p class="Pp">Unicode casing is very different from ASCII casing.</p>
<p class="Pp"></p>
<pre> uc(&quot;henry X&quot;)  # &quot;HENRY X&quot;
 uc(&quot;tschuess&quot;)   # &quot;TSCHUeSS&quot;  notice ss =&gt; SS
 # both are true:
 &quot;tschuess&quot;  =~ /TSCHUeSS/i   # notice ss =&gt; SS
 &quot;XXXXXXX&quot; =~ /XXXXXXX/i   # notice X,X,X sameness
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_21:_Unicode_case-insensitive_comparisons"><a class="permalink" href="#X_21:_Unicode_case-insensitive_comparisons">X
  21: Unicode case-insensitive comparisons</a></h2>
<p class="Pp">Also available in the CPAN Unicode::CaseFold module, the new
    <span class="Li">&quot;fc&quot;</span> XfoldcaseX function from v5.16 grants
    access to the same Unicode casefolding as the
    <span class="Li">&quot;/i&quot;</span> pattern modifier has always used:</p>
<p class="Pp"></p>
<pre> use feature &quot;fc&quot;; # fc() function is from v5.16
 # sort case-insensitively
 my @sorted = sort { fc($a) cmp fc($b) } @list;
 # both are true:
 fc(&quot;tschuess&quot;)  eq fc(&quot;TSCHUeSS&quot;)
 fc(&quot;XXXXXXX&quot;) eq fc(&quot;XXXXXXX&quot;)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_22:_Match_Unicode_linebreak_sequence_in_regex"><a class="permalink" href="#X_22:_Match_Unicode_linebreak_sequence_in_regex">X
  22: Match Unicode linebreak sequence in regex</a></h2>
<p class="Pp">A Unicode linebreak matches the two-character CRLF grapheme or any
    of seven vertical whitespace characters. Good for dealing with textfiles
    coming from different operating systems.</p>
<p class="Pp"></p>
<pre> \R
 s/\R/\n/g;  # normalize all linebreaks to \n
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_23:_Get_character_category"><a class="permalink" href="#X_23:_Get_character_category">X
  23: Get character category</a></h2>
<p class="Pp">Find the general category of a numeric codepoint.</p>
<p class="Pp"></p>
<pre> use Unicode::UCD qw(charinfo);
 my $cat = charinfo(0x3A3)-&gt;{category};  # &quot;Lu&quot;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_24:_Disabling_Unicode-awareness_in_builtin_charclasses"><a class="permalink" href="#X_24:_Disabling_Unicode-awareness_in_builtin_charclasses">X
  24: Disabling Unicode-awareness in builtin charclasses</a></h2>
<p class="Pp">Disable <span class="Li">&quot;\w&quot;</span>,
    <span class="Li">&quot;\b&quot;</span>,
    <span class="Li">&quot;\s&quot;</span>,
    <span class="Li">&quot;\d&quot;</span>, and the POSIX classes from working
    correctly on Unicode either in this scope, or in just one regex.</p>
<p class="Pp"></p>
<pre> use v5.14;
 use re &quot;/a&quot;;
 # OR
 my($num) = $str =~ /(\d+)/a;
</pre>
<p class="Pp">Or use specific un-Unicode properties, like
    <span class="Li">&quot;\p{ahex}&quot;</span> and
    <span class="Li">&quot;\p{POSIX_Digit&quot;</span>}. Properties still work
    normally no matter what charset modifiers (<span class="Li">&quot;/d /u /l
    /a /aa&quot;</span>) should be effect.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="X_25:_Match_Unicode_properties_in_regex_with_"><a class="permalink" href="#X_25:_Match_Unicode_properties_in_regex_with_">X
  25: Match Unicode properties in regex with \p, \P</a></h2>
<p class="Pp">These all match a single codepoint with the given property. Use
    <span class="Li">&quot;\P&quot;</span> in place of
    <span class="Li">&quot;\p&quot;</span> to match one codepoint lacking that
    property.</p>
<p class="Pp"></p>
<pre> \pL, \pN, \pS, \pP, \pM, \pZ, \pC
 \p{Sk}, \p{Ps}, \p{Lt}
 \p{alpha}, \p{upper}, \p{lower}
 \p{Latin}, \p{Greek}
 \p{script_extensions=Latin}, \p{scx=Greek}
 \p{East_Asian_Width=Wide}, \p{EA=W}
 \p{Line_Break=Hyphen}, \p{LB=HY}
 \p{Numeric_Value=4}, \p{NV=4}
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_26:_Custom_character_properties"><a class="permalink" href="#X_26:_Custom_character_properties">X
  26: Custom character properties</a></h2>
<p class="Pp">Define at compile-time your own custom character properties for
    use in regexes.</p>
<p class="Pp"></p>
<pre> # using private-use characters
 sub In_Tengwar { &quot;E000\tE07F\n&quot; }
 if (/\p{In_Tengwar}/) { ... }
 # blending existing properties
 sub Is_GraecoRoman_Title {&lt;&lt;'END_OF_SET'}
 +utf8::IsLatin
 +utf8::IsGreek
 &amp;utf8::IsTitle
 END_OF_SET
 if (/\p{Is_GraecoRoman_Title}/ { ... }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_27:_Unicode_normalization"><a class="permalink" href="#X_27:_Unicode_normalization">X
  27: Unicode normalization</a></h2>
<p class="Pp">Typically render into NFD on input and NFC on output. Using NFKC
    or NFKD functions improves recall on searches, assuming you've already done
    to the same text to be searched. Note that this is about much more than just
    pre- combined compatibility glyphs; it also reorders marks according to
    their canonical combining classes and weeds out singletons.</p>
<p class="Pp"></p>
<pre> use Unicode::Normalize;
 my $nfd  = NFD($orig);
 my $nfc  = NFC($orig);
 my $nfkd = NFKD($orig);
 my $nfkc = NFKC($orig);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_28:_Convert_non-ASCII_Unicode_numerics"><a class="permalink" href="#X_28:_Convert_non-ASCII_Unicode_numerics">X
  28: Convert non-ASCII Unicode numerics</a></h2>
<p class="Pp">Unless youXve used <span class="Li">&quot;/a&quot;</span> or
    <span class="Li">&quot;/aa&quot;</span>,
    <span class="Li">&quot;\d&quot;</span> matches more than ASCII digits only,
    but PerlXs implicit string-to-number conversion does not current recognize
    these. HereXs how to convert such strings manually.</p>
<p class="Pp"></p>
<pre> use v5.14;  # needed for num() function
 use Unicode::UCD qw(num);
 my $str = &quot;got X and XXXX and X and here&quot;;
 my @nums = ();
 while ($str =~ /(\d+|\N)/g) {  # not just ASCII!
    push @nums, num($1);
 }
 say &quot;@nums&quot;;   #     12      4567      0.875
 use charnames qw(:full);
 my $nv = num(&quot;\N{RUMI DIGIT ONE}\N{RUMI DIGIT TWO}&quot;);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_29:_Match_Unicode_grapheme_cluster_in_regex"><a class="permalink" href="#X_29:_Match_Unicode_grapheme_cluster_in_regex">X
  29: Match Unicode grapheme cluster in regex</a></h2>
<p class="Pp">Programmer-visible XcharactersX are codepoints matched by
    <span class="Li">&quot;/./s&quot;</span>, but user-visible XcharactersX are
    graphemes matched by <span class="Li">&quot;/\X/&quot;</span>.</p>
<p class="Pp"></p>
<pre> # Find vowel *plus* any combining diacritics,underlining,etc.
 my $nfd = NFD($orig);
 $nfd =~ / (?=[aeiou]) \X /xi
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_30:_Extract_by_grapheme_instead_of_by_codepoint_(regex)"><a class="permalink" href="#X_30:_Extract_by_grapheme_instead_of_by_codepoint_(regex)">X
  30: Extract by grapheme instead of by codepoint (regex)</a></h2>
<pre> # match and grab five first graphemes
 my($first_five) = $str =~ /^ ( \X{5} ) /x;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_31:_Extract_by_grapheme_instead_of_by_codepoint_(substr)"><a class="permalink" href="#X_31:_Extract_by_grapheme_instead_of_by_codepoint_(substr)">X
  31: Extract by grapheme instead of by codepoint (substr)</a></h2>
<pre> # cpan -i Unicode::GCString
 use Unicode::GCString;
 my $gcs = Unicode::GCString-&gt;new($str);
 my $first_five = $gcs-&gt;substr(0, 5);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_32:_Reverse_string_by_grapheme"><a class="permalink" href="#X_32:_Reverse_string_by_grapheme">X
  32: Reverse string by grapheme</a></h2>
<p class="Pp">Reversing by codepoint messes up diacritics, mistakenly converting
    <span class="Li">&quot;creme brulee&quot;</span> into
    <span class="Li">&quot;eelXurb emXerc&quot;</span> instead of into
    <span class="Li">&quot;eelurb emerc&quot;</span>; so reverse by grapheme
    instead. Both these approaches work right no matter what normalization the
    string is in:</p>
<p class="Pp"></p>
<pre> $str = join(&quot;&quot;, reverse $str =~ /\X/g);
 # OR: cpan -i Unicode::GCString
 use Unicode::GCString;
 $str = reverse Unicode::GCString-&gt;new($str);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_33:_String_length_in_graphemes"><a class="permalink" href="#X_33:_String_length_in_graphemes">X
  33: String length in graphemes</a></h2>
<p class="Pp">The string <span class="Li">&quot;brulee&quot;</span> has six
    graphemes but up to eight codepoints. This counts by grapheme, not by
    codepoint:</p>
<p class="Pp"></p>
<pre> my $str = &quot;brulee&quot;;
 my $count = 0;
 while ($str =~ /\X/g) { $count++ }
  # OR: cpan -i Unicode::GCString
 use Unicode::GCString;
 my $gcs = Unicode::GCString-&gt;new($str);
 my $count = $gcs-&gt;length;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_34:_Unicode_column-width_for_printing"><a class="permalink" href="#X_34:_Unicode_column-width_for_printing">X
  34: Unicode column-width for printing</a></h2>
<p class="Pp">PerlXs <span class="Li">&quot;printf&quot;</span>,
    <span class="Li">&quot;sprintf&quot;</span>, and
    <span class="Li">&quot;format&quot;</span> think all codepoints take up 1
    print column, but many take 0 or 2. Here to show that normalization makes no
    difference, we print out both forms:</p>
<p class="Pp"></p>
<pre> use Unicode::GCString;
 use Unicode::Normalize;
 my @words = qw/creme brulee/;
 @words = map { NFC($_), NFD($_) } @words;
 for my $str (@words) {
     my $gcs = Unicode::GCString-&gt;new($str);
     my $cols = $gcs-&gt;columns;
     my $pad = &quot; &quot; x (10 - $cols);
     say str, $pad, &quot; |&quot;;
 }
</pre>
<p class="Pp">generates this to show that it pads correctly no matter the
    normalization:</p>
<p class="Pp"></p>
<pre> creme      |
 creXme      |
 brulee     |
 bruXleXe     |
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_35:_Unicode_collation"><a class="permalink" href="#X_35:_Unicode_collation">X
  35: Unicode collation</a></h2>
<p class="Pp">Text sorted by numeric codepoint follows no reasonable alphabetic
    order; use the UCA for sorting text.</p>
<p class="Pp"></p>
<pre> use Unicode::Collate;
 my $col = Unicode::Collate-&gt;new();
 my @list = $col-&gt;sort(@old_list);
</pre>
<p class="Pp">See the <i>ucsort</i> program from the Unicode::Tussle CPAN module
    for a convenient command-line interface to this module.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="X_36:_Case"><a class="permalink" href="#X_36:_Case">X 36:
  Case- <i>and</i> accent-insensitive Unicode sort</a></h2>
<p class="Pp">Specify a collation strength of level 1 to ignore case and
    diacritics, only looking at the basic character.</p>
<p class="Pp"></p>
<pre> use Unicode::Collate;
 my $col = Unicode::Collate-&gt;new(level =&gt; 1);
 my @list = $col-&gt;sort(@old_list);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_37:_Unicode_locale_collation"><a class="permalink" href="#X_37:_Unicode_locale_collation">X
  37: Unicode locale collation</a></h2>
<p class="Pp">Some locales have special sorting rules.</p>
<p class="Pp"></p>
<pre> # either use v5.12, OR: cpan -i Unicode::Collate::Locale
 use Unicode::Collate::Locale;
 my $col = Unicode::Collate::Locale-&gt;new(locale =&gt; &quot;de__phonebook&quot;);
 my @list = $col-&gt;sort(@old_list);
</pre>
<p class="Pp">The <i>ucsort</i> program mentioned above accepts a
    <span class="Li">&quot;--locale&quot;</span> parameter.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="X_38:_Making__cmp__work_on_text_instead_of_codepoints"><a class="permalink" href="#X_38:_Making__cmp__work_on_text_instead_of_codepoints">X
  38: Making &quot;cmp&quot; work on text instead of codepoints</a></h2>
<p class="Pp">Instead of this:</p>
<p class="Pp"></p>
<pre> @srecs = sort {
     $b-&gt;{AGE}   &lt;=&gt;  $a-&gt;{AGE}
                 ||
     $a-&gt;{NAME}  cmp  $b-&gt;{NAME}
 } @recs;
</pre>
<p class="Pp">Use this:</p>
<p class="Pp"></p>
<pre> my $coll = Unicode::Collate-&gt;new();
 for my $rec (@recs) {
     $rec-&gt;{NAME_key} = $coll-&gt;getSortKey( $rec-&gt;{NAME} );
 }
 @srecs = sort {
     $b-&gt;{AGE}       &lt;=&gt;  $a-&gt;{AGE}
                     ||
     $a-&gt;{NAME_key}  cmp  $b-&gt;{NAME_key}
 } @recs;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_39:_Case"><a class="permalink" href="#X_39:_Case">X 39:
  Case- <i>and</i> accent-insensitive comparisons</a></h2>
<p class="Pp">Use a collator object to compare Unicode text by character instead
    of by codepoint.</p>
<p class="Pp"></p>
<pre> use Unicode::Collate;
 my $es = Unicode::Collate-&gt;new(
     level =&gt; 1,
     normalization =&gt; undef
 );
  # now both are true:
 $es-&gt;eq(&quot;Garcia&quot;,  &quot;GARCIA&quot; );
 $es-&gt;eq(&quot;Marquez&quot;, &quot;MARQUEZ&quot;);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_40:_Case"><a class="permalink" href="#X_40:_Case">X 40:
  Case- <i>and</i> accent-insensitive locale comparisons</a></h2>
<p class="Pp">Same, but in a specific locale.</p>
<p class="Pp"></p>
<pre> my $de = Unicode::Collate::Locale-&gt;new(
            locale =&gt; &quot;de__phonebook&quot;,
          );
 # now this is true:
 $de-&gt;eq(&quot;tschuess&quot;, &quot;TSCHUESS&quot;);  # notice ue =&gt; UE, ss =&gt; SS
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_41:_Unicode_linebreaking"><a class="permalink" href="#X_41:_Unicode_linebreaking">X
  41: Unicode linebreaking</a></h2>
<p class="Pp">Break up text into lines according to Unicode rules.</p>
<p class="Pp"></p>
<pre> # cpan -i Unicode::LineBreak
 use Unicode::LineBreak;
 use charnames qw(:full);
 my $para = &quot;This is a super\N{HYPHEN}long string. &quot; x 20;
 my $fmt = Unicode::LineBreak-&gt;new;
 print $fmt-&gt;break($para), &quot;\n&quot;;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_42:_Unicode_text_in_"><a class="permalink" href="#X_42:_Unicode_text_in_">X
  42: Unicode text in DBM hashes, the tedious way</a></h2>
<p class="Pp">Using a regular Perl string as a key or value for a DBM hash will
    trigger a wide character exception if any codepoints wonXt fit into a byte.
    HereXs how to manually manage the translation:</p>
<p class="Pp"></p>
<pre>    use DB_File;
    use Encode qw(encode decode);
    tie %dbhash, &quot;DB_File&quot;, &quot;pathname&quot;;
 # STORE
    # assume $uni_key and $uni_value are abstract Unicode strings
    my $enc_key   = encode(&quot;UTF-8&quot;, $uni_key, 1);
    my $enc_value = encode(&quot;UTF-8&quot;, $uni_value, 1);
    $dbhash{$enc_key} = $enc_value;
 # FETCH
    # assume $uni_key holds a normal Perl string (abstract Unicode)
    my $enc_key   = encode(&quot;UTF-8&quot;, $uni_key, 1);
    my $enc_value = $dbhash{$enc_key};
    my $uni_value = decode(&quot;UTF-8&quot;, $enc_value, 1);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_43:_Unicode_text_in_"><a class="permalink" href="#X_43:_Unicode_text_in_">X
  43: Unicode text in DBM hashes, the easy way</a></h2>
<p class="Pp">HereXs how to implicitly manage the translation; all encoding and
    decoding is done automatically, just as with streams that have a particular
    encoding attached to them:</p>
<p class="Pp"></p>
<pre>    use DB_File;
    use DBM_Filter;
    my $dbobj = tie %dbhash, &quot;DB_File&quot;, &quot;pathname&quot;;
    $dbobj-&gt;Filter_Value(&quot;utf8&quot;);  # this is the magic bit
 # STORE
    # assume $uni_key and $uni_value are abstract Unicode strings
    $dbhash{$uni_key} = $uni_value;
  # FETCH
    # $uni_key holds a normal Perl string (abstract Unicode)
    my $uni_value = $dbhash{$uni_key};
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="X_44:_"><a class="permalink" href="#X_44:_">X 44: PROGRAM:
  Demo of Unicode collation and printing</a></h2>
<p class="Pp">HereXs a full program showing how to make use of locale-sensitive
    sorting, Unicode casing, and managing print widths when some of the
    characters take up zero or two columns, not just one column each time. When
    run, the following program produces this nicely aligned output:</p>
<p class="Pp"></p>
<pre>    Creme Brulee....... X2.00
    Eclair............. X1.60
    Fideua............. X4.20
    Hamburger.......... X6.00
    Jamon Serrano...... X4.45
    Linguica........... X7.00
    Pate............... X4.15
    Pears.............. X2.00
    Peches............. X2.25
    Smorbrod........... X5.75
    Spaetzle............ X5.50
    Xorico............. X3.00
    XXXXX.............. X6.50
    XXX............. X4.00
    XXX............. X2.65
    XXXXX......... X8.00
    XXXXXXX..... X1.85
    XX............... X9.99
    XX............... X7.50
</pre>
<p class="Pp">Here's that program; tested on v5.14.</p>
<p class="Pp"></p>
<pre> #!/usr/bin/env perl
 # umenu - demo sorting and printing of Unicode food
 #
 # (obligatory and increasingly long preamble)
 #
 use utf8;
 use v5.14;                       # for locale sorting
 use strict;
 use warnings;
 use warnings  qw(FATAL utf8);    # fatalize encoding faults
 use open      qw(:std :encoding(UTF-8)); # undeclared streams in UTF-8
 use charnames qw(:full :short);  # unneeded in v5.16
 # std modules
 use Unicode::Normalize;          # std perl distro as of v5.8
 use List::Util qw(max);          # std perl distro as of v5.10
 use Unicode::Collate::Locale;    # std perl distro as of v5.14
 # cpan modules
 use Unicode::GCString;           # from CPAN
 # forward defs
 sub pad($$$);
 sub colwidth(_);
 sub entitle(_);
 my %price = (
     &quot;XXXXX&quot;             =&gt; 6.50, # gyros
     &quot;pears&quot;             =&gt; 2.00, # like um, pears
     &quot;linguica&quot;          =&gt; 7.00, # spicy sausage, Portuguese
     &quot;xorico&quot;            =&gt; 3.00, # chorizo sausage, Catalan
     &quot;hamburger&quot;         =&gt; 6.00, # burgermeister meisterburger
     &quot;eclair&quot;            =&gt; 1.60, # dessert, French
     &quot;smorbrod&quot;          =&gt; 5.75, # sandwiches, Norwegian
     &quot;spaetzle&quot;           =&gt; 5.50, # Bayerisch noodles, little sparrows
     &quot;XX&quot;              =&gt; 7.50, # bao1 zi5, steamed pork buns, Mandarin
     &quot;jamon serrano&quot;     =&gt; 4.45, # country ham, Spanish
     &quot;peches&quot;            =&gt; 2.25, # peaches, French
     &quot;XXXXXXX&quot;    =&gt; 1.85, # cream-filled pastry like eclair
     &quot;XXX&quot;            =&gt; 4.00, # makgeolli, Korean rice wine
     &quot;XX&quot;              =&gt; 9.99, # sushi, Japanese
     &quot;XXX&quot;            =&gt; 2.65, # omochi, rice cakes, Japanese
     &quot;creme brulee&quot;      =&gt; 2.00, # crema catalana
     &quot;fideua&quot;            =&gt; 4.20, # more noodles, Valencian
                                  # (Catalan=fideuada)
     &quot;pate&quot;              =&gt; 4.15, # gooseliver paste, French
     &quot;XXXXX&quot;        =&gt; 8.00, # okonomiyaki, Japanese
 );
 my $width = 5 + max map { colwidth } keys %price;
 # So the Asian stuff comes out in an order that someone
 # who reads those scripts won't freak out over; the
 # CJK stuff will be in JIS X 0208 order that way.
 my $coll  = Unicode::Collate::Locale-&gt;new(locale =&gt; &quot;ja&quot;);
 for my $item ($coll-&gt;sort(keys %price)) {
     print pad(entitle($item), $width, &quot;.&quot;);
     printf &quot; X%.2f\n&quot;, $price{$item};
 }
 sub pad($$$) {
     my($str, $width, $padchar) = @_;
     return $str . ($padchar x ($width - colwidth($str)));
 }
 sub colwidth(_) {
     my($str) = @_;
     return Unicode::GCString-&gt;new($str)-&gt;columns;
 }
 sub entitle(_) {
     my($str) = @_;
     $str =~ s{ (?=\pL)(\S)     (\S*) }
              { ucfirst($1) . lc($2)  }xge;
     return $str;
 }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">See these manpages, some of which are CPAN modules: perlunicode,
    perluniprops, perlre, perlrecharclass, perluniintro, perlunitut, perlunifaq,
    PerlIO, DB_File, DBM_Filter, DBM_Filter::utf8, Encode, Encode::Locale,
    Unicode::UCD, Unicode::Normalize, Unicode::GCString, Unicode::LineBreak,
    Unicode::Collate, Unicode::Collate::Locale, Unicode::Unihan,
    Unicode::CaseFold, Unicode::Tussle, Lingua::JA::Romanize::Japanese,
    Lingua::ZH::Romanize::Pinyin, Lingua::KO::Romanize::Hangul.</p>
<p class="Pp">The Unicode::Tussle CPAN module includes many programs to help
    with working with Unicode, including these programs to fully or partly
    replace standard utilities: <i>tcgrep</i> instead of <i>egrep</i>,
    <i>uniquote</i> instead of <i>cat -v</i> or <i>hexdump</i>, <i>uniwc</i>
    instead of <i>wc</i>, <i>unilook</i> instead of <i>look</i>, <i>unifmt</i>
    instead of <i>fmt</i>, and <i>ucsort</i> instead of <i>sort</i>. For
    exploring Unicode character names and character properties, see its
    <i>uniprops</i>, <i>unichars</i>, and <i>uninames</i> programs. It also
    supplies these programs, all of which are general filters that do Unicode-y
    things: <i>unititle</i> and <i>unicaps</i>; <i>uniwide</i> and
    <i>uninarrow</i>; <i>unisupers</i> and <i>unisubs</i>; <i>nfd</i>,
    <i>nfc</i>, <i>nfkd</i>, and <i>nfkc</i>; and <i>uc</i>, <i>lc</i>, and
    <i>tc</i>.</p>
<p class="Pp">Finally, see the published Unicode Standard (page numbers are from
    version 6.0.0), including these specific annexes and technical reports:</p>
<dl class="Bl-tag">
  <dt id="X3.13"><a class="permalink" href="#X3.13">X3.13 Default Case
    Algorithms, page 113; X4.2 Case, pages 120X122; Case Mappings, page 166X172,
    especially Caseless Matching starting on page 170.</a></dt>
  <dd></dd>
  <dt id="UAX"><a class="permalink" href="#UAX">UAX #44: Unicode Character
    Database</a></dt>
  <dd></dd>
  <dt id="UTS"><a class="permalink" href="#UTS">UTS #18: Unicode Regular
    Expressions</a></dt>
  <dd></dd>
  <dt id="UAX~2"><a class="permalink" href="#UAX~2">UAX #15: Unicode
    Normalization Forms</a></dt>
  <dd></dd>
  <dt id="UTS~2"><a class="permalink" href="#UTS~2">UTS #10: Unicode Collation
    Algorithm</a></dt>
  <dd></dd>
  <dt id="UAX~3"><a class="permalink" href="#UAX~3">UAX #29: Unicode Text
    Segmentation</a></dt>
  <dd></dd>
  <dt id="UAX~4"><a class="permalink" href="#UAX~4">UAX #14: Unicode Line
    Breaking Algorithm</a></dt>
  <dd></dd>
  <dt id="UAX~5"><a class="permalink" href="#UAX~5">UAX #11: East Asian
    Width</a></dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Tom Christiansen &lt;tchrist@perl.com&gt; wrote this, with
    occasional kibbitzing from Larry Wall and Jeffrey Friedl in the
  background.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENCE"><a class="permalink" href="#COPYRIGHT_AND_LICENCE">COPYRIGHT
  AND LICENCE</a></h1>
<p class="Pp">Copyright X 2012 Tom Christiansen.</p>
<p class="Pp">This program is free software; you may redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">Most of these examples taken from the current edition of the
    XCamel BookX; that is, from the 4XX Edition of <i>Programming Perl</i>,
    Copyright X 2012 Tom Christiansen &lt;et al.&gt;, 2012-02-13 by OXReilly
    Media. The code itself is freely redistributable, and you are encouraged to
    transplant, fold, spindle, and mutilate any of the examples in this manpage
    however you please for inclusion into your own programs without any
    encumbrance whatsoever. Acknowledgement via code comment is polite but not
    required.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="REVISION_HISTORY"><a class="permalink" href="#REVISION_HISTORY">REVISION
  HISTORY</a></h1>
<p class="Pp">v1.0.0 X first public release, 2012-02-27</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-06-14</td>
    <td class="foot-os">perl v5.34.0</td>
  </tr>
</table>
</body>
</html>

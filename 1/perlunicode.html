<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PERLUNICODE(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLUNICODE(1)</td>
    <td class="head-vol"><a href=".">Perl Programmers Reference Guide</a></td>
    <td class="head-rtitle">PERLUNICODE(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlunicode - Unicode support in Perl</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">If you haven't already, before reading this document, you should
    become familiar with both perlunitut and perluniintro.</p>
<p class="Pp">Unicode aims to <b>UNI</b>-fy the en-<b>CODE</b>-ings of all the
    world's character sets into a single Standard. For quite a few of the
    various coding standards that existed when Unicode was first created,
    converting from each to Unicode essentially meant adding a constant to each
    code point in the original standard, and converting back meant just
    subtracting that same constant. For ASCII and ISO-8859-1, the constant is 0.
    For ISO-8859-5, (Cyrillic) the constant is 864; for Hebrew (ISO-8859-8),
    it's 1488; Thai (ISO-8859-11), 3424; and so forth. This made it easy to do
    the conversions, and facilitated the adoption of Unicode.</p>
<p class="Pp">And it worked; nowadays, those legacy standards are rarely used.
    Most everyone uses Unicode.</p>
<p class="Pp">Unicode is a comprehensive standard. It specifies many things
    outside the scope of Perl, such as how to display sequences of characters.
    For a full discussion of all aspects of Unicode, see
    &lt;https://www.unicode.org&gt;.</p>
<section class="Ss">
<h2 class="Ss" id="Important_Caveats"><a class="permalink" href="#Important_Caveats">Important
  Caveats</a></h2>
<p class="Pp">Even though some of this section may not be understandable to you
    on first reading, we think it's important enough to highlight some of the
    gotchas before delving further, so here goes:</p>
<p class="Pp">Unicode support is an extensive requirement. While Perl does not
    implement the Unicode standard or the accompanying technical reports from
    cover to cover, Perl does support many Unicode features.</p>
<p class="Pp">Also, the use of Unicode may present security issues that aren't
    obvious, see &quot;Security Implications of Unicode&quot; below.</p>
<dl class="Bl-tag">
  <dt id="Safest"><a class="permalink" href="#Safest">Safest if you &quot;use
    feature 'unicode_strings'&quot;</a></dt>
  <dd>In order to preserve backward compatibility, Perl does not turn on full
      internal Unicode support unless the pragma
      <span class="Li">&quot;use&#x00A0;feature&#x00A0;'unicode_strings'&quot;</span>
      is specified. (This is automatically selected if you
      <span class="Li">&quot;use&#x00A0;5.012&quot;</span> or higher.) Failure
      to do this can trigger unexpected surprises. See &quot;The &quot;Unicode
      Bug&quot;&quot; below.
    <p class="Pp">This pragma doesn't affect I/O. Nor does it change the
        internal representation of strings, only their interpretation. There are
        still several places where Unicode isn't fully supported, such as in
        filenames.</p>
  </dd>
  <dt id="Input"><a class="permalink" href="#Input">Input and Output
    Layers</a></dt>
  <dd>Use the <span class="Li">&quot;:encoding(...)&quot;</span> layer to read
      from and write to filehandles using the specified encoding. (See
    open.)</dd>
  <dt id="You"><a class="permalink" href="#You">You must convert your non-ASCII,
    non-UTF-8 Perl scripts to be UTF-8.</a></dt>
  <dd>The encoding module has been deprecated since perl 5.18 and the perl
      internals it requires have been removed with perl 5.26.</dd>
  <dt>&quot;use utf8&quot; still needed to enable UTF-8 in scripts</dt>
  <dd>If your Perl script is itself encoded in UTF-8, the
      <span class="Li">&quot;use&#x00A0;utf8&quot;</span> pragma must be
      explicitly included to enable recognition of that (in string or regular
      expression literals, or in identifier names). <b>This is the only time
      when an explicit
      </b><span class="Li"><b>&quot;use&#x00A0;utf8&quot;</b></span><b> is
      needed.</b> (See utf8).
    <p class="Pp">If a Perl script begins with the bytes that form the UTF-8
        encoding of the Unicode BYTE ORDER MARK
        (<span class="Li">&quot;BOM&quot;</span>, see &quot;Unicode
        Encodings&quot;), those bytes are completely ignored.</p>
  </dd>
  <dt id="UTF"><a class="permalink" href="#UTF">UTF-16 scripts
    autodetected</a></dt>
  <dd>If a Perl script begins with the Unicode
      <span class="Li">&quot;BOM&quot;</span> (UTF-16LE, UTF16-BE), or if the
      script looks like non-<span class="Li">&quot;BOM&quot;</span>-marked
      UTF-16 of either endianness, Perl will correctly read in the script as the
      appropriate Unicode encoding.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Byte_and_Character_Semantics"><a class="permalink" href="#Byte_and_Character_Semantics">Byte
  and Character Semantics</a></h2>
<p class="Pp">Before Unicode, most encodings used 8 bits (a single byte) to
    encode each character. Thus a character was a byte, and a byte was a
    character, and there could be only 256 or fewer possible characters.
    &quot;Byte Semantics&quot; in the title of this section refers to this
    behavior. There was no need to distinguish between &quot;Byte&quot; and
    &quot;Character&quot;.</p>
<p class="Pp">Then along comes Unicode which has room for over a million
    characters (and Perl allows for even more). This means that a character may
    require more than a single byte to represent it, and so the two terms are no
    longer equivalent. What matter are the characters as whole entities, and not
    usually the bytes that comprise them. That's what the term &quot;Character
    Semantics&quot; in the title of this section refers to.</p>
<p class="Pp">Perl had to change internally to decouple &quot;bytes&quot; from
    &quot;characters&quot;. It is important that you too change your ideas, if
    you haven't already, so that &quot;byte&quot; and &quot;character&quot; no
    longer mean the same thing in your mind.</p>
<p class="Pp">The basic building block of Perl strings has always been a
    &quot;character&quot;. The changes basically come down to that the
    implementation no longer thinks that a character is always just a single
    byte.</p>
<p class="Pp">There are various things to note:</p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>String handling functions, for the most part, continue to operate in terms
      of characters. <span class="Li">&quot;length()&quot;</span>, for example,
      returns the number of characters in a string, just as before. But that
      number no longer is necessarily the same as the number of bytes in the
      string (there may be more bytes than characters). The other such functions
      include <span class="Li">&quot;chop()&quot;</span>,
      <span class="Li">&quot;chomp()&quot;</span>,
      <span class="Li">&quot;substr()&quot;</span>,
      <span class="Li">&quot;pos()&quot;</span>,
      <span class="Li">&quot;index()&quot;</span>,
      <span class="Li">&quot;rindex()&quot;</span>,
      <span class="Li">&quot;sort()&quot;</span>,
      <span class="Li">&quot;sprintf()&quot;</span>, and
      <span class="Li">&quot;write()&quot;</span>.
    <p class="Pp">The exceptions are:</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>the bit-oriented <span class="Li">&quot;vec&quot;</span>
    <p class="Pp">&#x00A0;</p>
  </li>
  <li>the byte-oriented
      <span class="Li">&quot;pack&quot;</span>/<span class="Li">&quot;unpack&quot;</span>
      <span class="Li">&quot;C&quot;</span> format
    <p class="Pp">However, the <span class="Li">&quot;W&quot;</span> specifier
        does operate on whole characters, as does the
        <span class="Li">&quot;U&quot;</span> specifier.</p>
  </li>
  <li>some operators that interact with the platform's operating system
    <p class="Pp">Operators dealing with filenames are examples.</p>
  </li>
  <li>when the functions are called from within the scope of the
      <span class="Li">&quot;use&#x00A0;bytes&quot;</span> pragma
    <p class="Pp">Likely, you should use this only for debugging anyway.</p>
  </li>
</ul>
</div>
<div class="Bd-indent"></div>
<ul class="Bl-bullet">
  <li>Strings--including hash keys--and regular expression patterns may contain
      characters that have ordinal values larger than 255.
    <p class="Pp">If you use a Unicode editor to edit your program, Unicode
        characters may occur directly within the literal strings in UTF-8
        encoding, or UTF-16. (The former requires a <span class="Li">&quot;use
        utf8&quot;</span>, the latter may require a
        <span class="Li">&quot;BOM&quot;</span>.)</p>
    <p class="Pp">&quot;Creating Unicode&quot; in perluniintro gives other ways
        to place non-ASCII characters in your strings.</p>
  </li>
  <li>The <span class="Li">&quot;chr()&quot;</span> and
      <span class="Li">&quot;ord()&quot;</span> functions work on whole
      characters.</li>
  <li>Regular expressions match whole characters. For example,
      <span class="Li">&quot;.&quot;</span> matches a whole character instead of
      only a single byte.</li>
  <li>The <span class="Li">&quot;tr///&quot;</span> operator translates whole
      characters. (Note that the <span class="Li">&quot;tr///CU&quot;</span>
      functionality has been removed. For similar functionality to that, see
      <span class="Li">&quot;pack('U0', ...)&quot;</span> and
      <span class="Li">&quot;pack('C0', ...)&quot;</span>).</li>
  <li><span class="Li">&quot;scalar reverse()&quot;</span> reverses by character
      rather than by byte.</li>
  <li>The bit string operators, <span class="Li">&quot;&amp; | ^ ~&quot;</span>
      and (starting in v5.22) <span class="Li">&quot;&amp;. |. ^.
      ~.&quot;</span> can operate on bit strings encoded in UTF-8, but this can
      give unexpected results if any of the strings contain code points above
      0xFF. Starting in v5.28, it is a fatal error to have such an operand.
      Otherwise, the operation is performed on a non-UTF-8 copy of the operand.
      If you're not sure about the encoding of a string, downgrade it before
      using any of these operators; you can use
      <span class="Li">&quot;utf8::utf8_downgrade()&quot;</span>.</li>
</ul>
<p class="Pp">The bottom line is that Perl has always practiced &quot;Character
    Semantics&quot;, but with the advent of Unicode, that is now different than
    &quot;Byte Semantics&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss">ASCII Rules versus Unicode Rules</h2>
<p class="Pp">Before Unicode, when a character was a byte was a character, Perl
    knew only about the 128 characters defined by ASCII, code points 0 through
    127 (except for under
    <span class="Li">&quot;use&#x00A0;locale&quot;</span>). That left the code
    points 128 to 255 as unassigned, and available for whatever use a program
    might want. The only semantics they have is their ordinal numbers, and that
    they are members of none of the non-negative character classes. None are
    considered to match <span class="Li">&quot;\w&quot;</span> for example, but
    all match <span class="Li">&quot;\W&quot;</span>.</p>
<p class="Pp">Unicode, of course, assigns each of those code points a particular
    meaning (along with ones above 255). To preserve backward compatibility,
    Perl only uses the Unicode meanings when there is some indication that
    Unicode is what is intended; otherwise the non-ASCII code points remain
    treated as if they are unassigned.</p>
<p class="Pp">Here are the ways that Perl knows that a string should be treated
    as Unicode:</p>
<ul class="Bl-bullet">
  <li>Within the scope of <span class="Li">&quot;use&#x00A0;utf8&quot;</span>
    <p class="Pp">If the whole program is Unicode (signified by using 8-bit
        <b>U</b>nicode <b>T</b>ransformation <b>F</b>ormat), then all literal
        strings within it must be Unicode.</p>
  </li>
  <li>Within the scope of
      <span class="Li">&quot;use&#x00A0;feature&#x00A0;'unicode_strings'&quot;</span>
    <p class="Pp">This pragma was created so you can explicitly tell Perl that
        operations executed within its scope are to use Unicode rules. More
        operations are affected with newer perls. See &quot;The &quot;Unicode
        Bug&quot;&quot;.</p>
  </li>
  <li>Within the scope of <span class="Li">&quot;use&#x00A0;5.012&quot;</span>
      or higher
    <p class="Pp">This implicitly turns on
        <span class="Li">&quot;use&#x00A0;feature&#x00A0;'unicode_strings'&quot;</span>.</p>
  </li>
  <li>Within the scope of
      <span class="Li">&quot;use&#x00A0;locale&#x00A0;'not_characters'&quot;</span>,
      or <span class="Li">&quot;use&#x00A0;locale&quot;</span> and the current
      locale is a UTF-8 locale.
    <p class="Pp">The former is defined to imply Unicode handling; and the
        latter indicates a Unicode locale, hence a Unicode interpretation of all
        strings within it.</p>
  </li>
  <li>When the string contains a Unicode-only code point
    <p class="Pp">Perl has never accepted code points above 255 without them
        being Unicode, so their use implies Unicode for the whole string.</p>
  </li>
  <li>When the string contains a Unicode named code point
      <span class="Li">&quot;\N{...}&quot;</span>
    <p class="Pp">The <span class="Li">&quot;\N{...}&quot;</span> construct
        explicitly refers to a Unicode code point, even if it is one that is
        also in ASCII. Therefore the string containing it must be Unicode.</p>
  </li>
  <li>When the string has come from an external source marked as Unicode
    <p class="Pp">The <span class="Li">&quot;-C&quot;</span> command line option
        can specify that certain inputs to the program are Unicode, and the
        values of this can be read by your Perl code, see
        &quot;${^UNICODE}&quot; in perlvar.</p>
  </li>
  <li>When the string has been upgraded to UTF-8
    <p class="Pp">The function
        <span class="Li">&quot;utf8::utf8_upgrade()&quot;</span> can be
        explicitly used to permanently (unless a subsequent
        <span class="Li">&quot;utf8::utf8_downgrade()&quot;</span> is called)
        cause a string to be treated as Unicode.</p>
  </li>
  <li>There are additional methods for regular expression patterns
    <p class="Pp">A pattern that is compiled with the
        <span class="Li">&quot;/u&quot;</span> or
        <span class="Li">&quot;/a&quot;</span> modifiers is treated as Unicode
        (though there are some restrictions with
        <span class="Li">&quot;/a&quot;</span>). Under the
        <span class="Li">&quot;/d&quot;</span> and
        <span class="Li">&quot;/l&quot;</span> modifiers, there are several
        other indications for Unicode; see &quot;Character set modifiers&quot;
        in perlre.</p>
  </li>
</ul>
<p class="Pp">Note that all of the above are overridden within the scope of
    <span class="Li">&quot;use bytes&quot;</span>; but you should be using this
    pragma only for debugging.</p>
<p class="Pp">Note also that some interactions with the platform's operating
    system never use Unicode rules.</p>
<p class="Pp">When Unicode rules are in effect:</p>
<ul class="Bl-bullet">
  <li>Case translation operators use the Unicode case translation tables.
    <p class="Pp">Note that <span class="Li">&quot;uc()&quot;</span>, or
        <span class="Li">&quot;\U&quot;</span> in interpolated strings,
        translates to uppercase, while
        <span class="Li">&quot;ucfirst&quot;</span>, or
        <span class="Li">&quot;\u&quot;</span> in interpolated strings,
        translates to titlecase in languages that make the distinction (which is
        equivalent to uppercase in languages without the distinction).</p>
    <p class="Pp">There is a CPAN module,
        <span class="Li">&quot;Unicode::Casing&quot;</span>, which allows you to
        define your own mappings to be used in
        <span class="Li">&quot;lc()&quot;</span>,
        <span class="Li">&quot;lcfirst()&quot;</span>,
        <span class="Li">&quot;uc()&quot;</span>,
        <span class="Li">&quot;ucfirst()&quot;</span>, and
        <span class="Li">&quot;fc&quot;</span> (or their double-quoted string
        inlined versions such as <span class="Li">&quot;\U&quot;</span>). (Prior
        to Perl 5.16, this functionality was partially provided in the Perl
        core, but suffered from a number of insurmountable drawbacks, so the
        CPAN module was written instead.)</p>
  </li>
  <li>Character classes in regular expressions match based on the character
      properties specified in the Unicode properties database.
    <p class="Pp"><span class="Li">&quot;\w&quot;</span> can be used to match a
        Japanese ideograph, for instance; and
        <span class="Li">&quot;[[:digit:]]&quot;</span> a Bengali number.</p>
  </li>
  <li>Named Unicode properties, scripts, and block ranges may be used (like
      bracketed character classes) by using the
      <span class="Li">&quot;\p{}&quot;</span> &quot;matches property&quot;
      construct and the <span class="Li">&quot;\P{}&quot;</span> negation,
      &quot;doesn't match property&quot;.
    <p class="Pp">See &quot;Unicode Character Properties&quot; for more
      details.</p>
    <p class="Pp">You can define your own character properties and use them in
        the regular expression with the <span class="Li">&quot;\p{}&quot;</span>
        or <span class="Li">&quot;\P{}&quot;</span> construct. See
        &quot;User-Defined Character Properties&quot; for more details.</p>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Extended_Grapheme_Clusters_(Logical_characters)"><a class="permalink" href="#Extended_Grapheme_Clusters_(Logical_characters)">Extended
  Grapheme Clusters (Logical characters)</a></h2>
<p class="Pp">Consider a character, say <span class="Li">&quot;H&quot;</span>.
    It could appear with various marks around it, such as an acute accent, or a
    circumflex, or various hooks, circles, arrows, <i>etc.</i>, above, below, to
    one side or the other, <i>etc</i>. There are many possibilities among the
    world's languages. The number of combinations is astronomical, and if there
    were a character for each combination, it would soon exhaust Unicode's more
    than a million possible characters. So Unicode took a different approach:
    there is a character for the base <span class="Li">&quot;H&quot;</span>, and
    a character for each of the possible marks, and these can be variously
    combined to get a final logical character. So a logical character--what
    appears to be a single character--can be a sequence of more than one
    individual characters. The Unicode standard calls these &quot;extended
    grapheme clusters&quot; (which is an improved version of the no-longer much
    used &quot;grapheme cluster&quot;); Perl furnishes the
    <span class="Li">&quot;\X&quot;</span> regular expression construct to match
    such sequences in their entirety.</p>
<p class="Pp">But Unicode's intent is to unify the existing character set
    standards and practices, and several pre-existing standards have single
    characters that mean the same thing as some of these combinations, like
    ISO-8859-1, which has quite a few of them. For example,
    <span class="Li">&quot;LATIN CAPITAL LETTER E</span> <span class="Li">WITH
    ACUTE&quot;</span> was already in this standard when Unicode came along.
    Unicode therefore added it to its repertoire as that single character. But
    this character is considered by Unicode to be equivalent to the sequence
    consisting of the character <span class="Li">&quot;LATIN CAPITAL LETTER
    E&quot;</span> followed by the character <span class="Li">&quot;COMBINING
    ACUTE ACCENT&quot;</span>.</p>
<p class="Pp"><span class="Li">&quot;LATIN CAPITAL LETTER E WITH
    ACUTE&quot;</span> is called a &quot;pre-composed&quot; character, and its
    equivalence with the &quot;E&quot; and the &quot;COMBINING ACCENT&quot;
    sequence is called canonical equivalence. All pre-composed characters are
    said to have a decomposition (into the equivalent sequence), and the
    decomposition type is also called canonical. A string may be comprised as
    much as possible of precomposed characters, or it may be comprised of
    entirely decomposed characters. Unicode calls these respectively,
    &quot;Normalization Form Composed&quot; (NFC) and &quot;Normalization Form
    Decomposed&quot;. The <span class="Li">&quot;Unicode::Normalize&quot;</span>
    module contains functions that convert between the two. A string may also
    have both composed characters and decomposed characters; this module can be
    used to make it all one or the other.</p>
<p class="Pp">You may be presented with strings in any of these equivalent
    forms. There is currently nothing in Perl 5 that ignores the differences. So
    you'll have to specially handle it. The usual advice is to convert your
    inputs to <span class="Li">&quot;NFD&quot;</span> before processing
  further.</p>
<p class="Pp">For more detailed information, see
    &lt;http://unicode.org/reports/tr15/&gt;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Unicode_Character_Properties"><a class="permalink" href="#Unicode_Character_Properties">Unicode
  Character Properties</a></h2>
<p class="Pp">(The only time that Perl considers a sequence of individual code
    points as a single logical character is in the
    <span class="Li">&quot;\X&quot;</span> construct, already mentioned above.
    Therefore &quot;character&quot; in this discussion means a single Unicode
    code point.)</p>
<p class="Pp">Very nearly all Unicode character properties are accessible
    through regular expressions by using the
    <span class="Li">&quot;\p{}&quot;</span> &quot;matches property&quot;
    construct and the <span class="Li">&quot;\P{}&quot;</span> &quot;doesn't
    match property&quot; for its negation.</p>
<p class="Pp">For instance, <span class="Li">&quot;\p{Uppercase}&quot;</span>
    matches any single character with the Unicode
    <span class="Li">&quot;Uppercase&quot;</span> property, while
    <span class="Li">&quot;\p{L}&quot;</span> matches any character with a
    <span class="Li">&quot;General_Category&quot;</span> of
    <span class="Li">&quot;L&quot;</span> (letter) property (see
    &quot;General_Category&quot; below). Brackets are not required for single
    letter property names, so <span class="Li">&quot;\p{L}&quot;</span> is
    equivalent to <span class="Li">&quot;\pL&quot;</span>.</p>
<p class="Pp">More formally, <span class="Li">&quot;\p{Uppercase}&quot;</span>
    matches any single character whose Unicode
    <span class="Li">&quot;Uppercase&quot;</span> property value is
    <span class="Li">&quot;True&quot;</span>, and
    <span class="Li">&quot;\P{Uppercase}&quot;</span> matches any character
    whose <span class="Li">&quot;Uppercase&quot;</span> property value is
    <span class="Li">&quot;False&quot;</span>, and they could have been written
    as <span class="Li">&quot;\p{Uppercase=True}&quot;</span> and
    <span class="Li">&quot;\p{Uppercase=False}&quot;</span>, respectively.</p>
<p class="Pp">This formality is needed when properties are not binary; that is,
    if they can take on more values than just
    <span class="Li">&quot;True&quot;</span> and
    <span class="Li">&quot;False&quot;</span>. For example, the
    <span class="Li">&quot;Bidi_Class&quot;</span> property (see
    &quot;Bidirectional Character Types&quot; below), can take on several
    different values, such as <span class="Li">&quot;Left&quot;</span>,
    <span class="Li">&quot;Right&quot;</span>,
    <span class="Li">&quot;Whitespace&quot;</span>, and others. To match these,
    one needs to specify both the property name
    (<span class="Li">&quot;Bidi_Class&quot;</span>), AND the value being
    matched against (<span class="Li">&quot;Left&quot;</span>,
    <span class="Li">&quot;Right&quot;</span>, <i>etc.</i>). This is done, as in
    the examples above, by having the two components separated by an equal sign
    (or interchangeably, a colon), like <span class="Li">&quot;\p{Bidi_Class:
    Left}&quot;</span>.</p>
<p class="Pp">All Unicode-defined character properties may be written in these
    compound forms of
    <span class="Li">&quot;\p{</span><span class="Li"><i>property</i></span><span class="Li">=</span><span class="Li"><i>value</i></span><span class="Li">}&quot;</span>
    or
    <span class="Li">&quot;\p{</span><span class="Li"><i>property</i></span><span class="Li">:</span><span class="Li"><i>value</i></span><span class="Li">}&quot;</span>,
    but Perl provides some additional properties that are written only in the
    single form, as well as single-form short-cuts for all binary properties and
    certain others described below, in which you may omit the property name and
    the equals or colon separator.</p>
<p class="Pp">Most Unicode character properties have at least two synonyms (or
    aliases if you prefer): a short one that is easier to type and a longer one
    that is more descriptive and hence easier to understand. Thus the
    <span class="Li">&quot;L&quot;</span> and
    <span class="Li">&quot;Letter&quot;</span> properties above are equivalent
    and can be used interchangeably. Likewise,
    <span class="Li">&quot;Upper&quot;</span> is a synonym for
    <span class="Li">&quot;Uppercase&quot;</span>, and we could have written
    <span class="Li">&quot;\p{Uppercase}&quot;</span> equivalently as
    <span class="Li">&quot;\p{Upper}&quot;</span>. Also, there are typically
    various synonyms for the values the property can be. For binary properties,
    <span class="Li">&quot;True&quot;</span> has 3 synonyms:
    <span class="Li">&quot;T&quot;</span>,
    <span class="Li">&quot;Yes&quot;</span>, and
    <span class="Li">&quot;Y&quot;</span>; and
    <span class="Li">&quot;False&quot;</span> has correspondingly
    <span class="Li">&quot;F&quot;</span>,
    <span class="Li">&quot;No&quot;</span>, and
    <span class="Li">&quot;N&quot;</span>. But be careful. A short form of a
    value for one property may not mean the same thing as the short form spelled
    the same for another. Thus, for the
    <span class="Li">&quot;General_Category&quot;</span> property,
    <span class="Li">&quot;L&quot;</span> means
    <span class="Li">&quot;Letter&quot;</span>, but for the
    <span class="Li">&quot;Bidi_Class&quot;</span> property,
    <span class="Li">&quot;L&quot;</span> means
    <span class="Li">&quot;Left&quot;</span>. A complete list of properties and
    synonyms is in perluniprops.</p>
<p class="Pp">Upper/lower case differences in property names and values are
    irrelevant; thus <span class="Li">&quot;\p{Upper}&quot;</span> means the
    same thing as <span class="Li">&quot;\p{upper}&quot;</span> or even
    <span class="Li">&quot;\p{UpPeR}&quot;</span>. Similarly, you can add or
    subtract underscores anywhere in the middle of a word, so that these are
    also equivalent to <span class="Li">&quot;\p{U_p_p_e_r}&quot;</span>. And
    white space is generally irrelevant adjacent to non-word characters, such as
    the braces and the equals or colon separators, so <span class="Li">&quot;\p{
    Upper }&quot;</span> and <span class="Li">&quot;\p{ Upper_case : Y
    }&quot;</span> are equivalent to these as well. In fact, white space and
    even hyphens can usually be added or deleted anywhere. So even
    <span class="Li">&quot;\p{ Up-per case = Yes}&quot;</span> is equivalent.
    All this is called &quot;loose-matching&quot; by Unicode. The
    &quot;name&quot; property has some restrictions on this due to a few outlier
    names. Full details are given in
    &lt;https://www.unicode.org/reports/tr44/tr44-24.html#UAX44-LM2&gt;.</p>
<p class="Pp">The few places where stricter matching is used is in the middle of
    numbers, the &quot;name&quot; property, and in the Perl extension properties
    that begin or end with an underscore. Stricter matching cares about white
    space (except adjacent to non-word characters), hyphens, and non-interior
    underscores.</p>
<p class="Pp">You can also use negation in both
    <span class="Li">&quot;\p{}&quot;</span> and
    <span class="Li">&quot;\P{}&quot;</span> by introducing a caret
    (<span class="Li">&quot;^&quot;</span>) between the first brace and the
    property name: <span class="Li">&quot;\p{^Tamil}&quot;</span> is equal to
    <span class="Li">&quot;\P{Tamil}&quot;</span>.</p>
<p class="Pp">Almost all properties are immune to case-insensitive matching.
    That is, adding a <span class="Li">&quot;/i&quot;</span> regular expression
    modifier does not change what they match. There are two sets that are
    affected. The first set is
    <span class="Li">&quot;Uppercase_Letter&quot;</span>,
    <span class="Li">&quot;Lowercase_Letter&quot;</span>, and
    <span class="Li">&quot;Titlecase_Letter&quot;</span>, all of which match
    <span class="Li">&quot;Cased_Letter&quot;</span> under
    <span class="Li">&quot;/i&quot;</span> matching. And the second set is
    <span class="Li">&quot;Uppercase&quot;</span>,
    <span class="Li">&quot;Lowercase&quot;</span>, and
    <span class="Li">&quot;Titlecase&quot;</span>, all of which match
    <span class="Li">&quot;Cased&quot;</span> under
    <span class="Li">&quot;/i&quot;</span> matching. This set also includes its
    subsets <span class="Li">&quot;PosixUpper&quot;</span> and
    <span class="Li">&quot;PosixLower&quot;</span> both of which under
    <span class="Li">&quot;/i&quot;</span> match
    <span class="Li">&quot;PosixAlpha&quot;</span>. (The difference between
    these sets is that some things, such as Roman numerals, come in both upper
    and lower case so they are <span class="Li">&quot;Cased&quot;</span>, but
    aren't considered letters, so they aren't
    <span class="Li">&quot;Cased_Letter&quot;</span>'s.)</p>
<p class="Pp">See &quot;Beyond Unicode code points&quot; for special
    considerations when matching Unicode properties against non-Unicode code
    points.</p>
<p class="Pp"><i></i><b><i>General_Category</i></b><i></i></p>
<p class="Pp">Every Unicode character is assigned a general category, which is
    the &quot;most usual categorization of a character&quot; (from
    &lt;https://www.unicode.org/reports/tr44&gt;).</p>
<p class="Pp">The compound way of writing these is like
    <span class="Li">&quot;\p{General_Category=Number}&quot;</span> (short:
    <span class="Li">&quot;\p{gc:n}&quot;</span>). But Perl furnishes shortcuts
    in which everything up through the equal or colon separator is omitted. So
    you can instead just write <span class="Li">&quot;\pN&quot;</span>.</p>
<p class="Pp">Here are the short and long forms of the values the
    <span class="Li">&quot;General Category&quot;</span> property can have:</p>
<p class="Pp"></p>
<pre>    Short       Long
    L           Letter
    LC, L&amp;      Cased_Letter (that is: [\p{Ll}\p{Lu}\p{Lt}])
    Lu          Uppercase_Letter
    Ll          Lowercase_Letter
    Lt          Titlecase_Letter
    Lm          Modifier_Letter
    Lo          Other_Letter
    M           Mark
    Mn          Nonspacing_Mark
    Mc          Spacing_Mark
    Me          Enclosing_Mark
    N           Number
    Nd          Decimal_Number (also Digit)
    Nl          Letter_Number
    No          Other_Number
    P           Punctuation (also Punct)
    Pc          Connector_Punctuation
    Pd          Dash_Punctuation
    Ps          Open_Punctuation
    Pe          Close_Punctuation
    Pi          Initial_Punctuation
                (may behave like Ps or Pe depending on usage)
    Pf          Final_Punctuation
                (may behave like Ps or Pe depending on usage)
    Po          Other_Punctuation
    S           Symbol
    Sm          Math_Symbol
    Sc          Currency_Symbol
    Sk          Modifier_Symbol
    So          Other_Symbol
    Z           Separator
    Zs          Space_Separator
    Zl          Line_Separator
    Zp          Paragraph_Separator
    C           Other
    Cc          Control (also Cntrl)
    Cf          Format
    Cs          Surrogate
    Co          Private_Use
    Cn          Unassigned
</pre>
<p class="Pp">Single-letter properties match all characters in any of the
    two-letter sub-properties starting with the same letter.
    <span class="Li">&quot;LC&quot;</span> and
    <span class="Li">&quot;L&amp;&quot;</span> are special: both are aliases for
    the set consisting of everything matched by
    <span class="Li">&quot;Ll&quot;</span>,
    <span class="Li">&quot;Lu&quot;</span>, and
    <span class="Li">&quot;Lt&quot;</span>.</p>
<p class="Pp"><i></i><b><i>Bidirectional Character Types</i></b><i></i></p>
<p class="Pp">Because scripts differ in their directionality (Hebrew and Arabic
    are written right to left, for example) Unicode supplies a
    <span class="Li">&quot;Bidi_Class&quot;</span> property. Some of the values
    this property can have are:</p>
<p class="Pp"></p>
<pre>    Value       Meaning
    L           Left-to-Right
    LRE         Left-to-Right Embedding
    LRO         Left-to-Right Override
    R           Right-to-Left
    AL          Arabic Letter
    RLE         Right-to-Left Embedding
    RLO         Right-to-Left Override
    PDF         Pop Directional Format
    EN          European Number
    ES          European Separator
    ET          European Terminator
    AN          Arabic Number
    CS          Common Separator
    NSM         Non-Spacing Mark
    BN          Boundary Neutral
    B           Paragraph Separator
    S           Segment Separator
    WS          Whitespace
    ON          Other Neutrals
</pre>
<p class="Pp">This property is always written in the compound form. For example,
    <span class="Li">&quot;\p{Bidi_Class:R}&quot;</span> matches characters that
    are normally written right to left. Unlike the
    <span class="Li">&quot;General_Category&quot;</span> property, this property
    can have more values added in a future Unicode release. Those listed above
    comprised the complete set for many Unicode releases, but others were added
    in Unicode 6.3; you can always find what the current ones are in
    perluniprops. And &lt;https://www.unicode.org/reports/tr9/&gt; describes how
    to use them.</p>
<p class="Pp"><i></i><b><i>Scripts</i></b><i></i></p>
<p class="Pp">The world's languages are written in many different scripts. This
    sentence (unless you're reading it in translation) is written in Latin,
    while Russian is written in Cyrillic, and Greek is written in, well, Greek;
    Japanese mainly in Hiragana or Katakana. There are many more.</p>
<p class="Pp">The Unicode <span class="Li">&quot;Script&quot;</span> and
    <span class="Li">&quot;Script_Extensions&quot;</span> properties give what
    script a given character is in. The
    <span class="Li">&quot;Script_Extensions&quot;</span> property is an
    improved version of <span class="Li">&quot;Script&quot;</span>, as
    demonstrated below. Either property can be specified with the compound form
    like <span class="Li">&quot;\p{Script=Hebrew}&quot;</span> (short:
    <span class="Li">&quot;\p{sc=hebr}&quot;</span>), or
    <span class="Li">&quot;\p{Script_Extensions=Javanese}&quot;</span> (short:
    <span class="Li">&quot;\p{scx=java}&quot;</span>). In addition, Perl
    furnishes shortcuts for all
    <span class="Li">&quot;Script_Extensions&quot;</span> property names. You
    can omit everything up through the equals (or colon), and simply write
    <span class="Li">&quot;\p{Latin}&quot;</span> or
    <span class="Li">&quot;\P{Cyrillic}&quot;</span>. (This is not true for
    <span class="Li">&quot;Script&quot;</span>, which is required to be written
    in the compound form. Prior to Perl v5.26, the single form returned the
    plain old <span class="Li">&quot;Script&quot;</span> version, but was
    changed because <span class="Li">&quot;Script_Extensions&quot;</span> gives
    better results.)</p>
<p class="Pp">The difference between these two properties involves characters
    that are used in multiple scripts. For example the digits '0' through '9'
    are used in many parts of the world. These are placed in a script named
    <span class="Li">&quot;Common&quot;</span>. Other characters are used in
    just a few scripts. For example, the
    <span class="Li">&quot;KATAKANA-HIRAGANA DOUBLE HYPHEN&quot;</span> is used
    in both Japanese scripts, Katakana and Hiragana, but nowhere else. The
    <span class="Li">&quot;Script&quot;</span> property places all characters
    that are used in multiple scripts in the
    <span class="Li">&quot;Common&quot;</span> script, while the
    <span class="Li">&quot;Script_Extensions&quot;</span> property places those
    that are used in only a few scripts into each of those scripts; while still
    using <span class="Li">&quot;Common&quot;</span> for those used in many
    scripts. Thus both these match:</p>
<p class="Pp"></p>
<pre> &quot;0&quot; =~ /\p{sc=Common}/     # Matches
 &quot;0&quot; =~ /\p{scx=Common}/    # Matches
</pre>
<p class="Pp">and only the first of these match:</p>
<p class="Pp"></p>
<pre> &quot;\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}&quot; =~ /\p{sc=Common}  # Matches
 &quot;\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}&quot; =~ /\p{scx=Common} # No match
</pre>
<p class="Pp">And only the last two of these match:</p>
<p class="Pp"></p>
<pre> &quot;\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}&quot; =~ /\p{sc=Hiragana}  # No match
 &quot;\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}&quot; =~ /\p{sc=Katakana}  # No match
 &quot;\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}&quot; =~ /\p{scx=Hiragana} # Matches
 &quot;\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}&quot; =~ /\p{scx=Katakana} # Matches
</pre>
<p class="Pp"><span class="Li">&quot;Script_Extensions&quot;</span> is thus an
    improved <span class="Li">&quot;Script&quot;</span>, in which there are
    fewer characters in the <span class="Li">&quot;Common&quot;</span> script,
    and correspondingly more in other scripts. It is new in Unicode version 6.0,
    and its data are likely to change significantly in later releases, as things
    get sorted out. New code should probably be using
    <span class="Li">&quot;Script_Extensions&quot;</span> and not plain
    <span class="Li">&quot;Script&quot;</span>. If you compile perl with a
    Unicode release that doesn't have
    <span class="Li">&quot;Script_Extensions&quot;</span>, the single form Perl
    extensions will instead refer to the plain
    <span class="Li">&quot;Script&quot;</span> property. If you compile with a
    version of Unicode that doesn't have the
    <span class="Li">&quot;Script&quot;</span> property, these extensions will
    not be defined at all.</p>
<p class="Pp">(Actually, besides <span class="Li">&quot;Common&quot;</span>, the
    <span class="Li">&quot;Inherited&quot;</span> script, contains characters
    that are used in multiple scripts. These are modifier characters which
    inherit the script value of the controlling character. Some of these are
    used in many scripts, and so go into
    <span class="Li">&quot;Inherited&quot;</span> in both
    <span class="Li">&quot;Script&quot;</span> and
    <span class="Li">&quot;Script_Extensions&quot;</span>. Others are used in
    just a few scripts, so are in <span class="Li">&quot;Inherited&quot;</span>
    in <span class="Li">&quot;Script&quot;</span>, but not in
    <span class="Li">&quot;Script_Extensions&quot;</span>.)</p>
<p class="Pp">It is worth stressing that there are several different sets of
    digits in Unicode that are equivalent to 0-9 and are matchable by
    <span class="Li">&quot;\d&quot;</span> in a regular expression. If they are
    used in a single language only, they are in that language's
    <span class="Li">&quot;Script&quot;</span> and
    <span class="Li">&quot;Script_Extensions&quot;</span>. If they are used in
    more than one script, they will be in
    <span class="Li">&quot;sc=Common&quot;</span>, but only if they are used in
    many scripts should they be in
    <span class="Li">&quot;scx=Common&quot;</span>.</p>
<p class="Pp">The explanation above has omitted some detail; refer to UAX#24
    &quot;Unicode Script Property&quot;:
    &lt;https://www.unicode.org/reports/tr24&gt;.</p>
<p class="Pp">A complete list of scripts and their shortcuts is in
  perluniprops.</p>
<p class="Pp"><i></i><b><i>Use of the
    </i></b><span class="Li"><b>&quot;Is&quot;</b></span><b><i>
    Prefix</i></b><i></i></p>
<p class="Pp">For backward compatibility (with ancient Perl 5.6), all properties
    writable without using the compound form mentioned so far may have
    <span class="Li">&quot;Is&quot;</span> or
    <span class="Li">&quot;Is_&quot;</span> prepended to their name, so
    <span class="Li">&quot;\P{Is_Lu}&quot;</span>, for example, is equal to
    <span class="Li">&quot;\P{Lu}&quot;</span>, and
    <span class="Li">&quot;\p{IsScript:Arabic}&quot;</span> is equal to
    <span class="Li">&quot;\p{Arabic}&quot;</span>.</p>
<p class="Pp"><i></i><b><i>Blocks</i></b><i></i></p>
<p class="Pp">In addition to <b>scripts</b>, Unicode also defines <b>blocks</b>
    of characters. The difference between scripts and blocks is that the concept
    of scripts is closer to natural languages, while the concept of blocks is
    more of an artificial grouping based on groups of Unicode characters with
    consecutive ordinal values. For example, the <span class="Li">&quot;Basic
    Latin&quot;</span> block is all the characters whose ordinals are between 0
    and 127, inclusive; in other words, the ASCII characters. The
    <span class="Li">&quot;Latin&quot;</span> script contains some letters from
    this as well as several other blocks, like <span class="Li">&quot;Latin-1
    Supplement&quot;</span>, <span class="Li">&quot;Latin
    Extended-A&quot;</span>, <i>etc.</i>, but it does not contain all the
    characters from those blocks. It does not, for example, contain the digits
    0-9, because those digits are shared across many scripts, and hence are in
    the <span class="Li">&quot;Common&quot;</span> script.</p>
<p class="Pp">For more about scripts versus blocks, see UAX#24 &quot;Unicode
    Script Property&quot;: &lt;https://www.unicode.org/reports/tr24&gt;</p>
<p class="Pp">The <span class="Li">&quot;Script_Extensions&quot;</span> or
    <span class="Li">&quot;Script&quot;</span> properties are likely to be the
    ones you want to use when processing natural language; the
    <span class="Li">&quot;Block&quot;</span> property may occasionally be
    useful in working with the nuts and bolts of Unicode.</p>
<p class="Pp">Block names are matched in the compound form, like
    <span class="Li">&quot;\p{Block: Arrows}&quot;</span> or
    <span class="Li">&quot;\p{Blk=Hebrew}&quot;</span>. Unlike most other
    properties, only a few block names have a Unicode-defined short name.</p>
<p class="Pp">Perl also defines single form synonyms for the block property in
    cases where these do not conflict with something else. But don't use any of
    these, because they are unstable. Since these are Perl extensions, they are
    subordinate to official Unicode property names; Unicode doesn't know nor
    care about Perl's extensions. It may happen that a name that currently means
    the Perl extension will later be changed without warning to mean a different
    Unicode property in a future version of the perl interpreter that uses a
    later Unicode release, and your code would no longer work. The extensions
    are mentioned here for completeness: Take the block name and prefix it with
    one of: <span class="Li">&quot;In&quot;</span> (for example
    <span class="Li">&quot;\p{Blk=Arrows}&quot;</span> can currently be written
    as <span class="Li">&quot;\p{In_Arrows}&quot;</span>); or sometimes
    <span class="Li">&quot;Is&quot;</span> (like
    <span class="Li">&quot;\p{Is_Arrows}&quot;</span>); or sometimes no prefix
    at all (<span class="Li">&quot;\p{Arrows}&quot;</span>). As of this writing
    (Unicode 9.0) there are no conflicts with using the
    <span class="Li">&quot;In_&quot;</span> prefix, but there are plenty with
    the other two forms. For example,
    <span class="Li">&quot;\p{Is_Hebrew}&quot;</span> and
    <span class="Li">&quot;\p{Hebrew}&quot;</span> mean
    <span class="Li">&quot;\p{Script_Extensions=Hebrew}&quot;</span> which is
    NOT the same thing as <span class="Li">&quot;\p{Blk=Hebrew}&quot;</span>.
    Our advice used to be to use the <span class="Li">&quot;In_&quot;</span>
    prefix as a single form way of specifying a block. But Unicode 8.0 added
    properties whose names begin with <span class="Li">&quot;In&quot;</span>,
    and it's now clear that it's only luck that's so far prevented a conflict.
    Using <span class="Li">&quot;In&quot;</span> is only marginally less typing
    than <span class="Li">&quot;Blk:&quot;</span>, and the latter's meaning is
    clearer anyway, and guaranteed to never conflict. So don't take chances. Use
    <span class="Li">&quot;\p{Blk=foo}&quot;</span> for new code. And be sure
    that block is what you really really want to do. In most cases scripts are
    what you want instead.</p>
<p class="Pp">A complete list of blocks is in perluniprops.</p>
<p class="Pp"><i></i><b><i>Other Properties</i></b><i></i></p>
<p class="Pp">There are many more properties than the very basic ones described
    here. A complete list is in perluniprops.</p>
<p class="Pp">Unicode defines all its properties in the compound form, so all
    single-form properties are Perl extensions. Most of these are just synonyms
    for the Unicode ones, but some are genuine extensions, including several
    that are in the compound form. And quite a few of these are actually
    recommended by Unicode (in
  &lt;https://www.unicode.org/reports/tr18&gt;).</p>
<p class="Pp">This section gives some details on all extensions that aren't just
    synonyms for compound-form Unicode properties (for those properties, you'll
    have to refer to the Unicode Standard
    &lt;https://www.unicode.org/reports/tr44&gt;.</p>
<dl class="Bl-tag">
  <dt><b></b><span class="Li"><b>&quot;\p{All}&quot;</b></span><b></b></dt>
  <dd>This matches every possible code point. It is equivalent to
      <span class="Li">&quot;qr/./s&quot;</span>. Unlike all the other
      non-user-defined <span class="Li">&quot;\p{}&quot;</span> property
      matches, no warning is ever generated if this is property is matched
      against a non-Unicode code point (see &quot;Beyond Unicode code
      points&quot; below).</dd>
  <dt><b></b><span class="Li"><b>&quot;\p{Alnum}&quot;</b></span><b></b></dt>
  <dd>This matches any <span class="Li">&quot;\p{Alphabetic}&quot;</span> or
      <span class="Li">&quot;\p{Decimal_Number}&quot;</span> character.</dd>
  <dt><b></b><span class="Li"><b>&quot;\p{Any}&quot;</b></span><b></b></dt>
  <dd>This matches any of the 1_114_112 Unicode code points. It is a synonym for
      <span class="Li">&quot;\p{Unicode}&quot;</span>.</dd>
  <dt><b></b><span class="Li"><b>&quot;\p{ASCII}&quot;</b></span><b></b></dt>
  <dd>This matches any of the 128 characters in the US-ASCII character set,
      which is a subset of Unicode.</dd>
  <dt><b></b><span class="Li"><b>&quot;\p{Assigned}&quot;</b></span><b></b></dt>
  <dd>This matches any assigned code point; that is, any code point whose
      general category is not <span class="Li">&quot;Unassigned&quot;</span> (or
      equivalently, not <span class="Li">&quot;Cn&quot;</span>).</dd>
  <dt><b></b><span class="Li"><b>&quot;\p{Blank}&quot;</b></span><b></b></dt>
  <dd>This is the same as <span class="Li">&quot;\h&quot;</span> and
      <span class="Li">&quot;\p{HorizSpace}&quot;</span>: A character that
      changes the spacing horizontally.</dd>
  <dt><b></b><span class="Li"><b>&quot;\p{Decomposition_Type:
    Non_Canonical}&quot;</b></span><b></b> (Short:
    &quot;\p{Dt=NonCanon}&quot;)</dt>
  <dd>Matches a character that has a non-canonical decomposition.
    <p class="Pp">The &quot;Extended Grapheme Clusters (Logical
        characters)&quot; section above talked about canonical decompositions.
        However, many more characters have a different type of decomposition, a
        &quot;compatible&quot; or &quot;non-canonical&quot; decomposition. The
        sequences that form these decompositions are not considered canonically
        equivalent to the pre-composed character. An example is the
        <span class="Li">&quot;SUPERSCRIPT ONE&quot;</span>. It is somewhat like
        a regular digit 1, but not exactly; its decomposition into the digit 1
        is called a &quot;compatible&quot; decomposition, specifically a
        &quot;super&quot; decomposition. There are several such compatibility
        decompositions (see &lt;https://www.unicode.org/reports/tr44&gt;),
        including one called &quot;compat&quot;, which means some miscellaneous
        type of decomposition that doesn't fit into the other decomposition
        categories that Unicode has chosen.</p>
    <p class="Pp">Note that most Unicode characters don't have a decomposition,
        so their decomposition type is
      <span class="Li">&quot;None&quot;</span>.</p>
    <p class="Pp">For your convenience, Perl has added the
        <span class="Li">&quot;Non_Canonical&quot;</span> decomposition type to
        mean any of the several compatibility decompositions.</p>
  </dd>
  <dt><b></b><span class="Li"><b>&quot;\p{Graph}&quot;</b></span><b></b></dt>
  <dd>Matches any character that is graphic. Theoretically, this means a
      character that on a printer would cause ink to be used.</dd>
  <dt><b></b><span class="Li"><b>&quot;\p{HorizSpace}&quot;</b></span><b></b></dt>
  <dd>This is the same as <span class="Li">&quot;\h&quot;</span> and
      <span class="Li">&quot;\p{Blank}&quot;</span>: a character that changes
      the spacing horizontally.</dd>
  <dt><b></b><span class="Li"><b>&quot;\p{In=*}&quot;</b></span><b></b></dt>
  <dd>This is a synonym for
    <span class="Li">&quot;\p{Present_In=*}&quot;</span></dd>
  <dt><b></b><span class="Li"><b>&quot;\p{PerlSpace}&quot;</b></span><b></b></dt>
  <dd>This is the same as <span class="Li">&quot;\s&quot;</span>, restricted to
      ASCII, namely <span class="Li">&quot;[&#x00A0;\f\n\r\t]&quot;</span> and
      starting in Perl v5.18, a vertical tab.
    <p class="Pp">Mnemonic: Perl's (original) space</p>
  </dd>
  <dt><b></b><span class="Li"><b>&quot;\p{PerlWord}&quot;</b></span><b></b></dt>
  <dd>This is the same as <span class="Li">&quot;\w&quot;</span>, restricted to
      ASCII, namely <span class="Li">&quot;[A-Za-z0-9_]&quot;</span>
    <p class="Pp">Mnemonic: Perl's (original) word.</p>
  </dd>
  <dt><b></b><span class="Li"><b>&quot;\p{Posix...}&quot;</b></span><b></b></dt>
  <dd>There are several of these, which are equivalents, using the
      <span class="Li">&quot;\p{}&quot;</span> notation, for Posix classes and
      are described in &quot;POSIX Character Classes&quot; in
    perlrecharclass.</dd>
  <dt><b></b><span class="Li"><b>&quot;\p{Present_In: *}&quot;</b></span><b></b>
    (Short: &quot;\p{In=*}&quot;)</dt>
  <dd>This property is used when you need to know in what Unicode version(s) a
      character is.
    <p class="Pp">The &quot;*&quot; above stands for some Unicode version
        number, such as <span class="Li">1.1</span> or
        <span class="Li">12.0</span>; or the &quot;*&quot; can also be
        <span class="Li">&quot;Unassigned&quot;</span>. This property will match
        the code points whose final disposition has been settled as of the
        Unicode release given by the version number;
        <span class="Li">&quot;\p{Present_In: Unassigned}&quot;</span> will
        match those code points whose meaning has yet to be assigned.</p>
    <p class="Pp">For example, <span class="Li">&quot;U+0041&quot;</span>
        <span class="Li">&quot;LATIN CAPITAL LETTER A&quot;</span> was present
        in the very first Unicode release available, which is
        <span class="Li">1.1</span>, so this property is true for all valid
        &quot;*&quot; versions. On the other hand,
        <span class="Li">&quot;U+1EFF&quot;</span> was not assigned until
        version 5.1 when it became <span class="Li">&quot;LATIN SMALL LETTER Y
        WITH LOOP&quot;</span>, so the only &quot;*&quot; that would match it
        are 5.1, 5.2, and later.</p>
    <p class="Pp">Unicode furnishes the <span class="Li">&quot;Age&quot;</span>
        property from which this is derived. The problem with Age is that a
        strict interpretation of it (which Perl takes) has it matching the
        precise release a code point's meaning is introduced in. Thus
        <span class="Li">&quot;U+0041&quot;</span> would match only 1.1; and
        <span class="Li">&quot;U+1EFF&quot;</span> only 5.1. This is not usually
        what you want.</p>
    <p class="Pp">Some non-Perl implementations of the Age property may change
        its meaning to be the same as the Perl
        <span class="Li">&quot;Present_In&quot;</span> property; just be aware
        of that.</p>
    <p class="Pp">Another confusion with both these properties is that the
        definition is not that the code point has been <i>assigned</i>, but that
        the meaning of the code point has been <i>determined</i>. This is
        because 66 code points will always be unassigned, and so the
        <span class="Li">&quot;Age&quot;</span> for them is the Unicode version
        in which the decision to make them so was made. For example,
        <span class="Li">&quot;U+FDD0&quot;</span> is to be permanently
        unassigned to a character, and the decision to do that was made in
        version 3.1, so <span class="Li">&quot;\p{Age=3.1}&quot;</span> matches
        this character, as also does <span class="Li">&quot;\p{Present_In:
        3.1}&quot;</span> and up.</p>
  </dd>
  <dt><b></b><span class="Li"><b>&quot;\p{Print}&quot;</b></span><b></b></dt>
  <dd>This matches any character that is graphical or blank, except
    controls.</dd>
  <dt><b></b><span class="Li"><b>&quot;\p{SpacePerl}&quot;</b></span><b></b></dt>
  <dd>This is the same as <span class="Li">&quot;\s&quot;</span>, including
      beyond ASCII.
    <p class="Pp">Mnemonic: Space, as modified by Perl. (It doesn't include the
        vertical tab until v5.18, which both the Posix standard and Unicode
        consider white space.)</p>
  </dd>
  <dt><b></b><span class="Li"><b>&quot;\p{Title}&quot;</b></span><b></b> and
    <b></b><span class="Li"><b>&quot;\p{Titlecase}&quot;</b></span><b></b></dt>
  <dd>Under case-sensitive matching, these both match the same code points as
      <span class="Li">&quot;\p{General Category=Titlecase_Letter}&quot;</span>
      (<span class="Li">&quot;\p{gc=lt}&quot;</span>). The difference is that
      under <span class="Li">&quot;/i&quot;</span> caseless matching, these
      match the same as <span class="Li">&quot;\p{Cased}&quot;</span>, whereas
      <span class="Li">&quot;\p{gc=lt}&quot;</span> matches
      <span class="Li">&quot;\p{Cased_Letter&quot;</span>).</dd>
  <dt><b></b><span class="Li"><b>&quot;\p{Unicode}&quot;</b></span><b></b></dt>
  <dd>This matches any of the 1_114_112 Unicode code points.
      <span class="Li">&quot;\p{Any}&quot;</span>.</dd>
  <dt><b></b><span class="Li"><b>&quot;\p{VertSpace}&quot;</b></span><b></b></dt>
  <dd>This is the same as <span class="Li">&quot;\v&quot;</span>: A character
      that changes the spacing vertically.</dd>
  <dt><b></b><span class="Li"><b>&quot;\p{Word}&quot;</b></span><b></b></dt>
  <dd>This is the same as <span class="Li">&quot;\w&quot;</span>, including over
      100_000 characters beyond ASCII.</dd>
  <dt><b></b><span class="Li"><b>&quot;\p{XPosix...}&quot;</b></span><b></b></dt>
  <dd>There are several of these, which are the standard Posix classes extended
      to the full Unicode range. They are described in &quot;POSIX Character
      Classes&quot; in perlrecharclass.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Comparison_of__"><a class="permalink" href="#Comparison_of__">Comparison
  of &quot;\N{...}&quot; and &quot;\p{name=...}&quot;</a></h2>
<p class="Pp">Starting in Perl 5.32, you can specify a character by its name in
    regular expression patterns using
    <span class="Li">&quot;\p{name=...}&quot;</span>. This is in addition to the
    longstanding method of using <span class="Li">&quot;\N{...}&quot;</span>.
    The following summarizes the differences between these two:</p>
<p class="Pp"></p>
<pre>                       \N{...}       \p{Name=...}
 can interpolate    only with eval       yes            [1]
 custom names            yes             no             [2]
 name aliases            yes             yes            [3]
 named sequences         yes             yes            [4]
 name value parsing     exact       Unicode loose       [5]
</pre>
<dl class="Bl-tag">
  <dt>[1]</dt>
  <dd>The ability to interpolate means you can do something like
    <p class="Pp"></p>
    <pre> qr/\p{na=latin capital letter $which}/
    </pre>
    <p class="Pp">and specify <span class="Li">$which</span> elsewhere.</p>
  </dd>
  <dt>[2]</dt>
  <dd>You can create your own names for characters, and override official ones
      when using <span class="Li">&quot;\N{...}&quot;</span>. See &quot;CUSTOM
      ALIASES&quot; in charnames.</dd>
  <dt>[3]</dt>
  <dd>Some characters have multiple names (synonyms).</dd>
  <dt>[4]</dt>
  <dd>Some particular sequences of characters are given a single name, in
      addition to their individual ones.</dd>
  <dt>[5]</dt>
  <dd>Exact name value matching means you have to specify case, hyphens,
      underscores, and spaces precisely in the name you want. Loose matching
      follows the Unicode rules
      &lt;https://www.unicode.org/reports/tr44/tr44-24.html#UAX44-LM2&gt;, where
      these are mostly irrelevant. Except for a few outlier character names,
      these are the same rules as are already used for any other
      <span class="Li">&quot;\p{...}&quot;</span> property.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Wildcards_in_Property_Values"><a class="permalink" href="#Wildcards_in_Property_Values">Wildcards
  in Property Values</a></h2>
<p class="Pp">Starting in Perl 5.30, it is possible to do something like
  this:</p>
<p class="Pp"></p>
<pre> qr!\p{numeric_value=/\A[0-5]\z/}!
</pre>
<p class="Pp">or, by abbreviating and adding
    <span class="Li">&quot;/x&quot;</span>,</p>
<p class="Pp"></p>
<pre> qr! \p{nv= /(?x) \A [0-5] \z / }!
</pre>
<p class="Pp">This matches all code points whose numeric value is one of 0, 1,
    2, 3, 4, or 5. This particular example could instead have been written
  as</p>
<p class="Pp"></p>
<pre> qr! \A [ \p{nv=0}\p{nv=1}\p{nv=2}\p{nv=3}\p{nv=4}\p{nv=5} ] \z !xx
</pre>
<p class="Pp">in earlier perls, so in this case this feature just makes things
    easier and shorter to write. If we hadn't included the
    <span class="Li">&quot;\A&quot;</span> and
    <span class="Li">&quot;\z&quot;</span>, these would have matched things like
    <span class="Li">&quot;1/2&quot;</span> because that contains a 1 (as well
    as a 2). As written, it matches things like subscripts that have these
    numeric values. If we only wanted the decimal digits with those numeric
    values, we could say,</p>
<p class="Pp"></p>
<pre> qr! (?[ \d &amp; \p{nv=/[0-5]/ ]) }!x
</pre>
<p class="Pp">The <span class="Li">&quot;\d&quot;</span> gets rid of needing to
    anchor the pattern, since it forces the result to only match
    <span class="Li">&quot;[0-9]&quot;</span>, and the
    <span class="Li">&quot;[0-5]&quot;</span> further restricts it.</p>
<p class="Pp">The text in the above examples enclosed between the
    <span class="Li">&quot;/&quot;</span> characters can be just about any
    regular expression. It is independent of the main pattern, so doesn't share
    any capturing groups, <i>etc</i>. The delimiters for it must be ASCII
    punctuation, but it may NOT be delimited by
    <span class="Li">&quot;{&quot;</span>, nor
    <span class="Li">&quot;}&quot;</span> nor contain a literal
    <span class="Li">&quot;}&quot;</span>, as that delimits the end of the
    enclosing <span class="Li">&quot;\p{}&quot;</span>. Like any pattern,
    certain other delimiters are terminated by their mirror images. These are
    <span class="Li">&quot;(&quot;</span>,
    <span class="Li">&quot;&quot;[&quot;</span>&quot;, and
    <span class="Li">&quot;&lt;&quot;</span>. If the delimiter is any of
    <span class="Li">&quot;-&quot;</span>,
    <span class="Li">&quot;_&quot;</span>,
    <span class="Li">&quot;+&quot;</span>, or
    <span class="Li">&quot;\&quot;</span>, or is the same delimiter as is used
    for the enclosing pattern, it must be preceded by a backslash escape, both
    fore and aft.</p>
<p class="Pp">Beware of using <span class="Li">&quot;$&quot;</span> to indicate
    to match the end of the string. It can too easily be interpreted as being a
    punctuation variable, like <span class="Li">$/</span>.</p>
<p class="Pp">No modifiers may follow the final delimiter. Instead, use
    &quot;(?adlupimnsx-imnsx)&quot; in perlre and/or
    &quot;(?adluimnsx-imnsx:pattern)&quot; in perlre to specify modifiers.
    However, certain modifiers are illegal in your wildcard subpattern. The only
    character set modifier specifiable is
    <span class="Li">&quot;/aa&quot;</span>; any other character set, and
    <span class="Li">&quot;-m&quot;</span>, and
    <span class="Li">&quot;p&quot;</span>, and
    <span class="Li">&quot;s&quot;</span> are all illegal. Specifying modifiers
    like <span class="Li">&quot;qr/.../gc&quot;</span> that aren't legal in the
    <span class="Li">&quot;(?...)&quot;</span> notation normally raise a
    warning, but with wildcard subpatterns, their use is an error. The
    <span class="Li">&quot;m&quot;</span> modifier is ineffective; everything
    that matches will be a single line.</p>
<p class="Pp">By default, your pattern is matched case-insensitively, as if
    <span class="Li">&quot;/i&quot;</span> had been specified. You can change
    this by saying <span class="Li">&quot;(?-i)&quot;</span> in your
  pattern.</p>
<p class="Pp">There are also certain operations that are illegal. You can't nest
    <span class="Li">&quot;\p{...}&quot;</span> and
    <span class="Li">&quot;\P{...}&quot;</span> calls within a wildcard
    subpattern, and <span class="Li">&quot;\G&quot;</span> doesn't make sense,
    so is also prohibited.</p>
<p class="Pp">And the <span class="Li">&quot;*&quot;</span> quantifier (or its
    equivalent <span class="Li">&quot;(0,}&quot;</span>) is illegal.</p>
<p class="Pp">This feature is not available when the left-hand side is prefixed
    by <span class="Li">&quot;Is_&quot;</span>, nor for any form that is marked
    as &quot;Discouraged&quot; in &quot;Discouraged&quot; in perluniprops.</p>
<p class="Pp">This experimental feature has been added to begin to implement
    &lt;https://www.unicode.org/reports/tr18/#Wildcard_Properties&gt;. Using it
    will raise a (default-on) warning in the
    <span class="Li">&quot;experimental::uniprop_wildcards&quot;</span>
    category. We reserve the right to change its operation as we gain
    experience.</p>
<p class="Pp">Your subpattern can be just about anything, but for it to have
    some utility, it should match when called with either or both of a) the full
    name of the property value with underscores (and/or spaces in the Block
    property) and some things uppercase; or b) the property value in all
    lowercase with spaces and underscores squeezed out. For example,</p>
<p class="Pp"></p>
<pre> qr!\p{Blk=/Old I.*/}!
 qr!\p{Blk=/oldi.*/}!
</pre>
<p class="Pp">would match the same things.</p>
<p class="Pp">Another example that shows that within
    <span class="Li">&quot;\p{...}&quot;</span>,
    <span class="Li">&quot;/x&quot;</span> isn't needed to have spaces:</p>
<p class="Pp"></p>
<pre> qr!\p{scx= /Hebrew|Greek/ }!
</pre>
<p class="Pp">To be safe, we should have anchored the above example, to prevent
    matches for something like
    <span class="Li">&quot;Hebrew_Braille&quot;</span>, but there aren't any
    script names like that, so far. A warning is issued if none of the legal
    values for a property are matched by your pattern. It's likely that a future
    release will raise a warning if your pattern ends up causing every possible
    code point to match.</p>
<p class="Pp">Starting in 5.32, the Name, Name Aliases, and Named Sequences
    properties are allowed to be matched. They are considered to be a single
    combination property, just as has long been the case for
    <span class="Li">&quot;\N{}&quot;</span>. Loose matching doesn't work in
    exactly the same way for these as it does for the values of other
    properties. The rules are given in
    &lt;https://www.unicode.org/reports/tr44/tr44-24.html#UAX44-LM2&gt;. As a
    result, Perl doesn't try loose matching for you, like it does in other
    properties. All letters in names are uppercase, but you can add
    <span class="Li">&quot;(?i)&quot;</span> to your subpattern to ignore case.
    If you're uncertain where a blank is, you can use <span class="Li">&quot;
    ?&quot;</span> in your subpattern. No character name contains an underscore,
    so don't bother trying to match one. The use of hyphens is particularly
    problematic; refer to the above link. But note that, as of Unicode 13.0, the
    only script in modern usage which has weirdnesses with these is Tibetan;
    also the two Korean characters U+116C HANGUL JUNGSEONG OE and U+1180 HANGUL
    JUNGSEONG O-E. Unicode makes no promises to not add hyphen-problematic names
    in the future.</p>
<p class="Pp">Using wildcards on these is resource intensive, given the hundreds
    of thousands of legal names that must be checked against.</p>
<p class="Pp">An example of using Name property wildcards is</p>
<p class="Pp"></p>
<pre> qr!\p{name=/(SMILING|GRINNING) FACE/}!
</pre>
<p class="Pp">Another is</p>
<p class="Pp"></p>
<pre> qr/(?[ \p{name=\/CJK\/} - \p{ideographic} ])/
</pre>
<p class="Pp">which is the 200-ish (as of Unicode 13.0) CJK characters that
    aren't ideographs.</p>
<p class="Pp">There are certain properties that wildcard subpatterns don't
    currently work with. These are:</p>
<p class="Pp"></p>
<pre> Bidi Mirroring Glyph
 Bidi Paired Bracket
 Case Folding
 Decomposition Mapping
 Equivalent Unified Ideograph
 Lowercase Mapping
 NFKC Case Fold
 Titlecase Mapping
 Uppercase Mapping
</pre>
<p class="Pp">Nor is the
    <span class="Li">&quot;@</span><span class="Li"><i>unicode_property</i></span><span class="Li">@&quot;</span>
    form implemented.</p>
<p class="Pp">Here's a complete example of matching IPV4 internet protocol
    addresses in any (single) script</p>
<p class="Pp"></p>
<pre> no warnings 'experimental::regex_sets';
 no warnings 'experimental::uniprop_wildcards';
 # Can match a substring, so this intermediate regex needs to have
 # context or anchoring in its final use.  Using nt=de yields decimal
 # digits.  When specifying a subset of these, we must include \d to
 # prevent things like U+00B2 SUPERSCRIPT TWO from matching
 my $zero_through_255 =
  qr/ \b (*sr:                                  # All from same sript
            (?[ \p{nv=0} &amp; \d ])*               # Optional leading zeros
        (                                       # Then one of:
                                  \d{1,2}       #   0 - 99
            | (?[ \p{nv=1} &amp; \d ])  \d{2}       #   100 - 199
            | (?[ \p{nv=2} &amp; \d ])
               (  (?[ \p{nv=:[0-4]:} &amp; \d ]) \d #   200 - 249
                | (?[ \p{nv=5}     &amp; \d ])
                  (?[ \p{nv=:[0-5]:} &amp; \d ])    #   250 - 255
               )
        )
      )
    \b
  /x;
 my $ipv4 = qr/ \A (*sr:         $zero_through_255
                         (?: [.] $zero_through_255 ) {3}
                   )
                \z
            /x;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="User-Defined_Character_Properties"><a class="permalink" href="#User-Defined_Character_Properties">User-Defined
  Character Properties</a></h2>
<p class="Pp">You can define your own binary character properties by defining
    subroutines whose names begin with <span class="Li">&quot;In&quot;</span> or
    <span class="Li">&quot;Is&quot;</span>. (The experimental feature &quot;(?[
    ])&quot; in perlre provides an alternative which allows more complex
    definitions.) The subroutines can be defined in any package. They override
    any Unicode properties expressed as the same names. The user-defined
    properties can be used in the regular expression
    <span class="Li">&quot;\p{}&quot;</span> and
    <span class="Li">&quot;\P{}&quot;</span> constructs; if you are using a
    user-defined property from a package other than the one you are in, you must
    specify its package in the <span class="Li">&quot;\p{}&quot;</span> or
    <span class="Li">&quot;\P{}&quot;</span> construct.</p>
<p class="Pp"></p>
<pre>    # assuming property IsForeign defined in Lang::
    package main;  # property package name required
    if ($txt =~ /\p{Lang::IsForeign}+/) { ... }
    package Lang;  # property package name not required
    if ($txt =~ /\p{IsForeign}+/) { ... }
</pre>
<p class="Pp">Note that the effect is compile-time and immutable once defined.
    However, the subroutines are passed a single parameter, which is 0 if
    case-sensitive matching is in effect and non-zero if caseless matching is in
    effect. The subroutine may return different values depending on the value of
    the flag, and one set of values will immutably be in effect for all
    case-sensitive matches, and the other set for all case-insensitive
  matches.</p>
<p class="Pp">Note that if the regular expression is tainted, then Perl will die
    rather than calling the subroutine when the name of the subroutine is
    determined by the tainted data.</p>
<p class="Pp">The subroutines must return a specially-formatted string, with one
    or more newline-separated lines. Each line must be one of the following:</p>
<ul class="Bl-bullet">
  <li>A single hexadecimal number denoting a code point to include.</li>
  <li>Two hexadecimal numbers separated by horizontal whitespace (space or
      tabular characters) denoting a range of code points to include. The second
      number must not be smaller than the first.</li>
  <li>Something to include, prefixed by <span class="Li">&quot;+&quot;</span>: a
      built-in character property (prefixed by
      <span class="Li">&quot;utf8::&quot;</span>) or a fully qualified
      (including package name) user-defined character property, to represent all
      the characters in that property; two hexadecimal code points for a range;
      or a single hexadecimal code point.</li>
  <li>Something to exclude, prefixed by <span class="Li">&quot;-&quot;</span>:
      an existing character property (prefixed by
      <span class="Li">&quot;utf8::&quot;</span>) or a fully qualified
      (including package name) user-defined character property, to represent all
      the characters in that property; two hexadecimal code points for a range;
      or a single hexadecimal code point.</li>
  <li>Something to negate, prefixed <span class="Li">&quot;!&quot;</span>: an
      existing character property (prefixed by
      <span class="Li">&quot;utf8::&quot;</span>) or a fully qualified
      (including package name) user-defined character property, to represent all
      the characters in that property; two hexadecimal code points for a range;
      or a single hexadecimal code point.</li>
  <li>Something to intersect with, prefixed by
      <span class="Li">&quot;&amp;&quot;</span>: an existing character property
      (prefixed by <span class="Li">&quot;utf8::&quot;</span>) or a fully
      qualified (including package name) user-defined character property, for
      all the characters except the characters in the property; two hexadecimal
      code points for a range; or a single hexadecimal code point.</li>
</ul>
<p class="Pp">For example, to define a property that covers both the Japanese
    syllabaries (hiragana and katakana), you can define</p>
<p class="Pp"></p>
<pre>    sub InKana {
        return &lt;&lt;END;
    3040\t309F
    30A0\t30FF
    END
    }
</pre>
<p class="Pp">Imagine that the here-doc end marker is at the beginning of the
    line. Now you can use <span class="Li">&quot;\p{InKana}&quot;</span> and
    <span class="Li">&quot;\P{InKana}&quot;</span>.</p>
<p class="Pp">You could also have used the existing block property names:</p>
<p class="Pp"></p>
<pre>    sub InKana {
        return &lt;&lt;'END';
    +utf8::InHiragana
    +utf8::InKatakana
    END
    }
</pre>
<p class="Pp">Suppose you wanted to match only the allocated characters, not the
    raw block ranges: in other words, you want to remove the unassigned
    characters:</p>
<p class="Pp"></p>
<pre>    sub InKana {
        return &lt;&lt;'END';
    +utf8::InHiragana
    +utf8::InKatakana
    -utf8::IsCn
    END
    }
</pre>
<p class="Pp">The negation is useful for defining (surprise!) negated
  classes.</p>
<p class="Pp"></p>
<pre>    sub InNotKana {
        return &lt;&lt;'END';
    !utf8::InHiragana
    -utf8::InKatakana
    +utf8::IsCn
    END
    }
</pre>
<p class="Pp">This will match all non-Unicode code points, since every one of
    them is not in Kana. You can use intersection to exclude these, if desired,
    as this modified example shows:</p>
<p class="Pp"></p>
<pre>    sub InNotKana {
        return &lt;&lt;'END';
    !utf8::InHiragana
    -utf8::InKatakana
    +utf8::IsCn
    &amp;utf8::Any
    END
    }
</pre>
<p class="Pp"><span class="Li">&amp;utf8::Any</span> must be the last line in
    the definition.</p>
<p class="Pp">Intersection is used generally for getting the common characters
    matched by two (or more) classes. It's important to remember not to use
    <span class="Li">&quot;&amp;&quot;</span> for the first set; that would be
    intersecting with nothing, resulting in an empty set. (Similarly using
    <span class="Li">&quot;-&quot;</span> for the first set does nothing).</p>
<p class="Pp">Unlike non-user-defined <span class="Li">&quot;\p{}&quot;</span>
    property matches, no warning is ever generated if these properties are
    matched against a non-Unicode code point (see &quot;Beyond Unicode code
    points&quot; below).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="User-Defined_Case_Mappings_(for_serious_hackers_only)"><a class="permalink" href="#User-Defined_Case_Mappings_(for_serious_hackers_only)">User-Defined
  Case Mappings (for serious hackers only)</a></h2>
<p class="Pp"><b>This feature has been removed as of Perl 5.16.</b> The CPAN
    module <span class="Li">&quot;Unicode::Casing&quot;</span> provides better
    functionality without the drawbacks that this feature had. If you are using
    a Perl earlier than 5.16, this feature was most fully documented in the 5.14
    version of this pod:
    &lt;http://perldoc.perl.org/5.14.0/perlunicode.html#User-Defined-Case-Mappings-%28for-serious-hackers-only%29&gt;</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Character_Encodings_for_Input_and_Output"><a class="permalink" href="#Character_Encodings_for_Input_and_Output">Character
  Encodings for Input and Output</a></h2>
<p class="Pp">See Encode.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Unicode_Regular_Expression_Support_Level"><a class="permalink" href="#Unicode_Regular_Expression_Support_Level">Unicode
  Regular Expression Support Level</a></h2>
<p class="Pp">The following list of Unicode supported features for regular
    expressions describes all features currently directly supported by core
    Perl. The references to &quot;Level <i>N</i>&quot; and the section numbers
    refer to UTS#18 &quot;Unicode Regular Expressions&quot;
    &lt;https://www.unicode.org/reports/tr18&gt;, version 18, October 2016.</p>
<p class="Pp"><i>Level 1 - Basic Unicode Support</i></p>
<p class="Pp"></p>
<pre> RL1.1   Hex Notation                     - Done          [1]
 RL1.2   Properties                       - Done          [2]
 RL1.2a  Compatibility Properties         - Done          [3]
 RL1.3   Subtraction and Intersection     - Experimental  [4]
 RL1.4   Simple Word Boundaries           - Done          [5]
 RL1.5   Simple Loose Matches             - Done          [6]
 RL1.6   Line Boundaries                  - Partial       [7]
 RL1.7   Supplementary Code Points        - Done          [8]
</pre>
<dl class="Bl-tag">
  <dt>[1] &quot;\N{U+...}&quot; and &quot;\x{...}&quot;</dt>
  <dd></dd>
  <dt>[2] &quot;\p{...}&quot; &quot;\P{...}&quot;. This requirement is for a
    minimal list of properties. Perl supports these. See R2.7 for other
    properties.</dt>
  <dd></dd>
  <dt>[3] Perl has &quot;\d&quot; &quot;\D&quot; &quot;\s&quot; &quot;\S&quot;
    &quot;\w&quot; &quot;\W&quot; &quot;\X&quot; &quot;[:<i>prop</i>:]&quot;
    &quot;[:^<i>prop</i>:]&quot;, plus all the properties specified by
    &lt;https://www.unicode.org/reports/tr18/#Compatibility_Properties&gt;.
    These are described above in &quot;Other Properties&quot;</dt>
  <dd></dd>
  <dt>[4]</dt>
  <dd>The experimental feature <span class="Li">&quot;(?[...])&quot;</span>
      starting in v5.18 accomplishes this.
    <p class="Pp">See &quot;(?[ ])&quot; in perlre. If you don't want to use an
        experimental feature, you can use one of the following:</p>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>Regular expression lookahead
    <p class="Pp">You can mimic class subtraction using lookahead. For example,
        what UTS#18 might write as</p>
    <p class="Pp"></p>
    <pre>    [{Block=Greek}-[{UNASSIGNED}]]
    </pre>
    <p class="Pp">in Perl can be written as:</p>
    <p class="Pp"></p>
    <pre>    (?!\p{Unassigned})\p{Block=Greek}
    (?=\p{Assigned})\p{Block=Greek}
    </pre>
    <p class="Pp">But in this particular example, you probably really want</p>
    <p class="Pp"></p>
    <pre>    \p{Greek}
    </pre>
    <p class="Pp">which will match assigned characters known to be part of the
        Greek script.</p>
  </li>
  <li>CPAN module <span class="Li">&quot;Unicode::Regex::Set&quot;</span>
    <p class="Pp">It does implement the full UTS#18 grouping, intersection,
        union, and removal (subtraction) syntax.</p>
  </li>
  <li>&quot;User-Defined Character Properties&quot;
    <p class="Pp"><span class="Li">&quot;+&quot;</span> for union,
        <span class="Li">&quot;-&quot;</span> for removal (set-difference),
        <span class="Li">&quot;&amp;&quot;</span> for intersection</p>
  </li>
</ul>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>[5] &quot;\b&quot; &quot;\B&quot; meet most, but not all, the details of
    this requirement, but &quot;\b{wb}&quot; and &quot;\B{wb}&quot; do, as well
    as the stricter R2.3.</dt>
  <dd></dd>
  <dt>[6]</dt>
  <dd>Note that Perl does Full case-folding in matching, not Simple:
    <p class="Pp">For example <span class="Li">&quot;U+1F88&quot;</span> is
        equivalent to <span class="Li">&quot;U+1F00 U+03B9&quot;</span>, instead
        of just <span class="Li">&quot;U+1F80&quot;</span>. This difference
        matters mainly for certain Greek capital letters with certain modifiers:
        the Full case-folding decomposes the letter, while the Simple
        case-folding would map it to a single character.</p>
  </dd>
  <dt>[7]</dt>
  <dd>The reason this is considered to be only partially implemented is that
      Perl has <span class="Li">&quot;qr/\b{lb}/&quot;</span> and
      <span class="Li">&quot;Unicode::LineBreak&quot;</span> that are conformant
      with UAX#14 &quot;Unicode Line Breaking Algorithm&quot;
      &lt;https://www.unicode.org/reports/tr14&gt;. The regular expression
      construct provides default behavior, while the heavier-weight module
      provides customizable line breaking.
    <p class="Pp">But Perl treats <span class="Li">&quot;\n&quot;</span> as the
        start- and end-line delimiter, whereas Unicode specifies more characters
        that should be so-interpreted.</p>
    <p class="Pp">These are:</p>
    <p class="Pp"></p>
    <pre> VT   U+000B  (\v in C)
 FF   U+000C  (\f)
 CR   U+000D  (\r)
 NEL  U+0085
 LS   U+2028
 PS   U+2029
    </pre>
    <p class="Pp"><span class="Li">&quot;^&quot;</span> and
        <span class="Li">&quot;$&quot;</span> in regular expression patterns are
        supposed to match all these, but don't. These characters also don't, but
        should, affect <span class="Li">&quot;&lt;&gt;&quot;</span>
        <span class="Li">$.</span>, and script line numbers.</p>
    <p class="Pp">Also, lines should not be split within
        <span class="Li">&quot;CRLF&quot;</span> (i.e. there is no empty line
        between <span class="Li">&quot;\r&quot;</span> and
        <span class="Li">&quot;\n&quot;</span>). For
        <span class="Li">&quot;CRLF&quot;</span>, try the
        <span class="Li">&quot;:crlf&quot;</span> layer (see PerlIO).</p>
  </dd>
  <dt>[8] UTF-8/UTF-EBDDIC used in Perl allows not only &quot;U+10000&quot; to
    &quot;U+10FFFF&quot; but also beyond &quot;U+10FFFF&quot;</dt>
  <dd></dd>
</dl>
<p class="Pp"><i>Level 2 - Extended Unicode Support</i></p>
<p class="Pp"></p>
<pre> RL2.1   Canonical Equivalents           - Retracted     [9]
                                           by Unicode
 RL2.2   Extended Grapheme Clusters and  - Partial       [10]
         Character Classes with Strings
 RL2.3   Default Word Boundaries         - Done          [11]
 RL2.4   Default Case Conversion         - Done
 RL2.5   Name Properties                 - Done
 RL2.6   Wildcards in Property Values    - Partial       [12]
 RL2.7   Full Properties                 - Partial       [13]
 RL2.8   Optional Properties             - Partial       [14]
</pre>
<dl class="Bl-tag">
  <dt>[9] Unicode has rewritten this portion of UTS#18 to say that getting
    canonical equivalence (see UAX#15 &quot;Unicode Normalization Forms&quot;
    &lt;https://www.unicode.org/reports/tr15&gt;) is basically to be done at the
    programmer level. Use NFD to write both your regular expressions and text to
    match them against (you can use Unicode::Normalize).</dt>
  <dd></dd>
  <dt>[10] Perl has &quot;\X&quot; and &quot;\b{gcb}&quot;. Unicode has
    retracted their &quot;Grapheme Cluster Mode&quot;, and recently added string
    properties, which Perl does not yet support.</dt>
  <dd></dd>
  <dt>[11] see UAX#29 &quot;Unicode Text Segmentation&quot;
    &lt;https://www.unicode.org/reports/tr29&gt;,</dt>
  <dd></dd>
  <dt>[12] see &quot;Wildcards in Property Values&quot; above.</dt>
  <dd></dd>
  <dt>[13] Perl supports all the properties in the Unicode Character Database
    (UCD). It does not yet support the listed properties that come from other
    Unicode sources.</dt>
  <dd></dd>
  <dt>[14] The only optional property that Perl supports is Named Sequence. None
    of these properties are in the UCD.</dt>
  <dd></dd>
</dl>
<p class="Pp"><i>Level 3 - Tailored Support</i></p>
<p class="Pp">This has been retracted by Unicode.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Unicode_Encodings"><a class="permalink" href="#Unicode_Encodings">Unicode
  Encodings</a></h2>
<p class="Pp">Unicode characters are assigned to <i>code points</i>, which are
    abstract numbers. To use these numbers, various encodings are needed.</p>
<ul class="Bl-bullet">
  <li>UTF-8
    <p class="Pp">UTF-8 is a variable-length (1 to 4 bytes), byte-order
        independent encoding. In most of Perl's documentation, including
        elsewhere in this document, the term &quot;UTF-8&quot; means also
        &quot;UTF-EBCDIC&quot;. But in this section, &quot;UTF-8&quot; refers
        only to the encoding used on ASCII platforms. It is a superset of 7-bit
        US-ASCII, so anything encoded in ASCII has the identical representation
        when encoded in UTF-8.</p>
    <p class="Pp">The following table is from Unicode 3.2.</p>
    <p class="Pp"></p>
    <pre> Code Points            1st Byte  2nd Byte  3rd Byte 4th Byte
   U+0000..U+007F       00..7F
   U+0080..U+07FF     * C2..DF    80..BF
   U+0800..U+0FFF       E0      * A0..BF    80..BF
   U+1000..U+CFFF       E1..EC    80..BF    80..BF
   U+D000..U+D7FF       ED        80..9F    80..BF
   U+D800..U+DFFF       +++++ utf16 surrogates, not legal utf8 +++++
   U+E000..U+FFFF       EE..EF    80..BF    80..BF
  U+10000..U+3FFFF      F0      * 90..BF    80..BF    80..BF
  U+40000..U+FFFFF      F1..F3    80..BF    80..BF    80..BF
 U+100000..U+10FFFF     F4        80..8F    80..BF    80..BF
    </pre>
    <p class="Pp">Note the gaps marked by &quot;*&quot; before several of the
        byte entries above. These are caused by legal UTF-8 avoiding
        non-shortest encodings: it is technically possible to UTF-8-encode a
        single code point in different ways, but that is explicitly forbidden,
        and the shortest possible encoding should always be used (and that is
        what Perl does).</p>
    <p class="Pp">Another way to look at it is via bits:</p>
    <p class="Pp"></p>
    <pre>                Code Points  1st Byte  2nd Byte  3rd Byte  4th Byte
                   0aaaaaaa  0aaaaaaa
           00000bbbbbaaaaaa  110bbbbb  10aaaaaa
           ccccbbbbbbaaaaaa  1110cccc  10bbbbbb  10aaaaaa
 00000dddccccccbbbbbbaaaaaa  11110ddd  10cccccc  10bbbbbb  10aaaaaa
    </pre>
    <p class="Pp">As you can see, the continuation bytes all begin with
        <span class="Li">&quot;10&quot;</span>, and the leading bits of the
        start byte tell how many bytes there are in the encoded character.</p>
    <p class="Pp">The original UTF-8 specification allowed up to 6 bytes, to
        allow encoding of numbers up to
        <span class="Li">&quot;0x7FFF_FFFF&quot;</span>. Perl continues to allow
        those, and has extended that up to 13 bytes to encode code points up to
        what can fit in a 64-bit word. However, Perl will warn if you output any
        of these as being non-portable; and under strict UTF-8 input protocols,
        they are forbidden. In addition, it is now illegal to use a code point
        larger than what a signed integer variable on your system can hold. On
        32-bit ASCII systems, this means
        <span class="Li">&quot;0x7FFF_FFFF&quot;</span> is the legal maximum
        (much higher on 64-bit systems).</p>
  </li>
  <li>UTF-EBCDIC
    <p class="Pp">Like UTF-8, but EBCDIC-safe, in the way that UTF-8 is
        ASCII-safe. This means that all the basic characters (which includes all
        those that have ASCII equivalents (like
        <span class="Li">&quot;A&quot;</span>,
        <span class="Li">&quot;0&quot;</span>,
        <span class="Li">&quot;%&quot;</span>, <i>etc.</i>) are the same in both
        EBCDIC and UTF-EBCDIC.)</p>
    <p class="Pp">UTF-EBCDIC is used on EBCDIC platforms. It generally requires
        more bytes to represent a given code point than UTF-8 does; the largest
        Unicode code points take 5 bytes to represent (instead of 4 in UTF-8),
        and, extended for 64-bit words, it uses 14 bytes instead of 13 bytes in
        UTF-8.</p>
  </li>
  <li>UTF-16, UTF-16BE, UTF-16LE, Surrogates, and
      <span class="Li">&quot;BOM&quot;</span>'s (Byte Order Marks)
    <p class="Pp">The followings items are mostly for reference and general
        Unicode knowledge, Perl doesn't use these constructs internally.</p>
    <p class="Pp">Like UTF-8, UTF-16 is a variable-width encoding, but where
        UTF-8 uses 8-bit code units, UTF-16 uses 16-bit code units. All code
        points occupy either 2 or 4 bytes in UTF-16: code points
        <span class="Li">&quot;U+0000..U+FFFF&quot;</span> are stored in a
        single 16-bit unit, and code points
        <span class="Li">&quot;U+10000..U+10FFFF&quot;</span> in two 16-bit
        units. The latter case is using <i>surrogates</i>, the first 16-bit unit
        being the <i>high</i> <i>surrogate</i>, and the second being the <i>low
        surrogate</i>.</p>
    <p class="Pp">Surrogates are code points set aside to encode the
        <span class="Li">&quot;U+10000..U+10FFFF&quot;</span> range of Unicode
        code points in pairs of 16-bit units. The <i>high</i> <i>surrogates</i>
        are the range <span class="Li">&quot;U+D800..U+DBFF&quot;</span> and the
        <i>low surrogates</i> are the range
        <span class="Li">&quot;U+DC00..U+DFFF&quot;</span>. The surrogate
        encoding is</p>
    <p class="Pp"></p>
    <pre>    $hi = ($uni - 0x10000) / 0x400 + 0xD800;
    $lo = ($uni - 0x10000) % 0x400 + 0xDC00;
    </pre>
    <p class="Pp">and the decoding is</p>
    <p class="Pp"></p>
    <pre>    $uni = 0x10000 + ($hi - 0xD800) * 0x400 + ($lo - 0xDC00);
    </pre>
    <p class="Pp">Because of the 16-bitness, UTF-16 is byte-order dependent.
        UTF-16 itself can be used for in-memory computations, but if storage or
        transfer is required either UTF-16BE (big-endian) or UTF-16LE
        (little-endian) encodings must be chosen.</p>
    <p class="Pp">This introduces another problem: what if you just know that
        your data is UTF-16, but you don't know which endianness? Byte Order
        Marks, or <span class="Li">&quot;BOM&quot;</span>'s, are a solution to
        this. A special character has been reserved in Unicode to function as a
        byte order marker: the character with the code point
        <span class="Li">&quot;U+FEFF&quot;</span> is the
        <span class="Li">&quot;BOM&quot;</span>.</p>
    <p class="Pp">The trick is that if you read a
        <span class="Li">&quot;BOM&quot;</span>, you will know the byte order,
        since if it was written on a big-endian platform, you will read the
        bytes <span class="Li">&quot;0xFE 0xFF&quot;</span>, but if it was
        written on a little-endian platform, you will read the bytes
        <span class="Li">&quot;0xFF 0xFE&quot;</span>. (And if the originating
        platform was writing in ASCII platform UTF-8, you will read the bytes
        <span class="Li">&quot;0xEF 0xBB 0xBF&quot;</span>.)</p>
    <p class="Pp">The way this trick works is that the character with the code
        point <span class="Li">&quot;U+FFFE&quot;</span> is not supposed to be
        in input streams, so the sequence of bytes <span class="Li">&quot;0xFF
        0xFE&quot;</span> is unambiguously
        &quot;<span class="Li">&quot;BOM&quot;</span>, represented in
        little-endian format&quot; and cannot be
        <span class="Li">&quot;U+FFFE&quot;</span>, represented in big-endian
        format&quot;.</p>
    <p class="Pp">Surrogates have no meaning in Unicode outside their use in
        pairs to represent other code points. However, Perl allows them to be
        represented individually internally, for example by saying
        <span class="Li">&quot;chr(0xD801)&quot;</span>, so that all code
        points, not just those valid for open interchange, are representable.
        Unicode does define semantics for them, such as their
        <span class="Li">&quot;General_Category&quot;</span> is
        <span class="Li">&quot;Cs&quot;</span>. But because their use is
        somewhat dangerous, Perl will warn (using the warning category
        <span class="Li">&quot;surrogate&quot;</span>, which is a sub-category
        of <span class="Li">&quot;utf8&quot;</span>) if an attempt is made to do
        things like take the lower case of one, or match case-insensitively, or
        to output them. (But don't try this on Perls before 5.14.)</p>
  </li>
  <li>UTF-32, UTF-32BE, UTF-32LE
    <p class="Pp">The UTF-32 family is pretty much like the UTF-16 family,
        except that the units are 32-bit, and therefore the surrogate scheme is
        not needed. UTF-32 is a fixed-width encoding. The
        <span class="Li">&quot;BOM&quot;</span> signatures are
        <span class="Li">&quot;0x00 0x00 0xFE 0xFF&quot;</span> for BE and
        <span class="Li">&quot;0xFF 0xFE 0x00 0x00&quot;</span> for LE.</p>
  </li>
  <li>UCS-2, UCS-4
    <p class="Pp">Legacy, fixed-width encodings defined by the ISO 10646
        standard. UCS-2 is a 16-bit encoding. Unlike UTF-16, UCS-2 is not
        extensible beyond <span class="Li">&quot;U+FFFF&quot;</span>, because it
        does not use surrogates. UCS-4 is a 32-bit encoding, functionally
        identical to UTF-32 (the difference being that UCS-4 forbids neither
        surrogates nor code points larger than
        <span class="Li">&quot;0x10_FFFF&quot;</span>).</p>
  </li>
  <li>UTF-7
    <p class="Pp">A seven-bit safe (non-eight-bit) encoding, which is useful if
        the transport or storage is not eight-bit safe. Defined by RFC 2152.</p>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Noncharacter_code_points"><a class="permalink" href="#Noncharacter_code_points">Noncharacter
  code points</a></h2>
<p class="Pp">66 code points are set aside in Unicode as &quot;noncharacter code
    points&quot;. These all have the
    <span class="Li">&quot;Unassigned&quot;</span>
    (<span class="Li">&quot;Cn&quot;</span>)
    <span class="Li">&quot;General_Category&quot;</span>, and no character will
    ever be assigned to any of them. They are the 32 code points between
    <span class="Li">&quot;U+FDD0&quot;</span> and
    <span class="Li">&quot;U+FDEF&quot;</span> inclusive, and the 34 code
    points:</p>
<p class="Pp"></p>
<pre> U+FFFE   U+FFFF
 U+1FFFE  U+1FFFF
 U+2FFFE  U+2FFFF
 ...
 U+EFFFE  U+EFFFF
 U+FFFFE  U+FFFFF
 U+10FFFE U+10FFFF
</pre>
<p class="Pp">Until Unicode 7.0, the noncharacters were &quot;<b>forbidden</b>
    for use in open interchange of Unicode text data&quot;, so that code that
    processed those streams could use these code points as sentinels that could
    be mixed in with character data, and would always be distinguishable from
    that data. (Emphasis above and in the next paragraph are added in this
    document.)</p>
<p class="Pp">Unicode 7.0 changed the wording so that they are &quot;<b>not
    recommended</b> for use in open interchange of Unicode text data&quot;. The
    7.0 Standard goes on to say:</p>
<p class="Pp"></p>
<div class="Bd-indent">&quot;If a noncharacter is received in open interchange,
  an application is not required to interpret it in any way. It is good
  practice, however, to recognize it as a noncharacter and to take appropriate
  action, such as replacing it with <span class="Li">&quot;U+FFFD&quot;</span>
  replacement character, to indicate the problem in the text. It is not
  recommended to simply delete noncharacter code points from such text, because
  of the potential security issues caused by deleting uninterpreted characters.
  (See conformance clause C7 in Section 3.2, Conformance Requirements, and
  Unicode Technical Report #36, &quot;Unicode Security Considerations&quot;
  &lt;https://www.unicode.org/reports/tr36/#Substituting_for_Ill_Formed_Subsequences&gt;).&quot;</div>
<p class="Pp">This change was made because it was found that various commercial
    tools like editors, or for things like source code control, had been written
    so that they would not handle program files that used these code points,
    effectively precluding their use almost entirely! And that was never the
    intent. They've always been meant to be usable within an application, or
    cooperating set of applications, at will.</p>
<p class="Pp">If you're writing code, such as an editor, that is supposed to be
    able to handle any Unicode text data, then you shouldn't be using these code
    points yourself, and instead allow them in the input. If you need sentinels,
    they should instead be something that isn't legal Unicode. For UTF-8 data,
    you can use the bytes 0xC1 and 0xC2 as sentinels, as they never appear in
    well-formed UTF-8. (There are equivalents for UTF-EBCDIC). You can also
    store your Unicode code points in integer variables and use negative values
    as sentinels.</p>
<p class="Pp">If you're not writing such a tool, then whether you accept
    noncharacters as input is up to you (though the Standard recommends that you
    not). If you do strict input stream checking with Perl, these code points
    continue to be forbidden. This is to maintain backward compatibility
    (otherwise potential security holes could open up, as an unsuspecting
    application that was written assuming the noncharacters would be filtered
    out before getting to it, could now, without warning, start getting them).
    To do strict checking, you can use the layer
    <span class="Li">&quot;:encoding('UTF-8')&quot;</span>.</p>
<p class="Pp">Perl continues to warn (using the warning category
    <span class="Li">&quot;nonchar&quot;</span>, which is a sub-category of
    <span class="Li">&quot;utf8&quot;</span>) if an attempt is made to output
    noncharacters.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Beyond_Unicode_code_points"><a class="permalink" href="#Beyond_Unicode_code_points">Beyond
  Unicode code points</a></h2>
<p class="Pp">The maximum Unicode code point is
    <span class="Li">&quot;U+10FFFF&quot;</span>, and Unicode only defines
    operations on code points up through that. But Perl works on code points up
    to the maximum permissible signed number available on the platform. However,
    Perl will not accept these from input streams unless lax rules are being
    used, and will warn (using the warning category
    <span class="Li">&quot;non_unicode&quot;</span>, which is a sub-category of
    <span class="Li">&quot;utf8&quot;</span>) if any are output.</p>
<p class="Pp">Since Unicode rules are not defined on these code points, if a
    Unicode-defined operation is done on them, Perl uses what we believe are
    sensible rules, while generally warning, using the
    <span class="Li">&quot;non_unicode&quot;</span> category. For example,
    <span class="Li">&quot;uc(&quot;\x{11_0000}&quot;)&quot;</span> will
    generate such a warning, returning the input parameter as its result, since
    Perl defines the uppercase of every non-Unicode code point to be the code
    point itself. (All the case changing operations, not just uppercasing, work
    this way.)</p>
<p class="Pp">The situation with matching Unicode properties in regular
    expressions, the <span class="Li">&quot;\p{}&quot;</span> and
    <span class="Li">&quot;\P{}&quot;</span> constructs, against these code
    points is not as clear cut, and how these are handled has changed as we've
    gained experience.</p>
<p class="Pp">One possibility is to treat any match against these code points as
    undefined. But since Perl doesn't have the concept of a match being
    undefined, it converts this to failing or
    <span class="Li">&quot;FALSE&quot;</span>. This is almost, but not quite,
    what Perl did from v5.14 (when use of these code points became generally
    reliable) through v5.18. The difference is that Perl treated all
    <span class="Li">&quot;\p{}&quot;</span> matches as failing, but all
    <span class="Li">&quot;\P{}&quot;</span> matches as succeeding.</p>
<p class="Pp">One problem with this is that it leads to unexpected, and
    confusing results in some cases:</p>
<p class="Pp"></p>
<pre> chr(0x110000) =~ \p{ASCII_Hex_Digit=True}      # Failed on &lt;= v5.18
 chr(0x110000) =~ \p{ASCII_Hex_Digit=False}     # Failed! on &lt;= v5.18
</pre>
<p class="Pp">That is, it treated both matches as undefined, and converted that
    to false (raising a warning on each). The first case is the expected result,
    but the second is likely counterintuitive: &quot;How could both be false
    when they are complements?&quot; Another problem was that the implementation
    optimized many Unicode property matches down to already existing simpler,
    faster operations, which don't raise the warning. We chose to not forgo
    those optimizations, which help the vast majority of matches, just to
    generate a warning for the unlikely event that an above-Unicode code point
    is being matched against.</p>
<p class="Pp">As a result of these problems, starting in v5.20, what Perl does
    is to treat non-Unicode code points as just typical unassigned Unicode
    characters, and matches accordingly. (Note: Unicode has atypical unassigned
    code points. For example, it has noncharacter code points, and ones that,
    when they do get assigned, are destined to be written Right-to-left, as
    Arabic and Hebrew are. Perl assumes that no non-Unicode code point has any
    atypical properties.)</p>
<p class="Pp">Perl, in most cases, will raise a warning when matching an
    above-Unicode code point against a Unicode property when the result is
    <span class="Li">&quot;TRUE&quot;</span> for
    <span class="Li">&quot;\p{}&quot;</span>, and
    <span class="Li">&quot;FALSE&quot;</span> for
    <span class="Li">&quot;\P{}&quot;</span>. For example:</p>
<p class="Pp"></p>
<pre> chr(0x110000) =~ \p{ASCII_Hex_Digit=True}      # Fails, no warning
 chr(0x110000) =~ \p{ASCII_Hex_Digit=False}     # Succeeds, with warning
</pre>
<p class="Pp">In both these examples, the character being matched is
    non-Unicode, so Unicode doesn't define how it should match. It clearly isn't
    an ASCII hex digit, so the first example clearly should fail, and so it
    does, with no warning. But it is arguable that the second example should
    have an undefined, hence <span class="Li">&quot;FALSE&quot;</span>, result.
    So a warning is raised for it.</p>
<p class="Pp">Thus the warning is raised for many fewer cases than in earlier
    Perls, and only when what the result is could be arguable. It turns out that
    none of the optimizations made by Perl (or are ever likely to be made) cause
    the warning to be skipped, so it solves both problems of Perl's earlier
    approach. The most commonly used property that is affected by this change is
    <span class="Li">&quot;\p{Unassigned}&quot;</span> which is a short form for
    <span class="Li">&quot;\p{General_Category=Unassigned}&quot;</span>.
    Starting in v5.20, all non-Unicode code points are considered
    <span class="Li">&quot;Unassigned&quot;</span>. In earlier releases the
    matches failed because the result was considered undefined.</p>
<p class="Pp">The only place where the warning is not raised when it might ought
    to have been is if optimizations cause the whole pattern match to not even
    be attempted. For example, Perl may figure out that for a string to match a
    certain regular expression pattern, the string has to contain the substring
    <span class="Li">&quot;foobar&quot;</span>. Before attempting the match,
    Perl may look for that substring, and if not found, immediately fail the
    match without actually trying it; so no warning gets generated even if the
    string contains an above-Unicode code point.</p>
<p class="Pp">This behavior is more &quot;Do what I mean&quot; than in earlier
    Perls for most applications. But it catches fewer issues for code that needs
    to be strictly Unicode compliant. Therefore there is an additional mode of
    operation available to accommodate such code. This mode is enabled if a
    regular expression pattern is compiled within the lexical scope where the
    <span class="Li">&quot;non_unicode&quot;</span> warning class has been made
    fatal, say by:</p>
<p class="Pp"></p>
<pre> use warnings FATAL =&gt; &quot;non_unicode&quot;
</pre>
<p class="Pp">(see warnings). In this mode of operation, Perl will raise the
    warning for all matches against a non-Unicode code point (not just the
    arguable ones), and it skips the optimizations that might cause the warning
    to not be output. (It currently still won't warn if the match isn't even
    attempted, like in the <span class="Li">&quot;foobar&quot;</span> example
    above.)</p>
<p class="Pp">In summary, Perl now normally treats non-Unicode code points as
    typical Unicode unassigned code points for regular expression matches,
    raising a warning only when it is arguable what the result should be.
    However, if this warning has been made fatal, it isn't skipped.</p>
<p class="Pp">There is one exception to all this.
    <span class="Li">&quot;\p{All}&quot;</span> looks like a Unicode property,
    but it is a Perl extension that is defined to be true for all possible code
    points, Unicode or not, so no warning is ever generated when matching this
    against a non-Unicode code point. (Prior to v5.20, it was an exact synonym
    for <span class="Li">&quot;\p{Any}&quot;</span>, matching code points
    <span class="Li">0</span> through <span class="Li">0x10FFFF</span>.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Security_Implications_of_Unicode"><a class="permalink" href="#Security_Implications_of_Unicode">Security
  Implications of Unicode</a></h2>
<p class="Pp">First, read Unicode Security Considerations
    &lt;https://www.unicode.org/reports/tr36&gt;.</p>
<p class="Pp">Also, note the following:</p>
<ul class="Bl-bullet">
  <li>Malformed UTF-8
    <p class="Pp">UTF-8 is very structured, so many combinations of bytes are
        invalid. In the past, Perl tried to soldier on and make some sense of
        invalid combinations, but this can lead to security holes, so now, if
        the Perl core needs to process an invalid combination, it will either
        raise a fatal error, or will replace those bytes by the sequence that
        forms the Unicode REPLACEMENT CHARACTER, for which purpose Unicode
        created it.</p>
    <p class="Pp">Every code point can be represented by more than one possible
        syntactically valid UTF-8 sequence. Early on, both Unicode and Perl
        considered any of these to be valid, but now, all sequences longer than
        the shortest possible one are considered to be malformed.</p>
    <p class="Pp">Unicode considers many code points to be illegal, or to be
        avoided. Perl generally accepts them, once they have passed through any
        input filters that may try to exclude them. These have been discussed
        above (see &quot;Surrogates&quot; under UTF-16 in &quot;Unicode
        Encodings&quot;, &quot;Noncharacter code points&quot;, and &quot;Beyond
        Unicode code points&quot;).</p>
  </li>
  <li>Regular expression pattern matching may surprise you if you're not
      accustomed to Unicode. Starting in Perl 5.14, several pattern modifiers
      are available to control this, called the character set modifiers. Details
      are given in &quot;Character set modifiers&quot; in perlre.</li>
</ul>
<p class="Pp">As discussed elsewhere, Perl has one foot (two hooves?) planted in
    each of two worlds: the old world of ASCII and single-byte locales, and the
    new world of Unicode, upgrading when necessary. If your legacy code does not
    explicitly use Unicode, no automatic switch-over to Unicode should
  happen.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Unicode_in_Perl_on_"><a class="permalink" href="#Unicode_in_Perl_on_">Unicode
  in Perl on EBCDIC</a></h2>
<p class="Pp">Unicode is supported on EBCDIC platforms. See perlebcdic.</p>
<p class="Pp">Unless ASCII vs. EBCDIC issues are specifically being discussed,
    references to UTF-8 encoding in this document and elsewhere should be read
    as meaning UTF-EBCDIC on EBCDIC platforms. See &quot;Unicode and UTF&quot;
    in perlebcdic.</p>
<p class="Pp">Because UTF-EBCDIC is so similar to UTF-8, the differences are
    mostly hidden from you; <span class="Li">&quot;use&#x00A0;utf8&quot;</span>
    (and NOT something like
    <span class="Li">&quot;use&#x00A0;utfebcdic&quot;</span>) declares the
    script is in the platform's &quot;native&quot; 8-bit encoding of Unicode.
    (Similarly for the <span class="Li">&quot;:utf8&quot;</span> layer.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Locales"><a class="permalink" href="#Locales">Locales</a></h2>
<p class="Pp">See &quot;Unicode and UTF-8&quot; in perllocale</p>
</section>
<section class="Ss">
<h2 class="Ss" id="When_Unicode_Does_Not_Happen"><a class="permalink" href="#When_Unicode_Does_Not_Happen">When
  Unicode Does Not Happen</a></h2>
<p class="Pp">There are still many places where Unicode (in some encoding or
    another) could be given as arguments or received as results, or both in
    Perl, but it is not, in spite of Perl having extensive ways to input and
    output in Unicode, and a few other &quot;entry points&quot; like the
    <span class="Li">@ARGV</span> array (which can sometimes be interpreted as
    UTF-8).</p>
<p class="Pp">The following are such interfaces. Also, see &quot;The
    &quot;Unicode Bug&quot;&quot;. For all of these interfaces Perl currently
    (as of v5.16.0) simply assumes byte strings both as arguments and results,
    or UTF-8 strings if the (deprecated)
    <span class="Li">&quot;encoding&quot;</span> pragma has been used.</p>
<p class="Pp">One reason that Perl does not attempt to resolve the role of
    Unicode in these situations is that the answers are highly dependent on the
    operating system and the file system(s). For example, whether filenames can
    be in Unicode and in exactly what kind of encoding, is not exactly a
    portable concept. Similarly for <span class="Li">&quot;qx&quot;</span> and
    <span class="Li">&quot;system&quot;</span>: how well will the
    &quot;command-line interface&quot; (and which of them?) handle Unicode?</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;chdir&quot;</span>,
      <span class="Li">&quot;chmod&quot;</span>,
      <span class="Li">&quot;chown&quot;</span>,
      <span class="Li">&quot;chroot&quot;</span>,
      <span class="Li">&quot;exec&quot;</span>,
      <span class="Li">&quot;link&quot;</span>,
      <span class="Li">&quot;lstat&quot;</span>,
      <span class="Li">&quot;mkdir&quot;</span>,
      <span class="Li">&quot;rename&quot;</span>,
      <span class="Li">&quot;rmdir&quot;</span>,
      <span class="Li">&quot;stat&quot;</span>,
      <span class="Li">&quot;symlink&quot;</span>,
      <span class="Li">&quot;truncate&quot;</span>,
      <span class="Li">&quot;unlink&quot;</span>,
      <span class="Li">&quot;utime&quot;</span>,
      <span class="Li">&quot;-X&quot;</span></li>
  <li><span class="Li">%ENV</span></li>
  <li><span class="Li">&quot;glob&quot;</span> (aka the
      <span class="Li">&quot;&lt;*&gt;&quot;</span>)</li>
  <li><span class="Li">&quot;open&quot;</span>,
      <span class="Li">&quot;opendir&quot;</span>,
      <span class="Li">&quot;sysopen&quot;</span></li>
  <li><span class="Li">&quot;qx&quot;</span> (aka the backtick operator),
      <span class="Li">&quot;system&quot;</span></li>
  <li><span class="Li">&quot;readdir&quot;</span>,
      <span class="Li">&quot;readlink&quot;</span></li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="The__Unicode_Bug_"><a class="permalink" href="#The__Unicode_Bug_">The
  &quot;Unicode Bug&quot;</a></h2>
<p class="Pp">The term, &quot;Unicode bug&quot; has been applied to an
    inconsistency with the code points in the <span class="Li">&quot;Latin-1
    Supplement&quot;</span> block, that is, between 128 and 255. Without a
    locale specified, unlike all other characters or code points, these
    characters can have very different semantics depending on the rules in
    effect. (Characters whose code points are above 255 force Unicode rules;
    whereas the rules for ASCII characters are the same under both ASCII and
    Unicode rules.)</p>
<p class="Pp">Under Unicode rules, these upper-Latin1 characters are interpreted
    as Unicode code points, which means they have the same semantics as Latin-1
    (ISO-8859-1) and C1 controls.</p>
<p class="Pp">As explained in &quot;ASCII Rules versus Unicode Rules&quot;,
    under ASCII rules, they are considered to be unassigned characters.</p>
<p class="Pp">This can lead to unexpected results. For example, a string's
    semantics can suddenly change if a code point above 255 is appended to it,
    which changes the rules from ASCII to Unicode. As an example, consider the
    following program and its output:</p>
<p class="Pp"></p>
<pre> $ perl -le'
     no feature &quot;unicode_strings&quot;;
     $s1 = &quot;\xC2&quot;;
     $s2 = &quot;\x{2660}&quot;;
     for ($s1, $s2, $s1.$s2) {
         print /\w/ || 0;
     }
 '
 0
 0
 1
</pre>
<p class="Pp">If there's no <span class="Li">&quot;\w&quot;</span> in
    <span class="Li">&quot;s1&quot;</span> nor in
    <span class="Li">&quot;s2&quot;</span>, why does their concatenation have
    one?</p>
<p class="Pp">This anomaly stems from Perl's attempt to not disturb older
    programs that didn't use Unicode, along with Perl's desire to add Unicode
    support seamlessly. But the result turned out to not be seamless. (By the
    way, you can choose to be warned when things like this happen. See
    <span class="Li">&quot;encoding::warnings&quot;</span>.)</p>
<p class="Pp"><span class="Li">&quot;use&#x00A0;feature&#x00A0;'unicode_strings'&quot;</span>
    was added, starting in Perl v5.12, to address this problem. It affects these
    things:</p>
<ul class="Bl-bullet">
  <li>Changing the case of a scalar, that is, using
      <span class="Li">&quot;uc()&quot;</span>,
      <span class="Li">&quot;ucfirst()&quot;</span>,
      <span class="Li">&quot;lc()&quot;</span>, and
      <span class="Li">&quot;lcfirst()&quot;</span>, or
      <span class="Li">&quot;\L&quot;</span>,
      <span class="Li">&quot;\U&quot;</span>,
      <span class="Li">&quot;\u&quot;</span> and
      <span class="Li">&quot;\l&quot;</span> in double-quotish contexts, such as
      regular expression substitutions.
    <p class="Pp">Under <span class="Li">&quot;unicode_strings&quot;</span>
        starting in Perl 5.12.0, Unicode rules are generally used. See
        &quot;lc&quot; in perlfunc for details on how this works in combination
        with various other pragmas.</p>
  </li>
  <li>Using caseless (<span class="Li">&quot;/i&quot;</span>) regular expression
      matching.
    <p class="Pp">Starting in Perl 5.14.0, regular expressions compiled within
        the scope of <span class="Li">&quot;unicode_strings&quot;</span> use
        Unicode rules even when executed or compiled into larger regular
        expressions outside the scope.</p>
  </li>
  <li>Matching any of several properties in regular expressions.
    <p class="Pp">These properties are <span class="Li">&quot;\b&quot;</span>
        (without braces), <span class="Li">&quot;\B&quot;</span> (without
        braces), <span class="Li">&quot;\s&quot;</span>,
        <span class="Li">&quot;\S&quot;</span>,
        <span class="Li">&quot;\w&quot;</span>,
        <span class="Li">&quot;\W&quot;</span>, and all the Posix character
        classes <i>except</i>
      <span class="Li">&quot;[[:ascii:]]&quot;</span>.</p>
    <p class="Pp">Starting in Perl 5.14.0, regular expressions compiled within
        the scope of <span class="Li">&quot;unicode_strings&quot;</span> use
        Unicode rules even when executed or compiled into larger regular
        expressions outside the scope.</p>
  </li>
  <li>In <span class="Li">&quot;quotemeta&quot;</span> or its inline equivalent
      <span class="Li">&quot;\Q&quot;</span>.
    <p class="Pp">Starting in Perl 5.16.0, consistent quoting rules are used
        within the scope of <span class="Li">&quot;unicode_strings&quot;</span>,
        as described in &quot;quotemeta&quot; in perlfunc. Prior to that, or
        outside its scope, no code points above 127 are quoted in UTF-8 encoded
        strings, but in byte encoded strings, code points between 128-255 are
        always quoted.</p>
  </li>
  <li>In the <span class="Li">&quot;..&quot;</span> or range operator.
    <p class="Pp">Starting in Perl 5.26.0, the range operator on strings treats
        their lengths consistently within the scope of
        <span class="Li">&quot;unicode_strings&quot;</span>. Prior to that, or
        outside its scope, it could produce strings whose length in characters
        exceeded that of the right-hand side, where the right-hand side took up
        more bytes than the correct range endpoint.</p>
  </li>
  <li>In <span class="Li">&quot;split&quot;</span>'s special-case whitespace
      splitting.
    <p class="Pp">Starting in Perl 5.28.0, the
        <span class="Li">&quot;split&quot;</span> function with a pattern
        specified as a string containing a single space handles whitespace
        characters consistently within the scope of
        <span class="Li">&quot;unicode_strings&quot;</span>. Prior to that, or
        outside its scope, characters that are whitespace according to Unicode
        rules but not according to ASCII rules were treated as field contents
        rather than field separators when they appear in byte-encoded
      strings.</p>
  </li>
</ul>
<p class="Pp">You can see from the above that the effect of
    <span class="Li">&quot;unicode_strings&quot;</span> increased over several
    Perl releases. (And Perl's support for Unicode continues to improve; it's
    best to use the latest available release in order to get the most complete
    and accurate results possible.) Note that
    <span class="Li">&quot;unicode_strings&quot;</span> is automatically chosen
    if you <span class="Li">&quot;use&#x00A0;5.012&quot;</span> or higher.</p>
<p class="Pp">For Perls earlier than those described above, or when a string is
    passed to a function outside the scope of
    <span class="Li">&quot;unicode_strings&quot;</span>, see the next
  section.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Forcing_Unicode_in_Perl_(Or_Unforcing_Unicode_in_Perl)"><a class="permalink" href="#Forcing_Unicode_in_Perl_(Or_Unforcing_Unicode_in_Perl)">Forcing
  Unicode in Perl (Or Unforcing Unicode in Perl)</a></h2>
<p class="Pp">Sometimes (see &quot;When Unicode Does Not Happen&quot; or
    &quot;The &quot;Unicode Bug&quot;&quot;) there are situations where you
    simply need to force a byte string into UTF-8, or vice versa. The standard
    module Encode can be used for this, or the low-level calls
    <span class="Li">&quot;utf8::upgrade($bytestring)&quot;</span> and
    <span class="Li">&quot;utf8::downgrade($utf8string[,
  FAIL_OK])&quot;</span>.</p>
<p class="Pp">Note that <span class="Li">&quot;utf8::downgrade()&quot;</span>
    can fail if the string contains characters that don't fit into a byte.</p>
<p class="Pp">Calling either function on a string that already is in the desired
    state is a no-op.</p>
<p class="Pp">&quot;ASCII Rules versus Unicode Rules&quot; gives all the ways
    that a string is made to use Unicode rules.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_Unicode_in_"><a class="permalink" href="#Using_Unicode_in_">Using
  Unicode in XS</a></h2>
<p class="Pp">See &quot;Unicode Support&quot; in perlguts for an introduction to
    Unicode at the XS level, and &quot;Unicode Support&quot; in perlapi for the
    API details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Hacking_Perl_to_work_on_earlier_Unicode_versions_(for_very_serious_hackers_only)"><a class="permalink" href="#Hacking_Perl_to_work_on_earlier_Unicode_versions_(for_very_serious_hackers_only)">Hacking
  Perl to work on earlier Unicode versions (for very serious hackers
  only)</a></h2>
<p class="Pp">Perl by default comes with the latest supported Unicode version
    built-in, but the goal is to allow you to change to use any earlier one. In
    Perls v5.20 and v5.22, however, the earliest usable version is Unicode 5.1.
    Perl v5.18 and v5.24 are able to handle all earlier versions.</p>
<p class="Pp">Download the files in the desired version of Unicode from the
    Unicode web site &lt;https://www.unicode.org&gt;). These should replace the
    existing files in <i>lib/unicore</i> in the Perl source tree. Follow the
    instructions in <i>README.perl</i> in that directory to change some of their
    names, and then build perl (see INSTALL).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Porting_code_from_perl"><a class="permalink" href="#Porting_code_from_perl">Porting
  code from perl-5.6.X</a></h2>
<p class="Pp">Perls starting in 5.8 have a different Unicode model from 5.6. In
    5.6 the programmer was required to use the
    <span class="Li">&quot;utf8&quot;</span> pragma to declare that a given
    scope expected to deal with Unicode data and had to make sure that only
    Unicode data were reaching that scope. If you have code that is working with
    5.6, you will need some of the following adjustments to your code. The
    examples are written such that the code will continue to work under 5.6, so
    you should be safe to try them out.</p>
<ul class="Bl-bullet">
  <li>A filehandle that should read or write UTF-8
    <p class="Pp"></p>
    <pre>  if ($] &gt; 5.008) {
    binmode $fh, &quot;:encoding(UTF-8)&quot;;
  }
    </pre>
  </li>
  <li>A scalar that is going to be passed to some extension
    <p class="Pp">Be it <span class="Li">&quot;Compress::Zlib&quot;</span>,
        <span class="Li">&quot;Apache::Request&quot;</span> or any extension
        that has no mention of Unicode in the manpage, you need to make sure
        that the UTF8 flag is stripped off. Note that at the time of this
        writing (January 2012) the mentioned modules are not UTF-8-aware. Please
        check the documentation to verify if this is still true.</p>
    <p class="Pp"></p>
    <pre>  if ($] &gt; 5.008) {
    require Encode;
    $val = Encode::encode(&quot;UTF-8&quot;, $val); # make octets
  }
    </pre>
  </li>
  <li>A scalar we got back from an extension
    <p class="Pp">If you believe the scalar comes back as UTF-8, you will most
        likely want the UTF8 flag restored:</p>
    <p class="Pp"></p>
    <pre>  if ($] &gt; 5.008) {
    require Encode;
    $val = Encode::decode(&quot;UTF-8&quot;, $val);
  }
    </pre>
  </li>
  <li>Same thing, if you are really sure it is UTF-8
    <p class="Pp"></p>
    <pre>  if ($] &gt; 5.008) {
    require Encode;
    Encode::_utf8_on($val);
  }
    </pre>
  </li>
  <li>A wrapper for DBI <span class="Li">&quot;fetchrow_array&quot;</span> and
      <span class="Li">&quot;fetchrow_hashref&quot;</span>
    <p class="Pp">When the database contains only UTF-8, a wrapper function or
        method is a convenient way to replace all your
        <span class="Li">&quot;fetchrow_array&quot;</span> and
        <span class="Li">&quot;fetchrow_hashref&quot;</span> calls. A wrapper
        function will also make it easier to adapt to future enhancements in
        your database driver. Note that at the time of this writing (January
        2012), the DBI has no standardized way to deal with UTF-8 data. Please
        check the DBI documentation to verify if that is still true.</p>
    <p class="Pp"></p>
    <pre>  sub fetchrow {
    # $what is one of fetchrow_{array,hashref}
    my($self, $sth, $what) = @_;
    if ($] &lt; 5.008) {
      return $sth-&gt;$what;
    } else {
      require Encode;
      if (wantarray) {
        my @arr = $sth-&gt;$what;
        for (@arr) {
          defined &amp;&amp; /[^\000-\177]/ &amp;&amp; Encode::_utf8_on($_);
        }
        return @arr;
      } else {
        my $ret = $sth-&gt;$what;
        if (ref $ret) {
          for my $k (keys %$ret) {
            defined
            &amp;&amp; /[^\000-\177]/
            &amp;&amp; Encode::_utf8_on($_) for $ret-&gt;{$k};
          }
          return $ret;
        } else {
          defined &amp;&amp; /[^\000-\177]/ &amp;&amp; Encode::_utf8_on($_) for $ret;
          return $ret;
        }
      }
    }
  }
    </pre>
  </li>
  <li>A large scalar that you know can only contain ASCII
    <p class="Pp">Scalars that contain only ASCII and are marked as UTF-8 are
        sometimes a drag to your program. If you recognize such a situation,
        just remove the UTF8 flag:</p>
    <p class="Pp"></p>
    <pre>  utf8::downgrade($val) if $] &gt; 5.008;
    </pre>
  </li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">See also &quot;The &quot;Unicode Bug&quot;&quot; above.</p>
<section class="Ss">
<h2 class="Ss" id="Interaction_with_Extensions"><a class="permalink" href="#Interaction_with_Extensions">Interaction
  with Extensions</a></h2>
<p class="Pp">When Perl exchanges data with an extension, the extension should
    be able to understand the UTF8 flag and act accordingly. If the extension
    doesn't recognize that flag, it's likely that the extension will return
    incorrectly-flagged data.</p>
<p class="Pp">So if you're working with Unicode data, consult the documentation
    of every module you're using if there are any issues with Unicode data
    exchange. If the documentation does not talk about Unicode at all, suspect
    the worst and probably look at the source to learn how the module is
    implemented. Modules written completely in Perl shouldn't cause problems.
    Modules that directly or indirectly access code written in other programming
    languages are at risk.</p>
<p class="Pp">For affected functions, the simple strategy to avoid data
    corruption is to always make the encoding of the exchanged data explicit.
    Choose an encoding that you know the extension can handle. Convert arguments
    passed to the extensions to that encoding and convert results back from that
    encoding. Write wrapper functions that do the conversions for you, so you
    can later change the functions when the extension catches up.</p>
<p class="Pp">To provide an example, let's say the popular
    <span class="Li">&quot;Foo::Bar::escape_html&quot;</span> function doesn't
    deal with Unicode data yet. The wrapper function would convert the argument
    to raw UTF-8 and convert the result back to Perl's internal representation
    like so:</p>
<p class="Pp"></p>
<pre>    sub my_escape_html ($) {
        my($what) = shift;
        return unless defined $what;
        Encode::decode(&quot;UTF-8&quot;, Foo::Bar::escape_html(
                                     Encode::encode(&quot;UTF-8&quot;, $what)));
    }
</pre>
<p class="Pp">Sometimes, when the extension does not convert data but just
    stores and retrieves it, you will be able to use the otherwise dangerous
    <span class="Li">&quot;Encode::_utf8_on()&quot;</span> function. Let's say
    the popular <span class="Li">&quot;Foo::Bar&quot;</span> extension, written
    in C, provides a <span class="Li">&quot;param&quot;</span> method that lets
    you store and retrieve data according to these prototypes:</p>
<p class="Pp"></p>
<pre>    $self-&gt;param($name, $value);            # set a scalar
    $value = $self-&gt;param($name);           # retrieve a scalar
</pre>
<p class="Pp">If it does not yet provide support for any encoding, one could
    write a derived class with such a <span class="Li">&quot;param&quot;</span>
    method:</p>
<p class="Pp"></p>
<pre>    sub param {
      my($self,$name,$value) = @_;
      utf8::upgrade($name);     # make sure it is UTF-8 encoded
      if (defined $value) {
        utf8::upgrade($value);  # make sure it is UTF-8 encoded
        return $self-&gt;SUPER::param($name,$value);
      } else {
        my $ret = $self-&gt;SUPER::param($name);
        Encode::_utf8_on($ret); # we know, it is UTF-8 encoded
        return $ret;
      }
    }
</pre>
<p class="Pp">Some extensions provide filters on data entry/exit points, such as
    <span class="Li">&quot;DB_File::filter_store_key&quot;</span> and family.
    Look out for such filters in the documentation of your extensions; they can
    make the transition to Unicode data much easier.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Speed"><a class="permalink" href="#Speed">Speed</a></h2>
<p class="Pp">Some functions are slower when working on UTF-8 encoded strings
    than on byte encoded strings. All functions that need to hop over characters
    such as <span class="Li">&quot;length()&quot;</span>,
    <span class="Li">&quot;substr()&quot;</span> or
    <span class="Li">&quot;index()&quot;</span>, or matching regular expressions
    can work <b>much</b> faster when the underlying data are byte-encoded.</p>
<p class="Pp">In Perl 5.8.0 the slowness was often quite spectacular; in Perl
    5.8.1 a caching scheme was introduced which improved the situation. In
    general, operations with UTF-8 encoded strings are still slower. As an
    example, the Unicode properties (character classes) like
    <span class="Li">&quot;\p{Nd}&quot;</span> are known to be quite a bit
    slower (5-20 times) than their simpler counterparts like
    <span class="Li">&quot;[0-9]&quot;</span> (then again, there are hundreds of
    Unicode characters matching <span class="Li">&quot;Nd&quot;</span> compared
    with the 10 ASCII characters matching
    <span class="Li">&quot;[0-9]&quot;</span>).</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">perlunitut, perluniintro, perluniprops, Encode, open, utf8, bytes,
    perlretut, &quot;${^UNICODE}&quot; in perlvar,
    &lt;https://www.unicode.org/reports/tr44&gt;).</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os"><a href="..">perl v5.34.1</a></td>
  </tr>
</table>
</body>
</html>

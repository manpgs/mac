<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>ZSHROADMAP(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">ZSHROADMAP(1)</td>
    <td class="head-vol">General Commands Manual</td>
    <td class="head-rtitle">ZSHROADMAP(1)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">zshroadmap - informal introduction to the zsh manual The Zsh
    Manual, like the shell itself, is large and often complicated. This section
    of the manual provides some pointers to areas of the shell that are likely
    to be of particular interest to new users, and indicates where in the rest
    of the manual the documentation is to be found.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="WHEN_THE_SHELL_STARTS"><a class="permalink" href="#WHEN_THE_SHELL_STARTS">WHEN
  THE SHELL STARTS</a></h1>
<p class="Pp">When it starts, the shell reads commands from various files. These
    can be created or edited to customize the shell. See the section
    Startup/Shutdown Files in <i>zsh</i>(1).</p>
<p class="Pp">If no personal initialization files exist for the current user, a
    function is run to help you change some of the most common settings. It
    won't appear if your administrator has disabled the <b>zsh/newuser</b>
    module. The function is designed to be self-explanatory. You can run it by
    hand with `<b>autoload -Uz zsh-newuser-install; zsh-newuser-install -f</b>'.
    See also the section User Configuration Functions in
  <i>zshcontrib</i>(1).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="INTERACTIVE_USE"><a class="permalink" href="#INTERACTIVE_USE">INTERACTIVE
  USE</a></h1>
<p class="Pp">Interaction with the shell uses the builtin Zsh Line Editor, ZLE.
    This is described in detail in <i>zshzle</i>(1).</p>
<p class="Pp">The first decision a user must make is whether to use the Emacs or
    Vi editing mode as the keys for editing are substantially different. Emacs
    editing mode is probably more natural for beginners and can be selected
    explicitly with the command <b>bindkey -e</b>.</p>
<p class="Pp">A history mechanism for retrieving previously typed lines (most
    simply with the Up or Down arrow keys) is available; note that, unlike other
    shells, zsh will not save these lines when the shell exits unless you set
    appropriate variables, and the number of history lines retained by default
    is quite small (30 lines). See the description of the shell variables
    (referred to in the documentation as parameters) <b>HISTFILE</b>,
    <b>HISTSIZE</b> and <b>SAVEHIST</b> in <i>zshparam</i>(1). Note that it's
    currently only possible to read and write files saving history when the
    shell is interactive, i.e. it does not work from scripts.</p>
<p class="Pp">The shell now supports the UTF-8 character set (and also others if
    supported by the operating system). This is (mostly) handled transparently
    by the shell, but the degree of support in terminal emulators is variable.
    There is some discussion of this in the shell FAQ,
    <b>http://www.zsh.org/FAQ/</b>. Note in particular that for combining
    characters to be handled the option <b>COMBINING_CHARS</b> needs to be set.
    Because the shell is now more sensitive to the definition of the character
    set, note that if you are upgrading from an older version of the shell you
    should ensure that the appropriate variable, either <b>LANG</b> (to affect
    all aspects of the shell's operation) or <b>LC_CTYPE</b> (to affect only the
    handling of character sets) is set to an appropriate value. This is true
    even if you are using a single-byte character set including extensions of
    ASCII such as <b>ISO-8859-1</b> or <b>ISO-8859-15</b>. See the description
    of <b>LC_CTYPE</b> in <i>zshparam</i>(1).</p>
<section class="Ss">
<h2 class="Ss" id="Completion"><a class="permalink" href="#Completion">Completion</a></h2>
<p class="Pp">Completion is a feature present in many shells. It allows the user
    to type only a part (usually the prefix) of a word and have the shell fill
    in the rest. The completion system in zsh is programmable. For example, the
    shell can be set to complete email addresses in arguments to the mail
    command from your <b>~/.abook/addressbook</b>; usernames, hostnames, and
    even remote paths in arguments to scp, and so on. Anything that can be
    written in or glued together with zsh can be the source of what the line
    editor offers as possible completions.</p>
<p class="Pp">Zsh has two completion systems, an old, so called <b>compctl</b>
    completion (named after the builtin command that serves as its complete and
    only user interface), and a new one, referred to as <b>compsys</b>,
    organized as library of builtin and user-defined functions. The two systems
    differ in their interface for specifying the completion behavior. The new
    system is more customizable and is supplied with completions for many
    commonly used commands; it is therefore to be preferred.</p>
<p class="Pp">The completion system must be enabled explicitly when the shell
    starts. For more information see <i>zshcompsys</i>(1).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Extending_the_line_editor"><a class="permalink" href="#Extending_the_line_editor">Extending
  the line editor</a></h2>
<p class="Pp">Apart from completion, the line editor is highly extensible by
    means of shell functions. Some useful functions are provided with the shell;
    they provide facilities such as:</p>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>insert-composed-char</b></dt>
  <dd>composing characters not found on the keyboard</dd>
  <dt id="match"><a class="permalink" href="#match"><b>match-words-by-style</b></a></dt>
  <dd>configuring what the line editor considers a word when moving or deleting
      by word</dd>
  <dt id="history"><a class="permalink" href="#history"><b>history-beginning-search-backward-end</b>,
    etc.</a></dt>
  <dd>alternative ways of searching the shell history</dd>
  <dt id="replace"><a class="permalink" href="#replace"><b>replace-string</b>,
    <b>replace-pattern</b></a></dt>
  <dd>functions for replacing strings or patterns globally in the command
    line</dd>
  <dt id="edit"><a class="permalink" href="#edit"><b>edit-command-line</b></a></dt>
  <dd>edit the command line with an external editor.</dd>
</dl>
<p class="Pp">See the section `ZLE Functions' in <i>zshcontrib</i>(1) for
    descriptions of these.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="OPTIONS"><a class="permalink" href="#OPTIONS">OPTIONS</a></h1>
<p class="Pp">The shell has a large number of options for changing its
    behaviour. These cover all aspects of the shell; browsing the full
    documentation is the only good way to become acquainted with the many
    possibilities. See <i>zshoptions</i>(1).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PATTERN_MATCHING"><a class="permalink" href="#PATTERN_MATCHING">PATTERN
  MATCHING</a></h1>
<p class="Pp">The shell has a rich set of patterns which are available for file
    matching (described in the documentation as `filename generation' and also
    known for historical reasons as `globbing') and for use when programming.
    These are described in the section `Filename Generation' in
    <i>zshexpn</i>(1).</p>
<p class="Pp">Of particular interest are the following patterns that are not
    commonly supported by other systems of pattern matching:</p>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>**</b></dt>
  <dd>for matching over multiple directories</dd>
  <dt><b>|</b></dt>
  <dd>for matching either of two alternatives</dd>
  <dt><b>~</b>, <b>^</b></dt>
  <dd>the ability to exclude patterns from matching when the
      <b>EXTENDED_GLOB</b> option is set</dd>
  <dt><b>(</b><i>...</i><b>)</b></dt>
  <dd>glob qualifiers, included in parentheses at the end of the pattern, which
      select files by type (such as directories) or attribute (such as
    size).</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="GENERAL_COMMENTS_ON_SYNTAX"><a class="permalink" href="#GENERAL_COMMENTS_ON_SYNTAX">GENERAL
  COMMENTS ON SYNTAX</a></h1>
<p class="Pp">Although the syntax of zsh is in ways similar to the Korn shell,
    and therefore more remotely to the original UNIX shell, the Bourne shell,
    its default behaviour does not entirely correspond to those shells. General
    shell syntax is introduced in the section `Shell Grammar' in
    <i>zshmisc</i>(1).</p>
<p class="Pp">One commonly encountered difference is that variables substituted
    onto the command line are not split into words. See the description of the
    shell option <b>SH_WORD_SPLIT</b> in the section `Parameter Expansion' in
    <i>zshexpn</i>(1). In zsh, you can either explicitly request the splitting
    (e.g. <b>${=foo}</b>) or use an array when you want a variable to expand to
    more than one word. See the section `Array Parameters' in
    <i>zshparam</i>(1).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PROGRAMMING"><a class="permalink" href="#PROGRAMMING">PROGRAMMING</a></h1>
<p class="Pp">The most convenient way of adding enhancements to the shell is
    typically by writing a shell function and arranging for it to be autoloaded.
    Functions are described in the section `Functions' in <i>zshmisc</i>(1).
    Users changing from the C shell and its relatives should notice that aliases
    are less used in zsh as they don't perform argument substitution, only
    simple text replacement.</p>
<p class="Pp">A few general functions, other than those for the line editor
    described above, are provided with the shell and are described in
    <i>zshcontrib</i>(1). Features include:</p>
<p class="Pp"></p>
<dl class="Bl-tag">
  <dt><b>promptinit</b></dt>
  <dd>a prompt theme system for changing prompts easily, see the section `Prompt
      Themes'
    <p class="Pp"></p>
  </dd>
  <dt id="zsh"><a class="permalink" href="#zsh"><b>zsh-mime-setup</b></a></dt>
  <dd>a MIME-handling system which dispatches commands according to the suffix
      of a file as done by graphical file managers</dd>
  <dt id="zcalc"><a class="permalink" href="#zcalc"><b>zcalc</b></a></dt>
  <dd>a calculator</dd>
  <dt id="zargs"><a class="permalink" href="#zargs"><b>zargs</b></a></dt>
  <dd>a version of <b>xargs</b> that makes the <b>find</b> command
    redundant</dd>
  <dt id="zmv"><a class="permalink" href="#zmv"><b>zmv</b></a></dt>
  <dd>a command for renaming files by means of shell patterns.</dd>
</dl>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">February 14, 2020</td>
    <td class="foot-os">zsh 5.8</td>
  </tr>
</table>
</body>
</html>

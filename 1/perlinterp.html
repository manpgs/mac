<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PERLINTERP(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLINTERP(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLINTERP(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlinterp - An overview of the Perl interpreter</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This document provides an overview of how the Perl interpreter
    works at the level of C code, along with pointers to the relevant C source
    code files.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ELEMENTS_OF_THE_INTERPRETER"><a class="permalink" href="#ELEMENTS_OF_THE_INTERPRETER">ELEMENTS
  OF THE INTERPRETER</a></h1>
<p class="Pp">The work of the interpreter has two main stages: compiling the
    code into the internal representation, or bytecode, and then executing it.
    &quot;Compiled code&quot; in perlguts explains exactly how the compilation
    stage happens.</p>
<p class="Pp">Here is a short breakdown of perl's operation:</p>
<section class="Ss">
<h2 class="Ss" id="Startup"><a class="permalink" href="#Startup">Startup</a></h2>
<p class="Pp">The action begins in <i>perlmain.c</i>. (or <i>miniperlmain.c</i>
    for miniperl) This is very high-level code, enough to fit on a single
    screen, and it resembles the code found in perlembed; most of the real
    action takes place in <i>perl.c</i></p>
<p class="Pp"><i>perlmain.c</i> is generated by
    <span class="Li">&quot;ExtUtils::Miniperl&quot;</span> from
    <i>miniperlmain.c</i> at make time, so you should make perl to follow this
    along.</p>
<p class="Pp">First, <i>perlmain.c</i> allocates some memory and constructs a
    Perl interpreter, along these lines:</p>
<p class="Pp"></p>
<pre>
    1 PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env);
    2
    3 if (!PL_do_undump) {
    4     my_perl = perl_alloc();
    5     if (!my_perl)
    6         exit(1);
    7     perl_construct(my_perl);
    8     PL_perl_destruct_level = 0;
    9 }
</pre>
<p class="Pp">Line 1 is a macro, and its definition is dependent on your
    operating system. Line 3 references
    <span class="Li">&quot;PL_do_undump&quot;</span>, a global variable - all
    global variables in Perl start with <span class="Li">&quot;PL_&quot;</span>.
    This tells you whether the current running program was created with the
    <span class="Li">&quot;-u&quot;</span> flag to perl and then <i>undump</i>,
    which means it's going to be false in any sane context.</p>
<p class="Pp">Line 4 calls a function in <i>perl.c</i> to allocate memory for a
    Perl interpreter. It's quite a simple function, and the guts of it looks
    like this:</p>
<p class="Pp"></p>
<pre>
 my_perl = (PerlInterpreter*)PerlMem_malloc(sizeof(PerlInterpreter));
</pre>
<p class="Pp">Here you see an example of Perl's system abstraction, which we'll
    see later: <span class="Li">&quot;PerlMem_malloc&quot;</span> is either your
    system's <span class="Li">&quot;malloc&quot;</span>, or Perl's own
    <span class="Li">&quot;malloc&quot;</span> as defined in <i>malloc.c</i> if
    you selected that option at configure time.</p>
<p class="Pp">Next, in line 7, we construct the interpreter using
    perl_construct, also in <i>perl.c</i>; this sets up all the special
    variables that Perl needs, the stacks, and so on.</p>
<p class="Pp">Now we pass Perl the command line options, and tell it to go:</p>
<p class="Pp"></p>
<pre>
 if (!perl_parse(my_perl, xs_init, argc, argv, (char **)NULL))
     perl_run(my_perl);

 exitstatus = perl_destruct(my_perl);

 perl_free(my_perl);
</pre>
<p class="Pp"><span class="Li">&quot;perl_parse&quot;</span> is actually a
    wrapper around <span class="Li">&quot;S_parse_body&quot;</span>, as defined
    in <i>perl.c</i>, which processes the command line options, sets up any
    statically linked XS modules, opens the program and calls
    <span class="Li">&quot;yyparse&quot;</span> to parse it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Parsing"><a class="permalink" href="#Parsing">Parsing</a></h2>
<p class="Pp">The aim of this stage is to take the Perl source, and turn it into
    an op tree. We'll see what one of those looks like later. Strictly speaking,
    there's three things going on here.</p>
<p class="Pp"><span class="Li">&quot;yyparse&quot;</span>, the parser, lives in
    <i>perly.c</i>, although you're better off reading the original YACC input
    in <i>perly.y</i>. (Yes, Virginia, there <b>is</b> a YACC grammar for Perl!)
    The job of the parser is to take your code and &quot;understand&quot; it,
    splitting it into sentences, deciding which operands go with which operators
    and so on.</p>
<p class="Pp">The parser is nobly assisted by the lexer, which chunks up your
    input into tokens, and decides what type of thing each token is: a variable
    name, an operator, a bareword, a subroutine, a core function, and so on. The
    main point of entry to the lexer is
    <span class="Li">&quot;yylex&quot;</span>, and that and its associated
    routines can be found in <i>toke.c</i>. Perl isn't much like other computer
    languages; it's highly context sensitive at times, it can be tricky to work
    out what sort of token something is, or where a token ends. As such, there's
    a lot of interplay between the tokeniser and the parser, which can get
    pretty frightening if you're not used to it.</p>
<p class="Pp">As the parser understands a Perl program, it builds up a tree of
    operations for the interpreter to perform during execution. The routines
    which construct and link together the various operations are to be found in
    <i>op.c</i>, and will be examined later.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Optimization"><a class="permalink" href="#Optimization">Optimization</a></h2>
<p class="Pp">Now the parsing stage is complete, and the finished tree
    represents the operations that the Perl interpreter needs to perform to
    execute our program. Next, Perl does a dry run over the tree looking for
    optimisations: constant expressions such as <span class="Li">&quot;3 +
    4&quot;</span> will be computed now, and the optimizer will also see if any
    multiple operations can be replaced with a single one. For instance, to
    fetch the variable <span class="Li">$foo</span>, instead of grabbing the
    glob <span class="Li">*foo</span> and looking at the scalar component, the
    optimizer fiddles the op tree to use a function which directly looks up the
    scalar in question. The main optimizer is
    <span class="Li">&quot;peep&quot;</span> in <i>op.c</i>, and many ops have
    their own optimizing functions.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Running"><a class="permalink" href="#Running">Running</a></h2>
<p class="Pp">Now we're finally ready to go: we have compiled Perl byte code,
    and all that's left to do is run it. The actual execution is done by the
    <span class="Li">&quot;runops_standard&quot;</span> function in
    <i>run.c</i>; more specifically, it's done by these three innocent looking
    lines:</p>
<p class="Pp"></p>
<pre>
    while ((PL_op = PL_op-&gt;op_ppaddr(aTHX))) {
        PERL_ASYNC_CHECK();
    }
</pre>
<p class="Pp">You may be more comfortable with the Perl version of that:</p>
<p class="Pp"></p>
<pre>
    PERL_ASYNC_CHECK() while $Perl::op = &amp;{$Perl::op-&gt;{function}};
</pre>
<p class="Pp">Well, maybe not. Anyway, each op contains a function pointer,
    which stipulates the function which will actually carry out the operation.
    This function will return the next op in the sequence - this allows for
    things like <span class="Li">&quot;if&quot;</span> which choose the next op
    dynamically at run time. The
    <span class="Li">&quot;PERL_ASYNC_CHECK&quot;</span> makes sure that things
    like signals interrupt execution if required.</p>
<p class="Pp">The actual functions called are known as PP code, and they're
    spread between four files: <i>pp_hot.c</i> contains the &quot;hot&quot;
    code, which is most often used and highly optimized, <i>pp_sys.c</i>
    contains all the system-specific functions, <i>pp_ctl.c</i> contains the
    functions which implement control structures
    (<span class="Li">&quot;if&quot;</span>,
    <span class="Li">&quot;while&quot;</span> and the like) and <i>pp.c</i>
    contains everything else. These are, if you like, the C code for Perl's
    built-in functions and operators.</p>
<p class="Pp">Note that each <span class="Li">&quot;pp_&quot;</span> function is
    expected to return a pointer to the next op. Calls to perl subs (and eval
    blocks) are handled within the same runops loop, and do not consume extra
    space on the C stack. For example,
    <span class="Li">&quot;pp_entersub&quot;</span> and
    <span class="Li">&quot;pp_entertry&quot;</span> just push a
    <span class="Li">&quot;CxSUB&quot;</span> or
    <span class="Li">&quot;CxEVAL&quot;</span> block struct onto the context
    stack which contain the address of the op following the sub call or eval.
    They then return the first op of that sub or eval block, and so execution
    continues of that sub or block. Later, a
    <span class="Li">&quot;pp_leavesub&quot;</span> or
    <span class="Li">&quot;pp_leavetry&quot;</span> op pops the
    <span class="Li">&quot;CxSUB&quot;</span> or
    <span class="Li">&quot;CxEVAL&quot;</span>, retrieves the return op from it,
    and returns it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Exception_handing"><a class="permalink" href="#Exception_handing">Exception
  handing</a></h2>
<p class="Pp">Perl's exception handing (i.e.
    <span class="Li">&quot;die&quot;</span> etc.) is built on top of the
    low-level
    <span class="Li">&quot;setjmp()&quot;</span>/<span class="Li">&quot;longjmp()&quot;</span>
    C-library functions. These basically provide a way to capture the current PC
    and SP registers and later restore them; i.e. a
    <span class="Li">&quot;longjmp()&quot;</span> continues at the point in code
    where a previous <span class="Li">&quot;setjmp()&quot;</span> was done, with
    anything further up on the C stack being lost. This is why code should
    always save values using <span class="Li">&quot;SAVE_FOO&quot;</span> rather
    than in auto variables.</p>
<p class="Pp">The perl core wraps <span class="Li">&quot;setjmp()&quot;</span>
    etc in the macros <span class="Li">&quot;JMPENV_PUSH&quot;</span> and
    <span class="Li">&quot;JMPENV_JUMP&quot;</span>. The basic rule of perl
    exceptions is that <span class="Li">&quot;exit&quot;</span>, and
    <span class="Li">&quot;die&quot;</span> (in the absence of
    <span class="Li">&quot;eval&quot;</span>) perform a
    <span class="Li">JMPENV_JUMP(2)</span>, while
    <span class="Li">&quot;die&quot;</span> within
    <span class="Li">&quot;eval&quot;</span> does a
    <span class="Li">JMPENV_JUMP(3)</span>.</p>
<p class="Pp">At entry points to perl, such as
    <span class="Li">&quot;perl_parse()&quot;</span>,
    <span class="Li">&quot;perl_run()&quot;</span> and
    <span class="Li">&quot;call_sv(cv, G_EVAL)&quot;</span> each does a
    <span class="Li">&quot;JMPENV_PUSH&quot;</span>, then enter a runops loop or
    whatever, and handle possible exception returns. For a 2 return, final
    cleanup is performed, such as popping stacks and calling
    <span class="Li">&quot;CHECK&quot;</span> or
    <span class="Li">&quot;END&quot;</span> blocks. Amongst other things, this
    is how scope cleanup still occurs during an
    <span class="Li">&quot;exit&quot;</span>.</p>
<p class="Pp">If a <span class="Li">&quot;die&quot;</span> can find a
    <span class="Li">&quot;CxEVAL&quot;</span> block on the context stack, then
    the stack is popped to that level and the return op in that block is
    assigned to <span class="Li">&quot;PL_restartop&quot;</span>; then a
    <span class="Li">JMPENV_JUMP(3)</span> is performed. This normally passes
    control back to the guard. In the case of
    <span class="Li">&quot;perl_run&quot;</span> and
    <span class="Li">&quot;call_sv&quot;</span>, a non-null
    <span class="Li">&quot;PL_restartop&quot;</span> triggers re-entry to the
    runops loop. The is the normal way that
    <span class="Li">&quot;die&quot;</span> or
    <span class="Li">&quot;croak&quot;</span> is handled within an
    <span class="Li">&quot;eval&quot;</span>.</p>
<p class="Pp">Sometimes ops are executed within an inner runops loop, such as
    tie, sort or overload code. In this case, something like</p>
<p class="Pp"></p>
<pre>
    sub FETCH { eval { die } }
</pre>
<p class="Pp">would cause a longjmp right back to the guard in
    <span class="Li">&quot;perl_run&quot;</span>, popping both runops loops,
    which is clearly incorrect. One way to avoid this is for the tie code to do
    a <span class="Li">&quot;JMPENV_PUSH&quot;</span> before executing
    <span class="Li">&quot;FETCH&quot;</span> in the inner runops loop, but for
    efficiency reasons, perl in fact just sets a flag, using
    <span class="Li">&quot;CATCH_SET(TRUE)&quot;</span>. The
    <span class="Li">&quot;pp_require&quot;</span>,
    <span class="Li">&quot;pp_entereval&quot;</span> and
    <span class="Li">&quot;pp_entertry&quot;</span> ops check this flag, and if
    true, they call <span class="Li">&quot;docatch&quot;</span>, which does a
    <span class="Li">&quot;JMPENV_PUSH&quot;</span> and starts a new runops
    level to execute the code, rather than doing it on the current loop.</p>
<p class="Pp">As a further optimisation, on exit from the eval block in the
    <span class="Li">&quot;FETCH&quot;</span>, execution of the code following
    the block is still carried on in the inner loop. When an exception is
    raised, <span class="Li">&quot;docatch&quot;</span> compares the
    <span class="Li">&quot;JMPENV&quot;</span> level of the
    <span class="Li">&quot;CxEVAL&quot;</span> with
    <span class="Li">&quot;PL_top_env&quot;</span> and if they differ, just
    re-throws the exception. In this way any inner loops get popped.</p>
<p class="Pp">Here's an example.</p>
<p class="Pp"></p>
<pre>
    1: eval { tie @a, 'A' };
    2: sub A::TIEARRAY {
    3:     eval { die };
    4:     die;
    5: }
</pre>
<p class="Pp">To run this code, <span class="Li">&quot;perl_run&quot;</span> is
    called, which does a <span class="Li">&quot;JMPENV_PUSH&quot;</span> then
    enters a runops loop. This loop executes the eval and tie ops on line 1,
    with the eval pushing a <span class="Li">&quot;CxEVAL&quot;</span> onto the
    context stack.</p>
<p class="Pp">The <span class="Li">&quot;pp_tie&quot;</span> does a
    <span class="Li">&quot;CATCH_SET(TRUE)&quot;</span>, then starts a second
    runops loop to execute the body of
    <span class="Li">&quot;TIEARRAY&quot;</span>. When it executes the entertry
    op on line 3, <span class="Li">&quot;CATCH_GET&quot;</span> is true, so
    <span class="Li">&quot;pp_entertry&quot;</span> calls
    <span class="Li">&quot;docatch&quot;</span> which does a
    <span class="Li">&quot;JMPENV_PUSH&quot;</span> and starts a third runops
    loop, which then executes the die op. At this point the C call stack looks
    like this:</p>
<p class="Pp"></p>
<pre>
    Perl_pp_die
    Perl_runops      # third loop
    S_docatch_body
    S_docatch
    Perl_pp_entertry
    Perl_runops      # second loop
    S_call_body
    Perl_call_sv
    Perl_pp_tie
    Perl_runops      # first loop
    S_run_body
    perl_run
    main
</pre>
<p class="Pp">and the context and data stacks, as shown by
    <span class="Li">&quot;-Dstv&quot;</span>, look like:</p>
<p class="Pp"></p>
<pre>
    STACK 0: MAIN
      CX 0: BLOCK  =&gt;
      CX 1: EVAL   =&gt; AV()  PV(&quot;A&quot;\0)
      retop=leave
    STACK 1: MAGIC
      CX 0: SUB    =&gt;
      retop=(null)
      CX 1: EVAL   =&gt; *
    retop=nextstate
</pre>
<p class="Pp">The die pops the first <span class="Li">&quot;CxEVAL&quot;</span>
    off the context stack, sets <span class="Li">&quot;PL_restartop&quot;</span>
    from it, does a <span class="Li">JMPENV_JUMP(3)</span>, and control returns
    to the top <span class="Li">&quot;docatch&quot;</span>. This then starts
    another third-level runops level, which executes the nextstate, pushmark and
    die ops on line 4. At the point that the second
    <span class="Li">&quot;pp_die&quot;</span> is called, the C call stack looks
    exactly like that above, even though we are no longer within an inner eval;
    this is because of the optimization mentioned earlier. However, the context
    stack now looks like this, ie with the top CxEVAL popped:</p>
<p class="Pp"></p>
<pre>
    STACK 0: MAIN
      CX 0: BLOCK  =&gt;
      CX 1: EVAL   =&gt; AV()  PV(&quot;A&quot;\0)
      retop=leave
    STACK 1: MAGIC
      CX 0: SUB    =&gt;
      retop=(null)
</pre>
<p class="Pp">The die on line 4 pops the context stack back down to the CxEVAL,
    leaving it as:</p>
<p class="Pp"></p>
<pre>
    STACK 0: MAIN
      CX 0: BLOCK  =&gt;
</pre>
<p class="Pp">As usual, <span class="Li">&quot;PL_restartop&quot;</span> is
    extracted from the <span class="Li">&quot;CxEVAL&quot;</span>, and a
    <span class="Li">JMPENV_JUMP(3)</span> done, which pops the C stack back to
    the docatch:</p>
<p class="Pp"></p>
<pre>
    S_docatch
    Perl_pp_entertry
    Perl_runops      # second loop
    S_call_body
    Perl_call_sv
    Perl_pp_tie
    Perl_runops      # first loop
    S_run_body
    perl_run
    main
</pre>
<p class="Pp">In this case, because the
    <span class="Li">&quot;JMPENV&quot;</span> level recorded in the
    <span class="Li">&quot;CxEVAL&quot;</span> differs from the current one,
    <span class="Li">&quot;docatch&quot;</span> just does a
    <span class="Li">JMPENV_JUMP(3)</span> and the C stack unwinds to:</p>
<p class="Pp"></p>
<pre>
    perl_run
    main
</pre>
<p class="Pp">Because <span class="Li">&quot;PL_restartop&quot;</span> is
    non-null, <span class="Li">&quot;run_body&quot;</span> starts a new runops
    loop and execution continues.</p>
</section>
<section class="Ss">
<h2 class="Ss">INTERNAL VARIABLE TYPES</h2>
<p class="Pp">You should by now have had a look at perlguts, which tells you
    about Perl's internal variable types: SVs, HVs, AVs and the rest. If not, do
    that now.</p>
<p class="Pp">These variables are used not only to represent Perl-space
    variables, but also any constants in the code, as well as some structures
    completely internal to Perl. The symbol table, for instance, is an ordinary
    Perl hash. Your code is represented by an SV as it's read into the parser;
    any program files you call are opened via ordinary Perl filehandles, and so
    on.</p>
<p class="Pp">The core Devel::Peek module lets us examine SVs from a Perl
    program. Let's see, for instance, how Perl treats the constant
    <span class="Li">&quot;hello&quot;</span>.</p>
<p class="Pp"></p>
<pre>
      % perl -MDevel::Peek -e 'Dump(&quot;hello&quot;)'
    1 SV = PV(0xa041450) at 0xa04ecbc
    2   REFCNT = 1
    3   FLAGS = (POK,READONLY,pPOK)
    4   PV = 0xa0484e0 &quot;hello&quot;\0
    5   CUR = 5
    6   LEN = 6
</pre>
<p class="Pp">Reading <span class="Li">&quot;Devel::Peek&quot;</span> output
    takes a bit of practise, so let's go through it line by line.</p>
<p class="Pp">Line 1 tells us we're looking at an SV which lives at
    <span class="Li">0xa04ecbc</span> in memory. SVs themselves are very simple
    structures, but they contain a pointer to a more complex structure. In this
    case, it's a PV, a structure which holds a string value, at location
    <span class="Li">0xa041450</span>. Line 2 is the reference count; there are
    no other references to this data, so it's 1.</p>
<p class="Pp">Line 3 are the flags for this SV - it's OK to use it as a PV, it's
    a read-only SV (because it's a constant) and the data is a PV internally.
    Next we've got the contents of the string, starting at location
    <span class="Li">0xa0484e0</span>.</p>
<p class="Pp">Line 5 gives us the current length of the string - note that this
    does <b>not</b> include the null terminator. Line 6 is not the length of the
    string, but the length of the currently allocated buffer; as the string
    grows, Perl automatically extends the available storage via a routine called
    <span class="Li">&quot;SvGROW&quot;</span>.</p>
<p class="Pp">You can get at any of these quantities from C very easily; just
    add <span class="Li">&quot;Sv&quot;</span> to the name of the field shown in
    the snippet, and you've got a macro which will return the value:
    <span class="Li">&quot;SvCUR(sv)&quot;</span> returns the current length of
    the string, <span class="Li">&quot;SvREFCOUNT(sv)&quot;</span> returns the
    reference count, <span class="Li">&quot;SvPV(sv, len)&quot;</span> returns
    the string itself with its length, and so on. More macros to manipulate
    these properties can be found in perlguts.</p>
<p class="Pp">Let's take an example of manipulating a PV, from
    <span class="Li">&quot;sv_catpvn&quot;</span>, in <i>sv.c</i></p>
<p class="Pp"></p>
<pre>
     1  void
     2  Perl_sv_catpvn(pTHX_ SV *sv, const char *ptr, STRLEN len)
     3  {
     4      STRLEN tlen;
     5      char *junk;

     6      junk = SvPV_force(sv, tlen);
     7      SvGROW(sv, tlen + len + 1);
     8      if (ptr == junk)
     9          ptr = SvPVX(sv);
    10      Move(ptr,SvPVX(sv)+tlen,len,char);
    11      SvCUR(sv) += len;
    12      *SvEND(sv) = '\0';
    13      (void)SvPOK_only_UTF8(sv);          /* validate pointer */
    14      SvTAINT(sv);
    15  }
</pre>
<p class="Pp">This is a function which adds a string,
    <span class="Li">&quot;ptr&quot;</span>, of length
    <span class="Li">&quot;len&quot;</span> onto the end of the PV stored in
    <span class="Li">&quot;sv&quot;</span>. The first thing we do in line 6 is
    make sure that the SV <b>has</b> a valid PV, by calling the
    <span class="Li">&quot;SvPV_force&quot;</span> macro to force a PV. As a
    side effect, <span class="Li">&quot;tlen&quot;</span> gets set to the
    current value of the PV, and the PV itself is returned to
    <span class="Li">&quot;junk&quot;</span>.</p>
<p class="Pp">In line 7, we make sure that the SV will have enough room to
    accommodate the old string, the new string and the null terminator. If
    <span class="Li">&quot;LEN&quot;</span> isn't big enough,
    <span class="Li">&quot;SvGROW&quot;</span> will reallocate space for us.</p>
<p class="Pp">Now, if <span class="Li">&quot;junk&quot;</span> is the same as
    the string we're trying to add, we can grab the string directly from the SV;
    <span class="Li">&quot;SvPVX&quot;</span> is the address of the PV in the
    SV.</p>
<p class="Pp">Line 10 does the actual catenation: the
    <span class="Li">&quot;Move&quot;</span> macro moves a chunk of memory
    around: we move the string <span class="Li">&quot;ptr&quot;</span> to the
    end of the PV - that's the start of the PV plus its current length. We're
    moving <span class="Li">&quot;len&quot;</span> bytes of type
    <span class="Li">&quot;char&quot;</span>. After doing so, we need to tell
    Perl we've extended the string, by altering
    <span class="Li">&quot;CUR&quot;</span> to reflect the new length.
    <span class="Li">&quot;SvEND&quot;</span> is a macro which gives us the end
    of the string, so that needs to be a
  <span class="Li">&quot;\0&quot;</span>.</p>
<p class="Pp">Line 13 manipulates the flags; since we've changed the PV, any IV
    or NV values will no longer be valid: if we have
    <span class="Li">&quot;$a=10; $a.=&quot;6&quot;;&quot;</span> we don't want
    to use the old IV of 10. <span class="Li">&quot;SvPOK_only_utf8&quot;</span>
    is a special UTF-8-aware version of
    <span class="Li">&quot;SvPOK_only&quot;</span>, a macro which turns off the
    IOK and NOK flags and turns on POK. The final
    <span class="Li">&quot;SvTAINT&quot;</span> is a macro which launders
    tainted data if taint mode is turned on.</p>
<p class="Pp">AVs and HVs are more complicated, but SVs are by far the most
    common variable type being thrown around. Having seen something of how we
    manipulate these, let's go on and look at how the op tree is
  constructed.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="OP_TREES"><a class="permalink" href="#OP_TREES">OP
  TREES</a></h1>
<p class="Pp">First, what is the op tree, anyway? The op tree is the parsed
    representation of your program, as we saw in our section on parsing, and
    it's the sequence of operations that Perl goes through to execute your
    program, as we saw in &quot;Running&quot;.</p>
<p class="Pp">An op is a fundamental operation that Perl can perform: all the
    built-in functions and operators are ops, and there are a series of ops
    which deal with concepts the interpreter needs internally - entering and
    leaving a block, ending a statement, fetching a variable, and so on.</p>
<p class="Pp">The op tree is connected in two ways: you can imagine that there
    are two &quot;routes&quot; through it, two orders in which you can traverse
    the tree. First, parse order reflects how the parser understood the code,
    and secondly, execution order tells perl what order to perform the
    operations in.</p>
<p class="Pp">The easiest way to examine the op tree is to stop Perl after it
    has finished parsing, and get it to dump out the tree. This is exactly what
    the compiler backends B::Terse, B::Concise and CPAN module &lt;B::Debug
  do.</p>
<p class="Pp">Let's have a look at how Perl sees <span class="Li">&quot;$a = $b
    + $c&quot;</span>:</p>
<p class="Pp"></p>
<pre>
     % perl -MO=Terse -e '$a=$b+$c'
     1  LISTOP (0x8179888) leave
     2      OP (0x81798b0) enter
     3      COP (0x8179850) nextstate
     4      BINOP (0x8179828) sassign
     5          BINOP (0x8179800) add [1]
     6              UNOP (0x81796e0) null [15]
     7                  SVOP (0x80fafe0) gvsv  GV (0x80fa4cc) *b
     8              UNOP (0x81797e0) null [15]
     9                  SVOP (0x8179700) gvsv  GV (0x80efeb0) *c
    10          UNOP (0x816b4f0) null [15]
    11              SVOP (0x816dcf0) gvsv  GV (0x80fa460) *a
</pre>
<p class="Pp">Let's start in the middle, at line 4. This is a BINOP, a binary
    operator, which is at location <span class="Li">0x8179828</span>. The
    specific operator in question is <span class="Li">&quot;sassign&quot;</span>
    - scalar assignment - and you can find the code which implements it in the
    function <span class="Li">&quot;pp_sassign&quot;</span> in <i>pp_hot.c</i>.
    As a binary operator, it has two children: the add operator, providing the
    result of <span class="Li">&quot;$b+$c&quot;</span>, is uppermost on line 5,
    and the left hand side is on line 10.</p>
<p class="Pp">Line 10 is the null op: this does exactly nothing. What is that
    doing there? If you see the null op, it's a sign that something has been
    optimized away after parsing. As we mentioned in &quot;Optimization&quot;,
    the optimization stage sometimes converts two operations into one, for
    example when fetching a scalar variable. When this happens, instead of
    rewriting the op tree and cleaning up the dangling pointers, it's easier
    just to replace the redundant operation with the null op. Originally, the
    tree would have looked like this:</p>
<p class="Pp"></p>
<pre>
    10          SVOP (0x816b4f0) rv2sv [15]
    11              SVOP (0x816dcf0) gv  GV (0x80fa460) *a
</pre>
<p class="Pp">That is, fetch the <span class="Li">&quot;a&quot;</span> entry
    from the main symbol table, and then look at the scalar component of it:
    <span class="Li">&quot;gvsv&quot;</span>
    (<span class="Li">&quot;pp_gvsv&quot;</span> in <i>pp_hot.c</i>) happens to
    do both these things.</p>
<p class="Pp">The right hand side, starting at line 5 is similar to what we've
    just seen: we have the <span class="Li">&quot;add&quot;</span> op
    (<span class="Li">&quot;pp_add&quot;</span>, also in <i>pp_hot.c</i>) add
    together two <span class="Li">&quot;gvsv&quot;</span>s.</p>
<p class="Pp">Now, what's this about?</p>
<p class="Pp"></p>
<pre>
     1  LISTOP (0x8179888) leave
     2      OP (0x81798b0) enter
     3      COP (0x8179850) nextstate
</pre>
<p class="Pp"><span class="Li">&quot;enter&quot;</span> and
    <span class="Li">&quot;leave&quot;</span> are scoping ops, and their job is
    to perform any housekeeping every time you enter and leave a block: lexical
    variables are tidied up, unreferenced variables are destroyed, and so on.
    Every program will have those first three lines:
    <span class="Li">&quot;leave&quot;</span> is a list, and its children are
    all the statements in the block. Statements are delimited by
    <span class="Li">&quot;nextstate&quot;</span>, so a block is a collection of
    <span class="Li">&quot;nextstate&quot;</span> ops, with the ops to be
    performed for each statement being the children of
    <span class="Li">&quot;nextstate&quot;</span>.
    <span class="Li">&quot;enter&quot;</span> is a single op which functions as
    a marker.</p>
<p class="Pp">That's how Perl parsed the program, from top to bottom:</p>
<p class="Pp"></p>
<pre>
                        Program
                           |
                       Statement
                           |
                           =
                          / \
                         /   \
                        $a   +
                            / \
                          $b   $c
</pre>
<p class="Pp">However, it's impossible to <b>perform</b> the operations in this
    order: you have to find the values of <span class="Li">$b</span> and
    <span class="Li">$c</span> before you add them together, for instance. So,
    the other thread that runs through the op tree is the execution order: each
    op has a field <span class="Li">&quot;op_next&quot;</span> which points to
    the next op to be run, so following these pointers tells us how perl
    executes the code. We can traverse the tree in this order using the
    <span class="Li">&quot;exec&quot;</span> option to
    <span class="Li">&quot;B::Terse&quot;</span>:</p>
<p class="Pp"></p>
<pre>
     % perl -MO=Terse,exec -e '$a=$b+$c'
     1  OP (0x8179928) enter
     2  COP (0x81798c8) nextstate
     3  SVOP (0x81796c8) gvsv  GV (0x80fa4d4) *b
     4  SVOP (0x8179798) gvsv  GV (0x80efeb0) *c
     5  BINOP (0x8179878) add [1]
     6  SVOP (0x816dd38) gvsv  GV (0x80fa468) *a
     7  BINOP (0x81798a0) sassign
     8  LISTOP (0x8179900) leave
</pre>
<p class="Pp">This probably makes more sense for a human: enter a block, start a
    statement. Get the values of <span class="Li">$b</span> and
    <span class="Li">$c</span>, and add them together. Find
    <span class="Li">$a</span>, and assign one to the other. Then leave.</p>
<p class="Pp">The way Perl builds up these op trees in the parsing process can
    be unravelled by examining <i>toke.c</i>, the lexer, and <i>perly.y</i>, the
    YACC grammar. Let's look at the code that constructs the tree for
    <span class="Li">&quot;$a = $b +</span>
  <span class="Li">$c&quot;</span>.</p>
<p class="Pp">First, we'll look at the
    <span class="Li">&quot;Perl_yylex&quot;</span> function in the lexer. We
    want to look for <span class="Li">&quot;case 'x'&quot;</span>, where x is
    the first character of the operator. (Incidentally, when looking for the
    code that handles a keyword, you'll want to search for
    <span class="Li">&quot;KEY_foo&quot;</span> where &quot;foo&quot; is the
    keyword.) Here is the code that handles assignment (there are quite a few
    operators beginning with <span class="Li">&quot;=&quot;</span>, so most of
    it is omitted for brevity):</p>
<p class="Pp"></p>
<pre>
     1    case '=':
     2        s++;
              ... code that handles == =&gt; etc. and pod ...
     3        pl_yylval.ival = 0;
     4        OPERATOR(ASSIGNOP);
</pre>
<p class="Pp">We can see on line 4 that our token type is
    <span class="Li">&quot;ASSIGNOP&quot;</span>
    (<span class="Li">&quot;OPERATOR&quot;</span> is a macro, defined in
    <i>toke.c</i>, that returns the token type, among other things). And
    <span class="Li">&quot;+&quot;</span>:</p>
<p class="Pp"></p>
<pre>
     1     case '+':
     2         {
     3             const char tmp = *s++;
                   ... code for ++ ...
     4             if (PL_expect == XOPERATOR) {
                       ...
     5                 Aop(OP_ADD);
     6             }
                   ...
     7         }
</pre>
<p class="Pp">Line 4 checks what type of token we are expecting.
    <span class="Li">&quot;Aop&quot;</span> returns a token. If you search for
    <span class="Li">&quot;Aop&quot;</span> elsewhere in <i>toke.c</i>, you will
    see that it returns an <span class="Li">&quot;ADDOP&quot;</span> token.</p>
<p class="Pp">Now that we know the two token types we want to look for in the
    parser, let's take the piece of <i>perly.y</i> we need to construct the tree
    for <span class="Li">&quot;$a = $b + $c&quot;</span></p>
<p class="Pp"></p>
<pre>
    1 term    :   term ASSIGNOP term
    2                { $$ = newASSIGNOP(OPf_STACKED, $1, $2, $3); }
    3         |   term ADDOP term
    4                { $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
</pre>
<p class="Pp">If you're not used to reading BNF grammars, this is how it works:
    You're fed certain things by the tokeniser, which generally end up in upper
    case. <span class="Li">&quot;ADDOP&quot;</span> and
    <span class="Li">&quot;ASSIGNOP&quot;</span> are examples of &quot;terminal
    symbols&quot;, because you can't get any simpler than them.</p>
<p class="Pp">The grammar, lines one and three of the snippet above, tells you
    how to build up more complex forms. These complex forms, &quot;non-terminal
    symbols&quot; are generally placed in lower case.
    <span class="Li">&quot;term&quot;</span> here is a non-terminal symbol,
    representing a single expression.</p>
<p class="Pp">The grammar gives you the following rule: you can make the thing
    on the left of the colon if you see all the things on the right in sequence.
    This is called a &quot;reduction&quot;, and the aim of parsing is to
    completely reduce the input. There are several different ways you can
    perform a reduction, separated by vertical bars: so,
    <span class="Li">&quot;term&quot;</span> followed by
    <span class="Li">&quot;=&quot;</span> followed by
    <span class="Li">&quot;term&quot;</span> makes a
    <span class="Li">&quot;term&quot;</span>, and
    <span class="Li">&quot;term&quot;</span> followed by
    <span class="Li">&quot;+&quot;</span> followed by
    <span class="Li">&quot;term&quot;</span> can also make a
    <span class="Li">&quot;term&quot;</span>.</p>
<p class="Pp">So, if you see two terms with an
    <span class="Li">&quot;=&quot;</span> or
    <span class="Li">&quot;+&quot;</span>, between them, you can turn them into
    a single expression. When you do this, you execute the code in the block on
    the next line: if you see <span class="Li">&quot;=&quot;</span>, you'll do
    the code in line 2. If you see <span class="Li">&quot;+&quot;</span>, you'll
    do the code in line 4. It's this code which contributes to the op tree.</p>
<p class="Pp"></p>
<pre>
            |   term ADDOP term
            { $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
</pre>
<p class="Pp">What this does is creates a new binary op, and feeds it a number
    of variables. The variables refer to the tokens: <span class="Li">$1</span>
    is the first token in the input, <span class="Li">$2</span> the second, and
    so on - think regular expression backreferences. <span class="Li">$$</span>
    is the op returned from this reduction. So, we call
    <span class="Li">&quot;newBINOP&quot;</span> to create a new binary
    operator. The first parameter to
    <span class="Li">&quot;newBINOP&quot;</span>, a function in <i>op.c</i>, is
    the op type. It's an addition operator, so we want the type to be
    <span class="Li">&quot;ADDOP&quot;</span>. We could specify this directly,
    but it's right there as the second token in the input, so we use
    <span class="Li">$2</span>. The second parameter is the op's flags: 0 means
    &quot;nothing special&quot;. Then the things to add: the left and right hand
    side of our expression, in scalar context.</p>
<p class="Pp">The functions that create ops, which have names like
    <span class="Li">&quot;newUNOP&quot;</span> and
    <span class="Li">&quot;newBINOP&quot;</span>, call a &quot;check&quot;
    function associated with each op type, before returning the op. The check
    functions can mangle the op as they see fit, and even replace it with an
    entirely new one. These functions are defined in <i>op.c</i>, and have a
    <span class="Li">&quot;Perl_ck_&quot;</span> prefix. You can find out which
    check function is used for a particular op type by looking in
    <i>regen/opcodes</i>. Take <span class="Li">&quot;OP_ADD&quot;</span>, for
    example. (<span class="Li">&quot;OP_ADD&quot;</span> is the token value from
    the <span class="Li">&quot;Aop(OP_ADD)&quot;</span> in <i>toke.c</i> which
    the parser passes to <span class="Li">&quot;newBINOP&quot;</span> as its
    first argument.) Here is the relevant line:</p>
<p class="Pp"></p>
<pre>
    add             addition (+)            ck_null         IfsT2   S S
</pre>
<p class="Pp">The check function in this case is
    <span class="Li">&quot;Perl_ck_null&quot;</span>, which does nothing. Let's
    look at a more interesting case:</p>
<p class="Pp"></p>
<pre>
    readline        &lt;HANDLE&gt;                ck_readline     t%      F?
</pre>
<p class="Pp">And here is the function from <i>op.c</i>:</p>
<p class="Pp"></p>
<pre>
     1 OP *
     2 Perl_ck_readline(pTHX_ OP *o)
     3 {
     4     PERL_ARGS_ASSERT_CK_READLINE;
     5 
     6     if (o-&gt;op_flags &amp; OPf_KIDS) {
     7          OP *kid = cLISTOPo-&gt;op_first;
     8          if (kid-&gt;op_type == OP_RV2GV)
     9              kid-&gt;op_private |= OPpALLOW_FAKE;
    10     }
    11     else {
    12         OP * const newop
    13             = newUNOP(OP_READLINE, 0, newGVOP(OP_GV, 0,
    14                                               PL_argvgv));
    15         op_free(o);
    16         return newop;
    17     }
    18     return o;
    19 }
</pre>
<p class="Pp">One particularly interesting aspect is that if the op has no kids
    (i.e., <span class="Li">&quot;readline()&quot;</span> or
    <span class="Li">&quot;&lt;&gt;&quot;</span>) the op is freed and replaced
    with an entirely new one that references <span class="Li">*ARGV</span>
    (lines 12-16).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="STACKS"><a class="permalink" href="#STACKS">STACKS</a></h1>
<p class="Pp">When perl executes something like
    <span class="Li">&quot;addop&quot;</span>, how does it pass on its results
    to the next op? The answer is, through the use of stacks. Perl has a number
    of stacks to store things it's currently working on, and we'll look at the
    three most important ones here.</p>
<section class="Ss">
<h2 class="Ss" id="Argument_stack"><a class="permalink" href="#Argument_stack">Argument
  stack</a></h2>
<p class="Pp">Arguments are passed to PP code and returned from PP code using
    the argument stack, <span class="Li">&quot;ST&quot;</span>. The typical way
    to handle arguments is to pop them off the stack, deal with them how you
    wish, and then push the result back onto the stack. This is how, for
    instance, the cosine operator works:</p>
<p class="Pp"></p>
<pre>
      NV value;
      value = POPn;
      value = Perl_cos(value);
      XPUSHn(value);
</pre>
<p class="Pp">We'll see a more tricky example of this when we consider Perl's
    macros below. <span class="Li">&quot;POPn&quot;</span> gives you the NV
    (floating point value) of the top SV on the stack: the
    <span class="Li">$x</span> in <span class="Li">&quot;cos($x)&quot;</span>.
    Then we compute the cosine, and push the result back as an NV. The
    <span class="Li">&quot;X&quot;</span> in
    <span class="Li">&quot;XPUSHn&quot;</span> means that the stack should be
    extended if necessary - it can't be necessary here, because we know there's
    room for one more item on the stack, since we've just removed one! The
    <span class="Li">&quot;XPUSH*&quot;</span> macros at least guarantee
  safety.</p>
<p class="Pp">Alternatively, you can fiddle with the stack directly:
    <span class="Li">&quot;SP&quot;</span> gives you the first element in your
    portion of the stack, and <span class="Li">&quot;TOP*&quot;</span> gives you
    the top SV/IV/NV/etc. on the stack. So, for instance, to do unary negation
    of an integer:</p>
<p class="Pp"></p>
<pre>
     SETi(-TOPi);
</pre>
<p class="Pp">Just set the integer value of the top stack entry to its
  negation.</p>
<p class="Pp">Argument stack manipulation in the core is exactly the same as it
    is in XSUBs - see perlxstut, perlxs and perlguts for a longer description of
    the macros used in stack manipulation.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Mark_stack"><a class="permalink" href="#Mark_stack">Mark
  stack</a></h2>
<p class="Pp">I say &quot;your portion of the stack&quot; above because PP code
    doesn't necessarily get the whole stack to itself: if your function calls
    another function, you'll only want to expose the arguments aimed for the
    called function, and not (necessarily) let it get at your own data. The way
    we do this is to have a &quot;virtual&quot; bottom-of-stack, exposed to each
    function. The mark stack keeps bookmarks to locations in the argument stack
    usable by each function. For instance, when dealing with a tied variable,
    (internally, something with &quot;P&quot; magic) Perl has to call methods
    for accesses to the tied variables. However, we need to separate the
    arguments exposed to the method to the argument exposed to the original
    function - the store or fetch or whatever it may be. Here's roughly how the
    tied <span class="Li">&quot;push&quot;</span> is implemented; see
    <span class="Li">&quot;av_push&quot;</span> in <i>av.c</i>:</p>
<p class="Pp"></p>
<pre>
     1  PUSHMARK(SP);
     2  EXTEND(SP,2);
     3  PUSHs(SvTIED_obj((SV*)av, mg));
     4  PUSHs(val);
     5  PUTBACK;
     6  ENTER;
     7  call_method(&quot;PUSH&quot;, G_SCALAR|G_DISCARD);
     8  LEAVE;
</pre>
<p class="Pp">Let's examine the whole implementation, for practice:</p>
<p class="Pp"></p>
<pre>
     1  PUSHMARK(SP);
</pre>
<p class="Pp">Push the current state of the stack pointer onto the mark stack.
    This is so that when we've finished adding items to the argument stack, Perl
    knows how many things we've added recently.</p>
<p class="Pp"></p>
<pre>
     2  EXTEND(SP,2);
     3  PUSHs(SvTIED_obj((SV*)av, mg));
     4  PUSHs(val);
</pre>
<p class="Pp">We're going to add two more items onto the argument stack: when
    you have a tied array, the <span class="Li">&quot;PUSH&quot;</span>
    subroutine receives the object and the value to be pushed, and that's
    exactly what we have here - the tied object, retrieved with
    <span class="Li">&quot;SvTIED_obj&quot;</span>, and the value, the SV
    <span class="Li">&quot;val&quot;</span>.</p>
<p class="Pp"></p>
<pre>
     5  PUTBACK;
</pre>
<p class="Pp">Next we tell Perl to update the global stack pointer from our
    internal variable: <span class="Li">&quot;dSP&quot;</span> only gave us a
    local copy, not a reference to the global.</p>
<p class="Pp"></p>
<pre>
     6  ENTER;
     7  call_method(&quot;PUSH&quot;, G_SCALAR|G_DISCARD);
     8  LEAVE;
</pre>
<p class="Pp"><span class="Li">&quot;ENTER&quot;</span> and
    <span class="Li">&quot;LEAVE&quot;</span> localise a block of code - they
    make sure that all variables are tidied up, everything that has been
    localised gets its previous value returned, and so on. Think of them as the
    <span class="Li">&quot;{&quot;</span> and
    <span class="Li">&quot;}&quot;</span> of a Perl block.</p>
<p class="Pp">To actually do the magic method call, we have to call a subroutine
    in Perl space: <span class="Li">&quot;call_method&quot;</span> takes care of
    that, and it's described in perlcall. We call the
    <span class="Li">&quot;PUSH&quot;</span> method in scalar context, and we're
    going to discard its return value. The <b>call_method()</b> function removes
    the top element of the mark stack, so there is nothing for the caller to
    clean up.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Save_stack"><a class="permalink" href="#Save_stack">Save
  stack</a></h2>
<p class="Pp">C doesn't have a concept of local scope, so perl provides one.
    We've seen that <span class="Li">&quot;ENTER&quot;</span> and
    <span class="Li">&quot;LEAVE&quot;</span> are used as scoping braces; the
    save stack implements the C equivalent of, for example:</p>
<p class="Pp"></p>
<pre>
    {
        local $foo = 42;
        ...
    }
</pre>
<p class="Pp">See &quot;Localizing changes&quot; in perlguts for how to use the
    save stack.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="MILLIONS_OF_MACROS"><a class="permalink" href="#MILLIONS_OF_MACROS">MILLIONS
  OF MACROS</a></h1>
<p class="Pp">One thing you'll notice about the Perl source is that it's full of
    macros. Some have called the pervasive use of macros the hardest thing to
    understand, others find it adds to clarity. Let's take an example, a
    stripped-down version the code which implements the addition operator:</p>
<p class="Pp"></p>
<pre>
   1  PP(pp_add)
   2  {
   3      dSP; dATARGET;
   4      tryAMAGICbin_MG(add_amg, AMGf_assign|AMGf_numeric);
   5      {
   6        dPOPTOPnnrl_ul;
   7        SETn( left + right );
   8        RETURN;
   9      }
  10  }
</pre>
<p class="Pp">Every line here (apart from the braces, of course) contains a
    macro. The first line sets up the function declaration as Perl expects for
    PP code; line 3 sets up variable declarations for the argument stack and the
    target, the return value of the operation. Line 4 tries to see if the
    addition operation is overloaded; if so, the appropriate subroutine is
    called.</p>
<p class="Pp">Line 6 is another variable declaration - all variable declarations
    start with <span class="Li">&quot;d&quot;</span> - which pops from the top
    of the argument stack two NVs (hence <span class="Li">&quot;nn&quot;</span>)
    and puts them into the variables <span class="Li">&quot;right&quot;</span>
    and <span class="Li">&quot;left&quot;</span>, hence the
    <span class="Li">&quot;rl&quot;</span>. These are the two operands to the
    addition operator. Next, we call <span class="Li">&quot;SETn&quot;</span> to
    set the NV of the return value to the result of adding the two values. This
    done, we return - the <span class="Li">&quot;RETURN&quot;</span> macro makes
    sure that our return value is properly handled, and we pass the next
    operator to run back to the main run loop.</p>
<p class="Pp">Most of these macros are explained in perlapi, and some of the
    more important ones are explained in perlxs as well. Pay special attention
    to &quot;Background and PERL_IMPLICIT_CONTEXT&quot; in perlguts for
    information on the <span class="Li">&quot;[pad]THX_?&quot;</span>
  macros.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FURTHER_READING"><a class="permalink" href="#FURTHER_READING">FURTHER
  READING</a></h1>
<p class="Pp">For more information on the Perl internals, please see the
    documents listed at &quot;Internals and C Language Interface&quot; in
  perl.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

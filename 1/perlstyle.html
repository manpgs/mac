<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PERLSTYLE(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLSTYLE(1)</td>
    <td class="head-vol"><a href=".">Perl Programmers Reference Guide</a></td>
    <td class="head-rtitle">PERLSTYLE(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlstyle - Perl style guide</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Each programmer will, of course, have his or her own preferences
    in regards to formatting, but there are some general guidelines that will
    make your programs easier to read, understand, and maintain.</p>
<p class="Pp">The most important thing is to use strict and warnings in all your
    code or know the reason why not to. You may turn them off explicitly for
    particular portions of code via <span class="Li">&quot;no
    warnings&quot;</span> or <span class="Li">&quot;no strict&quot;</span>, and
    this can be limited to the specific warnings or strict features you wish to
    disable. The <b>-w</b> flag and <span class="Li">$^W</span> variable should
    not be used for this purpose since they can affect code you use but did not
    write, such as modules from core or CPAN.</p>
<p class="Pp">Regarding aesthetics of code lay out, about the only thing Larry
    cares strongly about is that the closing curly bracket of a multi-line BLOCK
    should line up with the keyword that started the construct. Beyond that, he
    has other preferences that aren't so strong:</p>
<ul class="Bl-bullet">
  <li>4-column indent.</li>
  <li>Opening curly on same line as keyword, if possible, otherwise line
    up.</li>
  <li>Space before the opening curly of a multi-line BLOCK.</li>
  <li>One-line BLOCK may be put on one line, including curlies.</li>
  <li>No space before the semicolon.</li>
  <li>Semicolon omitted in &quot;short&quot; one-line BLOCK.</li>
  <li>Space around most operators.</li>
  <li>Space around a &quot;complex&quot; subscript (inside brackets).</li>
  <li>Blank lines between chunks that do different things.</li>
  <li>Uncuddled elses.</li>
  <li>No space between function name and its opening parenthesis.</li>
  <li>Space after each comma.</li>
  <li>Long lines broken after an operator (except
      <span class="Li">&quot;and&quot;</span> and
      <span class="Li">&quot;or&quot;</span>).</li>
  <li>Space after last parenthesis matching on current line.</li>
  <li>Line up corresponding items vertically.</li>
  <li>Omit redundant punctuation as long as clarity doesn't suffer.</li>
</ul>
<p class="Pp">Larry has his reasons for each of these things, but he doesn't
    claim that everyone else's mind works the same as his does.</p>
<p class="Pp">Here are some other more substantive style issues to think
  about:</p>
<ul class="Bl-bullet">
  <li>Just because you <i>CAN</i> do something a particular way doesn't mean
      that you <i>SHOULD</i> do it that way. Perl is designed to give you
      several ways to do anything, so consider picking the most readable one.
      For instance
    <p class="Pp"></p>
    <pre>    open(my $fh, '&lt;', $foo) || die &quot;Can't open $foo: $!&quot;;
    </pre>
    <p class="Pp">is better than</p>
    <p class="Pp"></p>
    <pre>    die &quot;Can't open $foo: $!&quot; unless open(my $fh, '&lt;', $foo);
    </pre>
    <p class="Pp">because the second way hides the main point of the statement
        in a modifier. On the other hand</p>
    <p class="Pp"></p>
    <pre>    print &quot;Starting analysis\n&quot; if $verbose;
    </pre>
    <p class="Pp">is better than</p>
    <p class="Pp"></p>
    <pre>    $verbose &amp;&amp; print &quot;Starting analysis\n&quot;;
    </pre>
    <p class="Pp">because the main point isn't whether the user typed <b>-v</b>
        or not.</p>
    <p class="Pp">Similarly, just because an operator lets you assume default
        arguments doesn't mean that you have to make use of the defaults. The
        defaults are there for lazy systems programmers writing one-shot
        programs. If you want your program to be readable, consider supplying
        the argument.</p>
    <p class="Pp">Along the same lines, just because you <i>CAN</i> omit
        parentheses in many places doesn't mean that you ought to:</p>
    <p class="Pp"></p>
    <pre>    return print reverse sort num values %array;
    return print(reverse(sort num (values(%array))));
    </pre>
    <p class="Pp">When in doubt, parenthesize. At the very least it will let
        some poor schmuck bounce on the % key in <b>vi</b>.</p>
    <p class="Pp">Even if you aren't in doubt, consider the mental welfare of
        the person who has to maintain the code after you, and who will probably
        put parentheses in the wrong place.</p>
  </li>
  <li>Don't go through silly contortions to exit a loop at the top or the
      bottom, when Perl provides the <span class="Li">&quot;last&quot;</span>
      operator so you can exit in the middle. Just &quot;outdent&quot; it a
      little to make it more visible:
    <p class="Pp"></p>
    <pre>    LINE:
        for (;;) {
            statements;
          last LINE if $foo;
            next LINE if /^#/;
            statements;
        }
    </pre>
  </li>
  <li>Don't be afraid to use loop labels--they're there to enhance readability
      as well as to allow multilevel loop breaks. See the previous example.</li>
  <li>Avoid using <span class="Li">&quot;grep()&quot;</span> (or
      <span class="Li">&quot;map()&quot;</span>) or `backticks` in a void
      context, that is, when you just throw away their return values. Those
      functions all have return values, so use them. Otherwise use a
      <span class="Li">&quot;foreach()&quot;</span> loop or the
      <span class="Li">&quot;system()&quot;</span> function instead.</li>
  <li>For portability, when using features that may not be implemented on every
      machine, test the construct in an eval to see if it fails. If you know
      what version or patchlevel a particular feature was implemented, you can
      test <span class="Li">$]</span> (<span class="Li">$PERL_VERSION</span> in
      <span class="Li">&quot;English&quot;</span>) to see if it will be there.
      The <span class="Li">&quot;Config&quot;</span> module will also let you
      interrogate values determined by the <b>Configure</b> program when Perl
      was installed.</li>
  <li>Choose mnemonic identifiers. If you can't remember what mnemonic means,
      you've got a problem.</li>
  <li>While short identifiers like <span class="Li">$gotit</span> are probably
      ok, use underscores to separate words in longer identifiers. It is
      generally easier to read <span class="Li">$var_names_like_this</span> than
      <span class="Li">$VarNamesLikeThis</span>, especially for non-native
      speakers of English. It's also a simple rule that works consistently with
      <span class="Li">&quot;VAR_NAMES_LIKE_THIS&quot;</span>.
    <p class="Pp">Package names are sometimes an exception to this rule. Perl
        informally reserves lowercase module names for &quot;pragma&quot;
        modules like <span class="Li">&quot;integer&quot;</span> and
        <span class="Li">&quot;strict&quot;</span>. Other modules should begin
        with a capital letter and use mixed case, but probably without
        underscores due to limitations in primitive file systems'
        representations of module names as files that must fit into a few sparse
        bytes.</p>
  </li>
  <li>You may find it helpful to use letter case to indicate the scope or nature
      of a variable. For example:
    <p class="Pp"></p>
    <pre>    $ALL_CAPS_HERE   constants only (beware clashes with perl vars!)
    $Some_Caps_Here  package-wide global/static
    $no_caps_here    function scope my() or local() variables
    </pre>
    <p class="Pp">Function and method names seem to work best as all lowercase.
        E.g., <span class="Li">&quot;$obj-&gt;as_string()&quot;</span>.</p>
    <p class="Pp">You can use a leading underscore to indicate that a variable
        or function should not be used outside the package that defined it.</p>
  </li>
  <li>If you have a really hairy regular expression, use the
      <span class="Li">&quot;/x&quot;</span> or
      <span class="Li">&quot;/xx&quot;</span> modifiers and put in some
      whitespace to make it look a little less like line noise. Don't use slash
      as a delimiter when your regexp has slashes or backslashes.</li>
  <li>Use the new <span class="Li">&quot;and&quot;</span> and
      <span class="Li">&quot;or&quot;</span> operators to avoid having to
      parenthesize list operators so much, and to reduce the incidence of
      punctuation operators like <span class="Li">&quot;&amp;&amp;&quot;</span>
      and <span class="Li">&quot;||&quot;</span>. Call your subroutines as if
      they were functions or list operators to avoid excessive ampersands and
      parentheses.</li>
  <li>Use here documents instead of repeated
      <span class="Li">&quot;print()&quot;</span> statements.</li>
  <li>Line up corresponding things vertically, especially if it'd be too long to
      fit on one line anyway.
    <p class="Pp"></p>
    <pre>    $IDX = $ST_MTIME;
    $IDX = $ST_ATIME       if $opt_u;
    $IDX = $ST_CTIME       if $opt_c;
    $IDX = $ST_SIZE        if $opt_s;
    mkdir $tmpdir, 0700 or die &quot;can't mkdir $tmpdir: $!&quot;;
    chdir($tmpdir)      or die &quot;can't chdir $tmpdir: $!&quot;;
    mkdir 'tmp',   0777 or die &quot;can't mkdir $tmpdir/tmp: $!&quot;;
    </pre>
  </li>
  <li>Always check the return codes of system calls. Good error messages should
      go to <span class="Li">&quot;STDERR&quot;</span>, include which program
      caused the problem, what the failed system call and arguments were, and
      (VERY IMPORTANT) should contain the standard system error message for what
      went wrong. Here's a simple but sufficient example:
    <p class="Pp"></p>
    <pre>    opendir(my $dh, $dir)        or die &quot;can't opendir $dir: $!&quot;;
    </pre>
  </li>
  <li>Line up your transliterations when it makes sense:
    <p class="Pp"></p>
    <pre>    tr [abc]
       [xyz];
    </pre>
  </li>
  <li>Think about reusability. Why waste brainpower on a one-shot when you might
      want to do something like it again? Consider generalizing your code.
      Consider writing a module or object class. Consider making your code run
      cleanly with <span class="Li">&quot;use strict&quot;</span> and
      <span class="Li">&quot;use warnings&quot;</span> in effect. Consider
      giving away your code. Consider changing your whole world view.
      Consider... oh, never mind.</li>
  <li>Try to document your code and use Pod formatting in a consistent way. Here
      are commonly expected conventions:</li>
</ul>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>use <span class="Li">&quot;C&lt;&gt;&quot;</span> for function, variable
      and module names (and more generally anything that can be considered part
      of code, like filehandles or specific values). Note that function names
      are considered more readable with parentheses after their name, that is
      <span class="Li">&quot;function()&quot;</span>.</li>
  <li>use <span class="Li">&quot;B&lt;&gt;&quot;</span> for commands names like
      <b>cat</b> or <b>grep</b>.</li>
  <li>use <span class="Li">&quot;F&lt;&gt;&quot;</span> or
      <span class="Li">&quot;C&lt;&gt;&quot;</span> for file names.
      <span class="Li">&quot;F&lt;&gt;&quot;</span> should be the only Pod code
      for file names, but as most Pod formatters render it as italic, Unix and
      Windows paths with their slashes and backslashes may be less readable, and
      better rendered with <span class="Li">&quot;C&lt;&gt;&quot;</span>.</li>
</ul>
</div>
<div class="Bd-indent"></div>
<ul class="Bl-bullet">
  <li>Be consistent.</li>
  <li>Be nice.</li>
</ul>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os"><a href="..">perl v5.34.1</a></td>
  </tr>
</table>
</body>
</html>

<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PERLUNICODE(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLUNICODE(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLUNICODE(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlunicode - Unicode support in Perl</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<section class="Ss">
<h2 class="Ss" id="Important_Caveats"><a class="permalink" href="#Important_Caveats">Important
  Caveats</a></h2>
<p class="Pp">Unicode support is an extensive requirement. While Perl does not
    implement the Unicode standard or the accompanying technical reports from
    cover to cover, Perl does support many Unicode features.</p>
<p class="Pp">People who want to learn to use Unicode in Perl, should probably
    read the Perl Unicode tutorial, perlunitut and perluniintro, before reading
    this reference document.</p>
<p class="Pp">Also, the use of Unicode may present security issues that aren't
    obvious. Read Unicode Security Considerations
    &lt;http://www.unicode.org/reports/tr36&gt;.</p>
<dl class="Bl-tag">
  <dt id="Safest"><a class="permalink" href="#Safest">Safest if you &quot;use
    feature 'unicode_strings'&quot;</a></dt>
  <dd>In order to preserve backward compatibility, Perl does not turn on full
      internal Unicode support unless the pragma <span class="Li">&quot;use
      feature 'unicode_strings'&quot;</span> is specified. (This is
      automatically selected if you use <span class="Li">&quot;use
      5.012&quot;</span> or higher.) Failure to do this can trigger unexpected
      surprises. See &quot;The &quot;Unicode Bug&quot;&quot; below.
    <p class="Pp">This pragma doesn't affect I/O. Nor does it change the
        internal representation of strings, only their interpretation. There are
        still several places where Unicode isn't fully supported, such as in
        filenames.</p>
  </dd>
  <dt id="Input"><a class="permalink" href="#Input">Input and Output
    Layers</a></dt>
  <dd>Perl knows when a filehandle uses Perl's internal Unicode encodings
      (UTF-8, or UTF-EBCDIC if in EBCDIC) if the filehandle is opened with the
      &quot;:encoding(utf8)&quot; layer. Other encodings can be converted to
      Perl's encoding on input or from Perl's encoding on output by use of the
      &quot;:encoding(...)&quot; layer. See open.
    <p class="Pp">To indicate that Perl source itself is in UTF-8, use
        <span class="Li">&quot;use utf8;&quot;</span>.</p>
  </dd>
  <dt>&quot;use utf8&quot; still needed to enable UTF-8/UTF-EBCDIC in
    scripts</dt>
  <dd>As a compatibility measure, the <span class="Li">&quot;use
      utf8&quot;</span> pragma must be explicitly included to enable recognition
      of UTF-8 in the Perl scripts themselves (in string or regular expression
      literals, or in identifier names) on ASCII-based machines or to recognize
      UTF-EBCDIC on EBCDIC-based machines. <b>These are the only times when an
      explicit </b><b>&quot;use utf8&quot;</b><b></b> <b>is needed.</b> See
      utf8.</dd>
  <dt id="BOM-marked"><a class="permalink" href="#BOM-marked">BOM-marked scripts
    and UTF-16 scripts autodetected</a></dt>
  <dd>If a Perl script begins marked with the Unicode BOM (UTF-16LE, UTF16-BE,
      or UTF-8), or if the script looks like non-BOM-marked UTF-16 of either
      endianness, Perl will correctly read in the script as Unicode. (BOMless
      UTF-8 cannot be effectively recognized or differentiated from ISO 8859-1
      or other eight-bit encodings.)</dd>
  <dt>&quot;use encoding&quot; needed to upgrade non-Latin-1 byte strings</dt>
  <dd>By default, there is a fundamental asymmetry in Perl's Unicode model:
      implicit upgrading from byte strings to Unicode strings assumes that they
      were encoded in <i>ISO 8859-1 (Latin-1)</i>, but Unicode strings are
      downgraded with UTF-8 encoding. This happens because the first 256
      codepoints in Unicode happens to agree with Latin-1.
    <p class="Pp">See &quot;Byte and Character Semantics&quot; for more
      details.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Byte_and_Character_Semantics"><a class="permalink" href="#Byte_and_Character_Semantics">Byte
  and Character Semantics</a></h2>
<p class="Pp">Perl uses logically-wide characters to represent strings
    internally.</p>
<p class="Pp">Starting in Perl 5.14, Perl-level operations work with characters
    rather than bytes within the scope of a <span class="Li">&quot;use feature
    'unicode_strings'&quot;</span> (or equivalently <span class="Li">&quot;use
    5.012&quot;</span> or higher). (This is not true if bytes have been
    explicitly requested by <span class="Li">&quot;use bytes&quot;</span>, nor
    necessarily true for interactions with the platform's operating system.)</p>
<p class="Pp">For earlier Perls, and when
    <span class="Li">&quot;unicode_strings&quot;</span> is not in effect, Perl
    provides a fairly safe environment that can handle both types of semantics
    in programs. For operations where Perl can unambiguously decide that the
    input data are characters, Perl switches to character semantics. For
    operations where this determination cannot be made without additional
    information from the user, Perl decides in favor of compatibility and
    chooses to use byte semantics.</p>
<p class="Pp">When <span class="Li">&quot;use locale&quot;</span> (but not
    <span class="Li">&quot;use locale ':not_characters'&quot;</span>) is in
    effect, Perl uses the semantics associated with the current locale.
    (<span class="Li">&quot;use locale&quot;</span> overrides
    <span class="Li">&quot;use feature 'unicode_strings'&quot;</span> in the
    same scope; while <span class="Li">&quot;use locale
    ':not_characters'&quot;</span> effectively also selects
    <span class="Li">&quot;use feature 'unicode_strings'&quot;</span> in its
    scope; see perllocale.) Otherwise, Perl uses the platform's native byte
    semantics for characters whose code points are less than 256, and Unicode
    semantics for those greater than 255. That means that non-ASCII characters
    are undefined except for their ordinal numbers. This means that none have
    case (upper and lower), nor are any a member of character classes, like
    <span class="Li">&quot;[:alpha:]&quot;</span> or
    <span class="Li">&quot;\w&quot;</span>. (But all do belong to the
    <span class="Li">&quot;\W&quot;</span> class or the Perl regular expression
    extension <span class="Li">&quot;[:^alpha:]&quot;</span>.)</p>
<p class="Pp">This behavior preserves compatibility with earlier versions of
    Perl, which allowed byte semantics in Perl operations only if none of the
    program's inputs were marked as being a source of Unicode character data.
    Such data may come from filehandles, from calls to external programs, from
    information provided by the system (such as <span class="Li">%ENV</span>),
    or from literals and constants in the source text.</p>
<p class="Pp">The <span class="Li">&quot;utf8&quot;</span> pragma is primarily a
    compatibility device that enables recognition of UTF-(8|EBCDIC) in literals
    encountered by the parser. Note that this pragma is only required while Perl
    defaults to byte semantics; when character semantics become the default,
    this pragma may become a no-op. See utf8.</p>
<p class="Pp">If strings operating under byte semantics and strings with Unicode
    character data are concatenated, the new string will have character
    semantics. This can cause surprises: See &quot;BUGS&quot;, below. You can
    choose to be warned when this happens. See encoding::warnings.</p>
<p class="Pp">Under character semantics, many operations that formerly operated
    on bytes now operate on characters. A character in Perl is logically just a
    number ranging from 0 to 2**31 or so. Larger characters may encode into
    longer sequences of bytes internally, but this internal detail is mostly
    hidden for Perl code. See perluniintro for more.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Effects_of_Character_Semantics"><a class="permalink" href="#Effects_of_Character_Semantics">Effects
  of Character Semantics</a></h2>
<p class="Pp">Character semantics have the following effects:</p>
<ul class="Bl-bullet">
  <li>Strings--including hash keys--and regular expression patterns may contain
      characters that have an ordinal value larger than 255.
    <p class="Pp">If you use a Unicode editor to edit your program, Unicode
        characters may occur directly within the literal strings in UTF-8
        encoding, or UTF-16. (The former requires a BOM or
        <span class="Li">&quot;use utf8&quot;</span>, the latter requires a
        BOM.)</p>
    <p class="Pp">Unicode characters can also be added to a string by using the
        <span class="Li">&quot;\N{U+...}&quot;</span> notation. The Unicode code
        for the desired character, in hexadecimal, should be placed in the
        braces, after the <span class="Li">&quot;U&quot;</span>. For instance, a
        smiley face is <span class="Li">&quot;\N{U+263A}&quot;</span>.</p>
    <p class="Pp">Alternatively, you can use the
        <span class="Li">&quot;\x{...}&quot;</span> notation for characters
        0x100 and above. For characters below 0x100 you may get byte semantics
        instead of character semantics; see &quot;The &quot;Unicode
        Bug&quot;&quot;. On EBCDIC machines there is the additional problem that
        the value for such characters gives the EBCDIC character rather than the
        Unicode one, thus it is more portable to use
        <span class="Li">&quot;\N{U+...}&quot;</span> instead.</p>
    <p class="Pp">Additionally, you can use the
        <span class="Li">&quot;\N{...}&quot;</span> notation and put the
        official Unicode character name within the braces, such as
        <span class="Li">&quot;\N{WHITE SMILING FACE}&quot;</span>. This
        automatically loads the charnames module with the
        <span class="Li">&quot;:full&quot;</span> and
        <span class="Li">&quot;:short&quot;</span> options. If you prefer
        different options for this module, you can instead, before the
        <span class="Li">&quot;\N{...}&quot;</span>, explicitly load it with
        your desired options; for example,</p>
    <p class="Pp"></p>
    <pre>
   use charnames ':loose';
    </pre>
  </li>
  <li>If an appropriate encoding is specified, identifiers within the Perl
      script may contain Unicode alphanumeric characters, including ideographs.
      Perl does not currently attempt to canonicalize variable names.</li>
  <li>Regular expressions match characters instead of bytes. &quot;.&quot;
      matches a character instead of a byte.</li>
  <li>Bracketed character classes in regular expressions match characters
      instead of bytes and match against the character properties specified in
      the Unicode properties database. <span class="Li">&quot;\w&quot;</span>
      can be used to match a Japanese ideograph, for instance.</li>
  <li>Named Unicode properties, scripts, and block ranges may be used (like
      bracketed character classes) by using the
      <span class="Li">&quot;\p{}&quot;</span> &quot;matches property&quot;
      construct and the <span class="Li">&quot;\P{}&quot;</span> negation,
      &quot;doesn't match property&quot;. See &quot;Unicode Character
      Properties&quot; for more details.
    <p class="Pp">You can define your own character properties and use them in
        the regular expression with the <span class="Li">&quot;\p{}&quot;</span>
        or <span class="Li">&quot;\P{}&quot;</span> construct. See
        &quot;User-Defined Character Properties&quot; for more details.</p>
  </li>
  <li>The special pattern <span class="Li">&quot;\X&quot;</span> matches a
      logical character, an &quot;extended grapheme cluster&quot; in
      Standardese. In Unicode what appears to the user to be a single character,
      for example an accented <span class="Li">&quot;G&quot;</span>, may in fact
      be composed of a sequence of characters, in this case a
      <span class="Li">&quot;G&quot;</span> followed by an accent character.
      <span class="Li">&quot;\X&quot;</span> will match the entire
    sequence.</li>
  <li>The <span class="Li">&quot;tr///&quot;</span> operator translates
      characters instead of bytes. Note that the
      <span class="Li">&quot;tr///CU&quot;</span> functionality has been
      removed. For similar functionality see pack('U0', ...) and pack('C0',
      ...).</li>
  <li>Case translation operators use the Unicode case translation tables when
      character input is provided. Note that
      <span class="Li">&quot;uc()&quot;</span>, or
      <span class="Li">&quot;\U&quot;</span> in interpolated strings, translates
      to uppercase, while <span class="Li">&quot;ucfirst&quot;</span>, or
      <span class="Li">&quot;\u&quot;</span> in interpolated strings, translates
      to titlecase in languages that make the distinction (which is equivalent
      to uppercase in languages without the distinction).</li>
  <li>Most operators that deal with positions or lengths in a string will
      automatically switch to using character positions, including
      <span class="Li">&quot;chop()&quot;</span>,
      <span class="Li">&quot;chomp()&quot;</span>,
      <span class="Li">&quot;substr()&quot;</span>,
      <span class="Li">&quot;pos()&quot;</span>,
      <span class="Li">&quot;index()&quot;</span>,
      <span class="Li">&quot;rindex()&quot;</span>,
      <span class="Li">&quot;sprintf()&quot;</span>,
      <span class="Li">&quot;write()&quot;</span>, and
      <span class="Li">&quot;length()&quot;</span>. An operator that
      specifically does not switch is <span class="Li">&quot;vec()&quot;</span>.
      Operators that really don't care include operators that treat strings as a
      bucket of bits such as <span class="Li">&quot;sort()&quot;</span>, and
      operators dealing with filenames.</li>
  <li>The
      <span class="Li">&quot;pack()&quot;</span>/<span class="Li">&quot;unpack()&quot;</span>
      letter <span class="Li">&quot;C&quot;</span> does <i>not</i> change, since
      it is often used for byte-oriented formats. Again, think
      <span class="Li">&quot;char&quot;</span> in the C language.
    <p class="Pp">There is a new <span class="Li">&quot;U&quot;</span> specifier
        that converts between Unicode characters and code points. There is also
        a <span class="Li">&quot;W&quot;</span> specifier that is the equivalent
        of
        <span class="Li">&quot;chr&quot;</span>/<span class="Li">&quot;ord&quot;</span>
        and properly handles character values even if they are above 255.</p>
  </li>
  <li>The <span class="Li">&quot;chr()&quot;</span> and
      <span class="Li">&quot;ord()&quot;</span> functions work on characters,
      similar to <span class="Li">&quot;pack(&quot;W&quot;)&quot;</span> and
      <span class="Li">&quot;unpack(&quot;W&quot;)&quot;</span>, <i>not</i>
      <span class="Li">&quot;pack(&quot;C&quot;)&quot;</span> and
      <span class="Li">&quot;unpack(&quot;C&quot;)&quot;</span>.
      <span class="Li">&quot;pack(&quot;C&quot;)&quot;</span> and
      <span class="Li">&quot;unpack(&quot;C&quot;)&quot;</span> are methods for
      emulating byte-oriented <span class="Li">&quot;chr()&quot;</span> and
      <span class="Li">&quot;ord()&quot;</span> on Unicode strings. While these
      methods reveal the internal encoding of Unicode strings, that is not
      something one normally needs to care about at all.</li>
  <li>The bit string operators, <span class="Li">&quot;&amp; | ^ ~&quot;</span>,
      can operate on character data. However, for backward compatibility, such
      as when using bit string operations when characters are all less than 256
      in ordinal value, one should not use <span class="Li">&quot;~&quot;</span>
      (the bit complement) with characters of both values less than 256 and
      values greater than 256. Most importantly, DeMorgan's laws
      (<span class="Li">&quot;~($x|$y) eq ~$x&amp;~$y&quot;</span> and
      <span class="Li">&quot;~($x&amp;$y) eq ~$x|~$y&quot;</span>) will not
      hold. The reason for this mathematical <i>faux pas</i> is that the
      complement cannot return <b>both</b> the 8-bit (byte-wide) bit complement
      <b>and</b> the full character-wide bit complement.</li>
  <li>There is a CPAN module, Unicode::Casing, which allows you to define your
      own mappings to be used in <span class="Li">&quot;lc()&quot;</span>,
      <span class="Li">&quot;lcfirst()&quot;</span>,
      <span class="Li">&quot;uc()&quot;</span>,
      <span class="Li">&quot;ucfirst()&quot;</span>, and
      <span class="Li">&quot;fc&quot;</span> (or their double-quoted string
      inlined versions such as <span class="Li">&quot;\U&quot;</span>). (Prior
      to Perl 5.16, this functionality was partially provided in the Perl core,
      but suffered from a number of insurmountable drawbacks, so the CPAN module
      was written instead.)</li>
  <li>And finally, <span class="Li">&quot;scalar reverse()&quot;</span> reverses
      by character rather than by byte.</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Unicode_Character_Properties"><a class="permalink" href="#Unicode_Character_Properties">Unicode
  Character Properties</a></h2>
<p class="Pp">(The only time that Perl considers a sequence of individual code
    points as a single logical character is in the
    <span class="Li">&quot;\X&quot;</span> construct, already mentioned above.
    Therefore &quot;character&quot; in this discussion means a single Unicode
    code point.)</p>
<p class="Pp">Very nearly all Unicode character properties are accessible
    through regular expressions by using the
    <span class="Li">&quot;\p{}&quot;</span> &quot;matches property&quot;
    construct and the <span class="Li">&quot;\P{}&quot;</span> &quot;doesn't
    match property&quot; for its negation.</p>
<p class="Pp">For instance, <span class="Li">&quot;\p{Uppercase}&quot;</span>
    matches any single character with the Unicode &quot;Uppercase&quot;
    property, while <span class="Li">&quot;\p{L}&quot;</span> matches any
    character with a General_Category of &quot;L&quot; (letter) property.
    Brackets are not required for single letter property names, so
    <span class="Li">&quot;\p{L}&quot;</span> is equivalent to
    <span class="Li">&quot;\pL&quot;</span>.</p>
<p class="Pp">More formally, <span class="Li">&quot;\p{Uppercase}&quot;</span>
    matches any single character whose Unicode Uppercase property value is True,
    and <span class="Li">&quot;\P{Uppercase}&quot;</span> matches any character
    whose Uppercase property value is False, and they could have been written as
    <span class="Li">&quot;\p{Uppercase=True}&quot;</span> and
    <span class="Li">&quot;\p{Uppercase=False}&quot;</span>, respectively.</p>
<p class="Pp">This formality is needed when properties are not binary; that is,
    if they can take on more values than just True and False. For example, the
    Bidi_Class (see &quot;Bidirectional Character Types&quot; below), can take
    on several different values, such as Left, Right, Whitespace, and others. To
    match these, one needs to specify both the property name (Bidi_Class), AND
    the value being matched against (Left, Right, etc.). This is done, as in the
    examples above, by having the two components separated by an equal sign (or
    interchangeably, a colon), like <span class="Li">&quot;\p{Bidi_Class:
    Left}&quot;</span>.</p>
<p class="Pp">All Unicode-defined character properties may be written in these
    compound forms of <span class="Li">&quot;\p{property=value}&quot;</span> or
    <span class="Li">&quot;\p{property:value}&quot;</span>, but Perl provides
    some additional properties that are written only in the single form, as well
    as single-form short-cuts for all binary properties and certain others
    described below, in which you may omit the property name and the equals or
    colon separator.</p>
<p class="Pp">Most Unicode character properties have at least two synonyms (or
    aliases if you prefer): a short one that is easier to type and a longer one
    that is more descriptive and hence easier to understand. Thus the
    &quot;L&quot; and &quot;Letter&quot; properties above are equivalent and can
    be used interchangeably. Likewise, &quot;Upper&quot; is a synonym for
    &quot;Uppercase&quot;, and we could have written
    <span class="Li">&quot;\p{Uppercase}&quot;</span> equivalently as
    <span class="Li">&quot;\p{Upper}&quot;</span>. Also, there are typically
    various synonyms for the values the property can be. For binary properties,
    &quot;True&quot; has 3 synonyms: &quot;T&quot;, &quot;Yes&quot;, and
    &quot;Y&quot;; and &quot;False has correspondingly &quot;F&quot;,
    &quot;No&quot;, and &quot;N&quot;. But be careful. A short form of a value
    for one property may not mean the same thing as the same short form for
    another. Thus, for the General_Category property, &quot;L&quot; means
    &quot;Letter&quot;, but for the Bidi_Class property, &quot;L&quot; means
    &quot;Left&quot;. A complete list of properties and synonyms is in
    perluniprops.</p>
<p class="Pp">Upper/lower case differences in property names and values are
    irrelevant; thus <span class="Li">&quot;\p{Upper}&quot;</span> means the
    same thing as <span class="Li">&quot;\p{upper}&quot;</span> or even
    <span class="Li">&quot;\p{UpPeR}&quot;</span>. Similarly, you can add or
    subtract underscores anywhere in the middle of a word, so that these are
    also equivalent to <span class="Li">&quot;\p{U_p_p_e_r}&quot;</span>. And
    white space is irrelevant adjacent to non-word characters, such as the
    braces and the equals or colon separators, so <span class="Li">&quot;\p{
    Upper }&quot;</span> and <span class="Li">&quot;\p{ Upper_case : Y
    }&quot;</span> are equivalent to these as well. In fact, white space and
    even hyphens can usually be added or deleted anywhere. So even
    <span class="Li">&quot;\p{ Up-per case = Yes}&quot;</span> is equivalent.
    All this is called &quot;loose-matching&quot; by Unicode. The few places
    where stricter matching is used is in the middle of numbers, and in the Perl
    extension properties that begin or end with an underscore. Stricter matching
    cares about white space (except adjacent to non-word characters), hyphens,
    and non-interior underscores.</p>
<p class="Pp">You can also use negation in both
    <span class="Li">&quot;\p{}&quot;</span> and
    <span class="Li">&quot;\P{}&quot;</span> by introducing a caret (^) between
    the first brace and the property name:
    <span class="Li">&quot;\p{^Tamil}&quot;</span> is equal to
    <span class="Li">&quot;\P{Tamil}&quot;</span>.</p>
<p class="Pp">Almost all properties are immune to case-insensitive matching.
    That is, adding a <span class="Li">&quot;/i&quot;</span> regular expression
    modifier does not change what they match. There are two sets that are
    affected. The first set is
    <span class="Li">&quot;Uppercase_Letter&quot;</span>,
    <span class="Li">&quot;Lowercase_Letter&quot;</span>, and
    <span class="Li">&quot;Titlecase_Letter&quot;</span>, all of which match
    <span class="Li">&quot;Cased_Letter&quot;</span> under
    <span class="Li">&quot;/i&quot;</span> matching. And the second set is
    <span class="Li">&quot;Uppercase&quot;</span>,
    <span class="Li">&quot;Lowercase&quot;</span>, and
    <span class="Li">&quot;Titlecase&quot;</span>, all of which match
    <span class="Li">&quot;Cased&quot;</span> under
    <span class="Li">&quot;/i&quot;</span> matching. This set also includes its
    subsets <span class="Li">&quot;PosixUpper&quot;</span> and
    <span class="Li">&quot;PosixLower&quot;</span> both of which under
    <span class="Li">&quot;/i&quot;</span> matching match
    <span class="Li">&quot;PosixAlpha&quot;</span>. (The difference between
    these sets is that some things, such as Roman numerals, come in both upper
    and lower case so they are <span class="Li">&quot;Cased&quot;</span>, but
    aren't considered letters, so they aren't
    <span class="Li">&quot;Cased_Letter&quot;</span>s.)</p>
<p class="Pp">The result is undefined if you try to match a non-Unicode code
    point (that is, one above 0x10FFFF) against a Unicode property. Currently, a
    warning is raised, and the match will fail. In some cases, this is
    counterintuitive, as both these fail:</p>
<p class="Pp"></p>
<pre>
 chr(0x110000) =~ \p{ASCII_Hex_Digit=True}      # Fails.
 chr(0x110000) =~ \p{ASCII_Hex_Digit=False}     # Fails!
</pre>
<p class="Pp"><i></i><b><i>General_Category</i></b><i></i></p>
<p class="Pp">Every Unicode character is assigned a general category, which is
    the &quot;most usual categorization of a character&quot; (from
    &lt;http://www.unicode.org/reports/tr44&gt;).</p>
<p class="Pp">The compound way of writing these is like
    <span class="Li">&quot;\p{General_Category=Number}&quot;</span> (short,
    <span class="Li">&quot;\p{gc:n}&quot;</span>). But Perl furnishes shortcuts
    in which everything up through the equal or colon separator is omitted. So
    you can instead just write <span class="Li">&quot;\pN&quot;</span>.</p>
<p class="Pp">Here are the short and long forms of the General Category
    properties:</p>
<p class="Pp"></p>
<pre>
    Short       Long

    L           Letter
    LC, L&amp;      Cased_Letter (that is: [\p{Ll}\p{Lu}\p{Lt}])
    Lu          Uppercase_Letter
    Ll          Lowercase_Letter
    Lt          Titlecase_Letter
    Lm          Modifier_Letter
    Lo          Other_Letter

    M           Mark
    Mn          Nonspacing_Mark
    Mc          Spacing_Mark
    Me          Enclosing_Mark

    N           Number
    Nd          Decimal_Number (also Digit)
    Nl          Letter_Number
    No          Other_Number

    P           Punctuation (also Punct)
    Pc          Connector_Punctuation
    Pd          Dash_Punctuation
    Ps          Open_Punctuation
    Pe          Close_Punctuation
    Pi          Initial_Punctuation
                (may behave like Ps or Pe depending on usage)
    Pf          Final_Punctuation
                (may behave like Ps or Pe depending on usage)
    Po          Other_Punctuation

    S           Symbol
    Sm          Math_Symbol
    Sc          Currency_Symbol
    Sk          Modifier_Symbol
    So          Other_Symbol

    Z           Separator
    Zs          Space_Separator
    Zl          Line_Separator
    Zp          Paragraph_Separator

    C           Other
    Cc          Control (also Cntrl)
    Cf          Format
    Cs          Surrogate
    Co          Private_Use
    Cn          Unassigned
</pre>
<p class="Pp">Single-letter properties match all characters in any of the
    two-letter sub-properties starting with the same letter.
    <span class="Li">&quot;LC&quot;</span> and
    <span class="Li">&quot;L&amp;&quot;</span> are special: both are aliases for
    the set consisting of everything matched by
    <span class="Li">&quot;Ll&quot;</span>,
    <span class="Li">&quot;Lu&quot;</span>, and
    <span class="Li">&quot;Lt&quot;</span>.</p>
<p class="Pp"><i></i><b><i>Bidirectional Character Types</i></b><i></i></p>
<p class="Pp">Because scripts differ in their directionality (Hebrew and Arabic
    are written right to left, for example) Unicode supplies these properties in
    the Bidi_Class class:</p>
<p class="Pp"></p>
<pre>
    Property    Meaning

    L           Left-to-Right
    LRE         Left-to-Right Embedding
    LRO         Left-to-Right Override
    R           Right-to-Left
    AL          Arabic Letter
    RLE         Right-to-Left Embedding
    RLO         Right-to-Left Override
    PDF         Pop Directional Format
    EN          European Number
    ES          European Separator
    ET          European Terminator
    AN          Arabic Number
    CS          Common Separator
    NSM         Non-Spacing Mark
    BN          Boundary Neutral
    B           Paragraph Separator
    S           Segment Separator
    WS          Whitespace
    ON          Other Neutrals
</pre>
<p class="Pp">This property is always written in the compound form. For example,
    <span class="Li">&quot;\p{Bidi_Class:R}&quot;</span> matches characters that
    are normally written right to left.</p>
<p class="Pp"><i></i><b><i>Scripts</i></b><i></i></p>
<p class="Pp">The world's languages are written in many different scripts. This
    sentence (unless you're reading it in translation) is written in Latin,
    while Russian is written in Cyrillic, and Greek is written in, well, Greek;
    Japanese mainly in Hiragana or Katakana. There are many more.</p>
<p class="Pp">The Unicode Script and Script_Extensions properties give what
    script a given character is in. Either property can be specified with the
    compound form like <span class="Li">&quot;\p{Script=Hebrew}&quot;</span>
    (short: <span class="Li">&quot;\p{sc=hebr}&quot;</span>), or
    <span class="Li">&quot;\p{Script_Extensions=Javanese}&quot;</span> (short:
    <span class="Li">&quot;\p{scx=java}&quot;</span>). In addition, Perl
    furnishes shortcuts for all <span class="Li">&quot;Script&quot;</span>
    property names. You can omit everything up through the equals (or colon),
    and simply write <span class="Li">&quot;\p{Latin}&quot;</span> or
    <span class="Li">&quot;\P{Cyrillic}&quot;</span>. (This is not true for
    <span class="Li">&quot;Script_Extensions&quot;</span>, which is required to
    be written in the compound form.)</p>
<p class="Pp">The difference between these two properties involves characters
    that are used in multiple scripts. For example the digits '0' through '9'
    are used in many parts of the world. These are placed in a script named
    <span class="Li">&quot;Common&quot;</span>. Other characters are used in
    just a few scripts. For example, the &quot;KATAKANA-HIRAGANA DOUBLE
    HYPHEN&quot; is used in both Japanese scripts, Katakana and Hiragana, but
    nowhere else. The <span class="Li">&quot;Script&quot;</span> property places
    all characters that are used in multiple scripts in the
    <span class="Li">&quot;Common&quot;</span> script, while the
    <span class="Li">&quot;Script_Extensions&quot;</span> property places those
    that are used in only a few scripts into each of those scripts; while still
    using <span class="Li">&quot;Common&quot;</span> for those used in many
    scripts. Thus both these match:</p>
<p class="Pp"></p>
<pre>
 &quot;0&quot; =~ /\p{sc=Common}/     # Matches
 &quot;0&quot; =~ /\p{scx=Common}/    # Matches
</pre>
<p class="Pp">and only the first of these match:</p>
<p class="Pp"></p>
<pre>
 &quot;\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}&quot; =~ /\p{sc=Common}  # Matches
 &quot;\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}&quot; =~ /\p{scx=Common} # No match
</pre>
<p class="Pp">And only the last two of these match:</p>
<p class="Pp"></p>
<pre>
 &quot;\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}&quot; =~ /\p{sc=Hiragana}  # No match
 &quot;\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}&quot; =~ /\p{sc=Katakana}  # No match
 &quot;\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}&quot; =~ /\p{scx=Hiragana} # Matches
 &quot;\N{KATAKANA-HIRAGANA DOUBLE HYPHEN}&quot; =~ /\p{scx=Katakana} # Matches
</pre>
<p class="Pp"><span class="Li">&quot;Script_Extensions&quot;</span> is thus an
    improved <span class="Li">&quot;Script&quot;</span>, in which there are
    fewer characters in the <span class="Li">&quot;Common&quot;</span> script,
    and correspondingly more in other scripts. It is new in Unicode version 6.0,
    and its data are likely to change significantly in later releases, as things
    get sorted out.</p>
<p class="Pp">(Actually, besides <span class="Li">&quot;Common&quot;</span>, the
    <span class="Li">&quot;Inherited&quot;</span> script, contains characters
    that are used in multiple scripts. These are modifier characters which
    modify other characters, and inherit the script value of the controlling
    character. Some of these are used in many scripts, and so go into
    <span class="Li">&quot;Inherited&quot;</span> in both
    <span class="Li">&quot;Script&quot;</span> and
    <span class="Li">&quot;Script_Extensions&quot;</span>. Others are used in
    just a few scripts, so are in <span class="Li">&quot;Inherited&quot;</span>
    in <span class="Li">&quot;Script&quot;</span>, but not in
    <span class="Li">&quot;Script_Extensions&quot;</span>.)</p>
<p class="Pp">It is worth stressing that there are several different sets of
    digits in Unicode that are equivalent to 0-9 and are matchable by
    <span class="Li">&quot;\d&quot;</span> in a regular expression. If they are
    used in a single language only, they are in that language's
    <span class="Li">&quot;Script&quot;</span> and
    <span class="Li">&quot;Script_Extension&quot;</span>. If they are used in
    more than one script, they will be in
    <span class="Li">&quot;sc=Common&quot;</span>, but only if they are used in
    many scripts should they be in
    <span class="Li">&quot;scx=Common&quot;</span>.</p>
<p class="Pp">A complete list of scripts and their shortcuts is in
  perluniprops.</p>
<p class="Pp"><i></i><b><i>Use of &quot;Is&quot; Prefix</i></b><i></i></p>
<p class="Pp">For backward compatibility (with Perl 5.6), all properties
    mentioned so far may have <span class="Li">&quot;Is&quot;</span> or
    <span class="Li">&quot;Is_&quot;</span> prepended to their name, so
    <span class="Li">&quot;\P{Is_Lu}&quot;</span>, for example, is equal to
    <span class="Li">&quot;\P{Lu}&quot;</span>, and
    <span class="Li">&quot;\p{IsScript:Arabic}&quot;</span> is equal to
    <span class="Li">&quot;\p{Arabic}&quot;</span>.</p>
<p class="Pp"><i></i><b><i>Blocks</i></b><i></i></p>
<p class="Pp">In addition to <b>scripts</b>, Unicode also defines <b>blocks</b>
    of characters. The difference between scripts and blocks is that the concept
    of scripts is closer to natural languages, while the concept of blocks is
    more of an artificial grouping based on groups of Unicode characters with
    consecutive ordinal values. For example, the &quot;Basic Latin&quot; block
    is all characters whose ordinals are between 0 and 127, inclusive; in other
    words, the ASCII characters. The &quot;Latin&quot; script contains some
    letters from this as well as several other blocks, like &quot;Latin-1
    Supplement&quot;, &quot;Latin Extended-A&quot;, etc., but it does not
    contain all the characters from those blocks. It does not, for example,
    contain the digits 0-9, because those digits are shared across many scripts,
    and hence are in the <span class="Li">&quot;Common&quot;</span> script.</p>
<p class="Pp">For more about scripts versus blocks, see UAX#24 &quot;Unicode
    Script Property&quot;: &lt;http://www.unicode.org/reports/tr24&gt;</p>
<p class="Pp">The <span class="Li">&quot;Script&quot;</span> or
    <span class="Li">&quot;Script_Extensions&quot;</span> properties are likely
    to be the ones you want to use when processing natural language; the Block
    property may occasionally be useful in working with the nuts and bolts of
    Unicode.</p>
<p class="Pp">Block names are matched in the compound form, like
    <span class="Li">&quot;\p{Block: Arrows}&quot;</span> or
    <span class="Li">&quot;\p{Blk=Hebrew}&quot;</span>. Unlike most other
    properties, only a few block names have a Unicode-defined short name. But
    Perl does provide a (slight) shortcut: You can say, for example
    <span class="Li">&quot;\p{In_Arrows}&quot;</span> or
    <span class="Li">&quot;\p{In_Hebrew}&quot;</span>. For backwards
    compatibility, the <span class="Li">&quot;In&quot;</span> prefix may be
    omitted if there is no naming conflict with a script or any other property,
    and you can even use an <span class="Li">&quot;Is&quot;</span> prefix
    instead in those cases. But it is not a good idea to do this, for a couple
    reasons:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>It is confusing. There are many naming conflicts, and you may forget some.
      For example, <span class="Li">&quot;\p{Hebrew}&quot;</span> means the
      <i>script</i> Hebrew, and NOT the <i>block</i> Hebrew. But would you
      remember that 6 months from now?</dd>
  <dt>2.</dt>
  <dd>It is unstable. A new version of Unicode may pre-empt the current meaning
      by creating a property with the same name. There was a time in very early
      Unicode releases when <span class="Li">&quot;\p{Hebrew}&quot;</span> would
      have matched the <i>block</i> Hebrew; now it doesn't.</dd>
</dl>
<p class="Pp">Some people prefer to always use <span class="Li">&quot;\p{Block:
    foo}&quot;</span> and <span class="Li">&quot;\p{Script: bar}&quot;</span>
    instead of the shortcuts, whether for clarity, because they can't remember
    the difference between 'In' and 'Is' anyway, or they aren't confident that
    those who eventually will read their code will know that difference.</p>
<p class="Pp">A complete list of blocks and their shortcuts is in
  perluniprops.</p>
<p class="Pp"><i></i><b><i>Other Properties</i></b><i></i></p>
<p class="Pp">There are many more properties than the very basic ones described
    here. A complete list is in perluniprops.</p>
<p class="Pp">Unicode defines all its properties in the compound form, so all
    single-form properties are Perl extensions. Most of these are just synonyms
    for the Unicode ones, but some are genuine extensions, including several
    that are in the compound form. And quite a few of these are actually
    recommended by Unicode (in &lt;http://www.unicode.org/reports/tr18&gt;).</p>
<p class="Pp">This section gives some details on all extensions that aren't just
    synonyms for compound-form Unicode properties (for those properties, you'll
    have to refer to the Unicode Standard
    &lt;http://www.unicode.org/reports/tr44&gt;.</p>
<dl class="Bl-tag">
  <dt><b></b><b>&quot;\p{All}&quot;</b><b></b></dt>
  <dd>This matches any of the 1_114_112 Unicode code points. It is a synonym for
      <span class="Li">&quot;\p{Any}&quot;</span>.</dd>
  <dt><b></b><b>&quot;\p{Alnum}&quot;</b><b></b></dt>
  <dd>This matches any <span class="Li">&quot;\p{Alphabetic}&quot;</span> or
      <span class="Li">&quot;\p{Decimal_Number}&quot;</span> character.</dd>
  <dt><b></b><b>&quot;\p{Any}&quot;</b><b></b></dt>
  <dd>This matches any of the 1_114_112 Unicode code points. It is a synonym for
      <span class="Li">&quot;\p{All}&quot;</span>.</dd>
  <dt><b></b><b>&quot;\p{ASCII}&quot;</b><b></b></dt>
  <dd>This matches any of the 128 characters in the US-ASCII character set,
      which is a subset of Unicode.</dd>
  <dt><b></b><b>&quot;\p{Assigned}&quot;</b><b></b></dt>
  <dd>This matches any assigned code point; that is, any code point whose
      general category is not Unassigned (or equivalently, not Cn).</dd>
  <dt><b></b><b>&quot;\p{Blank}&quot;</b><b></b></dt>
  <dd>This is the same as <span class="Li">&quot;\h&quot;</span> and
      <span class="Li">&quot;\p{HorizSpace}&quot;</span>: A character that
      changes the spacing horizontally.</dd>
  <dt><b></b><b>&quot;\p{Decomposition_Type: Non_Canonical}&quot;</b><b></b>
    (Short: &quot;\p{Dt=NonCanon}&quot;)</dt>
  <dd>Matches a character that has a non-canonical decomposition.
    <p class="Pp">To understand the use of this rarely used property=value
        combination, it is necessary to know some basics about decomposition.
        Consider a character, say H. It could appear with various marks around
        it, such as an acute accent, or a circumflex, or various hooks, circles,
        arrows, <i>etc.</i>, above, below, to one side or the other, etc. There
        are many possibilities among the world's languages. The number of
        combinations is astronomical, and if there were a character for each
        combination, it would soon exhaust Unicode's more than a million
        possible characters. So Unicode took a different approach: there is a
        character for the base H, and a character for each of the possible
        marks, and these can be variously combined to get a final logical
        character. So a logical character--what appears to be a single
        character--can be a sequence of more than one individual characters.
        This is called an &quot;extended grapheme cluster&quot;; Perl furnishes
        the <span class="Li">&quot;\X&quot;</span> regular expression construct
        to match such sequences.</p>
    <p class="Pp">But Unicode's intent is to unify the existing character set
        standards and practices, and several pre-existing standards have single
        characters that mean the same thing as some of these combinations. An
        example is ISO-8859-1, which has quite a few of these in the Latin-1
        range, an example being &quot;LATIN CAPITAL LETTER E WITH ACUTE&quot;.
        Because this character was in this pre-existing standard, Unicode added
        it to its repertoire. But this character is considered by Unicode to be
        equivalent to the sequence consisting of the character &quot;LATIN
        CAPITAL LETTER E&quot; followed by the character &quot;COMBINING ACUTE
        ACCENT&quot;.</p>
    <p class="Pp">&quot;LATIN CAPITAL LETTER E WITH ACUTE&quot; is called a
        &quot;pre-composed&quot; character, and its equivalence with the
        sequence is called canonical equivalence. All pre-composed characters
        are said to have a decomposition (into the equivalent sequence), and the
        decomposition type is also called canonical.</p>
    <p class="Pp">However, many more characters have a different type of
        decomposition, a &quot;compatible&quot; or &quot;non-canonical&quot;
        decomposition. The sequences that form these decompositions are not
        considered canonically equivalent to the pre-composed character. An
        example, again in the Latin-1 range, is the &quot;SUPERSCRIPT ONE&quot;.
        It is somewhat like a regular digit 1, but not exactly; its
        decomposition into the digit 1 is called a &quot;compatible&quot;
        decomposition, specifically a &quot;super&quot; decomposition. There are
        several such compatibility decompositions (see
        &lt;http://www.unicode.org/reports/tr44&gt;), including one called
        &quot;compat&quot;, which means some miscellaneous type of decomposition
        that doesn't fit into the decomposition categories that Unicode has
        chosen.</p>
    <p class="Pp">Note that most Unicode characters don't have a decomposition,
        so their decomposition type is &quot;None&quot;.</p>
    <p class="Pp">For your convenience, Perl has added the
        <span class="Li">&quot;Non_Canonical&quot;</span> decomposition type to
        mean any of the several compatibility decompositions.</p>
  </dd>
  <dt><b></b><b>&quot;\p{Graph}&quot;</b><b></b></dt>
  <dd>Matches any character that is graphic. Theoretically, this means a
      character that on a printer would cause ink to be used.</dd>
  <dt><b></b><b>&quot;\p{HorizSpace}&quot;</b><b></b></dt>
  <dd>This is the same as <span class="Li">&quot;\h&quot;</span> and
      <span class="Li">&quot;\p{Blank}&quot;</span>: a character that changes
      the spacing horizontally.</dd>
  <dt><b></b><b>&quot;\p{In=*}&quot;</b><b></b></dt>
  <dd>This is a synonym for
    <span class="Li">&quot;\p{Present_In=*}&quot;</span></dd>
  <dt><b></b><b>&quot;\p{PerlSpace}&quot;</b><b></b></dt>
  <dd>This is the same as <span class="Li">&quot;\s&quot;</span>, restricted to
      ASCII, namely <span class="Li">&quot;[&#x00A0;\f\n\r\t]&quot;</span> and
      starting in Perl v5.18, experimentally, a vertical tab.
    <p class="Pp">Mnemonic: Perl's (original) space</p>
  </dd>
  <dt><b></b><b>&quot;\p{PerlWord}&quot;</b><b></b></dt>
  <dd>This is the same as <span class="Li">&quot;\w&quot;</span>, restricted to
      ASCII, namely <span class="Li">&quot;[A-Za-z0-9_]&quot;</span>
    <p class="Pp">Mnemonic: Perl's (original) word.</p>
  </dd>
  <dt><b></b><b>&quot;\p{Posix...}&quot;</b><b></b></dt>
  <dd>There are several of these, which are equivalents using the
      <span class="Li">&quot;\p&quot;</span> notation for Posix classes and are
      described in &quot;POSIX Character Classes&quot; in perlrecharclass.</dd>
  <dt><b></b><b>&quot;\p{Present_In: *}&quot;</b><b></b> (Short:
    &quot;\p{In=*}&quot;)</dt>
  <dd>This property is used when you need to know in what Unicode version(s) a
      character is.
    <p class="Pp">The &quot;*&quot; above stands for some two digit Unicode
        version number, such as <span class="Li">1.1</span> or
        <span class="Li">4.0</span>; or the &quot;*&quot; can also be
        <span class="Li">&quot;Unassigned&quot;</span>. This property will match
        the code points whose final disposition has been settled as of the
        Unicode release given by the version number;
        <span class="Li">&quot;\p{Present_In: Unassigned}&quot;</span> will
        match those code points whose meaning has yet to be assigned.</p>
    <p class="Pp">For example, <span class="Li">&quot;U+0041&quot;</span>
        &quot;LATIN CAPITAL LETTER A&quot; was present in the very first Unicode
        release available, which is <span class="Li">1.1</span>, so this
        property is true for all valid &quot;*&quot; versions. On the other
        hand, <span class="Li">&quot;U+1EFF&quot;</span> was not assigned until
        version 5.1 when it became &quot;LATIN SMALL LETTER Y WITH LOOP&quot;,
        so the only &quot;*&quot; that would match it are 5.1, 5.2, and
      later.</p>
    <p class="Pp">Unicode furnishes the <span class="Li">&quot;Age&quot;</span>
        property from which this is derived. The problem with Age is that a
        strict interpretation of it (which Perl takes) has it matching the
        precise release a code point's meaning is introduced in. Thus
        <span class="Li">&quot;U+0041&quot;</span> would match only 1.1; and
        <span class="Li">&quot;U+1EFF&quot;</span> only 5.1. This is not usually
        what you want.</p>
    <p class="Pp">Some non-Perl implementations of the Age property may change
        its meaning to be the same as the Perl Present_In property; just be
        aware of that.</p>
    <p class="Pp">Another confusion with both these properties is that the
        definition is not that the code point has been <i>assigned</i>, but that
        the meaning of the code point has been <i>determined</i>. This is
        because 66 code points will always be unassigned, and so the Age for
        them is the Unicode version in which the decision to make them so was
        made. For example, <span class="Li">&quot;U+FDD0&quot;</span> is to be
        permanently unassigned to a character, and the decision to do that was
        made in version 3.1, so <span class="Li">&quot;\p{Age=3.1}&quot;</span>
        matches this character, as also does
        <span class="Li">&quot;\p{Present_In: 3.1}&quot;</span> and up.</p>
  </dd>
  <dt><b></b><b>&quot;\p{Print}&quot;</b><b></b></dt>
  <dd>This matches any character that is graphical or blank, except
    controls.</dd>
  <dt><b></b><b>&quot;\p{SpacePerl}&quot;</b><b></b></dt>
  <dd>This is the same as <span class="Li">&quot;\s&quot;</span>, including
      beyond ASCII.
    <p class="Pp">Mnemonic: Space, as modified by Perl. (It doesn't include the
        vertical tab which both the Posix standard and Unicode consider white
        space.)</p>
  </dd>
  <dt><b></b><b>&quot;\p{Title}&quot;</b><b></b> and
    <b></b><b>&quot;\p{Titlecase}&quot;</b><b></b></dt>
  <dd>Under case-sensitive matching, these both match the same code points as
      <span class="Li">&quot;\p{General Category=Titlecase_Letter}&quot;</span>
      (<span class="Li">&quot;\p{gc=lt}&quot;</span>). The difference is that
      under <span class="Li">&quot;/i&quot;</span> caseless matching, these
      match the same as <span class="Li">&quot;\p{Cased}&quot;</span>, whereas
      <span class="Li">&quot;\p{gc=lt}&quot;</span> matches
      <span class="Li">&quot;\p{Cased_Letter&quot;</span>).</dd>
  <dt><b></b><b>&quot;\p{VertSpace}&quot;</b><b></b></dt>
  <dd>This is the same as <span class="Li">&quot;\v&quot;</span>: A character
      that changes the spacing vertically.</dd>
  <dt><b></b><b>&quot;\p{Word}&quot;</b><b></b></dt>
  <dd>This is the same as <span class="Li">&quot;\w&quot;</span>, including over
      100_000 characters beyond ASCII.</dd>
  <dt><b></b><b>&quot;\p{XPosix...}&quot;</b><b></b></dt>
  <dd>There are several of these, which are the standard Posix classes extended
      to the full Unicode range. They are described in &quot;POSIX Character
      Classes&quot; in perlrecharclass.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="User-Defined_Character_Properties"><a class="permalink" href="#User-Defined_Character_Properties">User-Defined
  Character Properties</a></h2>
<p class="Pp">You can define your own binary character properties by defining
    subroutines whose names begin with &quot;In&quot; or &quot;Is&quot;. (The
    experimental feature &quot;(?[ ])&quot; in perlre provides an alternative
    which allows more complex definitions.) The subroutines can be defined in
    any package. The user-defined properties can be used in the regular
    expression <span class="Li">&quot;\p&quot;</span> and
    <span class="Li">&quot;\P&quot;</span> constructs; if you are using a
    user-defined property from a package other than the one you are in, you must
    specify its package in the <span class="Li">&quot;\p&quot;</span> or
    <span class="Li">&quot;\P&quot;</span> construct.</p>
<p class="Pp"></p>
<pre>
    # assuming property Is_Foreign defined in Lang::
    package main;  # property package name required
    if ($txt =~ /\p{Lang::IsForeign}+/) { ... }

    package Lang;  # property package name not required
    if ($txt =~ /\p{IsForeign}+/) { ... }
</pre>
<p class="Pp">Note that the effect is compile-time and immutable once defined.
    However, the subroutines are passed a single parameter, which is 0 if
    case-sensitive matching is in effect and non-zero if caseless matching is in
    effect. The subroutine may return different values depending on the value of
    the flag, and one set of values will immutably be in effect for all
    case-sensitive matches, and the other set for all case-insensitive
  matches.</p>
<p class="Pp">Note that if the regular expression is tainted, then Perl will die
    rather than calling the subroutine, where the name of the subroutine is
    determined by the tainted data.</p>
<p class="Pp">The subroutines must return a specially-formatted string, with one
    or more newline-separated lines. Each line must be one of the following:</p>
<ul class="Bl-bullet">
  <li>A single hexadecimal number denoting a Unicode code point to include.</li>
  <li>Two hexadecimal numbers separated by horizontal whitespace (space or
      tabular characters) denoting a range of Unicode code points to
    include.</li>
  <li>Something to include, prefixed by &quot;+&quot;: a built-in character
      property (prefixed by &quot;utf8::&quot;) or a fully qualified (including
      package name) user-defined character property, to represent all the
      characters in that property; two hexadecimal code points for a range; or a
      single hexadecimal code point.</li>
  <li>Something to exclude, prefixed by &quot;-&quot;: an existing character
      property (prefixed by &quot;utf8::&quot;) or a fully qualified (including
      package name) user-defined character property, to represent all the
      characters in that property; two hexadecimal code points for a range; or a
      single hexadecimal code point.</li>
  <li>Something to negate, prefixed &quot;!&quot;: an existing character
      property (prefixed by &quot;utf8::&quot;) or a fully qualified (including
      package name) user-defined character property, to represent all the
      characters in that property; two hexadecimal code points for a range; or a
      single hexadecimal code point.</li>
  <li>Something to intersect with, prefixed by &quot;&amp;&quot;: an existing
      character property (prefixed by &quot;utf8::&quot;) or a fully qualified
      (including package name) user-defined character property, for all the
      characters except the characters in the property; two hexadecimal code
      points for a range; or a single hexadecimal code point.</li>
</ul>
<p class="Pp">For example, to define a property that covers both the Japanese
    syllabaries (hiragana and katakana), you can define</p>
<p class="Pp"></p>
<pre>
    sub InKana {
        return &lt;&lt;END;
    3040\t309F
    30A0\t30FF
    END
    }
</pre>
<p class="Pp">Imagine that the here-doc end marker is at the beginning of the
    line. Now you can use <span class="Li">&quot;\p{InKana}&quot;</span> and
    <span class="Li">&quot;\P{InKana}&quot;</span>.</p>
<p class="Pp">You could also have used the existing block property names:</p>
<p class="Pp"></p>
<pre>
    sub InKana {
        return &lt;&lt;'END';
    +utf8::InHiragana
    +utf8::InKatakana
    END
    }
</pre>
<p class="Pp">Suppose you wanted to match only the allocated characters, not the
    raw block ranges: in other words, you want to remove the non-characters:</p>
<p class="Pp"></p>
<pre>
    sub InKana {
        return &lt;&lt;'END';
    +utf8::InHiragana
    +utf8::InKatakana
    -utf8::IsCn
    END
    }
</pre>
<p class="Pp">The negation is useful for defining (surprise!) negated
  classes.</p>
<p class="Pp"></p>
<pre>
    sub InNotKana {
        return &lt;&lt;'END';
    !utf8::InHiragana
    -utf8::InKatakana
    +utf8::IsCn
    END
    }
</pre>
<p class="Pp">This will match all non-Unicode code points, since every one of
    them is not in Kana. You can use intersection to exclude these, if desired,
    as this modified example shows:</p>
<p class="Pp"></p>
<pre>
    sub InNotKana {
        return &lt;&lt;'END';
    !utf8::InHiragana
    -utf8::InKatakana
    +utf8::IsCn
    &amp;utf8::Any
    END
    }
</pre>
<p class="Pp"><span class="Li">&amp;utf8::Any</span> must be the last line in
    the definition.</p>
<p class="Pp">Intersection is used generally for getting the common characters
    matched by two (or more) classes. It's important to remember not to use
    &quot;&amp;&quot; for the first set; that would be intersecting with
    nothing, resulting in an empty set.</p>
<p class="Pp">(Note that official Unicode properties differ from these in that
    they automatically exclude non-Unicode code points and a warning is raised
    if a match is attempted on one of those.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="User-Defined_Case_Mappings_(for_serious_hackers_only)"><a class="permalink" href="#User-Defined_Case_Mappings_(for_serious_hackers_only)">User-Defined
  Case Mappings (for serious hackers only)</a></h2>
<p class="Pp"><b>This feature has been removed as of Perl 5.16.</b> The CPAN
    module Unicode::Casing provides better functionality without the drawbacks
    that this feature had. If you are using a Perl earlier than 5.16, this
    feature was most fully documented in the 5.14 version of this pod:
    &lt;http://perldoc.perl.org/5.14.0/perlunicode.html#User-Defined-Case-Mappings-%28for-serious-hackers-only%29&gt;</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Character_Encodings_for_Input_and_Output"><a class="permalink" href="#Character_Encodings_for_Input_and_Output">Character
  Encodings for Input and Output</a></h2>
<p class="Pp">See Encode.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Unicode_Regular_Expression_Support_Level"><a class="permalink" href="#Unicode_Regular_Expression_Support_Level">Unicode
  Regular Expression Support Level</a></h2>
<p class="Pp">The following list of Unicode supported features for regular
    expressions describes all features currently directly supported by core
    Perl. The references to &quot;Level N&quot; and the section numbers refer to
    the Unicode Technical Standard #18, &quot;Unicode Regular Expressions&quot;,
    version 13, from August 2008.</p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>Level 1 - Basic Unicode Support
    <p class="Pp"></p>
    <pre>
 RL1.1   Hex Notation                     - done          [1]
 RL1.2   Properties                       - done          [2][3]
 RL1.2a  Compatibility Properties         - done          [4]
 RL1.3   Subtraction and Intersection     - experimental  [5]
 RL1.4   Simple Word Boundaries           - done          [6]
 RL1.5   Simple Loose Matches             - done          [7]
 RL1.6   Line Boundaries                  - MISSING       [8][9]
 RL1.7   Supplementary Code Points        - done          [10]
    </pre>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>[1]</dt>
  <dd>\x{...}</dd>
  <dt>[2]</dt>
  <dd>\p{...} \P{...}</dd>
  <dt>[3]</dt>
  <dd>supports not only minimal list, but all Unicode character properties (see
      Unicode Character Properties above)</dd>
  <dt>[4]</dt>
  <dd>\d \D \s \S \w \W \X [:prop:] [:^prop:]</dd>
  <dt>[5]</dt>
  <dd>The experimental feature in v5.18 &quot;(?[...])&quot; accomplishes this.
      See &quot;(?[ ])&quot; in perlre. If you don't want to use an experimental
      feature, you can use one of the following:</dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>Regular expression look-ahead
    <p class="Pp">You can mimic class subtraction using lookahead. For example,
        what UTS#18 might write as</p>
    <p class="Pp"></p>
    <pre>
    [{Block=Greek}-[{UNASSIGNED}]]
    </pre>
    <p class="Pp">in Perl can be written as:</p>
    <p class="Pp"></p>
    <pre>
    (?!\p{Unassigned})\p{Block=Greek}
    (?=\p{Assigned})\p{Block=Greek}
    </pre>
    <p class="Pp">But in this particular example, you probably really want</p>
    <p class="Pp"></p>
    <pre>
    \p{Greek}
    </pre>
    <p class="Pp">which will match assigned characters known to be part of the
        Greek script.</p>
  </li>
  <li>CPAN module Unicode::Regex::Set
    <p class="Pp">It does implement the full UTS#18 grouping, intersection,
        union, and removal (subtraction) syntax.</p>
  </li>
  <li>&quot;User-Defined Character Properties&quot;
    <p class="Pp">'+' for union, '-' for removal (set-difference), '&amp;' for
        intersection</p>
  </li>
</ul>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>[6]</dt>
  <dd>\b \B</dd>
  <dt>[7]</dt>
  <dd>Note that Perl does Full case-folding in matching (but with bugs), not
      Simple: for example U+1F88 is equivalent to U+1F00 U+03B9, instead of just
      U+1F80. This difference matters mainly for certain Greek capital letters
      with certain modifiers: the Full case-folding decomposes the letter, while
      the Simple case-folding would map it to a single character.</dd>
  <dt>[8]</dt>
  <dd>Should do ^ and $ also on U+000B (\v in C), FF (\f), CR (\r), CRLF (\r\n),
      NEL (U+0085), LS (U+2028), and PS (U+2029); should also affect &lt;&gt;,
      $., and script line numbers; should not split lines within CRLF (i.e.
      there is no empty line between \r and \n). For CRLF, try the
      <span class="Li">&quot;:crlf&quot;</span> layer (see PerlIO).</dd>
  <dt>[9]</dt>
  <dd>Linebreaking conformant with UAX#14 &quot;Unicode Line Breaking
      Algorithm&quot; is available through the Unicode::LineBreaking
    module.</dd>
  <dt>[10]</dt>
  <dd>UTF-8/UTF-EBDDIC used in Perl allows not only U+10000 to U+10FFFF but also
      beyond U+10FFFF</dd>
</dl>
</div>
<div class="Bd-indent"></div>
<ul class="Bl-bullet">
  <li>Level 2 - Extended Unicode Support
    <p class="Pp"></p>
    <pre>
 RL2.1   Canonical Equivalents           - MISSING       [10][11]
 RL2.2   Default Grapheme Clusters       - MISSING       [12]
 RL2.3   Default Word Boundaries         - MISSING       [14]
 RL2.4   Default Loose Matches           - MISSING       [15]
 RL2.5   Name Properties                 - DONE
 RL2.6   Wildcard Properties             - MISSING

 [10] see UAX#15 &quot;Unicode Normalization Forms&quot;
 [11] have Unicode::Normalize but not integrated to regexes
 [12] have \X but we don't have a &quot;Grapheme Cluster Mode&quot;
 [14] see UAX#29, Word Boundaries
 [15] This is covered in Chapter 3.13 (in Unicode 6.0)
    </pre>
  </li>
  <li>Level 3 - Tailored Support
    <p class="Pp"></p>
    <pre>
 RL3.1   Tailored Punctuation            - MISSING
 RL3.2   Tailored Grapheme Clusters      - MISSING       [17][18]
 RL3.3   Tailored Word Boundaries        - MISSING
 RL3.4   Tailored Loose Matches          - MISSING
 RL3.5   Tailored Ranges                 - MISSING
 RL3.6   Context Matching                - MISSING       [19]
 RL3.7   Incremental Matches             - MISSING
      ( RL3.8   Unicode Set Sharing )
 RL3.9   Possible Match Sets             - MISSING
 RL3.10  Folded Matching                 - MISSING       [20]
 RL3.11  Submatchers                     - MISSING

 [17] see UAX#10 &quot;Unicode Collation Algorithms&quot;
 [18] have Unicode::Collate but not integrated to regexes
 [19] have (?&lt;=x) and (?=x), but look-aheads or look-behinds
      should see outside of the target substring
 [20] need insensitive matching for linguistic features other
      than case; for example, hiragana to katakana, wide and
      narrow, simplified Han to traditional Han (see UTR#30
      &quot;Character Foldings&quot;)
    </pre>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Unicode_Encodings"><a class="permalink" href="#Unicode_Encodings">Unicode
  Encodings</a></h2>
<p class="Pp">Unicode characters are assigned to <i>code points</i>, which are
    abstract numbers. To use these numbers, various encodings are needed.</p>
<ul class="Bl-bullet">
  <li>UTF-8
    <p class="Pp">UTF-8 is a variable-length (1 to 4 bytes), byte-order
        independent encoding. For ASCII (and we really do mean 7-bit ASCII, not
        another 8-bit encoding), UTF-8 is transparent.</p>
    <p class="Pp">The following table is from Unicode 3.2.</p>
    <p class="Pp"></p>
    <pre>
 Code Points            1st Byte  2nd Byte  3rd Byte 4th Byte

   U+0000..U+007F       00..7F
   U+0080..U+07FF     * C2..DF    80..BF
   U+0800..U+0FFF       E0      * A0..BF    80..BF
   U+1000..U+CFFF       E1..EC    80..BF    80..BF
   U+D000..U+D7FF       ED        80..9F    80..BF
   U+D800..U+DFFF       +++++ utf16 surrogates, not legal utf8 +++++
   U+E000..U+FFFF       EE..EF    80..BF    80..BF
  U+10000..U+3FFFF      F0      * 90..BF    80..BF    80..BF
  U+40000..U+FFFFF      F1..F3    80..BF    80..BF    80..BF
 U+100000..U+10FFFF     F4        80..8F    80..BF    80..BF
    </pre>
    <p class="Pp">Note the gaps marked by &quot;*&quot; before several of the
        byte entries above. These are caused by legal UTF-8 avoiding
        non-shortest encodings: it is technically possible to UTF-8-encode a
        single code point in different ways, but that is explicitly forbidden,
        and the shortest possible encoding should always be used (and that is
        what Perl does).</p>
    <p class="Pp">Another way to look at it is via bits:</p>
    <p class="Pp"></p>
    <pre>
                Code Points  1st Byte  2nd Byte  3rd Byte  4th Byte

                   0aaaaaaa  0aaaaaaa
           00000bbbbbaaaaaa  110bbbbb  10aaaaaa
           ccccbbbbbbaaaaaa  1110cccc  10bbbbbb  10aaaaaa
 00000dddccccccbbbbbbaaaaaa  11110ddd  10cccccc  10bbbbbb  10aaaaaa
    </pre>
    <p class="Pp">As you can see, the continuation bytes all begin with
        &quot;10&quot;, and the leading bits of the start byte tell how many
        bytes there are in the encoded character.</p>
    <p class="Pp">The original UTF-8 specification allowed up to 6 bytes, to
        allow encoding of numbers up to 0x7FFF_FFFF. Perl continues to allow
        those, and has extended that up to 13 bytes to encode code points up to
        what can fit in a 64-bit word. However, Perl will warn if you output any
        of these as being non-portable; and under strict UTF-8 input protocols,
        they are forbidden.</p>
    <p class="Pp">The Unicode non-character code points are also disallowed in
        UTF-8 in &quot;open interchange&quot;. See &quot;Non-character code
        points&quot;.</p>
  </li>
  <li>UTF-EBCDIC
    <p class="Pp">Like UTF-8 but EBCDIC-safe, in the way that UTF-8 is
        ASCII-safe.</p>
  </li>
  <li>UTF-16, UTF-16BE, UTF-16LE, Surrogates, and BOMs (Byte Order Marks)
    <p class="Pp">The followings items are mostly for reference and general
        Unicode knowledge, Perl doesn't use these constructs internally.</p>
    <p class="Pp">Like UTF-8, UTF-16 is a variable-width encoding, but where
        UTF-8 uses 8-bit code units, UTF-16 uses 16-bit code units. All code
        points occupy either 2 or 4 bytes in UTF-16: code points
        <span class="Li">&quot;U+0000..U+FFFF&quot;</span> are stored in a
        single 16-bit unit, and code points
        <span class="Li">&quot;U+10000..U+10FFFF&quot;</span> in two 16-bit
        units. The latter case is using <i>surrogates</i>, the first 16-bit unit
        being the <i>high</i> <i>surrogate</i>, and the second being the <i>low
        surrogate</i>.</p>
    <p class="Pp">Surrogates are code points set aside to encode the
        <span class="Li">&quot;U+10000..U+10FFFF&quot;</span> range of Unicode
        code points in pairs of 16-bit units. The <i>high</i> <i>surrogates</i>
        are the range <span class="Li">&quot;U+D800..U+DBFF&quot;</span> and the
        <i>low surrogates</i> are the range
        <span class="Li">&quot;U+DC00..U+DFFF&quot;</span>. The surrogate
        encoding is</p>
    <p class="Pp"></p>
    <pre>
    $hi = ($uni - 0x10000) / 0x400 + 0xD800;
    $lo = ($uni - 0x10000) % 0x400 + 0xDC00;
    </pre>
    <p class="Pp">and the decoding is</p>
    <p class="Pp"></p>
    <pre>
    $uni = 0x10000 + ($hi - 0xD800) * 0x400 + ($lo - 0xDC00);
    </pre>
    <p class="Pp">Because of the 16-bitness, UTF-16 is byte-order dependent.
        UTF-16 itself can be used for in-memory computations, but if storage or
        transfer is required either UTF-16BE (big-endian) or UTF-16LE
        (little-endian) encodings must be chosen.</p>
    <p class="Pp">This introduces another problem: what if you just know that
        your data is UTF-16, but you don't know which endianness? Byte Order
        Marks, or BOMs, are a solution to this. A special character has been
        reserved in Unicode to function as a byte order marker: the character
        with the code point <span class="Li">&quot;U+FEFF&quot;</span> is the
        BOM.</p>
    <p class="Pp">The trick is that if you read a BOM, you will know the byte
        order, since if it was written on a big-endian platform, you will read
        the bytes <span class="Li">&quot;0xFE 0xFF&quot;</span>, but if it was
        written on a little-endian platform, you will read the bytes
        <span class="Li">&quot;0xFF 0xFE&quot;</span>. (And if the originating
        platform was writing in UTF-8, you will read the bytes
        <span class="Li">&quot;0xEF 0xBB 0xBF&quot;</span>.)</p>
    <p class="Pp">The way this trick works is that the character with the code
        point <span class="Li">&quot;U+FFFE&quot;</span> is not supposed to be
        in input streams, so the sequence of bytes <span class="Li">&quot;0xFF
        0xFE&quot;</span> is unambiguously &quot;BOM, represented in
        little-endian format&quot; and cannot be
        <span class="Li">&quot;U+FFFE&quot;</span>, represented in big-endian
        format&quot;.</p>
    <p class="Pp">Surrogates have no meaning in Unicode outside their use in
        pairs to represent other code points. However, Perl allows them to be
        represented individually internally, for example by saying
        <span class="Li">&quot;chr(0xD801)&quot;</span>, so that all code
        points, not just those valid for open interchange, are representable.
        Unicode does define semantics for them, such as their General Category
        is &quot;Cs&quot;. But because their use is somewhat dangerous, Perl
        will warn (using the warning category &quot;surrogate&quot;, which is a
        sub-category of &quot;utf8&quot;) if an attempt is made to do things
        like take the lower case of one, or match case-insensitively, or to
        output them. (But don't try this on Perls before 5.14.)</p>
  </li>
  <li>UTF-32, UTF-32BE, UTF-32LE
    <p class="Pp">The UTF-32 family is pretty much like the UTF-16 family,
        expect that the units are 32-bit, and therefore the surrogate scheme is
        not needed. UTF-32 is a fixed-width encoding. The BOM signatures are
        <span class="Li">&quot;0x00 0x00 0xFE 0xFF&quot;</span> for BE and
        <span class="Li">&quot;0xFF 0xFE 0x00 0x00&quot;</span> for LE.</p>
  </li>
  <li>UCS-2, UCS-4
    <p class="Pp">Legacy, fixed-width encodings defined by the ISO 10646
        standard. UCS-2 is a 16-bit encoding. Unlike UTF-16, UCS-2 is not
        extensible beyond <span class="Li">&quot;U+FFFF&quot;</span>, because it
        does not use surrogates. UCS-4 is a 32-bit encoding, functionally
        identical to UTF-32 (the difference being that UCS-4 forbids neither
        surrogates nor code points larger than 0x10_FFFF).</p>
  </li>
  <li>UTF-7
    <p class="Pp">A seven-bit safe (non-eight-bit) encoding, which is useful if
        the transport or storage is not eight-bit safe. Defined by RFC 2152.</p>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Non-character_code_points"><a class="permalink" href="#Non-character_code_points">Non-character
  code points</a></h2>
<p class="Pp">66 code points are set aside in Unicode as &quot;non-character
    code points&quot;. These all have the Unassigned (Cn) General Category, and
    they never will be assigned. These are never supposed to be in legal Unicode
    input streams, so that code can use them as sentinels that can be mixed in
    with character data, and they always will be distinguishable from that data.
    To keep them out of Perl input streams, strict UTF-8 should be specified,
    such as by using the layer
    <span class="Li">&quot;:encoding('UTF-8')&quot;</span>. The non-character
    code points are the 32 between U+FDD0 and U+FDEF, and the 34 code points
    U+FFFE, U+FFFF, U+1FFFE, U+1FFFF, ... U+10FFFE, U+10FFFF. Some people are
    under the mistaken impression that these are &quot;illegal&quot;, but that
    is not true. An application or cooperating set of applications can legally
    use them at will internally; but these code points are &quot;illegal for
    open interchange&quot;. Therefore, Perl will not accept these from input
    streams unless lax rules are being used, and will warn (using the warning
    category &quot;nonchar&quot;, which is a sub-category of &quot;utf8&quot;)
    if an attempt is made to output them.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Beyond_Unicode_code_points"><a class="permalink" href="#Beyond_Unicode_code_points">Beyond
  Unicode code points</a></h2>
<p class="Pp">The maximum Unicode code point is U+10FFFF. But Perl accepts code
    points up to the maximum permissible unsigned number available on the
    platform. However, Perl will not accept these from input streams unless lax
    rules are being used, and will warn (using the warning category
    &quot;non_unicode&quot;, which is a sub-category of &quot;utf8&quot;) if an
    attempt is made to operate on or output them. For example,
    <span class="Li">&quot;uc(0x11_0000)&quot;</span> will generate this
    warning, returning the input parameter as its result, as the upper case of
    every non-Unicode code point is the code point itself.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Security_Implications_of_Unicode"><a class="permalink" href="#Security_Implications_of_Unicode">Security
  Implications of Unicode</a></h2>
<p class="Pp">Read Unicode Security Considerations
    &lt;http://www.unicode.org/reports/tr36&gt;. Also, note the following:</p>
<ul class="Bl-bullet">
  <li>Malformed UTF-8
    <p class="Pp">Unfortunately, the original specification of UTF-8 leaves some
        room for interpretation of how many bytes of encoded output one should
        generate from one input Unicode character. Strictly speaking, the
        shortest possible sequence of UTF-8 bytes should be generated, because
        otherwise there is potential for an input buffer overflow at the
        receiving end of a UTF-8 connection. Perl always generates the shortest
        length UTF-8, and with warnings on, Perl will warn about non-shortest
        length UTF-8 along with other malformations, such as the surrogates,
        which are not Unicode code points valid for interchange.</p>
  </li>
  <li>Regular expression pattern matching may surprise you if you're not
      accustomed to Unicode. Starting in Perl 5.14, several pattern modifiers
      are available to control this, called the character set modifiers. Details
      are given in &quot;Character set modifiers&quot; in perlre.</li>
</ul>
<p class="Pp">As discussed elsewhere, Perl has one foot (two hooves?) planted in
    each of two worlds: the old world of bytes and the new world of characters,
    upgrading from bytes to characters when necessary. If your legacy code does
    not explicitly use Unicode, no automatic switch-over to characters should
    happen. Characters shouldn't get downgraded to bytes, either. It is possible
    to accidentally mix bytes and characters, however (see perluniintro), in
    which case <span class="Li">&quot;\w&quot;</span> in regular expressions
    might start behaving differently (unless the
    <span class="Li">&quot;/a&quot;</span> modifier is in effect). Review your
    code. Use warnings and the <span class="Li">&quot;strict&quot;</span>
    pragma.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Unicode_in_Perl_on_"><a class="permalink" href="#Unicode_in_Perl_on_">Unicode
  in Perl on EBCDIC</a></h2>
<p class="Pp">The way Unicode is handled on EBCDIC platforms is still
    experimental. On such platforms, references to UTF-8 encoding in this
    document and elsewhere should be read as meaning the UTF-EBCDIC specified in
    Unicode Technical Report 16, unless ASCII vs. EBCDIC issues are specifically
    discussed. There is no <span class="Li">&quot;utfebcdic&quot;</span> pragma
    or &quot;:utfebcdic&quot; layer; rather, &quot;utf8&quot; and
    &quot;:utf8&quot; are reused to mean the platform's &quot;natural&quot;
    8-bit encoding of Unicode. See perlebcdic for more discussion of the
  issues.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Locales"><a class="permalink" href="#Locales">Locales</a></h2>
<p class="Pp">See &quot;Unicode and UTF-8&quot; in perllocale</p>
</section>
<section class="Ss">
<h2 class="Ss" id="When_Unicode_Does_Not_Happen"><a class="permalink" href="#When_Unicode_Does_Not_Happen">When
  Unicode Does Not Happen</a></h2>
<p class="Pp">While Perl does have extensive ways to input and output in
    Unicode, and a few other &quot;entry points&quot; like the
    <span class="Li">@ARGV</span> array (which can sometimes be interpreted as
    UTF-8), there are still many places where Unicode (in some encoding or
    another) could be given as arguments or received as results, or both, but it
    is not.</p>
<p class="Pp">The following are such interfaces. Also, see &quot;The
    &quot;Unicode Bug&quot;&quot;. For all of these interfaces Perl currently
    (as of v5.16.0) simply assumes byte strings both as arguments and results,
    or UTF-8 strings if the (problematic)
    <span class="Li">&quot;encoding&quot;</span> pragma has been used.</p>
<p class="Pp">One reason that Perl does not attempt to resolve the role of
    Unicode in these situations is that the answers are highly dependent on the
    operating system and the file system(s). For example, whether filenames can
    be in Unicode and in exactly what kind of encoding, is not exactly a
    portable concept. Similarly for <span class="Li">&quot;qx&quot;</span> and
    <span class="Li">&quot;system&quot;</span>: how well will the
    &quot;command-line interface&quot; (and which of them?) handle Unicode?</p>
<ul class="Bl-bullet">
  <li>chdir, chmod, chown, chroot, exec, link, lstat, mkdir, rename, rmdir,
      stat, symlink, truncate, unlink, utime, -X</li>
  <li><span class="Li">%ENV</span></li>
  <li>glob (aka the &lt;*&gt;)</li>
  <li>open, opendir, sysopen</li>
  <li>qx (aka the backtick operator), system</li>
  <li>readdir, readlink</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="The__Unicode_Bug_"><a class="permalink" href="#The__Unicode_Bug_">The
  &quot;Unicode Bug&quot;</a></h2>
<p class="Pp">The term, &quot;Unicode bug&quot; has been applied to an
    inconsistency on ASCII platforms with the Unicode code points in the Latin-1
    Supplement block, that is, between 128 and 255. Without a locale specified,
    unlike all other characters or code points, these characters have very
    different semantics in byte semantics versus character semantics, unless
    <span class="Li">&quot;use feature 'unicode_strings'&quot;</span> is
    specified, directly or indirectly. (It is indirectly specified by a
    <span class="Li">&quot;use v5.12&quot;</span> or higher.)</p>
<p class="Pp">In character semantics these upper-Latin1 characters are
    interpreted as Unicode code points, which means they have the same semantics
    as Latin-1 (ISO-8859-1).</p>
<p class="Pp">In byte semantics (without
    <span class="Li">&quot;unicode_strings&quot;</span>), they are considered to
    be unassigned characters, meaning that the only semantics they have is their
    ordinal numbers, and that they are not members of various character classes.
    None are considered to match <span class="Li">&quot;\w&quot;</span> for
    example, but all match <span class="Li">&quot;\W&quot;</span>.</p>
<p class="Pp">Perl 5.12.0 added
    <span class="Li">&quot;unicode_strings&quot;</span> to force character
    semantics on these code points in some circumstances, which fixed portions
    of the bug; Perl 5.14.0 fixed almost all of it; and Perl 5.16.0 fixed the
    remainder (so far as we know, anyway). The lesson here is to enable
    <span class="Li">&quot;unicode_strings&quot;</span> to avoid the headaches
    described below.</p>
<p class="Pp">The old, problematic behavior affects these areas:</p>
<ul class="Bl-bullet">
  <li>Changing the case of a scalar, that is, using
      <span class="Li">&quot;uc()&quot;</span>,
      <span class="Li">&quot;ucfirst()&quot;</span>,
      <span class="Li">&quot;lc()&quot;</span>, and
      <span class="Li">&quot;lcfirst()&quot;</span>, or
      <span class="Li">&quot;\L&quot;</span>,
      <span class="Li">&quot;\U&quot;</span>,
      <span class="Li">&quot;\u&quot;</span> and
      <span class="Li">&quot;\l&quot;</span> in double-quotish contexts, such as
      regular expression substitutions. Under
      <span class="Li">&quot;unicode_strings&quot;</span> starting in Perl
      5.12.0, character semantics are generally used. See &quot;lc&quot; in
      perlfunc for details on how this works in combination with various other
      pragmas.</li>
  <li>Using caseless (<span class="Li">&quot;/i&quot;</span>) regular expression
      matching. Starting in Perl 5.14.0, regular expressions compiled within the
      scope of <span class="Li">&quot;unicode_strings&quot;</span> use character
      semantics even when executed or compiled into larger regular expressions
      outside the scope.</li>
  <li>Matching any of several properties in regular expressions, namely
      <span class="Li">&quot;\b&quot;</span>,
      <span class="Li">&quot;\B&quot;</span>,
      <span class="Li">&quot;\s&quot;</span>,
      <span class="Li">&quot;\S&quot;</span>,
      <span class="Li">&quot;\w&quot;</span>,
      <span class="Li">&quot;\W&quot;</span>, and all the Posix character
      classes <i>except</i> <span class="Li">&quot;[[:ascii:]]&quot;</span>.
      Starting in Perl 5.14.0, regular expressions compiled within the scope of
      <span class="Li">&quot;unicode_strings&quot;</span> use character
      semantics even when executed or compiled into larger regular expressions
      outside the scope.</li>
  <li>In <span class="Li">&quot;quotemeta&quot;</span> or its inline equivalent
      <span class="Li">&quot;\Q&quot;</span>, no code points above 127 are
      quoted in UTF-8 encoded strings, but in byte encoded strings, code points
      between 128-255 are always quoted. Starting in Perl 5.16.0, consistent
      quoting rules are used within the scope of
      <span class="Li">&quot;unicode_strings&quot;</span>, as described in
      &quot;quotemeta&quot; in perlfunc.</li>
</ul>
<p class="Pp">This behavior can lead to unexpected results in which a string's
    semantics suddenly change if a code point above 255 is appended to or
    removed from it, which changes the string's semantics from byte to character
    or vice versa. As an example, consider the following program and its
  output:</p>
<p class="Pp"></p>
<pre>
 $ perl -le'
     no feature 'unicode_strings';
     $s1 = &quot;\xC2&quot;;
     $s2 = &quot;\x{2660}&quot;;
     for ($s1, $s2, $s1.$s2) {
         print /\w/ || 0;
     }
 '
 0
 0
 1
</pre>
<p class="Pp">If there's no <span class="Li">&quot;\w&quot;</span> in
    <span class="Li">&quot;s1&quot;</span> or in
    <span class="Li">&quot;s2&quot;</span>, why does their concatenation have
    one?</p>
<p class="Pp">This anomaly stems from Perl's attempt to not disturb older
    programs that didn't use Unicode, and hence had no semantics for characters
    outside of the ASCII range (except in a locale), along with Perl's desire to
    add Unicode support seamlessly. The result wasn't seamless: these characters
    were orphaned.</p>
<p class="Pp">For Perls earlier than those described above, or when a string is
    passed to a function outside the subpragma's scope, a workaround is to
    always call <span class="Li">&quot;utf8::upgrade($string)&quot;</span>, or
    to use the standard module Encode. Also, a scalar that has any characters
    whose ordinal is above 0x100, or which were specified using either of the
    <span class="Li">&quot;\N{...}&quot;</span> notations, will automatically
    have character semantics.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Forcing_Unicode_in_Perl_(Or_Unforcing_Unicode_in_Perl)"><a class="permalink" href="#Forcing_Unicode_in_Perl_(Or_Unforcing_Unicode_in_Perl)">Forcing
  Unicode in Perl (Or Unforcing Unicode in Perl)</a></h2>
<p class="Pp">Sometimes (see &quot;When Unicode Does Not Happen&quot; or
    &quot;The &quot;Unicode Bug&quot;&quot;) there are situations where you
    simply need to force a byte string into UTF-8, or vice versa. The low-level
    calls utf8::upgrade($bytestring) and utf8::downgrade($utf8string[, FAIL_OK])
    are the answers.</p>
<p class="Pp">Note that <i>utf8::downgrade()</i> can fail if the string contains
    characters that don't fit into a byte.</p>
<p class="Pp">Calling either function on a string that already is in the desired
    state is a no-op.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_Unicode_in_"><a class="permalink" href="#Using_Unicode_in_">Using
  Unicode in XS</a></h2>
<p class="Pp">If you want to handle Perl Unicode in XS extensions, you may find
    the following C APIs useful. See also &quot;Unicode Support&quot; in
    perlguts for an explanation about Unicode at the XS level, and perlapi for
    the API details.</p>
<ul class="Bl-bullet">
  <li><span class="Li">&quot;DO_UTF8(sv)&quot;</span> returns true if the
      <span class="Li">&quot;UTF8&quot;</span> flag is on and the bytes pragma
      is not in effect. <span class="Li">&quot;SvUTF8(sv)&quot;</span> returns
      true if the <span class="Li">&quot;UTF8&quot;</span> flag is on; the bytes
      pragma is ignored. The <span class="Li">&quot;UTF8&quot;</span> flag being
      on does <b>not</b> mean that there are any characters of code points
      greater than 255 (or 127) in the scalar or that there are even any
      characters in the scalar. What the
      <span class="Li">&quot;UTF8&quot;</span> flag means is that the sequence
      of octets in the representation of the scalar is the sequence of UTF-8
      encoded code points of the characters of a string. The
      <span class="Li">&quot;UTF8&quot;</span> flag being off means that each
      octet in this representation encodes a single character with code point
      0..255 within the string. Perl's Unicode model is not to use UTF-8 until
      it is absolutely necessary.</li>
  <li><span class="Li">&quot;uvchr_to_utf8(buf, chr)&quot;</span> writes a
      Unicode character code point into a buffer encoding the code point as
      UTF-8, and returns a pointer pointing after the UTF-8 bytes. It works
      appropriately on EBCDIC machines.</li>
  <li><span class="Li">&quot;utf8_to_uvchr_buf(buf, bufend, lenp)&quot;</span>
      reads UTF-8 encoded bytes from a buffer and returns the Unicode character
      code point and, optionally, the length of the UTF-8 byte sequence. It
      works appropriately on EBCDIC machines.</li>
  <li><span class="Li">&quot;utf8_length(start, end)&quot;</span> returns the
      length of the UTF-8 encoded buffer in characters.
      <span class="Li">&quot;sv_len_utf8(sv)&quot;</span> returns the length of
      the UTF-8 encoded scalar.</li>
  <li><span class="Li">&quot;sv_utf8_upgrade(sv)&quot;</span> converts the
      string of the scalar to its UTF-8 encoded form.
      <span class="Li">&quot;sv_utf8_downgrade(sv)&quot;</span> does the
      opposite, if possible.
      <span class="Li">&quot;sv_utf8_encode(sv)&quot;</span> is like
      sv_utf8_upgrade except that it does not set the
      <span class="Li">&quot;UTF8&quot;</span> flag.
      <span class="Li">&quot;sv_utf8_decode()&quot;</span> does the opposite of
      <span class="Li">&quot;sv_utf8_encode()&quot;</span>. Note that none of
      these are to be used as general-purpose encoding or decoding interfaces:
      <span class="Li">&quot;use Encode&quot;</span> for that.
      <span class="Li">&quot;sv_utf8_upgrade()&quot;</span> is affected by the
      encoding pragma but
      <span class="Li">&quot;sv_utf8_downgrade()&quot;</span> is not (since the
      encoding pragma is designed to be a one-way street).</li>
  <li><span class="Li">&quot;is_utf8_string(buf, len)&quot;</span> returns true
      if <span class="Li">&quot;len&quot;</span> bytes of the buffer are valid
      UTF-8.</li>
  <li><span class="Li">&quot;is_utf8_char_buf(buf, buf_end)&quot;</span> returns
      true if the pointer points to a valid UTF-8 character.</li>
  <li><span class="Li">&quot;UTF8SKIP(buf)&quot;</span> will return the number
      of bytes in the UTF-8 encoded character in the buffer.
      <span class="Li">&quot;UNISKIP(chr)&quot;</span> will return the number of
      bytes required to UTF-8-encode the Unicode character code point.
      <span class="Li">&quot;UTF8SKIP()&quot;</span> is useful for example for
      iterating over the characters of a UTF-8 encoded buffer;
      <span class="Li">&quot;UNISKIP()&quot;</span> is useful, for example, in
      computing the size required for a UTF-8 encoded buffer.</li>
  <li><span class="Li">&quot;utf8_distance(a, b)&quot;</span> will tell the
      distance in characters between the two pointers pointing to the same UTF-8
      encoded buffer.</li>
  <li><span class="Li">&quot;utf8_hop(s, off)&quot;</span> will return a pointer
      to a UTF-8 encoded buffer that is <span class="Li">&quot;off&quot;</span>
      (positive or negative) Unicode characters displaced from the UTF-8 buffer
      <span class="Li">&quot;s&quot;</span>. Be careful not to overstep the
      buffer: <span class="Li">&quot;utf8_hop()&quot;</span> will merrily run
      off the end or the beginning of the buffer if told to do so.</li>
  <li><span class="Li">&quot;pv_uni_display(dsv, spv, len, pvlim,
      flags)&quot;</span> and <span class="Li">&quot;sv_uni_display(dsv, ssv,
      pvlim, flags)&quot;</span> are useful for debugging the output of Unicode
      strings and scalars. By default they are useful only for debugging--they
      display <b>all</b> characters as hexadecimal code points--but with the
      flags <span class="Li">&quot;UNI_DISPLAY_ISPRINT&quot;</span>,
      <span class="Li">&quot;UNI_DISPLAY_BACKSLASH&quot;</span>, and
      <span class="Li">&quot;UNI_DISPLAY_QQ&quot;</span> you can make the output
      more readable.</li>
  <li><span class="Li">&quot;foldEQ_utf8(s1, pe1, l1, u1, s2, pe2, l2,
      u2)&quot;</span> can be used to compare two strings case-insensitively in
      Unicode. For case-sensitive comparisons you can just use
      <span class="Li">&quot;memEQ()&quot;</span> and
      <span class="Li">&quot;memNE()&quot;</span> as usual, except if one string
      is in utf8 and the other isn't.</li>
</ul>
<p class="Pp">For more information, see perlapi, and <i>utf8.c</i> and
    <i>utf8.h</i> in the Perl source code distribution.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Hacking_Perl_to_work_on_earlier_Unicode_versions_(for_very_serious_hackers_only)"><a class="permalink" href="#Hacking_Perl_to_work_on_earlier_Unicode_versions_(for_very_serious_hackers_only)">Hacking
  Perl to work on earlier Unicode versions (for very serious hackers
  only)</a></h2>
<p class="Pp">Perl by default comes with the latest supported Unicode version
    built in, but you can change to use any earlier one.</p>
<p class="Pp">Download the files in the desired version of Unicode from the
    Unicode web site &lt;http://www.unicode.org&gt;). These should replace the
    existing files in <i>lib/unicore</i> in the Perl source tree. Follow the
    instructions in <i>README.perl</i> in that directory to change some of their
    names, and then build perl (see INSTALL).</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<section class="Ss">
<h2 class="Ss" id="Interaction_with_Locales"><a class="permalink" href="#Interaction_with_Locales">Interaction
  with Locales</a></h2>
<p class="Pp">See &quot;Unicode and UTF-8&quot; in perllocale</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Problems_with_characters_in_the_Latin"><a class="permalink" href="#Problems_with_characters_in_the_Latin">Problems
  with characters in the Latin-1 Supplement range</a></h2>
<p class="Pp">See &quot;The &quot;Unicode Bug&quot;&quot;</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Interaction_with_Extensions"><a class="permalink" href="#Interaction_with_Extensions">Interaction
  with Extensions</a></h2>
<p class="Pp">When Perl exchanges data with an extension, the extension should
    be able to understand the UTF8 flag and act accordingly. If the extension
    doesn't recognize that flag, it's likely that the extension will return
    incorrectly-flagged data.</p>
<p class="Pp">So if you're working with Unicode data, consult the documentation
    of every module you're using if there are any issues with Unicode data
    exchange. If the documentation does not talk about Unicode at all, suspect
    the worst and probably look at the source to learn how the module is
    implemented. Modules written completely in Perl shouldn't cause problems.
    Modules that directly or indirectly access code written in other programming
    languages are at risk.</p>
<p class="Pp">For affected functions, the simple strategy to avoid data
    corruption is to always make the encoding of the exchanged data explicit.
    Choose an encoding that you know the extension can handle. Convert arguments
    passed to the extensions to that encoding and convert results back from that
    encoding. Write wrapper functions that do the conversions for you, so you
    can later change the functions when the extension catches up.</p>
<p class="Pp">To provide an example, let's say the popular Foo::Bar::escape_html
    function doesn't deal with Unicode data yet. The wrapper function would
    convert the argument to raw UTF-8 and convert the result back to Perl's
    internal representation like so:</p>
<p class="Pp"></p>
<pre>
    sub my_escape_html ($) {
        my($what) = shift;
        return unless defined $what;
        Encode::decode_utf8(Foo::Bar::escape_html(
                                         Encode::encode_utf8($what)));
    }
</pre>
<p class="Pp">Sometimes, when the extension does not convert data but just
    stores and retrieves them, you will be able to use the otherwise dangerous
    <i>Encode::_utf8_on()</i> function. Let's say the popular
    <span class="Li">&quot;Foo::Bar&quot;</span> extension, written in C,
    provides a <span class="Li">&quot;param&quot;</span> method that lets you
    store and retrieve data according to these prototypes:</p>
<p class="Pp"></p>
<pre>
    $self-&gt;param($name, $value);            # set a scalar
    $value = $self-&gt;param($name);           # retrieve a scalar
</pre>
<p class="Pp">If it does not yet provide support for any encoding, one could
    write a derived class with such a <span class="Li">&quot;param&quot;</span>
    method:</p>
<p class="Pp"></p>
<pre>
    sub param {
      my($self,$name,$value) = @_;
      utf8::upgrade($name);     # make sure it is UTF-8 encoded
      if (defined $value) {
        utf8::upgrade($value);  # make sure it is UTF-8 encoded
        return $self-&gt;SUPER::param($name,$value);
      } else {
        my $ret = $self-&gt;SUPER::param($name);
        Encode::_utf8_on($ret); # we know, it is UTF-8 encoded
        return $ret;
      }
    }
</pre>
<p class="Pp">Some extensions provide filters on data entry/exit points, such as
    DB_File::filter_store_key and family. Look out for such filters in the
    documentation of your extensions, they can make the transition to Unicode
    data much easier.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Speed"><a class="permalink" href="#Speed">Speed</a></h2>
<p class="Pp">Some functions are slower when working on UTF-8 encoded strings
    than on byte encoded strings. All functions that need to hop over characters
    such as <i>length()</i>, <i>substr()</i> or <i>index()</i>, or matching
    regular expressions can work <b>much</b> faster when the underlying data are
    byte-encoded.</p>
<p class="Pp">In Perl 5.8.0 the slowness was often quite spectacular; in Perl
    5.8.1 a caching scheme was introduced which will hopefully make the slowness
    somewhat less spectacular, at least for some operations. In general,
    operations with UTF-8 encoded strings are still slower. As an example, the
    Unicode properties (character classes) like
    <span class="Li">&quot;\p{Nd}&quot;</span> are known to be quite a bit
    slower (5-20 times) than their simpler counterparts like
    <span class="Li">&quot;\d&quot;</span> (then again, there are hundreds of
    Unicode characters matching <span class="Li">&quot;Nd&quot;</span> compared
    with the 10 ASCII characters matching
    <span class="Li">&quot;d&quot;</span>).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Problems_on_"><a class="permalink" href="#Problems_on_">Problems
  on EBCDIC platforms</a></h2>
<p class="Pp">There are several known problems with Perl on EBCDIC platforms. If
    you want to use Perl there, send email to perlbug@perl.org.</p>
<p class="Pp">In earlier versions, when byte and character data were
    concatenated, the new string was sometimes created by decoding the byte
    strings as <i>ISO 8859-1 (Latin-1)</i>, even if the old Unicode string used
    EBCDIC.</p>
<p class="Pp">If you find any of these, please report them as bugs.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Porting_code_from_perl"><a class="permalink" href="#Porting_code_from_perl">Porting
  code from perl-5.6.X</a></h2>
<p class="Pp">Perl 5.8 has a different Unicode model from 5.6. In 5.6 the
    programmer was required to use the <span class="Li">&quot;utf8&quot;</span>
    pragma to declare that a given scope expected to deal with Unicode data and
    had to make sure that only Unicode data were reaching that scope. If you
    have code that is working with 5.6, you will need some of the following
    adjustments to your code. The examples are written such that the code will
    continue to work under 5.6, so you should be safe to try them out.</p>
<ul class="Bl-bullet">
  <li>A filehandle that should read or write UTF-8
    <p class="Pp"></p>
    <pre>
  if ($] &gt; 5.008) {
    binmode $fh, &quot;:encoding(utf8)&quot;;
  }
    </pre>
  </li>
  <li>A scalar that is going to be passed to some extension
    <p class="Pp">Be it Compress::Zlib, Apache::Request or any extension that
        has no mention of Unicode in the manpage, you need to make sure that the
        UTF8 flag is stripped off. Note that at the time of this writing
        (January 2012) the mentioned modules are not UTF-8-aware. Please check
        the documentation to verify if this is still true.</p>
    <p class="Pp"></p>
    <pre>
  if ($] &gt; 5.008) {
    require Encode;
    $val = Encode::encode_utf8($val); # make octets
  }
    </pre>
  </li>
  <li>A scalar we got back from an extension
    <p class="Pp">If you believe the scalar comes back as UTF-8, you will most
        likely want the UTF8 flag restored:</p>
    <p class="Pp"></p>
    <pre>
  if ($] &gt; 5.008) {
    require Encode;
    $val = Encode::decode_utf8($val);
  }
    </pre>
  </li>
  <li>Same thing, if you are really sure it is UTF-8
    <p class="Pp"></p>
    <pre>
  if ($] &gt; 5.008) {
    require Encode;
    Encode::_utf8_on($val);
  }
    </pre>
  </li>
  <li>A wrapper for fetchrow_array and fetchrow_hashref
    <p class="Pp">When the database contains only UTF-8, a wrapper function or
        method is a convenient way to replace all your fetchrow_array and
        fetchrow_hashref calls. A wrapper function will also make it easier to
        adapt to future enhancements in your database driver. Note that at the
        time of this writing (January 2012), the DBI has no standardized way to
        deal with UTF-8 data. Please check the documentation to verify if that
        is still true.</p>
    <p class="Pp"></p>
    <pre>
  sub fetchrow {
    # $what is one of fetchrow_{array,hashref}
    my($self, $sth, $what) = @_;
    if ($] &lt; 5.008) {
      return $sth-&gt;$what;
    } else {
      require Encode;
      if (wantarray) {
        my @arr = $sth-&gt;$what;
        for (@arr) {
          defined &amp;&amp; /[^\000-\177]/ &amp;&amp; Encode::_utf8_on($_);
        }
        return @arr;
      } else {
        my $ret = $sth-&gt;$what;
        if (ref $ret) {
          for my $k (keys %$ret) {
            defined
            &amp;&amp; /[^\000-\177]/
            &amp;&amp; Encode::_utf8_on($_) for $ret-&gt;{$k};
          }
          return $ret;
        } else {
          defined &amp;&amp; /[^\000-\177]/ &amp;&amp; Encode::_utf8_on($_) for $ret;
          return $ret;
        }
      }
    }
  }
    </pre>
  </li>
  <li>A large scalar that you know can only contain ASCII
    <p class="Pp">Scalars that contain only ASCII and are marked as UTF-8 are
        sometimes a drag to your program. If you recognize such a situation,
        just remove the UTF8 flag:</p>
    <p class="Pp"></p>
    <pre>
  utf8::downgrade($val) if $] &gt; 5.008;
    </pre>
  </li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">perlunitut, perluniintro, perluniprops, Encode, open, utf8, bytes,
    perlretut, &quot;${^UNICODE}&quot; in perlvar
    &lt;http://www.unicode.org/reports/tr44&gt;).</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>

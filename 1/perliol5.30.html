<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PERLIOL(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLIOL(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLIOL(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perliol - C API for Perl's implementation of IO in Layers.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>
    /* Defining a layer ... */
    #include &lt;perliol.h&gt;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This document describes the behavior and implementation of the
    PerlIO abstraction described in perlapio when
    <span class="Li">&quot;USE_PERLIO&quot;</span> is defined.</p>
<section class="Ss">
<h2 class="Ss" id="History_and_Background"><a class="permalink" href="#History_and_Background">History
  and Background</a></h2>
<p class="Pp">The PerlIO abstraction was introduced in perl5.003_02 but
    languished as just an abstraction until perl5.7.0. However during that time
    a number of perl extensions switched to using it, so the API is mostly fixed
    to maintain (source) compatibility.</p>
<p class="Pp">The aim of the implementation is to provide the PerlIO API in a
    flexible and platform neutral manner. It is also a trial of an &quot;Object
    Oriented C, with vtables&quot; approach which may be applied to Perl 6.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Basic_Structure"><a class="permalink" href="#Basic_Structure">Basic
  Structure</a></h2>
<p class="Pp">PerlIO is a stack of layers.</p>
<p class="Pp">The low levels of the stack work with the low-level operating
    system calls (file descriptors in C) getting bytes in and out, the higher
    layers of the stack buffer, filter, and otherwise manipulate the I/O, and
    return characters (or bytes) to Perl. Terms <i>above</i> and <i>below</i>
    are used to refer to the relative positioning of the stack layers.</p>
<p class="Pp">A layer contains a &quot;vtable&quot;, the table of I/O operations
    (at C level a table of function pointers), and status flags. The functions
    in the vtable implement operations like &quot;open&quot;, &quot;read&quot;,
    and &quot;write&quot;.</p>
<p class="Pp">When I/O, for example &quot;read&quot;, is requested, the request
    goes from Perl first down the stack using &quot;read&quot; functions of each
    layer, then at the bottom the input is requested from the operating system
    services, then the result is returned up the stack, finally being
    interpreted as Perl data.</p>
<p class="Pp">The requests do not necessarily go always all the way down to the
    operating system: that's where PerlIO buffering comes into play.</p>
<p class="Pp">When you do an <b>open()</b> and specify extra PerlIO layers to be
    deployed, the layers you specify are &quot;pushed&quot; on top of the
    already existing default stack. One way to see it is that &quot;operating
    system is on the left&quot; and &quot;Perl is on the right&quot;.</p>
<p class="Pp">What exact layers are in this default stack depends on a lot of
    things: your operating system, Perl version, Perl compile time
    configuration, and Perl runtime configuration. See PerlIO,
    &quot;PERLIO&quot; in perlrun, and open for more information.</p>
<p class="Pp"><b>binmode()</b> operates similarly to <b>open()</b>: by default
    the specified layers are pushed on top of the existing stack.</p>
<p class="Pp">However, note that even as the specified layers are &quot;pushed
    on top&quot; for <b>open()</b> and <b>binmode()</b>, this doesn't mean that
    the effects are limited to the &quot;top&quot;: PerlIO layers can be very
    'active' and inspect and affect layers also deeper in the stack. As an
    example there is a layer called &quot;raw&quot; which repeatedly
    &quot;pops&quot; layers until it reaches the first layer that has declared
    itself capable of handling binary data. The &quot;pushed&quot; layers are
    processed in left-to-right order.</p>
<p class="Pp"><b>sysopen()</b> operates (unsurprisingly) at a lower level in the
    stack than <b>open()</b>. For example in Unix or Unix-like systems
    <b>sysopen()</b> operates directly at the level of file descriptors: in the
    terms of PerlIO layers, it uses only the &quot;unix&quot; layer, which is a
    rather thin wrapper on top of the Unix file descriptors.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Layers_vs_Disciplines"><a class="permalink" href="#Layers_vs_Disciplines">Layers
  vs Disciplines</a></h2>
<p class="Pp">Initial discussion of the ability to modify IO streams behaviour
    used the term &quot;discipline&quot; for the entities which were added. This
    came (I believe) from the use of the term in &quot;sfio&quot;, which in turn
    borrowed it from &quot;line disciplines&quot; on Unix terminals. However,
    this document (and the C code) uses the term &quot;layer&quot;.</p>
<p class="Pp">This is, I hope, a natural term given the implementation, and
    should avoid connotations that are inherent in earlier uses of
    &quot;discipline&quot; for things which are rather different.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Data_Structures"><a class="permalink" href="#Data_Structures">Data
  Structures</a></h2>
<p class="Pp">The basic data structure is a PerlIOl:</p>
<p class="Pp"></p>
<pre>
        typedef struct _PerlIO PerlIOl;
        typedef struct _PerlIO_funcs PerlIO_funcs;
        typedef PerlIOl *PerlIO;

        struct _PerlIO
        {
         PerlIOl *      next;       /* Lower layer */
         PerlIO_funcs * tab;        /* Functions for this layer */
         U32            flags;      /* Various flags for state */
        };
</pre>
<p class="Pp">A <span class="Li">&quot;PerlIOl *&quot;</span> is a pointer to
    the struct, and the <i>application</i> level <span class="Li">&quot;PerlIO
    *&quot;</span> is a pointer to a <span class="Li">&quot;PerlIOl
    *&quot;</span> - i.e. a pointer to a pointer to the struct. This allows the
    application level <span class="Li">&quot;PerlIO *&quot;</span> to remain
    constant while the actual <span class="Li">&quot;PerlIOl *&quot;</span>
    underneath changes. (Compare perl's <span class="Li">&quot;SV *&quot;</span>
    which remains constant while its <span class="Li">&quot;sv_any&quot;</span>
    field changes as the scalar's type changes.) An IO stream is then in general
    represented as a pointer to this linked-list of &quot;layers&quot;.</p>
<p class="Pp">It should be noted that because of the double indirection in a
    <span class="Li">&quot;PerlIO *&quot;</span>, a
    <span class="Li">&quot;&amp;(perlio-&gt;next)&quot;</span> &quot;is&quot; a
    <span class="Li">&quot;PerlIO *&quot;</span>, and so to some degree at least
    one layer can use the &quot;standard&quot; API on the next layer down.</p>
<p class="Pp">A &quot;layer&quot; is composed of two parts:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>The functions and attributes of the &quot;layer class&quot;.</dd>
  <dt>2.</dt>
  <dd>The per-instance data for a particular handle.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Functions_and_Attributes"><a class="permalink" href="#Functions_and_Attributes">Functions
  and Attributes</a></h2>
<p class="Pp">The functions and attributes are accessed via the &quot;tab&quot;
    (for table) member of <span class="Li">&quot;PerlIOl&quot;</span>. The
    functions (methods of the layer &quot;class&quot;) are fixed, and are
    defined by the <span class="Li">&quot;PerlIO_funcs&quot;</span> type. They
    are broadly the same as the public
    <span class="Li">&quot;PerlIO_xxxxx&quot;</span> functions:</p>
<p class="Pp"></p>
<pre>
 struct _PerlIO_funcs
 {
  Size_t     fsize;
  char *     name;
  Size_t     size;
  IV         kind;
  IV         (*Pushed)(pTHX_ PerlIO *f,
                             const char *mode,
                             SV *arg,
                             PerlIO_funcs *tab);
  IV         (*Popped)(pTHX_ PerlIO *f);
  PerlIO *   (*Open)(pTHX_ PerlIO_funcs *tab,
                           PerlIO_list_t *layers, IV n,
                           const char *mode,
                           int fd, int imode, int perm,
                           PerlIO *old,
                           int narg, SV **args);
  IV         (*Binmode)(pTHX_ PerlIO *f);
  SV *       (*Getarg)(pTHX_ PerlIO *f, CLONE_PARAMS *param, int flags)
  IV         (*Fileno)(pTHX_ PerlIO *f);
  PerlIO *   (*Dup)(pTHX_ PerlIO *f,
                          PerlIO *o,
                          CLONE_PARAMS *param,
                          int flags)
  /* Unix-like functions - cf sfio line disciplines */
  SSize_t    (*Read)(pTHX_ PerlIO *f, void *vbuf, Size_t count);
  SSize_t    (*Unread)(pTHX_ PerlIO *f, const void *vbuf, Size_t count);
  SSize_t    (*Write)(pTHX_ PerlIO *f, const void *vbuf, Size_t count);
  IV         (*Seek)(pTHX_ PerlIO *f, Off_t offset, int whence);
  Off_t      (*Tell)(pTHX_ PerlIO *f);
  IV         (*Close)(pTHX_ PerlIO *f);
  /* Stdio-like buffered IO functions */
  IV         (*Flush)(pTHX_ PerlIO *f);
  IV         (*Fill)(pTHX_ PerlIO *f);
  IV         (*Eof)(pTHX_ PerlIO *f);
  IV         (*Error)(pTHX_ PerlIO *f);
  void       (*Clearerr)(pTHX_ PerlIO *f);
  void       (*Setlinebuf)(pTHX_ PerlIO *f);
  /* Perl's snooping functions */
  STDCHAR *  (*Get_base)(pTHX_ PerlIO *f);
  Size_t     (*Get_bufsiz)(pTHX_ PerlIO *f);
  STDCHAR *  (*Get_ptr)(pTHX_ PerlIO *f);
  SSize_t    (*Get_cnt)(pTHX_ PerlIO *f);
  void       (*Set_ptrcnt)(pTHX_ PerlIO *f,STDCHAR *ptr,SSize_t cnt);
 };
</pre>
<p class="Pp">The first few members of the struct give a function table size for
    compatibility check &quot;name&quot; for the layer, the size to
    <span class="Li">&quot;malloc&quot;</span> for the per-instance data, and
    some flags which are attributes of the class as whole (such as whether it is
    a buffering layer), then follow the functions which fall into four basic
    groups:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>Opening and setup functions</dd>
  <dt>2.</dt>
  <dd>Basic IO operations</dd>
  <dt>3.</dt>
  <dd>Stdio class buffering options.</dd>
  <dt>4.</dt>
  <dd>Functions to support Perl's traditional &quot;fast&quot; access to the
      buffer.</dd>
</dl>
<p class="Pp">A layer does not have to implement all the functions, but the
    whole table has to be present. Unimplemented slots can be NULL (which will
    result in an error when called) or can be filled in with stubs to
    &quot;inherit&quot; behaviour from a &quot;base class&quot;. This
    &quot;inheritance&quot; is fixed for all instances of the layer, but as the
    layer chooses which stubs to populate the table, limited &quot;multiple
    inheritance&quot; is possible.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Per-instance_Data"><a class="permalink" href="#Per-instance_Data">Per-instance
  Data</a></h2>
<p class="Pp">The per-instance data are held in memory beyond the basic PerlIOl
    struct, by making a PerlIOl the first member of the layer's struct thus:</p>
<p class="Pp"></p>
<pre>
        typedef struct
        {
         struct _PerlIO base;       /* Base &quot;class&quot; info */
         STDCHAR *      buf;        /* Start of buffer */
         STDCHAR *      end;        /* End of valid part of buffer */
         STDCHAR *      ptr;        /* Current position in buffer */
         Off_t          posn;       /* Offset of buf into the file */
         Size_t         bufsiz;     /* Real size of buffer */
         IV             oneword;    /* Emergency buffer */
        } PerlIOBuf;
</pre>
<p class="Pp">In this way (as for perl's scalars) a pointer to a PerlIOBuf can
    be treated as a pointer to a PerlIOl.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Layers_in_action."><a class="permalink" href="#Layers_in_action.">Layers
  in action.</a></h2>
<pre>
                table           perlio          unix
            |           |
            +-----------+    +----------+    +--------+
   PerlIO -&gt;|           |---&gt;|  next    |---&gt;|  NULL  |
            +-----------+    +----------+    +--------+
            |           |    |  buffer  |    |   fd   |
            +-----------+    |          |    +--------+
            |           |    +----------+
</pre>
<p class="Pp">The above attempts to show how the layer scheme works in a simple
    case. The application's <span class="Li">&quot;PerlIO *&quot;</span> points
    to an entry in the table(s) representing open (allocated) handles. For
    example the first three slots in the table correspond to
    <span class="Li">&quot;stdin&quot;</span>,<span class="Li">&quot;stdout&quot;</span>
    and <span class="Li">&quot;stderr&quot;</span>. The table in turn points to
    the current &quot;top&quot; layer for the handle - in this case an instance
    of the generic buffering layer &quot;perlio&quot;. That layer in turn points
    to the next layer down - in this case the low-level &quot;unix&quot;
  layer.</p>
<p class="Pp">The above is roughly equivalent to a &quot;stdio&quot; buffered
    stream, but with much more flexibility:</p>
<ul class="Bl-bullet">
  <li>If Unix level
      <span class="Li">&quot;read&quot;</span>/<span class="Li">&quot;write&quot;</span>/<span class="Li">&quot;lseek&quot;</span>
      is not appropriate for (say) sockets then the &quot;unix&quot; layer can
      be replaced (at open time or even dynamically) with a &quot;socket&quot;
      layer.</li>
  <li>Different handles can have different buffering schemes. The
      &quot;top&quot; layer could be the &quot;mmap&quot; layer if reading disk
      files was quicker using <span class="Li">&quot;mmap&quot;</span> than
      <span class="Li">&quot;read&quot;</span>. An &quot;unbuffered&quot; stream
      can be implemented simply by not having a buffer layer.</li>
  <li>Extra layers can be inserted to process the data as it flows through. This
      was the driving need for including the scheme in perl 5.7.0+ - we needed a
      mechanism to allow data to be translated between perl's internal encoding
      (conceptually at least Unicode as UTF-8), and the &quot;native&quot;
      format used by the system. This is provided by the
      &quot;:encoding(xxxx)&quot; layer which typically sits above the buffering
      layer.</li>
  <li>A layer can be added that does &quot;\n&quot; to CRLF translation. This
      layer can be used on any platform, not just those that normally do such
      things.</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Per-instance_flag_bits"><a class="permalink" href="#Per-instance_flag_bits">Per-instance
  flag bits</a></h2>
<p class="Pp">The generic flag bits are a hybrid of
    <span class="Li">&quot;O_XXXXX&quot;</span> style flags deduced from the
    mode string passed to <span class="Li">&quot;PerlIO_open()&quot;</span>, and
    state bits for typical buffer layers.</p>
<dl class="Bl-tag">
  <dt id="PERLIO_F_EOF"><a class="permalink" href="#PERLIO_F_EOF">PERLIO_F_EOF</a></dt>
  <dd>End of file.</dd>
  <dt id="PERLIO_F_CANWRITE"><a class="permalink" href="#PERLIO_F_CANWRITE">PERLIO_F_CANWRITE</a></dt>
  <dd>Writes are permitted, i.e. opened as &quot;w&quot; or &quot;r+&quot; or
      &quot;a&quot;, etc.</dd>
  <dt id="PERLIO_F_CANREAD"><a class="permalink" href="#PERLIO_F_CANREAD">PERLIO_F_CANREAD</a></dt>
  <dd>Reads are permitted i.e. opened &quot;r&quot; or &quot;w+&quot; (or even
      &quot;a+&quot; - ick).</dd>
  <dt id="PERLIO_F_ERROR"><a class="permalink" href="#PERLIO_F_ERROR">PERLIO_F_ERROR</a></dt>
  <dd>An error has occurred (for
      <span class="Li">&quot;PerlIO_error()&quot;</span>).</dd>
  <dt id="PERLIO_F_TRUNCATE"><a class="permalink" href="#PERLIO_F_TRUNCATE">PERLIO_F_TRUNCATE</a></dt>
  <dd>Truncate file suggested by open mode.</dd>
  <dt id="PERLIO_F_APPEND"><a class="permalink" href="#PERLIO_F_APPEND">PERLIO_F_APPEND</a></dt>
  <dd>All writes should be appends.</dd>
  <dt id="PERLIO_F_CRLF"><a class="permalink" href="#PERLIO_F_CRLF">PERLIO_F_CRLF</a></dt>
  <dd>Layer is performing Win32-like &quot;\n&quot; mapped to CR,LF for output
      and CR,LF mapped to &quot;\n&quot; for input. Normally the provided
      &quot;crlf&quot; layer is the only layer that need bother about this.
      <span class="Li">&quot;PerlIO_binmode()&quot;</span> will mess with this
      flag rather than add/remove layers if the
      <span class="Li">&quot;PERLIO_K_CANCRLF&quot;</span> bit is set for the
      layers class.</dd>
  <dt id="PERLIO_F_UTF8"><a class="permalink" href="#PERLIO_F_UTF8">PERLIO_F_UTF8</a></dt>
  <dd>Data written to this layer should be UTF-8 encoded; data provided by this
      layer should be considered UTF-8 encoded. Can be set on any layer by
      &quot;:utf8&quot; dummy layer. Also set on &quot;:encoding&quot;
    layer.</dd>
  <dt id="PERLIO_F_UNBUF"><a class="permalink" href="#PERLIO_F_UNBUF">PERLIO_F_UNBUF</a></dt>
  <dd>Layer is unbuffered - i.e. write to next layer down should occur for each
      write to this layer.</dd>
  <dt id="PERLIO_F_WRBUF"><a class="permalink" href="#PERLIO_F_WRBUF">PERLIO_F_WRBUF</a></dt>
  <dd>The buffer for this layer currently holds data written to it but not sent
      to next layer.</dd>
  <dt id="PERLIO_F_RDBUF"><a class="permalink" href="#PERLIO_F_RDBUF">PERLIO_F_RDBUF</a></dt>
  <dd>The buffer for this layer currently holds unconsumed data read from layer
      below.</dd>
  <dt id="PERLIO_F_LINEBUF"><a class="permalink" href="#PERLIO_F_LINEBUF">PERLIO_F_LINEBUF</a></dt>
  <dd>Layer is line buffered. Write data should be passed to next layer down
      whenever a &quot;\n&quot; is seen. Any data beyond the &quot;\n&quot;
      should then be processed.</dd>
  <dt id="PERLIO_F_TEMP"><a class="permalink" href="#PERLIO_F_TEMP">PERLIO_F_TEMP</a></dt>
  <dd>File has been <span class="Li">&quot;unlink()&quot;</span>ed, or should be
      deleted on <span class="Li">&quot;close()&quot;</span>.</dd>
  <dt id="PERLIO_F_OPEN"><a class="permalink" href="#PERLIO_F_OPEN">PERLIO_F_OPEN</a></dt>
  <dd>Handle is open.</dd>
  <dt id="PERLIO_F_FASTGETS"><a class="permalink" href="#PERLIO_F_FASTGETS">PERLIO_F_FASTGETS</a></dt>
  <dd>This instance of this layer supports the &quot;fast
      <span class="Li">&quot;gets&quot;</span>&quot; interface. Normally set
      based on <span class="Li">&quot;PERLIO_K_FASTGETS&quot;</span> for the
      class and by the existence of the function(s) in the table. However a
      class that normally provides that interface may need to avoid it on a
      particular instance. The &quot;pending&quot; layer needs to do this when
      it is pushed above a layer which does not support the interface. (Perl's
      <span class="Li">&quot;sv_gets()&quot;</span> does not expect the streams
      fast <span class="Li">&quot;gets&quot;</span> behaviour to change during
      one &quot;get&quot;.)</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Methods_in_Detail"><a class="permalink" href="#Methods_in_Detail">Methods
  in Detail</a></h2>
<dl class="Bl-tag">
  <dt id="fsize"><a class="permalink" href="#fsize">fsize</a></dt>
  <dd>
    <pre>
        Size_t fsize;
    </pre>
    <p class="Pp">Size of the function table. This is compared against the value
        PerlIO code &quot;knows&quot; as a compatibility check. Future versions
        <i>may</i> be able to tolerate layers compiled against an old version of
        the headers.</p>
  </dd>
  <dt id="name"><a class="permalink" href="#name">name</a></dt>
  <dd>
    <pre>
        char * name;
    </pre>
    <p class="Pp">The name of the layer whose <b>open()</b> method Perl should
        invoke on <b>open()</b>. For example if the layer is called APR, you
        will call:</p>
    <p class="Pp"></p>
    <pre>
  open $fh, &quot;&gt;:APR&quot;, ...
    </pre>
    <p class="Pp">and Perl knows that it has to invoke the
        <b>PerlIOAPR_open()</b> method implemented by the APR layer.</p>
  </dd>
  <dt id="size"><a class="permalink" href="#size">size</a></dt>
  <dd>
    <pre>
        Size_t size;
    </pre>
    <p class="Pp">The size of the per-instance data structure, e.g.:</p>
    <p class="Pp"></p>
    <pre>
  sizeof(PerlIOAPR)
    </pre>
    <p class="Pp">If this field is zero then
        <span class="Li">&quot;PerlIO_pushed&quot;</span> does not malloc
        anything and assumes layer's Pushed function will do any required layer
        stack manipulation - used to avoid malloc/free overhead for dummy
        layers. If the field is non-zero it must be at least the size of
        <span class="Li">&quot;PerlIOl&quot;</span>,
        <span class="Li">&quot;PerlIO_pushed&quot;</span> will allocate memory
        for the layer's data structures and link new layer onto the stream's
        stack. (If the layer's Pushed method returns an error indication the
        layer is popped again.)</p>
  </dd>
  <dt id="kind"><a class="permalink" href="#kind">kind</a></dt>
  <dd>
    <pre>
        IV kind;
    </pre>
  </dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>PERLIO_K_BUFFERED
    <p class="Pp">The layer is buffered.</p>
  </li>
  <li>PERLIO_K_RAW
    <p class="Pp">The layer is acceptable to have in a binmode(FH) stack - i.e.
        it does not (or will configure itself not to) transform bytes passing
        through it.</p>
  </li>
  <li>PERLIO_K_CANCRLF
    <p class="Pp">Layer can translate between &quot;\n&quot; and CRLF line
      ends.</p>
  </li>
  <li>PERLIO_K_FASTGETS
    <p class="Pp">Layer allows buffer snooping.</p>
  </li>
  <li>PERLIO_K_MULTIARG
    <p class="Pp">Used when the layer's <b>open()</b> accepts more arguments
        than usual. The extra arguments should come not before the
        <span class="Li">&quot;MODE&quot;</span> argument. When this flag is
        used it's up to the layer to validate the args.</p>
  </li>
</ul>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt id="Pushed"><a class="permalink" href="#Pushed">Pushed</a></dt>
  <dd>
    <pre>
 IV     (*Pushed)(pTHX_ PerlIO *f,const char *mode, SV *arg);
    </pre>
    <p class="Pp">The only absolutely mandatory method. Called when the layer is
        pushed onto the stack. The <span class="Li">&quot;mode&quot;</span>
        argument may be NULL if this occurs post-open. The
        <span class="Li">&quot;arg&quot;</span> will be
        non-<span class="Li">&quot;NULL&quot;</span> if an argument string was
        passed. In most cases this should call
        <span class="Li">&quot;PerlIOBase_pushed()&quot;</span> to convert
        <span class="Li">&quot;mode&quot;</span> into the appropriate
        <span class="Li">&quot;PERLIO_F_XXXXX&quot;</span> flags in addition to
        any actions the layer itself takes. If a layer is not expecting an
        argument it need neither save the one passed to it, nor provide
        <span class="Li">&quot;Getarg()&quot;</span> (it could perhaps
        <span class="Li">&quot;Perl_warn&quot;</span> that the argument was
        un-expected).</p>
    <p class="Pp">Returns 0 on success. On failure returns -1 and should set
        errno.</p>
  </dd>
  <dt id="Popped"><a class="permalink" href="#Popped">Popped</a></dt>
  <dd>
    <pre>
        IV      (*Popped)(pTHX_ PerlIO *f);
    </pre>
    <p class="Pp">Called when the layer is popped from the stack. A layer will
        normally be popped after <span class="Li">&quot;Close()&quot;</span> is
        called. But a layer can be popped without being closed if the program is
        dynamically managing layers on the stream. In such cases
        <span class="Li">&quot;Popped()&quot;</span> should free any resources
        (buffers, translation tables, ...) not held directly in the layer's
        struct. It should also <span class="Li">&quot;Unread()&quot;</span> any
        unconsumed data that has been read and buffered from the layer below
        back to that layer, so that it can be re-provided to what ever is now
        above.</p>
    <p class="Pp">Returns 0 on success and failure. If
        <span class="Li">&quot;Popped()&quot;</span> returns <i>true</i> then
        <i>perlio.c</i> assumes that either the layer has popped itself, or the
        layer is super special and needs to be retained for other reasons. In
        most cases it should return <i>false</i>.</p>
  </dd>
  <dt id="Open"><a class="permalink" href="#Open">Open</a></dt>
  <dd>
    <pre>
        PerlIO *        (*Open)(...);
    </pre>
    <p class="Pp">The <span class="Li">&quot;Open()&quot;</span> method has lots
        of arguments because it combines the functions of perl's
        <span class="Li">&quot;open&quot;</span>,
        <span class="Li">&quot;PerlIO_open&quot;</span>, perl's
        <span class="Li">&quot;sysopen&quot;</span>,
        <span class="Li">&quot;PerlIO_fdopen&quot;</span> and
        <span class="Li">&quot;PerlIO_reopen&quot;</span>. The full prototype is
        as follows:</p>
    <p class="Pp"></p>
    <pre>
 PerlIO *       (*Open)(pTHX_ PerlIO_funcs *tab,
                        PerlIO_list_t *layers, IV n,
                        const char *mode,
                        int fd, int imode, int perm,
                        PerlIO *old,
                        int narg, SV **args);
    </pre>
    <p class="Pp">Open should (perhaps indirectly) call
        <span class="Li">&quot;PerlIO_allocate()&quot;</span> to allocate a slot
        in the table and associate it with the layers information for the opened
        file, by calling <span class="Li">&quot;PerlIO_push&quot;</span>. The
        <i>layers</i> is an array of all the layers destined for the
        <span class="Li">&quot;PerlIO *&quot;</span>, and any arguments passed
        to them, <i>n</i> is the index into that array of the layer being
        called. The macro <span class="Li">&quot;PerlIOArg&quot;</span> will
        return a (possibly <span class="Li">&quot;NULL&quot;</span>) SV * for
        the argument passed to the layer.</p>
    <p class="Pp">Where a layer opens or takes ownership of a file descriptor,
        that layer is responsible for getting the file descriptor's
        close-on-exec flag into the correct state. The flag should be clear for
        a file descriptor numbered less than or equal to
        <span class="Li">&quot;PL_maxsysfd&quot;</span>, and set for any file
        descriptor numbered higher. For thread safety, when a layer opens a new
        file descriptor it should if possible open it with the close-on-exec
        flag initially set.</p>
    <p class="Pp">The <i>mode</i> string is an
        &quot;<span class="Li">&quot;fopen()&quot;</span>-like&quot; string
        which would match the regular expression
        <span class="Li">&quot;/^[I#]?[rwa]\+?[bt]?$/&quot;</span>.</p>
    <p class="Pp">The <span class="Li">'I'</span> prefix is used during creation
        of
        <span class="Li">&quot;stdin&quot;</span>..<span class="Li">&quot;stderr&quot;</span>
        via special <span class="Li">&quot;PerlIO_fdopen&quot;</span> calls; the
        <span class="Li">'#'</span> prefix means that this is
        <span class="Li">&quot;sysopen&quot;</span> and that <i>imode</i> and
        <i>perm</i> should be passed to
        <span class="Li">&quot;PerlLIO_open3&quot;</span>;
        <span class="Li">'r'</span> means <b>r</b>ead,
        <span class="Li">'w'</span> means <b>w</b>rite and
        <span class="Li">'a'</span> means <b>a</b>ppend. The
        <span class="Li">'+'</span> suffix means that both reading and
        writing/appending are permitted. The <span class="Li">'b'</span> suffix
        means file should be binary, and <span class="Li">'t'</span> means it is
        text. (Almost all layers should do the IO in binary mode, and ignore the
        b/t bits. The <span class="Li">&quot;:crlf&quot;</span> layer should be
        pushed to handle the distinction.)</p>
    <p class="Pp">If <i>old</i> is not <span class="Li">&quot;NULL&quot;</span>
        then this is a <span class="Li">&quot;PerlIO_reopen&quot;</span>. Perl
        itself does not use this (yet?) and semantics are a little vague.</p>
    <p class="Pp">If <i>fd</i> not negative then it is the numeric file
        descriptor <i>fd</i>, which will be open in a manner compatible with the
        supplied mode string, the call is thus equivalent to
        <span class="Li">&quot;PerlIO_fdopen&quot;</span>. In this case
        <i>nargs</i> will be zero. The file descriptor may have the
        close-on-exec flag either set or clear; it is the responsibility of the
        layer that takes ownership of it to get the flag into the correct
      state.</p>
    <p class="Pp">If <i>nargs</i> is greater than zero then it gives the number
        of arguments passed to <span class="Li">&quot;open&quot;</span>,
        otherwise it will be 1 if for example
        <span class="Li">&quot;PerlIO_open&quot;</span> was called. In simple
        cases SvPV_nolen(*args) is the pathname to open.</p>
    <p class="Pp">If a layer provides <span class="Li">&quot;Open()&quot;</span>
        it should normally call the <span class="Li">&quot;Open()&quot;</span>
        method of next layer down (if any) and then push itself on top if that
        succeeds. <span class="Li">&quot;PerlIOBase_open&quot;</span> is
        provided to do exactly that, so in most cases you don't have to write
        your own <span class="Li">&quot;Open()&quot;</span> method. If this
        method is not defined, other layers may have difficulty pushing
        themselves on top of it during open.</p>
    <p class="Pp">If <span class="Li">&quot;PerlIO_push&quot;</span> was
        performed and open has failed, it must
        <span class="Li">&quot;PerlIO_pop&quot;</span> itself, since if it's
        not, the layer won't be removed and may cause bad problems.</p>
    <p class="Pp">Returns <span class="Li">&quot;NULL&quot;</span> on
      failure.</p>
  </dd>
  <dt id="Binmode"><a class="permalink" href="#Binmode">Binmode</a></dt>
  <dd>
    <pre>
        IV        (*Binmode)(pTHX_ PerlIO *f);
    </pre>
    <p class="Pp">Optional. Used when <span class="Li">&quot;:raw&quot;</span>
        layer is pushed (explicitly or as a result of binmode(FH)). If not
        present layer will be popped. If present should configure layer as
        binary (or pop itself) and return 0. If it returns -1 for error
        <span class="Li">&quot;binmode&quot;</span> will fail with layer still
        on the stack.</p>
  </dd>
  <dt id="Getarg"><a class="permalink" href="#Getarg">Getarg</a></dt>
  <dd>
    <pre>
        SV *      (*Getarg)(pTHX_ PerlIO *f,
                            CLONE_PARAMS *param, int flags);
    </pre>
    <p class="Pp">Optional. If present should return an SV * representing the
        string argument passed to the layer when it was pushed. e.g.
        &quot;:encoding(ascii)&quot; would return an SvPV with value
        &quot;ascii&quot;. (<i>param</i> and <i>flags</i> arguments can be
        ignored in most cases)</p>
    <p class="Pp"><span class="Li">&quot;Dup&quot;</span> uses
        <span class="Li">&quot;Getarg&quot;</span> to retrieve the argument
        originally passed to <span class="Li">&quot;Pushed&quot;</span>, so you
        must implement this function if your layer has an extra argument to
        <span class="Li">&quot;Pushed&quot;</span> and will ever be
        <span class="Li">&quot;Dup&quot;</span>ed.</p>
  </dd>
  <dt id="Fileno"><a class="permalink" href="#Fileno">Fileno</a></dt>
  <dd>
    <pre>
        IV        (*Fileno)(pTHX_ PerlIO *f);
    </pre>
    <p class="Pp">Returns the Unix/Posix numeric file descriptor for the handle.
        Normally <span class="Li">&quot;PerlIOBase_fileno()&quot;</span> (which
        just asks next layer down) will suffice for this.</p>
    <p class="Pp">Returns -1 on error, which is considered to include the case
        where the layer cannot provide such a file descriptor.</p>
  </dd>
  <dt id="Dup"><a class="permalink" href="#Dup">Dup</a></dt>
  <dd>
    <pre>
        PerlIO * (*Dup)(pTHX_ PerlIO *f, PerlIO *o,
                        CLONE_PARAMS *param, int flags);
    </pre>
    <p class="Pp">XXX: Needs more docs.</p>
    <p class="Pp">Used as part of the &quot;clone&quot; process when a thread is
        spawned (in which case param will be non-NULL) and when a stream is
        being duplicated via '&amp;' in the
        <span class="Li">&quot;open&quot;</span>.</p>
    <p class="Pp">Similar to <span class="Li">&quot;Open&quot;</span>, returns
        PerlIO* on success, <span class="Li">&quot;NULL&quot;</span> on
      failure.</p>
  </dd>
  <dt id="Read"><a class="permalink" href="#Read">Read</a></dt>
  <dd>
    <pre>
        SSize_t (*Read)(pTHX_ PerlIO *f, void *vbuf, Size_t count);
    </pre>
    <p class="Pp">Basic read operation.</p>
    <p class="Pp">Typically will call <span class="Li">&quot;Fill&quot;</span>
        and manipulate pointers (possibly via the API).
        <span class="Li">&quot;PerlIOBuf_read()&quot;</span> may be suitable for
        derived classes which provide &quot;fast gets&quot; methods.</p>
    <p class="Pp">Returns actual bytes read, or -1 on an error.</p>
  </dd>
  <dt id="Unread"><a class="permalink" href="#Unread">Unread</a></dt>
  <dd>
    <pre>
        SSize_t (*Unread)(pTHX_ PerlIO *f,
                          const void *vbuf, Size_t count);
    </pre>
    <p class="Pp">A superset of stdio's
        <span class="Li">&quot;ungetc()&quot;</span>. Should arrange for future
        reads to see the bytes in <span class="Li">&quot;vbuf&quot;</span>. If
        there is no obviously better implementation then
        <span class="Li">&quot;PerlIOBase_unread()&quot;</span> provides the
        function by pushing a &quot;fake&quot; &quot;pending&quot; layer above
        the calling layer.</p>
    <p class="Pp">Returns the number of unread chars.</p>
  </dd>
  <dt id="Write"><a class="permalink" href="#Write">Write</a></dt>
  <dd>
    <pre>
        SSize_t (*Write)(PerlIO *f, const void *vbuf, Size_t count);
    </pre>
    <p class="Pp">Basic write operation.</p>
    <p class="Pp">Returns bytes written or -1 on an error.</p>
  </dd>
  <dt id="Seek"><a class="permalink" href="#Seek">Seek</a></dt>
  <dd>
    <pre>
        IV      (*Seek)(pTHX_ PerlIO *f, Off_t offset, int whence);
    </pre>
    <p class="Pp">Position the file pointer. Should normally call its own
        <span class="Li">&quot;Flush&quot;</span> method and then the
        <span class="Li">&quot;Seek&quot;</span> method of next layer down.</p>
    <p class="Pp">Returns 0 on success, -1 on failure.</p>
  </dd>
  <dt id="Tell"><a class="permalink" href="#Tell">Tell</a></dt>
  <dd>
    <pre>
        Off_t   (*Tell)(pTHX_ PerlIO *f);
    </pre>
    <p class="Pp">Return the file pointer. May be based on layers cached concept
        of position to avoid overhead.</p>
    <p class="Pp">Returns -1 on failure to get the file pointer.</p>
  </dd>
  <dt id="Close"><a class="permalink" href="#Close">Close</a></dt>
  <dd>
    <pre>
        IV      (*Close)(pTHX_ PerlIO *f);
    </pre>
    <p class="Pp">Close the stream. Should normally call
        <span class="Li">&quot;PerlIOBase_close()&quot;</span> to flush itself
        and close layers below, and then deallocate any data structures
        (buffers, translation tables, ...) not held directly in the data
        structure.</p>
    <p class="Pp">Returns 0 on success, -1 on failure.</p>
  </dd>
  <dt id="Flush"><a class="permalink" href="#Flush">Flush</a></dt>
  <dd>
    <pre>
        IV      (*Flush)(pTHX_ PerlIO *f);
    </pre>
    <p class="Pp">Should make stream's state consistent with layers below. That
        is, any buffered write data should be written, and file position of
        lower layers adjusted for data read from below but not actually
        consumed. (Should perhaps <span class="Li">&quot;Unread()&quot;</span>
        such data to the lower layer.)</p>
    <p class="Pp">Returns 0 on success, -1 on failure.</p>
  </dd>
  <dt id="Fill"><a class="permalink" href="#Fill">Fill</a></dt>
  <dd>
    <pre>
        IV      (*Fill)(pTHX_ PerlIO *f);
    </pre>
    <p class="Pp">The buffer for this layer should be filled (for read) from
        layer below. When you &quot;subclass&quot; PerlIOBuf layer, you want to
        use its <i>_read</i> method and to supply your own fill method, which
        fills the PerlIOBuf's buffer.</p>
    <p class="Pp">Returns 0 on success, -1 on failure.</p>
  </dd>
  <dt id="Eof"><a class="permalink" href="#Eof">Eof</a></dt>
  <dd>
    <pre>
        IV      (*Eof)(pTHX_ PerlIO *f);
    </pre>
    <p class="Pp">Return end-of-file indicator.
        <span class="Li">&quot;PerlIOBase_eof()&quot;</span> is normally
        sufficient.</p>
    <p class="Pp">Returns 0 on end-of-file, 1 if not end-of-file, -1 on
      error.</p>
  </dd>
  <dt id="Error"><a class="permalink" href="#Error">Error</a></dt>
  <dd>
    <pre>
        IV      (*Error)(pTHX_ PerlIO *f);
    </pre>
    <p class="Pp">Return error indicator.
        <span class="Li">&quot;PerlIOBase_error()&quot;</span> is normally
        sufficient.</p>
    <p class="Pp">Returns 1 if there is an error (usually when
        <span class="Li">&quot;PERLIO_F_ERROR&quot;</span> is set), 0
      otherwise.</p>
  </dd>
  <dt id="Clearerr"><a class="permalink" href="#Clearerr">Clearerr</a></dt>
  <dd>
    <pre>
        void    (*Clearerr)(pTHX_ PerlIO *f);
    </pre>
    <p class="Pp">Clear end-of-file and error indicators. Should call
        <span class="Li">&quot;PerlIOBase_clearerr()&quot;</span> to set the
        <span class="Li">&quot;PERLIO_F_XXXXX&quot;</span> flags, which may
        suffice.</p>
  </dd>
  <dt id="Setlinebuf"><a class="permalink" href="#Setlinebuf">Setlinebuf</a></dt>
  <dd>
    <pre>
        void    (*Setlinebuf)(pTHX_ PerlIO *f);
    </pre>
    <p class="Pp">Mark the stream as line buffered.
        <span class="Li">&quot;PerlIOBase_setlinebuf()&quot;</span> sets the
        PERLIO_F_LINEBUF flag and is normally sufficient.</p>
  </dd>
  <dt id="Get_base"><a class="permalink" href="#Get_base">Get_base</a></dt>
  <dd>
    <pre>
        STDCHAR *       (*Get_base)(pTHX_ PerlIO *f);
    </pre>
    <p class="Pp">Allocate (if not already done so) the read buffer for this
        layer and return pointer to it. Return NULL on failure.</p>
  </dd>
  <dt id="Get_bufsiz"><a class="permalink" href="#Get_bufsiz">Get_bufsiz</a></dt>
  <dd>
    <pre>
        Size_t  (*Get_bufsiz)(pTHX_ PerlIO *f);
    </pre>
    <p class="Pp">Return the number of bytes that last
        <span class="Li">&quot;Fill()&quot;</span> put in the buffer.</p>
  </dd>
  <dt id="Get_ptr"><a class="permalink" href="#Get_ptr">Get_ptr</a></dt>
  <dd>
    <pre>
        STDCHAR *       (*Get_ptr)(pTHX_ PerlIO *f);
    </pre>
    <p class="Pp">Return the current read pointer relative to this layer's
        buffer.</p>
  </dd>
  <dt id="Get_cnt"><a class="permalink" href="#Get_cnt">Get_cnt</a></dt>
  <dd>
    <pre>
        SSize_t (*Get_cnt)(pTHX_ PerlIO *f);
    </pre>
    <p class="Pp">Return the number of bytes left to be read in the current
        buffer.</p>
  </dd>
  <dt id="Set_ptrcnt"><a class="permalink" href="#Set_ptrcnt">Set_ptrcnt</a></dt>
  <dd>
    <pre>
        void    (*Set_ptrcnt)(pTHX_ PerlIO *f,
                              STDCHAR *ptr, SSize_t cnt);
    </pre>
    <p class="Pp">Adjust the read pointer and count of bytes to match
        <span class="Li">&quot;ptr&quot;</span> and/or
        <span class="Li">&quot;cnt&quot;</span>. The application (or layer
        above) must ensure they are consistent. (Checking is allowed by the
        paranoid.)</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Utilities"><a class="permalink" href="#Utilities">Utilities</a></h2>
<p class="Pp">To ask for the next layer down use PerlIONext(PerlIO *f).</p>
<p class="Pp">To check that a PerlIO* is valid use PerlIOValid(PerlIO *f). (All
    this does is really just to check that the pointer is non-NULL and that the
    pointer behind that is non-NULL.)</p>
<p class="Pp">PerlIOBase(PerlIO *f) returns the &quot;Base&quot; pointer, or in
    other words, the <span class="Li">&quot;PerlIOl*&quot;</span> pointer.</p>
<p class="Pp">PerlIOSelf(PerlIO* f, type) return the PerlIOBase cast to a
  type.</p>
<p class="Pp">Perl_PerlIO_or_Base(PerlIO* f, callback, base, failure, args)
    either calls the <i>callback</i> from the functions of the layer <i>f</i>
    (just by the name of the IO function, like &quot;Read&quot;) with the
    <i>args</i>, or if there is no such callback, calls the <i>base</i> version
    of the callback with the same args, or if the f is invalid, set errno to
    EBADF and return <i>failure</i>.</p>
<p class="Pp">Perl_PerlIO_or_fail(PerlIO* f, callback, failure, args) either
    calls the <i>callback</i> of the functions of the layer <i>f</i> with the
    <i>args</i>, or if there is no such callback, set errno to EINVAL. Or if the
    f is invalid, set errno to EBADF and return <i>failure</i>.</p>
<p class="Pp">Perl_PerlIO_or_Base_void(PerlIO* f, callback, base, args) either
    calls the <i>callback</i> of the functions of the layer <i>f</i> with the
    <i>args</i>, or if there is no such callback, calls the <i>base</i> version
    of the callback with the same args, or if the f is invalid, set errno to
    EBADF.</p>
<p class="Pp">Perl_PerlIO_or_fail_void(PerlIO* f, callback, args) either calls
    the <i>callback</i> of the functions of the layer <i>f</i> with the
    <i>args</i>, or if there is no such callback, set errno to EINVAL. Or if the
    f is invalid, set errno to EBADF.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Implementing_PerlIO_Layers"><a class="permalink" href="#Implementing_PerlIO_Layers">Implementing
  PerlIO Layers</a></h2>
<p class="Pp">If you find the implementation document unclear or not sufficient,
    look at the existing PerlIO layer implementations, which include:</p>
<ul class="Bl-bullet">
  <li>C implementations
    <p class="Pp">The <i>perlio.c</i> and <i>perliol.h</i> in the Perl core
        implement the &quot;unix&quot;, &quot;perlio&quot;, &quot;stdio&quot;,
        &quot;crlf&quot;, &quot;utf8&quot;, &quot;byte&quot;, &quot;raw&quot;,
        &quot;pending&quot; layers, and also the &quot;mmap&quot; and
        &quot;win32&quot; layers if applicable. (The &quot;win32&quot; is
        currently unfinished and unused, to see what is used instead in Win32,
        see &quot;Querying the layers of filehandles&quot; in PerlIO .)</p>
    <p class="Pp">PerlIO::encoding, PerlIO::scalar, PerlIO::via in the Perl
        core.</p>
    <p class="Pp">PerlIO::gzip and APR::PerlIO (mod_perl 2.0) on CPAN.</p>
  </li>
  <li>Perl implementations
    <p class="Pp">PerlIO::via::QuotedPrint in the Perl core and PerlIO::via::*
        on CPAN.</p>
  </li>
</ul>
<p class="Pp">If you are creating a PerlIO layer, you may want to be lazy, in
    other words, implement only the methods that interest you. The other methods
    you can either replace with the &quot;blank&quot; methods</p>
<p class="Pp"></p>
<pre>
    PerlIOBase_noop_ok
    PerlIOBase_noop_fail
</pre>
<p class="Pp">(which do nothing, and return zero and -1, respectively) or for
    certain methods you may assume a default behaviour by using a NULL method.
    The Open method looks for help in the 'parent' layer. The following table
    summarizes the behaviour:</p>
<p class="Pp"></p>
<pre>
    method      behaviour with NULL

    Clearerr    PerlIOBase_clearerr
    Close       PerlIOBase_close
    Dup         PerlIOBase_dup
    Eof         PerlIOBase_eof
    Error       PerlIOBase_error
    Fileno      PerlIOBase_fileno
    Fill        FAILURE
    Flush       SUCCESS
    Getarg      SUCCESS
    Get_base    FAILURE
    Get_bufsiz  FAILURE
    Get_cnt     FAILURE
    Get_ptr     FAILURE
    Open        INHERITED
    Popped      SUCCESS
    Pushed      SUCCESS
    Read        PerlIOBase_read
    Seek        FAILURE
    Set_cnt     FAILURE
    Set_ptrcnt  FAILURE
    Setlinebuf  PerlIOBase_setlinebuf
    Tell        FAILURE
    Unread      PerlIOBase_unread
    Write       FAILURE

 FAILURE        Set errno (to EINVAL in Unixish, to LIB$_INVARG in VMS)
                and return -1 (for numeric return values) or NULL (for
                pointers)
 INHERITED      Inherited from the layer below
 SUCCESS        Return 0 (for numeric return values) or a pointer
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Core_Layers"><a class="permalink" href="#Core_Layers">Core
  Layers</a></h2>
<p class="Pp">The file <span class="Li">&quot;perlio.c&quot;</span> provides the
    following layers:</p>
<dl class="Bl-tag">
  <dt>&quot;unix&quot;</dt>
  <dd>A basic non-buffered layer which calls Unix/POSIX
      <span class="Li">&quot;read()&quot;</span>,
      <span class="Li">&quot;write()&quot;</span>,
      <span class="Li">&quot;lseek()&quot;</span>,
      <span class="Li">&quot;close()&quot;</span>. No buffering. Even on
      platforms that distinguish between O_TEXT and O_BINARY this layer is
      always O_BINARY.</dd>
  <dt>&quot;perlio&quot;</dt>
  <dd>A very complete generic buffering layer which provides the whole of PerlIO
      API. It is also intended to be used as a &quot;base class&quot; for other
      layers. (For example its <span class="Li">&quot;Read()&quot;</span> method
      is implemented in terms of the
      <span class="Li">&quot;Get_cnt()&quot;</span>/<span class="Li">&quot;Get_ptr()&quot;</span>/<span class="Li">&quot;Set_ptrcnt()&quot;</span>
      methods).
    <p class="Pp">&quot;perlio&quot; over &quot;unix&quot; provides a complete
        replacement for stdio as seen via PerlIO API. This is the default for
        USE_PERLIO when system's stdio does not permit perl's &quot;fast
        gets&quot; access, and which do not distinguish between
        <span class="Li">&quot;O_TEXT&quot;</span> and
        <span class="Li">&quot;O_BINARY&quot;</span>.</p>
  </dd>
  <dt>&quot;stdio&quot;</dt>
  <dd>A layer which provides the PerlIO API via the layer scheme, but implements
      it by calling system's stdio. This is (currently) the default if system's
      stdio provides sufficient access to allow perl's &quot;fast gets&quot;
      access and which do not distinguish between
      <span class="Li">&quot;O_TEXT&quot;</span> and
      <span class="Li">&quot;O_BINARY&quot;</span>.</dd>
  <dt>&quot;crlf&quot;</dt>
  <dd>A layer derived using &quot;perlio&quot; as a base class. It provides
      Win32-like &quot;\n&quot; to CR,LF translation. Can either be applied
      above &quot;perlio&quot; or serve as the buffer layer itself.
      &quot;crlf&quot; over &quot;unix&quot; is the default if system
      distinguishes between <span class="Li">&quot;O_TEXT&quot;</span> and
      <span class="Li">&quot;O_BINARY&quot;</span> opens. (At some point
      &quot;unix&quot; will be replaced by a &quot;native&quot; Win32 IO layer
      on that platform, as Win32's read/write layer has various drawbacks.) The
      &quot;crlf&quot; layer is a reasonable model for a layer which transforms
      data in some way.</dd>
  <dt>&quot;mmap&quot;</dt>
  <dd>If Configure detects <span class="Li">&quot;mmap()&quot;</span> functions
      this layer is provided (with &quot;perlio&quot; as a &quot;base&quot;)
      which does &quot;read&quot; operations by <b>mmap()</b>ing the file.
      Performance improvement is marginal on modern systems, so it is mainly
      there as a proof of concept. It is likely to be unbundled from the core at
      some point. The &quot;mmap&quot; layer is a reasonable model for a
      minimalist &quot;derived&quot; layer.</dd>
  <dt>&quot;pending&quot;</dt>
  <dd>An &quot;internal&quot; derivative of &quot;perlio&quot; which can be used
      to provide <b>Unread()</b> function for layers which have no buffer or
      cannot be bothered. (Basically this layer's
      <span class="Li">&quot;Fill()&quot;</span> pops itself off the stack and
      so resumes reading from layer below.)</dd>
  <dt>&quot;raw&quot;</dt>
  <dd>A dummy layer which never exists on the layer stack. Instead when
      &quot;pushed&quot; it actually pops the stack removing itself, it then
      calls Binmode function table entry on all the layers in the stack -
      normally this (via PerlIOBase_binmode) removes any layers which do not
      have <span class="Li">&quot;PERLIO_K_RAW&quot;</span> bit set. Layers can
      modify that behaviour by defining their own Binmode entry.</dd>
  <dt>&quot;utf8&quot;</dt>
  <dd>Another dummy layer. When pushed it pops itself and sets the
      <span class="Li">&quot;PERLIO_F_UTF8&quot;</span> flag on the layer which
      was (and now is once more) the top of the stack.</dd>
</dl>
<p class="Pp">In addition <i>perlio.c</i> also provides a number of
    <span class="Li">&quot;PerlIOBase_xxxx()&quot;</span> functions which are
    intended to be used in the table slots of classes which do not need to do
    anything special for a particular method.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Extension_Layers"><a class="permalink" href="#Extension_Layers">Extension
  Layers</a></h2>
<p class="Pp">Layers can be made available by extension modules. When an unknown
    layer is encountered the PerlIO code will perform the equivalent of :</p>
<p class="Pp"></p>
<pre>
   use PerlIO 'layer';
</pre>
<p class="Pp">Where <i>layer</i> is the unknown layer. <i>PerlIO.pm</i> will
    then attempt to:</p>
<p class="Pp"></p>
<pre>
   require PerlIO::layer;
</pre>
<p class="Pp">If after that process the layer is still not defined then the
    <span class="Li">&quot;open&quot;</span> will fail.</p>
<p class="Pp">The following extension layers are bundled with perl:</p>
<dl class="Bl-tag">
  <dt>&quot;:encoding&quot;</dt>
  <dd>
    <pre>
   use Encoding;
    </pre>
    <p class="Pp">makes this layer available, although <i>PerlIO.pm</i>
        &quot;knows&quot; where to find it. It is an example of a layer which
        takes an argument as it is called thus:</p>
    <p class="Pp"></p>
    <pre>
   open( $fh, &quot;&lt;:encoding(iso-8859-7)&quot;, $pathname );
    </pre>
  </dd>
  <dt>&quot;:scalar&quot;</dt>
  <dd>Provides support for reading data from and writing data to a scalar.
    <p class="Pp"></p>
    <pre>
   open( $fh, &quot;+&lt;:scalar&quot;, \$scalar );
    </pre>
    <p class="Pp">When a handle is so opened, then reads get bytes from the
        string value of <i></i><i>$scalar</i><i></i>, and writes change the
        value. In both cases the position in <i></i><i>$scalar</i><i></i> starts
        as zero but can be altered via <span class="Li">&quot;seek&quot;</span>,
        and determined via <span class="Li">&quot;tell&quot;</span>.</p>
    <p class="Pp">Please note that this layer is implied when calling
        <b>open()</b> thus:</p>
    <p class="Pp"></p>
    <pre>
   open( $fh, &quot;+&lt;&quot;, \$scalar );
    </pre>
  </dd>
  <dt>&quot;:via&quot;</dt>
  <dd>Provided to allow layers to be implemented as Perl code. For instance:
    <p class="Pp"></p>
    <pre>
   use PerlIO::via::StripHTML;
   open( my $fh, &quot;&lt;:via(StripHTML)&quot;, &quot;index.html&quot; );
    </pre>
    <p class="Pp">See PerlIO::via for details.</p>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TODO"><a class="permalink" href="#TODO">TODO</a></h1>
<p class="Pp">Things that need to be done to improve this document.</p>
<ul class="Bl-bullet">
  <li>Explain how to make a valid fh without going through <b>open()</b>(i.e.
      apply a layer). For example if the file is not opened through perl, but we
      want to get back a fh, like it was opened by Perl.
    <p class="Pp">How PerlIO_apply_layera fits in, where its docs, was it made
        public?</p>
    <p class="Pp">Currently the example could be something like this:</p>
    <p class="Pp"></p>
    <pre>
  PerlIO *foo_to_PerlIO(pTHX_ char *mode, ...)
  {
      char *mode; /* &quot;w&quot;, &quot;r&quot;, etc */
      const char *layers = &quot;:APR&quot;; /* the layer name */
      PerlIO *f = PerlIO_allocate(aTHX);
      if (!f) {
          return NULL;
      }

      PerlIO_apply_layers(aTHX_ f, mode, layers);

      if (f) {
          PerlIOAPR *st = PerlIOSelf(f, PerlIOAPR);
          /* fill in the st struct, as in _open() */
          st-&gt;file = file;
          PerlIOBase(f)-&gt;flags |= PERLIO_F_OPEN;

          return f;
      }
      return NULL;
  }
    </pre>
  </li>
  <li>fix/add the documentation in places marked as XXX.</li>
  <li>The handling of errors by the layer is not specified. e.g. when $! should
      be set explicitly, when the error handling should be just delegated to the
      top layer.
    <p class="Pp">Probably give some hints on using <b>SETERRNO()</b> or
        pointers to where they can be found.</p>
  </li>
  <li>I think it would help to give some concrete examples to make it easier to
      understand the API. Of course I agree that the API has to be concise, but
      since there is no second document that is more of a guide, I think that
      it'd make it easier to start with the doc which is an API, but has
      examples in it in places where things are unclear, to a person who is not
      a PerlIO guru (yet).</li>
</ul>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

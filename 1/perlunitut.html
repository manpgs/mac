<!DOCTYPE html>
<html lang="en">
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PERLUNITUT(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLUNITUT(1)</td>
    <td class="head-vol"><a href=".">Perl Programmers Reference Guide</a></td>
    <td class="head-rtitle">PERLUNITUT(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perlunitut - Perl Unicode Tutorial</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The days of just flinging strings around are over. It's well
    established that modern programs need to be capable of communicating funny
    accented letters, and things like euro symbols. This means that programmers
    need new habits. It's easy to program Unicode capable software, but it does
    require discipline to do it right.</p>
<p class="Pp">There's a lot to know about character sets, and text encodings.
    It's probably best to spend a full day learning all this, but the basics can
    be learned in minutes.</p>
<p class="Pp">These are not the very basics, though. It is assumed that you
    already know the difference between bytes and characters, and realise (and
    accept!) that there are many different character sets and encodings, and
    that your program has to be explicit about them. Recommended reading is
    &quot;The Absolute Minimum Every Software Developer Absolutely, Positively
    Must Know About Unicode and Character Sets (No Excuses!)&quot; by Joel
    Spolsky, at &lt;http://joelonsoftware.com/articles/Unicode.html&gt;.</p>
<p class="Pp">This tutorial speaks in rather absolute terms, and provides only a
    limited view of the wealth of character string related features that Perl
    has to offer. For most projects, this information will probably suffice.</p>
<section class="Ss">
<h2 class="Ss" id="Definitions"><a class="permalink" href="#Definitions">Definitions</a></h2>
<p class="Pp">It's important to set a few things straight first. This is the
    most important part of this tutorial. This view may conflict with other
    information that you may have found on the web, but that's mostly because
    many sources are wrong.</p>
<p class="Pp">You may have to re-read this entire section a few times...</p>
<p class="Pp"><i>Unicode</i></p>
<p class="Pp"><b>Unicode</b> is a character set with room for lots of
    characters. The ordinal value of a character is called a <b>code point</b>.
    (But in practice, the distinction between code point and character is
    blurred, so the terms often are used interchangeably.)</p>
<p class="Pp">There are many, many code points, but computers work with bytes,
    and a byte has room for only 256 values. Unicode has many more characters
    than that, so you need a method to make these accessible.</p>
<p class="Pp">Unicode is encoded using several competing encodings, of which
    UTF-8 is the most used. In a Unicode encoding, multiple subsequent bytes can
    be used to store a single code point, or simply: character.</p>
<p class="Pp"><i>UTF-8</i></p>
<p class="Pp"><b>UTF-8</b> is a Unicode encoding. Many people think that Unicode
    and UTF-8 are the same thing, but they're not. There are more Unicode
    encodings, but much of the world has standardized on UTF-8.</p>
<p class="Pp">UTF-8 treats the first 128 codepoints, 0..127, the same as ASCII.
    They take only one byte per character. All other characters are encoded as
    two to four bytes using a complex scheme. Fortunately, Perl handles this for
    us, so we don't have to worry about this.</p>
<p class="Pp"><i>Text strings (character strings)</i></p>
<p class="Pp"><b>Text strings</b>, or <b>character strings</b> are made of
    characters. Bytes are irrelevant here, and so are encodings. Each character
    is just that: the character.</p>
<p class="Pp">On a text string, you would do things like:</p>
<p class="Pp"></p>
<pre>    $text =~ s/foo/bar/;
    if ($string =~ /^\d+$/) { ... }
    $text = ucfirst $text;
    my $character_count = length $text;
</pre>
<p class="Pp">The value of a character (<span class="Li">&quot;ord&quot;</span>,
    <span class="Li">&quot;chr&quot;</span>) is the corresponding Unicode code
    point.</p>
<p class="Pp"><i>Binary strings (byte strings)</i></p>
<p class="Pp"><b>Binary strings</b>, or <b>byte strings</b> are made of bytes.
    Here, you don't have characters, just bytes. All communication with the
    outside world (anything outside of your current Perl process) is done in
    binary.</p>
<p class="Pp">On a binary string, you would do things like:</p>
<p class="Pp"></p>
<pre>    my (@length_content) = unpack &quot;(V/a)*&quot;, $binary;
    $binary =~ s/\x00\x0F/\xFF\xF0/;  # for the brave :)
    print {$fh} $binary;
    my $byte_count = length $binary;
</pre>
<p class="Pp"><i>Encoding</i></p>
<p class="Pp"><b>Encoding</b> (as a verb) is the conversion from <i>text</i> to
    <i>binary</i>. To encode, you have to supply the target encoding, for
    example <span class="Li">&quot;iso-8859-1&quot;</span> or
    <span class="Li">&quot;UTF-8&quot;</span>. Some encodings, like the
    <span class="Li">&quot;iso-8859&quot;</span> (&quot;latin&quot;) range, do
    not support the full Unicode standard; characters that can't be represented
    are lost in the conversion.</p>
<p class="Pp"><i>Decoding</i></p>
<p class="Pp"><b>Decoding</b> is the conversion from <i>binary</i> to
    <i>text</i>. To decode, you have to know what encoding was used during the
    encoding phase. And most of all, it must be something decodable. It doesn't
    make much sense to decode a PNG image into a text string.</p>
<p class="Pp"><i>Internal format</i></p>
<p class="Pp">Perl has an <b>internal format</b>, an encoding that it uses to
    encode text strings so it can store them in memory. All text strings are in
    this internal format. In fact, text strings are never in any other
  format!</p>
<p class="Pp">You shouldn't worry about what this format is, because conversion
    is automatically done when you decode or encode.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Your_new_toolkit"><a class="permalink" href="#Your_new_toolkit">Your
  new toolkit</a></h2>
<p class="Pp">Add to your standard heading the following line:</p>
<p class="Pp"></p>
<pre>    use Encode qw(encode decode);
</pre>
<p class="Pp">Or, if you're lazy, just:</p>
<p class="Pp"></p>
<pre>    use Encode;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="I/O_flow_(the_actual_5_minute_tutorial)"><a class="permalink" href="#I/O_flow_(the_actual_5_minute_tutorial)">I/O
  flow (the actual 5 minute tutorial)</a></h2>
<p class="Pp">The typical input/output flow of a program is:</p>
<p class="Pp"></p>
<pre>    1. Receive and decode
    2. Process
    3. Encode and output
</pre>
<p class="Pp">If your input is binary, and is supposed to remain binary, you
    shouldn't decode it to a text string, of course. But in all other cases, you
    should decode it.</p>
<p class="Pp">Decoding can't happen reliably if you don't know how the data was
    encoded. If you get to choose, it's a good idea to standardize on UTF-8.</p>
<p class="Pp"></p>
<pre>    my $foo   = decode('UTF-8', get 'http://example.com/');
    my $bar   = decode('ISO-8859-1', readline STDIN);
    my $xyzzy = decode('Windows-1251', $cgi-&gt;param('foo'));
</pre>
<p class="Pp">Processing happens as you knew before. The only difference is that
    you're now using characters instead of bytes. That's very useful if you use
    things like <span class="Li">&quot;substr&quot;</span>, or
    <span class="Li">&quot;length&quot;</span>.</p>
<p class="Pp">It's important to realize that there are no bytes in a text
    string. Of course, Perl has its internal encoding to store the string in
    memory, but ignore that. If you have to do anything with the number of
    bytes, it's probably best to move that part to step 3, just after you've
    encoded the string. Then you know exactly how many bytes it will be in the
    destination string.</p>
<p class="Pp">The syntax for encoding text strings to binary strings is as
    simple as decoding:</p>
<p class="Pp"></p>
<pre>    $body = encode('UTF-8', $body);
</pre>
<p class="Pp">If you needed to know the length of the string in bytes, now's the
    perfect time for that. Because <span class="Li">$body</span> is now a byte
    string, <span class="Li">&quot;length&quot;</span> will report the number of
    bytes, instead of the number of characters. The number of characters is no
    longer known, because characters only exist in text strings.</p>
<p class="Pp"></p>
<pre>    my $byte_count = length $body;
</pre>
<p class="Pp">And if the protocol you're using supports a way of letting the
    recipient know which character encoding you used, please help the receiving
    end by using that feature! For example, E-mail and HTTP support MIME
    headers, so you can use the <span class="Li">&quot;Content-Type&quot;</span>
    header. They can also have
    <span class="Li">&quot;Content-Length&quot;</span> to indicate the number of
    <i>bytes</i>, which is always a good idea to supply if the number is
  known.</p>
<p class="Pp"></p>
<pre>    &quot;Content-Type: text/plain; charset=UTF-8&quot;,
    &quot;Content-Length: $byte_count&quot;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SUMMARY"><a class="permalink" href="#SUMMARY">SUMMARY</a></h1>
<p class="Pp">Decode everything you receive, encode everything you send out. (If
    it's text data.)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Q_and_A_(or_FAQ)"><a class="permalink" href="#Q_and_A_(or_FAQ)">Q
  and A (or FAQ)</a></h1>
<p class="Pp">After reading this document, you ought to read perlunifaq too,
    then perluniintro.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGEMENTS"><a class="permalink" href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></h1>
<p class="Pp">Thanks to Johan Vromans from Squirrel Consultancy. His UTF-8 rants
    during the Amsterdam Perl Mongers meetings got me interested and determined
    to find out how to use character encodings in Perl in ways that don't break
    easily.</p>
<p class="Pp">Thanks to Gerard Goossen from TTY. His presentation &quot;UTF-8 in
    the wild&quot; (Dutch Perl Workshop 2006) inspired me to publish my thoughts
    and write this tutorial.</p>
<p class="Pp">Thanks to the people who asked about this kind of stuff in several
    Perl IRC channels, and have constantly reminded me that a simpler
    explanation was needed.</p>
<p class="Pp">Thanks to the people who reviewed this document for me, before it
    went public. They are: Benjamin Smith, Jan-Pieter Cornet, Johan Vromans,
    Lukas Mai, Nathan Gray.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Juerd Waalboer &lt;#####@juerd.nl&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">perlunifaq, perlunicode, perluniintro, Encode</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2022-02-19</td>
    <td class="foot-os"><a href="..">perl v5.34.1</a></td>
  </tr>
</table>
</body>
</html>

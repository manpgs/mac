<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>PERLTIE(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLTIE(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLTIE(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perltie - how to hide an object class in a simple variable</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre> tie VARIABLE, CLASSNAME, LIST
 $object = tied VARIABLE
 untie VARIABLE
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Prior to release 5.0 of Perl, a programmer could use
    <b>dbmopen()</b> to connect an on-disk database in the standard Unix
    <b>dbm</b>(3x) format magically to a <span class="Li">%HASH</span> in their
    program. However, their Perl was either built with one particular dbm
    library or another, but not both, and you couldn't extend this mechanism to
    other packages or types of variables.</p>
<p class="Pp">Now you can.</p>
<p class="Pp">The <b>tie()</b> function binds a variable to a class (package)
    that will provide the implementation for access methods for that variable.
    Once this magic has been performed, accessing a tied variable automatically
    triggers method calls in the proper class. The complexity of the class is
    hidden behind magic methods calls. The method names are in ALL CAPS, which
    is a convention that Perl uses to indicate that they're called implicitly
    rather than explicitly--just like the <b>BEGIN()</b> and <b>END()</b>
    functions.</p>
<p class="Pp">In the <b>tie()</b> call,
    <span class="Li">&quot;VARIABLE&quot;</span> is the name of the variable to
    be enchanted. <span class="Li">&quot;CLASSNAME&quot;</span> is the name of a
    class implementing objects of the correct type. Any additional arguments in
    the <span class="Li">&quot;LIST&quot;</span> are passed to the appropriate
    constructor method for that class--meaning <b>TIESCALAR()</b>,
    <b>TIEARRAY()</b>, <b>TIEHASH()</b>, or <b>TIEHANDLE()</b>. (Typically these
    are arguments such as might be passed to the <b>dbminit()</b> function of
    C.) The object returned by the &quot;new&quot; method is also returned by
    the <b>tie()</b> function, which would be useful if you wanted to access
    other methods in <span class="Li">&quot;CLASSNAME&quot;</span>. (You don't
    actually have to return a reference to a right &quot;type&quot; (e.g., HASH
    or <span class="Li">&quot;CLASSNAME&quot;</span>) so long as it's a properly
    blessed object.) You can also retrieve a reference to the underlying object
    using the <b>tied()</b> function.</p>
<p class="Pp">Unlike <b>dbmopen()</b>, the <b>tie()</b> function will not
    <span class="Li">&quot;use&quot;</span> or
    <span class="Li">&quot;require&quot;</span> a module for you--you need to do
    that explicitly yourself.</p>
<section class="Ss">
<h2 class="Ss" id="Tying_Scalars"><a class="permalink" href="#Tying_Scalars">Tying
  Scalars</a></h2>
<p class="Pp">A class implementing a tied scalar should define the following
    methods: TIESCALAR, FETCH, STORE, and possibly UNTIE and/or DESTROY.</p>
<p class="Pp">Let's look at each in turn, using as an example a tie class for
    scalars that allows the user to do something like:</p>
<p class="Pp"></p>
<pre>    tie $his_speed, 'Nice', getppid();
    tie $my_speed,  'Nice', $$;
</pre>
<p class="Pp">And now whenever either of those variables is accessed, its
    current system priority is retrieved and returned. If those variables are
    set, then the process's priority is changed!</p>
<p class="Pp">We'll use Jarkko Hietaniemi &lt;<i>jhi@iki.fi</i>&gt;'s
    BSD::Resource class (not included) to access the PRIO_PROCESS, PRIO_MIN, and
    PRIO_MAX constants from your system, as well as the <b>getpriority()</b> and
    <b>setpriority()</b> system calls. Here's the preamble of the class.</p>
<p class="Pp"></p>
<pre>    package Nice;
    use Carp;
    use BSD::Resource;
    use strict;
    $Nice::DEBUG = 0 unless defined $Nice::DEBUG;
</pre>
<dl class="Bl-tag">
  <dt id="TIESCALAR"><a class="permalink" href="#TIESCALAR">TIESCALAR classname,
    LIST</a></dt>
  <dd>This is the constructor for the class. That means it is expected to return
      a blessed reference to a new scalar (probably anonymous) that it's
      creating. For example:
    <p class="Pp"></p>
    <pre> sub TIESCALAR {
     my $class = shift;
     my $pid = shift || $$; # 0 means me
     if ($pid !~ /^\d+$/) {
         carp &quot;Nice::Tie::Scalar got non-numeric pid $pid&quot; if $^W;
         return undef;
     }
     unless (kill 0, $pid) { # EPERM or ERSCH, no doubt
         carp &quot;Nice::Tie::Scalar got bad pid $pid: $!&quot; if $^W;
         return undef;
     }
     return bless \$pid, $class;
 }
    </pre>
    <p class="Pp">This tie class has chosen to return an error rather than
        raising an exception if its constructor should fail. While this is how
        <b>dbmopen()</b> works, other classes may well not wish to be so
        forgiving. It checks the global variable <span class="Li">$^W</span> to
        see whether to emit a bit of noise anyway.</p>
  </dd>
  <dt id="FETCH"><a class="permalink" href="#FETCH">FETCH this</a></dt>
  <dd>This method will be triggered every time the tied variable is accessed
      (read). It takes no arguments beyond its self reference, which is the
      object representing the scalar we're dealing with. Because in this case
      we're using just a SCALAR ref for the tied scalar object, a simple $$self
      allows the method to get at the real value stored there. In our example
      below, that real value is the process ID to which we've tied our variable.
    <p class="Pp"></p>
    <pre>    sub FETCH {
        my $self = shift;
        confess &quot;wrong type&quot; unless ref $self;
        croak &quot;usage error&quot; if @_;
        my $nicety;
        local($!) = 0;
        $nicety = getpriority(PRIO_PROCESS, $$self);
        if ($!) { croak &quot;getpriority failed: $!&quot; }
        return $nicety;
    }
    </pre>
    <p class="Pp">This time we've decided to blow up (raise an exception) if the
        renice fails--there's no place for us to return an error otherwise, and
        it's probably the right thing to do.</p>
  </dd>
  <dt id="STORE"><a class="permalink" href="#STORE">STORE this, value</a></dt>
  <dd>This method will be triggered every time the tied variable is set
      (assigned). Beyond its self reference, it also expects one (and only one)
      argument: the new value the user is trying to assign. Don't worry about
      returning a value from STORE; the semantic of assignment returning the
      assigned value is implemented with FETCH.
    <p class="Pp"></p>
    <pre> sub STORE {
     my $self = shift;
     confess &quot;wrong type&quot; unless ref $self;
     my $new_nicety = shift;
     croak &quot;usage error&quot; if @_;
     if ($new_nicety &lt; PRIO_MIN) {
         carp sprintf
           &quot;WARNING: priority %d less than minimum system priority %d&quot;,
               $new_nicety, PRIO_MIN if $^W;
         $new_nicety = PRIO_MIN;
     }
     if ($new_nicety &gt; PRIO_MAX) {
         carp sprintf
           &quot;WARNING: priority %d greater than maximum system priority %d&quot;,
               $new_nicety, PRIO_MAX if $^W;
         $new_nicety = PRIO_MAX;
     }
     unless (defined setpriority(PRIO_PROCESS,
                                 $$self,
                                 $new_nicety))
     {
         confess &quot;setpriority failed: $!&quot;;
     }
 }
    </pre>
  </dd>
  <dt id="UNTIE"><a class="permalink" href="#UNTIE">UNTIE this</a></dt>
  <dd>This method will be triggered when the
      <span class="Li">&quot;untie&quot;</span> occurs. This can be useful if
      the class needs to know when no further calls will be made. (Except
      DESTROY of course.) See &quot;The
      <span class="Li">&quot;untie&quot;</span> Gotcha&quot; below for more
      details.</dd>
  <dt id="DESTROY"><a class="permalink" href="#DESTROY">DESTROY this</a></dt>
  <dd>This method will be triggered when the tied variable needs to be
      destructed. As with other object classes, such a method is seldom
      necessary, because Perl deallocates its moribund object's memory for you
      automatically--this isn't C++, you know. We'll use a DESTROY method here
      for debugging purposes only.
    <p class="Pp"></p>
    <pre>    sub DESTROY {
        my $self = shift;
        confess &quot;wrong type&quot; unless ref $self;
        carp &quot;[ Nice::DESTROY pid $$self ]&quot; if $Nice::DEBUG;
    }
    </pre>
  </dd>
</dl>
<p class="Pp">That's about all there is to it. Actually, it's more than all
    there is to it, because we've done a few nice things here for the sake of
    completeness, robustness, and general aesthetics. Simpler TIESCALAR classes
    are certainly possible.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Tying_Arrays"><a class="permalink" href="#Tying_Arrays">Tying
  Arrays</a></h2>
<p class="Pp">A class implementing a tied ordinary array should define the
    following methods: TIEARRAY, FETCH, STORE, FETCHSIZE, STORESIZE, CLEAR and
    perhaps UNTIE and/or DESTROY.</p>
<p class="Pp">FETCHSIZE and STORESIZE are used to provide
    <span class="Li">$#array</span> and equivalent
    <span class="Li">&quot;scalar(@array)&quot;</span> access.</p>
<p class="Pp">The methods POP, PUSH, SHIFT, UNSHIFT, SPLICE, DELETE, and EXISTS
    are required if the perl operator with the corresponding (but lowercase)
    name is to operate on the tied array. The <b>Tie::Array</b> class can be
    used as a base class to implement the first five of these in terms of the
    basic methods above. The default implementations of DELETE and EXISTS in
    <b>Tie::Array</b> simply <span class="Li">&quot;croak&quot;</span>.</p>
<p class="Pp">In addition EXTEND will be called when perl would have
    pre-extended allocation in a real array.</p>
<p class="Pp">For this discussion, we'll implement an array whose elements are a
    fixed size at creation. If you try to create an element larger than the
    fixed size, you'll take an exception. For example:</p>
<p class="Pp"></p>
<pre>    use FixedElem_Array;
    tie @array, 'FixedElem_Array', 3;
    $array[0] = 'cat';  # ok.
    $array[1] = 'dogs'; # exception, length('dogs') &gt; 3.
</pre>
<p class="Pp">The preamble code for the class is as follows:</p>
<p class="Pp"></p>
<pre>    package FixedElem_Array;
    use Carp;
    use strict;
</pre>
<dl class="Bl-tag">
  <dt id="TIEARRAY"><a class="permalink" href="#TIEARRAY">TIEARRAY classname,
    LIST</a></dt>
  <dd>This is the constructor for the class. That means it is expected to return
      a blessed reference through which the new array (probably an anonymous
      ARRAY ref) will be accessed.
    <p class="Pp">In our example, just to show you that you don't <i>really</i>
        have to return an ARRAY reference, we'll choose a HASH reference to
        represent our object. A HASH works out well as a generic record type:
        the <span class="Li">&quot;{ELEMSIZE}&quot;</span> field will store the
        maximum element size allowed, and the
        <span class="Li">&quot;{ARRAY}&quot;</span> field will hold the true
        ARRAY ref. If someone outside the class tries to dereference the object
        returned (doubtless thinking it an ARRAY ref), they'll blow up. This
        just goes to show you that you should respect an object's privacy.</p>
    <p class="Pp"></p>
    <pre>    sub TIEARRAY {
      my $class    = shift;
      my $elemsize = shift;
      if ( @_ || $elemsize =~ /\D/ ) {
        croak &quot;usage: tie ARRAY, '&quot; . __PACKAGE__ . &quot;', elem_size&quot;;
      }
      return bless {
        ELEMSIZE =&gt; $elemsize,
        ARRAY    =&gt; [],
      }, $class;
    }
    </pre>
  </dd>
  <dt id="FETCH~2"><a class="permalink" href="#FETCH~2">FETCH this,
    index</a></dt>
  <dd>This method will be triggered every time an individual element the tied
      array is accessed (read). It takes one argument beyond its self reference:
      the index whose value we're trying to fetch.
    <p class="Pp"></p>
    <pre>    sub FETCH {
      my $self  = shift;
      my $index = shift;
      return $self-&gt;{ARRAY}-&gt;[$index];
    }
    </pre>
    <p class="Pp">If a negative array index is used to read from an array, the
        index will be translated to a positive one internally by calling
        FETCHSIZE before being passed to FETCH. You may disable this feature by
        assigning a true value to the variable
        <span class="Li">$NEGATIVE_INDICES</span> in the tied array class.</p>
    <p class="Pp">As you may have noticed, the name of the FETCH method (et al.)
        is the same for all accesses, even though the constructors differ in
        names (TIESCALAR vs TIEARRAY). While in theory you could have the same
        class servicing several tied types, in practice this becomes cumbersome,
        and it's easiest to keep them at simply one tie type per class.</p>
  </dd>
  <dt id="STORE~2"><a class="permalink" href="#STORE~2">STORE this, index,
    value</a></dt>
  <dd>This method will be triggered every time an element in the tied array is
      set (written). It takes two arguments beyond its self reference: the index
      at which we're trying to store something and the value we're trying to put
      there.
    <p class="Pp">In our example, <span class="Li">&quot;undef&quot;</span> is
        really <span class="Li">&quot;$self-&gt;{ELEMSIZE}&quot;</span> number
        of spaces so we have a little more work to do here:</p>
    <p class="Pp"></p>
    <pre> sub STORE {
   my $self = shift;
   my( $index, $value ) = @_;
   if ( length $value &gt; $self-&gt;{ELEMSIZE} ) {
     croak &quot;length of $value is greater than $self-&gt;{ELEMSIZE}&quot;;
   }
   # fill in the blanks
   $self-&gt;EXTEND( $index ) if $index &gt; $self-&gt;FETCHSIZE();
   # right justify to keep element size for smaller elements
   $self-&gt;{ARRAY}-&gt;[$index] = sprintf &quot;%$self-&gt;{ELEMSIZE}s&quot;, $value;
 }
    </pre>
    <p class="Pp">Negative indexes are treated the same as with FETCH.</p>
  </dd>
  <dt id="FETCHSIZE"><a class="permalink" href="#FETCHSIZE">FETCHSIZE
    this</a></dt>
  <dd>Returns the total number of items in the tied array associated with object
      <i>this</i>. (Equivalent to
      <span class="Li">&quot;scalar(@array)&quot;</span>). For example:
    <p class="Pp"></p>
    <pre>    sub FETCHSIZE {
      my $self = shift;
      return scalar @{$self-&gt;{ARRAY}};
    }
    </pre>
  </dd>
  <dt id="STORESIZE"><a class="permalink" href="#STORESIZE">STORESIZE this,
    count</a></dt>
  <dd>Sets the total number of items in the tied array associated with object
      <i>this</i> to be <i>count</i>. If this makes the array larger then
      class's mapping of <span class="Li">&quot;undef&quot;</span> should be
      returned for new positions. If the array becomes smaller then entries
      beyond count should be deleted.
    <p class="Pp">In our example, 'undef' is really an element containing
        <span class="Li">&quot;$self-&gt;{ELEMSIZE}&quot;</span> number of
        spaces. Observe:</p>
    <p class="Pp"></p>
    <pre>    sub STORESIZE {
      my $self  = shift;
      my $count = shift;
      if ( $count &gt; $self-&gt;FETCHSIZE() ) {
        foreach ( $count - $self-&gt;FETCHSIZE() .. $count ) {
          $self-&gt;STORE( $_, '' );
        }
      } elsif ( $count &lt; $self-&gt;FETCHSIZE() ) {
        foreach ( 0 .. $self-&gt;FETCHSIZE() - $count - 2 ) {
          $self-&gt;POP();
        }
      }
    }
    </pre>
  </dd>
  <dt id="EXTEND"><a class="permalink" href="#EXTEND">EXTEND this,
    count</a></dt>
  <dd>Informative call that array is likely to grow to have <i>count</i>
      entries. Can be used to optimize allocation. This method need do nothing.
    <p class="Pp">In our example, we want to make sure there are no blank
        (<span class="Li">&quot;undef&quot;</span>) entries, so
        <span class="Li">&quot;EXTEND&quot;</span> will make use of
        <span class="Li">&quot;STORESIZE&quot;</span> to fill elements as
        needed:</p>
    <p class="Pp"></p>
    <pre>    sub EXTEND {   
      my $self  = shift;
      my $count = shift;
      $self-&gt;STORESIZE( $count );
    }
    </pre>
  </dd>
  <dt id="EXISTS"><a class="permalink" href="#EXISTS">EXISTS this, key</a></dt>
  <dd>Verify that the element at index <i>key</i> exists in the tied array
      <i>this</i>.
    <p class="Pp">In our example, we will determine that if an element consists
        of <span class="Li">&quot;$self-&gt;{ELEMSIZE}&quot;</span> spaces only,
        it does not exist:</p>
    <p class="Pp"></p>
    <pre> sub EXISTS {
   my $self  = shift;
   my $index = shift;
   return 0 if ! defined $self-&gt;{ARRAY}-&gt;[$index] ||
               $self-&gt;{ARRAY}-&gt;[$index] eq ' ' x $self-&gt;{ELEMSIZE};
   return 1;
 }
    </pre>
  </dd>
  <dt id="DELETE"><a class="permalink" href="#DELETE">DELETE this, key</a></dt>
  <dd>Delete the element at index <i>key</i> from the tied array <i>this</i>.
    <p class="Pp">In our example, a deleted item is
        <span class="Li">&quot;$self-&gt;{ELEMSIZE}&quot;</span> spaces:</p>
    <p class="Pp"></p>
    <pre>    sub DELETE {
      my $self  = shift;
      my $index = shift;
      return $self-&gt;STORE( $index, '' );
    }
    </pre>
  </dd>
  <dt id="CLEAR"><a class="permalink" href="#CLEAR">CLEAR this</a></dt>
  <dd>Clear (remove, delete, ...) all values from the tied array associated with
      object <i>this</i>. For example:
    <p class="Pp"></p>
    <pre>    sub CLEAR {
      my $self = shift;
      return $self-&gt;{ARRAY} = [];
    }
    </pre>
  </dd>
  <dt id="PUSH"><a class="permalink" href="#PUSH">PUSH this, LIST</a></dt>
  <dd>Append elements of <i>LIST</i> to the array. For example:
    <p class="Pp"></p>
    <pre>    sub PUSH {  
      my $self = shift;
      my @list = @_;
      my $last = $self-&gt;FETCHSIZE();
      $self-&gt;STORE( $last + $_, $list[$_] ) foreach 0 .. $#list;
      return $self-&gt;FETCHSIZE();
    }
    </pre>
  </dd>
  <dt id="POP"><a class="permalink" href="#POP">POP this</a></dt>
  <dd>Remove last element of the array and return it. For example:
    <p class="Pp"></p>
    <pre>    sub POP {
      my $self = shift;
      return pop @{$self-&gt;{ARRAY}};
    }
    </pre>
  </dd>
  <dt id="SHIFT"><a class="permalink" href="#SHIFT">SHIFT this</a></dt>
  <dd>Remove the first element of the array (shifting other elements down) and
      return it. For example:
    <p class="Pp"></p>
    <pre>    sub SHIFT {
      my $self = shift;
      return shift @{$self-&gt;{ARRAY}};
    }
    </pre>
  </dd>
  <dt id="UNSHIFT"><a class="permalink" href="#UNSHIFT">UNSHIFT this,
    LIST</a></dt>
  <dd>Insert LIST elements at the beginning of the array, moving existing
      elements up to make room. For example:
    <p class="Pp"></p>
    <pre>    sub UNSHIFT {
      my $self = shift;
      my @list = @_;
      my $size = scalar( @list );
      # make room for our list
      @{$self-&gt;{ARRAY}}[ $size .. $#{$self-&gt;{ARRAY}} + $size ]
       = @{$self-&gt;{ARRAY}};
      $self-&gt;STORE( $_, $list[$_] ) foreach 0 .. $#list;
    }
    </pre>
  </dd>
  <dt id="SPLICE"><a class="permalink" href="#SPLICE">SPLICE this, offset,
    length, LIST</a></dt>
  <dd>Perform the equivalent of <span class="Li">&quot;splice&quot;</span> on
      the array.
    <p class="Pp"><i>offset</i> is optional and defaults to zero, negative
        values count back from the end of the array.</p>
    <p class="Pp"><i>length</i> is optional and defaults to rest of the
      array.</p>
    <p class="Pp"><i>LIST</i> may be empty.</p>
    <p class="Pp">Returns a list of the original <i>length</i> elements at
        <i>offset</i>.</p>
    <p class="Pp">In our example, we'll use a little shortcut if there is a
        <i>LIST</i>:</p>
    <p class="Pp"></p>
    <pre>    sub SPLICE {
      my $self   = shift;
      my $offset = shift || 0;
      my $length = shift || $self-&gt;FETCHSIZE() - $offset;
      my @list   = (); 
      if ( @_ ) {
        tie @list, __PACKAGE__, $self-&gt;{ELEMSIZE};
        @list   = @_;
      }
      return splice @{$self-&gt;{ARRAY}}, $offset, $length, @list;
    }
    </pre>
  </dd>
  <dt id="UNTIE~2"><a class="permalink" href="#UNTIE~2">UNTIE this</a></dt>
  <dd>Will be called when <span class="Li">&quot;untie&quot;</span> happens.
      (See &quot;The <span class="Li">&quot;untie&quot;</span> Gotcha&quot;
      below.)</dd>
  <dt id="DESTROY~2"><a class="permalink" href="#DESTROY~2">DESTROY
    this</a></dt>
  <dd>This method will be triggered when the tied variable needs to be
      destructed. As with the scalar tie class, this is almost never needed in a
      language that does its own garbage collection, so this time we'll just
      leave it out.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Tying_Hashes"><a class="permalink" href="#Tying_Hashes">Tying
  Hashes</a></h2>
<p class="Pp">Hashes were the first Perl data type to be tied (see
    <b>dbmopen()</b>). A class implementing a tied hash should define the
    following methods: TIEHASH is the constructor. FETCH and STORE access the
    key and value pairs. EXISTS reports whether a key is present in the hash,
    and DELETE deletes one. CLEAR empties the hash by deleting all the key and
    value pairs. FIRSTKEY and NEXTKEY implement the <b>keys()</b> and
    <b>each()</b> functions to iterate over all the keys. SCALAR is triggered
    when the tied hash is evaluated in scalar context, and in 5.28 onwards, by
    <span class="Li">&quot;keys&quot;</span> in boolean context. UNTIE is called
    when <span class="Li">&quot;untie&quot;</span> happens, and DESTROY is
    called when the tied variable is garbage collected.</p>
<p class="Pp">If this seems like a lot, then feel free to inherit from merely
    the standard Tie::StdHash module for most of your methods, redefining only
    the interesting ones. See Tie::Hash for details.</p>
<p class="Pp">Remember that Perl distinguishes between a key not existing in the
    hash, and the key existing in the hash but having a corresponding value of
    <span class="Li">&quot;undef&quot;</span>. The two possibilities can be
    tested with the <span class="Li">&quot;exists()&quot;</span> and
    <span class="Li">&quot;defined()&quot;</span> functions.</p>
<p class="Pp">Here's an example of a somewhat interesting tied hash class: it
    gives you a hash representing a particular user's dot files. You index into
    the hash with the name of the file (minus the dot) and you get back that dot
    file's contents. For example:</p>
<p class="Pp"></p>
<pre>    use DotFiles;
    tie %dot, 'DotFiles';
    if ( $dot{profile} =~ /MANPATH/ ||
         $dot{login}   =~ /MANPATH/ ||
         $dot{cshrc}   =~ /MANPATH/    )
    {
        print &quot;you seem to set your MANPATH\n&quot;;
    }
</pre>
<p class="Pp">Or here's another sample of using our tied class:</p>
<p class="Pp"></p>
<pre>    tie %him, 'DotFiles', 'daemon';
    foreach $f ( keys %him ) {
        printf &quot;daemon dot file %s is size %d\n&quot;,
            $f, length $him{$f};
    }
</pre>
<p class="Pp">In our tied hash DotFiles example, we use a regular hash for the
    object containing several important fields, of which only the
    <span class="Li">&quot;{LIST}&quot;</span> field will be what the user
    thinks of as the real hash.</p>
<dl class="Bl-tag">
  <dt id="USER"><a class="permalink" href="#USER">USER</a></dt>
  <dd>whose dot files this object represents</dd>
  <dt id="HOME"><a class="permalink" href="#HOME">HOME</a></dt>
  <dd>where those dot files live</dd>
  <dt id="CLOBBER"><a class="permalink" href="#CLOBBER">CLOBBER</a></dt>
  <dd>whether we should try to change or remove those dot files</dd>
  <dt id="LIST"><a class="permalink" href="#LIST">LIST</a></dt>
  <dd>the hash of dot file names and content mappings</dd>
</dl>
<p class="Pp">Here's the start of <i>Dotfiles.pm</i>:</p>
<p class="Pp"></p>
<pre>    package DotFiles;
    use Carp;
    sub whowasi { (caller(1))[3] . '()' }
    my $DEBUG = 0;
    sub debug { $DEBUG = @_ ? shift : 1 }
</pre>
<p class="Pp">For our example, we want to be able to emit debugging info to help
    in tracing during development. We keep also one convenience function around
    internally to help print out warnings; <b>whowasi()</b> returns the function
    name that calls it.</p>
<p class="Pp">Here are the methods for the DotFiles tied hash.</p>
<dl class="Bl-tag">
  <dt id="TIEHASH"><a class="permalink" href="#TIEHASH">TIEHASH classname,
    LIST</a></dt>
  <dd>This is the constructor for the class. That means it is expected to return
      a blessed reference through which the new object (probably but not
      necessarily an anonymous hash) will be accessed.
    <p class="Pp">Here's the constructor:</p>
    <p class="Pp"></p>
    <pre>    sub TIEHASH {
        my $self = shift;
        my $user = shift || $&gt;;
        my $dotdir = shift || '';
        croak &quot;usage: @{[&amp;whowasi]} [USER [DOTDIR]]&quot; if @_;
        $user = getpwuid($user) if $user =~ /^\d+$/;
        my $dir = (getpwnam($user))[7]
                || croak &quot;@{[&amp;whowasi]}: no user $user&quot;;
        $dir .= &quot;/$dotdir&quot; if $dotdir;
        my $node = {
            USER    =&gt; $user,
            HOME    =&gt; $dir,
            LIST    =&gt; {},
            CLOBBER =&gt; 0,
        };
        opendir(DIR, $dir)
                || croak &quot;@{[&amp;whowasi]}: can't opendir $dir: $!&quot;;
        foreach $dot ( grep /^\./ &amp;&amp; -f &quot;$dir/$_&quot;, readdir(DIR)) {
            $dot =~ s/^\.//;
            $node-&gt;{LIST}{$dot} = undef;
        }
        closedir DIR;
        return bless $node, $self;
    }
    </pre>
    <p class="Pp">It's probably worth mentioning that if you're going to
        filetest the return values out of a readdir, you'd better prepend the
        directory in question. Otherwise, because we didn't <b>chdir()</b>
        there, it would have been testing the wrong file.</p>
  </dd>
  <dt id="FETCH~3"><a class="permalink" href="#FETCH~3">FETCH this, key</a></dt>
  <dd>This method will be triggered every time an element in the tied hash is
      accessed (read). It takes one argument beyond its self reference: the key
      whose value we're trying to fetch.
    <p class="Pp">Here's the fetch for our DotFiles example.</p>
    <p class="Pp"></p>
    <pre>    sub FETCH {
        carp &amp;whowasi if $DEBUG;
        my $self = shift;
        my $dot = shift;
        my $dir = $self-&gt;{HOME};
        my $file = &quot;$dir/.$dot&quot;;
        unless (exists $self-&gt;{LIST}-&gt;{$dot} || -f $file) {
            carp &quot;@{[&amp;whowasi]}: no $dot file&quot; if $DEBUG;
            return undef;
        }
        if (defined $self-&gt;{LIST}-&gt;{$dot}) {
            return $self-&gt;{LIST}-&gt;{$dot};
        } else {
            return $self-&gt;{LIST}-&gt;{$dot} = `cat $dir/.$dot`;
        }
    }
    </pre>
    <p class="Pp">It was easy to write by having it call the Unix <b>cat</b>(1)
        command, but it would probably be more portable to open the file
        manually (and somewhat more efficient). Of course, because dot files are
        a Unixy concept, we're not that concerned.</p>
  </dd>
  <dt id="STORE~3"><a class="permalink" href="#STORE~3">STORE this, key,
    value</a></dt>
  <dd>This method will be triggered every time an element in the tied hash is
      set (written). It takes two arguments beyond its self reference: the index
      at which we're trying to store something, and the value we're trying to
      put there.
    <p class="Pp">Here in our DotFiles example, we'll be careful not to let them
        try to overwrite the file unless they've called the <b>clobber()</b>
        method on the original object reference returned by <b>tie()</b>.</p>
    <p class="Pp"></p>
    <pre>    sub STORE {
        carp &amp;whowasi if $DEBUG;
        my $self = shift;
        my $dot = shift;
        my $value = shift;
        my $file = $self-&gt;{HOME} . &quot;/.$dot&quot;;
        my $user = $self-&gt;{USER};
        croak &quot;@{[&amp;whowasi]}: $file not clobberable&quot;
            unless $self-&gt;{CLOBBER};
        open(my $f, '&gt;', $file) || croak &quot;can't open $file: $!&quot;;
        print $f $value;
        close($f);
    }
    </pre>
    <p class="Pp">If they wanted to clobber something, they might say:</p>
    <p class="Pp"></p>
    <pre>    $ob = tie %daemon_dots, 'daemon';
    $ob-&gt;clobber(1);
    $daemon_dots{signature} = &quot;A true daemon\n&quot;;
    </pre>
    <p class="Pp">Another way to lay hands on a reference to the underlying
        object is to use the <b>tied()</b> function, so they might alternately
        have set clobber using:</p>
    <p class="Pp"></p>
    <pre>    tie %daemon_dots, 'daemon';
    tied(%daemon_dots)-&gt;clobber(1);
    </pre>
    <p class="Pp">The clobber method is simply:</p>
    <p class="Pp"></p>
    <pre>    sub clobber {
        my $self = shift;
        $self-&gt;{CLOBBER} = @_ ? shift : 1;
    }
    </pre>
  </dd>
  <dt id="DELETE~2"><a class="permalink" href="#DELETE~2">DELETE this,
    key</a></dt>
  <dd>This method is triggered when we remove an element from the hash,
      typically by using the <b>delete()</b> function. Again, we'll be careful
      to check whether they really want to clobber files.
    <p class="Pp"></p>
    <pre> sub DELETE   {
     carp &amp;whowasi if $DEBUG;
     my $self = shift;
     my $dot = shift;
     my $file = $self-&gt;{HOME} . &quot;/.$dot&quot;;
     croak &quot;@{[&amp;whowasi]}: won't remove file $file&quot;
         unless $self-&gt;{CLOBBER};
     delete $self-&gt;{LIST}-&gt;{$dot};
     my $success = unlink($file);
     carp &quot;@{[&amp;whowasi]}: can't unlink $file: $!&quot; unless $success;
     $success;
 }
    </pre>
    <p class="Pp">The value returned by DELETE becomes the return value of the
        call to <b>delete()</b>. If you want to emulate the normal behavior of
        <b>delete()</b>, you should return whatever FETCH would have returned
        for this key. In this example, we have chosen instead to return a value
        which tells the caller whether the file was successfully deleted.</p>
  </dd>
  <dt id="CLEAR~2"><a class="permalink" href="#CLEAR~2">CLEAR this</a></dt>
  <dd>This method is triggered when the whole hash is to be cleared, usually by
      assigning the empty list to it.
    <p class="Pp">In our example, that would remove all the user's dot files!
        It's such a dangerous thing that they'll have to set CLOBBER to
        something higher than 1 to make it happen.</p>
    <p class="Pp"></p>
    <pre> sub CLEAR    {
     carp &amp;whowasi if $DEBUG;
     my $self = shift;
     croak &quot;@{[&amp;whowasi]}: won't remove all dot files for $self-&gt;{USER}&quot;
         unless $self-&gt;{CLOBBER} &gt; 1;
     my $dot;
     foreach $dot ( keys %{$self-&gt;{LIST}}) {
         $self-&gt;DELETE($dot);
     }
 }
    </pre>
  </dd>
  <dt id="EXISTS~2"><a class="permalink" href="#EXISTS~2">EXISTS this,
    key</a></dt>
  <dd>This method is triggered when the user uses the <b>exists()</b> function
      on a particular hash. In our example, we'll look at the
      <span class="Li">&quot;{LIST}&quot;</span> hash element for this:
    <p class="Pp"></p>
    <pre>    sub EXISTS   {
        carp &amp;whowasi if $DEBUG;
        my $self = shift;
        my $dot = shift;
        return exists $self-&gt;{LIST}-&gt;{$dot};
    }
    </pre>
  </dd>
  <dt id="FIRSTKEY"><a class="permalink" href="#FIRSTKEY">FIRSTKEY this</a></dt>
  <dd>This method will be triggered when the user is going to iterate through
      the hash, such as via a <b>keys()</b>, <b>values()</b>, or <b>each()</b>
      call.
    <p class="Pp"></p>
    <pre>    sub FIRSTKEY {
        carp &amp;whowasi if $DEBUG;
        my $self = shift;
        my $a = keys %{$self-&gt;{LIST}};  # reset each() iterator
        each %{$self-&gt;{LIST}}
    }
    </pre>
    <p class="Pp">FIRSTKEY is always called in scalar context and it should just
        return the first key. <b>values()</b>, and <b>each()</b> in list
        context, will call FETCH for the returned keys.</p>
  </dd>
  <dt id="NEXTKEY"><a class="permalink" href="#NEXTKEY">NEXTKEY this,
    lastkey</a></dt>
  <dd>This method gets triggered during a <b>keys()</b>, <b>values()</b>, or
      <b>each()</b> iteration. It has a second argument which is the last key
      that had been accessed. This is useful if you're caring about ordering or
      calling the iterator from more than one sequence, or not really storing
      things in a hash anywhere.
    <p class="Pp">NEXTKEY is always called in scalar context and it should just
        return the next key. <b>values()</b>, and <b>each()</b> in list context,
        will call FETCH for the returned keys.</p>
    <p class="Pp">For our example, we're using a real hash so we'll do just the
        simple thing, but we'll have to go through the LIST field
      indirectly.</p>
    <p class="Pp"></p>
    <pre>    sub NEXTKEY  {
        carp &amp;whowasi if $DEBUG;
        my $self = shift;
        return each %{ $self-&gt;{LIST} }
    }
    </pre>
  </dd>
  <dt id="SCALAR"><a class="permalink" href="#SCALAR">SCALAR this</a></dt>
  <dd>This is called when the hash is evaluated in scalar context, and in 5.28
      onwards, by <span class="Li">&quot;keys&quot;</span> in boolean context.
      In order to mimic the behaviour of untied hashes, this method must return
      a value which when used as boolean, indicates whether the tied hash is
      considered empty. If this method does not exist, perl will make some
      educated guesses and return true when the hash is inside an iteration. If
      this isn't the case, FIRSTKEY is called, and the result will be a false
      value if FIRSTKEY returns the empty list, true otherwise.
    <p class="Pp">However, you should <b>not</b> blindly rely on perl always
        doing the right thing. Particularly, perl will mistakenly return true
        when you clear the hash by repeatedly calling DELETE until it is empty.
        You are therefore advised to supply your own SCALAR method when you want
        to be absolutely sure that your hash behaves nicely in scalar
      context.</p>
    <p class="Pp">In our example we can just call
        <span class="Li">&quot;scalar&quot;</span> on the underlying hash
        referenced by <span class="Li">&quot;$self-&gt;{LIST}&quot;</span>:</p>
    <p class="Pp"></p>
    <pre>    sub SCALAR {
        carp &amp;whowasi if $DEBUG;
        my $self = shift;
        return scalar %{ $self-&gt;{LIST} }
    }
    </pre>
    <p class="Pp">NOTE: In perl 5.25 the behavior of scalar
        <span class="Li">%hash</span> on an untied hash changed to return the
        count of keys. Prior to this it returned a string containing information
        about the bucket setup of the hash. See &quot;bucket_ratio&quot; in
        Hash::Util for a backwards compatibility path.</p>
  </dd>
  <dt id="UNTIE~3"><a class="permalink" href="#UNTIE~3">UNTIE this</a></dt>
  <dd>This is called when <span class="Li">&quot;untie&quot;</span> occurs. See
      &quot;The <span class="Li">&quot;untie&quot;</span> Gotcha&quot;
    below.</dd>
  <dt id="DESTROY~3"><a class="permalink" href="#DESTROY~3">DESTROY
    this</a></dt>
  <dd>This method is triggered when a tied hash is about to go out of scope. You
      don't really need it unless you're trying to add debugging or have
      auxiliary state to clean up. Here's a very simple function:
    <p class="Pp"></p>
    <pre>    sub DESTROY  {
        carp &amp;whowasi if $DEBUG;
    }
    </pre>
  </dd>
</dl>
<p class="Pp">Note that functions such as <b>keys()</b> and <b>values()</b> may
    return huge lists when used on large objects, like DBM files. You may prefer
    to use the <b>each()</b> function to iterate over such. Example:</p>
<p class="Pp"></p>
<pre>    # print out history file offsets
    use NDBM_File;
    tie(%HIST, 'NDBM_File', '/usr/lib/news/history', 1, 0);
    while (($key,$val) = each %HIST) {
        print $key, ' = ', unpack('L',$val), &quot;\n&quot;;
    }
    untie(%HIST);
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Tying_FileHandles"><a class="permalink" href="#Tying_FileHandles">Tying
  FileHandles</a></h2>
<p class="Pp">This is partially implemented now.</p>
<p class="Pp">A class implementing a tied filehandle should define the following
    methods: TIEHANDLE, at least one of PRINT, PRINTF, WRITE, READLINE, GETC,
    READ, and possibly CLOSE, UNTIE and DESTROY. The class can also provide:
    BINMODE, OPEN, EOF, FILENO, SEEK, TELL - if the corresponding perl operators
    are used on the handle.</p>
<p class="Pp">When STDERR is tied, its PRINT method will be called to issue
    warnings and error messages. This feature is temporarily disabled during the
    call, which means you can use <span class="Li">&quot;warn()&quot;</span>
    inside PRINT without starting a recursive loop. And just like
    <span class="Li">&quot;__WARN__&quot;</span> and
    <span class="Li">&quot;__DIE__&quot;</span> handlers, STDERR's PRINT method
    may be called to report parser errors, so the caveats mentioned under
    &quot;%SIG&quot; in perlvar apply.</p>
<p class="Pp">All of this is especially useful when perl is embedded in some
    other program, where output to STDOUT and STDERR may have to be redirected
    in some special way. See nvi and the Apache module for examples.</p>
<p class="Pp">When tying a handle, the first argument to
    <span class="Li">&quot;tie&quot;</span> should begin with an asterisk. So,
    if you are tying STDOUT, use <span class="Li">*STDOUT</span>. If you have
    assigned it to a scalar variable, say <span class="Li">$handle</span>, use
    <span class="Li">*$handle</span>. <span class="Li">&quot;tie
    $handle&quot;</span> ties the scalar variable
    <span class="Li">$handle</span>, not the handle inside it.</p>
<p class="Pp">In our example we're going to create a shouting handle.</p>
<p class="Pp"></p>
<pre>    package Shout;
</pre>
<dl class="Bl-tag">
  <dt id="TIEHANDLE"><a class="permalink" href="#TIEHANDLE">TIEHANDLE classname,
    LIST</a></dt>
  <dd>This is the constructor for the class. That means it is expected to return
      a blessed reference of some sort. The reference can be used to hold some
      internal information.
    <p class="Pp"></p>
    <pre>    sub TIEHANDLE { print &quot;&lt;shout&gt;\n&quot;; my $i; bless \$i, shift }
    </pre>
  </dd>
  <dt id="WRITE"><a class="permalink" href="#WRITE">WRITE this, LIST</a></dt>
  <dd>This method will be called when the handle is written to via the
      <span class="Li">&quot;syswrite&quot;</span> function.
    <p class="Pp"></p>
    <pre> sub WRITE {
     $r = shift;
     my($buf,$len,$offset) = @_;
     print &quot;WRITE called, \$buf=$buf, \$len=$len, \$offset=$offset&quot;;
 }
    </pre>
  </dd>
  <dt id="PRINT"><a class="permalink" href="#PRINT">PRINT this, LIST</a></dt>
  <dd>This method will be triggered every time the tied handle is printed to
      with the <span class="Li">&quot;print()&quot;</span> or
      <span class="Li">&quot;say()&quot;</span> functions. Beyond its self
      reference it also expects the list that was passed to the print function.
    <p class="Pp"></p>
    <pre>  sub PRINT { $r = shift; $$r++; print join($,,map(uc($_),@_)),$\ }
    </pre>
    <p class="Pp"><span class="Li">&quot;say()&quot;</span> acts just like
        <span class="Li">&quot;print()&quot;</span> except $\ will be localized
        to <span class="Li">&quot;\n&quot;</span> so you need do nothing special
        to handle <span class="Li">&quot;say()&quot;</span> in
        <span class="Li">&quot;PRINT()&quot;</span>.</p>
  </dd>
  <dt id="PRINTF"><a class="permalink" href="#PRINTF">PRINTF this, LIST</a></dt>
  <dd>This method will be triggered every time the tied handle is printed to
      with the <span class="Li">&quot;printf()&quot;</span> function. Beyond its
      self reference it also expects the format and list that was passed to the
      printf function.
    <p class="Pp"></p>
    <pre>    sub PRINTF {
        shift;
        my $fmt = shift;
        print sprintf($fmt, @_);
    }
    </pre>
  </dd>
  <dt id="READ"><a class="permalink" href="#READ">READ this, LIST</a></dt>
  <dd>This method will be called when the handle is read from via the
      <span class="Li">&quot;read&quot;</span> or
      <span class="Li">&quot;sysread&quot;</span> functions.
    <p class="Pp"></p>
    <pre> sub READ {
   my $self = shift;
   my $bufref = \$_[0];
   my(undef,$len,$offset) = @_;
   print &quot;READ called, \$buf=$bufref, \$len=$len, \$offset=$offset&quot;;
   # add to $$bufref, set $len to number of characters read
   $len;
 }
    </pre>
  </dd>
  <dt id="READLINE"><a class="permalink" href="#READLINE">READLINE this</a></dt>
  <dd>This method is called when the handle is read via
      <span class="Li">&quot;&lt;HANDLE&gt;&quot;</span> or
      <span class="Li">&quot;readline HANDLE&quot;</span>.
    <p class="Pp">As per <span class="Li">&quot;readline&quot;</span>, in scalar
        context it should return the next line, or
        <span class="Li">&quot;undef&quot;</span> for no more data. In list
        context it should return all remaining lines, or an empty list for no
        more data. The strings returned should include the input record
        separator <span class="Li">$/</span> (see perlvar), unless it is
        <span class="Li">&quot;undef&quot;</span> (which means &quot;slurp&quot;
        mode).</p>
    <p class="Pp"></p>
    <pre>    sub READLINE {
      my $r = shift;
      if (wantarray) {
        return (&quot;all remaining\n&quot;,
                &quot;lines up\n&quot;,
                &quot;to eof\n&quot;);
      } else {
        return &quot;READLINE called &quot; . ++$$r . &quot; times\n&quot;;
      }
    }
    </pre>
  </dd>
  <dt id="GETC"><a class="permalink" href="#GETC">GETC this</a></dt>
  <dd>This method will be called when the
      <span class="Li">&quot;getc&quot;</span> function is called.
    <p class="Pp"></p>
    <pre>    sub GETC { print &quot;Don't GETC, Get Perl&quot;; return &quot;a&quot;; }
    </pre>
  </dd>
  <dt id="EOF"><a class="permalink" href="#EOF">EOF this</a></dt>
  <dd>This method will be called when the
      <span class="Li">&quot;eof&quot;</span> function is called.
    <p class="Pp">Starting with Perl 5.12, an additional integer parameter will
        be passed. It will be zero if <span class="Li">&quot;eof&quot;</span> is
        called without parameter; <span class="Li">1</span> if
        <span class="Li">&quot;eof&quot;</span> is given a filehandle as a
        parameter, e.g. <span class="Li">&quot;eof(FH)&quot;</span>; and
        <span class="Li">2</span> in the very special case that the tied
        filehandle is <span class="Li">&quot;ARGV&quot;</span> and
        <span class="Li">&quot;eof&quot;</span> is called with an empty
        parameter list, e.g. <span class="Li">&quot;eof()&quot;</span>.</p>
    <p class="Pp"></p>
    <pre>    sub EOF { not length $stringbuf }
    </pre>
  </dd>
  <dt id="CLOSE"><a class="permalink" href="#CLOSE">CLOSE this</a></dt>
  <dd>This method will be called when the handle is closed via the
      <span class="Li">&quot;close&quot;</span> function.
    <p class="Pp"></p>
    <pre>    sub CLOSE { print &quot;CLOSE called.\n&quot; }
    </pre>
  </dd>
  <dt id="UNTIE~4"><a class="permalink" href="#UNTIE~4">UNTIE this</a></dt>
  <dd>As with the other types of ties, this method will be called when
      <span class="Li">&quot;untie&quot;</span> happens. It may be appropriate
      to &quot;auto CLOSE&quot; when this occurs. See &quot;The
      <span class="Li">&quot;untie&quot;</span> Gotcha&quot; below.</dd>
  <dt id="DESTROY~4"><a class="permalink" href="#DESTROY~4">DESTROY
    this</a></dt>
  <dd>As with the other types of ties, this method will be called when the tied
      handle is about to be destroyed. This is useful for debugging and possibly
      cleaning up.
    <p class="Pp"></p>
    <pre>    sub DESTROY { print &quot;&lt;/shout&gt;\n&quot; }
    </pre>
  </dd>
</dl>
<p class="Pp">Here's how to use our little example:</p>
<p class="Pp"></p>
<pre>    tie(*FOO,'Shout');
    print FOO &quot;hello\n&quot;;
    $a = 4; $b = 6;
    print FOO $a, &quot; plus &quot;, $b, &quot; equals &quot;, $a + $b, &quot;\n&quot;;
    print &lt;FOO&gt;;
</pre>
</section>
<section class="Ss">
<h2 class="Ss">UNTIE this</h2>
<p class="Pp">You can define for all tie types an UNTIE method that will be
    called at <b>untie()</b>. See &quot;The
    <span class="Li">&quot;untie&quot;</span> Gotcha&quot; below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The__untie__Gotcha"><a class="permalink" href="#The__untie__Gotcha">The
  &quot;untie&quot; Gotcha</a></h2>
<p class="Pp">If you intend making use of the object returned from either
    <b>tie()</b> or <b>tied()</b>, and if the tie's target class defines a
    destructor, there is a subtle gotcha you <i>must</i> guard against.</p>
<p class="Pp">As setup, consider this (admittedly rather contrived) example of a
    tie; all it does is use a file to keep a log of the values assigned to a
    scalar.</p>
<p class="Pp"></p>
<pre>    package Remember;
    use strict;
    use warnings;
    use IO::File;
    sub TIESCALAR {
        my $class = shift;
        my $filename = shift;
        my $handle = IO::File-&gt;new( &quot;&gt; $filename&quot; )
                         or die &quot;Cannot open $filename: $!\n&quot;;
        print $handle &quot;The Start\n&quot;;
        bless {FH =&gt; $handle, Value =&gt; 0}, $class;
    }
    sub FETCH {
        my $self = shift;
        return $self-&gt;{Value};
    }
    sub STORE {
        my $self = shift;
        my $value = shift;
        my $handle = $self-&gt;{FH};
        print $handle &quot;$value\n&quot;;
        $self-&gt;{Value} = $value;
    }
    sub DESTROY {
        my $self = shift;
        my $handle = $self-&gt;{FH};
        print $handle &quot;The End\n&quot;;
        close $handle;
    }
    1;
</pre>
<p class="Pp">Here is an example that makes use of this tie:</p>
<p class="Pp"></p>
<pre>    use strict;
    use Remember;
    my $fred;
    tie $fred, 'Remember', 'myfile.txt';
    $fred = 1;
    $fred = 4;
    $fred = 5;
    untie $fred;
    system &quot;cat myfile.txt&quot;;
</pre>
<p class="Pp">This is the output when it is executed:</p>
<p class="Pp"></p>
<pre>    The Start
    1
    4
    5
    The End
</pre>
<p class="Pp">So far so good. Those of you who have been paying attention will
    have spotted that the tied object hasn't been used so far. So lets add an
    extra method to the Remember class to allow comments to be included in the
    file; say, something like this:</p>
<p class="Pp"></p>
<pre>    sub comment {
        my $self = shift;
        my $text = shift;
        my $handle = $self-&gt;{FH};
        print $handle $text, &quot;\n&quot;;
    }
</pre>
<p class="Pp">And here is the previous example modified to use the
    <span class="Li">&quot;comment&quot;</span> method (which requires the tied
    object):</p>
<p class="Pp"></p>
<pre>    use strict;
    use Remember;
    my ($fred, $x);
    $x = tie $fred, 'Remember', 'myfile.txt';
    $fred = 1;
    $fred = 4;
    comment $x &quot;changing...&quot;;
    $fred = 5;
    untie $fred;
    system &quot;cat myfile.txt&quot;;
</pre>
<p class="Pp">When this code is executed there is no output. Here's why:</p>
<p class="Pp">When a variable is tied, it is associated with the object which is
    the return value of the TIESCALAR, TIEARRAY, or TIEHASH function. This
    object normally has only one reference, namely, the implicit reference from
    the tied variable. When <b>untie()</b> is called, that reference is
    destroyed. Then, as in the first example above, the object's destructor
    (DESTROY) is called, which is normal for objects that have no more valid
    references; and thus the file is closed.</p>
<p class="Pp">In the second example, however, we have stored another reference
    to the tied object in <span class="Li">$x</span>. That means that when
    <b>untie()</b> gets called there will still be a valid reference to the
    object in existence, so the destructor is not called at that time, and thus
    the file is not closed. The reason there is no output is because the file
    buffers have not been flushed to disk.</p>
<p class="Pp">Now that you know what the problem is, what can you do to avoid
    it? Prior to the introduction of the optional UNTIE method the only way was
    the good old <span class="Li">&quot;-w&quot;</span> flag. Which will spot
    any instances where you call <b>untie()</b> and there are still valid
    references to the tied object. If the second script above this near the top
    <span class="Li">&quot;use warnings 'untie'&quot;</span> or was run with the
    <span class="Li">&quot;-w&quot;</span> flag, Perl prints this warning
    message:</p>
<p class="Pp"></p>
<pre>    untie attempted while 1 inner references still exist
</pre>
<p class="Pp">To get the script to work properly and silence the warning make
    sure there are no valid references to the tied object <i>before</i>
    <b>untie()</b> is called:</p>
<p class="Pp"></p>
<pre>    undef $x;
    untie $fred;
</pre>
<p class="Pp">Now that UNTIE exists the class designer can decide which parts of
    the class functionality are really associated with
    <span class="Li">&quot;untie&quot;</span> and which with the object being
    destroyed. What makes sense for a given class depends on whether the inner
    references are being kept so that non-tie-related methods can be called on
    the object. But in most cases it probably makes sense to move the
    functionality that would have been in DESTROY to the UNTIE method.</p>
<p class="Pp">If the UNTIE method exists then the warning above does not occur.
    Instead the UNTIE method is passed the count of &quot;extra&quot; references
    and can issue its own warning if appropriate. e.g. to replicate the no UNTIE
    case this method can be used:</p>
<p class="Pp"></p>
<pre> sub UNTIE
 {
  my ($obj,$count) = @_;
  carp &quot;untie attempted while $count inner references still exist&quot;
                                                              if $count;
 }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp">See DB_File or Config for some interesting <b>tie()</b>
    implementations. A good starting point for many <b>tie()</b> implementations
    is with one of the modules Tie::Scalar, Tie::Array, Tie::Hash, or
    Tie::Handle.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">The normal return provided by
    <span class="Li">&quot;scalar(%hash)&quot;</span> is not available. What
    this means is that using <span class="Li">%tied_hash</span> in boolean
    context doesn't work right (currently this always tests false, regardless of
    whether the hash is empty or hash elements). [ This paragraph needs review
    in light of changes in 5.25 ]</p>
<p class="Pp">Localizing tied arrays or hashes does not work. After exiting the
    scope the arrays or the hashes are not restored.</p>
<p class="Pp">Counting the number of entries in a hash via
    <span class="Li">&quot;scalar(keys(%hash))&quot;</span> or
    <span class="Li">&quot;scalar(values(%hash)&quot;</span>) is inefficient
    since it needs to iterate through all the entries with FIRSTKEY/NEXTKEY.</p>
<p class="Pp">Tied hash/array slices cause multiple FETCH/STORE pairs, there are
    no tie methods for slice operations.</p>
<p class="Pp">You cannot easily tie a multilevel data structure (such as a hash
    of hashes) to a dbm file. The first problem is that all but GDBM and
    Berkeley DB have size limitations, but beyond that, you also have problems
    with how references are to be represented on disk. One module that does
    attempt to address this need is DBM::Deep. Check your nearest CPAN site as
    described in perlmodlib for source code. Note that despite its name,
    DBM::Deep does not use dbm. Another earlier attempt at solving the problem
    is MLDBM, which is also available on the CPAN, but which has some fairly
    serious limitations.</p>
<p class="Pp">Tied filehandles are still incomplete. <b>sysopen()</b>,
    <b>truncate()</b>, <b>flock()</b>, <b>fcntl()</b>, <b>stat()</b> and -X
    can't currently be trapped.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Tom Christiansen</p>
<p class="Pp">TIEHANDLE by Sven Verdoolaege &lt;<i>skimo@dns.ufsia.ac.be</i>&gt;
    and Doug MacEachern &lt;<i>dougm@osf.org</i>&gt;</p>
<p class="Pp">UNTIE by Nick Ing-Simmons &lt;<i>nick@ing-simmons.net</i>&gt;</p>
<p class="Pp">SCALAR by Tassilo von Parseval
    &lt;<i>tassilo.von.parseval@rwth-aachen.de</i>&gt;</p>
<p class="Pp">Tying Arrays by Casey West &lt;<i>casey@geeknest.com</i>&gt;</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-21</td>
    <td class="foot-os">perl v5.30.3</td>
  </tr>
</table>
</body>
</html>

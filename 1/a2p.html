<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
 -->
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="../style.css" type="text/css" media="all"/>
  <title>A2P(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">A2P(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">A2P(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">a2p - Awk to Perl translator</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp"><b>a2p</b> [<i>options</i>] [<i>filename</i>]</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><i>A2p</i> takes an awk script specified on the command line (or
    from standard input) and produces a comparable <i>perl</i> script on the
    standard output.</p>
<section class="Ss">
<h2 class="Ss">OPTIONS</h2>
<p class="Pp">Options include:</p>
<dl class="Bl-tag">
  <dt id="D_number_"><a class="permalink" href="#D_number_"><b>-D&lt;number&gt;</b></a></dt>
  <dd>sets debugging flags.</dd>
  <dt id="F_character_"><a class="permalink" href="#F_character_"><b>-F&lt;character&gt;</b></a></dt>
  <dd>tells a2p that this awk script is always invoked with this <b>-F</b>
      switch.</dd>
  <dt id="n_fieldlist_"><a class="permalink" href="#n_fieldlist_"><b>-n&lt;fieldlist&gt;</b></a></dt>
  <dd>specifies the names of the input fields if input does not have to be split
      into an array. If you were translating an awk script that processes the
      password file, you might say:
    <p class="Pp"></p>
    <pre>
        a2p -7 -nlogin.password.uid.gid.gcos.shell.home
    </pre>
    <p class="Pp">Any delimiter can be used to separate the field names.</p>
  </dd>
  <dt><b>-&lt;number&gt;</b></dt>
  <dd>causes a2p to assume that input will always have that many fields.</dd>
  <dt id="o"><a class="permalink" href="#o"><b>-o</b></a></dt>
  <dd>tells a2p to use old awk behavior. The only current differences are:</dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>Old awk always has a line loop, even if there are no line actions, whereas
      new awk does not.</li>
  <li>In old awk, sprintf is extremely greedy about its arguments. For example,
      given the statement
    <p class="Pp"></p>
    <pre>
        print sprintf(some_args), extra_args;
    </pre>
    <p class="Pp">old awk considers <i>extra_args</i> to be arguments to
        <span class="Li">&quot;sprintf&quot;</span>; new awk considers them
        arguments to <span class="Li">&quot;print&quot;</span>.</p>
  </li>
</ul>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Ss">
<h2 class="Ss" id="_Considerations_"><a class="permalink" href="#_Considerations_">&quot;Considerations&quot;</a></h2>
<p class="Pp">A2p cannot do as good a job translating as a human would, but it
    usually does pretty well. There are some areas where you may want to examine
    the perl script produced and tweak it some. Here are some of them, in no
    particular order.</p>
<p class="Pp">There is an awk idiom of putting <i>int()</i> around a string
    expression to force numeric interpretation, even though the argument is
    always integer anyway. This is generally unneeded in perl, but a2p can't
    tell if the argument is always going to be integer, so it leaves it in. You
    may wish to remove it.</p>
<p class="Pp">Perl differentiates numeric comparison from string comparison. Awk
    has one operator for both that decides at run time which comparison to do.
    A2p does not try to do a complete job of awk emulation at this point.
    Instead it guesses which one you want. It's almost always right, but it can
    be spoofed. All such guesses are marked with the comment
    &quot;<span class="Li">&quot;#???&quot;</span>&quot;. You should go through
    and check them. You might want to run at least once with the <b>-w</b>
    switch to perl, which will warn you if you use == where you should have used
    eq.</p>
<p class="Pp">Perl does not attempt to emulate the behavior of awk in which
    nonexistent array elements spring into existence simply by being referenced.
    If somehow you are relying on this mechanism to create null entries for a
    subsequent for...in, they won't be there in perl.</p>
<p class="Pp">If a2p makes a split line that assigns to a list of variables that
    looks like (Fld1, Fld2, Fld3...) you may want to rerun a2p using the
    <b>-n</b> option mentioned above. This will let you name the fields
    throughout the script. If it splits to an array instead, the script is
    probably referring to the number of fields somewhere.</p>
<p class="Pp">The exit statement in awk doesn't necessarily exit; it goes to the
    END block if there is one. Awk scripts that do contortions within the END
    block to bypass the block under such circumstances can be simplified by
    removing the conditional in the END block and just exiting directly from the
    perl script.</p>
<p class="Pp">Perl has two kinds of array, numerically-indexed and associative.
    Perl associative arrays are called &quot;hashes&quot;. Awk arrays are
    usually translated to hashes, but if you happen to know that the index is
    always going to be numeric you could change the {...} to [...]. Iteration
    over a hash is done using the <i>keys()</i> function, but iteration over an
    array is NOT. You might need to modify any loop that iterates over such an
    array.</p>
<p class="Pp">Awk starts by assuming OFMT has the value %.6g. Perl starts by
    assuming its equivalent, $#, to have the value %.20g. You'll want to set $#
    explicitly if you use the default value of OFMT.</p>
<p class="Pp">Near the top of the line loop will be the split operation that is
    implicit in the awk script. There are times when you can move this down past
    some conditionals that test the entire record so that the split is not done
    as often.</p>
<p class="Pp">For aesthetic reasons you may wish to change index variables from
    being 1-based (awk style) to 0-based (Perl style). Be sure to change all
    operations the variable is involved in to match.</p>
<p class="Pp">Cute comments that say &quot;# Here is a workaround because awk is
    dumb&quot; are passed through unmodified.</p>
<p class="Pp">Awk scripts are often embedded in a shell script that pipes stuff
    into and out of awk. Often the shell script wrapper can be incorporated into
    the perl script, since perl can start up pipes into and out of itself, and
    can do other things that awk can't do by itself.</p>
<p class="Pp">Scripts that refer to the special variables RSTART and RLENGTH can
    often be simplified by referring to the variables $`, $&amp; and $', as long
    as they are within the scope of the pattern match that sets them.</p>
<p class="Pp">The produced perl script may have subroutines defined to deal with
    awk's semantics regarding getline and print. Since a2p usually picks
    correctness over efficiency. it is almost always possible to rewrite such
    code to be more efficient by discarding the semantic sugar.</p>
<p class="Pp">For efficiency, you may wish to remove the keyword from any return
    statement that is the last statement executed in a subroutine. A2p catches
    the most common case, but doesn't analyze embedded blocks for subtler
  cases.</p>
<p class="Pp">ARGV[0] translates to <span class="Li">$ARGV0</span>, but ARGV[n]
    translates to <span class="Li">$ARGV</span>[$n-1]. A loop that tries to
    iterate over ARGV[0] won't find it.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ENVIRONMENT"><a class="permalink" href="#ENVIRONMENT">ENVIRONMENT</a></h1>
<p class="Pp">A2p uses no environment variables.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<p class="Pp">Larry Wall &lt;<i>larry@wall.org</i>&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FILES"><a class="permalink" href="#FILES">FILES</a></h1>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<pre>
 perl   The perl compiler/interpreter

 s2p    sed to perl translator
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DIAGNOSTICS"><a class="permalink" href="#DIAGNOSTICS">DIAGNOSTICS</a></h1>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">It would be possible to emulate awk's behavior in selecting string
    versus numeric operations at run time by inspection of the operands, but it
    would be gross and inefficient. Besides, a2p almost always guesses
  right.</p>
<p class="Pp">Storage for the awk syntax tree is currently static, and can run
    out.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
